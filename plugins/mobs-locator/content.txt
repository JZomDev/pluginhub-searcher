package com.mobslocator;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import java.awt.Color;

@ConfigGroup("mobslocator")
public interface MobsLocatorConfig extends Config
{
    @ConfigSection(
            name = "Search",
            description = "Mob search settings",
            position = 0
    )
    String searchSection = "search";

    @ConfigSection(
            name = "Display",
            description = "Display settings",
            position = 1
    )
    String displaySection = "display";

    @ConfigItem(
            keyName = "searchedMob",
            name = "Search for Mob",
            description = "Enter the name of the mob you want to locate, then click the game screen to activate",
            section = searchSection,
            position = 0
    )
    default String searchedMob()
    {
        return "";
    }


    @ConfigItem(
            keyName = "showSearchResults",
            name = "Show Search Results",
            description = "Display search results in overlay",
            section = searchSection,
            position = 1
    )
    default boolean showSearchResults()
    {
        return true;
    }

    @ConfigItem(
            keyName = "hullColor",
            name = "Hull Highlight Color",
            description = "Color of the outline around searched mobs",
            section = displaySection,
            position = 0
    )
    default Color hullColor()
    {
        return new Color(255, 0, 255); // Hot pink default
    }

    @ConfigItem(
            keyName = "minimapDotColor",
            name = "Minimap Dot Color",
            description = "Color of minimap location dots",
            section = displaySection,
            position = 1
    )
    default Color minimapDotColor()
    {
        return new Color(255, 0, 255); // Hot pink default
    }

    @ConfigItem(
            keyName = "showMinimapDots",
            name = "Show Minimap Dots",
            description = "Show mob locations on minimap",
            section = displaySection,
            position = 2
    )
    default boolean showMinimapDots()
    {
        return true;
    }






    @ConfigItem(
            keyName = "backgroundColor",
            name = "Panel Background Color",
            description = "Background color of the overlay panels (the boxes showing mob locations)",
            section = displaySection,
            position = 6
    )
    default Color backgroundColor()
    {
        return new Color(0, 0, 0, 15);  // More transparent (was 100)
    }
}

package com.mobslocator;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.api.Perspective;

public class MobsLocatorMinimapOverlay extends Overlay
{
    private final Client client;
    private final MobsLocatorPlugin plugin;
    private final MobsLocatorConfig config;

    @Inject
    public MobsLocatorMinimapOverlay(Client client, MobsLocatorPlugin plugin, MobsLocatorConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.showMinimapDots())
        {
            return null;
        }

        String searchedMob = config.searchedMob().trim().toLowerCase();
        if (searchedMob.isEmpty())
        {
            return null;
        }

        // Hot pink color (255, 0, 255)
        // Use configured minimap dot color
        Color dotColor = config.minimapDotColor();

        // Draw dots for searched mobs
        for (NPC npc : plugin.getSearchedMobs())
        {
            if (npc == null || npc.getWorldLocation() == null)
            {
                continue;
            }

            LocalPoint localPoint = LocalPoint.fromWorld(client, npc.getWorldLocation());
            if (localPoint == null)
            {
                continue;
            }

            Point minimapPoint = Perspective.localToMinimap(client, localPoint);
            if (minimapPoint == null)
            {
                continue;
            }

            // Draw a hot pink dot on the minimap
            // Draw dot on the minimap
            graphics.setColor(dotColor);
            graphics.fillOval(minimapPoint.getX() - 2, minimapPoint.getY() - 2, 4, 4);

            // Draw a black border around the dot
            graphics.setColor(Color.BLACK);
            graphics.drawOval(minimapPoint.getX() - 2, minimapPoint.getY() - 2, 4, 4);
        }

        return null;
    }
}
package com.mobslocator;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.api.widgets.Widget;

public class MobsLocatorOverlay extends Overlay
{
    private final Client client;
    private final MobsLocatorPlugin plugin;
    private final MobsLocatorConfig config;
    private final PanelComponent leftPanel = new PanelComponent();
    private final PanelComponent rightPanel = new PanelComponent();

    @Inject
    public MobsLocatorOverlay(Client client, MobsLocatorPlugin plugin, MobsLocatorConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);

        // Make panels transparent so we can draw our own background
        leftPanel.setBackgroundColor(null);
        rightPanel.setBackgroundColor(null);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null)
        {
            return null;
        }

        plugin.hasSearchTermChanged();

        //Widget worldMap = client.getWidget(ComponentID.WORLD_MAP_VIEW);
        Widget worldMap = client.getWidget(595, 25);  // World map widget
        if (worldMap != null && !worldMap.isHidden())
        {
            return null;
        }

        renderMobHighlights(graphics);

        String searchedMob = config.searchedMob().trim();

        if (!searchedMob.isEmpty() && config.showSearchResults())
        {
            renderSideBySidePanels(graphics, localPlayer.getWorldLocation(), searchedMob);
        }

        return null;
    }

    private void renderSideBySidePanels(Graphics2D graphics, WorldPoint playerLocation, String searchedMob)
    {
        leftPanel.getChildren().clear();
        leftPanel.setPreferredSize(new Dimension(250, 0));

        rightPanel.getChildren().clear();
        rightPanel.setPreferredSize(new Dimension(90, 0));

        List<MobSpawnData.SpawnLocation> knownSpawns = MobSpawnData.getSpawnLocations(searchedMob.toLowerCase(), plugin.getGson());

        leftPanel.getChildren().add(TitleComponent.builder()
                .text("All Locations")
                .color(Color.CYAN)
                .build());

        if (!knownSpawns.isEmpty())
        {
            knownSpawns.stream()
                    .sorted((a, b) -> Integer.compare(
                            playerLocation.distanceTo(a.getApproximateCenter()),
                            playerLocation.distanceTo(b.getApproximateCenter())
                    ))
                    .forEach(spawn -> {
                        String membersTag = spawn.isMembers() ? " [M]" : " [F2P]";
                        String locationInfo = String.format("- %s (%d spawns)",
                                spawn.getAreaName(),
                                spawn.getCount());

                        Color tagColor = spawn.isMembers() ? new Color(255, 215, 0) : new Color(192, 192, 192);

                        leftPanel.getChildren().add(LineComponent.builder()
                                .left(locationInfo)
                                .leftColor(Color.WHITE)
                                .right(membersTag)
                                .rightColor(tagColor)
                                .build());
                    });
        }
        else
        {
            leftPanel.getChildren().add(LineComponent.builder()
                    .left("No data available")
                    .leftColor(Color.GRAY)
                    .build());
        }

        rightPanel.getChildren().add(TitleComponent.builder()
                .text("Nearby")
                .color(Color.CYAN)
                .build());

        List<NPC> nearbyMobs = plugin.getSearchedMobs();

        if (!nearbyMobs.isEmpty())
        {
            nearbyMobs.stream()
                    .filter(npc -> npc.getWorldLocation() != null)
                    .sorted((a, b) -> Integer.compare(
                            playerLocation.distanceTo(a.getWorldLocation()),
                            playerLocation.distanceTo(b.getWorldLocation())
                    ))
                    .limit(10)
                    .forEach(npc -> {
                        int distance = playerLocation.distanceTo(npc.getWorldLocation());
                        String locationInfo = String.format("%d tiles away", distance);
                        Color textColor = distance <= 10 ? Color.GREEN :
                                distance <= 25 ? Color.YELLOW : Color.WHITE;

                        rightPanel.getChildren().add(LineComponent.builder()
                                .left(locationInfo)
                                .leftColor(textColor)
                                .build());
                    });
        }
        else
        {
            rightPanel.getChildren().add(LineComponent.builder()
                    .left("None nearby")
                    .leftColor(Color.GRAY)
                    .build());
        }

        // Render panels with transparent backgrounds
        renderPanelWithTransparentBackground(graphics, leftPanel, 0, 0);
        renderPanelWithTransparentBackground(graphics, rightPanel, 260, 0);
    }

    private void renderPanelWithTransparentBackground(Graphics2D graphics, PanelComponent panel, int xOffset, int yOffset)
    {
        graphics.translate(xOffset, yOffset);

        // Render panel to get its size
        Dimension panelSize = panel.render(graphics);

        // Reset position to draw background behind
        graphics.translate(-xOffset, -yOffset);

        // Draw transparent background
        Color bgColor = config.backgroundColor();
        graphics.setColor(new Color(bgColor.getRed(), bgColor.getGreen(), bgColor.getBlue(), 100));
        graphics.fillRect(xOffset, yOffset, panelSize.width, panelSize.height);

        // Render panel content on top
        graphics.translate(xOffset, yOffset);
        panel.render(graphics);
        graphics.translate(-xOffset, -yOffset);
    }

    private void renderMobHighlights(Graphics2D graphics)
    {
        String searchedMob = config.searchedMob().trim().toLowerCase();
        if (searchedMob.isEmpty())
        {
            return;
        }

        Color hullColor = config.hullColor();
        int canvasWidth = client.getCanvasWidth();
        int canvasHeight = client.getCanvasHeight();

        int leftMargin = 0;
        int rightMargin = (int)(canvasWidth * 0.82);
        int topMargin = (int)(canvasHeight * 0.05);
        int bottomMargin = (int)(canvasHeight * 0.72);

        for (NPC npc : plugin.getSearchedMobs())
        {
            if (npc == null)
            {
                continue;
            }

            java.awt.Shape hull = npc.getConvexHull();

            if (hull == null)
            {
                continue;
            }

            java.awt.Rectangle bounds = hull.getBounds();

            if (bounds.x < leftMargin ||
                    bounds.x + bounds.width > rightMargin ||
                    bounds.y < topMargin ||
                    bounds.y + bounds.height > bottomMargin)
            {
                continue;
            }

            graphics.setColor(new Color(hullColor.getRed(), hullColor.getGreen(), hullColor.getBlue(), 180));
            graphics.setStroke(new java.awt.BasicStroke(2));
            graphics.draw(hull);

            graphics.setColor(new Color(hullColor.getRed(), hullColor.getGreen(), hullColor.getBlue(), 50));
            graphics.fill(hull);
        }
    }
}

package com.mobslocator;

import com.google.inject.Provides;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.NpcDespawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import java.util.*;
import java.util.stream.Collectors;

@PluginDescriptor(
        name = "Mobs Locator",
        description = "Locate and track mobs around you with search functionality",
        tags = {"mobs", "npc", "locate", "monsters", "search"}
)
public class MobsLocatorPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private MobsLocatorConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private MobsLocatorOverlay overlay;

    @Inject
    private MobsLocatorMinimapOverlay minimapOverlay;

    @Inject
        private MobsLocatorWorldMapOverlay worldMapOverlay;

     @Inject
        private com.google.gson.Gson gson;

        
    private final Set<NPC> trackedNPCs = new HashSet<>();
    private final Map<String, List<NPC>> mobsByName = new HashMap<>();
    private final Map<String, Map<WorldPoint, Integer>> mobLocationCounts = new HashMap<>();
    private String lastSearchedMob = "";

    @Override
    protected void startUp() throws Exception
    {
        overlayManager.add(overlay);
        overlayManager.add(minimapOverlay);
        overlayManager.add(worldMapOverlay);
    }

    @Override
    protected void shutDown() throws Exception
    {
        overlayManager.remove(overlay);
        overlayManager.remove(minimapOverlay);
        overlayManager.remove(worldMapOverlay);
        trackedNPCs.clear();
        mobsByName.clear();
        mobLocationCounts.clear();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
        {
            trackedNPCs.clear();
            mobsByName.clear();
            mobLocationCounts.clear();
        }
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned npcSpawned)
    {
        NPC npc = npcSpawned.getNpc();
        if (npc != null && shouldTrackNPC(npc))
        {
            trackedNPCs.add(npc);
            updateMobMaps(npc, true);
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned npcDespawned)
    {
        NPC npc = npcDespawned.getNpc();
        if (trackedNPCs.remove(npc))
        {
            updateMobMaps(npc, false);
        }
    }

    private void updateMobMaps(NPC npc, boolean add)
    {
        String mobName = npc.getName();
        if (mobName == null) return;

        // Update mobsByName map
        if (add)
        {
            mobsByName.computeIfAbsent(mobName, k -> new ArrayList<>()).add(npc);
        }
        else
        {
            List<NPC> npcs = mobsByName.get(mobName);
            if (npcs != null)
            {
                npcs.remove(npc);
                if (npcs.isEmpty())
                {
                    mobsByName.remove(mobName);
                }
            }
        }

        // Update location counts
        WorldPoint location = npc.getWorldLocation();
        if (location != null)
        {
            Map<WorldPoint, Integer> locationCounts = mobLocationCounts.computeIfAbsent(mobName, k -> new HashMap<>());

            if (add)
            {
                locationCounts.put(location, locationCounts.getOrDefault(location, 0) + 1);
            }
            else
            {
                int count = locationCounts.getOrDefault(location, 0);
                if (count <= 1)
                {
                    locationCounts.remove(location);
                }
                else
                {
                    locationCounts.put(location, count - 1);
                }
            }

            if (locationCounts.isEmpty())
            {
                mobLocationCounts.remove(mobName);
            }
        }
    }

    private boolean shouldTrackNPC(NPC npc)
    {
        if (npc.getName() == null)
        {
            return false;
        }

        // Always track searched mob
        String searchedMob = config.searchedMob().trim().toLowerCase();
        if (!searchedMob.isEmpty() && npc.getName().toLowerCase().contains(searchedMob))
        {
            return true;
        }

        // Don't track other mobs unless searching
        return false;
    }

    public Set<NPC> getTrackedNPCs()
    {
        return trackedNPCs;
    }

    public List<String> getAvailableMobNames()
    {
        return trackedNPCs.stream()
                .map(NPC::getName)
                .filter(Objects::nonNull)
                .distinct()
                .sorted()
                .collect(Collectors.toList());
    }

    public List<NPC> getSearchedMobs()
    {
        String searchedMob = config.searchedMob().trim().toLowerCase();
        if (searchedMob.isEmpty())
        {
            return Collections.emptyList();
        }

        return trackedNPCs.stream()
                .filter(npc -> npc.getName() != null &&
                        npc.getName().toLowerCase().contains(searchedMob))
                .collect(Collectors.toList());
    }

    public Map<WorldPoint, Integer> getSearchedMobLocations()
    {
        String searchedMob = config.searchedMob().trim().toLowerCase();
        if (searchedMob.isEmpty())
        {
            return Collections.emptyMap();
        }

        Map<WorldPoint, Integer> allLocations = new HashMap<>();

        for (Map.Entry<String, Map<WorldPoint, Integer>> entry : mobLocationCounts.entrySet())
        {
            if (entry.getKey().toLowerCase().contains(searchedMob))
            {
                for (Map.Entry<WorldPoint, Integer> locationEntry : entry.getValue().entrySet())
                {
                    allLocations.merge(locationEntry.getKey(), locationEntry.getValue(), Integer::sum);
                }
            }
        }

        return allLocations;
    }

    public boolean hasSearchTermChanged()
    {
        String currentSearch = config.searchedMob().trim().toLowerCase();
        if (!currentSearch.equals(lastSearchedMob))
        {
            lastSearchedMob = currentSearch;
            // Clear and re-scan NPCs when search term changes
            trackedNPCs.clear();
            mobsByName.clear();
            mobLocationCounts.clear();

            // Re-scan all visible NPCs
            for (NPC npc : client.getNpcs())
            {
                if (npc != null && shouldTrackNPC(npc))
                {
                    trackedNPCs.add(npc);
                    updateMobMaps(npc, true);
                }
            }
            return true;
        }
        return false;
    }

    @Provides
    MobsLocatorConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(MobsLocatorConfig.class);
    }

    public com.google.gson.Gson getGson()
    {
        return gson;
    }
}

package com.mobslocator;

import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.worldmap.WorldMapOverlay;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.geom.Rectangle2D;
import java.util.List;

public class MobsLocatorWorldMapOverlay extends Overlay
{
    private final MobsLocatorConfig config;
    private final WorldMapOverlay worldMapOverlay;
    private final MobsLocatorPlugin plugin;  // ADD THIS LINE
    
    @Inject
    public MobsLocatorWorldMapOverlay(MobsLocatorConfig config, WorldMapOverlay worldMapOverlay, MobsLocatorPlugin plugin)  // ADD plugin parameter
    {
        this.config = config;
        this.worldMapOverlay = worldMapOverlay;
        this.plugin = plugin;  // ADD THIS LINE
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        String searchedMob = config.searchedMob().trim().toLowerCase();
        if (searchedMob.isEmpty())
        {
            return null;
        }

        List<MobSpawnData.SpawnLocation> spawnLocations = MobSpawnData.getSpawnLocations(searchedMob, plugin.getGson());
        if (spawnLocations.isEmpty())
        {
            return null;
        }

        Color hotPink = new Color(255, 0, 255);

        int screenWidth = graphics.getClipBounds().width;
        int screenHeight = graphics.getClipBounds().height;
        int leftMargin = 250;
        int rightMargin = screenWidth - 50;
        int topMargin = 50;
        int bottomMargin = screenHeight - 50;

        for (MobSpawnData.SpawnLocation spawn : spawnLocations)
        {
            WorldPoint worldPoint = spawn.getApproximateCenter();
            Point mapPoint = worldMapOverlay.mapWorldPointToGraphicsPoint(worldPoint);

            if (mapPoint == null)
            {
                continue;
            }

            int x = mapPoint.getX();
            int y = mapPoint.getY();

            boolean isOnScreen = x >= leftMargin && x <= rightMargin &&
                    y >= topMargin && y <= bottomMargin;

            if (isOnScreen)
            {
                int starSize = 12;
                drawStar(graphics, x, y, starSize, hotPink);

                String label = spawn.getAreaName() + " (" + spawn.getCount() + ")";
                graphics.setFont(graphics.getFont().deriveFont(java.awt.Font.BOLD, 16f));
                FontMetrics fm = graphics.getFontMetrics();
                Rectangle2D bounds = fm.getStringBounds(label, graphics);

                int textX = x - (int) bounds.getWidth() / 2;
                int textY = y + starSize + fm.getAscent() + 5;

                if (textX >= leftMargin && textX + bounds.getWidth() <= rightMargin)
                {
                    graphics.setColor(new Color(0, 0, 0, 220));
                    graphics.fillRect(textX - 5, textY - fm.getAscent() - 2, (int) bounds.getWidth() + 10, fm.getHeight() + 4);

                    graphics.setColor(Color.BLACK);
                    graphics.drawRect(textX - 5, textY - fm.getAscent() - 2, (int) bounds.getWidth() + 10, fm.getHeight() + 4);

                    graphics.setColor(hotPink);
                    graphics.drawString(label, textX, textY);
                }
            }
            else
            {
                drawDirectionalArrow(graphics, x, y, leftMargin, rightMargin, topMargin, bottomMargin, hotPink);
            }
        }

        return null;
    }

    private void drawDirectionalArrow(Graphics2D graphics, int targetX, int targetY,
                                      int leftMargin, int rightMargin, int topMargin, int bottomMargin,
                                      Color color)
    {
        int centerX = (leftMargin + rightMargin) / 2;
        int centerY = (topMargin + bottomMargin) / 2;

        double dx = targetX - centerX;
        double dy = targetY - centerY;
        double angle = Math.atan2(dy, dx);

        int arrowX, arrowY;

        double slope = dy / dx;

        if (Math.abs(dx) > Math.abs(dy))
        {
            if (targetX < leftMargin)
            {
                arrowX = leftMargin + 30;
                arrowY = (int) (centerY + (arrowX - centerX) * slope);
            }
            else
            {
                arrowX = rightMargin - 30;
                arrowY = (int) (centerY + (arrowX - centerX) * slope);
            }
            arrowY = Math.max(topMargin + 30, Math.min(bottomMargin - 30, arrowY));
        }
        else
        {
            if (targetY < topMargin)
            {
                arrowY = topMargin + 30;
                arrowX = (int) (centerX + (arrowY - centerY) / slope);
            }
            else
            {
                arrowY = bottomMargin - 30;
                arrowX = (int) (centerX + (arrowY - centerY) / slope);
            }
            arrowX = Math.max(leftMargin + 30, Math.min(rightMargin - 30, arrowX));
        }

        drawArrow(graphics, arrowX, arrowY, angle, 20, color);
    }

    private void drawArrow(Graphics2D graphics, int x, int y, double angle, int size, Color color)
    {
        int[] xPoints = new int[3];
        int[] yPoints = new int[3];

        xPoints[0] = x + (int) (size * Math.cos(angle));
        yPoints[0] = y + (int) (size * Math.sin(angle));

        xPoints[1] = x + (int) (size * 0.4 * Math.cos(angle + 2.5));
        yPoints[1] = y + (int) (size * 0.4 * Math.sin(angle + 2.5));

        xPoints[2] = x + (int) (size * 0.4 * Math.cos(angle - 2.5));
        yPoints[2] = y + (int) (size * 0.4 * Math.sin(angle - 2.5));

        graphics.setColor(color);
        graphics.fillPolygon(xPoints, yPoints, 3);

        graphics.setColor(Color.BLACK);
        graphics.setStroke(new java.awt.BasicStroke(2));
        graphics.drawPolygon(xPoints, yPoints, 3);
    }

    // Helper method to draw a star
    private void drawStar(Graphics2D graphics, int centerX, int centerY, int size, Color color)
    {
        int[] xPoints = new int[10];
        int[] yPoints = new int[10];

        double angle = Math.PI / 2; // Start from top
        double angleStep = Math.PI / 5; // 10 points = 5 outer + 5 inner

        for (int i = 0; i < 10; i++)
        {
            double radius = (i % 2 == 0) ? size : size * 0.4; // Outer and inner points
            xPoints[i] = centerX + (int) (radius * Math.cos(angle));
            yPoints[i] = centerY - (int) (radius * Math.sin(angle));
            angle += angleStep;
        }

        // Fill star
        graphics.setColor(color);
        graphics.fillPolygon(xPoints, yPoints, 10);

        // Draw black outline
        graphics.setColor(Color.BLACK);
        graphics.drawPolygon(xPoints, yPoints, 10);
    }
}

package com.mobslocator;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import net.runelite.api.coords.WorldPoint;
import lombok.extern.slf4j.Slf4j;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
public class MobSpawnData
{
    private static final Map<String, List<SpawnLocation>> MOB_SPAWNS = new HashMap<>();
    private static final List<Region> REGIONS = new ArrayList<>();
    private static final int CLUSTER_DISTANCE = 50;
    private static boolean initialized = false;
    private static Gson gson;

    public static synchronized void initialize(Gson gsonInstance)
    {
        if (initialized)
        {
            return;
        }

        gson = gsonInstance;
        loadRegions();
        loadSpawnData();
        initialized = true;
    }

    private static void loadRegions()
    {
        loadRegionsFromFile("/surface_areas.json");
        loadRegionsFromFile("/regions.json");
        REGIONS.sort((a, b) -> Integer.compare(a.getArea(), b.getArea()));
        log.info("Loaded {} region definitions", REGIONS.size());
    }

    private static void loadRegionsFromFile(String filename)
    {
        try
        {
            InputStream inputStream = MobSpawnData.class.getResourceAsStream(filename);
            if (inputStream == null)
            {
                log.error("Could not find {} resource", filename);
                return;
            }
            JsonArray jsonArray = gson.fromJson(new InputStreamReader(inputStream), JsonArray.class);

            for (JsonElement element : jsonArray)
            {
                JsonObject obj = element.getAsJsonObject();
                
                if (!obj.has("name") || !obj.has("bounds"))
                {
                    continue;
                }

                String name = obj.get("name").getAsString();
                JsonArray boundsArray = obj.getAsJsonArray("bounds");
                
                if (boundsArray.size() != 2)
                {
                    continue;
                }

                JsonArray minBounds = boundsArray.get(0).getAsJsonArray();
                JsonArray maxBounds = boundsArray.get(1).getAsJsonArray();

                int minX = minBounds.get(0).getAsInt();
                int minY = minBounds.get(1).getAsInt();
                int maxX = maxBounds.get(0).getAsInt();
                int maxY = maxBounds.get(1).getAsInt();

                REGIONS.add(new Region(name, minX, minY, maxX, maxY));
            }
        }
        catch (Exception e)
        {
            log.error("Error loading {}", filename, e);
        }
    }

    private static void loadSpawnData()
    {
        try
        {
            InputStream inputStream = MobSpawnData.class.getResourceAsStream("/npc_spawns.json");
            if (inputStream == null)
            {
                log.error("Could not find npc_spawns.json resource");
                return;
            }
            JsonArray jsonArray = gson.fromJson(new InputStreamReader(inputStream), JsonArray.class);
            
            Map<String, List<NpcSpawn>> rawSpawnsByName = new HashMap<>();

            for (JsonElement element : jsonArray)
            {
                JsonObject obj = element.getAsJsonObject();
                
                if (!obj.has("name") || !obj.has("x") || !obj.has("y") || !obj.has("p"))
                {
                    continue;
                }

                String name = obj.get("name").getAsString();

                int x = obj.get("x").getAsInt();
                int y = obj.get("y").getAsInt();
                int plane = obj.get("p").getAsInt();

                WorldPoint worldPoint = new WorldPoint(x, y, plane);
                
                rawSpawnsByName.computeIfAbsent(name.toLowerCase(), k -> new ArrayList<>())
                    .add(new NpcSpawn(worldPoint, name));
            }

            for (Map.Entry<String, List<NpcSpawn>> entry : rawSpawnsByName.entrySet())
            {
                String mobName = entry.getKey();
                List<NpcSpawn> spawns = entry.getValue();
                
                List<SpawnLocation> clusterLocations = clusterSpawns(spawns);
                MOB_SPAWNS.put(mobName, clusterLocations);
            }

            log.info("Loaded spawn data for {} different mobs", MOB_SPAWNS.size());
        }
        catch (Exception e)
        {
            log.error("Error loading NPC spawn data", e);
        }
    }

    private static List<SpawnLocation> clusterSpawns(List<NpcSpawn> spawns)
    {
        List<SpawnCluster> clusters = new ArrayList<>();

        for (NpcSpawn spawn : spawns)
        {
            boolean addedToCluster = false;

            for (SpawnCluster cluster : clusters)
            {
                if (cluster.isNearby(spawn.worldPoint, CLUSTER_DISTANCE))
                {
                    cluster.add(spawn);
                    addedToCluster = true;
                    break;
                }
            }

            if (!addedToCluster)
            {
                SpawnCluster newCluster = new SpawnCluster();
                newCluster.add(spawn);
                clusters.add(newCluster);
            }
        }

        return clusters.stream()
            .map(cluster -> new SpawnLocation(
                getAreaName(cluster.getCenter()),
                cluster.getCount(),
                cluster.getCenter(),
                isMembersArea(cluster.getCenter())
            ))
            .collect(Collectors.toList());
    }

    private static String getAreaName(WorldPoint point)
    {
        for (Region region : REGIONS)
        {
            if (region.contains(point))
            {
                if (region.name.equals("Gielinor Surface"))
                {
                    return getNearestSurfaceArea(point);
                }
                return region.name;
            }
        }

        return String.format("Unknown Area (%d, %d)", point.getX(), point.getY());
    }

    private static String getNearestSurfaceArea(WorldPoint point)
    {
        Region nearestRegion = null;
        int minDistance = Integer.MAX_VALUE;

        for (Region region : REGIONS)
        {
            if (region.name.equals("Gielinor Surface") || 
                region.name.contains("Dungeon") || 
                region.name.contains("Cave") || 
                region.name.contains("Underground"))
            {
                continue;
            }

            WorldPoint regionCenter = region.getCenter();
            int distance = point.distanceTo(regionCenter);

            if (distance < minDistance)
            {
                minDistance = distance;
                nearestRegion = region;
            }
        }

        if (nearestRegion != null)
        {
            return nearestRegion.name;
        }

        return "Gielinor Surface";
    }

    private static boolean isMembersArea(WorldPoint point)
    {
        int x = point.getX();
        int y = point.getY();

        if (x >= 2944 && x <= 3392 && y >= 3136 && y <= 3712 && point.getPlane() == 0)
        {
            return false;
        }

        return true;
    }

    public static List<SpawnLocation> getSpawnLocations(String mobName, Gson gsonInstance)
    {
        if (!initialized)
        {
            initialize(gsonInstance);
        }
        
        String searchTerm = mobName.toLowerCase().trim();
        log.debug("Searching for: '{}'", searchTerm);
        
        if (MOB_SPAWNS.containsKey(searchTerm))
        {
            log.debug("Found exact match for: {}", searchTerm);
            return MOB_SPAWNS.get(searchTerm);
        }
        
        List<SpawnLocation> matchingSpawns = new ArrayList<>();
        for (Map.Entry<String, List<SpawnLocation>> entry : MOB_SPAWNS.entrySet())
        {
            if (entry.getKey().contains(searchTerm))
            {
                log.debug("Found partial match: {}", entry.getKey());
                matchingSpawns.addAll(entry.getValue());
            }
        }
        
        log.debug("Total matches found: {}", matchingSpawns.size());
        return matchingSpawns;
    }

   

    private static class Region
    {
        final String name;
        final int minX;
        final int minY;
        final int maxX;
        final int maxY;

        Region(String name, int minX, int minY, int maxX, int maxY)
        {
            this.name = name;
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        }

        boolean contains(WorldPoint point)
        {
            int x = point.getX();
            int y = point.getY();
            return x >= minX && x <= maxX && y >= minY && y <= maxY;
        }

        int getArea()
        {
            return (maxX - minX) * (maxY - minY);
        }

        WorldPoint getCenter()
        {
            int centerX = (minX + maxX) / 2;
            int centerY = (minY + maxY) / 2;
            return new WorldPoint(centerX, centerY, 0);
        }
    }

    private static class NpcSpawn
    {
        final WorldPoint worldPoint;
        final String name;

        NpcSpawn(WorldPoint worldPoint, String name)
        {
            this.worldPoint = worldPoint;
            this.name = name;
        }
    }

    private static class SpawnCluster
    {
        private final List<WorldPoint> points = new ArrayList<>();

        void add(NpcSpawn spawn)
        {
            points.add(spawn.worldPoint);
        }

        boolean isNearby(WorldPoint point, int maxDistance)
        {
            for (WorldPoint existing : points)
            {
                if (existing.distanceTo(point) <= maxDistance)
                {
                    return true;
                }
            }
            return false;
        }

        WorldPoint getCenter()
        {
            if (points.isEmpty())
            {
                return new WorldPoint(0, 0, 0);
            }

            int avgX = (int) points.stream().mapToInt(WorldPoint::getX).average().orElse(0);
            int avgY = (int) points.stream().mapToInt(WorldPoint::getY).average().orElse(0);
            int plane = points.get(0).getPlane();

            return new WorldPoint(avgX, avgY, plane);
        }

        int getCount()
        {
            return points.size();
        }
    }

    public static class SpawnLocation
    {
        private final String areaName;
        private final int count;
        private final WorldPoint approximateCenter;
        private final boolean members;

        public SpawnLocation(String areaName, int count, WorldPoint approximateCenter, boolean members)
        {
            this.areaName = areaName;
            this.count = count;
            this.approximateCenter = approximateCenter;
            this.members = members;
        }

        public String getAreaName() { return areaName; }
        public int getCount() { return count; }
        public WorldPoint getApproximateCenter() { return approximateCenter; }
        public boolean isMembers() { return members; }
    }
}

