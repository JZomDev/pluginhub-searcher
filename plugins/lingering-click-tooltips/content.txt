package ryanxie0.runelite.plugin.lingeringclicktooltips;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LingeringClickTooltipsTest
{
	public static void main(String[] args) throws Exception
	{
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Units;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Alpha;
import ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilterMode;

import java.awt.Color;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorConstants.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilteringConstants.*;

@ConfigGroup(LingeringClickTooltipsConfig.GROUP_NAME)
public interface LingeringClickTooltipsConfig extends Config
{
	String GROUP_NAME = "lingeringclicktooltips";
	String OVERLAY_PREFERRED_POSITION = "LingeringClickTooltipsOverlay_preferredPosition";
	String OVERLAY_PREFERRED_LOCATION = "LingeringClickTooltipsOverlay_preferredLocation";

	@ConfigSection(
		name = "Lifespan",
		description = "Modify lifespan of tooltips",
		position = 0
	)
	String lifespan = "lifespan";

	@ConfigSection(
		name = "Appearance",
		description = "Modify appearance of tooltips",
		position = 1
	)
	String appearance = "appearance";

	@ConfigSection(
		name = "Modes",
		description = "Convenient operating modes for tooltips",
		position = 2
	)
	String modes = "modes";

	@ConfigSection(
		name = "Filter lists",
		description = "Configure the filter mode behavior",
		position = 3,
		closedByDefault = true
	)
	String filterLists = "filterLists";

	@ConfigSection(
		name = "Location",
		description = "Modify location of tooltips",
		position = 4,
		closedByDefault = true
	)
	String location = "location";

	@ConfigSection(
		name = "Hotkeys",
		description = "Configure hotkey functionality",
		position = 5,
		closedByDefault = true
	)
	String hotkeys = "hotkeys";

	@ConfigSection(
		name = "Trivial clicks",
		description = "Declare which clicks are considered trivial",
		position = 6,
		closedByDefault = true
	)
	String trivialClicks = "trivialClicks";

	@ConfigItem(
		keyName = "tooltipDuration",
		name = "Tooltip duration",
		description = "The duration for which tooltips will render at max opacity",
		position = 0,
		section = lifespan
	)
	@Units(Units.MILLISECONDS)
	@Range(min = 1, max = 5000)
	default int tooltipDuration() { return 600;}

	@ConfigItem(
		keyName = "tooltipFadeIn",
		name = "Tooltip fade-in",
		description = "Adds a fade-in period equal to a percentage of tooltip duration, 0 to disable",
		position = 1,
		section = lifespan
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int tooltipFadeIn() { return 20; }

	@ConfigItem(
		keyName = "tooltipFadeout",
		name = "Tooltip fadeout",
		description = "Adds a fadeout period equal to a percentage of tooltip duration, 0 to disable",
		position = 2,
		section = lifespan
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int tooltipFadeout() { return 40; }

	@ConfigItem(
		keyName = "maximumTooltipsShown",
		name = "Max tooltips shown",
		description = "The maximum number of tooltips shown at any given time",
		position = 3,
		section = lifespan
	)
	@Range(min = 1)
	default int maximumTooltipsShown() { return 1; }

	@ConfigItem(
		keyName = "permanentTooltips",
		name = "Permanent tooltips",
		description = "Choose whether to use tooltips that do not disappear",
		position = 4,
		section = lifespan
	)
	default boolean permanentTooltips() { return false; }

	@ConfigItem(
		keyName = USE_CUSTOM_TEXT_COLOR,
		name = "Use custom text color",
		description = "Choose whether to apply the text color below to non-info tooltips",
		position = 0,
		section = appearance
	)
	default boolean useCustomTextColor() { return false; }

	@ConfigItem(
		keyName = CUSTOM_TEXT_COLOR,
		name = "Text color",
		description = "Applied to non-info tooltips only",
		position = 1,
		section = appearance
	)
	default Color customTextColor() { return Color.WHITE; }

	@ConfigItem(
		keyName = USE_CUSTOM_BACKGROUND_COLOR,
		name = "Use custom background color",
		description = "Choose whether to apply the background color below to non-info tooltips",
		position = 2,
		section = appearance
	)
	default boolean useCustomBackgroundColor() { return false; }

	@Alpha
	@ConfigItem(
		keyName = CUSTOM_BACKGROUND_COLOR,
		name = "Background color",
		description = "Applied to non-info tooltips only",
		position = 3,
		section = appearance
	)
	default Color customBackgroundColor() { return Color.BLACK; }

	@ConfigItem(
		keyName = "overrideMenuColors",
		name = "Override menu colors",
		description = "Choose whether the custom text color, if enabled, should override menu colors",
		position = 4,
		section = appearance
	)
	default boolean overrideMenuColors() { return false; }

	@ConfigItem(
		keyName = "maximumOpacity",
		name = "Max opacity",
		description = "The maximum opacity of tooltips",
		position = 5,
		section = appearance
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int maximumOpacity() { return 100; }

	@ConfigItem(
		keyName = "fastMode",
		name = "Fast mode",
		description = "Tooltip duration cut by half",
		position = 0,
		section = modes
	)
	default boolean fastMode() { return false; }

	@ConfigItem(
		keyName = "lightMode",
		name = "Light mode",
		description = "Max opacity reduced by 25% of its current value",
		position = 1,
		section = modes
	)
	default boolean lightMode() { return false; }

	@ConfigItem(
		keyName = "trackerMode",
		name = "Tracker mode",
		description = "Tooltips become permanent and follow the cursor, trivial clicks shown",
		position = 2,
		section = modes
	)
	default boolean trackerMode() { return false; }

	@ConfigItem(
		keyName = "tickSyncMode",
		name = "Tick sync mode",
		description = "Tooltips process at the next game tick instead of immediately",
		position = 3,
		section = modes
	)
	default boolean tickSyncMode() { return false; }

	@ConfigItem(
		keyName = "filterMode",
		name = "Filter mode",
		description = "Select the mode used for filtering tooltips based on user-managed lists",
		position = 4,
		section = modes
	)
	default LingeringClickTooltipsFilterMode filterMode() { return LingeringClickTooltipsFilterMode.NONE; }

	@ConfigItem(
		keyName = BLACKLIST_CSV,
		name = "Blacklist",
		description = "Tooltips matching text in this list will NOT show",
		position = 0,
		section = filterLists
	)
	default String blacklist() { return ""; }

	@ConfigItem(
		keyName = BLACKLIST_CSV,
		name = "",
		description = ""
	)
	void setBlacklist(String key);

	@ConfigItem(
		keyName = WHITELIST_CSV,
		name = "Whitelist",
		description = "Tooltips NOT matching text in this list will NOT show",
		position = 1,
		section = filterLists
	)
	default String whitelist() { return ""; }

	@ConfigItem(
		keyName = WHITELIST_CSV,
		name = "",
		description = ""
	)
	void setWhitelist(String key);

	@ConfigItem(
		keyName = "blockFilteredClicks",
		name = "Block filtered clicks",
		description = "Choose whether filtered clicks should be consumed, preventing native client processing",
		position = 2,
		section = filterLists
	)
	default boolean blockFilteredClicks() { return false; }

	@ConfigItem(
		keyName = "showBlockedClicks",
		name = "Show blocked clicks",
		description = "Choose whether tooltips appear for consumed clicks",
		position = 3,
		section = filterLists
	)
	default boolean showBlockedClicks() { return true; }

	@ConfigItem(
		keyName = LingeringClickTooltipsLocation.TOOLTIP_LOCATION_CONFIG_KEY,
		name = "Tooltip location",
		description = "Lingering remains at the click point, anchored follows the mouse cursor, fixed stays at a static location",
		position = 0,
		section = location
	)
	default LingeringClickTooltipsLocation tooltipLocation() { return LingeringClickTooltipsLocation.LINGERING; }

	@ConfigItem(
		keyName = "tooltipXOffset",
		name = "Tooltip x offset",
		description = "Horizontal offset for tooltips, lingering location only, higher values move the tooltip further right",
		position = 1,
		section = location
	)
	@Range(max = 100)
	default int tooltipXOffset() { return 0; }

	@ConfigItem(
		keyName = "tooltipYOffset",
		name = "Tooltip y offset",
		description = "Vertical offset for tooltips, lingering location only, positive values move the tooltip down",
		position = 2,
		section = location
	)
	@Range(min = -100, max = 100)
	default int tooltipYOffset() { return -20; }

	@ConfigItem(
		keyName = "clampXPadding",
		name = "Clamp x padding",
		description = "The minimum distance between tooltips and the left/right window borders, lingering location only, 0 means no gap",
		position = 3,
		section = location
	)
	@Range(max = 30)
	default int clampXPadding() { return 5; }

	@ConfigItem(
		keyName = "clampYPadding",
		name = "Clamp y padding",
		description = "The minimum distance between tooltips and the top/bottom window borders, lingering location only, 0 means no gap",
		position = 4,
		section = location
	)
	@Range(max = 30)
	default int clampYPadding() { return 5; }

	@ConfigItem(
		keyName = "ctrlDoubleTapDelay",
		name = "CTRL double-tap delay",
		description = "Double-tap delay for CTRL to toggle tooltips, 0 to disable",
		position = 0,
		section = hotkeys
	)
	@Units(Units.MILLISECONDS)
	@Range(max = 500)
	default int ctrlDoubleTapDelay() { return 300; }

	@ConfigItem(
		keyName = "ctrlTogglesHide",
		name = "CTRL toggles hide",
		description = "Choose whether holding CTRL shows tooltips normally",
		position = 1,
		section = hotkeys
	)
	default boolean ctrlTogglesHide() { return true; }

	@ConfigItem(
		keyName = "ctrlBypassesBlock",
		name = "CTRL bypasses block",
		description = "Choose whether holding CTRL will allow blocked clicks to process",
		position = 2,
		section = hotkeys
	)
	default boolean ctrlBypassesBlock() { return true; }

	@ConfigItem(
		keyName = "shiftDoubleTapDelay",
		name = "SHIFT double-tap delay",
		description = "Double-tap delay for SHIFT to blacklist/whitelist tooltips, must be holding CTRL, 0 to disable",
		position = 3,
		section = hotkeys
	)
	@Units(Units.MILLISECONDS)
	@Range(max = 500)
	default int shiftDoubleTapDelay() { return 350; }

	@ConfigItem(
		keyName = "shiftPeeks",
		name = "SHIFT peeks",
		description = "Choose whether holding SHIFT for more than SHIFT double-tap delay produces peek tooltips, must be holding CTRL",
		position = 4,
		section = hotkeys
	)
	default boolean shiftPeeks() { return true; }

	@ConfigItem(
		keyName = "shiftBlocks",
		name = "SHIFT blocks",
		description = "Choose whether clicks should be consumed while holding SHIFT, must have filter mode set to blacklist/whitelist",
		position = 5,
		section = hotkeys
	)
	default boolean shiftBlocks() { return true; }

	@ConfigItem(
		keyName = HIDE_TRIVIAL_CLICKS,
		name = "Hide trivial clicks",
		description = "Choose whether to hide trivial clicks such as walk",
		position = 0,
		section = trivialClicks
	)
	default boolean hideTrivialClicks() { return true; }

	@ConfigItem(
		keyName = HIDE_WALK_HERE,
		name = "Walk here",
		description = "Choose whether walk should be hidden",
		position = 1,
		section = trivialClicks
	)
	default boolean hideWalkHere() { return true; }

	@ConfigItem(
		keyName = HIDE_WALK_HERE_WITH_TARGET,
		name = "Walk here (with target)",
		description = "Choose whether walk with a target should be hidden",
		position = 2,
		section = trivialClicks
	)
	default boolean hideWalkHereWithTarget() { return true; }

	@ConfigItem(
		keyName = HIDE_WIELD,
		name = "Wield",
		description = "Choose whether wield (not from menu) should be hidden",
		position = 3,
		section = trivialClicks
	)
	default boolean hideWield() { return true; }

	@ConfigItem(
		keyName = HIDE_WEAR,
		name = "Wear",
		description = "Choose whether wear (not from menu) should be hidden",
		position = 4,
		section = trivialClicks
	)
	default boolean hideWear() { return true; }

	@ConfigItem(
		keyName = HIDE_TOGGLE_RUN,
		name = "Toggle Run",
		description = "Choose whether toggle run should be hidden",
		position = 5,
		section = trivialClicks
	)
	default boolean hideToggleRun() { return true; }

	@ConfigItem(
			keyName = HIDE_SPECIAL_ATTACK,
			name = "Special attack",
			description = "Choose whether using special attack should be hidden",
			position = 7,
			section = trivialClicks
	)
	default boolean hideSpecialAttack() { return true; }

	@ConfigItem(
		keyName = HIDE_QUICK_PRAYERS,
		name = "Quick-prayers",
		description = "Choose whether toggle quick-prayers should be hidden",
		position = 6,
		section = trivialClicks
	)
	default boolean hideQuickPrayers() { return true; }

	@ConfigItem(
		keyName = HIDE_PANEL_PRAYERS,
		name = "Panel prayers",
		description = "Choose whether toggling prayers from the prayer panel should be hidden",
		position = 8,
		section = trivialClicks
	)
	default boolean hidePanelPrayers() { return true; }

	@ConfigItem(
		keyName = HIDE_PANELS_GROUP,
		name = "Panels (group)",
		description = "Choose whether most clicks on panels should be hidden",
		position = 9,
		section = trivialClicks
	)
	default boolean hidePanelsGroup() { return true; }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum LingeringClickTooltipsLocation {

    LINGERING("Lingering"),
    ANCHORED("Anchored"),
    FIXED("Fixed");

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }

    public static final String TOOLTIP_LOCATION_CONFIG_KEY = "tooltipLocation";
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips;

import com.google.inject.Provides;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsTextColorManager;
import ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsTrivialClicksManager;

import javax.inject.Inject;

@PluginDescriptor(
	name = "Lingering Click Tooltips",
	description = "Generate configurable tooltips with left click mouse actions",
	tags = {"overlay","tooltip","text","hover","click","action","toast","filter"}
)
public class LingeringClickTooltipsPlugin extends Plugin
{
	@Inject
	private RuneLiteConfig runeLiteConfig;

	@Inject
	private LingeringClickTooltipsConfig config;

	@Inject
	private LingeringClickTooltipsOverlay overlay;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private LingeringClickTooltipsQueueManager queueManager;

	@Inject
	private LingeringClickTooltipsInputListener inputListener;

	@Inject
	private LingeringClickTooltipsTrivialClicksManager trivialClicksManager;

	@Inject
	private LingeringClickTooltipsTextColorManager textColorManager;

	@Override
	protected void startUp() throws Exception
	{
		mouseManager.registerMouseListener(inputListener);
		keyManager.registerKeyListener(inputListener);
		inputListener.initialize(queueManager);

		queueManager.initialize(inputListener);

		overlayManager.add(overlay);
		overlay.initialize(inputListener, queueManager);

		trivialClicksManager.initialize();

		textColorManager.initialize();
	}

	@Override
	protected void shutDown() throws Exception
	{
		mouseManager.unregisterMouseListener(inputListener);
		keyManager.unregisterKeyListener(inputListener);
		inputListener.destroy();

		queueManager.destroy();

		overlayManager.remove(overlay);
		overlay.destroy();

		trivialClicksManager.destroy();

		textColorManager.destroy();
	}

	@Provides
	LingeringClickTooltipsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LingeringClickTooltipsConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(LingeringClickTooltipsConfig.GROUP_NAME))
		{
			trivialClicksManager.updateFromConfig(event.getKey());
			textColorManager.updateFromConfig(event.getKey());
			overlay.updateFromConfig(event.getKey());
			queueManager.clear(event.getKey());
		}
		else if (event.getGroup().equals(runeLiteConfig.GROUP_NAME))
		{
			textColorManager.updateFromConfig(event.getKey());
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		queueManager.createNewTooltip(event);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		queueManager.processTick();
	}
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.filtering;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum LingeringClickTooltipsFilterMode
{
    NONE("None"),
    BLACKLIST("Blacklist"),
    WHITELIST("Whitelist");

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.filtering;

import net.runelite.client.util.Text;

import java.util.List;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorConstants.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilterMode.*;

public class LingeringClickTooltipsFilteringUtil {

    /**
     * @param tooltipText the tooltip text to inspect for filter list action keywords
     * @return the appropriate filter list action (e.g. BLACKLIST + ADD), returns empty string if none apply
     */
    public static String extractFilterListAction(String tooltipText)
    {
        String filterListAction = "";

        if (tooltipText.contains(BLACKLIST.toString()))
        {
            filterListAction += BLACKLIST.toString();
        }
        else if (tooltipText.contains(WHITELIST.toString()))
        {
            filterListAction += WHITELIST.toString();
        }
        else if (tooltipText.contains(NO_FILTER_MODE_ENABLED))
        {
            filterListAction += NO_FILTER_MODE_ENABLED;
        }

        if (!filterListAction.isEmpty()) // for an added layer of specificity
        {
            if (tooltipText.contains(ADD))
            {
                filterListAction += ADD;
            }
            else if (tooltipText.contains(REMOVE))
            {
                filterListAction += REMOVE;
            }
        }

        return filterListAction;
    }

    /**
     * @param text the text from which tags will be stripped
     * @return text with all tags such as <col=ffffff> (a color tag specifying white text) removed
     */
    public static String removeTags(String text)
    {
        return Text.removeTags(text);
    }

    /**
     * @param csvString the string containing csv
     * @return csv converted to a list
     */
    public static List<String> csvToList(String csvString)
    {
        return Text.fromCSV(csvString);
    }

    /**
     * @param list the list to convert to csv
     * @return string containing csv
     */
    public static String listToCsv(List<String> list)
    {
        return Text.toCSV(list);
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.filtering;

import ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsConfig;
import java.util.LinkedList;
import java.util.List;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorConstants.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilterMode.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilteringUtil.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilteringConstants.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsTrivialClicksManager.*;

public class LingeringClickTooltipsFiltering {

    /**
     * @param tooltipText the tooltip text to check for processing
     * @param isHide whether the plugin is currently in hide mode, where tooltips do not show
     * @param isCtrlPressed whether the CTRL key is currently held down, may show tooltips normally during hide mode
     * @param config the configuration settings for the plugin
     * @return whether the click should render a tooltip
     */
    public static boolean shouldRenderTooltip(String tooltipText, boolean isHide, boolean isCtrlPressed, LingeringClickTooltipsConfig config)
    {
        String filterableText = removeTags(tooltipText); // filtering should never include tags

        boolean isHideMode = isHideMode(isHide, isCtrlPressed, config.ctrlTogglesHide());
        boolean isTrivialClick = isTrivialClick(filterableText, config);
        boolean isFilteredByList = isFilteredByList(filterableText, config);
        boolean isBlockedClickTooltip = isBlockedClickTooltip(filterableText);
        boolean isHiddenBlockedClickTooltip = isBlockedClickTooltip && !config.showBlockedClicks();

        return !isHideMode && !isTrivialClick && !(isFilteredByList && !isBlockedClickTooltip) && !isHiddenBlockedClickTooltip;
    }

    /**
     * @param isHide the current hide mode state
     * @param isCtrlPressed whether the CTRL key is currently pressed
     * @param ctrlTogglesHide whether the CTRL key can toggle hide mode while pressed
     * @return whether tooltips are currently hidden
     */
    public static boolean isHideMode(boolean isHide, boolean isCtrlPressed, boolean ctrlTogglesHide)
    {
        return isHide && !(isCtrlPressed && ctrlTogglesHide);
    }

    /**
     * @param tooltipText the tooltip text to check for triviality
     * @param config the configuration settings for the plugin
     * @return whether tooltipText is a trivial click based on the current config (or a default trivial click)
     */
    public static boolean isTrivialClick(String tooltipText, LingeringClickTooltipsConfig config)
    {
        if (defaultContains(tooltipText))
        {
            return true;
        }
        else if (config.hideTrivialClicks() && !config.trackerMode())
        {
            if (tooltipText.contains(WALK_HERE) && tooltipText.length() > WALK_HERE.length())
            {
                return configurableContains(WALK_HERE_WITH_TARGET);
            }
            else if ((tooltipText.contains(ACTIVATE) || tooltipText.contains(DEACTIVATE)) && !tooltipText.contains(QUICK_PRAYERS))
            {
                return configurableContains(TOGGLE_PANEL_PRAYER);
            }
            else return configurableContains(tooltipText);
        }
        else
        {
            return false;
        }
    }

    /**
     * @param tooltipText the tooltip text to check for filtering
     * @param config the configuration settings for the plugin
     * @return whether tooltipText is filtered based on the current filter mode
     */
    public static boolean isFilteredByList(String tooltipText, LingeringClickTooltipsConfig config)
    {
        if (config.filterMode() == BLACKLIST)
        {
            List<String> blacklist = csvToList(config.blacklist());
            return blacklist.contains(tooltipText);
        }
        else if (config.filterMode() == WHITELIST)
        {
            List<String> whitelist = csvToList(config.whitelist());
            return !whitelist.contains(tooltipText);
        }
        else
        {
            return false;
        }
    }

    /**
     * @param tooltipText text which may contain blocked click keywords
     * @return whether tooltipText is for a blocked or bypass click
     */
    public static boolean isBlockedClickTooltip(String tooltipText)
    {
        return (tooltipText.contains(BYPASS) || tooltipText.contains(BLOCKED_BY))
            && (tooltipText.contains(BLACKLIST.toString()) || tooltipText.contains(WHITELIST.toString()) || tooltipText.contains(SHIFT));
    }

    /**
     * Updates the appropriate filter list, then indicates the action by returning a String with keywords.
     * @param config the configuration settings for the plugin
     * @param tooltipText the last tooltip text detected by the plugin, including all trivial clicks
     * @param isPeek whether the method was called from a peek action
     * @return tooltipText prefixed with the appropriate filter list action keywords
     */
    public static String updateFilterLists(LingeringClickTooltipsConfig config, String tooltipText, boolean isPeek)
    {
        String infoTooltipText = "";
        if (tooltipText == null || tooltipText.isEmpty())
        {
            return infoTooltipText;
        }
        LingeringClickTooltipsFilterMode filterMode = config.filterMode();
        String filterableText = removeTags(tooltipText);
        if (filterMode == BLACKLIST)
        {
            List<String> blacklist = new LinkedList<>(csvToList(config.blacklist()));
            if (blacklist.contains(filterableText))
            {
                blacklist.remove(filterableText);
                infoTooltipText += BLACKLIST + REMOVE + tooltipText;
            }
            else
            {
                blacklist.add(filterableText);
                infoTooltipText += BLACKLIST + ADD + tooltipText;
            }

            if (!isPeek) // peek actions do not commit changes to config
            {
                config.setBlacklist(listToCsv(blacklist));
            }
        }
        else if (filterMode == WHITELIST)
        {
            List<String> whitelist = new LinkedList<>(csvToList(config.whitelist()));
            if (whitelist.contains(filterableText))
            {
                whitelist.remove(filterableText);
                infoTooltipText += WHITELIST + REMOVE + tooltipText;
            }
            else
            {
                whitelist.add(filterableText);
                infoTooltipText += WHITELIST + ADD + tooltipText;
            }

            if (!isPeek) // peek actions do not commit changes to config
            {
                config.setWhitelist(listToCsv(whitelist));
            }
        }
        else if (filterMode == NONE)
        {
            infoTooltipText += NO_FILTER_MODE_ENABLED;
        }
        return infoTooltipText;
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.filtering;

import ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsConfig;

import javax.inject.Inject;
import java.util.HashSet;
import java.util.Set;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilteringConstants.*;

public class LingeringClickTooltipsTrivialClicksManager {

    @Inject
    private LingeringClickTooltipsConfig config;

    private static Set<String> configurableTrivialClicks;
    private static Set<String> defaultTrivialClicks;
    private static Set<String> panelTrivialClicks;

    public void updateFromConfig(String configKey)
    {
        switch (configKey)
        {
            case HIDE_WALK_HERE:
                modifyConfigurableTrivialClicks(config.hideWalkHere(), WALK_HERE);
                break;
            case HIDE_WALK_HERE_WITH_TARGET:
                modifyConfigurableTrivialClicks(config.hideWalkHereWithTarget(), WALK_HERE_WITH_TARGET);
                break;
            case HIDE_WIELD:
                modifyConfigurableTrivialClicks(config.hideWield(), WIELD);
                break;
            case HIDE_WEAR:
                modifyConfigurableTrivialClicks(config.hideWear(), WEAR);
                break;
            case HIDE_TOGGLE_RUN:
                modifyConfigurableTrivialClicks(config.hideToggleRun(), TOGGLE_RUN);
                break;
            case HIDE_SPECIAL_ATTACK:
                modifyConfigurableTrivialClicks(config.hideSpecialAttack(), USE_SPECIAL_ATTACK);
                break;
            case HIDE_QUICK_PRAYERS:
                modifyConfigurableTrivialClicks(config.hideQuickPrayers(), ACTIVATE_QUICK_PRAYERS);
                modifyConfigurableTrivialClicks(config.hideQuickPrayers(), DEACTIVATE_QUICK_PRAYERS);
                break;
            case HIDE_PANEL_PRAYERS:
                modifyConfigurableTrivialClicks(config.hidePanelPrayers(), TOGGLE_PANEL_PRAYER);
                break;
            case HIDE_PANELS_GROUP:
                modifyConfigurableTrivialClicks(config.hidePanelsGroup(), panelTrivialClicks);
                break;
            default:
                break;
        }
    }

    private static void modifyConfigurableTrivialClicks(boolean configEnabled, String text)
    {
        if (configEnabled)
        {
            configurableTrivialClicks.add(text);
        }
        else
        {
            configurableTrivialClicks.remove(text);
        }
    }

    private static void modifyConfigurableTrivialClicks(boolean configEnabled, Set<String> textGroup)
    {
        if (configEnabled)
        {
            configurableTrivialClicks.addAll(textGroup);
        }
        else
        {
            configurableTrivialClicks.removeAll(textGroup);
        }
    }

    public static boolean defaultContains(String text)
    {
        return defaultTrivialClicks.contains(text);
    }

    public static boolean configurableContains(String text)
    {
        return configurableTrivialClicks.contains(text);
    }

    public void initialize()
    {
        initializeDefault();
        initializePanelGroup();
        initializeConfigurable();
    }

    public void destroy()
    {
        defaultTrivialClicks.clear();
        defaultTrivialClicks = null;
        panelTrivialClicks.clear();
        panelTrivialClicks = null;
        configurableTrivialClicks.clear();
        configurableTrivialClicks = null;
    }

    private void initializeDefault()
    {
        defaultTrivialClicks = new HashSet<>();
        defaultTrivialClicks.add(CANCEL);
        defaultTrivialClicks.add(CONTINUE);
        defaultTrivialClicks.add(PLAY);
        defaultTrivialClicks.add(LOGOUT);
        defaultTrivialClicks.add(CLOSE);
        defaultTrivialClicks.add(WORLD_SWITCHER);
        defaultTrivialClicks.add(SELECT);
        defaultTrivialClicks.add(SHIFT_DROP);
        defaultTrivialClicks.add(USE_INITIATE);
        defaultTrivialClicks.add(EAT);
        defaultTrivialClicks.add(MOVE_SLIDING_PIECE);
    }

    private void initializePanelGroup()
    {
        panelTrivialClicks = new HashSet<>();
        panelTrivialClicks.add(COMBAT_OPTIONS);
        panelTrivialClicks.add(SKILLS);
        panelTrivialClicks.add(CHARACTER_SUMMARY);
        panelTrivialClicks.add(QUEST_LIST);
        panelTrivialClicks.add(ACHIEVEMENT_DIARIES);
        panelTrivialClicks.add(KOUREND_FAVOUR);
        panelTrivialClicks.add(INVENTORY);
        panelTrivialClicks.add(WORN_EQUIPMENT);
        panelTrivialClicks.add(PRAYER);
        panelTrivialClicks.add(MAGIC);
        panelTrivialClicks.add(CHAT_CHANNEL);
        panelTrivialClicks.add(YOUR_CLAN);
        panelTrivialClicks.add(VIEW_ANOTHER_CLAN);
        panelTrivialClicks.add(GROUPING);
        panelTrivialClicks.add(FRIENDS_LIST);
        panelTrivialClicks.add(IGNORE_LIST);
        panelTrivialClicks.add(ACCOUNT_MANAGEMENT);
        panelTrivialClicks.add(SETTINGS);
        panelTrivialClicks.add(EMOTES);
        panelTrivialClicks.add(MUSIC_PLAYER);
    }

    private void initializeConfigurable()
    {
        configurableTrivialClicks = new HashSet<>();
        modifyConfigurableTrivialClicks(config.hideWalkHere(), WALK_HERE);
        modifyConfigurableTrivialClicks(config.hideWalkHereWithTarget(), WALK_HERE_WITH_TARGET);
        modifyConfigurableTrivialClicks(config.hideWield(), WIELD);
        modifyConfigurableTrivialClicks(config.hideWear(), WEAR);
        modifyConfigurableTrivialClicks(config.hideToggleRun(), TOGGLE_RUN);
        modifyConfigurableTrivialClicks(config.hideSpecialAttack(), USE_SPECIAL_ATTACK);
        modifyConfigurableTrivialClicks(config.hideQuickPrayers(), ACTIVATE_QUICK_PRAYERS);
        modifyConfigurableTrivialClicks(config.hideQuickPrayers(), DEACTIVATE_QUICK_PRAYERS);
        modifyConfigurableTrivialClicks(config.hidePanelPrayers(), TOGGLE_PANEL_PRAYER);
        modifyConfigurableTrivialClicks(config.hidePanelsGroup(), panelTrivialClicks);
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.filtering;

public class LingeringClickTooltipsFilteringConstants {

    // config key names
    public static final String HIDE_TRIVIAL_CLICKS = "hideTrivialClicks";
    public static final String HIDE_WALK_HERE = "hideWalkHere";
    public static final String HIDE_WALK_HERE_WITH_TARGET = "hideWalkHereWithTarget";
    public static final String HIDE_WIELD = "hideWield";
    public static final String HIDE_WEAR = "hideWear";
    public static final String HIDE_TOGGLE_RUN = "hideToggleRun";
    public static final String HIDE_SPECIAL_ATTACK = "hideSpecialAttack";
    public static final String HIDE_QUICK_PRAYERS = "hideQuickPrayers";
    public static final String HIDE_PANEL_PRAYERS = "hidePanelPrayers";
    public static final String HIDE_PANELS_GROUP = "hidePanelsGroup";
    public static final String WHITELIST_CSV = "whitelist";
    public static final String BLACKLIST_CSV = "blacklist";

    // default trivial clicks
    public static final String CANCEL = "Cancel";
    public static final String CONTINUE = "Continue";
    public static final String PLAY = "Play";
    public static final String LOGOUT = "Logout";
    public static final String CLOSE = "Close";
    public static final String WORLD_SWITCHER = "World Switcher";
    public static final String SELECT = "Select";
    public static final String SHIFT_DROP = "Drop";
    public static final String USE_INITIATE = "Use";
    public static final String EAT = "Eat";
    public static final String MOVE_SLIDING_PIECE = "Move Sliding piece";

    // panel trivial clicks group
    public static final String COMBAT_OPTIONS = "Combat Options";
    public static final String SKILLS = "Skills";
    public static final String CHARACTER_SUMMARY = "Character Summary";
    public static final String QUEST_LIST = "Quest List";
    public static final String ACHIEVEMENT_DIARIES = "Achievement Diaries";
    public static final String KOUREND_FAVOUR = "Kourend Favour";
    public static final String INVENTORY = "Inventory";
    public static final String WORN_EQUIPMENT = "Worn Equipment";
    public static final String PRAYER = "Prayer";
    public static final String MAGIC = "Magic";
    public static final String CHAT_CHANNEL = "Chat-channel";
    public static final String YOUR_CLAN = "Your Clan";
    public static final String VIEW_ANOTHER_CLAN = "View another clan";
    public static final String GROUPING = "Grouping";
    public static final String FRIENDS_LIST = "Friends List";
    public static final String IGNORE_LIST = "Ignore List";
    public static final String ACCOUNT_MANAGEMENT = "Account Management";
    public static final String SETTINGS = "Settings";
    public static final String EMOTES = "Emotes";
    public static final String MUSIC_PLAYER = "Music Player";

    // configurable trivial clicks
    public static final String WALK_HERE = "Walk here";
    public static final String WALK_HERE_WITH_TARGET = WALK_HERE + "[TARGET]"; // special case placeholder, does not match text
    public static final String WIELD = "Wield";
    public static final String WEAR = "Wear";
    public static final String TOGGLE_RUN = "Toggle Run";
    public static final String USE_SPECIAL_ATTACK = "Use Special Attack";
    public static final String ACTIVATE = "Activate";
    public static final String DEACTIVATE = "Deactivate";
    public static final String QUICK_PRAYERS = "Quick-prayers";
    public static final String ACTIVATE_QUICK_PRAYERS = ACTIVATE + " " + QUICK_PRAYERS;
    public static final String DEACTIVATE_QUICK_PRAYERS = DEACTIVATE + " " + QUICK_PRAYERS;
    public static final String TOGGLE_PANEL_PRAYER = ACTIVATE + DEACTIVATE + "[PRAYER]"; // special case placeholder, does not match text
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.fade;

import ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsConfig;
import ryanxie0.runelite.plugin.lingeringclicktooltips.wrapper.LingeringClickTooltipsWrapper;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.fade.LingeringClickTooltipsFadeUtil.*;

public class LingeringClickTooltipsFade {

    /**
     * Calculates the alpha value for a tooltip. It is dependent on which phase of fade the tooltip is in.
     * @param tooltip the tooltip for which fade will be calculated
     * @param config the configuration settings for the plugin
     * @return the tooltip alpha modifier which will be used during rendering
     */
    public static double calculateAlphaModifier(LingeringClickTooltipsWrapper tooltip, LingeringClickTooltipsConfig config)
    {
        double alphaModifier = getMaximumOpacity(config);

        Duration sinceCreation = Duration.between(tooltip.getTimeOfCreation(), Instant.now());

        int fadeInPeriodThreshold = calculateFadeInPeriodThreshold(config, tooltip.isInfoTooltip());
        int fadeOutPeriodThreshold = calculateFadeoutPeriodThreshold(config, tooltip.isInfoTooltip());

        if (isInFadeInPeriod(sinceCreation.toMillis(), fadeInPeriodThreshold))
        {
            alphaModifier = applyFadeIn(alphaModifier, sinceCreation.toMillis(), fadeInPeriodThreshold);
        }
        else if (isInFadeoutPeriod(sinceCreation.toMillis(), fadeOutPeriodThreshold))
        {
            Duration totalTooltipDuration = tooltip.getTooltipDuration();
            long timeRemaining = totalTooltipDuration.minus(sinceCreation).toMillis();
            long fadeoutPeriod = totalTooltipDuration.toMillis() - fadeOutPeriodThreshold;
            alphaModifier = applyFadeout(alphaModifier, timeRemaining, fadeoutPeriod);
        }

        return alphaModifier;
    }

    /**
     * Used for refreshing an info tooltip in the case that its text did not change.
     * @param infoTooltip the info tooltip to refresh
     */
    public static void refreshInfoTooltip(LingeringClickTooltipsWrapper infoTooltip, LingeringClickTooltipsConfig config)
    {
        if (infoTooltip.isFaded())
        {   // if faded, must reset isFaded and set time of creation to now
            infoTooltip.setFaded(false);
            infoTooltip.setTimeOfCreation(Instant.now());
            return;
        }

        Duration sinceCreation = Duration.between(infoTooltip.getTimeOfCreation(), Instant.now());
        int fadeInPeriodThreshold = calculateFadeInPeriodThreshold(config, infoTooltip.isInfoTooltip());
        if (!isInFadeInPeriod(sinceCreation.toMillis(), fadeInPeriodThreshold))
        {   // if not yet faded and not fading in, resets time of creation excluding the fade-in period
            infoTooltip.setTimeOfCreation(Instant.now().minus(fadeInPeriodThreshold, ChronoUnit.MILLIS));
        }
    }

    /**
     * Resets the time of creation of a tooltip wrapper to now.
     * @param tooltip the tooltip to reset
     */
    public static void refreshTooltipTimeOfCreation(LingeringClickTooltipsWrapper tooltip)
    {
        tooltip.setTimeOfCreation(Instant.now());
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.fade;

public class LingeringClickTooltipsFadeConstants {

    // multipliers for modifying duration/fade
    public static final double LIGHT_MODE_MULTIPLIER = 0.75;
    public static final double INFO_TOOLTIP_MULTIPLIER = 1.5;
    public static final double FAST_MODE_MULTIPLIER = 2.0;
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.fade;

import ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsConfig;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.fade.LingeringClickTooltipsFadeConstants.*;

public class LingeringClickTooltipsFadeUtil {

    /**
     * @return the tooltip start opacity, adjusted by light mode if applicable
     */
    public static double getMaximumOpacity(LingeringClickTooltipsConfig config)
    {
        if (config.lightMode())
        {
            return config.maximumOpacity() / 100.0 * LIGHT_MODE_MULTIPLIER;
        }
        else
        {
            return config.maximumOpacity() / 100.0;
        }
    }

    /**
     * Returns the fade-in period threshold of a tooltip.
     * @param config the configuration settings for the plugin
     * @param isInfoTooltip whether the tooltip is an info tooltip
     * @return the number of ms since creation of the tooltip at which fade-in will complete
     */
    public static int calculateFadeInPeriodThreshold(LingeringClickTooltipsConfig config, boolean isInfoTooltip)
    {
        if (isInfoTooltip)
        {
            return (int) (config.tooltipDuration() * config.tooltipFadeIn() / 100.0 / INFO_TOOLTIP_MULTIPLIER);
        }
        else if (config.fastMode())
        {
            return (int) (config.tooltipDuration() * config.tooltipFadeIn() / 100.0 / FAST_MODE_MULTIPLIER);
        }
        else
        {
            return (int) (config.tooltipDuration() * config.tooltipFadeIn() / 100.0);
        }
    }

    /**
     * Returns the fadeout period threshold of a tooltip.
     * @param config the configuration settings for the plugin
     * @param isInfoTooltip whether the tooltip is an info tooltip
     * @return the number of ms since creation of the tooltip at which fadeout will begin
     */
    public static int calculateFadeoutPeriodThreshold(LingeringClickTooltipsConfig config, boolean isInfoTooltip)
    {
        int fadeoutPeriodThreshold = config.tooltipDuration();
        if (isInfoTooltip)
        {
            return (int) (fadeoutPeriodThreshold * INFO_TOOLTIP_MULTIPLIER);
        }
        else if (config.fastMode())
        {
            return (int) (fadeoutPeriodThreshold / FAST_MODE_MULTIPLIER);
        }
        return calculateFadeInPeriodThreshold(config, isInfoTooltip) + fadeoutPeriodThreshold;
    }

    /**
     * Modifies the alphaModifier during the fade-in period.
     * @param alphaModifier the alpha modifier to which fade-in will be applied
     * @param sinceCreation the time since the creation of the tooltip
     * @param fadeInPeriodThreshold the number of ms since creation of the tooltip at which fade-in will complete
     * @return alphaModifier adjusted for the fade-in period
     */
    public static double applyFadeIn(double alphaModifier, long sinceCreation, long fadeInPeriodThreshold)
    {
        return alphaModifier * sinceCreation / fadeInPeriodThreshold;
    }

    /**
     * Modifies the alphaModifier during the fadeout period.
     * @param alphaModifier the alpha modifier to which fadeout will be applied
     * @param timeRemaining the time remaining on the tooltip duration
     * @param fadeoutPeriod the total length of the fadeout period
     * @return alphaModifier adjusted for the fadeout period
     */
    public static double applyFadeout(double alphaModifier, long timeRemaining, long fadeoutPeriod)
    {
        return alphaModifier * timeRemaining / fadeoutPeriod;
    }

    /**
     * Returns whether a tooltip is currently in the fade-in period.
     * @param sinceCreation the time since the creation of the tooltip
     * @param fadeInPeriodThreshold the number of ms since creation of the tooltip at which fade-in will complete
     * @return whether the tooltip is currently in the fade-in period
     */
    public static boolean isInFadeInPeriod(long sinceCreation, long fadeInPeriodThreshold)
    {
        return sinceCreation < fadeInPeriodThreshold;
    }

    /**
     * Returns whether a tooltip is currently in the fadeout period.
     * @param sinceCreation the time since the creation of the tooltip
     * @param fadeoutPeriodThreshold the number of ms since creation of the tooltip at which fadeout will begin
     * @return whether the tooltip is currently in the fade-in period
     */
    public static boolean isInFadeoutPeriod(long sinceCreation, long fadeoutPeriodThreshold)
    {
        return sinceCreation > fadeoutPeriodThreshold;
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.color;

import java.awt.Color;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilterMode.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorUtil.hexToColor;

public class LingeringClickTooltipsColorConstants {

    // config key names
    public static final String OVERLAY_BACKGROUND_COLOR = "overlayBackgroundColor";
    public static final String USE_CUSTOM_BACKGROUND_COLOR = "useCustomBackgroundColor";
    public static final String CUSTOM_BACKGROUND_COLOR = "customBackgroundColor";
    public static final String USE_CUSTOM_TEXT_COLOR = "useCustomTextColor";
    public static final String CUSTOM_TEXT_COLOR = "customTextColor";

    // color hex codes
    private static final String TRANSPARENT_HEX = "0x00000000"; // fully transparent
    private static final String LIGHT_GREEN_HEX = "0x55ED55"; // lighter and less intense green
    private static final String LIGHT_RED_HEX = "0xED5555"; // lighter and less intense red
    private static final String DARKER_GRAY_HEX = "0xA0202020"; // between Color.BLACK and Color.DARK_GRAY, alpha = 160
    private static final String MEDIUM_GRAY_HEX = "0xA0606060"; // between Color.DARK_GRAY AND Color.GRAY, alpha = 160
    private static final String LIGHTER_GRAY_HEX = "0xD0D0D0"; // between Color.LIGHT_GRAY and Color.WHITE

    // colors derived from hex codes
    public static final Color TRANSPARENT = hexToColor(TRANSPARENT_HEX);
    public static final Color LIGHT_GREEN = hexToColor(LIGHT_GREEN_HEX);
    public static final Color LIGHT_RED = hexToColor(LIGHT_RED_HEX);
    public static final Color DARKER_GRAY = hexToColor(DARKER_GRAY_HEX);
    public static final Color MEDIUM_GRAY = hexToColor(MEDIUM_GRAY_HEX);
    public static final Color LIGHTER_GRAY = hexToColor(LIGHTER_GRAY_HEX);

    // keywords to indicate where to apply the color
    public static final String BACKGROUND_COLOR = ".backgroundColor";
    public static final String TEXT_COLOR = ".textColor";

    // keywords used for text color mappings/building tooltip text
    public static final String TOOLTIPS = "Tooltips";
    public static final String HIDDEN = "HIDDEN";
    public static final String SHOWN = "SHOWN";
    public static final String TOOLTIPS_HIDDEN = TOOLTIPS + " " + HIDDEN;
    public static final String TOOLTIPS_SHOWN = TOOLTIPS + " " + SHOWN;
    public static final String BLACKLIST_BACKGROUND_COLOR = BLACKLIST + BACKGROUND_COLOR;
    public static final String WHITELIST_BACKGROUND_COLOR = WHITELIST + BACKGROUND_COLOR;
    public static final String BLACKLIST_TEXT_COLOR = BLACKLIST + TEXT_COLOR;
    public static final String WHITELIST_TEXT_COLOR = WHITELIST + TEXT_COLOR;
    public static final String ADD = "ADD";
    public static final String REMOVE = "REMOVE";
    public static final String NO_FILTER_MODE_ENABLED = "No filter mode enabled";
    public static final String NO_FILTER_MODE_ENABLED_BACKGROUND_COLOR = NO_FILTER_MODE_ENABLED + BACKGROUND_COLOR;
    public static final String NO_FILTER_MODE_ENABLED_TEXT_COLOR = NO_FILTER_MODE_ENABLED + TEXT_COLOR;
    public static final String LAST_CLICK = "Last click";
    public static final String LAST_CLICK_BACKGROUND_COLOR = LAST_CLICK + BACKGROUND_COLOR;
    public static final String LAST_CLICK_TEXT_COLOR = LAST_CLICK + TEXT_COLOR;
    public static final String BLOCKED_BY = "Blocked by";
    public static final String BYPASS = "Bypass";
    public static final String SHIFT = "SHIFT";
    public static final String BLOCKED_BY_SHIFT_BACKGROUND_COLOR = BLOCKED_BY + SHIFT + BACKGROUND_COLOR;
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.color;

import java.awt.Color;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsTextColorManager.getColor;

public class LingeringClickTooltipsColorUtil {

    /**
     * @param color the color for which a text tag will be obtained, e.g. <col=ffffff> for Color.WHITE
     * @return the color text tag generated for color
     */
    public static String getColorTag(Color color)
    {
        return "<col=" + colorToHex(color).substring(2) + ">";
    }

    /**
     * If this method receives text which maps to no color, returns an empty string.
     * @param mappedText the text which is mapped to a color using LingeringClickTooltipsTextToColorMapper.java
     * @return the color text tag generated for mappedText
     */
    public static String getColorTag(String mappedText)
    {
        Color mappedColor = getColor(mappedText);
        return mappedColor != null? getColorTag(mappedColor) : "";
    }

    /**
     * @param color the color to convert to hex
     * @return the hex value of the color
     */
    public static String colorToHex(Color color)
    {
        return Integer.toHexString(color.getRGB());
    }

    /**
     * Generates a Color from a hex string. Accepts both opaque colors and colors with alpha.
     * @param hex the hex string to convert to a Color, may be prefixed with "#" or "0x".
     * @return the Color converted from hex
     */
    public static Color hexToColor(String hex)
    {
        hex = hex.replaceAll("#", "");
        hex = hex.replaceAll("0x", "");

        String byte0 = "0x" + hex.substring(0, 2);
        String byte1 = "0x" + hex.substring(2, 4);
        String byte2 = "0x" + hex.substring(4, 6);

        if (hex.matches("[0-F]{6}"))
        {
            int r = Integer.decode(byte0);
            int g = Integer.decode(byte1);
            int b = Integer.decode(byte2);
            return new Color(r, g, b);
        }
        else if (hex.matches("[0-F]{8}"))
        {
            String byte3 = "0x" + hex.substring(6, 8);
            int a = Integer.decode(byte0);
            int r = Integer.decode(byte1);
            int g = Integer.decode(byte2);
            int b = Integer.decode(byte3);
            return new Color(r, g, b, a);
        }
        return null;
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.color;

import java.awt.Color;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsTextColorManager.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorConstants.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorUtil.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilterMode.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilteringUtil.*;

public class LingeringClickTooltipsColor {

    /**
     * @param tooltipText the tooltip text to which custom text color will be applied
     * @param overrideMenuColors whether the native client menu colors should be overridden
     * @return tooltipText with appropriate color tags, if applicable
     */
    public static String applyCustomTextColor(String tooltipText, boolean overrideMenuColors)
    {
        String tooltipTextColor = getColorTag(Color.WHITE); // defaults to white

        Color customTextColor = getColor(CUSTOM_TEXT_COLOR);
        if (customTextColor != null)
        {
            tooltipTextColor = getColorTag(customTextColor);
            if (overrideMenuColors)
            {
                tooltipText = removeTags(tooltipText);
            }
        }
        return tooltipTextColor + tooltipText;
    }

    /**
     * @param blockedClickText text containing blocked click keywords, e.g. BLOCKED_BY + BLACKLIST
     * @return the keywords in blockedClickText with proper formatting and color tags applied, empty string if N/A
     */
    public static String getBlockedClickTextWithColor(String blockedClickText)
    {
        String blockedClickTextWithColor = "";

        if (blockedClickText.contains(BYPASS))
        {
            blockedClickText = blockedClickText.substring(BYPASS.length());
            blockedClickTextWithColor += getColorTag(BYPASS) + BYPASS + " ";
        }
        else if (blockedClickText.contains(BLOCKED_BY))
        {
            blockedClickText = blockedClickText.substring(BLOCKED_BY.length());
            blockedClickTextWithColor += getColorTag(BLOCKED_BY) + BLOCKED_BY + " ";
        }

        if (blockedClickText.contains(BLACKLIST.toString()))
        {
            blockedClickTextWithColor += getColorTag(BLACKLIST_TEXT_COLOR) + BLACKLIST;
        }
        else if (blockedClickText.contains(WHITELIST.toString()))
        {
            blockedClickTextWithColor += getColorTag(WHITELIST_TEXT_COLOR) + WHITELIST;
        }
        else if (blockedClickText.contains(SHIFT))
        {
            blockedClickTextWithColor += getColorTag(SHIFT) + SHIFT;
        }

        if (!blockedClickText.isEmpty())
        {
            blockedClickTextWithColor += getColorTag(Color.WHITE) + ": ";
        }

        return blockedClickTextWithColor;
    }

    /**
     * @param infoTooltipText the info tooltip text to which color will be applied
     * @param isPeek whether the method was called from a peek action, used for filter list actions
     * @return infoTooltipText with appropriate formatting and color tags, if applicable
     */
    public static String applyInfoTooltipTextColor(String infoTooltipText, boolean isPeek)
    {
        String hideModeTooltipWithTextColor = getHideModeTooltipTextWithColor(infoTooltipText);
        if (!hideModeTooltipWithTextColor.isEmpty())
        {
            return hideModeTooltipWithTextColor;
        }

        String filterListActionTooltipTextWithColor = getFilterListActionTooltipTextWithColor(infoTooltipText, isPeek);
        if (!filterListActionTooltipTextWithColor.isEmpty())
        {
            return filterListActionTooltipTextWithColor;
        }

        String peekLastClickTooltipTextWithColor = getPeekLastClickTooltipTextWithColor(infoTooltipText);
        if (!peekLastClickTooltipTextWithColor.isEmpty())
        {
            return peekLastClickTooltipTextWithColor;
        }

        return infoTooltipText;
    }

    /**
     * @param tooltipText the tooltip text which may contain hide mode keywords
     * @return tooltipText with color tags applied, empty string if N/A
     */
    private static String getHideModeTooltipTextWithColor(String tooltipText)
    {
        String hideModeTooltipTextWithColor = "";
        if (tooltipText.contains(TOOLTIPS))
        {
            if (tooltipText.contains(HIDDEN))
            {
                hideModeTooltipTextWithColor += getColorTag(Color.WHITE) + TOOLTIPS + " " + getColorTag(HIDDEN) + HIDDEN;
            }
            else if (tooltipText.contains(SHOWN))
            {
                hideModeTooltipTextWithColor += getColorTag(Color.WHITE) + TOOLTIPS + " " + getColorTag(SHOWN) + SHOWN;
            }
        }
        return hideModeTooltipTextWithColor;
    }

    /**
     * @param tooltipText the tooltip text from which filter list actions will be extracted
     * @param isPeek whether the method was called from a peek action
     * @return tooltipText prefixed with the filter list action, formatting and color tags applied, empty string if N/A
     */
    private static String getFilterListActionTooltipTextWithColor(String tooltipText, boolean isPeek)
    {
        String filterListTooltipTextColor = "";
        String filterListAction = extractFilterListAction(tooltipText);

        if (filterListAction.contains(BLACKLIST.toString()))
        {
            tooltipText = tooltipText.substring(BLACKLIST.toString().length());
            filterListTooltipTextColor += getColorTag(BLACKLIST_TEXT_COLOR) + BLACKLIST + " ";
        }
        else if (filterListAction.contains(WHITELIST.toString()))
        {
            tooltipText = tooltipText.substring(WHITELIST.toString().length());
            filterListTooltipTextColor += getColorTag(WHITELIST_TEXT_COLOR) + WHITELIST + " ";
        }
        else if (filterListAction.contains(NO_FILTER_MODE_ENABLED))
        {
            filterListTooltipTextColor += getColorTag(NO_FILTER_MODE_ENABLED_TEXT_COLOR);
        }

        if (filterListAction.contains(ADD))
        {
            tooltipText = tooltipText.substring(ADD.length());
            filterListTooltipTextColor += getColorTag(ADD) + ADD + (isPeek? "? " : "ED ");
        }
        else if (filterListAction.contains(REMOVE))
        {
            tooltipText = tooltipText.substring(REMOVE.length());
            filterListTooltipTextColor += getColorTag(REMOVE) + REMOVE + (isPeek? "? " : "D ");
        }

        return filterListTooltipTextColor.isEmpty()? "" : filterListTooltipTextColor + tooltipText;
    }


    /**
     * @param tooltipText the tooltip text which may contain a peek last click action
     * @return tooltipText prefixed with peek action keywords, formatting and color tags applied, empty string if N/A
     */
    private static String getPeekLastClickTooltipTextWithColor(String tooltipText)
    {
        String peekLastClickTooltipTextColor = "";
        if (tooltipText.contains(LAST_CLICK))
        {
            tooltipText = tooltipText.substring(LAST_CLICK.length());
            peekLastClickTooltipTextColor = getColorTag(LAST_CLICK_TEXT_COLOR) + LAST_CLICK + ": ";
        }
        return peekLastClickTooltipTextColor + tooltipText;
    }

    /**
     * Returns the appropriate background color from all the available sources. Defaults to the overlay background
     * color specified under the RuneLite settings.
     * @param tooltipText the tooltip text which may map to a pre-designated background color
     * @return the background color as selected by the logic
     */
    public static Color getTooltipBackgroundColor(String tooltipText)
    {
        tooltipText = removeTags(tooltipText); // color mappings should not include text color tags, only in scope

        Color specialBackgroundColor = getSpecialBackgroundColor(tooltipText);
        if (specialBackgroundColor != null)
        {
            return specialBackgroundColor;
        }

        Color textMappedBackgroundColor = getColor(tooltipText);
        if (textMappedBackgroundColor != null)
        {
            return textMappedBackgroundColor;
        }

        Color customBackgroundColor = getColor(CUSTOM_BACKGROUND_COLOR);
        if (customBackgroundColor != null)
        {
            return customBackgroundColor;
        }

        return getColor(OVERLAY_BACKGROUND_COLOR);
    }

    /**
     * Maps tooltip text to a special background color.
     * @param tooltipText text which may map to a special background color
     * @return tooltipText mapped to a special background color, null if N/A
     */
    private static Color getSpecialBackgroundColor(String tooltipText)
    {
        String filterListAction = extractFilterListAction(tooltipText);
        if (filterListAction.contains(BLACKLIST.toString()))
        {
            return getColor(BLACKLIST_BACKGROUND_COLOR);
        }
        else if (filterListAction.contains(WHITELIST.toString()))
        {
            return getColor(WHITELIST_BACKGROUND_COLOR);
        }
        else if (filterListAction.contains(NO_FILTER_MODE_ENABLED))
        {
            return getColor(NO_FILTER_MODE_ENABLED_BACKGROUND_COLOR);
        }

        if (tooltipText.contains(LAST_CLICK))
        {
            return getColor(LAST_CLICK_BACKGROUND_COLOR);
        }

        if (tooltipText.contains(BLOCKED_BY) && tooltipText.contains(SHIFT))
        {
            return getColor(BLOCKED_BY_SHIFT_BACKGROUND_COLOR);
        }

        return null;
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.color;

import net.runelite.client.config.RuneLiteConfig;
import ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsConfig;

import javax.inject.Inject;
import java.awt.Color;
import java.util.HashMap;
import java.util.Map;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorConstants.*;

public class LingeringClickTooltipsTextColorManager {

    @Inject
    private RuneLiteConfig runeLiteConfig;

    @Inject
    private LingeringClickTooltipsConfig config;

    private static Map<String, Color> textToColorMap;

    public void updateFromConfig(String configKey)
    {
        switch (configKey)
        {
            case USE_CUSTOM_BACKGROUND_COLOR:
            case CUSTOM_BACKGROUND_COLOR:
                modifyTextToColorMap(config.useCustomBackgroundColor(), CUSTOM_BACKGROUND_COLOR, config.customBackgroundColor());
                break;
            case USE_CUSTOM_TEXT_COLOR:
            case CUSTOM_TEXT_COLOR:
                modifyTextToColorMap(config.useCustomTextColor(), CUSTOM_TEXT_COLOR, config.customTextColor());
                break;
            case OVERLAY_BACKGROUND_COLOR:
                modifyTextToColorMap(true, OVERLAY_BACKGROUND_COLOR, runeLiteConfig.overlayBackgroundColor());
                break;
            default:
                break;
        }
    }

    private static void modifyTextToColorMap(boolean configEnabled, String text, Color color)
    {
        if (configEnabled)
        {
            textToColorMap.put(text, color);
        }
        else
        {
            textToColorMap.remove(text);
        }
    }

    public static Color getColor(String text)
    {
        return textToColorMap.get(text);
    }

    public void initialize()
    {
        initializeTextToColorMap();
    }

    public void destroy()
    {
        textToColorMap.clear();
        textToColorMap = null;
    }

    private void initializeTextToColorMap()
    {
        textToColorMap = new HashMap<>();
        textToColorMap.put(TOOLTIPS_SHOWN, TRANSPARENT);
        textToColorMap.put(TOOLTIPS_HIDDEN, TRANSPARENT);
        textToColorMap.put(SHOWN, LIGHT_GREEN);
        textToColorMap.put(HIDDEN, LIGHT_RED);
        textToColorMap.put(BLACKLIST_BACKGROUND_COLOR, DARKER_GRAY);
        textToColorMap.put(WHITELIST_BACKGROUND_COLOR, MEDIUM_GRAY);
        textToColorMap.put(BLACKLIST_TEXT_COLOR, Color.YELLOW);
        textToColorMap.put(WHITELIST_TEXT_COLOR, Color.ORANGE);
        textToColorMap.put(ADD, LIGHT_GREEN);
        textToColorMap.put(REMOVE, LIGHT_RED);
        textToColorMap.put(NO_FILTER_MODE_ENABLED_BACKGROUND_COLOR, TRANSPARENT);
        textToColorMap.put(NO_FILTER_MODE_ENABLED_TEXT_COLOR, LIGHT_RED);
        textToColorMap.put(LAST_CLICK_BACKGROUND_COLOR, TRANSPARENT);
        textToColorMap.put(LAST_CLICK_TEXT_COLOR, LIGHTER_GRAY);
        textToColorMap.put(BLOCKED_BY, LIGHT_RED);
        textToColorMap.put(BYPASS, LIGHT_GREEN);
        textToColorMap.put(SHIFT, LIGHTER_GRAY);
        textToColorMap.put(BLOCKED_BY_SHIFT_BACKGROUND_COLOR, TRANSPARENT);

        modifyTextToColorMap(config.useCustomBackgroundColor(), CUSTOM_BACKGROUND_COLOR, config.customBackgroundColor());
        modifyTextToColorMap(config.useCustomTextColor(), CUSTOM_TEXT_COLOR, config.customTextColor());

        modifyTextToColorMap(true, OVERLAY_BACKGROUND_COLOR, runeLiteConfig.overlayBackgroundColor());
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips;

import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Point;

public class LingeringClickTooltipsOverlayStateManager {

    private LingeringClickTooltipsOverlay managedOverlay;

    private OverlayPosition lastPosition;
    private OverlayPosition lastPreferredPosition;
    private Point lastPreferredLocation;

    public void save()
    {
        lastPosition = managedOverlay.getPosition();
        lastPreferredPosition = managedOverlay.getPreferredPosition();
        lastPreferredLocation = managedOverlay.getPreferredLocation();
    }

    public void load()
    {
        managedOverlay.setPosition(lastPosition);
        managedOverlay.setPreferredPosition(lastPreferredPosition);
        managedOverlay.setPreferredLocation(lastPreferredLocation);
    }

    public void setDynamic()
    {
        managedOverlay.setPosition(OverlayPosition.DYNAMIC);
        managedOverlay.setPreferredPosition(null);
    }

    public boolean isDynamic()
    {
        return managedOverlay.getPosition() == OverlayPosition.DYNAMIC;
    }

    public void forceDynamic()
    {
        if (isDynamic() && managedOverlay.getPreferredPosition() != null)
        {
            setDynamic();
        }
    }

    public void initialize(LingeringClickTooltipsOverlay overlay)
    {
        managedOverlay = overlay;
        save();
    }

    public void destroy()
    {
        this.managedOverlay = null;
        this.lastPosition = null;
        this.lastPreferredPosition = null;
        this.lastPreferredLocation = null;
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips;

import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.Point;
import java.time.Duration;
import java.time.Instant;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.MouseAdapter;

import javax.inject.Inject;

public class LingeringClickTooltipsInputListener extends MouseAdapter implements KeyListener
{
    @Inject
    private LingeringClickTooltipsPlugin plugin;

    @Inject
    private LingeringClickTooltipsConfig config;

    @Getter(AccessLevel.PACKAGE)
    private Point lastClickPoint;

    @Getter(AccessLevel.PACKAGE)
    private boolean isCtrlPressed;

    @Getter(AccessLevel.PACKAGE)
    private boolean isShiftPressed;

    @Getter(AccessLevel.PACKAGE)
    private boolean isMouseOverCanvas;

    @Getter(AccessLevel.PACKAGE)
    private boolean isHide;

    private LingeringClickTooltipsQueueManager queueManager;

    private Instant lastCtrlPressTime;
    private Instant lastShiftPressTime;

    @Override
    public MouseEvent mousePressed(MouseEvent event)
    {
        if (event.getButton() == MouseEvent.BUTTON1)
        {
            lastClickPoint = event.getPoint();
        }
        return event;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent event)
    {
        isMouseOverCanvas = true;
        return event;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent event)
    {
        isMouseOverCanvas = false;
        return event;
    }

    @Override
    public void keyPressed(KeyEvent event)
    {
        if (event.getKeyCode() == KeyEvent.VK_CONTROL)
        {
            processCtrlPressed(event);
        }
        else if (event.getKeyCode() == KeyEvent.VK_SHIFT)
        {
            processShiftPressed(event);
        }
    }

    @Override
    public void keyReleased(KeyEvent event)
    {
        if (event.getKeyCode() == KeyEvent.VK_CONTROL)
        {
            processCtrlReleased(event);
        }
        else if (event.getKeyCode() == KeyEvent.VK_SHIFT)
        {
            processShiftReleased(event);
        }
    }

    @Override
    public void keyTyped(KeyEvent event)
    {

    }

    /**
     * Processes CTRL being pressed. Manages double-tap CTRL to toggle hide.
     * @param event the KeyEvent from a CTRL press
     */
    private void processCtrlPressed(KeyEvent event)
    {
        if (!isCtrlPressed)
        {
            if (lastCtrlPressTime != null && config.ctrlDoubleTapDelay() > 0
                && Duration.between(lastCtrlPressTime, Instant.now()).compareTo(Duration.ofMillis(config.ctrlDoubleTapDelay())) < 0)
            {
                isHide = !isHide;
                queueManager.createHideModeInfoTooltip(isHide);
                lastCtrlPressTime = null;
            }
            else
            {
                isCtrlPressed = true;
                lastCtrlPressTime = Instant.now();
            }
        }
    }

    /**
     * Processes SHIFT being pressed. Manages double-tap SHIFT to update filter lists and hold SHIFT to peek.
     * @param event the KeyEvent from a SHIFT press, consumed to avoid SHIFT-drop conflicts
     */
    private void processShiftPressed(KeyEvent event)
    {
        if (isCtrlPressed)
        {
            if (!isShiftPressed)
            {
                if (lastShiftPressTime != null && config.shiftDoubleTapDelay() > 0
                    && Duration.between(lastShiftPressTime, Instant.now()).compareTo(Duration.ofMillis(config.shiftDoubleTapDelay())) < 0)
                {
                    queueManager.createFilterListUpdateInfoTooltip();
                    lastShiftPressTime = null;
                }
                else
                {
                    isShiftPressed = true;
                    lastShiftPressTime = Instant.now();
                }
            }
            else
            {
                if (lastShiftPressTime != null && config.shiftDoubleTapDelay() > 0
                    && Duration.between(lastShiftPressTime, Instant.now()).compareTo(Duration.ofMillis(config.shiftDoubleTapDelay())) > 0)
                {
                    if (config.shiftPeeks())
                    {
                        queueManager.createPeekInfoTooltip();
                    }
                }
            }
            event.consume(); // consume to avoid conflict with SHIFT-drop
        }
    }

    /**
     * Processes CTRL being released. Manages the strong double-tap behavior by timing out long keypresses.
     * @param event the KeyEvent from a CTRL release
     */
    private void processCtrlReleased(KeyEvent event)
    {
        if (isCtrlPressed && config.ctrlDoubleTapDelay() > 0)
        {
            if (lastCtrlPressTime != null && Duration.between(lastCtrlPressTime, Instant.now()).compareTo(Duration.ofMillis(config.ctrlDoubleTapDelay())) > 0)
            {
                lastCtrlPressTime = null; // we want to time out presses that are too long to enforce a strong double-tap behavior
            }
        }
        isCtrlPressed = false;
        isShiftPressed = false;
    }

    /**
     * Processes SHIFT being released. Manages the strong double-tap behavior by timing out long keypresses.
     * @param event the KeyEvent from a SHIFT release
     */
    private void processShiftReleased(KeyEvent event)
    {
        if (isCtrlPressed)
        {
            if (isShiftPressed && config.shiftDoubleTapDelay() > 0)
            {
                if (lastShiftPressTime != null && Duration.between(lastShiftPressTime, Instant.now()).compareTo(Duration.ofMillis(config.shiftDoubleTapDelay())) > 0)
                {
                    lastShiftPressTime = null; // we want to time out presses that are too long to enforce a strong double-tap behavior
                }
            }
        }
        isShiftPressed = false;
    }

    public void initialize(LingeringClickTooltipsQueueManager queueManager)
    {
        this.queueManager = queueManager;
        isCtrlPressed = false;
        isShiftPressed = false;
        isMouseOverCanvas = true;
        isHide = false;
    }

    public void destroy()
    {
        queueManager = null;
        lastCtrlPressTime = null;
        lastShiftPressTime = null;
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips;

import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.events.MenuOptionClicked;
import ryanxie0.runelite.plugin.lingeringclicktooltips.wrapper.LingeringClickTooltipsWrapper;
import javax.inject.Inject;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsConfig.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColor.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.color.LingeringClickTooltipsColorConstants.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.fade.LingeringClickTooltipsFade.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilterMode.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilteringConstants.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFilteringUtil.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.filtering.LingeringClickTooltipsFiltering.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.wrapper.LingeringClickTooltipsWrapperUtil.*;

public class LingeringClickTooltipsQueueManager {

    @Inject
    private LingeringClickTooltipsConfig config;

    @Getter(AccessLevel.PACKAGE)
    private Queue<LingeringClickTooltipsWrapper> tooltips;

    @Getter(AccessLevel.PACKAGE)
    private LingeringClickTooltipsWrapper fixedLocationTooltip;

    @Getter(AccessLevel.PACKAGE)
    private LingeringClickTooltipsWrapper infoTooltip;

    private LingeringClickTooltipsWrapper tickSyncTooltip;

    private List<LingeringClickTooltipsWrapper> tooltipsToFlush;

    private LingeringClickTooltipsInputListener inputListener;

    @Getter(AccessLevel.PACKAGE)
    private String lastUnfilteredTooltipText; // used for peeking while no filter mode is enabled

    private String lastTooltipText; // used for managing filter lists

    private String lastInfoTooltipText; // used for optimizing info tooltips

    /**
     * Creates a new tooltip from a click. Builds the raw tooltip text, applies color tags, checks for
     * blocked/bypass clicks, then sets the currently rendered tooltip.
     * @param event the event fired when the user left clicks
     */
    public void createNewTooltip(MenuOptionClicked event)
    {
        String rawTooltipText = getRawTooltipText(event.getMenuOption(), event.getMenuTarget());
        String tooltipText = applyCustomTextColor(rawTooltipText, config.overrideMenuColors());
        lastTooltipText = tooltipText;
        tooltipText = getBlockedClickText(tooltipText, event) + tooltipText;
        setRenderedTooltip(tooltipText);
    }

    /**
     * Gets the text for a blocked click and consumes the MenuOptionClicked event, if applicable.
     * @param tooltipText the text which may be blocked by a filter list
     * @param event the event fired when the user left clicks
     * @return text indicating a block/bypass, proper formatting and color tags applied, empty string if N/A
     */
    private String getBlockedClickText(String tooltipText, MenuOptionClicked event)
    {
        String blockedClickText = "";
        if (config.filterMode() == NONE)
        {
            return blockedClickText;
        }
        else if (config.shiftBlocks() && inputListener.isShiftPressed())
        {
            event.consume();
            blockedClickText = BLOCKED_BY + SHIFT;
        }
        else if (config.blockFilteredClicks() && isFilteredByList(removeTags(tooltipText), config))
        {
            if (config.ctrlBypassesBlock() && inputListener.isCtrlPressed())
            {
                blockedClickText = BYPASS + config.filterMode();
            }
            else
            {
                event.consume();
                blockedClickText = BLOCKED_BY + config.filterMode();
            }
        }
        return getBlockedClickTextWithColor(blockedClickText);
    }

    /**
     * Builds a tooltip using tooltipText, then assigns the tooltip to the currently rendered variable.
     * @param tooltipText the tooltip text that will be rendered
     */
    private void setRenderedTooltip(String tooltipText)
    {
        if (shouldRenderTooltip(tooltipText, inputListener.isHide(), inputListener.isCtrlPressed(), config))
        {
            LingeringClickTooltipsWrapper tooltip = buildTooltipWrapper(
                tooltipText,
                getOffsetLocation(inputListener.getLastClickPoint(), config),
                getTooltipBackgroundColor(tooltipText),
                false,
                config
            );
            if (config.tickSyncMode())
            {
                tickSyncTooltip = tooltip;
            }
            else if (config.tooltipLocation() == LingeringClickTooltipsLocation.FIXED)
            {
                fixedLocationTooltip = tooltip;
            }
            else
            {
                addTooltip(tooltip);
            }
            lastUnfilteredTooltipText = tooltipText;
        }
    }

    /**
     * Adds a tooltip wrapper to the queue. If doing so were to increase the queue size beyond maximumTooltipsShown,
     * adds the head of the queue to flush.
     * @param tooltip the tooltip wrapper to add to the queue
     */
    private void addTooltip(LingeringClickTooltipsWrapper tooltip)
    {
        tooltips.add(tooltip);
        if (tooltips.size() > config.maximumTooltipsShown())
        {
            tooltipsToFlush.add(tooltips.peek());
        }
    }

    /**
     * Assigns tickSyncTooltip to the appropriate variable, then consumes it. Called on each game tick.
     */
    public void processTick()
    {
        if (config.tickSyncMode() && tickSyncTooltip != null)
        {
            refreshTooltipTimeOfCreation(tickSyncTooltip);
            if (config.tooltipLocation() == LingeringClickTooltipsLocation.FIXED)
            {
                fixedLocationTooltip = tickSyncTooltip;
            }
            else
            {
                addTooltip(tickSyncTooltip);
            }
            tickSyncTooltip = null;
        }
    }

    /**
     * Creates a new info tooltip, which will begin rendering at the next render cycle. If the text did not change,
     * infoTooltip is refreshed instead.
     * @param infoTooltipText the text of the info tooltip, contains color tags
     */
    private void createNewInfoTooltip(String infoTooltipText)
    {
        if (lastInfoTooltipText != null && !lastInfoTooltipText.isEmpty() && removeTags(infoTooltipText).equals(removeTags(lastInfoTooltipText)))
        {
            refreshInfoTooltip(infoTooltip, config);
        }
        else
        {
            infoTooltip = buildTooltipWrapper(
                infoTooltipText,
                null,
                getTooltipBackgroundColor(infoTooltipText),
                true,
                config
            );
            lastInfoTooltipText = infoTooltipText;
        }
    }

    /**
     * Creates an info tooltip regarding the current hide mode state. First generates text containing keywords
     * structured as (TOOLTIPS + HIDDEN), then applies the appropriate formatting and color tags.
     * @param isHide whether hide mode is enabled
     */
    public void createHideModeInfoTooltip(boolean isHide)
    {
        String hideModeTooltipText = isHide? TOOLTIPS + HIDDEN : TOOLTIPS + SHOWN;
        String toggledHideModeTooltipTextWithColor = applyInfoTooltipTextColor(hideModeTooltipText, false);
        createNewInfoTooltip(toggledHideModeTooltipTextWithColor);
    }

    /**
     * Creates an info tooltip regarding a filter list update. If no filter list action is detected, indicates to
     * the user that no filter mode is enabled.
     */
    public void createFilterListUpdateInfoTooltip()
    {
        String filterListUpdateTooltipText = updateFilterLists(config, lastTooltipText, false);
        if (!filterListUpdateTooltipText.isEmpty())
        {
            String filterListUpdateTooltipTextWithColor = applyInfoTooltipTextColor(filterListUpdateTooltipText, false);
            createNewInfoTooltip(filterListUpdateTooltipTextWithColor);
        }
    }

    /**
     * Creates an info tooltip peeking a relevant action. If no filter list action is detected, creates a peek info
     * tooltip containing the last unfiltered action.
     */
    public void createPeekInfoTooltip()
    {
        String filterListUpdateTooltipText = updateFilterLists(config, lastTooltipText, true);
        if (!filterListUpdateTooltipText.isEmpty() && !filterListUpdateTooltipText.contains(NO_FILTER_MODE_ENABLED))
        {
            String filterListUpdateTooltipTextWithColor = applyInfoTooltipTextColor(filterListUpdateTooltipText, true);
            createNewInfoTooltip(filterListUpdateTooltipTextWithColor);
        }
        else if (lastUnfilteredTooltipText != null && !lastUnfilteredTooltipText.isEmpty())
        {
            String peekLastClickTooltipTextWithColor = applyInfoTooltipTextColor(LAST_CLICK + lastUnfilteredTooltipText, true);
            createNewInfoTooltip(peekLastClickTooltipTextWithColor);
        }
    }

    /**
     * Adds a tooltip to tooltipsToFlush.
     * @param tooltip the tooltip to flush
     */
    public void addTooltipToFlush(LingeringClickTooltipsWrapper tooltip)
    {
        tooltipsToFlush.add(tooltip);
    }

    /**
     * Flushes the collected tooltips from the queue. Called once at the beginning of each render.
     */
    public void flushTooltips()
    {
        for (LingeringClickTooltipsWrapper tooltip : tooltipsToFlush)
        {
            tooltips.remove(tooltip);
        }
    }

    public void initialize(LingeringClickTooltipsInputListener inputListener)
    {
        this.inputListener = inputListener;
        tooltips = new LinkedList<>();
        tooltipsToFlush = new LinkedList<>();
    }

    public void destroy()
    {
        inputListener = null;

        tooltips.clear();
        tooltips = null;

        tooltipsToFlush.clear();
        tooltipsToFlush = null;

        fixedLocationTooltip = null;

        infoTooltip = null;

        lastTooltipText = null;
        lastUnfilteredTooltipText = null;
        lastInfoTooltipText = null;
    }

    public void clear(String configKey)
    {
        if (!configKey.equals(OVERLAY_PREFERRED_LOCATION) && !configKey.equals(OVERLAY_PREFERRED_POSITION))
        {
            tooltips.clear();
            tooltipsToFlush.clear();
            fixedLocationTooltip = null;
        }

        if (!configKey.equals(BLACKLIST_CSV) && !configKey.equals(WHITELIST_CSV))
        {
            lastTooltipText = null;
            lastUnfilteredTooltipText = null;
            lastInfoTooltipText = null;
        }
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import ryanxie0.runelite.plugin.lingeringclicktooltips.renderable.alpha.AlphaTooltipComponent;
import ryanxie0.runelite.plugin.lingeringclicktooltips.wrapper.LingeringClickTooltipsWrapper;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Queue;
import javax.inject.Inject;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsLocation.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.fade.LingeringClickTooltipsFade.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.fade.LingeringClickTooltipsFadeUtil.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.wrapper.LingeringClickTooltipsWrapperUtil.*;

public class LingeringClickTooltipsOverlay extends Overlay
{
    @Inject
    private LingeringClickTooltipsPlugin plugin;

    @Inject
    private LingeringClickTooltipsConfig config;

    @Inject
    private Client client;

    @Inject
    private TooltipManager tooltipManager;

    private LingeringClickTooltipsInputListener inputListener;
    private LingeringClickTooltipsQueueManager queueManager;
    private LingeringClickTooltipsOverlayStateManager stateManager;

    @Inject
    LingeringClickTooltipsOverlay()
    {
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
        setPriority(OverlayPriority.HIGHEST);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        stateManager.forceDynamic();
        queueManager.flushTooltips();
        renderInfoTooltip(queueManager.getInfoTooltip(), graphics);
        if (config.tooltipLocation() == FIXED)
        {
            return renderFixedLocationTooltip(queueManager.getFixedLocationTooltip(), graphics);
        }
        else
        {
            renderTooltips(queueManager.getTooltips(), graphics);
        }
        return null;
    }

    /**
     * Renders the fixed location tooltip and returns its dimensions.
     * @param fixedLocationTooltip the fixed location tooltip from queueManager
     * @param graphics engine used to render
     * @return the dimensions of the fixed location tooltip, null if not rendered
     */
    private Dimension renderFixedLocationTooltip(LingeringClickTooltipsWrapper fixedLocationTooltip, Graphics2D graphics)
    {
        if (fixedLocationTooltip == null)
        {
            return null;
        }

        if (fixedLocationTooltip.getRenderableComponent() == null)
        {
            buildAlphaTooltipComponent(fixedLocationTooltip, client);
        }

        double alphaModifier;
        if (fixedLocationTooltip.isFaded())
        {   // fixedLocationTooltip continues to render transparent so that the overlay bounds still shows
            return fixedLocationTooltip.getRenderableComponent().render(graphics);
        }
        else if (config.permanentTooltips() || config.trackerMode())
        {
            alphaModifier = getMaximumOpacity(config);
        }
        else
        {
            alphaModifier = calculateAlphaModifier(fixedLocationTooltip, config);
        }

        return renderTooltip(fixedLocationTooltip, graphics, alphaModifier);
    }

    /**
     * Logic for preparing to render all tooltips in the queue from queueManager. Any tooltip marked as faded is
     * collected here for flushing.
     * @param tooltips the queue of tooltips currently being rendered, front of the queue is oldest
     * @param graphics engine used to render
     */
    private void renderTooltips(Queue<LingeringClickTooltipsWrapper> tooltips, Graphics2D graphics)
    {
        int queuePosition = 0;
        for (LingeringClickTooltipsWrapper tooltip : tooltips)
        {
            if (tooltip.getRenderableComponent() == null)
            {
                buildAlphaTooltipComponent(tooltip, client);
            }

            if (!tooltip.isClamped() && tooltip.getLocation() != null)
            {
                clampTooltip(tooltip, graphics);
            }

            if (queuePosition++ < config.maximumTooltipsShown())
            {
                double alphaModifier;
                if (config.permanentTooltips() || config.trackerMode())
                {
                    alphaModifier = getMaximumOpacity(config) * queuePosition / tooltips.size();
                }
                else
                {
                    alphaModifier = calculateAlphaModifier(tooltip, config);
                }
                renderTooltip(tooltip, graphics, alphaModifier);
            }

            if (tooltip.isFaded())
            {
                queueManager.addTooltipToFlush(tooltip);
            }
        }
    }

    /**
     * Logic for preparing to render the info tooltip from queueManager.
     * @param infoTooltip the info tooltip that will be rendered
     * @param graphics engine used to render
     */
    private void renderInfoTooltip(LingeringClickTooltipsWrapper infoTooltip, Graphics2D graphics)
    {
        if (infoTooltip != null)
        {
            if (!infoTooltip.isFaded())
            {
                if (infoTooltip.getRenderableComponent() == null)
                {
                    buildAlphaTooltipComponent(infoTooltip, client);
                }
                renderTooltip(infoTooltip, graphics, calculateAlphaModifier(infoTooltip, config));
            }
        }
    }

    /**
     * Performs actual rendering of tooltips. Tooltips are marked here as faded if alphaModifier is transparent.
     * @param tooltip the tooltip wrapper which is used to construct a renderable component
     * @param graphics engine used to render
     * @param alphaModifier the opacity of the tooltip
     */
    private Dimension renderTooltip(LingeringClickTooltipsWrapper tooltip, Graphics2D graphics, double alphaModifier)
    {
        if (alphaModifier > 0.0)
        {
            AlphaTooltipComponent renderableComponent = tooltip.getRenderableComponent();
            if (tooltip.isInfoTooltip() || config.tooltipLocation() == ANCHORED || config.trackerMode())
            {
                renderableComponent.setAlphaModifier(inputListener.isMouseOverCanvas()? alphaModifier : 0.0);
                tooltipManager.addFront(new Tooltip(renderableComponent));
            }
            else
            {
                renderableComponent.setAlphaModifier(alphaModifier);
                return renderableComponent.render(graphics);
            }
        }
        else
        {
            tooltip.setFaded(true);
        }
        return null;
    }

    /**
     * Clamps tooltips by first rendering an invisible component to obtain its dimensions, then setting the tooltip
     * location to the new clamped location. Sets clamped to true so that clamping is only calculated once per component.
     * @param tooltip the tooltip wrapper which is used to construct a renderable component
     * @param graphics engine used to render
     */
    private void clampTooltip(LingeringClickTooltipsWrapper tooltip, Graphics2D graphics)
    {
        AlphaTooltipComponent renderableComponent = tooltip.getRenderableComponent();
        renderableComponent.setAlphaModifier(0.0);
        Dimension dimension = renderableComponent.render(graphics);
        renderableComponent.setPosition(getClampedLocation(dimension, tooltip.getLocation(), client, config));
        tooltip.setClamped(true);
    }

    public void initialize(LingeringClickTooltipsInputListener inputListener, LingeringClickTooltipsQueueManager queueManager)
    {
        this.inputListener = inputListener;
        this.queueManager = queueManager;
        initializeStateManager();
    }

    public void destroy()
    {
        inputListener = null;
        queueManager = null;
        stateManager.destroy();
        stateManager = null;
    }

    private void initializeStateManager()
    {
        stateManager = new LingeringClickTooltipsOverlayStateManager();
        stateManager.initialize(this);
        updateFromConfig(TOOLTIP_LOCATION_CONFIG_KEY);
    }

    public void updateFromConfig(String configKey)
    {
        if (configKey.equals(TOOLTIP_LOCATION_CONFIG_KEY))
        {
            if (config.tooltipLocation() == FIXED)
            {
                stateManager.load();
            }
            else
            {
                if (!stateManager.isDynamic())
                {
                    stateManager.save(); // state should only be saved when switching off of Fixed
                }
                stateManager.setDynamic();
            }
        }
    }
}

/*
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.renderable.alpha;

import com.google.common.annotations.VisibleForTesting;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.regex.Pattern;
import lombok.Setter;
import net.runelite.api.IndexedSprite;
import net.runelite.client.ui.overlay.components.BackgroundComponent;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;

@Setter
public class AlphaTooltipComponent implements LayoutableRenderableEntity
{
	private static final Pattern BR = Pattern.compile("</br>");
	private static final int OFFSET = 4;
	private static final int MOD_ICON_WIDTH = 13; // they are generally 13px wide
	private static final Color TRANSPARENT_COLOR = new Color(0, 0, 0, 0);

	private String text;
	private Color backgroundColor = ComponentConstants.STANDARD_BACKGROUND_COLOR;
	private Point position = new Point();
	private IndexedSprite[] modIcons;
	private double alphaModifier = 1.0;

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Tooltip size
		final FontMetrics metrics = graphics.getFontMetrics();
		final int textDescent = metrics.getDescent();
		final int textHeight = metrics.getHeight();
		int tooltipWidth = 0;
		int tooltipHeight = 0;
		String[] lines = BR.split(text);

		// Calculate tooltip size
		for (String line : lines)
		{
			int textWidth = calculateTextWidth(metrics, line);

			if (textWidth > tooltipWidth)
			{
				tooltipWidth = textWidth;
			}

			tooltipHeight += textHeight;
		}

		// Tooltip position
		int x = position.x;
		int y = position.y;

		// Render tooltip - background
		final Rectangle tooltipBackground = new Rectangle(x, y,
			tooltipWidth + OFFSET * 2, tooltipHeight + OFFSET * 2);
		final BackgroundComponent backgroundComponent = new BackgroundComponent();
		backgroundComponent.setBackgroundColor(AlphaUtil.getAlphaModdedColor(backgroundColor, alphaModifier));
		backgroundComponent.setRectangle(tooltipBackground);
		backgroundComponent.render(graphics);
		graphics.setColor(Color.WHITE);

		// Render tooltip - text - line by line
		int textX = x + OFFSET;
		int textY = y + OFFSET;
		int lineX;
		final Color defaultColor = AlphaUtil.getAlphaModdedColor(Color.WHITE, alphaModifier);
		Color nextColor = defaultColor;
		for (int i = 0; i < lines.length; i++)
		{
			lineX = textX;
			final String line = lines[i];
			char[] chars = line.toCharArray();

			int begin = 0;
			boolean inTag = false;
			for (int j = 0; j < chars.length; j++)
			{
				if (chars[j] == '<')
				{
					AlphaTextComponent textComponent = new AlphaTextComponent();
					textComponent.setColor(nextColor);
					textComponent.setAlphaModifier(alphaModifier);
					String text = line.substring(begin, j);
					textComponent.setText(text);
					textComponent.setPosition(new Point(lineX, textY + (i + 1) * textHeight - textDescent));
					textComponent.render(graphics);

					lineX += metrics.stringWidth(text);

					begin = j;
					inTag = true;
				}
				else if (chars[j] == '>' && inTag)
				{
					String subLine = line.substring(begin + 1, j);

					if (subLine.startsWith("col="))
					{
						String argument = subLine.substring(4);
						nextColor = AlphaUtil.getAlphaModdedColor(Color.decode("#" + argument), alphaModifier);
					}
					else if (subLine.equals("/col"))
					{
						nextColor = defaultColor;
					}
					else if (subLine.startsWith("img="))
					{
						if (modIcons != null)
						{
							String argument = subLine.substring(4);
							int iconId = Integer.parseInt(argument);
							IndexedSprite modIcon = modIcons[iconId];
							renderModIcon(graphics, lineX, textY + i * textHeight - textDescent, modIcon);
							lineX += modIcon.getWidth();
						}
					}
					else
					{
						AlphaTextComponent textComponent = new AlphaTextComponent();
						textComponent.setColor(nextColor);
						textComponent.setAlphaModifier(alphaModifier);
						String text = line.substring(begin, j + 1);
						textComponent.setText(text);
						textComponent.setPosition(new Point(lineX, textY + (i + 1) * textHeight - textDescent));
						textComponent.render(graphics);

						lineX += metrics.stringWidth(text);
					}

					begin = j + 1;
					inTag = false;
				}
			}

			// Draw trailing text (after last tag)
			final AlphaTextComponent textComponent = new AlphaTextComponent();
			textComponent.setColor(nextColor);
			textComponent.setAlphaModifier(alphaModifier);
			textComponent.setText(line.substring(begin));
			textComponent.setPosition(new Point(lineX, textY + (i + 1) * textHeight - textDescent));
			textComponent.render(graphics);
		}

		return new Dimension(tooltipWidth + OFFSET * 2, tooltipHeight + OFFSET * 2);
	}

	@VisibleForTesting
	static int calculateTextWidth(FontMetrics metrics, String line)
	{
		char[] chars = line.toCharArray();
		int textWidth = 0;

		int begin = 0;
		boolean inTag = false;
		for (int j = 0; j < chars.length; j++)
		{
			if (chars[j] == '<')
			{
				textWidth += metrics.stringWidth(line.substring(begin, j));

				begin = j;
				inTag = true;
			}
			else if (chars[j] == '>' && inTag)
			{
				String subLine = line.substring(begin + 1, j);

				if (subLine.startsWith("img="))
				{
					textWidth += MOD_ICON_WIDTH;
				}
				else if (!subLine.startsWith("col=") && !subLine.startsWith("/col"))
				{
					textWidth += metrics.stringWidth(line.substring(begin, j + 1));
				}

				begin = j + 1;
				inTag = false;
			}
		}

		// Include trailing text (after last tag)
		textWidth += metrics.stringWidth(line.substring(begin));

		return textWidth;
	}

	private void renderModIcon(Graphics2D graphics, int x, int y, IndexedSprite modIcon)
	{
		int sourceOffset = 0;

		for (int y2 = 0; y2 < modIcon.getHeight(); y2++)
		{
			for (int x2 = 0; x2 < modIcon.getWidth(); x2++)
			{
				int index = modIcon.getPixels()[sourceOffset++] & 0xff;

				if (index != 0)
				{
					graphics.setColor(new Color(modIcon.getPalette()[index]));
					graphics.drawLine(x + x2, y + y2, x + x2, y + y2);
				}
			}
		}
	}

	@Override
	public Rectangle getBounds()
	{
		return null;
	}

	@Override
	public void setPreferredLocation(Point position)
	{
		this.position = position;
	}

	@Override
	public void setPreferredSize(Dimension dimension)
	{
	}
}

/*
 * Copyright (c) 2020, Cyborger1
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.renderable.alpha;

import java.awt.Color;

public class AlphaUtil
{
	/**
	 * Applies the given alpha modifier to the transparency of the given color.
	 * @param color The color to get the alpha modified version of.
	 * @param alphaModifier The alpha modifier.
	 * @return The alpha modified color or the passed Color object if alphaModifier == 1.0.
	 */
	public static Color getAlphaModdedColor(Color color, double alphaModifier)
	{
		if (alphaModifier == 1.0)
		{
			return color;
		}
		else
		{
			int newAlpha = (int) (color.getAlpha() * alphaModifier);
			// Clamp value to 0 - 255
			newAlpha = Math.max(0, Math.min(newAlpha, 255));

			return new Color(
				color.getRed(),
				color.getGreen(),
				color.getBlue(),
				newAlpha);
		}
	}
}

/*
 * Copyright (c) 2017, Tomas Slusny <slusnucky@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.renderable.alpha;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.util.regex.Pattern;
import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.util.Text;

@Setter
public class AlphaTextComponent implements RenderableEntity
{
	private static final String COL_TAG_REGEX = "(<col=([0-9a-fA-F]){2,6}>)";
	private static final Pattern COL_TAG_PATTERN_W_LOOKAHEAD = Pattern.compile("(?=" + COL_TAG_REGEX + ")");

	private String text;
	private Point position = new Point();
	private Color color = Color.WHITE;
	private boolean outline;
	private double alphaModifier = 1.0;

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final FontMetrics fontMetrics = graphics.getFontMetrics();
		final Color shadowColor = AlphaUtil.getAlphaModdedColor(Color.BLACK, alphaModifier);

		if (COL_TAG_PATTERN_W_LOOKAHEAD.matcher(text).find())
		{
			final String[] parts = COL_TAG_PATTERN_W_LOOKAHEAD.split(text);
			int x = position.x;

			for (String textSplitOnCol : parts)
			{
				final String textWithoutCol = Text.removeTags(textSplitOnCol);
				final String colColor = textSplitOnCol.substring(textSplitOnCol.indexOf("=") + 1, textSplitOnCol.indexOf(">"));

				graphics.setColor(shadowColor);

				if (outline)
				{
					graphics.drawString(textWithoutCol, x, position.y + 1);
					graphics.drawString(textWithoutCol, x, position.y - 1);
					graphics.drawString(textWithoutCol, x + 1, position.y);
					graphics.drawString(textWithoutCol, x - 1, position.y);
				}
				else
				{
					// shadow
					graphics.drawString(textWithoutCol, x + 1, position.y + 1);
				}

				// actual text
				graphics.setColor(AlphaUtil.getAlphaModdedColor(Color.decode("#" + colColor), alphaModifier));
				graphics.drawString(textWithoutCol, x, position.y);

				x += fontMetrics.stringWidth(textWithoutCol);
			}
		}
		else
		{
			graphics.setColor(shadowColor);

			if (outline)
			{
				graphics.drawString(text, position.x, position.y + 1);
				graphics.drawString(text, position.x, position.y - 1);
				graphics.drawString(text, position.x + 1, position.y);
				graphics.drawString(text, position.x - 1, position.y);
			}
			else
			{
				// shadow
				graphics.drawString(text, position.x + 1, position.y + 1);
			}

			// actual text
			graphics.setColor(AlphaUtil.getAlphaModdedColor(color, alphaModifier));
			graphics.drawString(text, position.x, position.y);
		}

		return new Dimension(fontMetrics.stringWidth(text), fontMetrics.getHeight());
	}
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.wrapper;

import net.runelite.api.Client;
import ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsConfig;
import ryanxie0.runelite.plugin.lingeringclicktooltips.renderable.alpha.AlphaTooltipComponent;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.time.Duration;
import java.time.Instant;

import static ryanxie0.runelite.plugin.lingeringclicktooltips.LingeringClickTooltipsLocation.*;
import static ryanxie0.runelite.plugin.lingeringclicktooltips.fade.LingeringClickTooltipsFadeConstants.*;

public class LingeringClickTooltipsWrapperUtil {

    /**
     * @param tooltipText the text of the tooltip, includes color tags and the full action as seen by the user
     * @param location the location of the tooltip, includes config offset but NOT clamping (clamp is handled by the overlay as it requires Dimension)
     * @param backgroundColor the background color of the tooltip as chosen by the various different sources, see LingeringClickTooltipsColorUtil.java
     * @param isInfoTooltip whether the tooltip is an info tooltip, used later for determining adjusted duration, fadeout, permanence bypass, etc.
     * @return the tooltip wrapper which is used to construct a renderable component
     */
    public static LingeringClickTooltipsWrapper buildTooltipWrapper(
        String tooltipText,
        Point location,
        Color backgroundColor,
        boolean isInfoTooltip,
        LingeringClickTooltipsConfig config
    )
    {
        LingeringClickTooltipsWrapper tooltipWrapper = new LingeringClickTooltipsWrapper();
        tooltipWrapper.setFaded(false);
        tooltipWrapper.setInfoTooltip(isInfoTooltip);
        tooltipWrapper.setClamped(false);
        tooltipWrapper.setText(tooltipText);
        tooltipWrapper.setBackgroundColor(backgroundColor);
        tooltipWrapper.setTimeOfCreation(Instant.now());
        tooltipWrapper.setLocation(location);
        tooltipWrapper.setTooltipDuration(calculateTotalTooltipDuration(isInfoTooltip, config));
        return tooltipWrapper;
    }

    /**
     * This method returns tooltip text = option when target is empty (i.e. there was no target) or if target == option.
     * The latter case is meant to avoid confusing text for actions such as a use initiate, where the text would
     * otherwise appear as "Use Use".
     * @param option the menu option selected by the user, e.g. "Walk here"
     * @param target the menu target selected by the user, e.g. "Door" or "Tree"
     * @return the tooltip text produced by combining the option and the target
     */
    public static String getRawTooltipText(String option, String target)
    {
        String tooltipText = option + (target.equals("") || option.equals(target) ? "" : " " + target);
        tooltipText = tooltipText.replaceAll("\\s+$", ""); // trim any trailing whitespace
        return tooltipText;
    }

    /**
     * This method returns null for cases where location is not necessary, e.g. tooltips handled by the TooltipManager.
     * A null location is later used to avoid further unnecessary calculations regarding tooltip location.
     * @param location the exact location of the click input by the user
     * @param config the configuration settings for the plugin
     * @return location adjusted according to the offsets specified by the user in the config
     */
    public static Point getOffsetLocation(Point location, LingeringClickTooltipsConfig config)
    {
        if (config.tooltipLocation() == ANCHORED || config.trackerMode() || config.tooltipLocation() == FIXED)
        {
            return null;
        }
        location.translate(config.tooltipXOffset(), config.tooltipYOffset());
        return location;
    }

    /**
     * Calculates the total tooltip duration accounting for various different factors.
     * @param isInfoTooltip whether the tooltip is an info tooltip
     * @param config the configuration settings for the plugin
     * @return the total tooltip duration
     */
    public static Duration calculateTotalTooltipDuration(boolean isInfoTooltip, LingeringClickTooltipsConfig config)
    {
        int totalTooltipDuration = config.tooltipDuration();
        if (isInfoTooltip)
        {
            totalTooltipDuration *= INFO_TOOLTIP_MULTIPLIER;
        }
        else if (config.fastMode())
        {
            totalTooltipDuration /= FAST_MODE_MULTIPLIER;
        }

        if (config.tooltipFadeIn() > 0)
        {
            totalTooltipDuration += totalTooltipDuration * config.tooltipFadeIn() / 100.0;
        }
        if (config.tooltipFadeout() > 0)
        {
            totalTooltipDuration += totalTooltipDuration * config.tooltipFadeout() / 100.0;
        }
        return Duration.ofMillis(totalTooltipDuration);
    }

    /**
     * This method ensures that tooltips do not render offscreen/cutoff by providing the location at which the tooltip
     * can render while remaining within the specified boundaries. It applies only to tooltips which are not
     * anchored, i.e. handled by TooltipManager.
     * @param dimension the dimension of the component, contains the necessary height and width of the tooltips
     * @param location the location the component would like to render at
     * @param client the RuneLite client API, contains the necessary height and width of the canvas
     * @param config the configuration settings for the plugin
     * @return the adjusted location of the tooltip accounting for component dimension/location, canvas dimensions, and padding
     */
    public static Point getClampedLocation(Dimension dimension, Point location, Client client, LingeringClickTooltipsConfig config)
    {
        int clampedX = location.x;
        int clampedY = location.y;

        int xPadding = config.clampXPadding();
        int yPadding = config.clampYPadding();

        int xMax = client.getCanvasWidth();
        int yMax = client.getCanvasHeight();

        if (clampedX < xPadding)
        {
            clampedX = xPadding;
        }
        else if (clampedX + dimension.width + xPadding > xMax)
        {
            clampedX = xMax - dimension.width - xPadding;
        }

        if (clampedY < yPadding)
        {
            clampedY = yPadding;
        }
        else if (clampedY + dimension.height + yPadding > yMax)
        {
            clampedY = yMax - dimension.height - yPadding;
        }

        return new Point(clampedX, clampedY);
    }

    /**
     * Used to build the renderable component, called once per new tooltip wrapper. It does not need to set the alpha
     * modifier because the rendering code calculates and sets the alpha just before calling render.
     * @param tooltip the tooltip wrapper which is used to construct a renderable component
     * @param client the RuneLite client API
     */
    public static void buildAlphaTooltipComponent(LingeringClickTooltipsWrapper tooltip, Client client)
    {
        AlphaTooltipComponent alphaTooltipComponent = new AlphaTooltipComponent();
        alphaTooltipComponent.setText(tooltip.getText());
        alphaTooltipComponent.setModIcons(client.getModIcons());
        alphaTooltipComponent.setBackgroundColor(tooltip.getBackgroundColor());
        if (tooltip.getLocation() != null)
        {
            alphaTooltipComponent.setPosition(tooltip.getLocation());
        }
        tooltip.setRenderableComponent(alphaTooltipComponent);
    }
}

/*
 * Copyright (c) 2021, Ryan Xie <ryanlxie@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ryanxie0.runelite.plugin.lingeringclicktooltips.wrapper;

import lombok.Data;
import ryanxie0.runelite.plugin.lingeringclicktooltips.renderable.alpha.AlphaTooltipComponent;

import java.awt.Point;
import java.awt.Color;
import java.time.Duration;
import java.time.Instant;

@Data
public class LingeringClickTooltipsWrapper {
    private boolean isFaded;
    private boolean isInfoTooltip;
    private boolean isClamped;
    private String text;
    private Color backgroundColor;
    private Instant timeOfCreation;
    private Point location;
    private AlphaTooltipComponent renderableComponent;
    private Duration tooltipDuration;
}

