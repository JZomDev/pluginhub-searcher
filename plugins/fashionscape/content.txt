package eq.uirs.fashionscape;

import com.google.inject.Provides;
import eq.uirs.fashionscape.core.Exporter;
import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.data.anim.ItemInteractions;
import eq.uirs.fashionscape.panel.FashionscapePanel;
import java.awt.image.BufferedImage;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Provider;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.PlayerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(
	name = "Fashionscape",
	description = "Previews combinations of equipment by changing the player's local appearance"
)
@Slf4j
public class FashionscapePlugin extends Plugin
{
	private static final Pattern PAREN_REPLACE = Pattern.compile("\\(.*\\)");

	private static final String COPY_PLAYER = "Copy-outfit";
	private static final Set<Integer> ITEM_ID_DUPES = new HashSet<>();

	// combined set of all items to skip when searching (bad items, dupes, non-standard if applicable)
	public static Set<Integer> getItemIdsToExclude(FashionscapeConfig config)
	{
		Set<Integer> result = ITEM_ID_DUPES;
		result.addAll(ItemInteractions.BAD_ITEM_IDS);
		if (config.excludeNonStandardItems())
		{
			result.addAll(ItemInteractions.NON_STANDARD_ITEMS);
		}
		return result;
	}

	private static String stripName(String name)
	{
		String noParens = PAREN_REPLACE.matcher(name).replaceAll("");
		return noParens.replaceAll("[^A-Za-z]+", "");
	}

	@Value
	private static class ItemDupeData
	{
		int modelId;
		short[] colorsToReplace;
		short[] texturesToReplace;
		String strippedName;
	}

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ItemManager itemManager;

	@Inject
	private FashionManager fashionManager;

	@Inject
	private Exporter exporter;

	@Inject
	private FashionscapeConfig config;

	@Inject
	private Provider<MenuManager> menuManager;

	private FashionscapePanel panel;
	private NavigationButton navButton;

	@Provides
	FashionscapeConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FashionscapeConfig.class);
	}

	@Override
	protected void startUp()
	{
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "panelicon.png");
		panel = injector.getInstance(FashionscapePanel.class);
		navButton = NavigationButton.builder()
			.tooltip("Fashionscape")
			.icon(icon)
			.panel(panel)
			.priority(8)
			.build();
		clientToolbar.addNavigation(navButton);
		refreshMenuEntries();
		clientThread.invokeLater(() -> {
			populateDupes();
			fashionManager.startUp();
		});
	}

	@Override
	protected void shutDown()
	{
		menuManager.get().removePlayerMenuItem(COPY_PLAYER);
		clientThread.invokeLater(() -> fashionManager.shutDown());
		clientToolbar.removeNavigation(navButton);
		ITEM_ID_DUPES.clear();
	}

	@Subscribe
	public void onPlayerChanged(PlayerChanged event)
	{
		Player player = event.getPlayer();
		if (player != null && player == client.getLocalPlayer())
		{
			fashionManager.onPlayerChanged();
			if (panel != null)
			{
				panel.onPlayerChanged(player);
			}
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getContainerId() == InventoryID.WORN)
		{
			fashionManager.onEquipmentChanged();
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(FashionscapeConfig.GROUP))
		{
			if (event.getKey().equals(FashionscapeConfig.KEY_EXCLUDE_NON_STANDARD) ||
				event.getKey().equals(FashionscapeConfig.KEY_EXCLUDE_MEMBERS))
			{
				// reload displayed results
				clientThread.invokeLater(() -> {
					populateDupes();
					panel.reloadResults();
					panel.refreshKitsPanel();
				});
			}
			else if (event.getKey().equals(FashionscapeConfig.KEY_IMPORT_MENU_ENTRY))
			{
				refreshMenuEntries();
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			populateDupes();
			fashionManager.onEquipmentChanged();
		}
		else if (event.getGameState() == GameState.LOGIN_SCREEN)
		{
			fashionManager.setGender(null);
		}
		if (panel != null)
		{
			panel.onGameStateChanged(event);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals(COPY_PLAYER))
		{
			Player p = client.getTopLevelWorldView().players().byIndex(event.getId());
			if (p == null)
			{
				return;
			}
			exporter.importPlayer(p.getPlayerComposition());
			panel.reloadResults();
		}
	}

	private void populateDupes()
	{
		ITEM_ID_DUPES.clear();
		Set<Integer> ids = new HashSet<>();
		Set<ItemDupeData> itemUniques = new HashSet<>();
		Set<Integer> skips = FashionscapePlugin.getItemIdsToExclude(config);
		for (int i = 0; i < client.getItemCount(); i++)
		{
			int canonical = itemManager.canonicalize(i);
			if (skips.contains(canonical))
			{
				continue;
			}
			ItemComposition itemComposition = itemManager.getItemComposition(canonical);
			String itemName = itemComposition.getMembersName().toLowerCase();
			boolean badItemName = ItemInteractions.BAD_ITEM_NAMES.contains(itemName);
			boolean membersObject = config.excludeMembersItems() && itemComposition.isMembers();
			if (badItemName || membersObject)
			{
				ITEM_ID_DUPES.add(canonical);
				continue;
			}
			ItemStats itemStats = itemManager.getItemStats(canonical);
			if (!ids.contains(itemComposition.getId()) && itemStats != null && itemStats.isEquipable())
			{
				ItemDupeData itemDupeData = new ItemDupeData(
					itemComposition.getInventoryModel(),
					itemComposition.getColorToReplaceWith(),
					itemComposition.getTextureToReplaceWith(),
					stripName(itemName)
				);
				if (itemUniques.contains(itemDupeData))
				{
					ITEM_ID_DUPES.add(canonical);
					continue;
				}
				itemUniques.add(itemDupeData);
				ids.add(itemComposition.getId());
			}
		}
	}

	private void refreshMenuEntries()
	{
		if (config.copyMenuEntry())
		{
			menuManager.get().addPlayerMenuItem(COPY_PLAYER);
		}
		else
		{
			menuManager.get().removePlayerMenuItem(COPY_PLAYER);
		}
	}

}

package eq.uirs.fashionscape.data.anim;

import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableSet;
import eq.uirs.fashionscape.data.kit.ArmsKit;
import eq.uirs.fashionscape.data.kit.BootsKit;
import eq.uirs.fashionscape.data.kit.Kit;
import eq.uirs.fashionscape.data.kit.LegsKit;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import net.runelite.api.ItemID;

public class ItemInteractions
{
	/**
	 * broken items which don't have models or have placeholder models
	 */
	public static final Set<Integer> BAD_ITEM_IDS = ImmutableSet.of(
		286, 287, 288, 1410, 2513, 4024, 4025, 4026, 4027, 4028, 4029, 4030, 4031, 4284, 4285, 7957, 9054, 9055, 9056,
		9057, 9058, 9059, 10595, 10596, 10888, 11165, 11167, 19525, 24265, 24619, 25155, 25582, 25584, 25958, 25959,
		25960, 25961, 25969, 25971, 25983, 25987, 25989, 25973, 26217, 26237, 26239, 26376, 26378, 26380, 26526, 26567,
		26686, 26687, 26688, 26689, 26690, 26691, 26692, 26693, 26694, 26695, 26698, 26699, 26700, 26701, 26702, 26703,
		// inactive corrupted bh armor sets (vesta, statius, zuriel, morrigan)
		27965, 27968, 27971, 27974, 27977, 27980, 27983, 27986, 27989, 27992, 27995,
		28813, 29055, 29064, 29073, 29277
	);

	/**
	 * items which are always hidden (icons are hidden because they have their own dedicated slots which don't
	 * go through item manager)
	 */
	public static final Set<String> BAD_ITEM_NAMES = ImmutableSet.of("attacker icon", "defender icon",
		"collector icon", "healer icon", "red icon", "blue icon");

	/**
	 * items that cannot be normally obtained/equipped in the overworld, also includes degraded/redundant items
	 */
	public static final Set<Integer> NON_STANDARD_ITEMS = ImmutableSet.of(
		945, 1235, 3839, 3841, 3843, 4041, 4042, 4083, 4084, 4181, 4692, 4860, 4866, 4868, 4872, 4878, 4884, 4890, 4896,
		4902, 4908, 4914, 4920, 4926, 4932, 4938, 4944, 4950, 4956, 4962, 4968, 4974, 4980, 4986, 4992, 4998, 5607,
		5608, 5609, 5732, 6122, 6123, 7414, 7671, 7673, 7675, 7679, 7682, 7684, 7686, 7756, 7804, 7806, 7807, 7808,
		7809, 8856, 8860, 8861, 8862, 8863, 8864, 8871, 9660, 9702, 10023, 10024, 10500, 10556, 10557, 10558, 10559,
		10567, 10840, 10841, 12607, 12609, 12611, 13080, 13195, 20802, 21433, 21539, 22308, 22309, 22310, 22311, 22312,
		22313, 22314, 22315, 22331, 22333, 22335, 22337, 22338, 22339, 22340, 22341, 22342, 22343, 22344, 22345, 22346,
		22347, 22348, 22349, 22516, 22610, 22613, 22616, 22619, 22622, 22625, 22628, 22631, 22634, 22636, 22638, 22641,
		22644, 22647, 22650, 22653, 22656, 22721, 22722, 22723, 22724, 22725, 22726, 22727, 22728, 22729, 22730, 22816,
		22817, 23460, 23461, 23462, 23463, 23464, 23465, 23466, 23467, 23468, 23469, 23470, 23471, 23472, 23473, 23474,
		23475, 23476, 23477, 23478, 23479, 23480, 23481, 23482, 23483, 23484, 23485, 23486, 23820, 23821, 23822, 23823,
		23840, 23841, 23842, 23843, 23844, 23845, 23846, 23847, 23848, 23849, 23850, 23851, 23852, 23853, 23854, 23855,
		23856, 23857, 23861, 23886, 23887, 23888, 23889, 23890, 23891, 23892, 23893, 23894, 23895, 23896, 23897, 23898,
		23899, 23900, 23901, 23902, 23903, 23907, 25106, 25108, 25282, 26695, 26696, 26708, 26710, 26712, 26714, 26715,
		26716, 26718, 26719, 26720, 26721, 26722, 26723, 26724, 26725, 26726, 26879, 27010, 27100, 27115, 27117, 27119,
		27123, 27125, 27127, 28363
	);

	/**
	 * item ids of helm-slot items that DON'T hide the player's hair
	 * TODO can get these from wearpos in item definitions
	 */
	public static final Set<Integer> HAIR_HELMS = ImmutableSet.of(
		579, 656, 658, 660, 662, 664, 1017, 1025, 1037, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1949, 2581, 2631,
		2633, 2635, 2637, 2639, 2641, 2643, 2645, 2647, 2649, 2651, 2900, 2910, 2920, 2930, 2940, 2978, 2979, 2980,
		2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 3057, 3327, 3329,
		3331, 3333, 3335, 3337, 3339, 3341, 3343, 3385, 3797, 4089, 4099, 4109, 4164, 4166, 4168, 4284, 4285, 5013,
		5014, 5525, 5527, 5529, 5531, 5533, 5535, 5537, 5539, 5541, 5543, 5545, 5547, 5549, 6182, 6335, 6337, 6339,
		6345, 6355, 6365, 6375, 6382, 6547, 6548, 6656, 6665, 6856, 6858, 6860, 6862, 6918, 7319, 7321, 7323, 7325,
		7327, 7394, 7396, 7917, 8860, 8861, 8862, 8863, 8864, 8901, 8903, 8905, 8907, 8909, 8911, 8913, 8915, 8917,
		8919, 8921, 8928, 8950, 8959, 8960, 8961, 8962, 8963, 8964, 8965, 9068, 9106, 9472, 9660, 9729, 9733, 10172,
		10556, 10557, 10558, 10559, 10567, 10836, 10862, 11280, 11282, 11774, 11775, 11776, 11777, 11778, 11779, 11780,
		11781, 11782, 11783, 11784, 11862, 11863, 11898, 11990, 12013, 12247, 12299, 12301, 12303, 12305, 12307, 12309,
		12311, 12313, 12319, 12321, 12323, 12325, 12337, 12351, 12353, 12355, 12359, 12397, 12399, 12412, 12419, 12432,
		12434, 12453, 12455, 12457, 12516, 12540, 12600, 12637, 12638, 12639, 12855, 12856, 13137, 13203, 13258, 13343,
		13344, 13385, 13646, 13647, 13655, 19724, 19727, 19988, 20008, 20053, 20205, 20246, 20562, 20568, 20802, 21211,
		21859, 22121, 22308, 22309, 22310, 22311, 22312, 22313, 22314, 22315, 22337, 22338, 22339, 22340, 22341, 22342,
		22343, 22344, 22345, 22346, 22347, 22348, 22349, 22664, 22665, 22666, 22721, 22722, 22723, 22724, 22725, 22726,
		22727, 22728, 22729, 22730, 23047, 23255, 23312, 23460, 23461, 23462, 23463, 23464, 23465, 23466, 23467, 23468,
		23469, 23470, 23471, 23472, 23473, 23474, 23475, 23476, 23477, 23478, 23479, 23480, 23481, 23482, 23483, 23484,
		23485, 23486, 23522, 23911, 23913, 23915, 23917, 23919, 23921, 23923, 23925, 24165, 24169, 24170, 24171, 24192,
		24194, 24195, 24197, 24198, 24200, 24201, 24203, 24204, 24206, 24288, 24338, 24340, 24342, 24344, 24346, 24348,
		24387, 24397, 24405, 24525, 24527, 24872, 24942, 25212, 25213, 25214, 25215, 25216, 25217, 25218, 25219, 25220,
		25221, 25222, 25223, 25224, 25225, 25226, 25227, 25228, 25229, 25230, 25231, 25232, 25233, 25234, 25235, 25236,
		25237, 25238, 25239, 25240, 25241, 25242, 25243, 25398, 25413, 25438, 25549, 25592, 25840, 26254, 26312, 26531,
		26788, 26801, 26804, 26937, 26963, 26967, 27035, 27123, 27141, 27143, 27145, 27147, 27149, 27151, 27153, 27155,
		27576, 27584, 27588, 27804, 27828, 27875, 27877, 28603, 28605, 28607, 28609, 28611, 28620, 28655, 28712, 28724,
		28736, 29010, 29019, 29028, 29263, 29443
	);

	/**
	 * item ids of helm-slot items that DO hide the player's jaw
	 * TODO can get these from wearpos in item definitions
	 */
	public static final Set<Integer> NO_JAW_HELMS = ImmutableSet.of(
		1053, 1055, 1057, 1153, 1155, 1157, 1159, 1161, 1163, 1165, 1506, 2587, 2595, 2605, 2613, 2619, 2627, 2657,
		2665, 2673, 3057, 3486, 4164, 4551, 4611, 4724, 4732, 4745, 4753, 4904, 4905, 4906, 4907, 4908, 4928, 4929,
		4930, 4931, 4932, 4952, 4953, 4954, 4955, 4956, 4976, 4977, 4978, 4979, 4980, 5554, 5574, 6188, 6623, 7534,
		7594, 8464, 8466, 8468, 8470, 8472, 8474, 8476, 8478, 8480, 8482, 8484, 8486, 8488, 8490, 8492, 8494, 8682,
		8684, 8686, 8688, 8690, 8692, 8694, 8696, 8698, 8700, 8702, 8704, 8706, 8708, 8710, 8712, 9096, 9629, 9672,
		9920, 10567, 11282, 11335, 11847, 11850, 11864, 11865, 11919, 12211, 12221, 12231, 12241, 12249, 12251, 12283,
		12293, 12363, 12365, 12367, 12369, 12371, 12417, 12466, 12476, 12486, 12518, 12520, 12522, 12524, 12810, 12813,
		12845, 12887, 12892, 12929, 12931, 13140, 13196, 13197, 13198, 13199, 13283, 13359, 13364, 13369, 13374, 13379,
		13579, 13591, 13603, 13615, 13627, 13667, 19639, 19641, 19643, 19645, 19647, 19649, 19915, 19988, 20020, 20023,
		20026, 20029, 20032, 20035, 20080, 20095, 20178, 20193, 20266, 20269, 20561, 20563, 20595, 20708, 20773, 20792,
		20802, 20838, 21061, 21264, 21266, 21298, 21720, 21847, 21888, 21890, 22159, 22161, 22163, 22165, 22167, 22169,
		22171, 22173, 22175, 22177, 22179, 22181, 22183, 22185, 22187, 22189, 22308, 22309, 22310, 22311, 22312, 22313,
		22314, 22315, 22326, 22337, 22338, 22339, 22340, 22341, 22342, 22343, 22344, 22345, 22346, 22347, 22348, 22349,
		22689, 22713, 22721, 22722, 22723, 22724, 22725, 22726, 22727, 22728, 22729, 22730, 23073, 23075, 23101, 23252,
		23270, 23273, 23448, 23460, 23461, 23462, 23463, 23464, 23465, 23466, 23467, 23468, 23469, 23470, 23471, 23472,
		23473, 23474, 23475, 23476, 23477, 23478, 23479, 23480, 23481, 23482, 23483, 23484, 23485, 23486, 23785, 23840,
		23841, 23842, 23886, 23887, 23888, 23971, 23973, 24034, 24271, 24305, 24315, 24342, 24344, 24346, 24348, 24370,
		24419, 24444, 24743, 24975, 25069, 25165, 25169, 25174, 25176, 25212, 25213, 25214, 25215, 25216, 25217, 25218,
		25219, 25220, 25221, 25222, 25223, 25224, 25225, 25226, 25227, 25228, 25229, 25230, 25231, 25232, 25233, 25234,
		25235, 25236, 25237, 25238, 25239, 25240, 25241, 25242, 25243, 25336, 25898, 25900, 25902, 25904, 25906, 25908,
		25910, 25912, 25914, 26225, 26241, 26382, 26427, 26439, 26451, 26731, 26733, 26735, 26741, 26745, 26747, 27119,
		27226, 27235, 27705, 27707, 27717, 27719, 27729, 27731, 27741, 27743, 27753, 27755, 27765, 27767, 27777, 27779,
		28254, 28788, 29560, 29566
	);

	/**
	 * item ids of torso-slot items that DON'T hide the player's arms
	 * TODO can get these from wearpos in item definitions
	 */
	public static final Set<Integer> ARMS_TORSOS = ImmutableSet.of(
		1005, 1101, 1103, 1105, 1107, 1109, 1111, 1113, 1129, 1131, 1133, 1135, 1757, 2499, 2501, 2503, 2513, 6615,
		7110, 7122, 7128, 7134, 7362, 7364, 7370, 7372, 7374, 7376, 7592, 7957, 12327, 12331, 12381, 12385, 20149,
		20208, 20417, 20423, 20566, 23264, 23381
	);

	/**
	 * kit ids of boot-slot items that, when detected in-game, will disable the boots, weapon and shield slots
	 */
	public static final Set<Integer> DISABLE_BOOT_KITS = ImmutableSet.of(BootsKit.MINECART.getKitId(0),
		BootsKit.MINECART.getKitId(1));

	/**
	 * item ids of weapon-slot items that, when detected in-game, will disable the weapon and shield slots
	 */
	public static final Set<Integer> DISABLE_WEAPONS = ImmutableSet.of(ItemID.MAGIC_CARPET);

	// region Gender Swap Kits

	// roughly corresponding kits that don't share the same name
	public static final BiMap<Kit, Kit> GENDER_MIRRORED_KITS;

	static
	{
		Map<Kit, Kit> mToF = new HashMap<>();
		// TODO review
		mToF.put(ArmsKit.REGULAR, ArmsKit.SHORT_SLEEVES);
		mToF.put(ArmsKit.MUSCLEBOUND, ArmsKit.MUSCLEY);
		mToF.put(ArmsKit.LOOSE_SLEEVED, ArmsKit.FRILLY_A);
		mToF.put(ArmsKit.LARGE_CUFFED, ArmsKit.LARGE_CUFFS);
		mToF.put(ArmsKit.THIN, ArmsKit.LONG_SLEEVED);
		mToF.put(ArmsKit.SHOULDER_PADS, ArmsKit.BARE_ARMS);
		mToF.put(ArmsKit.THICK_STRIPE, ArmsKit.SWEATER_A);
		mToF.put(ArmsKit.RIPPED, ArmsKit.BARE_SHOULDERS);
		mToF.put(LegsKit.SHORTS, LegsKit.SHORT_SKIRT);
		mToF.put(LegsKit.RIPPED_L, LegsKit.TORN_SKIRT);
		mToF.put(LegsKit.PATCHED, LegsKit.PATCHED_SKIRT);
		GENDER_MIRRORED_KITS = new ImmutableBiMap.Builder<Kit, Kit>()
			.putAll(mToF)
			.build();
	}

	// endregion

	// region Weapons

	/**
	 * Weapon item id mapped to its idle animation id (if not present, anim id is the default 808)
	 */
	public static final Map<Integer, Integer> WEAPON_TO_IDLE = new HashMap<>();

	static
	{
		WEAPON_TO_IDLE.put(ItemID.BLURITE_SWORD, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.PHOENIX_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.DRAMEN_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.POISONED_DAGGERP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_LONGSWORD, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.IRON_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.STEEL_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLACK_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.RUNE_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_AIR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_WATER, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_EARTH, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_FIRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MAGIC_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.FIRE_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.WATER_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.AIR_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.EARTH_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_FIRE_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_WATER_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_AIR_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_EARTH_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IBANS_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IBANS_STAFF_1410, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SCYTHE, IdleAnimationID.HALLOWEEN_SCYTHE);
		WEAPON_TO_IDLE.put(ItemID.LAVA_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_LAVA_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLACK_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.PET_ROCK, IdleAnimationID.PET_ROCK);
		WEAPON_TO_IDLE.put(ItemID.SARADOMIN_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.ZAMORAK_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.SLED, IdleAnimationID.SLED);
		WEAPON_TO_IDLE.put(ItemID.SLED_4084, IdleAnimationID.SLED);
		WEAPON_TO_IDLE.put(ItemID.GRANITE_MAUL, IdleAnimationID.GRANITE_MAUL);
		WEAPON_TO_IDLE.put(ItemID.LEAFBLADED_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SLAYERS_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.EASTER_BASKET, IdleAnimationID.EASTER_BASKET);
		WEAPON_TO_IDLE.put(ItemID.RUBBER_CHICKEN, IdleAnimationID.RUBBER_CHICKEN);
		WEAPON_TO_IDLE.put(ItemID.BLACK_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLACK_SPEARP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLACK_SPEARKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ANCIENT_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.AHRIMS_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DHAROKS_GREATAXE, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.GUTHANS_WARSPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.KARILS_CROSSBOW, IdleAnimationID.KARILS_CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.VERACS_FLAIL, IdleAnimationID.VERACS_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.AHRIMS_STAFF_100, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.AHRIMS_STAFF_75, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.AHRIMS_STAFF_50, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.AHRIMS_STAFF_25, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.AHRIMS_STAFF_0, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DHAROKS_GREATAXE_100, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.DHAROKS_GREATAXE_75, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.DHAROKS_GREATAXE_50, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.DHAROKS_GREATAXE_25, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.DHAROKS_GREATAXE_0, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.GUTHANS_WARSPEAR_100, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GUTHANS_WARSPEAR_75, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GUTHANS_WARSPEAR_50, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GUTHANS_WARSPEAR_25, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GUTHANS_WARSPEAR_0, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.KARILS_CROSSBOW_100, IdleAnimationID.KARILS_CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.KARILS_CROSSBOW_0, IdleAnimationID.KARILS_CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.VERACS_FLAIL_100, IdleAnimationID.VERACS_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.VERACS_FLAIL_75, IdleAnimationID.VERACS_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.VERACS_FLAIL_50, IdleAnimationID.VERACS_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.VERACS_FLAIL_25, IdleAnimationID.VERACS_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.VERACS_FLAIL_0, IdleAnimationID.VERACS_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.BONE_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MAGIC_CARPET, IdleAnimationID.MAGIC_CARPET);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_SPEARP_5704, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_SPEARP_5706, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_SPEARP_5708, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_SPEARP_5710, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_SPEARP_5712, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_SPEARP_5714, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_SPEARP_5716, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_SPEARP_5718, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_SPEARP_5720, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_SPEARP_5722, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_SPEARP_5724, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_SPEARP_5726, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_SPEARP_5728, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_SPEARP_5730, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLACK_SPEARP_5734, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLACK_SPEARP_5736, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.FIXED_DEVICE, IdleAnimationID.OVERHEAD_LAUNCHER);
		WEAPON_TO_IDLE.put(ItemID.TOKTZMEJTAL, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TZHAARKETOM, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.MUD_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_MUD_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.WHITE_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.WHITE_MAGIC_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.WHITE_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.GUTHIX_MJOLNIR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SARADOMIN_MJOLNIR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ZAMORAK_MJOLNIR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RAT_POLE, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.RAT_POLE_6774, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.RAT_POLE_6775, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.RAT_POLE_6776, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.RAT_POLE_6777, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.RAT_POLE_6778, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.RAT_POLE_6779, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BEGINNER_WAND, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.APPRENTICE_WAND, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TEACHER_WAND, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MASTER_WAND, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.MUD_PIE, IdleAnimationID.CHINCHOMPA);
		WEAPON_TO_IDLE.put(ItemID.SPATULA, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.MEAT_TENDERISER, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_10, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_9, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_8, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_7, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_6, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_5, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_4, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_3, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_2, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROD_OF_IVANDIS_1, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GADDERHAMMER, IdleAnimationID.GRANITE_MAUL);
		WEAPON_TO_IDLE.put(ItemID.BOXING_GLOVES, IdleAnimationID.BOXING_GLOVES);
		WEAPON_TO_IDLE.put(ItemID.BOXING_GLOVES_7673, IdleAnimationID.BOXING_GLOVES);
		WEAPON_TO_IDLE.put(ItemID.ANGER_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8652, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8654, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8656, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8658, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8660, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8662, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8664, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8666, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8668, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8670, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8672, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8674, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8676, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8678, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BANNER_8680, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.CRATE_WITH_ZANIK, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.DORGESHUUN_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.CUTTHROAT_FLAG, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.GILDED_SMILE_FLAG, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_FIST_FLAG, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.LUCKY_SHOT_FLAG, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.TREASURE_FLAG, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.PHASMATYS_FLAG, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.SKULL_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.PHARAOHS_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.LUNAR_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.LUNAR_STAFF__PT1, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.LUNAR_STAFF__PT2, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.LUNAR_STAFF__PT3, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.BLURITE_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.IRON_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.STEEL_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.RUNE_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.BUTTERFLY_NET, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.FALCONERS_GLOVE_10024, IdleAnimationID.FALCON);
		WEAPON_TO_IDLE.put(ItemID.CHINCHOMPA_10033, IdleAnimationID.CHINCHOMPA);
		WEAPON_TO_IDLE.put(ItemID.RED_CHINCHOMPA_10034, IdleAnimationID.CHINCHOMPA);
		WEAPON_TO_IDLE.put(ItemID.ORANGE_SALAMANDER, IdleAnimationID.SALAMANDER);
		WEAPON_TO_IDLE.put(ItemID.RED_SALAMANDER, IdleAnimationID.SALAMANDER);
		WEAPON_TO_IDLE.put(ItemID.BLACK_SALAMANDER, IdleAnimationID.SALAMANDER);
		WEAPON_TO_IDLE.put(ItemID.SWAMP_LIZARD, IdleAnimationID.SALAMANDER);
		WEAPON_TO_IDLE.put(ItemID.NOOSE_WAND, IdleAnimationID.NOOSE_WAND);
		WEAPON_TO_IDLE.put(ItemID.HUNTERS_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.WILLOW_COMP_BOW, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.YEW_COMP_BOW, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MAGIC_COMP_BOW, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SARADOMIN_CROZIER, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GUTHIX_CROZIER, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ZAMORAK_CROZIER, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.UNDEAD_CHICKEN, IdleAnimationID.UNDEAD_CHICKEN);
		WEAPON_TO_IDLE.put(ItemID.SHADOW_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BARRELCHEST_ANCHOR, IdleAnimationID.BARRELCHEST_ANCHOR);
		WEAPON_TO_IDLE.put(ItemID.BARRELCHEST_ANCHOR_10888, IdleAnimationID.BARRELCHEST_ANCHOR);
		WEAPON_TO_IDLE.put(ItemID.MAGIC_BUTTERFLY_NET, IdleAnimationID.MAGIC_NET);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_HASTAP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_HASTAKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_HASTAP_11382, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_HASTAP_11384, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_HASTAP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_HASTAKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_HASTAP_11389, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IRON_HASTAP_11391, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_HASTAP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_HASTAKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_HASTAP_11396, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STEEL_HASTAP_11398, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_HASTAP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_HASTAKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_HASTAP_11403, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_HASTAP_11405, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_HASTAP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_HASTAKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_HASTAP_11410, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_HASTAP_11412, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_HASTAP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_HASTAKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_HASTAP_11417, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_HASTAP_11419, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BEACH_BOXING_GLOVES, IdleAnimationID.BOXING_GLOVES);
		WEAPON_TO_IDLE.put(ItemID.BEACH_BOXING_GLOVES_11706, IdleAnimationID.BOXING_GLOVES);
		WEAPON_TO_IDLE.put(ItemID.CURSED_GOBLIN_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ARMADYL_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.STEAM_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_STEAM_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_THE_DEAD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ARMADYL_GODSWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.BANDOS_GODSWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.SARADOMIN_GODSWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.ZAMORAK_GODSWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.ZAMORAKIAN_SPEAR, IdleAnimationID.ZAMORAKIAN_SPEAR);
		WEAPON_TO_IDLE.put(ItemID.SARADOMIN_SWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.ZAMORAKIAN_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TRIDENT_OF_THE_SEAS_FULL, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TRIDENT_OF_THE_SEAS, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.UNCHARGED_TRIDENT, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLACK_CHINCHOMPA, IdleAnimationID.CHINCHOMPA);
		WEAPON_TO_IDLE.put(ItemID.SMOKE_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_SMOKE_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ANCIENT_CROZIER, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ARMADYL_CROZIER, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BANDOS_CROZIER, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_CANE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID._3RD_AGE_WAND, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ROYAL_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IBANS_STAFF_U, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GOBLIN_PAINT_CANNON, IdleAnimationID.OVERHEAD_LAUNCHER);
		WEAPON_TO_IDLE.put(ItemID.STEAM_BATTLESTAFF_12795, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_STEAM_STAFF_12796, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SARAS_BLESSED_SWORD_FULL, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.SARADOMINS_BLESSED_SWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.GRANITE_MAUL_12848, IdleAnimationID.GRANITE_MAUL);
		WEAPON_TO_IDLE.put(ItemID.TRIDENT_OF_THE_SWAMP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.UNCHARGED_TOXIC_TRIDENT, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TOXIC_STAFF_UNCHARGED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TOXIC_STAFF_OF_THE_DEAD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TOXIC_BLOWPIPE_EMPTY, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TOXIC_BLOWPIPE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.NEW_CRYSTAL_HALBERD_FULL_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_FULL_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_910_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_810_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_710_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_610_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_510_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_410_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_310_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_210_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_110_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.WESTERN_BANNER_1, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.WESTERN_BANNER_2, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.WESTERN_BANNER_3, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.WESTERN_BANNER_4, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.ODDSKULL, IdleAnimationID.ODDSKULL);
		WEAPON_TO_IDLE.put(ItemID.ABYSSAL_BLUDGEON, IdleAnimationID.BLUDGEON);
		WEAPON_TO_IDLE.put(ItemID.ABYSSAL_DAGGER, IdleAnimationID.ABYSSAL_DAGGER);
		WEAPON_TO_IDLE.put(ItemID.ABYSSAL_DAGGER_P, IdleAnimationID.ABYSSAL_DAGGER);
		WEAPON_TO_IDLE.put(ItemID.ABYSSAL_DAGGER_P_13269, IdleAnimationID.ABYSSAL_DAGGER);
		WEAPON_TO_IDLE.put(ItemID.ABYSSAL_DAGGER_P_13271, IdleAnimationID.ABYSSAL_DAGGER);
		WEAPON_TO_IDLE.put(ItemID.GREEN_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.LIGHT_BALLISTA, IdleAnimationID.BALLISTA);
		WEAPON_TO_IDLE.put(ItemID.HEAVY_BALLISTA, IdleAnimationID.BALLISTA);
		WEAPON_TO_IDLE.put(ItemID.HEAVY_CASKET, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.ALE_OF_THE_GODS, IdleAnimationID.DRUNKEN_SWAY);
		WEAPON_TO_IDLE.put(ItemID.GILDED_2H_SWORD, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.GILDED_SPEAR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GILDED_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.LARGE_SPADE, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.CLUELESS_SCROLL, IdleAnimationID.CLUELESS_SCROLL);
		WEAPON_TO_IDLE.put(ItemID.ARCEUUS_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.HOSIDIUS_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.LOVAKENGJ_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.PISCARILIUS_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.SHAYZIEN_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.ARMADYL_GODSWORD_OR, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.BANDOS_GODSWORD_OR, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.SARADOMIN_GODSWORD_OR, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.ZAMORAK_GODSWORD_OR, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.ANCIENT_STAFF_20431, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BEGINNER_WAND_20553, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.RUNE_2H_SWORD_20555, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.APPRENTICE_WAND_20556, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_2H_SWORD_20559, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.MASTER_WAND_20560, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STALE_BAGUETTE, IdleAnimationID.RUBBER_CHICKEN);
		WEAPON_TO_IDLE.put(ItemID.ARMADYL_GODSWORD_20593, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.MIST_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_MIST_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DUST_BATTLESTAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_DUST_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.HILL_GIANT_CLUB, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.HUNTING_KNIFE, IdleAnimationID.CANDY_CANE);
		WEAPON_TO_IDLE.put(ItemID.GIANT_PRESENT, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.ELDER_MAUL, IdleAnimationID.ELDER_MAUL);
		WEAPON_TO_IDLE.put(ItemID.KODAI_WAND, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HUNTER_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.DINHS_BULWARK, IdleAnimationID.DINHS_BULWARK);
		WEAPON_TO_IDLE.put(ItemID.KILLERS_KNIFE_21059, IdleAnimationID.CANDY_CANE);
		WEAPON_TO_IDLE.put(ItemID.LAVA_BATTLESTAFF_21198, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_LAVA_STAFF_21200, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ELDER_MAUL_21205, IdleAnimationID.ELDER_MAUL);
		WEAPON_TO_IDLE.put(ItemID.BIRTHDAY_BALLOONS, IdleAnimationID.BALLOONS);
		WEAPON_TO_IDLE.put(ItemID.SLAYERS_STAFF_E, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SKULL_SCEPTRE_I, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.HAND_FAN, IdleAnimationID.HAND_FAN);
		WEAPON_TO_IDLE.put(ItemID.MERFOLK_TRIDENT, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.TRIDENT_OF_THE_SEAS_E, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.UNCHARGED_TRIDENT_E, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TRIDENT_OF_THE_SWAMP_E, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.UNCHARGED_TOXIC_TRIDENT_E, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_LIGHT, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.PROP_SWORD, IdleAnimationID.CANDY_CANE);
		WEAPON_TO_IDLE.put(ItemID.SANGUINESTI_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GHRAZI_RAPIER, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.SCYTHE_OF_VITUR, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.STARTER_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRYOPHYTAS_STAFF_UNCHARGED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRYOPHYTAS_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.IVANDIS_FLAIL, IdleAnimationID.SWINGING_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.SANGUINESTI_STAFF_UNCHARGED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SCYTHE_OF_VITUR_UNCHARGED, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.VIGGORAS_CHAINMACE_U, IdleAnimationID.VIGGORAS_CHAINMACE);
		WEAPON_TO_IDLE.put(ItemID.VIGGORAS_CHAINMACE, IdleAnimationID.VIGGORAS_CHAINMACE);
		WEAPON_TO_IDLE.put(ItemID.THAMMARONS_SCEPTRE_U, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.THAMMARONS_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.VESTAS_LONGSWORD, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.CANDY_CANE, IdleAnimationID.CANDY_CANE);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HASTA, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HASTAP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HASTAP_22737, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HASTAP_22740, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HASTAKP, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CORMORANTS_GLOVE_22817, IdleAnimationID.FALCON);
		WEAPON_TO_IDLE.put(ItemID.GOLDEN_TENCH, IdleAnimationID.GOLDEN_TENCH);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HUNTER_LANCE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BIRTHDAY_CAKE, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TZHAARKETOM_T, IdleAnimationID.GREATAXE);
		WEAPON_TO_IDLE.put(ItemID.GILDED_SPADE, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID._3RD_AGE_DRUIDIC_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_BOB_THE_CAT, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GIANT_EASTER_EGG, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.SARACHNIS_CUDGEL, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.ARMADYL_CROSSBOW_23611, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_HALBERD_BASIC, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_HALBERD_ATTUNED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_HALBERD_PERFECTED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_STAFF_BASIC, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_STAFF_ATTUNED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_STAFF_PERFECTED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_BASIC, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_ATTUNED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD_PERFECTED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_STAFF_BASIC, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_STAFF_ATTUNED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_STAFF_PERFECTED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_HALBERD, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_INACTIVE, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_GRAIL, IdleAnimationID.DRUNKEN_SWAY);
		WEAPON_TO_IDLE.put(ItemID.STAFF_OF_BALANCE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DECORATIVE_SWORD_L, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.GRANITE_MAUL_24225, IdleAnimationID.GRANITE_MAUL);
		WEAPON_TO_IDLE.put(ItemID.GRANITE_MAUL_24227, IdleAnimationID.GRANITE_MAUL);
		WEAPON_TO_IDLE.put(ItemID.SKELETON_LANTERN, IdleAnimationID.SPOOKY_LANTERN);
		WEAPON_TO_IDLE.put(ItemID.TWISTED_DRAGON_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TWISTED_RUNE_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TWISTED_ADAMANT_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TWISTED_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.NIGHTMARE_STAFF, IdleAnimationID.NIGHTMARE_STAFF);
		WEAPON_TO_IDLE.put(ItemID.HARMONISED_NIGHTMARE_STAFF, IdleAnimationID.NIGHTMARE_STAFF);
		WEAPON_TO_IDLE.put(ItemID.VOLATILE_NIGHTMARE_STAFF, IdleAnimationID.NIGHTMARE_STAFF);
		WEAPON_TO_IDLE.put(ItemID.ELDRITCH_NIGHTMARE_STAFF, IdleAnimationID.NIGHTMARE_STAFF);
		WEAPON_TO_IDLE.put(ItemID.CARROT_SWORD, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID._24CARAT_SWORD, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.VESTAS_BLIGHTED_LONGSWORD, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.VESTAS_LONGSWORD_INACTIVE, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLISTERWOOD_FLAIL, IdleAnimationID.SWINGING_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_DRAGON_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_RUNE_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_ADAMANT_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.SLED_25282, IdleAnimationID.SLED);
		WEAPON_TO_IDLE.put(ItemID.GIANT_BOULDER, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.CURSED_BANANA, IdleAnimationID.CURSED_BANANA);
		WEAPON_TO_IDLE.put(ItemID.GREGGS_EASTDOOR, IdleAnimationID.DINHS_BULWARK);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM_25723, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM_25724, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM_25725, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM_25726, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM_25727, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM_25728, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.CLAN_VEXILLUM_25729, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.HOLY_SANGUINESTI_STAFF, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.HOLY_SANGUINESTI_STAFF_UNCHARGED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.HOLY_GHRAZI_RAPIER, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.HOLY_SCYTHE_OF_VITUR, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.HOLY_SCYTHE_OF_VITUR_UNCHARGED, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.SANGUINE_SCYTHE_OF_VITUR, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.SANGUINE_SCYTHE_OF_VITUR_UNCHARGED, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.PROTEST_BANNER, IdleAnimationID.CLAN_VEXILLUM);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_24553, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_25870, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_25872, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_25874, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_25876, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_25878, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_25880, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.BLADE_OF_SAELDOR_C_25882, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HUNTER_CROSSBOW_T, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HUNTER_CROSSBOW_B, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.KERIS_PARTISAN, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.OSMUMTENS_FANG, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.ANCIENT_GODSWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.ZARYTE_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.SHATTERED_BANNER, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.RUNE_CROSSBOW_OR, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.SHATTERED_RELICS_ADAMANT_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.SHATTERED_RELICS_RUNE_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.SHATTERED_RELICS_DRAGON_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.SHATTERED_CANE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SKIS, IdleAnimationID.SKIS);
		WEAPON_TO_IDLE.put(ItemID.HEAVY_BALLISTA_OR, IdleAnimationID.BALLISTA);
		WEAPON_TO_IDLE.put(ItemID.PREFORM, IdleAnimationID.ELDER_MAUL);
		WEAPON_TO_IDLE.put(ItemID.COLOSSAL_BLADE, IdleAnimationID.COLOSSAL_BLADE);
		WEAPON_TO_IDLE.put(ItemID.ELDER_MAUL_OR, IdleAnimationID.ELDER_MAUL);
		WEAPON_TO_IDLE.put(ItemID.OSMUMTENS_FANG_OR, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.TUMEKENS_SHADOW, IdleAnimationID.TUMEKENS_SHADOW);
		WEAPON_TO_IDLE.put(ItemID.TUMEKENS_SHADOW_UNCHARGED, IdleAnimationID.TUMEKENS_SHADOW);
		WEAPON_TO_IDLE.put(ItemID.KERIS_PARTISAN_OF_BREACHING, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.KERIS_PARTISAN_OF_CORRUPTION, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.KERIS_PARTISAN_OF_THE_SUN, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.GIANT_STOPWATCH, IdleAnimationID.GIANT_STOPWATCH);
		WEAPON_TO_IDLE.put(ItemID.GOLD_SPEEDRUN_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.PLATINUM_SPEEDRUN_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.FESTIVE_NUTCRACKER_STAFF, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.SWEET_NUTCRACKER_STAFF, IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.VENATOR_BOW, IdleAnimationID.VENATOR_BOW);
		WEAPON_TO_IDLE.put(ItemID.VENATOR_BOW_UNCHARGED, IdleAnimationID.VENATOR_BOW);
		WEAPON_TO_IDLE.put(ItemID.ANCIENT_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.MYSTIC_CARDS, IdleAnimationID.MYSTIC_CARDS);
		WEAPON_TO_IDLE.put(ItemID.URSINE_CHAINMACE, IdleAnimationID.VIGGORAS_CHAINMACE);
		WEAPON_TO_IDLE.put(ItemID.URSINE_CHAINMACE_U, IdleAnimationID.VIGGORAS_CHAINMACE);
		WEAPON_TO_IDLE.put(ItemID.ACCURSED_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ACCURSED_SCEPTRE_U, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ACCURSED_SCEPTRE_AU, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ACCURSED_SCEPTRE_A, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DIAMOND_SPEEDRUN_TROPHY, IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.THAMMARONS_SCEPTRE_AU, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.THAMMARONS_SCEPTRE_A, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID._10TH_BIRTHDAY_BALLOONS, IdleAnimationID.TENTH_ANNI_BALLOONS);
		WEAPON_TO_IDLE.put(ItemID.BARRELCHEST_ANCHOR_BH, IdleAnimationID.BARRELCHEST_ANCHOR);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_LONGSWORD_BH, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.ABYSSAL_DAGGER_BH, IdleAnimationID.ABYSSAL_DAGGER);
		WEAPON_TO_IDLE.put(ItemID.ABYSSAL_DAGGER_BHP, IdleAnimationID.ABYSSAL_DAGGER);
		WEAPON_TO_IDLE.put(ItemID.GIANT_BRONZE_DAGGER, IdleAnimationID.COLOSSAL_BLADE);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_LONGSWORD_CR, IdleAnimationID.TALL_SWORD);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_SPEAR_CR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_SPEAR_PCR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_HALBERD_CR, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_2H_SWORD_CR, IdleAnimationID.TWO_HANDED_SWORD);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_CROSSBOW_CR, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.LOVE_CROSSBOW, IdleAnimationID.CROSSBOW);
		WEAPON_TO_IDLE.put(ItemID.SOULREAPER_AXE_28338, IdleAnimationID.SOULREAPER_AXE);
		WEAPON_TO_IDLE.put(ItemID.BLOOD_ANCIENT_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ICE_ANCIENT_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SMOKE_ANCIENT_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SHADOW_ANCIENT_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLOOD_ANCIENT_SCEPTRE_28260, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.ICE_ANCIENT_SCEPTRE_28262, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SMOKE_ANCIENT_SCEPTRE_28264, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.SHADOW_ANCIENT_SCEPTRE_28266, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BRONZE_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.IRON_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.STEEL_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.BLACK_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.MITHRIL_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.ADAMANT_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.RUNE_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.DRAGON_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID._3RD_AGE_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_FELLING_AXE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.CRYSTAL_FELLING_AXE_INACTIVE, IdleAnimationID.TWO_HANDED_AXE);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_ARMADYL_GODSWORD, IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_SCYTHE_OF_VITUR, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_SCYTHE_OF_VITUR_UNCHARGED, IdleAnimationID.SCYTHE_OF_VITUR);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_TUMEKENS_SHADOW, IdleAnimationID.TUMEKENS_SHADOW);
		WEAPON_TO_IDLE.put(ItemID.WARPED_SCEPTRE_UNCHARGED, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.WARPED_SCEPTRE, IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.DINHS_BLAZING_BULWARK , IdleAnimationID.DINHS_BULWARK);
		WEAPON_TO_IDLE.put(ItemID.BLAZING_BLOWPIPE , IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.BLAZING_BLOWPIPE_EMPTY , IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_RELOADED_BANNER , IdleAnimationID.BANNER);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_RELOADED_TORCH , IdleAnimationID.TRAILBLAZER_TORCH);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_RELOADED_DRAGON_TROPHY , IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_RELOADED_RUNE_TROPHY , IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.TRAILBLAZER_RELOADED_ADAMANT_TROPHY , IdleAnimationID.HEAVY_ITEM);
		WEAPON_TO_IDLE.put(ItemID.BONE_MACE , IdleAnimationID.VERACS_FLAIL);
		WEAPON_TO_IDLE.put(ItemID.BONE_STAFF , IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.TECU_SALAMANDER , IdleAnimationID.SALAMANDER);
		WEAPON_TO_IDLE.put(ItemID.BLUE_MOON_SPEAR , IdleAnimationID.ZAMORAKIAN_SPEAR);
		WEAPON_TO_IDLE.put(ItemID.PURGING_STAFF , IdleAnimationID.UPRIGHT_WEAPON);
		WEAPON_TO_IDLE.put(ItemID.CORRUPTED_VOLATILE_NIGHTMARE_STAFF , IdleAnimationID.NIGHTMARE_STAFF);
		WEAPON_TO_IDLE.put(ItemID.ARMADYL_GODSWORD_DEADMAN , IdleAnimationID.GODSWORD);
		WEAPON_TO_IDLE.put(ItemID.VOLATILE_NIGHTMARE_STAFF_DEADMAN , IdleAnimationID.NIGHTMARE_STAFF);
	}

	// endregion
}

package eq.uirs.fashionscape.data.anim;

// Idle pose animations from equipping various main-hand items
public class IdleAnimationID
{
	public static final int VIGGORAS_CHAINMACE = 244;
	public static final int DEFAULT = 808;
	public static final int TALL_SWORD = 809;
	public static final int UPRIGHT_WEAPON = 813;
	public static final int HALLOWEEN_SCYTHE = 847;
	public static final int BANNER = 1421;
	public static final int SLED = 1461;
	public static final int BLUDGEON = 1652;
	public static final int GRANITE_MAUL = 1662;
	public static final int ZAMORAKIAN_SPEAR = 1713;
	public static final int ODDSKULL = 1824;
	public static final int RUBBER_CHICKEN = 1832;
	public static final int EASTER_BASKET = 1837;
	public static final int VERACS_FLAIL = 2061;
	public static final int GREATAXE = 2065;
	public static final int KARILS_CROSSBOW = 2074;
	public static final int MINECART = 2148;
	public static final int OVERHEAD_LAUNCHER = 2316;
	public static final int TWO_HANDED_SWORD = 2561;
	public static final int CANDY_CANE = 2911;
	public static final int DRUNKEN_SWAY = 3040;
	public static final int CHINCHOMPA = 3175;
	public static final int ABYSSAL_DAGGER = 3296;
	public static final int BOXING_GLOVES = 3677;
	public static final int HEAVY_ITEM = 4193;
	public static final int NIGHTMARE_STAFF = 4504;
	public static final int CROSSBOW = 4591;
	public static final int CURSED_BANANA = 4646;
	public static final int FALCON = 5160;
	public static final int SALAMANDER = 5246;
	public static final int NOOSE_WAND = 5254;
	public static final int UNDEAD_CHICKEN = 5363;
	public static final int BARRELCHEST_ANCHOR = 5869;
	public static final int HAND_FAN = 6297;
	public static final int MAGIC_NET = 6604;
	public static final int PET_ROCK = 6657;
	public static final int MAGIC_CARPET = 6936;
	public static final int GODSWORD = 7053;
	public static final int BALLISTA = 7220;
	public static final int CLUELESS_SCROLL = 7271;
	public static final int DINHS_BULWARK = 7508;
	public static final int ELDER_MAUL = 7518;
	public static final int BALLOONS = 7538;
	public static final int SWINGING_FLAIL = 8009;
	public static final int SCYTHE_OF_VITUR = 8057;
	public static final int GOLDEN_TENCH = 8208;
	public static final int SPOOKY_LANTERN = 8521;
	public static final int CLAN_VEXILLUM = 9018;
	public static final int SKIS = 9341;
	public static final int COLOSSAL_BLADE = 9460;
	public static final int TUMEKENS_SHADOW = 9494;
	public static final int GIANT_STOPWATCH = 9814;
	public static final int MYSTIC_CARDS = 9847;
	public static final int VENATOR_BOW = 9857;
	public static final int TENTH_ANNI_BALLOONS = 10032;
	public static final int TWO_HANDED_AXE = 10075;
	public static final int TRAILBLAZER_TORCH = 10636;
	public static final int SOULREAPER_AXE = 10169;
}

package eq.uirs.fashionscape.data.color;

import java.awt.Color;

public interface Colorable
{
	String getDisplayName();

	Color getColor();

	int getColorId(ColorType type);
}

package eq.uirs.fashionscape.data.color;

import java.awt.Color;
import java.util.Arrays;
import java.util.Comparator;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.Text;

@Getter
@RequiredArgsConstructor
public enum SkinColor implements Colorable
{
	VERY_PALE(7, new Color(213, 169, 133)),
	PALE(0, new Color(187, 143, 106)),
	DEFAULT(1, new Color(164, 127, 93)),
	SLIGHTLY_TAN(2, new Color(158, 122, 73)),
	TAN(3, new Color(131, 110, 66)),
	VERY_TAN(4, new Color(121, 88, 42)),
	DARK(5, new Color(100, 78, 36)),
	VERY_DARK(6, new Color(76, 61, 9)),
	GREEN(8, new Color(0, 127, 0)),
	BLACK(9, new Color(15, 15, 15)),
	WHITE(10, new Color(255, 255, 255)),
	CYAN(11, new Color(5, 152, 159)),
	PURPLE(12, new Color(100, 65, 164));

	private static final SkinColor[] sorted = Arrays.stream(values())
		.sorted(Comparator.comparing(SkinColor::getColorId))
		.toArray(SkinColor[]::new);

	public static SkinColor fromId(int id)
	{
		if (id < 0 || id >= sorted.length)
		{
			return null;
		}
		return values()[id];
	}

	private final int colorId;

	private final Color color;

	@Override
	public String getDisplayName()
	{
		return Text.titleCase(this);
	}

	@Override
	public int getColorId(ColorType type)
	{
		return this.colorId;
	}
}

package eq.uirs.fashionscape.data.color;

import java.awt.Color;
import java.util.Arrays;
import java.util.Comparator;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.Text;

@Getter
@RequiredArgsConstructor
public enum HairColor implements Colorable
{
	DARK_BROWN(0, new Color(93, 65, 29)),
	WHITE(1, new Color(227, 224, 224)),
	LIGHT_GREY(2, new Color(134, 144, 124)),
	DARK_GREY(3, new Color(72, 68, 68)),
	APRICOT(4, new Color(217, 148, 78)),
	STRAW(5, new Color(214, 185, 100)),
	LIGHT_BROWN(6, new Color(166, 123, 60)),
	BROWN(7, new Color(124, 89, 56)),
	TURQUOISE(8, new Color(18, 156, 161)),
	GREEN(9, new Color(18, 161, 24)),
	GINGER(10, new Color(179, 80, 21)),
	MAGENTA(11, new Color(198, 24, 207)),
	BLACK(12, new Color(44, 42, 42)),
	GREY(13, new Color(121, 109, 96)),
	BEIGE(14, new Color(187, 186, 149)),
	PEACH(15, new Color(217, 145, 101)),
	LIGHT_BLUE(16, new Color(144, 173, 202)),
	ROYAL_BLUE(17, new Color(62, 64, 173)),
	PALE_PINK(18, new Color(181, 146, 145)),
	INTENSE_PINK(19, new Color(204, 101, 95)),
	MAROON(20, new Color(87, 18, 9)),
	LIGHT_GREEN(21, new Color(145, 202, 146)),
	DARK_GREEN(22, new Color(59, 88, 79)),
	PURPLE(23, new Color(136, 65, 178)),
	LIGHT_PURPLE(24, new Color(185, 141, 200)),
	NAVY_BLUE(25, new Color(36, 37, 67)),
	BRIGHT_RED(26, new Color(155, 13, 5)),
	YELLOW(27, new Color(248, 203, 18)),
	DARK_PURPLE(28, new Color(56, 2, 74)),
	AQUA(29, new Color(31, 155, 127));

	private static final HairColor[] sorted = Arrays.stream(values())
		.sorted(Comparator.comparing(HairColor::getColorId))
		.toArray(HairColor[]::new);

	public static HairColor fromId(int id)
	{
		if (id < 0 || id >= sorted.length)
		{
			return null;
		}
		return values()[id];
	}

	private final int colorId;

	private final Color color;

	public String getDisplayName()
	{
		return Text.titleCase(this);
	}

	@Override
	public int getColorId(ColorType type)
	{
		return this.colorId;
	}
}

package eq.uirs.fashionscape.data.color;

import net.runelite.client.util.Text;

public enum ColorType
{
	HAIR,
	TORSO,
	LEGS,
	BOOTS,
	SKIN;

	public String getDisplayName()
	{
		return Text.titleCase(this);
	}

	public Colorable[] getColorables()
	{
		switch (this)
		{
			case HAIR:
				return HairColor.values();
			case TORSO:
			case LEGS:
				return ClothingColor.values();
			case BOOTS:
				return BootsColor.values();
			case SKIN:
				return SkinColor.values();
		}
		return new Colorable[0];
	}
}

package eq.uirs.fashionscape.data.color;

import java.awt.Color;
import java.util.Arrays;
import java.util.Comparator;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.Text;

@Getter
@RequiredArgsConstructor
public enum BootsColor implements Colorable
{
	BROWN(0, new Color(111, 89, 61)),
	KHAKI(1, new Color(88, 88, 8)),
	ASHEN(2, new Color(121, 113, 96)),
	DARK(3, new Color(65, 60, 60)),
	TERRACOTTA(4, new Color(129, 98, 58)),
	GREY(5, new Color(115, 114, 106));

	private static final BootsColor[] sorted = Arrays.stream(values())
		.sorted(Comparator.comparing(BootsColor::getColorId))
		.toArray(BootsColor[]::new);

	public static BootsColor fromId(int id)
	{
		if (id < 0 || id >= sorted.length)
		{
			return null;
		}
		return values()[id];
	}

	private final int colorId;

	private final Color color;

	public String getDisplayName()
	{
		return Text.titleCase(this);
	}

	@Override
	public int getColorId(ColorType type)
	{
		return this.colorId;
	}
}

package eq.uirs.fashionscape.data.color;

import java.awt.Color;
import java.util.Arrays;
import java.util.Comparator;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.Text;

@Getter
@RequiredArgsConstructor
public enum ClothingColor implements Colorable
{
	KHAKI(0, 1, new Color(123, 110, 50)),
	CHARCOAL(1, 2, new Color(38, 35, 35)),
	CRIMSON(2, 3, new Color(117, 47, 59)),
	NAVY(3, 4, new Color(59, 59, 78)),
	STRAW(4, 5, new Color(170, 144, 69)),
	WHITE(5, 6, new Color(173, 164, 129)),
	RED(6, 7, new Color(139, 59, 42)),
	BLUE(7, 8, new Color(45, 82, 114)),
	GREEN(8, 9, new Color(45, 114, 62)),
	YELLOW(9, 10, new Color(163, 151, 13)),
	PURPLE(10, 11, new Color(131, 83, 123)),
	ORANGE(11, 12, new Color(157, 100, 47)),
	ROSE(12, 13, new Color(161, 112, 103)),
	LIME(13, 14, new Color(130, 148, 114)),
	CYAN(14, 15, new Color(114, 140, 148)),
	EMERALD(15, 0, new Color(28, 97, 53)),
	BLACK(16, 16, new Color(16, 16, 16)),
	GREY(17, 17, new Color(64, 64, 64)),
	ONION(18, 18, new Color(248, 216, 144)),
	PEACH(19, 19, new Color(248, 190, 130)),
	LUMBRIDGE_BLUE(20, 20, new Color(150, 150, 255)),
	DEEP_BLUE(21, 21, new Color(0, 0, 255)),
	LIGHT_PINK(22, 22, new Color(255, 190, 190)),
	CADMIUM_RED(23, 23, new Color(200, 80, 50)),
	MAROON(24, 24, new Color(150, 40, 0)),
	PALE_GREEN(25, 25, new Color(200, 255, 200)),
	TURQUOISE(26, 26, new Color(0, 120, 120)),
	DEEP_PURPLE(27, 27, new Color(150, 0, 150)),
	LIGHT_PURPLE(28, 28, new Color(255, 150, 255));

	private static final ClothingColor[] torsoSorted = Arrays.stream(values())
		.sorted(Comparator.comparing(ClothingColor::getTorsoColorId))
		.toArray(ClothingColor[]::new);

	private static final ClothingColor[] legsSorted = Arrays.stream(values())
		.sorted(Comparator.comparing(ClothingColor::getLegsColorId))
		.toArray(ClothingColor[]::new);

	public static ClothingColor fromTorsoId(int id)
	{
		if (id < 0 || id >= torsoSorted.length)
		{
			return null;
		}
		return values()[id];
	}

	public static ClothingColor fromLegsId(int id)
	{
		if (id < 0 || id >= legsSorted.length)
		{
			return null;
		}
		return values()[id];
	}

	private final int torsoColorId;

	private final int legsColorId;

	private final Color color;

	public String getDisplayName()
	{
		return Text.titleCase(this);
	}

	@Override
	public int getColorId(ColorType type)
	{
		if (type == ColorType.TORSO)
		{
			return torsoColorId;
		}
		else
		{
			return legsColorId;
		}
	}
}

package eq.uirs.fashionscape.data.kit;

import com.google.common.collect.ImmutableMap;
import eq.uirs.fashionscape.core.FashionManager;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;

/**
 * Unlike other kits, the jaw slot can contain icon items, which require special handling since they're treated
 * as neither normal items nor normal kits by the plugin.
 */
@RequiredArgsConstructor
public enum JawKit implements Kit
{
	// only valid when worn items obscure the player's jaw
	NO_JAW(-256, -256,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 10556)
			.put(JawIcon.BA_DEFENDER, 10558)
			.put(JawIcon.BA_COLLECTOR, 10557)
			.put(JawIcon.BA_HEALER, 10559)
			.put(JawIcon.SW_BLUE, 25212)
			.put(JawIcon.SW_RED, 25228)
			.build()),

	GOATEE(10, 292,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 23460)
			.put(JawIcon.BA_DEFENDER, 23466)
			.put(JawIcon.BA_COLLECTOR, 22339)
			.put(JawIcon.BA_HEALER, 23478)
			.put(JawIcon.SW_BLUE, 25213)
			.put(JawIcon.SW_RED, 25229)
			.build()),

	LONG_J(11, 293,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22723)
			.put(JawIcon.BA_DEFENDER, 22345)
			.put(JawIcon.BA_COLLECTOR, 23471)
			.put(JawIcon.BA_HEALER, 22311)
			.put(JawIcon.SW_BLUE, 25214)
			.put(JawIcon.SW_RED, 25230)
			.build()),

	MEDIUM_J(12, 294,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 23461)
			.put(JawIcon.BA_DEFENDER, 22728)
			.put(JawIcon.BA_COLLECTOR, 23472)
			.put(JawIcon.BA_HEALER, 23479)
			.put(JawIcon.SW_BLUE, 25215)
			.put(JawIcon.SW_RED, 25231)
			.build()),

	SMALL_MOUSTACHE(13, 295,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22722)
			.put(JawIcon.BA_DEFENDER, 22344)
			.put(JawIcon.BA_COLLECTOR, 22338)
			.put(JawIcon.BA_HEALER, 22310)
			.put(JawIcon.SW_BLUE, 25216)
			.put(JawIcon.SW_RED, 25232)
			.build()),

	CLEAN_SHAVEN(14, 296,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 23462)
			.put(JawIcon.BA_DEFENDER, 23467)
			.put(JawIcon.BA_COLLECTOR, 23473)
			.put(JawIcon.BA_HEALER, 23480)
			.put(JawIcon.SW_BLUE, 25217)
			.put(JawIcon.SW_RED, 25233)
			.build()),

	SHORT_J(15, 297,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 23463)
			.put(JawIcon.BA_DEFENDER, 23468)
			.put(JawIcon.BA_COLLECTOR, 22337)
			.put(JawIcon.BA_HEALER, 22309)
			.put(JawIcon.SW_BLUE, 25218)
			.put(JawIcon.SW_RED, 25234)
			.build()),

	POINTY(16, 298,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22721)
			.put(JawIcon.BA_DEFENDER, 22343)
			.put(JawIcon.BA_COLLECTOR, 23474)
			.put(JawIcon.BA_HEALER, 23481)
			.put(JawIcon.SW_BLUE, 25219)
			.put(JawIcon.SW_RED, 25235)
			.build()),

	SPLIT(17, 299,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 23464)
			.put(JawIcon.BA_DEFENDER, 23469)
			.put(JawIcon.BA_COLLECTOR, 22315)
			.put(JawIcon.BA_HEALER, 23482)
			.put(JawIcon.SW_BLUE, 25220)
			.put(JawIcon.SW_RED, 25236)
			.build()),

	HANDLEBAR(111, 300,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22349)
			.put(JawIcon.BA_DEFENDER, 22342)
			.put(JawIcon.BA_COLLECTOR, 23475)
			.put(JawIcon.BA_HEALER, 22308)
			.put(JawIcon.SW_BLUE, 25221)
			.put(JawIcon.SW_RED, 25237)
			.build()),

	MUTTON(112, 301,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22730)
			.put(JawIcon.BA_DEFENDER, 23470)
			.put(JawIcon.BA_COLLECTOR, 22314)
			.put(JawIcon.BA_HEALER, 23483)
			.put(JawIcon.SW_BLUE, 25222)
			.put(JawIcon.SW_RED, 25238)
			.build()),

	FULL_MUTTON(113, 302,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22348)
			.put(JawIcon.BA_DEFENDER, 22341)
			.put(JawIcon.BA_COLLECTOR, 23476)
			.put(JawIcon.BA_HEALER, 20802)
			.put(JawIcon.SW_BLUE, 25223)
			.put(JawIcon.SW_RED, 25239)
			.build()),

	BIG_MOUSTACHE(114, 303,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22729)
			.put(JawIcon.BA_DEFENDER, 22727)
			.put(JawIcon.BA_COLLECTOR, 22313)
			.put(JawIcon.BA_HEALER, 23484)
			.put(JawIcon.SW_BLUE, 25224)
			.put(JawIcon.SW_RED, 25240)
			.build()),

	WAXED_MOUSTACHE(115, 304,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22347)
			.put(JawIcon.BA_DEFENDER, 22340)
			.put(JawIcon.BA_COLLECTOR, 22724)
			.put(JawIcon.BA_HEALER, 10567)
			.put(JawIcon.SW_BLUE, 25225)
			.put(JawIcon.SW_RED, 25241)
			.build()),

	DALI(116, 305,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 23465)
			.put(JawIcon.BA_DEFENDER, 22726)
			.put(JawIcon.BA_COLLECTOR, 22312)
			.put(JawIcon.BA_HEALER, 23485)
			.put(JawIcon.SW_BLUE, 25226)
			.put(JawIcon.SW_RED, 25242)
			.build()),

	VIZIER(117, 306,
		new ImmutableMap.Builder<JawIcon, Integer>()
			.put(JawIcon.BA_ATTACKER, 22346)
			.put(JawIcon.BA_DEFENDER, 22725)
			.put(JawIcon.BA_COLLECTOR, 23477)
			.put(JawIcon.BA_HEALER, 23486)
			.put(JawIcon.SW_BLUE, 25227)
			.put(JawIcon.SW_RED, 25243)
			.build());

	// item id -> icon
	private static final Map<Integer, JawIcon> reverseLookupIcon = new HashMap<>();
	// equipment id -> kit
	private static final Map<Integer, JawKit> reverseLookupKit = new HashMap<>();

	@Nonnull
	public static JawIcon iconFromItemId(Integer itemId)
	{
		JawIcon icon = reverseLookupIcon.get(itemId);
		return icon != null ? icon : JawIcon.NOTHING;
	}

	public static boolean isNoJawIcon(int itemId)
	{
		return JawKit.NO_JAW.icons.containsValue(itemId);
	}

	public static JawKit fromEquipmentId(int equipId)
	{
		return reverseLookupKit.get(equipId);
	}

	static
	{
		for (JawKit kit : JawKit.values())
		{
			reverseLookupKit.put(kit.mascKitId + FashionManager.KIT_OFFSET, kit);
			reverseLookupKit.put(kit.femKitId + FashionManager.KIT_OFFSET, kit);
			kit.icons.forEach((icon, itemId) -> {
				reverseLookupIcon.put(itemId, icon);
				reverseLookupKit.put(itemId + FashionManager.ITEM_OFFSET, kit);
			});
		}
	}

	@Getter
	private final Integer mascKitId;
	@Getter
	private final Integer femKitId;

	// values are equipment ids
	private final Map<JawIcon, Integer> icons;

	@Override
	public KitType getKitType()
	{
		return KitType.JAW;
	}

	@Override
	public String getDisplayName()
	{
		switch (this)
		{
			case NO_JAW:
				return "";
			case CLEAN_SHAVEN:
				return "Clean-shaven";
			case LONG_J:
				return "Long";
			case MEDIUM_J:
				return "Medium";
			case SHORT_J:
				return "Short";
		}
		return Kit.sentenceCaseName(this);
	}

	@Nullable
	public Integer getIconItemId(JawIcon icon)
	{
		return icons.get(icon);
	}

	@Override
	public boolean isHidden()
	{
		return false;
	}
}

package eq.uirs.fashionscape.data.kit;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;

@Getter
@RequiredArgsConstructor
public enum ArmsKit implements Kit
{
	REGULAR(26, null),
	MUSCLEBOUND(27, null),
	LOOSE_SLEEVED(28, null),
	LARGE_CUFFED(29, null),
	THIN(30, null),
	SHOULDER_PADS(31, null),
	THIN_STRIPE(32, 97),
	THICK_STRIPE(84, null),
	WHITE_CUFFS(85, 96),
	PRINCELY_A(86, null),
	TATTY(87, 98),
	RIPPED(88, null),
	SHORT_SLEEVES(null, 61),
	BARE_ARMS(null, 62),
	MUSCLEY(null, 63),
	LONG_SLEEVED(null, 64),
	LARGE_CUFFS(null, 65),
	FRILLY_A(null, 66),
	SWEATER_A(null, 95),
	BARE_SHOULDERS(null, 99);

	private final Integer mascKitId;
	private final Integer femKitId;

	@Override
	public KitType getKitType()
	{
		return KitType.ARMS;
	}

	@Override
	public String getDisplayName()
	{
		switch (this)
		{
			case PRINCELY_A:
				return "Princely";
			case FRILLY_A:
				return "Frilly";
			case SWEATER_A:
				return "Sweater";
		}
		return Kit.sentenceCaseName(this);
	}

	@Override
	public boolean isHidden()
	{
		return false;
	}
}

package eq.uirs.fashionscape.data.kit;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;

@RequiredArgsConstructor
@Getter
public enum HandsKit implements Kit
{
	BRACERS2("Bracers", 33, 67, true),
	PLAIN_H("Plain", 34, 68, false),
	BRACERS("Bracers", 35, 69, false);

	private final String displayName;

	private final Integer mascKitId;
	private final Integer femKitId;

	private final boolean hidden;

	@Override
	public KitType getKitType()
	{
		return KitType.HANDS;
	}

	@Override
	public String getDisplayName()
	{
		return displayName;
	}

	@Override
	public boolean isHidden()
	{
		return hidden;
	}
}

package eq.uirs.fashionscape.data.kit;

import java.util.Arrays;
import java.util.function.IntFunction;
import net.runelite.api.kit.KitType;
import org.apache.commons.text.WordUtils;

public interface Kit
{
	static Kit[] allInSlot(KitType slot, boolean includeHidden)
	{
		Kit[] values;
		IntFunction<Kit[]> creator;
		switch (slot)
		{
			case HAIR:
				values = HairKit.values();
				creator = HairKit[]::new;
				break;
			case JAW:
				values = JawKit.values();
				creator = JawKit[]::new;
				break;
			case TORSO:
				values = TorsoKit.values();
				creator = TorsoKit[]::new;
				break;
			case ARMS:
				values = ArmsKit.values();
				creator = ArmsKit[]::new;
				break;
			case LEGS:
				values = LegsKit.values();
				creator = LegsKit[]::new;
				break;
			case HANDS:
				values = HandsKit.values();
				creator = HandsKit[]::new;
				break;
			case BOOTS:
				values = BootsKit.values();
				creator = BootsKit[]::new;
				break;
			default:
				return new Kit[0];
		}
		return Arrays.stream(values)
			.filter(kit -> includeHidden || !kit.isHidden())
			.toArray(creator);
	}

	KitType getKitType();

	String getDisplayName();

	boolean isHidden();

	Integer getMascKitId();
	Integer getFemKitId();

	default Integer getKitId(Integer gender)
	{
		switch (gender)
		{
			case 0:
				return getMascKitId();
			case 1:
				return getFemKitId();
			default:
				return null;
		}
	}

	static String sentenceCaseName(Enum e)
	{
		return WordUtils.capitalize(e.toString().toLowerCase()).replace("_", " ");
	}
}

package eq.uirs.fashionscape.data.kit;

import java.util.Arrays;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum JawIcon
{
	NOTHING("No icon", -1),
	BA_ATTACKER("Attacker icon", 10556),
	BA_DEFENDER("Defender icon", 10558),
	BA_COLLECTOR("Collector icon", 10557),
	BA_HEALER("Healer icon", 10559),
	SW_BLUE("Blue icon", 25212),
	SW_RED("Red icon", 25228);

	@Nullable
	public static JawIcon fromId(int id)
	{
		return Arrays.stream(JawIcon.values())
			.filter(i -> i.id == id)
			.findFirst()
			.orElse(null);
	}

	private final String displayName;

	// representative item id for displaying in panel icon and for color scoring
	private final int id;
}

package eq.uirs.fashionscape.data.kit;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;

@RequiredArgsConstructor
@Getter
public enum TorsoKit implements Kit
{
	PLAIN(18, 56),
	LIGHT_BUTTONS(19, null),
	DARK_BUTTONS(20, null),
	JACKET(21, null),
	SHIRT(22, 90),
	STITCHING(23, null),
	TORN(24, 60),
	TWO_TONED(25, null),
	SWEATER(105, 89),
	BUTTONED_SHIRT(106, null),
	VEST(107, 91),
	PRINCELY_T(108, null),
	RIPPED_WESKIT(109, null),
	TORN_WESKIT(110, null),
	CROP_TOP(null, 57),
	POLO_NECK(null, 58),
	SIMPLE(null, 59),
	FRILLY(null, 92),
	CORSETRY(null, 93),
	BODICE(null, 94);

	private final Integer mascKitId;
	private final Integer femKitId;

	@Override
	public KitType getKitType()
	{
		return KitType.TORSO;
	}

	@Override
	public String getDisplayName()
	{
		switch (this)
		{
			case TWO_TONED:
				return "Two-toned";
			case PRINCELY_T:
				return "Princely";
			case CROP_TOP:
				return "Crop-top";
		}
		return Kit.sentenceCaseName(this);
	}

	@Override
	public boolean isHidden()
	{
		return false;
	}
}

package eq.uirs.fashionscape.data.kit;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;

@RequiredArgsConstructor
@Getter
public enum HairKit implements Kit
{
	BALD(0, 45),
	DREADLOCKS(1, 47),
	LONG(2, 48),
	MEDIUM(3, 49),
	TONSURE(4, 174),
	SHORT(5, 51),
	CROPPED(6, 52),
	WILD_SPIKES(7, 53),
	SPIKES(8, 54),
	MOHAWK(9, 175),
	WIND_BRAIDS(129, 120),
	QUIFF(130, 176),
	SAMURAI(131, 177),
	PRINCELY(132, 178),
	CURTAINS(133, 128),
	LONG_CURTAINS(134, 179),
	TOUSLED(144, 180),
	SIDE_WEDGE(145, 181),
	FRONT_WEDGE(146, 182),
	FRONT_SPIKES(147, 183),
	FROHAWK(148, 184),
	REAR_SKIRT(149, 185),
	QUEUE(150, 186),
	FRONT_SPLIT(151, 141),
	MULLET(201, 154),
	UNDERCUT(202, 155),
	POMPADOUR(203, 156),
	AFRO(204, 157),
	SHORT_LOCS(205, 158),
	SPIKY_MOHAWK(206, 159),
	SLICKED_MOHAWK(207, 160),
	LONG_QUIFF(208, 161),
	SHORT_CHOPPY(209, 162),
	SIDE_AFRO(210, 163),
	PUNK(211, 164),
	HALF_SHAVED(212, 165),
	FREMENNIK(213, 166),
	ELVEN(214, 167),
	MEDIUM_COILS(215, 168),
	LOW_BUN(216, 169),
	MESSY_BUN(217, 170),
	HIGH_PONYTAIL(218, 171),
	PLAITS(219, 172),
	HIGH_BUNCHES(220, 173),
	BUN(221, 46),
	PIGTAILS(222, 50),
	EARMUFFS(223, 55),
	SIDE_PONY(224, 118),
	CURLS(225, 119),
	PONYTAIL(226, 121),
	BRAIDS(227, 122),
	BUNCHES(228, 123),
	BOB(229, 124),
	LAYERED(230, 125),
	STRAIGHT(231, 126),
	STRAIGHT_BRAIDS(232, 127),
	TWO_BACK(233, 143);

	private final Integer mascKitId;
	private final Integer femKitId;

	@Override
	public KitType getKitType()
	{
		return KitType.HAIR;
	}

	@Override
	public String getDisplayName()
	{
		switch (this)
		{
			case HALF_SHAVED:
				return "Half-shaved";
			case TWO_BACK:
				return "Two-back";
		}
		return Kit.sentenceCaseName(this);
	}

	@Override
	public boolean isHidden()
	{
		return false;
	}
}

package eq.uirs.fashionscape.data.kit;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;

@Getter
@RequiredArgsConstructor
public enum BootsKit implements Kit
{
	SMALL(42, 79, false),
	LARGE(43, 80, false),
	LARGE_2(44, 81, true),
	MINECART(82, 83, true);

	private final Integer mascKitId;
	private final Integer femKitId;

	private final boolean hidden;

	@Override
	public KitType getKitType()
	{
		return KitType.BOOTS;
	}

	@Override
	public String getDisplayName()
	{
		if (this == LARGE_2)
		{
			return "Large";
		}
		return Kit.sentenceCaseName(this);
	}
}

package eq.uirs.fashionscape.data.kit;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;

@RequiredArgsConstructor
@Getter
public enum LegsKit implements Kit
{
	PLAIN_L(36, 70),
	SHORTS(37, null),
	FLARES(38, 72),
	TURN_UPS(39, 76),
	TATTY_L(40, 75),
	BEACH(41, null),
	PRINCELY_L(100, null),
	LEGGINGS(101, null),
	SIDE_STRIPES(102, null),
	RIPPED_L(103, null),
	PATCHED(104, null),
	SKIRT(null, 71),
	LONG_SKIRT(null, 73),
	LONG_NARROW_SKIRT(null, 74),
	SHORT_SKIRT(null, 77),
	LAYERED_L(null, 78),
	SASH_AND_DOTS(null, 135),
	BIG_HEM(null, 136),
	SASH_AND_TROUSERS(null, 137),
	PATTERNED(null, 138),
	TORN_SKIRT(null, 139),
	PATCHED_SKIRT(null, 140);

	private final Integer mascKitId;
	private final Integer femKitId;

	@Override
	public KitType getKitType()
	{
		return KitType.LEGS;
	}

	@Override
	public String getDisplayName()
	{
		switch (this)
		{
			case PLAIN_L:
				return "Plain";
			case TURN_UPS:
				return "Turn-ups";
			case TATTY_L:
				return "Tatty";
			case PRINCELY_L:
				return "Princely";
			case SIDE_STRIPES:
				return "Side-stripes";
			case RIPPED_L:
				return "Ripped";
			case LAYERED_L:
				return "Layered";
			case SASH_AND_DOTS:
				return "Sash & dots";
			case SASH_AND_TROUSERS:
				return "Sash & trousers";
		}
		return Kit.sentenceCaseName(this);
	}

	@Override
	public boolean isHidden()
	{
		return false;
	}
}

package eq.uirs.fashionscape.colors;

import lombok.Value;

@Value
public class ItemColorInfo
{
	public int rgb;
	public double pct;
}

package eq.uirs.fashionscape.colors;

import com.google.gson.annotations.SerializedName;
import lombok.Value;

@Value
public class GenderItemColors
{
	@SerializedName("a")
	public ItemColors any;
	@SerializedName("m")
	public ItemColors masc;
	@SerializedName("f")
	public ItemColors fem;
}

package eq.uirs.fashionscape.colors;

import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import lombok.Value;

@Value
public class ItemColors
{
	public List<ItemColorInfo> itemColorInfo;

	public static class Deserializer implements JsonDeserializer<ItemColors>
	{
		@Override
		public ItemColors deserialize(JsonElement jsonElement, Type type,
									  JsonDeserializationContext jsonDeserializationContext) throws JsonParseException
		{
			List<ItemColorInfo> info = new ArrayList<>();
			JsonArray outer = jsonElement.getAsJsonArray();
			JsonArray rgbs = outer.get(0).getAsJsonArray();
			JsonArray pcts = outer.get(1).getAsJsonArray();
			for (int i = 0; i < rgbs.size(); i++)
			{
				int rgb = rgbs.get(i).getAsInt();
				double pct = pcts.get(i).getAsDouble();
				info.add(new ItemColorInfo(rgb, pct));
			}
			return new ItemColors(info);
		}
	}
}

package eq.uirs.fashionscape.colors;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.data.color.ColorType;
import eq.uirs.fashionscape.data.color.Colorable;
import eq.uirs.fashionscape.data.kit.JawIcon;
import eq.uirs.fashionscape.data.kit.JawKit;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.kit.KitType;

@Slf4j
@Singleton
public class ColorScorer
{
	private final Client client;
	private final FashionManager fashionManager;

	private final Map<Integer, GenderItemColors> allColors;
	private final Map<KitType, List<ItemColorInfo>> kitColors = new ConcurrentHashMap<>();
	private final Map<ColorType, Colorable> playerColors = new ConcurrentHashMap<>();

	private Integer gender;

	@Value
	private static class Score
	{
		// color similarity (scaled 0-1)
		double match;
		// area percentage (0-1) of the match, relative to item or player
		double percentage;
	}

	@Inject
	ColorScorer(Client client, FashionManager fashionManager, Gson baseGson)
	{
		this.client = client;
		this.fashionManager = fashionManager;
		GsonBuilder builder = baseGson.newBuilder()
			.registerTypeAdapter(ItemColors.class, new ItemColors.Deserializer());
		Gson gson = builder.create();
		InputStream stream = this.getClass().getResourceAsStream("colors.json");
		if (stream != null)
		{
			Reader reader = new BufferedReader(new InputStreamReader(stream));
			Type type = new TypeToken<Map<Integer, GenderItemColors>>()
			{
			}.getType();
			allColors = new ConcurrentHashMap<>(gson.fromJson(reader, type));
		}
		else
		{
			allColors = new ConcurrentHashMap<>();
		}
	}

	// this should be called before scoring if relying on current player swaps
	public void updatePlayerInfo()
	{
		kitColors.clear();
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}
		PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
		{
			return;
		}
		playerColors.clear();
		playerColors.putAll(fashionManager.swappedColorsMap());
		gender = composition.getGender();
		for (KitType slot : KitType.values())
		{
			Integer itemId = fashionManager.swappedItemIdIn(slot);
			if (itemId != null)
			{
				kitColors.put(slot, colorsFor(itemId));
			}
		}
		JawIcon icon = fashionManager.swappedIcon();
		if (icon != null)
		{
			Integer iconItemId = JawKit.NO_JAW.getIconItemId(icon);
			if (iconItemId != null)
			{
				kitColors.put(KitType.JAW, colorsFor(iconItemId));
			}
		}
	}

	public void setPlayerInfo(Map<KitType, Integer> itemIds, Map<ColorType, Colorable> colors)
	{
		kitColors.clear();
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}
		playerColors.clear();
		playerColors.putAll(colors);
		PlayerComposition composition = player.getPlayerComposition();
		gender = composition.getGender();
		for (Map.Entry<KitType, Integer> entry : itemIds.entrySet())
		{
			kitColors.put(entry.getKey(), colorsFor(entry.getValue()));
		}
	}

	public void addPlayerInfo(KitType slot, Integer itemId)
	{
		if (itemId != null)
		{
			kitColors.put(slot, colorsFor(itemId));
		}
	}

	public void addPlayerColor(ColorType type, Colorable colorable)
	{
		if (colorable != null)
		{
			playerColors.put(type, colorable);
		}
	}

	/**
	 * scores color similarity between an item and the current player's outfit:
	 * 1 is a perfect match, 0 is a complete mismatch
	 */
	public double score(int itemId, KitType exclude)
	{
		List<ItemColorInfo> colors = colorsFor(itemId);
		return score(colors, exclude, null);
	}

	/**
	 * scores color similarity between a Colorable and the current player's outfit:
	 * 1 is a perfect match, 0 is a complete mismatch
	 */
	public double score(Colorable colorable, ColorType exclude)
	{
		int rgb = colorable.getColor().getRGB();
		List<ItemColorInfo> colors = Collections.singletonList(new ItemColorInfo(rgb, 1.0));
		return score(colors, null, exclude);
	}

	private double score(List<ItemColorInfo> colors, KitType excludeKit, ColorType excludeColor)
	{
		if (colors.isEmpty())
		{
			return 0;
		}
		Map<Integer, Double> playerInfo = getPlayerRgbInfo(excludeKit, excludeColor);
		if (playerInfo.isEmpty())
		{
			return 0;
		}
		// compute an aggregate score relative to the item/color target
		List<Score> scoresTarget = new ArrayList<>();
		for (ItemColorInfo c : colors)
		{
			playerInfo.entrySet().stream()
				.min(Comparator.comparingDouble(e -> colorDistance(c.rgb, e.getKey())))
				.map(e -> new Score(1.0 - colorDistance(c.rgb, e.getKey()), c.pct))
				.ifPresent(scoresTarget::add);
		}
		double targetScore = scoresTarget.stream()
			.mapToDouble(s -> Math.pow(s.match, 2) * s.percentage)
			.sum();
		// compute an aggregate score relative to the player
		List<Score> scoresPlayer = new ArrayList<>();
		for (Map.Entry<Integer, Double> e : playerInfo.entrySet())
		{
			colors.stream()
				.min(Comparator.comparingDouble(c -> colorDistance(c.rgb, e.getKey())))
				.map(c -> new Score(1.0 - colorDistance(c.rgb, e.getKey()), e.getValue()))
				.ifPresent(scoresPlayer::add);
		}
		double playerScore = scoresPlayer.stream()
			.mapToDouble(s -> Math.pow(s.match, 2) * s.percentage)
			.sum();
		// more weighting in relation to the target itself seems to yield better results
		return (3.0 * targetScore + playerScore) / 4.0;
	}

	// Standard Euclidean color distance scaled from 0 (best) to 1 (worst)
	private double colorDistance(int c1, int c2)
	{
		Color color1 = new Color(c1);
		Color color2 = new Color(c2);
		double deltaR = Math.abs(color1.getRed() - color2.getRed()) / 255f;
		double deltaG = Math.abs(color1.getGreen() - color2.getGreen()) / 255f;
		double deltaB = Math.abs(color1.getBlue() - color2.getBlue()) / 255f;
		return Math.sqrt((Math.pow(deltaR, 2) + Math.pow(deltaG, 2) + Math.pow(deltaB, 2)) / 3.0);
	}

	private List<ItemColorInfo> colorsFor(int itemId)
	{
		GenderItemColors genderColors = allColors.get(itemId);
		if (genderColors != null)
		{
			if (genderColors.any != null)
			{
				return genderColors.any.itemColorInfo;
			}
			else
			{
				switch (gender)
				{
					case 0:
						return genderColors.masc.itemColorInfo;
					case 1:
						return genderColors.fem.itemColorInfo;
				}
			}
		}
		return new ArrayList<>();
	}

	// Maps rgb -> summed percentage in player, excluding the given slot or color type
	private Map<Integer, Double> getPlayerRgbInfo(KitType excludeKit, ColorType excludeColor)
	{
		Map<Integer, Double> unscaled = kitColors.entrySet().stream()
			.filter(e -> e.getKey() != excludeKit)
			.map(Map.Entry::getValue)
			.flatMap(List::stream)
			.collect(Collectors.toMap(ItemColorInfo::getRgb, ItemColorInfo::getPct, Double::sum));
		Map<Integer, Double> unscaledColors = playerColors.entrySet().stream()
			.filter(e -> e.getKey() != excludeColor)
			.map(Map.Entry::getValue)
			.collect(Collectors.toMap(c -> c.getColor().getRGB(), c -> 1.0, Double::sum));
		unscaledColors.forEach((rgb, score) -> unscaled.merge(rgb, score, Double::sum));
		final Double scale = unscaled.values().stream().mapToDouble(d -> d).sum();
		return unscaled.entrySet().stream()
			.collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() / scale));
	}
}

package eq.uirs.fashionscape;

import eq.uirs.fashionscape.core.randomizer.RandomizerIntelligence;
import eq.uirs.fashionscape.panel.SortBy;
import java.util.HashMap;
import net.runelite.api.kit.KitType;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import org.apache.commons.lang3.SerializationUtils;

@ConfigGroup(FashionscapeConfig.GROUP)
public interface FashionscapeConfig extends Config
{
	String GROUP = "fashionscape";
	String KEY_EXCLUDE_NON_STANDARD = "excludeNonStandardItems";
	String KEY_EXCLUDE_MEMBERS = "excludeMembersItems";
	String KEY_IMPORT_MENU_ENTRY = "copyMenuEntry";
	String KEY_REAL_KITS = "realKitIds";

	@ConfigItem(
		position = 0,
		keyName = KEY_EXCLUDE_NON_STANDARD,
		name = "Exclude non-standard items",
		description = "Filters out items that cannot be normally equipped anywhere"
	)
	default boolean excludeNonStandardItems()
	{
		return false;
	}

	@ConfigItem(
		position = 1,
		keyName = KEY_EXCLUDE_MEMBERS,
		name = "Exclude members items",
		description = "Filters out members-only objects"
	)
	default boolean excludeMembersItems()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = KEY_IMPORT_MENU_ENTRY,
		name = "\"Copy-outfit\" entry",
		description = "Adds \"copy-outfit\" right click option to other players"
	)
	default boolean copyMenuEntry()
	{
		return true;
	}

	@ConfigSection(
		name = "Randomizer",
		description = "Settings relating to the outfit randomizer",
		position = 3
	)
	String randomizerSettings = "randomizerSettings";

	@ConfigItem(
		position = 0,
		keyName = "randomizerIntelligence",
		name = "Intelligence",
		description = "Randomizer will utilize colour matching with higher settings",
		section = randomizerSettings
	)
	default RandomizerIntelligence randomizerIntelligence()
	{
		return RandomizerIntelligence.LOW;
	}

	@ConfigItem(
		position = 1,
		keyName = "excludeBaseModels",
		name = "Exclude base models",
		description = "Randomizer will not shuffle base models (e.g., hair) if checked",
		section = randomizerSettings
	)
	default boolean excludeBaseModels()
	{
		return false;
	}

	// region Hidden stuff

	@ConfigItem(
		keyName = "preferredSort",
		name = "Preferred sort order",
		description = "Last used result sort order (hidden)",
		hidden = true
	)
	default SortBy preferredSort()
	{
		return SortBy.COLOR_MATCH;
	}

	@ConfigItem(
		keyName = "preferredSort",
		name = "Preferred sort order",
		description = "Last used result sort order (hidden)",
		hidden = true
	)
	void setPreferredSort(SortBy sort);

	@ConfigItem(
		keyName = "currentEquipment",
		name = "Current equipment",
		description = "The player's equipment ids set by the plugin (hidden)",
		hidden = true
	)
	default byte[] currentEquipment()
	{
		return SerializationUtils.serialize(new HashMap<KitType, Integer>());
	}

	@ConfigItem(
		keyName = "currentEquipment",
		name = "Current equipment",
		description = "The player's equipment ids set by the plugin (hidden)",
		hidden = true
	)
	void setCurrentEquipment(byte[] equipIdsMapBytes);

	@ConfigItem(
		keyName = "currentIcon",
		name = "Current icon",
		description = "The player's jaw icon set by the plugin (hidden)",
		hidden = true
	)
	default Integer currentIcon()
	{
		return null;
	}

	@ConfigItem(
		keyName = "currentIcon",
		name = "Current icon",
		description = "The player's jaw icon set by the plugin (hidden)",
		hidden = true
	)
	void setCurrentIcon(Integer iconId);

	@ConfigItem(
		keyName = "currentColors",
		name = "Current colors",
		description = "The player's color ids (map of color type ordinal -> color id) set by the plugin (hidden)",
		hidden = true
	)
	default byte[] currentColors()
	{
		return SerializationUtils.serialize(new HashMap<Integer, Integer>());
	}

	@ConfigItem(
		keyName = "currentColors",
		name = "Current colors",
		description = "The player's color ids set by the plugin (hidden)",
		hidden = true
	)
	void setCurrentColors(byte[] colorMapBytes);

	@ConfigItem(
		keyName = KEY_REAL_KITS,
		name = "Real kit ids",
		description = "Known kit ids of the current player (hidden, per-profile)",
		hidden = true
	)
	default byte[] realKitIds()
	{
		return SerializationUtils.serialize(new HashMap<KitType, Integer>());
	}

	// endregion

}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.core.Exporter;
import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.core.event.ColorChangedListener;
import eq.uirs.fashionscape.core.event.ColorLockChangedListener;
import eq.uirs.fashionscape.core.event.IconChangedListener;
import eq.uirs.fashionscape.core.event.ItemChangedListener;
import eq.uirs.fashionscape.core.event.KitChangedListener;
import eq.uirs.fashionscape.core.event.LockChangedListener;
import eq.uirs.fashionscape.data.color.ColorType;
import java.awt.BorderLayout;
import java.awt.Cursor;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

@Slf4j
public class FashionscapePanel extends PluginPanel
{
	private final Client client;
	private final ClientThread clientThread;
	private final FashionManager fashionManager;
	private final Exporter exporter;

	private JButton undo;
	private JButton redo;
	private JButton shuffle;
	private JButton save;
	private JButton load;
	private JButton clear;

	private final SearchClearingPanel tabDisplayPanel;
	private final MaterialTabGroup tabGroup;
	private final MaterialTab searchTab;

	private final SearchPanel searchPanel;
	private final KitsPanel kitsPanel;

	@RequiredArgsConstructor
	static class SearchClearingPanel extends JPanel
	{
		boolean shouldClearSearch = true;
		private final SearchPanel searchPanel;

		@Override
		public void removeAll()
		{
			if (shouldClearSearch)
			{
				searchPanel.clearResults();
			}
			super.removeAll();
		}
	}

	@Inject
	public FashionscapePanel(SearchPanel searchPanel, KitsPanel kitsPanel, FashionManager fashionManager,
							 ItemManager itemManager, Client client, ClientThread clientThread, Exporter exporter)
	{
		super(false);
		this.client = client;
		this.clientThread = clientThread;
		this.fashionManager = fashionManager;
		this.exporter = exporter;
		tabDisplayPanel = new SearchClearingPanel(searchPanel);
		tabGroup = new MaterialTabGroup(tabDisplayPanel);

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel tabPanel = new JPanel();
		tabPanel.setLayout(new BorderLayout());
		tabPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		SearchOpener searchOpener = new SearchOpener()
		{
			@Override
			public void openSearchFor(KitType slot)
			{
				tabGroup.select(searchTab);
				searchPanel.chooseSlot(slot);
				searchPanel.clearSearch();
			}
		};
		SwapsPanel swapsPanel = new SwapsPanel(fashionManager, itemManager, searchOpener, clientThread);
		this.searchPanel = searchPanel;
		this.kitsPanel = kitsPanel;

		MaterialTab swapsTab = new MaterialTab("Items", tabGroup, swapsPanel);
		MaterialTab kitsTab = new MaterialTab("Base", tabGroup, kitsPanel);
		searchTab = new MaterialTab("Search", tabGroup, searchPanel);

		// need some hacky listeners set up to clear search results when changing tabs
		searchTab.setOnSelectEvent(() -> {
			tabDisplayPanel.shouldClearSearch = false;
			searchPanel.reloadResults();
			kitsPanel.collapseOptions();
			return true;
		});
		kitsTab.setOnSelectEvent(() -> {
			tabDisplayPanel.shouldClearSearch = true;
			return true;
		});
		swapsTab.setOnSelectEvent(() -> {
			tabDisplayPanel.shouldClearSearch = true;
			kitsPanel.collapseOptions();
			return true;
		});

		tabGroup.setBorder(new EmptyBorder(5, 0, 0, 0));
		tabGroup.addTab(swapsTab);
		tabGroup.addTab(kitsTab);
		tabGroup.addTab(searchTab);
		tabGroup.select(swapsTab);

		JPanel buttonPanel = setUpButtonPanel();
		add(buttonPanel, BorderLayout.NORTH);

		tabPanel.add(tabGroup, BorderLayout.NORTH);
		tabPanel.add(tabDisplayPanel, BorderLayout.CENTER);
		add(tabPanel, BorderLayout.CENTER);

		// additional listeners
		final Runnable lockListener = () -> {
			boolean loggedIn = client.getGameState() == GameState.LOGGED_IN;
			boolean unlocked = hasUnlocked();
			boolean nonEmpty = hasNonEmpty();
			checkButtonEnabled(shuffle, loggedIn, unlocked, nonEmpty);
			checkButtonEnabled(clear, loggedIn, unlocked, nonEmpty);
		};
		fashionManager.addEventListener(new LockChangedListener(e -> lockListener.run()));
		fashionManager.addEventListener(new ColorLockChangedListener(e -> lockListener.run()));
		final Runnable saveClearListener = () -> {
			boolean loggedIn = client.getGameState() == GameState.LOGGED_IN;
			boolean unlocked = hasUnlocked();
			boolean nonEmpty = hasNonEmpty();
			checkButtonEnabled(save, loggedIn, unlocked, nonEmpty);
			checkButtonEnabled(clear, loggedIn, unlocked, nonEmpty);
		};
		fashionManager.addEventListener(new ItemChangedListener(e -> saveClearListener.run()));
		fashionManager.addEventListener(new KitChangedListener(e -> saveClearListener.run()));
		fashionManager.addEventListener(new ColorChangedListener(e -> saveClearListener.run()));
		fashionManager.addEventListener(new IconChangedListener(e -> saveClearListener.run()));
	}

	public void onGameStateChanged(GameStateChanged event)
	{
		boolean loggedIn = event.getGameState() == GameState.LOGGED_IN;
		boolean hasNonEmpty = hasNonEmpty();
		boolean hasUnlocked = hasUnlocked();
		checkButtonEnabled(undo, loggedIn, hasUnlocked, hasNonEmpty);
		checkButtonEnabled(redo, loggedIn, hasUnlocked, hasNonEmpty);
		checkButtonEnabled(shuffle, loggedIn, hasUnlocked, hasNonEmpty);
		checkButtonEnabled(save, loggedIn, hasUnlocked, hasNonEmpty);
		checkButtonEnabled(load, loggedIn, hasUnlocked, hasNonEmpty);
		checkButtonEnabled(clear, loggedIn, hasUnlocked, hasNonEmpty);
	}

	public void onPlayerChanged(Player player)
	{
		if (kitsPanel != null)
		{
			kitsPanel.onPlayerChanged(player);
		}
	}

	public void reloadResults()
	{
		if (searchPanel != null)
		{
			searchPanel.reloadResults();
		}
	}

	public void refreshKitsPanel()
	{
		if (kitsPanel != null)
		{
			kitsPanel.populateKitSlots();
		}
	}

	private JPanel setUpButtonPanel()
	{
		JPanel buttonContainer = new JPanel();
		buttonContainer.setBorder(new EmptyBorder(5, 10, 0, 10));
		buttonContainer.setLayout(new GridBagLayout());
		buttonContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.insets = new Insets(0, 1, 0, 1);
		c.weightx = 1;
		c.weighty = 1;
		c.gridx = 0;
		c.gridy = 0;

		boolean isLoggedIn = client.getGameState() == GameState.LOGGED_IN;
		boolean hasUnlocked = hasUnlocked();
		boolean hasNonEmpty = hasNonEmpty();

		undo = new JButton(new ImageIcon(ImageUtil.loadImageResource(getClass(), "undo.png")));
		undo.setToolTipText("Undo");
		undo.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.undoLastSwap();
			reloadResults();
		}));
		checkButtonEnabled(undo, isLoggedIn, hasUnlocked, hasNonEmpty);
		undo.addMouseListener(createHoverListener(undo));
		fashionManager.addUndoQueueChangeListener(size -> checkButtonEnabled(undo, null, null, null));
		undo.setFocusPainted(false);
		buttonContainer.add(undo, c);
		c.gridx++;

		redo = new JButton(new ImageIcon(ImageUtil.loadImageResource(getClass(), "redo.png")));
		redo.setToolTipText("Redo");
		redo.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.redoLastSwap();
			reloadResults();
		}));
		checkButtonEnabled(redo, isLoggedIn, hasUnlocked, hasNonEmpty);
		redo.addMouseListener(createHoverListener(redo));
		fashionManager.addRedoQueueChangeListener(size -> checkButtonEnabled(redo, null, null, null));
		redo.setFocusPainted(false);
		buttonContainer.add(redo, c);
		c.gridx++;

		shuffle = new JButton(new ImageIcon(ImageUtil.loadImageResource(getClass(), "shuffle.png")));
		shuffle.setSize(12, 12);
		shuffle.setToolTipText("Randomize");
		shuffle.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.shuffle();
			reloadResults();
		}));
		checkButtonEnabled(shuffle, isLoggedIn, hasUnlocked, hasNonEmpty);
		shuffle.setFocusPainted(false);
		shuffle.addMouseListener(createHoverListener(shuffle));
		buttonContainer.add(shuffle, c);
		c.gridx++;

		JPopupMenu openSavedFolderMenu = new JPopupMenu();
		JMenuItem openAll = new JMenuItem("Open outfits folder");
		openAll.addActionListener(e -> LinkBrowser.open(Exporter.OUTFITS_DIR.toString()));
		openSavedFolderMenu.add(openAll);

		save = new JButton(new ImageIcon(ImageUtil.loadImageResource(getClass(), "save.png")));
		save.setToolTipText("Save");
		save.addActionListener(e -> openSaveDialog());
		save.setFocusPainted(false);
		save.addMouseListener(createHoverListener(save));
		save.setComponentPopupMenu(openSavedFolderMenu);
		checkButtonEnabled(save, isLoggedIn, hasUnlocked, hasNonEmpty);
		buttonContainer.add(save, c);
		c.gridx++;

		load = new JButton(new ImageIcon(ImageUtil.loadImageResource(getClass(), "load.png")));
		load.setToolTipText("Load");
		load.addActionListener(e -> openLoadDialog());
		load.setFocusPainted(false);
		load.setComponentPopupMenu(openSavedFolderMenu);
		checkButtonEnabled(load, isLoggedIn, hasUnlocked, hasNonEmpty);
		load.addMouseListener(createHoverListener(load));
		buttonContainer.add(load, c);
		c.gridx++;

		JPopupMenu softClearMenu = new JPopupMenu();
		JMenuItem softClear = new JMenuItem("Soft clear");
		softClear.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.revertSwaps(false, false);
			reloadResults();
		}));
		softClearMenu.add(softClear);

		clear = new JButton(new ImageIcon(ImageUtil.loadImageResource(getClass(), "clear.png")));
		clear.setToolTipText("Clear all");
		clear.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.revertSwaps(true, false);
			reloadResults();
		}));
		clear.setFocusPainted(false);
		clear.addMouseListener(createHoverListener(clear));
		clear.setComponentPopupMenu(softClearMenu);
		checkButtonEnabled(clear, isLoggedIn, hasUnlocked, hasNonEmpty);
		buttonContainer.add(clear, c);

		return buttonContainer;
	}

	@SuppressWarnings("ResultOfMethodCallIgnored")
	private void openSaveDialog()
	{
		File outputDir = Exporter.OUTFITS_DIR;
		outputDir.mkdirs();

		JFileChooser fileChooser = new JFileChooser(outputDir)
		{
			@Override
			public void approveSelection()
			{
				File f = getSelectedFile();
				if (!f.getName().endsWith(".txt"))
				{
					f = new File(f.getPath() + ".txt");
				}
				if (f.exists() && getDialogType() == SAVE_DIALOG)
				{
					int result = JOptionPane.showConfirmDialog(
						this,
						"File already exists, overwrite?",
						"Warning",
						JOptionPane.YES_NO_CANCEL_OPTION
					);
					switch (result)
					{
						case JOptionPane.YES_OPTION:
							super.approveSelection();
							return;
						case JOptionPane.NO_OPTION:
						case JOptionPane.CLOSED_OPTION:
							return;
						case JOptionPane.CANCEL_OPTION:
							cancelSelection();
							return;
					}
				}
				super.approveSelection();
			}
		};
		fileChooser.setSelectedFile(new File("outfit.txt"));
		fileChooser.setDialogTitle("Save current outfit");

		int option = fileChooser.showSaveDialog(this);
		if (option == JFileChooser.APPROVE_OPTION)
		{
			File selectedFile = fileChooser.getSelectedFile();
			if (!selectedFile.getName().endsWith(".txt"))
			{
				selectedFile = new File(selectedFile.getPath() + ".txt");
			}
			exporter.export(selectedFile);
		}
	}

	@SuppressWarnings("ResultOfMethodCallIgnored")
	private void openLoadDialog()
	{
		File outputDir = Exporter.OUTFITS_DIR;
		outputDir.mkdirs();

		JFileChooser fileChooser = new JFileChooser(outputDir);
		fileChooser.setDialogTitle("Select an outfit to load");

		int option = fileChooser.showOpenDialog(this);
		if (option == JFileChooser.APPROVE_OPTION)
		{
			File selectedFile = fileChooser.getSelectedFile();
			try (BufferedReader reader = new BufferedReader(new FileReader(selectedFile)))
			{
				List<String> lines = reader.lines().collect(Collectors.toList());
				exporter.parseImports(lines);
			}
			catch (IOException e)
			{
				log.warn("Failed to import swaps from file", e);
			}
		}
	}

	private MouseAdapter createHoverListener(JButton jButton)
	{
		return new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (jButton.isEnabled())
				{
					setCursor(new Cursor(Cursor.HAND_CURSOR));
				}
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		};
	}

	private boolean hasNonEmpty()
	{
		long numSlotSwaps = Arrays.stream(KitType.values())
			.filter(slot -> {
				Integer item = fashionManager.swappedItemIdIn(slot);
				Integer kit = fashionManager.swappedKitIdIn(slot);
				boolean containsNothing = fashionManager.isHidden(slot);
				return item != null || kit != null || containsNothing;
			})
			.count();
		long numColorSwaps = Arrays.stream(ColorType.values())
			.map(fashionManager::swappedColorIdIn)
			.filter(Objects::nonNull)
			.count();
		boolean hasIcon = fashionManager.swappedIcon() != null;
		return numSlotSwaps + numColorSwaps > 0 || hasIcon;
	}

	private boolean hasUnlocked()
	{
		long numUnlockedSlots = Arrays.stream(KitType.values())
			.filter(Objects::nonNull)
			.map(fashionManager::isSlotLocked)
			.filter(b -> !b)
			.count();
		long numUnlockedColors = Arrays.stream(ColorType.values())
			.filter(Objects::nonNull)
			.map(fashionManager::isColorLocked)
			.filter(b -> !b)
			.count();
		long unlockedIcon = fashionManager.isIconLocked() ? 0 : 1;
		return numUnlockedSlots + numUnlockedColors + unlockedIcon > 0;
	}

	private void checkButtonEnabled(JButton button, Boolean isLoggedIn, Boolean hasUnlocked, Boolean hasNonEmpty)
	{
		if (button == null)
		{
			return;
		}
		boolean loggedIn = isLoggedIn != null ? isLoggedIn : client.getGameState() == GameState.LOGGED_IN;
		boolean unlocked = hasUnlocked != null ? hasUnlocked : hasUnlocked();
		boolean nonEmpty = hasNonEmpty != null ? hasNonEmpty : hasNonEmpty();
		boolean enabled = loggedIn;
		if (button == undo)
		{
			enabled &= fashionManager.canUndo();
		}
		else if (button == redo)
		{
			enabled &= fashionManager.canRedo();
		}
		else if (button == shuffle)
		{
			enabled &= unlocked;
		}
		else if (button == save)
		{
			enabled &= nonEmpty;
		}
		else if (button == clear)
		{
			// can clear regardless of login state
			enabled = nonEmpty;
		}
		// note: load just requires login
		button.setEnabled(enabled);
	}
}


package eq.uirs.fashionscape.panel;

import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;

/**
 * Panel that opens a dropdown menu of options to select
 */
@Slf4j
abstract class DropdownIconPanel extends AbsIconLabelPanel
{
	static final Dimension BUTTON_SIZE = new Dimension(16, 16);
	static final int ICON_CORNER_RADIUS = 15;

	protected final JButton lockButton = new JButton();
	protected final JButton xButton = new JButton();
	// constrain items in the list of dropdown results
	protected final JPanel optionsContainer = new JPanel();

	DropdownIconPanel(BufferedImage image, ClientThread clientThread)
	{
		super(image, clientThread);

		icon.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				openDropdown();
			}
		});
	}

	protected void configureButton(JButton button)
	{
		button.setBorder(new EmptyBorder(0, 2, 0, 2));
		button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		button.setPreferredSize(BUTTON_SIZE);
		button.setFocusPainted(false);
		button.setBorderPainted(false);
		button.setContentAreaFilled(false);
	}

	abstract void openDropdown();
}

package eq.uirs.fashionscape.panel;

public enum SortBy
{
	COLOR_MATCH,
	ALPHABETICAL,
	RELEASE;

	@Override
	public String toString()
	{
		switch (this)
		{
			case RELEASE:
				return "Release";
			case ALPHABETICAL:
				return "Alphabetical";
			case COLOR_MATCH:
				return "Colour match";
			default:
				return "";
		}
	}
}

package eq.uirs.fashionscape.panel;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableMap;
import eq.uirs.fashionscape.FashionscapeConfig;
import eq.uirs.fashionscape.FashionscapePlugin;
import eq.uirs.fashionscape.colors.ColorScorer;
import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.core.event.LockChanged;
import eq.uirs.fashionscape.core.event.LockChangedListener;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

/**
 * Tab panel that houses the search UI: bar, filters, sort, results, etc.
 */
public class SearchPanel extends JPanel
{
	private static final int DEBOUNCE_DELAY_MS = 200;
	private static final String ERROR_PANEL = "ERROR_PANEL";
	private static final String RESULTS_PANEL = "RESULTS_PANEL";
	private static final Set<Integer> VALID_SLOT_IDS = Arrays.stream(PanelEquipSlot.values())
		.map(PanelEquipSlot::getKitType)
		.filter(Objects::nonNull)
		.map(KitType::getIndex)
		.collect(Collectors.toSet());

	private final Client client;
	private final FashionManager fashionManager;
	private final ItemManager itemManager;
	private final ClientThread clientThread;
	private final FashionscapeConfig config;
	private final ScheduledExecutorService executor;
	private final ColorScorer colorScorer;

	// constrain items in the list of results
	private final GridBagConstraints itemConstraints = new GridBagConstraints();
	private final CardLayout cardLayout = new CardLayout();
	private final IconTextField searchBar = new IconTextField();
	private final MaterialTabGroup slotFilter = new MaterialTabGroup();
	private final JPanel resultsPanel = new JPanel();
	private final JScrollPane resultsScrollPane;
	private final JPanel centerPanel = new JPanel(cardLayout);
	private final PluginErrorPanel errorPanel = new PluginErrorPanel();
	private final Map<PanelEquipSlot, MaterialTab> tabMap;
	private final List<SearchItemPanel> searchPanels = new ArrayList<>();

	private final List<Result> results = new ArrayList<>();
	private final AtomicBoolean searchInProgress = new AtomicBoolean();
	private final OnSelectionChangingListener listener = new OnSelectionChangingListener()
	{
		@Override
		public void onSearchSelectionChanging(KitType slot)
		{
			for (SearchItemPanel item : searchPanels)
			{
				if (Objects.equals(item.itemId, fashionManager.swappedItemIdIn(slot)) ||
					(item.itemId != null && item.itemId < 0 && fashionManager.isHidden(slot)))
				{
					item.resetBackground();
				}
			}
		}
	};

	private Future<?> searchFuture = null;
	private Function<ItemComposition, Boolean> filter;
	private boolean allowShortQueries = false;
	private SortBy sort;
	private KitType selectedSlot = null;
	private boolean hasSearched = false;
	private final Map<Integer, Double> scores = new HashMap<>();

	private final Comparator<Result> itemAlphaComparator = Comparator.comparing(Result::getName);

	@Value
	private static class Result
	{
		@Nullable
		ItemComposition itemComposition;
		BufferedImage icon;
		KitType slot;

		int getId() {
			return itemComposition != null ? itemComposition.getId() : NothingItemComposition.ID;
		}

		String getName() {
			return itemComposition != null ? itemComposition.getMembersName() : NothingItemComposition.NAME;
		}
	}

	@Inject
	public SearchPanel(Client client, FashionManager fashionManager, ClientThread clientThread,
					   ItemManager itemManager, ScheduledExecutorService executor,
					   FashionscapeConfig config, ColorScorer colorScorer)
	{
		this.client = client;
		this.fashionManager = fashionManager;
		this.itemManager = itemManager;
		this.clientThread = clientThread;
		this.executor = executor;
		this.config = config;
		this.colorScorer = colorScorer;
		this.sort = config.preferredSort();

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// constrain top-level view groups
		GridBagConstraints groupConstraints = new GridBagConstraints();
		groupConstraints.fill = GridBagConstraints.HORIZONTAL;
		groupConstraints.weightx = 1;
		groupConstraints.weighty = 0;
		groupConstraints.gridx = 0;
		groupConstraints.gridy = 0;

		itemConstraints.fill = GridBagConstraints.HORIZONTAL;
		itemConstraints.weightx = 1;
		itemConstraints.weighty = 0;
		itemConstraints.gridx = 0;
		itemConstraints.gridy = 0;

		JPanel container = new JPanel();
		container.setLayout(new GridBagLayout());
		container.setBorder(new EmptyBorder(10, 10, 10, 10));
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		this.tabMap = setUpSlotFilters();
		setUpSearchBar();

		resultsPanel.setLayout(new GridBagLayout());
		resultsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel wrapper = new JPanel(new BorderLayout());
		wrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wrapper.add(resultsPanel, BorderLayout.NORTH);

		resultsScrollPane = new JScrollPane(wrapper);
		resultsScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resultsScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(10, 0));
		resultsScrollPane.setVisible(false);

		JPanel infoWrapper = new JPanel(new BorderLayout());
		infoWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		errorPanel.setContent("Equipment Search", "Items you can try on will appear here.");
		infoWrapper.add(errorPanel, BorderLayout.NORTH);

		centerPanel.add(resultsScrollPane, RESULTS_PANEL);
		centerPanel.add(infoWrapper, ERROR_PANEL);

		cardLayout.show(centerPanel, ERROR_PANEL);

		JPanel sortBar = new JPanel();
		sortBar.setLayout(new GridLayout(1, 2));
		sortBar.setBorder(new EmptyBorder(5, 0, 0, 0));
		sortBar.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JLabel sortLabel = new JLabel("Sort by");
		sortLabel.setForeground(Color.WHITE);
		sortLabel.setMaximumSize(new Dimension(0, 0));
		sortLabel.setPreferredSize(new Dimension(0, 0));
		sortBar.add(sortLabel);

		JComboBox<SortBy> sortBox = createSortBox(config);
		sortBar.add(sortBox);

		container.add(slotFilter, groupConstraints);
		groupConstraints.gridy++;
		container.add(searchBar, groupConstraints);
		groupConstraints.gridy++;
		container.add(sortBar, groupConstraints);
		groupConstraints.gridy++;

		add(container, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);

		SwingUtilities.invokeLater(searchBar::requestFocusInWindow);

		fashionManager.addEventListener(new LockChangedListener((e) -> {
			if (e.getType() != LockChanged.Type.KIT)
			{
				updateTabIcon(e);
			}
		}));
	}

	private JComboBox<SortBy> createSortBox(FashionscapeConfig config)
	{
		JComboBox<SortBy> sortBox = new JComboBox<>(SortBy.values());
		sortBox.setSelectedItem(this.sort);
		sortBox.setPreferredSize(new Dimension(sortBox.getPreferredSize().width, 25));
		sortBox.setForeground(Color.WHITE);
		sortBox.setFocusable(false);
		sortBox.addItemListener(e -> {
			if (e.getStateChange() == ItemEvent.SELECTED)
			{
				SortBy selectedSort = (SortBy) sortBox.getSelectedItem();
				config.setPreferredSort(selectedSort);
				sort = selectedSort;
				updateSearchDebounced();
			}
		});
		return sortBox;
	}

	public void clearResults()
	{
		searchPanels.clear();
		SwingUtil.fastRemoveAll(resultsPanel);
	}

	public void reloadResults()
	{
		updateSearchDebounced();
		SwingUtilities.invokeLater(searchBar::requestFocusInWindow);
	}

	public void chooseSlot(KitType slot)
	{
		PanelEquipSlot panelSlot = Arrays.stream(PanelEquipSlot.values())
			.filter(p -> p.getKitType() == slot)
			.findFirst()
			.orElse(PanelEquipSlot.ALL);
		MaterialTab tab = tabMap.get(panelSlot);
		if (tab != null)
		{
			slotFilter.select(tab);
		}
	}

	public void clearSearch()
	{
		if (!Strings.isNullOrEmpty(searchBar.getText()))
		{
			searchBar.setText("");
		}
		results.clear();
		searchPanels.clear();
		SwingUtilities.invokeLater(() -> {
			SwingUtil.fastRemoveAll(resultsPanel);
			resultsPanel.updateUI();
			searchBar.requestFocusInWindow();
		});
	}

	private Map<PanelEquipSlot, MaterialTab> setUpSlotFilters()
	{
		ImmutableMap.Builder<PanelEquipSlot, MaterialTab> builder = new ImmutableMap.Builder<>();
		slotFilter.setLayout(new GridLayout(2, 5, 5, 5));
		slotFilter.setBorder(new EmptyBorder(0, 0, 10, 0));
		MaterialTab allTab = null;
		for (PanelEquipSlot filterSlot : PanelEquipSlot.values())
		{
			MaterialTab tab = new MaterialTab(new ImageIcon(), slotFilter, null);
			builder.put(filterSlot, tab);
			boolean isLocked = false;
			if (filterSlot.getKitType() == null)
			{
				allTab = tab;
			}
			else
			{
				isLocked = fashionManager.isItemLocked(filterSlot.getKitType());
			}
			ImageIcon icon = iconFor(filterSlot, isLocked);
			tab.setIcon(icon);
			tab.setToolTipText(filterSlot.getDisplayName());
			tab.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseEntered(MouseEvent e)
				{
					setCursor(new Cursor(Cursor.HAND_CURSOR));
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
				}
			});
			tab.setOnSelectEvent(() -> {
				filter = itemComposition -> {
					KitType kitType = filterSlot.getKitType();
					selectedSlot = kitType;
					Integer slotId = fashionManager.slotIdFor(itemComposition);
					if (kitType == null)
					{
						// allow any equipment slot that is also a KitType (so no ammo, etc)
						return slotId != null && VALID_SLOT_IDS.contains(slotId);
					}
					else
					{
						return slotId != null && kitType.getIndex() == slotId;
					}
				};
				// individual slots will show all results all the time
				allowShortQueries = filterSlot.getKitType() != null;
				// reset scroll position
				updateSearchDebounced(() -> resultsScrollPane.getVerticalScrollBar().setValue(0));
				return true;
			});
			slotFilter.addTab(tab);
		}
		if (allTab != null)
		{
			slotFilter.select(allTab);
		}
		return builder.build();
	}

	private void setUpSearchBar()
	{
		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(100, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.addActionListener(e -> updateSearchDebounced());
		searchBar.addClearListener(this::clearSearch);
		searchBar.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				hasSearched = true;
				updateSearchDebounced();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				hasSearched = true;
				updateSearchDebounced();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				hasSearched = true;
				updateSearchDebounced();
			}
		});
	}

	private void updateSearchDebounced()
	{
		updateSearchDebounced(() -> {
			// no-op
		});
	}

	private void updateSearchDebounced(Runnable postExec)
	{
		Future<?> future = searchFuture;
		if (searchFuture != null)
		{
			future.cancel(false);
		}
		searchFuture = executor.schedule(() -> clientThread.invokeLater(() -> {
			if (!updateSearch(postExec))
			{
				// search was in progress; try again later
				updateSearchDebounced(postExec);
			}
		}), DEBOUNCE_DELAY_MS, TimeUnit.MILLISECONDS);
	}

	// should only be called from debouncer and on client thread
	private boolean updateSearch(Runnable postExec)
	{
		boolean willUpdate = searchInProgress.compareAndSet(false, true);
		if (willUpdate)
		{
			results.clear();

			String search = searchBar.getText().toLowerCase();
			if (!allowShortQueries && search.length() < 2)
			{
				searchPanels.clear();
				SwingUtilities.invokeLater(() -> {
					SwingUtil.fastRemoveAll(resultsPanel);
					resultsPanel.updateUI();
					if (hasSearched)
					{
						errorPanel.setContent("Search too short", "Type a longer search for results");
					}
					cardLayout.show(centerPanel, ERROR_PANEL);
					searchInProgress.set(false);
				});
				return true;
			}

			Set<Integer> ids = new HashSet<>();
			Set<Integer> skips = FashionscapePlugin.getItemIdsToExclude(config);
			for (int i = 0; i < client.getItemCount(); i++)
			{
				ItemComposition itemComposition = null;
				ItemStats stats = null;
				try
				{
					int canonical = itemManager.canonicalize(i);
					if (skips.contains(canonical))
					{
						continue;
					}
					itemComposition = itemManager.getItemComposition(canonical);
					stats = itemManager.getItemStats(canonical);
				}
				catch (Exception ignored)
				{
				}
				// id might already be in results due to canonicalize
				if (itemComposition != null && stats != null && stats.isEquipable() &&
					!ids.contains(itemComposition.getId()) && isValidSearch(itemComposition, search))
				{
					ids.add(itemComposition.getId());
					try
					{
						KitType slot = KitType.values()[stats.getEquipment().getSlot()];
						AsyncBufferedImage image = itemManager.getImage(itemComposition.getId());
						results.add(new Result(itemComposition, image, slot));
					}
					catch (Exception ignored)
					{
					}
				}
			}
			if (selectedSlot != null && FashionManager.ALLOWS_NOTHING.contains(selectedSlot) &&
				NothingItemComposition.NAME.toLowerCase().contains(search))
			{
				BufferedImage image = ImageUtil.loadImageResource(getClass(), selectedSlot.name().toLowerCase() + ".png");
				results.add(0, new Result(null, image, selectedSlot));
			}

			searchPanels.clear();
			scores.clear();
			switch (this.sort)
			{
				case RELEASE:
					addPendingResults(postExec);
					break;
				case ALPHABETICAL:
					executor.submit(() -> {
						results.sort(itemAlphaComparator);
						addPendingResults(postExec);
					});
					break;
				case COLOR_MATCH:
					executor.submit(() -> {
						performSuggestedSort();
						addPendingResults(postExec);
					});
					break;
			}
		}
		return willUpdate;
	}

	private void performSuggestedSort()
	{
		colorScorer.updatePlayerInfo();
		for (Result result : results)
		{
			int itemId = result.getId();
			scores.put(itemId, colorScorer.score(itemId, selectedSlot));
		}
		results.sort(Comparator.comparing(r ->
			-scores.getOrDefault(r.getId(), 0.0)));
	}

	// only to be called from updateSearch
	private void addPendingResults(Runnable postExec)
	{
		SwingUtilities.invokeLater(() -> {
			SwingUtil.fastRemoveAll(resultsPanel);
			if (results.isEmpty())
			{
				String slotName = "any";
				if (selectedSlot != null)
				{
					slotName = selectedSlot.name().toLowerCase();
				}
				errorPanel.setContent("No results",
					"No items match \"" + searchBar.getText() + "\" in " + slotName + " slot");
				cardLayout.show(centerPanel, ERROR_PANEL);
			}
			else
			{
				boolean firstItem = true;
				boolean showScores = true;
				for (Result result : results)
				{
					Integer itemId = result.getId();
					Double score = scores.get(itemId);
					if (firstItem)
					{
						showScores = score != null && score != 0.0;
					}
					if (!showScores)
					{
						score = null;
					}
					SearchItemPanel panel = new SearchItemPanel(itemId, result.getIcon(),
						result.getSlot(), itemManager, fashionManager, clientThread, listener, score);
					searchPanels.add(panel);
					int topPadding = firstItem ? 0 : 5;
					firstItem = false;
					JPanel marginWrapper = new JPanel(new BorderLayout());
					marginWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
					marginWrapper.setBorder(new EmptyBorder(topPadding, 10, 0, 10));
					marginWrapper.add(panel, BorderLayout.NORTH);
					resultsPanel.add(marginWrapper, itemConstraints);
					itemConstraints.gridy++;
				}
				cardLayout.show(centerPanel, RESULTS_PANEL);
				resultsPanel.updateUI();
			}
			searchInProgress.set(false);
			postExec.run();
		});
	}

	private boolean isValidSearch(ItemComposition itemComposition, String query)
	{
		String name = itemComposition.getMembersName().toLowerCase();
		// The client assigns "null" to item names of items it doesn't know about
		if (name.equals("null") || !name.contains(query))
		{
			return false;
		}
		return filter == null || filter.apply(itemComposition);
	}

	private void updateTabIcon(LockChanged event)
	{
		KitType slot = event.getSlot();
		boolean isLocked = event.isLocked();
		Arrays.stream(PanelEquipSlot.values())
			.filter(p -> p.getKitType() == slot)
			.findFirst()
			.ifPresent(panelEquipSlot -> updateTabIcon(panelEquipSlot, isLocked));
	}

	private void updateTabIcon(PanelEquipSlot panelSlot, boolean isLocked)
	{
		MaterialTab tab = tabMap.get(panelSlot);
		if (tab != null)
		{
			tab.setIcon(iconFor(panelSlot, isLocked));
		}
	}

	private ImageIcon iconFor(PanelEquipSlot panelSlot, boolean isLocked)
	{
		String lockStr = isLocked ? "-lock" : "";
		String iconName = panelSlot.getDisplayName().toLowerCase() + lockStr + ".png";
		return new ImageIcon(ImageUtil.loadImageResource(getClass(), iconName));
	}

}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.FashionscapeConfig;
import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.data.color.ColorType;
import eq.uirs.fashionscape.data.kit.JawIcon;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

/**
 * Tab panel that houses "base" player models and colors
 */
@Slf4j
public class KitsPanel extends JPanel
{
	private final FashionManager fashionManager;
	private final ClientThread clientThread;
	private final ItemManager itemManager;
	private final Client client;
	private final FashionscapeConfig config;

	private final JPanel resultsPanel = new JPanel();
	private final JScrollPane scrollPane = new JScrollPane();
	private final List<KitItemPanel> kitPanels = new ArrayList<>();
	private JawIconPanel jawIconPanel = null;

	private Integer gender;
	private final KitColorOpener kitColorOpener = (slot, type) -> {
		kitPanels.forEach(panel -> {
			if (slot == panel.getSlot() && type == panel.getType())
			{
				Integer gender = getGender();
				if (gender != null)
				{
					panel.openOptions(gender);
				}
			}
			else
			{
				panel.closeOptions();
			}
		});
		if (jawIconPanel != null)
		{
			if (slot == null && type == null)
			{
				jawIconPanel.openOptions();
			}
			else
			{
				jawIconPanel.closeOptions();
			}
		}
		updateUI();
		scrollPane.revalidate();
	};

	@Value
	private static class KitColorResult
	{
		KitType slot;
		Integer id; // icon id if icon, kit id otherwise

		ColorType colorType;
		Integer colorId;
	}

	@Inject
	public KitsPanel(FashionManager fashionManager, ClientThread clientThread, Client client, FashionscapeConfig config,
					 ItemManager itemManager)
	{
		this.fashionManager = fashionManager;
		this.clientThread = clientThread;
		this.client = client;
		this.config = config;
		this.itemManager = itemManager;

		setLayout(new GridLayout(1, 1));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(new EmptyBorder(5, 10, 5, 10));

		resultsPanel.setLayout(new GridBagLayout());
		resultsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(10, 0));

		JPanel resultsWrapper = new JPanel(new BorderLayout());
		resultsWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resultsWrapper.add(resultsPanel, BorderLayout.NORTH);

		scrollPane.setViewportView(resultsWrapper);
		add(scrollPane, BorderLayout.CENTER);
		populateKitSlots();
	}

	public void collapseOptions()
	{
		for (KitItemPanel kitPanel : kitPanels)
		{
			kitPanel.closeOptions();
		}
		updateUI();
		scrollPane.revalidate();
	}

	void populateKitSlots()
	{
		clientThread.invokeLater(() -> {
			List<KitColorResult> results = new ArrayList<>();
			for (PanelKitSlot slot : PanelKitSlot.values())
			{
				KitType kitType = slot.getKitType();
				ColorType colorType = slot.getColorType();
				Integer kitId = null;
				Integer colorId = null;

				if (kitType == null && colorType == null)
				{
					if (config.excludeNonStandardItems() || config.excludeMembersItems())
					{
						continue;
					}
					JawIcon jawIcon = fashionManager.swappedIcon();
					Integer iconId = jawIcon != null ? jawIcon.getId() : null;
					results.add(new KitColorResult(null, iconId, null, null));
				}
				else
				{
					if (kitType != null)
					{
						kitId = fashionManager.swappedKitIdIn(kitType);
					}
					if (colorType != null)
					{
						colorId = fashionManager.swappedColorIdIn(colorType);
					}
					results.add(new KitColorResult(kitType, kitId, colorType, colorId));
				}
			}
			SwingUtilities.invokeLater(() -> addKitSlotPanels(results));
		});
	}

	private void addKitSlotPanels(List<KitColorResult> results)
	{
		resultsPanel.removeAll();
		kitPanels.clear();
		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.anchor = GridBagConstraints.PAGE_START;
		c.weightx = 1;
		c.weighty = 0;
		c.gridx = 0;
		c.gridy = 0;

		for (KitColorResult result : results)
		{
			BufferedImage image = null;
			JPanel panel;
			if (result.colorType == null && result.slot == null)
			{
				image = ImageUtil.loadImageResource(getClass(), "icon.png");
				JawIconPanel jawPanel = new JawIconPanel(image, clientThread, fashionManager, itemManager, kitColorOpener,
					result.id);
				jawIconPanel = jawPanel;
				panel = jawPanel;
			}
			else
			{
				if (result.slot != null)
				{
					image = ImageUtil.loadImageResource(getClass(), result.slot.name().toLowerCase() + ".png");
				}
				KitItemPanel kitPanel = new KitItemPanel(fashionManager, result.colorType, result.colorId, result.slot,
					result.id, kitColorOpener, image, clientThread);
				kitPanels.add(kitPanel);
				panel = kitPanel;
			}
			JPanel marginWrapper = new JPanel(new BorderLayout());
			marginWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
			marginWrapper.setBorder(new EmptyBorder(5, 0, 0, 0));
			marginWrapper.add(panel, BorderLayout.NORTH);
			resultsPanel.add(marginWrapper, c);
			c.gridy++;
		}
		revalidate();
		repaint();
	}

	public void onPlayerChanged(Player player)
	{
		if (player != null)
		{
			PlayerComposition composition = player.getPlayerComposition();
			if (composition != null)
			{
				int gender = composition.getGender();
				if (this.gender == null || this.gender != gender)
				{
					this.gender = gender;
					populateKitSlots();
				}
			}
		}
	}

	// returns null if gender cannot be determined
	@Nullable
	private Integer getGender()
	{
		Player player = client.getLocalPlayer();
		if (player != null)
		{
			PlayerComposition composition = player.getPlayerComposition();
			if (composition != null)
			{
				return composition.getGender();
			}
		}
		return null;
	}
}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.core.FashionManager;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.util.Objects;
import javax.annotation.Nullable;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

@Slf4j
class SearchItemPanel extends AbsItemPanel
{
	private final FashionManager fashionManager;
	private final KitType slot;

	public SearchItemPanel(@Nullable Integer itemId, BufferedImage icon, KitType slot,
						   ItemManager itemManager, FashionManager fashionManager, ClientThread clientThread,
						   OnSelectionChangingListener listener, Double score)
	{
		super(itemId, icon, itemManager, clientThread);
		this.fashionManager = fashionManager;
		this.slot = slot;

		MouseAdapter itemPanelMouseListener = new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (!fashionManager.isItemLocked(slot))
				{
					for (JPanel panel : highlightPanels)
					{
						matchComponentBackground(panel, ColorScheme.DARK_GRAY_HOVER_COLOR);
					}
					setCursor(new Cursor(Cursor.HAND_CURSOR));
				}
				fashionManager.hoverOverItem(slot, itemId);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				for (JPanel panel : highlightPanels)
				{
					matchComponentBackground(panel, defaultBackgroundColor());
				}
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
				fashionManager.hoverAway();
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				// pre-emptively set background
				boolean isAlreadySelected = isMatch();
				Color bg = isAlreadySelected ? nonHighlightColor : ColorScheme.MEDIUM_GRAY_COLOR;
				for (JPanel panel : highlightPanels)
				{
					matchComponentBackground(panel, bg);
				}
				// now swap it
				clientThread.invokeLater(() -> {
					if (!fashionManager.isItemLocked(slot))
					{
						listener.onSearchSelectionChanging(slot);
						fashionManager.hoverSelectItem(slot, itemId);
					}
				});
			}
		};

		addMouseListener(itemPanelMouseListener);

		// Item details panel
		int rows = score == null ? 1 : 2;
		JPanel rightPanel = new JPanel(new GridLayout(rows, 1));
		rightPanel.setBorder(new EmptyBorder(0, 5, 0, 5));
		highlightPanels.add(rightPanel);
		rightPanel.add(label);

		if (score != null)
		{
			DecimalFormat format = new DecimalFormat("#.#");
			JLabel scoreLabel = new JLabel();
			scoreLabel.setForeground(Color.WHITE);
			scoreLabel.setMaximumSize(new Dimension(0, 0));
			scoreLabel.setPreferredSize(new Dimension(0, 0));
			scoreLabel.setText(format.format(score * 100.0) + "%");
			scoreLabel.setForeground(getScoreColor(score));
			rightPanel.add(scoreLabel);
		}

		for (JPanel panel : highlightPanels)
		{
			matchComponentBackground(panel, defaultBackgroundColor());
		}

		add(rightPanel, BorderLayout.CENTER);
	}

	public void resetBackground()
	{
		for (JPanel panel : highlightPanels)
		{
			matchComponentBackground(panel, nonHighlightColor);
		}
	}

	private Color defaultBackgroundColor()
	{
		if (isMatch())
		{
			return ColorScheme.MEDIUM_GRAY_COLOR;
		}
		else
		{
			return nonHighlightColor;
		}
	}

	private boolean isMatch()
	{
		if (itemId < 0)
		{
			return fashionManager.isHidden(slot);
		}
		else
		{
			return Objects.equals(itemId, fashionManager.swappedItemIdIn(slot));
		}
	}

	private Color getScoreColor(Double score)
	{
		int red = (int) (255.0 * (1 - Math.pow(score, 2)));
		int green = (int) (255.0 * Math.pow(score, 2));
		return new Color(red, green, 0);
	}
}

package eq.uirs.fashionscape.panel;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;
import net.runelite.client.util.Text;

@Getter
@RequiredArgsConstructor
public enum PanelEquipSlot
{
	ALL(null),
	HEAD(KitType.HEAD),
	AMULET(KitType.AMULET),
	CAPE(KitType.CAPE),
	TORSO(KitType.TORSO),
	WEAPON(KitType.WEAPON),
	SHIELD(KitType.SHIELD),
	HANDS(KitType.HANDS),
	LEGS(KitType.LEGS),
	BOOTS(KitType.BOOTS);

	private final KitType kitType;

	public String getDisplayName()
	{
		return Text.titleCase(this);
	}
}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.data.color.ColorType;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.kit.KitType;
import net.runelite.client.util.Text;

@Getter
@RequiredArgsConstructor
public enum PanelKitSlot
{
	SKIN(null, ColorType.SKIN),
	HAIR(KitType.HAIR, ColorType.HAIR),
	JAW(KitType.JAW, ColorType.HAIR),
	TORSO(KitType.TORSO, ColorType.TORSO),
	ARMS(KitType.ARMS, ColorType.TORSO),
	HANDS(KitType.HANDS, null),
	LEGS(KitType.LEGS, ColorType.LEGS),
	BOOTS(KitType.BOOTS, ColorType.BOOTS),
	ICON(null, null);

	private final KitType kitType;

	private final ColorType colorType;

	public String getDisplayName()
	{
		return Text.titleCase(this);
	}
}

package eq.uirs.fashionscape.panel;

/**
 * ItemComposition representing "nothing". Only to be displayed in search results.
 */
class NothingItemComposition
{
	public static final String NAME = "Nothing";
	public static final int ID = -1;
}

package eq.uirs.fashionscape.panel;

import net.runelite.api.kit.KitType;

interface OnSelectionChangingListener
{
	void onSearchSelectionChanging(KitType slot);
}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.core.event.ColorChangedListener;
import eq.uirs.fashionscape.core.event.ColorLockChangedListener;
import eq.uirs.fashionscape.core.event.KitChangedListener;
import eq.uirs.fashionscape.core.event.LockChanged;
import eq.uirs.fashionscape.core.event.LockChangedListener;
import eq.uirs.fashionscape.data.color.ColorType;
import eq.uirs.fashionscape.data.color.Colorable;
import eq.uirs.fashionscape.data.kit.Kit;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

/**
 * Could represent either a player's kit, a color, or both for a given slot.
 */
@Slf4j
public class KitItemPanel extends DropdownIconPanel
{
	private static final Dimension COLOR_CHOOSER_SIZE = new Dimension(15, 15);

	@Getter
	private final ColorType type;
	@Getter
	private final KitType slot;

	private final FashionManager fashionManager;
	private final KitColorOpener kitColorOpener;

	private final Map<Integer, Colorable> colorMap = new HashMap<>();

	private final JButton lockColorButton = new JButton();
	private final List<Kit> allKits = new ArrayList<>();

	private Integer colorId;
	private Color color;
	private Integer kitId;

	public KitItemPanel(FashionManager fashionManager, ColorType type, Integer colorId, KitType slot, Integer kitId,
						KitColorOpener kitColorOpener, BufferedImage image, ClientThread clientThread)
	{
		super(image, clientThread);
		this.fashionManager = fashionManager;
		this.kitColorOpener = kitColorOpener;
		this.slot = slot;
		this.type = type;
		this.colorId = colorId;
		this.kitId = kitId;
		if (type != null)
		{
			for (Colorable colorable : type.getColorables())
			{
				colorMap.put(colorable.getColorId(type), colorable);
			}
		}

		JPanel rightPanel = new JPanel(new BorderLayout());
		rightPanel.setBackground(nonHighlightColor);
		rightPanel.setBorder(new EmptyBorder(0, 5, 0, 0));
		highlightPanels.add(rightPanel);
		rightPanel.add(label, BorderLayout.CENTER);

		setIconTooltip();

		int cols = type != null && slot != null ? 3 : 2;
		JPanel buttons = new JPanel(new GridLayout(1, cols, 2, 0));
		buttons.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		if (slot != null)
		{
			allKits.clear();
			allKits.addAll(Arrays.asList(Kit.allInSlot(slot, false)));
			setKitName();
			setIcon(icon, image);
			fashionManager.addEventListener(new KitChangedListener(e -> {
				if (slot == e.getSlot())
				{
					this.kitId = e.getKitId();
					setKitName();
					updateXButton();
				}
			}));
			configureButton(lockButton);
			lockButton.addActionListener(e -> {
				fashionManager.toggleKitLocked(slot);
				updateLockButton();
				updateXButton();
			});
			buttons.add(lockButton);
		}
		else if (type != null)
		{
			BufferedImage colorImage = ImageUtil.loadImageResource(this.getClass(), "color.png");
			setIcon(icon, colorImage);
			setColorName();
		}

		if (type != null)
		{
			setIconColor();
			fashionManager.addEventListener(new ColorChangedListener(e -> {
				if (type == e.getType())
				{
					this.colorId = e.getColorId();
					setIconColor();
					if (slot == null)
					{
						setColorName();
					}
					setIconTooltip();
					updateXButton();
				}
			}));
			configureButton(lockColorButton);
			lockColorButton.addActionListener(e -> {
				fashionManager.toggleColorLocked(type);
				updateColorLockButton();
				updateXButton();
			});
			buttons.add(lockColorButton);
		}
		else
		{
			icon.setBorder(new RoundedBorder(ColorScheme.LIGHT_GRAY_COLOR, ICON_CORNER_RADIUS));
		}

		configureButton(xButton);
		xButton.setIcon(new ImageIcon(ImageUtil.loadImageResource(this.getClass(), "x.png")));
		xButton.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.revert(slot, type);
			SwingUtilities.invokeLater(() -> {
				updateLockButton();
				updateColorLockButton();
				updateXButton();
			});
		}));
		buttons.add(xButton);

		updateLockButton();
		updateColorLockButton();
		updateXButton();

		optionsContainer.setLayout(new BorderLayout());
		optionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		optionsContainer.setVisible(false);
		add(optionsContainer, BorderLayout.SOUTH);
		rightPanel.add(buttons, BorderLayout.EAST);
		add(rightPanel, BorderLayout.CENTER);

		fashionManager.addEventListener(new LockChangedListener(e -> {
			if (e.getSlot() == slot && e.getType() != LockChanged.Type.ITEM)
			{
				updateLockButton();
			}
		}));
		fashionManager.addEventListener(new ColorLockChangedListener(e -> {
			if (e.getType() == type)
			{
				updateColorLockButton();
			}
		}));
	}

	@Override
	void openDropdown()
	{
		kitColorOpener.openOptions(slot, type);
	}

	public void openOptions(Integer gender)
	{
		optionsContainer.removeAll();
		if (optionsContainer.isVisible())
		{
			optionsContainer.setVisible(false);
			return;
		}
		else
		{
			optionsContainer.setVisible(true);
		}

		JPanel colorsBox = new JPanel();
		colorsBox.setLayout(new GridBagLayout());
		colorsBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		if (type != null)
		{
			colorsBox.setBorder(new EmptyBorder(10, 0, 0, 0));
			GridBagConstraints c = new GridBagConstraints();
			c.fill = GridBagConstraints.NONE;
			c.anchor = GridBagConstraints.LINE_START;
			c.weightx = 0;
			c.weighty = 0;
			c.gridx = 0;
			c.gridy = 0;

			for (Colorable colorable : type.getColorables())
			{
				JLabel colorLabel = createColorLabel(colorable);

				JPanel colorWrapper = new JPanel(new BorderLayout());
				colorWrapper.setBorder(new EmptyBorder(1, 1, 1, 1));
				colorWrapper.add(colorLabel, BorderLayout.CENTER);

				colorsBox.add(colorWrapper, c);
				if (c.gridx == 9)
				{
					c.gridx = 0;
					c.gridy++;
				}
				else
				{
					c.gridx++;
				}
			}
		}
		optionsContainer.add(colorsBox, BorderLayout.NORTH);

		JPanel kitsList = new JPanel();
		kitsList.setLayout(new GridBagLayout());
		kitsList.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		if (slot != null)
		{
			kitsList.setBorder(new EmptyBorder(10, 0, 0, 0));
			GridBagConstraints c = new GridBagConstraints();
			c.fill = GridBagConstraints.HORIZONTAL;
			c.anchor = GridBagConstraints.LINE_START;
			c.weightx = 1;
			c.weighty = 1;
			c.gridx = 0;
			c.gridy = 0;

			for (Kit kit : allKits)
			{
				final Integer kitId = kit.getKitId(gender);
				if (kitId == null)
				{
					continue;
				}
				JLabel kitLabel = createKitLabel(kit, kitId);
				kitsList.add(kitLabel, c);
				c.gridy++;
			}
		}
		optionsContainer.add(kitsList, BorderLayout.CENTER);

		optionsContainer.updateUI();
	}

	private JLabel createColorLabel(Colorable colorable)
	{
		JLabel colorLabel = new JLabel();
		colorLabel.setOpaque(true);
		colorLabel.setBackground(colorable.getColor());
		colorLabel.setPreferredSize(COLOR_CHOOSER_SIZE);
		colorLabel.setToolTipText(colorable.getDisplayName());
		colorLabel.setBorder(BorderFactory.createLineBorder(ColorScheme.LIGHT_GRAY_COLOR));
		colorLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (!fashionManager.isColorLocked(type))
				{
					setCursor(new Cursor(Cursor.HAND_CURSOR));
				}
				fashionManager.hoverOverColor(type, colorable.getColorId(type));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
				fashionManager.hoverAway();
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				fashionManager.hoverSelectColor(type, colorable.getColorId(type));
			}
		});
		return colorLabel;
	}

	private JLabel createKitLabel(Kit kit, Integer kitId)
	{
		JLabel kitLabel = new JLabel();
		kitLabel.setBorder(new EmptyBorder(5, 5, 0, 5));
		kitLabel.setText(kit.getDisplayName());
		kitLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (!fashionManager.isKitLocked(slot))
				{
					setCursor(new Cursor(Cursor.HAND_CURSOR));
				}
				fashionManager.hoverOverKit(slot, kitId);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
				fashionManager.hoverAway();
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				fashionManager.hoverSelectKit(slot, kitId);
			}
		});
		return kitLabel;
	}

	public void closeOptions()
	{
		optionsContainer.removeAll();
		optionsContainer.setVisible(false);
	}

	private void setKitName()
	{
		String kitName = "Not set";
		if (kitId != null)
		{
			Kit kit = FashionManager.KIT_ID_TO_KIT.get(kitId);
			if (kit != null)
			{
				kitName = kit.getDisplayName();
			}
		}
		label.setText(kitName);
	}

	private void setColorName()
	{
		String colorName = "Not set";
		if (colorId != null)
		{
			try
			{
				colorName = colorMap.get(colorId).getDisplayName();
			}
			catch (Exception ignored)
			{
			}
		}
		label.setText(colorName);
	}

	private void setIconColor()
	{
		color = ColorScheme.LIGHT_GRAY_COLOR;
		if (colorId != null)
		{
			Colorable colorable = colorMap.get(colorId);
			if (colorable != null)
			{
				color = colorable.getColor();
			}
		}
		Border border = new RoundedBorder(color, ICON_CORNER_RADIUS);
		icon.setBorder(border);
		updateColorLockButton();
	}

	private void setIconTooltip()
	{
		StringBuilder sb = new StringBuilder();
		if (slot != null)
		{
			sb.append(Text.titleCase(slot));
		}
		else if (type != null)
		{
			sb.append(Text.titleCase(type));
		}

		if (type != null)
		{
			Colorable colorable = colorMap.get(colorId);
			if (colorable != null)
			{
				if (sb.length() > 0)
				{
					sb.append(": ");
				}
				sb.append(colorable.getDisplayName().toLowerCase());
			}
		}
		icon.setToolTipText(sb.toString());
	}

	private void updateLockButton()
	{
		if (slot != null)
		{
			boolean locked = fashionManager.isKitLocked(slot);
			String lockIcon = locked ? "lock" : "unlock";
			lockButton.setIcon(
				new ImageIcon(ImageUtil.loadImageResource(this.getClass(), lockIcon + ".png")));
			String action = locked ? "Unlock" : "Lock";
			lockButton.setToolTipText(action + " " + slot.name().toLowerCase() + " slot");
		}
	}

	private void updateColorLockButton()
	{
		if (type != null)
		{
			boolean locked = fashionManager.isColorLocked(type);
			String lockStr = locked ? "lock" : "unlock";
			BufferedImage lockIcon = ImageUtil.loadImageResource(this.getClass(), lockStr + ".png");
			lockIcon = fillImage(lockIcon, color, 50);
			lockColorButton.setIcon(new ImageIcon(lockIcon));
			String action = locked ? "Unlock" : "Lock";
			lockColorButton.setToolTipText(action + " " + type.name().toLowerCase() + " colour");
		}
	}

	private void updateXButton()
	{
		xButton.setEnabled(colorId != null || kitId != null);
		String text = slot != null ?
			slot.name().toLowerCase() + " slot" :
			type != null ? type.name().toLowerCase() + " colour" : "";
		xButton.setToolTipText("Clear " + text);
	}

	// copied from ImageUtil, modified to allow for alpha threshold
	public BufferedImage fillImage(final BufferedImage image, final Color color, int alphaThreshold)
	{
		final BufferedImage filledImage = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);
		for (int x = 0; x < filledImage.getWidth(); x++)
		{
			for (int y = 0; y < filledImage.getHeight(); y++)
			{
				int pixel = image.getRGB(x, y);
				int a = pixel >>> 24;
				if (a < alphaThreshold)
				{
					continue;
				}

				filledImage.setRGB(x, y, color.getRGB());
			}
		}
		return filledImage;
	}
}

package eq.uirs.fashionscape.panel;

import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;

abstract class AbsItemPanel extends AbsIconLabelPanel
{
	public final Integer itemId;

	protected final ItemManager itemManager;

	AbsItemPanel(@Nullable Integer itemId, BufferedImage icon, ItemManager itemManager,
				 ClientThread clientThread)
	{
		super(icon, clientThread);
		this.itemId = itemId;
		this.itemManager = itemManager;
		setItemName(itemId);
	}

	protected void setItemName(Integer itemId)
	{
		clientThread.invokeLater(() -> {
			String itemName = "Not set";
			if (itemId != null)
			{
				if (itemId >= 0)
				{
					ItemComposition itemComposition = itemManager.getItemComposition(itemId);
					itemName = itemComposition.getMembersName();
				}
				else
				{
					itemName = NothingItemComposition.NAME;
				}
			}
			label.setText(itemName);
		});
	}
}

package eq.uirs.fashionscape.panel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;

abstract class AbsIconLabelPanel extends JPanel
{
	static final Dimension ICON_SIZE = new Dimension(32, 32);

	protected final ClientThread clientThread;
	protected final List<JPanel> highlightPanels;
	protected final Color nonHighlightColor;
	protected final JLabel label;
	protected final JLabel icon;

	AbsIconLabelPanel(BufferedImage image, ClientThread clientThread)
	{
		this.clientThread = clientThread;

		BorderLayout layout = new BorderLayout();
		setLayout(layout);
		setBorder(new EmptyBorder(0, 10, 0, 10));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		highlightPanels = new ArrayList<>();
		nonHighlightColor = getBackground();
		highlightPanels.add(this);

		setBorder(new EmptyBorder(5, 5, 5, 5));

		icon = new JLabel();
		icon.setPreferredSize(ICON_SIZE);
		icon.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setIcon(icon, image);
		add(icon, BorderLayout.LINE_START);

		label = new JLabel();
		label.setForeground(Color.WHITE);
		label.setMaximumSize(new Dimension(0, 0));
		label.setPreferredSize(new Dimension(0, 0));
		// subclasses will add the item label as needed
	}

	protected void setIcon(JLabel icon, BufferedImage image)
	{
		if (image != null)
		{
			if (image instanceof AsyncBufferedImage)
			{
				((AsyncBufferedImage) image).addTo(icon);
			}
			else
			{
				icon.setIcon(new ImageIcon(image));
			}
		}
	}

	protected void matchComponentBackground(JPanel panel, Color color)
	{
		panel.setBackground(color);
		for (Component c : panel.getComponents())
		{
			c.setBackground(color);
		}
	}
}

package eq.uirs.fashionscape.panel;

import java.awt.Color;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.RoundRectangle2D;
import javax.swing.border.AbstractBorder;

public class RoundedBorder extends AbstractBorder
{

	private final Color color;
	private final int radius;

	public RoundedBorder(Color color, int radius)
	{
		this.color = color;
		this.radius = radius;
	}

	@Override
	public void paintBorder(Component c, Graphics g, int x, int y, int width, int height)
	{
		Graphics2D g2d = (Graphics2D) g.create();
		g2d.setColor(color);
		g2d.draw(new RoundRectangle2D.Double(x, y, width - 1, height - 1, radius, radius));
		g2d.dispose();
	}
}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.data.color.ColorType;
import net.runelite.api.kit.KitType;

interface KitColorOpener
{
	void openOptions(KitType slot, ColorType type);
}

package eq.uirs.fashionscape.panel;

import net.runelite.api.kit.KitType;

interface SearchOpener
{
	void openSearchFor(KitType slot);
}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.core.event.KnownKitChangedListener;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

/**
 * Tab panel that houses all equipment swaps and the main controls
 */
@Slf4j
class SwapsPanel extends JPanel
{
	private final FashionManager fashionManager;
	private final ItemManager itemManager;
	private final ClientThread clientThread;
	private final SearchOpener searchOpener;

	private final Set<KitType> unknownSlots = new HashSet<>();

	private JPanel slotsPanel;
	private JPanel warningsPanel;

	@Value
	private static class SlotResult
	{
		KitType slot;
		Integer itemId;
		BufferedImage image;
	}

	public SwapsPanel(FashionManager fashionManager, ItemManager itemManager, SearchOpener searchOpener,
					  ClientThread clientThread)
	{
		this.fashionManager = fashionManager;
		this.itemManager = itemManager;
		this.searchOpener = searchOpener;
		this.clientThread = clientThread;

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setBorder(new EmptyBorder(5, 10, 5, 10));

		JPanel swapsPanel = setUpContentPanel();
		JPanel scrollWrapper = new JPanel(new BorderLayout());
		scrollWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollWrapper.add(swapsPanel, BorderLayout.NORTH);

		JScrollPane scrollPane = new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
			JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(10, 0));
		scrollPane.setViewportView(scrollWrapper);

		add(scrollPane, BorderLayout.CENTER);

		fashionManager.addEventListener(new KnownKitChangedListener(e -> {
			KitType slot = e.getSlot();
			if (e.isUnknown())
			{
				this.unknownSlots.add(slot);
			}
			else
			{
				this.unknownSlots.remove(slot);
			}
			SwingUtilities.invokeLater(this::refreshWarnings);
		}));
	}

	private JPanel setUpContentPanel()
	{
		JPanel contentContainer = new JPanel();
		contentContainer.setLayout(new GridBagLayout());
		contentContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.insets = new Insets(0, 1, 0, 1);
		c.weightx = 1;
		c.weighty = 1;
		c.gridx = 0;
		c.gridy = 0;

		slotsPanel = new JPanel();
		slotsPanel.setLayout(new GridBagLayout());
		slotsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		populateSwapSlots();
		contentContainer.add(slotsPanel, c);
		c.gridy++;

		warningsPanel = new JPanel();
		warningsPanel.setLayout(new GridBagLayout());
		warningsPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
		warningsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		refreshWarnings();
		contentContainer.add(warningsPanel, c);

		return contentContainer;
	}

	private void populateSwapSlots()
	{
		clientThread.invokeLater(() -> {
			List<SlotResult> slotResults = new ArrayList<>();
			for (PanelEquipSlot panelSlot : PanelEquipSlot.values())
			{
				KitType slot = panelSlot.getKitType();
				if (slot == null)
				{
					continue;
				}
				Integer itemId = fashionManager.swappedItemIdIn(slot);
				BufferedImage image;
				if (itemId != null && itemId >= 0)
				{
					ItemComposition itemComposition = itemManager.getItemComposition(itemId);
					image = itemManager.getImage(itemComposition.getId());
				}
				else
				{
					image = ImageUtil.loadImageResource(getClass(), slot.name().toLowerCase() + ".png");
				}
				slotResults.add(new SlotResult(slot, itemId, image));
			}
			SwingUtilities.invokeLater(() -> addSlotItemPanels(slotResults));
		});
	}

	private void addSlotItemPanels(List<SlotResult> results)
	{
		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.anchor = GridBagConstraints.PAGE_START;
		c.weightx = 1;
		c.weighty = 0;
		c.gridx = 0;
		c.gridy = 0;

		for (SlotResult s : results)
		{
			SwapItemPanel itemPanel = new SwapItemPanel(s.itemId, s.image, itemManager,
				clientThread, fashionManager, s.slot, searchOpener);
			JPanel marginWrapper = new JPanel(new BorderLayout());
			marginWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
			marginWrapper.setBorder(new EmptyBorder(5, 0, 0, 0));
			marginWrapper.add(itemPanel, BorderLayout.NORTH);
			slotsPanel.add(marginWrapper, c);
			c.gridy++;
		}
	}

	public void refreshWarnings()
	{
		warningsPanel.removeAll();

		if (!unknownSlots.isEmpty())
		{
			GridBagConstraints c = new GridBagConstraints();
			c.fill = GridBagConstraints.HORIZONTAL;
			c.anchor = GridBagConstraints.PAGE_START;
			c.weightx = 1;
			c.weighty = 0;
			c.gridx = 0;
			c.gridy = 0;

			JLabel label = new JLabel("<html>Some base models can't be determined. Remove " +
				"some of your in-game equipment to detect them:</html>");
			label.setPreferredSize(new Dimension(100, 60));
			label.setForeground(ColorScheme.BRAND_ORANGE);
			warningsPanel.add(label, c);
			c.gridy++;

			unknownSlots.stream()
				.sorted(Comparator.comparing(KitType::name))
				.forEach(slot -> {
					JLabel slotLabel = new JLabel(Text.titleCase(slot));
					slotLabel.setForeground(ColorScheme.BRAND_ORANGE);
					warningsPanel.add(slotLabel, c);
					c.gridy++;
				});
		}
		revalidate();
	}

}

package eq.uirs.fashionscape.panel;

import com.google.common.base.Objects;
import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.core.event.IconChangedListener;
import eq.uirs.fashionscape.core.event.IconLockChangedListener;
import eq.uirs.fashionscape.data.kit.JawIcon;
import java.awt.BorderLayout;
import java.awt.Cursor;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import javax.annotation.Nullable;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

/**
 * Special base panel handling BA/SW icons since they're tied to jaw kits
 */
@Slf4j
public class JawIconPanel extends DropdownIconPanel
{
	private final FashionManager fashionManager;
	private final ItemManager itemManager;
	private final KitColorOpener kitColorOpener;
	private JawIcon jawIcon = null;

	JawIconPanel(BufferedImage image, ClientThread clientThread, FashionManager fashionManager, ItemManager itemManager,
				 KitColorOpener kitColorOpener, @Nullable Integer iconId)
	{
		super(image, clientThread);
		this.fashionManager = fashionManager;
		this.itemManager = itemManager;
		this.kitColorOpener = kitColorOpener;
		Arrays.stream(JawIcon.values())
			.filter(i -> Objects.equal(i.getId(), iconId))
			.findFirst()
			.ifPresent(i -> this.jawIcon = i);

		JPanel rightPanel = new JPanel(new BorderLayout());
		rightPanel.setBackground(nonHighlightColor);
		rightPanel.setBorder(new EmptyBorder(0, 5, 0, 0));
		highlightPanels.add(rightPanel);
		rightPanel.add(label, BorderLayout.CENTER);

		setIconTooltip();

		JPanel buttons = new JPanel(new GridLayout(1, 2, 2, 0));
		buttons.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		setIcon(icon, image);
		icon.setBorder(new RoundedBorder(ColorScheme.LIGHT_GRAY_COLOR, ICON_CORNER_RADIUS));

		fashionManager.addEventListener(new IconChangedListener(e -> {
			if (jawIcon != e.getIcon())
			{
				this.jawIcon = e.getIcon();
				setIconName();
				updateIconImage();
				updateXButton();
			}
		}));
		fashionManager.addEventListener(new IconLockChangedListener(e -> updateLockButton()));
		configureButton(lockButton);
		lockButton.addActionListener(e -> {
			fashionManager.toggleIconLocked();
			updateLockButton();
			updateXButton();
		});
		buttons.add(lockButton);

		configureButton(xButton);
		xButton.setIcon(new ImageIcon(ImageUtil.loadImageResource(this.getClass(), "x.png")));
		xButton.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.revertIcon();
			SwingUtilities.invokeLater(() -> {
				updateLockButton();
				updateXButton();
			});
		}));
		buttons.add(xButton);

		updateLockButton();
		updateXButton();

		optionsContainer.setLayout(new BorderLayout());
		optionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		optionsContainer.setVisible(false);
		add(optionsContainer, BorderLayout.SOUTH);
		rightPanel.add(buttons, BorderLayout.EAST);
		add(rightPanel, BorderLayout.CENTER);

		setIconName();
		updateIconImage();
	}

	@Override
	void openDropdown()
	{
		kitColorOpener.openOptions(null, null);
	}

	public void openOptions()
	{
		optionsContainer.removeAll();
		if (optionsContainer.isVisible())
		{
			optionsContainer.setVisible(false);
			return;
		}
		else
		{
			optionsContainer.setVisible(true);
		}

		JPanel iconsList = new JPanel();
		iconsList.setLayout(new GridBagLayout());
		iconsList.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		iconsList.setBorder(new EmptyBorder(10, 0, 0, 0));
		GridBagConstraints c = new GridBagConstraints();
		c.fill = GridBagConstraints.HORIZONTAL;
		c.anchor = GridBagConstraints.LINE_START;
		c.weightx = 1;
		c.weighty = 1;
		c.gridx = 0;
		c.gridy = 0;

		for (JawIcon jawIcon : JawIcon.values())
		{
			if (jawIcon == JawIcon.NOTHING)
			{
				continue;
			}
			JLabel iconLabel = createIconLabel(jawIcon);
			iconsList.add(iconLabel, c);
			c.gridy++;
		}
		optionsContainer.add(iconsList, BorderLayout.CENTER);
		optionsContainer.updateUI();
	}

	private JLabel createIconLabel(JawIcon jawIcon)
	{
		JLabel iconLabel = new JLabel();
		iconLabel.setBorder(new EmptyBorder(5, 5, 0, 5));
		iconLabel.setText(jawIcon.getDisplayName());
		iconLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (!fashionManager.isIconLocked())
				{
					setCursor(new Cursor(Cursor.HAND_CURSOR));
				}
				fashionManager.hoverOverIcon(jawIcon);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
				fashionManager.hoverAway();
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				fashionManager.hoverSelectIcon(jawIcon);
			}
		});
		return iconLabel;
	}

	public void closeOptions()
	{
		optionsContainer.removeAll();
		optionsContainer.setVisible(false);
	}

	private void setIconName()
	{
		String iconName = "Not set";
		if (jawIcon != null)
		{
			iconName = jawIcon.getDisplayName();
		}
		label.setText(iconName);
	}

	private void updateIconImage()
	{
		if (jawIcon != null && jawIcon != JawIcon.NOTHING)
		{
			clientThread.invokeLater(() -> {
				ItemComposition itemComposition = itemManager.getItemComposition(jawIcon.getId());
				AsyncBufferedImage image = itemManager.getImage(itemComposition.getId());
				image.addTo(icon);
			});
		}
		else
		{
			BufferedImage image = ImageUtil.loadImageResource(getClass(), "icon.png");
			setIcon(icon, image);
		}
	}

	private void updateXButton()
	{
		xButton.setEnabled(jawIcon != null);
		xButton.setToolTipText("Clear icon");
	}

	private void updateLockButton()
	{
		boolean locked = fashionManager.isIconLocked();
		String lockIcon = locked ? "lock" : "unlock";
		lockButton.setIcon(
			new ImageIcon(ImageUtil.loadImageResource(this.getClass(), lockIcon + ".png")));
		String action = locked ? "Unlock" : "Lock";
		lockButton.setToolTipText(action + " icon");
	}

	private void setIconTooltip()
	{
		StringBuilder sb = new StringBuilder();
		sb.append("Icon");
		if (jawIcon != null)
		{
			if (sb.length() > 0)
			{
				sb.append(": ");
			}
			sb.append(jawIcon.getDisplayName().toLowerCase());
		}
		icon.setToolTipText(sb.toString());
	}
}

package eq.uirs.fashionscape.panel;

import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.core.event.ItemChangedListener;
import eq.uirs.fashionscape.core.event.LockChanged;
import eq.uirs.fashionscape.core.event.LockChangedListener;
import java.awt.BorderLayout;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.annotation.Nullable;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

@Slf4j
class SwapItemPanel extends AbsItemPanel
{
	private static final Dimension ICON_SIZE = new Dimension(20, 20);

	private final KitType slot;
	private final FashionManager fashionManager;
	private final JButton lockButton;
	private final JButton xButton;
	private final SearchOpener searchOpener;
	private Integer itemId;
	private MouseAdapter mouseAdapter = null;
	private MouseAdapter hoverAdapter = null;

	public SwapItemPanel(@Nullable Integer itemId, BufferedImage icon, ItemManager itemManager,
						 ClientThread clientThread, FashionManager fashionManager, KitType slot,
						 SearchOpener searchOpener)
	{
		super(itemId, icon, itemManager, clientThread);
		this.slot = slot;
		this.itemId = itemId;
		this.fashionManager = fashionManager;
		this.searchOpener = searchOpener;
		// Item details panel
		JPanel rightPanel = new JPanel(new BorderLayout());
		rightPanel.setBackground(nonHighlightColor);
		rightPanel.setBorder(new EmptyBorder(0, 5, 0, 0));
		highlightPanels.add(rightPanel);
		rightPanel.add(label, BorderLayout.CENTER);
		JPanel buttons = new JPanel(new GridLayout(1, 2, 2, 0));
		buttons.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lockButton = new JButton();
		lockButton.setBorder(new EmptyBorder(0, 2, 0, 2));
		lockButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		lockButton.setPreferredSize(ICON_SIZE);
		lockButton.setFocusPainted(false);
		lockButton.setBorderPainted(false);
		lockButton.setContentAreaFilled(false);
		lockButton.addActionListener(e -> {
			fashionManager.toggleItemLocked(slot);
			updateLockButton();
			updateXButton();
		});
		buttons.add(lockButton);

		xButton = new JButton();
		xButton.setPreferredSize(ICON_SIZE);
		xButton.setBorder(new EmptyBorder(0, 2, 0, 2));
		xButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		xButton.setFocusPainted(false);
		xButton.setBorderPainted(false);
		xButton.setContentAreaFilled(false);
		xButton.setIcon(new ImageIcon(ImageUtil.loadImageResource(this.getClass(), "x.png")));
		xButton.addActionListener(e -> clientThread.invokeLater(() -> {
			fashionManager.revertSlot(slot);
			SwingUtilities.invokeLater(() -> {
				updateLockButton();
				updateXButton();
			});
		}));
		buttons.add(xButton);

		updateLockButton();
		updateXButton();

		rightPanel.add(buttons, BorderLayout.EAST);

		add(rightPanel, BorderLayout.CENTER);

		fashionManager.addEventListener(new ItemChangedListener(e -> {
			if (e.getSlot() == slot)
			{
				Integer newId = e.getItemId();
				this.itemId = newId;
				setItemName(newId);
				setItemIcon(newId);
				resetMouseListeners();
				updateXButton();
			}
		}));

		fashionManager.addEventListener(new LockChangedListener(e -> {
			if (e.getSlot() == slot && e.getType() != LockChanged.Type.KIT)
			{
				updateLockButton();
			}
		}));

		resetMouseListeners();
	}

	private void resetMouseListeners()
	{
		// Somehow these listeners clear when the item changes, so they're refreshed like this (ugh)
		icon.removeMouseListener(mouseAdapter);
		mouseAdapter = createOpenSearchClickListener();
		icon.addMouseListener(mouseAdapter);
		icon.setToolTipText("Open " + slot.name().toLowerCase() + " slot search");

		icon.removeMouseListener(hoverAdapter);
		xButton.removeMouseListener(hoverAdapter);
		lockButton.removeMouseListener(hoverAdapter);
		hoverAdapter = createHoverListener();
		icon.addMouseListener(hoverAdapter);
		xButton.addMouseListener(hoverAdapter);
		lockButton.addMouseListener(hoverAdapter);
	}

	void updateLockButton()
	{
		boolean locked = fashionManager.isItemLocked(slot);
		String lockIcon = locked ? "lock" : "unlock";
		lockButton.setIcon(
			new ImageIcon(ImageUtil.loadImageResource(this.getClass(), lockIcon + ".png")));
		String action = locked ? "Unlock" : "Lock";
		lockButton.setToolTipText(action + " " + slot.name().toLowerCase() + " slot");
	}

	void updateXButton()
	{
		xButton.setEnabled(itemId != null);
		xButton.setToolTipText("Clear " + slot.name().toLowerCase() + " slot");
	}

	private MouseAdapter createOpenSearchClickListener()
	{
		return new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				searchOpener.openSearchFor(slot);
			}
		};
	}

	private MouseAdapter createHoverListener()
	{
		return new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (e.getComponent().isEnabled())
				{
					setCursor(new Cursor(Cursor.HAND_CURSOR));
				}
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		};
	}

	private void setItemIcon(Integer itemId)
	{
		if (itemId != null && itemId >= 0)
		{
			clientThread.invokeLater(() -> {
				ItemComposition itemComposition = itemManager.getItemComposition(itemId);
				AsyncBufferedImage image = itemManager.getImage(itemComposition.getId());
				image.addTo(icon);
			});
		}
		else
		{
			BufferedImage image = ImageUtil.loadImageResource(getClass(), slot.name().toLowerCase() + ".png");
			setIcon(icon, image);
		}
	}

}

package eq.uirs.fashionscape.core;

import eq.uirs.fashionscape.data.kit.JawIcon;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.kit.KitType;

/**
 * Several slots are tightly coupled in their interactions. This groups them together so
 * that they're submitted for swapping at the same time.
 */
@Getter
public class CompoundSwap
{
	@NonNull
	private final Type type;

	@NonNull
	private final Map<KitType, Integer> equipmentIds;

	@Nullable
	private final JawIcon icon;

	public static List<CompoundSwap> fromMap(Map<KitType, Integer> equipmentIds, @Nullable JawIcon icon)
	{
		List<CompoundSwap> result = new ArrayList<>();
		Map<Type, Map<KitType, Integer>> grouping = equipmentIds.entrySet().stream()
			.collect(Collectors.groupingBy(
				e -> Type.fromSlot(e.getKey()),
				Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)));
		Map<KitType, Integer> heads = grouping.get(Type.HEAD) != null ? grouping.get(Type.HEAD) : new HashMap<>();
		if (!heads.isEmpty() || icon != null)
		{
			result.add(head(heads.get(KitType.HEAD), heads.get(KitType.HAIR), heads.get(KitType.JAW), icon));
		}
		Map<KitType, Integer> torsos = grouping.get(Type.TORSO);
		if (torsos != null && !torsos.isEmpty())
		{
			result.add(torso(torsos.get(KitType.TORSO), torsos.get(KitType.ARMS)));
		}
		Map<KitType, Integer> weapons = grouping.get(Type.WEAPONS);
		if (weapons != null && !weapons.isEmpty())
		{
			result.add(weapons(weapons.get(KitType.WEAPON), weapons.get(KitType.SHIELD)));
		}
		Map<KitType, Integer> singles = grouping.get(Type.SINGLE);
		if (singles != null && !singles.isEmpty())
		{
			singles.forEach((slot, equipId) -> result.add(single(slot, equipId)));
		}
		return result;
	}

	enum Type
	{
		// hair jaw head icon
		HEAD,
		// torso arms
		TORSO,
		// weapon shield
		WEAPONS,
		// any one slot
		SINGLE;

		private static Type fromSlot(KitType slot)
		{
			switch (slot)
			{
				case HEAD:
				case HAIR:
				case JAW:
					return HEAD;
				case TORSO:
				case ARMS:
					return TORSO;
				case WEAPON:
				case SHIELD:
					return WEAPONS;
				default:
					return SINGLE;
			}
		}
	}

	static CompoundSwap single(KitType slot, Integer equipmentId)
	{
		switch (slot)
		{
			case HEAD:
				return head(equipmentId, null, null, null);
			case HAIR:
				return head(null, equipmentId, null, null);
			case JAW:
				return head(null, null, equipmentId, null);
			case TORSO:
				return torso(equipmentId, null);
			case ARMS:
				return torso(null, equipmentId);
			case WEAPON:
				return weapons(equipmentId, null);
			case SHIELD:
				return weapons(null, equipmentId);
		}
		Map<KitType, Integer> map = new HashMap<>();
		map.put(slot, equipmentId);
		return new CompoundSwap(Type.SINGLE, map, null);
	}

	public static CompoundSwap fromIcon(JawIcon icon)
	{
		return new CompoundSwap(Type.HEAD, new HashMap<>(), icon);
	}

	static CompoundSwap head(Integer headEquipId, Integer hairEquipId, Integer jawEquipId, JawIcon icon)
	{
		Map<KitType, Integer> map = new HashMap<>();
		map.put(KitType.HEAD, headEquipId);
		map.put(KitType.HAIR, hairEquipId);
		map.put(KitType.JAW, jawEquipId);
		return new CompoundSwap(Type.HEAD, map, icon);
	}

	static CompoundSwap torso(Integer torsoEquipId, Integer armsEquipId)
	{
		Map<KitType, Integer> map = new HashMap<>();
		map.put(KitType.TORSO, torsoEquipId);
		map.put(KitType.ARMS, armsEquipId);
		return new CompoundSwap(Type.TORSO, map, null);
	}

	static CompoundSwap weapons(Integer weaponEquipId, Integer shieldEquipId)
	{
		Map<KitType, Integer> map = new HashMap<>();
		map.put(KitType.WEAPON, weaponEquipId);
		map.put(KitType.SHIELD, shieldEquipId);
		return new CompoundSwap(Type.WEAPONS, map, null);
	}

	private CompoundSwap(Type type, Map<KitType, Integer> equipmentIds, JawIcon icon)
	{
		this.type = type;
		this.equipmentIds = equipmentIds;
		this.icon = icon;
	}

	/**
	 * @return the sole equipment id for this swap request. this will only make sense for SINGLE type swaps.
	 */
	Integer getEquipmentId()
	{
		return equipmentIds.values().stream().findAny().orElse(null);
	}

	/**
	 * @return the sole kit slot for this swap request. this will only make sense for SINGLE type swaps.
	 */
	KitType getKitType()
	{
		return equipmentIds.keySet().stream().findAny().orElse(null);
	}
}

package eq.uirs.fashionscape.core;

import com.google.common.base.Objects;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import eq.uirs.fashionscape.FashionscapeConfig;
import eq.uirs.fashionscape.core.event.ColorChanged;
import eq.uirs.fashionscape.core.event.ColorLockChanged;
import eq.uirs.fashionscape.core.event.IconChanged;
import eq.uirs.fashionscape.core.event.IconLockChanged;
import eq.uirs.fashionscape.core.event.ItemChanged;
import eq.uirs.fashionscape.core.event.KitChanged;
import eq.uirs.fashionscape.core.event.KnownKitChanged;
import eq.uirs.fashionscape.core.event.LockChanged;
import eq.uirs.fashionscape.core.event.SwapEvent;
import eq.uirs.fashionscape.core.event.SwapEventListener;
import eq.uirs.fashionscape.data.color.ColorType;
import eq.uirs.fashionscape.data.kit.ArmsKit;
import eq.uirs.fashionscape.data.kit.BootsKit;
import eq.uirs.fashionscape.data.kit.HairKit;
import eq.uirs.fashionscape.data.kit.HandsKit;
import eq.uirs.fashionscape.data.kit.JawIcon;
import eq.uirs.fashionscape.data.kit.JawKit;
import eq.uirs.fashionscape.data.kit.LegsKit;
import eq.uirs.fashionscape.data.kit.TorsoKit;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.kit.KitType;
import net.runelite.client.config.ConfigManager;
import org.apache.commons.lang3.SerializationUtils;

/**
 * observable wrapper for user's item swaps. Persists swaps to plugin config.
 */
@Singleton
@Slf4j
public class SavedSwaps
{
	private static final int DEBOUNCE_DELAY_MS = 500;
	// when player's kit info is not known, fall back to showing some default values
	private static final Map<KitType, Integer> FALLBACK_MASC_KITS = new HashMap<>();
	private static final Map<KitType, Integer> FALLBACK_FEM_KITS = new HashMap<>();

	static
	{
		FALLBACK_MASC_KITS.put(KitType.HAIR, HairKit.BALD.getKitId(0));
		FALLBACK_MASC_KITS.put(KitType.JAW, JawKit.GOATEE.getKitId(0));
		FALLBACK_MASC_KITS.put(KitType.TORSO, TorsoKit.PLAIN.getKitId(0));
		FALLBACK_MASC_KITS.put(KitType.ARMS, ArmsKit.REGULAR.getKitId(0));
		FALLBACK_MASC_KITS.put(KitType.LEGS, LegsKit.PLAIN_L.getKitId(0));
		FALLBACK_MASC_KITS.put(KitType.HANDS, HandsKit.PLAIN_H.getKitId(0));
		FALLBACK_MASC_KITS.put(KitType.BOOTS, BootsKit.SMALL.getKitId(0));

		FALLBACK_FEM_KITS.put(KitType.HAIR, HairKit.PIGTAILS.getKitId(1));
		FALLBACK_FEM_KITS.put(KitType.JAW, JawKit.CLEAN_SHAVEN.getKitId(1));
		FALLBACK_FEM_KITS.put(KitType.TORSO, TorsoKit.SIMPLE.getKitId(1));
		FALLBACK_FEM_KITS.put(KitType.ARMS, ArmsKit.SHORT_SLEEVES.getKitId(1));
		FALLBACK_FEM_KITS.put(KitType.LEGS, LegsKit.PLAIN_L.getKitId(1));
		FALLBACK_FEM_KITS.put(KitType.HANDS, HandsKit.PLAIN_H.getKitId(1));
		FALLBACK_FEM_KITS.put(KitType.BOOTS, BootsKit.SMALL.getKitId(1));
	}

	@Inject
	private FashionscapeConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ScheduledExecutorService executor;

	// player's real kit ids, e.g., hairstyles, base clothing
	@Getter
	private final HashMap<KitType, Integer> realKitIds = new HashMap<>();
	// player's real base colors
	private final Map<ColorType, Integer> realColorIds = new HashMap<>();
	// player's real jaw icon (derived from real jaw item)
	@Getter
	private JawIcon realIcon = JawIcon.NOTHING;

	private final HashMap<KitType, Integer> swappedItemIds = new HashMap<>();
	private final HashMap<KitType, Integer> swappedKitIds = new HashMap<>();
	private final HashMap<ColorType, Integer> swappedColorIds = new HashMap<>();
	// swapped icon is stored as item id
	@Getter
	private JawIcon swappedIcon = null;
	// currently only applicable for slots that exclusively hold items
	@Getter
	private final HashSet<KitType> hiddenSlots = new HashSet<>();

	private final Set<KitType> lockedKits = new HashSet<>();
	// If kit is locked, item must also be locked. If item is unlocked, kit must also be unlocked.
	// Only valid state where locks differ is item locked, kit unlocked
	private final Set<KitType> lockedItems = new HashSet<>();
	private final Set<ColorType> lockedColors = new HashSet<>();
	private boolean lockedIcon = false;

	private final Map<String, List<SwapEventListener<? extends SwapEvent>>> listeners = new HashMap<>();

	// should only load once since config might be behind local state
	private boolean hasLoadedConfig = false;
	private Future<?> colorSaveFuture = null;
	private Future<?> kitsSaveFuture = null;
	private Future<?> equipSaveFuture = null;

	/**
	 * Reads saved swaps from config. Should be called after listeners are set (i.e., after panels created)
	 */
	void loadFromConfig()
	{
		if (!hasLoadedConfig)
		{
			hasLoadedConfig = true;
		}
		else
		{
			return;
		}
		byte[] equipment = config.currentEquipment();
		byte[] colors = config.currentColors();
		Integer iconId = config.currentIcon();
		try
		{
			Map<KitType, Integer> equipIds = SerializationUtils.deserialize(equipment);
			equipIds.forEach((slot, equipId) -> {
				if (equipId >= FashionManager.KIT_OFFSET && equipId < FashionManager.ITEM_OFFSET)
				{
					putKit(slot, equipId - FashionManager.KIT_OFFSET);
				}
				else if (equipId >= FashionManager.ITEM_OFFSET)
				{
					putItem(slot, equipId - FashionManager.ITEM_OFFSET);
				}
			});
			Map<Integer, Integer> colorIds = SerializationUtils.deserialize(colors);
			ColorType[] allColorTypes = ColorType.values();
			colorIds.forEach((typeId, colorId) -> putColor(allColorTypes[typeId], colorId));
			JawIcon icon = JawIcon.fromId(iconId);
			if (icon != null)
			{
				putIcon(icon);
			}
		}
		catch (Exception ignored)
		{
			// ignore
		}
	}

	/**
	 * Loads default kits from config. Called during pre-refresh check, on first login and on rsn change
	 */
	void loadRSProfileConfig()
	{
		byte[] realKits = configManager.getRSProfileConfiguration(FashionscapeConfig.GROUP,
			FashionscapeConfig.KEY_REAL_KITS, byte[].class);
		try
		{
			realKitIds.putAll(SerializationUtils.deserialize(realKits));
		}
		catch (Exception ignored)
		{
			// ignore
		}
	}

	void addEventListener(SwapEventListener<? extends SwapEvent> listener)
	{
		String key = listener.getKey();
		List<SwapEventListener<?>> list = listeners.getOrDefault(key, new LinkedList<>());
		list.add(listener);
		listeners.put(key, list);
	}

	void removeListeners()
	{
		listeners.clear();
	}

	Set<Map.Entry<KitType, Integer>> itemEntries()
	{
		return ImmutableSet.copyOf(swappedItemIds.entrySet());
	}

	Set<Map.Entry<KitType, Integer>> hiddenSlotEntries()
	{
		return ImmutableSet.copyOf(
			hiddenSlots.stream()
				.collect(Collectors.toMap(v -> v, v -> 0))
				.entrySet()
		);
	}

	Set<Map.Entry<KitType, Integer>> kitEntries()
	{
		return ImmutableSet.copyOf(swappedKitIds.entrySet());
	}

	Set<Map.Entry<ColorType, Integer>> colorEntries()
	{
		return ImmutableSet.copyOf(swappedColorIds.entrySet());
	}

	public Integer getItem(KitType slot)
	{
		return swappedItemIds.get(slot);
	}

	Integer getKit(KitType slot)
	{
		return swappedKitIds.get(slot);
	}

	Integer getColor(ColorType type)
	{
		return swappedColorIds.get(type);
	}

	Integer getRealColor(ColorType type)
	{
		return realColorIds.get(type);
	}

	/**
	 * Returns the player's actual kit id in the given slot, or null if it's not known.
	 */
	Integer getRealKit(KitType slot)
	{
		return realKitIds.get(slot);
	}

	/**
	 * Returns the player's actual kit id in the given slot, or a fallback kit id if it's not known
	 */
	int getRealKit(KitType slot, Integer gender)
	{
		Integer realKit = getRealKit(slot);
		return realKit != null ? realKit : getFallbackKit(slot, gender);
	}

	int getFallbackKit(KitType slot, Integer gender)
	{
		if (gender == null || slot == null)
		{
			return -FashionManager.KIT_OFFSET;
		}
		Map<KitType, Integer> map = gender == 1 ? FALLBACK_FEM_KITS : FALLBACK_MASC_KITS;
		int result = map.getOrDefault(slot, -FashionManager.KIT_OFFSET);
		if (result != -FashionManager.KIT_OFFSET)
		{
			fireEvent(new KnownKitChanged(true, slot));
		}
		return result;
	}

	public boolean containsSlot(KitType slot)
	{
		if (swappedKitIds.containsKey(slot))
		{
			return true;
		}
		return containsItem(slot);
	}

	public boolean containsItem(KitType slot)
	{
		return swappedItemIds.containsKey(slot);
	}

	public boolean containsIcon()
	{
		return swappedIcon != null;
	}

	public boolean isHidden(KitType slot)
	{
		return hiddenSlots.contains(slot);
	}

	public boolean containsColor(ColorType type)
	{
		return swappedColorIds.containsKey(type);
	}

	void putItem(KitType slot, Integer itemId)
	{
		if (isSlotLocked(slot))
		{
			return;
		}
		if (slot == KitType.JAW)
		{
			log.warn("putting jaw {} - this should not happen", itemId);
		}
		Integer oldId = swappedItemIds.put(slot, itemId);
		hiddenSlots.remove(slot);
		if (swappedKitIds.containsKey(slot))
		{
			removeKit(slot);
		}
		if (!itemId.equals(oldId))
		{
			fireEvent(new ItemChanged(slot, itemId));
			saveEquipmentConfigDebounced();
		}
	}

	void putIcon(JawIcon icon)
	{
		Integer previousId = swappedIcon != null ? swappedIcon.getId() : null;
		Integer newId = icon != null ? icon.getId() : null;
		swappedIcon = icon;
		if (!Objects.equal(previousId, newId))
		{
			fireEvent(new IconChanged(icon));
			saveEquipmentConfigDebounced();
		}
	}

	// this differs from removing, which leaves the slot open for the real item/kit to show
	void putNothing(KitType slot)
	{
		if (lockedItems.contains(slot))
		{
			return;
		}
		Integer oldId = swappedItemIds.remove(slot);
		boolean wasNotHidden = hiddenSlots.add(slot);
		if (oldId != null || wasNotHidden)
		{
			fireEvent(new ItemChanged(slot, -1));
			saveEquipmentConfigDebounced();
		}
	}

	void putKit(KitType slot, Integer kitId)
	{
		if (lockedKits.contains(slot))
		{
			return;
		}
		Integer oldId = swappedKitIds.put(slot, kitId);
		if (swappedItemIds.containsKey(slot))
		{
			removeItem(slot);
		}
		if (!kitId.equals(oldId))
		{
			fireEvent(new KitChanged(slot, kitId));
			saveEquipmentConfigDebounced();
		}
	}

	void putColor(ColorType type, Integer colorId)
	{
		Integer oldId = swappedColorIds.put(type, colorId);
		if (!colorId.equals(oldId))
		{
			fireEvent(new ColorChanged(type, colorId));
			saveColorConfigDebounced();
		}
	}

	void putRealKit(KitType slot, Integer kitId)
	{
		fireEvent(new KnownKitChanged(false, slot));
		Integer oldKitId = realKitIds.put(slot, kitId);
		if (!kitId.equals(oldKitId))
		{
			saveRealKitsDebounced();
		}
	}

	void putRealColor(ColorType type, Integer colorId)
	{
		realColorIds.put(type, colorId);
	}

	void putRealIcon(JawIcon icon)
	{
		realIcon = icon;
	}

	void removeSlot(KitType slot)
	{
		removeItem(slot);
		removeKit(slot);
	}

	private void removeItem(KitType slot)
	{
		if (isItemLocked(slot))
		{
			return;
		}
		Integer oldId = swappedItemIds.remove(slot);
		boolean wasHidden = hiddenSlots.remove(slot);
		if (oldId != null || wasHidden)
		{
			fireEvent(new ItemChanged(slot, null));
			saveEquipmentConfigDebounced();
		}
	}

	private void removeKit(KitType slot)
	{
		if (isKitLocked(slot))
		{
			return;
		}
		Integer oldId = swappedKitIds.remove(slot);
		if (oldId != null)
		{
			fireEvent(new KitChanged(slot, null));
			saveEquipmentConfigDebounced();
		}
	}

	void removeColor(ColorType type)
	{
		Integer oldId = swappedColorIds.remove(type);
		if (oldId != null)
		{
			fireEvent(new ColorChanged(type, null));
			saveColorConfigDebounced();
		}
	}

	void removeIcon()
	{
		if (swappedIcon != null)
		{
			swappedIcon = null;
			fireEvent(new IconChanged(null));
			saveEquipmentConfigDebounced();
		}
	}

	void clearSwapped()
	{
		Set<KitType> swappedItems = Sets.union(new HashSet<>(swappedItemIds.keySet()), new HashSet<>(hiddenSlots));
		Set<KitType> itemSlots = Sets.difference(swappedItems, lockedItems);
		itemSlots.forEach(this::removeItem);
		Set<KitType> kitSlots = Sets.difference(new HashSet<>(swappedKitIds.keySet()), lockedKits);
		kitSlots.forEach(this::removeKit);
		Set<ColorType> colorTypes = Sets.difference(new HashSet<>(swappedColorIds.keySet()), lockedColors);
		colorTypes.forEach(this::removeColor);
		removeIcon();
	}

	void clearRealKits()
	{
		boolean realKitsNeedRefresh = realKitIds.isEmpty();
		realKitIds.clear();
		if (realKitsNeedRefresh)
		{
			saveRealKitsImmediate();
		}
	}

	Set<KitType> getAllLockedKits()
	{
		return Arrays.stream(KitType.values())
			.filter(lockedKits::contains)
			.collect(Collectors.toSet());
	}

	void setLockedKits(Set<KitType> kits)
	{
		for (KitType slot : KitType.values())
		{
			if (lockedKits.contains(slot) && !kits.contains(slot))
			{
				lockedKits.remove(slot);
				fireEvent(new LockChanged(slot, false, LockChanged.Type.KIT));
			}
			else if (!lockedKits.contains(slot) && kits.contains(slot))
			{
				lockedKits.add(slot);
				fireEvent(new LockChanged(slot, true, LockChanged.Type.KIT));
			}
		}
	}

	Set<KitType> getAllLockedItems()
	{
		return Arrays.stream(KitType.values())
			.filter(lockedItems::contains)
			.collect(Collectors.toSet());
	}

	void setLockedItems(Set<KitType> items)
	{
		for (KitType slot : KitType.values())
		{
			if (lockedItems.contains(slot) && !items.contains(slot))
			{
				lockedItems.remove(slot);
				fireEvent(new LockChanged(slot, false, LockChanged.Type.ITEM));
			}
			else if (!lockedItems.contains(slot) && items.contains(slot))
			{
				lockedItems.add(slot);
				fireEvent(new LockChanged(slot, true, LockChanged.Type.ITEM));
			}
		}
	}

	void setIconLocked(boolean locked)
	{
		lockedIcon = locked;
	}

	public boolean isSlotLocked(KitType slot)
	{
		return isKitLocked(slot) || isItemLocked(slot);
	}

	public boolean isKitLocked(KitType slot)
	{
		return lockedKits.contains(slot);
	}

	public boolean isItemLocked(KitType slot)
	{
		return lockedItems.contains(slot);
	}

	public boolean isColorLocked(ColorType type)
	{
		return lockedColors.contains(type);
	}

	public boolean isIconLocked()
	{
		return lockedIcon;
	}

	void toggleItemLocked(KitType slot)
	{
		if (lockedItems.contains(slot))
		{
			lockedItems.remove(slot);
			// if item unlocks, kit must also unlock
			lockedKits.remove(slot);
			fireEvent(new LockChanged(slot, false, LockChanged.Type.KIT));
		}
		else
		{
			lockedItems.add(slot);
		}
		fireEvent(new LockChanged(slot, isItemLocked(slot), LockChanged.Type.ITEM));
	}

	void toggleKitLocked(KitType slot)
	{
		if (lockedKits.contains(slot))
		{
			lockedKits.remove(slot);
		}
		else
		{
			lockedKits.add(slot);
			// if kit is locked, item must be locked too
			lockedItems.add(slot);
			fireEvent(new LockChanged(slot, true, LockChanged.Type.ITEM));
		}
		fireEvent(new LockChanged(slot, isSlotLocked(slot), LockChanged.Type.KIT));
	}

	void toggleColorLocked(ColorType type)
	{
		if (lockedColors.contains(type))
		{
			lockedColors.remove(type);
		}
		else
		{
			lockedColors.add(type);
		}
		fireEvent(new ColorLockChanged(type, isColorLocked(type)));
	}

	void toggleIconLocked()
	{
		lockedIcon = !lockedIcon;
		fireEvent(new IconLockChanged(isIconLocked()));
	}

	void removeAllLocks()
	{
		Set<KitType> slotClears = new HashSet<>(lockedKits);
		slotClears.addAll(lockedItems);
		Set<ColorType> colorClears = new HashSet<>(lockedColors);
		lockedKits.clear();
		lockedItems.clear();
		lockedColors.clear();
		lockedIcon = false;
		slotClears.forEach(slot -> fireEvent(new LockChanged(slot, false, LockChanged.Type.BOTH)));
		colorClears.forEach(type -> fireEvent(new ColorLockChanged(type, false)));
		fireEvent(new IconLockChanged(false));
	}

	void removeSlotLock(KitType slot)
	{
		lockedKits.remove(slot);
		lockedItems.remove(slot);
		fireEvent(new LockChanged(slot, false, LockChanged.Type.BOTH));
	}

	void removeColorLock(ColorType type)
	{
		lockedColors.remove(type);
		fireEvent(new ColorLockChanged(type, false));
	}

	void removeIconLock()
	{
		lockedIcon = false;
		fireEvent(new IconLockChanged(false));
	}

	private void fireEvent(SwapEvent event)
	{
		String key = event.getKey();
		listeners.getOrDefault(key, new LinkedList<>()).forEach(listener -> listener.onEvent(event));
	}

	// this needs to be immediate so that changes are reflected when loading from config
	void saveRealKitsImmediate()
	{
		byte[] bytes = SerializationUtils.serialize(realKitIds);
		configManager.setRSProfileConfiguration(FashionscapeConfig.GROUP, FashionscapeConfig.KEY_REAL_KITS, bytes);
	}

	private void saveEquipmentConfigDebounced()
	{
		Future<?> future = equipSaveFuture;
		if (future != null)
		{
			future.cancel(false);
		}
		equipSaveFuture = executor.schedule(() -> {
			Map<KitType, Integer> itemEquips = swappedItemIds.entrySet().stream()
				.collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + FashionManager.ITEM_OFFSET));
			Map<KitType, Integer> kitEquips = swappedKitIds.entrySet().stream()
				.collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + FashionManager.KIT_OFFSET));
			Map<KitType, Integer> hides = hiddenSlots.stream()
				.collect(Collectors.toMap(v -> v, v -> 0));
			HashMap<KitType, Integer> equips = new HashMap<>(itemEquips);
			equips.putAll(kitEquips);
			equips.putAll(hides);
			byte[] bytes = SerializationUtils.serialize(equips);
			config.setCurrentEquipment(bytes);
			Integer iconId = swappedIcon != null ? swappedIcon.getId() : null;
			config.setCurrentIcon(iconId);
		}, DEBOUNCE_DELAY_MS, TimeUnit.MILLISECONDS);
	}

	private void saveColorConfigDebounced()
	{
		Future<?> future = colorSaveFuture;
		if (future != null)
		{
			future.cancel(false);
		}
		colorSaveFuture = executor.schedule(() -> {
			Map<Integer, Integer> serialMap = swappedColorIds.entrySet().stream()
				.collect(Collectors.toMap(e -> e.getKey().ordinal(), Map.Entry::getValue));
			byte[] bytes = SerializationUtils.serialize(new HashMap<>(serialMap));
			config.setCurrentColors(bytes);
		}, DEBOUNCE_DELAY_MS, TimeUnit.MILLISECONDS);
	}

	private void saveRealKitsDebounced()
	{
		Future<?> future = kitsSaveFuture;
		if (future != null)
		{
			future.cancel(false);
		}
		kitsSaveFuture = executor.schedule(() -> {
			byte[] bytes = SerializationUtils.serialize(realKitIds);
			configManager.setRSProfileConfiguration(FashionscapeConfig.GROUP, FashionscapeConfig.KEY_REAL_KITS, bytes);
		}, DEBOUNCE_DELAY_MS, TimeUnit.MILLISECONDS);
	}

}

package eq.uirs.fashionscape.core;

import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableList;
import eq.uirs.fashionscape.core.event.SwapEvent;
import eq.uirs.fashionscape.core.event.SwapEventListener;
import eq.uirs.fashionscape.core.randomizer.Randomizer;
import eq.uirs.fashionscape.data.anim.IdleAnimationID;
import eq.uirs.fashionscape.data.anim.ItemInteractions;
import eq.uirs.fashionscape.data.color.BootsColor;
import eq.uirs.fashionscape.data.color.ClothingColor;
import eq.uirs.fashionscape.data.color.ColorType;
import eq.uirs.fashionscape.data.color.Colorable;
import eq.uirs.fashionscape.data.color.HairColor;
import eq.uirs.fashionscape.data.color.SkinColor;
import eq.uirs.fashionscape.data.kit.JawIcon;
import eq.uirs.fashionscape.data.kit.JawKit;
import eq.uirs.fashionscape.data.kit.Kit;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.game.ItemEquipmentStats;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;

/**
 * Singleton class that maintains the memory and logic of swapping items through the plugin
 */
@Singleton
@Slf4j
public class FashionManager
{
	public static final Map<Integer, Kit> KIT_ID_TO_KIT = new HashMap<>();
	// item-only slots that can always contain an equipment id of 0
	public static final List<KitType> ALLOWS_NOTHING = ImmutableList.of(KitType.HEAD, KitType.CAPE, KitType.AMULET,
		KitType.WEAPON, KitType.SHIELD);
	public static final int ITEM_OFFSET = PlayerComposition.ITEM_OFFSET;
	public static final int KIT_OFFSET = PlayerComposition.KIT_OFFSET;

	private static final List<KitType> NEVER_ZERO_SLOTS = ImmutableList.of(KitType.TORSO, KitType.LEGS,
		KitType.HAIR, KitType.HANDS, KitType.BOOTS, KitType.JAW);

	static
	{
		for (KitType slot : KitType.values())
		{
			for (Kit value : Kit.allInSlot(slot, true))
			{
				Integer mascId = value.getKitId(0);
				if (mascId != null)
				{
					KIT_ID_TO_KIT.put(mascId, value);
				}
				Integer femId = value.getKitId(1);
				if (femId != null)
				{
					KIT_ID_TO_KIT.put(femId, value);
				}
			}
		}
	}

	@Inject
	private ItemManager itemManager;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private SavedSwaps savedSwaps;

	@Inject
	private Randomizer randomizer;

	@Getter
	private final SwapDiffHistory swapDiffHistory = new SwapDiffHistory(s -> this.restore(s, true));

	@Getter
	@Setter
	private Integer gender;
	private String lastKnownPlayerName = null;
	private SwapDiff hoverSwapDiff;
	// slot -> override equipment id, used to disable the plugin's functionality per slot
	private final Map<KitType, Integer> disabledSlots = new HashMap<>();
	// idle anim id to switch to when weapon slot is disabled (sometimes sourced from non-weapons like minecart)
	private Integer disabledAnimationId = null;

	public void startUp()
	{
		doPreRefreshCheck();
		refreshAllSwaps();
	}

	public void shutDown()
	{
		revertSwaps(true, true);
		savedSwaps.removeListeners();
		swapDiffHistory.removeListeners();
		hoverSwapDiff = null;
	}

	public void onPlayerChanged()
	{
		doPreRefreshCheck();
		savedSwaps.loadFromConfig();
		refreshAllSwaps();
	}

	public void addEventListener(SwapEventListener<? extends SwapEvent> listener)
	{
		savedSwaps.addEventListener(listener);
	}

	public void addUndoQueueChangeListener(Consumer<Integer> listener)
	{
		swapDiffHistory.addUndoQueueChangeListener(listener);
	}

	public void addRedoQueueChangeListener(Consumer<Integer> listener)
	{
		swapDiffHistory.addRedoQueueChangeListener(listener);
	}

	public boolean isSlotLocked(KitType slot)
	{
		return savedSwaps.isSlotLocked(slot);
	}

	public boolean isKitLocked(KitType slot)
	{
		return savedSwaps.isKitLocked(slot);
	}

	public boolean isItemLocked(KitType slot)
	{
		return savedSwaps.isItemLocked(slot);
	}

	public boolean isColorLocked(ColorType type)
	{
		return savedSwaps.isColorLocked(type);
	}

	public boolean isIconLocked()
	{
		return savedSwaps.isIconLocked();
	}

	public void toggleItemLocked(KitType slot)
	{
		savedSwaps.toggleItemLocked(slot);
	}

	public void toggleKitLocked(KitType slot)
	{
		savedSwaps.toggleKitLocked(slot);
	}

	public void toggleColorLocked(ColorType type)
	{
		savedSwaps.toggleColorLocked(type);
	}

	public void toggleIconLocked()
	{
		savedSwaps.toggleIconLocked();
	}

	// this should only be called from the client thread
	public void refreshAllSwaps()
	{
		Map<KitType, Integer> savedEquipmentIds = savedSwaps.itemEntries().stream().collect(
			Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + ITEM_OFFSET)
		);
		Map<KitType, Integer> savedKitEquipIds = savedSwaps.kitEntries().stream().collect(
			Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + KIT_OFFSET)
		);
		Map<KitType, Integer> hiddenEquipIds = savedSwaps.getHiddenSlots().stream().collect(
			Collectors.toMap(v -> v, v -> 0)
		);
		savedEquipmentIds.putAll(savedKitEquipIds);
		savedEquipmentIds.putAll(hiddenEquipIds);
		for (CompoundSwap c : CompoundSwap.fromMap(sanitize(savedEquipmentIds), savedSwaps.getSwappedIcon()))
		{
			swap(c, SwapMode.PREVIEW);
		}
		for (Map.Entry<ColorType, Integer> e : savedSwaps.colorEntries())
		{
			swap(e.getKey(), e.getValue(), SwapMode.PREVIEW);
		}
	}

	/**
	 * Undoes the last action performed.
	 * Can only be called from the client thread.
	 */
	public void undoLastSwap()
	{
		if (client.getLocalPlayer() != null)
		{
			swapDiffHistory.undoLast();
		}
	}

	public boolean canUndo()
	{
		return swapDiffHistory.undoSize() > 0;
	}

	/**
	 * Redoes the last action that was undone.
	 * Can only be called from the client thread.
	 */
	public void redoLastSwap()
	{
		if (client.getLocalPlayer() != null)
		{
			swapDiffHistory.redoLast();
		}
	}

	public boolean canRedo()
	{
		return swapDiffHistory.redoSize() > 0;
	}

	/**
	 * Check for:
	 * - player's gender, match against last known (non-null) gender. if no match, revert and clear all kit swaps
	 * - player's real kit ids and real colors so that they can be reverted
	 * - player's real icon in the jaw slot (playing Barbarian Assault or Soul Wars)
	 * - any kit/item ids that should disable swaps (e.g., minecart, magic carpet)
	 */
	public void doPreRefreshCheck()
	{
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}
		PlayerComposition playerComposition = player.getPlayerComposition();
		if (playerComposition == null)
		{
			return;
		}
		int gender = playerComposition.getGender();
		checkRealKits(gender);
		this.gender = gender;
		if (!Objects.equals(lastKnownPlayerName, player.getName()))
		{
			savedSwaps.loadRSProfileConfig();
			lastKnownPlayerName = player.getName();
		}
		for (KitType kitType : KitType.values())
		{
			Integer kitId = kitIdFor(kitType);
			if (kitId != null)
			{
				if (kitId >= 0 && (!savedSwaps.containsSlot(kitType) ||
					!Objects.equals(savedSwaps.getKit(kitType), kitId)))
				{
					savedSwaps.putRealKit(kitType, kitId);
				}
			}
		}
		for (ColorType colorType : ColorType.values())
		{
			Integer colorId = colorIdFor(colorType);
			if (colorId != null && (!savedSwaps.containsColor(colorType) ||
				!Objects.equals(savedSwaps.getColor(colorType), colorId)))
			{
				savedSwaps.putRealColor(colorType, colorId);
			}
		}
		int jawEquipId = playerComposition.getEquipmentIds()[KitType.JAW.getIndex()];
		if (jawEquipId >= ITEM_OFFSET)
		{
			JawIcon icon = JawKit.iconFromItemId(jawEquipId - ITEM_OFFSET);
			savedSwaps.putRealIcon(icon);
		}
		else
		{
			savedSwaps.putRealIcon(JawIcon.NOTHING);
		}
		int bootKitId = playerComposition.getKitId(KitType.BOOTS);
		int weaponItemId = playerComposition.getEquipmentIds()[KitType.WEAPON.getIndex()] - ITEM_OFFSET;
		if (ItemInteractions.DISABLE_BOOT_KITS.contains(bootKitId))
		{
			disabledAnimationId = IdleAnimationID.MINECART;
			disabledSlots.put(KitType.BOOTS, bootKitId + KIT_OFFSET);
			disabledSlots.put(KitType.WEAPON, 0);
			disabledSlots.put(KitType.SHIELD, 0);
		}
		else if (ItemInteractions.DISABLE_WEAPONS.contains(weaponItemId))
		{
			disabledSlots.put(KitType.WEAPON, weaponItemId + ITEM_OFFSET);
			disabledSlots.put(KitType.SHIELD, 0);
		}
		else
		{
			disabledAnimationId = null;
			disabledSlots.clear();
		}
		refreshDisabledSlots();
	}

	private void checkRealKits(Integer gender)
	{
		boolean containsOppositeGenderKits = savedSwaps.getRealKitIds().entrySet().stream()
			.anyMatch(e -> {
				Kit kit = KIT_ID_TO_KIT.get(e.getValue());
				return kit != null && kit.getKitId(gender) == null;
			});
		if (containsOppositeGenderKits)
		{
			savedSwaps.clearRealKits();
		}
	}

	private void refreshDisabledSlots()
	{
		if (!disabledSlots.isEmpty())
		{
			// temporarily remove locks while swapping disabled slots
			Set<KitType> lockedItems = savedSwaps.getAllLockedItems();
			Set<KitType> lockedKits = savedSwaps.getAllLockedKits();
			boolean iconLocked = savedSwaps.isIconLocked();
			for (KitType slot : disabledSlots.keySet())
			{
				savedSwaps.removeSlotLock(slot);
				savedSwaps.removeIconLock();
			}
			if (!disabledSlots.isEmpty())
			{
				CompoundSwap.fromMap(disabledSlots, null)
					.forEach(c -> swap(c, true, SwapMode.PREVIEW));
			}
			if (disabledAnimationId != null)
			{
				Player player = client.getLocalPlayer();
				if (player != null)
				{
					setIdleAnimationId(player, disabledAnimationId, true);
				}
				disabledAnimationId = null;
			}
			savedSwaps.setLockedItems(lockedItems);
			savedSwaps.setLockedKits(lockedKits);
			savedSwaps.setIconLocked(iconLocked);
		}
	}

	/**
	 * Sanity checks after changing equipment:
	 * <p>
	 * If there's an actual item in a slot and no virtual swap in that slot, BUT other kit swaps hide
	 * the item, do a one-off unsaved swap to hide this newly-equipped item.
	 */
	public void onEquipmentChanged()
	{
		for (KitType kitType : KitType.values())
		{
			Integer inventoryItemId = inventoryItemId(kitType);
			Integer virtualItemId = savedSwaps.getItem(kitType);
			Integer virtualKitId = savedSwaps.getKit(kitType);
			if (virtualItemId == null && virtualKitId == null && inventoryItemId != null)
			{
				switch (kitType)
				{
					case HEAD:
						if ((savedSwaps.containsSlot(KitType.HAIR) &&
							!ItemInteractions.HAIR_HELMS.contains(inventoryItemId)) ||
							(savedSwaps.containsSlot(KitType.JAW) &&
								ItemInteractions.NO_JAW_HELMS.contains(inventoryItemId)))
						{
							swap(CompoundSwap.single(KitType.HEAD, 0), SwapMode.PREVIEW);
						}
						else if (savedSwaps.containsIcon())
						{
							// if icon is swapped but not hair/jaw, just refresh (head is not in conflict)
							swap(CompoundSwap.single(KitType.HEAD, inventoryItemId + ITEM_OFFSET), SwapMode.PREVIEW);
						}
						break;
					case TORSO:
						if (savedSwaps.containsSlot(KitType.ARMS) &&
							!ItemInteractions.ARMS_TORSOS.contains(inventoryItemId))
						{
							int kitId = savedSwaps.getRealKit(kitType, gender);
							swap(CompoundSwap.single(kitType, kitId + KIT_OFFSET), SwapMode.PREVIEW);
						}
						break;
					default:
						break;
				}
			}
		}
	}

	public void importSwaps(
		Map<KitType, Integer> newItems,
		Map<KitType, Integer> newKits,
		Map<ColorType, Integer> newColors,
		JawIcon icon,
		Set<KitType> slotsToRemove)
	{
		clientThread.invokeLater(() -> {
			// prepare swaps for import
			Map<KitType, Integer> itemEquipSwaps = newItems.entrySet().stream().collect(
				Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + ITEM_OFFSET)
			);
			Map<KitType, Integer> kitEquipSwaps = newKits.entrySet().stream().collect(
				Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + KIT_OFFSET)
			);
			Map<KitType, Integer> removals = slotsToRemove.stream().collect(
				Collectors.toMap(v -> v, v -> 0)
			);
			Map<KitType, Integer> equipSwaps = new HashMap<>(kitEquipSwaps);
			equipSwaps.putAll(itemEquipSwaps);
			equipSwaps.putAll(removals);

			// remove locks and revert everything on player
			savedSwaps.removeAllLocks();
			SwapDiff iconRevert = doRevertIcon();
			SwapDiff kitRevert = Arrays.stream(KitType.values())
				.map(this::doRevert)
				.filter(Objects::nonNull)
				.reduce(SwapDiff::mergeOver)
				.orElse(SwapDiff.blank());
			SwapDiff colorRevert = Arrays.stream(ColorType.values())
				.map(this::doRevert)
				.reduce(SwapDiff::mergeOver)
				.orElse(SwapDiff.blank());

			SwapDiff equips = CompoundSwap.fromMap(sanitize(equipSwaps), icon).stream()
				.map(c -> this.swap(c, SwapMode.SAVE))
				.reduce(SwapDiff::mergeOver)
				.orElse(SwapDiff.blank());

			Map<ColorType, Integer> colorSwaps = newColors.entrySet().stream()
				.filter(e -> !savedSwaps.isColorLocked(e.getKey()))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
			Map<ColorType, Integer> colorEquipSwaps = colorSwaps.entrySet().stream().collect(
				Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)
			);

			SwapDiff colors = colorEquipSwaps.entrySet().stream()
				.map(e -> this.swapColor(e.getKey(), e.getValue(), true))
				.reduce(SwapDiff::mergeOver)
				.orElse(SwapDiff.blank());
			SwapDiff total = iconRevert
				.mergeOver(kitRevert)
				.mergeOver(colorRevert)
				.mergeOver(equips)
				.mergeOver(colors);
			swapDiffHistory.appendToUndo(total);
		});
	}

	@Nullable
	public Integer swappedItemIdIn(KitType slot)
	{
		return savedSwaps.getItem(slot);
	}

	@Nullable
	public JawIcon swappedIcon()
	{
		return savedSwaps.getSwappedIcon();
	}

	public boolean isHidden(KitType slot)
	{
		return savedSwaps.isHidden(slot);
	}

	@Nullable
	public Integer swappedKitIdIn(KitType slot)
	{
		return savedSwaps.getKit(slot);
	}

	@Nullable
	public Integer swappedColorIdIn(ColorType type)
	{
		return savedSwaps.getColor(type);
	}

	public Map<ColorType, Colorable> swappedColorsMap()
	{
		BiFunction<ColorType, Integer, Colorable> getColor = (type, id) -> {
			switch (type)
			{
				case HAIR:
					return HairColor.fromId(id);
				case TORSO:
					return ClothingColor.fromTorsoId(id);
				case LEGS:
					return ClothingColor.fromLegsId(id);
				case BOOTS:
					return BootsColor.fromId(id);
				case SKIN:
					return SkinColor.fromId(id);
			}
			return null;
		};
		return Arrays.stream(ColorType.values())
			.filter(savedSwaps::containsColor)
			.collect(Collectors.toMap(t -> t, t -> getColor.apply(t, savedSwaps.getColor(t))));
	}

	// this should only be called from the client thread
	public void revert(KitType slot, ColorType type)
	{
		SwapDiff s = SwapDiff.blank();
		if (slot != null)
		{
			savedSwaps.removeSlotLock(slot);
			s = s.mergeOver(doRevert(slot));
		}
		if (type != null)
		{
			savedSwaps.removeColorLock(type);
			s = s.mergeOver(doRevert(type));
		}
		swapDiffHistory.appendToUndo(s);
	}

	// this should only be called from the client thread
	public void revertSlot(KitType slot)
	{
		savedSwaps.removeSlotLock(slot);
		SwapDiff s = doRevert(slot);
		swapDiffHistory.appendToUndo(s);
	}

	public void revertIcon()
	{
		savedSwaps.removeIconLock();
		SwapDiff s = doRevertIcon();
		swapDiffHistory.appendToUndo(s);
	}

	public void hoverOverItem(KitType slot, Integer itemId)
	{
		hoverOver(() -> {
			int id = itemId < 0 ? -ITEM_OFFSET : itemId;
			return swapItem(slot, id, false, false);
		});
	}

	public void hoverOverKit(KitType slot, int kitId)
	{
		hoverOver(() -> swapKit(slot, kitId, false));
	}

	public void hoverOverColor(ColorType type, Integer colorId)
	{
		hoverOver(() -> swapColor(type, colorId, false));
	}

	public void hoverOverIcon(JawIcon icon)
	{
		hoverOver(() -> swapIcon(icon, false));
	}

	private void hoverOver(Supplier<SwapDiff> diffCallable)
	{
		clientThread.invokeLater(() -> {
			SwapDiff swapDiff = diffCallable.get();
			if (hoverSwapDiff == null)
			{
				hoverSwapDiff = swapDiff;
			}
			else if (!swapDiff.isBlank())
			{
				hoverSwapDiff = swapDiff.mergeOver(hoverSwapDiff);
			}
		});
	}

	public void hoverSelectItem(KitType slot, Integer itemId)
	{
		hoverSelect(() -> {
			if (savedSwaps.isItemLocked(slot))
			{
				return SwapDiff.blank();
			}
			if (itemId < 0)
			{
				return savedSwaps.isHidden(slot) ?
					doRevert(slot) :
					swapItem(slot, -ITEM_OFFSET, true, false);
			}
			else
			{
				return Objects.equals(savedSwaps.getItem(slot), itemId) ?
					doRevert(slot) :
					swapItem(slot, itemId, true, false);
			}
		});
	}

	public void hoverSelectKit(KitType slot, int kitId)
	{
		hoverSelect(() -> {
			if (savedSwaps.isKitLocked(slot))
			{
				return SwapDiff.blank();
			}
			return Objects.equals(savedSwaps.getKit(slot), kitId) ?
				doRevert(slot) :
				swapKit(slot, kitId, true);
		});
	}

	public void hoverSelectColor(ColorType type, Integer colorId)
	{
		hoverSelect(() -> {
			if (savedSwaps.isColorLocked(type))
			{
				return SwapDiff.blank();
			}
			return Objects.equals(savedSwaps.getColor(type), colorId) ?
				doRevert(type) :
				swapColor(type, colorId, true);
		});
	}

	public void hoverSelectIcon(JawIcon icon)
	{
		hoverSelect(() -> {
			if (savedSwaps.isIconLocked())
			{
				return SwapDiff.blank();
			}
			return savedSwaps.getSwappedIcon() == icon ?
				doRevertIcon() :
				swapIcon(icon, true);
		});
	}

	private void hoverSelect(Supplier<SwapDiff> diffSupplier)
	{
		clientThread.invokeLater(() -> {
			SwapDiff swapDiff = diffSupplier.get();
			if (!swapDiff.isBlank())
			{
				if (hoverSwapDiff != null)
				{
					swapDiff = hoverSwapDiff.mergeOver(swapDiff);
				}
				swapDiffHistory.appendToUndo(swapDiff);
				hoverSwapDiff = null;
			}
		});
	}

	public void hoverAway()
	{
		clientThread.invokeLater(() -> {
			if (hoverSwapDiff != null)
			{
				restore(hoverSwapDiff, false);
				hoverSwapDiff = null;
			}
			refreshAllSwaps();
		});
	}

	// reverts only the given swaps. if removeLocks is true, only removes locks for those slots.
	private void revertSwaps(List<KitType> slots, boolean removeLocks, boolean preview)
	{
		if (removeLocks)
		{
			slots.forEach(slot -> savedSwaps.removeSlotLock(slot));
			savedSwaps.removeIconLock();
		}
		SwapMode mode = preview ? SwapMode.PREVIEW : SwapMode.REVERT;
		JawIcon icon = null;
		if (!savedSwaps.isIconLocked())
		{
			icon = JawIcon.NOTHING;
		}
		Map<KitType, Integer> equipIdsToRevert = slots.stream()
			.filter(slot -> !savedSwaps.isSlotLocked(slot))
			.collect(Collectors.toMap(slot -> slot, slot -> {
				Integer itemId = inventoryItemId(slot);
				if (itemId != null && itemId != 0)
				{
					return itemId + ITEM_OFFSET;
				}
				return savedSwaps.getRealKit(slot, gender) + KIT_OFFSET;
			}));
		SwapDiff kitsDiff = CompoundSwap.fromMap(equipIdsToRevert, icon).stream()
			.map(c -> this.swap(c, false, (s) -> mode, mode))
			.reduce(SwapDiff::mergeOver)
			.orElse(SwapDiff.blank());
		SwapDiff colorsDiff = Arrays.stream(ColorType.values())
			.filter(type -> !savedSwaps.isColorLocked(type))
			.map(type -> {
				Integer colorId = savedSwaps.getRealColor(type);
				return colorId != null ? swap(type, colorId, mode) : SwapDiff.blank();
			})
			.reduce(SwapDiff::mergeOver)
			.orElse(SwapDiff.blank());
		SwapDiff totalDiff = kitsDiff
			.mergeOver(colorsDiff);
		if (mode == SwapMode.REVERT)
		{
			swapDiffHistory.appendToUndo(totalDiff);
			savedSwaps.clearSwapped();
		}
	}

	/**
	 * Reverts all item/kit slots, colors, and icon. Unless `removeLocks` is true, locked slots will remain.
	 * If `preview` is true, saved swaps will be unaffected.
	 * Can only be called from the client thread.
	 */
	public void revertSwaps(boolean removeLocks, boolean preview)
	{
		revertSwaps(Arrays.asList(KitType.values()), removeLocks, preview);
	}

	@Nullable
	// this should only be called from the client thread
	public Integer slotIdFor(ItemComposition itemComposition)
	{
		ItemEquipmentStats equipStats = equipmentStatsFor(itemComposition.getId());
		if (equipStats != null)
		{
			return equipStats.getSlot();
		}
		return null;
	}

	/**
	 * Takes a map of equipment ids and returns a new map, replacing any equipment ids that are inapplicable to
	 * the current player's gender with equipment ids that are (if no analogous ids are found, those slots are removed)
	 */
	private Map<KitType, Integer> sanitize(Map<KitType, Integer> equipmentIds)
	{
		Integer gender = this.gender;
		if (gender == null)
		{
			return new HashMap<>();
		}
		Map<KitType, Integer> newEquipIds = new HashMap<>();
		equipmentIds.forEach((slot, equipId) -> {
			if (equipId >= KIT_OFFSET && equipId < ITEM_OFFSET || equipId >= ITEM_OFFSET && slot == KitType.JAW)
			{
				Integer newEquipId = getAnalogousEquipmentId(equipId);
				if (newEquipId != null)
				{
					newEquipIds.put(slot, newEquipId);
				}
			}
			else if (equipId >= ITEM_OFFSET)
			{
				newEquipIds.put(slot, equipId);
			}
		});
		Map<KitType, Integer> removals = equipmentIds.entrySet().stream()
			.filter(e -> e.getValue() == 0 && !NEVER_ZERO_SLOTS.contains(e.getKey()))
			.collect(Collectors.toMap(Map.Entry::getKey, entry -> 0));
		newEquipIds.putAll(removals);
		return newEquipIds;
	}

	/**
	 * Attempts to match the given (kit/icon) equipment id with one that matches
	 * the current player's gender. Returns null if no analogue is found.
	 */
	@Nullable
	private Integer getAnalogousEquipmentId(int equipId)
	{
		Integer result = null;
		JawIcon icon = JawIcon.NOTHING;
		if (equipId >= ITEM_OFFSET)
		{
			JawKit kit = JawKit.fromEquipmentId(equipId);
			if (kit != null)
			{
				icon = JawKit.iconFromItemId(equipId - ITEM_OFFSET);
				Integer jawKitId = kit.getKitId(gender);
				if (jawKitId != null)
				{
					equipId = jawKitId + KIT_OFFSET;
				}
			}
		}
		Kit kit = KIT_ID_TO_KIT.get(equipId - KIT_OFFSET);
		if (kit != null)
		{
			Integer kitId = kit.getKitId(gender);
			if (kitId != null)
			{
				result = kitId + KIT_OFFSET;
			}
			else
			{
				BiMap<Kit, Kit> lookup = Objects.equals(gender, 0) ?
					ItemInteractions.GENDER_MIRRORED_KITS :
					ItemInteractions.GENDER_MIRRORED_KITS.inverse();
				if (lookup.containsKey(kit))
				{
					Integer analogKitId = lookup.get(kit).getKitId(gender);
					if (analogKitId != null)
					{
						result = analogKitId + KIT_OFFSET;
					}
				}
			}
			if (icon != JawIcon.NOTHING)
			{
				if (result != null)
				{
					Integer itemId = JawKit.fromEquipmentId(result).getIconItemId(icon);
					result = itemId != null ? itemId + ITEM_OFFSET : result;
				}
				else
				{
					result = combineJawIcon(null, icon);
				}
			}
		}
		return result;
	}

	public void shuffle()
	{
		randomizer.shuffle();
	}

	// this should only be called from the client thread
	public SwapDiff swapItem(KitType slot, Integer itemId, boolean save, boolean saveIcon)
	{
		if (itemId == null)
		{
			return SwapDiff.blank();
		}
		int equipmentId = itemId + ITEM_OFFSET;
		SwapMode swapMode = save ? SwapMode.SAVE : SwapMode.PREVIEW;
		SwapMode iconSwapMode = saveIcon ? SwapMode.SAVE : SwapMode.PREVIEW;
		SwapDiff swapDiff = swap(CompoundSwap.single(slot, equipmentId), swapMode, iconSwapMode);
		if (hoverSwapDiff != null)
		{
			swapDiff = swapDiff.mergeOver(hoverSwapDiff);
		}
		return swapDiff;
	}

	// this should only be called from the client thread
	public SwapDiff swapKit(KitType slot, Integer kitId, boolean save)
	{
		if (kitId == null)
		{
			return SwapDiff.blank();
		}
		int equipmentId = kitId + KIT_OFFSET;
		SwapMode swapMode = save ? SwapMode.SAVE : SwapMode.PREVIEW;
		SwapDiff swapDiff = swap(CompoundSwap.single(slot, equipmentId), swapMode, SwapMode.PREVIEW);
		if (hoverSwapDiff != null)
		{
			swapDiff = swapDiff.mergeOver(hoverSwapDiff);
		}
		return swapDiff;
	}

	// this should only be called from the client thread
	public SwapDiff swapIcon(JawIcon icon, boolean save)
	{
		if (icon == null)
		{
			return SwapDiff.blank();
		}
		SwapMode swapMode = save ? SwapMode.SAVE : SwapMode.PREVIEW;
		SwapDiff swapDiff = swap(CompoundSwap.fromIcon(icon), SwapMode.PREVIEW, swapMode);
		if (hoverSwapDiff != null)
		{
			swapDiff = swapDiff.mergeOver(hoverSwapDiff);
		}
		return swapDiff;
	}

	// this should only be called from the client thread
	public SwapDiff swapColor(ColorType type, Integer colorId, boolean save)
	{
		if (colorId == null)
		{
			return SwapDiff.blank();
		}
		SwapMode swapMode = save ? SwapMode.SAVE : SwapMode.PREVIEW;
		SwapDiff swapDiff = swap(type, colorId, swapMode);
		if (hoverSwapDiff != null)
		{
			swapDiff = swapDiff.mergeOver(hoverSwapDiff);
		}
		return swapDiff;
	}

	/**
	 * directly swaps a single color by id
	 */
	public SwapDiff swap(ColorType type, Integer colorId, SwapMode swapMode)
	{
		if (type == null || colorId == null)
		{
			return SwapDiff.blank();
		}
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return SwapDiff.blank();
		}
		PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
		{
			return SwapDiff.blank();
		}
		try
		{
			int oldColorId = setColorId(composition, type, colorId);
			Map<ColorType, SwapDiff.Change> changes = new HashMap<>();
			changes.put(type, new SwapDiff.Change(oldColorId, savedSwaps.containsColor(type)));
			switch (swapMode)
			{
				case SAVE:
					savedSwaps.putColor(type, colorId);
					break;
				case REVERT:
					savedSwaps.removeColor(type);
					break;
				case PREVIEW:
					break;
			}
			return new SwapDiff(new HashMap<>(), changes, null, null);
		}
		catch (Exception e)
		{
			return SwapDiff.blank();
		}
	}

	/**
	 * Most of the requested swaps should call this method instead of the more specific swaps below, to ensure
	 * that the swap doesn't result in illegal combinations of models
	 */
	public SwapDiff swap(CompoundSwap s, SwapMode swapMode)
	{
		return swap(s, false, swapMode);
	}

	public SwapDiff swap(CompoundSwap s, SwapMode swapMode, SwapMode iconSwapMode)
	{
		return swap(s, false, (ignore) -> swapMode, iconSwapMode);
	}

	private SwapDiff swap(CompoundSwap s, boolean allowDisabledSwaps, SwapMode swapMode)
	{
		return swap(s, allowDisabledSwaps, (ignore) -> swapMode, swapMode);
	}

	private SwapDiff swap(
		CompoundSwap s,
		boolean allowDisabledSwaps,
		Function<KitType, SwapMode> swapModeProvider,
		SwapMode iconSwapMode)
	{
		switch (s.getType())
		{
			case HEAD:
				Integer headEquipId = s.getEquipmentIds().get(KitType.HEAD);
				Integer hairEquipId = s.getEquipmentIds().get(KitType.HAIR);
				Integer jawEquipId = s.getEquipmentIds().get(KitType.JAW);
				JawIcon icon = s.getIcon();
				return swapHead(headEquipId, hairEquipId, jawEquipId, icon, allowDisabledSwaps, swapModeProvider,
					iconSwapMode);
			case TORSO:
				Integer torsoEquipId = s.getEquipmentIds().get(KitType.TORSO);
				Integer armsEquipId = s.getEquipmentIds().get(KitType.ARMS);
				return swapTorso(torsoEquipId, armsEquipId, allowDisabledSwaps, swapModeProvider);
			case WEAPONS:
				Integer weaponEquipId = s.getEquipmentIds().get(KitType.WEAPON);
				Integer shieldEquipId = s.getEquipmentIds().get(KitType.SHIELD);
				return swapWeapons(weaponEquipId, shieldEquipId, allowDisabledSwaps, swapModeProvider);
			case SINGLE:
				return swapSingle(s.getKitType(), s.getEquipmentId(), allowDisabledSwaps,
					swapModeProvider.apply(s.getKitType()));
		}
		return SwapDiff.blank();
	}

	private SwapDiff swapSingle(KitType slot, Integer equipmentId, boolean allowDisabledSwaps, SwapMode swapMode)
	{
		Map<SwapDiff.Change.Type, SwapDiff.Change> results = swap(slot, equipmentId, swapMode, SwapMode.PREVIEW,
			allowDisabledSwaps);
		Map<KitType, SwapDiff.Change> changes = new HashMap<>();
		SwapDiff.Change iconChange = results.get(SwapDiff.Change.Type.ICON);
		if (results.containsKey(SwapDiff.Change.Type.EQUIPMENT))
		{
			changes.put(slot, results.get(SwapDiff.Change.Type.EQUIPMENT));
		}
		return new SwapDiff(changes, new HashMap<>(), iconChange, null);
	}

	/**
	 * Swaps an item in the head slot, and kits in the hair and/or jaw slots. Behavior changes depending
	 * on the information present:
	 * <p>
	 * When the head slot id is null, the head slot will not change. The hair and jaw kits sent
	 * will be used if the currently shown item allows for it, otherwise nothing will happen.
	 * <p>
	 * The head slot item is removed when id == 0. This means swapping to the hair and jaw kit ids
	 * if they are sent, otherwise the player's existing kit ids will be used.
	 * <p>
	 * For non-null, non-zero head ids, the head item will be swapped, but not if (the item hides hair and the hair kit
	 * is locked) or (the item hides jaws and the jaw slot is locked). If the new item allows showing hair
	 * and/or jaw kits, then they will also be swapped using the sent values or the existing kits on the player.
	 * If the kits are not allowed, they will be hidden as needed.
	 */
	private SwapDiff swapHead(
		Integer headEquipId,
		Integer hairEquipId,
		Integer jawEquipId,
		JawIcon icon,
		boolean allowDisabledSwaps,
		Function<KitType, SwapMode> swapModeProvider,
		SwapMode iconSwapMode)
	{
		// equipment ids that will be used in the swap
		Integer finalHeadId = null;
		Integer finalHairId;
		Integer finalJawId;

		Function<Integer, Boolean> isJawlessIcon = (equipId) ->
			equipId >= ITEM_OFFSET && JawKit.isNoJawIcon(equipId - ITEM_OFFSET);
		Function<Integer, Boolean> headAllowsHair = (equipId) ->
			equipId < ITEM_OFFSET || ItemInteractions.HAIR_HELMS.contains(equipId - ITEM_OFFSET);
		Function<Integer, Boolean> headAllowsJaw = (equipId) ->
			equipId < ITEM_OFFSET || !ItemInteractions.NO_JAW_HELMS.contains(equipId - ITEM_OFFSET);

		int currentHeadEquipId = equipmentIdInSlot(KitType.HEAD);

		Integer adjustedJawEquipId = !savedSwaps.isKitLocked(KitType.JAW) ? jawEquipId : null;
		JawIcon adjustedIcon = !savedSwaps.isIconLocked() ? icon : null;
		if (adjustedJawEquipId != null || icon != null)
		{
			adjustedJawEquipId = combineJawIcon(adjustedJawEquipId, adjustedIcon);
		}

		Integer adjustedHairEquipId = !savedSwaps.isKitLocked(KitType.HAIR) ? hairEquipId : null;

		if (savedSwaps.isItemLocked(KitType.HEAD))
		{
			// only change hair/jaw and only if current head item allows
			if (adjustedHairEquipId != null)
			{
				boolean hairAllowed = (headAllowsHair.apply(currentHeadEquipId) && adjustedHairEquipId > 0) ||
					(!headAllowsHair.apply(currentHeadEquipId) && adjustedHairEquipId <= 0);
				finalHairId = hairAllowed ? adjustedHairEquipId : null;
			}
			else
			{
				finalHairId = null;
			}
			if (adjustedJawEquipId != null)
			{
				boolean jawAllowed = (headAllowsJaw.apply(currentHeadEquipId) && adjustedJawEquipId > 0) ||
					(!headAllowsJaw.apply(currentHeadEquipId) && (adjustedJawEquipId <= 0 ||
						isJawlessIcon.apply(adjustedJawEquipId)));
				if (jawAllowed)
				{
					finalJawId = adjustedJawEquipId;
				}
				else if (adjustedJawEquipId >= ITEM_OFFSET)
				{
					finalJawId = combineJawIcon(0, adjustedIcon);
				}
				else
				{
					finalJawId = null;
				}
			}
			else
			{
				finalJawId = null;
			}
		}
		else if (headEquipId == null)
		{
			// prioritize showing hair/jaw and hiding current helm if new kits conflict with it.
			finalHairId = adjustedHairEquipId;
			finalJawId = adjustedJawEquipId;
			boolean headForbidsHair = finalHairId != null && finalHairId > 0 &&
				!headAllowsHair.apply(currentHeadEquipId);
			if (headForbidsHair)
			{
				finalHeadId = 0;
			}
			else
			{
				boolean headForbidsJaw = finalJawId != null && finalJawId > 0 && !isJawlessIcon.apply(finalJawId) &&
					!headAllowsJaw.apply(currentHeadEquipId);
				if (headForbidsJaw)
				{
					// if not actually requesting jaw kit, use only icon and keep head item
					if (jawEquipId == null)
					{
						finalJawId = combineJawIcon(0, adjustedIcon);
					}
					else
					{
						finalHeadId = 0;
					}
				}
			}
		}
		else
		{
			// priority: show head and hide hair/jaw, but not if locks on hair/jaw disallow (in which case don't change)
			boolean hairDisallowed = !headAllowsHair.apply(headEquipId) && savedSwaps.isKitLocked(KitType.HAIR);
			boolean jawDisallowed = !headAllowsJaw.apply(headEquipId) && savedSwaps.isKitLocked(KitType.JAW);
			finalHeadId = hairDisallowed || jawDisallowed ? null : headEquipId;
			Integer headIdToCheck = hairDisallowed || jawDisallowed ? currentHeadEquipId : headEquipId;
			Integer potentialHairId = headAllowsHair.apply(headIdToCheck) ? adjustedHairEquipId : Integer.valueOf(0);
			finalHairId = !savedSwaps.isKitLocked(KitType.HAIR) ? potentialHairId : null;
			Integer potentialJawId = headAllowsJaw.apply(headIdToCheck) ||
				(adjustedJawEquipId != null && isJawlessIcon.apply(adjustedJawEquipId)) ?
				adjustedJawEquipId :
				(Integer) combineJawIcon(0, adjustedIcon);
			finalJawId = !savedSwaps.isKitLocked(KitType.JAW) ? potentialJawId : null;
		}

		Map<KitType, SwapDiff.Change> changes = new HashMap<>();
		final SwapDiff.Change[] iconChange = {null};

		// edge cases:
		// if not changing hair but hair can be shown, make sure that at least something is displayed there
		if (finalHairId == null && equipmentIdInSlot(KitType.HAIR) == 0 &&
			((finalHeadId == null && headAllowsHair.apply(currentHeadEquipId)) ||
				(finalHeadId != null && headAllowsHair.apply(finalHeadId))))
		{
			if (savedSwaps.isKitLocked(KitType.HAIR))
			{
				// hair is locked on nothing, don't change helm to something that could show empty kit
				finalHeadId = null;
				finalJawId = null;
			}
			else
			{
				int revertHairId = savedSwaps.getRealKit(KitType.HAIR, gender) + KIT_OFFSET;
				Map<SwapDiff.Change.Type, SwapDiff.Change> result = swap(KitType.HAIR, revertHairId, SwapMode.REVERT,
					SwapMode.PREVIEW, allowDisabledSwaps);
				if (result.containsKey(SwapDiff.Change.Type.EQUIPMENT))
				{
					changes.put(KitType.HAIR, result.get(SwapDiff.Change.Type.EQUIPMENT));
				}
			}
		}

		int currentJawEquipId = equipmentIdInSlot(KitType.JAW);
		// if not changing jaw but jaw should be shown, make sure that at least something is displayed there
		if (finalJawId == null && (currentJawEquipId == 0 || isJawlessIcon.apply(currentJawEquipId)) &&
			((finalHeadId == null && headAllowsJaw.apply(currentHeadEquipId)) ||
				(finalHeadId != null && headAllowsJaw.apply(finalHeadId))))
		{
			if (savedSwaps.isKitLocked(KitType.JAW))
			{
				// jaw is locked on nothing, don't change helm to something that could show empty kit
				finalHeadId = null;
				finalHairId = null;
			}
			else
			{
				int realKitId = savedSwaps.getRealKit(KitType.JAW, gender);
				int fallbackJawId = combineJawIcon(realKitId + KIT_OFFSET, adjustedIcon);
				Map<SwapDiff.Change.Type, SwapDiff.Change> result = swap(KitType.JAW, fallbackJawId, SwapMode.REVERT,
					SwapMode.PREVIEW, allowDisabledSwaps);
				if (result.containsKey(SwapDiff.Change.Type.EQUIPMENT))
				{
					changes.put(KitType.JAW, result.get(SwapDiff.Change.Type.EQUIPMENT));
				}
			}
		}

		BiConsumer<KitType, Integer> attemptChange = (slot, equipId) -> {
			if (equipId != null && equipId >= 0)
			{
				Map<SwapDiff.Change.Type, SwapDiff.Change> result = swap(slot, equipId, swapModeProvider.apply(slot),
					iconSwapMode, allowDisabledSwaps);
				if (result.containsKey(SwapDiff.Change.Type.EQUIPMENT))
				{
					changes.put(slot, result.get(SwapDiff.Change.Type.EQUIPMENT));
				}
				if (result.containsKey(SwapDiff.Change.Type.ICON))
				{
					iconChange[0] = result.get(SwapDiff.Change.Type.ICON);
				}
			}
		};
		attemptChange.accept(KitType.HEAD, finalHeadId);
		attemptChange.accept(KitType.HAIR, finalHairId);
		attemptChange.accept(KitType.JAW, finalJawId);
		return new SwapDiff(changes, new HashMap<>(), iconChange[0], null);
	}

	/**
	 * Swaps an item or kit in the torso slot and a kit in the arms slot. Behavior changes depending
	 * on the information present:
	 * <p>
	 * When the torso slot id is null, the torso slot will not change. The arms kits sen will be
	 * used if the currently shown torso allows for it, otherwise nothing will happen.
	 * <p>
	 * The torso slot item is removed when id == 0. This means swapping to the arms kit id if it is sent,
	 * otherwise the player's existing kit id will be used.
	 * <p>
	 * For non-null, non-zero torso ids, the torso slot item will change, but not if the item hides arms and the arms
	 * kit is currently locked. If the new item allows showing the arms kit, then it will also be swapped using the
	 * sent value or the existing kit on the player. If the torso does not allow showing arms, then the arms kit
	 * will be removed.
	 */
	private SwapDiff swapTorso(
		Integer torsoEquipId,
		Integer armsEquipId,
		boolean allowDisabledSwaps,
		Function<KitType, SwapMode> swapModeProvider)
	{
		Integer finalTorsoId = null;
		Integer finalArmsId;

		Function<Integer, Boolean> torsoAllowsArms = (equipId) ->
			equipId < ITEM_OFFSET || ItemInteractions.ARMS_TORSOS.contains(equipId - ITEM_OFFSET);

		Map<KitType, SwapDiff.Change> changes = new HashMap<>();

		int currentTorsoEquipId = equipmentIdInSlot(KitType.TORSO);
		if (savedSwaps.isKitLocked(KitType.TORSO) ||
			(savedSwaps.isItemLocked(KitType.TORSO) && torsoEquipId != null && torsoEquipId >= ITEM_OFFSET))
		{
			// only change arms and only if current torso item allows
			if (savedSwaps.isKitLocked(KitType.ARMS) && armsEquipId != null)
			{
				boolean armsAllowed = (torsoAllowsArms.apply(currentTorsoEquipId) && armsEquipId > 0) ||
					(!torsoAllowsArms.apply(currentTorsoEquipId) && armsEquipId <= 0);
				finalArmsId = armsAllowed ? armsEquipId : null;
			}
			else
			{
				finalArmsId = null;
			}
		}
		else if (torsoEquipId == null)
		{
			// prioritize showing arms and hiding current torso if applicable
			finalArmsId = !savedSwaps.isKitLocked(KitType.ARMS) ? armsEquipId : null;
			boolean torsoForbidsArms = !torsoAllowsArms.apply(currentTorsoEquipId) && finalArmsId != null &&
				finalArmsId > 0;
			if (torsoForbidsArms)
			{
				int revertTorsoId = savedSwaps.getRealKit(KitType.TORSO, gender) + KIT_OFFSET;
				Map<SwapDiff.Change.Type, SwapDiff.Change> result = swap(KitType.TORSO, revertTorsoId, SwapMode.REVERT,
					SwapMode.PREVIEW, allowDisabledSwaps);
				if (result.containsKey(SwapDiff.Change.Type.EQUIPMENT))
				{
					changes.put(KitType.TORSO, result.get(SwapDiff.Change.Type.EQUIPMENT));
				}
			}
		}
		else
		{
			// priority: show torso and hide arms, but not if locks on arms disallow (in which case don't change)
			boolean torsoDisallowed = !torsoAllowsArms.apply(torsoEquipId) && savedSwaps.isKitLocked(KitType.ARMS);
			finalTorsoId = torsoDisallowed ? null : torsoEquipId;
			Integer torsoIdToCheck = torsoDisallowed ? currentTorsoEquipId : torsoEquipId;
			Integer potentialArmsId = torsoAllowsArms.apply(torsoIdToCheck) ? armsEquipId : Integer.valueOf(0);
			finalArmsId = !savedSwaps.isKitLocked(KitType.ARMS) ? potentialArmsId : null;
		}

		// edge case:
		// if not changing arms but arms can be shown, make sure that at least something is displayed there
		if (finalArmsId == null && equipmentIdInSlot(KitType.ARMS) == 0 &&
			((finalTorsoId == null && torsoAllowsArms.apply(currentTorsoEquipId)) ||
				(finalTorsoId != null && torsoAllowsArms.apply(finalTorsoId))))
		{
			if (savedSwaps.isKitLocked(KitType.ARMS))
			{
				// arms locked on nothing, don't change torso to something that could show empty kit
				finalTorsoId = null;
			}
			else
			{
				int revertArmsId = savedSwaps.getRealKit(KitType.ARMS, gender) + KIT_OFFSET;
				Map<SwapDiff.Change.Type, SwapDiff.Change> result = swap(KitType.ARMS, revertArmsId, SwapMode.REVERT,
					SwapMode.PREVIEW, allowDisabledSwaps);
				if (result.containsKey(SwapDiff.Change.Type.EQUIPMENT))
				{
					changes.put(KitType.ARMS, result.get(SwapDiff.Change.Type.EQUIPMENT));
				}
			}
		}

		BiConsumer<KitType, Integer> attemptChange = (slot, equipId) -> {
			if (equipId != null && equipId >= 0)
			{
				Map<SwapDiff.Change.Type, SwapDiff.Change> result = swap(slot, equipId, swapModeProvider.apply(slot),
					SwapMode.PREVIEW, allowDisabledSwaps);
				if (result.containsKey(SwapDiff.Change.Type.EQUIPMENT))
				{
					changes.put(slot, result.get(SwapDiff.Change.Type.EQUIPMENT));
				}
			}
		};
		attemptChange.accept(KitType.TORSO, finalTorsoId);
		attemptChange.accept(KitType.ARMS, finalArmsId);
		return new SwapDiff(changes, new HashMap<>(), null, null);
	}

	/**
	 * Swaps an item weapon slot and an item in the shield slot. Behavior changes depending
	 * on the information present:
	 * <p>
	 * If the weapon id is null, only the shield will be considered. If the shield is non-null and
	 * non-zero, and the current weapon is two-handed, then the weapon will be removed.
	 * <p>
	 * If the weapon is non-null, non-zero, and two-handed, the shield will be removed. Otherwise,
	 * the weapon and shield are both swapped if they are respectively non-null.
	 * <p>
	 * Lastly, the idle animation ID will change if the sent weapon id is non-null or if it's determined
	 * that the weapon must be removed.
	 */
	private SwapDiff swapWeapons(
		Integer weaponEquipId,
		Integer shieldEquipId,
		boolean allowDisabledSwaps,
		Function<KitType, SwapMode> swapModeProvider)
	{
		Integer finalWeaponId = null;
		Integer finalShieldId;
		Integer finalAnimId = null;

		Function<Integer, Boolean> weaponForbidsShields = (equipId) -> {
			if (equipId >= ITEM_OFFSET)
			{
				ItemEquipmentStats stats = equipmentStatsFor(equipId - ITEM_OFFSET);
				return stats != null && stats.isTwoHanded();
			}
			return false;
		};

		if (weaponEquipId == null || savedSwaps.isItemLocked(KitType.WEAPON))
		{
			finalShieldId = shieldEquipId;
			if (shieldEquipId != null && weaponForbidsShields.apply(equipmentIdInSlot(KitType.WEAPON)))
			{
				if (!savedSwaps.isItemLocked(KitType.WEAPON))
				{
					finalWeaponId = 0;
					finalAnimId = IdleAnimationID.DEFAULT;
				}
				else
				{
					// weapon is locked and 2h, should not equip shield
					finalShieldId = null;
				}
			}
		}
		else
		{
			finalShieldId = weaponForbidsShields.apply(weaponEquipId) && !savedSwaps.isItemLocked(KitType.SHIELD) ?
				Integer.valueOf(0) :
				shieldEquipId;
			finalWeaponId = weaponForbidsShields.apply(weaponEquipId) && savedSwaps.isItemLocked(KitType.SHIELD) ?
				null :
				weaponEquipId;
			finalAnimId = finalWeaponId != null ?
				ItemInteractions.WEAPON_TO_IDLE.getOrDefault(weaponEquipId - ITEM_OFFSET, IdleAnimationID.DEFAULT) :
				null;
		}

		Map<KitType, SwapDiff.Change> changes = new HashMap<>();
		BiConsumer<KitType, Integer> attemptChange = (slot, equipId) -> {
			if (equipId != null && equipId >= 0)
			{
				Map<SwapDiff.Change.Type, SwapDiff.Change> results = swap(slot, equipId, swapModeProvider.apply(slot),
					SwapMode.PREVIEW, allowDisabledSwaps);
				if (results.containsKey(SwapDiff.Change.Type.EQUIPMENT))
				{
					changes.put(slot, results.get(SwapDiff.Change.Type.EQUIPMENT));
				}
			}
		};
		attemptChange.accept(KitType.WEAPON, finalWeaponId);
		attemptChange.accept(KitType.SHIELD, finalShieldId);

		Integer changedAnim = null;
		if (finalAnimId != null && finalAnimId >= 0)
		{
			Player player = client.getLocalPlayer();
			if (player != null)
			{
				changedAnim = setIdleAnimationId(player, finalAnimId, allowDisabledSwaps);
				if (changedAnim.equals(finalAnimId))
				{
					changedAnim = null;
				}
			}
		}
		return new SwapDiff(changes, new HashMap<>(), null, changedAnim);
	}

	/**
	 * this should only be called from one of the swap methods utilizing `CompoundSwap`, otherwise the
	 * swap may not make logical sense.
	 * <p>
	 * equipmentId follows `PlayerComposition::getEquipmentId`:
	 * 0 for nothing
	 * 256-2047 for a base kit model (i.e., kitId + 256)
	 * >=2048 for an item (i.e., itemId + 2048)
	 * <p>
	 *
	 * @return a map of changes performed, keyed by type (potentially empty if no changes)
	 */
	private Map<SwapDiff.Change.Type, SwapDiff.Change> swap(
		KitType slot, int equipmentId, SwapMode swapMode, SwapMode iconSwapMode, boolean allowDisabledSwaps)
	{
		Map<SwapDiff.Change.Type, SwapDiff.Change> changes = new HashMap<>();
		if (slot == null)
		{
			return changes;
		}
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return changes;
		}
		PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
		{
			return changes;
		}
		// returns equipment id of jaw kit (without icon)
		Function<Integer, Integer> deIconJaw = (equipId) -> {
			JawKit kit = JawKit.fromEquipmentId(equipId);
			if (kit != null)
			{
				Integer kitId = kit.getKitId(gender);
				if (kitId != null)
				{
					return kitId + KIT_OFFSET;
				}
			}
			return equipId;
		};
		// adjust equipment ids for jaw swaps since diff could be icon-only
		int saveId = equipmentId;
		if (slot == KitType.JAW && equipmentId >= ITEM_OFFSET)
		{
			saveId = deIconJaw.apply(equipmentId);
		}
		Supplier<Boolean> unnaturalCheck = () -> savedSwaps.containsSlot(slot) || savedSwaps.isHidden(slot);
		Supplier<Boolean> unnaturalIconCheck = () -> savedSwaps.containsIcon();
		int oldId = setEquipmentId(composition, slot, equipmentId, allowDisabledSwaps);
		int oldSaveId = oldId;
		if (slot == KitType.JAW && oldId >= ITEM_OFFSET)
		{
			oldSaveId = deIconJaw.apply(oldId);
		}
		boolean oldUnnatural = unnaturalCheck.get();
		switch (swapMode)
		{
			case SAVE:
				if (saveId <= 0)
				{
					if (ALLOWS_NOTHING.contains(slot))
					{
						savedSwaps.putNothing(slot);
					}
					else
					{
						savedSwaps.removeSlot(slot);
					}
				}
				else if (saveId < ITEM_OFFSET)
				{
					savedSwaps.putKit(slot, saveId - KIT_OFFSET);
				}
				else
				{
					savedSwaps.putItem(slot, saveId - ITEM_OFFSET);
				}
				break;
			case REVERT:
				savedSwaps.removeSlot(slot);
				break;
			case PREVIEW:
				break;
		}
		if (slot == KitType.JAW)
		{
			boolean oldUnnaturalIcon = unnaturalIconCheck.get();
			JawIcon oldIcon = oldId >= ITEM_OFFSET ? JawKit.iconFromItemId(oldId - ITEM_OFFSET) : JawIcon.NOTHING;
			JawIcon icon = equipmentId >= ITEM_OFFSET ? JawKit.iconFromItemId(equipmentId - ITEM_OFFSET) : JawIcon.NOTHING;
			switch (iconSwapMode)
			{
				case SAVE:
					if (equipmentId < ITEM_OFFSET)
					{
						savedSwaps.removeIcon();
					}
					else
					{
						savedSwaps.putIcon(icon);
					}
					break;
				case REVERT:
					savedSwaps.removeIcon();
					break;
				case PREVIEW:
					break;
			}
			boolean unnaturalIcon = unnaturalIconCheck.get();
			if (icon != oldIcon || oldUnnaturalIcon != unnaturalIcon)
			{
				changes.put(SwapDiff.Change.Type.ICON, new SwapDiff.Change(oldIcon.getId(), oldUnnaturalIcon));
			}
		}
		boolean unnatural = unnaturalCheck.get();
		if (oldSaveId != saveId || oldUnnatural != unnatural)
		{
			changes.put(SwapDiff.Change.Type.EQUIPMENT, new SwapDiff.Change(oldSaveId, oldUnnatural));
		}
		return changes;
	}

	/**
	 * Sets equipment id for slot and returns equipment id of previously occupied item.
	 * If allowDisabledSwaps is false or if the slot is disabled, no actual change occurs.
	 */
	private int setEquipmentId(
		@Nonnull PlayerComposition composition,
		@Nonnull KitType slot,
		int equipmentId,
		boolean allowDisabledSwaps)
	{
		int previousId = composition.getEquipmentIds()[slot.getIndex()];
		if (allowDisabledSwaps || !disabledSlots.containsKey(slot))
		{
			composition.getEquipmentIds()[slot.getIndex()] = equipmentId;
			composition.setHash();
		}
		return previousId;
	}

	/**
	 * Sets color id for slot and returns color id before replacement.
	 */
	private int setColorId(@Nonnull PlayerComposition composition, @Nonnull ColorType type, int colorId)
	{
		int[] colors = composition.getColors();
		int previousId = colors[type.ordinal()];
		colors[type.ordinal()] = colorId;
		composition.setHash();
		return previousId;
	}

	/**
	 * Sets idle animation id for current player and returns previous idle animation.
	 * If allowDisabledSwaps is false or the weapon slot is disabled, no actual anim change occurs.
	 */
	private int setIdleAnimationId(@Nonnull Player player, int animationId, boolean allowDisabledSwaps)
	{
		int previousId = player.getIdlePoseAnimation();
		if (allowDisabledSwaps || !disabledSlots.containsKey(KitType.WEAPON))
		{
			player.setIdlePoseAnimation(animationId);
		}
		return previousId;
	}

	/**
	 * Performs a revert back to an "original" state for the given slot.
	 * In most cases, this swaps to whatever was actually equipped in the slot. Some exceptions:
	 * When reverting a kit, and an item is actually equipped in a slot that hides that kit, the item will be shown
	 * and the kit will be hidden.
	 */
	private SwapDiff doRevert(KitType slot)
	{
		if (slot == KitType.HAIR)
		{
			Integer headItemId = inventoryItemId(KitType.HEAD);
			if (headItemId != null && headItemId >= 0 && !ItemInteractions.HAIR_HELMS.contains(headItemId))
			{
				return swap(CompoundSwap.single(KitType.HEAD, headItemId + ITEM_OFFSET), SwapMode.REVERT, SwapMode.PREVIEW);
			}
		}
		else if (slot == KitType.JAW)
		{
			Integer headItemId = inventoryItemId(KitType.HEAD);
			if (headItemId != null && headItemId >= 0 && ItemInteractions.NO_JAW_HELMS.contains(headItemId))
			{
				return swap(CompoundSwap.single(KitType.HEAD, headItemId + ITEM_OFFSET), SwapMode.REVERT, SwapMode.PREVIEW);
			}
		}
		else if (slot == KitType.ARMS)
		{
			Integer torsoItemId = inventoryItemId(KitType.TORSO);
			if (torsoItemId != null && torsoItemId >= 0 && !ItemInteractions.ARMS_TORSOS.contains(torsoItemId))
			{
				return swap(CompoundSwap.single(KitType.TORSO, torsoItemId + ITEM_OFFSET), SwapMode.REVERT, SwapMode.PREVIEW);
			}
		}
		Integer originalItemId = inventoryItemId(slot);
		Integer originalKitId = savedSwaps.getRealKit(slot, gender);
		if (originalKitId == -KIT_OFFSET)
		{
			originalKitId = null;
		}
		int equipmentId;
		if (originalItemId != null)
		{
			equipmentId = originalItemId < 0 ? 0 : originalItemId + ITEM_OFFSET;
		}
		else if (originalKitId != null)
		{
			equipmentId = originalKitId < 0 ? 0 : originalKitId + KIT_OFFSET;
		}
		else
		{
			equipmentId = 0;
		}
		return swap(CompoundSwap.single(slot, equipmentId), SwapMode.REVERT, SwapMode.PREVIEW);
	}

	private SwapDiff doRevert(ColorType type)
	{
		Integer originalColorId = savedSwaps.getRealColor(type);
		return swap(type, originalColorId, SwapMode.REVERT);
	}

	private SwapDiff doRevertIcon()
	{
		JawIcon revertIcon = savedSwaps.getRealIcon();
		if (revertIcon == null)
		{
			revertIcon = JawIcon.NOTHING;
		}
		int jawEquipId = combineJawIcon(null, revertIcon);
		JawKit kit = JawKit.fromEquipmentId(jawEquipId);
		if (kit != null)
		{
			Integer kitId = kit.getKitId(gender);
			if (kitId != null)
			{
				Map<SwapDiff.Change.Type, SwapDiff.Change> changes = swap(KitType.JAW, kitId + KIT_OFFSET,
					SwapMode.PREVIEW, SwapMode.REVERT, false);
				SwapDiff.Change iconChange = changes.get(SwapDiff.Change.Type.ICON);
				return new SwapDiff(new HashMap<>(), new HashMap<>(), iconChange, null);
			}
		}
		return SwapDiff.blank();
	}

	/**
	 * Combines given jaw equipment id and icon to one equipment id. If either are null, will use current saved
	 * values.
	 */
	private int combineJawIcon(Integer jawEquipId, @Nullable JawIcon icon)
	{
		int finalJawId;
		if (jawEquipId != null)
		{
			finalJawId = jawEquipId;
		}
		else
		{
			Integer jawKitId = savedSwaps.getKit(KitType.JAW);
			if (jawKitId != null)
			{
				finalJawId = jawKitId + KIT_OFFSET;
			}
			else
			{
				finalJawId = savedSwaps.getRealKit(KitType.JAW, gender) + KIT_OFFSET;
			}
		}
		JawIcon finalJawIcon;
		if (icon != null)
		{
			finalJawIcon = icon;
		}
		else
		{
			finalJawIcon = savedSwaps.getSwappedIcon();
			if (finalJawIcon == null)
			{
				finalJawIcon = savedSwaps.getRealIcon();
			}
			if (finalJawIcon == null)
			{
				finalJawIcon = JawIcon.NOTHING;
			}
		}
		JawKit kit = JawKit.fromEquipmentId(finalJawId);
		if (kit != null)
		{
			Integer itemId = kit.getIconItemId(finalJawIcon);
			if (itemId != null)
			{
				return itemId + ITEM_OFFSET;
			}
		}
		return finalJawId;
	}

	@Nullable
	public KitType slotForId(Integer slotId)
	{
		if (slotId == null)
		{
			return null;
		}
		return Arrays.stream(KitType.values())
			.filter(type -> type.getIndex() == slotId)
			.findFirst()
			.orElse(null);
	}



	@Nullable
	public ItemEquipmentStats equipmentStatsFor(int itemId)
	{
		ItemStats stats = itemManager.getItemStats(itemId);
		return stats != null && stats.isEquipable() ? stats.getEquipment() : null;
	}

	/**
	 * returns the equipment id of whatever is being displayed in the given slot
	 */
	public int equipmentIdInSlot(KitType kitType)
	{
		if (savedSwaps.isHidden(kitType))
		{
			return 0;
		}
		Integer virtualItemId = savedSwaps.getItem(kitType);
		if (virtualItemId != null && virtualItemId >= 0)
		{
			return virtualItemId + ITEM_OFFSET;
		}
		Integer realItemId = inventoryItemId(kitType);
		if (realItemId != null && realItemId >= 0)
		{
			// check if a virtual slot is obscuring the real item
			boolean realItemHidden = false;
			switch (kitType)
			{
				case HEAD:
					realItemHidden = (!ItemInteractions.HAIR_HELMS.contains(realItemId) &&
						savedSwaps.containsSlot(KitType.HAIR)) ||
						(ItemInteractions.NO_JAW_HELMS.contains(realItemId) && savedSwaps.containsSlot(KitType.JAW));
					break;
				case TORSO:
					realItemHidden = !ItemInteractions.ARMS_TORSOS.contains(realItemId) &&
						savedSwaps.containsSlot(KitType.ARMS);
					break;
				default:
					break;
			}
			if (!realItemHidden)
			{
				return realItemId + ITEM_OFFSET;
			}
		}
		if (kitType == KitType.JAW)
		{
			int jawEquipId = combineJawIcon(null, null);
			int headEquipId = equipmentIdInSlot(KitType.HEAD);
			boolean jawlessIcon = jawEquipId >= ITEM_OFFSET && JawKit.isNoJawIcon(jawEquipId - ITEM_OFFSET);
			if (!ItemInteractions.NO_JAW_HELMS.contains(headEquipId - ITEM_OFFSET) || jawEquipId <= 0 || jawlessIcon)
			{
				return jawEquipId;
			}
		}
		Integer kitId = kitIdFor(kitType);
		return kitId != null && kitId >= 0 ? kitId + KIT_OFFSET : 0;
	}

	/**
	 * returns the item id of the actual item equipped in the given slot (swaps are ignored)
	 */
	@Nullable
	public Integer inventoryItemId(KitType kitType)
	{
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return null;
		}
		PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
		{
			return null;
		}
		ItemContainer inventory = client.getItemContainer(InventoryID.WORN);
		if (inventory == null)
		{
			return null;
		}
		Item item = inventory.getItem(kitType.getIndex());
		return item != null && item.getId() >= 0 ? item.getId() : null;
	}

	@Nullable
	private Integer kitIdFor(KitType kitType)
	{
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return null;
		}
		PlayerComposition composition = player.getPlayerComposition();
		return composition == null ? null : composition.getKitId(kitType);
	}

	@Nullable
	private Integer colorIdFor(ColorType colorType)
	{
		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return null;
		}
		PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
		{
			return null;
		}
		int[] colors = composition.getColors();
		return colors[colorType.ordinal()];
	}

	// restores diff and returns a new diff with reverted changes (allows redo)
	private SwapDiff restore(SwapDiff swapDiff, boolean save)
	{
		Function<KitType, SwapMode> swapModeProvider = (slot) -> {
			SwapDiff.Change change = swapDiff.getSlotChanges().get(slot);
			return !save ? SwapMode.PREVIEW : change != null && change.isUnnatural() ?
				SwapMode.SAVE :
				SwapMode.REVERT;
		};
		SwapDiff.Change iconChange = swapDiff.getIconChange();
		SwapMode iconSwapMode = (!save || iconChange == null) ? SwapMode.PREVIEW :
			iconChange.isUnnatural() ? SwapMode.SAVE : SwapMode.REVERT;
		JawIcon icon = iconChange != null ? JawIcon.fromId(iconChange.getId()) : null;
		// restore kits and items
		Map<KitType, Integer> restoreEquipIds = sanitize(
			swapDiff.getSlotChanges().entrySet().stream().collect(
				Collectors.toMap(Map.Entry::getKey, e -> e.getValue().getId()))
		);
		SwapDiff slotRestore = CompoundSwap.fromMap(restoreEquipIds, icon)
			.stream()
			.map(c -> this.swap(c, false, swapModeProvider, iconSwapMode))
			.reduce(SwapDiff::mergeOver)
			.orElse(SwapDiff.blank());
		SwapDiff colorRestore = swapDiff.getColorChanges().entrySet()
			.stream()
			.map(e -> {
				ColorType type = e.getKey();
				SwapDiff.Change change = e.getValue();
				int colorId = change.getId();
				SwapMode mode;
				if (save)
				{
					mode = change.isUnnatural() ? SwapMode.SAVE : SwapMode.REVERT;
				}
				else
				{
					mode = SwapMode.PREVIEW;
				}
				return swap(type, colorId, mode);
			})
			.reduce(SwapDiff::mergeOver)
			.orElse(SwapDiff.blank());
		return slotRestore.mergeOver(colorRestore);
	}

}

package eq.uirs.fashionscape.core;

import eq.uirs.fashionscape.data.color.ColorType;
import java.util.HashMap;
import java.util.Map;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.Value;
import net.runelite.api.kit.KitType;

/**
 * Holds onto information about equipment and animations before a swap occurred
 */
@Getter
@RequiredArgsConstructor
@ToString
@EqualsAndHashCode
public class SwapDiff
{
	@Value
	public static class Change
	{
		public enum Type
		{

			EQUIPMENT,
			COLOR,
			ICON

		}

		/**
		 * The changed equipment id, color id, or icon id (depending on type)
		 */
		int id;
		/**
		 * Indicates that the previous state was "unnatural", i.e., originated from the plugin, not the game
		 */
		boolean unnatural;
	}

	public static SwapDiff blank()
	{
		return new SwapDiff(new HashMap<>(), new HashMap<>(), null, null);
	}

	private final Map<KitType, Change> slotChanges;
	private final Map<ColorType, Change> colorChanges;
	private final Change iconChange;
	private final Integer changedIdleAnimationId;

	boolean isBlank()
	{
		return changedIdleAnimationId == null && iconChange == null && slotChanges.isEmpty() && colorChanges.isEmpty();
	}

	// This diff will take priority of the other diff in the event of a collision.
	public SwapDiff mergeOver(SwapDiff other)
	{
		Map<KitType, Change> mergedSlots = new HashMap<>();
		mergedSlots.putAll(other.slotChanges);
		mergedSlots.putAll(this.slotChanges);
		Map<ColorType, Change> mergedColors = new HashMap<>();
		mergedColors.putAll(other.colorChanges);
		mergedColors.putAll(this.colorChanges);
		Change iconChange = this.iconChange;
		if (iconChange == null)
		{
			iconChange = other.iconChange;
		}
		Integer idleId = this.changedIdleAnimationId;
		if (idleId == null)
		{
			idleId = other.changedIdleAnimationId;
		}
		return new SwapDiff(mergedSlots, mergedColors, iconChange, idleId);
	}
}

package eq.uirs.fashionscape.core;

import java.util.LinkedList;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

/**
 * Observable wrapper for user's undo / redo history
 */
@RequiredArgsConstructor
@Slf4j
public class SwapDiffHistory
{
	private final Function<SwapDiff, SwapDiff> restoration;
	private static final int MAX_LIST_SIZE = 10;

	private final LinkedList<SwapDiff> undoSwapDiffs = new LinkedList<>();
	private final List<Consumer<Integer>> undoCountListeners = new LinkedList<>();

	private final LinkedList<SwapDiff> redoSwapDiffs = new LinkedList<>();
	private final List<Consumer<Integer>> redoCountListeners = new LinkedList<>();

	void addUndoQueueChangeListener(Consumer<Integer> listener)
	{
		undoCountListeners.add(listener);
	}

	void addRedoQueueChangeListener(Consumer<Integer> listener)
	{
		redoCountListeners.add(listener);
	}

	void removeListeners()
	{
		undoCountListeners.clear();
		redoCountListeners.clear();
	}

	void undoLast()
	{
		if (undoSwapDiffs.isEmpty())
		{
			return;
		}
		SwapDiff last = undoSwapDiffs.removeLast();
		undoCountListeners.forEach(listener -> listener.accept(undoSwapDiffs.size()));
		SwapDiff redo = restoration.apply(last);
		addRedoDiff(redo);
	}

	void redoLast()
	{
		if (redoSwapDiffs.isEmpty())
		{
			return;
		}
		SwapDiff last = redoSwapDiffs.removeLast();
		redoCountListeners.forEach(listener -> listener.accept(redoSwapDiffs.size()));
		SwapDiff restore = restoration.apply(last);
		addUndoDiff(restore);
	}

	public void appendToUndo(SwapDiff swapDiff)
	{
		if (swapDiff.isBlank())
		{
			return;
		}
		addUndoDiff(swapDiff);
		redoSwapDiffs.clear();
		redoCountListeners.forEach(listener -> listener.accept(0));
	}

	int undoSize()
	{
		return undoSwapDiffs.size();
	}

	int redoSize()
	{
		return redoSwapDiffs.size();
	}

	private void addUndoDiff(SwapDiff swapDiff)
	{
		if (swapDiff.isBlank())
		{
			return;
		}
		SwapDiff lastUndo = undoSwapDiffs.peekLast();
		if (swapDiff.equals(lastUndo))
		{
			return;
		}
		undoSwapDiffs.add(swapDiff);
		while (undoSwapDiffs.size() > MAX_LIST_SIZE)
		{
			undoSwapDiffs.removeFirst();
		}
		undoCountListeners.forEach(listener -> listener.accept(undoSwapDiffs.size()));
	}

	private void addRedoDiff(SwapDiff swapDiff)
	{
		if (swapDiff.isBlank())
		{
			return;
		}
		SwapDiff lastRedo = redoSwapDiffs.peekLast();
		if (swapDiff.equals(lastRedo))
		{
			return;
		}
		redoSwapDiffs.add(swapDiff);
		while (redoSwapDiffs.size() > MAX_LIST_SIZE)
		{
			redoSwapDiffs.removeFirst();
		}
		redoCountListeners.forEach(listener -> listener.accept(redoSwapDiffs.size()));
	}

}


package eq.uirs.fashionscape.core;

public enum SwapMode
{
	/**
	 * Swapping to a "virtual" item that will show up in the side panel
	 */
	SAVE,
	/**
	 * Indicates that whatever is being sent is not "virtual", so it should clear the panel UI
	 */
	REVERT,
	/**
	 * A temporary preview where the item will be swapped but it won't be saved to the panel
	 */
	PREVIEW
}

package eq.uirs.fashionscape.core;

import eq.uirs.fashionscape.data.color.ColorType;
import eq.uirs.fashionscape.data.kit.JawIcon;
import eq.uirs.fashionscape.data.kit.JawKit;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.PlayerComposition;
import net.runelite.api.kit.KitType;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.game.ItemManager;

/**
 * For saving/loading fashionscape to local files
 */
@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = {@Inject})
public class Exporter
{
	public static final File OUTFITS_DIR = new File(RuneLite.RUNELITE_DIR, "outfits");

	private static final Pattern PROFILE_PATTERN = Pattern.compile("^(\\w+):(-?\\d+).*");
	private static final String KIT_SUFFIX = "_KIT";
	private static final String COLOR_SUFFIX = "_COLOR";
	private static final String ICON_KEY = "ICON";

	private final ClientThread clientThread;
	private final ChatMessageManager chatMessageManager;
	private final ItemManager itemManager;

	private final SavedSwaps savedSwaps;
	private final Provider<FashionManager> fashionManagerProvider;

	// this should only be called from the client thread
	public List<String> stringifySwaps()
	{
		Set<Map.Entry<KitType, Integer>> itemEntries = new HashSet<>(savedSwaps.hiddenSlotEntries());
		itemEntries.addAll(savedSwaps.itemEntries());
		List<String> items = itemEntries.stream()
			.sorted(Comparator.comparingInt(Map.Entry::getValue))
			.map(e -> {
				KitType slot = e.getKey();
				int itemId = e.getValue();
				if (itemId == 0)
				{
					return slot.name() + ":-1 (Nothing)";
				}
				else
				{
					String itemName = itemManager.getItemComposition(itemId).getMembersName();
					return slot.name() + ":" + itemId + " (" + itemName + ")";
				}
			})
			.collect(Collectors.toList());
		List<String> kits = savedSwaps.kitEntries().stream()
			.sorted(Comparator.comparingInt(Map.Entry::getValue))
			.map(e -> {
				KitType slot = e.getKey();
				Integer kitId = e.getValue();
				String kitName = FashionManager.KIT_ID_TO_KIT.get(kitId).getDisplayName();
				return slot.name() + KIT_SUFFIX + ":" + kitId + " (" + kitName + ")";
			})
			.collect(Collectors.toList());
		List<String> colors = savedSwaps.colorEntries().stream()
			.sorted(Comparator.comparingInt(Map.Entry::getValue))
			.map(e -> {
				ColorType type = e.getKey();
				int colorId = e.getValue();
				return Arrays.stream(type.getColorables())
					.filter(c -> c.getColorId(type) == colorId)
					.findFirst()
					.map(c -> type.name() + COLOR_SUFFIX + ":" + colorId + " (" + c.getDisplayName() + ")")
					.orElse("");
			})
			.collect(Collectors.toList());
		List<String> icons = new ArrayList<>();
		JawIcon icon = savedSwaps.getSwappedIcon();
		if (savedSwaps.containsIcon())
		{
			icons.add(ICON_KEY + ":" + icon.getId() + " (" + icon.getDisplayName() + ")");
		}
		items.addAll(kits);
		items.addAll(colors);
		items.addAll(icons);
		return items;
	}

	public void parseImports(List<String> allLines)
	{
		Map<KitType, Integer> itemImports = new HashMap<>();
		Map<KitType, Integer> kitImports = new HashMap<>();
		Map<ColorType, Integer> colorImports = new HashMap<>();
		JawIcon icon = null;
		Set<KitType> removes = new HashSet<>();
		for (String line : allLines)
		{
			if (line.trim().isEmpty())
			{
				continue;
			}
			Matcher matcher = PROFILE_PATTERN.matcher(line);
			if (matcher.matches())
			{
				String slotStr = matcher.group(1);
				// could be item id, kit id, or color id
				int id = Integer.parseInt(matcher.group(2));
				KitType itemSlot = itemSlotMatch(slotStr);
				KitType kitSlot = kitSlotMatch(slotStr);
				ColorType colorType = colorSlotMatch(slotStr);
				if (itemSlot != null)
				{
					if (id <= 0)
					{
						removes.add(itemSlot);
					}
					else
					{
						itemImports.put(itemSlot, id);
					}
				}
				else if (kitSlot != null)
				{
					kitImports.put(kitSlot, id);
				}
				else if (colorType != null)
				{
					colorImports.put(colorType, id);
				}
				else if (slotStr.equals(ICON_KEY))
				{
					icon = JawIcon.fromId(id);
				}
				else
				{
					sendHighlightedMessage("Could not import line: " + line);
				}
			}
		}
		// if not explicitly included, items without data should be explicitly hidden
		FashionManager.ALLOWS_NOTHING.forEach(slot -> {
			if (!itemImports.containsKey(slot))
			{
				removes.add(slot);
			}
		});
		if (!itemImports.isEmpty() || !kitImports.isEmpty() || !colorImports.isEmpty())
		{
			fashionManagerProvider.get().importSwaps(itemImports, kitImports, colorImports, icon, removes);
		}
	}

	@Nullable
	private KitType itemSlotMatch(String name)
	{
		try
		{
			return KitType.valueOf(name);
		}
		catch (Exception e)
		{
			return null;
		}
	}

	@Nullable
	private KitType kitSlotMatch(String name)
	{
		try
		{
			String k = name.replace(KIT_SUFFIX, "");
			return KitType.valueOf(k);
		}
		catch (Exception e)
		{
			return null;
		}
	}

	@Nullable
	private ColorType colorSlotMatch(String name)
	{
		try
		{
			String c = name.replace(COLOR_SUFFIX, "");
			return ColorType.valueOf(c);
		}
		catch (Exception e)
		{
			return null;
		}
	}

	public void importPlayer(PlayerComposition other)
	{
		int[] equipmentIds = other.getEquipmentIds();
		KitType[] slots = KitType.values();
		Map<KitType, Integer> equipIdImports = IntStream.range(0, equipmentIds.length).boxed()
			.collect(Collectors.toMap(i -> slots[i], i -> equipmentIds[i]));

		Map<KitType, Integer> itemImports = equipIdImports.entrySet().stream()
			.filter(e -> e.getValue() >= FashionManager.ITEM_OFFSET)
			.collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() - FashionManager.ITEM_OFFSET));
		Map<KitType, Integer> kitImports = equipIdImports.entrySet().stream()
			.filter(e -> e.getValue() >= FashionManager.KIT_OFFSET && e.getValue() < FashionManager.ITEM_OFFSET)
			.collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() - FashionManager.KIT_OFFSET));
		Set<KitType> removals = equipIdImports.entrySet().stream()
			.filter(e -> e.getValue() <= 0)
			.map(Map.Entry::getKey)
			.collect(Collectors.toSet());

		int[] colors = other.getColors();
		ColorType[] types = ColorType.values();
		Map<ColorType, Integer> colorImports = IntStream.range(0, colors.length).boxed()
			.collect(Collectors.toMap(i -> types[i], i -> colors[i]));

		JawIcon icon = null;
		Integer jawItemId = itemImports.get(KitType.JAW);
		if (jawItemId != null)
		{
			icon = JawKit.iconFromItemId(jawItemId);
			itemImports.remove(KitType.JAW);
		}

		if (!itemImports.isEmpty() || !kitImports.isEmpty() || !colorImports.isEmpty() || !removals.isEmpty())
		{
			fashionManagerProvider.get().importSwaps(itemImports, kitImports, colorImports, icon, removals);
		}
	}

	public void export(File selected)
	{
		clientThread.invokeLater(() -> {
			try (PrintWriter out = new PrintWriter(selected))
			{
				List<String> exports = stringifySwaps();
				for (String line : exports)
				{
					out.println(line);
				}
				sendHighlightedMessage("Saved fashionscape to " + selected.getName());
			}
			catch (FileNotFoundException e)
			{
				log.warn("Could not find selected file for swaps export", e);
			}
		});
	}

	private void sendHighlightedMessage(String message)
	{
		String chatMessage = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(message)
			.build();

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(chatMessage)
			.build());
	}
}

package eq.uirs.fashionscape.core.randomizer;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Determines the size of the queue for scoring the "best" matched item via randomizer request
 */
@Getter
@RequiredArgsConstructor
public enum RandomizerIntelligence
{
	NONE(1),
	LOW(15),
	MODERATE(30),
	HIGH(50);

	private final int depth;
}

package eq.uirs.fashionscape.core.randomizer;

import eq.uirs.fashionscape.FashionscapeConfig;
import eq.uirs.fashionscape.FashionscapePlugin;
import eq.uirs.fashionscape.colors.ColorScorer;
import eq.uirs.fashionscape.core.CompoundSwap;
import eq.uirs.fashionscape.core.FashionManager;
import eq.uirs.fashionscape.core.SavedSwaps;
import eq.uirs.fashionscape.core.SwapDiff;
import eq.uirs.fashionscape.core.SwapMode;
import eq.uirs.fashionscape.data.anim.ItemInteractions;
import eq.uirs.fashionscape.data.color.ColorType;
import eq.uirs.fashionscape.data.color.Colorable;
import eq.uirs.fashionscape.data.kit.JawIcon;
import eq.uirs.fashionscape.data.kit.JawKit;
import eq.uirs.fashionscape.data.kit.Kit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Random;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import javax.inject.Inject;
import javax.inject.Provider;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemEquipmentStats;
import net.runelite.client.game.ItemManager;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = {@Inject})
public class Randomizer
{
	private static final Map<KitType, List<Kit>> KIT_TYPE_TO_KITS = Arrays.stream(KitType.values())
		.collect(Collectors.toMap(s -> s, s -> Arrays.asList(Kit.allInSlot(s, true))));;

	private final Client client;
	private final ItemManager itemManager;
	private final FashionscapeConfig config;
	private final ColorScorer colorScorer;
	private final SavedSwaps savedSwaps;
	private final Provider<FashionManager> fashionManagerProvider;

	@Value
	private static class Candidate
	{
		public int itemId;
		public KitType slot;
	}

	/**
	 * Randomizes items/kits/colors in unlocked slots.
	 * Can only be called from the client thread.
	 */
	public void shuffle()
	{
		FashionManager fashionManager = fashionManagerProvider.get();
		final Random r = new Random();
		RandomizerIntelligence intelligence = config.randomizerIntelligence();
		int size = intelligence.getDepth();
		if (size > 1)
		{
			Map<KitType, Integer> lockedItems = Arrays.stream(KitType.values())
				.filter(s -> savedSwaps.isItemLocked(s) && savedSwaps.containsItem(s))
				.collect(Collectors.toMap(s -> s, savedSwaps::getItem));
			if (savedSwaps.isIconLocked() && savedSwaps.containsIcon())
			{
				Integer iconItemId = JawKit.NO_JAW.getIconItemId(savedSwaps.getSwappedIcon());
				if (iconItemId != null)
				{
					lockedItems.put(KitType.JAW, iconItemId);
				}
			}
			Map<ColorType, Colorable> lockedColors = fashionManager.swappedColorsMap().entrySet().stream()
				.filter(e -> savedSwaps.isColorLocked(e.getKey()) && savedSwaps.containsColor(e.getKey()))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
			colorScorer.setPlayerInfo(lockedItems, lockedColors);
		}
		Map<KitType, Boolean> itemSlotsToRevert = Arrays.stream(KitType.values())
			.collect(Collectors.toMap(slot -> slot, savedSwaps::isItemLocked));

		// pre-fill slots that will be skipped with -1 as a placeholder
		Map<KitType, Integer> newSwaps = Arrays.stream(KitType.values())
			.filter(itemSlotsToRevert::get)
			.collect(Collectors.toMap(s -> s, s -> -1));
		Set<Integer> skips = FashionscapePlugin.getItemIdsToExclude(config);
		List<Candidate> candidates = new ArrayList<>(size);
		List<Integer> randomOrder = IntStream.range(0, client.getItemCount()).boxed().collect(Collectors.toList());
		Collections.shuffle(randomOrder);
		Iterator<Integer> randomIterator = randomOrder.iterator();
		while (newSwaps.size() < KitType.values().length && randomIterator.hasNext())
		{
			Integer i = randomIterator.next();
			int canonical = itemManager.canonicalize(i);
			if (skips.contains(canonical))
			{
				continue;
			}
			ItemComposition itemComposition = itemManager.getItemComposition(canonical);
			int itemId = itemComposition.getId();
			KitType slot = fashionManager.slotForId(fashionManager.slotIdFor(itemComposition));
			if (slot != null && !newSwaps.containsKey(slot))
			{
				// Don't equip a 2h weapon if we already have a shield
				if (slot == KitType.WEAPON)
				{
					ItemEquipmentStats stats = fashionManager.equipmentStatsFor(itemId);
					if (stats != null && stats.isTwoHanded() && newSwaps.get(KitType.SHIELD) != null)
					{
						continue;
					}
				}
				// Don't equip a shield if we already have a 2h weapon (mark shield as removed instead)
				else if (slot == KitType.SHIELD)
				{
					Integer weaponItemId = newSwaps.get(KitType.WEAPON);
					if (weaponItemId != null)
					{
						ItemEquipmentStats stats = fashionManager.equipmentStatsFor(weaponItemId);
						if (stats != null && stats.isTwoHanded())
						{
							newSwaps.put(KitType.SHIELD, -1);
							continue;
						}
					}
				}
				else if (slot == KitType.HEAD)
				{
					// Don't equip a helm if it hides hair and hair is locked
					if (!ItemInteractions.HAIR_HELMS.contains(itemId) && savedSwaps.isKitLocked(KitType.HAIR))
					{
						continue;
					}
					// Don't equip a helm if it hides jaw and jaw is locked
					if (ItemInteractions.NO_JAW_HELMS.contains(itemId) && savedSwaps.isKitLocked(KitType.JAW))
					{
						continue;
					}
				}
				else if (slot == KitType.TORSO)
				{
					// Don't equip torso if it hides arms and arms is locked
					if (!ItemInteractions.ARMS_TORSOS.contains(itemId) && savedSwaps.isKitLocked(KitType.ARMS))
					{
						continue;
					}
				}
				candidates.add(new Candidate(itemComposition.getId(), slot));
			}

			if (!candidates.isEmpty() && candidates.size() >= size)
			{
				Candidate best;
				if (size > 1)
				{
					best = candidates.stream()
						.max(Comparator.comparingDouble(c -> colorScorer.score(c.itemId, c.slot)))
						.get();
					colorScorer.addPlayerInfo(best.slot, best.itemId);
				}
				else
				{
					best = candidates.get(0);
				}
				newSwaps.put(best.slot, best.itemId);
				candidates.clear();
			}
		}
		// slots filled with -1 were placeholders that need to be removed
		List<KitType> removes = newSwaps.entrySet().stream()
			.filter(e -> e.getValue() < 0)
			.map(Map.Entry::getKey)
			.collect(Collectors.toList());
		removes.forEach(newSwaps::remove);

		// shuffle colors
		Map<ColorType, Integer> newColors = new HashMap<>();
		List<ColorType> allColorTypes = Arrays.asList(ColorType.values().clone());
		Collections.shuffle(allColorTypes);
		for (ColorType type : allColorTypes)
		{
			if (savedSwaps.isColorLocked(type))
			{
				continue;
			}
			List<Colorable> colorables = Arrays.asList(type.getColorables().clone());
			if (colorables.isEmpty())
			{
				continue;
			}
			Collections.shuffle(colorables);
			int limit;
			switch (intelligence)
			{
				case LOW:
					limit = Math.max(1, colorables.size() / 4);
					break;
				case MODERATE:
					limit = Math.max(1, colorables.size() / 2);
					break;
				case HIGH:
					limit = colorables.size();
					break;
				default:
					limit = 1;
			}
			Colorable best = colorables.stream()
				.limit(limit)
				.max(Comparator.comparingDouble(c -> colorScorer.score(c, type)))
				.orElse(colorables.get(0));
			colorScorer.addPlayerColor(type, best);
			newColors.put(type, best.getColorId(type));
		}

		SwapDiff totalDiff = SwapDiff.blank();

		// convert to equipment ids
		Map<KitType, Integer> newEquipSwaps = newSwaps.entrySet().stream()
			.collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + FashionManager.ITEM_OFFSET));

		// swap items now before moving on to kits
		SwapDiff itemsDiff = CompoundSwap.fromMap(newEquipSwaps, null).stream()
			.map(c -> fashionManager.swap(c, SwapMode.SAVE))
			.reduce(SwapDiff::mergeOver)
			.orElse(SwapDiff.blank());
		totalDiff = totalDiff.mergeOver(itemsDiff);

		// See if remaining slots can be kit-swapped
		if (fashionManager.getGender() != null && !config.excludeBaseModels())
		{
			Map<KitType, Integer> kitSwaps = Arrays.stream(KitType.values())
				.filter(slot -> !newSwaps.containsKey(slot) && isOpen(slot))
				.map(slot -> {
					List<Kit> kits = KIT_TYPE_TO_KITS.getOrDefault(slot, new ArrayList<>()).stream()
						.filter(k -> k.getKitId(fashionManager.getGender()) != null)
						.collect(Collectors.toList());
					return kits.isEmpty() ? null : kits.get(r.nextInt(kits.size()));
				})
				.filter(Objects::nonNull)
				.collect(Collectors.toMap(Kit::getKitType, k -> k.getKitId(fashionManager.getGender())));

			Map<KitType, Integer> kitEquipSwaps = kitSwaps.entrySet().stream()
				.collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() + FashionManager.KIT_OFFSET));

			SwapDiff kitsDiff = CompoundSwap.fromMap(kitEquipSwaps, null)
				.stream()
				.map(c -> fashionManager.swap(c, SwapMode.SAVE))
				.reduce(SwapDiff::mergeOver)
				.orElse(SwapDiff.blank());

			totalDiff = totalDiff.mergeOver(kitsDiff);
		}

		if (!config.excludeNonStandardItems() && !config.excludeMembersItems() && !savedSwaps.isIconLocked())
		{
			List<JawIcon> icons = Arrays.asList(JawIcon.values());
			Collections.shuffle(icons);
			int limit = icons.size();
			if (intelligence == RandomizerIntelligence.NONE)
			{
				limit = 1;
			}
			Map<JawIcon, Double> scores = icons.stream()
				.limit(limit)
				.collect(Collectors.toMap(i -> i, i -> {
					Integer itemId = JawKit.NO_JAW.getIconItemId(i);
					return itemId != null ? colorScorer.score(itemId, null) : 0;
				}));
			// only icon swap if >75% match (if intelligence is > NONE)
			JawIcon icon = scores.entrySet().stream()
				.filter(e -> intelligence == RandomizerIntelligence.NONE || e.getValue() > 0.75)
				.max(Comparator.comparingDouble(Map.Entry::getValue))
				.map(Map.Entry::getKey)
				.orElse(JawIcon.NOTHING);
			SwapDiff iconDiff = fashionManager.swap(CompoundSwap.fromIcon(icon), SwapMode.PREVIEW, SwapMode.SAVE);
			totalDiff = totalDiff.mergeOver(iconDiff);
		}

		SwapDiff colorsDiff = newColors.entrySet().stream()
			.filter(e -> e.getValue() >= 0)
			.map(e -> fashionManager.swap(e.getKey(), e.getValue(), SwapMode.SAVE))
			.reduce(SwapDiff::mergeOver)
			.orElse(SwapDiff.blank());

		totalDiff = totalDiff.mergeOver(colorsDiff);

		fashionManager.getSwapDiffHistory().appendToUndo(totalDiff);
	}

	/**
	 * @return true if the slot does not have an item (real or virtual) obscuring it (directly or indirectly)
	 */
	public boolean isOpen(KitType slot)
	{
		if (slot == null || savedSwaps.isKitLocked(slot) || savedSwaps.containsItem(slot))
		{
			return false;
		}
		FashionManager fashionManager = fashionManagerProvider.get();
		Supplier<Boolean> fallback = () -> {
			if (fashionManager.equipmentIdInSlot(slot) > 0)
			{
				// equipment id must be a kit since there can't be an item at this point
				return true;
			}
			else
			{
				Integer actualEquipId = fashionManager.inventoryItemId(slot);
				return actualEquipId == null || actualEquipId < FashionManager.ITEM_OFFSET;
			}
		};
		switch (slot)
		{
			case HAIR:
			case JAW:
				int headEquipId = fashionManager.equipmentIdInSlot(KitType.HEAD);
				if (headEquipId > FashionManager.ITEM_OFFSET)
				{
					int headItemId = headEquipId - FashionManager.ITEM_OFFSET;
					if (slot == KitType.HAIR)
					{
						return ItemInteractions.HAIR_HELMS.contains(headItemId);
					}
					return !ItemInteractions.NO_JAW_HELMS.contains(headItemId);
				}
				return fallback.get();
			case ARMS:
				int torsoEquipId = fashionManager.equipmentIdInSlot(KitType.TORSO);
				if (torsoEquipId > FashionManager.ITEM_OFFSET)
				{
					int torsoItemId = torsoEquipId - FashionManager.ITEM_OFFSET;
					return ItemInteractions.ARMS_TORSOS.contains(torsoItemId);
				}
				return fallback.get();
			default:
				return fallback.get();
		}
	}

}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class KitChangedListener extends SwapEventListener<KitChanged>
{
	public KitChangedListener(Consumer<KitChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<KitChanged> getEventClass()
	{
		return KitChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.kit.KitType;

@EqualsAndHashCode(callSuper = false)
@Value
public class LockChanged extends SwapEvent
{
	KitType slot;
	boolean isLocked;
	Type type;

	public enum Type
	{
		ITEM,
		KIT,
		BOTH
	}
}

package eq.uirs.fashionscape.core.event;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.kit.KitType;

@EqualsAndHashCode(callSuper = false)
@Value
public class KitChanged extends SwapEvent
{
	KitType slot;
	// will be null if kit removed
	Integer kitId;
}

package eq.uirs.fashionscape.core.event;

import eq.uirs.fashionscape.data.color.ColorType;
import lombok.EqualsAndHashCode;
import lombok.Value;

@EqualsAndHashCode(callSuper = false)
@Value
public class ColorChanged extends SwapEvent
{
	ColorType type;
	// will be null if color reverted
	Integer colorId;
}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class IconChangedListener extends SwapEventListener<IconChanged>
{
	public IconChangedListener(Consumer<IconChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<IconChanged> getEventClass()
	{
		return IconChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.kit.KitType;

/**
 * A `true` event means that fallback kit is used in a swap (instead of the player's known kit).
 * A `false` event means that the kit is definitively known by the plugin.
 */
@EqualsAndHashCode(callSuper = false)
@Value
public class KnownKitChanged extends SwapEvent
{
	boolean unknown;
	KitType slot;
}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public abstract class SwapEventListener<T extends SwapEvent>
{
	private final Consumer<T> consumer;

	abstract Class<T> getEventClass();

	public String getKey()
	{
		return getEventClass().getName();
	}

	// onEvent is only ever called for events of type T
	@SuppressWarnings("unchecked")
	public void onEvent(SwapEvent event)
	{
		consumer.accept((T) event);
	}
}


package eq.uirs.fashionscape.core.event;

import eq.uirs.fashionscape.data.kit.JawIcon;
import lombok.EqualsAndHashCode;
import lombok.Value;

@EqualsAndHashCode(callSuper = false)
@Value
public class IconChanged extends SwapEvent
{
	JawIcon icon;
}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class ColorChangedListener extends SwapEventListener<ColorChanged>
{
	public ColorChangedListener(Consumer<ColorChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<ColorChanged> getEventClass()
	{
		return ColorChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class ColorLockChangedListener extends SwapEventListener<ColorLockChanged>
{
	public ColorLockChangedListener(Consumer<ColorLockChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<ColorLockChanged> getEventClass()
	{
		return ColorLockChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class LockChangedListener extends SwapEventListener<LockChanged>
{
	public LockChangedListener(Consumer<LockChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<LockChanged> getEventClass()
	{
		return LockChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

public abstract class SwapEvent
{
	public String getKey()
	{
		return this.getClass().getName();
	}
}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class ItemChangedListener extends SwapEventListener<ItemChanged>
{
	public ItemChangedListener(Consumer<ItemChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<ItemChanged> getEventClass()
	{
		return ItemChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

import lombok.EqualsAndHashCode;
import lombok.Value;

@EqualsAndHashCode(callSuper = false)
@Value
public class IconLockChanged extends SwapEvent
{
	boolean isLocked;
}


package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class IconLockChangedListener extends SwapEventListener<IconLockChanged>
{
	public IconLockChangedListener(Consumer<IconLockChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<IconLockChanged> getEventClass()
	{
		return IconLockChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

import java.util.function.Consumer;

public class KnownKitChangedListener extends SwapEventListener<KnownKitChanged>
{
	public KnownKitChangedListener(Consumer<KnownKitChanged> consumer)
	{
		super(consumer);
	}

	@Override
	Class<KnownKitChanged> getEventClass()
	{
		return KnownKitChanged.class;
	}
}

package eq.uirs.fashionscape.core.event;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.kit.KitType;

@EqualsAndHashCode(callSuper = false)
@Value
public class ItemChanged extends SwapEvent
{
	KitType slot;
	// will be null if a virtual item has been removed, and -1 when item is hidden (over a real item)
	Integer itemId;
}

package eq.uirs.fashionscape.core.event;

import eq.uirs.fashionscape.data.color.ColorType;
import lombok.EqualsAndHashCode;
import lombok.Value;

@EqualsAndHashCode(callSuper = false)
@Value
public class ColorLockChanged extends SwapEvent
{
	ColorType type;
	boolean isLocked;
}

package eq.uirs.fashionscape;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FashionscapePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FashionscapePlugin.class);
		RuneLite.main(args);
	}
}

