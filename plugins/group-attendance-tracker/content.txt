package com.GroupAttendanceTracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;

@ConfigGroup("GroupAttendanceTracker")
public interface GroupAttendanceTrackerConfig extends Config
{
    @ConfigItem(
            keyName = "showOverlay",
            name = "Show Overlay",
            description = "Show the on-screen attendance overlay box"
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
            keyName = "trackingEnabled",
            name = "Tracking enabled",
            description = "If disabled, attendance timers will not update"
    )
    default boolean trackingEnabled()
    {
        return true;
    }

    @ConfigItem(
            keyName = "ClanChat",
            name = "Track Clan Chat",
            description = "Allow members of Clan chat to be tracked"
    )
    default boolean ClanChat()
    {
        return true;
    }

    @ConfigItem(
            keyName = "FriendsChat",
            name = "Track Friends Chat",
            description = "Allow members of Friends chat to be tracked"
    )
    default boolean FriendsChat()
    {
        return true;
    }


    @ConfigItem(
            keyName = "PublicChat",
            name = "Track All Players",
            description = "Allow All visible players to be tracked"
    )
    default boolean PublicChat()
    {
        return true;
    }

    @Range(min = 1, max = 50)
    @ConfigItem(
            keyName = "maxPlayers",
            name = "Max players in overlay",
            description = "Maximum number of players to show in the overlay list"
    )
    default int maxPlayers()
    {
        return 25;
    }

    @ConfigItem(
            keyName = "showCount",
            name = "Show player count",
            description = "Show the total number of visible players in the overlay header"
    )
    default boolean showCount()
    {
        return true;
    }

    @ConfigItem(
            keyName = "sortAlphabetically",
            name = "Sort alphabetically",
            description = "Sort player names alphabetically in the overlay"
    )
    default boolean sortAlphabetically()
    {
        return true;
    }

}

package com.GroupAttendanceTracker;

import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.util.List;

@Singleton
public class GroupAttendanceTrackerOverlay extends OverlayPanel
{
    private final GroupAttendanceTrackerPlugin plugin;
    private final GroupAttendanceTrackerConfig config;

    @Inject
    private GroupAttendanceTrackerOverlay(GroupAttendanceTrackerPlugin plugin, GroupAttendanceTrackerConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);

        // ✅ allow Alt-drag & snapping
        setMovable(true);
        setSnappable(true);
        setDragTargetable(true);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        panelComponent.getChildren().clear();

        List<String> names = plugin.getVisibleNames();

        // Title
        String title = "Nearby Players";
        panelComponent.getChildren().add(
                TitleComponent.builder()
                        .text(title)
                        .color(Color.WHITE)
                        .build()
        );

        // Count
        if (config.showCount())
        {
            panelComponent.getChildren().add(
                    LineComponent.builder()
                            .left("Count:")
                            .right(Integer.toString(names.size()))
                            .leftColor(Color.LIGHT_GRAY)
                            .rightColor(Color.CYAN)
                            .build()
            );
        }

        if (names.isEmpty())
        {
            panelComponent.getChildren().add(
                    LineComponent.builder()
                            .left("No players")
                            .right("")
                            .leftColor(Color.GRAY)
                            .build()
            );
        }
        else
        {
            int index = 1;
            for (String name : names)
            {
                panelComponent.getChildren().add(
                        LineComponent.builder()
                                .left(index + ".")
                                .right(name)
                                .leftColor(Color.LIGHT_GRAY)
                                .rightColor(Color.GREEN)
                                .build()
                );
                index++;
            }
        }

        return super.render(graphics);
    }
}

package com.GroupAttendanceTracker;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.StringSelection;

@Singleton
public class GroupAttendanceTrackerPanel extends PluginPanel
{
    private static final String CONFIG_GROUP = "GroupAttendanceTracker";

    private final GroupAttendanceTrackerConfig config;
    private final ConfigManager configManager;

    private final JTextArea attendanceArea = new JTextArea();
    private final JButton startButton = new JButton("Start");
    private final JButton stopButton = new JButton("Stop");
    private final JButton resetButton = new JButton("Reset");
    private final JButton copyButton = new JButton("Copy to Clipboard");

    private final JScrollPane scrollPane;

    // Plugin reference so we can ask it to reset internal data
    private GroupAttendanceTrackerPlugin plugin;

    @Inject
    GroupAttendanceTrackerPanel(GroupAttendanceTrackerConfig config, ConfigManager configManager)
    {
        this.config = config;
        this.configManager = configManager;

        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        // Header at the top (title + subtitle only)
        add(buildHeader(), BorderLayout.NORTH);

        // Attendance list takes the rest of the panel
        attendanceArea.setEditable(false);
        attendanceArea.setLineWrap(true);
        attendanceArea.setWrapStyleWord(true);
        attendanceArea.setFont(FontManager.getRunescapeSmallFont());
        attendanceArea.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        attendanceArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        attendanceArea.setMargin(new Insets(5, 5, 5, 5));

        scrollPane = new JScrollPane(attendanceArea);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setUnitIncrement(16);
        add(scrollPane, BorderLayout.CENTER);

        // Footer with all control buttons (Copy below Start/Stop/Reset)
        add(buildFooter(), BorderLayout.SOUTH);

        // Initialise button states from config
        updateButtonStates(config.trackingEnabled());
    }

    private JPanel buildHeader()
    {
        JPanel header = new JPanel();
        header.setLayout(new BoxLayout(header, BoxLayout.Y_AXIS));
        header.setOpaque(false);
        header.setBorder(new EmptyBorder(0, 0, 4, 0));

        JLabel title = new JLabel("Group Attendance");
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setForeground(ColorScheme.BRAND_ORANGE);

        JLabel subtitle = new JLabel("Track and copy attendance for your group.");
        subtitle.setFont(FontManager.getRunescapeSmallFont());
        subtitle.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        header.add(title);
        header.add(Box.createVerticalStrut(2));
        header.add(subtitle);

        return header;
    }

    private JPanel buildFooter()
    {
        JPanel footer = new JPanel(new BorderLayout());
        footer.setOpaque(false);
        footer.setBorder(new EmptyBorder(6, 0, 0, 0));

        // We’ll stack controls vertically on the right:
        // Row 1: Start | Stop | Reset
        // Row 2: Copy
        JPanel controlsColumn = new JPanel();
        controlsColumn.setOpaque(false);
        controlsColumn.setLayout(new BoxLayout(controlsColumn, BoxLayout.Y_AXIS));

        // Row 1: Start / Stop / Reset in a horizontal row
        JPanel row1 = new JPanel();
        row1.setOpaque(false);
        row1.setLayout(new BoxLayout(row1, BoxLayout.X_AXIS));

        startButton.setFont(FontManager.getRunescapeSmallFont());
        startButton.setFocusable(false);
        startButton.addActionListener(e -> setTracking(true));

        stopButton.setFont(FontManager.getRunescapeSmallFont());
        stopButton.setFocusable(false);
        stopButton.addActionListener(e -> setTracking(false));

        resetButton.setFont(FontManager.getRunescapeSmallFont());
        resetButton.setFocusable(false);
        resetButton.addActionListener(e -> resetAttendance());

        row1.add(startButton);
        row1.add(Box.createHorizontalStrut(4));
        row1.add(stopButton);
        row1.add(Box.createHorizontalStrut(4));
        row1.add(resetButton);

        // Row 2: Copy button below
        JPanel row2 = new JPanel();
        row2.setOpaque(false);
        row2.setLayout(new BoxLayout(row2, BoxLayout.X_AXIS));

        copyButton.setFont(FontManager.getRunescapeSmallFont());
        copyButton.setFocusable(false);
        copyButton.addActionListener(e -> copyAttendanceToClipboard());

        // Add a small vertical gap then align copy to the right
        row2.add(Box.createHorizontalGlue());
        row2.add(copyButton);

        controlsColumn.add(row1);
        controlsColumn.add(Box.createVerticalStrut(4));
        controlsColumn.add(row2);

        footer.add(controlsColumn, BorderLayout.EAST);
        return footer;
    }

    private void setTracking(boolean enabled)
    {
        // Flip the config value – plugin listens via ConfigChanged
        configManager.setConfiguration(CONFIG_GROUP, "trackingEnabled", enabled);
        updateButtonStates(enabled);
    }

    private void resetAttendance()
    {
        // Ask plugin to clear its internal state
        if (plugin != null)
        {
            plugin.resetAttendance();
        }
        else
        {
            // Fallback: just clear text if plugin ref isn't set yet
            attendanceArea.setText("");
        }

        // Ensure layout updates after reset as well
        attendanceArea.invalidate();
        scrollPane.invalidate();
        revalidate();
        repaint();
    }

    private void updateButtonStates(boolean trackingEnabled)
    {
        startButton.setEnabled(!trackingEnabled);
        stopButton.setEnabled(trackingEnabled);
        // Reset and Copy always enabled
    }

    private void copyAttendanceToClipboard()
    {
        String text = attendanceArea.getText();
        if (text == null)
        {
            text = "";
        }

        StringSelection selection = new StringSelection(text);
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(selection, selection);
    }

    /**
     * Called by the plugin to update the rendered attendance text.
     * Also forces the scroll area to re-layout so its size matches the new content.
     */
    void updateAttendanceText(String text)
    {
        attendanceArea.setText(text == null ? "" : text);
        attendanceArea.setCaretPosition(0);

        // Force layout/scrollbox size refresh
        attendanceArea.invalidate();
        scrollPane.invalidate();
        revalidate();
        repaint();
    }

    // Backwards compat alias if you used this name anywhere else
    void setAttendanceText(String text)
    {
        updateAttendanceText(text);
    }

    // Called from the plugin's startUp() so the panel can invoke reset on it
    void setPlugin(GroupAttendanceTrackerPlugin plugin)
    {
        this.plugin = plugin;
    }
}

package com.GroupAttendanceTracker;

import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;


@Slf4j
@PluginDescriptor(
        name = "Group Attendance Tracker",
        description = "Track Group/Event attendance using world views",
        tags = {"clan", "attendance", "group"}
)
public class GroupAttendanceTrackerPlugin extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private GroupAttendanceTrackerConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private GroupAttendanceTrackerOverlay overlay;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private GroupAttendanceTrackerPanel panel;

    private NavigationButton navButton;

    // Names shown in the overlay (sorted/limited subset)
    @Getter
    private List<String> visibleNames = Collections.emptyList();

    // Total time present per player (ticks), for *all* filtered players
    private final Map<String, Integer> attendanceTicks = new HashMap<>();

    // For logging: last set of visible names
    private Set<String> lastLoggedSet = new HashSet<>();

    // Whether we’re currently tracking attendance
    private boolean trackingEnabled;

    // Icon for nav button
    private static final BufferedImage ICON = createListIcon();

    @Provides
    GroupAttendanceTrackerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(GroupAttendanceTrackerConfig.class);
    }

    @Override
    protected void startUp()
    {
        log.info("Group Attendance plugin started");
        visibleNames = Collections.emptyList();
        attendanceTicks.clear();
        lastLoggedSet.clear();

        trackingEnabled = config.trackingEnabled();

        if (config.showOverlay())
        {
            overlayManager.add(overlay);
        }

        // Make panel aware of this plugin (for reset button)
        panel.setPlugin(this);

        navButton = NavigationButton.builder()
                .tooltip("Group Attendance")
                .priority(5)
                .icon(ICON)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        SwingUtilities.invokeLater(() -> panel.updateAttendanceText("No attendance yet."));
    }



    @Override
    protected void shutDown()
    {
        log.info("Group Attendance plugin stopped");

        overlayManager.remove(overlay);

        if (navButton != null)
        {
            clientToolbar.removeNavigation(navButton);
            navButton = null;
        }

        visibleNames = Collections.emptyList();
        attendanceTicks.clear();
        lastLoggedSet.clear();

        // Clear panel text
        SwingUtilities.invokeLater(() -> panel.updateAttendanceText("No attendance yet."));
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN && client.getLocalPlayer() != null)
        {
            log.info("Attendance: logged in as {}", client.getLocalPlayer().getName());
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!event.getGroup().equals("GroupAttendanceTracker"))
        {
            return;
        }

        if ("showOverlay".equals(event.getKey()))
        {
            if (config.showOverlay())
            {
                overlayManager.add(overlay);
            }
            else
            {
                overlayManager.remove(overlay);
            }
        }
        else if ("trackingEnabled".equals(event.getKey()))
        {
            trackingEnabled = config.trackingEnabled();

            if (!trackingEnabled)
            {
                // Stop showing current players in the overlay when tracking stops.
                // (We do NOT clear attendanceTicks so times remain in the panel.)
                visibleNames = Collections.emptyList();
            }
        }
    }


    @Subscribe
    public void onGameTick(GameTick tick)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        // If tracking is disabled, do nothing.
        if (!trackingEnabled)
        {
            return;
        }

        final Player local = client.getLocalPlayer();
        if (local == null)
        {
            visibleNames = Collections.emptyList();
            return;
        }

        final WorldView rootView = client.getTopLevelWorldView();
        if (rootView == null)
        {
            visibleNames = Collections.emptyList();
            return;
        }

        // Collect all players from world view tree
        List<Player> allPlayers = new ArrayList<>();
        collectPlayersRecursive(rootView, allPlayers);

        // Names after filtering (clanOnly etc.), BEFORE overlay limiting
        List<String> filteredNames = new ArrayList<>();

        for (Player p : allPlayers)
        {
            if (p == null || p == local)
            {
                continue;
            }

            String name = p.getName();
            boolean isNameInFilter = false;

            // Clan-only filter (clan OR friends chat) if enabled
            if (config.ClanChat() && p.isClanMember())
            {

                    isNameInFilter = true;
            }

            // Friends Chat-only filter (OR friends chat) if enabled
            else if (config.FriendsChat() && p.isFriendsChatMember())
            {
                    isNameInFilter = true;
            }
            else if (config.PublicChat())
            {
                isNameInFilter = true;
            }

            if (name != null && !name.isEmpty() && isNameInFilter)
            {
                filteredNames.add(name);
            }
        }

        // Sort (for overlay & panel output)
        if (config.sortAlphabetically())
        {
            filteredNames.sort(String.CASE_INSENSITIVE_ORDER);
        }

        // ---- Track time present: 1 tick per game tick while they are in filteredNames ----
        Set<String> filteredSet = new HashSet<>(filteredNames);

        for (String name : filteredSet)
        {
            attendanceTicks.merge(name, 1, Integer::sum);
        }

        // IMPORTANT:
        // Do NOT remove players who are no longer in filteredSet.
        // This keeps their names and final times in the panel.
        // attendanceTicks.keySet().removeIf(n -> !filteredSet.contains(n));

        // ---- Build overlay-visible list (limited) ----
        int max = Math.max(1, config.maxPlayers());
        List<String> overlayNames;
        if (filteredNames.size() > max)
        {
            overlayNames = new ArrayList<>(filteredNames.subList(0, max));
        }
        else
        {
            overlayNames = new ArrayList<>(filteredNames);
        }

        visibleNames = Collections.unmodifiableList(overlayNames);

        // ---- Build attendance text for panel & clipboard ----
        final String attendanceText = buildAttendanceText();
        SwingUtilities.invokeLater(() -> panel.updateAttendanceText(attendanceText));
    }



    /**
     * Recursively collect players from this worldview and all child worldviews.
     */
    private void collectPlayersRecursive(WorldView worldView, List<Player> out)
    {
        for (Player p : worldView.players())
        {
            if (p != null)
            {
                out.add(p);
            }
        }

        for (WorldView child : worldView.worldViews())
        {
            collectPlayersRecursive(child, out);
        }
    }

    /**
     * Build a text block like:
     *
     *   Group attendance (3)
     *   Alice - 03:24
     *   Bob   - 01:18
     */
    private String buildAttendanceText()
    {
        if (attendanceTicks.isEmpty())
        {
            return "Group attendance (0)\nNo players currently tracked.";
        }

        List<Map.Entry<String, Integer>> entries = new ArrayList<>(attendanceTicks.entrySet());
        // Sort by longest time present desc, then name
        entries.sort(Comparator
                .comparingInt((Map.Entry<String, Integer> e) -> e.getValue()).reversed()
                .thenComparing(Map.Entry::getKey, String.CASE_INSENSITIVE_ORDER));

        StringBuilder sb = new StringBuilder();
        sb.append("Group attendance (").append(entries.size()).append(")\n");

        for (Map.Entry<String, Integer> e : entries)
        {
            String name = e.getKey();
            int ticks = e.getValue();
            String duration = formatDurationTicks(ticks);
            sb.append(name).append(" - ").append(duration).append('\n');
        }

        return sb.toString();
    }

    /**
     * Convert game ticks (~0.6s) to mm:ss.
     */
    private static String formatDurationTicks(int ticks)
    {
        long totalMillis = ticks * 600L; // 600 ms per tick
        long totalSeconds = totalMillis / 1000L;
        long minutes = totalSeconds / 60L;
        long seconds = totalSeconds % 60L;
        return String.format("%02d:%02d", minutes, seconds);
    }

    /**
     * Simple list-style icon: three rows of [■ ███].
     */
    private static BufferedImage createListIcon()
    {
        int size = 16;
        BufferedImage img = new BufferedImage(size, size, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = img.createGraphics();

        g.setColor(Color.WHITE);

        // Row 1
        g.fillRect(2, 3, 3, 3);   // bullet
        g.fillRect(7, 3, 7, 3);   // line

        // Row 2
        g.fillRect(2, 7, 3, 3);
        g.fillRect(7, 7, 7, 3);

        // Row 3
        g.fillRect(2, 11, 3, 3);
        g.fillRect(7, 11, 7, 3);

        g.dispose();
        return img;
    }

    /**
     * Snapshot for tests / external use if needed.
     */
    public Map<String, Integer> getAttendanceTicks()
    {
        return Collections.unmodifiableMap(attendanceTicks);
    }

    // Small DTO if you ever want structured access elsewhere
    public static class AttendanceRecord
    {
        private final String name;
        private final int ticks;

        public AttendanceRecord(String name, int ticks)
        {
            this.name = name;
            this.ticks = ticks;
        }

        public String getName()
        {
            return name;
        }

        public int getTicks()
        {
            return ticks;
        }
    }

    void resetAttendance()
    {
        attendanceTicks.clear();
        visibleNames = Collections.emptyList();
        lastLoggedSet.clear();

        SwingUtilities.invokeLater(() -> panel.updateAttendanceText("No attendance yet."));
    }

}

package com.GroupAttendanceTracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class Group_AttendanceTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GroupAttendanceTrackerPlugin.class);
		RuneLite.main(args);
	}
}
