package com.weaponcharges;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup(WeaponChargesPlugin.CONFIG_GROUP_NAME)
public interface WeaponChargesConfig extends Config
{
	@ConfigItem(
		keyName = "chargesTextRegularColor",
		name = "Charge Text Color",
		description = "The color to display charge count text in when charges are not low.",
		position = 0
	)
	default Color chargesTextRegularColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
		keyName = "chargesTextLowColor",
		name = "Low Charge Text Color",
		description = "The color to display charge count text in when charges are low.",
		position = 1
	)
	default Color chargesTextLowColor()
	{
		return Color.RED;
	}

	enum DisplayWhenNoDefault {
		ALWAYS,
		LOW_CHARGE,
		NEVER,
		;

		public static DisplayWhen getDisplayWhen(DisplayWhen specificDisplayWhen, DisplayWhenNoDefault defaultDisplayWhen)
		{
			if (specificDisplayWhen != DisplayWhen.USE_DEFAULT) return specificDisplayWhen;
			switch (defaultDisplayWhen) {
				case ALWAYS:
					return DisplayWhen.ALWAYS;
				case LOW_CHARGE:
					return DisplayWhen.LOW_CHARGE;
				case NEVER:
					return DisplayWhen.NEVER;
				default:
					throw new IllegalStateException("Unexpected value: " + defaultDisplayWhen);
			}
		}
	}

	@ConfigItem(
		keyName = "defaultDisplay",
		name = "Show Charges",
		description = "When weapons should show their charges, if you haven't specified anything for that weapon in \"" + WEAPON_SPECIFIC_SETTING + "\".",
		position = 2
	)
	default DisplayWhenNoDefault defaultDisplay()
	{
		return DisplayWhenNoDefault.ALWAYS;
	}

	@ConfigItem(
			keyName = "emptyNotZero",
			name = "Show \"Empty\"",
			description = "Enable to show \"Empty\" instead of \"0\" when something has no charges.",
			position = 3
	)
	default boolean emptyNotZero()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOnUncharged",
		name = "Show on uncharged items.",
		description = "When the charged item has an uncharged version that is separate, do not draw \"0\" or \"Empty\" on it.",
		position = 4
	)
	default boolean showOnUncharged()
	{
		return true;
	}

	@ConfigItem(
		keyName = WeaponChargesPlugin.DEV_MODE_CONFIG_KEY,
		name = "log data",
		description = "fills your logs with stuff, if you're collecting game messages/dialogs that have to do with weapon charges.",
		position = 5
	)
	default boolean devMode()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showOnHotkey",
		name = "Always show charge when held",
		description = "When this key is held, show charges on all tracked weapons.",
		position = 6
	)
	default Keybind showOnHotkey()
	{
		return Keybind.ALT;
	}

	enum DisplayWhen {
		USE_DEFAULT,
		ALWAYS,
		LOW_CHARGE,
		NEVER,
	}

	@ConfigSection(
		name = "Ammo saving capes",
		description = "Instructions for setting vorkath's head ammo saving status.",
		position = 7,
		closedByDefault = true
	)
	String AMMO_SAVING_CAPES_SECTION = "vorkathsHeadAmmoSavingInstructionsSection";

	@ConfigItem(
		keyName = "vorkathsHeadInstructions",
		name = "<html>" +
			   "The ranging skillcape and dizana's<br>" +
			   "quiver have variable ammo saving<br>" +
			   "changes. Shift-right-click these to<br>" +
			   "choose what ammo saving you have on<br>" +
			   "it. This setting is per account." +
		       "</html>",
		description = "",
		section = AMMO_SAVING_CAPES_SECTION,
		position = 1
	)
	default void vorkathsHeadInstructions()
	{
	}

	@ConfigItem(
		keyName = "vorkathsHeadMenuOptionDisabled",
		name = "Never show option on cape",
		description = "When enabled, the option to select ammo saving status is never shown. Normally it is shown when holding shift and right-clicking the cape.",
		section = AMMO_SAVING_CAPES_SECTION,
		position = 2
	)
	default boolean vorkathsHeadMenuOptionDisabled()
	{
		return false;
	}

	@ConfigSection(
		name = "Weapon Specific Config",
		description = "Specify display and low charge threshold values for specific weapons.",
		position = 7,
		closedByDefault = true
	)
	String WEAPON_SPECIFIC_SETTING = "weaponSpecificConfig";

	@ConfigItem(
		keyName = "hideShiftRightClickOptions",
		name = "Hide shift-right-click options",
		description = "Weapon specific settings are now available by holding shift and right-clicking the weapon. Turning this option on hides these menu entries.",
		section = WEAPON_SPECIFIC_SETTING,
		position = 2
	)
	default boolean hideShiftRightClickOptions()
	{
		return false;
	}

	enum SerpModes {
		SCALES,
		PERCENT,
		BOTH,
	}

}

package com.weaponcharges;

import com.google.inject.Inject;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import javax.annotation.Nullable;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.VarClientStr;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyListener;
import net.runelite.client.util.Text;

// Things to test: clicks and keystrokes for click here to continue in NPC, PLAYER, SPRITE, and NPC DIALOG OPTIONS
// (all 5 options!).

/**
 * need to register it to the eventbus and keymanager for it to work.
 *
 * Not working: meslayer (I'm assuming, cause I don't know what meslayer actually is), sprite (partial).
 * double sprite dialog (e.g. removing fang from swamp trident).
 */
@Slf4j
public class DialogTracker implements KeyListener
{
    private static final int COMPONENT_ID_DIALOG_PLAYER_CLICK_HERE_TO_CONTINUE = 5;
    private static final int COMPONENT_ID_DIALOG_NPC_CLICK_HERE_TO_CONTINUE = 5;
    private static final int COMPONENT_ID_DIALOG_PLAYER_NAME = 4;

    @Inject
    private Client client;

	@Inject
	private ClientThread clientThread;

	private Consumer<DialogState> dialogStateChanged;
    private BiConsumer<DialogState, String> dialogOptionSelected;

    private DialogState lastDialogState = null;

    public void setStateChangedListener(Consumer<DialogState> listener) {
        dialogStateChanged = listener;
    }

    public void setOptionSelectedListener(BiConsumer<DialogState, String> listener) {
        dialogOptionSelected = listener;
    }

    /*
    It's possible to miss a click but I've only seen then when I'm moving the mouse as fast as I possibly can.
     */
    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
		int widgetId = event.getParam1();
		int interfaceId = WidgetUtil.componentToInterface(widgetId);
        int componentId = WidgetUtil.componentToId(widgetId);
        if (widgetId == ComponentID.DIALOG_OPTION_OPTIONS) {
            Widget widget = client.getWidget(ComponentID.DIALOG_OPTION_OPTIONS);
            int dynamicChildIndex = event.getParam0();
            Widget[] dynamicChildren = widget.getDynamicChildren();
            Widget dynamicChild = dynamicChildren[dynamicChildIndex];
            if (dynamicChild == null)
            {
                log.debug("dynamic child option was null, index " + dynamicChildIndex + " total children: " + dynamicChildren.length);
                return; // not sure why this would happen.
            }
            optionSelected(lastDialogState, dynamicChild.getText());
        } else if (interfaceId == InterfaceID.DIALOG_NPC && componentId == COMPONENT_ID_DIALOG_NPC_CLICK_HERE_TO_CONTINUE) {
            optionSelected(lastDialogState, null);
        } else if (interfaceId == InterfaceID.DIALOG_PLAYER && componentId == COMPONENT_ID_DIALOG_PLAYER_CLICK_HERE_TO_CONTINUE) {
            optionSelected(lastDialogState, null);
        } else if (interfaceId == InterfaceID.DIALOG_SPRITE && componentId == 0) {
            optionSelected(lastDialogState, null);
        }
    }

    public DialogState getDialogState() {
        DialogState.DialogType type = getDialogType();

        DialogState state;
        switch (type) {
            case NPC:
            {
                Widget nameWidget = client.getWidget(ComponentID.DIALOG_NPC_NAME);
                Widget textWidget = client.getWidget(ComponentID.DIALOG_NPC_TEXT);

                String name = (nameWidget != null) ? nameWidget.getText() : null;
                String text = (textWidget != null) ? textWidget.getText() : null;

                state = DialogState.npc(name, text);
                break;
            }
            case PLAYER:
            {
                Widget nameWidget = client.getWidget(InterfaceID.DIALOG_PLAYER, COMPONENT_ID_DIALOG_PLAYER_NAME);
                Widget textWidget = client.getWidget(ComponentID.DIALOG_PLAYER_TEXT);

                String name = (nameWidget != null) ? nameWidget.getText() : null;
                String text = (textWidget != null) ? textWidget.getText() : null;

                state = DialogState.player(name, text);
                break;
            }
            case OPTIONS:
            {
                String text = null;

                Widget optionsWidget = client.getWidget(ComponentID.DIALOG_OPTION_OPTIONS);
                List<String> options = null;
                if (optionsWidget != null) {
                    options = new ArrayList<>();
                    for (Widget child : optionsWidget.getDynamicChildren()) {
                        if (child.getText() != null && !child.getText().isEmpty())
                        {
                            options.add(child.getText());
                        }
                    }
                    text = options.remove(0); // remove "Select an Option".
                }

                state = DialogState.options(text, options);
                break;
            }
            case SPRITE:
            {
                Widget textWidget = client.getWidget(ComponentID.DIALOG_SPRITE_TEXT);
                String text = (textWidget != null) ? textWidget.getText() : null;

				Widget itemWidget = client.getWidget(ComponentID.DIALOG_SPRITE_SPRITE);
				int itemId = (itemWidget != null) ? itemWidget.getItemId() : -1;

				state = DialogState.sprite(text, itemId);
                break;
            }
			case INPUT:
			{
				Widget titleWidget = client.getWidget(ComponentID.CHATBOX_TITLE);
				String title = (titleWidget != null) ? titleWidget.getText() : null;
				String input = client.getVarcStrValue(VarClientStr.INPUT_TEXT);

				state = DialogState.input(title, input);
				break;
			}
			case NO_DIALOG:
			{
				state = DialogState.noDialog();
				break;
			}
			default:
				throw new IllegalStateException("Unexpected value: " + type);
		}

		return state;
    }

    private DialogState.DialogType getDialogType()
    {
        Widget npcDialog = client.getWidget(InterfaceID.DIALOG_NPC, 0);
        if (npcDialog != null && !npcDialog.isHidden())
        {
            return DialogState.DialogType.NPC;
        }

        Widget playerDialog = client.getWidget(InterfaceID.DIALOG_PLAYER, 0);
        if (playerDialog != null && !playerDialog.isHidden())
        {
            return DialogState.DialogType.PLAYER;
        }

        Widget optionsDialog = client.getWidget(InterfaceID.DIALOG_OPTION, 0);
        if (optionsDialog != null && !optionsDialog.isHidden())
        {
            return DialogState.DialogType.OPTIONS;
        }

        Widget spriteDialog = client.getWidget(InterfaceID.DIALOG_SPRITE, 0);
        if (spriteDialog != null && !spriteDialog.isHidden())
        {
            return DialogState.DialogType.SPRITE;
        }

		Widget inputDialog = client.getWidget(ComponentID.CHATBOX_FULL_INPUT);
		if (inputDialog != null && !inputDialog.isHidden())
		{
			return DialogState.DialogType.INPUT;
		}

		return DialogState.DialogType.NO_DIALOG;
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
//        log.debug("Game tick: {}", client.getTickCount());
        optionSelected = false;

        DialogState dialogState = getDialogState();
        if (!Objects.equals(dialogState, lastDialogState)) {
            log.debug("dialog changed: {} previous: {} (game tick: {})", dialogState, lastDialogState, client.getTickCount());

            if (dialogStateChanged != null) dialogStateChanged.accept(dialogState);
        }
        lastDialogState = dialogState;
    }

	@Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (event.getScriptId() == 2153)
        {
            Widget w = client.getWidget(ComponentID.DIALOG_OPTION_OPTIONS);
            if (w != null && !w.isHidden())
            {
                for (int i = 0; i < w.getDynamicChildren().length; i++)
                {
                    Widget dynamicChild = w.getDynamicChildren()[i];
                    if ("Please wait...".equals(Text.removeTags(dynamicChild.getText()))) {
                        String option = null;
                        if (lastDialogState.type == DialogState.DialogType.OPTIONS) {
                            if (lastDialogState.options != null) {
                                if (lastDialogState.options.size() > i - 1) { // -1 because we skip "Select an Option".
                                    option = lastDialogState.options.get(i - 1); // -1 because we skip "Select an Option".
                                }
                            }
                        }
                        optionSelected(lastDialogState, option);
                    }
                }
            }
            w = client.getWidget(InterfaceID.DIALOG_NPC, COMPONENT_ID_DIALOG_NPC_CLICK_HERE_TO_CONTINUE);
            if (w != null && !w.isHidden() && "Please wait...".equals(Text.removeTags(w.getText())))
            {
                optionSelected(lastDialogState, null);
            }
            w = client.getWidget(InterfaceID.DIALOG_PLAYER, COMPONENT_ID_DIALOG_PLAYER_CLICK_HERE_TO_CONTINUE);
            if (w != null && !w.isHidden() && "Please wait...".equals(Text.removeTags(w.getText())))
            {
                optionSelected(lastDialogState, null);
            }
        } else if (event.getScriptId() == 2869) {
			Widget w = client.getWidget(InterfaceID.DIALOG_SPRITE, 0);
            if (w != null && !w.isHidden())
            {
                Widget dynamicChild = w.getDynamicChildren()[2];
                if ("Please wait...".equals(Text.removeTags(dynamicChild.getText())))
                {
                    optionSelected(lastDialogState, null);
                }
            }
        }
	}

    /**
     * To prevent multiple selections from occuring in the same game tick. Only the first one should count.
     */
    private boolean optionSelected = false;

    private void optionSelected(DialogState state, String option) {
        if (optionSelected) return;
        optionSelected = true;
        if (state.type == DialogState.DialogType.OPTIONS) {
            log.debug("option selected: \"" + option + "\" " + state);
        } else {
            log.debug("clicked here to continue: " + state);
        }
        if (dialogOptionSelected != null) dialogOptionSelected.accept(state, option);
    }

    public void reset()
    {
        lastDialogState = null;
    }

	@Override
	public void keyTyped(KeyEvent e)
	{
		// unused.
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		try
		{
			if (e.getKeyCode() == KeyEvent.VK_ENTER)
			{
				clientThread.invoke(() -> {
					String inputText = client.getVarcStrValue(VarClientStr.INPUT_TEXT);

					if (lastDialogState.type == DialogState.DialogType.INPUT)
					{
						optionSelected(lastDialogState, inputText);
					}
				});
			}
		} catch (RuntimeException ex) {
			// Exceptions thrown from here can prevent other keylisteners from receiving the key event.
			log.error("", ex);
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		// unused.
	}

	@RequiredArgsConstructor
    public static class DialogState
	{
		enum DialogType
		{
            /**
             * NO_DIALOG does NOT indicate the end of a dialog. For example you can end a dialog with an npc by doing something like checking a kharedst memoirs, without seeing the NO_DIALOG state inbetween.
             */
            NO_DIALOG,
            PLAYER,
            NPC,
            OPTIONS,
            SPRITE,
			INPUT,
        }

        @NonNull
        final DialogTracker.DialogState.DialogType type;

        // Meaningful only when type is PLAYER or NPC or INPUT.
        @Nullable
        final String name;

        @Nullable
        final String text;

		@Nullable
		final Integer spriteDialogItemId;

		// Meaningful only when type is OPTIONS
        @Nullable
        final List<String> options;

        public static DialogState sprite(String text, int itemId) {
            return new DialogState(DialogType.SPRITE, null, text, itemId, null);
        }

        public static DialogState player(String name, String text) {
            return new DialogState(DialogType.PLAYER, name, text, null, null);
        }

        public static DialogState npc(String name, String text) {
            return new DialogState(DialogType.NPC, name, text, null, null);
        }

        public static DialogState options(String text, List<String> options) {
            return new DialogState(DialogType.OPTIONS, null, text, null, options);
        }

        public static DialogState options(String text, String... options) {
            return new DialogState(DialogType.OPTIONS, null, text, null, Arrays.asList(options));
        }

		public static DialogState input(String title, String input)
		{
			return new DialogState(DialogType.INPUT, title, input, null, null);
		}

		public static DialogState noDialog() {
            return new DialogState(DialogType.NO_DIALOG, null, null, null, null);
        }

        @Override
        public boolean equals(Object o)
        {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            DialogState that = (DialogState) o;
            return type == that.type && Objects.equals(text, that.text) && Objects.equals(name, that.name) && Objects.equals(options, that.options);
        }

        @Override
        public int hashCode()
        {
            return Objects.hash(type, text, name, options);
        }

        @Override
        public String toString()
        {
            switch (type) {
                case NO_DIALOG:
                    return "DialogState{" + type +
                            "}";
                case PLAYER:
                case NPC:
                    return "DialogState{" + type +
                            ", name='" + name + "'" +
                            ", text='" + text + "'" +
                            "}";
                case SPRITE:
                    return "DialogState{" + type +
                            ", text='" + text + "'" +
							", itemId=" + spriteDialogItemId +
							"}";
                case OPTIONS:
                    return "DialogState{" + type +
                            ", text='" + text + "'" +
                            ", options=" + options +
                            "}";
				case INPUT:
					return "DialogState{" + type +
						", title='" + name + "'" +
						", input='" + text + "'" +
						"}";
				default:
					throw new IllegalStateException();
			}
        }
    }
}

package com.weaponcharges;

import static com.weaponcharges.ChargedWeapon.SERPENTINE_HELM;
import com.weaponcharges.WeaponChargesConfig.DisplayWhen;
import static com.weaponcharges.WeaponChargesConfig.DisplayWhen.LOW_CHARGE;
import static com.weaponcharges.WeaponChargesConfig.DisplayWhen.NEVER;
import static com.weaponcharges.WeaponChargesConfig.DisplayWhenNoDefault;
import com.weaponcharges.WeaponChargesConfig.SerpModes;
import static com.weaponcharges.WeaponChargesConfig.SerpModes.BOTH;
import static com.weaponcharges.WeaponChargesConfig.SerpModes.PERCENT;
import static com.weaponcharges.WeaponChargesPlugin.MAX_SCALES_BLOWPIPE;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import static java.lang.Math.round;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import javax.inject.Inject;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.components.TextComponent;

public class WeaponChargesItemOverlay extends WidgetItemOverlay
{
	private final WeaponChargesPlugin plugin;
	private final WeaponChargesConfig config;

	@Inject
	WeaponChargesItemOverlay(WeaponChargesPlugin plugin, WeaponChargesConfig config)
	{
		this.plugin = plugin;
		this.config = config;
		showOnInventory();
		showOnEquipment();
		showOnBank();
		showOnInterfaces(InterfaceID.CHAMBERS_OF_XERIC_INVENTORY);
		showOnInterfaces(InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_PRIVATE);
	}

	@FunctionalInterface interface DrawAfter {
		void drawAfter(TextComponent topText, TextComponent bottomText, ConfigManager configManager, int itemId);
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem itemWidget)
	{
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values()) {
			Integer charges;
			if (chargedWeapon.getItemIds().contains(itemId)) {
				Float c = plugin.getCharges(chargedWeapon);
				charges = c == null ? null : (int) (float) c;
			} else if (chargedWeapon.getUnchargedIds().contains(itemId)) {
				if (!config.showOnUncharged()) return;
				charges = 0;
			} else {
				continue;
			}

			graphics.setFont(FontManager.getRunescapeSmallFont());

			Rectangle bounds = itemWidget.getCanvasBounds();
			TextComponent topText = new TextComponent();
			topText.setPosition(new java.awt.Point(bounds.x, bounds.y + (itemWidget.getQuantity() > 1 ? 20 : 10)));
			topText.setText("");
			topText.setColor(config.chargesTextRegularColor());
			TextComponent bottomText = new TextComponent();
			bottomText.setPosition(new java.awt.Point(bounds.x - 1, bounds.y + 30));
			bottomText.setText("");
			bottomText.setColor(config.chargesTextRegularColor());

			if (chargedWeapon != ChargedWeapon.TOXIC_BLOWPIPE) {
				if (charges == null) {
					topText.setText("?");
				} else {
					DisplayWhen displayWhen = DisplayWhenNoDefault.getDisplayWhen(chargedWeapon.getDisplayWhen(plugin.configManager), config.defaultDisplay());
					if (displayWhen == NEVER && !plugin.isShowChargesKeyIsDown()) break;

					boolean isLowCharge = charges <= chargedWeapon.getLowCharge(plugin.configManager);
					if (!isLowCharge && displayWhen == LOW_CHARGE && !plugin.isShowChargesKeyIsDown()) break;

					if (charges == 0 && config.emptyNotZero()) {
						topText.setText("Empty");
					} else {
						if (chargedWeapon != SERPENTINE_HELM) {
							String prefix = ""; // This used to be used to show "~". Keeping in case I want this later.
							topText.setText(prefix + ((charges >= 10000) ? (charges / 1000) + "k" : charges));
						} else {
							String scalesLeftPercentDisplay = formatPercentage(charges, SERPENTINE_HELM.rechargeAmount);
							SerpModes displayStyle = plugin.getSerpHelmDisplayStyle();
							if (displayStyle == PERCENT) {
								topText.setText(scalesLeftPercentDisplay);
							} else if (displayStyle == BOTH) {
								topText.setText(charges.toString());
								bottomText.setText(scalesLeftPercentDisplay);
								if (isLowCharge) bottomText.setColor(config.chargesTextLowColor());
							}
						}
					}
					if (isLowCharge) topText.setColor(config.chargesTextLowColor());

					if (chargedWeapon.drawAfter != null) {
						chargedWeapon.drawAfter.drawAfter(topText, bottomText, plugin.configManager, itemId);
					}
				}
			}
			else
			{
				DisplayWhen displayWhen = DisplayWhenNoDefault.getDisplayWhen(ChargedWeapon.TOXIC_BLOWPIPE.getDisplayWhen(plugin.configManager), config.defaultDisplay());
				Float dartsLeft1 = plugin.getDartsLeft();
				Float scalesLeft = plugin.getScalesLeft();
				if (dartsLeft1 == null || scalesLeft == null)
				{
					topText.setText("?");
				} else {
					if (displayWhen == NEVER && !plugin.isShowChargesKeyIsDown()) return;

					boolean isLowCharge = blowpipeChargesLow(scalesLeft, dartsLeft1);
					if (!isLowCharge && displayWhen == LOW_CHARGE && !plugin.isShowChargesKeyIsDown()) return;

					String dartsString;
					if (dartsLeft1 == null) {
						dartsString = "?";
					} else {
						int dartsLeft = (int) (float) dartsLeft1;
						dartsString = dartsLeft > 9999 ? new DecimalFormat("#0").format(dartsLeft / 1000.0) + "k" : dartsLeft < 1000 ? String.valueOf(dartsLeft) :
							new DecimalFormat("#0.0").format(dartsLeft / 1000.0) + "k";
					}
					bottomText.setText(dartsString);
					int stringLength = graphics.getFontMetrics().stringWidth(dartsString);
					bottomText.setPosition(new java.awt.Point(bounds.x - 1 + 30 - stringLength, bounds.y + 30));

					WeaponChargesPlugin.DartType dartType = plugin.getDartType();
					if (dartType == null) {
						bottomText.setText("");
					} else {
						bottomText.setColor(dartType.displayColor);
					}

					if (scalesLeft == null) {
						topText.setText("??.?%");
					} else {
						String scalesLeftPercentDisplay = formatPercentage(round(scalesLeft), MAX_SCALES_BLOWPIPE);
						topText.setText(scalesLeftPercentDisplay);
						if (blowpipeChargesLow(scalesLeft, dartsLeft1)) topText.setColor(config.chargesTextLowColor());
					}
				}
			}

			topText.render(graphics);
			bottomText.render(graphics);
			return;
		}
	}

	static String formatPercentage(int numerator, int denominator)
	{
		NumberFormat df = new DecimalFormat("##0.0");
		df.setRoundingMode(RoundingMode.DOWN);
		float scalesLeftPercent = (float) numerator / denominator;
		String percentage = df.format((scalesLeftPercent * 100));
		if (percentage.equals("0.0") && numerator > 0) percentage = "0.1";
		return percentage + "%";
	}

	private boolean blowpipeChargesLow(float scalesLeft, float dartsLeft)
	{
		int lowCharges = ChargedWeapon.TOXIC_BLOWPIPE.getLowCharge(plugin.configManager);
		int scaleCharges = (int) (scalesLeft * 1.5f);
		int dartCharges = (int) (dartsLeft * 5);
		return scaleCharges <= lowCharges || dartCharges <= lowCharges;
	}

	private Color getColorForScalesLeft(float scalesLeftPercent)
	{
		return Color.getHSBColor((float) (scalesLeftPercent * 1/3f), 1f, 1f);
	}
}

package com.weaponcharges;

import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.ConfigManager;

@RequiredArgsConstructor
public class ChargesMessage
{
	@Getter
	private final Pattern pattern;
	private final matcherthing chargeLeft;

	@FunctionalInterface private interface matcherthing {
		Integer customHandler(Matcher matcher, ConfigManager configManager);
	}

	public ChargesMessage(Pattern pattern, Function<Matcher, Integer> chargeLeft2) {
		this(pattern, (matcher, configManager) -> chargeLeft2.apply(matcher));
	}

	public int getChargesLeft(Matcher matcher, ConfigManager configManager)
	{
		return chargeLeft.customHandler(matcher, configManager);
	}

	public static ChargesMessage staticChargeMessage(String s, int charges)
	{
		return new ChargesMessage(Pattern.compile(s), matcher -> charges);
	}

	public static ChargesMessage matcherGroupChargeMessage(String s, int group)
	{
		return new ChargesMessage(Pattern.compile(s), matcher -> {
			String chargeCountString = matcher.group(group);
			return parseCharges(chargeCountString);
		}
		);
	}

	private static int parseCharges(String chargeCountString)
	{
		if (chargeCountString.equals("one")) {
			return 1;
		}
		return Integer.parseInt(chargeCountString.replaceAll(",", ""));
	}

	@FunctionalInterface public interface CustomChargeMatcher {
		Integer customHandler(Matcher matcher, Integer chargeCount, ConfigManager configManager);
	}

	public static ChargesMessage matcherGroupChargeMessage(String s, int group, CustomChargeMatcher customMatcher)
	{
		return new ChargesMessage(Pattern.compile(s), (matcher, configManager) -> {
			String chargeCountString = matcher.group(group).replaceAll(",", "");
			int chargeCount = parseCharges(chargeCountString);
			return customMatcher.customHandler(matcher, chargeCount, configManager);
		}
		);
	}
}

/*
 * Copyright (c) 2018, Sir Girion <https://github.com/sirgirion>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.weaponcharges;

import com.google.inject.Provides;
import com.weaponcharges.WeaponChargesConfig.DisplayWhen;
import static com.weaponcharges.WeaponChargesConfig.DisplayWhen.ALWAYS;
import static com.weaponcharges.WeaponChargesConfig.DisplayWhen.LOW_CHARGE;
import static com.weaponcharges.WeaponChargesConfig.DisplayWhen.NEVER;
import static com.weaponcharges.WeaponChargesConfig.DisplayWhen.USE_DEFAULT;
import com.weaponcharges.WeaponChargesConfig.SerpModes;
import static com.weaponcharges.WeaponChargesConfig.SerpModes.BOTH;
import static com.weaponcharges.WeaponChargesConfig.SerpModes.PERCENT;
import static com.weaponcharges.WeaponChargesConfig.SerpModes.SCALES;
import java.awt.Color;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.HitsplatID;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.KeyCode;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Skill;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.FocusChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.StatChanged;
import net.runelite.api.kit.KitType;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

@PluginDescriptor(
	name = "Weapon Charges",
	description = "Displays ibans blast and swamp trident charges on the inventory icon or as an infobox.",
	tags = {"iban", "trident", "charge"}
)
// TODO for midrif's weak math brain: https://github.com/runelite/runelite/pull/11044/files
// could also do this for stuff like ibans, but in reverse. You can't charge those, but you might want to know how
// many runes to bring so that you don't run out of runes before charges.
@Slf4j
public class WeaponChargesPlugin extends Plugin implements KeyListener
{
	public static final String CONFIG_GROUP_NAME = "weaponCharges";
	public static final String DEV_MODE_CONFIG_KEY = "logData";
	public static final int MAX_SCALES_BLOWPIPE = 16383;
	public static final int MAX_DARTS = 16383;
	private static final int[] BLOWPIPE_ATTACK_ANIMATIONS = new int[]{5061, 10656};

	// TODO rename. This is used for when an item is used on a weapon, when a weapon is used on an item, and when "pages" is clicked.
	ChargedWeapon lastUsedOnWeapon;
	ChargedWeapon lastUnchargeClickedWeapon;

	@Inject Client client;
	@Inject private WeaponChargesItemOverlay itemOverlay;
	@Inject private ItemManager itemManager;
	@Inject private WeaponChargesConfig config;
	@Inject private ClientThread clientThread;
	@Inject private EventBus eventBus;
	@Inject private OverlayManager overlayManager;
	@Inject private KeyManager keyManager;
	@Inject private DialogTracker dialogTracker;
	@Inject private ChatboxPanelManager chatboxPanelManager;
	@Inject private ChatMessageManager chatMessageManager;

	private Devtools devtools;

	@Provides
	WeaponChargesConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(WeaponChargesConfig.class);
	}

	@Override
	protected void startUp()
	{
		overlayManager.add(itemOverlay);
		if (config.devMode()) enableDevMode();
		dialogTracker.reset();
		eventBus.register(dialogTracker);
		keyManager.registerKeyListener(dialogTracker);
		keyManager.registerKeyListener(this);
		dialogTracker.setStateChangedListener(this::dialogStateChanged);
		dialogTracker.setOptionSelectedListener(this::optionSelected);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(itemOverlay);
		disableDevMode();
		eventBus.unregister(dialogTracker);
		keyManager.unregisterKeyListener(dialogTracker);
		keyManager.unregisterKeyListener(this);
	}

	void dialogStateChanged(DialogTracker.DialogState dialogState)
	{
		if (devtools != null && config.devMode()) devtools.dialogStateChanged(dialogState);

		// TODO if you can calculate the total charges available in the inventory you could get an accurate count on the "add how many charges" dialog, because max charges - max charges addable = current charges.

		for (ChargesDialogHandler nonUniqueDialogHandler : ChargedWeapon.getNonUniqueDialogHandlers())
		{
			nonUniqueDialogHandler.handleDialog(dialogState, this);
		}

		outer_loop:
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
		{
			for (ChargesDialogHandler dialogHandler : chargedWeapon.getDialogHandlers())
			{
				if (dialogHandler.handleDialog(dialogState, this)) break outer_loop;
			}
		}
	}

//	private static final Pattern CHARGES_PATTERN = Pattern.compile("How many charges would you like to add\\? \\(0 - ([\\d,]+)\\)");
//
	void optionSelected(DialogTracker.DialogState dialogState, String optionSelected)
	{
		if (devtools != null && config.devMode()) devtools.optionSelected(dialogState, optionSelected);

		// I don't think adding a single charge by using the items on the weapon is going to be trackable if the user
		// skips the sprite dialog.

		for (ChargesDialogHandler nonUniqueDialogHandler : ChargedWeapon.getNonUniqueDialogHandlers())
		{
			nonUniqueDialogHandler.handleDialogOptionSelected(dialogState, optionSelected, this);
		}

		outer_loop:
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
		{
			for (ChargesDialogHandler dialogHandler : chargedWeapon.getDialogHandlers())
			{
				if (dialogHandler.handleDialogOptionSelected(dialogState, optionSelected, this)) break outer_loop;
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		if (configChanged.getGroup().equals(CONFIG_GROUP_NAME) && configChanged.getKey().equals(DEV_MODE_CONFIG_KEY)) {
			if (config.devMode()) {
				enableDevMode();
			} else {
				disableDevMode();
			}
		}
	}

	private void enableDevMode()
	{
		if (devtools == null) devtools = new Devtools(this);
		eventBus.register(devtools);
	}

	private int lastDegradedHitsplatTick = -1000; // 1000 is far more than 91, so the serp helm will be able to have its degrading tracked on login rather than having to wait 90 ticks.

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied e) {
		int hitType = e.getHitsplat().getHitsplatType();
		if (checkScytheHitsplats == client.getTickCount() && e.getHitsplat().isMine() && e.getHitsplat().getAmount() > 0 && scytheHitsplatsSeen <= 2) {
			// skip first hit since one charge has already been removed due to the xp drop.
			if (scytheHitsplatsSeen > 0) addCharges(ChargedWeapon.BLOOD_FURY, -1, false);
			scytheHitsplatsSeen++;
		}
		ChargedWeapon helm = getEquippedChargedWeapon(EquipmentInventorySlot.HEAD);
		if (helm == ChargedWeapon.SERPENTINE_HELM) {
			if (e.getHitsplat().isMine()) { // Caused by or dealt to the local player.
				if (client.getTickCount() - lastDegradedHitsplatTick > 90) {
					addCharges(helm, -10, false);
					lastDegradedHitsplatTick = client.getTickCount();
					if (config.devMode())
						client.addChatMessage(ChatMessageType.FRIENDSCHAT, "WeaponCharges", "Serpentine Helmet has Degraded!", "DEVMODE");
				}
			}
		}
		ChargedWeapon body = getEquippedChargedWeapon(EquipmentInventorySlot.BODY);
		ChargedWeapon legs = getEquippedChargedWeapon(EquipmentInventorySlot.LEGS);
		if (e.getActor() == client.getLocalPlayer() && hitType == HitsplatID.DAMAGE_ME) {
			if (helm == ChargedWeapon.CRYSTAL_HELM) {
				addCharges(helm, -1, false);
			}
			if (body == ChargedWeapon.CRYSTAL_BODY) {
				addCharges(body, -1, false);
			}
			if (legs == ChargedWeapon.CRYSTAL_LEGS) {
				addCharges(legs, -1, false);
			}
		}
	}

	private void disableDevMode()
	{
		if (devtools != null) eventBus.unregister(devtools);
	}

	// There are two lists to keep a list of checked weapons not just in the last tick, but in the last 2. I do this because
	// I'm paranoid that someone will somehow check an item without getting a check message, or the check message
	// does not match any regexes for some reason. This can cause the plugin to assign charges to the wrong weapon.
	private List<ChargedWeapon> lastWeaponChecked = new ArrayList<>();
	private List<ChargedWeapon> lastWeaponChecked2 = new ArrayList<>();

	// If this doesn't have -1 priority, it will run prior to the vanilla
	// runelite MES which cannot properly handle other plugins adding menu
	// entries to the menu before it adds its menu entries. This is because it
	// uses the MenuOpened event's list of menu entries which does not reflect
	// changes to the menu entries made by other plugins in their MenuOpened
	// subscribers. It can lead to the vanilla runelite MES menu options being
	// added in the wrong spot.
	@Subscribe(priority = -1)
	public void onMenuOpened(MenuOpened e)
	{
		onMenuOpened2();

		addVorkathsHeadMenuOptions();
	}

	private void addVorkathsHeadMenuOptions()
	{
		if (!client.isKeyPressed(KeyCode.KC_SHIFT) || config.vorkathsHeadMenuOptionDisabled()) {
			return;
		}

		for (MenuEntry menuEntry : client.getMenuEntries())
		{
			int itemId;
			if (WidgetUtil.componentToInterface(menuEntry.getParam1()) == InterfaceID.EQUIPMENT) { // item is equipped.
				int childId = WidgetUtil.componentToId(menuEntry.getParam1());
				if (childId == 16) // cape slot.
				{
					ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
					if (itemContainer == null) return;

					Item item = itemContainer.getItem(EquipmentInventorySlot.CAPE.getSlotIdx());
					if (item == null) return;

					itemId = item.getId();
				} else {
					return;
				}
			} else if (menuEntry.getItemId() != -1) {
				itemId = menuEntry.getItemId();
			} else {
				continue;
			}

			if (
				itemId == ItemID.RANGING_CAPE ||
				itemId == ItemID.RANGING_CAPET ||
				itemId == ItemID.MAX_CAPE
			) {
				boolean vorkathsHeadUsed = Boolean.valueOf(configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "vorkathsHeadUsed"));
				Menu submenu = createSubmenu();
				addSubmenu(ColorUtil.wrapWithColorTag("Vorkath's head ammo saving", Color.decode("#ff9040")),
					submenu);
				addSubmenuRadioButtonStyle(vorkathsHeadUsed, ColorUtil.wrapWithColorTag("80%", Color.decode("#49afd6")),
					e -> configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "vorkathsHeadUsed", true),
					submenu);
				addSubmenuRadioButtonStyle(!vorkathsHeadUsed, ColorUtil.wrapWithColorTag("72%", Color.decode("#5e855a")),
					e -> configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "vorkathsHeadUsed", false),
					submenu);
				break;
			} else if (
				itemId == ItemID.DIZANAS_MAX_CAPE ||
				itemId == ItemID.DIZANAS_MAX_CAPE_L ||
				itemId == ItemID.DIZANAS_QUIVER ||
				itemId == ItemID.DIZANAS_QUIVER_L ||
				itemId == ItemID.BLESSED_DIZANAS_QUIVER ||
				itemId == ItemID.BLESSED_DIZANAS_QUIVER_L ||
				itemId == ItemID.DIZANAS_QUIVER_UNCHARGED ||
				itemId == ItemID.DIZANAS_QUIVER_UNCHARGED_L
			) {
				String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "dizanasQuiverAmmoSaving");
				int dizanasQuiverAmmoSaving = configString == null ? 0 : Integer.parseInt(configString);
				Menu submenu = createSubmenu();
				addSubmenu(ColorUtil.wrapWithColorTag("Dizana's quiver ammo saving", Color.decode("#ff9040")),
					submenu);
				addSubmenuRadioButtonStyle(dizanasQuiverAmmoSaving == 0, ColorUtil.wrapWithColorTag("80%", Color.decode("#49afd6")),
					e -> configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "dizanasQuiverAmmoSaving", 0),
					submenu);
				addSubmenuRadioButtonStyle(dizanasQuiverAmmoSaving == 1, ColorUtil.wrapWithColorTag("72%", Color.decode("#5e855a")),
					e -> configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "dizanasQuiverAmmoSaving", 1),
					submenu);
				addSubmenuRadioButtonStyle(dizanasQuiverAmmoSaving == 2, ColorUtil.wrapWithColorTag("60%", Color.decode("#3d5885")),
					e -> configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "dizanasQuiverAmmoSaving", 2),
					submenu);
				break;
			}
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
	    if (event.getMenuOption().equalsIgnoreCase("check")) {
	    	// TODO investigate shift-click.
			if (config.devMode()) log.info("clicked \"check\" on " + event.getMenuTarget());

			if (WidgetUtil.componentToInterface(event.getParam1()) == InterfaceID.EQUIPMENT) { // item is equipped.
				int childId = WidgetUtil.componentToId(event.getParam1());
				if (childId == 18) {
					ChargedWeapon chargedWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.WEAPON);
					if (chargedWeapon != null) lastWeaponChecked.add(chargedWeapon);
				} else if (childId == 20) {
					ChargedWeapon chargedWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.SHIELD);
					if (chargedWeapon != null) lastWeaponChecked.add(chargedWeapon);
				}
			} else {
				for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
				{
					if (chargedWeapon.getItemIds().contains(event.getItemId()) && chargedWeapon.getCheckChargesRegexes().isEmpty())
					{
						if (config.devMode()) log.info("adding last weapon checked to " + chargedWeapon);
						lastWeaponChecked.add(chargedWeapon);
						break;
					}
				}
			}
		} else if (event.getMenuOption().equalsIgnoreCase("uncharge")) {
			for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
			{
				if (chargedWeapon.getItemIds().contains(event.getItemId()))
				{
					if (config.devMode()) log.info("setting lastUnchargeClickedWeapon to " + chargedWeapon);
					lastUnchargeClickedWeapon = chargedWeapon;
					break;
				}
			}
		} else if (event.getMenuOption().equalsIgnoreCase("unload") && event.getItemId() == ItemID.TOXIC_BLOWPIPE) {
			checkBlowpipeUnload = client.getTickCount();
		} else if (event.getMenuOption().equalsIgnoreCase("pages")) {
			if (WidgetUtil.componentToInterface(event.getParam1()) == InterfaceID.EQUIPMENT) { // item is equipped.
				lastUsedOnWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.SHIELD);
			} else {
				lastUsedOnWeapon = ChargedWeapon.getChargedWeaponFromId(event.getItemId());
			}
			if (config.devMode()) log.info("pages checked. setting last used weapon to {}", lastUsedOnWeapon.toString());
		}

		if (event.getMenuAction() == MenuAction.WIDGET_TARGET_ON_WIDGET) {
			ItemContainer itemContainer = client.getItemContainer(InventoryID.INVENTORY);
			Item itemUsed = itemContainer.getItem(client.getSelectedWidget().getIndex());
			if (itemUsed == null) return;
			int itemUsedId = itemUsed.getId();
			Item itemUsedOn = itemContainer.getItem(event.getWidget().getIndex());
			if (itemUsedOn == null) return;
			int itemUsedOnId = itemUsedOn.getId();
			lastUsedOnWeapon = ChargedWeapon.getChargedWeaponFromId(itemUsedId);
			if (lastUsedOnWeapon == null)
			{
				lastUsedOnWeapon = ChargedWeapon.getChargedWeaponFromId(itemUsedOnId);
				if (lastUsedOnWeapon != null)
				{
					if (config.devMode()) log.info("{}: used {} on {}", client.getTickCount(), itemUsedId, lastUsedOnWeapon);
					checkSingleCrystalShardUse(itemUsed, itemUsedId);
				} else {
					if (config.devMode()) log.info("{}: used {} on {}", client.getTickCount(), itemUsedId, itemUsedOnId);
				}
			} else {
				if (config.devMode()) log.info("{}: used {} on {}", client.getTickCount(), lastUsedOnWeapon, itemUsedOnId);
				checkSingleCrystalShardUse(itemUsedOn, itemUsedOnId);
			}
		}
	}

	private void checkSingleCrystalShardUse(Item itemUsed, int itemUsedId)
	{
		if (itemUsedId == ItemID.CRYSTAL_SHARD && itemUsed.getQuantity() == 1 && ChargedWeapon.CRYSTAL_SHARD_RECHARGABLE_ITEMS.contains(lastUsedOnWeapon)) {
			checkSingleCrystalShardUse = client.getTickCount();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged itemContainerChanged) {
		if (itemContainerChanged.getContainerId() != InventoryID.INVENTORY.getId()) {
			return;
		}

		if (checkBlowpipeUnload == client.getTickCount() || checkBlowpipeUnload + 1 == client.getTickCount()) {
			setDartsLeft(0);
			setDartType(DartType.UNKNOWN);
		}

		if (checkSingleCrystalShardUse == client.getTickCount() || checkSingleCrystalShardUse + 1 == client.getTickCount()) {
			addCharges(lastUsedOnWeapon, 100, false);
		}
	}

	private final List<Runnable> delayChargeUpdateUntilAfterAnimations = new ArrayList<>();

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String message = Text.removeTags(event.getMessage());

		for (ChargesMessage checkMessage : ChargedWeapon.getNonUniqueCheckChargesRegexes())
		{
			Matcher matcher = checkMessage.getPattern().matcher(message);
			if (matcher.find()) {
				ChargedWeapon chargedWeapon = removeLastWeaponChecked();
				// TODO possible to mess stuff up by checking a weapon immediately after the tome of water/fire dialog?
				if (chargedWeapon != null) {
					setCharges(chargedWeapon, checkMessage.getChargesLeft(matcher, configManager));
				} else if (lastUsedOnWeapon != null) {
					setCharges(lastUsedOnWeapon, checkMessage.getChargesLeft(matcher, configManager));
					if (config.devMode()) log.info("applying charges to last used-on weapon: {}", lastUsedOnWeapon);
				} else {
					log.warn("saw check message without having seen a charged weapon checked or used: \"" + message + "\"" );
				}
				break;
			}
		}

		for (ChargesMessage checkMessage : ChargedWeapon.getNonUniqueUpdateMessageChargesRegexes())
		{
			Matcher matcher = checkMessage.getPattern().matcher(message);
			if (matcher.find()) {
				int chargeCount = checkMessage.getChargesLeft(matcher, configManager);
				delayChargeUpdateUntilAfterAnimations.add(() -> {
					ChargedWeapon equippedWeapon = getEquippedChargedWeapon(EquipmentInventorySlot.WEAPON);
					if (equippedWeapon != null) {
						setCharges(equippedWeapon, chargeCount);
					} else {
						log.warn("saw charge update message without a weapon being equipped: \"" + message + "\"");
					}
				});
				break;
			}
		}

		outer_loop:
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
		{
			if (chargedWeapon.getCheckChargesRegexes().isEmpty()) continue;

			for (ChargesMessage checkMessage : chargedWeapon.getCheckChargesRegexes())
			{
				Matcher matcher = checkMessage.getPattern().matcher(message);
				if (matcher.find()) {
					setCharges(chargedWeapon, checkMessage.getChargesLeft(matcher, configManager));
					break outer_loop;
				}
			}

			for (ChargesMessage checkMessage : chargedWeapon.getUpdateMessageChargesRegexes())
			{
				Matcher matcher = checkMessage.getPattern().matcher(message);
				if (matcher.find()) {
					delayChargeUpdateUntilAfterAnimations.add(() -> setCharges(chargedWeapon, checkMessage.getChargesLeft(matcher, configManager)));
					break outer_loop;
				}
			}
		}

		chatMessageBlowpipe(message);
	}

	private ChargedWeapon removeLastWeaponChecked()
	{
		return !lastWeaponChecked2.isEmpty() ? lastWeaponChecked2.remove(0) :
				!lastWeaponChecked.isEmpty() ? lastWeaponChecked.remove(0) :
				null;
	}

	private ChargedWeapon getEquippedChargedWeapon(EquipmentInventorySlot slot)
	{
		ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
		if (itemContainer == null) return null;

		Item item = itemContainer.getItem(slot.getSlotIdx());
		if (item == null) return null;

		return ChargedWeapon.getChargedWeaponFromId(item.getId());
	}

	/* blowpipe:
	// checking:
	// 2021-08-29 14:22:09 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 1135: GAMEMESSAGE "Darts: <col=007f00>None</col>. Scales: <col=007f00>99 (0.6%)</col>."
	// 2021-09-05 13:55:04 [Client] INFO  com.weaponcharges.Devtools - 9: GAMEMESSAGE "Darts: <col=007f00>Adamant dart x 16,383</col>. Scales: <col=007f00>16,383 (100.0%)</col>."
	// 2021-09-05 13:55:26 [Client] INFO  com.weaponcharges.Devtools - 46: GAMEMESSAGE "Darts: <col=007f00>Adamant dart x 16,383</col>. Scales: <col=007f00>0 (0.0%)</col>."

	// adding charges either uses the check messages, or one of the following:
	// using scales on full blowpipe: 2021-09-05 13:48:26 [Client] INFO  com.weaponcharges.Devtools - 640: GAMEMESSAGE "The blowpipe can't hold any more scales."
	// using darts on full blowpipe: 2021-09-05 13:48:25 [Client] INFO  com.weaponcharges.Devtools - 638: GAMEMESSAGE "The blowpipe can't hold any more darts."

	// run out of darts: 2021-08-29 14:19:11 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 841: GAMEMESSAGE "Your blowpipe has run out of darts."
	// run out of scales: 2021-08-29 14:18:27 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 767: GAMEMESSAGE "Your blowpipe needs to be charged with Zulrah's scales."
	// run out of both: 2021-09-05 13:45:24 [Client] INFO  com.weaponcharges.Devtools - 336: GAMEMESSAGE "Your blowpipe has run out of scales and darts."

	// (attacking with no darts: 2021-09-05 13:43:43 [Client] INFO  com.weaponcharges.Devtools - 169: GAMEMESSAGE "Your blowpipe contains no darts."
	// (attacking with no darts or scales (trying to equip blowpipe without EITHER scales or darts in it produces the same message, lol) : 2021-09-05 13:45:43 [Client] INFO  com.weaponcharges.Devtools - 369: GAMEMESSAGE "Your blowpipe needs to be charged with Zulrah's scales and loaded with darts."
	// (attacking with no scales, same as run out of scales message): 2021-09-05 13:47:42 [Client] INFO  com.weaponcharges.Devtools - 566: GAMEMESSAGE "Your blowpipe needs to be charged with Zulrah's scales."

	// unload
	// unload with no darts: 2021-09-05 13:59:25 [Client] INFO  com.weaponcharges.Devtools - 443: GAMEMESSAGE "The blowpipe has no darts in it."
	// unload with darts has no chat message.

	// don't care because when you add charges after it always produces a chat message.
	// uncharge 2021-09-05 14:40:47 [Client] INFO  com.weaponcharges.Devtools - 481: dialog state changed: DialogState{DESTROY_ITEM, title='Are you sure you want to uncharge it?', itemId=12926, item_name='Toxic blowpipe', text='If you uncharge the blowpipe, all scales and darts will fall out.'}
	 */

	// check messages.
	private static final Pattern NO_DARTS_CHECK_PATTERN = Pattern.compile("Darts: None. Scales: ([\\d,]+) \\(\\d+[.]?\\d%\\).");
	private static final Pattern DARTS_AND_SCALE_CHECK_PATTERN = Pattern.compile("Darts: (\\S*)(?: dart)? x ([\\d,]+). Scales: ([\\d,]+) \\(\\d+[.]?\\d%\\).");
	private static final Pattern USE_SCALES_ON_FULL_BLOWPIPE_PATTERN = Pattern.compile("The blowpipe can't hold any more scales.");
	private static final Pattern USE_DARTS_ON_FULL_BLOWPIPE_PATTERN = Pattern.compile("The blowpipe can't hold any more darts.");
	private static final Pattern UNLOAD_EMPTY_BLOWPIPE_PATTERN = Pattern.compile("The blowpipe has no darts in it.");

	// update messages.
	private static final Pattern NO_DARTS_PATTERN = Pattern.compile("Your blowpipe has run out of darts.");
	private static final Pattern NO_SCALES_PATTERN = Pattern.compile("Your blowpipe needs to be charged with Zulrah's scales.");
	private static final Pattern NO_DARTS_OR_SCALES_PATTERN = Pattern.compile("Your blowpipe has run out of scales and darts.");
	private static final Pattern NO_DARTS_PATTERN_2 = Pattern.compile("Your blowpipe contains no darts.");
	private static final Pattern NO_DARTS_OR_SCALES_PATTERN_2 = Pattern.compile("Your blowpipe needs to be charged with Zulrah's scales and loaded with darts.");

	private void chatMessageBlowpipe(String chatMsg)
	{
		Matcher matcher = DARTS_AND_SCALE_CHECK_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			setDartsLeft(Integer.parseInt(matcher.group(2).replace(",", "")));
			setScalesLeft(Integer.parseInt(matcher.group(3).replace(",", "")));
			setDartType(DartType.getDartTypeByName(matcher.group(1)));
		}

		matcher = NO_DARTS_CHECK_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			setDartsLeft(0);
			setScalesLeft(Integer.parseInt(matcher.group(1).replace(",", "")));
			setDartType(DartType.UNKNOWN);
		}

		matcher = USE_SCALES_ON_FULL_BLOWPIPE_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			setScalesLeft(MAX_SCALES_BLOWPIPE);
		}

		matcher = USE_DARTS_ON_FULL_BLOWPIPE_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			setDartsLeft(MAX_DARTS);
		}

		matcher = UNLOAD_EMPTY_BLOWPIPE_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			setDartsLeft(0);
			setDartType(DartType.UNKNOWN);
		}

		matcher = NO_DARTS_PATTERN.matcher(chatMsg);
		if (matcher.find()) {
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}

		matcher = NO_SCALES_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> setScalesLeft(0));
		}

		matcher = NO_DARTS_OR_SCALES_PATTERN.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setScalesLeft(0);
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}

		matcher = NO_DARTS_PATTERN_2.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}

		matcher = NO_DARTS_OR_SCALES_PATTERN_2.matcher(chatMsg);
		if (matcher.find())
		{
			delayChargeUpdateUntilAfterAnimations.add(() -> {
				setScalesLeft(0);
				setDartsLeft(0);
				setDartType(DartType.UNKNOWN);
			});
		}
	}

	private int checkBlowpipeUnload = -100;
	private int checkSingleCrystalShardUse = -100;

	private int lastLocalPlayerAnimationChangedGameTick = -1;
	// I record the animation id so that animation changing plugins that change the animation (e.g. weapon animation replacer) can't interfere.
	private int lastLocalPlayerAnimationChanged = -1;
	private int lastLocalPlayerGraphicChangedGameTick = -1;
	// I record the graphic id so that graphic changing plugins that change the graphic can't interfere.
	private int lastLocalPlayerGraphicChanged = -1;

	@Subscribe(priority = 10.0f) // I want to get ahead of those pesky animation modifying plugins.
	public void onAnimationChanged(AnimationChanged event)
	{
		final Actor actor = event.getActor();
		if (actor != client.getLocalPlayer()) return;

		lastLocalPlayerAnimationChangedGameTick = client.getTickCount();
		lastLocalPlayerAnimationChanged = actor.getAnimation();
	}

	@Subscribe(priority = 10.0f)
	public void onGraphicChanged(GraphicChanged event)
	{
		final Actor actor = event.getActor();
		if (actor != client.getLocalPlayer()) return;

		lastLocalPlayerGraphicChangedGameTick = client.getTickCount();
		lastLocalPlayerGraphicChanged = actor.getGraphic();
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		bloodFuryAppliedThisTick = false;
		int tickCount = client.getTickCount();

		// This delay is necessary because equipped items are updated after onAnimationChanged, so with items that share
		// a game message it will not be possible to tell which item the message is for.
		// The order must be: check messages, animation, charge update messages.
		// Runelite's order is: onChatMessage, onAnimationChanged, onGameTick.
		// charge update messages must also be delayed due to equipment slot info not being current in onChatMessage.
		checkAnimation(lastLocalPlayerAnimationChangedGameTick == tickCount, lastLocalPlayerGraphicChangedGameTick == tickCount);

		if (Arrays.stream(BLOWPIPE_ATTACK_ANIMATIONS).anyMatch(id -> id == lastLocalPlayerAnimationChanged) && client.getLocalPlayer().getAnimationFrame() == 0) {
			consumeBlowpipeCharges();
		}

		if (!delayChargeUpdateUntilAfterAnimations.isEmpty()) {
			for (Runnable runnable : delayChargeUpdateUntilAfterAnimations)
			{
				runnable.run();
			}
			delayChargeUpdateUntilAfterAnimations.clear();
		}

		if (!lastWeaponChecked2.isEmpty()) {
			log.warn("checked weapons with no check message: " + lastWeaponChecked2);
		}
		lastWeaponChecked2.clear();
		lastWeaponChecked2 = lastWeaponChecked;
		lastWeaponChecked = new ArrayList<>();
	}

	private void checkAnimation(boolean checkAnimation, boolean checkGraphic)
	{
		if (!checkAnimation && !checkGraphic) return;

		ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
		if (itemContainer == null) return;
		Item weapon = itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		int weaponItemId = (weapon == null) ? -1 : weapon.getId();
		Item offhand = itemContainer.getItem(EquipmentInventorySlot.SHIELD.getSlotIdx());
		int offhandItemId = (offhand == null) ? -1 : offhand.getId();

		for (ChargedWeapon chargedWeapon : ChargedWeapon.values()) {
			if (chargedWeapon.getItemIds().contains(weaponItemId) || chargedWeapon.getItemIds().contains(offhandItemId)) {
				if (
					checkAnimation && chargedWeapon.animationIds.contains(lastLocalPlayerAnimationChanged) ||
					checkGraphic && chargedWeapon.graphicIds.contains(lastLocalPlayerGraphicChanged)
				) {
					addCharges(chargedWeapon, -1, false);
				}
			}
		}
	}

	public int leaguesRelic()
	{
		return client.getVarbitValue(10052);
	}

	private void consumeBlowpipeCharges()
	{
		addDartsLeft(-1 * getAmmoLossChance(), false);
		addScalesLeft(-2/3f, false);
	}

	private float getAmmoLossChance()
	{
		int attractorEquippedId = client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.CAPE);
		switch (attractorEquippedId) {
			case ItemID.AVAS_ATTRACTOR:
				return 0.4f;
			case ItemID.AVAS_ACCUMULATOR:
			case ItemID.ACCUMULATOR_MAX_CAPE:
				return 0.28f;
			case ItemID.RANGING_CAPE:
			case ItemID.RANGING_CAPET:
			case ItemID.MAX_CAPE:
				boolean vorkathsHeadUsed = Boolean.valueOf(configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "vorkathsHeadUsed"));
				return vorkathsHeadUsed ? 0.2f : 0.28f;
			case ItemID.AVAS_ASSEMBLER:
			case ItemID.AVAS_ASSEMBLER_L:
			case ItemID.ASSEMBLER_MAX_CAPE:
			case ItemID.ASSEMBLER_MAX_CAPE_L:
			case ItemID.MASORI_ASSEMBLER:
			case ItemID.MASORI_ASSEMBLER_L:
			case ItemID.MASORI_ASSEMBLER_MAX_CAPE:
			case ItemID.MASORI_ASSEMBLER_MAX_CAPE_L:
				return 0.2f;
			case ItemID.DIZANAS_MAX_CAPE:
			case ItemID.DIZANAS_MAX_CAPE_L:
			case ItemID.DIZANAS_QUIVER:
			case ItemID.DIZANAS_QUIVER_L:
			case ItemID.BLESSED_DIZANAS_QUIVER:
			case ItemID.BLESSED_DIZANAS_QUIVER_L:
			case ItemID.DIZANAS_QUIVER_UNCHARGED:
			case ItemID.DIZANAS_QUIVER_UNCHARGED_L:
				String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "dizanasQuiverAmmoSaving");
				int dizanasQuiverAmmoSaving = configString == null ? 0 : Integer.parseInt(configString);
				return dizanasQuiverAmmoSaving == 0 ? 0.2f : dizanasQuiverAmmoSaving == 1 ? 0.28f : 0.4f;
			default:
				// no ammo-saving thing equipped.
				return 1f;
		}
	}

	@Inject
	ConfigManager configManager;

	public Float getCharges(ChargedWeapon weapon) {
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, weapon.configKeyName);
		if (configString == null) return null;
		return Float.parseFloat(configString);
	}

	public void setCharges(ChargedWeapon weapon, int charges) {
		setCharges(weapon, charges, true);
	}

	public void setCharges(ChargedWeapon weapon, float charges, boolean logChange) {
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, weapon.configKeyName, Math.max(charges, 0));
		if (logChange)
		{
			log.info("set charges for " + weapon + " to " + charges + " (" + configManager.getRSProfileKey() + ")");
		}
	}

	public void addCharges(ChargedWeapon weapon, float change, boolean logChange) {
		Float charges = getCharges(weapon);
		setCharges(weapon, (charges == null ? 0f : charges) + change, logChange);
	}

	public Float getDartsLeft()
	{
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDarts");
		if (configString == null) return null;
		return Float.parseFloat(configString);
	}

	void setDartsLeft(float dartsLeft)
	{
		setDartsLeft(dartsLeft, true);
	}

	private void setDartsLeft(float dartsLeft, boolean logChange)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDarts", dartsLeft);
		if (logChange)
		{
			log.info("set darts left to " + dartsLeft + " (" + configManager.getRSProfileKey() + ")");
		}
	}

	private void addDartsLeft(float change, boolean logChange) {
		Float dartsLeft = getDartsLeft();
		setDartsLeft((dartsLeft == null ? 0 : dartsLeft) + change, logChange);
	}

	public DartType getDartType()
	{
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDartType");
		if (configString == null) return DartType.UNKNOWN;
		return DartType.valueOf(configString);
	}

	void setDartType(DartType dartType)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeDartType", dartType);
		log.info("set dart type to " + dartType + " (" + configManager.getRSProfileKey() + ")");
	}

	public Float getScalesLeft()
	{
		String configString = configManager.getRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeScales");
		if (configString == null) return null;
		return Float.parseFloat(configString);
	}

	void setScalesLeft(float scalesLeft)
	{
		setScalesLeft(scalesLeft, true);
	}

	private void setScalesLeft(float scalesLeft, boolean logChange)
	{
		configManager.setRSProfileConfiguration(CONFIG_GROUP_NAME, "blowpipeScales", scalesLeft);
		if (logChange)
		{
			log.info("set scales left to " + scalesLeft + " (" + configManager.getRSProfileKey() + ")");
		}
	}

	private void addScalesLeft(float change, boolean logChange) {
		Float scalesLeft = getScalesLeft();
		setScalesLeft((scalesLeft == null ? 0 : scalesLeft) + change, logChange);
	}

	@Getter
	private boolean showChargesKeyIsDown = false;

	@Override
	public void keyPressed(KeyEvent e)
	{
		if (config.showOnHotkey().matches(e)) {
			showChargesKeyIsDown = true;
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		if (config.showOnHotkey().matches(e)) {
			showChargesKeyIsDown = false;
		}
	}

	@Override
	public void keyTyped(KeyEvent e)
	{

	}

	@Subscribe
	public void onFocusChanged(FocusChanged focusChanged) {
		if (!focusChanged.isFocused()) {
			showChargesKeyIsDown = false;
		}
	}

	@RequiredArgsConstructor
	public enum DartType {
		UNKNOWN(-1, Color.LIGHT_GRAY, null),
		BRONZE(ItemID.BRONZE_DART, new Color(0x6e5727), "bronze"),
		IRON(ItemID.IRON_DART, new Color(0x52504c), "iron"),
		STEEL(ItemID.STEEL_DART, new Color(0x7a7873), "steel"),
		MITHRIL(ItemID.MITHRIL_DART, new Color(0x414f78), "mithril"),
		ADAMANT(ItemID.ADAMANT_DART, new Color(0x417852), "adamant"),
		RUNE(ItemID.RUNE_DART, new Color(0x67e0f5), "rune"),
		AMETHYST(ItemID.AMETHYST_DART, new Color(0xc87dd4), "amethyst"),
		DRAGON(ItemID.DRAGON_DART, new Color(0x3e7877), "dragon"),
		;

		public final int itemId;
		public final Color displayColor;
		public final String checkBlowpipeMessageName;

		public static DartType getDartTypeByName(String group)
		{
			group = group.toLowerCase();
			for (DartType dartType : DartType.values())
			{
				if (dartType.checkBlowpipeMessageName != null && dartType.checkBlowpipeMessageName.equals(group)) {
					return dartType;
				}
			}
			return null;
		}
	}

	public void onMenuOpened2()
	{
		if (!client.isKeyPressed(KeyCode.KC_SHIFT) || config.hideShiftRightClickOptions())
		{
			return;
		}

		MenuEntry[] entries = client.getMenuEntries();
		for (int i = 0; i < entries.length; i++)
		{
			MenuEntry entry = entries[i];
			Widget w = entry.getWidget();

			int itemId;
			if (w != null && WidgetUtil.componentToInterface(w.getId()) == InterfaceID.INVENTORY
				&& "Examine".equals(entry.getOption()) && entry.getIdentifier() == 10)
			{
				itemId = entry.getItemId();
			}
			else if (w != null && WidgetUtil.componentToInterface(w.getId()) == InterfaceID.EQUIPMENT
				&& "Examine".equals(entry.getOption()) && entry.getIdentifier() == 10)
			{
				w = w.getChild(1);
				if (w == null) continue;
				itemId = w.getItemId();
			}
			else
			{
				continue;
			}

			for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
			{
				if (!chargedWeapon.getItemIds().contains(itemId) && !chargedWeapon.getUnchargedIds().contains(itemId))
				{
					continue;
				}

				// I want to insert the menu entry underneath everything else (except "Cancel"), such as the runelite MES left and shift click swap options, and inventory tags, because those are more useful to people.
				Menu submenu = createSubmenu();
				/*
				Set low charge threshold (500)
				Show charge count on item
				[ ] Use default setting
				[ ] Always
				[x] Only when low
				[ ] Never
				 */
				addSubmenu("Set low charge threshold (" + chargedWeapon.getLowCharge(configManager) + ")",
					e -> openChangeLowChargeDialog(chargedWeapon, chargedWeapon.getLowCharge(configManager)),
					submenu);
				addSubmenu(ColorUtil.wrapWithColorTag("Show charge count on item", Color.decode("#ff9040")),
					submenu);
				DisplayWhen displayWhen = chargedWeapon.getDisplayWhen(configManager);
				addSubmenuRadioButtonStyle(displayWhen == USE_DEFAULT, "Use default settings",
					e -> chargedWeapon.setDisplayWhen(configManager, USE_DEFAULT),
					submenu);
				addSubmenuRadioButtonStyle(displayWhen == LOW_CHARGE, "When low",
					e -> chargedWeapon.setDisplayWhen(configManager, LOW_CHARGE),
					submenu);
				addSubmenuRadioButtonStyle(displayWhen == ALWAYS, "Always",
					e -> chargedWeapon.setDisplayWhen(configManager, ALWAYS),
					submenu);
				addSubmenuRadioButtonStyle(displayWhen == NEVER, "Never",
					e -> chargedWeapon.setDisplayWhen(configManager, NEVER),
					submenu);
				if (chargedWeapon == ChargedWeapon.SERPENTINE_HELM) {
					addSubmenu(ColorUtil.wrapWithColorTag("Display style", Color.decode("#ff9040")),
						submenu);
					SerpModes serpMode = getSerpHelmDisplayStyle();
					addSubmenuRadioButtonStyle(serpMode == PERCENT, "Percent",
						e -> setSerpHelmDisplayStyle(PERCENT),
						submenu);
					addSubmenuRadioButtonStyle(serpMode == SCALES, "Scales",
						e -> setSerpHelmDisplayStyle(SCALES),
						submenu);
					addSubmenuRadioButtonStyle(serpMode == BOTH, "Both",
						e -> setSerpHelmDisplayStyle(BOTH),
						submenu);
				}
				chargedWeapon.addMenuEntries(this, submenu);
				break;
			}
		}
	}

	private Menu createSubmenu() {
		MenuEntry submenuEntry = client.createMenuEntry(1)
			.setOption("Weapon charges plugin")
			.setType(MenuAction.RUNELITE);
		return submenuEntry.createSubMenu();
	}

	public void setSerpHelmDisplayStyle(SerpModes percent)
	{
		configManager.setConfiguration(CONFIG_GROUP_NAME, "serpentine_helm_display_style", percent);
	}

	public SerpModes getSerpHelmDisplayStyle()
	{
		String serpentine_helm_display_style = configManager.getConfiguration(CONFIG_GROUP_NAME, "serpentine_helm_display_style");
		try
		{
			return SerpModes.valueOf(serpentine_helm_display_style);
		} catch (IllegalArgumentException | NullPointerException e) {
			return PERCENT;
		}
	}

	private void openChangeLowChargeDialog(ChargedWeapon chargedWeapon, int currentLowCharge)
	{
		chatboxPanelManager.openTextInput("Set low charge threshold for " + chargedWeapon.getName() + ", (currently " + currentLowCharge + "):")
			.addCharValidator(c -> "-0123456789".indexOf(c) != -1)
			.onDone((Consumer<String>) (input) -> clientThread.invoke(() ->
			{
				int newLowChargeThreshold;
				try
				{
					newLowChargeThreshold = Integer.parseInt(input);
				} catch (NumberFormatException e) {
					final String message = new ChatMessageBuilder()
						.append(ChatColorType.HIGHLIGHT)
						.append("\"" + input + "\" is not a number.")
						.build();

					chatMessageManager.queue(
						QueuedMessage.builder()
							.type(ChatMessageType.CONSOLE)
							.runeLiteFormattedMessage(message)
							.build());
					return;
				}
				chargedWeapon.setLowCharge(configManager, newLowChargeThreshold);
			}))
			.build();
	}

	void addSubmenu(String option, Menu submenu)
	{
		addSubmenu(option, e -> {}, submenu);
	}

	void addSubmenuRadioButtonStyle(boolean selected, String option, Consumer<MenuEntry> callback, Menu submenu)
	{
		addSubmenu("(" + (selected ? "x" : "  ") + ") " + option,
			callback,
			submenu);
	}

	void addSubmenuCheckboxStyle(boolean selected, String option, Consumer<MenuEntry> callback, Menu submenu)
	{
		addSubmenu("[" + (selected ? "x" : "  ") + "] " + option,
			callback,
			submenu);
	}

	void addSubmenu(String option, Consumer<MenuEntry> callback, Menu submenu)
	{
		submenu.createMenuEntry(0)
			.setOption(option)
			.setType(MenuAction.RUNELITE)
			.onClick(callback);
	}

	private boolean bloodFuryAppliedThisTick = false;
	private final Set<Integer> MELEE_ATTACK_ANIMATIONS = Set.of(8056, 245,376,381,386,390,8288,8290,8289,9471,6118,393,0,395,400,401,406,407,414,419,422,423,428,429,440,1058,1060,1062,1378,1658,1665,1667,2066,2067,2078,2661,3297,3298,3852,4503,5865,7004,7045,7054,7055,7514,7515,7516,7638,7639,7640,7641,7642,7643,7644,7645,8145,9171,1203, 5439, 8640);
	private int checkScytheHitsplats = -1;
	private int scytheHitsplatsSeen = 0;

	@Subscribe
	public void onStatChanged(StatChanged e) {
		Skill skill = e.getSkill();
		if (
			!bloodFuryAppliedThisTick &&
			(
				skill == Skill.ATTACK ||
				skill == Skill.STRENGTH ||
				skill == Skill.DEFENCE && MELEE_ATTACK_ANIMATIONS.contains(client.getLocalPlayer().getAnimation())
			) &&
			getEquippedChargedWeapon(EquipmentInventorySlot.AMULET) == ChargedWeapon.BLOOD_FURY
		) {
			bloodFuryAppliedThisTick = true;
			if (client.getLocalPlayer().getAnimation() == 8056) {
				checkScytheHitsplats = client.getTickCount() + 1;
				scytheHitsplatsSeen = 0;
			}
			addCharges(ChargedWeapon.BLOOD_FURY, -1, false);
		}
	}

}
package com.weaponcharges;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class Devtools
{
	private final WeaponChargesPlugin plugin;

	public Devtools(WeaponChargesPlugin plugin) {
		this.plugin = plugin;
	}

	private void message(String message) {
		log.info(plugin.client.getTickCount() + ": " + message);
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() == ChatMessageType.GAMEMESSAGE || chatMessage.getType() == ChatMessageType.SPAM)
		{
			message(chatMessage.getType() + " \"" + chatMessage.getMessage() + "\"");
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged animationChanged) {
		if (animationChanged.getActor().equals(plugin.client.getLocalPlayer())) {
			message("animation changed: " + animationChanged.getActor().getAnimation());
		}
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted) {
		if ("setcharges".equals(commandExecuted.getCommand())) {
			String weapon = commandExecuted.getArguments()[0];
			String key = getKey(weapon);
			plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "setting " + key + " to " + commandExecuted.getArguments()[1], "");
			plugin.configManager.setRSProfileConfiguration(plugin.CONFIG_GROUP_NAME, key, commandExecuted.getArguments()[1]);
		} else if ("unsetcharges".equals(commandExecuted.getCommand())) {
			String weapon = commandExecuted.getArguments()[0];
			String key = getKey(weapon);
			plugin.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "unsetting " + key, "");
			plugin.configManager.unsetRSProfileConfiguration(plugin.CONFIG_GROUP_NAME, key);
		}
	}

	private String getKey(String weapon)
	{
		switch (weapon) {
			case "bpscales":
				return "blowpipeScales";
			case "bpdarts":
				return "blowpipeDarts";
			case "swamp":
				return ChargedWeapon.TRIDENT_OF_THE_SWAMP.configKeyName;
			case "seas":
				return ChargedWeapon.TRIDENT_OF_THE_SEAS.configKeyName;
			case "ibans":
				return ChargedWeapon.IBANS_STAFF.configKeyName;
			case "chally":
				return ChargedWeapon.CRYSTAL_HALBERD.configKeyName;
			case "tent":
				return ChargedWeapon.ABYSSAL_TENTACLE.configKeyName;
			case "tome":
				return ChargedWeapon.TOME_OF_FIRE.configKeyName;
			case "serp":
				return ChargedWeapon.SERPENTINE_HELM.configKeyName;
			default:
				return null;
		}
	}

	public void dialogStateChanged(DialogTracker.DialogState dialogState)
	{
		message("dialog state changed: " + dialogState);
	}

	public void optionSelected(DialogTracker.DialogState dialogState, String s)
	{
		message("option selected: \"" + s + "\" from " + dialogState);
	}
}

package com.weaponcharges;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public final class ChargesDialogHandler
{
	@FunctionalInterface
	public interface MatchHandler
	{
		void handleDialog(DialogStateMatcher.DialogStateMatchers matchers, DialogTracker.DialogState dialogState, String optionSelected, WeaponChargesPlugin plugin);
	}

	private final DialogStateMatcher dialogStateMatcher;
	private final MatchHandler matchHandler;

	public boolean handleDialog(DialogTracker.DialogState dialogState, WeaponChargesPlugin plugin)
	{
		DialogStateMatcher.DialogStateMatchers matchers = dialogStateMatcher.matchDialog(dialogState);
		boolean matched = matchers != null;
		if (matched)
		{
			matchHandler.handleDialog(matchers, dialogState, null, plugin);
		}
		return matched;
	}

	public boolean handleDialogOptionSelected(DialogTracker.DialogState dialogState, String optionSelected, WeaponChargesPlugin plugin)
	{
		DialogStateMatcher.DialogStateMatchers matchers = dialogStateMatcher.matchDialogOptionSelected(dialogState, optionSelected);
		boolean matched = matchers != null;
		if (matched)
		{
			matchHandler.handleDialog(matchers, dialogState, optionSelected, plugin);
		}
		return matched;
	}

	public static MatchHandler genericSpriteDialogChargesMessage(boolean chargesAbsolute, int group) {
		return (matchers, dialogState, optionSelected, plugin) -> {
			if (dialogState.spriteDialogItemId == null) throw new IllegalArgumentException("This handler is for sprite dialogs only.");

			String chargeCountString = matchers.getTextMatcher().group(group).replaceAll(",", "");
			int charges = Integer.parseInt(chargeCountString);
			ChargedWeapon chargedWeapon = ChargedWeapon.getChargedWeaponFromId(matchers.getSpriteDialogId());
			if (chargedWeapon != null)
			{
				if (chargesAbsolute)
				{
					plugin.setCharges(chargedWeapon, charges);
				} else {
					plugin.addCharges(chargedWeapon, charges, true);
				}
			}
		};
	}

	public static MatchHandler genericSpriteDialogUnchargeMessage()
	{
		return (matchers, dialogState, optionSelected, plugin) -> {
			if (dialogState.spriteDialogItemId == null) throw new IllegalArgumentException("This handler is for sprite dialogs only.");

			ChargedWeapon chargedWeapon = ChargedWeapon.getChargedWeaponFromId(matchers.getSpriteDialogId());
			if (chargedWeapon != null)
			{
				plugin.setCharges(chargedWeapon, 0);
			}
		};
	}

	public static MatchHandler genericSpriteDialogFullChargeMessage()
	{
		return (matchers, dialogState, optionSelected, plugin) -> {
			if (dialogState.spriteDialogItemId == null) throw new IllegalArgumentException("This handler is for sprite dialogs only.");

			ChargedWeapon chargedWeapon = ChargedWeapon.getChargedWeaponFromId(matchers.getSpriteDialogId());
			if (chargedWeapon != null)
			{
				plugin.setCharges(chargedWeapon, chargedWeapon.getRechargeAmount());
			}
		};
	}

	public static MatchHandler genericInputChargeMessage()
	{
		return genericInputChargeMessage(1);
	}

	public static MatchHandler genericInputChargeMessage(int multiplier)
	{
		return (matchers, dialogState, optionSelected, plugin) -> {
			if (plugin.lastUsedOnWeapon == null) return;

			String chargeCountString = matchers.getNameMatcher().group(1).replaceAll(",", "");
			int maxChargeCount = Integer.parseInt(chargeCountString);
			int chargesEntered;
			try
			{
				chargesEntered = Integer.parseInt(optionSelected.replaceAll("k", "000").replaceAll("m", "000000").replaceAll("b", "000000000"));
			} catch (NumberFormatException e) {
				// can happen if the input is empty for example.
				return;
			}

			if (chargesEntered > maxChargeCount) chargesEntered = maxChargeCount;

			plugin.addCharges(plugin.lastUsedOnWeapon, chargesEntered * multiplier, true);
		};
	}

	public static MatchHandler genericUnchargeDialog()
	{
		return (matchers, dialogState, optionSelected, plugin) -> {
			plugin.setCharges(plugin.lastUnchargeClickedWeapon, 0, true);
		};
	}
}

package com.weaponcharges;

import com.weaponcharges.WeaponChargesConfig.DisplayWhen;
import com.weaponcharges.WeaponChargesItemOverlay.DrawAfter;
import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.regex.Pattern;
import lombok.Getter;
import net.runelite.api.Menu;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

@Getter
public enum ChargedWeapon
{
	// many weapons are handled specially in ways not found in this file.
	/*
	 * I think my minimum reqs should be: check message >1, periodic update, animation-based reduction, charge, uncharge.
	 */
	/* template for data collection:
		check (full, <full & >1, 1, 0/empty):
			full: TODO
			>1: TODO
			1: TODO
			empty: TODO

		periodic updates (periodic, empty):
			periodic: TODO
			empty: TODO
			attacking when empty: TODO

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: TODO
			right-click options: TODO
			other: TODO

		removing (regular removal methods, dropping:
			regular: TODO
			dropping: TODO

		message overlap:
			TODO
	 */

	/* ibans
		check (full, <full & >1, 1, 0/empty):
			full: 2021-08-29 20:24:05 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 11707: GAMEMESSAGE "You have 2500 charges left on the staff."
			>1: 2021-08-29 18:56:25 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 5107: GAMEMESSAGE "You have 116 charges left on the staff."
			1: 2021-08-29 20:03:05 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9622: GAMEMESSAGE "You have a charge left on the staff." TODO unimplemented.
			empty: 2021-08-29 20:03:14 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9638: GAMEMESSAGE "You have no charges left on the staff." TODO unimplemented.

		periodic updates (periodic, empty):
			periodic: 2021-08-29 19:53:15 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 8651: GAMEMESSAGE "<col=ef1020>Your staff only has 100 charges left.</col>" TODO unimplemented.
				2021-08-29 19:57:43 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9092: GAMEMESSAGE "<col=ef1020>Your staff only has 50 charges left.</col>"
				every 100 but also at 50.
			empty: 2021-08-29 20:03:11 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9632: GAMEMESSAGE "<col=ef1020>Your staff has run out of charges.</col>" TODO unimplemented.
			attacking when empty: 2021-08-29 20:03:18 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9644: GAMEMESSAGE "You need to recharge your staff to use this spell." TODO unimplemented.

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			well: 2021-08-29 20:14:23 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 10744: dialog state changed: NpcDialogState{SPRITE, text='You hold the staff above the well and feel the power of<br>Zamorak flow through you.', itemId=12658}. not skippable. TODO unimplemented.
			using items: none
			right-click options: none
			other: none

		removing:
			regular: impossible
			dropping: no charge loss

		message overlap:
			(u) and non-(u) probably both use the same messages. TODO
	 */
	IBANS_STAFF(new ChargedWeaponBuilder()
		.chargedItemIds(1409 /*IBANS_STAFF*/, 12658 /*IBANS_STAFF_U*/)
		.graphicIds(87)
		.name("Iban's staff")
		.rechargeAmount(2500) /*120 for regular, 2500 for (u)*/ // TODO fix this for regular staff?
		.defaultLowChargeThreshold(250)
		.configKeyName("ibans_staff")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("You have ([\\d,]+) charges left on the staff.", 1),
			ChargesMessage.staticChargeMessage("You have a charge left on the staff.", 1),
			ChargesMessage.staticChargeMessage("You have no charges left on the staff.", 0)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your staff only has ([\\d,]+) charges left.</col>"), 1),
			ChargesMessage.staticChargeMessage(Text.removeTags("<col=ef1020>Your staff has run out of charges.</col>"), 0),
			ChargesMessage.staticChargeMessage("You need to recharge your staff to use this spell.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You hold the staff above the well and feel the power of Zamorak flow through you."), null),
				ChargesDialogHandler.genericSpriteDialogFullChargeMessage()
			)
		)
	),

	/* Tridents
		Tridents all work the same way, afaik (only tested swap trident and partially seas trident).

		check:
			2022-05-04 12:37:05 [Client] INFO  com.weaponcharges.Devtools - 354: GAMEMESSAGE "Your Trident of the swamp (e) has 2,000 charges."
			2022-05-04 12:38:41 [Client] INFO  com.weaponcharges.Devtools - 514: GAMEMESSAGE "Your Trident of the swamp (e) has one charge."
			2022-05-04 12:40:27 [Client] INFO  com.weaponcharges.Devtools - 691: GAMEMESSAGE "Your Trident of the seas (e) has one charge."
			2022-05-04 12:40:36 [Client] INFO  com.weaponcharges.Devtools - 706: GAMEMESSAGE "Your Trident of the seas (e) has 1,001 charges."
			2022-05-04 07:08:09 [Client] INFO  com.weaponcharges.Devtools - 12: GAMEMESSAGE "Your Trident of the swamp has 6 charges."
			2022-05-04 07:09:59 [Client] INFO  com.weaponcharges.Devtools - 196: GAMEMESSAGE "Your Trident of the seas has one charge."
			2022-05-04 07:10:55 [Client] INFO  com.weaponcharges.Devtools - 288: GAMEMESSAGE "Your Trident of the seas has 2 charges."
			2022-05-04 07:13:15 [Client] INFO  com.weaponcharges.Devtools - 521: GAMEMESSAGE "Your Trident of the seas has 100 charges."

			// These are useless because the uncharged version has a different item id anyways.
			2022-05-04 12:36:51 [Client] INFO  com.weaponcharges.Devtools - 332: GAMEMESSAGE "Your Uncharged toxic trident (e) has no charges."
			2022-05-04 12:40:13 [Client] INFO  com.weaponcharges.Devtools - 667: GAMEMESSAGE "Your Uncharged trident (e) has no charges."

		periodic updates:
			2021-08-27 23:02:13 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "<col=ef1020>Your trident only has 100 charges left!</col>"
		emptying by consuming charge:
			2021-08-27 22:59:08 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "<col=ef1020>Your trident has run out of charges.</col>"
			attacking when empty: 2021-08-29 20:04:16 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 9740: GAMEMESSAGE "The weapon has no charges left. You need death runes, chaos runes, fire runes and Zulrah's scales to charge it." TODO unimplemented.

		adding:
			dialog, only non-skippable indication of charges added is the number the player inputs.
			2021-09-02 23:29:44 [AWT-EventQueue-0] INFO  com.weaponcharges.Devtools - 13154: option selected: "123" from NpcDialogState{INPUT, title='How many charges would you like to add? (0 - 2,477)', input='123'}
			(skippable) 2021-08-28 04:00:20 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - dialog state changed: NpcDialogState{SPRITE, text='You add a charge to the weapon.<br>New total: 2016'}
			The above message does not have a comma in the second number if the weapon is at max charges (tested with swamp trident, 2500).
			if adding only one charge because only 1 charge is in your inventory, or the item is 1 charge from full, it skips the dialog and goes straight to the skippable sprite dialog.
			2021-09-02 23:39:44 [Client] INFO  com.weaponcharges.Devtools - 14154: dialog state changed: NpcDialogState{SPRITE, text='You add 123 charges to the weapon.<br>New total: 246', itemId=12899}
			2021-08-29 18:08:48 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 368: dialog state changed: NpcDialogState{SPRITE, text='Your weapon is already fully charged.'}
			2021-08-29 18:13:57 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 882: dialog state changed: NpcDialogState{SPRITE, text='You uncharge your weapon.'}

		removing:
			dialog choice. the dialog that confirms the player's choice is skippable.
			seas trident: 2021-08-29 18:48:38 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 4334: dialog state changed: NpcDialogState{OPTIONS, text='You will NOT get the coins back.', options=[Okay, uncharge it., No, don't uncharge it.]}
			seas (e): presumably the same as seas.
			swamp trident: 2023-03-10 17:14:02 [Client] INFO  com.weaponcharges.Devtools - 2786: option selected: "Okay, uncharge it." from DialogState{OPTIONS, text='Really uncharge the Trident of the swamp?', options=[Okay, uncharge it., No, don't uncharge it.]}
			swamp (e): just adds " (e)" to it, according to a screenshot I recieved.
			dropping: 2021-08-29 19:03:59 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 5862: option selected: "Drop it." from NpcDialogState{OPTIONS, text='If you drop it, it will lose all its charges.', options=[Drop it., No, don't drop it.]} TODO unimplemented
				(the charge loss happens when you select "Drop it.".

		message overlap: all 4 tridents use the same messages except for the check messages.
	 */
	TRIDENT_OF_THE_SEAS(new ChargedWeaponBuilder()
		.chargedItemIds(11907 /*TRIDENT_OF_THE_SEAS*/)
		.unchargedItemIds(11908 /*UNCHARGED_TRIDENT*/)
		.animationIds(11430)
		.name("Trident of the seas")
		.rechargeAmount(2500)
		.configKeyName("trident_of_the_seas")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the seas has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas has no charges.", 0)
		)
	),
	TRIDENT_OF_THE_SWAMP(new ChargedWeaponBuilder()
		.chargedItemIds(12899 /*TRIDENT_OF_THE_SWAMP*/)
		.unchargedItemIds(12900 /*UNCHARGED_TOXIC_TRIDENT*/)
		.animationIds(11430)
		.name("Trident of the swamp")
		.rechargeAmount(2500)
		.configKeyName("trident_of_the_swamp")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the swamp has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp has no charges.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Really uncharge the Trident of the swamp?"), null, Pattern.compile("Okay, uncharge it.")),
				ChargesDialogHandler.genericUnchargeDialog()
			)
		)
	),
	TRIDENT_OF_THE_SEAS_E(new ChargedWeaponBuilder()
		.chargedItemIds(22288 /*TRIDENT_OF_THE_SEAS_E*/)
		.unchargedItemIds(22290 /*UNCHARGED_TRIDENT_E*/)
		.animationIds(11430)
		.name("Trident of the seas (e)")
		.rechargeAmount(10_000)
		.configKeyName("trident_of_the_seas_e")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the seas \\(e\\) has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas \\(e\\) has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the seas \\(e\\) has no charges.", 0)
		)
	),
	TRIDENT_OF_THE_SWAMP_E(new ChargedWeaponBuilder()
		.chargedItemIds(22292 /*TRIDENT_OF_THE_SWAMP_E*/)
		.unchargedItemIds(22294 /*UNCHARGED_TOXIC_TRIDENT_E*/)
		.animationIds(11430)
		.name("Trident of the swamp (e)")
		.rechargeAmount(10_000)
		.configKeyName("trident_of_the_swamp_e")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Trident of the swamp \\(e\\) has ([\\d,]+) charges.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp \\(e\\) has one charge.", 1),
			ChargesMessage.staticChargeMessage("Your Trident of the swamp \\(e\\) has no charges.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Really uncharge the Trident of the swamp (e)?"), null, Pattern.compile("Okay, uncharge it.")),
				ChargesDialogHandler.genericUnchargeDialog()
			)
		)
	),
	WARPED_SCEPTRE(new ChargedWeaponBuilder()
			.chargedItemIds(28585 /*WARPED_SCEPTRE*/)
			.unchargedItemIds(28583 /*UNCHARGED_WARPED_SCEPTRE*/)
			.animationIds(10501)
			.name("Warped sceptre")
			.rechargeAmount(20_000)
			.configKeyName("warped_sceptre")
			.checkChargesRegexes(
					ChargesMessage.matcherGroupChargeMessage("Your warped sceptre has ([\\d,]+) charges remaining\\.", 1),
					ChargesMessage.staticChargeMessage("Your warped sceptre has 1 charge remaining\\.", 1),
					ChargesMessage.staticChargeMessage(Text.removeTags("<col=ff0000>Your warped sceptre has run out of charges!</col>"), 0)
			)
			.dialogHandlers(
					new ChargesDialogHandler(
							DialogStateMatcher.optionsOptionSelected(Pattern.compile("Fully uncharge your warped sceptre\\?"), null, Pattern.compile("Yes\\.")),
							ChargesDialogHandler.genericUnchargeDialog()
					),
					new ChargesDialogHandler(
							DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges do you want to add\\? \\(0 - ([\\d,]+)\\)"), null),
							ChargesDialogHandler.genericInputChargeMessage()
					),
					new ChargesDialogHandler(
							DialogStateMatcher.sprite(Pattern.compile("You add ([\\d,]+) charges? to your warped sceptre\\."), null),
							ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
					),
					new ChargesDialogHandler(
							DialogStateMatcher.sprite(Pattern.compile("You add an additional ([\\d,]+) charges to your warped sceptre\\. It now has ([\\d,]+) charges in total\\."), null),
							ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 2)
					)
			)
	),

	ABYSSAL_TENTACLE(new ChargedWeaponBuilder()
		.chargedItemIds(12006 /*ABYSSAL_TENTACLE*/, 26484 /*ABYSSAL_TENTACLE_OR*/)
		.animationIds(1658)
		.name("Abyssal tentacle")
		.rechargeAmount(10_000)
		.configKeyName("abyssal_tentacle")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your abyssal tentacle can perform ([\\d,]+) more attacks.", 1)
		)
	),
	/* chally
		checking:
			full: unknown. TODO
			>1: 2021-08-29 18:38:45 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - 3351: GAMEMESSAGE "Your crystal halberd has 278 charges remaining."
			1 charge: unknown. TODO
			0 charges: not possible, item degrades into seed.

		periodic updates:
			unknown TODO

		adding:
			using crystal shards on it. This does not have a game message. TODO unimplemented

		removing:
			attack/spec - 1 charge.
			reverting TODO unimplemented

		message overlap: none that I'm aware of.
	 */
	CRYSTAL_HALBERD(new ChargedWeaponBuilder()
		.chargedItemIds(23987 /*CRYSTAL_HALBERD*/)
		.unchargedItemIds() // TODO add proper empty halberd ID oh God help me
		.animationIds(428, 440, 1203)
		.name("Crystal halberd")
		.rechargeAmount(10_000/*TODO is this correct?*/)
		.defaultLowChargeThreshold(25)
		.configKeyName("crystal_halberd")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal halberd has ([\\d,]+) charges remaining.", 1)
		)
	),

	/* Tome of fire:
		checking:
			// cannot check empty book, there is no such menu option.
			2024-06-21 18:09:44 PDT [Client] DEBUG client-patch - Chat message type GAMEMESSAGE: Your tome has been charged with Burnt Pages. It currently holds 200 charges.
			2024-06-21 18:10:00 PDT [Client] DEBUG client-patch - Chat message type GAMEMESSAGE: Your tome has been charged with Searing Pages. It currently holds 60 charges.

		periodic updates:
			"Your Tome of Fire is now empty."

		adding:
			using pages on it, or using the "Pages" menu option and the associated dialog, auto-uses all and produces the same chat message as checking.

		removing:
			2021-08-26 16:35:43 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "You remove a page from the book. Your tome currently holds 6,839 charges."
			2021-08-26 16:35:51 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "You remove 2 pages from the book. Your tome currently holds 6,799 charges."
			2021-08-26 16:36:44 [Client] INFO  n.r.c.plugins.weaponcharges.Devtools - GAMEMESSAGE "You empty your book of pages."
			"You remove 299 pages from the book. Your tome currently holds one charge."

		message overlap:
			tome of water: 2024-06-21 18:09:58 PDT [Client] DEBUG client-patch - Chat message type GAMEMESSAGE: You empty your book of pages.
	 */
	TOME_OF_FIRE(new ChargedWeaponBuilder()
		.chargedItemIds(20714 /*TOME_OF_FIRE*/)
		.unchargedItemIds(20716 /*TOME_OF_FIRE_EMPTY*/)
		.graphicIds(99, 126, 129, 155, 1464)
		.name("Tome of fire")
		.rechargeAmount(20_000)
		.configKeyName("tome_of_fire")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("You remove [\\S]+ pages? from the book. Your tome currently holds ([\\d,]+|one) charges?.", 1),
			ChargesMessage.matcherGroupChargeMessage("Your tome has been charged with (Burnt|Searing) Pages. It currently holds ([\\d,]+|one) charges?.", 2, (matcher, chargeCount, configManager) -> {
				configManager.setRSProfileConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, "tome_of_fire_page_type", matcher.group(1).contains("Searing") ? "searing" : "burnt");
				return chargeCount;
			})
		)
		.updateMessageChargesRegexes(
			ChargesMessage.staticChargeMessage("Your Tome of Fire is now empty.", 0)
		)
		.drawAfter((topText, bottomText, configManager, itemId) -> {
			if (itemId == 20716) return; // empty.
			Boolean hidePageType = Boolean.valueOf(configManager.getRSProfileConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, "tome_of_fire_hide_page_type"));
			if (hidePageType) return;
			String tome_of_fire_page_type = configManager.getRSProfileConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, "tome_of_fire_page_type");
			if (tome_of_fire_page_type == null) return;
			boolean searing = tome_of_fire_page_type.equals("searing");
			bottomText.setText(searing ? "Sear" : "Burnt");
			bottomText.setColor(searing ? Color.ORANGE : Color.GRAY);
		})
		.configMenuEntries((plugin, submenu) -> {
			plugin.addSubmenu(ColorUtil.wrapWithColorTag("Display style", Color.decode("#ff9040")),
				submenu);
			Boolean hidePageType = Boolean.valueOf(plugin.configManager.getRSProfileConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, "tome_of_fire_hide_page_type"));
			plugin.addSubmenuCheckboxStyle(!hidePageType, "Show page type",
				e -> plugin.configManager.setRSProfileConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, "tome_of_fire_hide_page_type", !hidePageType),
				submenu);
		})
	),
	/* Tome of water:
		checking:
			"Your tome currently holds 6,839 charges."
			"Your tome currently holds one charge."

		periodic updates:
			"Your Tome of Water is now empty."

		adding:
		removing:
			same as ToF

		message overlap: definitely overlaps with the Tome of fire.
	 */
	TOME_OF_WATER(new ChargedWeaponBuilder()
		.chargedItemIds(25574 /*TOME_OF_WATER*/)
		.unchargedItemIds(25576 /*TOME_OF_WATER_EMPTY*/)
		.graphicIds(177, 102, 105, 108, 167, 170, 173, 93, 120, 135, 161, 1458)
		.name("Tome of water")
		.rechargeAmount(20_000)
		.configKeyName("tome_of_water")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("(You remove [\\S]+ pages? from the book. )?Your tome currently holds ([\\d,]+) charges.", 2),
			ChargesMessage.staticChargeMessage("(You remove [\\S]+ pages? from the book. )?Your tome currently holds one charge.", 1)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.staticChargeMessage("Your Tome of Water is now empty.", 0)
		)
	),
	/* scythe
		check (full, <full & >1, 1, 0/empty):
			full: TODO
			>1: "Your Scythe of vitur has 19,529 charges remaining."
				2022-05-02 14:40:15 [Client] INFO  com.weaponcharges.Devtools - 3388: GAMEMESSAGE "Your Sanguine scythe of vitur has 2,056 charges remaining."
			1: TODO
			empty: TODO

		periodic updates (periodic, empty):
			periodic: TODO
			empty: TODO
			attacking when empty: TODO

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: (input) "How many sets of 100 charges do you wish to apply? (Up to 173)" TODO
				receipt dialog: (sprite dialog, unknown id) "You apply 17,300 charges to your Scythe of vitur." TODO
			right-click options: TODO
			other: TODO

		removing (regular removal methods, dropping:
			regular: (sprite dialog, unknown id) "If you uncharge your scythe into the well, 17,300<br>charges will be added to the well." TODO
				receipt dialog: (sprite dialog, unknown id) "You uncharge your scythe into the well. It now<br>contains 173 sets of 100 charges." probably redundant.
			dropping: TODO

		message overlap:
			TODO
	 */
	SCYTHE_OF_VITUR(new ChargedWeaponBuilder()
		// TODO some kind of optional graphic to show when a scythe is uncharged? like a "(u)" that shows up on the item.
		.chargedItemIds(22325 /*SCYTHE_OF_VITUR*/, 25736 /*HOLY_SCYTHE_OF_VITUR*/, 25739 /*SANGUINE_SCYTHE_OF_VITUR*/)
		.unchargedItemIds(22486 /*SCYTHE_OF_VITUR_UNCHARGED*/, 25738 /*HOLY_SCYTHE_OF_VITUR_UNCHARGED*/, 25741 /*SANGUINE_SCYTHE_OF_VITUR_UNCHARGED*/)
		.animationIds(8056)
		.name("Scythe of vitur")
		.rechargeAmount(20_000)
		.configKeyName("scythe_of_vitur")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your (Sanguine s|Holy s|S)cythe of vitur has ([\\d,]+) charges remaining.", 2)
		)
		.updateMessageChargesRegexes( // TODO one of these would be really good.
			ChargesMessage.matcherGroupChargeMessage("Your scythe has ([\\d,]+) charges remaining.", 1)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many sets of 100 charges do you wish to apply\\? \\(Up to ([\\d,]+)\\)"), null),
				(matchers, dialogState, optionSelected, plugin) -> {
					String chargeCountString = matchers.getNameMatcher().group(1).replaceAll(",", "");
					int maxChargeCount = Integer.parseInt(chargeCountString);
					int chargesEntered;
					try {
						chargesEntered = Integer.parseInt(optionSelected.replaceAll("k", "000").replaceAll("m", "000000").replaceAll("b", "000000000"));
					} catch (NumberFormatException e) {
						// can happen if the input is empty for example.
						return;
					}

					if (chargesEntered > maxChargeCount) {
						chargesEntered = maxChargeCount;
					}

					plugin.addCharges(get_scythe_circumvent_illegal_self_reference(), chargesEntered * 100, true);
				}
			),
//			new ChargesDialogHandler(
//				DialogStateMatcher.sprite(Pattern.compile("You apply ([\\d,]+) charges to your (Sanguine s|Holy s|S)cythe of vitur."), null /* TODO find out what this should be */),
//				ChargesDialogHandler.genericSpriteDialogChargesMessage(false, 1)
//			),
			new ChargesDialogHandler(
				DialogStateMatcher.spriteOptionSelected(Pattern.compile("If you uncharge your scythe into the well, ([\\d,]+) charges will be added to the well."), null /* TODO find out what this should be */),
				ChargesDialogHandler.genericSpriteDialogUnchargeMessage()
			)
		)
	),
	/* blood fury
		check (full, <full & >1, 1, 0/empty):
			full: "Your Amulet of blood fury will work for 30,000 more hits."
			>1: GAMEMESSAGE "Your Amulet of blood fury will work for 9,016 more hits."

		periodic updates (periodic, empty):
			periodic: "Your Amulet of blood fury can perform 4,000 more hits." - from screenshot.

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: TODO
			right-click options: TODO
			other: TODO
			TODO overcharge warning, different text?

		How to track? either xp drop + hitsplats if it's possible to always see all of your own hitsplats, or xp drop + animation.
	 */
	BLOOD_FURY(new ChargedWeaponBuilder()
		.chargedItemIds(24780 /*ItemID.AMULET_OF_BLOOD_FURY*/)
		.name("Amulet of blood fury")
		.rechargeAmount(10_000)
		.configKeyName("amulet_of_blood_fury")
		.checkChargesRegexes(
			ChargesMessage.staticChargeMessage("You have successfully created an Amulet of blood fury.", 10_000),
			ChargesMessage.matcherGroupChargeMessage("Your Amulet of blood fury will work for ([\\d,]+) more hits.", 1)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Amulet of blood fury can perform ([\\d,]+) more hits.", 1)
		)
	),
//	BLOOD_FURY(),
	/* sang staff
		check (full, <full & >1, 1, 0/empty):
			full: GAMEMESSAGE "Your Sanguinesti staff is already fully charged."
			>1: GAMEMESSAGE "Your Sanguinesti staff has 1,000 charges remaining."
				2022-05-02 14:40:16 [Client] INFO  com.weaponcharges.Devtools - 3390: GAMEMESSAGE "Your Holy sanguinesti staff has 144 charges remaining."
			1: GAMEMESSAGE "Your Sanguinesti staff has 1 charges remaining."
			empty: no option when uncharged

		periodic updates (periodic, empty):
			periodic: GAMEMESSAGE "Your Sanguinesti staff has 200 charges remaining."
			low: "<col=ef1020>Your Sanguinesti staff only has 100 charges left!</col>"
			empty: GAMEMESSAGE "Your Sanguinesti staff has run out of charges."
			attacking when empty: GAMEMESSAGE "Your sanguinesti staff has no charges! You need to charge it with blood runes."

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items:
			right-click options:
			DialogState{INPUT, title='How many charges do you want to apply? (Up to 1,033)', input='1'}
			DialogState{SPRITE, text='You apply 1 charges to your Sanguinesti staff.', itemId=22323}
			DialogState{SPRITE, text='You apply an additional 33 charges to your Sanguinesti<br>staff. It now has 1,033 charges in total.', itemId=22323}
			other:

		removing (regular removal methods, dropping:
			regular: DialogState{OPTIONS, text='Uncharge your staff for all its charges? (regaining 3 blood runes)', options=[Proceed., Cancel.]}
				receipt: DialogState{SPRITE, text='You uncharge your Sanguinesti staff, regaining 3 blood<br>runes in the process.', itemId=22481}
			dropping: not droppable while charged

		message overlap:
			none afaik
	 */
	SANGUINESTI_STAFF(new ChargedWeaponBuilder()
		.chargedItemIds(22323 /*SANGUINESTI_STAFF*/, 25731 /*HOLY_SANGUINESTI_STAFF*/)
		.unchargedItemIds(22481 /*SANGUINESTI_STAFF_UNCHARGED*/, 25733 /*HOLY_SANGUINESTI_STAFF_UNCHARGED*/)
		.animationIds(11430)
		.name("Sanguinesti staff")
		.rechargeAmount(20_000)
		.configKeyName("sanguinesti_staff")
		.checkChargesRegexes(
			ChargesMessage.staticChargeMessage("Your (Holy s|S)anguinesti staff is already fully charged.", 20000)
			// Some check messages omitted because they are the same as update messages.
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your (Holy s|S)anguinesti staff has ([\\d,]+) charges remaining.", 2),
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your (Holy s|S)anguinesti staff only has ([\\d,]+) charges left!</col>"), 2),
			ChargesMessage.staticChargeMessage("Your (Holy s|S)anguinesti staff has run out of charges.", 0)
			// ChargesMessage.staticChargeMessage("Your sanguinesti staff has no charges! You need to charge it with blood runes.", 0) // (sic) sang is not capitalized. bug report sent to os team
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Uncharge your staff for all its charges\\? \\(regaining [\\d,]+ blood runes\\)"), null, Pattern.compile("Proceed.")),
				ChargesDialogHandler.genericUnchargeDialog()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges do you want to apply\\? \\(Up to ([\\d,]+)\\)"), null),
				ChargesDialogHandler.genericInputChargeMessage()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply ([\\d,]+) charges to your (Holy s|S)anguinesti staff."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply an additional ([\\d,]+) charges to your (Holy s|S)anguinesti staff. It now has ([\\d,]+) charges in total."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 3)
			)
		)
	),
	/* arclight
		check (full, <full & >1, 1, 0/empty):
			full: TODO
			>1: "Your arclight has 6397 charges left."
			1: TODO
			empty: TODO

		periodic updates (periodic, empty):
			periodic: TODO
			empty: TODO
			attacking when empty: TODO

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items: TODO
			right-click options: TODO
			other: TODO

		removing (regular removal methods, dropping:
			regular: TODO
			dropping: TODO

		message overlap:
			TODO
	 */
	ARCLIGHT(new ChargedWeaponBuilder()
		.chargedItemIds(19675 /*ARCLIGHT*/)
		.animationIds(386, 390)
		.name("Arclight")
		.rechargeAmount(10_000)
		.configKeyName("arclight")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your arclight has ([\\d,]+) charges left.", 1)
		)
	),
	/* Ether Weapon common
		check (full, <full & >1, 1, 0/empty):
			<weapon> is chainmace, sceptre, or bow (THIS CHECK SECTION ONLY)
			full: "Your <weapon> has 16,000 charges left powering it."
			>1: "Your <weapon> has 666 charges left powering it."
			1: "Your <weapon> has 1 charge left powering it."
			empty: "Your <weapon> has 0 charges left powering it."

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items:
				GAMEMESSAGE "You require at least 1000 revenant ether to activate this weapon."
				GAMEMESSAGE "You use 1000 ether to activate the weapon."
				GAMEMESSAGE "You add a further 16,000 revenant ether to your weapon, giving it a total of 16,000 charges."
			right-click options: n/a
			other: n/a

		periodic updates (periodic, empty):
			periodic:
				GAMEMESSAGE "Your weapon has 1,000 charges remaining."
				GAMEMESSAGE "Your weapon has 500 charges remaining."
				GAMEMESSAGE "<col=ef1020>Your weapon only has 100 charges left.</col>"
				GAMEMESSAGE "<col=ef1020>Your weapon only has 50 charges left.</col>"
			empty: GAMEMESSAGE "<col=ef1020>Your weapon has run out of revenant ether.</col>"

		removing (regular removal methods, dropping:
			uncharge: widget doesn't show in the logger
				Are you sure you want to uncharge it?
				<Weapon> Yes No
				If you uncharge this weapon, all the revenant ether will be returned to your inventory.
			dropping: no drop option while charged
	 */

	/* Craw's bow
		attacking when empty: GAMEMESSAGE "There is not enough revenant ether left powering your bow."

		message overlap:
			see Ether Weapon common
	 */
	CRAWS(new ChargedWeaponBuilder()
		.chargedItemIds(22550 /*CRAWS_BOW*/)
		.unchargedItemIds(22547 /*CRAWS_BOW_U*/)
		.animationIds(426)
		.name("Craw's bow")
		.rechargeAmount(16_000)
		.configKeyName("craws_bow")
	),
	WEBWEAVER(new ChargedWeaponBuilder()
		.chargedItemIds(27655 /*WEBWEAVER_BOW*/)
		.unchargedItemIds(27652 /*WEBWEAVER_BOW_U*/)
		.name("Webweaver bow")
		.animationIds(426, 9964)
		.rechargeAmount(16_000)
		.configKeyName("webweaver_bow")
		.settingsConfigKey("craws_bow")
	),
	/* Vigorra's chainmace
		message overlap:
			see Ether Weapon common
	 */
	VIGGORAS(new ChargedWeaponBuilder()
		.chargedItemIds(22545 /*VIGGORAS_CHAINMACE*/)
		.unchargedItemIds(22542 /*VIGGORAS_CHAINMACE_U*/)
		.animationIds(245, 9963)
		.name("Viggora's chainmace")
		.rechargeAmount(16_000)
		.configKeyName("viggoras_chainmace")
	),
	URSINE (new ChargedWeaponBuilder()
		.chargedItemIds(27660 /*URSINE_CHAINMACE*/)
		.unchargedItemIds(27657 /*URSINE_CHAINMACE_U*/)
		.name("Ursine chainmace")
		.animationIds(245, 9963)
		.rechargeAmount(16_000)
		.configKeyName("ursine_chainmace")
		.settingsConfigKey("viggoras_chainmace")
	),
	/* Thammaron's sceptre
		message overlap:
			see Ether Weapon common
	 */
	THAMMARONS(new ChargedWeaponBuilder()
		.chargedItemIds(22555 /*THAMMARONS_SCEPTRE*/, 27788 /*THAMMARONS_SCEPTRE_A*/)
		.unchargedItemIds(22552 /*THAMMARONS_SCEPTRE_U*/, 27785 /*THAMMARONS_SCEPTRE_AU*/)
		.name("Thammaron's sceptre")
		.animationIds(1167,1978,1979,1162,11430,7855,811, 9961)
		.rechargeAmount(16_000)
		.configKeyName("thammarons_sceptre")
	),
	ACCURSED(new ChargedWeaponBuilder()
		.chargedItemIds(27665 /*ACCURSED_SCEPTRE*/, 27679 /*ACCURSED_SCEPTRE_A*/)
		.unchargedItemIds(27662 /*ACCURSED_SCEPTRE_U*/, 27676 /*ACCURSED_SCEPTRE_AU*/)
		.name("Accursed sceptre")
		//1178 1179 Ancient
		//1162,1167,7855,811 Standard
		// Support for charge count for autocasting spell, manual casting non-combat spell will still not be tracked
		.animationIds(1167,1978,1979,1162,11430,7855,811, 9961)
		.rechargeAmount(16_000)
		.configKeyName("accursed_sceptre")
		.settingsConfigKey("thammarons_sceptre")
	),
	/*
	check:
2022-06-12 20:17:48 [Client] INFO  com.weaponcharges.Devtools - 939: GAMEMESSAGE "Your crystal bow has 299 charges remaining."
	update:
		there may be no message; I didn't see one at 100 charges.
	 */
	CRYSTAL_BOW(new ChargedWeaponBuilder() // crystal bow, for ctrl-f
		.chargedItemIds(23983 /*CRYSTAL_BOW*/)
		.animationIds(426)
		.name("Crystal bow")
		.configKeyName("crystal_bow")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal bow has ([\\d,]+) charges remaining.", 1)
		)
	),
	/*
	check:
2022-06-07 12:47:57 [Client] INFO  com.weaponcharges.Devtools - 76: GAMEMESSAGE "Your bow of Faerdhinen has 180 charges remaining."
	update:
2022-06-07 18:53:09 [Client] INFO  com.weaponcharges.Devtools - 3353: GAMEMESSAGE "<col=ff0000>Your bow of Faerdhinen has 100 charges remaining.</col>"
	 */
	BOW_OF_FAERDHINEN(new ChargedWeaponBuilder() // bofa bowfa, for ctrl-f :)
		.chargedItemIds(25865 /*BOW_OF_FAERDHINEN*/)
		.unchargedItemIds(25862 /*BOW_OF_FAERDHINEN_INACTIVE*/)
		.animationIds(426)
		.name("Bow of faerdhinen")
		.configKeyName("bow_of_faerdhinen")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your bow of Faerdhinen has ([\\d,]+) charges remaining.", 1)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ff0000>Your bow of Faerdhinen has ([\\d,]+) charges remaining.</col>"), 1)
		)
	),
	/*
	crystal armor
	check:
2022-06-07 12:47:59 [Client] INFO  com.weaponcharges.Devtools - 78: GAMEMESSAGE "Your crystal helm has 1,011 charges remaining."
2022-06-07 12:47:59 [Client] INFO  com.weaponcharges.Devtools - 79: GAMEMESSAGE "Your crystal body has 996 charges remaining."
2022-06-07 12:48:00 [Client] INFO  com.weaponcharges.Devtools - 81: GAMEMESSAGE "Your crystal legs has 982 charges remaining."
	 */
	CRYSTAL_HELM(new ChargedWeaponBuilder()
		.chargedItemIds(23971 /*CRYSTAL_HELM*/, 27705 /*CRYSTAL_HELM_27705*/, 27717 /*CRYSTAL_HELM_27717*/, 27729 /*CRYSTAL_HELM_27729*/, 27741 /*CRYSTAL_HELM_27741*/, 27753 /*CRYSTAL_HELM_27753*/, 27765 /*CRYSTAL_HELM_27765*/, 27777 /*CRYSTAL_HELM_27777*/)
		.unchargedItemIds(23973 /*CRYSTAL_HELM_INACTIVE*/, 27707 /*CRYSTAL_HELM_INACTIVE_27707*/, 27719 /*CRYSTAL_HELM_INACTIVE_27719*/, 27731 /*CRYSTAL_HELM_INACTIVE_27731*/, 27743 /*CRYSTAL_HELM_INACTIVE_27743*/, 27755 /*CRYSTAL_HELM_INACTIVE_27755*/, 27767 /*CRYSTAL_HELM_INACTIVE_27767*/, 27779 /*CRYSTAL_HELM_INACTIVE_27779*/)
		.name("Crystal armour")
		.configKeyName("crystal_helm")
		.settingsConfigKey("crystal_armour")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal helm has ([\\d,]+) charges remaining.", 1)
		)
	),
	CRYSTAL_BODY(new ChargedWeaponBuilder()
		.chargedItemIds(23975 /*CRYSTAL_BODY*/, 27697 /*CRYSTAL_BODY_27697*/, 27709 /*CRYSTAL_BODY_27709*/, 27721 /*CRYSTAL_BODY_27721*/, 27733 /*CRYSTAL_BODY_27733*/, 27745 /*CRYSTAL_BODY_27745*/, 27757 /*CRYSTAL_BODY_27757*/, 27769 /*CRYSTAL_BODY_27769*/)
		.unchargedItemIds(23977 /*CRYSTAL_BODY_INACTIVE*/, 27699 /*CRYSTAL_BODY_INACTIVE_27699*/, 27711 /*CRYSTAL_BODY_INACTIVE_27711*/, 27723 /*CRYSTAL_BODY_INACTIVE_27723*/, 27735 /*CRYSTAL_BODY_INACTIVE_27735*/, 27747 /*CRYSTAL_BODY_INACTIVE_27747*/, 27759 /*CRYSTAL_BODY_INACTIVE_27759*/, 27771 /*CRYSTAL_BODY_INACTIVE_27771*/)
		.name("Crystal armour")
		.configKeyName("crystal_body")
		.settingsConfigKey("crystal_armour")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal body has ([\\d,]+) charges remaining.", 1)
		)
	),
	CRYSTAL_LEGS(new ChargedWeaponBuilder()
		.chargedItemIds(23979 /*CRYSTAL_LEGS*/, 27701 /*CRYSTAL_LEGS_27701*/, 27713 /*CRYSTAL_LEGS_27713*/, 27725 /*CRYSTAL_LEGS_27725*/, 27737 /*CRYSTAL_LEGS_27737*/, 27749 /*CRYSTAL_LEGS_27749*/, 27761 /*CRYSTAL_LEGS_27761*/, 27773 /*CRYSTAL_LEGS_27773*/)
		.unchargedItemIds(23981 /*CRYSTAL_LEGS_INACTIVE*/, 27703 /*CRYSTAL_LEGS_INACTIVE_27703*/, 27715 /*CRYSTAL_LEGS_INACTIVE_27715*/, 27727 /*CRYSTAL_LEGS_INACTIVE_27727*/, 27739 /*CRYSTAL_LEGS_INACTIVE_27739*/, 27751 /*CRYSTAL_LEGS_INACTIVE_27751*/, 27763 /*CRYSTAL_LEGS_INACTIVE_27763*/, 27775 /*CRYSTAL_LEGS_INACTIVE_27775*/)
		.name("Crystal armour")
		.configKeyName("crystal_legs")
		.settingsConfigKey("crystal_armour")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your crystal legs has ([\\d,]+) charges remaining.", 1)
		)
	),
	/* Serpentine Helmet:
	degradation mechanics:
		-10 Scales when taking or dealing damage, and it has been more than 90 ticks (i.e. minimum 91) since the last time scales were removed.
		- taking or dealing damage is generally approximated by hitsplats dealt to or dealt by the player.
			- ranged attacks cause the helmet to degrade sometimes before the hitsplat it seems. This is not taken into account by this plugin.
			- splashes do not degrade it.
			- unknown how enemy ranged attacks and splashes interact with this.
		- the 90-tick timer is shared by barrows items - e.g. you could avoid all scale loss by having barrows items equipped and unequipping the serp helm at the right time.

    notes:
        Number = ([\\d,]+)
        Percent = \\(\\d+[.]?\\d%\\)

    check (full, <full & >1, 1, 0/empty):
        full: 2022-06-20 15:31:21 [Client] INFO  com.weaponcharges.Devtools - 562: GAMEMESSAGE "Scales: <col=007f00>11,000 (100.0%)</col>"
        >1: 2022-06-20 15:32:14 [Client] INFO  com.weaponcharges.Devtools - 650: GAMEMESSAGE "Scales: <col=007f00>5 (0.1%)</col>"
        1: 2022-06-20 15:33:02 [Client] INFO  com.weaponcharges.Devtools - 730: GAMEMESSAGE "Scales: <col=007f00>1 (0.1%)</col>"
        empty: None

    periodic updates (periodic, empty):
        periodic: TODO
        empty: 2022-06-20 18:19:29 [Client] INFO  com.weaponcharges.Devtools - 8380: GAMEMESSAGE "Your serpentine helm has run out of Zulrah's scales."
        attacking when empty: TODO

    adding (adding by using items on the weapon, adding via right-click option, any other methods):
        using items: 2022-06-20 15:40:12 [Client] INFO  com.weaponcharges.Devtools - 1438: GAMEMESSAGE "Scales: <col=007f00>5 (0.1%)</col>"
        right-click options: None
        other: None

    removing (regular removal methods, dropping):
        regular: None
        dropping: None

    message overlap:
        TODO
	*/
	SERPENTINE_HELM(new ChargedWeaponBuilder()
		.chargedItemIds(12931 /*SERPENTINE_HELM*/, 13197 /*TANZANITE_HELM*/, 13199 /*MAGMA_HELM*/)
		.unchargedItemIds(12929 /*SERPENTINE_HELM_UNCHARGED*/, 13196 /*TANZANITE_HELM_UNCHARGED*/, 13198 /*MAGMA_HELM_UNCHARGED*/)
		.name("Serpentine helm")
		.rechargeAmount(11_000)
		.configKeyName("serpentine_helm")
		.checkChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("^Scales: <col=007f00>([\\d,]+) (\\(\\d+[.]?\\d%\\))</col>$"), 1)
		)
		.updateMessageChargesRegexes(
			ChargesMessage.staticChargeMessage("Your serpentine helm has run out of Zulrah's scales.", 0),
			ChargesMessage.staticChargeMessage("Your tanzanite helm has run out of Zulrah's scales.", 0),
			ChargesMessage.staticChargeMessage("Your magma helm has run out of Zulrah's scales.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many scales would you like to use\\? \\(0 - ([\\d,]+)\\)"), null),
				ChargesDialogHandler.genericInputChargeMessage()
			)
		)
	),
	/* Tumeken's shadow
		https://github.com/geheur/weapon-charges/issues/14 log here.
		check (full, <full & >1, 1, 0/empty):
			full:
			>1: GAMEMESSAGE "Tumeken's shadow has 99 charges remaining."
			1:
			empty: GAMEMESSAGE "Tumeken's Shadow has no charges! You need to charge it with soul runes and chaos runes." // TODO is this one actually from checking?

		periodic updates (periodic, empty):
			periodic: GAMEMESSAGE "Tumeken's shadow has 200 charges remaining."
			low: GAMEMESSAGE "<col=e00a19>Tumeken's shadow only has 100 charges left!</col>"
			empty: GAMEMESSAGE "Tumeken's shadow has run out of charges."

			TODO check used on item id to see if he used it on an uncharged staff.

		adding (adding by using items on the weapon, adding via right-click option, any other methods):
			using items:
234589: used 566 on 27277
234590: dialog state changed: DialogState{INPUT, title='How many charges do you want to apply? (Up to 994)', input=''}
234592: option selected: "201" from DialogState{INPUT, title='How many charges do you want to apply? (Up to 994)', input=''}
234592: dialog state changed: DialogState{NO_DIALOG}
234593: dialog state changed: DialogState{SPRITE, text='You apply 201 charges to your Tumeken's shadow.', itemId=27275}
234594: option selected: "null" from DialogState{SPRITE, text='You apply 201 charges to your Tumeken's shadow.', itemId=27275}
234595: dialog state changed: DialogState{NO_DIALOG}

234643: used 566 on 27275
234643: dialog state changed: DialogState{INPUT, title='How many charges do you want to apply? (Up to 793)', input=''}
234645: dialog state changed: DialogState{INPUT, title='How many charges do you want to apply? (Up to 793)', input='301'}
234646: option selected: "301" from DialogState{INPUT, title='How many charges do you want to apply? (Up to 793)', input='301'}
234646: dialog state changed: DialogState{SPRITE, text='You apply an additional 301 charges to your<br>Tumeken's shadow. It now has 498 charges in total.', itemId=27275}
234648: dialog state changed: DialogState{NO_DIALOG}

234692: dialog state changed: DialogState{SPRITE, text='You apply 1 charges to your Tumeken's shadow.', itemId=27275}
			right-click options:
			// TODO there is a "Charge" option but I haven't seen it used.
			other:

		removing (regular removal methods, dropping:
234582: dialog state changed: DialogState{OPTIONS, text='Uncharge all the charges from your staff?', options=[Proceed., Cancel.]}
234584: option selected: "Proceed." from DialogState{OPTIONS, text='Uncharge all the charges from your staff?', options=[Proceed., Cancel.]}
234584: dialog state changed: DialogState{SPRITE, text='You uncharge your Tumeken's shadow, regaining 198<br>soul runes and 495 chaos runes in the process.', itemId=27277}
234586: option selected: "null" from DialogState{SPRITE, text='You uncharge your Tumeken's shadow, regaining 198<br>soul runes and 495 chaos runes in the process.', itemId=27277}
234586: dialog state changed: DialogState{NO_DIALOG}
	 */
	TUMEKENS_SHADOW(new ChargedWeaponBuilder()
		.chargedItemIds(27275 /*TUMEKENS_SHADOW*/)
		.unchargedItemIds(27277 /*TUMEKENS_SHADOW_UNCHARGED*/)
		.graphicIds(2125)
		.name("Tumeken's shadow")
		.rechargeAmount(20_000)
		.configKeyName("tumekens_shadow")
		.checkChargesRegexes(
			ChargesMessage.staticChargeMessage("Your Tumeken's shadow is already fully charged.", 20000) // I guessed this one.
			// Some check messages omitted because they are the same as update messages.
		)
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Tumeken's shadow has ([\\d,]+) charges remaining.", 1),
			ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=e00a19>Tumeken's shadow only has ([\\d,]+) charges left!</col>"), 1),
			ChargesMessage.staticChargeMessage("Tumeken's shadow has run out of charges.", 0)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.optionsOptionSelected(Pattern.compile("Uncharge all the charges from your staff?"), null, Pattern.compile("Proceed.")),
				ChargesDialogHandler.genericUnchargeDialog()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges do you want to apply\\? \\(Up to ([\\d,]+)\\)"), null),
				ChargesDialogHandler.genericInputChargeMessage()
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply ([\\d,]+) charges to your Tumeken's shadow."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
			),
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You apply an additional ([\\d,]+) charges to your Tumeken's shadow. It now has ([\\d,]+) charges in total."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 2)
			)
		)
	),
	/**
	 * Only used to access settings. Lots of things in the blowpipe are handled specially because it holds two kinds of
	 * charges: darts and scales.
	 */
	TOXIC_BLOWPIPE(new ChargedWeaponBuilder()
		.chargedItemIds(12926 /*TOXIC_BLOWPIPE*/, 28688 /*blazing blowpipe*/)
		.name("Toxic blowpipe")
		.settingsConfigKey("blowpipe")
	),
	VENATOR_BOW(new ChargedWeaponBuilder()
		.chargedItemIds(27610 /*ItemID.VENATOR_BOW*/)
		.unchargedItemIds(27612 /*ItemID.VENATOR_BOW_UNCHARGED*/)
		.animationIds(9858)
		.name("Venator bow")
		.configKeyName("venator_bow")
		.updateMessageChargesRegexes(
			ChargesMessage.matcherGroupChargeMessage("Your Venator bow has ([\\d,]+) charges remaining.", 1)
		)
		.checkChargesRegexes(
			//Yep, same as the automatic message but with a lowercase 'v'.
			ChargesMessage.matcherGroupChargeMessage("Your venator bow has ([\\d,]+) charges remaining.", 1)
		)
		.dialogHandlers(
			new ChargesDialogHandler(
				DialogStateMatcher.sprite(Pattern.compile("You use ([\\d,]+) ancient essence to charge your venator bow. It now has ([\\d,]+) charges."), null),
				ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 2)
			)
		)
	),
	;

	public static final List<ChargedWeapon> CRYSTAL_SHARD_RECHARGABLE_ITEMS = Arrays.asList(CRYSTAL_BOW, CRYSTAL_HELM, CRYSTAL_BODY, CRYSTAL_LEGS, BOW_OF_FAERDHINEN, CRYSTAL_HALBERD);

	@Getter
	private static final List<ChargesMessage> nonUniqueCheckChargesRegexes = Arrays.asList(
		// ether weapons
		ChargesMessage.matcherGroupChargeMessage("Your weapon has ([\\d,]+) charges.", 1),
		ChargesMessage.matcherGroupChargeMessage("Your bow has ([\\d,]+) charges? left powering it.", 1),
		ChargesMessage.matcherGroupChargeMessage("Your chainmace has ([\\d,]+) charges? left powering it.", 1),
		ChargesMessage.matcherGroupChargeMessage("Your sceptre has ([\\d,]+) charges? left powering it.", 1),
		//ChargesMessage.staticChargeMessage("You require at least 1000 revenant ether to activate this weapon.", 0),
		ChargesMessage.staticChargeMessage("You use 1000 ether to activate the weapon.", 0),
		ChargesMessage.matcherGroupChargeMessage("You add (a further )?([\\d,]+) revenant ether to your weapon, giving it a total of ([\\d,]+) charges?.", 3),
		// elemental tomes
		ChargesMessage.staticChargeMessage("You empty your book of pages.", 0)
	);
	@Getter
	private static final List<ChargesMessage> nonUniqueUpdateMessageChargesRegexes = Arrays.asList(
		// trident
		ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your trident only has ([\\d,]+) charges left!</col>"), 1),
		ChargesMessage.staticChargeMessage(Text.removeTags("<col=ef1020>Your trident has run out of charges.</col>"), 0),
		// ether weapons
		ChargesMessage.matcherGroupChargeMessage(Text.removeTags("<col=ef1020>Your weapon only has ([\\d,]+) charges left.</col>"), 1),
		ChargesMessage.staticChargeMessage(Text.removeTags("<col=ef1020>Your weapon has run out of revenant ether.</col>"), 0),
		ChargesMessage.staticChargeMessage("There is not enough revenant ether left powering your bow.", 0)
	);

	@Getter
	private static final List<ChargesDialogHandler> nonUniqueDialogHandlers = Arrays.asList(
		// trident
		new ChargesDialogHandler(
			DialogStateMatcher.sprite(Pattern.compile("You add [\\S]+ [\\S]+ to the weapon. New total: ([\\d,]+)"), null),
			ChargesDialogHandler.genericSpriteDialogChargesMessage(true, 1)
		),
		new ChargesDialogHandler(
			DialogStateMatcher.sprite(Pattern.compile("Your weapon is already fully charged."), null),
			ChargesDialogHandler.genericSpriteDialogFullChargeMessage()
		),
		new ChargesDialogHandler( // This one is entirely redundant, I think. Haven't checked (e) tridents though wrt the message they show in the uncharging options dialog.
			DialogStateMatcher.sprite(Pattern.compile("You uncharge your weapon."), null),
			ChargesDialogHandler.genericSpriteDialogUnchargeMessage()
		),
		new ChargesDialogHandler(
			DialogStateMatcher.inputOptionSelected(Pattern.compile("How many charges would you like to add\\? \\(0 - ([\\d,]+)\\)"), null),
			ChargesDialogHandler.genericInputChargeMessage()
		),
		new ChargesDialogHandler(
			DialogStateMatcher.optionsOptionSelected(Pattern.compile("You will NOT get the coins back."), null, Pattern.compile("Okay, uncharge it.")),
			ChargesDialogHandler.genericUnchargeDialog()
		),
		new ChargesDialogHandler(
			DialogStateMatcher.optionsOptionSelected(Pattern.compile("If you drop it, it will lose all its charges."), null, Pattern.compile("Drop it.")),
			ChargesDialogHandler.genericUnchargeDialog()
		),
		// Crystal shard recharging.
//		2022-06-13 09:38:09 [Client] INFO  com.weaponcharges.Devtools - 25: dialog state changed: DialogState{INPUT, title='How many shards do you wish to add? (0 - 5)', input=''}
		new ChargesDialogHandler(
			DialogStateMatcher.inputOptionSelected(Pattern.compile("How many shards do you wish to add\\? \\(0 - ([\\d,]+)\\)"), null),
			ChargesDialogHandler.genericInputChargeMessage(100)
		)
	);

	private static class ChargedWeaponBuilder {
		List<Integer> chargedItemIds = Collections.emptyList();
		public ChargedWeaponBuilder chargedItemIds(Integer... chargedItemIds) {
			this.chargedItemIds = Arrays.asList(chargedItemIds);
			return this;
		}
		List<Integer> unchargedItemIds = Collections.emptyList();
		public ChargedWeaponBuilder unchargedItemIds(Integer... unchargedItemIds) {
			this.unchargedItemIds = Arrays.asList(unchargedItemIds);
			return this;
		}
		List<Integer> animationIds = Collections.emptyList();
		public ChargedWeaponBuilder animationIds(Integer... animationIds) {
			this.animationIds = Arrays.asList(animationIds);
			return this;
		}
		String name = null;
		public ChargedWeaponBuilder name(String name) {
			this.name = name;
			return this;
		}
		Integer rechargeAmount;
		public ChargedWeaponBuilder rechargeAmount(Integer rechargeAmount) {
			this.rechargeAmount = rechargeAmount;
			return this;
		}
		String configKeyName;
		public ChargedWeaponBuilder configKeyName(String configKeyName) {
			this.configKeyName = configKeyName;
			return this;
		}
		String settingsConfigKey;
		/**
		 * If set, it is used in place of configKeyName when accessing config for the item (low charges and display when).
		 */
		public ChargedWeaponBuilder settingsConfigKey(String settingsConfigKey) {
			this.settingsConfigKey = settingsConfigKey;
			return this;
		}
		List<ChargesMessage> checkChargesRegexes = Collections.emptyList();
		public ChargedWeaponBuilder checkChargesRegexes(ChargesMessage... checkChargesRegexes) {
			this.checkChargesRegexes = Arrays.asList(checkChargesRegexes);
			return this;
		}
		List<ChargesMessage> updateMessageChargesRegexes = Collections.emptyList();
		public ChargedWeaponBuilder updateMessageChargesRegexes(ChargesMessage... updateMessageChargesRegexes) {
			this.updateMessageChargesRegexes = Arrays.asList(updateMessageChargesRegexes);
			return this;
		}
		List<ChargesDialogHandler> dialogHandlers = Collections.emptyList();
		public ChargedWeaponBuilder dialogHandlers(ChargesDialogHandler... dialogHandlers) {
			this.dialogHandlers = Arrays.asList(dialogHandlers);
			return this;
		}
		int defaultLowChargeThreshold = 500;
		public ChargedWeaponBuilder defaultLowChargeThreshold(int defaultLowChargeThreshold) {
			this.defaultLowChargeThreshold = defaultLowChargeThreshold;
			return this;
		}
		public List<Integer> graphicIds = Collections.emptyList();
		public ChargedWeaponBuilder graphicIds(Integer... graphicIds) {
			this.graphicIds = Arrays.asList(graphicIds);
			return this;
		}
		DrawAfter drawAfter;
		public ChargedWeaponBuilder drawAfter(DrawAfter drawAfter) {
			this.drawAfter = drawAfter;
			return this;
		}
		BiConsumer<WeaponChargesPlugin, Menu> addMenuEntries;
		public ChargedWeaponBuilder configMenuEntries(BiConsumer<WeaponChargesPlugin, Menu> addMenuEntries) {
			this.addMenuEntries = addMenuEntries;
			return this;
		}
	}

	public final List<Integer> itemIds;
	public final List<Integer> unchargedIds;
	public final List<Integer> animationIds;
	public final List<Integer> graphicIds;
	public final DrawAfter drawAfter;
	public final BiConsumer<WeaponChargesPlugin, Menu> addMenuEntries;
	public final String name;
	public final Integer rechargeAmount;
	public final int defaultLowChargeThreshold;
	public final String configKeyName;
	public final String settingsConfigKey;
	// check messages are those produced by menu actions like "Check". update messages are those produced by the weapon
	// being used (e.g. those that notify you it's empty, or has 100 charges left, etc.).
	// These must be kept separate because the check messages [seem to always] have the charges of the weapon before
	// any attacks the weapon is making that tick, while the update messages have the charges of the weapon after any
	// attacks it makes on that tick.
	private final List<ChargesMessage> checkChargesRegexes;
	private final List<ChargesMessage> updateMessageChargesRegexes;
	private final List<ChargesDialogHandler> dialogHandlers;

	ChargedWeapon(ChargedWeaponBuilder builder) {
		this.itemIds = builder.chargedItemIds;
		this.unchargedIds = builder.unchargedItemIds;
		this.animationIds = builder.animationIds;
		this.graphicIds = builder.graphicIds;
		this.drawAfter = builder.drawAfter;
		this.addMenuEntries = builder.addMenuEntries;
		if (builder.name == null) throw new IllegalStateException("cannot have a null name for charged weapon.");
		this.name = builder.name;
		this.rechargeAmount = builder.rechargeAmount;
		this.defaultLowChargeThreshold = builder.defaultLowChargeThreshold;
		this.configKeyName = builder.configKeyName;
		this.settingsConfigKey = builder.settingsConfigKey == null ? builder.configKeyName : builder.settingsConfigKey;
		this.checkChargesRegexes = builder.checkChargesRegexes;
		this.updateMessageChargesRegexes = builder.updateMessageChargesRegexes;
		this.dialogHandlers = builder.dialogHandlers;
	}

	public static ChargedWeapon getChargedWeaponFromId(int itemId)
	{
		for (ChargedWeapon weapon : values())
		{
			if (weapon.getItemIds().contains(itemId) || weapon.getUnchargedIds().contains(itemId))
			{
				return weapon;
			}
		}

		return null;
	}

	public static final String DISPLAY_CONFIG_KEY_SUFFIX = "_display";
	public static final String LOW_CHARGE_CONFIG_KEY_SUFFIX = "_low_charge_threshold";

	public DisplayWhen getDisplayWhen(ConfigManager configManager) {
		try
		{
			return DisplayWhen.valueOf(configManager.getConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, settingsConfigKey + DISPLAY_CONFIG_KEY_SUFFIX));
		}
		catch (NullPointerException | IllegalArgumentException e)
		{
			// return default value.
			return DisplayWhen.USE_DEFAULT;
		}
	}

	public void setDisplayWhen(ConfigManager configManager, DisplayWhen displayWhen)
	{
		if (displayWhen == null) throw new IllegalArgumentException("displaywhen cannot be set to null");
		configManager.setConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, settingsConfigKey + DISPLAY_CONFIG_KEY_SUFFIX, displayWhen);
	}

	public int getLowCharge(ConfigManager configManager)
	{
		try
		{
			return Integer.parseInt(configManager.getConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, settingsConfigKey + LOW_CHARGE_CONFIG_KEY_SUFFIX));
		}
		catch (NullPointerException | IllegalArgumentException e)
		{
			// return default value.
			return getDefaultLowChargeThreshold();
		}
	}

	public void setLowCharge(ConfigManager configManager, int charges)
	{
		configManager.setConfiguration(WeaponChargesPlugin.CONFIG_GROUP_NAME, settingsConfigKey + LOW_CHARGE_CONFIG_KEY_SUFFIX, charges);
	}

	public void addMenuEntries(WeaponChargesPlugin plugin, Menu submenu) {
		if (addMenuEntries != null) addMenuEntries.accept(plugin, submenu);
	}

	private static ChargedWeapon get_scythe_circumvent_illegal_self_reference() {
		return SCYTHE_OF_VITUR;
	}
}

package com.weaponcharges;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.util.Text;

@Getter
@Builder
public class DialogStateMatcher
{
	private final boolean isOptionSelected;
	private final DialogTracker.DialogState.DialogType type;

	private final Pattern nameMatch;
	private final Pattern textMatch;
	private final Integer spriteDialogId;
	private final List<Pattern> optionMatches;

	private final Pattern optionMatch;

	public static DialogStateMatcher sprite(Pattern textMatch, Integer itemId)
	{
		return sprite(textMatch, itemId, false);
	}

	public static DialogStateMatcher spriteOptionSelected(Pattern textMatch, Integer itemId)
	{
		return sprite(textMatch, itemId, true);
	}

	private static DialogStateMatcher sprite(Pattern textMatch, Integer itemId, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.SPRITE)
			.isOptionSelected(isOptionSelected)
			.textMatch(textMatch)
			.spriteDialogId(itemId)
			.build();
	}

	public static DialogStateMatcher player(Pattern textMatch, Pattern nameMatch)
	{
		return player(textMatch, nameMatch, false);
	}

	public static DialogStateMatcher playerOptionSelected(Pattern textMatch, Pattern nameMatch)
	{
		return player(textMatch, nameMatch, true);
	}

	private static DialogStateMatcher player(Pattern textMatch, Pattern nameMatch, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.PLAYER)
			.isOptionSelected(isOptionSelected)
			.nameMatch(nameMatch)
			.textMatch(textMatch)
			.build();
	}

	public static DialogStateMatcher npc(Pattern textMatch, Pattern nameMatch)
	{
		return npc(textMatch, nameMatch, false);
	}

	public static DialogStateMatcher npcOptionSelected(Pattern textMatch, Pattern nameMatch)
	{
		return npc(textMatch, nameMatch, true);
	}

	private static DialogStateMatcher npc(Pattern textMatch, Pattern nameMatch, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.NPC)
			.isOptionSelected(isOptionSelected)
			.nameMatch(nameMatch)
			.textMatch(textMatch)
			.build();
	}

	public static DialogStateMatcher options(Pattern textMatch, List<Pattern> optionsMatch)
	{
		return options(textMatch, optionsMatch, null, false);
	}

	public static DialogStateMatcher optionsOptionSelected(Pattern textMatch, List<Pattern> optionsMatch, Pattern optionSelectedMatch)
	{
		return options(textMatch, optionsMatch, optionSelectedMatch, true);
	}

	private static DialogStateMatcher options(Pattern textMatch, List<Pattern> optionsMatch, Pattern optionSelectedMatch, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.OPTIONS)
			.isOptionSelected(isOptionSelected)
			.textMatch(textMatch)
			.optionMatches(optionsMatch)
			.optionMatch(optionSelectedMatch)
			.build();
	}

	public static DialogStateMatcher input(Pattern textMatch)
	{
		return input(textMatch, null, false);
	}

	public static DialogStateMatcher inputOptionSelected(Pattern textMatch, Pattern optionSelectedMatcher)
	{
		return input(textMatch, optionSelectedMatcher, true);
	}

	private static DialogStateMatcher input(Pattern textMatch, Pattern optionSelectedMatcher, boolean isOptionSelected)
	{
		return DialogStateMatcher.builder()
			.type(DialogTracker.DialogState.DialogType.INPUT)
			.isOptionSelected(isOptionSelected)
			.nameMatch(textMatch)
			.build();
	}

	public DialogStateMatchers matchDialog(DialogTracker.DialogState dialogState)
	{
		return matchDialog(dialogState, false, null);
	}

	public DialogStateMatchers matchDialogOptionSelected(DialogTracker.DialogState dialogState, String isOptionSelected)
	{
		return matchDialog(dialogState, true, isOptionSelected);
	}

	private DialogStateMatchers matchDialog(DialogTracker.DialogState dialogState, boolean isOptionSelected, String optionSelected)
	{
		if (this.isOptionSelected != isOptionSelected)
		{
			return null;
		}
		if (this.getType() != dialogState.type)
		{
			return null;
		}
		if (this.getSpriteDialogId() != null && this.getSpriteDialogId() != dialogState.spriteDialogItemId)
		{
			return null;
		}

		Matcher nameMatcher = null;
		if (this.getNameMatch() != null)
		{
			if (dialogState.name == null)
			{
				return null; // argument should never be null, but let's be safe.
			}
			nameMatcher = this.getNameMatch().matcher(dialogState.name);
			if (!nameMatcher.find())
			{
				return null;
			}
		}

		Matcher textMatcher = null;
		String text = dialogState.text;
		text = Text.removeTags(text.replaceAll("<br>", " "));
		if (this.getTextMatch() != null)
		{
			if (text == null)
			{
				return null; // argument should never be null, but let's be safe.
			}
			textMatcher = this.getTextMatch().matcher(text);
			if (!textMatcher.find())
			{
				return null;
			}
		}

		List<Matcher> optionMatchers = new ArrayList<>();
		if (this.getOptionMatches() != null)
		{
			if (this.getOptionMatches().size() != dialogState.options.size())
			{
				return null;
			}
			for (int i = 0; i < this.getOptionMatches().size(); i++)
			{
				Pattern optionMatch = this.getOptionMatches().get(i);
				if (optionMatch == null)
				{
					optionMatchers.add(null);
					continue;
				}

				String option = dialogState.options.get(i);
				if (option == null)
				{
					return null;
				}
				Matcher optionMatcher = optionMatch.matcher(option);
				if (!optionMatcher.find())
				{
					return null;
				}
				optionMatchers.add(optionMatcher);
			}
		}

		Matcher optionMatcher = null;
		if (this.getOptionMatch() != null)
		{
			if (optionSelected == null)
			{
				return null; // argument should never be null, but let's be safe.
			}
			optionMatcher = this.getOptionMatch().matcher(optionSelected);
			if (!optionMatcher.find())
			{
				return null;
			}
		}

		return new DialogStateMatchers(nameMatcher, textMatcher, dialogState.spriteDialogItemId, optionMatchers, optionMatcher);
	}

	//		public static NpcDialogStateMatcher noDialog() {
//			return new NpcDialogStateMatcher(NpcDialogType.NO_DIALOG, null, null, null, null);
//		}
//
	@Getter
	@RequiredArgsConstructor
	public static final class DialogStateMatchers
	{
		private final Matcher nameMatcher;
		private final Matcher textMatcher;
		private final Integer spriteDialogId;
		private final List<Matcher> optionMatchers;

		private final Matcher optionMatch;
	}
}

package com.weaponcharges;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import com.weaponcharges.WeaponChargesPlugin.DartType;
import java.util.HashMap;
import java.util.Map;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ChatColorConfig;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.overlay.OverlayManager;
import static org.junit.Assert.assertEquals;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.Mock;
import org.mockito.Mockito;
import static org.mockito.Mockito.doAnswer;
import org.mockito.junit.MockitoJUnitRunner;
import org.slf4j.LoggerFactory;

@RunWith(MockitoJUnitRunner.class)
public class WeaponChargesTest
{
	@Mock @Bind private Client client;
	@Mock @Bind private ChatColorConfig chatColorConfig;
	@Mock @Bind private ConfigManager configManager;
	@Mock @Bind private ItemManager itemManager;
	@Mock @Bind private OverlayManager overlayManager;
	@Mock @Bind private MouseManager mouseManager;
	@Mock @Bind private KeyManager keyManager;
	@Mock @Bind private ClientThread clientThread;
	@Mock @Bind private WeaponChargesItemOverlay itemOverlay;
	@Mock @Bind private DialogTracker dialogTracker;
	@Mock @Bind private WeaponChargesConfig config;

	@Inject private WeaponChargesPlugin plugin;

	private Map<String, String> configMap = new HashMap<>();
	private Map<Integer, Integer> equipment = new HashMap<>();
	private int animationId = -1;

	@Before
	public void before()
	{
		final Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
		logger.setLevel(Level.DEBUG);
		Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);

		Player localPlayer = Mockito.mock(Player.class);
//		doReturn(localPlayer).when(client).getLocalPlayer();

		doAnswer(invocation -> {
			InventoryID inventoryId = invocation.getArgument(0, InventoryID.class);
			if (inventoryId.equals(InventoryID.EQUIPMENT)) {
				ItemContainer mock = Mockito.mock(ItemContainer.class);
				doAnswer(i -> {
					Integer slot = i.getArgument(0, Integer.class);
					Integer itemId = equipment.get(slot);
					if (itemId == null) throw new UnsupportedOperationException();
					return new Item(itemId, 1);
				}).when(mock).getItem(anyInt());
				return mock;
			}
			throw new UnsupportedOperationException();
		}).when(client).getItemContainer(any(InventoryID.class));

//		Mockito.when(configManager.getRSProfileKey()).thenAnswer(invocation -> "anrsprofilekey");
		Mockito.when(configManager.getRSProfileConfiguration(eq(WeaponChargesPlugin.CONFIG_GROUP_NAME), anyString())).thenAnswer(invocation -> {
			String key = invocation.getArgument(1, String.class);
			return configMap.get(key);
		});
		doAnswer(invocation -> {
			String key = invocation.getArgument(1, String.class);
			Object value = invocation.getArgument(2, Object.class);
			configMap.put(key, value.toString());
			return null;
		}).when(configManager).setRSProfileConfiguration(eq(WeaponChargesPlugin.CONFIG_GROUP_NAME), anyString(), any());
	}

	// TODO check weapons while they are equipped.
	// TODO check animations.

	@Test
	public void test() {
		checkTomeOfFire();

		if (true) return;
		for (ChargedWeapon chargedWeapon : ChargedWeapon.values())
		{
			plugin.setCharges(chargedWeapon, 100);

			chargedWeapon.getDisplayWhen(configManager);
			chargedWeapon.getLowCharge(configManager);
		}

		checkIbans();

		checkTridentCheckMessages();

		checkTrident(ChargedWeapon.TRIDENT_OF_THE_SEAS);
		checkTrident(ChargedWeapon.TRIDENT_OF_THE_SWAMP);
		checkTrident(ChargedWeapon.TRIDENT_OF_THE_SEAS_E);
		checkTrident(ChargedWeapon.TRIDENT_OF_THE_SWAMP_E);

		checkCrystalHalberd();
		checkCrystalBow();
		checkBowOfFaerdhinen();
		checkCrystalArmour();
		checkCrystalShardRecharging();

		checkAbyssalTentacle();

		checkScytheOfVitur();
		checkSanguineScytheOfVitur();
		checkHolyScytheOfVitur();

		checkSanguinestiStaff();
		checkHolySanguinestiStaff();

		checkArclight();
		
		checkBlowpipe();
	}

	private void checkCrystalShardRecharging()
	{
//		2022-06-13 09:38:09 [Client] INFO  com.weaponcharges.Devtools - 25: dialog state changed: DialogState{INPUT, title='How many shards do you wish to add? (0 - 5)', input=''}
		inputDialog(ChargedWeapon.CRYSTAL_BOW, "How many shards do you wish to add? (0 - 5)", "2", 100, 300);
		inputDialog(ChargedWeapon.CRYSTAL_BOW, "How many shards do you wish to add? (0 - 5)", "12", 100, 600);
		inputDialog(ChargedWeapon.BOW_OF_FAERDHINEN, "How many shards do you wish to add? (0 - 5)", "2", 100, 300);
		inputDialog(ChargedWeapon.CRYSTAL_HELM, "How many shards do you wish to add? (0 - 5)", "2", 100, 300);
		inputDialog(ChargedWeapon.CRYSTAL_BODY, "How many shards do you wish to add? (0 - 5)", "2", 100, 300);
		inputDialog(ChargedWeapon.CRYSTAL_LEGS, "How many shards do you wish to add? (0 - 5)", "2", 100, 300);
		inputDialog(ChargedWeapon.CRYSTAL_HALBERD, "How many shards do you wish to add? (0 - 5)", "2", 100, 300);
	}

	private void checkCrystalArmour()
	{
//		2022-06-07 12:47:59 [Client] INFO  com.weaponcharges.Devtools - 78: GAMEMESSAGE "Your crystal helm has 1,011 charges remaining."
//		2022-06-07 12:47:59 [Client] INFO  com.weaponcharges.Devtools - 79: GAMEMESSAGE "Your crystal body has 996 charges remaining."
//		2022-06-07 12:48:00 [Client] INFO  com.weaponcharges.Devtools - 81: GAMEMESSAGE "Your crystal legs has 982 charges remaining."
		checkWeaponMessage(ChargedWeapon.CRYSTAL_HELM, "Your crystal helm has 1,011 charges remaining.", 1011);
		checkWeaponMessage(ChargedWeapon.CRYSTAL_BODY, "Your crystal body has 996 charges remaining.", 996);
		checkWeaponMessage(ChargedWeapon.CRYSTAL_LEGS, "Your crystal legs has 982 charges remaining.", 982);

	}

	private void checkBowOfFaerdhinen()
	{
//		2022-06-07 12:47:57 [Client] INFO  com.weaponcharges.Devtools - 76: GAMEMESSAGE "Your bow of Faerdhinen has 180 charges remaining."
		checkWeaponMessage(ChargedWeapon.BOW_OF_FAERDHINEN, "Your bow of Faerdhinen has 180 charges remaining.", 180);
//		2022-06-07 18:53:09 [Client] INFO  com.weaponcharges.Devtools - 3353: GAMEMESSAGE "<col=ff0000>Your bow of Faerdhinen has 100 charges remaining.</col>"
		equippedWeaponPeriodicUpdate(ChargedWeapon.BOW_OF_FAERDHINEN, "<col=ff0000>Your bow of Faerdhinen has 100 charges remaining.</col>", 100);
	}

	private void checkCrystalBow()
	{
//		2022-06-12 20:17:48 [Client] INFO  com.weaponcharges.Devtools - 939: GAMEMESSAGE "Your crystal bow has 299 charges remaining."
		checkWeaponMessage(ChargedWeapon.CRYSTAL_BOW, "Your crystal bow has 299 charges remaining.", 299);
	}

	private void checkTridentCheckMessages()
	{
//		2022-05-04 12:37:05 [Client] INFO  com.weaponcharges.Devtools - 354: GAMEMESSAGE "Your Trident of the swamp (e) has 2,000 charges."
//		2022-05-04 12:38:41 [Client] INFO  com.weaponcharges.Devtools - 514: GAMEMESSAGE "Your Trident of the swamp (e) has one charge."
//		2022-05-04 12:40:27 [Client] INFO  com.weaponcharges.Devtools - 691: GAMEMESSAGE "Your Trident of the seas (e) has one charge."
//		2022-05-04 12:40:36 [Client] INFO  com.weaponcharges.Devtools - 706: GAMEMESSAGE "Your Trident of the seas (e) has 1,001 charges."
//		2022-05-04 07:08:09 [Client] INFO  com.weaponcharges.Devtools - 12: GAMEMESSAGE "Your Trident of the swamp has 6 charges."
//		2022-05-04 07:09:59 [Client] INFO  com.weaponcharges.Devtools - 196: GAMEMESSAGE "Your Trident of the seas has one charge."
//		2022-05-04 07:10:55 [Client] INFO  com.weaponcharges.Devtools - 288: GAMEMESSAGE "Your Trident of the seas has 2 charges."
//		2022-05-04 07:13:15 [Client] INFO  com.weaponcharges.Devtools - 521: GAMEMESSAGE "Your Trident of the seas has 100 charges."

		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SEAS, "Your Trident of the seas has 2 charges.", 2);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SEAS, "Your Trident of the seas has one charge.", 1);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SEAS, "Your Trident of the seas has no charges.", 0);

		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SWAMP_E, "Your Trident of the swamp (e) has 2,000 charges.", 2000);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SWAMP_E, "Your Trident of the swamp (e) has one charge.", 1);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SWAMP_E, "Your Trident of the swamp (e) has no charges.", 0);

		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SEAS_E, "Your Trident of the seas (e) has 1,001 charges.", 1001);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SEAS_E, "Your Trident of the seas (e) has one charge.", 1);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SEAS_E, "Your Trident of the seas (e) has no charges.", 0);

		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SWAMP, "Your Trident of the swamp has 6 charges.", 6);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SWAMP, "Your Trident of the swamp has one charge.", 1);
		checkWeaponMessage(ChargedWeapon.TRIDENT_OF_THE_SWAMP, "Your Trident of the swamp has no charges.", 0);
	}

	private void checkBlowpipe()
	{
		// TODO some of these unnecessarily check (menu option) the blowpipe.

		checkBlowpipeMessage("Darts: <col=007f00>None</col>. Scales: <col=007f00>99 (0.6%)</col>.", 99, 0, DartType.UNKNOWN);
		checkBlowpipeMessage("Darts: <col=007f00>Adamant dart x 16,383</col>. Scales: <col=007f00>16,383 (100.0%)</col>.", 16383, 16383, DartType.ADAMANT);
		checkBlowpipeMessage("Darts: <col=007f00>Adamant dart x 16,383</col>. Scales: <col=007f00>0 (0.0%)</col>.", 0, 16383, DartType.ADAMANT);

		checkBlowpipeMessage("The blowpipe can't hold any more scales.", WeaponChargesPlugin.MAX_SCALES_BLOWPIPE, null, null);
		checkBlowpipeMessage("The blowpipe can't hold any more darts.", null, WeaponChargesPlugin.MAX_DARTS, null);

		checkBlowpipeMessage("Your blowpipe has run out of darts.", null, 0, DartType.UNKNOWN);
		checkBlowpipeMessage("Your blowpipe needs to be charged with Zulrah's scales.", 0, null, null);
		checkBlowpipeMessage("Your blowpipe has run out of scales and darts.", 0, 0, DartType.UNKNOWN);

		checkBlowpipeMessage("Your blowpipe contains no darts.", null, 0, DartType.UNKNOWN);
		checkBlowpipeMessage("Your blowpipe needs to be charged with Zulrah's scales and loaded with darts.", 0, 0, DartType.UNKNOWN);

		checkBlowpipeMessage("The blowpipe has no darts in it.", null, 0, DartType.UNKNOWN);

		// unload with darts has no chat message. TODO

		// uncharge 2021-09-05 14:40:47 [Client] INFO  com.weaponcharges.Devtools - 481: dialog state changed: DialogState{DESTROY_ITEM, title='Are you sure you want to uncharge it?', itemId=12926, item_name='Toxic blowpipe', text='If you uncharge the blowpipe, all scales and darts will fall out.'}
	}

	// TODO not testing SPAM.

	private void checkBlowpipeMessage(String message, Integer scalesExpected, Integer dartsExpected, DartType dartType)
	{
		checkBlowpipeMessage(message, scalesExpected, dartsExpected, dartType, true);
	}

	private void blowpipeMessage(String message, Integer scalesExpected, Integer dartsExpected, DartType dartType)
	{
		checkBlowpipeMessage(message, scalesExpected, dartsExpected, dartType, false);
	}

	private void checkBlowpipeMessage(String message, Integer scalesExpected, Integer dartsExpected, DartType dartType, boolean checkBlowpipe)
	{
		if ((scalesExpected != null && scalesExpected == 1000) || (dartsExpected != null && dartsExpected == 1000) || dartType == DartType.BRONZE) {
			throw new IllegalArgumentException("Cannot have identical expected to the defaults.");
		}
		plugin.setScalesLeft(1000);
		plugin.setDartsLeft(1000);
		plugin.setDartType(DartType.BRONZE);

		if (checkBlowpipe)
		{
			TestMenuEntry menuEntry = new TestMenuEntry();
			menuEntry.setOption("Check");
			menuEntry.setItemId(ItemID.TOXIC_BLOWPIPE);
			MenuOptionClicked event = new MenuOptionClicked(menuEntry);
			plugin.onMenuOptionClicked(event);
		}

		gameMessage(message);
		plugin.onGameTick(new GameTick());

		if (scalesExpected != null) assertEquals(Float.valueOf(scalesExpected), plugin.getScalesLeft());
		else assertEquals(Float.valueOf(1000), plugin.getScalesLeft());
		if (dartsExpected != null) assertEquals(Float.valueOf(dartsExpected), plugin.getDartsLeft());
		else assertEquals(Float.valueOf(1000), plugin.getDartsLeft());
		if (dartType != null) assertEquals(dartType, plugin.getDartType());
		else assertEquals(DartType.BRONZE, plugin.getDartType());
	}

	private void checkArclight()
	{
		checkWeaponMessage(ChargedWeapon.ARCLIGHT, "Your arclight has 6397 charges left.", 6397);
	}

	private void checkSanguinestiStaff()
	{
		checkWeaponMessage(ChargedWeapon.SANGUINESTI_STAFF, "Your Sanguinesti staff is already fully charged.", 20000);
		checkWeaponMessage(ChargedWeapon.SANGUINESTI_STAFF, "Your Sanguinesti staff has 1,000 charges remaining.", 1000);
		checkWeaponMessage(ChargedWeapon.SANGUINESTI_STAFF, "Your Sanguinesti staff has 1 charges remaining.", 1);

		optionsDialogSelected(ChargedWeapon.SANGUINESTI_STAFF, "Uncharge your staff for all its charges? (regaining 11,748 blood runes)", "Proceed.", 123, 0, "Proceed.", "Cancel.");
	}

	private void checkHolySanguinestiStaff()
	{
		checkWeaponMessage(ChargedWeapon.SANGUINESTI_STAFF, "Your Holy sanguinesti staff is already fully charged.", 20000);
		checkWeaponMessage(ChargedWeapon.SANGUINESTI_STAFF, "Your Holy sanguinesti staff has 1,000 charges remaining.", 1000);
		checkWeaponMessage(ChargedWeapon.SANGUINESTI_STAFF, "Your Holy sanguinesti staff has 1 charges remaining.", 1);

		optionsDialogSelected(ChargedWeapon.SANGUINESTI_STAFF, "Uncharge your staff for all its charges? (regaining 11,748 blood runes)", "Proceed.", 123, 0, "Proceed.", "Cancel.");
	}

	private void checkScytheOfVitur()
	{
		checkWeaponMessage(ChargedWeapon.SCYTHE_OF_VITUR, "Your Scythe of vitur has 19,529 charges remaining.", 19529);

		inputDialog(ChargedWeapon.SCYTHE_OF_VITUR, "How many sets of 100 charges do you wish to apply? (Up to 173)", "120", 100, 12100);
//		spriteDialog(ChargedWeapon.SCYTHE_OF_VITUR, "You apply 17,300 charges to your Scythe of vitur.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 17400);

		spriteDialogOptionSelected(ChargedWeapon.SCYTHE_OF_VITUR, "If you uncharge your scythe into the well, 17,300<br>charges will be added to the well.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 0);
		// This one isn't tracked because it is superfluous.
//		spriteDialog(ChargedWeapon.SCYTHE_OF_VITUR, "You uncharge your scythe into the well. It now<br>contains 173 sets of 100 charges.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 0);
	}

	private void checkSanguineScytheOfVitur()
	{
		checkWeaponMessage(ChargedWeapon.SCYTHE_OF_VITUR, "Your Sanguine scythe of vitur has 19,529 charges remaining.", 19529);

		inputDialog(ChargedWeapon.SCYTHE_OF_VITUR, "How many sets of 100 charges do you wish to apply? (Up to 173)", "120", 100, 12100);
//		spriteDialog(ChargedWeapon.SCYTHE_OF_VITUR, "You apply 17,300 charges to your Sanguine scythe of vitur.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 17400);

		spriteDialogOptionSelected(ChargedWeapon.SCYTHE_OF_VITUR, "If you uncharge your scythe into the well, 17,300<br>charges will be added to the well.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 0);
		// This one isn't tracked because it is superfluous.
//		spriteDialog(ChargedWeapon.SCYTHE_OF_VITUR, "You uncharge your scythe into the well. It now<br>contains 173 sets of 100 charges.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 0);
	}

	private void checkHolyScytheOfVitur()
	{
		checkWeaponMessage(ChargedWeapon.SCYTHE_OF_VITUR, "Your Holy scythe of vitur has 19,529 charges remaining.", 19529);

		inputDialog(ChargedWeapon.SCYTHE_OF_VITUR, "How many sets of 100 charges do you wish to apply? (Up to 173)", "120", 100, 12100);
//		spriteDialog(ChargedWeapon.SCYTHE_OF_VITUR, "You apply 17,300 charges to your Holy scythe of vitur.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 17400);

		spriteDialogOptionSelected(ChargedWeapon.SCYTHE_OF_VITUR, "If you uncharge your scythe into the well, 17,300<br>charges will be added to the well.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 0);
		// This one isn't tracked because it is superfluous.
//		spriteDialog(ChargedWeapon.SCYTHE_OF_VITUR, "You uncharge your scythe into the well. It now<br>contains 173 sets of 100 charges.", ChargedWeapon.SCYTHE_OF_VITUR.getItemIds().get(0), 100, 0);
	}

	private void checkTomeOfFire()
	{
		checkWeaponMessage(ChargedWeapon.TOME_OF_FIRE, "Your tome has been charged with Searing Pages. It currently holds 40 charges.", 40);
//		checkWeaponMessage(ChargedWeapon.TOME_OF_FIRE, "Your tome currently holds 6,839 charges.", 6839);
//		checkWeaponMessage(ChargedWeapon.TOME_OF_FIRE, "Your tome currently holds one charge.", 1);

		equippedWeaponPeriodicUpdate(ChargedWeapon.TOME_OF_FIRE, "Your Tome of Fire is now empty.", 0);

		equippedWeaponPeriodicUpdate(ChargedWeapon.TOME_OF_FIRE, "You remove a page from the book. Your tome currently holds 6,839 charges.", 6839);
		equippedWeaponPeriodicUpdate(ChargedWeapon.TOME_OF_FIRE, "You remove 2 pages from the book. Your tome currently holds 6,799 charges.", 6799);
		equippedWeaponPeriodicUpdate(ChargedWeapon.TOME_OF_FIRE, "You empty your book of pages.", 0);
		equippedWeaponPeriodicUpdate(ChargedWeapon.TOME_OF_FIRE, "You remove 299 pages from the book. Your tome currently holds one charge.", 1);
	}

	private void checkAbyssalTentacle()
	{
		checkWeaponMessage(ChargedWeapon.ABYSSAL_TENTACLE, "Your abyssal tentacle can perform 190 more attacks.", 190);
	}

	private void checkCrystalHalberd()
	{
		checkWeaponMessage(ChargedWeapon.CRYSTAL_HALBERD, "Your crystal halberd has 278 charges remaining.", 278);
	}

	private void checkIbans()
	{
		checkWeaponMessage(ChargedWeapon.IBANS_STAFF, "You have 2500 charges left on the staff.", 2500);
		checkWeaponMessage(ChargedWeapon.IBANS_STAFF, "You have 116 charges left on the staff.", 116);
		checkWeaponMessage(ChargedWeapon.IBANS_STAFF, "You have a charge left on the staff.", 1);
		checkWeaponMessage(ChargedWeapon.IBANS_STAFF, "You have no charges left on the staff.", 0);

		equippedWeaponPeriodicUpdate(ChargedWeapon.IBANS_STAFF, "<col=ef1020>Your staff only has 100 charges left.</col>", 100);
		equippedWeaponPeriodicUpdate(ChargedWeapon.IBANS_STAFF, "<col=ef1020>Your staff has run out of charges.</col>", 0);
		equippedWeaponPeriodicUpdate(ChargedWeapon.IBANS_STAFF, "You need to recharge your staff to use this spell.", 0);

		spriteDialog(ChargedWeapon.IBANS_STAFF, "You hold the staff above the well and feel the power of<br>Zamorak flow through you.", 12658, 2015, 2500);
	}

	private void checkTrident(ChargedWeapon chargedWeapon)
	{
		equippedWeaponPeriodicUpdate(chargedWeapon, "<col=ef1020>Your trident only has 100 charges left!</col>", 100);
		equippedWeaponPeriodicUpdate(chargedWeapon, "<col=ef1020>Your trident has run out of charges.</col>", 0);
		equippedWeaponPeriodicUpdate(chargedWeapon, "The weapon has no charges left. You need death runes, chaos runes, fire runes and Zulrah's scales to charge it.", 0);

		inputDialog(chargedWeapon, "How many charges would you like to add? (0 - 2,477)", "123", 50, 50 + 123);

		spriteDialog(chargedWeapon, "You add a charge to the weapon.<br>New total: 2016", chargedWeapon.getItemIds().get(0), 2015, 2016);
		spriteDialog(chargedWeapon, "Your weapon is already fully charged.", chargedWeapon.getItemIds().get(0), 2015, chargedWeapon.rechargeAmount);
		spriteDialog(chargedWeapon, "You add 124 charges to the weapon.<br>New total: 247", chargedWeapon.getItemIds().get(0), 123, 247);

		optionsDialogSelected(chargedWeapon, (chargedWeapon == ChargedWeapon.TRIDENT_OF_THE_SEAS || chargedWeapon == ChargedWeapon.TRIDENT_OF_THE_SEAS_E) ? "You will NOT get the coins back." : "Really uncharge the trident?", "Okay, uncharge it.", 123, 0, "Okay, uncharge it.", "No, don't uncharge it.");
		optionsDialogSelected(chargedWeapon, "If you drop it, it will lose all its charges.", "Drop it.", 123, 0, "Drop it.", "No, don't drop it.");
	}

	private void optionsDialogSelected(ChargedWeapon chargedWeapon, String text, String optionSelected, int initialCharges, int charges, String... options)
	{
		if (initialCharges == 0) throw new RuntimeException();
		plugin.lastUnchargeClickedWeapon = chargedWeapon;
		plugin.setCharges(chargedWeapon, initialCharges);
		plugin.optionSelected(DialogTracker.DialogState.options(text, options), optionSelected);
		checkCharges(chargedWeapon, charges);
	}

	private void spriteDialog(ChargedWeapon chargedWeapon, String title, int itemId, int initialCharges, int charges)
	{
		if (initialCharges == 0) throw new RuntimeException();
		plugin.lastUsedOnWeapon = chargedWeapon;
		plugin.setCharges(chargedWeapon, initialCharges);
		plugin.dialogStateChanged(DialogTracker.DialogState.sprite(title, itemId));
		checkCharges(chargedWeapon, charges);
	}

	private void spriteDialogOptionSelected(ChargedWeapon chargedWeapon, String title, int itemId, int initialCharges, int charges)
	{
		if (initialCharges == 0) throw new RuntimeException();
		plugin.lastUsedOnWeapon = chargedWeapon;
		plugin.setCharges(chargedWeapon, initialCharges);
		plugin.optionSelected(DialogTracker.DialogState.sprite(title, itemId), null);
		checkCharges(chargedWeapon, charges);
	}

	private void inputDialog(ChargedWeapon chargedWeapon, String title, String input, int initialCharges, int charges)
	{
		if (initialCharges == 0) throw new RuntimeException("if initialCharges is 0 you can't differentiate between a set and an add.");
		plugin.lastUsedOnWeapon = chargedWeapon;
		plugin.setCharges(chargedWeapon, initialCharges);
		plugin.optionSelected(DialogTracker.DialogState.input(title, input), input);
		checkCharges(chargedWeapon, charges);
	}

	private void equippedWeaponPeriodicUpdate(ChargedWeapon chargedWeapon, String message, int charges)
	{
		equipWeapon(chargedWeapon);
		gameMessage(message);
		gameTick();
		checkCharges(chargedWeapon, charges);
	}

	private void gameTick()
	{
		plugin.onGameTick(new GameTick());
	}

	private void equipWeapon(ChargedWeapon chargedWeapon)
	{
		equipment.put(EquipmentInventorySlot.WEAPON.getSlotIdx(), chargedWeapon.getItemIds().get(0));
	}

	private void checkWeaponSpecificMessage(ChargedWeapon chargedWeapon, String message, int charges)
	{
		gameMessage(message);
		checkCharges(chargedWeapon, charges);
	}

	private void checkWeaponMessage(ChargedWeapon chargedWeapon, String message, int charges)
	{
		checkWeapon(chargedWeapon);
		gameMessage(message);
		gameTick(); // This isn't necessary for normal check messages, but some are identical to update messages so I
					// didn't include them in the check messages section but instead in the update section.
		checkCharges(chargedWeapon, charges);
	}

	private void checkWeapon(ChargedWeapon chargedWeapon)
	{
		TestMenuEntry menuEntry = new TestMenuEntry();
		menuEntry.setOption("Check");
		menuEntry.setItemId(chargedWeapon.getItemIds().get(0));
		MenuOptionClicked event = new MenuOptionClicked(menuEntry);
		plugin.onMenuOptionClicked(event);
	}

	private void checkCharges(ChargedWeapon chargedWeapon, int expectedCharges)
	{
		assertEquals(Float.valueOf(expectedCharges), plugin.getCharges(chargedWeapon));
	}

	private void gameMessage(String message)
	{
		plugin.onChatMessage(new ChatMessage(null, ChatMessageType.GAMEMESSAGE, null, message, null, -1));
	}
}


/*
 * Copyright (c) 2021, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.weaponcharges;

import java.util.function.Consumer;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Actor;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.widgets.Widget;

@EqualsAndHashCode
public class TestMenuEntry implements MenuEntry
{
	private String option;
	private String target;
	private int identifier;
	private int type;
	private int param0;
	private int param1;
	private boolean forceLeftClick;
	@Setter
	private int itemOp = -1;
	private int itemId = -1;
	@Setter
	private Widget widget;
	@Setter
	private Actor actor;
	@Getter
	private MenuEntry parent;

	@Override
	public String getOption()
	{
		return option;
	}

	@Override
	public MenuEntry setOption(String option)
	{
		this.option = option;
		return this;
	}

	@Override
	public String getTarget()
	{
		return target;
	}

	@Override
	public MenuEntry setTarget(String target)
	{
		this.target = target;
		return this;
	}

	@Override
	public int getIdentifier()
	{
		return this.identifier;
	}

	@Override
	public MenuEntry setIdentifier(int identifier)
	{
		this.identifier = identifier;
		return this;
	}

	@Override
	public MenuAction getType()
	{
		return MenuAction.of(this.type);
	}

	@Override
	public MenuEntry setType(MenuAction type)
	{
		this.type = type.getId();
		return this;
	}

	@Override
	public int getParam0()
	{
		return this.param0;
	}

	@Override
	public MenuEntry setParam0(int param0)
	{
		this.param0 = param0;
		return this;
	}

	@Override
	public int getParam1()
	{
		return this.param1;
	}

	@Override
	public MenuEntry setParam1(int param1)
	{
		this.param1 = param1;
		return this;
	}

	@Override
	public boolean isForceLeftClick()
	{
		return this.forceLeftClick;
	}

	@Override
	public MenuEntry setForceLeftClick(boolean forceLeftClick)
	{
		this.forceLeftClick = forceLeftClick;
		return this;
	}

	@Override
	public int getWorldViewId()
	{
		return 0;
	}

	@Override
	public MenuEntry setWorldViewId(int worldViewId)
	{
		return null;
	}

	@Override
	public boolean isDeprioritized()
	{
		return type >= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
	}

	@Override
	public MenuEntry setDeprioritized(boolean deprioritized)
	{
		if (deprioritized)
		{
			if (type < MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET)
			{
				type += MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
			}
		}
		else
		{
			if (type >= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET)
			{
				type -= MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;
			}
		}

		return this;
	}

	@Override
	public MenuEntry onClick(Consumer<MenuEntry> callback)
	{
		return this;
	}

	@Override
	public Consumer<MenuEntry> onClick()
	{
		return null;
	}

	@Override
	public boolean isItemOp()
	{
		return itemOp != -1;
	}

	@Override
	public int getItemOp()
	{
		return itemOp;
	}

	@Override
	public int getItemId()
	{
		return itemId;
	}

	@Override
	public MenuEntry setItemId(int itemId)
	{
		return null;
	}

	@Nullable
	@Override
	public Widget getWidget()
	{
		return widget;
	}

	@Nullable
	@Override
	public NPC getNpc()
	{
		return actor instanceof NPC ? (NPC) actor : null;
	}

	@Nullable
	@Override
	public Player getPlayer()
	{
		return actor instanceof Player ? (Player) actor : null;
	}

	@Nullable
	@Override
	public Actor getActor()
	{
		return actor;
	}

	@Nullable
	@Override
	public Menu getSubMenu()
	{
		return null;
	}

	@Nonnull
	@Override
	public Menu createSubMenu()
	{
		return null;
	}

	@Override
	public void deleteSubMenu()
	{

	}
}

package com.weaponcharges;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.Properties;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		setWindowTitle("weapon-charges (" + getCurrentGitBranch() + ") RL-" + RuneLiteProperties.getVersion());

		ExternalPluginManager.loadBuiltin(WeaponChargesPlugin.class);
		RuneLite.main(args);
	}

	private static void setWindowTitle(String title) throws NoSuchFieldException, IllegalAccessException
	{
		Field propertiesField = RuneLiteProperties.class.getDeclaredField("properties");
		propertiesField.setAccessible(true);
		Properties properties = (Properties) propertiesField.get(null);
		properties.setProperty("runelite.title", title);
	}

	public static String getCurrentGitBranch() {
		try
		{
			Process process = Runtime.getRuntime().exec("git rev-parse --abbrev-ref HEAD");
			process.waitFor();

			BufferedReader reader = new BufferedReader(
				new InputStreamReader(process.getInputStream()));

			return reader.readLine();
		}catch (Exception e) {
			return "threw exception";
		}
	}

}
