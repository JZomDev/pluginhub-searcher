package gimhub;

import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class CollectionLogWidgetSubscriber {
    @Inject
    private EventBus eventBus;

    @Inject
    private Client client;

    @Inject
    private CollectionLogManager collectionLogManager;

    private boolean searchTriggered = false;
    private int searchTriggeredTick = -1;

    public void startUp() {
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged e) {
        GameState s = e.getGameState();
        if (s != GameState.HOPPING && s != GameState.LOGGED_IN) {
            searchTriggered = false;
            searchTriggeredTick = -1;
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (searchTriggeredTick != -1) {
            int currentTick = client.getTickCount();

            if (currentTick - searchTriggeredTick >= 500) {
                searchTriggered = false;
                searchTriggeredTick = -1;
            }
        }
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired pre) {
        // Script 4100 fires when collection log items are enumerated via search
        if (pre.getScriptId() == 4100) {
            // Arguments: [widgetId, itemId, qty]
            Object[] args = pre.getScriptEvent().getArguments();
            if (args != null && args.length >= 3) {
                try {
                    int itemId = (int) args[1];
                    int quantity = (int) args[2];
                    collectionLogManager.storeClogItem(itemId, quantity);
                } catch (Exception ignored) {
                    //
                }
            }
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired post) {
        final int COLLECTION_LOG_SETUP = 7797;
        if (post.getScriptId() == COLLECTION_LOG_SETUP) {
            if (searchTriggered) return;
            boolean isAdventureLog = client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
            if (isAdventureLog) return;

            searchTriggered = true;
            searchTriggeredTick = client.getTickCount();
            client.menuAction(-1, InterfaceID.Collection.SEARCH_TOGGLE, MenuAction.CC_OP, 1, -1, "Search", null);
            final int COLLECTION_INIT = 2240;
            client.runScript(COLLECTION_INIT);
        }
    }
}

package gimhub.activity;

import gimhub.APISerializable;
import java.util.HashMap;
import java.util.Map;
import net.runelite.api.Client;
import net.runelite.api.Skill;

public class Skills implements APISerializable {
    private final Map<String, Integer> skillXpMap;

    public Skills(Client client) {
        this.skillXpMap = new HashMap<>();
        for (Skill skill : Skill.values()) {
            skillXpMap.put(skill.getName(), client.getSkillExperience(skill));
        }
    }

    @Override
    public Object serialize() {
        return new int[] {
            skillXpMap.get("Agility"),
            skillXpMap.get("Attack"),
            skillXpMap.get("Construction"),
            skillXpMap.get("Cooking"),
            skillXpMap.get("Crafting"),
            skillXpMap.get("Defence"),
            skillXpMap.get("Farming"),
            skillXpMap.get("Firemaking"),
            skillXpMap.get("Fishing"),
            skillXpMap.get("Fletching"),
            skillXpMap.get("Herblore"),
            skillXpMap.get("Hitpoints"),
            skillXpMap.get("Hunter"),
            skillXpMap.get("Magic"),
            skillXpMap.get("Mining"),
            skillXpMap.get("Prayer"),
            skillXpMap.get("Ranged"),
            skillXpMap.get("Runecraft"),
            skillXpMap.get("Slayer"),
            skillXpMap.get("Smithing"),
            skillXpMap.get("Strength"),
            skillXpMap.get("Thieving"),
            skillXpMap.get("Woodcutting"),
            skillXpMap.get("Sailing"),
        };
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Skills)) return false;

        Skills other = (Skills) o;
        return skillXpMap.equals(other.skillXpMap);
    }
}

package gimhub.activity;

import gimhub.APISerializable;
import net.runelite.api.coords.WorldPoint;

public class WorldLocation implements APISerializable {
    private final int x;
    private final int y;
    private final int plane;
    private final boolean isOnBoat;

    WorldLocation(WorldPoint worldPoint, boolean isOnBoat) {
        this.x = worldPoint.getX();
        this.y = worldPoint.getY();
        this.plane = worldPoint.getPlane();
        this.isOnBoat = isOnBoat;
    }

    @Override
    public Object serialize() {
        return new int[] {x, y, plane, isOnBoat ? 1 : 0};
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof WorldLocation)) return false;

        WorldLocation other = (WorldLocation) o;

        return (x == other.x) && (y == other.y) && (plane == other.plane) && (isOnBoat == other.isOnBoat);
    }

    @Override
    public String toString() {
        return String.format("{ x: %d, y: %d, plane: %d, isOnBoat: %b }", x, y, plane, isOnBoat);
    }
}

package gimhub.activity;

import gimhub.APISerializable;
import java.util.Map;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.WorldEntity;
import net.runelite.api.coords.WorldPoint;

public class ActivityRepository {
    public Resources resources = null;
    public Skills skills = null;
    public WorldLocation position = null;
    public Interaction interacting = null;

    public void updateResources(Client client) {
        resources = new Resources(client);
    }

    public void updateSkills(Client client) {
        skills = new Skills(client);
    }

    public void updateLocation(Client client) {
        Player player = client.getLocalPlayer();
        if (player == null) return;

        final int worldViewID = player.getWorldView().getId();
        final boolean isOnBoat = worldViewID != -1;
        WorldPoint location = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
        if (isOnBoat) {
            WorldEntity worldEntity =
                    client.getTopLevelWorldView().worldEntities().byIndex(worldViewID);
            location = WorldPoint.fromLocalInstance(client, worldEntity.getLocalLocation());
        }

        position = new WorldLocation(location, isOnBoat);
    }

    public void updateInteracting(Client client) {
        Player player = client.getLocalPlayer();
        if (player == null) return;

        Actor actor = player.getInteracting();
        if (actor == null) return;

        interacting = new Interaction(actor, client);
    }

    public void flatten(Map<String, APISerializable> flat) {
        flat.put("stats", resources);
        flat.put("skills", skills);
        flat.put("coordinates", position);
        flat.put("interacting", interacting);
    }
}

package gimhub.activity;

import gimhub.APISerializable;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;

public class Interaction implements APISerializable {
    private final String name;
    private final int scale;
    private final int ratio;
    private final WorldLocation location;

    private final transient int tick;

    public Interaction(Actor actor, Client client) {
        this.name = actor.getName();
        this.scale = actor.getHealthScale();
        this.ratio = actor.getHealthRatio();

        WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, actor.getLocalLocation());
        this.location = new WorldLocation(worldPoint, false);

        this.tick = client.getTickCount();
    }

    @Override
    public Object serialize() {
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Interaction)) return false;

        Interaction other = (Interaction) o;

        return tick == other.tick
                && location.equals(other.location)
                && scale == other.scale
                && ratio == other.ratio
                && name.equals(other.name);
    }
}

package gimhub.activity;

import gimhub.APISerializable;
import net.runelite.api.Client;
import net.runelite.api.Skill;

public class Resources implements APISerializable {
    private static class CurrentMax {
        private final int current;
        private final int max;

        CurrentMax(int current, int max) {
            this.current = current;
            this.max = max;
        }

        @Override
        public boolean equals(Object o) {
            if (o == this) return true;
            if (!(o instanceof CurrentMax)) return false;

            CurrentMax other = (CurrentMax) o;

            return current == other.current && max == other.max;
        }
    }

    private final CurrentMax hitpoints;
    private final CurrentMax prayer;
    private final CurrentMax energy;
    private final int world;

    Resources(Client client) {
        this.hitpoints =
                new CurrentMax(client.getBoostedSkillLevel(Skill.HITPOINTS), client.getRealSkillLevel(Skill.HITPOINTS));
        this.prayer = new CurrentMax(client.getBoostedSkillLevel(Skill.PRAYER), client.getRealSkillLevel(Skill.PRAYER));
        this.energy = new CurrentMax(client.getEnergy(), 100);
        this.world = client.getWorld();
    }

    @Override
    public Object serialize() {
        return new int[] {
            hitpoints.current, hitpoints.max, prayer.current, prayer.max, energy.current, energy.max, world
        };
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Resources)) return false;

        Resources other = (Resources) o;

        return other.world == world
                && other.hitpoints.equals(hitpoints)
                && other.prayer.equals(prayer)
                && other.energy.equals(energy);
    }
}

package gimhub;

import com.google.inject.Provides;
import gimhub.DataManager.PlayerState;
import java.time.temporal.ChronoUnit;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;

@Slf4j
@PluginDescriptor(name = "GIM hub")
public class GimHubPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private DataManager dataManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private CollectionLogWidgetSubscriber collectionLogWidgetSubscriber;

    private static final int SECONDS_BETWEEN_UPLOADS = 1;
    private static final int SECONDS_BETWEEN_INFREQUENT_DATA_CHANGES = 60;

    private static final int WIDGET_DEPOSIT_ITEM_BUTTON = 12582935;
    private static final int WIDGET_DEPOSIT_INVENTORY_BUTTON = 12582941;
    private static final int WIDGET_DEPOSIT_EQUIPMENT_BUTTON = 12582942;
    private static final int SCRIPT_CHATBOX_ENTERED = 681;

    @Override
    protected void startUp() throws Exception {
        collectionLogWidgetSubscriber.startUp();
        log.info("GIM hub started!");
    }

    @Override
    protected void shutDown() throws Exception {
        collectionLogWidgetSubscriber.shutDown();
        log.info("GIM hub stopped!");
    }

    @Schedule(period = SECONDS_BETWEEN_UPLOADS, unit = ChronoUnit.SECONDS, asynchronous = true)
    public void submitToApi() {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        String playerName = client.getLocalPlayer().getName();
        dataManager.submitToApi(playerName);
    }

    @Schedule(period = SECONDS_BETWEEN_INFREQUENT_DATA_CHANGES, unit = ChronoUnit.SECONDS)
    public void updateThingsThatDoNotChangeOften() {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        state.achievementRepository.update(client);
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        final int varpId = event.getVarpId();
        final int varbitId = event.getVarbitId();

        state.itemRepository.onVarbitChanged(client, varpId, varbitId, itemManager);
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        state.activityRepository.updateInteracting(client);
        state.activityRepository.updateResources(client);
        state.activityRepository.updateLocation(client);

        state.itemRepository.onGameTick(client, itemManager);

        // It seems onGameTick runs after all other subscribed callbacks, so this is a good spot to stage all the state
        // changes.
        dataManager.stageForSubmitToAPI();
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        state.activityRepository.updateSkills(client);
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        ItemContainer container = event.getItemContainer();
        state.itemRepository.onItemContainerChanged(container, itemManager);
    }

    @Subscribe
    private void onScriptPostFired(ScriptPostFired event) {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        final boolean enteredChatbox = event.getScriptId() == SCRIPT_CHATBOX_ENTERED;
        final boolean depositBoxWidgetIsOpen = client.getWidget(InterfaceID.BankDepositbox.INVENTORY) != null;
        if (enteredChatbox && depositBoxWidgetIsOpen) {
            state.itemRepository.onDepositTriggered();
        }
    }

    @Subscribe
    private void onMenuOptionClicked(MenuOptionClicked event) {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null) return;

        final int param1 = event.getParam1();
        final MenuAction menuAction = event.getMenuAction();
        final boolean depositButtonWasClicked = menuAction == MenuAction.CC_OP
                && (param1 == WIDGET_DEPOSIT_ITEM_BUTTON
                        || param1 == WIDGET_DEPOSIT_INVENTORY_BUTTON
                        || param1 == WIDGET_DEPOSIT_EQUIPMENT_BUTTON);
        if (depositButtonWasClicked) {
            state.itemRepository.onDepositTriggered();
        }
    }

    @Subscribe
    private void onInteractingChanged(InteractingChanged event) {
        PlayerState state = dataManager.getMaybeResetState(client);
        if (state == null || event.getSource() != client.getLocalPlayer()) return;

        state.activityRepository.updateInteracting(client);
    }

    @Provides
    GimHubConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(GimHubConfig.class);
    }
}

package gimhub.achievement;

import gimhub.APISerializable;
import java.util.Map;
import net.runelite.api.Client;

public class AchievementRepository {
    public QuestsProgress quests = null;
    public DiariesProgress diaries = null;

    public void update(Client client) {
        quests = new QuestsProgress(client);
        diaries = new DiariesProgress(client);
    }

    public void flatten(Map<String, APISerializable> flat) {
        flat.put("quests", quests);
        flat.put("diary_vars", diaries);
    }
}

package gimhub.achievement;

import gimhub.APISerializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import net.runelite.api.Client;

public class DiariesProgress implements APISerializable {
    private static final Integer[][] DIARY_VARPS = {
        {1196, 1197}, // Ardougne
        {1198, 1199}, // Desert
        {1186, 1187}, // Falador
        {1184, 1185}, // Fremennik
        {1178, 1179}, // Kandarin
        {1200}, // Karamja Elite
        {2085, 2086}, // Kourend & Kebos
        {1194, 1195}, // Lumbridge & Draynor
        {1180, 1181}, // Morytania
        {1176, 1177}, // Varrock
        {1182, 1183}, // Western Provinces
        {1192, 1193} // Wilderness
    };
    private static final List<Integer> diaryVarpIDsInAPIOrder =
            Arrays.stream(DIARY_VARPS).flatMap(Arrays::stream).collect(Collectors.toUnmodifiableList());

    private static final Integer[][] DIARY_VARBITS = {
        {3566, 3567, 3568, 3569, 3570, 3571, 3572, 3573, 3574, 3575}, // Karamja Easy
        {
            3579, 3580, 3581, 3582, 3583, 3584, 3596, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3597,
            3585
        }, // Karamja Medium
        {3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609} // Karamja Hard
    };
    private static final List<Integer> diaryVarbitIDsInAPIOrder =
            Arrays.stream(DIARY_VARBITS).flatMap(Arrays::stream).collect(Collectors.toUnmodifiableList());

    private final ArrayList<Integer> diaryVarValues;

    public DiariesProgress(Client client) {
        diaryVarValues = new ArrayList<>();
        for (Integer varpID : diaryVarpIDsInAPIOrder) {
            diaryVarValues.add(client.getVarpValue(varpID));
        }

        for (Integer varbitID : diaryVarbitIDsInAPIOrder) {
            diaryVarValues.add(client.getVarbitValue(varbitID));
        }
    }

    @Override
    public Object serialize() {
        return diaryVarValues;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof DiariesProgress)) return false;

        DiariesProgress other = (DiariesProgress) o;
        return other.diaryVarValues.equals(diaryVarValues);
    }
}

package gimhub.achievement;

import gimhub.APISerializable;
import java.util.*;
import java.util.stream.Collectors;
import net.runelite.api.Client;
import net.runelite.api.Quest;

public class QuestsProgress implements APISerializable {
    private final Map<Integer, net.runelite.api.QuestState> questStateMap;

    private static final List<Integer> sortedQuestIDs =
            Arrays.stream(Quest.values()).map(Quest::getId).sorted().collect(Collectors.toUnmodifiableList());

    public QuestsProgress(Client client) {
        this.questStateMap = new HashMap<>();
        for (Quest quest : Quest.values()) {
            questStateMap.put(quest.getId(), quest.getState(client));
        }
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof QuestsProgress)) return false;

        QuestsProgress other = (QuestsProgress) o;

        return other.questStateMap.equals(questStateMap);
    }

    @Override
    public Object serialize() {
        List<Integer> result = new ArrayList<>(questStateMap.size());
        for (Integer questId : sortedQuestIDs) {
            result.add(questStateMap.get(questId).ordinal());
        }

        return result;
    }
}

package gimhub;

import gimhub.achievement.AchievementRepository;
import gimhub.activity.ActivityRepository;
import gimhub.items.ItemRepository;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.config.RuneScapeProfileType;

@Slf4j
@Singleton
public class DataManager {
    // Managed by the Client thread

    private PlayerState state = null;
    private FlatState flatMostRecent = null;

    // Shared by both threads

    private final AtomicReference<FlatState> flatRef = new AtomicReference<>();

    // Managed by the request thread

    private FlatState flatFromFailedRequest = null;

    @Inject
    private HttpRequestService httpRequestService;

    @Inject
    private CollectionLogManager collectionLogManager;

    @Inject
    private GimHubConfig config;

    @Inject
    private ApiUrlBuilder apiUrlBuilder;

    private boolean isMemberInGroup = false;
    private int skipNextNAttempts = 0;

    /** Our tracked state of the player: their stats, items, location, etc. */
    public static class PlayerState {
        public final String ownedPlayer;
        public final ActivityRepository activityRepository;
        public final ItemRepository itemRepository;
        public final AchievementRepository achievementRepository;

        private FlatState flatten() {
            Map<String, APISerializable> flat = new HashMap<>();

            activityRepository.flatten(flat);
            itemRepository.flatten(flat);
            achievementRepository.flatten(flat);

            flat.entrySet().removeIf(e -> e.getValue() == null);

            return new FlatState(ownedPlayer, flat);
        }

        PlayerState(String ownedPlayer) {
            this.ownedPlayer = ownedPlayer;
            this.activityRepository = new ActivityRepository();
            this.itemRepository = new ItemRepository();
            this.achievementRepository = new AchievementRepository();
        }
    }

    /** PlayerState flattened but not yet serialized, in a form that allows easier diffing by key-value-pairs. */
    private static class FlatState {
        @Getter
        private final String ownedPlayer;

        private final Map<String, APISerializable> fields;

        public static FlatState combineWithPriority(FlatState priority, FlatState defaults) {
            final boolean samePlayer = priority.ownedPlayer.equals(defaults.ownedPlayer);
            if (!samePlayer) {
                return new FlatState(priority.ownedPlayer, new HashMap<>(priority.fields));
            }

            Map<String, APISerializable> mergedFields = new HashMap<>(defaults.fields);
            mergedFields.putAll(priority.fields);

            return new FlatState(priority.ownedPlayer, mergedFields);
        }

        public static FlatState diffKeepChangedFields(FlatState newer, FlatState older) {
            final boolean samePlayer = newer.ownedPlayer.equals(older.ownedPlayer);
            if (!samePlayer) {
                return new FlatState(newer.ownedPlayer, new HashMap<>(newer.fields));
            }

            Map<String, APISerializable> fieldsThatChanged = new HashMap<>(newer.fields);

            for (Entry<String, APISerializable> entry : older.fields.entrySet()) {
                APISerializable newerValue = fieldsThatChanged.get(entry.getKey());
                APISerializable olderValue = entry.getValue();

                if (newerValue != null && newerValue.equals(olderValue)) {
                    fieldsThatChanged.remove(entry.getKey());
                }
            }

            return new FlatState(newer.ownedPlayer, fieldsThatChanged);
        }

        public Map<String, Object> serialize() {
            Map<String, Object> serialized = fields.entrySet().stream()
                    .collect(Collectors.toMap(Entry::getKey, e -> e.getValue().serialize()));
            serialized.put("name", ownedPlayer);
            return serialized;
        }

        FlatState(String player, Map<String, APISerializable> fields) {
            this.ownedPlayer = player;
            this.fields = fields;
        }
    }

    /**
     * Call from Client thread. Get the PlayerState to then write updates to. Checks the passed client to see if the
     * player changes and is valid (logged in, not seasonal, etc.). If the player name changes, then the state is reset
     * before being returned.
     *
     * @return The current valid PlayerState, or null if the Player is invalid.
     */
    @Nullable public PlayerState getMaybeResetState(Client client) {
        final boolean isStandardProfile = RuneScapeProfileType.getCurrent(client) == RuneScapeProfileType.STANDARD;
        final boolean isValidPlayerLoggedIn = client.getGameState() == GameState.LOGGED_IN
                && client.getLocalPlayer() != null
                && client.getLocalPlayer().getName() != null;

        if (!isValidPlayerLoggedIn || !isStandardProfile) {
            return null;
        }

        final String player = client.getLocalPlayer().getName();
        if (state == null || !state.ownedPlayer.equals(player)) {
            state = new PlayerState(player);
        }

        return state;
    }

    /** Call from the Client thread. Releases state updates to the request thread. */
    public void stageForSubmitToAPI() {
        FlatState full = state.flatten();
        FlatState trimmed = full;

        if (flatMostRecent != null && trimmed.ownedPlayer.equals(flatMostRecent.ownedPlayer)) {
            trimmed = FlatState.diffKeepChangedFields(trimmed, flatMostRecent);
        }
        flatMostRecent = full;

        // Carry forward the updates that the submission thread has not yet consumed.

        FlatState notYetSubmitted = flatRef.get();
        FlatState combined = trimmed;
        if (notYetSubmitted != null) {
            combined = FlatState.combineWithPriority(trimmed, notYetSubmitted);
        }

        final boolean raceOccurred = !flatRef.compareAndSet(notYetSubmitted, combined);
        if (!raceOccurred) {
            return;
        }

        if (!flatRef.compareAndSet(null, trimmed)) {
            log.error("Another thread wrote to flatRef.");
        }
    }

    /**
     * Call from the request thread. Performs all our network requests and authentication for posting player data to the
     * configured server. If playerName does not match the state we are given, this method aborts.
     *
     * @param playerName The player name to expect updates for.
     */
    public void submitToApi(String playerName) {
        if (skipNextNAttempts-- > 0) return;

        String groupToken = config.authorizationToken().trim();

        if (groupToken.isEmpty()) return;

        if (!isMemberInGroup) {
            isMemberInGroup = fetchIsMember(groupToken, playerName);
        }

        if (!isMemberInGroup) {
            log.debug("Skip POST: not a member. Backing off.");
            skipNextNAttempts = 10;
            return;
        }

        String url = apiUrlBuilder.getUpdateGroupMemberUrl();
        if (url == null) {
            log.debug("Skip POST: Update Group Member URL is null (check base URL and group name).");
            return;
        }

        FlatState flat = flatRef.get();
        if (flat == null || !flat.ownedPlayer.equals(playerName)) {
            // The Client thread changed players.
            // We exit and wait for next time since we don't know how out-of-date flat is.
            log.debug("Skip POST: Player changed. Backing off.");
            return;
        }
        flatRef.compareAndSet(flat, null);

        if (flatFromFailedRequest != null && playerName.equals(flatFromFailedRequest.ownedPlayer)) {
            flat = FlatState.combineWithPriority(flat, flatFromFailedRequest);
        }
        flatFromFailedRequest = null;

        Map<String, Object> updates = flat.serialize();
        collectionLogManager.consumeState(updates);

        // We require greater than 1 since name field is automatically included
        if (updates.size() <= 1) {
            log.debug("Skip POST: no changes to send (fields={})", updates.size());
            return;
        }

        HttpRequestService.HttpResponse response = httpRequestService.post(url, groupToken, updates);

        if (!response.isSuccessful()) {
            skipNextNAttempts = 10;
            if (response.getCode() == 422) {
                isMemberInGroup = false;
            }
            flatFromFailedRequest = flat;
            return;
        }

        collectionLogManager.clearClogItems();
    }

    private boolean fetchIsMember(String groupToken, String playerName) {
        String url = apiUrlBuilder.getMembershipCheckUrl(playerName);
        if (url == null) {
            log.debug("Skip POST: Membership Check URL is null (check base URL and group name).");
            return false;
        }

        return httpRequestService.get(url, groupToken).isSuccessful();
    }
}

package gimhub;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("GimHub")
public interface GimHubConfig extends Config {
    @ConfigSection(
            name = "Group config",
            description = "Enter the group details you created on the website here.",
            position = 0)
    String GROUP_SECTION = "GroupSection";

    @ConfigSection(
            name = "Self hosted config",
            description = "Configure your connection to a self hosted server.",
            position = 1,
            closedByDefault = true)
    String CONNECTION_SECTION = "ConnectionSection";

    @ConfigItem(
            keyName = "groupName",
            name = "Group name (on the website)",
            description = "This is the group name you provided on the website when creating your group.",
            section = GROUP_SECTION)
    default String groupName() {
        return "";
    }

    @ConfigItem(
            keyName = "groupToken",
            name = "Group token",
            description =
                    "Secret token for your group provided by the website. Get this from the member which created the group on the site, or create a new one by visiting the site.",
            secret = true,
            section = GROUP_SECTION)
    default String authorizationToken() {
        return "";
    }

    @ConfigItem(
            keyName = "baseUrlOverride",
            name = "Server base URL override (leave blank to use public server)",
            description =
                    "Overrides the public server URL used to send data. Only change this if you are hosting your own server.",
            section = CONNECTION_SECTION)
    default String baseUrlOverride() {
        return "";
    }
}

package gimhub;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class ApiUrlBuilder {
    @Inject
    private GimHubConfig config;

    @Inject
    private HttpRequestService httpRequestService;

    public String getUpdateGroupMemberUrl() {
        String baseUrl = httpRequestService.getBaseUrl();
        String groupName = getGroupName();

        if (baseUrl == null || groupName == null) return null;

        return String.format("%s/api/group/%s/update-group-member", baseUrl, groupName);
    }

    public String getMembershipCheckUrl(String playerName) {
        String baseUrl = httpRequestService.getBaseUrl();
        String groupName = getGroupName();

        if (baseUrl == null || groupName == null) return null;

        return String.format("%s/api/group/%s/am-i-in-group?member_name=%s", baseUrl, groupName, playerName);
    }

    private String getGroupName() {
        String groupName = config.groupName().trim();

        return groupName.isEmpty() ? null : groupName;
    }
}

package gimhub;

import com.google.gson.Gson;
import java.io.IOException;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLiteProperties;
import okhttp3.*;

@Slf4j
@Singleton
public class HttpRequestService {
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private static final String USER_AGENT = "GIM-hub/RuneLite/" + RuneLiteProperties.getVersion();
    private static final String PUBLIC_BASE_URL = "https://gim-hub.com";

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private GimHubConfig config;

    @Inject
    private Gson gson;

    public HttpResponse get(String url, String authToken) {
        Request request = buildRequest(url, authToken).get().build();

        return executeRequest(request, "GET", url, null);
    }

    public HttpResponse post(String url, String authToken, Object requestBody) {
        String requestJson = gson.toJson(requestBody);
        RequestBody body = RequestBody.create(JSON, requestJson);

        Request request = buildRequest(url, authToken).post(body).build();

        return executeRequest(request, "POST", url, requestJson);
    }

    private Request.Builder buildRequest(String url, String authToken) {
        Request.Builder requestBuilder = new Request.Builder().url(url).header("User-Agent", USER_AGENT);

        if (isInternalUrl(url)) {
            if (authToken != null && !authToken.trim().isEmpty()) {
                requestBuilder.header("Authorization", authToken);
            }
            requestBuilder.header("Accept", "application/json");
        }

        return requestBuilder;
    }

    private boolean isInternalUrl(String url) {
        return url.startsWith(getBaseUrl());
    }

    private HttpResponse executeRequest(Request request, String method, String url, String requestBody) {
        Call call = okHttpClient.newCall(request);

        try (Response response = call.execute()) {
            String responseBody = readBodySafe(response);
            logRequest(method, url, requestBody, response, responseBody);

            return new HttpResponse(response.isSuccessful(), response.code(), responseBody);
        } catch (IOException ex) {
            log.warn("{} {} failed: {}", method, url, ex.toString());

            return new HttpResponse(false, -1, ex.getMessage());
        }
    }

    private void logRequest(String method, String url, String requestBody, Response response, String responseBody) {
        if (!log.isDebugEnabled()) {
            return;
        }

        switch (method) {
            case "GET":
                log.debug("GET {} -> {}\nResponse: {}", url, response.code(), responseBody);
                break;
            case "POST":
                log.debug("POST {}\nRequest: {}\nResponse({}): {}", url, requestBody, response.code(), responseBody);
                break;
            default:
                log.debug("{} {} -> {}\nResponse: {}", method, url, response.code(), responseBody);
        }
    }

    private static String readBodySafe(Response response) {
        try {
            ResponseBody responseBody = response.body();

            return responseBody != null ? responseBody.string() : "<no body>";
        } catch (Exception e) {
            return "<unavailable: " + e.getMessage() + ">";
        }
    }

    public String getBaseUrl() {
        String baseUrlOverride = config.baseUrlOverride().trim();
        if (!baseUrlOverride.isEmpty()) {
            return baseUrlOverride;
        }
        return PUBLIC_BASE_URL;
    }

    @Getter
    public static class HttpResponse {
        private final boolean successful;
        private final int code;
        private final String body;

        public HttpResponse(boolean successful, int code, String body) {
            this.successful = successful;
            this.code = code;
            this.body = body;
        }
    }
}

package gimhub;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class CollectionLogManager {
    // item id -> quantity
    private final Map<Integer, Integer> clogItems = new HashMap<>();

    public synchronized void storeClogItem(int itemId, int quantity) {
        if (quantity <= 0) return;
        clogItems.put(itemId, quantity);
    }

    public synchronized void consumeState(Map<String, Object> updates) {
        if (clogItems.isEmpty()) return;

        List<Integer> result = new ArrayList<>(clogItems.size() * 2);
        for (Map.Entry<Integer, Integer> item : clogItems.entrySet()) {
            result.add(item.getKey());
            result.add(item.getValue());
        }
        updates.put("collection_log_v2", result);
    }

    public synchronized void clearClogItems() {
        clogItems.clear();
    }

    @Subscribe
    public synchronized void onGameStateChanged(GameStateChanged ev) {
        if (ev.getGameState() != GameState.LOGGED_IN) {
            clogItems.clear();
        }
    }
}

package gimhub;

public interface APISerializable {
    Object serialize();
}

package gimhub.items;

import gimhub.APISerializable;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.client.game.ItemManager;

@Slf4j
public class ItemsUnordered implements APISerializable {
    private final Map<Integer, Integer> itemsQuantityByID;

    public ItemsUnordered() {
        this.itemsQuantityByID = new HashMap<>();
    }

    protected ItemsUnordered(ItemsUnordered other) {
        itemsQuantityByID = new HashMap<>(other.itemsQuantityByID);
    }

    public ItemsUnordered(ItemsOrdered items) {
        this.itemsQuantityByID = new HashMap<>();

        if (items == null) {
            return;
        }

        for (final ItemContainerItem item : items.getItems()) {
            final int itemID = item.getId();
            final int quantity = itemsQuantityByID.getOrDefault(itemID, 0) + item.getQuantity();
            itemsQuantityByID.put(itemID, quantity);
        }
    }

    public ItemsUnordered(ItemContainer container, ItemManager itemManager) {
        itemsQuantityByID = new HashMap<>();
        Item[] contents = container.getItems();
        for (final Item item : contents) {
            if (!ItemsUtilities.isItemValid(item, itemManager)) {
                continue;
            }

            final int itemID = itemManager.canonicalize(item.getId());
            final int quantity = itemsQuantityByID.getOrDefault(itemID, 0) + item.getQuantity();
            itemsQuantityByID.put(itemID, quantity);
        }
    }

    public static ItemsUnordered add(ItemsUnordered left, ItemsUnordered right) {
        if (left == null && right == null) {
            return new ItemsUnordered();
        }

        if (left == null) {
            return new ItemsUnordered(right);
        }

        if (right == null) {
            return new ItemsUnordered(left);
        }

        ItemsUnordered result = new ItemsUnordered();

        final Set<Integer> combinedKeys = Stream.concat(
                        left.itemsQuantityByID.keySet().stream(), right.itemsQuantityByID.keySet().stream())
                .collect(Collectors.toSet());
        for (final Integer itemID : combinedKeys) {
            final int quantity =
                    left.itemsQuantityByID.getOrDefault(itemID, 0) + right.itemsQuantityByID.getOrDefault(itemID, 0);

            result.itemsQuantityByID.put(itemID, quantity);
        }

        return result;
    }

    public static ItemsUnordered subtract(ItemsUnordered left, ItemsUnordered right) {
        if (left == null) {
            return new ItemsUnordered();
        }

        if (right == null) {
            return new ItemsUnordered(left);
        }

        ItemsUnordered result = new ItemsUnordered();

        // Only the keys in the LHS matter, since otherwise the subtraction is always negative.
        for (final Map.Entry<Integer, Integer> entry : left.itemsQuantityByID.entrySet()) {
            final int itemID = entry.getKey();
            if (itemID <= 0) {
                continue;
            }

            final int lhs = entry.getValue();
            final int rhs = right.itemsQuantityByID.getOrDefault(itemID, 0);

            final int subtraction = lhs - rhs;
            if (subtraction <= 0) {
                continue;
            }

            result.itemsQuantityByID.put(itemID, subtraction);
        }

        return result;
    }

    public Object serialize() {
        List<Integer> result = new ArrayList<>(itemsQuantityByID.size() * 2);

        for (final Map.Entry<Integer, Integer> entry : itemsQuantityByID.entrySet()) {
            result.add(entry.getKey());
            result.add(entry.getValue());
        }

        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof ItemsUnordered)) return false;
        ItemsUnordered other = (ItemsUnordered) o;
        return other.itemsQuantityByID.equals(this.itemsQuantityByID);
    }
}

package gimhub.items;

import gimhub.APISerializable;
import java.util.ArrayList;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.client.game.ItemManager;

@Slf4j
public class ItemsOrdered implements APISerializable {
    private final List<ItemContainerItem> items;

    public ItemsOrdered(Iterable<Item> container, ItemManager itemManager) {
        this.items = new ArrayList<>();

        for (final Item item : container) {
            if (!ItemsUtilities.isItemValid(item, itemManager)) {
                items.add(new ItemContainerItem(0, 0));
            } else {
                items.add(new ItemContainerItem(itemManager.canonicalize(item.getId()), item.getQuantity()));
            }
        }
    }

    /**
     * Specifying the size is required, since Runescape does not pad inventory and equipment. For example, if you do not
     * have ammo equipped, the equipment ItemContainer will have 13 items instead of 14 as we require.
     */
    public ItemsOrdered(ItemContainer container, ItemManager itemManager, int size) {
        this.items = new ArrayList<>();

        for (int i = 0; i < size; i++) {
            Item item = container.getItem(i);

            if (!ItemsUtilities.isItemValid(item, itemManager)) {
                items.add(new ItemContainerItem(0, 0));
            } else {
                items.add(new ItemContainerItem(itemManager.canonicalize(item.getId()), item.getQuantity()));
            }
        }
    }

    public Iterable<ItemContainerItem> getItems() {
        return items;
    }

    public Object serialize() {
        List<Integer> result = new ArrayList<>(items.size() * 2);

        for (ItemContainerItem item : items) {
            result.add(item.getId());
            result.add(item.getQuantity());
        }

        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof ItemsOrdered)) return false;
        ItemsOrdered other = (ItemsOrdered) o;
        return other.items.equals(items);
    }
}

package gimhub.items;

import gimhub.APISerializable;
import gimhub.items.containers.*;
import java.util.Map;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.client.game.ItemManager;

public class ItemRepository {
    private final TrackedItemContainer[] containers;

    public ItemRepository() {
        final InventoryItems inventory = new InventoryItems();
        final EquipmentItems equipment = new EquipmentItems();

        containers = new TrackedItemContainer[] {
            inventory,
            equipment,
            new SharedBankItems(),
            new BankItems(),
            new PotionStorageItems(),
            new SeedVaultItems(),
            new PohCostumeRoomItems(),
            new RunePouchItems(),
            new QuiverItems(),
            new DepositedItems(inventory, equipment),
        };
    }

    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        for (TrackedItemContainer tracked : containers) {
            tracked.onItemContainerChanged(container, itemManager);
        }
    }

    public void onVarbitChanged(Client client, int varpId, int varbitId, ItemManager itemManager) {
        for (TrackedItemContainer tracked : containers) {
            tracked.onVarbitChanged(client, varpId, varbitId, itemManager);
        }
    }

    public void onGameTick(Client client, ItemManager itemManager) {
        for (TrackedItemContainer tracked : containers) {
            tracked.onGameTick(client, itemManager);
        }
    }

    public void onDepositTriggered() {
        for (TrackedItemContainer tracked : containers) {
            tracked.onDepositTriggered();
        }
    }

    public void flatten(Map<String, APISerializable> flat) {
        for (TrackedItemContainer tracked : containers) {
            flat.put(tracked.key(), tracked.get());
        }
    }
}

package gimhub.items;

import lombok.Getter;

public class ItemContainerItem {
    @Getter
    public final int id;

    @Getter
    public final int quantity;

    public ItemContainerItem(int id, int quantity) {
        this.id = id;
        this.quantity = quantity;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof ItemContainerItem)) return false;
        ItemContainerItem other = (ItemContainerItem) o;

        return other.id == id && other.quantity == quantity;
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsOrdered;
import lombok.Getter;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.game.ItemManager;

@Getter
public class EquipmentItems implements TrackedItemContainer {
    public static final int SIZE = 14;

    private ItemsOrdered items = null;

    @Override
    public String key() {
        return "equipment";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        if (container.getId() == InventoryID.WORN) {
            items = new ItemsOrdered(container, itemManager, SIZE);
        }
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsUnordered;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.game.ItemManager;

public class SeedVaultItems implements TrackedItemContainer {
    private ItemsUnordered items = null;

    @Override
    public String key() {
        return "seed_vault";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        if (container.getId() == InventoryID.SEED_VAULT) {
            items = new ItemsUnordered(container, itemManager);
        }
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsUnordered;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.game.ItemManager;

public class BankItems implements TrackedItemContainer {
    private ItemsUnordered items = null;

    @Override
    public String key() {
        return "bank";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        if (container.getId() == InventoryID.BANK) {
            items = new ItemsUnordered(container, itemManager);
        }
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsUnordered;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;

public class SharedBankItems implements TrackedItemContainer {
    private static final int WIDGET_GROUP_STORAGE_LOADER_PARENT = 293;
    private static final int WIDGET_GROUP_STORAGE_LOADER_TEXT_CHILD = 1;

    private ItemsUnordered committed = null;
    private ItemsUnordered uncommitted = null;

    @Override
    public String key() {
        return "shared_bank";
    }

    @Override
    public APISerializable get() {
        return committed;
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        if (container.getId() == InventoryID.INV_GROUP_TEMP) {
            uncommitted = new ItemsUnordered(container, itemManager);
        }
    }

    @Override
    public void onGameTick(Client client, ItemManager itemManager) {
        Widget groupStorageLoaderText =
                client.getWidget(WIDGET_GROUP_STORAGE_LOADER_PARENT, WIDGET_GROUP_STORAGE_LOADER_TEXT_CHILD);
        if (groupStorageLoaderText != null && groupStorageLoaderText.getText().equalsIgnoreCase("saving...")) {
            committed = uncommitted;
            uncommitted = null;
        }
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsUnordered;
import net.runelite.api.ItemContainer;
import net.runelite.client.game.ItemManager;

public class PohCostumeRoomItems implements TrackedItemContainer {
    private static final int INVENTORY_ID_COSTUME_ROOM = 33405;

    private ItemsUnordered items = null;

    @Override
    public String key() {
        return "poh_costume_room";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        if (container.getId() == INVENTORY_ID_COSTUME_ROOM) {
            items = new ItemsUnordered(container, itemManager);
        }
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsOrdered;
import lombok.Getter;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.game.ItemManager;

@Getter
public class InventoryItems implements TrackedItemContainer {
    public static final int SIZE = 28;

    private ItemsOrdered items = null;

    @Override
    public String key() {
        return "inventory";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        if (container.getId() == InventoryID.INV) {
            items = new ItemsOrdered(container, itemManager, SIZE);
        }
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsOrdered;
import java.util.ArrayList;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.game.ItemManager;

public class QuiverItems implements TrackedItemContainer {
    private ItemsOrdered items = null;

    @Override
    public String key() {
        return "quiver";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    private static boolean isRelevantVarp(int varpId) {
        return varpId == VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO || varpId == VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO_AMOUNT;
    }

    private void update(Client client, ItemManager itemManager) {
        final ArrayList<Item> quiverItems = new ArrayList<>();
        quiverItems.add(new Item(
                client.getVarpValue(VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO),
                client.getVarpValue(VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO_AMOUNT)));
        items = new ItemsOrdered(quiverItems, itemManager);
    }

    @Override
    public void onVarbitChanged(Client client, int varpId, int varbitId, ItemManager itemManager) {
        if (isRelevantVarp(varpId)) {
            update(client, itemManager);
        }
    }

    @Override
    public void onGameTick(Client client, ItemManager itemManager) {
        update(client, itemManager);
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsOrdered;
import java.util.ArrayList;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.Item;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;

public class RunePouchItems implements TrackedItemContainer {
    private ItemsOrdered items = null;

    @Override
    public String key() {
        return "rune_pouch";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    private static boolean isRelevantVarbit(int varbitId) {
        return varbitId == VarbitID.RUNE_POUCH_TYPE_1
                || varbitId == VarbitID.RUNE_POUCH_QUANTITY_1
                || varbitId == VarbitID.RUNE_POUCH_TYPE_2
                || varbitId == VarbitID.RUNE_POUCH_QUANTITY_2
                || varbitId == VarbitID.RUNE_POUCH_TYPE_3
                || varbitId == VarbitID.RUNE_POUCH_QUANTITY_3
                || varbitId == VarbitID.RUNE_POUCH_TYPE_4
                || varbitId == VarbitID.RUNE_POUCH_QUANTITY_4;
    }

    private void update(Client client, ItemManager itemManager) {
        final EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
        final ArrayList<Item> runepouchItems = new ArrayList<>();
        runepouchItems.add(new Item(
                runepouchEnum.getIntValue(client.getVarbitValue(VarbitID.RUNE_POUCH_TYPE_1)),
                client.getVarbitValue(VarbitID.RUNE_POUCH_QUANTITY_1)));
        runepouchItems.add(new Item(
                runepouchEnum.getIntValue(client.getVarbitValue(VarbitID.RUNE_POUCH_TYPE_2)),
                client.getVarbitValue(VarbitID.RUNE_POUCH_QUANTITY_2)));
        runepouchItems.add(new Item(
                runepouchEnum.getIntValue(client.getVarbitValue(VarbitID.RUNE_POUCH_TYPE_3)),
                client.getVarbitValue(VarbitID.RUNE_POUCH_QUANTITY_3)));
        runepouchItems.add(new Item(
                runepouchEnum.getIntValue(client.getVarbitValue(VarbitID.RUNE_POUCH_TYPE_4)),
                client.getVarbitValue(VarbitID.RUNE_POUCH_QUANTITY_4)));
        items = new ItemsOrdered(runepouchItems, itemManager);
    }

    @Override
    public void onVarbitChanged(Client client, int varpId, int varbitId, ItemManager itemManager) {
        if (isRelevantVarbit(varbitId)) {
            update(client, itemManager);
        }
    }

    @Override
    public void onGameTick(Client client, ItemManager itemManager) {
        update(client, itemManager);
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsOrdered;
import gimhub.items.ItemsUnordered;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.game.ItemManager;

public class DepositedItems implements TrackedItemContainer {
    private static final int GAME_TICKS_FOR_DEPOSIT_DETECTION = 2;

    private final InventoryItems inventory;
    private final EquipmentItems equipment;

    private ItemsUnordered deposited = null;
    private ItemsUnordered inventoryPreDeposit = null;
    private ItemsUnordered equipmentPreDeposit = null;

    private int gameTicksToLogDeposits = 0;

    public DepositedItems(InventoryItems inventory, EquipmentItems equipment) {
        this.inventory = inventory;
        this.equipment = equipment;
    }

    @Override
    public String key() {
        return "deposited";
    }

    @Override
    public APISerializable get() {
        return deposited;
    }

    @Override
    public void onDepositTriggered() {
        final boolean isAlreadyChecking = gameTicksToLogDeposits > 0;
        if (!isAlreadyChecking) {
            inventoryPreDeposit = new ItemsUnordered(getInventory());
            equipmentPreDeposit = new ItemsUnordered(getEquipment());
        }
        gameTicksToLogDeposits = GAME_TICKS_FOR_DEPOSIT_DETECTION;
    }

    @Override
    public void onGameTick(Client client, ItemManager itemManager) {
        if (gameTicksToLogDeposits > 0) {
            --gameTicksToLogDeposits;
        }
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        final int id = container.getId();

        if (id == InventoryID.BANK) {
            deposited = null;
            return;
        }

        if (gameTicksToLogDeposits <= 0) {
            return;
        }

        if (id == InventoryID.INV || id == InventoryID.WORN) {
            updateDeposited();
        }
    }

    private ItemsOrdered getInventory() {
        return inventory.getItems();
    }

    private ItemsOrdered getEquipment() {
        return equipment.getItems();
    }

    private void updateDeposited() {
        final ItemsUnordered depositedEquipment =
                ItemsUnordered.subtract(equipmentPreDeposit, new ItemsUnordered(getEquipment()));
        final ItemsUnordered depositedItems =
                ItemsUnordered.subtract(inventoryPreDeposit, new ItemsUnordered(getInventory()));
        deposited = ItemsUnordered.add(depositedEquipment, depositedItems);
    }
}

package gimhub.items.containers;

import gimhub.APISerializable;
import net.runelite.api.Client;
import net.runelite.api.ItemContainer;
import net.runelite.client.game.ItemManager;

public interface TrackedItemContainer {
    String key();

    APISerializable get();

    default void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {}

    default void onVarbitChanged(Client client, int varpId, int varbitId, ItemManager itemManager) {}

    default void onGameTick(Client client, ItemManager itemManager) {}

    default void onDepositTriggered() {}
}

package gimhub.items.containers;

import gimhub.APISerializable;
import gimhub.items.ItemsOrdered;
import gimhub.items.ItemsUnordered;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;

public class PotionStorageItems implements TrackedItemContainer {
    private static final int POTION_STORE_WIDGET = 786484;
    private static final int VARP_VIALS_IN_POTION_STORAGE = 4286;
    private static final int ITEM_VIAL = 229;

    private static final int ENUM_POTIONS_1 = 4826;
    private static final int ENUM_POTIONS_2 = 4829;
    private static final int SCRIPT_POTION_STORE_GET_DOSES = 3750;

    private ItemsUnordered items = null;

    private boolean dirty = true;
    private Set<Integer> potionStoreVarps = null;

    @Override
    public String key() {
        return "potion_storage";
    }

    @Override
    public APISerializable get() {
        return items;
    }

    @Override
    public void onItemContainerChanged(ItemContainer container, ItemManager itemManager) {
        if (container.getId() == InventoryID.POTION_STORE_TEMP_INV) {
            dirty = true;
        }
    }

    @Override
    public void onVarbitChanged(Client client, int varpId, int varbitId, ItemManager itemManager) {
        if (potionStoreVarps != null && potionStoreVarps.contains(varpId)) {
            dirty = true;
        }
    }

    @Override
    public void onGameTick(Client client, ItemManager itemManager) {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        final Widget widget = client.getWidget(POTION_STORE_WIDGET);
        if (widget == null) {
            // RuneLite invalidates the cached potions when the bank interface unloads.
            items = null;
            return;
        }

        if (potionStoreVarps == null) {
            final int[] triggers = widget.getVarTransmitTrigger();
            if (triggers != null) {
                potionStoreVarps = new HashSet<>();
                for (final int t : triggers) {
                    potionStoreVarps.add(t);
                }
            }
        }

        if (!dirty) {
            return;
        }

        dirty = false;
        items = readPotionStorage(client, itemManager);
    }

    private static ItemsUnordered readPotionStorage(Client client, ItemManager itemManager) {
        final List<Item> result = new ArrayList<>();

        final int vials = client.getVarpValue(VARP_VIALS_IN_POTION_STORAGE);
        if (vials > 0) {
            result.add(new Item(ITEM_VIAL, vials));
        }

        for (final int potionsEnumId : new int[] {ENUM_POTIONS_1, ENUM_POTIONS_2}) {
            final EnumComposition potionsEnum = client.getEnum(potionsEnumId);
            if (potionsEnum == null || potionsEnum.getIntVals() == null) {
                continue;
            }

            for (final int potionEnumId : potionsEnum.getIntVals()) {
                final EnumComposition potionEnum = client.getEnum(potionEnumId);
                if (potionEnum == null) {
                    continue;
                }

                client.runScript(SCRIPT_POTION_STORE_GET_DOSES, potionEnumId);
                int doses = client.getIntStack()[0];

                if (doses <= 0) {
                    continue;
                }

                for (int dose = 4; dose >= 1 && doses > 0; dose--) {
                    final int itemId = potionEnum.getIntValue(dose);
                    if (itemId <= 0) {
                        continue;
                    }

                    final int quantity = doses / dose;
                    if (quantity == 0) {
                        continue;
                    }

                    doses -= quantity * dose;
                    result.add(new Item(itemId, quantity));
                }
            }
        }

        return new ItemsUnordered(new ItemsOrdered(result, itemManager));
    }
}

package gimhub.items;

import net.runelite.api.Item;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;

public final class ItemsUtilities {
    private ItemsUtilities() {}

    public static boolean isItemValid(Item item, ItemManager itemManager) {
        if (item == null) return false;
        final int id = item.getId();
        final int quantity = item.getQuantity();
        if (itemManager != null) {
            final boolean isPlaceholder = itemManager.getItemComposition(id).getPlaceholderTemplateId() != -1;

            return id >= 0 && quantity >= 0 && !isPlaceholder;
        }
        return false;
    }

    public static boolean isQuiver(int varpID) {
        return varpID == VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO || varpID == VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO_AMOUNT;
    }

    public static boolean isRunePouch(int varbitID) {
        return varbitID == VarbitID.RUNE_POUCH_TYPE_1
                || varbitID == VarbitID.RUNE_POUCH_QUANTITY_1
                || varbitID == VarbitID.RUNE_POUCH_TYPE_2
                || varbitID == VarbitID.RUNE_POUCH_QUANTITY_2
                || varbitID == VarbitID.RUNE_POUCH_TYPE_3
                || varbitID == VarbitID.RUNE_POUCH_QUANTITY_3
                || varbitID == VarbitID.RUNE_POUCH_TYPE_4
                || varbitID == VarbitID.RUNE_POUCH_QUANTITY_4;
    }
}

package gimhub;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GimHubPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(GimHubPlugin.class);
        RuneLite.main(args);
    }
}

