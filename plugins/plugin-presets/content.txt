/*
 * Copyright (c) 2021, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.file.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import javax.swing.SwingUtilities;

import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import static java.nio.file.StandardOpenOption.*;

@Slf4j
public class PluginPresetsStorage
{
	private static final File PRESETS_DIR = PluginPresetsPlugin.PRESETS_DIR;
	private static final File LOCK_FILE = new File(PRESETS_DIR, "lock");

	private final List<String> failedFileNames = new ArrayList<>();
	private final PluginPresetsPlugin plugin;

	@Inject
	private Gson gson;
	
	private Thread thread;
	private WatchService watcher;

	@Inject
	public PluginPresetsStorage(PluginPresetsPlugin plugin)
	{
		this.plugin = plugin;
	}

	private FileLock lock() {
		try {
			// wait until the lock file is free
			while (LOCK_FILE.exists()) {
				// writing the plugin preset files should only take a few ms
				// if the lock file is more than 5sec old then we assume it's an artifact from a previous run
				// this can happen in the event runelite crashes or is killed vai external process
				if(Instant.now().toEpochMilli() - LOCK_FILE.lastModified() > 5000) {
					LOCK_FILE.delete();
				} else {
					TimeUnit.MILLISECONDS.sleep(50);
				}
			}

			FileChannel channel = FileChannel.open(LOCK_FILE.toPath(), CREATE_NEW, SYNC, WRITE);
			return channel.lock();
		} catch (IOException | InterruptedException e) {
			log.warn("Failed to lock file");
		}
		return null;
	}

	private void unlock(FileLock lock) {
		if(lock == null) {
			log.warn("lock is null"); // probably caused by ending runelite via task manager
			LOCK_FILE.delete();
			return;
		}

		try {
			lock.release();
			LOCK_FILE.delete();
		} catch (IOException e) {
			log.warn("Failed to release lock file");
		}
	}

	private boolean isLockFile(File file) {
		try {
			return LOCK_FILE.exists() && Files.isSameFile(file.toPath(), LOCK_FILE.toPath());
		} catch (IOException e) {
			log.warn(String.format("Failed compare file to lock file, %s", e.toString()));
		}
		return false;
	}

	private static File createNewPresetFileWithCustomSuffix(final PluginPreset pluginPreset, final int fileNumber)
	{
		return new File(PRESETS_DIR, String.format("%s (%d).json", pluginPreset.getName(), fileNumber));
	}

	public static void createPresetFolder()
	{
		final boolean presetFolderWasCreated = PRESETS_DIR.mkdirs();

		if (presetFolderWasCreated)
		{
			log.info(String.format("Preset folder created at %s", PRESETS_DIR.getAbsolutePath()));
		}
	}

	public void deletePresetFolderIfEmpty()
	{
		if (PRESETS_DIR.exists() && Objects.requireNonNull(PRESETS_DIR.listFiles()).length > 0)
		{
			return;
		}

		deletePresetFolder();
	}

	private void deletePresetFolder()
	{
		boolean folderDeleted = PRESETS_DIR.delete();

		if (!folderDeleted)
		{
			log.warn(String.format("Could not delete %s", PRESETS_DIR.getName()));
		}
	}

	public void savePresets(final List<PluginPreset> pluginPresets)
	{
		synchronized (LOCK_FILE) {
			FileLock lock = lock();
			clearPresetFolder();
			pluginPresets.forEach(this::storePluginPresetToJsonFile);
			unlock(lock);
		}
	}

	private void clearPresetFolder()
	{
		for (File file : Objects.requireNonNull(PRESETS_DIR.listFiles()))
		{
			// Don't delete invalid files,
			// those could be e.g. v1 style presets or some syntax failed presets
			if (!failedFileNames.contains(file.getName()) && !isLockFile(file))
			{
				deleteFile(file);
			}
		}
	}

	private void deleteFile(File file)
	{
		final boolean fileWasDeleted = file.delete();
		if (!fileWasDeleted)
		{
			log.warn(String.format("Could not delete %s", file.getName()));
		}
	}

	@SneakyThrows
	private void storePluginPresetToJsonFile(final PluginPreset pluginPreset)
	{
		// Only store local presets
		if (!pluginPreset.getLocal())
		{
			return;
		}

		File presetJsonFile = getPresetJsonFileFrom(pluginPreset);

		if (presetJsonFile.exists())
		{
			presetJsonFile = giveJsonFileCustomSuffixNumber(pluginPreset, presetJsonFile);
		}

		writePresetDataToJsonFile(pluginPreset, presetJsonFile);
	}

	private File getPresetJsonFileFrom(final PluginPreset pluginPreset)
	{
		return new File(PRESETS_DIR, String.format("%s.json", pluginPreset.getName()));
	}

	private File giveJsonFileCustomSuffixNumber(final PluginPreset pluginPreset, File presetJsonFile)
	{
		int fileNumber = 1;
		while (presetJsonFile.exists())
		{
			presetJsonFile = createNewPresetFileWithCustomSuffix(pluginPreset, fileNumber);
			fileNumber++;
		}
		return presetJsonFile;
	}

	private void writePresetDataToJsonFile(final PluginPreset pluginPreset, final File presetJsonFile)
	{
		pluginPreset.setLocal(null); // Don't store status value to file

		try (Writer writer = new FileWriter(presetJsonFile))
		{
			gson.toJson(pluginPreset, writer);
		}
		catch (Exception e)
		{
			// Ignore
		}
		finally
		{
			pluginPreset.setLocal(true);
		}

	}

	public List<PluginPreset> loadPresets() throws IOException
	{
		ArrayList<Long> loadedIds = new ArrayList<>();
		List<PluginPreset> pluginPresetsFromFolder = new ArrayList<>();
		synchronized (LOCK_FILE) {
			FileLock lock = lock();

			failedFileNames.clear();
			for (File file : Objects.requireNonNull(PRESETS_DIR.listFiles()))
			{
				if (file.isFile() && !isLockFile(file))
				{
					PluginPreset pluginPreset = parsePluginPresetFrom(file);

					if (pluginPreset != null)
					{
						long id = pluginPreset.getId();
						if (!(loadedIds.contains(id)))
						{
							pluginPreset.setLocal(true);
							pluginPresetsFromFolder.add(pluginPreset);
							loadedIds.add(id);
						}
					}
					else
					{
						failedFileNames.add(file.getName());
					}
				}
			}

			unlock(lock);
		}
		return pluginPresetsFromFolder;
	}

	private PluginPreset parsePluginPresetFrom(final File file) throws IOException
	{
		PluginPreset newPreset;

		try (Reader reader = new FileReader(file))
		{
			newPreset = gson.fromJson(reader, new TypeToken<PluginPreset>()
			{
			}.getType());
		}
		catch (JsonSyntaxException | FileNotFoundException e)
		{
			log.warn(String.format("Failed to load preset from %s, %s", file.getAbsolutePath(), e.getMessage()));
			return null;
		}

		if (isMalformedPluginPreset(newPreset))
		{
			log.warn(String.format("Plugin Preset data is malformed in file and could not be loaded %s, %s", file.getAbsolutePath(), newPreset));
			return null;
		}

		return newPreset;
	}

	private boolean isMalformedPluginPreset(PluginPreset newPreset)
	{
		return newPreset.getName() == null || newPreset.getPluginConfigs() == null;
	}

	public PluginPreset parsePluginPresetFrom(String string)
	{
		PluginPreset newPreset;

		try
		{
			newPreset = gson.fromJson(string, new TypeToken<PluginPreset>()
			{
			}.getType());
		}
		catch (JsonSyntaxException e)
		{
			return null;
		}

		if (newPreset == null || newPreset.getName() == null || newPreset.getPluginConfigs() == null)
		{
			return null;
		}

		return newPreset;
	}

	/**
	 * Starts thread that runs method that watches preset folder for file changes that do preset refresh.
	 */
	public void watchFolderChanges()
	{
		thread = new Thread(this::watchFolder);
		thread.setName("PresetFolderWatcher");
		thread.start();
	}

	public void stopWatcher()
	{
		thread.interrupt();
		try
		{
			watcher.close();
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
		watcher = null;
		thread = null;
	}

	public void watchFolder()
	{
		Path presetDir = PRESETS_DIR.toPath();

		try
		{
			watcher = presetDir.getFileSystem().newWatchService();
			presetDir.register(
				watcher,
				StandardWatchEventKinds.ENTRY_CREATE,
				StandardWatchEventKinds.ENTRY_DELETE,
				StandardWatchEventKinds.ENTRY_MODIFY
			);
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}

		while (watcher != null)
		{
			WatchKey wk;
			if (!thread.isAlive())
			{
				return;
			}

			try
			{
				wk = watcher.take();
			}
			catch (InterruptedException e)
			{
				Thread.currentThread().interrupt();
				return;
			}

			// test to see if any files other than the lock file were modified
			boolean change = false;
			for(WatchEvent<?> event : wk.pollEvents()) {
				WatchEvent<Path> path = (WatchEvent<Path>) event;
				change = !path.context().toString().equals(LOCK_FILE.getName());
				if(change){
					break;
				}
			}

			// if any plugin preset files were modified then run the update
			// we lock here to ensure that all updates happen before we reload
			if(change) {
				synchronized (LOCK_FILE) {
					FileLock lock = lock();
					wk.pollEvents(); // clear all events
					SwingUtilities.invokeLater(plugin::refreshPresets); // Refresh
					unlock(lock);
				}
			}
			boolean valid = wk.reset();
			if (!valid)
			{
				break;
			}
		}
	}
}
/*
 * Copyright (c) 2021, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import com.google.common.base.Strings;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import java.util.List;
import java.util.regex.Pattern;
import org.apache.commons.text.WordUtils;

public class PluginPresetsUtils
{
	/**
	 * Checks whether given string is valid for a preset filename.
	 */
	public static boolean stringContainsInvalidCharacters(final String string)
	{
		return !(Pattern.compile("(?i)^[ a-ö0-9-_.,;=()+!]+$").matcher(string).matches());
	}

	/**
	 * Split from uppercase letters and capitalize
	 */
	public static String splitAndCapitalize(final String string)
	{
		return WordUtils.capitalize(string.replaceAll("\\W", "").replaceAll("(.)([A-Z])", "$1 $2"));
	}

	/**
	 * Add commas to list of strings.
	 *
	 * @param plugins list of strings
	 * @return list of string append with commas
	 */
	public static String pluginListToString(List<String> plugins)
	{
		StringBuilder message = new StringBuilder(plugins.get(0));
		for (int i = 1; i < plugins.size(); i++)
		{
			if (i == plugins.size() - 1)
			{
				message.append(" and ").append(plugins.get(i));
				break;
			}

			message.append(", ");

			if (i % 4 == 0)
			{
				message.append("\n");
			}

			message.append(plugins.get(i));
		}

		if (plugins.size() == 1)
		{
			return message + " plugin.";
		}
		else
		{
			return message + " plugins.";
		}
	}

	public static String getClipboardText()
	{
		final String clipboardText;
		try
		{
			clipboardText = Toolkit.getDefaultToolkit()
				.getSystemClipboard()
				.getData(DataFlavor.stringFlavor)
				.toString();
		}
		catch (IOException | UnsupportedFlavorException ignore)
		{
			return null;
		}

		if (Strings.isNullOrEmpty(clipboardText))
		{
			return null;
		}

		return clipboardText;
	}

	public static String createNameWithSuffixIfNeeded(String name, List<PluginPreset> pluginPresets)
	{
		int duplicates = 0;
		for (PluginPreset preset : pluginPresets)
		{
			if (preset.getName().contains(name))
			{
				duplicates++;
			}
		}

		if (duplicates > 0)
		{
			boolean endWithSuffix = name.length() > 2 && name.charAt((name.length() - 2)) == '(' && name.endsWith(")");
			if (endWithSuffix)
			{
				return String.format("%s (%d)", name.substring(0, name.length() - 3), duplicates);
			}
			else
			{
				return String.format("%s (%d)", name, duplicates);
			}
		}
		else
		{
			return name;
		}
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableMap;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.pluginpresets.ui.PluginPresetsPluginPanel;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.SneakyThrows;
import net.runelite.api.GameState;
import net.runelite.api.events.FocusChanged;
import net.runelite.api.events.GameStateChanged;
import static net.runelite.client.RuneLite.RUNELITE_DIR;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.Keybind;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ExternalPluginsChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

@PluginDescriptor(
	name = "Plugin Presets",
	description = "Create presets of your plugin configurations.",
	tags = {"preset", "setups", "plugins"}
)
public class PluginPresetsPlugin extends Plugin
{
	public static final File PRESETS_DIR = new File(RUNELITE_DIR, "presets");
	public static final String HELP_LINK = "https://github.com/antero111/plugin-presets/wiki/General-Features#using-plugin-presets";
	public static final String DEFAULT_PRESET_NAME = "Preset";
	static final List<String> IGNORED_PLUGINS = Stream.of("Plugin Presets", "Configuration", "Xtea").collect(Collectors.toList());
	/**
	 * Non-user configurable settings that don't contain any context or user
	 * sensitive data that should not to be saved to presets
	 */
	static final List<String> IGNORED_KEYS = Stream.of("channel", "oauth", "username", "notesData", "tzhaarStartTime", "tzhaarLastTime", "chatsData", "previousPartyId", "lastWorld", "tab", "position").collect(Collectors.toList());
	private static final String PLUGIN_NAME = "Plugin Presets";
	private static final String ICON_FILE = "panel_icon.png";
	private static final String CONFIG_GROUP = "pluginpresets";
	private static final String CONFIG_KEY_PRESETS = "presets";
	private static final String CONFIG_KEY_AUTO_UPDATE = "autoUpdate";

	@Getter
	private final List<PluginPreset> pluginPresets = new ArrayList<>();

	private final KeyListener keybindListener = new KeyListener()
	{
		@Override
		public void keyTyped(KeyEvent e)
		{
			// Ignore
		}

		@Override
		public void keyPressed(KeyEvent e)
		{
			PluginPreset preset = keybindManager.getPresetFor(new Keybind(e));
			if (preset != null)
			{
				loadPreset(preset);
			}
		}

		@Override
		public void keyReleased(KeyEvent e)
		{
			// Ignore
		}
	};

	@Getter
	@Inject
	private CurrentConfigurations currentConfigurations;

	@Getter
	@Inject
	private CustomSettingsManager customSettingsManager;

	@Getter
	@Inject
	private KeybindManager keybindManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	@Inject
	private KeyManager keyManager;

	private NavigationButton navigationButton;

	private PluginPresetsPluginPanel pluginPanel;

	@Getter
	@Inject
	private PluginPresetsPresetManager presetManager;

	@Inject
	private PluginPresetsStorage presetStorage;

	@Getter
	@Setter
	private PluginPresetsPresetEditor presetEditor;

	@Getter
	@Setter
	private PluginPresetsPresetEditor autoUpdater;

	@Getter
	private Boolean loggedIn = false; // Used to inform that keybinds don't work in login screen

	private Boolean loadingPreset = false;

	@Setter
	private String errorMessage;

	@Getter
	@Setter
	private Boolean focusChangedPaused = false;

	@Override
	protected void startUp()
	{
		PluginPresetsStorage.createPresetFolder();
		pluginPanel = new PluginPresetsPluginPanel(this);

		loadPresets();
		updateCurrentConfigurations();
		setupAutoUpdater();
		savePresets();
		rebuildPluginUi();

		presetStorage.watchFolderChanges();

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), ICON_FILE);
		navigationButton = NavigationButton.builder()
			.tooltip(PLUGIN_NAME)
			.priority(8)
			.icon(icon)
			.panel(pluginPanel)
			.popup(ImmutableMap
				.<String, Runnable>builder()
				.put("Open preset folder...", () -> LinkBrowser.open(PRESETS_DIR.toString()))
				.build())
			.build();
		clientToolbar.addNavigation(navigationButton);

		keyManager.registerKeyListener(keybindListener);
	}

	@Override
	protected void shutDown()
	{
		pluginPresets.clear();
		keybindManager.clearKeybinds();
		autoUpdater = null;

		presetStorage.stopWatcher();
		clientToolbar.removeNavigation(navigationButton);
		keyManager.unregisterKeyListener(keybindListener);
		presetStorage.deletePresetFolderIfEmpty();

		pluginPanel = null;
		presetEditor = null;
		navigationButton = null;
	}

	@Subscribe
	public void onExternalPluginsChanged(ExternalPluginsChanged externalPluginsChanged)
	{
		updateCurrentConfigurations();
		SwingUtilities.invokeLater(this::rebuildPluginUi);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (validConfigChange(configChanged) && !loadingPreset)
		{
			// When profile changes, multiple onConfigChanged events are
			// fired and we don't want to update configurations multiple times since it
			// hangs the client.
			// Current configurations updater filters these out with update interval
			// timestamp.
			boolean updated = updateCurrentConfigurations();
			if (updated)
			{
				if (autoUpdater != null)
				{
					SwingUtilities.invokeLater(autoUpdater::updateAllModified);
				}
				else
				{
					SwingUtilities.invokeLater(this::rebuildPluginUi);
				}
			}
		}
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged)
	{
		SwingUtilities.invokeLater(this::refreshPresets);
	}

	/**
	 * Updates current configurations from RuneLite config.
	 *
	 * @return true if configurations were updated
	 */
	public boolean updateCurrentConfigurations()
	{
		Boolean updated = currentConfigurations.update();
		if (updated) keybindManager.setCurrentConfigurations(currentConfigurations);
		return updated;
	}

	private boolean validConfigChange(ConfigChanged configChanged)
	{
		return !(configChanged.getKey().equals("pluginpresetsplugin")
			|| configChanged.getGroup().equals("pluginpresets"));
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		loggedIn = event.getGameState() == GameState.LOGGED_IN;
		SwingUtilities.invokeLater(this::rebuildPluginUi);
	}

	@Subscribe
	public void onFocusChanged(FocusChanged focusChanged)
	{
		if (!focusChangedPaused)
		{
			boolean focused = focusChanged.isFocused();
			for (PluginPreset preset : pluginPresets)
			{
				Boolean loadOnFocus = preset.getLoadOnFocus();
				if (loadOnFocus != null && loadOnFocus == focused)
				{
					loadPreset(preset);
				}
			}
		}
	}

	public void updateConfig()
	{
		List<PluginPreset> syncPresets = pluginPresets.stream()
			.filter(preset -> !preset.getLocal())
			.collect(Collectors.toList());

		syncPresets.forEach(preset -> preset.setLocal(null));

		if (syncPresets.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_PRESETS);
		}
		else
		{
			final String json = gson.toJson(syncPresets);
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_PRESETS, json);
		}

		syncPresets.forEach(preset -> preset.setLocal(false));

		// If all presets are saved to config, do a refresh since...
		// ...presetStorage folder watcher does not recognize any file change and
		// doesn't refresh presets.
		if (syncPresets.size() == pluginPresets.size())
		{
			refreshPresets();
		}
	}

	private void loadConfig(String json)
	{
		if (Strings.isNullOrEmpty(json))
		{
			return;
		}

		final List<PluginPreset> configPresetData = gson.fromJson(json, new TypeToken<ArrayList<PluginPreset>>()
		{
		}.getType());

		configPresetData.forEach(preset -> preset.setLocal(false));
		pluginPresets.addAll(configPresetData);
	}

	public void createPreset(String presetName, boolean empty)
	{
		boolean noName = presetName.equals("");
		boolean invalidName = !noName && PluginPresetsUtils.stringContainsInvalidCharacters(presetName);
		if (noName || invalidName)
		{
			presetName = PluginPresetsPlugin.DEFAULT_PRESET_NAME + " " + (pluginPresets.size() + 1);
			if (invalidName)
			{
				errorMessage = "Preset name contained invalid characters.";
			}
		}

		PluginPreset preset = presetManager.createPluginPreset(presetName);
		if (!empty)
		{
			preset.setPluginConfigs(currentConfigurations.getPluginConfigs());
		}

		pluginPresets.add(preset);

		savePresets();
	}

	/**
	 * Saves presets to preset folder and RuneLite config.
	 * Changes in preset directory or config causes refreshPresets() to run.
	 */
	@SneakyThrows
	public void savePresets()
	{
		presetStorage.savePresets(pluginPresets);
		updateConfig();
	}

	/**
	 * Clears presets from memory, loads them again and then rebuilds ui.
	 */
	public void refreshPresets()
	{
		pluginPresets.clear();
		loadPresets();
		rebuildPluginUi();

		if (errorMessage != null)
		{
			renderPanelErrorNotification(errorMessage);
			errorMessage = null;
		}
	}

	/**
	 * Loads preset and updates current configurations.
	 */
	@SneakyThrows
	public void loadPreset(final PluginPreset preset)
	{
		// if (preset.match(currentConfigurations))
		// {
		// 	disablePreset(preset);
		// }

		loadingPreset = true;

		// Auto updater gets disabled if preset doesn't match
		if (autoUpdater != null && !autoUpdater.getEditedPreset().match(preset))
		{
			setAutoUpdatedPreset(null);
		}

		presetManager.loadPreset(preset, () -> {
			loadingPreset = false;

			updateCurrentConfigurations();
			rebuildPluginUi();

			// When preset has loaded, turn auto updater on
			if (preset.getAutoUpdated() != null)
			{
				setAutoUpdatedPreset(preset.getId());
			}
		});
	}

	@SneakyThrows
	public void disablePreset(final PluginPreset preset)
	{
		loadingPreset = true;

		presetManager.disablePreset(preset, () -> {
			loadingPreset = false;

			updateCurrentConfigurations();
			rebuildPluginUi();
		});
	}

	public void deletePreset(final PluginPreset preset)
	{
		pluginPresets.remove(preset);
		savePresets();
	}

	/**
	 * Loads presets from preset folder and RuneLite config and adds them to plugin
	 * memory.
	 */
	@SneakyThrows
	public void loadPresets()
	{
		pluginPresets.addAll(presetStorage.loadPresets());
		loadConfig(configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_PRESETS));
		pluginPresets.sort(Comparator.comparing(PluginPreset::getName)); // Keep presets in order
		customSettingsManager.parseCustomSettings(pluginPresets);
		keybindManager.cacheKeybinds(pluginPresets);
	}

	private void setupAutoUpdater()
	{
		String configuration = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_AUTO_UPDATE);
		if (configuration != null)
		{
			long id = Long.parseLong(configuration);
			boolean failed = true;
			for (PluginPreset p : pluginPresets)
			{
				if (p.getId() == id)
				{
					PluginPresetsPresetEditor updater = new PluginPresetsPresetEditor(this, p, currentConfigurations);
					setAutoUpdater(updater);
					failed = false;
				}
			}

			// If auto preset does not exist or it got deleted, unset autoUpdate
			// configuration
			if (failed)
			{
				setAutoUpdatedPreset(null);
			}
			else
			{
				autoUpdater.updateAllModified();
			}
		}
	}

	public void setAutoUpdatedPreset(Long id)
	{
		if (id == null)
		{
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_AUTO_UPDATE);
			setAutoUpdater(null);
			rebuildPluginUi();
		}
		else
		{
			boolean doRefresh = false;
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_AUTO_UPDATE, id);
			for (PluginPreset p : pluginPresets)
			{
				if (p.getId() == id)
				{
					p.setAutoUpdated(true);
					doRefresh = true;
					savePresets();
				}
			}

			setupAutoUpdater();
			if (doRefresh && presetEditor != null)
			{
				presetEditor.syncAutoUpdate();

			}
		}

	}

	public void addAutoUpdateFrom(PluginPreset preset)
	{
		preset.setAutoUpdated(true);
		savePresets();
		rebuildPluginUi();
	}

	public void removeAutoUpdateFrom(PluginPreset preset)
	{
		preset.setAutoUpdated(null);
		savePresets();
		rebuildPluginUi();
	}

	public void importPresetFromClipboard()
	{
		String clipboardText = PluginPresetsUtils.getClipboardText();
		if (clipboardText == null)
		{
			renderPanelErrorNotification("Unable read to clipboard content.");
			return;
		}

		PluginPreset newPreset = presetStorage.parsePluginPresetFrom(clipboardText);
		if (newPreset != null)
		{
			newPreset.setId(Instant.now().toEpochMilli());
			newPreset.setName(PluginPresetsUtils.createNameWithSuffixIfNeeded(newPreset.getName(), pluginPresets));
			newPreset.setLocal(true); // Presets are imported to /presets folder

			pluginPresets.add(newPreset);
			savePresets();
			refreshPresets();
		}
		else
		{
			renderPanelErrorNotification("You do not have any valid presets in your clipboard.");
		}
	}

	public void duplicatePreset(final PluginPreset preset)
	{
		PluginPreset newPreset = new PluginPreset(PluginPresetsUtils.createNameWithSuffixIfNeeded(preset.getName(), pluginPresets));
		newPreset.setPluginConfigs(preset.getPluginConfigs());

		pluginPresets.add(newPreset);
		savePresets();
		refreshPresets();
	}

	public void exportPresetToClipboard(final PluginPreset preset)
	{
		final String json = gson.toJson(preset);
		final StringSelection contents = new StringSelection(json);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(contents, null);
	}

	public void renderPanelErrorNotification(String message)
	{
		pluginPanel.renderNotification(message);
	}

	public void rebuildPluginUi()
	{
		pluginPanel.rebuild();
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import com.google.inject.Inject;
import java.util.List;
import lombok.Getter;
import lombok.Setter;

/**
 * Helper class that retrieves the user's current set of configs periodically
 */
public class CurrentConfigurations
{
	private static final int UPDATE_INTERVAL_MS = 150;

	private final PluginPresetsCurrentConfigManager currentConfigManager;

	@Getter
	@Setter
	private List<PluginConfig> pluginConfigs;

	private Long lastUpdate = null;

	@Inject
	public CurrentConfigurations(PluginPresetsCurrentConfigManager currentConfigManager)
	{
		this.currentConfigManager = currentConfigManager;
	}


	public Boolean update()
	{
		boolean updated = false;
		Long timestamp = System.currentTimeMillis();
		if (lastUpdate == null || timestamp - lastUpdate > UPDATE_INTERVAL_MS)
		{
			setPluginConfigs(currentConfigManager.getCurrentConfigs());
			updated = true;
		}
		lastUpdate = timestamp;
		return updated;
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import java.util.List;
import java.util.stream.Collectors;
import lombok.AllArgsConstructor;
import lombok.Data;

/**
 * The config for an individual plugin within a preset. Contains various PluginSettings.
 *
 * @param name       Name of the plugin configuration
 * @param configName RuneLite config name
 * @param enabled    Configuration sidepanel switch value on/off
 * @param settings   List of saved plugins settings.
 *                   Some plugins don't have any configurable settings e.g. Ammo Plugin, in those cases this will be an empty array.
 */
@Data
@AllArgsConstructor
public class PluginConfig
{
	private String name;
	private String configName;
	private Boolean enabled;
	private List<PluginSetting> settings;

	public Boolean match(PluginConfig presetConfig)
	{
		if (presetConfig == null)
		{
			return false;
		}

		Boolean presetEnabled = presetConfig.getEnabled();
		if ((presetEnabled != null && enabled != null) && !presetEnabled.equals(enabled))
		{
			return false;
		}

		List<PluginSetting> currentSettings = settings;
		// Compare plugin settings from preset to current config settings
		for (PluginSetting presetConfigSetting : presetConfig.getSettings())
		{
			// Get current config setting for compared preset setting
			PluginSetting currentConfigSetting = currentSettings.stream()
				.filter(c ->c.getKey().equals(presetConfigSetting.getKey()))
				.findFirst()
				.orElse(null);

			if (currentConfigSetting != null &&
				presetConfigSetting.getValue() != null &&
				!presetConfigSetting.getValue().equals(currentConfigSetting.getValue()))
			{
				return false;
			}
		}
		return true;
	}

	public PluginSetting getSetting(PluginSetting searchedSetting)
	{
		PluginSetting presetSetting = null;
		if (settings != null)
		{
			for (PluginSetting setting : settings)
			{
				if (setting.getKey().equals(searchedSetting.getKey()))
				{
					presetSetting = setting;
					break;
				}
			}
		}
		return presetSetting;
	}

	public List<String> getSettingKeys()
	{
		return settings.stream().map(PluginSetting::getKey).collect(Collectors.toList());
	}

	public boolean containsCustomSettings()
	{
		for (PluginSetting s : settings)
		{
			if (s.getCustomConfigName() != null)
			{
				return true;
			}
		}
		return false;
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Container storing all custom settings from all plugins across all presets
 */
@Singleton
public class CustomSettingsManager
{
	private final List<CustomSetting> settings;

	@Inject
	public CustomSettingsManager()
	{
		this.settings = new ArrayList<>();
	}

	/**
	 * Finds custom settings for an individual plugin preset.
	 * @param id the id of the preset to match against
	 * @return all matching custom settings
	 */
	public List<CustomSetting> getCustomSettingsFor(long id)
	{
		ArrayList<CustomSetting> customSettingsList = new ArrayList<>();

		settings.forEach(s ->
		{
			if (s.parentPreset.getId() == id)
			{
				customSettingsList.add(s);
			}
		});

		return customSettingsList;
	}

	/**
	 * Finds custom settings for all presets matching a plugin config name.
	 * @param configName the config name of the plugin
	 * @return all matching custom settings
	 */
	public List<CustomSetting> getCustomConfigsFor(String configName)
	{
		ArrayList<CustomSetting> customSettingsList = new ArrayList<>();

		settings.forEach(s ->
		{
			if (s.parentConfig.getConfigName().equals(configName))
			{
				customSettingsList.add(s);
			}
		});

		return customSettingsList;
	}

	/**
	 * Finds and stores custom settings given all plugin presets
	 * @param pluginPresets all the user's presets
	 */
	public void parseCustomSettings(List<PluginPreset> pluginPresets)
	{
		settings.clear();

		pluginPresets.forEach(preset ->
			preset.getPluginConfigs().forEach(configuration ->
				configuration.getSettings().forEach(setting ->
				{
					if (setting.getCustomConfigName() != null)
					{
						CustomSetting customSetting = new CustomSetting(setting, configuration, preset);
						settings.add(customSetting);
					}
				})));
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.config.Keybind;

/**
 * A single preset which contains multiple PluginConfigs, each of which contains various PluginSettings.
 *
 * @param id            Time of creation used as id
 * @param name          Name of the preset
 * @param keybind       Used to enable the preset without the side panel. (Optional)
 * @param local         Used to identify whether the preset is stored in /presets or settings.properties
 * @param loadOnFocus   Used to enable the preset when client is (un)focused (Optional)
 * @param pluginConfigs List of saved plugin configurations.
 */
public class PluginPreset
{
	@Getter
	@Setter
	private long id;

	@Getter
	@Setter
	private String name;

	@Getter
	@Setter
	private Keybind keybind;

	@Getter
	@Setter
	private Boolean local;

	/**
	 * True when loaded on focus and false when loaded on unfocus.
	 */
	@Getter
	@Setter
	private Boolean loadOnFocus;

	/**
	 * Preset gets auto updated automatically on load if true
	 */
	@Getter
	@Setter
	private Boolean autoUpdated;

	@Getter
	@Setter
	private List<PluginConfig> pluginConfigs;

	public PluginPreset(String name)
	{
		this.id = Instant.now().toEpochMilli();
		this.name = name;
		this.keybind = null;
		this.local = true;
		this.loadOnFocus = null;
		this.autoUpdated = null;
		this.pluginConfigs = new ArrayList<>();
	}

	public Boolean match(PluginPreset preset)
	{
		for (PluginConfig presetConfig : pluginConfigs)
		{
			for (PluginConfig comparedConfig : preset.getPluginConfigs())
			{
				if (comparedConfig.getName().equals(presetConfig.getName()))
				{
					if (!presetConfig.match(comparedConfig))
					{
						return false;
					}
				}
			}
		}
		return true;
	}

	public Boolean match(CurrentConfigurations currentConfigurations)
	{
		for (PluginConfig presetConfig : pluginConfigs)
		{
			PluginConfig currentConfig = null;
			for (PluginConfig config : currentConfigurations.getPluginConfigs())
			{
				if (config.getName().equals(presetConfig.getName()))
				{
					currentConfig = config;
					break;
				}
			}

			if (currentConfig == null)
			{
				continue;
			}

			if (presetConfig.getEnabled() != null && !presetConfig.getEnabled().equals(currentConfig.getEnabled()))
			{
				return false;
			}

			List<PluginSetting> currentSettings = currentConfig.getSettings();
			// Compare plugin settings from preset to current config settings
			for (PluginSetting presetConfigSetting : presetConfig.getSettings())
			{
				// Get current config setting for compared preset setting
				PluginSetting currentConfigSetting = currentSettings.stream()
					.filter(c -> c.getKey().equals(presetConfigSetting.getKey()))
					.findFirst()
					.orElse(null);

				if (currentConfigSetting != null &&
					presetConfigSetting.getValue() != null &&
					!presetConfigSetting.getValue().equals(currentConfigSetting.getValue()))
				{
					return false;
				}
			}
		}
		return true;
	}

	public PluginConfig getConfig(final PluginConfig searchedConfig)
	{
		PluginConfig presetConfig = null;
		for (PluginConfig config : pluginConfigs)
		{
			if (config.getName().equals(searchedConfig.getName()))
			{
				presetConfig = config;
				break;
			}
		}
		return presetConfig;
	}

	public boolean isEmpty()
	{
		return pluginConfigs.isEmpty();
	}

	public boolean canBeDisabled()
	{
		for (PluginConfig presetConfig : pluginConfigs)
		{
			if (presetConfig.getEnabled() != null && presetConfig.getEnabled())
			{
				return true;
			}
		}
		return false;
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets.ui;

import com.pluginpresets.PluginConfig;
import com.pluginpresets.PluginPresetsPlugin;
import com.pluginpresets.PluginPresetsPresetEditor;
import com.pluginpresets.PluginPresetsUtils;
import com.pluginpresets.PluginSetting;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

/**
 * Row for editing a single config of a plugin in the current preset
 */
public class ConfigRow extends JPanel
{
	private final PluginSetting currentSetting;
	private final PluginSetting presetSetting;
	private final JLabel customLabel = new JLabel();
	private JCheckBox checkBox = new JCheckBox();
	private final boolean presetHasConfigurations;
	private final PluginPresetsPresetEditor presetEditor;

	public ConfigRow(PluginConfig currentConfig, PluginSetting currentSetting, PluginSetting presetSetting, PluginPresetsPlugin plugin)
	{
		this.currentSetting = currentSetting;
		this.presetSetting = presetSetting;

		presetEditor = plugin.getPresetEditor();

		presetHasConfigurations = presetHasConfigurations();
		boolean configsMatch = configsMatch();

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, 0, 0, 0));

		JLabel title = new JLabel();
		if (currentSetting == null)
		{
			title.setText(PluginPresetsUtils.splitAndCapitalize(presetSetting.getKey()));
			title.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			title.setToolTipText(presetSetting.getKey());
		}
		else if (currentSetting.getName().length() == 0)
		{
			title.setText(PluginPresetsUtils.splitAndCapitalize(currentSetting.getKey()));
			title.setToolTipText(currentSetting.getKey());
		}
		else
		{
			title.setText(currentSetting.getName());
			title.setToolTipText(currentSetting.getName() + " - " + currentSetting.getKey());
		}
		// 0 width is to prevent the title causing the panel to grow in y direction on long setting descriptions
		// 16 height is UPDATE_ICONs height
		title.setPreferredSize(new Dimension(0, 16));
		title.setFont(FontManager.getRunescapeSmallFont());

		if (presetHasConfigurations)
		{
			String customConfigName = presetSetting.getCustomConfigName();
			if (customConfigName != null)
			{
				checkBox = null; // Hide checkbox
				customLabel.setText("remove");
				customLabel.setPreferredSize(new Dimension(38, 16));
				customLabel.setFont(FontManager.getRunescapeSmallFont());
				customLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
				customLabel.setToolTipText("Remove custom setting '" + presetSetting.getName() + "' from preset.");
				customLabel.addMouseListener(new MouseAdapter()
				{
					@Override
					public void mousePressed(MouseEvent mouseEvent)
					{
						int confirm = JOptionPane.showConfirmDialog(customLabel,
							"Are you sure to remove custom setting '" + presetSetting.getName() + "'?",
							"Remove custom setting", JOptionPane.OK_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE);

						if (confirm == 0)
						{
							presetEditor.removeSettingFromEdited(currentConfig, presetSetting);
						}
					}

					@Override
					public void mouseEntered(MouseEvent mouseEvent)
					{
						customLabel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);

					}

					@Override
					public void mouseExited(MouseEvent mouseEvent)
					{
						customLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
					}
				});
			}
			else
			{
				checkBox.setSelected(true);
				checkBox.setToolTipText("Remove '" + presetSetting.getName() + "' from preset.");
				checkBox.addMouseListener(new MouseAdapter()
				{
					@Override
					public void mousePressed(MouseEvent mouseEvent)
					{
						presetEditor.removeSettingFromEdited(currentConfig, presetSetting);
					}
				});
			}

			if (configsMatch)
			{
				title.setForeground(Color.LIGHT_GRAY);
			}
			else
			{
				title.setForeground(ColorScheme.BRAND_ORANGE);
			}
		}
		else if (currentSetting == null)
		{
			checkBox = null; // Hide checkbox
			customLabel.setIcon(Icons.NOTIFICATION_ICON);
			customLabel.setToolTipText("Invalid plugin setting configuration (Click to remove)");
			customLabel.setBorder(new EmptyBorder(2, 0, 2, 0));
			customLabel.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					presetEditor.removeSettingFromEdited(null, presetSetting);
				}

				@Override
				public void mouseEntered(MouseEvent mouseEvent)
				{
					customLabel.setIcon(Icons.NOTIFICATION_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent mouseEvent)
				{
					customLabel.setIcon(Icons.NOTIFICATION_ICON);
				}
			});
		}
		else
		{
			title.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
			checkBox.setSelected(false);
			checkBox.setToolTipText("Add '" + currentSetting.getName() + "' to preset.");
			checkBox.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					presetEditor.addSettingToEdited(currentConfig, currentSetting);
				}
			});
		}

		JLabel customSettingLabel = new JLabel();
		boolean isCustomSetting = (currentSetting != null && currentSetting.getCustomConfigName() != null) || (presetSetting != null && presetSetting.getCustomConfigName() != null);
		if (isCustomSetting)
		{
			customSettingLabel.setText("(Custom)");
			customSettingLabel.setFont(FontManager.getRunescapeSmallFont());
			customSettingLabel.setToolTipText("User added custom setting");
			customSettingLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		}

		JPanel rightActions = new JPanel();
		rightActions.setLayout(new FlowLayout(FlowLayout.LEFT, 14, 0));
		JLabel updateLabel = new JLabel();
		rightActions.add(updateLabel);
		rightActions.add(checkBox == null ? customLabel : checkBox);

		JPanel leftActions = new JPanel();
		leftActions.setLayout(new BorderLayout());
		leftActions.add(title, BorderLayout.CENTER);
		leftActions.add(customSettingLabel, BorderLayout.EAST);

		add(leftActions, BorderLayout.CENTER);
		add(rightActions, BorderLayout.EAST);
	}

	private boolean presetHasConfigurations()
	{
		return currentSetting != null && presetSetting != null;
	}

	private boolean configsMatch()
	{
		return presetHasConfigurations && presetSetting.equals(currentSetting);
	}
}

/*
 * Copyright (c) 2023, antero111 <https://github.com/antero111>
 * Original code that has been since modified here Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets.ui;

import com.pluginpresets.PluginPresetsPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.shadowlabel.JShadowedLabel;
import net.runelite.client.util.LinkBrowser;

public class NoPresetsPanel extends JPanel
{
	private final JLabel wikiLink = new JLabel();

	public NoPresetsPanel()
	{
		setOpaque(false);
		setBorder(new EmptyBorder(50, 10, 0, 10));
		setLayout(new BorderLayout());

		JLabel title = new JShadowedLabel();
		title.setForeground(Color.WHITE);
		title.setHorizontalAlignment(SwingConstants.CENTER);
		title.setText("Plugin Presets");

		JLabel description = new JLabel();
		description.setFont(FontManager.getRunescapeSmallFont());
		description.setBorder(new EmptyBorder(5, 0, 0, 0));

		description.setForeground(Color.GRAY);
		description.setHorizontalAlignment(SwingConstants.CENTER);
		description.setText("<html><body style = 'text-align:center'>Presets of your plugin configurations.</body></html>");

		wikiLink.setFont(FontManager.getRunescapeSmallFont());
		wikiLink.setBorder(new EmptyBorder(10, 0, 0, 0));
		wikiLink.setForeground(Color.GRAY);
		wikiLink.setHorizontalAlignment(SwingConstants.CENTER);
		wikiLink.setIcon(Icons.HELP_ICON);
		wikiLink.setText("<html><body style = 'text-align:center'>See wiki for usage guide.</body></html>");
		wikiLink.setToolTipText("Open Plugin Presets wiki: " + PluginPresetsPlugin.HELP_LINK);
		wikiLink.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				LinkBrowser.browse(PluginPresetsPlugin.HELP_LINK);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				wikiLink.setIcon(Icons.HELP_HOVER_ICON);
				wikiLink.setForeground(Color.GRAY.darker());

			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				wikiLink.setIcon(Icons.HELP_ICON);
				wikiLink.setForeground(Color.GRAY);

			}
		});

		add(title, BorderLayout.NORTH);
		add(description, BorderLayout.CENTER);
		add(wikiLink, BorderLayout.SOUTH);
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets.ui;

import com.pluginpresets.PluginConfig;
import com.pluginpresets.PluginPresetsPlugin;
import com.pluginpresets.PluginPresetsPresetEditor;
import com.pluginpresets.PluginPresetsPresetManager;
import com.pluginpresets.PluginSetting;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

/**
 * Panel for editing a single preset
 */
public class ConfigPanel extends JPanel
{
	private final PluginConfig presetConfig;
	private final PluginConfig currentConfig;
	private final PluginPresetsPlugin plugin;
	private final JLabel updateLabel = new JLabel();
	private final JLabel notificationLabel = new JLabel();
	private final boolean presetHasConfigurations;
	private final boolean external;
	private final boolean configsMatch;
	private final JPanel settings = new JPanel(new GridBagLayout());
	private final List<String> openSettings;
	private final boolean settingsVisible;
	private final PluginPresetsPresetManager presetManager;
	private final PluginPresetsPresetEditor presetEditor;

	public ConfigPanel(PluginConfig currentConfig, PluginConfig presetConfig, PluginPresetsPlugin plugin, List<String> openSettings)
	{
		this.presetConfig = presetConfig;
		this.currentConfig = currentConfig;
		this.plugin = plugin;
		this.openSettings = openSettings;

		presetManager = plugin.getPresetManager();
		presetEditor = plugin.getPresetEditor();

		presetHasConfigurations = presetHasConfigurations();
		configsMatch = currentConfig.match(presetConfig);
		external = isExternalPluginConfig();
		boolean installed = isExternalPluginInstalled();
		settingsVisible = isSettingsVisible();

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, 3, 0, 0));
		JCheckBox checkbox = new JCheckBox();
		checkbox.setBackground(ColorScheme.LIGHT_GRAY_COLOR);

		JLabel title = new JLabel();
		JLabel downArrow = new JLabel();
		title.setText(currentConfig.getName());
		JPopupMenu customSettingPopupMenu = getCustomSettingPopupMenu();
		title.setComponentPopupMenu(customSettingPopupMenu);
		// 0 width is to prevent the title causing the panel to grow in y direction on long plugin names
		// 16 height is UPDATE_ICONs height
		title.setPreferredSize(new Dimension(0, 26));
		title.addMouseListener(new MouseAdapter()
		{
			private Color foreground;

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() != MouseEvent.BUTTON3) // Right click
				{
					toggleSettings();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				foreground = title.getForeground(); // Remember the original foreground color
				title.setForeground(ColorScheme.BRAND_ORANGE);
				if (!settingsVisible)
				{
					downArrow.setIcon(Icons.ARROW_RIGHT_HOVER_ICON);
				}
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				title.setForeground(foreground);
				if (!settingsVisible)
				{
					downArrow.setIcon(Icons.ARROW_RIGHT_ICON);
				}
			}
		});

		JLabel externalNotice = new JLabel();
		if (external)
		{
			externalNotice.setText("(E)");
			externalNotice.setToolTipText("Plugin from Plugin Hub");
			externalNotice.setBorder(new EmptyBorder(0, 3, 0, 0));
			externalNotice.setForeground(ColorScheme.BRAND_ORANGE);
		}

		JLabel partialNotice = new JLabel();
		if (presetHasConfigurations && isPartial())
		{
			partialNotice.setText("(P)");
			partialNotice.setToolTipText("Some settings unticked");
			partialNotice.setBorder(new EmptyBorder(0, 3, 0, 0));
			partialNotice.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		}

		JLabel customNotice = new JLabel();
		if (currentConfig.containsCustomSettings())
		{
			customNotice.setText("(C)");
			customNotice.setToolTipText("Contains custom settings");
			customNotice.setBorder(new EmptyBorder(0, 3, 0, 0));
			customNotice.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		}

		JLabel statusLabel = new JLabel();
		JLabel notInstalledLabel = new JLabel();
		if (presetHasConfigurations)
		{
			checkbox.setSelected(true);
			checkbox.setToolTipText("Remove '" + currentConfig.getName() + "' configurations from the preset.");
			JPopupMenu updateAllPopupMenu = getUpdateAllMenuPopup();
			checkbox.setComponentPopupMenu(updateAllPopupMenu);
			checkbox.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					if (mouseEvent.getButton() != MouseEvent.BUTTON3) // Right click
					{
						presetEditor.removeConfigurationFromEdited(presetConfig);
					}
				}
			});

			if (!configsMatch)
			{
				title.setToolTipText("Your '" + currentConfig.getName() + "' configurations do not match the preset.");

				statusLabel.setText("Modified");
				statusLabel.setForeground(ColorScheme.PROGRESS_INPROGRESS_COLOR);
				statusLabel.setToolTipText("Your '" + currentConfig.getName() + "' configurations do not match the preset.");

				if (settingsVisible)
				{
					statusLabel.setBorder(new EmptyBorder(5, 0, 0, 0));
					updateLabel.setBorder(new EmptyBorder(4, 0, 0, 5));
				}

				updateLabel.setIcon(Icons.UPDATE_ICON);
				updateLabel.setToolTipText("Replace presets '" + currentConfig.getName() + "' configurations with your current configuration.");
				updateLabel.addMouseListener(new MouseAdapter()
				{
					@Override
					public void mousePressed(MouseEvent mouseEvent)
					{
						presetEditor.updateConfigurations(presetConfig, currentConfig);
					}

					@Override
					public void mouseEntered(MouseEvent mouseEvent)
					{
						updateLabel.setIcon(Icons.UPDATE_HOVER_ICON);
					}

					@Override
					public void mouseExited(MouseEvent mouseEvent)
					{
						updateLabel.setIcon(Icons.UPDATE_ICON);
					}
				});
			}
			else
			{
				title.setToolTipText("Your '" + currentConfig.getName() + "' configurations match the preset.");
				title.setForeground(Color.WHITE);
			}

			if (external && !installed)
			{
				title.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);

				notInstalledLabel.setIcon(Icons.NOT_INSTALLED_ICON);
				notInstalledLabel.setToolTipText("Plugin not installed, download from Plugin Hub if you want to use these settings or click to remove.");
				notInstalledLabel.setBorder(new EmptyBorder(5, 0, 0, 4));
				notInstalledLabel.addMouseListener(new MouseAdapter()
				{
					@Override
					public void mousePressed(MouseEvent mouseEvent)
					{
						int confirm = JOptionPane.showConfirmDialog(notInstalledLabel,
							"Are you sure to remove '" + presetConfig.getName() + "' configurations from the preset.",
							"Remove configuration", JOptionPane.OK_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE);

						if (confirm == 0)
						{
							presetEditor.removeConfigurationFromEdited(presetConfig);
						}
					}

					@Override
					public void mouseEntered(MouseEvent mouseEvent)
					{
						notInstalledLabel.setIcon(Icons.NOT_INSTALLED_HOVER_ICON);
					}

					@Override
					public void mouseExited(MouseEvent mouseEvent)
					{
						notInstalledLabel.setIcon(Icons.NOT_INSTALLED_ICON);
					}
				});
			}
		}
		else
		{
			title.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
			title.setToolTipText("This preset does not include any configurations to '" + currentConfig.getName() + "' plugin.");

			checkbox.setSelected(false);
			checkbox.setToolTipText("Add your current '" + currentConfig.getName() + "' configurations to the preset.");
			JPopupMenu updateAllPopupMenu = getUpdateAllMenuPopup();
			checkbox.setComponentPopupMenu(updateAllPopupMenu);
			checkbox.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					if (mouseEvent.getButton() != MouseEvent.BUTTON3) // Right click
					{
						presetEditor.addConfigurationToEdited(currentConfig);
					}
				}
			});
		}

		notificationLabel.setIcon(Icons.NOTIFICATION_ICON);
		notificationLabel.setVisible(false);

		downArrow.setIcon(settingsVisible ? Icons.ARROW_DOWN_ICON : Icons.ARROW_RIGHT_ICON);
		downArrow.addMouseListener(new MouseAdapter()
		{
			private Color foreground;

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				toggleSettings();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				foreground = title.getForeground(); // Remember the original foreground color
				title.setForeground(ColorScheme.BRAND_ORANGE);
				if (!settingsVisible)
				{
					downArrow.setIcon(Icons.ARROW_RIGHT_HOVER_ICON);
				}
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				title.setForeground(foreground);
				if (!settingsVisible)
				{
					downArrow.setIcon(Icons.ARROW_RIGHT_ICON);
				}
			}
		});

		checkbox.setVisible(!settingsVisible && !(external && !installed));

		JPanel leftActions = new JPanel();
		leftActions.setLayout(new BoxLayout(leftActions, BoxLayout.X_AXIS));
		leftActions.add(downArrow);
		leftActions.add(title);
		leftActions.add(externalNotice);
		leftActions.add(partialNotice);
		leftActions.add(customNotice);

		JPanel rightActions = new JPanel();
		rightActions.setLayout(new FlowLayout(FlowLayout.LEFT, 3, 0));
		rightActions.add(statusLabel);
		rightActions.add(notInstalledLabel);
		rightActions.add(notificationLabel);
		rightActions.add(updateLabel);
		rightActions.add(checkbox);

		JPanel topActions = new JPanel(new BorderLayout());
		topActions.add(leftActions, BorderLayout.CENTER);
		topActions.add(rightActions, BorderLayout.EAST);

		if (settingsVisible)
		{
			createSettings();
		}
		settings.setBorder(new EmptyBorder(0, 5, 3, 0));
		settings.setVisible(settingsVisible);

		add(topActions, BorderLayout.NORTH);
		add(settings, BorderLayout.CENTER);
	}

	private void createSettings()
	{
		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		settings.removeAll();

		settings.add(getEnabledRow(), constraints);
		constraints.gridy++;

		// Some plugins don't have settings like Ammo, Account, Emojis etc.
		List<PluginSetting> presetSettings = (presetConfig != null) ? presetConfig.getSettings() : null;

		ArrayList<String> loopedInvalidConfigurations = new ArrayList<>();
		String configName = currentConfig.getConfigName();
		List<String> keys = currentConfig.getSettingKeys();

		currentConfig.getSettings().forEach(currentSetting ->
		{
			PluginSetting presetSetting;
			if (presetHasConfigurations)
			{
				assert presetConfig != null;
				presetSetting = presetConfig.getSetting(currentSetting);
			}
			else
			{
				presetSetting = null;
			}

			if (presetSettings != null && !loopedInvalidConfigurations.contains(configName))
			{
				presetSettings.forEach(setting ->
				{
					boolean invalidSetting = !keys.contains(setting.getKey()) && setting.getCustomConfigName() == null;
					if (invalidSetting)
					{
						settings.add(new ConfigRow(null, null, setting, plugin), constraints);
						constraints.gridy++;

						if (!settingsVisible)
						{
							notificationLabel.setVisible(true);
							notificationLabel.setToolTipText("Preset contains invalid configurations for this plugin");
						}
					}
				});

				loopedInvalidConfigurations.add(configName);
			}
			settings.add(new ConfigRow(currentConfig, currentSetting, presetSetting, plugin), constraints);
			constraints.gridy++;
		});
	}

	private JPanel getEnabledRow()
	{
		JPanel enabledRow = new JPanel(new BorderLayout());

		JLabel title = new JLabel();
		title.setText("Plugin on/off");
		title.setToolTipText("Whether the plugin is disabled or not.");
		// 0 width is to prevent the title causing the panel to grow in y direction on long setting descriptions
		// 16 height is UPDATE_ICONs height
		title.setPreferredSize(new Dimension(0, 16));
		title.setFont(FontManager.getRunescapeSmallFont());

		JCheckBox checkBox = new JCheckBox();
		if (presetHasConfigurations && presetConfig.getEnabled() != null)
		{
			checkBox.setToolTipText("Remove plugin on/off configuration from the preset.");
			checkBox.setSelected(true);
			checkBox.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					presetEditor.removeEnabledFromEdited(currentConfig);
				}
			});

			if (currentConfig.getEnabled().equals(presetConfig.getEnabled()))
			{
				title.setForeground(Color.LIGHT_GRAY);
			}
			else
			{
				title.setForeground(ColorScheme.BRAND_ORANGE);
			}

		}
		else
		{
			title.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
			checkBox.setSelected(false);
			checkBox.setToolTipText("Add plugin on/off configuration to the preset.");
			checkBox.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					presetEditor.addEnabledToEdited(currentConfig);
				}
			});
		}

		JPanel rightActions = new JPanel();
		rightActions.setLayout(new FlowLayout(FlowLayout.LEFT, 14, 0));
		rightActions.add(checkBox);

		enabledRow.add(title, BorderLayout.CENTER);
		enabledRow.add(rightActions, BorderLayout.EAST);

		return enabledRow;
	}

	private boolean isSettingsVisible()
	{
		return openSettings.contains(currentConfig.getName());
	}

	private JPopupMenu getCustomSettingPopupMenu()
	{
		JMenuItem addCustomOption = new JMenuItem();
		addCustomOption.setText("Add custom setting");
		addCustomOption.addActionListener(e -> promptCustomSettingInput());

		JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(2, 2, 2, 0));
		popupMenu.add(addCustomOption);
		return popupMenu;
	}

	private void promptCustomSettingInput()
	{
		String customPresetName = JOptionPane.showInputDialog(ConfigPanel.this,
			"Format: configName.settingKey", currentConfig.getName() + " custom setting", JOptionPane.PLAIN_MESSAGE);

		if (customPresetName != null && customPresetName.length() > 0)
		{
			presetEditor.addCustomSettingToEdited(currentConfig, customPresetName);
		}
	}

	private void toggleSettings()
	{
		String name = currentConfig.getName();
		if (settingsVisible)
		{
			openSettings.remove(name);
		}
		else
		{
			openSettings.add(name);
		}

		plugin.rebuildPluginUi();
	}

	private boolean presetHasConfigurations()
	{
		return presetConfig != null;
	}

	private boolean isExternalPluginConfig()
	{
		return presetManager.isExternalPlugin(currentConfig.getName());
	}

	private boolean isExternalPluginInstalled()
	{
		return external && presetManager.isExternalPluginInstalled(currentConfig.getName());
	}

	private boolean isPartial()
	{
		return presetConfig.getSettings().size() < currentConfig.getSettings().size()
			|| (presetConfig.getEnabled() == null && presetConfig.getSettings().size() > 0);
	}

	private JPopupMenu getUpdateAllMenuPopup()
	{
		JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(2, 2, 2, 0));

		if (configsMatch)
		{
			JMenuItem removeOption = new JMenuItem();
			removeOption.setText("Remove " + currentConfig.getName() + " from all presets");
			removeOption.addActionListener(e -> presetEditor.removeConfigurationFromPresets(currentConfig));
			popupMenu.add(removeOption);
		}
		else
		{
			JMenuItem addOption = new JMenuItem();
			addOption.setText("Add " + currentConfig.getName() + " to all presets");
			addOption.addActionListener(e -> presetEditor.addConfigurationToPresets(currentConfig));
			popupMenu.add(addOption);
		}

		return popupMenu;
	}
}

/*
 * Copyright (c) 2021, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets.ui;

import com.pluginpresets.CurrentConfigurations;
import com.pluginpresets.CustomSetting;
import com.pluginpresets.PluginConfig;
import com.pluginpresets.PluginPreset;
import com.pluginpresets.PluginPresetsPlugin;
import com.pluginpresets.PluginPresetsPresetEditor;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.Box;
import javax.swing.Icon;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.LinkBrowser;

/**
 * Main panel displaying all plugin presets
 */
public class PluginPresetsPluginPanel extends PluginPanel
{
	private final PluginPresetsPlugin plugin;
	private final GridBagConstraints constraints = new GridBagConstraints();
	private final JPanel contentView = new JPanel(new GridBagLayout());
	private final JPanel editPanel = new JPanel(new BorderLayout());
	private final JLabel errorNotification = new JLabel(Icons.NOTIFICATION_ICON);
	private final JLabel helpButton = new JLabel(Icons.HELP_ICON);
	private final JLabel pauseLabel = new JLabel();
	private final JLabel addPreset = new JLabel(Icons.ADD_ICON);
	private final JLabel stopEdit = new JLabel(Icons.ARROW_LEFT_ICON);
	private final JLabel ellipsisMenu = new JLabel(Icons.ELLIPSIS);
	private final JLabel syncLabel = new JLabel();
	private final JLabel updateAll = new JLabel(Icons.REFRESH_ICON);
	private final NoPresetsPanel noPresetsPanel = new NoPresetsPanel();
	private final PluginErrorPanel noContent = new PluginErrorPanel();
	private final JPanel titlePanel = new JPanel(new BorderLayout());
	private final JLabel title = new JLabel();
	private final JLabel editTitle = new JLabel();
	private final IconTextField searchBar = new IconTextField();
	private final String[] filters = new String[]{"All A to Z", "Included", "Not included", "Modified", "Plugin enabled", "Plugin disabled", "Configs match", "Only Plugin Hub"};
	private final List<String> openSettings = new ArrayList<>();
	private final List<PluginConfig> filtered = new ArrayList<>();
	private final JLabel autoUpdateLabel = new JLabel();
	private final JLabel autoUpdate = new JLabel();
	private String filter = filters[0];
	private boolean syncLocal;
	private PluginPreset editedPreset;
	private boolean openPartialConfigs;
	private boolean openAll;
	private MouseAdapter pauseMouseAdapter;
	private MouseAdapter autoUpdateMouseAdapter;

	public PluginPresetsPluginPanel(PluginPresetsPlugin pluginPresetsPlugin)
	{
		super(false);

		this.plugin = pluginPresetsPlugin;

		setLayout(new BorderLayout());

		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(10, 10, 10, 5));

		title.setText("Plugin Presets");
		title.setForeground(Color.WHITE);
		title.setBorder(new EmptyBorder(0, 0, 0, 40));

		JPanel presetActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 3));

		errorNotification.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				errorNotification.setVisible(false);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				errorNotification.setIcon(Icons.NOTIFICATION_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				errorNotification.setIcon(Icons.NOTIFICATION_ICON);
			}
		});

		helpButton.setToolTipText("Open Plugin Presets wiki: " + PluginPresetsPlugin.HELP_LINK);
		helpButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					LinkBrowser.browse(PluginPresetsPlugin.HELP_LINK);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				helpButton.setIcon(Icons.HELP_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				helpButton.setIcon(Icons.HELP_ICON);
			}
		});

		addPreset.setToolTipText("Create new plugin preset");
		JPopupMenu importPopupMenu = getImportMenuPopup();
		addPreset.setComponentPopupMenu(importPopupMenu);
		addPreset.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() != MouseEvent.BUTTON3) // Right click
				{
					promptPresetCreation(true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				addPreset.setIcon(Icons.ADD_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				addPreset.setIcon(Icons.ADD_ICON);
			}
		});

		presetActions.add(errorNotification);
		presetActions.add(pauseLabel);
		presetActions.add(helpButton);
		presetActions.add(addPreset);

		titlePanel.add(title, BorderLayout.WEST);
		titlePanel.add(presetActions, BorderLayout.EAST);

		editTitle.setForeground(Color.WHITE);

		stopEdit.setToolTipText("Back to presets");
		stopEdit.setBorder(new EmptyBorder(0, 0, 0, 10));
		stopEdit.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				stopEdit();
				emptyBar();
				rebuild();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				stopEdit.setIcon(Icons.ARROW_LEFT_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				stopEdit.setIcon(Icons.ARROW_LEFT_ICON);
			}
		});

		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				rebuild();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				rebuild();

			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				rebuild();
			}
		});

		autoUpdateLabel.setText("Auto updated");
		autoUpdateLabel.setToolTipText("This preset automatically runs update all after every config change.");
		autoUpdateLabel.setVisible(false);
		autoUpdateLabel.setFont(FontManager.getRunescapeSmallFont());
		autoUpdateLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		autoUpdateLabel.setBorder(new EmptyBorder(5, 0, 0, 5));

		updateAll.setToolTipText("Update all modified configurations with your current settings.");
		updateAll.setBorder(new EmptyBorder(3, 0, 0, 0));
		updateAll.setText("Update all");
		updateAll.setForeground(Color.WHITE);
		updateAll.setVisible(false);
		updateAll.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				plugin.getPresetEditor().updateAllModified();
				if (plugin.getAutoUpdater() == null && editedPreset.getAutoUpdated() != null)
				{
					plugin.setAutoUpdatedPreset(plugin.getPresetEditor().getEditedPreset().getId());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				updateAll.setIcon(Icons.REFRESH_HOVER_ICON);
				updateAll.setForeground(updateAll.getForeground().darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				updateAll.setIcon(Icons.REFRESH_ICON);
				updateAll.setForeground(Color.WHITE);

			}
		});

		JPanel editActions = new JPanel();
		editActions.add(updateAll);
		editActions.add(autoUpdateLabel);

		JPanel filterWrapper = new JPanel();
		filterWrapper.setAlignmentX(LEFT_ALIGNMENT);

		JComboBox<String> filterDropdown = new JComboBox<>(filters);
		filterDropdown.setFocusable(false);
		filterDropdown.setForeground(Color.WHITE);
		filterDropdown.setToolTipText("Filter configuration listing");
		filterDropdown.addActionListener(this::selectFilter);

		filterWrapper.add(filterDropdown);

		JPanel editActionsWrapper = new JPanel(new BorderLayout());
		editActionsWrapper.setBorder(new EmptyBorder(5, 0, 3, 0));
		editActionsWrapper.add(filterWrapper, BorderLayout.WEST);
		editActionsWrapper.add(editActions, BorderLayout.EAST);

		JPanel searchWrapper = new JPanel(new BorderLayout());
		searchWrapper.add(searchBar, BorderLayout.CENTER);
		searchWrapper.add(editActionsWrapper, BorderLayout.NORTH);

		JPanel rightActions = new JPanel();
		rightActions.setLayout(new FlowLayout(FlowLayout.RIGHT, 5, 0));

		syncLocal = true;
		syncLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					plugin.getPresetEditor().toggleLocal();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				syncLabel.setIcon(syncLocal ? Icons.SYNC_LOCAL_HOVER_ICON : Icons.SYNC_CONFIG_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				syncLabel.setIcon(syncLocal ? Icons.SYNC_LOCAL_ICON : Icons.SYNC_CONFIG_ICON);
			}
		});

		ellipsisMenu.setBorder(new EmptyBorder(0, 5, 0, 10));
		ellipsisMenu.addMouseListener(new MouseAdapter()
		{
			private final JPopupMenu popup = getEllipsisMenuPopup();

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				showPopup(mouseEvent);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				ellipsisMenu.setIcon(Icons.ELLIPSIS_HOVER);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				ellipsisMenu.setIcon(Icons.ELLIPSIS);
			}

			private void showPopup(MouseEvent e)
			{
				popup.show(
					e.getComponent(),
					e.getX(),
					e.getY()
				);
			}
		});

		rightActions.add(syncLabel);
		rightActions.add(autoUpdate);
		rightActions.add(ellipsisMenu);

		editPanel.add(stopEdit, BorderLayout.WEST);
		editPanel.add(editTitle, BorderLayout.CENTER);
		editPanel.add(rightActions, BorderLayout.EAST);
		editPanel.add(searchWrapper, BorderLayout.SOUTH);
		editPanel.setVisible(false);

		northPanel.add(titlePanel, BorderLayout.NORTH);
		northPanel.add(editPanel, BorderLayout.CENTER);

		contentView.setBorder(new EmptyBorder(0, 7, 0, 7));

		JPanel contentWrapper = new JPanel(new BorderLayout());
		contentWrapper.add(contentView, BorderLayout.NORTH);

		JScrollPane scrollableContainer = new JScrollPane(contentWrapper);
		scrollableContainer.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

		noPresetsPanel.setVisible(false);

		add(northPanel, BorderLayout.NORTH);
		add(scrollableContainer, BorderLayout.CENTER);
	}

	private void selectFilter(ActionEvent e)
	{
		JComboBox<String> cb = (JComboBox) e.getSource();
		filter = (String) cb.getSelectedItem();

		rebuild();

		if (filter.equals("Not included"))
		{
			openPartialConfigs();
		}
	}

	public void rebuild()
	{
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		contentView.removeAll();

		boolean editingPreset = plugin.getPresetEditor() != null;

		titlePanel.setVisible(!editingPreset);
		editPanel.setVisible(editingPreset);

		if (editingPreset)
		{
			renderEditView();
		}
		else
		{
			renderPresetView();
		}

		errorNotification.setVisible(false);

		invalidate();
		validate();
		repaint();
	}

	private void renderPresetView()
	{
		for (final PluginPreset preset : plugin.getPluginPresets())
		{
			contentView.add(new PresetPanel(preset, plugin), constraints);
			constraints.gridy++;

			contentView.add(Box.createRigidArea(new Dimension(0, 10)), constraints);
			constraints.gridy++;
		}

		boolean empty = constraints.gridy == 0;
		noPresetsPanel.setVisible(empty);
		helpButton.setVisible(!empty);
		title.setVisible(!empty);
		openSettings.clear();

		if (!empty)
		{
			boolean showPause = showPause();
			pauseLabel.setVisible(showPause);
			if (showPause)
			{
				showFocusPause();
			}
		}

		contentView.add(noPresetsPanel, constraints);
		constraints.gridy++;
	}

	private boolean showPause()
	{
		List<PluginPreset> presets = plugin.getPluginPresets();
		for (PluginPreset p : presets)
		{
			if (p.getLoadOnFocus() != null && !p.getPluginConfigs().isEmpty())
			{
				return true;
			}
		}
		return false;
	}

	private void showFocusPause()
	{
		Boolean paused = plugin.getFocusChangedPaused();
		Icon icon = paused ? Icons.PLAY_ICON : Icons.PAUSE_ICON;
		Icon hoverIcon = paused ? Icons.PLAY_HOVER_ICON : Icons.PAUSE_HOVER_ICON;
		pauseLabel.setIcon(icon);
		pauseLabel.setToolTipText(paused ? "Resume" : "Pause" + " focus preset loading");
		pauseLabel.removeMouseListener(pauseMouseAdapter);
		pauseMouseAdapter = new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				Boolean focusChangedPaused = plugin.getFocusChangedPaused();
				plugin.setFocusChangedPaused(!focusChangedPaused);
				rebuild();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				pauseLabel.setIcon(hoverIcon);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				pauseLabel.setIcon(icon);
			}
		};

		pauseLabel.addMouseListener(pauseMouseAdapter);
	}

	private void renderEditView()
	{
		PluginPresetsPresetEditor presetEditor = plugin.getPresetEditor();
		editedPreset = presetEditor.getEditedPreset();

		setLocalIcon(editedPreset.getLocal());
		editTitle.setText("Editing " + editedPreset.getName());
		searchBar.requestFocusInWindow();

		CurrentConfigurations currentConfigurations = plugin.getCurrentConfigurations();
		List<PluginConfig> configurations = currentConfigurations.getPluginConfigs();

		// Only show custom configs that are saved to edited preset
		filterCustomConfigs(configurations);

		// Add configurations that are in the preset but not in current configurations
		// e.g. preset is from a friend and the preset has settings
		// to some plugin hub plugin that you don't have in your current configs
		addMissingConfigurations(configurations);

		List<String> keywordFilteredConfigNames = filterIfSearchKeyword(configurations)
			.stream().map(PluginConfig::getName)
			.collect(Collectors.toList());

		List<PluginConfig> filteredConfigs = filterConfigurations(filter, configurations);
		List<String> filterConfigNames = filteredConfigs.stream().map(PluginConfig::getName).collect(Collectors.toList());

		plugin.updateCurrentConfigurations();

		if (filteredConfigs.isEmpty() || keywordFilteredConfigNames.isEmpty())
		{
			noContent.setContent(null, "There is nothing to be shown");
			contentView.add(noContent);
			constraints.gridy++;
		}

		int notMatchingConfigs = 0;
		for (final PluginConfig currentConfig : configurations)
		{
			PluginConfig presetConfig = editedPreset.getConfig(currentConfig);

			if (presetConfig != null && !presetConfig.match(currentConfig))
			{
				notMatchingConfigs++;
			}

			if (keywordFilteredConfigNames.contains(currentConfig.getName()) && filterConfigNames.contains(currentConfig.getName()))
			{
				contentView.add(new ConfigPanel(currentConfig, presetConfig, plugin, openSettings), constraints);
				constraints.gridy++;
			}
		}

		boolean modified = notMatchingConfigs > 0;
		setUpdateAllVisibility(modified);
	}

	private void filterCustomConfigs(List<PluginConfig> configurations)
	{
		List<CustomSetting> editedPresetCustomSettings = plugin.getCustomSettingsManager().getCustomSettingsFor(editedPreset.getId());
		List<String> customSettingKeys = editedPresetCustomSettings.stream().map(customSetting -> customSetting.getSetting().getKey()).collect(Collectors.toList());
		configurations.forEach(c -> c.getSettings().removeIf(setting -> setting.getCustomConfigName() != null && !customSettingKeys.contains(setting.getKey())));
	}

	private void addMissingConfigurations(List<PluginConfig> configurations)
	{
		List<String> names = configurations.stream()
			.map(PluginConfig::getName)
			.collect(Collectors.toList());

		for (PluginConfig config : editedPreset.getPluginConfigs())
		{
			if (!names.contains(config.getName()))
			{
				configurations.add(config);
			}
		}
	}

	private void setLocalIcon(Boolean local)
	{
		syncLocal = local;
		if (local)
		{
			syncLabel.setIcon(Icons.SYNC_LOCAL_ICON);
			syncLabel.setText("Local");
			syncLabel.setToolTipText("Stored in presets folder (Click to change)");
		}
		else
		{
			syncLabel.setIcon(Icons.SYNC_CONFIG_ICON);
			syncLabel.setText("Config");
			syncLabel.setToolTipText("Stored in RuneLite config (Click to change)");
		}
	}

	private void setUpdateAllVisibility(boolean modified)
	{
		boolean hasAutoUpdater = plugin.getAutoUpdater() != null;
		boolean thisHasAutoUpdater = hasAutoUpdater && plugin.getAutoUpdater().getEditedPreset().getId() == editedPreset.getId();
		boolean thisAutoUpdated = editedPreset.getAutoUpdated() != null;

		String text = "Automatically run update all on this preset";
		if (thisAutoUpdated)
		{
			if (thisHasAutoUpdater)
			{
				updateAll.setVisible(false);
				autoUpdateLabel.setVisible(true);
			}
			else
			{
				updateAll.setVisible(modified);
				autoUpdateLabel.setVisible(false);
			}
			autoUpdate.setIcon(Icons.ORANGE_REFRESH_ICON);
			text = "Turn auto updating off from this preset";
		}
		else
		{
			updateAll.setVisible(modified);
			autoUpdateLabel.setVisible(false);
			autoUpdate.setIcon(Icons.REFRESH_INACTIVE_ICON);
		}

		autoUpdate.setToolTipText(text);
		autoUpdate.removeMouseListener(autoUpdateMouseAdapter);
		Icon icon = thisAutoUpdated ? Icons.ORANGE_REFRESH_ICON : Icons.REFRESH_INACTIVE_ICON;
		Icon hoverIcon = thisAutoUpdated ? Icons.ORANGE_REFRESH_HOVER_ICON : Icons.REFRESH_HOVER_ICON;
		autoUpdateMouseAdapter = new MouseAdapter()
		{

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					if (thisAutoUpdated)
					{
						if (thisHasAutoUpdater)
						{
							plugin.setAutoUpdatedPreset(null);
						}
						plugin.removeAutoUpdateFrom(plugin.getPresetEditor().getEditedPreset());
					}
					else
					{
						if (modified)
						{
							plugin.addAutoUpdateFrom(plugin.getPresetEditor().getEditedPreset());
						}
						else
						{
							plugin.setAutoUpdatedPreset(plugin.getPresetEditor().getEditedPreset().getId());
						}
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				autoUpdate.setIcon(hoverIcon);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				autoUpdate.setIcon(icon);
			}
		};
		autoUpdate.addMouseListener(autoUpdateMouseAdapter);
	}

	private List<PluginConfig> filterIfSearchKeyword(List<PluginConfig> currentConfigurations)
	{
		final String text = searchBar.getText();
		if (!text.isEmpty())
		{
			currentConfigurations = currentConfigurations.stream()
				.filter(
					c -> c.getName().toLowerCase()
						.contains(text.toLowerCase()))
				.collect(Collectors.toList());
		}
		return currentConfigurations;
	}

	private void sortAlphabetically(List<PluginConfig> configurations)
	{
		// // Sort alphabetically similar to the configurations tab
		configurations.sort(Comparator.comparing(PluginConfig::getConfigName));
	}

	private List<PluginConfig> filterConfigurations(final String filter, final List<PluginConfig> configurations)
	{
		if (!filtered.isEmpty())
		{
			filtered.clear();
		}

		sortAlphabetically(configurations);

		for (final PluginConfig config : configurations)
		{
			PluginConfig presetConfig = editedPreset.getConfig(config);
			boolean someSettingsUnticked = presetConfig != null && presetConfig.getSettings().size() < config.getSettings().size();

			if (filter.equals("All A to Z"))
			{
				filtered.add(config);
			}

			if (filter.equals("Only Plugin Hub") && plugin.getPresetManager().isExternalPlugin(config.getName()))
			{
				filtered.add(config);
			}
			else if (presetConfig == null)
			{
				if (filter.equals("Not included"))
				{
					filtered.add(config);
				}
			}
			else
			{
				if (filter.equals("Included"))
				{
					filtered.add(config);
				}

				if (filter.equals("Not included") && someSettingsUnticked)
				{
					filtered.add(config);
				}

				if (presetConfig.getEnabled() != null)
				{
					if (filter.equals("Plugin enabled") && presetConfig.getEnabled())
					{
						filtered.add(config);
					}

					if (filter.equals("Plugin disabled") && !presetConfig.getEnabled())
					{
						filtered.add(config);
					}
				}

				if (presetConfig.match(config))
				{
					if (filter.equals("Configs match"))
					{
						filtered.add(config);
					}
				}
				else
				{
					if (filter.equals("Modified"))
					{
						filtered.add(config);
					}
				}
			}

			// Runs when "Open partial configs" is clicked
			if (openPartialConfigs && someSettingsUnticked)
			{
				openSettings.add(config.getName());
			}
		}

		if (openAll)
		{
			filtered.forEach(f -> openSettings.add(f.getName()));
		}

		return filtered;
	}

	private JPopupMenu getEllipsisMenuPopup()
	{
		JMenuItem enableAllOption = new JMenuItem();
		enableAllOption.setText("Add all");
		enableAllOption.setToolTipText("Adds all visible configurations to edited preset");
		enableAllOption.addActionListener(e -> enableAllVisible());

		JMenuItem disableAllOption = new JMenuItem();
		disableAllOption.setText("Remove all");
		disableAllOption.setToolTipText("Removes all visible settings from edited preset.");
		disableAllOption.addActionListener(e -> disableAllVisible());

		JMenuItem openAllOption = new JMenuItem();
		openAllOption.setText("Open all");
		openAllOption.setToolTipText("Opens all visible configuration dropdowns.");
		openAllOption.addActionListener(e -> openAll());

		JMenuItem openPartialOption = new JMenuItem();
		openPartialOption.setText("Open partial");
		openPartialOption.setToolTipText("Opens all visible configurations that have some settings ticked also unticked.");
		openPartialOption.addActionListener(e -> openPartialConfigs());

		JMenuItem collapseAllOption = new JMenuItem();
		collapseAllOption.setText("Close all");
		collapseAllOption.setToolTipText("Closes all open configuration dropdowns.");
		collapseAllOption.addActionListener(e -> closeAll());

		JMenuItem divider = new JMenuItem();
		divider.setBorder(new EmptyBorder(1, 5, 1, 5));
		divider.setPreferredSize(new Dimension(0, 1));
		divider.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);

		JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(2, 2, 2, 0));
		popupMenu.add(enableAllOption);
		popupMenu.add(disableAllOption);
		popupMenu.add(divider);
		popupMenu.add(openAllOption);
		popupMenu.add(openPartialOption);
		popupMenu.add(collapseAllOption);
		return popupMenu;
	}

	private void enableAllVisible()
	{
		List<PluginConfig> configs = filterIfSearchKeyword(filtered);
		plugin.getPresetEditor().addAll(configs);
	}

	private void disableAllVisible()
	{
		List<PluginConfig> configs = filterIfSearchKeyword(filtered);
		plugin.getPresetEditor().removeAll(configs);
	}

	private void openAll()
	{
		openAll = true;
		rebuild();
		openAll = false;
	}

	private void openPartialConfigs()
	{
		openPartialConfigs = true;
		rebuild();
		openPartialConfigs = false;
	}

	private void closeAll()
	{
		if (!openSettings.isEmpty())
		{
			openSettings.clear();
			rebuild();
		}
	}

	private JPopupMenu getImportMenuPopup()
	{
		JMenuItem importOption = new JMenuItem();
		importOption.setText("Import preset from clipboard");
		importOption.addActionListener(e -> plugin.importPresetFromClipboard());

		JMenuItem createEmptyOption = new JMenuItem();
		createEmptyOption.setText("Create new preset with all settings");
		createEmptyOption.addActionListener(e -> promptPresetCreation(false));

		JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder(new EmptyBorder(2, 2, 2, 0));
		popupMenu.add(importOption);
		popupMenu.add(createEmptyOption);
		return popupMenu;
	}

	private void promptPresetCreation(boolean empty)
	{
		String customPresetName = JOptionPane.showInputDialog(PluginPresetsPluginPanel.this,
			"Name your new preset.", "New Plugin Preset", JOptionPane.PLAIN_MESSAGE);
		if (customPresetName != null)
		{
			plugin.createPreset(customPresetName, empty);
		}
	}

	public void renderNotification(String errorMessage)
	{
		errorNotification.setToolTipText(errorMessage);
		errorNotification.setVisible(true);
	}

	private void emptyBar()
	{
		searchBar.setText("");
	}

	private void stopEdit()
	{
		plugin.setPresetEditor(null);
		plugin.setFocusChangedPaused(false);
		editedPreset = null;
	}
}

/*
 * Copyright (c) 2021, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets.ui;

import com.pluginpresets.PluginPreset;
import com.pluginpresets.PluginPresetsPlugin;
import com.pluginpresets.PluginPresetsPresetEditor;
import com.pluginpresets.PluginPresetsUtils;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.InputEvent;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingConstants;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import net.runelite.client.config.Keybind;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;

/**
 * Row representing a single preset in the list of presets
 */
class PresetPanel extends JPanel
{
	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
		BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private final PluginPresetsPlugin plugin;
	private final PluginPreset preset;
	private final JPanel labelWrapper = new JPanel();
	private final JLabel keybindLabel = new JLabel();
	private final JLabel shareLabel = new JLabel();
	private final JLabel editLabel = new JLabel();
	private final JLabel deleteLabel = new JLabel();
	private final JLabel loadLabel = new JLabel();
	private final FlatTextField nameInput = new FlatTextField();
	private final JLabel rename = new JLabel("Rename");
	private final JLabel saveRename = new JLabel("Save");
	private final JLabel cancelRename = new JLabel("Cancel");
	private final JPanel keybindWrapper = new JPanel();
	private final JLabel keybind = new JLabel();
	private final JLabel saveKeybind = new JLabel("Save");
	private final JLabel cancelKeybind = new JLabel("Cancel");
	private final JPanel presetNameContainer = new JPanel();
	private KeyEvent savedKeybind = null;

	PresetPanel(PluginPreset pluginPreset, PluginPresetsPlugin pluginPresetsPlugin)
	{
		this.plugin = pluginPresetsPlugin;
		this.preset = pluginPreset;

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel nameActions = new JPanel(new BorderLayout(3, 0));
		nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
		nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getClickCount() == 2)  // double click
				{
					editPreset(pluginPreset);
				}
			}
		});

		saveRename.setVisible(false);
		saveRename.setFont(FontManager.getRunescapeSmallFont());
		saveRename.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		saveRename.setToolTipText("Save new name");
		saveRename.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					saveRename();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				saveRename.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				saveRename.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
			}
		});

		cancelRename.setVisible(false);
		cancelRename.setFont(FontManager.getRunescapeSmallFont());
		cancelRename.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancelRename.setToolTipText("Cancel rename");
		cancelRename.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{	
					cancelRename();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				cancelRename.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				cancelRename.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		});

		rename.setFont(FontManager.getRunescapeSmallFont());
		rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		rename.setToolTipText("Rename preset");
		rename.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					updateNameActions(true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			}
		});

		nameActions.add(saveRename, BorderLayout.EAST);
		nameActions.add(cancelRename, BorderLayout.WEST);
		nameActions.add(rename, BorderLayout.CENTER);

		JPanel nameContainer = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		nameContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		nameInput.setText(preset.getName());
		nameInput.setBorder(null);
		nameInput.setEditable(false);
		nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameInput.setPreferredSize(new Dimension(145, 25));
		nameInput.setVisible(false);
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setBorder(new EmptyBorder(0, 5, 0, 0));
		nameInput.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					saveRename();
				}
				else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					cancelRename();
				}
			}
		});

		JLabel nameLabel = new JLabel(preset.getName());
		nameLabel.setPreferredSize(new Dimension(170, 15));
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setHorizontalTextPosition(SwingConstants.LEFT);
		if (!preset.getLocal())
		{
			nameLabel.setIcon(Icons.SYNC_CONFIG_ICON);
			nameLabel.setToolTipText("Stored in RuneLite config");
		}

		presetNameContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		presetNameContainer.add(nameLabel);

		nameContainer.add(nameInput);
		nameContainer.add(presetNameContainer);

		nameWrapper.add(nameContainer, BorderLayout.CENTER);
		nameWrapper.add(nameActions, BorderLayout.EAST);

		JPanel bottomContainer = new JPanel(new BorderLayout());
		bottomContainer.setBorder(new EmptyBorder(6, 0, 6, 0));
		bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 3, 3));
		leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftActions.setPreferredSize(new Dimension(65, 14));

		loadLabel.setBorder(new EmptyBorder(0, 5, 0, 0));
		loadLabel.setPreferredSize(new Dimension(25, 14));

		Boolean loadOnFocus = preset.getLoadOnFocus();
		boolean autoUpdate = plugin.getAutoUpdater() != null && plugin.getAutoUpdater().getEditedPreset().getId() == preset.getId();
		loadLabel.setComponentPopupMenu(getLoadLabelPopup());

		JLabel notice = new JLabel();

		boolean emptyPreset = false;
		Boolean match = preset.match(plugin.getCurrentConfigurations());
		if (match)
		{
			loadLabel.setIcon(Icons.SWITCH_ON_ICON);
			loadLabel.setToolTipText("Current configurations match this preset");
			// String text = preset.canBeDisabled()
			// 	? "Current configurations match this preset. Click to disable preset."
			// 	: "Current configurations match this preset.";
			// loadLabel.setToolTipText(text);
			// loadLabel.addMouseListener(new MouseAdapter()
			// {
			// 	@Override
			// 	public void mousePressed(MouseEvent mouseEvent)
			// 	{
			// 		if (mouseEvent.getButton() == MouseEvent.BUTTON1)
			// 		{
			// 			plugin.disablePreset(preset);
			// 		}
			// 	}

			// 	@Override
			// 	public void mouseEntered(MouseEvent mouseEvent)
			// 	{
			// 		loadLabel.setIcon(Icons.SWITCH_ON_ICON);
			// 	}

			// 	@Override
			// 	public void mouseExited(MouseEvent mouseEvent)
			// 	{
			// 		loadLabel.setIcon(Icons.SWITCH_ON_ICON);
			// 	}
			// });

			emptyPreset = preset.isEmpty();
			if (emptyPreset)
			{
				notice.setFont(FontManager.getRunescapeSmallFont());
				notice.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
				notice.setText("Empty preset");
				notice.setBorder(new EmptyBorder(0, 5, 0, 0));
				notice.setToolTipText("This preset has no configurations, click the edit icon to add configurations.");
				leftActions.setVisible(false);
			}
		}
		else
		{
			loadLabel.setIcon(Icons.SWITCH_OFF_ICON);
			loadLabel.setToolTipText("Load this preset");
			loadLabel.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mousePressed(MouseEvent mouseEvent)
				{
					if (mouseEvent.getButton() == MouseEvent.BUTTON1)
					{
						plugin.loadPreset(preset);
					}
				}

				@Override
				public void mouseEntered(MouseEvent mouseEvent)
				{
					loadLabel.setIcon(Icons.SWITCH_OFF_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent mouseEvent)
				{
					loadLabel.setIcon(Icons.SWITCH_OFF_ICON);
				}
			});
		}

		JLabel focusActionLabel = new JLabel();
		if (loadOnFocus != null && !emptyPreset)
		{
			String text;
			if (loadOnFocus)
			{
				focusActionLabel.setIcon(Icons.FOCUS_ICON);
				text = "This preset gets loaded when client gets focused";
			}
			else
			{
				focusActionLabel.setIcon(Icons.UNFOCUS_ICON);
				text = "This preset gets loaded when client gets unfocused";
			}
			focusActionLabel.setToolTipText(text);
		}

		JLabel autoUpdateLabel = new JLabel();
		if (!emptyPreset)
		{
			if (autoUpdate)
			{
				autoUpdateLabel.setIcon(Icons.ORANGE_REFRESH_ICON);
				autoUpdateLabel.setToolTipText("Auto updated preset");
			}
			else if (preset.getAutoUpdated() != null)
			{
				autoUpdateLabel.setIcon(Icons.REFRESH_INACTIVE_ICON);
				String tooltipText = "Auto updated when loaded.";
				
				if (match)
				{
					tooltipText += " Click to auto update this preset.";
					autoUpdateLabel.addMouseListener(new MouseAdapter()
					{
						@Override
						public void mousePressed(MouseEvent mouseEvent)
						{
							if (mouseEvent.getButton() == MouseEvent.BUTTON1)
							{
								toggleAutoUpdate();
							}
						}
					});
				}
				autoUpdateLabel.setToolTipText(tooltipText);
			}
		}

		leftActions.add(loadLabel);
		leftActions.add(autoUpdateLabel);
		leftActions.add(focusActionLabel);

		JPanel rightActions = new JPanel();
		rightActions.setLayout(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		keybindWrapper.setLayout(new FlowLayout(FlowLayout.RIGHT, 0, 3));
		keybindWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		keybindWrapper.setVisible(false);

		JPanel keybindActions = new JPanel();
		keybindActions.setLayout(new BorderLayout(3, 0));
		keybindActions.setBorder(new EmptyBorder(0, 5, 0, 2));
		keybindActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		keybindActions.setAlignmentX(RIGHT_ALIGNMENT);

		saveKeybind.setFont(FontManager.getRunescapeSmallFont());
		saveKeybind.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		saveKeybind.setToolTipText("Save keybind");
		saveKeybind.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					saveKeybind();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				saveKeybind.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				saveKeybind.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
			}
		});

		cancelKeybind.setFont(FontManager.getRunescapeSmallFont());
		cancelKeybind.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancelKeybind.setToolTipText("Cancel keybind");
		cancelKeybind.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					cancelKeybind();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				cancelKeybind.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				cancelKeybind.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		});

		keybindActions.add(cancelKeybind, BorderLayout.WEST);
		keybindActions.add(saveKeybind, BorderLayout.EAST);

		keybind.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		keybind.setFont(FontManager.getRunescapeSmallFont());
		int keybindWidth = emptyPreset ? 50 : 60;
		keybind.setPreferredSize(new Dimension(keybindWidth, 12));
		keybind.setHorizontalAlignment(SwingConstants.RIGHT);

		boolean keybindSet = preset.getKeybind() != null;
		if (keybindSet)
		{
			String keybindText = preset.getKeybind().toString();
			keybindLabel.setText(keybindText);
			keybindLabel.setToolTipText(keybindText + " (Click to edit)");

			keybindLabel.setPreferredSize(new Dimension(keybindWidth, 12));
			keybindLabel.setHorizontalAlignment(SwingConstants.RIGHT);
			keybindLabel.setAlignmentX(RIGHT_ALIGNMENT);

			keybind.setText(keybindText);
			keybind.setToolTipText(keybindText + " (Clear with backspace)");

			// Inform that keybind don't work in login screen
			if (!plugin.getLoggedIn())
			{
				keybindLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
				keybindLabel.setToolTipText(keybindText + " (Keybinds are disabled on login screen)");
			}
		}
		else
		{
			keybindLabel.setText("Not set");
			keybindLabel.setToolTipText("Click to bind this preset to a keybind");
			keybindLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());

			keybind.setText("No keybind set");
			keybind.setToolTipText("Type a keybind you wish to set");
		}

		keybindLabel.addMouseListener(new MouseAdapter()
		{
			private Color foreground;

			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					editKeybind();
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				foreground = keybindLabel.getForeground();
				keybindLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				keybindLabel.setForeground(foreground);
			}
		});

		keybindWrapper.add(keybind);
		keybindWrapper.add(keybindActions);

		shareLabel.setIcon(Icons.DUPLICATE_ICON);
		shareLabel.setToolTipText("Duplicate preset");
		shareLabel.setComponentPopupMenu(getCopyLabelPopup());
		shareLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					plugin.duplicatePreset(preset);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				shareLabel.setIcon(Icons.DUPLICATE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				shareLabel.setIcon(Icons.DUPLICATE_ICON);
			}
		});

		deleteLabel.setIcon(Icons.DELETE_ICON);
		deleteLabel.setToolTipText("Delete preset");
		deleteLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					int confirm = JOptionPane.showConfirmDialog(PresetPanel.this,
					"Are you sure you want to permanently delete this plugin preset?",
					"Delete preset", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
					
					if (confirm == 0)
					{
						plugin.deletePreset(preset);
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(Icons.DELETE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				deleteLabel.setIcon(Icons.DELETE_ICON);
			}
		});

		editLabel.setIcon(Icons.EDIT_ICON);
		editLabel.setToolTipText("Edit preset configurations");
		editLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				if (mouseEvent.getButton() == MouseEvent.BUTTON1)
				{
					editPreset(preset);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent)
			{
				editLabel.setIcon(Icons.EDIT_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent)
			{
				editLabel.setIcon(Icons.EDIT_ICON);
			}
		});

		labelWrapper.setLayout(new FlowLayout(FlowLayout.RIGHT, 8, 0));
		labelWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		labelWrapper.add(keybindLabel);
		labelWrapper.add(shareLabel);
		labelWrapper.add(editLabel);
		labelWrapper.add(deleteLabel);

		rightActions.add(keybindWrapper);
		rightActions.add(labelWrapper);

		bottomContainer.add(leftActions, BorderLayout.WEST);
		bottomContainer.add(notice, BorderLayout.CENTER);
		bottomContainer.add(rightActions, BorderLayout.EAST);

		add(nameWrapper, BorderLayout.NORTH);
		add(bottomContainer, BorderLayout.CENTER);
	}

	private void saveRename()
	{
		updatePresetName();

		nameInput.setEditable(false);
		updateNameActions(false);
		requestFocusInWindow();

		plugin.savePresets();
	}

	private void updatePresetName()
	{
		String nameInputText = nameInput.getText();
		boolean empty = nameInputText.isEmpty();
		boolean stringContainsInvalidCharacters = PluginPresetsUtils.stringContainsInvalidCharacters(nameInputText);

		boolean validName = !empty && !stringContainsInvalidCharacters;
		if (validName)
		{
			preset.setName(nameInputText);
		}
		else
		{
			if (empty)
			{
				setDefaultPresetName();
			}
			else
			{
				plugin.setErrorMessage("Rename failed because name input had invalid characters.");
			}
			// Else keep the old name
		}
	}

	private void setDefaultPresetName()
	{
		String defaultPresetName = PluginPresetsPlugin.DEFAULT_PRESET_NAME;
		preset.setName(defaultPresetName);
		nameInput.setText(defaultPresetName);
	}

	private void cancelRename()
	{
		nameInput.setEditable(false);
		nameInput.setText(preset.getName());
		updateNameActions(false);
		requestFocusInWindow();
	}

	private void updateNameActions(boolean saveAndCancel)
	{
		saveRename.setVisible(saveAndCancel);
		cancelRename.setVisible(saveAndCancel);
		rename.setVisible(!saveAndCancel);

		nameInput.setEditable(saveAndCancel);
		nameInput.setVisible(saveAndCancel);
		presetNameContainer.setVisible(!saveAndCancel);

		if (saveAndCancel)
		{
			nameInput.getTextField().requestFocusInWindow();
			nameInput.getTextField().selectAll();
		}
	}

	private void showKeybind(boolean show)
	{
		labelWrapper.setVisible(!show);
		keybindWrapper.setVisible(show);
	}

	private void editKeybind()
	{
		showKeybind(true);
		keybind.requestFocusInWindow();
		keybind.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				handleKeybindInput(e);
			}

		});
	}

	private void handleKeybindInput(KeyEvent e)
	{
		int keyCode = e.getKeyCode();

		if (keyCode == KeyEvent.VK_ENTER)
		{
			saveKeybind();
		}
		else if (keyCode == KeyEvent.VK_ESCAPE)
		{
			cancelKeybind();
		}
		else if (keyCode == KeyEvent.VK_BACK_SPACE)
		{
			savedKeybind = e;
			clearKeybind();
		}
		else
		{
			savedKeybind = e;
			String keyText = KeyEvent.getKeyText(keyCode);
			String keybindText = keyText.toUpperCase();

			int modifiersEx = e.getModifiersEx();
			if (modifiersEx != 0) // If modifier included e.g. CTRL
			{
				String modifiersExText = InputEvent.getModifiersExText(modifiersEx);
				String text = (modifiersExText + "+" + keyText).toUpperCase();
				if (!modifiersExText.equals(keyText)) // Don't include only multiplier keybindings e.g. ALT+ALT
				{
					keybindText = text;
				}

				keybind.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
				keybind.setToolTipText(keybindText + " (Clear with backspace)");
			}
			else
			{
				keybind.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
				keybind.setToolTipText("Add some modifier to this keybind! This preset could possibly be accidentally enabled e.g. when typing chat messages.");
			}

			if (!keybind.getText().equals(keybindText))
			{
				keybind.setText(keybindText);
			}
		}
	}

	private void saveKeybind()
	{
		showKeybind(false);

		// Save pressed but no changes made to preset keybind
		if (preset.getKeybind() != null && savedKeybind == null)
		{
			return;
		}

		// Clear keybind if keybind was cleared with backspace and then saved
		Keybind presetKeybind = (savedKeybind == null || savedKeybind.getKeyCode() == KeyEvent.VK_BACK_SPACE)
			? null
			: new Keybind(savedKeybind);

		preset.setKeybind(presetKeybind);
		plugin.savePresets();
	}

	private void cancelKeybind()
	{
		savedKeybind = null;
		showKeybind(false);
	}

	private void clearKeybind()
	{
		keybind.setText("No keybind set");
		keybind.setToolTipText("Save to clear keybind");
	}

	private JPopupMenu getCopyLabelPopup()
	{
		JPopupMenu popupMenu = new JPopupMenu();

		JMenuItem duplicatePreset = new JMenuItem();
		duplicatePreset.setText("Duplicate preset");
		duplicatePreset.addActionListener(e -> plugin.duplicatePreset(preset));

		JMenuItem copyToClipboard = new JMenuItem();
		copyToClipboard.setText("Copy preset to clipboard");
		copyToClipboard.addActionListener(e -> {
			plugin.exportPresetToClipboard(preset);
			JOptionPane.showMessageDialog(shareLabel,
				"Preset data of '" + preset.getName() + "' copied to clipboard.", "Preset exported",
				JOptionPane.INFORMATION_MESSAGE);
		});

		popupMenu.add(duplicatePreset);
		popupMenu.add(copyToClipboard);

		return popupMenu;
	}

	private JPopupMenu getLoadLabelPopup()
	{
		JPopupMenu popupMenu = new JPopupMenu();

		Boolean match = preset.match(plugin.getCurrentConfigurations());
		if (!match)
		{
			JMenuItem loadOption = new JMenuItem();
			loadOption.setText("Load preset");
			loadOption.addActionListener(e -> plugin.loadPreset(preset));

			JMenuItem divider = getDivider();

			popupMenu.add(loadOption);
			popupMenu.add(divider);
		}

		JMenuItem toggleAutoUpdate = new JMenuItem();
		toggleAutoUpdate.setText("Toggle auto update");
		toggleAutoUpdate.addActionListener(e -> toggleAutoUpdate());

		JMenuItem clearAutoUpdate = new JMenuItem();
		clearAutoUpdate.setText("Clear auto update");
		clearAutoUpdate.addActionListener(e -> clearAutoUpdate());

		JMenuItem divider = getDivider();

		JMenuItem focusedOption = new JMenuItem();
		focusedOption.setText("Load when focused");
		focusedOption.setToolTipText("Load this preset automatically when client gets focused");
		focusedOption.addActionListener(e -> setPresetWindowFocus(true));

		JMenuItem unfocusedOption = new JMenuItem();
		unfocusedOption.setText("Load when unfocused");
		unfocusedOption.setToolTipText("Load this preset automatically when client gets unfocused");
		unfocusedOption.addActionListener(e -> setPresetWindowFocus(false));

		JMenuItem clearFocusOption = new JMenuItem();
		clearFocusOption.setText("Clear focus action");
		clearFocusOption.addActionListener(e -> setPresetWindowFocus(null));

		popupMenu.setBorder(new EmptyBorder(2, 2, 2, 0));
		popupMenu.add(toggleAutoUpdate);
		popupMenu.add(clearAutoUpdate);
		popupMenu.add(divider);
		popupMenu.add(focusedOption);
		popupMenu.add(unfocusedOption);
		popupMenu.add(clearFocusOption);
		return popupMenu;
	}

	private JMenuItem getDivider()
	{
		JMenuItem divider = new JMenuItem();
		divider.setBorder(new EmptyBorder(1, 5, 1, 5));
		divider.setPreferredSize(new Dimension(0, 1));
		divider.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		return divider;
	}

	private void toggleAutoUpdate()
	{
		if (preset.match(plugin.getCurrentConfigurations()))
		{
			plugin.setAutoUpdatedPreset(preset.getId());
		}
		else
		{
			preset.setAutoUpdated(true);
			plugin.savePresets();
		}
	}

	private void clearAutoUpdate()
	{
		boolean thisAutoUpdated = plugin.getAutoUpdater() != null && plugin.getAutoUpdater().getEditedPreset().getId() == preset.getId();
		if (thisAutoUpdated)
		{
			plugin.setAutoUpdatedPreset(null);
		}
		plugin.removeAutoUpdateFrom(preset);
	}

	private void setPresetWindowFocus(Boolean loadOnFocus)
	{
		preset.setLoadOnFocus(loadOnFocus);
		plugin.savePresets();
	}

	public void editPreset(PluginPreset preset)
	{
		plugin.setPresetEditor(new PluginPresetsPresetEditor(plugin, preset, plugin.getCurrentConfigurations()));
		plugin.setFocusChangedPaused(true);
		plugin.rebuildPluginUi();
	}
}

package com.pluginpresets.ui;

import com.pluginpresets.PluginPresetsPlugin;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import net.runelite.client.util.ImageUtil;

public final class Icons
{

	static final ImageIcon NOTIFICATION_ICON;
	static final ImageIcon NOTIFICATION_HOVER_ICON;
	static final ImageIcon HELP_ICON;
	static final ImageIcon HELP_HOVER_ICON;
	static final ImageIcon ELLIPSIS;
	static final ImageIcon ELLIPSIS_HOVER;
	static final ImageIcon SYNC_CONFIG_ICON;
	static final ImageIcon SYNC_CONFIG_HOVER_ICON;
	static final ImageIcon SYNC_LOCAL_ICON;
	static final ImageIcon SYNC_LOCAL_HOVER_ICON;
	static final ImageIcon REFRESH_ICON;
	static final ImageIcon REFRESH_INACTIVE_ICON;
	static final ImageIcon REFRESH_HOVER_ICON;
	static final ImageIcon ORANGE_REFRESH_ICON;
	static final ImageIcon ORANGE_REFRESH_HOVER_ICON;
	static final ImageIcon ADD_ICON;
	static final ImageIcon ADD_HOVER_ICON;
	static final ImageIcon ARROW_LEFT_ICON;
	static final ImageIcon ARROW_LEFT_HOVER_ICON;
	static final ImageIcon PAUSE_ICON;
	static final ImageIcon PAUSE_HOVER_ICON;
	static final ImageIcon PLAY_ICON;
	static final ImageIcon PLAY_HOVER_ICON;
	static final ImageIcon SWITCH_ON_ICON;
	static final ImageIcon SWITCH_OFF_ICON;
	static final ImageIcon SWITCH_OFF_HOVER_ICON;
	static final ImageIcon DUPLICATE_ICON;
	static final ImageIcon DUPLICATE_HOVER_ICON;
	static final ImageIcon DELETE_ICON;
	static final ImageIcon DELETE_HOVER_ICON;
	static final ImageIcon EDIT_ICON;
	static final ImageIcon EDIT_HOVER_ICON;
	static final ImageIcon FOCUS_ICON;
	static final ImageIcon UNFOCUS_ICON;
	static final ImageIcon NOT_INSTALLED_ICON;
	static final ImageIcon NOT_INSTALLED_HOVER_ICON;
	static final ImageIcon ARROW_DOWN_ICON;
	static final ImageIcon ARROW_RIGHT_ICON;
	static final ImageIcon ARROW_RIGHT_HOVER_ICON;
	static final ImageIcon UPDATE_ICON;
	static final ImageIcon UPDATE_HOVER_ICON;

	static
	{
		final BufferedImage notificationImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class,
			"warning_icon.png");
		NOTIFICATION_ICON = new ImageIcon(notificationImg);
		NOTIFICATION_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(notificationImg, 0.53f));

		final BufferedImage helpImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "help_icon.png");
		HELP_ICON = new ImageIcon(helpImg);
		HELP_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(helpImg, 0.53f));

		final BufferedImage ellipsisImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "ellipsis_icon.png");
		ELLIPSIS = new ImageIcon(ellipsisImg);
		ELLIPSIS_HOVER = new ImageIcon(ImageUtil.alphaOffset(ellipsisImg, 0.53f));

		final BufferedImage cloudImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "cloud_icon.png");
		SYNC_CONFIG_ICON = new ImageIcon(cloudImg);
		SYNC_CONFIG_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(cloudImg, -100));

		final BufferedImage folderImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "folder_icon.png");
		SYNC_LOCAL_ICON = new ImageIcon(folderImg);
		SYNC_LOCAL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(folderImg, -100));

		final BufferedImage refreshImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "refresh_icon.png");
		REFRESH_ICON = new ImageIcon(refreshImg);
		REFRESH_INACTIVE_ICON = new ImageIcon(ImageUtil.alphaOffset(refreshImg, -120));
		REFRESH_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(refreshImg, 0.53f));

		final BufferedImage orangeRefreshImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class,
			"orange_refresh_icon.png");
		ORANGE_REFRESH_ICON = new ImageIcon(orangeRefreshImg);
		ORANGE_REFRESH_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(orangeRefreshImg, 0.63f));

		final BufferedImage addImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "add_icon.png");
		ADD_ICON = new ImageIcon(addImg);
		ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addImg, 0.53f));

		final BufferedImage arrowLeftImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class,
			"arrow_left_icon.png");
		ARROW_LEFT_ICON = new ImageIcon(arrowLeftImg);
		ARROW_LEFT_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(arrowLeftImg, 0.53f));

		final BufferedImage pauseImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "pause_icon.png");
		PAUSE_ICON = new ImageIcon(pauseImg);
		PAUSE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(pauseImg, 0.53f));

		final BufferedImage playImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "play_icon.png");
		PLAY_ICON = new ImageIcon(playImg);
		PLAY_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(playImg, 0.53f));

		final BufferedImage switchOnImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "switch_on_icon.png");
		SWITCH_ON_ICON = new ImageIcon(switchOnImg);

		final BufferedImage switchOffImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class,
			"switch_off_icon.png");
		final BufferedImage switchOffHoverImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class,
			"switch_off_hover_icon.png");
		SWITCH_OFF_ICON = new ImageIcon(switchOffImg);
		SWITCH_OFF_HOVER_ICON = new ImageIcon(switchOffHoverImg);

		final BufferedImage duplicateImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "duplicate_icon.png");
		DUPLICATE_ICON = new ImageIcon(duplicateImg);
		DUPLICATE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(duplicateImg, -100));

		final BufferedImage deleteImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));

		final BufferedImage editImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "edit_icon.png");
		EDIT_ICON = new ImageIcon(editImg);
		EDIT_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(editImg, 0.53f));

		final BufferedImage focusImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "focus_icon.png");
		FOCUS_ICON = new ImageIcon(focusImg);

		final BufferedImage unfocusImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "unfocus_icon.png");
		UNFOCUS_ICON = new ImageIcon(unfocusImg);

		final BufferedImage notInstalledImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class,
			"not_installed_icon.png");
		NOT_INSTALLED_ICON = new ImageIcon(notInstalledImg);
		NOT_INSTALLED_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(notInstalledImg, 0.80f));

		final BufferedImage arrowDownImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class,
			"arrow_right_icon.png");
		ARROW_DOWN_ICON = new ImageIcon(ImageUtil.rotateImage(arrowDownImg, (Math.PI / 2)));
		ARROW_RIGHT_ICON = new ImageIcon(ImageUtil.alphaOffset(arrowDownImg, 0.45f));
		ARROW_RIGHT_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(arrowDownImg, 0.80f));

		final BufferedImage updateImg = ImageUtil.loadImageResource(PluginPresetsPlugin.class, "refresh_icon.png");
		UPDATE_ICON = new ImageIcon(updateImg);
		UPDATE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(updateImg, -100));
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

/**
 * Handles updating a preset: enabling/disabling plugin configs and their individual settings.
 * Globally saves changes to the preset if needed.
 */
@Slf4j
public class PluginPresetsPresetEditor
{
	private final PluginPresetsPlugin plugin;
	private final CurrentConfigurations currentConfigurations;

	@Getter
	private final PluginPreset editedPreset;

	public PluginPresetsPresetEditor(PluginPresetsPlugin plugin, PluginPreset editedPreset, CurrentConfigurations currentConfigurations)
	{
		this.plugin = plugin;
		this.editedPreset = editedPreset;
		this.currentConfigurations = currentConfigurations;
	}

	/**
	 * Removes the given plugin config from the preset.
	 * Switching to this preset will not affect any of the plugin's settings from this point on.
	 *
	 * @param configuration the plugin to remove from this preset
	 */
	public void removeConfigurationFromEdited(PluginConfig configuration)
	{
		removeConfigurationFromEdited(configuration, false);
	}

	private void removeConfigurationFromEdited(PluginConfig configuration, Boolean skipUpdate)
	{
		List<PluginConfig> pluginConfigs = editedPreset.getPluginConfigs().stream()
			.filter(c -> !(c.getName().equals(configuration.getName())))
			.collect(Collectors.toList());

		editedPreset.setPluginConfigs(pluginConfigs);

		if (!skipUpdate)
		{
			updateEditedPreset();
		}
	}

	/**
	 * Adds the given plugin config to the preset.
	 * Switching to this preset changes some or all the plugin's settings to whatever the preset has saved.
	 *
	 * @param configuration the plugin to add to this preset
	 */
	public void addConfigurationToEdited(PluginConfig configuration)
	{
		addConfigurationToEdited(configuration, false);
	}

	private void addConfigurationToEdited(PluginConfig configuration, Boolean skipUpdate)
	{
		List<PluginConfig> pluginConfigs = editedPreset.getPluginConfigs();
		pluginConfigs.add(configuration);
		editedPreset.setPluginConfigs(pluginConfigs);

		if (!skipUpdate)
		{
			updateEditedPreset();
		}
	}

	/**
	 * Removes a setting from a config in this preset.
	 * Switching to this preset will not affect this setting from this point on.
	 *
	 * @param currentConfig the setting's parent config
	 * @param setting       the setting to remove from the preset
	 */
	public void removeSettingFromEdited(PluginConfig currentConfig, PluginSetting setting)
	{
		editedPreset.getPluginConfigs().forEach(configuration ->
		{
			boolean configToBeRemoved = currentConfig == null || configuration.getName().equals(currentConfig.getName());
			if (configToBeRemoved)
			{
				List<PluginSetting> settings = configuration.getSettings().stream().filter((s -> !s.getKey().equals(setting.getKey()))).collect(Collectors.toList());
				configuration.setSettings(settings);

				boolean lastSetting = configuration.getSettings().isEmpty() && configuration.getEnabled() == null;
				if (lastSetting)
				{
					removeConfigurationFromEdited(configuration);
				}
			}
		});
		updateEditedPreset();
	}

	/**
	 * Adds a setting to a config in this preset.
	 * Switching to this preset changes this setting to whatever the preset has saved.
	 *
	 * @param currentConfig the setting's parent config
	 * @param setting       the setting to add to the preset
	 */
	public void addSettingToEdited(PluginConfig currentConfig, PluginSetting setting)
	{
		boolean noneMatch = editedPreset.getPluginConfigs().stream().noneMatch(c -> c.getName().equals(currentConfig.getName()));
		if (noneMatch)
		{
			ArrayList<PluginSetting> settings = new ArrayList<>();
			settings.add(setting);
			PluginConfig pluginConfig = new PluginConfig(currentConfig.getName(), currentConfig.getConfigName(), null, settings);
			editedPreset.getPluginConfigs().add(pluginConfig);
		}
		else
		{
			editedPreset.getPluginConfigs().forEach(configuration ->
			{
				if (configuration.getName().equals(currentConfig.getName()))
				{
					configuration.getSettings().add(setting);
				}
			});
		}
		updateEditedPreset();
	}

	/**
	 * Adds a custom setting key to a config in this preset.
	 * Switching to this preset changes this custom setting to whatever the preset has saved.
	 *
	 * @param currentConfig the config that will house the custom setting (plugin config name may not always be
	 *                      equal to the custom setting's config key)
	 * @param customSetting the setting key to add, in the format configKey.settingKey
	 */
	public void addCustomSettingToEdited(PluginConfig currentConfig, String customSetting)
	{
		String configName;
		String key;

		// Parse user input
		try
		{
			String[] split = customSetting.split("\\.");
			configName = split[0];
			key = split[1].split("=")[0];
		}
		catch (Exception e)
		{
			log.warn("Failed to add custom setting " + customSetting + " to preset. Reason: " + e.getMessage());
			return;
		}

		PluginConfig config = editedPreset.getPluginConfigs().stream()
			.filter(customer -> customer.getConfigName().equals(currentConfig.getConfigName()))
			.findAny()
			.orElse(null);

		if (config == null)
		{
			for (PluginConfig c : currentConfigurations.getPluginConfigs())
			{
				if (c.getConfigName().equals(currentConfig.getConfigName()))
				{
					config = new PluginConfig(c.getName(), c.getConfigName(), null, new ArrayList<>());
				}
			}
			editedPreset.getPluginConfigs().add(config);
		}

		if (config == null)
		{
			log.warn("Could not add custom setting.");
			return;
		}

		String value = plugin.getPresetManager().getConfiguration(configName, key);
		PluginSetting setting = new PluginSetting(PluginPresetsUtils.splitAndCapitalize(key), key, value, configName, config.getConfigName());

		// don't add this setting if its key is already present
		if (config.getSetting(setting) == null)
		{
			config.getSettings().add(setting);
			updateEditedPreset();
			plugin.refreshPresets(); // Must do refresh to reload custom configs
		}
	}

	/**
	 * Adds the given plugin config's on/off status to the preset.
	 * Switching to this preset changes whether the plugin is enabled.
	 *
	 * @param currentConfig the plugin to enable/disable in this preset
	 */
	public void addEnabledToEdited(PluginConfig currentConfig)
	{
		boolean noneMatch = editedPreset.getPluginConfigs().stream().noneMatch(c -> currentConfig.getName().equals(c.getName()));
		if (noneMatch)
		{
			ArrayList<PluginSetting> settings = new ArrayList<>();
			PluginConfig pluginConfig = new PluginConfig(currentConfig.getName(), currentConfig.getConfigName(), currentConfig.getEnabled(), settings);
			editedPreset.getPluginConfigs().add(pluginConfig);
		}
		else
		{
			editedPreset.getPluginConfigs().forEach(configuration ->
			{
				if (configuration.getName().equals(currentConfig.getName()))
				{
					configuration.setEnabled(currentConfig.getEnabled());
				}
			});
		}
		updateEditedPreset();
	}

	/**
	 * Removes the given plugin config's on/off status from the preset.
	 * Switching to this preset will not change the plugin's on/off status.
	 *
	 * @param currentConfig the plugin that will no longer be enabled/disabled by this preset
	 */
	public void removeEnabledFromEdited(PluginConfig currentConfig)
	{
		editedPreset.getPluginConfigs().forEach(configurations ->
		{
			if (configurations.getName().equals(currentConfig.getName()))
			{
				configurations.setEnabled(null);
				if (configurations.getSettings().isEmpty())
				{
					removeConfigurationFromEdited(configurations);
				}
			}
		});

		updateEditedPreset();
	}

	/**
	 * Adds the config for the given plugin in all the user's presets.
	 *
	 * @param configuration the plugin config to add to all presets
	 */
	public void addConfigurationToPresets(PluginConfig configuration)
	{
		addConfigurationToEdited(configuration);

		plugin.getPluginPresets().forEach(preset ->
		{
			boolean contains = preset.getPluginConfigs().stream().map(PluginConfig::getName).collect(Collectors.toList()).contains(configuration.getName());
			if (contains)
			{
				List<PluginConfig> pluginConfigs = preset.getPluginConfigs().stream()
					.filter(c -> !(c.getName().equals(configuration.getName())))
					.collect(Collectors.toList());
				preset.setPluginConfigs(pluginConfigs);
			}
			preset.getPluginConfigs().add(configuration);
		});
	}

	/**
	 * Removes the config for the given plugin from all the user's presets.
	 *
	 * @param configuration the plugin config to remove from all presets
	 */
	public void removeConfigurationFromPresets(PluginConfig configuration)
	{
		removeConfigurationFromEdited(configuration);

		plugin.getPluginPresets().forEach(preset ->
		{
			List<PluginConfig> pluginConfigs = preset.getPluginConfigs().stream()
				.filter(c -> !(c.getName().equals(configuration.getName())))
				.collect(Collectors.toList());
			preset.setPluginConfigs(pluginConfigs);
		});
		plugin.savePresets();
	}

	/**
	 * Replaces an existing config in this preset with the provided (current) config.
	 *
	 * @param presetConfig  the preset config to replace
	 * @param currentConfig the current config that will replace presetConfig
	 */
	public void updateConfigurations(PluginConfig presetConfig, PluginConfig currentConfig)
	{
		removeConfigurationFromEdited(presetConfig, true);
		List<String> presetConfigKeys = presetConfig.getSettingKeys();
		List<PluginSetting> currentSettings = currentConfig.getSettings().stream()
			.filter(s -> presetConfigKeys.contains(s.getKey()))
			.collect(Collectors.toList());

		currentConfig.setSettings(currentSettings);

		if (presetConfig.getEnabled() == null)
		{
			currentConfig.setEnabled(null);
		}

		addConfigurationToEdited(currentConfig, true);
		updateEditedPreset();
	}

	/**
	 * Updates this preset, replacing all preset configs that have been modified with their current values.
	 */
	public void updateAllModified()
	{
		for (PluginConfig presetConfig : editedPreset.getPluginConfigs())
		{
			PluginConfig currentConfig = currentConfigurations
				.getPluginConfigs()
				.stream()
				.filter(c -> c.getName().equals(presetConfig.getName()))
				.findAny()
				.orElse(null);

			removeConfigurationFromEdited(presetConfig, true);

			List<String> keys = presetConfig
				.getSettings()
				.stream()
				.map(PluginSetting::getKey)
				.collect(Collectors.toList());

			if (currentConfig == null)
			{
				addConfigurationToEdited(presetConfig, true);
				continue;
			}

			List<PluginSetting> updatedSettings = currentConfig
				.getSettings()
				.stream()
				.filter(s -> keys.contains(s.getKey()))
				.collect(Collectors.toList());

			currentConfig.setSettings(updatedSettings);

			if (presetConfig.getEnabled() == null)
			{
				currentConfig.setEnabled(null);
			}

			addConfigurationToEdited(currentConfig, true);
		}

		updateEditedPreset();
	}

	/**
	 * Adds all provided configs to this preset.
	 *
	 * @param pluginConfigs configs to add
	 */
	public void addAll(List<PluginConfig> pluginConfigs)
	{
		for (PluginConfig pluginConfig : pluginConfigs)
		{
			removeConfigurationFromEdited(pluginConfig, true);
			addConfigurationToEdited(pluginConfig, true);
		}
		updateEditedPreset();
	}

	/**
	 * Removes all provided configs from this preset.
	 *
	 * @param pluginConfigs configs to remove
	 */
	public void removeAll(List<PluginConfig> pluginConfigs)
	{
		for (PluginConfig pluginConfig : pluginConfigs)
		{
			removeConfigurationFromEdited(pluginConfig, true);
		}
		updateEditedPreset();
	}

	/**
	 * Toggles cloud/local storage for this preset.
	 */
	public void toggleLocal()
	{
		editedPreset.setLocal(!editedPreset.getLocal());
		updateEditedPreset();
	}

	private PluginPreset getPresetBeingEdited()
	{
		for (PluginPreset preset : plugin.getPluginPresets())
		{
			if (preset.getId() == editedPreset.getId())
			{
				return preset;
			}
		}

		return null;
	}

	public void syncAutoUpdate()
	{
		editedPreset.setAutoUpdated(Objects.requireNonNull(getPresetBeingEdited()).getAutoUpdated());
		updateEditedPreset();
	}

	/**
	 * Update edited presets plugin configs in pluginPresets and then save.
	 */
	public void updateEditedPreset()
	{
		PluginPreset preset = getPresetBeingEdited();
		if (preset != null)
		{
			preset.setPluginConfigs(editedPreset.getPluginConfigs());
			preset.setAutoUpdated(editedPreset.getAutoUpdated());
			preset.setLocal(editedPreset.getLocal());
		}
		plugin.savePresets();
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import lombok.AllArgsConstructor;
import lombok.Data;

/**
 * One custom plugin setting within a config within a preset.
 */
@Data
@AllArgsConstructor
public class CustomSetting
{
	PluginSetting setting;
	PluginConfig parentConfig;
	PluginPreset parentPreset;
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import lombok.AllArgsConstructor;
import lombok.Data;

/**
 * The setting for a single item in a PluginConfig.
 *
 * @param name             Displayed name of the setting
 * @param key              Key used internally by configManager
 * @param value            Value of the setting
 * @param customConfigName Optional different config name that Plugin configs
 *                         since with custom settings, they might differ
 * @param configName       Name of the config, where the setting contains
 */
@Data
@AllArgsConstructor
public class PluginSetting
{
	private String name;
	private String key;
	private String value;
	private String customConfigName;
	private String configName;
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigDescriptor;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.plugins.PluginManager;

/**
 * Helper class that retrieves the user's current configs from the RuneLite client
 */
@Singleton
public class PluginPresetsCurrentConfigManager
{
	private final PluginManager pluginManager;
	private final ConfigManager configManager;
	private final RuneLiteConfig runeLiteConfig;
	private final CustomSettingsManager customSettingsManager;

	@Inject
	public PluginPresetsCurrentConfigManager(PluginManager pluginManager, ConfigManager configManager, RuneLiteConfig runeLiteConfig, CustomSettingsManager customSettingsManager)
	{
		this.pluginManager = pluginManager;
		this.configManager = configManager;
		this.runeLiteConfig = runeLiteConfig;
		this.customSettingsManager = customSettingsManager;
	}

	public List<PluginConfig> getCurrentConfigs()
	{
		ArrayList<PluginConfig> pluginConfigs = new ArrayList<>();

		pluginManager.getPlugins().forEach(p ->
		{
			String name = p.getName();
			if (!PluginPresetsPlugin.IGNORED_PLUGINS.contains(name))
			{
				Config pluginConfigProxy = pluginManager.getPluginConfigProxy(p);

				boolean enabled = pluginManager.isPluginEnabled(p);

				ArrayList<PluginSetting> pluginSettings = new ArrayList<>();
				String configName;

				if (pluginConfigProxy == null)
				{
					configName = p.getClass().getSimpleName().toLowerCase();
				}
				else
				{
					ConfigDescriptor configDescriptor = configManager.getConfigDescriptor(pluginConfigProxy);
					configName = configDescriptor.getGroup().value();

					configDescriptor.getItems().forEach(i ->
					{
						if (!PluginPresetsPlugin.IGNORED_KEYS.contains(i.key()))
						{
							String settingName = i.name();
							if (i.name().equals(""))
							{
								settingName = PluginPresetsUtils.splitAndCapitalize(settingName);
							}

							String configuration = configManager.getConfiguration(configDescriptor.getGroup().value(), i.key());
							PluginSetting pluginSetting = new PluginSetting(settingName, i.key(),
								configuration, null, null);
							pluginSettings.add(pluginSetting);
						}
					});
				}

				List<CustomSetting> configsCustomSettings = customSettingsManager.getCustomConfigsFor(configName);
				if (!configsCustomSettings.isEmpty())
				{
					// Don't add duplicate custom settings: config.key must be unique
					ArrayList<String> addedCustomSettings = new ArrayList<>();

					configsCustomSettings.forEach(customSetting ->
					{
						PluginSetting setting = customSetting.getSetting();
						String customConfigName = setting.getCustomConfigName();
						String customConfigKey = setting.getKey();
						String customConfig = customConfigName + "." + customConfigKey;
						if (!addedCustomSettings.contains(customConfig))
						{
							String value = configManager.getConfiguration(customConfigName, setting.getKey());
							PluginSetting pluginSetting = new PluginSetting(setting.getName(), setting.getKey(), value, customConfigName, setting.getConfigName());
							pluginSettings.add(pluginSetting);
							addedCustomSettings.add(customConfig);
						}
					});
				}

				PluginConfig pluginConfig = new PluginConfig(name, configName, enabled, pluginSettings);

				pluginConfigs.add(pluginConfig);
			}
		});

		// Add RuneLite settings
		ArrayList<PluginSetting> runelitePluginSettings = new ArrayList<>();

		PluginConfig runeliteConfig = new PluginConfig("RuneLite", RuneLiteConfig.GROUP_NAME, true, runelitePluginSettings);

		configManager.getConfigDescriptor(runeLiteConfig).getItems().forEach(i ->
		{
			if (!PluginPresetsPlugin.IGNORED_KEYS.contains(i.key()))
			{
				String configuration = configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, i.key());
				PluginSetting pluginSetting = new PluginSetting(i.name(), i.key(),
					configuration, null, null);
				runelitePluginSettings.add(pluginSetting);
			}
		});

		// Add possible custom RuneLite settings
		List<CustomSetting> customRuneLiteSettings = customSettingsManager.getCustomConfigsFor(RuneLiteConfig.GROUP_NAME);
		if (!customRuneLiteSettings.isEmpty())
		{
			customRuneLiteSettings.forEach(customSetting ->
			{
				PluginSetting setting = customSetting.getSetting();
				String value = configManager.getConfiguration(setting.getCustomConfigName(), setting.getKey());
				setting.setValue(value);

				runelitePluginSettings.add(setting);
			});
		}

		pluginConfigs.add(runeliteConfig);

		return pluginConfigs;
	}
}

/*
 * Copyright (c) 2022, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import com.google.common.reflect.ClassPath;
import com.google.common.reflect.ClassPath.ClassInfo;
import com.google.inject.Inject;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;

/**
 * Handles loading presets and creating new ones
 */
@Slf4j
@Singleton
public class PluginPresetsPresetManager
{
	private final PluginManager pluginManager;
	private final ConfigManager configManager;
	private final List<String> corePlugins;

	@Inject
	public PluginPresetsPresetManager(PluginManager pluginManager, ConfigManager configManager)
	{
		this.pluginManager = pluginManager;
		this.configManager = configManager;
		this.corePlugins = getCorePlugins();
	}

	/**
	 * Disable a preset, turn every plugin off that has the enabled==true
	 *
	 * @param preset     the preset to be disabled
	 * @param onComplete callback invoked once preset is loaded
	 */
	public void disablePreset(PluginPreset preset, Runnable onComplete)
	{
		Collection<Plugin> plugins = pluginManager.getPlugins();

		preset.getPluginConfigs().forEach(pluginConfig ->
		{
			Plugin plugin = findPlugin(pluginConfig.getName(), plugins);

			// Set plugin off
			Boolean enabled = pluginConfig.getEnabled();
			if (plugin != null && enabled != null && enabled)
			{
				enablePlugin(plugin, false);
			}
		});

		onComplete.run();
	}

	/**
	 * Loads a preset, changing its specified settings and enabling/disabling its plugins.
	 *
	 * @param preset     the preset to be loaded
	 * @param onComplete callback invoked once preset is loaded
	 */
	public void loadPreset(PluginPreset preset, Runnable onComplete)
	{
		Collection<Plugin> plugins = pluginManager.getPlugins();

		// A plugin that contains custom settings should be restarted asynchronously.
		// However, it only needs to be restarted if it's not going to be toggled by the preset
		Map<Plugin, Boolean> customPluginsToRestart = preset.getPluginConfigs().stream()
			.filter(PluginConfig::containsCustomSettings)
			.map(config -> {
				Plugin plugin = findPlugin(config.getName(), plugins);
				Boolean enabled = plugin != null ? pluginManager.isPluginEnabled(plugin) : null;
				Boolean shouldEnable = config.getEnabled();
				return shouldEnable == null || Objects.equals(enabled, shouldEnable) ? plugin : null;
			})
			.filter(Objects::nonNull)
			.collect(Collectors.toMap(p -> p, pluginManager::isPluginEnabled));

		preset.getPluginConfigs().forEach(pluginConfig ->
		{
			Plugin plugin = findPlugin(pluginConfig.getName(), plugins);

			pluginConfig.getSettings().forEach(setting ->
			{
				// Some values e.g. hidden timers like tzhaar
				// or color inputs with "Pick a color" option appears as null
				String value = setting.getValue();
				if (value != null)
				{
					String customConfigName = setting.getCustomConfigName();
					boolean customConfig = customConfigName != null;
					String groupName = customConfig ? customConfigName : pluginConfig.getConfigName();
					// Set configuration
					configManager.setConfiguration(groupName, setting.getKey(), value);
				}
			});

			// Set plugin on/off
			Boolean enabled = pluginConfig.getEnabled();
			if (plugin != null && enabled != null)
			{
				enablePlugin(plugin, enabled);
			}
		});

		if (customPluginsToRestart.isEmpty())
		{
			onComplete.run();
		}
		else
		{
			// Toggle plugin immediately, then toggle again later (strange things happen otherwise)
			customPluginsToRestart.forEach((plugin, enabled) -> enablePlugin(plugin, !enabled, false));
			SwingUtilities.invokeLater(() -> {
				customPluginsToRestart.forEach((plugin, enabled) -> enablePlugin(plugin, enabled, false));
				onComplete.run();
			});
		}
	}

	private Plugin findPlugin(String plugin, Collection<Plugin> plugins)
	{
		for (Plugin p : plugins)
		{
			if (p.getName().equals(plugin))
			{
				return p;
			}
		}
		return null;
	}

	private void enablePlugin(Plugin plugin, boolean enabled)
	{
		enablePlugin(plugin, enabled, false);
	}

	private void enablePlugin(Plugin plugin, boolean enabled, boolean skipSetEnable)
	{
		if (!skipSetEnable)
		{
			pluginManager.setPluginEnabled(plugin, enabled);
		}

		try
		{
			if (enabled)
			{
				pluginManager.startPlugin(plugin);
			}
			else
			{
				pluginManager.stopPlugin(plugin);
			}
		}
		catch (PluginInstantiationException ex)
		{
			log.warn("Error when {} plugin {}", enabled ? "starting" : "stopping", plugin.getClass().getSimpleName(), ex);
		}
	}

	public PluginPreset createPluginPreset(String presetName)
	{
		return new PluginPreset(presetName);
	}

	public boolean isExternalPlugin(String pluginName)
	{
		if (pluginName.equals("RuneLite"))
		{
			return false;
		}
		return !corePlugins.contains(pluginName);
	}

	public boolean isExternalPluginInstalled(String pluginName)
	{
		return pluginManager.getPlugins().stream()
			.map(Plugin::getName).collect(Collectors.toList())
			.contains(pluginName);
	}

	public String getConfiguration(String groupName, String key)
	{
		return configManager.getConfiguration(groupName, key);
	}

	private List<String> getCorePlugins()
	{
		ArrayList<String> pluginNames = new ArrayList<>();
		try
		{
			ClassPath classPath = ClassPath.from(pluginManager.getClass().getClassLoader());
			List<Class<?>> plugins = classPath.getTopLevelClassesRecursive("net.runelite.client.plugins").stream()
				.map(ClassInfo::load)
				.collect(Collectors.toList());

			for (Class<?> clazz : plugins)
			{
				PluginDescriptor pluginDescriptor = clazz.getAnnotation(PluginDescriptor.class);
				if (pluginDescriptor != null)
				{
					pluginNames.add(pluginDescriptor.name());
				}
			}

		}
		catch (IOException e)
		{
			log.error("Error getting core plugins", e);
		}
		return pluginNames;
	}
}

/*
 * Copyright (c) 2023, antero111 <https://github.com/antero111>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pluginpresets;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Setter;
import net.runelite.client.config.Keybind;

/**
 * Container for storing all keybinds from all plugins across all presets
 */
@Singleton
public class KeybindManager
{
	private final HashMap<Keybind, List<PluginPreset>> keybinds;

	@Setter
	private CurrentConfigurations currentConfigurations;

	@Inject
	public KeybindManager()
	{
		this.keybinds = new HashMap<>();
	}

	public void cacheKeybinds(final List<PluginPreset> pluginPresets)
	{
		keybinds.clear();
		pluginPresets.forEach(preset -> {
			final Keybind keybind = preset.getKeybind();
			if (keybind != null)
			{
				// try to add to existing keybind list
				if (keybinds.containsKey(keybind))
				{
					keybinds.get(keybind).add(preset);
				}
				else
				{
					final List<PluginPreset> list = new ArrayList<>();
					list.add(preset);
					keybinds.put(keybind, list);
				}
			}
		});
	}

	public PluginPreset getPresetFor(final Keybind keybind)
	{
		if (keybinds.containsKey(keybind))
		{
			return getNextPreset(keybinds.get(keybind));
		}
		return null;
	}

	public void clearKeybinds()
	{
		keybinds.clear();
	}

	/**
	 * Returns the next preset for the same keybind.
	 * This allows for cycling through presets with the same keybind.
	 *
	 * @param list Plugin preset list for certain keybind
	 */
	private PluginPreset getNextPreset(final List<PluginPreset> list)
	{
		int currentIndex = -1;
		for (int i = 0; i < list.size(); i++)
		{
			final PluginPreset preset = list.get(i);
			if (preset.match(currentConfigurations))
			{
				currentIndex = i;
				break;
			}
		}
		return list.get(currentIndex == list.size() - 1 ? 0 : currentIndex + 1);
	}
}

package com.pluginpresets;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginPresetsPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(PluginPresetsPlugin.class);
		RuneLite.main(args);
	}
}
