/*
 * Copyright (c) 2018, Psikoi <https://github.com/Psikoi>
 * Copyright (c) 2025, rsfost <https://github.com/rsfost>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rsfost.ba_world_scouter;

import com.google.common.collect.Ordering;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.function.Function;

/**
 * Borrows heavily from World Hopper plugin
 */
class WorldInfoPanel extends PluginPanel
{
    private static final Color ODD_ROW = new Color(44, 44, 44);

    private static final int WORLD_COLUMN_WIDTH = 60;
    private static final int Y_COLUMN_WIDTH = 40;
    private static final int LAST_UPDATED_COLUMN_WIDTH = 47;

    private final BaWorldScouterPlugin plugin;
    private final JPanel listContainer;

    private WorldOrder orderIndex = WorldOrder.WORLD;
    private boolean ascendingOrder = true;

    private final ArrayList<WorldTableRow> rows = new ArrayList<>();

    private WorldInfoHeader worldHeader;
    private WorldInfoHeader yHeader;
    private WorldInfoHeader lastUpdatedHeader;

    public WorldInfoPanel(BaWorldScouterPlugin plugin)
    {
        this.plugin = plugin;

        setBorder(null);
        setLayout(new DynamicGridLayout(0, 1));

        JPanel headerContainer = buildHeader();
        this.listContainer = new JPanel();
        listContainer.setLayout(new GridLayout(0, 1));

        add(headerContainer);
        add(listContainer);
    }

    void populate(InstanceInfo[] worlds)
    {
        rows.clear();

        for (InstanceInfo instanceInfo : worlds)
        {
            WorldTableRow row = new WorldTableRow(instanceInfo);
            rows.add(row);
        }
        updateList();
    }

    void updateList()
    {
        listContainer.removeAll();

        rows.sort((r1, r2) -> {
            switch (orderIndex)
            {
                case INSTANCE_Y:
                    return getCompareValue(r1, r2, row -> row.getInstanceInfo().getY());
                case WORLD:
                    return getCompareValue(r1, r2, row -> row.getInstanceInfo().getWorldId());
                case LAST_UPDATED:
                    return getCompareValue(r1, r2, row -> row.getInstanceInfo().getTime());
                default:
                    return 0;
            }
        });

        for (int i = 0; i < rows.size(); ++i)
        {
            WorldTableRow row = rows.get(i);
            row.setBackground(i % 2 == 0 ? ODD_ROW : ColorScheme.DARK_GRAY_COLOR);
            listContainer.add(row);
        }

        listContainer.revalidate();
        listContainer.repaint();
    }

    private int getCompareValue(WorldTableRow row1, WorldTableRow row2, Function<WorldTableRow, Comparable> compareByFn)
    {
        Ordering<Comparable> ordering = Ordering.natural();
        if (!ascendingOrder)
        {
            ordering = ordering.reverse();
        }
        ordering = ordering.nullsLast();
        return ordering.compare(compareByFn.apply(row1), compareByFn.apply(row2));
    }

    @Override
    public void onActivate()
    {

    }

    @Override
    public void onDeactivate()
    {

    }

    private void orderBy(WorldOrder order)
    {
        yHeader.highlight(false, ascendingOrder);
        worldHeader.highlight(false, ascendingOrder);
        lastUpdatedHeader.highlight(false, ascendingOrder);

        switch (order)
        {
            case INSTANCE_Y:
                yHeader.highlight(true, ascendingOrder);
                break;
            case WORLD:
                worldHeader.highlight(true, ascendingOrder);
                break;
            case LAST_UPDATED:
                lastUpdatedHeader.highlight(true, ascendingOrder);
                break;
        }

        orderIndex = order;
        updateList();
    }

    private JPanel buildHeader()
    {
        JPanel header = new JPanel(new BorderLayout());
        JPanel leftSide = new JPanel(new BorderLayout());
        JPanel rightSide = new JPanel(new BorderLayout());

        yHeader = new WorldInfoHeader("Y", orderIndex == WorldOrder.INSTANCE_Y, ascendingOrder);
        yHeader.setPreferredSize(new Dimension(Y_COLUMN_WIDTH, 20));
        yHeader.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                if (SwingUtilities.isRightMouseButton(e))
                {
                    return;
                }
                ascendingOrder = orderIndex != WorldOrder.INSTANCE_Y || !ascendingOrder;
                orderBy(WorldOrder.INSTANCE_Y);
            }
        });

        worldHeader = new WorldInfoHeader("World", orderIndex == WorldOrder.WORLD, ascendingOrder);
        worldHeader.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 20));
        worldHeader.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                if (SwingUtilities.isRightMouseButton(e))
                {
                    return;
                }
                ascendingOrder = orderIndex != WorldOrder.WORLD || !ascendingOrder;
                orderBy(WorldOrder.WORLD);
            }
        });

        lastUpdatedHeader = new WorldInfoHeader("Last updated", orderIndex == WorldOrder.LAST_UPDATED, ascendingOrder);
        lastUpdatedHeader.setPreferredSize(new Dimension(LAST_UPDATED_COLUMN_WIDTH, 20));
        lastUpdatedHeader.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                if (SwingUtilities.isRightMouseButton(e))
                {
                    return;
                }
                ascendingOrder = orderIndex != WorldOrder.LAST_UPDATED || !ascendingOrder;
                orderBy(WorldOrder.LAST_UPDATED);
            }
        });

        leftSide.add(worldHeader, BorderLayout.WEST);
        leftSide.add(yHeader, BorderLayout.CENTER);

        rightSide.add(lastUpdatedHeader, BorderLayout.CENTER);

        header.add(leftSide, BorderLayout.WEST);
        header.add(rightSide, BorderLayout.CENTER);

        return header;
    }

    private enum WorldOrder
    {
        WORLD,
        INSTANCE_Y,
        LAST_UPDATED
    }
}

package rsfost.ba_world_scouter;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.WorldsFetch;
import net.runelite.client.game.WorldService;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;
import java.util.stream.Collectors;

@Slf4j
class InstanceInfoService
{
    private static final String API_BASE = "https://gkcgbnux6ylar7fzz6aiztnk3a0vzoct.lambda-url.us-east-1.on.aws";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    private final Client client;
    private final ClientThread clientThread;
    private final WorldService worldService;
    private final OkHttpClient httpClient;
    private final Gson gson;

    private volatile Map<Integer, World> allWorlds;
    private volatile EnumComposition worldLocations;

    @Inject
    public InstanceInfoService(
        Client client, ClientThread clientThread, ScheduledExecutorService executorService,
        WorldService worldService, OkHttpClient httpClient, Gson gson)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.worldService = worldService;
        this.httpClient = httpClient;
        this.gson = gson;

        // Get initial world list
        clientThread.invokeLater(() -> {
            if (client.getGameState().getState() < GameState.LOGIN_SCREEN.getState())
            {
                return false;
            }
            executorService.execute(() -> {
                if (!this.updateWorlds())
                {
                    log.warn("Failed to get initial world list.");
                }
            });
            return true;
        });
    }

    public void putInstanceInfo(WorldPoint wp, int regionId)
    {
        final int world = client.getWorld();
        JsonObject data = new JsonObject();
        data.addProperty("x", wp.getX());
        data.addProperty("y", wp.getY());
        data.addProperty("region", regionId);
        Request request = new Request.Builder()
            .url(API_BASE + "/world/" + world)
            .put(RequestBody.create(JSON, gson.toJson(data)))
            .build();
        Call call = httpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.error("Network error submitting world info", e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (response)
                {
                    if (response.code() == 200)
                    {
                        log.debug("Updated world info");
                    }
                    else
                    {
                        log.error("Unable to update world info (http {})", response.code());
                    }
                }
            }
        });
    }

    public void getInstanceInfos(Consumer<InstanceInfo[]> onSuccess, Consumer<Throwable> onError)
    {
        Request request = new Request.Builder()
            .url(API_BASE + "/worlds")
            .get()
            .build();
        Call call = httpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                String message = "Network error fetching world info";
                log.error("Network error fetching world info", e);
                onError.accept(new RuntimeException(message));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                try (ResponseBody respBody = response.body())
                {
                    if (!response.isSuccessful())
                    {
                        String message = String.format("Unable to fetch world info (http %d)", response.code());
                        log.error(message);
                        onError.accept(new RuntimeException(message));
                        return;
                    }
                    if (respBody == null)
                    {
                        String message = "Empty response from world fetch";
                        log.error(message);
                        onError.accept(new RuntimeException(message));
                        return;
                    }

                    String json = respBody.string();
                    InstanceInfo[] worlds = gson.fromJson(json, InstanceInfo[].class);
                    Arrays.stream(worlds).forEach(w -> {
                        if (allWorlds != null)
                        {
                            w.setWorld(allWorlds.get(w.getWorldId()));
                        }
                        if (worldLocations != null)
                        {
                            w.setWorldLocation(worldLocations.getIntValue(w.getWorldId()));
                        }
                    });
                    onSuccess.accept(worlds);
                }
            }
        });
    }

    @Subscribe
    public void onWorldsFetch(WorldsFetch event)
    {
        updateWorlds();
    }

    private boolean updateWorlds()
    {
        if (client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())
        {
            return false;
        }

        WorldResult worldResult = worldService.getWorlds();
        if (worldResult == null)
        {
            return false;
        }

        List<World> worlds = worldResult.getWorlds();
        this.allWorlds = worlds.stream().collect(Collectors.toMap(World::getId, w -> w));
        clientThread.invokeLater(() -> {
            this.worldLocations = client.getEnum(EnumID.WORLD_LOCATIONS);
        });

        return true;
    }
}

package rsfost.ba_world_scouter;

import lombok.RequiredArgsConstructor;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("ba_world_scouter")
public interface BaWorldScouterConfig extends Config
{
    @ConfigItem(
        keyName = "indicatorActiveMode",
        name = "Indication condition",
        description = "When to display the premove indicator",
        position = 1
    )
    default IndicatorActiveMode indicatorActiveMode()
    {
        return IndicatorActiveMode.SCROLLER_ONLY;
    }

    @ConfigItem(
        keyName = "indicatorDisplayMode",
        name = "Indication display",
        description = "How to display the premove indicator",
        position = 2
    )
    default IndicatorDisplayMode indicatorDisplayMode()
    {
        return IndicatorDisplayMode.INFO_BOX_AND_CHAT;
    }

    @RequiredArgsConstructor
    enum IndicatorDisplayMode
    {
        INFO_BOX_AND_CHAT("Info box/chat"),
        INFO_BOX("Info box"),
        CHAT("Chat");

        private final String name;

        public String toString()
        {
            return name;
        }
    }

    @RequiredArgsConstructor
    enum IndicatorActiveMode
    {
        SCROLLER_ONLY("As scroller"),
        BA_ONLY("In BA"),
        ALL_INSTANCES("All instances"),
        DISABLE("Disable");

        private final String name;

        public String toString()
        {
            return name;
        }
    }
}

package rsfost.ba_world_scouter;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.Color;
import java.awt.image.BufferedImage;

class PremoveInfoBox extends InfoBox
{
    @Getter
    @Setter
    private String text;
    @Getter @Setter
    private boolean goodPremove;

    public PremoveInfoBox(BufferedImage image, Plugin plugin)
    {
        super(image, plugin);
    }

    @Override
    public Color getTextColor()
    {
        return goodPremove ? Color.GREEN : Color.RED;
    }
}

package rsfost.ba_world_scouter;

import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.*;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import static rsfost.ba_world_scouter.BaWorldScouterConfig.*;

@Slf4j
@PluginDescriptor(
	name = "BA World Scouter",
	description = "Helps scout for worlds with good quick-start conditions in Barbarian Assault"
)
public class BaWorldScouterPlugin extends Plugin
{
	private static final int BA_LOBBY_REGION = 10322;
	private static final int BA_WAVE_REGION = 7509;
	private static final int BA_WAVE_10_REGION = 7508;
	private static final int PREMOVE_Y_THRESHOLD = 5300;

	@Inject
	private Client client;

	@Inject
	private BaWorldScouterConfig config;

	@Inject
	private InstanceInfoService instanceInfoService;

	@Inject
	private ItemManager itemManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private ChatMessageManager chatManager;

	@Inject
	private EventBus eventBus;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ScheduledExecutorService executorService;

	private NavigationButton navButton;
	private WorldInfoPanel panel;

	private PremoveInfoBox premoveInfoBox;
	private boolean premoveInfoBoxVisible;

	private boolean shouldCheckLocation;
	private int lastRegionId;
	private ScheduledFuture<?> fetchWorldsFuture;

	@Override
	protected void startUp() throws Exception
	{
		BufferedImage icon = ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "icon.png");
		panel = new WorldInfoPanel(this);
		navButton = NavigationButton.builder()
			.tooltip("BA World Scouter")
			.priority(4)
			.panel(panel)
			.icon(icon)
			.build();
		clientToolbar.addNavigation(navButton);

		fetchWorldsFuture = executorService.scheduleAtFixedRate(this::updateWorlds, 10, 30, TimeUnit.SECONDS);
		eventBus.register(instanceInfoService);

		if (premoveInfoBox == null)
		{
			premoveInfoBox = new PremoveInfoBox(itemManager.getImage(ItemID.TRAIL_WATCH), this);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		fetchWorldsFuture.cancel(true);
		clientToolbar.removeNavigation(navButton);
		eventBus.unregister(instanceInfoService);
		setInfoBoxVisible(false);
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (!shouldCheckLocation)
		{
			return;
		}

		final Player player = client.getLocalPlayer();
		final WorldView worldView = player.getWorldView();
		final WorldPoint wp = player.getWorldLocation();
		final int currentRegionId = wp.getRegionID();

		if (!worldView.isInstance())
		{
			setInfoBoxVisible(false);
			return;
		}
		if (currentRegionId == lastRegionId)
		{
			return;
		}

		final int templateRegionId = WorldPoint.fromLocalInstance(client,
			client.getLocalPlayer().getLocalLocation()).getRegionID();
		log.debug("y = {}, region id = {}", wp.getY(), templateRegionId);
		instanceInfoService.putInstanceInfo(wp, templateRegionId);
		announcePremoveCondition(wp, templateRegionId);
		shouldCheckLocation = false;
		lastRegionId = currentRegionId;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOADING)
		{
			shouldCheckLocation = true;
		}
	}

	@Provides
	BaWorldScouterConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BaWorldScouterConfig.class);
	}

	private void updateWorlds()
	{
		instanceInfoService.getInstanceInfos(
			instanceInfos -> {
				SwingUtilities.invokeLater(() -> {
					panel.populate(instanceInfos);
				});
			},
			error -> {
				log.error("Unable to update instance information", error);
				panel.updateList();
			}
		);
	}

	private void announcePremoveCondition(WorldPoint wp, int regionId)
	{
		if (config.indicatorActiveMode() == IndicatorActiveMode.DISABLE)
		{
			return;
		}

		final boolean baRegionOnly =
			config.indicatorActiveMode() == IndicatorActiveMode.SCROLLER_ONLY ||
			config.indicatorActiveMode() == IndicatorActiveMode.BA_ONLY;
		if (baRegionOnly && regionId != BA_WAVE_REGION && regionId != BA_WAVE_10_REGION)
		{
			return;
		}

		if (config.indicatorActiveMode() == IndicatorActiveMode.SCROLLER_ONLY)
		{
			ItemContainer inventory = client.getItemContainer(InventoryID.INV);
			if (inventory == null || !inventory.contains(ItemID.BARBASSAULT_SCROLL))
			{
				return;
			}
		}

		final String yStr = formatInt(wp.getY());
		final boolean goodPremove = wp.getY() < PREMOVE_Y_THRESHOLD;
		final String premoveStr = goodPremove ? "Good premove" : "Bad premove";
		switch (config.indicatorDisplayMode())
		{
			case INFO_BOX_AND_CHAT:
			case INFO_BOX:
				premoveInfoBox.setGoodPremove(goodPremove);
				premoveInfoBox.setText(yStr);
				premoveInfoBox.setTooltip(premoveStr);
				setInfoBoxVisible(true);
		}
		switch (config.indicatorDisplayMode())
		{
			case INFO_BOX_AND_CHAT:
			case CHAT:
				String message = ColorUtil.wrapWithColorTag(
					String.format("%s (%s)", premoveStr, yStr),
					goodPremove ? Color.GREEN : Color.RED);
				chatManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(message)
					.build());
		}
	}

	private void setInfoBoxVisible(boolean visible)
	{
		if (visible && !this.premoveInfoBoxVisible)
		{
			infoBoxManager.addInfoBox(premoveInfoBox);
		}
		else if (!visible && this.premoveInfoBoxVisible)
		{
			infoBoxManager.removeInfoBox(premoveInfoBox);
		}
		this.premoveInfoBoxVisible = visible;
	}

	private static String formatInt(int a)
	{
		return String.format("%d.%dk", a / 1000, (a % 1000) / 100);
	}
}

/*
 * Copyright (c) 2018, Psikoi <https://github.com/Psikoi>
 * Copyright (c) 2025, rsfost <https://github.com/rsfost>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rsfost.ba_world_scouter;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;

/**
 * Borrows heavily from World Hopper plugin
 */
class WorldInfoHeader extends JPanel
{
    private static final ImageIcon ARROW_UP;
    private static final ImageIcon HIGHLIGHT_ARROW_DOWN;
    private static final ImageIcon HIGHLIGHT_ARROW_UP;

    private static final Color ARROW_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
    private static final Color HIGHLIGHT_COLOR = ColorScheme.BRAND_ORANGE;

    static
    {
        final BufferedImage arrowDown = ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "arrow_down.png");
        final BufferedImage arrowUp = ImageUtil.rotateImage(arrowDown, Math.PI);
        final BufferedImage arrowUpFaded = ImageUtil.luminanceOffset(arrowUp, -80);
        ARROW_UP = new ImageIcon(arrowUpFaded);

        final BufferedImage highlightArrowDown = ImageUtil.fillImage(arrowDown, HIGHLIGHT_COLOR);
        final BufferedImage highlightArrowUp = ImageUtil.fillImage(arrowUp, HIGHLIGHT_COLOR);
        HIGHLIGHT_ARROW_DOWN = new ImageIcon(highlightArrowDown);
        HIGHLIGHT_ARROW_UP = new ImageIcon(highlightArrowUp);
    }

    private final JLabel textLabel = new JLabel();
    private final JLabel arrowLabel = new JLabel();
    // Determines if this header column is being used to order the list
    private boolean ordering = false;

    public WorldInfoHeader(String title, boolean ordered, boolean ascending)
    {
        setLayout(new BorderLayout(5, 0));
        setBorder(new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 0, 1, ColorScheme.MEDIUM_GRAY_COLOR),
            new EmptyBorder(0, 5, 0, 2)));
        setBackground(ColorScheme.SCROLL_TRACK_COLOR);

        textLabel.setText(title);
        textLabel.setFont(FontManager.getRunescapeSmallFont());

        highlight(ordered, ascending);

        arrowLabel.setIcon(HIGHLIGHT_ARROW_DOWN);

        add(textLabel, BorderLayout.WEST);
        add(arrowLabel, BorderLayout.EAST);
    }

    /**
     * The labels inherit the parent's mouse listeners.
     */
    @Override
    public void addMouseListener(MouseListener mouseListener)
    {
        super.addMouseListener(mouseListener);
        textLabel.addMouseListener(mouseListener);
        arrowLabel.addMouseListener(mouseListener);
    }

    /**
     * If this column header is being used to order, then it should be
     * highlighted, changing its font color and icon.
     */
    public void highlight(boolean on, boolean ascending)
    {
        ordering = on;
        arrowLabel.setIcon(on ? (ascending ? HIGHLIGHT_ARROW_DOWN : HIGHLIGHT_ARROW_UP) : ARROW_UP);
        textLabel.setForeground(on ? HIGHLIGHT_COLOR : ARROW_COLOR);
    }
}

package rsfost.ba_world_scouter;

import lombok.Data;
import lombok.RequiredArgsConstructor;
import net.runelite.http.api.worlds.World;

@Data
@RequiredArgsConstructor
class InstanceInfo
{
    private final int worldId;
    private final int y;
    private final long time;

    private transient World world;
    private transient int worldLocation;
}

/*
 * Copyright (c) 2018, Psikoi <https://github.com/Psikoi>
 * Copyright (c) 2025, rsfost <https://github.com/rsfost>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package rsfost.ba_world_scouter;

import lombok.Getter;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldRegion;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.time.Duration;
import java.time.Instant;

/**
 * Borrows heavily from World Hopper plugin
 */
class WorldTableRow extends JPanel
{
    private static final ImageIcon FLAG_AUS;
    private static final ImageIcon FLAG_UK;
    private static final ImageIcon FLAG_US;
    private static final ImageIcon FLAG_US_EAST;
    private static final ImageIcon FLAG_US_WEST;
    private static final ImageIcon FLAG_GER;

    private static final int WORLD_COLUMN_WIDTH = 60;
    private static final int Y_COLUMN_WIDTH = 40;
    private static final int LAST_UPDATED_COLUMN_WIDTH = 70;

    static
    {
        FLAG_AUS = new ImageIcon(ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "flag_aus.png"));
        FLAG_UK = new ImageIcon(ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "flag_uk.png"));
        FLAG_US = new ImageIcon(ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "flag_us.png"));
        FLAG_US_EAST = new ImageIcon(ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "flag_us_east.png"));
        FLAG_US_WEST = new ImageIcon(ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "flag_us_west.png"));
        FLAG_GER = new ImageIcon(ImageUtil.loadImageResource(BaWorldScouterPlugin.class, "flag_ger.png"));
    }

    private static final int LOCATION_US_WEST = -73;
    private static final int LOCATION_US_EAST = -42;

    @Getter
    private final InstanceInfo instanceInfo;

    private JLabel worldField;
    private JLabel yField;
    private JLabel lastUpdatedField;

    public WorldTableRow(InstanceInfo instanceInfo)
    {
        this.instanceInfo = instanceInfo;
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(2, 0, 2, 0));

        JPanel leftSide = new JPanel(new BorderLayout());
        JPanel rightSide = new JPanel(new BorderLayout());
        leftSide.setOpaque(false);
        rightSide.setOpaque(false);

        JPanel worldField = buildWorldField();
        worldField.setPreferredSize(new Dimension(WORLD_COLUMN_WIDTH, 20));
        worldField.setOpaque(false);

        JPanel yField = buildYField();
        yField.setPreferredSize(new Dimension(Y_COLUMN_WIDTH, 20));
        yField.setOpaque(false);

        JPanel lastUpdatedField = buildLastUpdatedField();
        lastUpdatedField.setPreferredSize(new Dimension(LAST_UPDATED_COLUMN_WIDTH, 20));
        lastUpdatedField.setOpaque(false);

        leftSide.add(worldField, BorderLayout.WEST);
        leftSide.add(yField, BorderLayout.CENTER);
        rightSide.add(lastUpdatedField, BorderLayout.EAST);

        add(leftSide, BorderLayout.WEST);
        add(rightSide, BorderLayout.CENTER);

    }

    private JPanel buildWorldField()
    {
        JPanel column = new JPanel(new BorderLayout(7, 0));
        column.setBorder(new EmptyBorder(0, 5, 0, 5));

        worldField = new JLabel(Integer.toString(instanceInfo.getWorldId()));

        World world = instanceInfo.getWorld();
        if (world != null)
        {
            ImageIcon flagIcon = getFlag(instanceInfo.getWorld().getRegion(), instanceInfo.getWorldLocation());
            if (flagIcon != null)
            {
                JLabel flag = new JLabel(flagIcon);
                column.add(flag, BorderLayout.WEST);
            }
        }

        column.add(worldField, BorderLayout.CENTER);

        return column;
    }

    private JPanel buildYField()
    {
        JPanel column = new JPanel(new BorderLayout());
        column.setBorder(new EmptyBorder(0, 5, 0, 5));

        yField = new JLabel(formatInt(instanceInfo.getY()));
        yField.setFont(FontManager.getRunescapeSmallFont());

        column.add(yField, BorderLayout.EAST);

        return column;
    }

    private JPanel buildLastUpdatedField()
    {
        JPanel column = new JPanel(new BorderLayout());
        column.setBorder(new EmptyBorder(0, 5, 0, 5));

        lastUpdatedField = new JLabel() {
            @Override
            public String getText() {
                return formatTime(instanceInfo.getTime());
            }
        };
        lastUpdatedField.setFont(FontManager.getRunescapeSmallFont());
        column.add(lastUpdatedField, BorderLayout.EAST);

        return column;
    }

    private static ImageIcon getFlag(WorldRegion region, int worldLocation)
    {
        if (region == null)
        {
            return null;
        }

        switch (region)
        {
            case UNITED_STATES_OF_AMERICA:
                switch (worldLocation)
                {
                    case LOCATION_US_WEST:
                        return FLAG_US_WEST;
                    case LOCATION_US_EAST:
                        return FLAG_US_EAST;
                    default:
                        return FLAG_US;
                }
            case UNITED_KINGDOM:
                return FLAG_UK;
            case AUSTRALIA:
                return FLAG_AUS;
            case GERMANY:
                return FLAG_GER;
            default:
                return null;
        }
    }

    private static String formatTime(long time)
    {
        Instant timestamp = Instant.ofEpochSecond(time);
        Instant now = Instant.now();
        long minutes = Duration.between(timestamp, now).toMinutes();

        if (minutes == 0)
        {
            return "Just now";
        }
        else if (minutes == 1)
        {
            return "1 min ago";
        }
        else
        {
            return String.format("%d mins ago", minutes);
        }
    }

    private static String formatInt(int a)
    {
        return String.format("%d.%dk", a / 1000, (a % 1000) / 100);
    }
}

package rsfost.ba_world_scouter;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BaWorldScouterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BaWorldScouterPlugin.class);
		RuneLite.main(args);
	}
}
