/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.db;

import com.flippingutilities.model.*;
import com.flippingutilities.ui.uiutilities.TimeFormatters;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * This class is responsible for handling all the IO related tasks for persisting trades. This class should contain
 * any logic that pertains to reading/writing to disk. This includes logic related to whether it should reload things
 * again, etc.
 */
@Slf4j
public class TradePersister
{
	Gson gson;

	public TradePersister(Gson gson) {
		this.gson = gson;
	}

	//this is in {user's home directory}/.runelite/flipping
	public static final File PARENT_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "flipping");
	public static final File OLD_FILE = new File(PARENT_DIRECTORY, "trades.json");

	/**
	 * Creates flipping directory if it doesn't exist and partitions trades.json into individual files
	 * for each account, if it exists.
	 *
	 * @throws IOException handled in FlippingPlugin
	 */
	public static void setupFlippingFolder() throws IOException
	{
		if (!PARENT_DIRECTORY.exists())
		{
			log.info("flipping directory doesn't exist yet so it's being created");
			if (!PARENT_DIRECTORY.mkdir())
			{
				throw new IOException("unable to create parent directory!");
			}
		}
		else
		{
			log.info("flipping directory already exists so it's not being created");
			if (OLD_FILE.exists())
			{
				OLD_FILE.delete();

			}
		}
	}

	/**
	 * loads each account's data from the parent directory located at {user's home directory}/.runelite/flipping/
	 * Each account's data is stored in separate file in that directory and is named {displayName}.json
	 *
	 * Why not use loadAccount(displayName) in this method? Here we have access to the files first so we can call
	 * loadFromFile directly. rather than getting the display name from the file and then calling
	 * loadAccount
	 *
	 * @return a map of display name to that account's data
	 * @throws IOException handled in FlippingPlugin
	 */
	public Map<String, AccountData> loadAllAccounts()
	{
		Map<String, AccountData> accountsData = new HashMap<>();
		for (File f : PARENT_DIRECTORY.listFiles())
		{
			if (f.getName().equals("accountwide.json") || !f.getName().contains(".json") || f.getName().contains(".backup.json") || f.getName().contains(".special.json")) {
				continue;
			}
			String displayName = f.getName().split("\\.")[0];
			AccountData accountData  = loadAccount(displayName);
			accountsData.put(displayName, accountData);
		}

		return accountsData;
	}

	//anything that wants to load an account's data MUST go through this method as it handles various cases such as
	//loading from backups
	public AccountData loadAccount(String displayName)
	{
		log.info("loading data for {}", displayName);
		try {
			File accountFile = new File(PARENT_DIRECTORY, displayName + ".json");
			AccountData accountData = loadFromFile(accountFile);
			if (accountData == null)
			{
				log.warn("data for {} is null for some reason. Will try loading from backup", displayName);
				accountData = loadAccountFromBackup(displayName);
			}
			return accountData;
		}
		catch (Exception e) {
			log.warn("Got exception {} while loading data for {}. Will try loading from backup", e, displayName);
			return loadAccountFromBackup(displayName);
		}
	}

	private AccountData loadAccountFromBackup(String displayName) {
		log.info("loading data for {} from backup", displayName);
		try {
			File accountFile = new File(PARENT_DIRECTORY, displayName + ".backup.json");
			if (!accountFile.exists()) {
				log.info("backup for {} does not exist, returning empty AccountData", displayName);
				return new AccountData();
			}
			AccountData accountData = loadFromFile(accountFile);
			if (accountData == null) {
				log.info("data loaded from backup for {} is null for some reason, returning an empty AccountData object", displayName);
				accountData = new AccountData();
			}
			return accountData;
		}
		catch (Exception e) {
			log.info("Couldn't load data for {} from backup due to {}", displayName, e);
			return new AccountData();
		}
	}

	private AccountData loadFromFile(File f) throws IOException
	{
		String accountDataJson = new String(Files.readAllBytes(f.toPath()));
		return gson.fromJson(accountDataJson, AccountData.class);
	}

	public AccountWideData loadAccountWideData() throws IOException {
		File accountFile = new File(PARENT_DIRECTORY, "accountwide.json");
		if (accountFile.exists()){
			String accountWideDataJson = new String(Files.readAllBytes(accountFile.toPath()));
			Type type = new TypeToken<AccountWideData>(){}.getType();
			return gson.fromJson(accountWideDataJson, type);
		}
		else {
			return new AccountWideData();
		}
	}

	public BackupCheckpoints fetchBackupCheckpoints() {
		try {
			log.info("Fetching backup checkpoints");
			File backupCheckpointsFile = new File(PARENT_DIRECTORY, "backupcheckpoints.special.json");
			if (backupCheckpointsFile.exists()){
				String backupCheckpointsJson = new String(Files.readAllBytes(backupCheckpointsFile.toPath()));
				Type type = new TypeToken<BackupCheckpoints>(){}.getType();
				return gson.fromJson(backupCheckpointsJson, type);
			}
			else {
				return new BackupCheckpoints();
			}
		}
		catch (Exception e) {
			return new BackupCheckpoints();
		}
	}

	/**
	 * stores trades for an account in {user's home directory}/.runelite/flipping/{account's display name}.json
	 *
	 * @param displayName display name of the account the data is associated with
	 * @param data        the trades and last offers of that account
	 * @throws IOException
	 */
	public void writeToFile(String displayName, Object data) throws IOException
	{
		log.info("Writing to file for {}", displayName);
		File accountFile = new File(PARENT_DIRECTORY, displayName + ".json");
		final String json = gson.toJson(data);
		Files.write(accountFile.toPath(), json.getBytes());
	}

	public static long lastModified(String fileName)
	{
		return new File(PARENT_DIRECTORY, fileName).lastModified();
	}

	public static void deleteFile(String fileName)
	{
		File accountFile = new File(PARENT_DIRECTORY, fileName);
		if (accountFile.exists())
		{
			if (accountFile.delete())
			{
				log.info("{} deleted", fileName);
			}
			else
			{
				log.info("unable to delete {}", fileName);
			}
		}
	}

	public static void exportToCsv(File file, List<FlippingItem> trades, String startOfIntervalName) throws IOException {
		FileWriter out = new FileWriter(file);
		CSVPrinter csvWriter = new CSVPrinter(out,
				CSVFormat.DEFAULT.
						withHeader("name", "date", "quantity", "price", "state").
						withCommentMarker('#').
						withHeaderComments("Displaying trades for selected time interval: " + startOfIntervalName));

		for (FlippingItem item : trades) {
			for (OfferEvent offer : item.getHistory().getCompressedOfferEvents()) {
				csvWriter.printRecord(
						item.getItemName(),
						TimeFormatters.formatInstantToDate(offer.getTime()),
						offer.getCurrentQuantityInTrade(),
						offer.getPrice(),
						offer.getState()
				);
			}
			csvWriter.printComment(String.format("Total profit: %d", FlippingItem.getProfit(item.getHistory().getCompressedOfferEvents())));
			csvWriter.println();
		}
		csvWriter.close();
	}
}

package com.flippingutilities.controller;

import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.model.Option;
import com.flippingutilities.utilities.InvalidOptionException;
import com.flippingutilities.utilities.WikiItemMargins;
import com.flippingutilities.utilities.WikiRequest;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.http.api.item.ItemStats;

import java.util.Optional;

public class OptionHandler {
    FlippingPlugin plugin;

    public OptionHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
    }

    public int calculateOptionValue(Option option, Optional<FlippingItem> highlightedItem, int highlightedItemId) throws InvalidOptionException {
        int val = 0;
        String propertyString = option.getProperty();
        switch (propertyString) {
            case Option.GE_LIMIT:
                val = geLimitCalculation(highlightedItem, highlightedItemId);
                break;
            case Option.REMAINING_LIMIT:
                val = remainingGeLimitCalculation(highlightedItem, highlightedItemId);
                break;
            case Option.CASHSTACK:
                val = cashStackCalculation(highlightedItem, highlightedItemId);
                break;
            case Option.INSTA_SELL:
                val = instaSellCalculation(highlightedItem);
                break;
            case Option.INSTA_BUY:
                val = instaBuyCalculation(highlightedItem);
                break;
            case Option.LAST_BUY:
                val = latestBuyCalculation(highlightedItem);
                break;
            case Option.LAST_SELL:
                val = latestSellCalculation(highlightedItem);
                break;
            case Option.WIKI_BUY:
                val = wikiPriceCalculation(highlightedItemId, true);
                break;
            case Option.WIKI_SELL:
                val = wikiPriceCalculation(highlightedItemId, false);
                break;
        }

        int finalValue = applyModifier(option.getModifier(), val);
        if (finalValue < 0) {
            throw new InvalidOptionException("resulting value was negative");
        }
        return finalValue;
    }

    private int wikiPriceCalculation(int itemId, boolean getBuyPrice) throws InvalidOptionException {
        if (plugin.getLastWikiRequestWrapper() != null) {
            WikiRequest wr = plugin.getLastWikiRequestWrapper().getWikiRequest();
            WikiItemMargins wikiItemMargins = wr.getData().get(itemId);
            int wikiPrice = getBuyPrice ? wikiItemMargins.getHigh() : wikiItemMargins.getLow();
            if (wikiPrice == 0) {
                throw new InvalidOptionException(String.format("no insta %s data for this item", getBuyPrice ? "buy" : "sell"));
            }
            return wikiPrice;
        } else {
            throw new InvalidOptionException("wiki request has not been made yet");
        }
    }

    private int remainingGeLimitCalculation(Optional<FlippingItem> item, int itemId) throws InvalidOptionException {
        ItemStats itemStats = plugin.getItemManager().getItemStats(itemId, false);
        int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;
        int totalGeLimit = item.map(FlippingItem::getTotalGELimit).orElse(geLimit);
        if (totalGeLimit <= 0) {
            throw new InvalidOptionException("Item does not have a known limit. Cannot calculate resulting value");
        }
        return item.map(FlippingItem::getRemainingGeLimit).orElse(geLimit);
    }

    private int geLimitCalculation(Optional<FlippingItem> item, int itemId) throws InvalidOptionException {
        ItemStats itemStats = plugin.getItemManager().getItemStats(itemId, false);
        int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;
        int totalGeLimit = item.map(FlippingItem::getTotalGELimit).orElse(geLimit);
        if (totalGeLimit <= 0) {
            throw new InvalidOptionException("Item does not have a known limit. Cannot calculate resulting value");
        }
        return item.map(FlippingItem::getTotalGELimit).orElse(geLimit);
    }

    private int cashStackCalculation(Optional<FlippingItem> item, int itemId) throws InvalidOptionException {
        if (getCashStackInInv() == 0) {
            throw new InvalidOptionException("Player has no cash in inventory");
        }
        int offerPrice = plugin.getClient().getVarbitValue(4398);
        if (offerPrice <= 0) {
            throw new InvalidOptionException("Item offer price missing");
        }

        return getCashStackInInv() / offerPrice;
    }

    private int instaBuyCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestInstaBuy().isPresent()) {
                return item.get().getLatestInstaBuy().get().getPrice();
            } else {
                throw new InvalidOptionException("item does not have an insta buy price");
            }
        }
    }

    private int instaSellCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestInstaSell().isPresent()) {
                return item.get().getLatestInstaSell().get().getPreTaxPrice();
            } else {
                throw new InvalidOptionException("item does not have an insta sell price");
            }
        }
    }

    private int latestSellCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestSell().isPresent()) {
                return item.get().getLatestSell().get().getPreTaxPrice();
            } else {
                throw new InvalidOptionException("item does not have a sell");
            }
        }
    }

    private int latestBuyCalculation(Optional<FlippingItem> item) throws InvalidOptionException {
        if (!item.isPresent()) {
            throw new InvalidOptionException("item was not bought or sold");
        } else {
            if (item.get().getLatestBuy().isPresent()) {
                return item.get().getLatestBuy().get().getPrice();
            } else {
                throw new InvalidOptionException("item does not have a buy");
            }
        }
    }

    private int applyModifier(String modifier, int value) throws InvalidOptionException {
        if (modifier.length() < 2) {
            throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
        }

        float num = 0;
        try {
            num = Float.parseFloat(modifier.substring(1));
            if (num < 0) {
                throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
            }
        } catch (NumberFormatException e) {
            throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
        }

        char operator = modifier.charAt(0);
        switch (operator) {
            case '-':
                return Math.round(value - num);
            case '+':
                return Math.round(value + num);
            case '*':
                return Math.round(value * num);
            default:
                throw new InvalidOptionException("Modifier has to be one of +,-,*, followed by a positive number. Example: +2, -5, *9");
        }
    }

    private int getCashStackInInv() {
        ItemContainer inventory = plugin.getClient().getItemContainer(InventoryID.INVENTORY);
        if (inventory == null) {
            return 0;
        }
        Item[] inventoryItems = inventory.getItems();
        for (Item item : inventoryItems) {
            if (item.getId() == 995) {
                return item.getQuantity();
            }
        }
        return 0;
    }

}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.controller;

import com.flippingutilities.db.TradePersister;
import com.flippingutilities.model.AccountData;
import com.flippingutilities.model.AccountWideData;
import com.flippingutilities.model.BackupCheckpoints;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.*;

/**
 * Responsible for loading data from disk, handling any operations to access/change data during the plugin's life, and storing
 * data to disk.
 */
@Slf4j
public class DataHandler {
    FlippingPlugin plugin;
    private AccountWideData accountWideData;
    private BackupCheckpoints backupCheckpoints;
    private Map<String, AccountData> accountSpecificData = new HashMap<>();
    private boolean accountWideDataChanged = false;
    private Set<String> accountsWithUnsavedChanges = new HashSet<>();
    public String thisClientLastStored;

    public DataHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
    }

    public AccountWideData viewAccountWideData() {
        return accountWideData;
    }

    public AccountWideData getAccountWideData() {
        accountWideDataChanged = true;
        return accountWideData;
    }

    public void addAccount(String displayName) {
        log.info("adding {} to data handler", displayName);
        AccountData accountData = new AccountData();
        accountData.prepareForUse(plugin);
        accountSpecificData.put(displayName, accountData);
    }

    public void deleteAccount(String displayName) {
        log.info("deleting account: {}", displayName);
        accountSpecificData.remove(displayName);
        TradePersister.deleteFile(displayName + ".json");
    }

    public Collection<AccountData> getAllAccountData() {
        accountsWithUnsavedChanges.addAll(accountSpecificData.keySet());
        return accountSpecificData.values();
    }

    public Collection<AccountData> viewAllAccountData() {
        return accountSpecificData.values();
    }

    //TODO this is a weird solution to the problem of having to know whether data changed...
    //TODO change it to something that perhaps takes a snapshot of data at plugin start and compares it to
    //TODO data at logout/plugin shutdown.
    //calls it if data is going to be updated,
    public AccountData getAccountData(String displayName) {
        accountsWithUnsavedChanges.add(displayName);
        return accountSpecificData.get(displayName);
    }

    //is called if account data just needs to be viewed, not updated
    public AccountData viewAccountData(String displayName) {
        return accountSpecificData.get(displayName);
    }

    public Set<String> getCurrentAccounts() {
        return accountSpecificData.keySet();
    }

    public void markDataAsHavingChanged(String displayName) {
        if (displayName.equals(FlippingPlugin.ACCOUNT_WIDE)) {
            accountWideDataChanged = true;
        }
        else {
            accountsWithUnsavedChanges.add(displayName);
        }
    }

    public void storeData() {
        log.info("storing data");
        if (accountsWithUnsavedChanges.size() > 0) {
            log.info("accounts with unsaved changes are {}. Saving them.", accountsWithUnsavedChanges);
            accountsWithUnsavedChanges.forEach(accountName -> storeAccountData(accountName));
            accountsWithUnsavedChanges.clear();
        }

        if (accountWideDataChanged) {
            log.info("accountwide data changed, saving it.");
            storeData("accountwide", accountWideData);
            accountWideDataChanged = false;
        }
    }

    public void loadData() {
        log.info("Loading data on startup");
        try {
            TradePersister.setupFlippingFolder();
        }
        catch (Exception e) {
            log.warn("Couldn't set up flipping folder, setting defaults", e);
            accountWideData = new AccountWideData();
            accountWideData.setDefaults();
            accountSpecificData = new HashMap<>();
            accountWideDataChanged = true;
            return;
        }

        backupCheckpoints = plugin.tradePersister.fetchBackupCheckpoints();
        accountWideData = fetchAccountWideData();
        accountSpecificData = fetchAndPrepareAllAccountData();
        backupAllAccountData();
    }
    
    private void backupAllAccountData() {
        log.info("backing up account data");
        boolean backupCheckpointsChanged = false;
        for (String displayName : accountSpecificData.keySet()) {
            AccountData accountData = accountSpecificData.get(displayName);
            //the data could be empty because there was an exception when loading it (such as in fetchAccountData)
            //or perhaps there are legitimately no trades because it is a new file or the user reset their history. In
            //any of these cases, we shouldn't back it up as its useless to backup an empty AccountData and, even worse, 
            //we may overwrite a previous backup with nothing.

            if (!accountData.getTrades().isEmpty() && backupCheckpoints.shouldBackup(displayName, accountData.getLastStoredAt())) {
                try { 
                    plugin.tradePersister.writeToFile(displayName + ".backup", accountData);
                    backupCheckpoints.getAccountToBackupTime().put(displayName, accountData.getLastStoredAt());
                    backupCheckpointsChanged = true;
                }
                catch (Exception e) {
                    log.warn("Couldn't backup account data for {} due to {}", displayName, e);
                }
            }
            else {
                log.info("Not backing up data for {} as it's empty or it hasn't changed since last backup", displayName);
            }
        }
        if (backupCheckpointsChanged) {
            storeData("backupCheckpoints.special", backupCheckpoints);
        }
    }

    private AccountWideData fetchAccountWideData() {
        try {
            log.info("Fetching accountwide data");
            AccountWideData accountWideData = plugin.tradePersister.loadAccountWideData();
            boolean didActuallySetDefaults = accountWideData.setDefaults();
            accountWideDataChanged = didActuallySetDefaults;
            return accountWideData;
        }
        catch (Exception e) {
            log.warn("couldn't load accountwide data, setting defaults", e);
            AccountWideData accountWideData = new AccountWideData();
            accountWideData.setDefaults();
            accountWideDataChanged = true;
            return accountWideData;
        }
    }

    private Map<String, AccountData> fetchAndPrepareAllAccountData()
    {
        Map<String, AccountData> accounts = fetchAllAccountData();
        prepareAllAccountData(accounts);
        return accounts;
    }

    private void prepareAllAccountData(Map<String, AccountData> allAccountData) {

        for (String displayName : allAccountData.keySet()) {
            AccountData accountData = allAccountData.get(displayName);
            try {
                accountData.startNewSession();
                accountData.prepareForUse(plugin);

            }

            catch (Exception e) {
                log.warn("Couldn't prepare account data for {} due to {}, setting default", displayName, e);
                AccountData newAccountData = new AccountData();
                newAccountData.startNewSession();
                newAccountData.prepareForUse(plugin);
                allAccountData.put(displayName, newAccountData);
            }
        }
    }

    private Map<String, AccountData> fetchAllAccountData() {
        try {
            return plugin.tradePersister.loadAllAccounts();
        }
        catch (Exception e) {
            log.warn("error propagated from tradePersister.loadAllAccounts() when fetching all account data, returning empty hashmap", e);
            return new HashMap<>();
        }
    }

    // Used by other components to set accountWideData on DataHandler
    public void loadAccountWideData() {
        accountWideData = fetchAccountWideData();
    }
    
    // Used by other components to set account data on DataHandler
    public void loadAccountData(String displayName) {
        log.info("loading data for {}", displayName);
        accountSpecificData.put(displayName, fetchAccountData(displayName));
    }

    private AccountData fetchAccountData(String displayName)
    {
        try {
            AccountData accountData = plugin.tradePersister.loadAccount(displayName);
            accountData.prepareForUse(plugin);
            return accountData;
        }
        catch (Exception e)
        {
            log.warn("couldn't load trades for {}, e = " + e, displayName);
            return new AccountData();
        }
    }

    private void storeAccountData(String displayName)
    {
        try
        {
            AccountData data = accountSpecificData.get(displayName);
            if (data == null)
            {
                log.info("for an unknown reason the data associated with {} has been set to null. Storing" +
                        "an empty AccountData object instead.", displayName);
                data = new AccountData();
            }
            thisClientLastStored = displayName;
            data.setLastStoredAt(Instant.now());
            plugin.tradePersister.writeToFile(displayName, data);
        }
        catch (Exception e)
        {
            log.info("couldn't store trades, error = " + e);
        }
    }

    private void storeData(String fileName, Object data) {
        try {
            plugin.tradePersister.writeToFile(fileName, data);
        }
        catch (Exception e) {
            log.info("couldn't store data to {} bc of {}",fileName, e);
        }
    }
}

package com.flippingutilities.controller;

import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.ui.flipping.FlippingPanel;
import com.flippingutilities.ui.offereditor.AbstractOfferEditorPanel;
import com.flippingutilities.ui.offereditor.OfferEditorContainerPanel;
import com.flippingutilities.ui.widgets.OfferEditor;
import com.flippingutilities.utilities.Constants;
import com.flippingutilities.utilities.WikiRequest;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.*;
import net.runelite.http.api.item.ItemStats;

import java.util.Optional;

import static net.runelite.api.VarPlayer.CURRENT_GE_ITEM;

/**
 * This class is responsible for handling all the logic that should trigger when the main game ui changes. For example,
 * this class should detect when the chatbox gets opened, when the ge history box opens, when the user is in the
 * ge offer setupFlippingFolder screen, etc and trigger appropriate logic in those cases.
 */
@Slf4j
public class GameUiChangesHandler {
    private static final int GE_OFFER_INIT_STATE_CHILD_ID = 20;
    private static final int GE_HISTORY_TAB_WIDGET_ID = 149;
    FlippingPlugin plugin;
    boolean quantityOrPriceChatboxOpen;
    Optional<FlippingItem> highlightedItem = Optional.empty();
    int highlightedItemId;

    GameUiChangesHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
    }

    public void onVarClientIntChanged(VarClientIntChanged event) {
        Client client = plugin.getClient();

        if (event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 14
                && client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS) != null) {
            plugin.getClientThread().invokeLater(() -> {
                Widget geSearchResultBox = client.getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
                Widget child = geSearchResultBox.createChild(-1, WidgetType.TEXT);
                child.setTextColor(0x800000);
                child.setFontId(FontID.VERDANA_13_BOLD);
                child.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
                child.setOriginalX(0);
                child.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
                child.setOriginalY(-15);
                child.setOriginalHeight(20);
                child.setXTextAlignment(WidgetTextAlignment.CENTER);
                child.setYTextAlignment(WidgetTextAlignment.CENTER);
                child.setWidthMode(WidgetSizeMode.MINUS);
                child.setText("Type a quick search code to see all favorited items with that code!");
                child.revalidate();
            });
        }

        if (quantityOrPriceChatboxOpen
                && event.getIndex() == VarClientInt.INPUT_TYPE
                && client.getVarcIntValue(VarClientInt.INPUT_TYPE) == 0
        ) {
            quantityOrPriceChatboxOpen = false;

            return;
        }

        //Check that it was the chat input that got enabled.
        if (event.getIndex() != VarClientInt.INPUT_TYPE
                || client.getWidget(ComponentID.CHATBOX_TITLE) == null
                || client.getVarcIntValue(VarClientInt.INPUT_TYPE) != 7
                || client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER) == null) {
            return;
        }
        quantityOrPriceChatboxOpen = true;

        plugin.getClientThread().invokeLater(() ->
        {
            OfferEditor flippingWidget = new OfferEditor(client.getWidget(ComponentID.CHATBOX_CONTAINER), client);
            Optional<FlippingItem> selectedItem = plugin.viewItemsForCurrentView().stream().filter(item -> item.getItemId() == client.getVarpValue(CURRENT_GE_ITEM)).findFirst();

            String chatInputText = client.getWidget(ComponentID.CHATBOX_TITLE).getText();
            String offerText = client.getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER).getChild(GE_OFFER_INIT_STATE_CHILD_ID).getText();

            if (chatInputText.equals("How many do you wish to buy?")) {
                plugin.getFlippingPanel().getOfferEditorContainerPanel().selectQuantityEditor();
                //No recorded data; default to total GE limit
                if (!selectedItem.isPresent()) {
                    ItemStats itemStats = plugin.getItemManager().getItemStats(client.getVarpValue(CURRENT_GE_ITEM), false);
                    int itemGELimit = itemStats != null ? itemStats.getGeLimit() : 0;
                    flippingWidget.showQuantityWidgets(itemGELimit);
                } else {
                    flippingWidget.showQuantityWidgets(selectedItem.get().getRemainingGeLimit());
                }
            } else if (chatInputText.equals("Set a price for each item:")) {
                plugin.getFlippingPanel().getOfferEditorContainerPanel().selectPriceEditor();
                WikiRequest wikiRequest = plugin.getLastWikiRequestWrapper().getWikiRequest();

                if (offerText.equals("Buy offer")) {
                    int instaSellPrice = 0;
                    int wikiInstaSellPrice = 0;
                    if (selectedItem.isPresent() && selectedItem.get().getLatestInstaSell().isPresent()) {
                        instaSellPrice = selectedItem.get().getLatestInstaSell().get().getPreTaxPrice();
                    }
                    if (wikiRequest != null && wikiRequest.getData().containsKey(highlightedItemId) && wikiRequest.getData().get(highlightedItemId).getLow() != 0) {
                        wikiInstaSellPrice = wikiRequest.getData().get(highlightedItemId).getLow();
                    }
                    flippingWidget.showInstaSellPrices(instaSellPrice, wikiInstaSellPrice);
                }
                else if (offerText.equals("Sell offer")) {
                    int instaBuyPrice = 0;
                    int wikiInstaBuyPrice = 0;
                    if (selectedItem.isPresent() && selectedItem.get().getLatestInstaBuy().isPresent()) {
                        instaBuyPrice = selectedItem.get().getLatestInstaBuy().get().getPrice();
                    }

                    if (wikiRequest != null && wikiRequest.getData().containsKey(highlightedItemId) && wikiRequest.getData().get(highlightedItemId).getHigh() != 0) {
                        wikiInstaBuyPrice = wikiRequest.getData().get(highlightedItemId).getHigh();
                    }
                    flippingWidget.showInstaBuyPrices(instaBuyPrice, wikiInstaBuyPrice);
                }
            }
        });
    }

    public void onVarbitChanged(VarbitChanged event) {
        Client client = plugin.getClient();

        //when a user clicks on a slot or leaves one, this event triggers
        if (event.getVarpId() == 375) {
            plugin.getSlotStateDrawer().hideQuickLookPanel();
            handleClickOrLeaveOffer();
            return;
        }

        FlippingPanel flippingPanel = plugin.getFlippingPanel();
        OfferEditorContainerPanel offerEditorContainerPanel = flippingPanel.getOfferEditorContainerPanel();
        //this is the varbit with id 4398

        if (event.getVarpId() == 1043 && offerEditorContainerPanel != null) {
            AbstractOfferEditorPanel quantityEditorPanel = offerEditorContainerPanel.quantityEditorPanel;
            quantityEditorPanel.rebuild(quantityEditorPanel.getOptions());
        }

        //CURRENT_GE_ITEM == 1151
        if (event.getVarpId() == 1151 && client.getVarpValue(CURRENT_GE_ITEM) != -1 && client.getVarpValue(CURRENT_GE_ITEM) != 0) {
            highlightOffer(plugin.getClient().getVarpValue(CURRENT_GE_ITEM));
        }

        //need to check if panel is highlighted in this case because curr ge item is changed if you come back to ge interface after exiting out
        //and curr ge item would be -1 or 0 in that case and would trigger a dehighlight erroneously.
        if (event.getVarpId() == 1151 &&
                (client.getVarpValue(CURRENT_GE_ITEM) == -1 || client.getVarpValue(CURRENT_GE_ITEM) == 0) && highlightedItem.isPresent()) {
            deHighlightOffer();
        }
    }

    /**
     * Is triggered when a user clicks on an offer or leaves one
     */
    private void handleClickOrLeaveOffer() {
        Client client = plugin.getClient();
        int slot = client.getVarbitValue(4439) - 1;
        if (slot == -1 && highlightedItem.isPresent()) {
            deHighlightOffer();
            return;
        }
        if (slot != -1 && !highlightedItem.isPresent()) {
            int itemId = plugin.getClient().getGrandExchangeOffers()[slot].getItemId();
            if (itemId == 0) {
                return;
            }
            highlightOffer(itemId);
        }
    }

    /**
     * Can't use this for resetting the widgets on the slot widget handlers bc no WidgetLoaded
     * events are fired when the widgets are redrawn (?).
     */
    public void onWidgetLoaded(WidgetLoaded event) {
        //ge history widget loaded
        //GE_HISTORY_TAB_WIDGET_ID does not load when history tab is opened from the banker right click. It only loads when
        //the "history" button is clicked for the ge interface. However, 383 loads in both situations.
        if (event.getGroupId() == 383) {
            plugin.showGeHistoryTabPanel();
        }

        //if either ge interface or bank pin interface is loaded, hide the ge history tab panel again
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE || event.getGroupId() == 213) {
            plugin.getMasterPanel().selectPreviouslySelectedTab();
        }

        //remove highlighted item
        //The player opens the trade history tab from the ge interface. Necessary since the back button isn't considered hidden here.
        //this (id 149 and not id 383) will also trigger when the player just exits out of the ge interface offer window screen, which is good
        //as then the highlight won't linger in that case.
        if (event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID && highlightedItem.isPresent()) {
            deHighlightOffer();
        }

        if (event.getGroupId() == GE_HISTORY_TAB_WIDGET_ID) {
            plugin.getSlotStateDrawer().hideQuickLookPanel();
        }
    }


    /**
     * script 804 is Fired after every GE offer slot redraw
     * This seems to happen after any offer updates or if buttons are pressed inside the interface
     * https://github.com/RuneStar/cs2-scripts/blob/a144f1dceb84c3efa2f9e90648419a11ee48e7a2/scripts/%5Bclientscript%2Cge_offers_switchpanel%5D.cs2
     * need to redraw stuff when this happens as all widgets get reset
     *
     * script 782 fires at most of the times 804 is fired but also when the collect button is pressed
     * which is important bc that resets the widgets too
     */
    public void onScriptPostFired(ScriptPostFired event) {
        //ge history interface closed, so the geHistoryTabPanel should no longer show
        if (event.getScriptId() == 29) {
            plugin.getMasterPanel().selectPreviouslySelectedTab();
        }

        if (event.getScriptId() == 782 || event.getScriptId() == 804) {
           plugin.setWidgetsOnSlotStateDrawer();
        }

        if (event.getScriptId() == 804 && plugin.getConfig().slotTimersEnabled()) {
            plugin.setWidgetsOnSlotTimers();
        }
    }

    private void highlightOffer(int itemId) {
        highlightedItemId = itemId;
        Optional<FlippingItem> itemInHistory = plugin.viewItemsForCurrentView().stream().filter(item -> item.getItemId() == highlightedItemId).findFirst();
        if (itemInHistory.isPresent()) {
            highlightedItem = itemInHistory;
        }
        else {
            String itemName = plugin.getItemManager().getItemComposition(highlightedItemId).getName();
            ItemStats itemStats = plugin.getItemManager().getItemStats(highlightedItemId, false);
            int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;
            FlippingItem dummyFlippingItem = new FlippingItem(highlightedItemId, itemName, geLimit, Constants.DUMMY_ITEM);
            dummyFlippingItem.setValidFlippingPanelItem(true);
            highlightedItem = Optional.of(dummyFlippingItem);
        }

        plugin.getFlippingPanel().highlightItem(highlightedItem.get());
    }

    private void deHighlightOffer() {
        highlightedItem = Optional.empty();
        plugin.getFlippingPanel().dehighlightItem();
    }
}

package com.flippingutilities.controller;

import com.flippingutilities.utilities.Jwt;
import com.flippingutilities.utilities.OsrsAccount;
import com.flippingutilities.utilities.User;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * This class handles all of the extra logic associated with performing logins.
 * ALL attempts to login with the api MUST go through this class.
 * Its main responsibility is ensuring that there is a central place where  components can subscribe to successful
 * logins and fire off some action whenever a login happens.
 */
@Slf4j
public class ApiAuthHandler {
    FlippingPlugin plugin;
    @Getter
    @Setter
    private boolean hasValidJWT;
    private Set<String> successfullyRegisteredRsns = new HashSet<>();
    List<Runnable> validJwtSubscriberActions = new ArrayList<>();
    List<Consumer<Boolean>> premiumCheckSubscribers = new ArrayList<>();
    @Getter
    @Setter
    private boolean isPremium;

    public ApiAuthHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
    }

    public void subscribeToLogin(Runnable r) {
        this.validJwtSubscriberActions.add(r);
    }
    
    public void subscribeToPremiumChecking(Consumer<Boolean> consumer) {
        this.premiumCheckSubscribers.add(consumer);
    }

    /**
     * Shouldn't bother sending requests to the api if the jwt is not valid or the rsn was not successfully registered.
     * This is purely to prevent the plugin from sending unnecessary requests, the api would reject the requests anyway.
     */
    public boolean canCommunicateWithApi(String displayName) {
        return this.hasValidJWT && successfullyRegisteredRsns.contains(displayName);
    }

    /**
     * Checks if the user is premium, and if so, sets the premium status
     */
    public void setPremiumStatus() {
        if (!hasValidJWT) {
            return;
        }
        plugin.getApiRequestHandler().getUser().whenComplete((user, exception) -> {
            if (exception != null) {
                log.info("failed to get user, error: ", exception);
                isPremium = false;
            }
            else {
                log.info("got user, premium status: {}", user.isPremium());
                isPremium = user.isPremium();
            }
            premiumCheckSubscribers.forEach(c -> c.accept(isPremium));
        });
    }

    /**
     * Checks if the existing JWT has expired, and if so, gets a refreshed JWT. The setting of validJwt is purely
     * to stop the plugin from making useless requests, the api will safely reject invalid jwts itself.
     *
     * This should be called on client start up
     */
    public CompletableFuture<String> checkExistingJwt() {
        String jwtString = plugin.getDataHandler().getAccountWideData().getJwt();
        if (jwtString == null) {
            log.info("no jwt stored locally, not attempting to check existing jwt");
            return CompletableFuture.completedFuture("no jwt");
        }
        try {
            Jwt jwt = Jwt.fromString(jwtString, plugin.gson);
            if (jwt.isExpired()) {
                //TODO use master panel to display message about having to relog using a new token from flopper
                log.info("jwt is expired, prompting user to re log");
                hasValidJWT = false;
                return CompletableFuture.completedFuture("expired");
            }
            else if (jwt.shouldRefresh()) {
                return refreshJwt(jwtString);
            }
            else {
                log.info("jwt is valid");
                hasValidJWT = true;
                validJwtSubscriberActions.forEach(Runnable::run);
                return CompletableFuture.completedFuture("valid jwt");
            }
        }
        //this catch clause is just for the Jwt.fromString line
        catch (Exception e) {
            log.info("failed to check existing jwt, error: ", e);
            return CompletableFuture.completedFuture("error");
        }
    }

    private CompletableFuture<String> refreshJwt(String jwtString) {
        log.info("refresh jwt");
        hasValidJWT = true; //so it passes the check in refreshJwt
        CompletableFuture<String> newJwtFuture = plugin.getApiRequestHandler().refreshJwt(jwtString);
        return newJwtFuture.whenComplete((newJwt, exception) -> {
            if (exception != null) {
                log.info("failed to refresh jwt, error: ", exception);
                hasValidJWT = false; //validJwt is false by default, just setting it here for clarity
            }
            else {
                plugin.getDataHandler().getAccountWideData().setJwt(newJwt);
                hasValidJWT = true;
                log.info("successfully refreshed jwt");
                validJwtSubscriberActions.forEach(Runnable::run);
            }
        });
    }

    public CompletableFuture<Set<String>> checkRsn(String displayName) {
        if (!hasValidJWT) {
            log.debug("not checking rsn as we don't have a valid jwt yet");
            return CompletableFuture.completedFuture(this.successfullyRegisteredRsns);
        }
        CompletableFuture<List<OsrsAccount>> userAccountsFuture = plugin.getApiRequestHandler().getUserAccounts();
        return userAccountsFuture.thenCompose(accs -> {
            Set<String> registeredRsns = accs.stream().map(OsrsAccount::getRsn).collect(Collectors.toSet());
            if (registeredRsns.contains(displayName)) {
                successfullyRegisteredRsns.add(displayName);
                log.debug("rsn: {} is already registered, not registering again", displayName);
                return CompletableFuture.completedFuture(successfullyRegisteredRsns);
            }
            else {
                return plugin.getApiRequestHandler().registerNewAccount(displayName).
                        thenApply(acc -> {
                            successfullyRegisteredRsns.add(acc.getRsn());
                            log.debug("added rsn: {} to successfullyRegisteredRsns", acc.getRsn());
                            return successfullyRegisteredRsns;
                        }).
                        exceptionally(e -> {
                            log.debug("could not register display name: {}, error: {}", displayName, e);
                            return successfullyRegisteredRsns;
                });
            }
        }).exceptionally(e -> {
            log.debug("could not check rsn", e);
            return successfullyRegisteredRsns;
        });
    }

    public CompletableFuture<String> loginWithToken(String token) {
        log.info("attempting to login with token!");
        CompletableFuture<String> jwtFuture = plugin.getApiRequestHandler().loginWithToken(token);

        jwtFuture.whenComplete((jwt, exception) -> {
            if (exception != null) {
                log.info("failed to login with token!", exception);
            }
            else {
                plugin.getDataHandler().getAccountWideData().setJwt(jwt);
                hasValidJWT = true;
                validJwtSubscriberActions.forEach(Runnable::run);
                log.info("successfully logged in with token!");
                if (plugin.getCurrentlyLoggedInAccount() != null) {
                    checkRsn(plugin.getCurrentlyLoggedInAccount());
                }
                setPremiumStatus();
            }
        });

        return jwtFuture;
    }
}

package com.flippingutilities.controller;

import com.flippingutilities.model.AccountData;
import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.model.PartialOffer;
import com.flippingutilities.utilities.SORT;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.stream.Collectors;

public class FlippingItemHandler {
    FlippingPlugin plugin;

    FlippingItemHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
    }

    public List<FlippingItem> sortItems(List<FlippingItem> items, SORT selectedSort, Instant startOfInterval)
    {
        List<FlippingItem> result = new ArrayList<>(items);

        if (selectedSort == null || result.isEmpty()) {
            return result;
        }

        switch (selectedSort) {
            case TIME:
                result.sort(Comparator.comparing(FlippingItem::getLatestActivityTime));
                break;

            case TOTAL_PROFIT:
                result.sort(Comparator.comparing(item -> {
                    Map<String, PartialOffer> offerIdToPartialOffer = plugin.getOfferIdToPartialOffer(item.getItemId());
                    ArrayList<OfferEvent> intervalHistory = item.getIntervalHistory(startOfInterval);
                    List<OfferEvent> adjustedOffers = FlippingItem.getPartialOfferAdjustedView(intervalHistory, offerIdToPartialOffer);
                    return FlippingItem.getProfit(adjustedOffers);
                }));
                break;

            case PROFIT_EACH:
                result.sort(Comparator.comparing(item -> {
                    Map<String, PartialOffer> offerIdToPartialOffer = plugin.getOfferIdToPartialOffer(item.getItemId());
                    ArrayList<OfferEvent> intervalHistory = item.getIntervalHistory(startOfInterval);
                    List<OfferEvent> adjustedOffers = FlippingItem.getPartialOfferAdjustedView(intervalHistory, offerIdToPartialOffer);
                    long quantity = FlippingItem.countFlipQuantity(adjustedOffers);
                    if (quantity == 0) {
                        return Long.MIN_VALUE;
                    }

                    long profit = FlippingItem.getProfit(adjustedOffers);
                    return profit / quantity;
                }));
                break;
            case ROI:
                result.sort(Comparator.comparing(item -> {
                    Map<String, PartialOffer> offerIdToPartialOffer = plugin.getOfferIdToPartialOffer(item.getItemId());
                    List<OfferEvent> intervalHistory = item.getIntervalHistory(startOfInterval);
                    List<OfferEvent> adjustedOffers = FlippingItem.getPartialOfferAdjustedView(intervalHistory, offerIdToPartialOffer);

                    long profit = FlippingItem.getProfit(adjustedOffers);
                    long expense = FlippingItem.getValueOfMatchedOffers(adjustedOffers, true);
                    if (expense == 0) {
                        return Float.MIN_VALUE;
                    }

                    return (float) profit / expense * 100;
                }));
                break;
            case FLIP_COUNT:
                result.sort(Comparator.comparing(
                    item -> {
                        Map<String, PartialOffer> offerIdToPartialOffer = plugin.getOfferIdToPartialOffer(item.getItemId());
                        List<OfferEvent> intervalHistory = item.getIntervalHistory(startOfInterval);
                        List<OfferEvent> adjustedOffers = FlippingItem.getPartialOfferAdjustedView(intervalHistory, offerIdToPartialOffer);
                        return FlippingItem.countFlipQuantity(adjustedOffers);
                    }));
                break;
        }
        Collections.reverse(result);
        return result;
    }

    public void deleteRemovedItems(List<FlippingItem> currItems) {
        currItems.removeIf((item) ->
        {
            if (item.getGeLimitResetTime() != null) {
                Instant startOfRefresh = item.getGeLimitResetTime().minus(4, ChronoUnit.HOURS);

                return !item.getValidFlippingPanelItem() && !item.hasValidOffers()
                    && (!Instant.now().isAfter(item.getGeLimitResetTime()) || item.getGeLimitResetTime().isBefore(startOfRefresh));
            }
            return !item.getValidFlippingPanelItem() && !item.hasValidOffers();
        });
    }

    /**
     * creates a view of an "account wide tradelist". An account wide tradelist is just a reflection of the flipping
     * items currently in each of the account's tradelists. It does this by merging the flipping items of the same type
     * from each account's trade list into one flipping item.
     */
    List<FlippingItem> createAccountWideFlippingItemList(Collection<AccountData> allAccountData) {
        //take all flipping items from the account cache, regardless of account, and segregate them based on item name.
        Map<Integer, List<FlippingItem>> groupedItems = allAccountData.stream().
            flatMap(accountData -> accountData.getTrades().stream()).
            map(FlippingItem::clone).
            collect(Collectors.groupingBy(FlippingItem::getItemId));

        //take every list containing flipping items of the same type and reduce it to one merged flipping item and put that
        //item in a final merged list
        List<FlippingItem> mergedItems = groupedItems.values().stream().
            map(list -> list.stream().reduce(FlippingItem::merge)).filter(Optional::isPresent).map(Optional::get).
            collect(Collectors.toList());

        mergedItems.sort(Collections.reverseOrder(Comparator.comparing(FlippingItem::getLatestActivityTime)));

        return mergedItems;
    }
}

package com.flippingutilities.controller;

import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.widgets.SlotActivityTimer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.WorldType;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.http.api.item.ItemStats;

import java.time.Instant;
import java.util.*;

@Slf4j
public class NewOfferEventPipelineHandler {
    FlippingPlugin plugin;

    NewOfferEventPipelineHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
    }

    /**
     * This method is invoked every time the plugin receives a GrandExchangeOfferChanged event which is
     * when the user set an offer, cancelled an offer, or when an offer was updated (items bought/sold partially
     * or completely).
     *
     * @param offerChangedEvent the offer event that represents when an offer is updated
     *                          (buying, selling, bought, sold, cancelled sell, or cancelled buy)
     */
    @Subscribe
    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerChangedEvent) {
        EnumSet<WorldType> currentWorldType = this.plugin.getClient().getWorldType();
        EnumSet<WorldType> excludedWorldTypes = EnumSet.of(WorldType.SEASONAL);
        if (!Collections.disjoint(currentWorldType, excludedWorldTypes)) {
            return;
        }

        if (plugin.getCurrentlyLoggedInAccount() == null) {
            OfferEvent newOfferEvent = createOfferEvent(offerChangedEvent);

            //event came in before account was fully logged in. This means that the offer actually came through
            //sometime when the account was logged out, at an undetermined time. We need to mark the offer as such to
            //avoid adjusting ge limits and slot timers incorrectly (cause we don't know exactly when the offer came in)
            newOfferEvent.setBeforeLogin(true);
            plugin.getEventsReceivedBeforeFullLogin().add(newOfferEvent);
            return;
        }
        OfferEvent newOfferEvent = createOfferEvent(offerChangedEvent);
        if (newOfferEvent.getTickArrivedAt() == plugin.getLoginTickCount()) {
            newOfferEvent.setBeforeLogin(true);
        }
        onNewOfferEvent(newOfferEvent);
    }

    public void onNewOfferEvent(OfferEvent newOfferEvent) {
        String currentlyLoggedInAccount = plugin.getCurrentlyLoggedInAccount();
        if (currentlyLoggedInAccount != null) {
            newOfferEvent.setMadeBy(currentlyLoggedInAccount);
        }

        Optional<OfferEvent> screenedOfferEvent = screenOfferEvent(newOfferEvent);

        if (!screenedOfferEvent.isPresent()) {
            return;
        }

        OfferEvent finalizedOfferEvent = screenedOfferEvent.get();
        
        List<FlippingItem> currentlyLoggedInAccountsTrades = plugin.getDataHandler().getAccountData(currentlyLoggedInAccount).getTrades();

        Optional<FlippingItem> flippingItem = currentlyLoggedInAccountsTrades.stream().filter(item -> item.getItemId() == finalizedOfferEvent.getItemId()).findFirst();

        updateTradesList(currentlyLoggedInAccountsTrades, flippingItem, finalizedOfferEvent.clone());

        plugin.setUpdateSinceLastItemAccountWideBuild(true);

        rebuildDisplayAfterOfferEvent(finalizedOfferEvent);
    }

    /**
     * There is no point rebuilding either the stats panel or flipping panel when the user is looking at the trades list of
     * one of their accounts that isn't logged in as that trades list won't be being updated anyway.
     *
     * @param offerEvent   offer event just received
     */
    private void rebuildDisplayAfterOfferEvent(OfferEvent offerEvent) {

        if (!(plugin.getAccountCurrentlyViewed().equals(plugin.getCurrentlyLoggedInAccount()) ||
                plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE))) {
            return;
        }

        plugin.getFlippingPanel().onNewOfferEventRebuild(offerEvent);
        plugin.getStatPanel().rebuildItemsDisplay(plugin.viewItemsForCurrentView());
    }

    /**
     * Every single OfferEvent passes through this method for screening before being sent to the wider system because
     * offer updates have strange quirks such as duplicates, empty updates, etc.
     *
     * For example, every empty/buy/sell/cancelled buy/cancelled sell
     * spawns two identical events. And when you fully buy/sell item, it spawns two events (a
     * buying/selling event and a bought/sold event). This method screens out the unwanted events/duplicate
     * events and sets the ticksSinceFirstOffer field correctly on new OfferEvents. For detailed documentation see
     * the "Documenting RL events" section in the README.
     *
     * If some component needs access to OfferEvents prior to screening or at some point in the screening prior to
     * completion or in some way needs to benefit from the internal logic of this method, then we can pass the OfferEvent
     * to that component in this method itself. We currently do this with the slotsPanel and slotActivityTimer.
     *
     * @param newOfferEvent event that just occurred
     * @return an optional containing an OfferEvent.
     */
    public Optional<OfferEvent> screenOfferEvent(OfferEvent newOfferEvent) {
        plugin.getSlotsPanel().update(newOfferEvent);

        Map<Integer, OfferEvent> lastOfferEventForEachSlot = plugin.getDataHandler().getAccountData(plugin.getCurrentlyLoggedInAccount()).getLastOffers();
        List<SlotActivityTimer> slotActivityTimers = plugin.getDataHandler().getAccountData(plugin.getCurrentlyLoggedInAccount()).getSlotTimers();
        OfferEvent lastOfferEvent = lastOfferEventForEachSlot.get(newOfferEvent.getSlot());

        //completely useless updates
        if (newOfferEvent.isCausedByEmptySlot() && newOfferEvent.isBeforeLogin()) {
            return Optional.empty();
        }

        //is null when an offer was cleared or perhaps the slot in game has an offer but that offer was made
        //outside the plugin, so the lastOfferEvent for that slot is still null.
        if (lastOfferEvent == null) {
            //don't think newOfferEvent can be caused by an empty slot at this point but i'm leaving this old code
            //here in case i'm overlooking something that past self caught...
            if (!newOfferEvent.isCausedByEmptySlot()) {
                lastOfferEventForEachSlot.put(newOfferEvent.getSlot(), newOfferEvent);
                slotActivityTimers.get(newOfferEvent.getSlot()).setCurrentOffer(newOfferEvent);
            }
            if (newOfferEvent.isStartOfOffer()) {
                newOfferEvent.setTradeStartedAt(Instant.now());
            }

            return Optional.empty();
        }

        //we get essentially every offer event twice..
        if (lastOfferEvent.isDuplicate(newOfferEvent)) {
            return Optional.empty();
        }

        //because we took care of the empty slot updates on login in a previous clause, this
        //will only trigger on empty slot updates when an offer is collected
        if (newOfferEvent.isCausedByEmptySlot()) {
            lastOfferEventForEachSlot.remove(newOfferEvent.getSlot());
            slotActivityTimers.get(newOfferEvent.getSlot()).reset();
            return Optional.empty();
        }

        if (newOfferEvent.isRedundantEventBeforeOfferCompletion()) {
            return Optional.empty();
        }

        newOfferEvent.setTicksSinceFirstOffer(lastOfferEvent);
        newOfferEvent.setTradeStartedAt(lastOfferEvent.getTradeStartedAt());
        lastOfferEventForEachSlot.put(newOfferEvent.getSlot(), newOfferEvent);
        slotActivityTimers.get(newOfferEvent.getSlot()).setCurrentOffer(newOfferEvent);
        return newOfferEvent.getCurrentQuantityInTrade() ==0? Optional.empty() : Optional.of(newOfferEvent);
    }

    /**
     * Creates an OfferEvent object out of a GrandExchangeOfferChanged event and adds additional attributes such as
     * tickArrivedAt to help identify margin check offers.
     *
     * @param newOfferEvent event that we subscribe to.
     * @return an OfferEvent object with the relevant information from the event.
     */
    private OfferEvent createOfferEvent(GrandExchangeOfferChanged newOfferEvent) {
        OfferEvent offer = OfferEvent.fromGrandExchangeEvent(newOfferEvent);
        offer.setTickArrivedAt(plugin.getClient().getTickCount());
        offer.setMadeBy(plugin.getCurrentlyLoggedInAccount());
        return offer;
    }

    /**
     * This method updates the given trade list in response to an OfferEvent
     *
     * @param trades       the trades list to update
     * @param flippingItem the flipping item to be updated in the tradeslist, if it even exists
     * @param newOffer     new offer that just came in
     */
    private void updateTradesList(List<FlippingItem> trades, Optional<FlippingItem> flippingItem, OfferEvent newOffer) {
        if (flippingItem.isPresent()) {
            FlippingItem item = flippingItem.get();

            //if a user buys/sells an item they previously deleted from the flipping panel, show the panel again.
            if (!item.getValidFlippingPanelItem()) {
                item.setValidFlippingPanelItem(true);
            }

            item.updateHistory(newOffer);
            item.updateLatestProperties(newOffer);
        } else {
            addToTradesList(trades, newOffer);
        }
    }

    /**
     * Constructs a FlippingItem, the data structure that represents an item the user is currently flipping, and
     * adds it to the given trades list. This method is invoked when we receive an offer event for an item that isn't
     * currently present in the trades list.
     *
     * @param tradesList the trades list to be updated
     * @param newOffer   the offer to update the trade list with
     */
    private void addToTradesList(List<FlippingItem> tradesList, OfferEvent newOffer) {
        int tradeItemId = newOffer.getItemId();
        String itemName = plugin.getItemManager().getItemComposition(tradeItemId).getName();

        ItemStats itemStats = plugin.getItemManager().getItemStats(tradeItemId, false);
        int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;

        FlippingItem flippingItem = new FlippingItem(tradeItemId, itemName, geLimit, plugin.getCurrentlyLoggedInAccount());
        flippingItem.setValidFlippingPanelItem(true);
        flippingItem.updateHistory(newOffer);
        flippingItem.updateLatestProperties(newOffer);

        tradesList.add(0, flippingItem);
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.controller;

import com.flippingutilities.FlippingConfig;
import com.flippingutilities.db.TradePersister;
import com.flippingutilities.jobs.SlotSenderJob;
import com.flippingutilities.model.*;
import com.flippingutilities.ui.MasterPanel;
import com.flippingutilities.ui.flipping.FlippingPanel;
import com.flippingutilities.ui.gehistorytab.GeHistoryTabPanel;
import com.flippingutilities.ui.login.LoginPanel;
import com.flippingutilities.ui.settings.SettingsPanel;
import com.flippingutilities.ui.slots.SlotsPanel;
import com.flippingutilities.ui.statistics.StatsPanel;
import com.flippingutilities.ui.uiutilities.GeSpriteLoader;
import com.flippingutilities.ui.uiutilities.WidgetConstants;
import com.flippingutilities.ui.widgets.SlotActivityTimer;
import com.flippingutilities.jobs.CacheUpdaterJob;
import com.flippingutilities.ui.widgets.SlotStateDrawer;
import com.flippingutilities.utilities.*;
import com.flippingutilities.jobs.WikiDataFetcherJob;
import com.google.common.primitives.Shorts;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.item.ItemStats;
import okhttp3.*;

import javax.inject.Inject;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.io.File;
import java.io.IOException;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;


@Slf4j
@PluginDescriptor(
        name = "Flipping Utilities",
        description = "Provides utilities for GE flipping"
)
public class FlippingPlugin extends Plugin {
    public static final String CONFIG_GROUP = "flipping";
    public static final String ACCOUNT_WIDE = "Accountwide";

    @Inject
    @Getter
    private Client client;
    @Inject
    @Getter
    private ClientThread clientThread;
    @Inject
    @Getter
    private ScheduledExecutorService executor;
    private ScheduledFuture generalRepeatingTasks;
    @Inject
    private ClientToolbar clientToolbar;
    private NavigationButton navButton;

    @Inject
    private ConfigManager configManager;

    @Inject
    @Getter
    private FlippingConfig config;

    @Inject
    @Getter
    private ItemManager itemManager;

    @Inject
    private KeyManager keyManager;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    @Getter
    private OkHttpClient httpClient;

    @Getter
    private FlippingPanel flippingPanel;
    @Getter
    private StatsPanel statPanel;
    @Getter
    private SlotsPanel slotsPanel;
    @Getter
    private MasterPanel masterPanel;
    @Getter
    private GeHistoryTabPanel geHistoryTabPanel;
    private SettingsPanel settingsPanel;
    private LoginPanel loginPanel;

    //this flag is to know that when we see the login screen an account has actually logged out and its not just that the
    //client has started.
    private boolean previouslyLoggedIn;

    //the display name of the account whose trade list the user is currently looking at as selected
    //through the dropdown menu
    @Getter
    private String accountCurrentlyViewed = ACCOUNT_WIDE;

    //the display name of the currently logged in user. This is the only account that can actually receive offers
    //as this is the only account currently logged in.
    @Getter
    @Setter
    private String currentlyLoggedInAccount;

    //some events come before a display name has been retrieved and since a display name is crucial for figuring out
    //which account's trade list to add to, we queue the events here to be processed as soon as a display name is set.
    @Getter
    private List<OfferEvent> eventsReceivedBeforeFullLogin = new ArrayList<>();

    //building the account wide trade list is an expensive operation so we store it in this variable and only recompute
    //it if we have gotten an update since the last account wide trade list build.
    @Setter
    boolean updateSinceLastItemAccountWideBuild = true;
    @Setter
    boolean updateSinceLastRecipeFlipGroupAccountWideBuild = true;
    List<FlippingItem> prevBuiltAccountWideItemList;
    List<RecipeFlipGroup> prevBuildAccountWideRecipeFlipGroup;

    //updates the cache by monitoring the directory and loading a file's contents into the cache if it has been changed
    private CacheUpdaterJob cacheUpdaterJob;
    private WikiDataFetcherJob wikiDataFetcherJob;
    private SlotSenderJob slotStateSenderJob;

    private ScheduledFuture slotTimersTask;
    private Instant startUpTime = Instant.now();

    @Getter
    private int loginTickCount;

    private OptionHandler optionHandler;

    @Getter
    private DataHandler dataHandler;
    private GameUiChangesHandler gameUiChangesHandler;
    private NewOfferEventPipelineHandler newOfferEventPipelineHandler;
    @Getter
    private ApiAuthHandler apiAuthHandler;
    @Getter
    private ApiRequestHandler apiRequestHandler;

    @Getter
    private WikiRequestWrapper lastWikiRequestWrapper;
    @Getter
    private Instant timeOfLastWikiRequest;

    @Inject
    public Gson gson;

    public TradePersister tradePersister;
    private RecipeHandler recipeHandler;
    private FlippingItemHandler flippingItemHandler;
    @Getter
    private SlotStateDrawer slotStateDrawer;

    @Override
    protected void startUp() {
        accountCurrentlyViewed = ACCOUNT_WIDE;

        tradePersister = new TradePersister(gson);
        recipeHandler = new RecipeHandler(gson, httpClient);
        flippingItemHandler = new FlippingItemHandler(this);

        optionHandler = new OptionHandler(this);
        dataHandler = new DataHandler(this);
        gameUiChangesHandler = new GameUiChangesHandler(this);
        newOfferEventPipelineHandler = new NewOfferEventPipelineHandler(this);
        apiAuthHandler = new ApiAuthHandler(this);
        apiRequestHandler = new ApiRequestHandler(this);
        slotStateDrawer = new SlotStateDrawer(this);

        flippingPanel = new FlippingPanel(this);
        statPanel = new StatsPanel(this);
        geHistoryTabPanel = new GeHistoryTabPanel(this);
        slotsPanel = new SlotsPanel(this, itemManager);
        loginPanel = new LoginPanel(this);

        masterPanel = new MasterPanel(this, flippingPanel, statPanel, slotsPanel, loginPanel);
        masterPanel.addView(geHistoryTabPanel, "ge history");
        navButton = NavigationButton.builder()
                .tooltip("Flipping Utilities")
                .icon(ImageUtil.getResourceStreamFromClass(getClass(), "/graph_icon_green.png"))
                .priority(3)
                .panel(masterPanel)
                .build();

        clientToolbar.addNavigation(navButton);
        keyManager.registerKeyListener(offerEditorKeyListener());
        clientThread.invokeLater(() ->
        {
            switch (client.getGameState()) {
                case STARTING:
                case UNKNOWN:
                    return false;
            }

            dataHandler.loadData();
            masterPanel.setupAccSelectorDropdown(dataHandler.getCurrentAccounts());
            generalRepeatingTasks = setupRepeatingTasks(1000);
            startJobs();
            apiAuthHandler.subscribeToPremiumChecking((isPremium) -> { if (isPremium) WikiDataFetcherJob.requestInterval = 30; });
            apiAuthHandler.checkExistingJwt().thenRun(() -> apiAuthHandler.setPremiumStatus());

            //this is only relevant if the user downloads/enables the plugin after they login.
            if (client.getGameState() == GameState.LOGGED_IN) {
                log.info("user is already logged in when they downloaded/enabled the plugin");
                onLoggedInGameState();
            }

            GeSpriteLoader.setClientSpriteOverrides(client);
            return true;
        });
    }

    @Override
    protected void shutDown() {
        log.info("shutdown running!");
        if (generalRepeatingTasks != null) {
            generalRepeatingTasks.cancel(true);
            generalRepeatingTasks = null;
        }
        if (slotTimersTask != null) {
            slotTimersTask.cancel(true);
            slotTimersTask = null;
        }

        masterPanel.dispose();

        clientToolbar.removeNavigation(navButton);
    }

    //called when the X button on the client is pressed
    @Subscribe(priority = 101)
    public void onClientShutdown(ClientShutdown clientShutdownEvent) {
        if (generalRepeatingTasks != null) {
            generalRepeatingTasks.cancel(true);
        }
        if (slotTimersTask != null) {
            slotTimersTask.cancel(true);
            slotTimersTask = null;
        }
        dataHandler.storeData();
        cacheUpdaterJob.stop();
        wikiDataFetcherJob.stop();
        slotStateSenderJob.stop();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGED_IN) {
            onLoggedInGameState();
        } else if (event.getGameState() == GameState.LOGIN_SCREEN && previouslyLoggedIn) {
            //this randomly fired at night hours after i had logged off...so i'm adding this guard here.
            if (currentlyLoggedInAccount != null && client.getGameState() != GameState.LOGGED_IN) {
                handleLogout();
            }
        }
    }

    private void onLoggedInGameState() {
        //keep scheduling this task until it returns true (when we have access to a display name)
        clientThread.invokeLater(() ->
        {
            //we return true in this case as something went wrong and somehow the state isn't logged in, so we don't
            //want to keep scheduling this task.
            if (client.getGameState() != GameState.LOGGED_IN) {
                return true;
            }

            final Player player = client.getLocalPlayer();

            //player is null, so we can't get the display name so, return false, which will schedule
            //the task on the client thread again.
            if (player == null) {
                return false;
            }

            final String name = player.getName();

            if (name == null) {
                return false;
            }

            if (name.equals("")) {
                return false;
            }
            previouslyLoggedIn = true;

            if (currentlyLoggedInAccount == null) {
                handleLogin(name);
            }
            //stops scheduling this task
            return true;
        });
    }

    public void handleLogin(String displayName) {
        wikiDataFetcherJob.onWorldSwitch(client.getWorldType());
        if (client.getAccountType().isIronman()) {
            log.info("account is an ironman, not adding it to the cache");
            return;
        }

        log.info("{} has just logged in!", displayName);
        if (!dataHandler.getCurrentAccounts().contains(displayName)) {
            log.info("data handler does not contain data for {}", displayName);
            dataHandler.addAccount(displayName);
            masterPanel.getAccountSelector().addItem(displayName);
        }
        //see documentation for AccountData.fixIncorrectItemNames
        if (client.getWorldType().contains(WorldType.MEMBERS)) {
            dataHandler.viewAccountData(displayName).fixIncorrectItemNames(itemManager);
        }

        loginTickCount = client.getTickCount();
        currentlyLoggedInAccount = displayName;

        //now that we have a display name we can process any events that we received before the display name
        //was set.
        eventsReceivedBeforeFullLogin.forEach(newOfferEventPipelineHandler::onNewOfferEvent);
        eventsReceivedBeforeFullLogin.clear();

        if (dataHandler.getCurrentAccounts().size() > 1) {
            masterPanel.getAccountSelector().setVisible(true);
        }
        accountCurrentlyViewed = displayName;
        //this will cause changeView to be invoked which will cause a rebuildItemsDisplay of
        //flipping and stats panel
        masterPanel.getAccountSelector().setSelectedItem(displayName);

        if (slotTimersTask == null && config.slotTimersEnabled()) {
            log.info("starting slot timers on login");
            slotTimersTask = startSlotTimers();
        }
        apiAuthHandler.checkRsn(displayName);
        slotStateSenderJob.justLoggedIn = true;
    }

    public void handleLogout() {
        log.info("{} is logging out", currentlyLoggedInAccount);

        dataHandler.getAccountData(currentlyLoggedInAccount).setLastSessionTimeUpdate(null);
        dataHandler.storeData();

        if (slotTimersTask != null && !slotTimersTask.isCancelled()) {
            log.info("cancelling slot timers task on logout");
            slotTimersTask.cancel(true);
        }
        slotTimersTask = null;
        currentlyLoggedInAccount = null;
        masterPanel.revertToSafeDisplay();
    }

    /**
     * Currently used for updating time sensitive displays such as the accumulated session time,
     * how long ago an item was flipped, etc.
     *
     * @return a future object that can be used to cancel the tasks
     */
    public ScheduledFuture setupRepeatingTasks(int msStartDelay) {
        return executor.scheduleAtFixedRate(() ->
        {
            try {
                flippingPanel.updateTimerDisplays();
                statPanel.updateTimeDisplay();
                updateSessionTime();
            } catch (ConcurrentModificationException e) {
                log.info("concurrent modification exception. This is fine, will just restart tasks after delay." +
                        " Cancelling general repeating tasks and starting it again after 5000 ms delay");
                generalRepeatingTasks.cancel(true);
                generalRepeatingTasks = setupRepeatingTasks(5000);
            } catch (Exception e) {
                log.info("unknown exception in repeating tasks, error = {}, will cancel and restart them after 5 sec delay", e);
                generalRepeatingTasks.cancel(true);
                generalRepeatingTasks = setupRepeatingTasks(5000);
            }

        }, msStartDelay, 1000, TimeUnit.MILLISECONDS);
    }

    /**
     * This method is invoked every time the plugin receives a GrandExchangeOfferChanged event which is
     * when the user set an offer, cancelled an offer, or when an offer was updated (items bought/sold partially
     * or completely).
     *
     * @param offerChangedEvent the offer event that represents when an offer is updated
     *                          (buying, selling, bought, sold, cancelled sell, or cancelled buy)
     */
    @Subscribe
    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerChangedEvent) {
        newOfferEventPipelineHandler.onGrandExchangeOfferChanged(offerChangedEvent);
    }

    public List<FlippingItem> getItemsForCurrentView() {
        return accountCurrentlyViewed.equals(ACCOUNT_WIDE) ? createAccountWideFlippingItemList() : dataHandler.getAccountData(accountCurrentlyViewed).getTrades();
    }

    public List<FlippingItem> viewItemsForCurrentView() {
        return accountCurrentlyViewed.equals(ACCOUNT_WIDE) ? createAccountWideFlippingItemList() : dataHandler.viewAccountData(accountCurrentlyViewed).getTrades();
    }

    public List<RecipeFlipGroup> viewRecipeFlipGroupsForCurrentView() {
        return accountCurrentlyViewed.equals(ACCOUNT_WIDE) ? createAccountWideRecipeFlipGroupList() : dataHandler.viewAccountData(accountCurrentlyViewed).getRecipeFlipGroups();
    }

    public Duration viewAccumulatedTimeForCurrentView() {
        if (accountCurrentlyViewed.equals(ACCOUNT_WIDE)) {
            long millis = dataHandler.viewAllAccountData().stream().map(AccountData::getAccumulatedSessionTimeMillis).reduce(0L, (d1, d2) -> d1 + d2);
            return Duration.of(millis, ChronoUnit.MILLIS);
        } else {
            long millis = dataHandler.viewAccountData(accountCurrentlyViewed).getAccumulatedSessionTimeMillis();
            return Duration.of(millis, ChronoUnit.MILLIS);
        }
    }

    public Instant viewStartOfSessionForCurrentView() {
        if (accountCurrentlyViewed.equals(ACCOUNT_WIDE)) {
            return startUpTime;
        } else {
            return dataHandler.viewAccountData(accountCurrentlyViewed).getSessionStartTime();
        }
    }

    @Provides
    FlippingConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(FlippingConfig.class);
    }

    public void truncateTradeList() {
        if (accountCurrentlyViewed.equals(ACCOUNT_WIDE)) {
            dataHandler.getAllAccountData().forEach(accountData -> flippingItemHandler.deleteRemovedItems(accountData.getTrades()));
        } else {
            flippingItemHandler.deleteRemovedItems(getItemsForCurrentView());
        }
    }

    /**
     * This method is invoked every time a user selects a username from the dropdown at the top of the
     * panel. If the username selected does not exist in the cache, it uses loadTradeHistory to load it from
     * disk and set the cache. Otherwise, it just reads what in the cache for that username. It updates the displays
     * with the trades it either found in the cache or from disk.
     *
     * @param selectedName the username the user selected from the dropdown menu.
     */
    public void changeView(String selectedName) {
        log.info("changing view to {}", selectedName);
        accountCurrentlyViewed = selectedName;
        List<FlippingItem> itemsForCurrentView = viewItemsForCurrentView();
        statPanel.resetPaginators();
        flippingPanel.getPaginator().setPageNumber(1);
        statPanel.rebuildItemsDisplay(itemsForCurrentView);
        statPanel.rebuildRecipesDisplay(viewRecipeFlipGroupsForCurrentView());
        flippingPanel.rebuild(itemsForCurrentView);
    }

    private void startJobs() {
        cacheUpdaterJob = new CacheUpdaterJob();
        cacheUpdaterJob.subscribe(this::onDirectoryUpdate);
        cacheUpdaterJob.start();

        wikiDataFetcherJob = new WikiDataFetcherJob(this, httpClient);
        wikiDataFetcherJob.subscribe(this::onWikiFetch);
        wikiDataFetcherJob.start();

        slotStateSenderJob = new SlotSenderJob(this, httpClient);
        slotStateSenderJob.subscribe((success) -> loginPanel.onSlotRequest(success));
        slotStateSenderJob.start();
    }

    private void onWikiFetch(WikiRequestWrapper wikiRequestWrapper, Instant timeOfRequestCompletion) {
        lastWikiRequestWrapper = wikiRequestWrapper;
        timeOfLastWikiRequest = timeOfRequestCompletion;
        flippingPanel.onWikiRequest(wikiRequestWrapper, timeOfRequestCompletion);
        slotStateDrawer.onWikiRequest(wikiRequestWrapper.getWikiRequest());
        slotsPanel.onWikiRequest(wikiRequestWrapper.getWikiRequest());
    }

    /**
     * This is a callback executed by the cacheUpdater when it notices the directory has changed. If the
     * file changed belonged to a different acc than the currently logged in one, it updates the cache of that
     * account to ensure this client has the most up to date data on each account. If the user is currently looking
     * at the account that had its cache updated, a rebuildItemsDisplay takes place to display the most recent trade list.
     *
     * @param fileName name of the file which was modified.
     */
    public void onDirectoryUpdate(String fileName) {
        if (!fileName.contains(".json") || fileName.contains(".backup.json") || fileName.contains(".special.json")) {
            return;
        }
        String displayNameOfChangedAcc = fileName.split("\\.")[0];

        if (displayNameOfChangedAcc.equals(dataHandler.thisClientLastStored)) {
            log.info("not reloading data for {} into the cache as this client was the last one to store it", displayNameOfChangedAcc);
            dataHandler.thisClientLastStored = null;
            return;
        }

        if (fileName.equals("accountwide.json")) {
            executor.schedule(() -> {
                dataHandler.loadAccountWideData();
            }, 1000, TimeUnit.MILLISECONDS);
            return;
        }

        executor.schedule(() ->
        {
            //have to run on client thread cause loadAccount calls accountData.prepareForUse which uses the itemmanager
            clientThread.invokeLater(() -> {
                log.info("second has passed, updating cache for {}", displayNameOfChangedAcc);
                dataHandler.loadAccountData(displayNameOfChangedAcc);
                if (!masterPanel.getViewSelectorItems().contains(displayNameOfChangedAcc)) {
                    masterPanel.getAccountSelector().addItem(displayNameOfChangedAcc);
                }

                if (dataHandler.getCurrentAccounts().size() > 1) {
                    masterPanel.getAccountSelector().setVisible(true);
                }

                updateSinceLastItemAccountWideBuild = true;

                //rebuildItemsDisplay if you are currently looking at the account who's cache just got updated or the account wide view.
                if (accountCurrentlyViewed.equals(ACCOUNT_WIDE) || accountCurrentlyViewed.equals(displayNameOfChangedAcc)) {
                    List<FlippingItem> tradesForCurrentView = viewItemsForCurrentView();
                    flippingPanel.rebuild(tradesForCurrentView);
                    statPanel.rebuildItemsDisplay(tradesForCurrentView);
                    statPanel.rebuildRecipesDisplay(viewRecipeFlipGroupsForCurrentView());
                }
            });
        }, 1000, TimeUnit.MILLISECONDS);
    }

    //TODO this caching logic can be generalized and put into another component. There are also a bunch of
    //other places where I want to cache things.
    private List<RecipeFlipGroup> createAccountWideRecipeFlipGroupList() {
        if (!updateSinceLastRecipeFlipGroupAccountWideBuild) {
            return prevBuildAccountWideRecipeFlipGroup;
        }
        if (dataHandler.getCurrentAccounts().size() == 0) {
            return new ArrayList<>();
        }
        updateSinceLastRecipeFlipGroupAccountWideBuild = false;
        prevBuildAccountWideRecipeFlipGroup = recipeHandler.createAccountWideRecipeFlipGroupList(dataHandler.viewAllAccountData());
        return prevBuildAccountWideRecipeFlipGroup;
    }

    private List<FlippingItem> createAccountWideFlippingItemList() {
        //since this is an expensive operation, cache its results and only recompute it if there has been an update
        //to one of the account's tradelists, (updateSinceLastAccountWideBuild is set in onGrandExchangeOfferChanged)
        if (!updateSinceLastItemAccountWideBuild) {
            return prevBuiltAccountWideItemList;
        }

        if (dataHandler.getCurrentAccounts().size() == 0) {
            return new ArrayList<>();
        }

        updateSinceLastItemAccountWideBuild = false;
        prevBuiltAccountWideItemList = flippingItemHandler.createAccountWideFlippingItemList(dataHandler.viewAllAccountData());;
        return prevBuiltAccountWideItemList;
    }

    public List<FlippingItem> sortItems(List<FlippingItem> items, SORT sort, Instant startOfInterval) {
        return flippingItemHandler.sortItems(items, sort, startOfInterval);
    }

    public List<RecipeFlipGroup> sortRecipeFlipGroups(List<RecipeFlipGroup> recipeFlipGroups, SORT sort, Instant startOfInterval) {
        return recipeHandler.sortRecipeFlipGroups(recipeFlipGroups, sort, startOfInterval);
    }

    /**
     * Decides whether the user is currently flipping or not. To be flipping a user has to be logged in
     * and have at least one incomplete offer in the GE
     *
     * @return whether the user if currently flipping or not
     */
    private boolean currentlyFlipping() {
        if (currentlyLoggedInAccount == null) {
            return false;
        }

        Collection<OfferEvent> lastOffers = dataHandler.viewAccountData(currentlyLoggedInAccount).getLastOffers().values();
        return lastOffers.stream().anyMatch(offerInfo -> !offerInfo.isComplete());
    }

    /**
     * Calculates and updates the session time display in the statistics tab when a user is viewing
     * the "Session" time interval.
     */
    private void updateSessionTime() {
        if (currentlyFlipping()) {
            Instant lastSessionTimeUpdate = dataHandler.viewAccountData(currentlyLoggedInAccount).getLastSessionTimeUpdate();
            long accumulatedSessionTime = dataHandler.viewAccountData(currentlyLoggedInAccount).getAccumulatedSessionTimeMillis();
            if (lastSessionTimeUpdate == null) {
                lastSessionTimeUpdate = Instant.now();
            }
            long millisSinceLastSessionTimeUpdate = Instant.now().toEpochMilli() - lastSessionTimeUpdate.toEpochMilli();
            accumulatedSessionTime = accumulatedSessionTime + millisSinceLastSessionTimeUpdate;
            lastSessionTimeUpdate = Instant.now();
            dataHandler.getAccountData(currentlyLoggedInAccount).setAccumulatedSessionTimeMillis(accumulatedSessionTime);
            dataHandler.getAccountData(currentlyLoggedInAccount).setLastSessionTimeUpdate(lastSessionTimeUpdate);

            if (accountCurrentlyViewed.equals(ACCOUNT_WIDE) || accountCurrentlyViewed.equals(currentlyLoggedInAccount)) {
                statPanel.updateSessionTimeDisplay(viewAccumulatedTimeForCurrentView());
            }
        } else if (currentlyLoggedInAccount != null) {
            dataHandler.getAccountData(currentlyLoggedInAccount).setLastSessionTimeUpdate(null);
        }
    }

    /**
     * What hands the slot widgets on the screen to the SlotStateDrawer. This is called by
     * the GameUiChangesHandler in response to the appropriate UI changes that cause the
     * slot widgets to appear/get rebuilt.
     */
    public void setWidgetsOnSlotStateDrawer() {
        Widget slotWidgets = client.getWidget(InterfaceID.GRAND_EXCHANGE, WidgetConstants.SLOT_CONTAINER);
        if (slotWidgets != null) {
            slotStateDrawer.setSlotWidgets(slotWidgets.getStaticChildren());
        }
    }

    public void setWidgetsOnSlotTimers() {
        for (int slotIndex = 0; slotIndex < 8; slotIndex++) {
            SlotActivityTimer timer = dataHandler.viewAccountData(currentlyLoggedInAccount).getSlotTimers().get(slotIndex);

            //Get the offer slots from the window container
            //We add one to the index, as the first widget is the text above the offer slots
            Widget offerSlot = client.getWidget(InterfaceID.GRAND_EXCHANGE, WidgetConstants.SLOT_CONTAINER).getStaticChildren()[slotIndex + 1];

            if (offerSlot == null) {
                return;
            }

            if (timer.getSlotWidget() == null) {
                timer.setWidget(offerSlot);
            }

            clientThread.invokeLater(timer::updateTimerDisplay);
        }
    }

    public void setFavoriteOnAllAccounts(FlippingItem item, boolean favoriteStatus) {
        for (String accountName : dataHandler.getCurrentAccounts()) {
            AccountData account = dataHandler.viewAccountData(accountName);
            account.
                    getTrades().
                    stream().
                    filter(accountItem -> accountItem.getItemId() == item.getItemId()).
                    findFirst().
                    ifPresent(accountItem -> {
                        accountItem.setFavorite(favoriteStatus);
                        markAccountTradesAsHavingChanged(accountName);
                    });
        }
    }

    public void setFavoriteCodeOnAllAccounts(FlippingItem item, String favoriteCode) {
        for (String accountName : dataHandler.getCurrentAccounts()) {
            AccountData account = dataHandler.viewAccountData(accountName);
            account.
                    getTrades().
                    stream().
                    filter(accountItem -> accountItem.getItemId() == item.getItemId()).
                    findFirst().
                    ifPresent(accountItem -> {
                        accountItem.setFavoriteCode(favoriteCode);
                        markAccountTradesAsHavingChanged(accountName);
                    });
        }
    }

    public void addSelectedGeTabOffers(List<OfferEvent> selectedOffers) {
        for (OfferEvent offerEvent : selectedOffers) {
            addSelectedGeTabOffer(offerEvent);
        }

        //have to add a delay before rebuilding as item limit and name may not have been set yet in addSelectedGeTabOffer due to
        //clientThread being async and not offering a future to wait on when you submit a runnable...
        executor.schedule(() -> {
            flippingPanel.rebuild(viewItemsForCurrentView());
            statPanel.rebuildItemsDisplay(viewItemsForCurrentView());
        }, 500, TimeUnit.MILLISECONDS);
    }

    private void addSelectedGeTabOffer(OfferEvent selectedOffer) {
        if (currentlyLoggedInAccount == null) {
            return;
        }
        Optional<FlippingItem> flippingItem = dataHandler.getAccountData(currentlyLoggedInAccount).getTrades().stream().filter(item -> item.getItemId() == selectedOffer.getItemId()).findFirst();
        if (flippingItem.isPresent()) {
            flippingItem.get().updateHistory(selectedOffer);
            flippingItem.get().updateLatestProperties(selectedOffer);
            //incase it was set to false before
            flippingItem.get().setValidFlippingPanelItem(true);
        } else {
            int tradeItemId = selectedOffer.getItemId();
            FlippingItem item = new FlippingItem(tradeItemId, "", -1, currentlyLoggedInAccount);
            item.setValidFlippingPanelItem(true);
            item.updateLatestProperties(selectedOffer);
            item.updateHistory(selectedOffer);
            dataHandler.getAccountData(currentlyLoggedInAccount).getTrades().add(0, item);

            //itemmanager can only be used on the client thread.
            //i can't put everything in the runnable given to the client thread cause then it executes async and if there
            //are multiple offers for the same flipping item that doesn't yet exist in trades list, it might create multiple
            //of them.
            clientThread.invokeLater(() -> {
                String itemName = itemManager.getItemComposition(tradeItemId).getName();
                ItemStats itemStats = itemManager.getItemStats(tradeItemId, false);
                int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;
                item.setItemName(itemName);
                item.setTotalGELimit(geLimit);
            });
        }
    }

    public void showGeHistoryTabPanel() {
        clientThread.invokeLater(() -> {
            Widget[] geHistoryTabWidgets = client.getWidget(383, 3).getDynamicChildren();
            List<OfferEvent> offerEvents = GeHistoryTabExtractor.convertWidgetsToOfferEvents(geHistoryTabWidgets);
            List<List<OfferEvent>> matchingOffers = new ArrayList<>();
            offerEvents.forEach(o -> {
                o.setItemName(itemManager.getItemComposition(o.getItemId()).getName());
                o.setMadeBy(getCurrentlyLoggedInAccount());
                matchingOffers.add(findOfferMatches(o, 5));
            });
            geHistoryTabPanel.rebuild(offerEvents, matchingOffers, geHistoryTabWidgets, false);
            masterPanel.showView("ge history");
        });
    }

    public List<OfferEvent> findOfferMatches(OfferEvent offerEvent, int limit) {
        Optional<FlippingItem> flippingItem = dataHandler.getAccountData(currentlyLoggedInAccount).getTrades().stream().filter(item -> item.getItemId() == offerEvent.getItemId()).findFirst();
        if (!flippingItem.isPresent()) {
            return new ArrayList<>();
        }
        return flippingItem.get().getOfferMatches(offerEvent, limit);
    }

    public Font getFont() {
        return FontManager.getRunescapeSmallFont();
    }

    /**
     * Used by the stats panel to invalidate all offers for a certain interval when a user hits the reset button.
     */
    public void deleteOffers(Instant startOfInterval) {
        if (accountCurrentlyViewed.equals(ACCOUNT_WIDE)) {
            for (AccountData accountData : dataHandler.getAllAccountData()) {
                accountData.getTrades().forEach(item -> {
                    deleteOffers(item.getIntervalHistory(startOfInterval), item);
                });
            }
        } else {
            getItemsForCurrentView().forEach(item -> {
                deleteOffers(item.getIntervalHistory(startOfInterval), item);
            });
        }

        updateSinceLastItemAccountWideBuild = true;
        updateSinceLastRecipeFlipGroupAccountWideBuild = true;
        truncateTradeList();
    }

    public void deleteOffers(List<OfferEvent> offers, FlippingItem item) {
        deleteOffers(offers, viewRecipeFlipGroupsForCurrentView(), item);
    }

    private void deleteOffers(List<OfferEvent> offers, List<RecipeFlipGroup> recipeFlipGroups, FlippingItem item) {
        item.deleteOffers(offers);
        recipeHandler.deleteInvalidRecipeFlips(offers, recipeFlipGroups);
        markAccountTradesAsHavingChanged(accountCurrentlyViewed);
        updateSinceLastItemAccountWideBuild = true;
        updateSinceLastRecipeFlipGroupAccountWideBuild = true;
    }

    /**
     * Used by the flipping panel to hide all items (set the validfFippingItem property to false) when a user hits the
     * reset button
     */
    public void setAllFlippingItemsAsHidden() {
        if (accountCurrentlyViewed.equals(ACCOUNT_WIDE)) {
            for (AccountData accountData : dataHandler.getAllAccountData()) {
                accountData.getTrades().forEach(item -> item.setValidFlippingPanelItem(false));
            }
        } else {
            getItemsForCurrentView().forEach(flippingItem -> flippingItem.setValidFlippingPanelItem(false));
        }
        updateSinceLastItemAccountWideBuild = true;
        truncateTradeList();
    }

    public void exportToCsv(File parentDirectory, Instant startOfInterval, String startOfIntervalName) throws IOException {
        if (parentDirectory.equals(TradePersister.PARENT_DIRECTORY)) {
            throw new RuntimeException("Cannot save csv file in the flipping directory, pick another directory");
        }
        //create new flipping item list with only history from that interval
        List<FlippingItem> items = new ArrayList<>();
        for (FlippingItem item : viewItemsForCurrentView()) {
            List<OfferEvent> offersInInterval = item.getIntervalHistory(startOfInterval);
            if (offersInInterval.isEmpty()) {
                continue;
            }
            FlippingItem itemWithOnlySelectedIntervalHistory = new FlippingItem(item.getItemId(), item.getItemName(), item.getTotalGELimit(), item.getFlippedBy());
            itemWithOnlySelectedIntervalHistory.getHistory().setCompressedOfferEvents(offersInInterval);
            items.add(itemWithOnlySelectedIntervalHistory);
        }

        TradePersister.exportToCsv(new File(parentDirectory, accountCurrentlyViewed + ".csv"), items, startOfIntervalName);
    }

    public int calculateOptionValue(Option option) throws InvalidOptionException {
        return optionHandler.calculateOptionValue(option, gameUiChangesHandler.highlightedItem, gameUiChangesHandler.highlightedItemId);
    }

    public void markAccountTradesAsHavingChanged(String displayName) {
        dataHandler.markDataAsHavingChanged(displayName);
    }

    public Set<String> getCurrentDisplayNames() {
        return dataHandler.getCurrentAccounts();
    }

    private KeyListener offerEditorKeyListener() {
        return new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {
                if (gameUiChangesHandler.quantityOrPriceChatboxOpen && gameUiChangesHandler.highlightedItem.isPresent()) {
                    String keyPressed = KeyEvent.getKeyText(e.getKeyCode()).toLowerCase();
                    if (flippingPanel.getOfferEditorContainerPanel() == null) {
                        return;
                    }
                    boolean currentlyViewingQuantityEditor = flippingPanel.getOfferEditorContainerPanel().currentlyViewingQuantityEditor();

                    Optional<Option> optionExercised = dataHandler.viewAccountWideData().getOptions().stream().filter(option -> option.isQuantityOption() == currentlyViewingQuantityEditor && option.getKey().equals(keyPressed)).findFirst();

                    optionExercised.ifPresent(option -> clientThread.invoke(() -> {
                        try {
                            int optionValue = calculateOptionValue(option);
                            client.getWidget(ComponentID.CHATBOX_FULL_INPUT).setText(optionValue + "*");
                            client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(optionValue));
                            flippingPanel.getOfferEditorContainerPanel().highlightPressedOption(keyPressed);
                            e.consume();
                        } catch (InvalidOptionException ex) {
                            //ignore
                        } catch (Exception ex) {
                            log.info("exception during key press for offer editor", ex);
                        }
                    }));
                }
            }

            @Override
            public void keyReleased(KeyEvent e) {

            }
        };
    }

    public void deleteAccount(String displayName) {
        dataHandler.deleteAccount(displayName);
        if (accountCurrentlyViewed.equals(displayName)) {
            masterPanel.getAccountSelector().setSelectedItem(dataHandler.getCurrentAccounts().toArray()[0]);
        }
        if (dataHandler.getCurrentAccounts().size() < 2) {
            masterPanel.getAccountSelector().setVisible(false);
        }
        masterPanel.getAccountSelector().removeItem(displayName);
    }

    private ScheduledFuture startSlotTimers() {
        return executor.scheduleAtFixedRate(() ->
                dataHandler.viewAccountData(currentlyLoggedInAccount).getSlotTimers().forEach(slotWidgetTimer ->
                        clientThread.invokeLater(() -> {
                            try {
                                slotsPanel.updateTimerDisplays(slotWidgetTimer.getSlotIndex(), slotWidgetTimer.createFormattedTimeString());
                                slotWidgetTimer.updateTimerDisplay();
                            } catch (Exception e) {
                                log.error("exception when trying to update timer", e);
                            }
                        })), 1000, 1000, TimeUnit.MILLISECONDS);
    }

    //see RecipeHandler.getItemsInRecipe
    public Map<Integer, Optional<FlippingItem>> getItemsInRecipe(Recipe recipe) {
        return recipeHandler.getItemsInRecipe(recipe, getItemsForCurrentView());
    }
    //see RecipeHandler.getApplicableRecipes
    public List<Recipe> getApplicableRecipes(int parentId, boolean isBuy) {
        return recipeHandler.getApplicableRecipes(parentId, isBuy);
    }
    //see RecipeHandler.getTargetValuesForMaxRecipeCount
    public Map<Integer, Integer> getTargetValuesForMaxRecipeCount(Recipe recipe, Map<Integer, List<PartialOffer>> itemIdToPartialOffers, boolean useRemainingOffer) {
        return recipeHandler.getTargetValuesForMaxRecipeCount(recipe, itemIdToPartialOffers, useRemainingOffer);
    }
    //see RecipeHandler.getItemIdToMaxRecipesThatCanBeMade
    public Map<Integer, Integer> getItemIdToMaxRecipesThatCanBeMade(Recipe recipe, Map<Integer, List<PartialOffer>> itemIdToPartialOffers, boolean useRemainingOffer) {
        return recipeHandler.getItemIdToMaxRecipesThatCanBeMade(recipe, itemIdToPartialOffers, useRemainingOffer);
    }
    public Map<String, PartialOffer> getOfferIdToPartialOffer(int itemId) {
        return recipeHandler.getOfferIdToPartialOffer(viewRecipeFlipGroupsForCurrentView(), itemId);
    }
    public void addRecipeFlip(RecipeFlip recipeFlip, Recipe recipe) {
        AccountData account = dataHandler.getAccountData(accountCurrentlyViewed);
        recipeHandler.addRecipeFlip(account.getRecipeFlipGroups(), recipeFlip, recipe);
        updateSinceLastRecipeFlipGroupAccountWideBuild = true;
    }

    /**
     * Adds the dummy item that was favorited to the trades list. Dummy items are created for display purposes
     * when items are searched for/highlighted but they don't actually exist in history. However, if a user then
     * favorites it, we need to add it to the history.
     */
    public void addFavoritedItem(FlippingItem flippingItem) {
        if (accountCurrentlyViewed.equals(FlippingPlugin.ACCOUNT_WIDE)) {
            for (String accountName : dataHandler.getCurrentAccounts()) {
                addFavoritedItem(flippingItem, accountName);
            }
        }
        else {
            addFavoritedItem(flippingItem, accountCurrentlyViewed);
        }
    }

    private void addFavoritedItem(FlippingItem flippingItem, String accountName) {
        List<FlippingItem> items = dataHandler.getAccountData(accountName).getTrades();
        Optional<FlippingItem> existingItem = items.stream().filter(item -> item.getItemId() == flippingItem.getItemId()).findFirst();
        if (existingItem.isPresent()) {
            existingItem.get().setFavorite(true);
        }
        else {
            flippingItem.setFlippedBy(accountName);
            items.add(0, flippingItem);
            markAccountTradesAsHavingChanged(accountName);
            updateSinceLastItemAccountWideBuild = true;
        }
    }

    public void toggleEnhancedSlots(boolean shouldEnhance) {
        dataHandler.getAccountWideData().setEnhancedSlots(shouldEnhance);
        dataHandler.markDataAsHavingChanged(FlippingPlugin.ACCOUNT_WIDE);
        if (shouldEnhance) {
            slotStateDrawer.drawWrapper();
        }
        else {
            getClientThread().invokeLater(() -> slotStateDrawer.resetAllSlots());
        }
    }

    public boolean shouldEnhanceSlots() {
        return dataHandler.getAccountWideData().isEnhancedSlots();
    }

    @Subscribe
    public void onGrandExchangeSearched(GrandExchangeSearched event) {
        final String input = client.getVarcStrValue(VarClientStr.INPUT_TEXT);
        Set<Integer> ids = dataHandler.viewAccountData(currentlyLoggedInAccount).
                getTrades()
                .stream()
                .filter(item -> item.isFavorite() && input.equals(item.getFavoriteCode()))
                .map(FlippingItem::getItemId)
                .collect(Collectors.toSet());

        if (ids.isEmpty()) {
            return;
        }

        client.setGeSearchResultIndex(0);
        client.setGeSearchResultCount(ids.size());
        client.setGeSearchResultIds(Shorts.toArray(ids));
        event.consume();
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        gameUiChangesHandler.onScriptPostFired(event);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        gameUiChangesHandler.onWidgetLoaded(event);
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        gameUiChangesHandler.onVarbitChanged(event);
    }

    @Subscribe
    public void onVarClientIntChanged(VarClientIntChanged event) {
        gameUiChangesHandler.onVarClientIntChanged(event);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (event.getGroup().equals(CONFIG_GROUP)) {
            if (event.getKey().equals("slotTimersEnabled")) {
                if (config.slotTimersEnabled()) {
                    slotTimersTask = startSlotTimers();
                } else {
                    if (slotTimersTask != null) {
                        slotTimersTask.cancel(true);
                    }
                    dataHandler.viewAccountData(currentlyLoggedInAccount).getSlotTimers().forEach(SlotActivityTimer::resetToDefault);
                }
            }

            statPanel.rebuildItemsDisplay(viewItemsForCurrentView());
            flippingPanel.rebuild(viewItemsForCurrentView());
        }
    }
}

package com.flippingutilities.controller;

import com.flippingutilities.utilities.*;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;

/**
 * This class is responsible for wrapping the api. All api interactions must go through this class.
 */
@Slf4j
public class ApiRequestHandler {
    FlippingPlugin plugin;
    OkHttpClient httpClient;
    private static String BASE_API_URL = System.getenv("OSRS_CLOUD_API_BASE_URL") != null ? System.getenv("OSRS_CLOUD_API_BASE_URL")  : "https://api.osrs.cloud/v1/";
    public static String SLOT_FETCH_URL = BASE_API_URL + "ge/slots";
    public static String SLOT_UPDATE_URL = BASE_API_URL + "ge/slots/update";
    public static String JWT_HEALTH_URL = BASE_API_URL + "auth/jwt/health";
    public static String JWT_REFRESH_URL = BASE_API_URL + "auth/refresh";
    public static String USER_URL = BASE_API_URL + "user/self";
    public static String ACCOUNT_URL = BASE_API_URL + "account/self";
    public static String ACCOUNT_REGISTRATION_URL = BASE_API_URL + "account/register";
    public static String TOKEN_URL = BASE_API_URL + "auth/token";

    public ApiRequestHandler(FlippingPlugin plugin) {
        this.plugin = plugin;
        this.httpClient = plugin.getHttpClient();
    }

    public CompletableFuture<User> getUser() {
        if (!plugin.getApiAuthHandler().isHasValidJWT()) {
            return null;
        }
        String jwt = plugin.getDataHandler().viewAccountWideData().getJwt();
        Request request = new Request.Builder().
            header("User-Agent", "FlippingUtilities").
            header("Authorization", "bearer " + jwt).
            url(USER_URL).
            build();
        return getResponseFuture(request, new TypeToken<ApiResponse<User>>(){}).thenApply(r -> r.data);
    }

    public CompletableFuture<List<OsrsAccount>> getUserAccounts() {
        if (!plugin.getApiAuthHandler().isHasValidJWT()) {
            return null;
        }
        String jwt = plugin.getDataHandler().viewAccountWideData().getJwt();
        Request request = new Request.Builder().
                header("User-Agent", "FlippingUtilities").
                header("Authorization", "bearer " + jwt).
                url(ACCOUNT_URL).
                build();
        return getResponseFuture(request, new TypeToken<ApiResponse<List<OsrsAccount>>>(){}).thenApply(r -> r.data);
    }

    public CompletableFuture<OsrsAccount> registerNewAccount(String rsn) {
        if (!plugin.getApiAuthHandler().isHasValidJWT()) {
            return null;
        }
        String jwt = plugin.getDataHandler().viewAccountWideData().getJwt();
        HttpUrl url = HttpUrl.parse(ACCOUNT_REGISTRATION_URL).newBuilder().addQueryParameter("rsn", rsn).build();
        Request request = new Request.Builder().
                header("User-Agent", "FlippingUtilities").
                header("Authorization", "bearer " + jwt).
                url(url).
                build();
        CompletableFuture<ApiResponse<OsrsAccount>> response = getResponseFuture(request, new TypeToken<ApiResponse<OsrsAccount>>(){});
        return response.thenApply(r -> r.data);
    }

    public CompletableFuture<String> refreshJwt(String jwtString) {
        if (!plugin.getApiAuthHandler().isHasValidJWT()) {
            return null;
        }
        Request request = new Request.Builder().
                header("User-Agent", "FlippingUtilities").
                header("Authorization", "bearer " + jwtString).
                url(JWT_REFRESH_URL).
                build();
        return getResponseFuture(request, new TypeToken<ApiResponse<TokenResponse>>(){}).thenApply(r -> r.data.getAccess_token());
    }

    //don't care about the response body (if there is any), so we just return the entire response in case the caller
    //wants something.
    public CompletableFuture<Integer> updateGeSlots(AccountSlotsUpdate accountSlotsUpdate) {
        if (!plugin.getApiAuthHandler().isHasValidJWT()) {
            return null;
        }
        String jwt = plugin.getDataHandler().viewAccountWideData().getJwt();
        String json = plugin.gson.newBuilder().setDateFormat(SlotState.DATE_FORMAT).create().toJson(accountSlotsUpdate);
        RequestBody body = RequestBody.create(MediaType.parse("application/json"), json);
        Request request = new Request.Builder().
                header("User-Agent", "FlippingUtilities").
                header("Authorization", "bearer " + jwt).
                post(body).
                url(SLOT_UPDATE_URL).
                build();
        return getResponseFuture(request, new TypeToken<ApiResponse<Integer>>(){}).thenApply(r -> r.data);
    }

    /**
     * Authenticates with the api using the token provided by Flopper and returns the jwt which is used to communicate
     * with the other api endpoints.
     * <p>
     * This method should really only be called by the ApiLoginHandler class as that class is responsible for handling
     * logins and running any action that components interested in subscribing to logins have provided it.
     * If another component is calling this method and attempting to login, the login subscribers won't be notified,
     * unless we want duplicate code to notify the subscribers....So, the central place for logins should be the
     * ApiLoginHandler class and as such only it should call this method.
     *
     * @param token the token to authenticate with
     * @return the jwt meant to be sent on every subsequent request
     */
    public CompletableFuture<String> loginWithToken(String token) {
        //Cannot have the JWT check like we do with the other methods because this is the method that is triggered
        //when a user clicks the "Login" button on the login panel, so a user won't have a JWT at that point.
        String json = plugin.gson.toJson(Collections.singletonMap("token", token));
        RequestBody body = RequestBody.create(
                MediaType.parse("application/json"), json);
        Request request = new Request.Builder().
                header("User-Agent", "FlippingUtilities").
                post(body).
                url(TOKEN_URL).
                build();
        return getResponseFuture(request, new TypeToken<ApiResponse<TokenResponse>>(){}).thenApply(r -> r.data.getAccess_token());
    }

    /**
     * CompletableFuture API is wack...but it is much more flexible then the only callback way that okhttp offers. And
     * in the case where we need the result of the response from many requests to be joined together, the callback way
     * is not going to be sufficient as there is no way to "wait" for all the callbacks to finish. So this method
     * exists to bridge the gap between the callback only interface okhttp offers and Futures, specifically,
     * CompletableFutures.
     */
    public <T> CompletableFuture<ApiResponse<T>> getResponseFuture(Request request, TypeToken<ApiResponse<T>> type) {
        CompletableFuture<ApiResponse<T>> future = new CompletableFuture<>();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(new RequestFailureException(request, e));
            }

            @Override
            public void onResponse(Call call, Response response) {
                if (!response.isSuccessful()) {
                    future.completeExceptionally(new BadStatusCodeException(request, response, getResponseBody(response)));
                }
                else {
                    try {
                        String body =  response.body().string();
                        ApiResponse<T> apiResponse = plugin.gson.fromJson(body, type.getType());
                        if (apiResponse == null) {
                            future.completeExceptionally(new NullDtoException(request, response, type.toString()));
                        }
                        else if (apiResponse.errors.size() > 0) {
                            //TODO better exception here
                            future.completeExceptionally(new BadStatusCodeException(request, response, body));
                        }
                        else {
                            future.complete(apiResponse);
                        }
                        response.close();
                    }
                    catch (IOException e) {
                        future.completeExceptionally(new ResponseBodyReadingException(request, response, e));
                        response.close();
                    }
                }
            }
        });
        return future;
    }

    public static String getResponseBody(Response response) {
        try {
            return response.body().string();
        }
        catch (Exception e) {
            return "Could not fetch response body";
        }
    }
}


class BadStatusCodeException extends Exception {
    Request request;
    Response response;

    public BadStatusCodeException(Request request, Response response, String body) {
        super(String.format("Request: %s resulted in bad status code in response: %s, body %s", request, response, body));
        this.request = request;
        this.response = response;
    }
}

class NullDtoException extends RuntimeException {
    Request request;
    Response response;

    public NullDtoException(Request request, Response response, String dtoName) {
        super(String.format("%s from response: %s is null. Request: %s", dtoName, response, request));
        this.request = request;
        this.response = response;
    }
}

class ResponseBodyReadingException extends RuntimeException {
    Request request;
    Response response;

    public ResponseBodyReadingException(Request request, Response response, IOException e) {
        super(String.format("Could not read response body for response: %s from request: %s, exception: %s", response, request, e));
        this.request = request;
        this.response = response;
    }
}

class RequestFailureException extends Exception {
    Request request;

    public RequestFailureException(Request request, IOException e) {
        super(String.format("Request failure for request: %s, either the request failed to send or no response was received. Resulting" +
                "IOException: %s", request.toString(), e.toString()));
        this.request = request;
    }
}

class ApiResponse<T> {
    T data;
    String time;
    List<ApiError> errors;
    List<ApiMessage> messages;
}

class ApiMessage {
    String type;
    String key;
    String message;
}

class ApiError {
    int code;
    String type;
    String key;
    String message;
}

package com.flippingutilities.controller;

import com.flippingutilities.model.*;
import com.flippingutilities.utilities.*;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.apache.commons.lang3.exception.ExceptionUtils;

import java.io.IOException;
import java.lang.reflect.Type;
import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * This class is responsible for loading all the recipes and providing an api
 * for other components to get info on recipes.
 */
@Slf4j
public class RecipeHandler {

    private Gson gson;
    private final Optional<Map<Integer, List<Recipe>>> idToRecipes;
    private final Optional<Map<Integer, PotionGroup>> idToPotionGroup;
    private OkHttpClient httpClient;

    public RecipeHandler(Gson gson, OkHttpClient httpClient) {
        this.gson = gson;
        this.httpClient = httpClient;
        this.idToRecipes = getItemIdToRecipes(loadRecipes());
        this.idToPotionGroup = getItemIdToPotionGroup(loadPotionGroups());

        if (idToRecipes.isPresent()) {
            log.info("Successfully loaded recipes");
        }
    }

    public Optional<RecipeFlipGroup> findRecipeFlipGroup(List<RecipeFlipGroup> recipeFlipGroups, Recipe recipe) {
        return recipeFlipGroups.stream().filter(group -> group.getRecipe().equals(recipe)).findFirst();
    }

    //TODO this is pretty inefficient, i don't think it really matters, but might be worth looking into.
    //TODO We could either cache it in the plugin or make the lookups faster somehow.
    /**
     * Gets a map of offer id to partial offer. Since an offer can be referenced by multiple partial offers (each
     * consuming part of the offer) from recipe flips in different recipe flip groups, we need to sum up the amount
     * consumed by each of the partial offers referencing that one offer to get the final partial offer corresponding
     * to that offer id.
     */
    public Map<String, PartialOffer> getOfferIdToPartialOffer(List<RecipeFlipGroup> recipeFlipGroups, int itemId) {
        Map<String, PartialOffer> offerIdToPartialOffer = new HashMap<>();
        for (RecipeFlipGroup recipeFlipGroup : recipeFlipGroups) {
            if (!recipeFlipGroup.isInGroup(itemId)) {
                continue;
            }
            recipeFlipGroup.getOfferIdToPartialOffer(itemId).forEach((offerId, partialOffer) -> {
                if (offerIdToPartialOffer.containsKey(offerId)) {
                    PartialOffer otherPartialOffer = offerIdToPartialOffer.get(offerId);
                    PartialOffer cumulativePartialOffer = otherPartialOffer.clone();
                    cumulativePartialOffer.amountConsumed += partialOffer.amountConsumed;
                    offerIdToPartialOffer.put(offerId, cumulativePartialOffer);
                }
                else {
                    offerIdToPartialOffer.put(offerId, partialOffer);
                }
            });
        }
        return offerIdToPartialOffer;
    }

    public List<RecipeFlipGroup> createAccountWideRecipeFlipGroupList(Collection<AccountData> allAccountData) {
        Map<Recipe, List<RecipeFlipGroup>> groupedItems = allAccountData.stream().
            flatMap(accountData -> accountData.getRecipeFlipGroups().stream()).
            map(RecipeFlipGroup::clone).
            collect(Collectors.groupingBy(RecipeFlipGroup::getRecipe));

        List<RecipeFlipGroup> mergedRecipeFlipGroups = groupedItems.values().stream()
            .map(list -> list.stream().reduce(RecipeFlipGroup::merge))
            .filter(Optional::isPresent).map(Optional::get)
            .sorted(Collections.reverseOrder(Comparator.comparing(RecipeFlipGroup::getLatestActivityTime)))
            .collect(Collectors.toList());

        return mergedRecipeFlipGroups;
    }

    private boolean isInRegularRecipe(int itemId) {
        if (idToRecipes.isPresent()) {
            return idToRecipes.get().containsKey(itemId);
        }
        return false;
    }

    private boolean isInDecantRecipe(int itemId) {
        if (idToPotionGroup.isPresent()) {
            return idToPotionGroup.get().containsKey(itemId);
        }
        return false;
    }

    /**
     * @return The items in the recipe
     */
    public Map<Integer, Optional<FlippingItem>> getItemsInRecipe(Recipe recipe, List<FlippingItem> items) {
        Set<Integer> ids = recipe.getIds();

        Map<Integer, Optional<FlippingItem>> itemIdToItems = new HashMap<>();
        for (FlippingItem item : items) {
            if (ids.contains(item.getItemId())) {
                itemIdToItems.put(item.getItemId(), Optional.of(item));
            }
        }

        ids.forEach(id -> {
            if (!itemIdToItems.containsKey(id)) {
                itemIdToItems.put(id, Optional.empty());
            }
        });

        return itemIdToItems;
    }

    public List<Recipe> getApplicableRecipes(int itemId, boolean isBuy) {
        List<Recipe> applicableRecipes = new ArrayList<>();
        applicableRecipes.addAll(getApplicableDecantRecipes(itemId, isBuy));
        applicableRecipes.addAll(getApplicableRegularRecipes(itemId, isBuy));
        return applicableRecipes;
    }

    /**
     * Gets the applicable recipe given an item id and whether you are buying/selling the item.
     * For example, if you are buying a guthan warspear, the applicable recipe is the one where the
     * warspear in the inputs and the guthan set is in the outputs. However, if you were selling the
     * warspear, the applicable recipe would be the one where the guthan set was in the inputs and the warspear
     * was in the outputs.
     */
    private List<Recipe> getApplicableRegularRecipes(int itemId, boolean isBuy) {
        if (!isInRegularRecipe(itemId)) {
            return new ArrayList<>();
        }
        List<Recipe> applicableRegularRecipes = new ArrayList<>();
        List<Recipe> recipesWithTheItem = idToRecipes.get().get(itemId);
        for (Recipe recipe : recipesWithTheItem) {
            boolean isItemInInputs = recipe.isInput(itemId);
            if (isBuy && isItemInInputs) {
                applicableRegularRecipes.add(recipe);
            }
            if (!isBuy && !isItemInInputs) {
                applicableRegularRecipes.add(recipe);
            }
        }
        return applicableRegularRecipes;
    }

    private List<Recipe> getApplicableDecantRecipes(int itemId, boolean isBuy) {
        if (!isInDecantRecipe(itemId)) {
            return new ArrayList<>();
        }

        List<Recipe> applicableDecantRecipes = new ArrayList<>();

        PotionGroup potionGroup = idToPotionGroup.get().get(itemId);

        PotionDose sourceDose = potionGroup.getDoses().stream().filter(d -> d.getId() == itemId).findAny().get();
        List<PotionDose> otherDoses = potionGroup.getDoses().stream().filter(d -> d.getId() != itemId).collect(Collectors.toList());
        for (PotionDose otherDose : otherDoses) {
            PotionDose inputDose = isBuy? sourceDose:otherDose;
            PotionDose outputDose = isBuy? otherDose:sourceDose;
            long lcm = MathUtils.lcm(sourceDose.getDose(), otherDose.getDose());
            RecipeItem inputDoseRecipeItem = new RecipeItem(inputDose.getId(), (int) (lcm/inputDose.getDose()));
            RecipeItem outputDoseRecipeItem = new RecipeItem(outputDose.getId(), (int) (lcm/outputDose.getDose()));
            String recipeName = String.format("Decanting %s (%d)->(%d)",potionGroup.getName(), inputDose.getDose(), outputDose.getDose());
            Recipe recipe = new Recipe(
                new ArrayList<>(Arrays.asList(inputDoseRecipeItem)),
                new ArrayList<>(Arrays.asList(outputDoseRecipeItem)),
                recipeName);
            applicableDecantRecipes.add(recipe);
        }

        return applicableDecantRecipes;
    }

    /**
     * Gets a mapping of item id to the recipes it is in.
     */
    private Optional<Map<Integer, List<Recipe>>> getItemIdToRecipes(Optional<List<Recipe>> optionalRecipes) {
        if (!optionalRecipes.isPresent()) {
            return Optional.empty();
        }

        Map<Integer, List<Recipe>> idToRecipes= new HashMap<>();
        List<Recipe> recipes = optionalRecipes.get();
        stripElementalRunesFromRecipes(recipes);
        recipes.forEach(r -> {
            r.getIds().forEach(id -> {
                if (idToRecipes.containsKey(id)) {
                    idToRecipes.get(id).add(r);
                }
                else {
                    idToRecipes.put(id, new ArrayList<>(Arrays.asList(r)));
                }
            });
        });

        return Optional.of(idToRecipes);
    }

    /**
     * Elemental runes need to be stripped bc people don't buy elemental runes for recipes, they just use
     * staffs
     */
    private void stripElementalRunesFromRecipes(List<Recipe> recipes) {
        //water, earth, fire, air
        Set<Integer> elementalRunes = new HashSet<>(Arrays.asList(555, 557, 554, 556));

        for (Recipe recipe: recipes) {
            List<RecipeItem> inputs = recipe.getInputs();
            recipe.setInputs(
                inputs
                    .stream()
                    .filter(input -> !elementalRunes.contains(input.getId()))
                    .collect(Collectors.toList()));

        }
    }

    private Optional<Map<Integer, PotionGroup>> getItemIdToPotionGroup(Optional<List<PotionGroup>> optionalPotionGroups) {
        if (!optionalPotionGroups.isPresent()) {
            return Optional.empty();
        }

        Map<Integer, PotionGroup> idToPotionGroup= new HashMap<>();
        List<PotionGroup> potionGroups = optionalPotionGroups.get();
        potionGroups.forEach(potionGroup -> {
            potionGroup.getIds().forEach(id -> {
                idToPotionGroup.put(id, potionGroup);
            });
        });

        return Optional.of(idToPotionGroup);

    }

    /**
     * This method computes the initial target values for each of the items when the panel
     * first shows up. This is so that the user doesn't have to manually input them (tho they can still
     * adjust them if they want). The target values are selected such that the max amount of
     * recipes can be made. Here is an example:
     *
     * Lets say there is a recipe where for every item C you need 3 of item A and 5 of item B. We
     * can shorten it by saying the recipe is 1C, 3A, and 5B. Now, lets say we have a quantity of 5 for item C,
     * quantity of 9 for item A and a quantity of 25 for item B. What is the max amount of this recipe you can make?
     * The max amount is only 3 because it is limited by that fact you only have 9 A items, even though the amount
     * of C and B items you have can support more recipes.
     *
     * Once we know the max amount of recipes the offers can support, we can multiply the max amount by the
     * amount the recipe needs of each item to know how much of each item we will need to make the max amount of
     * recipes. Continuing with the example above, our max recipes is 3. To get the amount of C items, we would do
     * 1 * 3. To get the amount of B items, we would do 5 * 3. To get the amount of A items, we would do 3 * 3.
     *
     * In short:
     * recipe = 3A, 5B, 1C
     * quantities = 9A 25B 5C
     * max # of this recipe supported per item: A=3, B=5, C=5
     * # of recipe supported in actuality: 3, cause A is constraining it.
     * target values: A = 9(3 * 3), B = 15(3 * 5), C = 3(3 * 1)
     *
     * @param itemIdToPartialOffers all the suitable partial offers for each item
     */
    public Map<Integer, Integer> getTargetValuesForMaxRecipeCount(
            Recipe recipe,
            Map<Integer, List<PartialOffer>> itemIdToPartialOffers,
            boolean useRemainingOffer
    ) {
        Map<Integer, Integer> itemIdToQuantity = recipe.getItemIdToQuantity();
        Map<Integer, Integer> itemIdToMaxRecipesThatCanBeMade = getItemIdToMaxRecipesThatCanBeMade(recipe, itemIdToPartialOffers, useRemainingOffer);
        int lowestRecipeCountThatCanBeMade = itemIdToMaxRecipesThatCanBeMade.values().stream().min(Comparator.comparingInt(i -> i)).get();
        //if there are items with such few buys/sells that a recipe can't be made, avoid returning target values of 0
        //as we still want to make it clear what the min amount needed for at least one recipe creation is
        if (lowestRecipeCountThatCanBeMade == 0) {
            return itemIdToQuantity;
        }
        return itemIdToQuantity.entrySet().stream().
            map(e -> new AbstractMap.SimpleEntry<>(e.getKey(), e.getValue() * lowestRecipeCountThatCanBeMade)).
            collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    /**
     * Gets a mapping of item id to the max amount of recipes that can be contributed to for each item in the given
     * partial offers
     */
    public Map<Integer, Integer> getItemIdToMaxRecipesThatCanBeMade(
            Recipe recipe,
            Map<Integer, List<PartialOffer>> itemIdToPartialOffers,
            boolean useRemainingOffer) {
        Map<Integer, Integer> itemIdToQuantity = recipe.getItemIdToQuantity();
        return itemIdToPartialOffers.entrySet().stream().map(e -> {
            int itemId = e.getKey();
            //make sure that coins is never a limiting factor in how many recipes can be made, as it is automatically
            //accounted for
            if (itemId == 995) {
                return new AbstractMap.SimpleEntry<>(itemId, Integer.MAX_VALUE);
            }
            long totalQuantity = e.getValue().stream().
                mapToLong(
                    po -> useRemainingOffer? po.getOffer().getCurrentQuantityInTrade() - po.amountConsumed: po.amountConsumed)
                .sum();
            long quantityNeededForRecipe = itemIdToQuantity.get(itemId);
            int maxRecipesThatCanBeMade = (int) (totalQuantity / quantityNeededForRecipe);
            return new AbstractMap.SimpleEntry<>(itemId, maxRecipesThatCanBeMade);
        }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public void addRecipeFlip(List<RecipeFlipGroup> recipeFlipGroups, RecipeFlip recipeFlip, Recipe recipe) {
        for (RecipeFlipGroup recipeFlipGroup : recipeFlipGroups) {
            if (recipe.equals(recipeFlipGroup.getRecipe())) {
                recipeFlipGroup.addRecipeFlip(recipeFlip);
                return;
            }
        }
        RecipeFlipGroup recipeFlipGroup = new RecipeFlipGroup(recipe);
        recipeFlipGroup.addRecipeFlip(recipeFlip);
        recipeFlipGroups.add(recipeFlipGroup);
    }

    public List<RecipeFlipGroup> sortRecipeFlipGroups(List<RecipeFlipGroup> items, SORT selectedSort, Instant startOfInterval) {
        List<RecipeFlipGroup> result = new ArrayList<>(items);

        if (selectedSort == null || result.isEmpty()) {
            return result;
        }

        switch (selectedSort) {
            case TIME:
                result.sort(Comparator.comparing(RecipeFlipGroup::getLatestFlipTime));
                break;
            case FLIP_COUNT:
                result.sort(Comparator.comparing(group -> {
                    List<RecipeFlip> flips = group.getFlipsInInterval(startOfInterval);
                    return flips.stream().mapToInt(rf -> rf.getRecipeCountMade(group.getRecipe())).sum();
                }));
                break;
            case TOTAL_PROFIT:
                result.sort(Comparator.comparing(group -> {
                    List<RecipeFlip> flips = group.getFlipsInInterval(startOfInterval);
                    return flips.stream().mapToLong(RecipeFlip::getProfit).sum();
                }));
                break;
            case PROFIT_EACH:
                result.sort(Comparator.comparing(group -> {
                    List<RecipeFlip> flips = group.getFlipsInInterval(startOfInterval);
                    long totalProfit = flips.stream().mapToLong(RecipeFlip::getProfit).sum();
                    long totalRecipesMade = flips.stream().mapToInt(rf -> rf.getRecipeCountMade(group.getRecipe())).sum();
                    return totalProfit/totalRecipesMade;
                }));
                break;
            case ROI:
                result.sort(Comparator.comparing(group -> {
                    List<RecipeFlip> flips = group.getFlipsInInterval(startOfInterval);
                    long totalProfit = flips.stream().mapToLong(RecipeFlip::getProfit).sum();
                    long totalExpense = flips.stream().mapToLong(RecipeFlip::getExpense).sum();
                    return (float) totalProfit / totalExpense * 100;
                }));
                break;
        }
        Collections.reverse(result);
        return result;
    }

    public void deleteInvalidRecipeFlips(List<OfferEvent> offers, List<RecipeFlipGroup> recipeFlipGroups) {
        if (offers.isEmpty()) {
            return;
        }
        int itemId = offers.get(0).getItemId();
        //get all the rfgs containing recipe flips that the offers could possibly be referenced in
        recipeFlipGroups.stream().filter(rfg -> rfg.isInGroup(itemId)).forEach(rfg -> rfg.deleteFlipsWithDeletedOffers(offers));
    }

    private Optional<List<PotionGroup>> loadPotionGroups() {
        return makeRequest(
            "https://raw.githubusercontent.com/Flipping-Utilities/osrs-datasets/master/potions.json",
            new TypeToken<List<PotionGroup>>() {}
        );
    }

    private Optional<List<Recipe>> loadRecipes() {
        return makeRequest(
            "https://raw.githubusercontent.com/Flipping-Utilities/osrs-datasets/master/recipes.json",
            new TypeToken<List<Recipe>>() {}
            );
    }

    private <T> Optional<T> makeRequest(String url, TypeToken<T> typeToken) {
        Request request = new Request.Builder()
            .url(url)
            .build();

        try (Response response = httpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                log.error("Recipe fetch returned unsuccessful response: " + response);
                return Optional.empty();
            }
            if (response.body() == null) {
                log.error("Recipe response body was null: " + response);
                return Optional.empty();
            }

            Type type = typeToken.getType();
            return Optional.of(gson.fromJson(response.body().string(), type));
        } catch (IOException e) {
            log.warn("IOException when trying to fetch recipes: {}", ExceptionUtils.getStackTrace(e));
            return Optional.empty();
        }
    }
}
package com.flippingutilities.utilities;

public class MathUtils {

    public static long gcd(long a, long b) {
        while (b > 0) {
            long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    public static long lcm(long a, long b) {
        return a * (b / gcd(a, b));
    }

}

package com.flippingutilities.utilities;

public class GeTax {
    public static int getPostTaxPrice(int price) {
        if (price >= Constants.MAX_PRICE_FOR_GE_TAX) {
            return price - Constants.GE_TAX_CAP;
        }
        int tax = (int)Math.floor(price * Constants.GE_TAX);
        return price - tax;
    }
}

package com.flippingutilities.utilities;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.List;

@Data
@AllArgsConstructor
public class AccountSlotsUpdate {
    public final String rsn;
    public final List<SlotState> slots;
}

package com.flippingutilities.utilities;

import lombok.Data;


@Data
public class WikiItemMargins {
    int high;
    long highTime;
    int low;
    long lowTime;
}

package com.flippingutilities.utilities;

import com.flippingutilities.model.OfferEvent;
import com.google.common.collect.Lists;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.widgets.Widget;

import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Extracts data from the widgets in the trade history tab so that the TradeHistoryTabPanel can display them. I wanted
 * the TradeHistoryTabPanel, and all UI components, to pretty much only draw stuff and not do much else, hence the separation.
 */
@Slf4j
public class GeHistoryTabExtractor {
    private static Pattern MULTI_ITEM_PATTERN = Pattern.compile(">= (.*) each");
    private static Pattern SINGLE_ITEM_PATTERN = Pattern.compile(">(.*) coin");
    private static Pattern ORIGINAL_PRICE_PATTERN = Pattern.compile("\\((.*) -");

    public static List<OfferEvent> convertWidgetsToOfferEvents(Widget[] widgets) {
        //a group of 6 widgets makes up an offer in the trade history tab
        List<List<Widget>> groupsOfWidgets = Lists.partition(Arrays.asList(widgets), 6);
        return groupsOfWidgets.stream().map(w -> createOfferEventFromWidgetGroup(w)).collect(Collectors.toList());
    }

    public static OfferEvent createOfferEventFromWidgetGroup(List<Widget> widgets) {
        //set slot to -1 so we can handle it appropriately in the history manager when the offer is added.
        int slot = -1;
        GrandExchangeOfferState offerState = getState(widgets.get(2));
        int quantity = widgets.get(4).getItemQuantity();
        int itemId = widgets.get(4).getItemId();
        int price = getPrice(widgets.get(5), quantity);
        boolean isBuy = offerState == GrandExchangeOfferState.BOUGHT;
        Instant time = Instant.now();
        int totalQuantity = quantity;
        int tickArrivedAt = -1;
        //just making ticksSinceFirst offer something > 2 so it doesn't count as a margin check
        int ticksSinceFirstOffer = 10;

        OfferEvent offerEvent = new OfferEvent(UUID.randomUUID().toString(), isBuy, itemId, quantity, price, time, slot, offerState, tickArrivedAt, ticksSinceFirstOffer, totalQuantity, null, false, null, null,0,0);
        return offerEvent;
    }

    /**
     * Gets original price of each item (price before ge tax) from the ge history. We want
     * to get the price before ge tax bc the the price after ge tax is always calculated by the
     * OfferEvent class wherever we need to display it. That means that if we get the price after tax
     * here and then construct an OfferEvent with that price, and then try to display the OfferEvent's price
     * using OfferEvent.getPrice(), we will effectively be applying the ge tax twice.
     * @return the original price of each item in the offer
     */
    private static int getPrice(Widget w, int quantity) {
        String text = w.getText();
        String numString = text;
        Matcher m;
        boolean isTotalPrice = false;
        // This will trigger anytime there is the ge tax text on an offer in the history
        // For example when you have that text with the format "({original price} - {ge_tax})
        // Whenever that text is present, we want to get the original price (NOT THE PRICE
        // AFTER THE TAX). However, since the original price displayed is not the price of each item
        //we have to divide it by the quantity to get the original price of each item.
        if (text.contains(")</col>")) {
            m = ORIGINAL_PRICE_PATTERN.matcher(text);
            isTotalPrice = true;
        }
        //if the case above doesn't trigger that means there is no tax on the item, so we check if "each"
        //is present which allows us to use the regex for getting the price of each item when multiple
        //have been traded.
        else if (text.contains("each")) {
            m = MULTI_ITEM_PATTERN.matcher(text);
        }
        //if this case triggers than it is an offer for a single item that is untaxed
        else {
            m = SINGLE_ITEM_PATTERN.matcher(text);
        }
        m.find();
        numString = m.group(1);
        StringBuilder s = new StringBuilder();
        for (char c : numString.toCharArray()) {
            if (Character.isDigit(c)) {
                s.append(c);
            }
        }

        int price = Integer.parseInt(s.toString());
        if (isTotalPrice) {
            return price/quantity;
        }
        return price;
    }

    private static GrandExchangeOfferState getState(Widget w) {
        String text = w.getText();
        if (text.startsWith("Bought")) {
            return GrandExchangeOfferState.BOUGHT;
        } else {
            return GrandExchangeOfferState.SOLD;
        }
    }
}

package com.flippingutilities.utilities;

import lombok.Data;

@Data
public class PotionDose {
    int id;
    int dose;
}

package com.flippingutilities.utilities;

import org.apache.commons.lang3.tuple.Pair;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.IntStream;

public class ListUtils {
    /**
     * Partition a list of items into n sublists based on n conditions passed in. Perhaps this should be a static method?
     * The first condition puts items that meet its criteria in the first arraylist in the sublists array, the nth
     * conditions puts the items in the nth arraylist in the sublists array.
     *
     * @param items      to partition into sub lists
     * @param conditions conditions to partition on
     * @return
     */
    public static <T> List<T>[] partition(List<T> items, Predicate<T>... conditions) {
        List<T>[] subLists = new ArrayList[conditions.length];

        IntStream.range(0, subLists.length).forEach(i -> subLists[i] = new ArrayList<>());

        for (T item : items) {
            for (int i = 0; i < conditions.length; i++) {
                if (conditions[i].test(item)) {
                    subLists[i].add(item);
                }
            }
        }
        return subLists;
    }

    /**
     * Guava has a util function for converting a list to a map, but you are only
     * allowed to provide it a function which generates the keys of the map...it will
     * use the values of the list as the values of the map
     * <p>
     * This method allows you to provide a function that generates a k,v pair based on
     * a value in the provided list
     */
    public static <K, V, L> Map<K, V> toMap(
        List<L> values,
        Function<L, Pair<K, V>> keyValueFunction) {
        Map<K, V> m = new HashMap<>();
        values.forEach(l -> {
            Pair<K, V> pair = keyValueFunction.apply(l);
            m.put(pair.getKey(), pair.getValue());
        });
        return m;
    }
}

package com.flippingutilities.utilities;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class WikiRequestWrapper {
    WikiRequest wikiRequest;
    WikiDataSource wikiDataSource;
}

package com.flippingutilities.utilities;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class SlotInfo {
    int index;
    SlotPredictedState predictedState;
    int itemId;
    int offerPrice;
    boolean isBuyOffer;
}
package com.flippingutilities.utilities;

import lombok.Data;

@Data
public class OsrsAccount {
    String id;
    String rsn;
}

package com.flippingutilities.utilities;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.*;
import java.util.stream.Collectors;

@Data
@AllArgsConstructor
public class Recipe {
    List<RecipeItem> inputs;
    List<RecipeItem> outputs;
    String name;

    /**
     * Gets the item ids for all the items in the outputs and inputs of the recipe
     */
    public Set<Integer> getIds() {
        Set<Integer> ids = new HashSet<>();
        inputs.forEach(r -> ids.add(r.id));
        outputs.forEach(r -> ids.add(r.id));
        return ids;
    }

    public boolean isInRecipe(int itemId) {
        return getIds().contains(itemId);
    }

    /**
     * Gets a mapping of item id in the recipe to desired quantity of that item
     */
    public Map<Integer, Integer> getItemIdToQuantity() {
        Map<Integer, Integer> itemIdToQuantity = new HashMap<>();
        inputs.forEach(r -> itemIdToQuantity.put(r.id, r.quantity));
        outputs.forEach(r -> itemIdToQuantity.put(r.id, r.quantity));
        return itemIdToQuantity;
    }

    /**
     * Checks whether the given item is an input for this recipe
     */
    public boolean isInput(int itemId) {
        return inputs.stream().anyMatch(ri -> ri.id == itemId);
    }

    public Set<Integer> getInputIds() {
        return inputs.stream().map(ri -> ri.id).collect(Collectors.toSet());
    }

    public Set<Integer> getOutputIds() {
        return outputs.stream().map(ri -> ri.id).collect(Collectors.toSet());
    }
}
package com.flippingutilities.utilities;

import com.flippingutilities.model.OfferEvent;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;

import java.time.Instant;
import java.util.Date;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class SlotState {
    public static final transient String DATE_FORMAT = "YYYY-MM-dd'T'HH:mm:ss.sssZ";
    private Boolean isBuyOffer;
    private Integer itemId;
    private Integer filledQty;
    private Date lastFilledTime;
    private int index;
    private String state;
    private Integer offerQty;
    private Integer offerPrice;
    private Integer filledPrice;
    private Date offerCreationTime;

    public static SlotState fromOfferEvent(OfferEvent offerEvent) {
        return new SlotState(
                offerEvent.isBuy(),
                offerEvent.getItemId(),
                offerEvent.getCurrentQuantityInTrade(),
                offerEvent.isBeforeLogin()? null: Date.from(offerEvent.getTime()), //if the offer came before login, we don't know when it was actually filled
                offerEvent.getSlot(),
                convertStateEnum(offerEvent.getState()),
                offerEvent.getTotalQuantityInTrade(),
                offerEvent.getListedPrice(),
                offerEvent.getSpent(),
                offerEvent.getTradeStartedAt() != null? Date.from(offerEvent.getTradeStartedAt()): null
        );
    }

    public static String convertStateEnum(GrandExchangeOfferState grandExchangeOfferState) {
        switch (grandExchangeOfferState) {
            case SOLD:
            case BOUGHT:
                return "FILLED";
            case BUYING:
            case SELLING:
                return "ACTIVE";
            case CANCELLED_BUY:
            case CANCELLED_SELL:
                return "CANCELLED";
            default:
                return "EMPTY";
        }
    }

    /**
     * GSON will exclude null fields when serializing objects
     */
    public static SlotState createEmptySlot(int index) {
        SlotState emptySlot = new SlotState();
        emptySlot.index = index;
        return emptySlot;
    }
}



package com.flippingutilities.utilities;

public enum SlotPredictedState {
    UNKNOWN,
    IN_RANGE,
    OUT_OF_RANGE,
    BETTER_THAN_WIKI;

    public static SlotPredictedState getPredictedState(boolean buy, int listedPrice, int instaSell, int instaBuy) {
        boolean isBetterThanWiki = buy ? listedPrice > Math.max(instaBuy, instaSell) : listedPrice < Math.min(instaSell, instaBuy);
        boolean isInRange = buy ? listedPrice >= Math.min(instaSell, instaBuy) : listedPrice <= Math.max(instaBuy, instaSell);

        if (isBetterThanWiki) {
            return SlotPredictedState.BETTER_THAN_WIKI;
        } else if (isInRange) {
            return SlotPredictedState.IN_RANGE;
        } else {
            return SlotPredictedState.OUT_OF_RANGE;
        }
    }
}
package com.flippingutilities.utilities;

public class Constants {
    //epoch seconds that GE tax was introduced. This is not the exact time, just a close
    //enough approximation
    public static int GE_TAX_START = 1639072800;
    public static int GE_TAX_CAP = 5000000;
    public static int MAX_PRICE_FOR_GE_TAX = 250000000;
    public static double GE_TAX = 0.02; // 2%
    public static int BOND_ID = 13190;
    public static String DUMMY_ITEM = "dummy";

}

package com.flippingutilities.utilities;

public enum SORT {
    TIME,
    TOTAL_PROFIT,
    PROFIT_EACH,
    ROI,
    FLIP_COUNT
}

package com.flippingutilities.utilities;

public class InvalidOptionException extends Exception {
    public InvalidOptionException(String errorMessage) {
        super(errorMessage);
    }
}

package com.flippingutilities.utilities;

import lombok.Data;

@Data
public class TokenResponse {
    String access_token;
}

package com.flippingutilities.utilities;

public enum WikiDataSource {
    DMM,
    REGULAR
}

package com.flippingutilities.utilities;

import lombok.Data;

import java.util.Map;

@Data
public class WikiRequest {
    Map<Integer, WikiItemMargins> data;
}

package com.flippingutilities.utilities;

import lombok.Data;

@Data
public class User {
    String discordId;
    boolean isPremium;
}
package com.flippingutilities.utilities;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class RecipeItem {
    int id;
    int quantity;
}
package com.flippingutilities.utilities;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Value;
import okhttp3.Request;
import okhttp3.Response;

import java.io.IOException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Base64;

@AllArgsConstructor
@Data
public class Jwt {
    JwtHeader header;
    JwtPayload payload;
    String signature;

    public static Jwt fromString(String jwtString, Gson gson) throws JsonSyntaxException, ArrayIndexOutOfBoundsException, IllegalArgumentException {
        //need to escape the "." as it's a special character
        String[] parts = jwtString.split("\\.");
        String jwtHeaderString = new String(Base64.getDecoder().decode(parts[0]));
        String jwtPayloadString = new String(Base64.getDecoder().decode(parts[1]));
        JwtHeader jwtHeader = gson.fromJson(jwtHeaderString, JwtHeader.class);
        JwtPayload jwtPayload = gson.fromJson(jwtPayloadString, JwtPayload.class);
        String signature = parts[2];
        return new Jwt(jwtHeader, jwtPayload, signature);
    }

    public boolean isExpired() {
        return this.payload.exp <=  Instant.now().getEpochSecond();
    }

    /**
     * JWT should be refreshed if it will expire within the next 10 days. 10 days is a pretty safe buffer as we
     * run this check on client start up, and RL updates every week, so players' should not have their client open
     * for more than 10 days.
     */
    public boolean shouldRefresh() {
        return this.payload.exp <= Instant.now().plus(10, ChronoUnit.DAYS).getEpochSecond();
    }
}

@Data
class JwtHeader {
    String alg;
    String typ;
}

@Data
class JwtPayload {
    String userId;
    String discordId;
    int iat;
    long exp; //epoch seconds
}
package com.flippingutilities.utilities;

import java.time.Instant;

public interface Searchable {
    boolean isInInterval(Instant intervalStart);
    String getNameForSearch();
}

package com.flippingutilities.utilities;

import lombok.Data;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Data
public class PotionGroup {
    String name;
    List<PotionDose> doses;

    public Set<Integer> getIds() {
        return doses.stream().map(d -> d.id).collect(Collectors.toSet());
    }

}
package com.flippingutilities.model;

import lombok.Data;

import java.util.*;

/**
 * Represents one of the sections in the FlippingItemPanel. Since a user can heavily customize what a FlippingItemPanel
 * looks like (its sections), we have to store what their customizations are. This stores the customizations to a section.
 */
@Data
public class Section {
    String name;
    public static final String WIKI_BUY_PRICE = "wiki buy price";
    public static final String WIKI_SELL_PRICE = "wiki sell price";
    public static final String LAST_INSTA_SELL_PRICE = "price check buy price";
    public static final String LAST_INSTA_BUY_PRICE = "price check sell price";
    public static final String LAST_BUY_PRICE = "latest buy price";
    public static final String LAST_SELL_PRICE = "latest sell price";
    public static final String WIKI_PROFIT_EACH = "profit each";
    public static final String POTENTIAL_PROFIT = "potential profit";
    public static final String ROI = "roi";
    public static final String REMAINING_GE_LIMIT = "remaining ge limit";
    public static final String GE_LIMIT_REFRESH_TIMER = "ge limit refresh timer";
    public static final String MARGIN_CHECK_PROFIT_EACH = "margin check profit each";
    public static final List<String> possibleLabels = Arrays.asList(WIKI_BUY_PRICE, WIKI_SELL_PRICE, LAST_INSTA_SELL_PRICE, LAST_INSTA_BUY_PRICE, LAST_BUY_PRICE,
        LAST_SELL_PRICE, WIKI_PROFIT_EACH, POTENTIAL_PROFIT, ROI, REMAINING_GE_LIMIT, GE_LIMIT_REFRESH_TIMER, MARGIN_CHECK_PROFIT_EACH);
    Map<String, Boolean> labels;
    boolean defaultExpanded;

    public Section(String name) {
        this.name = name;
        this.labels = new LinkedHashMap<>();
        for (String label:Section.possibleLabels) {
            this.labels.put(label, false);
        }
    }

    public boolean isShowingLabel(String labelName) {
        if (labels.containsKey(labelName)) {
            return labels.get(labelName);
        }
        return false;
    }

    public void showLabel(String labelName, boolean shouldShow) {
            labels.put(labelName, shouldShow);
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package com.flippingutilities.model;

import com.flippingutilities.utilities.ListUtils;
import com.google.gson.annotations.SerializedName;
import lombok.*;
import lombok.extern.slf4j.Slf4j;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Manages the history for an item. This class is responsible for figuring out how much profit a user made for
 * an item along with tracking how many items they bought since the last ge limit refresh and when the
 * next ge limit refresh for this an item will be.
 */
@Slf4j
@AllArgsConstructor
@NoArgsConstructor
public class HistoryManager
{
	@SerializedName("sO")
	@Getter
	@Setter
	private List<OfferEvent> compressedOfferEvents = new ArrayList<>();

	@SerializedName("nGLR")
	@Getter
	private Instant nextGeLimitRefresh;

	@SerializedName("iBTLW")
	@Getter
	private int itemsBoughtThisLimitWindow;

	@SerializedName("pIB")
	private int itemsBoughtThroughCompleteOffers;

	public HistoryManager clone()
	{
		List<OfferEvent> clonedCompressedOfferEvents = compressedOfferEvents.stream().map(OfferEvent::clone).collect(Collectors.toList());
		Instant clonedGeLimitRefresh = nextGeLimitRefresh == null ? null : Instant.ofEpochMilli(nextGeLimitRefresh.toEpochMilli());
		return new HistoryManager(
				clonedCompressedOfferEvents,
				clonedGeLimitRefresh,
				itemsBoughtThisLimitWindow,
				itemsBoughtThroughCompleteOffers
		);
	}

	public void updateHistory(OfferEvent newOffer)
	{
		//if slot is -1 than the offer was added manually from GE history.
		//Since we don't know when it came or its slot/it doesn't have a time or slot, there is no point in updating ge
		//properties or trying to delete previous offers for the trade.
		if (newOffer.getSlot() != -1)
		{
			updateGeLimitProperties(newOffer);
			deletePreviousOffersForTrade(newOffer);
		}

		compressedOfferEvents.add(newOffer);
	}

	/**
	 * Updates when the ge limit will refresh and how many items have been bought since the last
	 * ge limit refresh.
	 *
	 * @param newOfferEvent offer event just received
	 */
	private void updateGeLimitProperties(OfferEvent newOfferEvent)
	{
		//there is a small bug in this method. Basically, when we get non-complete offers from different slots it will
		//only take one of the slots buys into account. When the offer completes or is cancelled things are fine.

		if (!newOfferEvent.isBuy())
		{
			return;
		}
		// when the time of the last offer (most recent offer) is greater than nextGeLimitRefresh,
		// you know the ge limits have refreshed. Since this is the first offer after the ge limits
		// have refreshed, the next refresh will be four hours after this offer's buy time.


		//if we got the event before login, there could be a problem. If the login was outside the current window
		//you don't know whether the event occurred within the window or outside.

		//if the login was within the window that was established by the purchase of an item while logged in
		// there isn't a problem, bc u know to just add to the items bought this window.
		if (nextGeLimitRefresh == null || newOfferEvent.getTime().compareTo(nextGeLimitRefresh) > 0)
		{
			nextGeLimitRefresh = newOfferEvent.getTime().plus(4, ChronoUnit.HOURS);
			if (newOfferEvent.isComplete())
			{
				itemsBoughtThroughCompleteOffers = newOfferEvent.getCurrentQuantityInTrade();
				itemsBoughtThisLimitWindow = itemsBoughtThroughCompleteOffers;
			}
			else
			{
				itemsBoughtThroughCompleteOffers = 0;
				itemsBoughtThisLimitWindow = newOfferEvent.getCurrentQuantityInTrade();

			}
		}
		//if the last offer (most recent offer) is before the next ge limit refresh, add its currentQuantityInTrade to the
		//amount bought this limit window.
		else
		{
			if (newOfferEvent.isComplete())
			{
				itemsBoughtThroughCompleteOffers += newOfferEvent.getCurrentQuantityInTrade();
				itemsBoughtThisLimitWindow = itemsBoughtThroughCompleteOffers;
			}
			else
			{
				itemsBoughtThisLimitWindow = itemsBoughtThroughCompleteOffers + newOfferEvent.getCurrentQuantityInTrade();
			}
		}
	}

	/**
	 * Deletes previous offer events for the same trade as the given offer event so that each trade has only one
	 * offer event representing it.
	 *
	 * @param newOfferEvent offer event just received
	 */
	//TODO pretty sure this has an edge cases where we think an offer is part of the same trade but it isn't...so we delete too much.
	//Ex:
	//IN RL: set offer to buy 100 lobsters in slot X. Offer event comes in and Five lobsters buy. log off.
	//log onto mobile, cancel the previous lobster offer and set another for 100 lobsters again in slot X.
	//Log back into RL with 10 lobsters being bought. This method will think those offers are for the same trade and delete
	//the first offer event for 5 lobsters...There are ways to make this more unlikely, such as checking if all the relevant
	//properties of the offers match (except currentQuantityInTrade). But, there is no way to be 100% sure because all
	//those properties could match but it could still be from a different trade if they cancel and make a trade outside of
	//RL
	public void deletePreviousOffersForTrade(OfferEvent newOfferEvent)
	{
		for (int i = compressedOfferEvents.size() - 1; i > -1; i--)
		{
			OfferEvent aPreviousOffer = compressedOfferEvents.get(i);
			if (aPreviousOffer.getSlot() == newOfferEvent.getSlot() && aPreviousOffer.isBuy() == newOfferEvent.isBuy())
			{
				//if it belongs to the same slot and its complete, it must belong to a previous trade given that
				//the most recent offer was for the same slot
				if (aPreviousOffer.isComplete())
				{
					return;
				}
				else
				{
					compressedOfferEvents.remove(i);
				}
			}
		}
	}

	/**
	 * Returns the history of the item that were traded between earliestTime and now.
	 *
	 * @param earliestTime the earliest time that trades from the trade history are added to the resulting list.
	 * @return A list of offers that were within the interval of earliestTime and now.
	 */
	public ArrayList<OfferEvent> getIntervalsHistory(Instant earliestTime)
	{
		ArrayList<OfferEvent> result = new ArrayList<>();

		for (OfferEvent offer : compressedOfferEvents)
		{
			if (offer.getTime().isAfter(earliestTime))
			{
				result.add(offer);
			}
		}

		return result;
	}

	/**
	 * This is to prevent old values from remaining for items that a user has bought and whose
	 * refresh times have already passed. If the user buys the item again, the values will be up to date,
	 * so this method wouldn't be needed, but there is no guarantee the user buys the item again after the
	 * limit refreshes. This method should be called periodically to ensure no old values will remain.
	 */
	public void validateGeProperties()
	{
		if (nextGeLimitRefresh == null)
		{
			return;
		}

		if (Instant.now().compareTo(nextGeLimitRefresh) >= 0)
		{
			nextGeLimitRefresh = null;
			itemsBoughtThisLimitWindow = 0;
		}
	}

	public boolean hasValidOffers()
	{
		return compressedOfferEvents.size() > 0;
	}

	public boolean hasOfferInInterval(Instant earliestTime) {
		if (!hasValidOffers()) {
			return false;
		}
		OfferEvent lastOffer = compressedOfferEvents.get(compressedOfferEvents.size()-1);
		return lastOffer.getTime().isAfter(earliestTime);
	}

	/**
	 * Used to mark offers as invalid. These offers are then pruned later. This is the mechanism
	 * by which offers are deleted.
	 * @param offerList the offers being invalidated
	 */
	public void deleteOffers(List<OfferEvent> offerList)
	{
		if (offerList.isEmpty()) {
			return;
		}

		Set<String> idsOfOffersToBeDeleted = offerList.stream().map(OfferEvent::getUuid).collect(Collectors.toSet());
		compressedOfferEvents.removeIf(o -> idsOfOffersToBeDeleted.contains(o.getUuid()));
	}

	/**
	 * Gets offers that have the same quantity, price ea, and buy/sell state as the given offer. This is currently used
	 * to see if there are any potential duplicates of an offer a user is trying to add manually from their GE history.
	 * Since the offers scraped from the GE history tab don't have slot information, the slots are not compared here
	 * to see if an offer is a match/duplicate.
	 *
	 * @param offer offer that duplicates are being found for.
	 * @return offers that could potentially be duplicates of the given offer event.
	 * @param limit max amount of potentially duplicate offers to find.
	 */
	public List<OfferEvent> getOfferMatches(OfferEvent offer, int limit)
	{
		List<OfferEvent> matches = new ArrayList<>();
		int count = 0;
		//look from the back to get the N most recent matches where N = limit.
		for (int i = compressedOfferEvents.size() - 1; i > -1; i--)
		{
			OfferEvent pastOffer = compressedOfferEvents.get(i);
			//don't just compare state because the scraped offer will only be of state BOUGHT/SOLD, whereas the offer in history
			//might be CANCELLED_BUY/CANCELLED_SELL
			if (offer.getPrice() == pastOffer.getPrice() && offer.getCurrentQuantityInTrade() == pastOffer.getCurrentQuantityInTrade()
				&& offer.isBuy() == pastOffer.isBuy() && pastOffer.isComplete())
			{
				matches.add(pastOffer);
				count++;
				if (count == limit)
				{
					break;
				}
			}
		}
		return matches;
	}

	/**
	 * Gets the YOUNGEST offer that matches some arbitrary conditions
	 * @param predicate conditions
	 */
	public Optional<OfferEvent> getLatestOfferThatMatchesPredicate(Predicate<OfferEvent> predicate)
	{
		for (int i = compressedOfferEvents.size() - 1; i > -1; i--)
		{
			if (predicate.test(compressedOfferEvents.get(i)))
			{
				return Optional.of(compressedOfferEvents.get(i));
			}
		}
		return Optional.empty();
	}

	/**
	 * Because we don't persist the itemName field in an OfferEvent, we need to hydrate every
	 * OfferEvent with it
	 */
	public void setOfferNames(String itemName) {
		compressedOfferEvents.forEach(o -> o.setItemName(itemName));
	}

	/**
	 * We don't persist the madeBy field, so it has to be hydrated.
	 */
	public void setOfferMadeBy(String name) {
		compressedOfferEvents.forEach(o -> o.setMadeBy(name));
	}

	/**
	 * Every new offer event created nowadays has a uuid associated with it. However, the old
	 * offer events that have already been persisted need their uuids' set.
	 */
	public void setOfferIds() {
		compressedOfferEvents.forEach(o -> {
			if (o.getUuid() == null) {
				o.setUuid(UUID.randomUUID().toString());
			}
		});
	}

	//STATIC METHODS BEGIN (wondering if i should move them elsewhere, but, where?)

	/**
	 * Calculates profit for a list of trades made with this item by counting the expenses and revenues
	 * accrued over these trades and figuring out the difference in value.
	 *
	 * @param tradeList The list of trades whose total profits will be calculated.
	 * @return profit
	 */
	public static long getProfit(List<OfferEvent> tradeList)
	{
		return getValueOfMatchedOffers(tradeList, false) -
			getValueOfMatchedOffers(tradeList, true);
	}

	/**
	 * This method finds the value of all the offers with the buyState that are
	 * contributing to flips. As such, this is NOT the value of the entire trade list, or the value of
	 * ALL the buys/sells. It is only the value of buys OR sells that are contributing to flips, meaning
	 * they would be matched to another buy/sell when constructing flips.
	 *
	 * @param tradeList  A list of offers
	 * @param isBuy Refers to whether buys or sells should be looked at
	 * @return Returns the value of flips
	 */
	public static long getValueOfMatchedOffers(List<OfferEvent> tradeList, boolean isBuy)
	{
		return getValueOfOffersUpToLimit(
			tradeList.stream().filter(o -> o.isBuy() == isBuy).collect(Collectors.toList()),
			countFlipQuantity(tradeList));
	}

	/**
	 * Calculates the total value of the sell or buy offers in a trade list.
	 */
	public static long getTotalRevenueOrExpense(List<OfferEvent> tradeList, boolean isBuy)
	{
		return tradeList.stream().
			filter(o -> o.isBuy() == isBuy).
			mapToLong(o -> o.getCurrentQuantityInTrade() * o.getPrice()).sum();
	}

	/**
	 * Gets the amount of items in a given tradelist that have been "flipped". We take
	 * min(itemsBought, itemsSold) bc we only want the amount of items that will actually be matched against each
	 * other to create flips and if either buys or sells has a surplus relative to the other, that surplus won't be
	 * matched.
	 *
	 * @param tradeList The list of offers that the flip count is based on
	 * @return An integer representing the total currentQuantityInTrade of items flipped in the list of offers
	 */
	public static int countFlipQuantity(List<OfferEvent> tradeList)
	{
		int numBoughtItems = 0;
		int numSoldItems = 0;

		for (OfferEvent offer : tradeList)
		{
			if (offer.isBuy())
			{
				numBoughtItems += offer.getCurrentQuantityInTrade();
			}
			else
			{
				numSoldItems += offer.getCurrentQuantityInTrade();
			}
		}

		return Math.min(numBoughtItems, numSoldItems);
	}

	/**
	 * Calculates the amount of money spent on either a buy or sell list, up to the amount of items
	 * specified by the limit.
	 *
	 * @param tradeList a buy or a sell list
	 * @param itemLimit the amount of items to calculate the value up until. This is for the case
	 *                  when a user has an unequal amount of buys/sells in which case you want to return the
	 *                  profit the items only up until the buys and sells are equal. If this values is -1, it
	 *                  ignores the limit.
	 * @return the amount of money spent on the offer list, up to the amount of items specified by the
	 * limit
	 */
	private static long getValueOfOffersUpToLimit(List<OfferEvent> tradeList, long itemLimit)
	{
		int itemsSeen = 0;
		long moneySpent = 0;

		itemLimit = itemLimit == -1 ? Long.MAX_VALUE : itemLimit;

		for (OfferEvent offer : tradeList)
		{
			if (itemsSeen + offer.getCurrentQuantityInTrade() >= itemLimit)
			{
				moneySpent += (itemLimit - itemsSeen) * offer.getPrice();
				break;
			}
			else
			{
				moneySpent += offer.getCurrentQuantityInTrade() * offer.getPrice();
				itemsSeen += offer.getCurrentQuantityInTrade();
			}

		}

		return moneySpent;
	}

	/**
	 * Returns a view of the offer events that accounts for the amount consumed by partial offers
	 * in the recipe flips
	 */
	static List<OfferEvent> getPartialOfferAdjustedView(List<OfferEvent> offers, Map<String, PartialOffer> partialOffers) {
		return offers.stream().map(o -> {
			if (partialOffers.containsKey(o.getUuid())) {
				return partialOffers.get(o.getUuid()).toRemainingOfferEvent();
			}
			return o;
		}).collect(Collectors.toList());
	}

	/**
	 * Creates Flips from offers. Flips represent a buy trade followed by a sell trade. A trade is a collection
	 * of offers from the empty offer to the completed offer. A completed offer marks the end of a trade.
	 *
	 * @param tradeList offers
	 * @return flips
	 */
	public static List<Flip> getFlips(List<OfferEvent> tradeList)
	{
		//group offers based on which account those offers belong to (this is really only relevant when getting the flips
		//of the account wide tradelist as you don't want to match offers from diff accounts.

		Map<String, List<OfferEvent>> groupedOffers = tradeList.stream().collect(Collectors.groupingBy(OfferEvent::getMadeBy));

		//take each offer list and create flips out of them, then put those flips into one list.
		List<Flip> flips = new ArrayList<>();
		groupedOffers.values().forEach(offers -> flips.addAll(createFlips(offers)));

		flips.sort(Comparator.comparing(Flip::getTime));

		return flips;
	}

	/**
	 * Creates flips out of a list of offers. It does this by first pairing margin check offers together and then
	 * pairing regular offers together.
	 *
	 * @param offers the offer list
	 * @return flips
	 */
	public static List<Flip> createFlips(List<OfferEvent> offers)
	{
		List<OfferEvent>[] subLists = ListUtils.partition(
			offers.stream().map(OfferEvent::clone).collect(Collectors.toList()),
			o -> o.isMarginCheck() && o.isBuy(),
			o -> o.isMarginCheck() && !o.isBuy(),
			o -> !o.isMarginCheck() && o.isBuy(),
			o -> !o.isMarginCheck() && !o.isBuy());

		List<OfferEvent> buyMarginChecks = subLists[0];
		List<OfferEvent> sellMarginChecks = subLists[1];
		List<OfferEvent> nonMarginCheckBuys = subLists[2];
		List<OfferEvent> nonMarginCheckSells = subLists[3];

		ArrayList<Flip> flips = new ArrayList<>();

		List<OfferEvent> unPairedMarginChecks = new ArrayList<>();
		List<Flip> flipsFromMarginChecks = pairMarginChecks(buyMarginChecks, sellMarginChecks, unPairedMarginChecks);

		unPairedMarginChecks.forEach(offer ->
		{
			if (offer.isBuy())
			{
				nonMarginCheckBuys.add(offer);
			}
			else
			{
				nonMarginCheckSells.add(offer);
			}
		});

		//we sort the offers because we added the unpaired margin checks back to the offer list and it should be
		//placed in the appropriate place in the list so it doesn't get matched with an offer from many days ago or something.
		nonMarginCheckBuys.sort(Comparator.comparing(OfferEvent::getTime));
		nonMarginCheckSells.sort(Comparator.comparing(OfferEvent::getTime));

		flips.addAll(flipsFromMarginChecks);
		flips.addAll(combineToFlips(nonMarginCheckBuys, nonMarginCheckSells));

		return flips;
	}

	/**
	 * We need to pair margin check offers together because we don't want them to be paired with a regular offer in the case
	 * of an uneven quantity of items bought/sold. Pairing margin checks is tricky...A "whole" margin check is defined as a
	 * buy margin check offer followed by a sell margin check offer. However, when flipping, one often insta
	 * buys an item just to see its optimal sell price and likewise they might randomly insta sell an item to see
	 * its optimal buy price. These "half" margin checks may not be followed by a corresponding buy/sell margin check offer
	 * to make it a "whole" margin check. As such, if we are grouping margin check offers together to create flips,
	 * if a user has done some of these "half" margin checks, we have to be careful not to accidently group them with a
	 * buy/sell margin check offer that actually has its corresponding buy/sell margin check offer that makes it a whole
	 * margin check. This can result in REALLY inaccurate Flips as half margin check (lets say its a margin check buy offer)
	 * from a day before can be matched with a sell margin check offer from another day (when the margin's are totally
	 * different). And since that buy margin check offer was erroneously matched to that sell margin check offer the
	 * buy offer that was actually supposed to be matched to it, might match with some sell margin check offer that
	 * IT doesn't correspond to, etc.
	 *
	 * @param buys      a list of buy margin check offers
	 * @param sells     a list of sell margin check offers
	 * @param remainder an empty list to be populated with margin check offers that don't have companion buy/sell offers.
	 * @return a list of flips created from "whole" margin checks.
	 */
	public static List<Flip> pairMarginChecks(List<OfferEvent> buys, List<OfferEvent> sells, List<OfferEvent> remainder)
	{
		List<Flip> flips = new ArrayList<>();
		int buyIdx;
		int sellIdx = 0;
		for (buyIdx = 0; buyIdx < buys.size(); buyIdx++)
		{

			if (sellIdx == sells.size())
			{
				break;
			}

			OfferEvent buy = buys.get(buyIdx);
			OfferEvent sell = sells.get(sellIdx);

			//just a subjective heuristic i am using to determine whether a buy margin check has a companion sell margin
			//check. Chances are, if there's a 1 minute difference
			long millisBetweenBuyAndSell = Duration.between(buy.getTime(), sell.getTime()).toMillis();
			if (millisBetweenBuyAndSell >= 0 && millisBetweenBuyAndSell < 60000) //60k milliseconds is a minute
			{
				flips.add(new Flip(buy.getPrice(), sell.getPrice(), sell.getCurrentQuantityInTrade(), sell.getTime(), sell.isMarginCheck(), false));
				sellIdx++;
			}

			//if the buy is more than 1 minute before the sell, its probably not for that sell.
			else if (millisBetweenBuyAndSell >= 0 && !(millisBetweenBuyAndSell < 60000))
			{
				remainder.add(buy);
			}

			//if the sell comes before the buy its a stand alone insta sell (a "half" margin check")
			else if (millisBetweenBuyAndSell < 0)
			{
				remainder.add(sell);
				sellIdx++;
				buyIdx--; //stay on this buy offer
			}

		}

		//if the sells were exhausted, it won't add anything as "i" will be equal to sells.size. The same applies with
		//the buys
		remainder.addAll(sells.subList(sellIdx, sells.size()));
		remainder.addAll(buys.subList(buyIdx, buys.size()));
		return flips;
	}

	/**
	 * Creates flips based on the buy and sell list. It does this by going through the sell list and the buy list
	 * and only moving onto the next sell offer when the current sell offer is exhausted (seen more items bought than it
	 * has items sold). This ensures that a flip is only created on a completed sell offer
	 *
	 * @param buys  the buy offers
	 * @param sells the sell offers
	 * @return a list of Flips based on the buy and sell list.
	 */
	private static ArrayList<Flip> combineToFlips(List<OfferEvent> buys, List<OfferEvent> sells)
	{
		ArrayList<Flip> flips = new ArrayList<>();

		int buyIdx = 0;
		for (OfferEvent sell : sells)
		{
			if (sell.getCurrentQuantityInTrade() == 0) {
				continue;
			}
			int numBuysSeen = 0;
			int totalRevenue = 0;
			while (buyIdx < buys.size())
			{
				OfferEvent buy = buys.get(buyIdx);
				numBuysSeen += buy.getCurrentQuantityInTrade();

				if (numBuysSeen >= sell.getCurrentQuantityInTrade())
				{
					int leftOver = numBuysSeen - sell.getCurrentQuantityInTrade();
					int amountTaken = buy.getCurrentQuantityInTrade() - leftOver;
					totalRevenue += amountTaken * buy.getPrice();
					buy.setCurrentQuantityInTrade(leftOver);
					flips.add(new Flip(totalRevenue / sell.getCurrentQuantityInTrade(), sell.getPrice(), sell.getCurrentQuantityInTrade(), sell.getTime(), false, !sell.isComplete()));
					break;
				}
				else
				{
					totalRevenue += buy.getCurrentQuantityInTrade() * buy.getPrice();
					buyIdx++;
				}
			}

			//buys only partially exhausted a sell
			if (buyIdx == buys.size() && numBuysSeen != 0)
			{
				flips.add(new Flip(totalRevenue / numBuysSeen, sell.getPrice(), numBuysSeen, sell.getTime(), false, true));
				break;
			}
		}

		return flips;
	}
}
package com.flippingutilities.model;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;

@Data
@Slf4j
public class AccountWideData {
    List<Option> options = new ArrayList<>();
    List<Section> sections = new ArrayList<>();
    boolean shouldMakeNewAdditions = true;
    boolean enhancedSlots = true;
    String jwt;

    public boolean setDefaults() {
        boolean didChangeData = changeOldPropertyNames();

        if (options.isEmpty()) {
            setDefaultOptions();
            shouldMakeNewAdditions = false;
            didChangeData = true;
        }
        //adding wiki options to users' existing options only once and making sure that its not added again by setting shouldMakeNewAdditions.
        //i need to use that flag so i don't add it multiple times in case a user deletes those options.
        boolean alreadyHasWikiOptions = options.stream().anyMatch(o -> o.getProperty().equals(Option.WIKI_BUY) || o.getProperty().equals(Option.WIKI_SELL));
        if (shouldMakeNewAdditions && !alreadyHasWikiOptions) {
            options.add(0, new Option("n", Option.WIKI_SELL, "+0", false));
            options.add(0, new Option("j", Option.WIKI_BUY, "+0", false));
            shouldMakeNewAdditions = false;
            didChangeData = true;
        }

        if (sections.isEmpty()) {
            didChangeData = true;
            setDefaultFlippingItemPanelSections();
        }
        return didChangeData;
    }

    private boolean changeOldPropertyNames() {
        boolean changedOldNames = false;
        for (Option o : options) {
            if (o.getProperty().equals("marg sell")) {
                o.setProperty(Option.INSTA_BUY);
                changedOldNames = true;
            }
            if (o.getProperty().equals("marg buy")) {
                o.setProperty(Option.INSTA_SELL);
                changedOldNames = true;
            }
        }

        return changedOldNames;
    }

    private void setDefaultOptions() {
        options.add(new Option("n", Option.WIKI_SELL, "+0", false));
        options.add(new Option("j", Option.WIKI_BUY, "+0", false));
        options.add(new Option("p", Option.INSTA_BUY, "+0", false));
        options.add(new Option("l", Option.INSTA_SELL, "+0", false));
        options.add(new Option("o", Option.LAST_BUY, "+0", false));
        options.add(new Option("u", Option.LAST_SELL, "+0", false));

        options.add(new Option("p", Option.GE_LIMIT, "+0", true));
        options.add(new Option("l", Option.REMAINING_LIMIT, "+0", true));
        options.add(new Option("o", Option.CASHSTACK, "+0", true));
    }

    private void setDefaultFlippingItemPanelSections() {
        Section importantSection = new Section("Important");
        Section otherSection = new Section("Other");

        importantSection.defaultExpanded = true;
        importantSection.showLabel(Section.WIKI_BUY_PRICE, true);
        importantSection.showLabel(Section.WIKI_SELL_PRICE, true);
        importantSection.showLabel(Section.LAST_BUY_PRICE, true);
        importantSection.showLabel(Section.LAST_SELL_PRICE, true);
        importantSection.showLabel(Section.LAST_INSTA_SELL_PRICE, true);
        importantSection.showLabel(Section.LAST_INSTA_BUY_PRICE, true);

        otherSection.showLabel(Section.WIKI_PROFIT_EACH, true);
        otherSection.showLabel(Section.MARGIN_CHECK_PROFIT_EACH, true);
        otherSection.showLabel(Section.POTENTIAL_PROFIT, true);
        otherSection.showLabel(Section.REMAINING_GE_LIMIT, true);
        otherSection.showLabel(Section.ROI, true);
        otherSection.showLabel(Section.GE_LIMIT_REFRESH_TIMER, true);

        sections.add(importantSection);
        sections.add(otherSection);
    }

}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.model;


import com.flippingutilities.utilities.Constants;
import com.flippingutilities.utilities.GeTax;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GrandExchangeOfferChanged;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Optional;
import java.util.UUID;

/**
 * This class stores information from a {@link GrandExchangeOfferChanged} event and is populated with
 * extra information such as ticksSinceFirstOffer and quantitySinceLastOffer based on previous offers
 * belonging to the same trade as it.
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class OfferEvent
{
	@Getter
	private String uuid;
	@SerializedName("b")
	private boolean buy;
	@SerializedName("id")
	private int itemId;
	@SerializedName("cQIT")
	private int currentQuantityInTrade;
	@SerializedName("p")
	private int price;
	@SerializedName("t")
	private Instant time;
	@SerializedName("s")
	private int slot;
	@SerializedName("st")
	private GrandExchangeOfferState state;
	@SerializedName("tAA")
	private int tickArrivedAt;

	//this isn't TRULY ticksSinceFirstOffer as the ticks don't constantly increase. This is only relevant within a
	//short time frame (before the tick counter resets). As such, it should only be used to compare two events
	//very close to each other, such as the whether an offer is a margin check.
	@SerializedName("tSFO")
	private int ticksSinceFirstOffer;
	@SerializedName("tQIT")
	private int totalQuantityInTrade;
	private Instant tradeStartedAt;
	private boolean beforeLogin;
	/**
	 * a offer always belongs to a flipping item. Every flipping item was flipped by an account and only one account and
	 * has a flipped by attribute. So, the reason this attribute is here is because during the process of creating
	 * the account wide trade list, we merge flipping items flipped by several different accounts into one. Thus, in that
	 * case, a flipping item would have been flipped by multiple accounts so each offer needs to be marked to
	 * differentiate offer. This functionality is currently only used in getFlips as, when getting the flips for the
	 * account wide list, you don't want to match offers from different accounts!
	 */
	private transient String madeBy;

	//Used in theGeHistoryTabOfferPanel and RecipeFlipPanel
	private transient String itemName;
	//used in the live slot view to show what price something was listed at
	private transient int listedPrice;
	private transient int spent;

	/**
	 * @return post tax values
	 */
	public int getPrice() {
		if (buy || time.getEpochSecond() < Constants.GE_TAX_START || itemId == Constants.BOND_ID) {
			return price;
		}

		return GeTax.getPostTaxPrice(price);
	}

	public int getPreTaxPrice() {
		return price;
	}

	public int getTaxPaid() {
		return (getPreTaxPrice() - getPrice()) * currentQuantityInTrade;
	}

	public int getTaxPaidPerItem() {
		return getPreTaxPrice() - getPrice();
	}

	/**
	 * Returns a boolean representing that the offer is a complete offer. A complete offer signifies
	 * the end of that trade, thus the end of the slot's history. The HistoryManager uses this to decide when
	 * to clear the history for a slot.
	 *
	 * @return boolean value representing that the offer is a complete offer
	 */
	public boolean isComplete()
	{
		return isComplete(state);
	}

	public boolean isCancelled()
	{
		return state == GrandExchangeOfferState.CANCELLED_BUY || state == GrandExchangeOfferState.CANCELLED_SELL;
	}

	public static boolean isComplete(GrandExchangeOfferState state) {
		return
			state == GrandExchangeOfferState.BOUGHT ||
				state == GrandExchangeOfferState.SOLD ||
				state == GrandExchangeOfferState.CANCELLED_BUY ||
				state == GrandExchangeOfferState.CANCELLED_SELL;
	}

	public static boolean isBuy(GrandExchangeOfferState state) {
		return state == GrandExchangeOfferState.BOUGHT
			|| state == GrandExchangeOfferState.CANCELLED_BUY
			|| state == GrandExchangeOfferState.BUYING;
	}

	/**
	 * when an offer is complete, two events are generated: a buying/selling event and a bought/sold event.
	 * this method identifies the redundant buying/selling event before the bought/sold event.
	 */
	public boolean isRedundantEventBeforeOfferCompletion()
	{
		return (state == GrandExchangeOfferState.BUYING || state == GrandExchangeOfferState.SELLING) && currentQuantityInTrade == totalQuantityInTrade;
	}

	/**
	 * A margin check is defined as an offer that is either a BOUGHT or SOLD offer and has a currentQuantityInTrade of 1. This
	 * resembles the typical margin check process wherein you buy an item (currentQuantityInTrade of 1) for a high press, and then
	 * sell that item (currentQuantityInTrade of 1), to figure out the optimal buying and selling prices.
	 *
	 * @return boolean value representing whether the offer is a margin check or not
	 */
	public boolean isMarginCheck()
	{
		return (state == GrandExchangeOfferState.BOUGHT || state == GrandExchangeOfferState.SOLD) && totalQuantityInTrade == 1
			&& ticksSinceFirstOffer <= 2;
	}

	/**
	 * We get an event for every empty slot on login and when a slot is cleared
	 *
	 * @return whether this OfferEvent was caused by an empty slot
	 */
	public boolean isCausedByEmptySlot()
	{
		return (itemId == 0 || state == GrandExchangeOfferState.EMPTY);
	}

	/**
	 * When we first place an offer for a slot we get an offer event that has a quantity traded of 0. This offer marks
	 * the tick the offer was placed. The reason we need to also check if it wasn't a complete offer is because you can
	 * cancel a buy or a sell, and provided you didn't buy or sell anything, the quantity in the offer can be 0, but its
	 * not the start of the offer.
	 *
	 * @return boolean value representing whether the offer is a start of a trade.
	 */
	public boolean isStartOfOffer()
	{
		return currentQuantityInTrade == 0 && !isComplete() && !isCausedByEmptySlot();
	}

	public OfferEvent clone()
	{
		return new OfferEvent(
				uuid,
				buy,
				itemId,
				currentQuantityInTrade,
				price,
				time,
				slot,
				state,
				tickArrivedAt,
				ticksSinceFirstOffer,
				totalQuantityInTrade,
				tradeStartedAt,
				beforeLogin,
				madeBy,
				itemName,
				listedPrice,
				spent
		);
	}

	public boolean equals(Object other)
	{
		if (other == this)
		{
			return true;
		}

		if (!(other instanceof OfferEvent))
		{
			return false;
		}

		OfferEvent otherOffer = (OfferEvent) other;

		return
			isDuplicate(otherOffer)
			&& uuid.equals(otherOffer.uuid)
			&& tickArrivedAt == otherOffer.tickArrivedAt
			&& ticksSinceFirstOffer == otherOffer.ticksSinceFirstOffer
			&& time.equals(otherOffer.time);
	}

	/**
	 * This checks whether the given OfferEvent is a "duplicate" of this OfferEvent. Some fields such as
	 * tickArrivedAt are omitted because even if they are different, the given offer is still redundant due to all
	 * the other information being the same and should be screened out by screenOfferEvent in FlippingPlugin, where
	 * this method is used.
	 *
	 * @param other the OfferEvent being compared.
	 * @return whether or not the given offer event is redundant
	 */
	public boolean isDuplicate(OfferEvent other)
	{
		return state == other.getState()
			&& currentQuantityInTrade == other.getCurrentQuantityInTrade()
			&& slot == other.getSlot()
			&& totalQuantityInTrade == other.getTotalQuantityInTrade() && itemId == other.getItemId()
			&& getPrice() == other.getPrice();
	}

	public static OfferEvent fromGrandExchangeEvent(GrandExchangeOfferChanged event)
	{
		GrandExchangeOffer offer = event.getOffer();

		boolean isBuy = offer.getState() == GrandExchangeOfferState.BOUGHT
			|| offer.getState() == GrandExchangeOfferState.CANCELLED_BUY
			|| offer.getState() == GrandExchangeOfferState.BUYING;

		return new OfferEvent(
			UUID.randomUUID().toString(),
			isBuy,
			offer.getItemId(),
			offer.getQuantitySold(),
			offer.getQuantitySold() == 0 ? 0 : offer.getSpent() / offer.getQuantitySold(),
			Instant.now().truncatedTo(ChronoUnit.SECONDS),
			event.getSlot(),
			offer.getState(),
			0,
			0,
			offer.getTotalQuantity(),
			null,
			false,
			null,
			null,
			offer.getPrice(),
			offer.getSpent());
	}

	/**
	 * Sets the ticks since the first offer event of the trade that this offer event belongs to. The ticks since first
	 * offer event is used to determine whether an offer event is a margin check or not.
	 *
	 * @param lastOfferForSlot the last offer event for the slot this offer event belongs to
	 */
	public void setTicksSinceFirstOffer(OfferEvent lastOfferForSlot)
	{
		int tickDiffFromLastOffer = Math.abs(tickArrivedAt - lastOfferForSlot.getTickArrivedAt());
		ticksSinceFirstOffer = tickDiffFromLastOffer + lastOfferForSlot.getTicksSinceFirstOffer();
	}

	public String prettyRepr() {
		return String.format("slot=%d, buy=%b, itemId=%d, state=%s, tq=%d",slot, buy, itemId, state, totalQuantityInTrade);
	}

	public static OfferEvent dummyOffer(boolean buyState, boolean marginCheck, int price, int id, String itemName) {
		return new OfferEvent(
				UUID.randomUUID().toString(),
				buyState,
				id,
				0,
				price,
				Instant.now(),
				-1,
				buyState ? GrandExchangeOfferState.BOUGHT : GrandExchangeOfferState.SOLD,
				1,
				marginCheck? 1 : 10,
				1,
				null,
				false,
				"",
				itemName,
				0,
				0);
	}
}


package com.flippingutilities.model;

import com.flippingutilities.utilities.Recipe;
import com.flippingutilities.utilities.Searchable;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Contains all the recipe flips for a recipe
 */
@Data
@AllArgsConstructor
public class RecipeFlipGroup implements Searchable {
    private Recipe recipe;
    private List<RecipeFlip> recipeFlips = new ArrayList<>();

    public RecipeFlipGroup(Recipe recipe) {
        this.recipe = recipe;
    }

    public RecipeFlipGroup clone() {
        return new RecipeFlipGroup(recipe, recipeFlips.stream().map(RecipeFlip::clone).collect(Collectors.toList()));
    }

    public RecipeFlipGroup merge(RecipeFlipGroup otherRecipeFlipGroup) {
        List<RecipeFlip> allRecipeFlips = recipeFlips;
        allRecipeFlips.addAll(otherRecipeFlipGroup.getRecipeFlips());
        allRecipeFlips.sort(Comparator.comparing(RecipeFlip::getTimeOfCreation));
        return new RecipeFlipGroup(recipe, allRecipeFlips);
    }

    public Instant getLatestActivityTime() {
        if (recipeFlips.isEmpty()) {
            return Instant.EPOCH;
        }
        return recipeFlips.get(recipeFlips.size()-1).timeOfCreation;
    }

    public boolean isInGroup(int itemId) {
        return recipe.isInRecipe(itemId);
    }

    /**
     * Gets a map of offer id to partial offer. Since an offer can be referenced by multiple partial offers (each
     * consuming part of the offer), we need to sum up the amount consumed by each of the partial offers referencing
     * that one offer to get the final partial offer corresponding to that offer id.
     */
    public Map<String, PartialOffer> getOfferIdToPartialOffer(int itemId) {
        Map<String, PartialOffer>  offerIdToPartialOffer = new HashMap<>();
        for (RecipeFlip recipeFlip : recipeFlips) {
            List<PartialOffer> partialOffers = recipeFlip.getPartialOffers(itemId);
            partialOffers.forEach(po -> {
                String offerId = po.offer.getUuid();
                if (offerIdToPartialOffer.containsKey(offerId)) {
                    PartialOffer otherPartialOffer = offerIdToPartialOffer.get(offerId);
                    PartialOffer clonedPartialOffer = po.clone();
                    clonedPartialOffer.amountConsumed += otherPartialOffer.amountConsumed;
                    offerIdToPartialOffer.put(offerId, clonedPartialOffer);
                }
                else {
                    offerIdToPartialOffer.put(offerId, po);
                }
            });
        }
        return offerIdToPartialOffer;
    }

    public List<PartialOffer> getPartialOffers() {
        return recipeFlips.stream().flatMap(rf -> rf.getPartialOffers().stream()).collect(Collectors.toList());
    }

    public void addRecipeFlip(RecipeFlip recipeFlip) {
        recipeFlips.add(recipeFlip);
    }

    public Instant getLatestFlipTime() {
        if (recipeFlips.isEmpty()) {
            return Instant.EPOCH;
        }
        return recipeFlips.get(recipeFlips.size()-1).timeOfCreation;
    }

    public List<RecipeFlip> getFlipsInInterval(Instant startOfInterval) {
        return recipeFlips.stream()
            .filter(recipeFlip -> recipeFlip.getTimeOfCreation().isAfter(startOfInterval))
            .collect(Collectors.toList());
    }

    public void deleteFlips(Instant startOfInterval) {
        recipeFlips.removeIf(rf -> rf.getTimeOfCreation().isAfter(startOfInterval));
    }

    public void deleteFlip(RecipeFlip recipeFlip) {
        recipeFlips.removeIf(rf -> rf.equals(recipeFlip));
    }

    public void deleteFlipsWithDeletedOffers(List<OfferEvent> offers) {
        Set<String> offerIds = offers.stream().map(OfferEvent::getUuid).collect(Collectors.toSet());
        recipeFlips.removeIf(rf -> rf.getPartialOffers().stream().anyMatch(po -> offerIds.contains(po.offer.getUuid())));
    }

    @Override
    public boolean isInInterval(Instant intervalStart) {
        return recipeFlips.stream().anyMatch(recipeFlip -> recipeFlip.getTimeOfCreation().isAfter(intervalStart));
    }

    @Override
    public String getNameForSearch() {
        return recipe.getName();
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.model;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.time.Instant;

/**
 * This class represents a flip to be made in the history panel.
 */
@Data
@AllArgsConstructor
public class Flip
{
	int buyPrice;
	int sellPrice;
	int quantity;
	Instant time;
	boolean marginCheck;
	boolean ongoing;
}

package com.flippingutilities.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
//need a no args constructor if you want field defaults to be respected when json is turned into object and its missing the field (when the field is
//newly added for example).
@NoArgsConstructor
public class Option {
    public static final String GE_LIMIT = "ge limit";
    public static final String REMAINING_LIMIT = "rem limit";
    public static final String CASHSTACK = "cashstack";
    public static final String LAST_BUY = "last buy";
    public static final String LAST_SELL = "last sell";
    public static final String INSTA_SELL = "insta sell";
    public static final String INSTA_BUY = "insta buy";
    public static final String WIKI_BUY = "wiki buy";
    public static final String WIKI_SELL = "wiki sell";
    public static final String[] QUANTITY_OPTIONS = new String[]{Option.REMAINING_LIMIT, Option.GE_LIMIT, Option.CASHSTACK};
    public static final String[] PRICE_OPTIONS = new String[]{Option.WIKI_BUY, Option.WIKI_SELL, Option.INSTA_SELL, Option.INSTA_BUY, Option.LAST_BUY, Option.LAST_SELL};
    String key;
    String property;
    String modifier;
    boolean isQuantityOption = true;

    public static Option defaultQuantityOption() {
        return new Option("", Option.GE_LIMIT, "+0", true);
    }

    public static Option defaultPriceOption() {
        return new Option("", Option.INSTA_BUY,"+0", false);
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.model;

import com.flippingutilities.utilities.Constants;
import com.flippingutilities.utilities.GeTax;
import com.flippingutilities.utilities.Searchable;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.*;

/**
 * This class is the representation of an item that a user is flipping. It contains information about the
 * margin of the item (buying and selling price), the latest buy and sell times, and the history of the item
 * which is all of the offers that make up the trade history of that item. This history is managed by the
 * {@link HistoryManager} and is used to get the profits for this item, how many more of it you can buy
 * until the ge limit refreshes, and when the next ge limit refreshes.
 * <p>
 * This class is the model behind a FlippingItemPanel as its data is used to create the contents
 * of a panel which is then displayed.
 */
@AllArgsConstructor
@NoArgsConstructor
@Slf4j
public class FlippingItem implements Searchable
{

	@SerializedName("id")
	@Getter
	private int itemId;

	@SerializedName("name")
	@Getter
	@Setter
	private String itemName;

	@SerializedName("tGL")
	@Getter
	@Setter
	private int totalGELimit;

	@SerializedName("h")
	@Getter
	@Setter
	private HistoryManager history = new HistoryManager();

	@SerializedName("fB")
	@Getter
	@Setter
	private String flippedBy;

	//whether the item should be on the flipping panel or not.
	@SerializedName("vFPI")
	@Getter
	@Setter
	private Boolean validFlippingPanelItem;

	@Getter
	@Setter
	private boolean favorite;

	@Getter
	@Setter
	private String favoriteCode = "1";

	//non persisted fields start here.
	@Setter
	@Getter
	private transient Optional<OfferEvent> latestInstaBuy;

	@Setter
	@Getter
	private transient Optional<OfferEvent> latestInstaSell;

	@Setter
	@Getter
	private transient Optional<OfferEvent> latestBuy;

	@Setter
	@Getter
	private transient Optional<OfferEvent> latestSell;

	//does not have to Optional because a flipping item always has at least one offer, which establishes
	//latestActivityTime.
	@Getter
	private transient Instant latestActivityTime;

	@Getter
	@Setter
	private transient Boolean expand;

	public FlippingItem(int itemId, String itemName, int totalGeLimit, String flippedBy)
	{
		this.latestInstaBuy = Optional.empty();
		this.latestInstaSell = Optional.empty();
		this.latestBuy = Optional.empty();
		this.latestSell = Optional.empty();
		this.itemName = itemName;
		this.itemId = itemId;
		this.totalGELimit = totalGeLimit;
		this.flippedBy = flippedBy;
		this.latestActivityTime = Constants.DUMMY_ITEM.equals(flippedBy)? Instant.EPOCH : Instant.now();
	}

	public FlippingItem clone()
	{
		return new FlippingItem(
				itemId,
				itemName,
				totalGELimit,
				history.clone(),
				flippedBy,
				validFlippingPanelItem,
				favorite,
				favoriteCode,
				latestInstaBuy,
				latestInstaSell,
				latestBuy,
				latestSell,
				latestActivityTime,
				expand);
	}

	/**
	 * This method updates the history of a FlippingItem. This history is used to calculate profits,
	 * next ge limit refresh, and how many items were bought during this limit window.
	 *
	 * @param newOffer the new offer that just came in
	 */
	public void updateHistory(OfferEvent newOffer)
	{
		newOffer.setItemName(itemName);
		history.updateHistory(newOffer);
	}

	/**
	 * Updates the latest margin check/buy/sell offers. Technically, we don't need this and we can just
	 * query the history manager, but this saves us from querying the history manager which would have
	 * to search through the offers.
	 *
	 * @param newOffer new offer just received
	 */
	public void updateLatestProperties(OfferEvent newOffer)
	{
		if (newOffer.isBuy())
		{
			if (newOffer.isMarginCheck())
			{
				latestInstaBuy = Optional.of(newOffer);
			}
			latestBuy = Optional.of(newOffer);
		}
		else
		{
			if (newOffer.isMarginCheck())
			{
				latestInstaSell = Optional.of(newOffer);
			}
			latestSell = Optional.of(newOffer);
		}
		latestActivityTime = newOffer.getTime();
	}

	/**
	 * combines two flipping items together (this only makes sense if they are for the same item) by adding
	 * their histories together and retaining the other properties of the latest active item. This is used to
	 * construct the account wide view as flipping items (referencing the same item) from different accounts need
	 * to be merged into one.
	 *
	 * @return merged flipping item
	 */
	public static FlippingItem merge(FlippingItem item1, FlippingItem item2)
	{
		if (item1 == null)
		{
			return item2;
		}

		if (item1.getLatestActivityTime().compareTo(item2.getLatestActivityTime()) >= 0)
		{
			item1.getHistory().getCompressedOfferEvents().addAll(item2.getHistory().getCompressedOfferEvents());
			item1.getHistory().getCompressedOfferEvents().sort(Comparator.comparing(OfferEvent::getTime));
			item1.setFavorite(item1.isFavorite() || item2.isFavorite());
			return item1;
		}
		else
		{
			item2.getHistory().getCompressedOfferEvents().addAll(item1.getHistory().getCompressedOfferEvents());
			item2.getHistory().getCompressedOfferEvents().sort(Comparator.comparing(OfferEvent::getTime));
			item2.setFavorite(item2.isFavorite() || item1.isFavorite());
			return item2;
		}
	}

	public static long getProfit(List<OfferEvent> tradeList)
	{
		return HistoryManager.getProfit(tradeList);
	}

	public static long getValueOfMatchedOffers(List<OfferEvent> tradeList, boolean isBuy)
	{
		return HistoryManager.getValueOfMatchedOffers(tradeList, isBuy);
	}

	public static long getTotalRevenueOrExpense(List<OfferEvent> tradeList, boolean isBuy)
	{
		return HistoryManager.getTotalRevenueOrExpense(tradeList, isBuy);
	}

	public static int countFlipQuantity(List<OfferEvent> tradeList)
	{
		return HistoryManager.countFlipQuantity(tradeList);
	}

	public static List<Flip> getFlips(List<OfferEvent> tradeList)
	{
		return HistoryManager.getFlips(tradeList);
	}

	public static List<OfferEvent> getPartialOfferAdjustedView(List<OfferEvent> offers, Map<String,PartialOffer> partialOffers) {
		return HistoryManager.getPartialOfferAdjustedView(offers, partialOffers);
	}

	public ArrayList<OfferEvent> getIntervalHistory(Instant earliestTime)
	{
		return history.getIntervalsHistory(earliestTime);
	}

	public int getRemainingGeLimit()
	{
		return totalGELimit - history.getItemsBoughtThisLimitWindow();
	}

	public int getItemsBoughtThisLimitWindow()
	{
		return history.getItemsBoughtThisLimitWindow();
	}

	public Instant getGeLimitResetTime()
	{
		return history.getNextGeLimitRefresh();
	}

	public void validateGeProperties()
	{
		history.validateGeProperties();
	}

	public boolean hasValidOffers()
	{
		return history.hasValidOffers();
	}

	@Override
	public boolean isInInterval(Instant earliestTime) {
		return history.hasOfferInInterval(earliestTime);
	}

	/**
	 * see the documentation for HistoryManager.deleteOffers
	 */
	public void deleteOffers(List<OfferEvent> offerList)
	{
		history.deleteOffers(offerList);
	}
	public void setValidFlippingPanelItem(boolean isValid)
	{
		validFlippingPanelItem = isValid;
		if (!isValid)
		{
			latestInstaBuy = Optional.empty();
			latestInstaSell = Optional.empty();
			latestBuy = Optional.empty();
			latestSell = Optional.empty();
		}
	}

	public Optional<Integer> getPotentialProfit(boolean includeMarginCheck, boolean shouldUseRemainingGeLimit)
	{
		if (!getLatestInstaBuy().isPresent() || !getLatestInstaSell().isPresent()) {
			return Optional.empty();
		}

		int profitEach = getCurrentProfitEach().get();
		int remainingGeLimit = getRemainingGeLimit();
		int geLimit = shouldUseRemainingGeLimit ? remainingGeLimit : totalGELimit;
		int profitTotal = geLimit * profitEach;
		if (includeMarginCheck)
		{
			profitTotal -= profitEach;
		}
		return Optional.of(profitTotal);
	}

	public List<OfferEvent> getOfferMatches(OfferEvent offerEvent, int limit)
	{
		return history.getOfferMatches(offerEvent, limit);
	}

	public Optional<Float> getCurrentRoi() {
		return getCurrentProfitEach().isPresent()?
				Optional.of((float)getCurrentProfitEach().get() / getLatestInstaSell().get().getPrice() * 100) : Optional.empty();
	}

	public Optional<Integer> getCurrentProfitEach() {
		return getLatestInstaBuy().isPresent() && getLatestInstaSell().isPresent()?
				Optional.of(GeTax.getPostTaxPrice(getLatestInstaBuy().get().getPrice()) - getLatestInstaSell().get().getPreTaxPrice()) : Optional.empty();
	}

	/**
	 * When the plugin starts up, the flipping items are constructed, but they are going to be missing
	 * values for certain fields that aren't persisted. I chose not to persist those fields as those fields
	 * can be constructed using the history that is already persisted. The downside is that I have to
	 * manually sync state when flipping items are created at plugin startup.
	 */
	private void syncState() {
		latestBuy = history.getLatestOfferThatMatchesPredicate(offer -> offer.isBuy());
		latestSell = history.getLatestOfferThatMatchesPredicate(offer -> !offer.isBuy());
		latestInstaBuy = history.getLatestOfferThatMatchesPredicate(offer -> offer.isBuy() & offer.isMarginCheck());
		latestInstaSell = history.getLatestOfferThatMatchesPredicate(offer -> !offer.isBuy() & offer.isMarginCheck());
		latestActivityTime = history.getCompressedOfferEvents().size() == 0? Instant.EPOCH : history.getCompressedOfferEvents().get(history.getCompressedOfferEvents().size()-1).getTime();
	}

	private void setOfferMadeBy() {
		if (flippedBy == null) {
			log.info("flipped by is null");
		}
		history.setOfferMadeBy(flippedBy);
	}

	private void setOfferIds() {
		history.setOfferIds();
	}

	private void setOfferNames() {
		history.setOfferNames(itemName);
	}

	/**
	 * There are several fields we don't persist in offer events, so we need to fill them in
	 * at plugin start. Additionally, due to schema evolution such as fields being added, we have to
	 * fill those new fields with default values. I think gson should do this when deserializing already, but
	 * I ran into some issues with it some time ago and am too lazy to re-explore...
	 */
	public void hydrate(int geLimit) {
		setTotalGELimit(geLimit);
		syncState();
		setOfferIds();
		setOfferNames();
		setOfferMadeBy();
		//when this change was made the field will not exist and will be null
		if (validFlippingPanelItem == null)
		{
			validFlippingPanelItem = true;
		}
	}

	@Override
	public String getNameForSearch() {
		return itemName;
	}
}

package com.flippingutilities.model;

import com.flippingutilities.utilities.Recipe;
import com.flippingutilities.utilities.RecipeItem;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.time.Instant;
import java.util.*;
import java.util.stream.Collectors;

/**
 * This is the structure that represents a flip made out of various different items, either because
 * those items were combined to make some other one, or were the result of breaking some other item.
 * Ex: guthan set bought then broken up into pieces and sold.
 * The "parent" in these recipeFlips is not necessarily the output item (of combining or breaking stuff), it is
 * the item that I have arbitrarily chosen to own the profits of the recipe flips. This is because profits cannot
 * be divided over all the items in the recipe flip. What decides how much profit each item gets? For that reason
 * I've decided that each recipe has a parent item (the parent item that will end up in the recipeFlip) and that
 * parent item shall own the profits, revenue, expense, etc for the recipe flip.
 */
@Data
@AllArgsConstructor
public class RecipeFlip {
    Instant timeOfCreation;
    Map<Integer, Map<String, PartialOffer>> outputs;
    //item id to a map of offer id to offer
    Map<Integer, Map<String, PartialOffer>> inputs;
    long coinCost;

    public RecipeFlip(Recipe recipe, Map<Integer, Map<String, PartialOffer>> allPartialOffers, long coinsCost) {
        Set<Integer> recipeInputIds = recipe.getInputIds();
        Set<Integer> recipeOutputIds = recipe.getOutputIds();
        this.coinCost = coinsCost;
        this.timeOfCreation = Instant.now();
        this.inputs = allPartialOffers.entrySet().stream().filter(e -> recipeInputIds.contains(e.getKey()))
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        this.outputs = allPartialOffers.entrySet().stream().filter(e -> recipeOutputIds.contains(e.getKey()))
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public RecipeFlip clone() {
        Instant clonedInstant = Instant.ofEpochSecond(timeOfCreation.getEpochSecond());
        Map<Integer, Map<String, PartialOffer>> clonedOutputs = cloneComponents(outputs);
        Map<Integer, Map<String, PartialOffer>> clonedInputs = cloneComponents(inputs);
        return new RecipeFlip(clonedInstant, clonedOutputs, clonedInputs, coinCost);
    }

    private Map<Integer, Map<String, PartialOffer>> cloneComponents(Map<Integer, Map<String, PartialOffer>> component) {
        return component.entrySet().stream()
            .map(e -> new AbstractMap.SimpleEntry<>(
                e.getKey(),
                e.getValue().entrySet().stream()
                    .map(entry -> new AbstractMap.SimpleEntry<>(entry.getKey(), entry.getValue().clone()))
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))))
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public long getProfit() {
        return getRevenue() - getExpense();
    }

    private long getIngredientsValue(boolean isBuyOffer) {
        return getPartialOffers().stream()
            .filter(po -> po.offer.isBuy() == isBuyOffer)
            .mapToLong(po -> po.amountConsumed * po.getOffer().getPrice())
            .sum();
    }

    public long getExpense() {
        return getIngredientsValue(true) + coinCost;
    }

    public long getRevenue() {
        return getIngredientsValue(false);
    }

    public long getTaxPaid() {
        return getOutputs().values().stream()
            .mapToLong(
                offerIdToPartialOfferMap -> offerIdToPartialOfferMap.values().stream().mapToInt(po -> po.getOffer().getTaxPaidPerItem() * po.amountConsumed).sum())
            .sum();
    }

    /**
     * This is a utility function used to calculate profit for a given set of partial offers. This doesn't calculate
     * the profit for an instance of a RecipeFlip. Just writing this here as it confused me why we had this and getProfit()
     * @param allPartialOffers
     * @return
     */
    public static long calculateProfit(Map<Integer, Map<String, PartialOffer>> allPartialOffers) {
        List<PartialOffer> offers = allPartialOffers.values().stream()
            .flatMap(offerIdToPartialOfferMap -> offerIdToPartialOfferMap.values().stream())
            .collect(Collectors.toList());

        long revenue = offers.stream()
            .filter(po -> !po.getOffer().isBuy())
            .mapToLong(po -> po.amountConsumed * po.getOffer().getPrice())
            .sum();
        long expense = offers.stream()
            .filter(po -> po.getOffer().isBuy())
            .mapToLong(po -> po.amountConsumed * po.getOffer().getPrice())
            .sum();
        return revenue - expense;
    }

    /**
     * Gets all the partial offers contained in this recipe flip.
     */
    public List<PartialOffer> getPartialOffers() {
        List<PartialOffer> offers = new ArrayList<>();
        inputs.values().forEach(map -> offers.addAll(map.values()));
        outputs.values().forEach(map -> offers.addAll(map.values()));
        return offers;
    }

    public List<PartialOffer> getPartialOffers(int itemId) {
        List<PartialOffer> partialOffers = new ArrayList<>();
        if (outputs.containsKey(itemId)) {
            partialOffers.addAll(outputs.get(itemId).values());
        }
        if (inputs.containsKey(itemId)) {
            partialOffers.addAll(inputs.get(itemId).values());
        }
        return partialOffers;
    }

    public int getRecipeCountMade(Recipe recipe) {
        RecipeItem randomItemInRecipe = recipe.getOutputs().get(0);
        int quantityOfRandomItemInRecipe = randomItemInRecipe.getQuantity();
        int randomItemIdInRecipe = randomItemInRecipe.getId();
        int amountConsumed = getPartialOffers(randomItemIdInRecipe).stream().mapToInt(po -> po.amountConsumed).sum();
        return amountConsumed/quantityOfRandomItemInRecipe;
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.model;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.ui.widgets.SlotActivityTimer;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.http.api.item.ItemStats;

import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Data
public class AccountData {
    private Map<Integer, OfferEvent> lastOffers = new HashMap<>();
    private List<FlippingItem> trades = new ArrayList<>();
    private Instant sessionStartTime = Instant.now();
    private long accumulatedSessionTimeMillis = 0;
    private Instant lastSessionTimeUpdate;
    private List<SlotActivityTimer> slotTimers;
    private List<RecipeFlipGroup> recipeFlipGroups = new ArrayList<>();
    private Instant lastStoredAt = Instant.EPOCH;
    private Instant lastModifiedAt = Instant.now();

    /**
     * Resets all session related data associated with an account. This is called when the plugin first starts
     * as that's when a new session is "started" and when a user wants to start a new session for an account.
     */
    public void startNewSession() {
        sessionStartTime = Instant.now();
        accumulatedSessionTimeMillis = 0;
        lastSessionTimeUpdate = null;
    }

    /**
     * Over time as we delete/add fields, we need to make sure the fields are set properly the first time the user
     * loads their trades after the new update. This method serves as a way to sanitize the data. It also ensures
     * that the FlippingItems have their non persisted fields set from history.
     */
    public void prepareForUse(FlippingPlugin plugin) {
        fixIncorrectItemNames(plugin.getItemManager());

        Map<String, OfferEvent> hydratedOffers = new HashMap<>();

        for (FlippingItem item : trades) {
            //in case ge limits have been updated
            int tradeItemId = item.getItemId();
            ItemStats itemStats = plugin.getItemManager().getItemStats(tradeItemId, false);
            int geLimit = itemStats != null ? itemStats.getGeLimit() : 0;

            item.hydrate(geLimit);
            item.getHistory().getCompressedOfferEvents().forEach(o -> hydratedOffers.put(o.getUuid(), o));
        }

        hydratePartialOffers(hydratedOffers);
        hydrateSlotTimers(plugin);
    }

    private void hydrateSlotTimers(FlippingPlugin plugin) {
        if (slotTimers == null) {
            slotTimers = setupSlotTimers(plugin);
        } else {
            slotTimers.forEach(timer -> {
                timer.setClient(plugin.getClient());
                timer.setPlugin(plugin);
            });
        }
    }

    private void hydratePartialOffers(Map<String, OfferEvent> hydratedOffers) {
        List<PartialOffer> partialOffers = recipeFlipGroups.stream().flatMap(rfg -> rfg.getPartialOffers().stream()).collect(Collectors.toList());
        partialOffers.forEach(po -> {
            OfferEvent o = hydratedOffers.get(po.offer.getUuid());
            if (o == null) {
                log.warn("partial offer references deleted offer event, this should not happen!");
                return;
            }
            po.hydrateUnderlyingOfferEvent(o.getMadeBy(), o.getItemName());
        });
    }

    /**
     * When a user is an f2p world and recieves events for members items (cause they were already in the GE),
     * the item manager retrieves the item's name as "Members object". The item manager returns the correct
     * name when the user is on a member's world or logged out. As such, this method is called when the plugin starts
     * and whenever the user logs into a members world to clean up any "Members object" item names.
     */
    public void fixIncorrectItemNames(ItemManager itemManager) {
        trades.forEach(item -> {
            if (item.getItemName().equals("Members object")) {
                String actualName = itemManager.getItemComposition(item.getItemId()).getName();
                item.setItemName(actualName);
            }
        });
    }

    private List<SlotActivityTimer> setupSlotTimers(FlippingPlugin plugin) {
        ArrayList<SlotActivityTimer> slotTimers = new ArrayList<>();
        for (int slotIndex = 0; slotIndex < 8; slotIndex++) {
            slotTimers.add(new SlotActivityTimer(plugin, plugin.getClient(), slotIndex));
        }
        return slotTimers;
    }
}

package com.flippingutilities.model;

import lombok.AllArgsConstructor;
import lombok.Data;

/**
 * Used as the data structure that references OfferEvents in RecipeFlips. Its only purpose is to
 * show how much of an offer event was consumed bc when creating recipe flips you can
 * specify that you only want some of the offer to be used.
 */
@Data
@AllArgsConstructor
public class PartialOffer {
    public OfferEvent offer;
    public int amountConsumed;

    public PartialOffer clone() {
        return new PartialOffer(
                offer.clone(),
                amountConsumed
        );
    }

    /**
     * Returns an OfferEvent that represents the offer left after taking into account the amount the PartialOffer
     * consumed.
     */
    public OfferEvent toRemainingOfferEvent() {
        int remainingAmount = offer.getCurrentQuantityInTrade() - amountConsumed;
        OfferEvent adjustedOfferEvent = offer.clone();
        adjustedOfferEvent.setCurrentQuantityInTrade(remainingAmount);
        return adjustedOfferEvent;
    }

    public void hydrateUnderlyingOfferEvent(String madeBy, String itemName) {
        offer.setMadeBy(madeBy);
        offer.setItemName(itemName);
    }
}



package com.flippingutilities.model;

import lombok.Data;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Data
public class BackupCheckpoints {
    Map<String, Instant> accountToBackupTime = new HashMap<>();

    public boolean shouldBackup(String displayName, Instant lastUpdatedAt) {
        if (!accountToBackupTime.containsKey(displayName)) {
            return true;
        }
        Instant backupLastUpdatedTime = accountToBackupTime.get(displayName);
        return !lastUpdatedAt.equals(backupLastUpdatedTime);
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.ui.uiutilities.CustomColors;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Units;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

@ConfigGroup(FlippingPlugin.CONFIG_GROUP)
public interface FlippingConfig extends Config
{
	@ConfigItem(
		keyName = "roiGradientMax",
		name = "Set ROI gradient range limit",
		description = "Set the limit of the range before the gradient is bright green"
	)
	@Units(Units.PERCENT)
	default int roiGradientMax()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "marginCheckLoss",
		name = "Account for margin check loss",
		description = "Subtract the loss from margin checking the item when calculating the total profit"
	)
	default boolean marginCheckLoss()
	{
		return true;
	}

	@ConfigItem(
		keyName = "twelveHourFormat",
		name = "12 hour format",
		description = "Shows times in a 12 hour format (AM/PM)"
	)
	default boolean twelveHourFormat()
	{
		return true;
	}

	@ConfigItem(
		keyName = "remainingGELimitProfit",
		name = "Calculate potential profit from remaining GE limit",
		description = "If unchecked, the potential profit will be calculated from total GE limit"
	)
	default boolean geLimitProfit()
	{
		return false;
	}

	@ConfigItem(
		keyName = "tradeStagnationTime",
		name = "Set trade stagnation time",
		description = "Set how long before the offer slot activity timer indicates that a trade has become stagnant"
	)
	@Units(Units.MINUTES)
	default int tradeStagnationTime()
	{
		return 15;
	}

	@ConfigItem(
		keyName = "slotTimersEnabled",
		name = "toggle slot timers",
		description = "Have a timer on active GE slots that will show the last time an offer came for the slot. This is useful" +
			"for knowing whether you should change your offer's price"
	)
	default boolean slotTimersEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "verboseView",
		name = "toggle verbose view",
		description = "show items in the flipping tab with all their tracked info like buy/sell price, roi, potential" +
			"profit, etc"
	)
	default boolean verboseViewEnabled() { return true; }

	@ConfigItem(
			keyName = "slotTimerBuyTextColor",
			name = "slot timer buy text color",
			description = "the color of the buy text on the slot timers"
	)
	default Color slotTimerBuyColor() {
		return ColorScheme.GRAND_EXCHANGE_LIMIT;
	}

	@ConfigItem(
			keyName = "slotTimerSellTextColor",
			name = "slot timer sell text color",
			description = "the color of the sell text on the slot timers"
	)
	default Color slotTimerSellColor() {
		return ColorScheme.GRAND_EXCHANGE_ALCH;
	}
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.ui.flipping.FlippingPanel;
import com.flippingutilities.ui.login.LoginPanel;
import com.flippingutilities.ui.slots.SlotsPanel;
import com.flippingutilities.ui.statistics.StatsPanel;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.FastTabGroup;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.HashSet;
import java.util.Set;

@Slf4j
public class MasterPanel extends PluginPanel
{
	@Getter
	private JComboBox<String> accountSelector;
	private FlippingPlugin plugin;
	private FastTabGroup tabGroup;
	private JDialog loginModal;

	/**
	 * THe master panel is always present. The components added to it are components that should always be visible
	 * regardless of whether you are looking at the flipping panel or the statistics panel. The tab group to switch
	 * between the flipping and stats panel, the account selector dropdown menu, and the settings button are all examples
	 * of components that are always present, hence they are on the master panel.
	 *
	 * @param flippingPanel FlippingPanel represents the main tool of the plugin.
	 * @param statPanel     StatPanel represents useful performance statistics to the user.
	 */
	public MasterPanel(FlippingPlugin plugin,
					   FlippingPanel flippingPanel,
					   StatsPanel statPanel,
					   SlotsPanel slotsPanel,
					   LoginPanel loginPanel)
	{
		super(false);

		this.plugin = plugin;

		setLayout(new BorderLayout());

		JPanel mainDisplay = new JPanel();

		loginModal = UIUtilities.createModalFromPanel(this, loginPanel);
		loginPanel.addOnViewChange(() -> {
			if (loginModal.isVisible()) {
				loginModal.pack();
				loginModal.setLocation(this.getLocationOnScreen().x - loginModal.getWidth() - 10 , Math.max(this.getLocationOnScreen().y,0) - loginModal.getHeight()/2 + 100);
			}
		});
		loginModal.pack();

		accountSelector = accountSelector();
		tabGroup = tabSelector(mainDisplay, flippingPanel, statPanel, slotsPanel);

		JPanel header = createHeader(accountSelector, tabGroup, loginModal);
		header.setBorder(BorderFactory.createCompoundBorder(
				BorderFactory.createMatteBorder(0,0,4,0, ColorScheme.DARKER_GRAY_COLOR.darker()),
				BorderFactory.createEmptyBorder(0,0,5,0)));

		add(header, BorderLayout.NORTH);
		add(mainDisplay, BorderLayout.CENTER);
	}

	/**
	 * The header is at the top of the panel. It is the component that contains the account selector dropdown, the
	 * settings button to the right of the dropdown, and the tab selector which allows a user to select either the
	 * flipping or stats tab.
	 *
	 * @param accountSelector the account selector dropdown
	 * @param tabSelector     a tab group with allows a user to select either the flipping or stats tab to view.
	 * @return a jpanel representing the header.
	 */
	private JPanel createHeader(JComboBox accountSelector, MaterialTabGroup tabSelector, JDialog loginModal)
	{
		JPanel accountSelectorPanel = new JPanel(new BorderLayout());
		accountSelectorPanel.setBackground(CustomColors.DARK_GRAY);
		accountSelectorPanel.add(accountSelector, BorderLayout.CENTER);
		accountSelectorPanel.setBorder(new EmptyBorder(0,0,4,0));

		JPanel header = new JPanel(new BorderLayout());
		header.setBackground(CustomColors.DARK_GRAY);
		header.add(accountSelectorPanel, BorderLayout.NORTH);
		header.add(createCommunityPanel(loginModal), BorderLayout.CENTER);
		header.add(tabSelector, BorderLayout.SOUTH);
		header.setBorder(new EmptyBorder(0,0,3,0));
		return header;
	}

	private JPanel createCommunityPanel(JDialog loginModal) {
		JPanel communityPanel = new JPanel(new BorderLayout());
		communityPanel.setBackground(CustomColors.DARK_GRAY);
		communityPanel.setBorder(new EmptyBorder(7,0,0,0));

		JPanel centerPanel = new JPanel();
		centerPanel.setBorder(new EmptyBorder(0,0,6,43));

		JLabel githubIcon = UIUtilities.createIcon(Icons.GITHUB_ICON, Icons.GITHUB_ICON_ON, "https://github.com/Flipping-Utilities/rl-plugin", "Click to go to Flipping Utilities github");
		JLabel twitterIcon = UIUtilities.createIcon(Icons.TWITTER_ICON, Icons.TWITTER_ICON_ON, "https://twitter.com/flippingutils", "Click to go to Flipping Utilities twitter");
		JLabel discordIcon = UIUtilities.createIcon(Icons.DISCORD_ICON, Icons.DISCORD_ICON_ON, "https://discord.gg/GDqVgMH26s","Click to go to Flipping Utilities discord");

		centerPanel.setBackground(CustomColors.DARK_GRAY);
		centerPanel.add(discordIcon);
		centerPanel.add(twitterIcon);
		centerPanel.add(githubIcon);

		communityPanel.add(centerPanel, BorderLayout.CENTER);
		MasterPanel m = this;
		JLabel profileButton = new JLabel(Icons.USER);
		plugin.getApiAuthHandler().subscribeToLogin(() -> {
			SwingUtilities.invokeLater(() -> {
				profileButton.setIcon(Icons.USER_LOGGED_IN);
				JPopupMenu profilePopup = new JPopupMenu();
				profilePopup.add(new JLabel("Click to open your profile page!"));
				UIUtilities.addPopupOnHover(profileButton, profilePopup, false);
			});
		});
		profileButton.setBorder(new EmptyBorder(0,15,10,0));
		profileButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				loginModal.pack();
				loginModal.setLocation(m.getLocationOnScreen().x - loginModal.getWidth() - 10, Math.max(m.getLocationOnScreen().y - loginModal.getHeight()/2,0) + 100);
				loginModal.setVisible(true);
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				if (!plugin.getApiAuthHandler().isHasValidJWT()) {
					profileButton.setIcon(Icons.USER_HOVER);
				}
			}

			@Override
			public void mouseExited(MouseEvent e) {
				ImageIcon icon = plugin.getApiAuthHandler().isHasValidJWT()? Icons.USER_LOGGED_IN:Icons.USER;
				profileButton.setIcon(icon);
			}
		});

		JPopupMenu profilePopup = new JPopupMenu();
		profilePopup.add(new JLabel("Click to login!"));
		UIUtilities.addPopupOnHover(profileButton, profilePopup, false);

		communityPanel.add(profileButton, BorderLayout.WEST);
		return communityPanel;
	}

	/**
	 * This is the dropdown at the top of the header which allows the user to select which account they want to view.
	 * Its only set to visible if the user has more than once account with a trading history.
	 *
	 * @return the account selector.
	 */
	private JComboBox accountSelector()
	{
		JComboBox viewSelectorDropdown = new JComboBox();
		viewSelectorDropdown.setBackground(CustomColors.DARK_GRAY_LIGHTER);
		viewSelectorDropdown.setFocusable(false);
		viewSelectorDropdown.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		viewSelectorDropdown.setRenderer(new TitleCaseListCellRenderer());

		viewSelectorDropdown.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()),
			BorderFactory.createEmptyBorder(4,2,4,2)));
		viewSelectorDropdown.setToolTipText("Select which of your account's trades list you want to view");
		viewSelectorDropdown.addItemListener(event ->
		{
			if (event.getStateChange() == ItemEvent.SELECTED)
			{
				String selectedName = (String) event.getItem();
				plugin.changeView(selectedName);
			}
		});

		return viewSelectorDropdown;
	}

	/**
	 * Adds the tabs for the flipping panel and stats panel onto the main display panel. These tabs can then
	 * be clicked to view the flipping/stats panel
	 *
	 * @param mainDisplay   the panel on which the tabs will be put and on which either the flipping or stats panel will be
	 *                      rendered
	 * @return
	 */
	private FastTabGroup tabSelector(JPanel mainDisplay, JPanel flippingPanel, JPanel statPanel, JPanel slotsPanel)
	{
		FastTabGroup tabGroup = new FastTabGroup(mainDisplay);
		MaterialTab flippingTab = new MaterialTab("flipping", tabGroup, flippingPanel);
		MaterialTab statisticsTab = new MaterialTab("stats", tabGroup, statPanel);
		MaterialTab slotsTab = new MaterialTab("slots", tabGroup, slotsPanel);

		tabGroup.addTab(slotsTab);
		tabGroup.addTab(flippingTab);
		tabGroup.addTab(statisticsTab);

		tabGroup.select(flippingTab);
		return tabGroup;
	}

	public Set<String> getViewSelectorItems()
	{
		Set<String> items = new HashSet<>();
		for (int i = 0; i < accountSelector.getItemCount(); i++)
		{
			items.add(accountSelector.getItemAt(i));
		}
		return items;
	}

	public void addView(JPanel panel, String name) {
		tabGroup.addView(panel, name);
	}

	public void showView(String name) {
		tabGroup.showView(name);
	}

	public void selectPreviouslySelectedTab() {
		tabGroup.selectPreviouslySelectedTab();
	}

	/**
	 * There are certain views that should not be viewable unless the user is logged in because they require the
	 * currently logged in account. This method is used to revert back to a "safe" previously selected tab that is
	 * safe to view when an account is logged out.
	 */
	public void revertToSafeDisplay() {
		tabGroup.revertToSafeDisplay();
	}

	/**
	 * sets up the account selector dropdown that lets you change which account's trade list you
	 * are looking at.
	 */
	public void setupAccSelectorDropdown(Set<String> currentAccounts) {
		//adding an item causes the event listener (changeView) to fire which causes stat panel
		//and flipping panel to rebuildItemsDisplay. I think this only happens on the first item you add.
		accountSelector.addItem(FlippingPlugin.ACCOUNT_WIDE);

		currentAccounts.forEach(displayName -> accountSelector.addItem(displayName));

		//sets the account selector dropdown to visible or not depending on whether the config option has been
		//selected and there are > 1 accounts.
		if (currentAccounts.size() > 1) {
			accountSelector.setVisible(true);
		} else {
			accountSelector.setVisible(false);
		}
	}

	/**
	* Use to dispose the underlying login dialog on shutdown.
	*/
	public void dispose() {
		loginModal.dispose();
	}
}

package com.flippingutilities.ui.gehistorytab;

import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.TimeFormatters;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.stream.Collectors;

public class MatchingOffersPanel extends JPanel
{
	MatchingOffersPanel(List<OfferEvent> matchingOffers) {
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel titlePanel = new JPanel(new BorderLayout());
		String plural = matchingOffers.size() == 1? "match":"matches";
		String titleText = matchingOffers.size() < 5? matchingOffers.size() + " " + plural + " in history": "At least 5 matches";
		JLabel titleTextLabel = new JLabel(titleText, SwingConstants.CENTER);
		titleTextLabel.setFont(FontManager.getRunescapeBoldFont());
		titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		titleTextLabel.setForeground(matchingOffers.size() == 0? ColorScheme.GRAND_EXCHANGE_PRICE: ColorScheme.GRAND_EXCHANGE_ALCH);
		JLabel collapsePanelIconLabel = new JLabel(Icons.OPEN_ICON);
		titlePanel.add(titleTextLabel, BorderLayout.CENTER);
		titlePanel.add(collapsePanelIconLabel, BorderLayout.EAST);
		titlePanel.setBorder(new EmptyBorder(3,0,0,0));
		titlePanel.setToolTipText("<html>Having a matching offer in your history means you made an offer in the past with the same quantity, price and buy/sell state.<br>" +
			"Having 0 matching offers means the plugin did not track the trade (perhaps you made it on mobile) and it's safe to add manually.<br>" +
			"If you have matching offers it still might be safe to manually add the offer but you have to decide whether the offer you are <br>" +
			"adding is one of the matching offers or not to make sure you are not adding an offer already tracked in your history.</html>");

		List<JPanel> matchingOfferPanels = matchingOffers.stream().map(o -> createMatchingOfferPanel(o)).collect(Collectors.toList());
		JPanel matchingOffersPanelBody = UIUtilities.stackPanelsVertically(matchingOfferPanels, 2);
		matchingOffersPanelBody.setVisible(false);

		titlePanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (e.getButton() == MouseEvent.BUTTON1)
				{
					if (matchingOffersPanelBody.isVisible())
					{
						matchingOffersPanelBody.setVisible(false);
						collapsePanelIconLabel.setIcon(Icons.OPEN_ICON);
					}
					else
					{
						matchingOffersPanelBody.setVisible(true);
						collapsePanelIconLabel.setIcon(Icons.CLOSE_ICON);
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				titlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		add(titlePanel, BorderLayout.NORTH);
		add(matchingOffersPanelBody, BorderLayout.CENTER);
	}

	JPanel createMatchingOfferPanel(OfferEvent offerEvent) {
		JPanel matchingOfferPanel = new JPanel(new BorderLayout());
		matchingOfferPanel.add(new JLabel("Same Offer Made:"), BorderLayout.WEST);
		matchingOfferPanel.add(new JLabel(TimeFormatters.formatDurationTruncated(offerEvent.getTime()) + " ago"), BorderLayout.EAST);
		return matchingOfferPanel;
	}
}

package com.flippingutilities.ui.gehistorytab;

import com.flippingutilities.model.OfferEvent;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.text.NumberFormat;
import java.util.List;
import java.util.function.BiConsumer;

public class GeHistoryTabOfferPanel extends JPanel
{
	private int offerId;
	private Widget[] geHistoryTabWidgets;
	private static final int ORIGINAL_WIDGET_COLOR = 16750623;
	private JCheckBox checkBox;
	private JPanel checkBoxPanel;

	public GeHistoryTabOfferPanel(OfferEvent offer, List<OfferEvent> matchingOffers, int offerId, BiConsumer<Integer, Boolean> onCheckBoxChangeCallback, Widget[] geHistoryTabWidgets)
	{
		this.offerId = offerId;
		this.geHistoryTabWidgets = geHistoryTabWidgets;
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 5));
		checkBoxPanel = new JPanel(new BorderLayout());
		checkBoxPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		checkBox = new JCheckBox();
		checkBox.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		checkBox.setFocusPainted(false);
		checkBoxPanel.add(checkBox, BorderLayout.CENTER);
		checkBox.addItemListener(itemEvent -> {
			onCheckBoxChangeCallback.accept(offerId, itemEvent.getStateChange() == itemEvent.SELECTED);
			lightCorrespondingWidgets(itemEvent.getStateChange() == itemEvent.SELECTED);
		});
		add(checkBoxPanel, BorderLayout.WEST);
		add(createInfoPanel(offer, matchingOffers), BorderLayout.CENTER);
	}

	public JPanel createInfoPanel(OfferEvent offer, List<OfferEvent> matchingOffers)
	{
		JPanel infoPanel = new JPanel(new BorderLayout());
		infoPanel.setBorder(new EmptyBorder(3, 6, 3, 3));
		infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel itemNameLabel = new JLabel(offer.getItemName(), SwingConstants.CENTER);
		itemNameLabel.setFont(FontManager.getRunescapeBoldFont());
		itemNameLabel.setForeground(Color.WHITE);
		itemNameLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel offerDetailsPanel = new JPanel(new DynamicGridLayout(3, 1, 0, 0));

		JPanel statePanel = new JPanel(new BorderLayout());
		JLabel leftStateLabel = new JLabel("State:");
		JLabel rightStateLabel = new JLabel(offer.getState() == GrandExchangeOfferState.BOUGHT ? "Bought" : "Sold");
		statePanel.add(leftStateLabel, BorderLayout.WEST);
		statePanel.add(rightStateLabel, BorderLayout.EAST);
		statePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel quantityPanel = new JPanel(new BorderLayout());
		JLabel leftQuantityLabel = new JLabel("Quantity:");
		JLabel rightQuantityLabel = new JLabel(NumberFormat.getIntegerInstance().format(offer.getCurrentQuantityInTrade()));
		quantityPanel.add(leftQuantityLabel, BorderLayout.WEST);
		quantityPanel.add(rightQuantityLabel, BorderLayout.EAST);
		quantityPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel pricePanel = new JPanel(new BorderLayout());
		JLabel leftPriceLabel = new JLabel("Price Ea:");
		JLabel rightPriceLabel = new JLabel(NumberFormat.getIntegerInstance().format(offer.getPrice()));
		pricePanel.add(leftPriceLabel, BorderLayout.WEST);
		pricePanel.add(rightPriceLabel, BorderLayout.EAST);
		pricePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		offerDetailsPanel.add(statePanel);
		offerDetailsPanel.add(quantityPanel);
		offerDetailsPanel.add(pricePanel);

		infoPanel.add(itemNameLabel, BorderLayout.NORTH);
		infoPanel.add(offerDetailsPanel, BorderLayout.CENTER);
		infoPanel.add(new MatchingOffersPanel(matchingOffers), BorderLayout.SOUTH);
		return infoPanel;
	}

	public void setAdded()
	{
		checkBox.setEnabled(false);
		checkBox.setBackground(ColorScheme.GRAND_EXCHANGE_PRICE);
		checkBoxPanel.setBackground(ColorScheme.GRAND_EXCHANGE_PRICE);
	}

	private void lightCorrespondingWidgets(boolean shouldLight) {
		int offset = offerId * 6;
		if (shouldLight)
		{
			geHistoryTabWidgets[offset + 2].setTextColor(ColorScheme.GRAND_EXCHANGE_PRICE.getRGB());
			geHistoryTabWidgets[offset + 3].setTextColor(ColorScheme.GRAND_EXCHANGE_PRICE.getRGB());
			geHistoryTabWidgets[offset + 5].setTextColor(ColorScheme.GRAND_EXCHANGE_PRICE.getRGB());
		}
		else
		{
			geHistoryTabWidgets[offset + 2].setTextColor(ORIGINAL_WIDGET_COLOR);
			geHistoryTabWidgets[offset + 3].setTextColor(ORIGINAL_WIDGET_COLOR);
			geHistoryTabWidgets[offset + 5].setTextColor(ORIGINAL_WIDGET_COLOR);
		}
	}
}

package com.flippingutilities.ui.gehistorytab;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * The panel that holds a view of the items in the trade history tab in the ge. This is so that users can manually add
 * trades they did while not using runelite (those trades will be in the GE trade history tab, assuming they are complete
 * and not too long ago).
 */
@Slf4j
public class GeHistoryTabPanel extends JPanel
{
	public JPanel geHistoryTabOffersPanel;
	public JLabel statusTextLabel;
	public Set<Integer> selectedOfferIds;
	public Set<Integer> highlightedPanels;
	public List<OfferEvent> offersFromHistoryTab;
	public JButton addOffersButton;
	public Widget[] geHistoryTabWidgets;
	public List<GeHistoryTabOfferPanel> offerPanels;
	public List<List<OfferEvent>> matchingOffers;
	FlippingPlugin plugin;
	private static final int ORIGINAL_WIDGET_COLOR = 16750623;

	public GeHistoryTabPanel(FlippingPlugin plugin) {
		this.plugin = plugin;
		this.offerPanels = new ArrayList<>();
		this.geHistoryTabOffersPanel = new JPanel();
		this.selectedOfferIds = new HashSet<>();
		this.highlightedPanels = new HashSet<>();
		geHistoryTabOffersPanel.setBorder((new EmptyBorder(5, 6, 0, 6)));
		geHistoryTabOffersPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());
		add(createTitlePanel(), BorderLayout.NORTH);
		add(createOfferContainer(), BorderLayout.CENTER);
	}

	private JPanel createTitlePanel() {
		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		titlePanel.setBorder(new EmptyBorder(5,5,10,5));
		JLabel titleText = new JLabel("Grand Exchange History", SwingConstants.CENTER);
		titleText.setFont(new Font("Verdana", Font.BOLD, 15));

		JPanel statusPanel = new JPanel(new BorderLayout(0, 5));
		statusPanel.setBorder(new EmptyBorder(7,0,0,0));
		statusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		statusTextLabel = new JLabel("0 items selected", SwingConstants.CENTER);
		statusTextLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		statusTextLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		statusTextLabel.setFont(FontManager.getRunescapeBoldFont());

		addOffersButton = new JButton("Add selected offers");
		addOffersButton.setFont(FontManager.getRunescapeBoldFont());
		addOffersButton.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		addOffersButton.setFocusPainted(false);
		addOffersButton.setVisible(false);
		addOffersButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (e.getButton() == MouseEvent.BUTTON1)
				{
					addSelectedOffers();
				}
			}
		});

		statusPanel.add(addOffersButton, BorderLayout.CENTER);
		statusPanel.add(statusTextLabel, BorderLayout.NORTH);

		titlePanel.add(titleText, BorderLayout.CENTER);
		titlePanel.add(statusPanel, BorderLayout.SOUTH);
 		return titlePanel;
	}

	private void addSelectedOffers() {
		List<OfferEvent> selectedOffers = selectedOfferIds.stream().map(idx -> offersFromHistoryTab.get(idx)).collect(Collectors.toList());
		highlightedPanels.addAll(selectedOfferIds);
		plugin.addSelectedGeTabOffers(selectedOffers);
		matchingOffers = offersFromHistoryTab.stream().map(o -> plugin.findOfferMatches(o,5)).collect(Collectors.toList());
		rebuild(offersFromHistoryTab, matchingOffers, geHistoryTabWidgets, true);
	}

	private JPanel createOfferContainer() {
		JPanel geHistoryTabOfferContainer = new JPanel(new BorderLayout());
		JPanel wrapper = new JPanel(new BorderLayout());
		wrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wrapper.add(geHistoryTabOffersPanel, BorderLayout.NORTH);

		JScrollPane scrollWrapper = new JScrollPane(wrapper);
		scrollWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollWrapper.getVerticalScrollBar().setPreferredSize(new Dimension(5, 0));
		scrollWrapper.getVerticalScrollBar().setBorder(new EmptyBorder(0, 0, 0, 0));

		geHistoryTabOfferContainer.add(scrollWrapper, BorderLayout.CENTER);
		geHistoryTabOfferContainer.setBorder(new EmptyBorder(5, 0, 0, 0));
		geHistoryTabOfferContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		return geHistoryTabOfferContainer;
	}

	private void onCheckBoxChange(int offerId, boolean selected) {
		int offset = offerId * 6;
		if (selected) {
			selectedOfferIds.add(offerId);
			geHistoryTabWidgets[offset + 2].setTextColor(ColorScheme.GRAND_EXCHANGE_PRICE.getRGB());
			geHistoryTabWidgets[offset + 3].setTextColor(ColorScheme.GRAND_EXCHANGE_PRICE.getRGB());
			geHistoryTabWidgets[offset + 5].setTextColor(ColorScheme.GRAND_EXCHANGE_PRICE.getRGB());
		}
		else {
			if (selectedOfferIds.contains(offerId)) {
				selectedOfferIds.remove(offerId);
				geHistoryTabWidgets[offset + 2].setTextColor(ORIGINAL_WIDGET_COLOR);
				geHistoryTabWidgets[offset + 3].setTextColor(ORIGINAL_WIDGET_COLOR);
				geHistoryTabWidgets[offset + 5].setTextColor(ORIGINAL_WIDGET_COLOR);
			}
		}
		statusTextLabel.setText(selectedOfferIds.size() + " items selected");
		addOffersButton.setVisible(selectedOfferIds.size() > 0);
	}

	public void rebuild(List<OfferEvent> offers, List<List<OfferEvent>> matchingOffers, Widget[] widgets, boolean keepHighlightedPanels) {
		SwingUtilities.invokeLater(() ->
		{
			Instant rebuildStart = Instant.now();
			offersFromHistoryTab = offers;
			this.matchingOffers = matchingOffers;
			geHistoryTabWidgets = widgets;
			selectedOfferIds.clear();
			if (!keepHighlightedPanels) {
				highlightedPanels.clear();
			}
			offerPanels.clear();
			addOffersButton.setVisible(false);
			statusTextLabel.setText("0 items selected");
			geHistoryTabOffersPanel.removeAll();

			for (int i=0; i < offers.size();i++) {
				offerPanels.add(new GeHistoryTabOfferPanel(offers.get(i),matchingOffers.get(i), i, this::onCheckBoxChange, geHistoryTabWidgets));
			}
			UIUtilities.stackPanelsVertically((List) offerPanels, geHistoryTabOffersPanel, 4);
			highlightedPanels.forEach(idx -> offerPanels.get(idx).setAdded());
			revalidate();
			repaint();
			//log.info("GeHistoryTabPanel rebuildItemsDisplay took {}", Duration.between(rebuildStart, Instant.now()).toMillis());
		});
	}
}

package com.flippingutilities.ui.login;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class LoggedInPanel extends JPanel {
    FlippingPlugin plugin;
    Runnable showLoggedOutPanel;
    JLabel slotFeatureHealthLabel = new JLabel("Inactive (not logged in)");

    public LoggedInPanel(FlippingPlugin plugin, Runnable showLoggedOutPanel) {
        this.plugin = plugin;
        this.showLoggedOutPanel = showLoggedOutPanel;
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10,10,10,10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        add(createTitle(), BorderLayout.NORTH);
        add(createSignOutButton(), BorderLayout.SOUTH);
    }

    private JLabel createTitle() {
        JLabel headerLabel = new JLabel("Status", JLabel.CENTER);
        headerLabel.setFont(new Font("Whitney", Font.PLAIN + Font.BOLD, 16));
        headerLabel.setForeground(CustomColors.CHEESE);
        return headerLabel;
    }

    private JPanel createResubPanel() {
        JPanel resubPanel = new JPanel();
        resubPanel.setLayout(new BoxLayout(resubPanel, BoxLayout.Y_AXIS));
        resubPanel.setBorder(new EmptyBorder(10,0,10,0));

        JLabel notPremium = new JLabel(String.format("<html><div style=\"text-align:center\" WIDTH=%d>%s</div></html>", 180,
            "You are not premium anymore, resub to gain access to premium features"), JLabel.CENTER);
        notPremium.setFont(new Font("Whitney", Font.PLAIN, 12));
        notPremium.setForeground(CustomColors.TOMATO);


        JLabel link = new JLabel("<html>https://upgrade.chat/flipping-utilities</html>", JLabel.CENTER);
        link.setFont(new Font("Whitney", Font.PLAIN, 12));
        link.setForeground(Color.WHITE);
        link.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                LinkBrowser.browse("https://upgrade.chat/flipping-utilities");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                link.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                link.setForeground(Color.WHITE);
            }
        });

        resubPanel.add(notPremium);
        resubPanel.add(Box.createVerticalStrut(10));
        resubPanel.add(link);

        return resubPanel;
    }

    private JPanel createPremiumFeaturesPanel() {
        JPanel healthPanel = new JPanel();
        healthPanel.setLayout(new BoxLayout(healthPanel, BoxLayout.Y_AXIS));
        healthPanel.setBorder(new EmptyBorder(10,0,10,0));

        JPanel slotSendingHealthPanel = new JPanel(new BorderLayout());
        JLabel slotFeatureHealthRight = new JLabel("Slot sending feature: ");
        slotFeatureHealthRight.setFont(new Font("Whitney", Font.PLAIN, 10));
        slotFeatureHealthRight.setForeground(CustomColors.CHEESE);
        slotFeatureHealthLabel.setFont(new Font("Whitney", Font.PLAIN + Font.ITALIC, 10));
        slotSendingHealthPanel.add(slotFeatureHealthRight, BorderLayout.WEST);
        slotSendingHealthPanel.add(slotFeatureHealthLabel, BorderLayout.EAST);

        healthPanel.add(slotSendingHealthPanel);
        healthPanel.add(createSlotEnhancementTogglePanel());
        return healthPanel;
    }

    private JPanel createSignOutButton() {
        JPanel signoutButtonWrapper = new JPanel();
        JLabel signOutButton = new JLabel("Sign Out", JLabel.CENTER);
        signOutButton.setBorder(new EmptyBorder(10,10,10,10));
        signOutButton.setFont(new Font("Whitney", Font.BOLD, 12));
        signOutButton.setBackground(CustomColors.TOMATO);
        signOutButton.setOpaque(true);
        Runnable r = showLoggedOutPanel;
        signOutButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                int result = JOptionPane.showOptionDialog(
                    signOutButton,
                    "Signing out will require you to re-enter the token\ngiven to you by the Flopper discord bot",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[] {"Yes", "No"}, "No");

                if (result == JOptionPane.YES_OPTION)
                {
                    plugin.getDataHandler().getAccountWideData().setJwt(null);
                    plugin.getDataHandler().markDataAsHavingChanged(FlippingPlugin.ACCOUNT_WIDE);
                    plugin.getApiAuthHandler().setPremium(false);
                    plugin.getApiAuthHandler().setHasValidJWT(false);
                    r.run();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                signOutButton.setBackground(CustomColors.TOMATO.brighter());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                signOutButton.setBackground(CustomColors.TOMATO);
            }
        });

        signoutButtonWrapper.add(signOutButton);
        return signoutButtonWrapper;
    }

    public void showPremiumFeaturesHealth(boolean isPremium) {
        SwingUtilities.invokeLater(() -> {
            if (isPremium) {
                removeAll();
                add(createTitle(), BorderLayout.NORTH);
                add(createSignOutButton(), BorderLayout.SOUTH);
                add(createPremiumFeaturesPanel(), BorderLayout.CENTER);
            }
            else {
                removeAll();
                add(createTitle(), BorderLayout.NORTH);
                add(createSignOutButton(), BorderLayout.SOUTH);
                add(createResubPanel(), BorderLayout.CENTER);
            }
            revalidate();
            repaint();
        });
    }

    private JPanel createSlotEnhancementTogglePanel() {
        JLabel toggleLabel = new JLabel("Slot enhancement");
        toggleLabel.setFont(new Font("Whitney", Font.PLAIN, 10));
        toggleLabel.setForeground(CustomColors.CHEESE);

        JToggleButton toggleButton = UIUtilities.createToggleButton();
        toggleButton.setSelected(plugin.shouldEnhanceSlots());
        toggleButton.addItemListener(i -> plugin.toggleEnhancedSlots(toggleButton.isSelected()));

        JPanel toggleSlotEnhancementPanel = new JPanel(new BorderLayout());
        toggleSlotEnhancementPanel.add(toggleLabel, BorderLayout.WEST);
        toggleSlotEnhancementPanel.add(toggleButton, BorderLayout.EAST);
        return toggleSlotEnhancementPanel;
    }

    public void setSlotFeatureHealthText(String text) {
        slotFeatureHealthLabel.setText(text);
    }
}

package com.flippingutilities.ui.login;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Instant;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class LoginPanel extends JPanel{
    FlippingPlugin plugin;
    Runnable onViewChange;
    public boolean showingLoggedInView;
    Instant timeOfLastSuccessfulRequest;
    boolean errorWhenSendingSlotRequest;
    boolean notSendingRequestDueToNoChange;
    LoggedInPanel loggedInPanel;

    public LoginPanel(FlippingPlugin plugin) {
        this.plugin = plugin;
        this.loggedInPanel = new LoggedInPanel(plugin, this::showLoggedOutView);
        plugin.getApiAuthHandler().subscribeToLogin(this::showLoggedInView);
        plugin.getApiAuthHandler().subscribeToPremiumChecking((isPremium) -> {
            loggedInPanel.showPremiumFeaturesHealth(isPremium);
        });

        add(createLoggedOutPanel());
        Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(this::checkHealth, 5, 1, TimeUnit.SECONDS);
    }

    public void addOnViewChange(Runnable r) {
        this.onViewChange = r;
    }

    private void checkHealth() {
        if (!showingLoggedInView) {
            return;
        }
        SwingUtilities.invokeLater(() -> {
            if (plugin.getCurrentlyLoggedInAccount() == null) {
                timeOfLastSuccessfulRequest = null;
                loggedInPanel.setSlotFeatureHealthText("Inactive (not logged in)");
            }
            else if (!plugin.getApiAuthHandler().canCommunicateWithApi(plugin.getCurrentlyLoggedInAccount())) {
                loggedInPanel.setSlotFeatureHealthText("Inactive (not registered yet)");
            }
            else if (timeOfLastSuccessfulRequest == null) {
                loggedInPanel.setSlotFeatureHealthText("Active (starting up)");
            }
            else if (notSendingRequestDueToNoChange) {
                loggedInPanel.setSlotFeatureHealthText("Active (no slot change detected)");
            }
            else if (errorWhenSendingSlotRequest) {
                loggedInPanel.setSlotFeatureHealthText("Inactive (error on slot update)");
            }
            else {
                long diff = Instant.now().getEpochSecond() - timeOfLastSuccessfulRequest.getEpochSecond();
                loggedInPanel.setSlotFeatureHealthText(String.format("Active (%ds since last update)", diff));
            }
        });
    }

    public void onSlotRequest(int success) {
        if (success == 0) {
            notSendingRequestDueToNoChange = true;
        }
        else if (success == 1) {
            timeOfLastSuccessfulRequest = Instant.now();
            errorWhenSendingSlotRequest = false;
            notSendingRequestDueToNoChange = false;
        }
        else {
            errorWhenSendingSlotRequest = true;
            notSendingRequestDueToNoChange = false;
        }
    }

    public void showLoggedInView() {
        SwingUtilities.invokeLater(() -> {
            removeAll();
            add(loggedInPanel);
            revalidate();
            repaint();
            if (this.onViewChange != null) {
                this.onViewChange.run();
            }
            showingLoggedInView = true;
        });
    }

    public void showLoggedOutView() {
        SwingUtilities.invokeLater(() -> {
            removeAll();
            add(createLoggedOutPanel());
            revalidate();
            repaint();
            if (this.onViewChange != null) {
                this.onViewChange.run();
            }
        });
    }
    private JPanel createLoggedOutPanel() {
        JPanel loggedOutPanel = new JPanel(new BorderLayout());
        loggedOutPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        loggedOutPanel.setBorder(new EmptyBorder(20,40,20,25));

        loggedOutPanel.add(createFeaturesPanel(), BorderLayout.WEST);
        loggedOutPanel.add(createTokenPanel(), BorderLayout.CENTER);
        loggedOutPanel.add(createLoginInstructionsPanel(), BorderLayout.EAST);
        return loggedOutPanel;
    }

    private JPanel createFeaturesPanel() {
        JPanel featuresPanel = new JPanel(new BorderLayout());
        featuresPanel.setBorder(new EmptyBorder(0,0,0,20));

        JLabel flashIcon = new JLabel(Icons.FLASH, JLabel.CENTER);

        JLabel headingText = new JLabel("<html>LOGIN TO...</html>");
        headingText.setFont(new Font("Whitney", Font.BOLD, 14));
        headingText.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        headingText.setBorder(new EmptyBorder(0,0,4,0));

        JPanel featuresListPanel = new JPanel(new DynamicGridLayout(4, 0, 0, 0));

        JPanel firstFeaturePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel firstFeatureDesc = new JLabel(String.format("<html><div WIDTH=%d>%s</div></html>", 180, "Get discord DMs when offers complete or you are undercut, even when logged out of rs!"));
        firstFeatureDesc.setFont(new Font("Whitney", Font.PLAIN, 12));
        firstFeatureDesc.setForeground(CustomColors.SOFT_ALCH);
        firstFeaturePanel.add(firstFeatureDesc);

        JPanel secondFeaturePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel secondFeatureDesc = new JLabel(String.format("<html><div WIDTH=%d>%s</div></html>", 180, "View the current state of your offers on discord!"));
        secondFeatureDesc.setFont(new Font("Whitney", Font.PLAIN, 12));
        secondFeatureDesc.setForeground(CustomColors.SOFT_ALCH);
        secondFeaturePanel.add(secondFeatureDesc);

        JLabel bottomText = new JLabel("<html>More features are in development!</html>");
        bottomText.setFont(new Font("Whitney", Font.BOLD + Font.ITALIC, 10));
        bottomText.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        bottomText.setBorder(new EmptyBorder(25,0,0,0));

        featuresListPanel.add(headingText);
        featuresListPanel.add(firstFeaturePanel);
        featuresListPanel.add(secondFeaturePanel);
        featuresListPanel.add(bottomText);

        featuresPanel.add(flashIcon, BorderLayout.NORTH);
        featuresPanel.add(featuresListPanel, BorderLayout.SOUTH);

        return featuresPanel;
    }

    private JPanel createLoginInstructionsPanel() {
        JPanel instructionsPanel = new JPanel(new BorderLayout());
        instructionsPanel.setBorder(new EmptyBorder(0,20,0,0));

        JLabel keyIcon = new JLabel(Icons.KEY, JLabel.CENTER);

        JLabel headingText = new JLabel("<html>GETTING A TOKEN</html>");
        headingText.setFont(new Font("Whitney", Font.BOLD, 14));
        headingText.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        headingText.setBorder(new EmptyBorder(0,0,7,0));

        JPanel firstStepPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel firstStepNumber = new JLabel("<html>1. </html>");
        firstStepNumber.setFont(new Font("Whitney", Font.BOLD, 14));
        firstStepNumber.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        JLabel firstStepDesc = new JLabel("Join our discord", JLabel.LEFT);
        firstStepDesc.setFont(new Font("Whitney", Font.PLAIN, 12));
        firstStepDesc.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        firstStepPanel.add(firstStepNumber);
        firstStepPanel.add(firstStepDesc);
        firstStepPanel.add(UIUtilities.createIcon(Icons.DISCORD_CHEESE, Icons.DISCORD_ICON_ON,"https://discord.gg/GDqVgMH26s","Click to go to Flipping Utilities discord!"));

        JPanel secondStepPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel secondStepDesc = new JLabel("Type /login in the bot channel");
        secondStepDesc.setFont(new Font("Whitney", Font.PLAIN, 12));
        secondStepDesc.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        JLabel secondStepNumber = new JLabel("<html>2. </html>");
        secondStepNumber.setFont(new Font("Whitney", Font.BOLD, 14));
        secondStepNumber.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        secondStepPanel.add(secondStepNumber);
        secondStepPanel.add(secondStepDesc);

        JPanel thirdStepPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JLabel thirdStepNumber = new JLabel("<html>3. </html>");
        thirdStepNumber.setFont(new Font("Whitney", Font.BOLD, 14));
        thirdStepNumber.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        JLabel thirdStepDesc = new JLabel("Enter the token here");
        thirdStepDesc.setFont(new Font("Whitney", Font.PLAIN, 12));
        thirdStepDesc.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        thirdStepPanel.add(thirdStepNumber);
        thirdStepPanel.add(thirdStepDesc);

        JLabel bottomText = new JLabel("<html>You will only have to do this once</html>");
        bottomText.setFont(new Font("Whitney", Font.BOLD + Font.ITALIC, 10));
        bottomText.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        bottomText.setBorder(new EmptyBorder(33,0,0,0));

        JPanel stepsPanel = new JPanel(new DynamicGridLayout(5, 0, 0, 0));
        stepsPanel.add(headingText);
        stepsPanel.add(firstStepPanel);
        stepsPanel.add(secondStepPanel);
        stepsPanel.add(thirdStepPanel);
        stepsPanel.add(bottomText);

        instructionsPanel.add(keyIcon, BorderLayout.NORTH);
        instructionsPanel.add(stepsPanel, BorderLayout.SOUTH);

        return instructionsPanel;
    }

    private JPanel createTokenPanel() {
        JPanel tokenPanel = new JPanel(new BorderLayout());
        tokenPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        tokenPanel.setBorder(new CompoundBorder(
                new MatteBorder(0,1,0,1, ColorScheme.MEDIUM_GRAY_COLOR),
                new EmptyBorder(0,30,0,30)
        ));

        JPanel header = new JPanel();
        header.setForeground(CustomColors.CHEESE);
        JLabel fuIcon = new JLabel(Icons.FU_ICON, JLabel.CENTER);
        header.add(fuIcon);

        JPanel middlePanel = new JPanel(new BorderLayout());
        middlePanel.setBorder(new EmptyBorder(20,0,20,0));
        middlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        IconTextField tokenField = new IconTextField();
        tokenField.setBackground(CustomColors.DARK_GRAY);
        tokenField.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()),
                BorderFactory.createEmptyBorder(10,0,10,0)));
        tokenField.setPreferredSize(new Dimension(170, 40));

        JLabel tokenFieldDescriptor = new JLabel("TOKEN", JLabel.LEFT);
        tokenFieldDescriptor.setFont(new Font("Whitney", Font.BOLD, 12));
        tokenFieldDescriptor.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        tokenFieldDescriptor.setBorder(new EmptyBorder(0,0,5,0));

        middlePanel.add(tokenFieldDescriptor, BorderLayout.NORTH);
        middlePanel.add(tokenField, BorderLayout.CENTER);

        JPanel loginButtonWrapper = new JPanel();
        loginButtonWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel loginButton = new JLabel("Login", JLabel.CENTER);
        loginButton.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(0,0,0,0, ColorScheme.GRAND_EXCHANGE_PRICE.darker()),new EmptyBorder(10,20,10,20))
        );
        loginButton.setFont(new Font("Whitney", Font.BOLD, 12));
        loginButton.setBackground(ColorScheme.GRAND_EXCHANGE_PRICE);
        loginButton.setOpaque(true);
        loginButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                int result = JOptionPane.showOptionDialog(
                        loginButton,
                        "Logging into flipping utilities will submit GE transactions and your IP address\n" +
                                "to flipping utilities, a 3rd party not controlled or verified by the RuneLite developers",
                        "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                        null, new String[] {"Yes", "No"}, "No");

                if (result == JOptionPane.YES_OPTION)
                {
                    plugin.getApiAuthHandler().loginWithToken(tokenField.getText().trim()).exceptionally((exception) -> {
                        SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(loginButton, "Authentication error, contact us on discord for help!", "Authentication error ",  JOptionPane.ERROR_MESSAGE));
                        return null;
                    });
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                loginButton.setBackground(ColorScheme.GRAND_EXCHANGE_PRICE.brighter());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                loginButton.setBackground(ColorScheme.GRAND_EXCHANGE_PRICE);
            }
        });

        loginButtonWrapper.add(loginButton);

        tokenPanel.add(header, BorderLayout.NORTH);
        tokenPanel.add(middlePanel, BorderLayout.CENTER);
        tokenPanel.add(loginButtonWrapper, BorderLayout.SOUTH);

        return tokenPanel;
    }
}

package com.flippingutilities.ui.slots;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.QuickLookPanel;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import com.flippingutilities.utilities.SlotInfo;
import com.flippingutilities.utilities.SlotPredictedState;
import com.flippingutilities.utilities.WikiItemMargins;
import com.flippingutilities.utilities.WikiRequest;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.ThinProgressBar;
import net.runelite.client.util.QuantityFormatter;


import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.List;

public class SlotPanel extends JPanel {
    public int itemId;
    public OfferEvent offerEvent;
    private ThinProgressBar progressBar = new ThinProgressBar();
    private JLabel itemName = new JLabel();
    private JLabel itemIcon = new JLabel();
    private JLabel price = new JLabel();
    private JLabel state = new JLabel();
    private JLabel action = new JLabel();
    private JLabel timer = new JLabel();
    private Component verticalGap;
    WikiRequest wikiRequest;
    List<JPanel> panelsToColor;
    boolean hasDrawnStatus = false;
    JPopupMenu popup;
    QuickLookPanel quickLookPanel;
    FlippingPlugin plugin;

    public SlotPanel(FlippingPlugin plugin, Component verticalGap, JPopupMenu popup, QuickLookPanel quickLookPanel) {
        this.plugin = plugin;
        this.popup = popup;
        this.verticalGap = verticalGap;
        this.quickLookPanel = quickLookPanel;
        setVisible(false);
        setLayout(new BorderLayout());
        setBackground(CustomColors.DARK_GRAY);
        setBorder(new CompoundBorder(
            new MatteBorder(2, 2, 2, 2, ColorScheme.DARKER_GRAY_COLOR.darker()),
            new EmptyBorder(10, 10, 0, 10)
        ));
        price.setHorizontalAlignment(SwingConstants.CENTER);
        price.setFont(FontManager.getRunescapeSmallFont());
        price.setBorder(new EmptyBorder(0, 16, 0, 0)); //to center it bc of the 16px magnifying glass icon
        state.setFont(FontManager.getRunescapeSmallFont());
        action.setFont(FontManager.getRunescapeBoldFont());
        action.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        timer.setFont(FontManager.getRunescapeSmallFont());

        progressBar.setForeground(CustomColors.DARK_GRAY);
        progressBar.setMaximumValue(100);
        progressBar.setValue(0);
        progressBar.setMaximumSize(new Dimension(Integer.MAX_VALUE, 10));
        progressBar.setMinimumSize(new Dimension(0, 10));
        progressBar.setPreferredSize(new Dimension(0, 10));
        progressBar.setSize(new Dimension(0, 10));
        //progressBar.setBorder(new EmptyBorder(0, 25, 0, 25));
        progressBar.setBorder(new CompoundBorder(
            new MatteBorder(1, 1, 1, 1, ColorScheme.DARKER_GRAY_COLOR.darker()),
            new EmptyBorder(0, 23, 0, 23)
        ));
        add(itemIcon, BorderLayout.WEST);

        JPanel topPanel = new JPanel(new BorderLayout());
        topPanel.setBorder(new EmptyBorder(0, 0, 10, 0));
        topPanel.setBackground(CustomColors.DARK_GRAY);
        topPanel.add(action, BorderLayout.WEST);
        topPanel.add(timer, BorderLayout.EAST);
        add(topPanel, BorderLayout.NORTH);

        JPanel centerPanel = new JPanel();
        centerPanel.setBackground(CustomColors.DARK_GRAY);
        centerPanel.setLayout(new BoxLayout(centerPanel, BoxLayout.Y_AXIS));
        centerPanel.add(itemName);
        centerPanel.add(Box.createVerticalStrut(3));
        centerPanel.add(state);
        add(centerPanel, BorderLayout.CENTER);

        JPanel bottomPanel = new JPanel();
        bottomPanel.setBorder(new EmptyBorder(10, 5, 5, 5));
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
        bottomPanel.setBackground(CustomColors.DARK_GRAY);
        bottomPanel.add(progressBar);
        bottomPanel.add(Box.createVerticalStrut(10));

        JPanel priceAndMagnifyingGlassPanel = new JPanel(new BorderLayout());
        priceAndMagnifyingGlassPanel.setBackground(CustomColors.DARK_GRAY);

        JLabel magnifyingGlassIcon = new JLabel(Icons.MAGNIFYING_GLASS);
        magnifyingGlassIcon.setVisible(false);
        magnifyingGlassIcon.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                updateQuickLookPanel();
                magnifyingGlassIcon.setIcon(Icons.MAGNIFYING_GLASS_HOVER);
                Point location  = magnifyingGlassIcon.getLocationOnScreen();
                int y = location.y - popup.getHeight();
                popup.setLocation(location.x, y);
                popup.setVisible(true);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                magnifyingGlassIcon.setIcon(Icons.MAGNIFYING_GLASS);
                popup.setVisible(false);
            }
        });

        priceAndMagnifyingGlassPanel.add(price, BorderLayout.CENTER);
        priceAndMagnifyingGlassPanel.add(magnifyingGlassIcon, BorderLayout.EAST);

        bottomPanel.add(priceAndMagnifyingGlassPanel);
        add(bottomPanel, BorderLayout.SOUTH);

        panelsToColor = Arrays.asList(topPanel, centerPanel, bottomPanel, priceAndMagnifyingGlassPanel);

        plugin.getApiAuthHandler().subscribeToPremiumChecking(magnifyingGlassIcon::setVisible);
    }

    public void updateTimer(String timeString) {
        if (offerEvent == null || offerEvent.isCausedByEmptySlot() || timeString == null) {
            timer.setText("");
            return;
        }
        timer.setText(timeString);
    }

    public boolean shouldNotUpdate(OfferEvent newOfferEvent) {
        return offerEvent != null && offerEvent.isDuplicate(newOfferEvent);
    }

    public void onWikiRequest(WikiRequest wikiRequest) {
        this.wikiRequest = wikiRequest;
        drawSlotStatus();
    }

    public void updateQuickLookPanel() {
        if (offerEvent == null || offerEvent.isCausedByEmptySlot() || wikiRequest == null) {
            quickLookPanel.updateDetails(null, null);
            return;
        }
        WikiItemMargins margins = wikiRequest.getData().get(offerEvent.getItemId());

        if (margins == null) {
            quickLookPanel.updateDetails(null, null);
            return;
        }

        SlotPredictedState predictedState = SlotPredictedState.getPredictedState(offerEvent.isBuy(),
            offerEvent.getListedPrice(), margins.getLow(), margins.getHigh());
        SlotInfo slotInfo = new SlotInfo(offerEvent.getSlot(), predictedState, offerEvent.getItemId(),
            offerEvent.getListedPrice(), offerEvent.isBuy());
        quickLookPanel.updateDetails(slotInfo, margins);
    }

    public void drawSlotStatus() {
        if (!plugin.getApiAuthHandler().isPremium()) {
            return;
        }
        if (offerEvent == null || offerEvent.isCausedByEmptySlot() || wikiRequest == null) {
            return;
        }

        WikiItemMargins margins = wikiRequest.getData().get(offerEvent.getItemId());
        if (margins == null) {
            return;
        }

        SlotPredictedState predictedState = SlotPredictedState.getPredictedState(offerEvent.isBuy(),
            offerEvent.getListedPrice(),  margins.getLow(), margins.getHigh());
        if (predictedState == SlotPredictedState.IN_RANGE) {
            setColor(CustomColors.IN_RANGE_SLOTS_TAB);
        } else if (predictedState == SlotPredictedState.OUT_OF_RANGE) {
            setColor(CustomColors.OUT_OF_RANGE_SLOTS_TAB);
        } else if (predictedState == SlotPredictedState.BETTER_THAN_WIKI) {
            setColor(CustomColors.BETTER_THAN_WIKI_SLOTS_TAB);
        }
        hasDrawnStatus = true;
    }

    public void reset() {
        setVisible(false);
        verticalGap.setVisible(false);
        itemId = 0;
        itemIcon.setIcon(null);
        itemName.setText("");
        progressBar.setMaximumValue(0);
        progressBar.setValue(100);
        progressBar.setForeground(CustomColors.DARK_GRAY);
        progressBar.setBackground(CustomColors.DARK_GRAY);
        setColor(CustomColors.DARK_GRAY);
        hasDrawnStatus = false;
    }

    private void setColor(Color color) {
        setBackground(color);
        panelsToColor.forEach(p -> p.setBackground(color));
    }

    public void update(BufferedImage itemImage, String name, OfferEvent newOfferEvent) {
        setVisible(true);
        verticalGap.setVisible(true);
        itemId = newOfferEvent.getItemId();
        if (name != null) {
            itemName.setText(name);
        }
        if (itemImage != null) {
            itemIcon.setIcon(new ImageIcon(itemImage));
        }
        String stateText = QuantityFormatter.quantityToRSDecimalStack(newOfferEvent.getCurrentQuantityInTrade()) + " / "
            + QuantityFormatter.quantityToRSDecimalStack(newOfferEvent.getTotalQuantityInTrade());

        action.setText(newOfferEvent.isBuy() ? "Buy" : "Sell");
        state.setText(stateText);
        price.setText(QuantityFormatter.formatNumber(newOfferEvent.getListedPrice()) + " coins");
        progressBar.setMaximumValue(newOfferEvent.getTotalQuantityInTrade());
        progressBar.setValue(newOfferEvent.getCurrentQuantityInTrade());
        if (newOfferEvent.isCancelled()) {
            progressBar.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
        } else if (newOfferEvent.isComplete()) {
            progressBar.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        } else {
            progressBar.setForeground(ColorScheme.PROGRESS_INPROGRESS_COLOR);
        }

        //when the slot panel gets an offer event, either because its the first one or because a new offer was created
        //we should draw the slot status immediately if we have a wiki request on hand rather than waiting for
        //drawSlotStatus to trigger on the next wiki fetch.
        if (!hasDrawnStatus) {
            drawSlotStatus();
        }
    }
}

package com.flippingutilities.ui.slots;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.uiutilities.QuickLookPanel;
import com.flippingutilities.utilities.WikiRequest;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;

/**
 * Container that holds the SlotPanels which contain the visual representation of the ge slots.
 * The SlotPanels are only created once. Their visibility and contents are changed as updates come in.
 */
@Slf4j
public class SlotsPanel extends JPanel {
    FlippingPlugin plugin;
    private List<SlotPanel> slotPanels;
    private ItemManager itemManager;
    JLabel statusText = new JLabel();
    JPopupMenu popup = new JPopupMenu();
    QuickLookPanel quickLookPanel = new QuickLookPanel();

    public SlotsPanel(FlippingPlugin plugin, ItemManager im) {
        popup.add(quickLookPanel);
        this.plugin = plugin;
        itemManager = im;
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        slotPanels = new ArrayList<>();
        JPanel slotPanelsContainer = new JPanel();
        slotPanelsContainer.setLayout(new BoxLayout(slotPanelsContainer, BoxLayout.Y_AXIS));

        for (int i = 0; i < 8; i++) {
            Component verticalGap = Box.createVerticalStrut(10);
            SlotPanel slotPanel = new SlotPanel(plugin, verticalGap, popup, quickLookPanel);
            slotPanels.add(slotPanel);
            slotPanelsContainer.add(slotPanel);
            slotPanelsContainer.add(verticalGap);
        }

        JPanel wrapper = new JPanel(new BorderLayout());
        wrapper.setBorder(new EmptyBorder(10,10,10,10));
        wrapper.add(slotPanelsContainer, BorderLayout.NORTH);

        JScrollPane jScrollPane = new JScrollPane(wrapper);
        jScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(5, 0));

        statusText.setAlignmentX(JLabel.CENTER_ALIGNMENT);
        statusText.setBorder(new EmptyBorder(20,0,0,0));
        statusText.setFont(FontManager.getRunescapeSmallFont());
        statusText.setText("No currently active slots");
        add(statusText, BorderLayout.NORTH);
        add(jScrollPane, BorderLayout.CENTER);
    }

    public void updateTimerDisplays(int slotIndex, String timeString) {
        slotPanels.get(slotIndex).updateTimer(timeString);
    }

    public void onWikiRequest(WikiRequest wikiRequest) {
        for (SlotPanel slotPanel: slotPanels) {
            slotPanel.onWikiRequest(wikiRequest);
        }
    }

    public void update(OfferEvent newOfferEvent) {
        int slot = newOfferEvent.getSlot();
        SlotPanel slotPanel = slotPanels.get(slot);
        //only update if there is some actual change in the slot
        if (slotPanel.shouldNotUpdate(newOfferEvent)) {
            return;
        }

        slotPanel.offerEvent = newOfferEvent;

        if (newOfferEvent.isCausedByEmptySlot()) {
            slotPanel.reset();
        }
        //no need to create image if slot still has same item in it
        else if (slotPanel.itemId == newOfferEvent.getItemId()) {
            slotPanel.update(null, null, newOfferEvent);
        } else {
            ItemComposition itemComposition = itemManager.getItemComposition(newOfferEvent.getItemId());
            boolean shouldStack = itemComposition.isStackable() || newOfferEvent.getTotalQuantityInTrade() > 1;
            BufferedImage itemImage = itemManager.getImage(newOfferEvent.getItemId(), newOfferEvent.getTotalQuantityInTrade(), shouldStack);
            String itemName = itemComposition.getName();
            slotPanel.update(itemImage, itemName, newOfferEvent);
        }
        boolean activeSlots = slotPanels.stream().anyMatch(s -> s.itemId != 0);
        statusText.setVisible(!activeSlots);
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.widgets;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.TimeFormatters;
import com.flippingutilities.ui.uiutilities.WidgetConstants;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.ColorUtil;

import java.awt.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;

@Slf4j
public class SlotActivityTimer
{
	//Spacing between the slot state text and the timer
	private static final String BUY_SPACER = "          ";
	private static final String SELL_SPACER = "          ";
	private static final int FONT_ID = 495;

	//The slot that this timer object embeds to
	@Getter
	private transient Widget slotWidget;
	//The widget of the text at the top of the offer slot
	private transient Widget slotStateWidget;
	//The state can be one of "Sell", "Buy" and "Empty", depending on the slot's offer state
	private transient String slotStateString;

	@Setter
	private transient FlippingPlugin plugin;
	@Setter
	private transient Client client;

	//Index of the slot widget from left to right, top to bottom. (0-7)
	@Getter
	private int slotIndex;
	private Instant lastUpdate;
	public Instant tradeStartTime;
	public OfferEvent currentOffer;
	//is true when we get an offer from when the account was logged out which means we don't know when it occurred.
	public boolean offerOccurredAtUnknownTime;

	public SlotActivityTimer(FlippingPlugin plugin, Client client, int slotIndex)
	{
		this.plugin = plugin;
		this.client = client;
		this.slotIndex = slotIndex;
	}

	public void setWidget(Widget slotWidget)
	{
		this.slotWidget = slotWidget;
		slotStateWidget = slotWidget.getChild(16);
		slotStateString = slotStateWidget.getText();
	}

	public void reset() {
		currentOffer = null;
		lastUpdate = null;
		tradeStartTime = null;
		offerOccurredAtUnknownTime = true;
	}

	public void setCurrentOffer(OfferEvent offer)
	{
		//is only given these types of offer events if they weren't empty updates
		//and there was no last offer or there was a last offer but this offer is not a dup
		if (offer.isBeforeLogin()) {
			offerOccurredAtUnknownTime = true;
			return;
		}

		offerOccurredAtUnknownTime = false;

		currentOffer = offer;
		lastUpdate = Instant.now();

		if (currentOffer.isStartOfOffer())
		{
			tradeStartTime = Instant.now();
		}
	}

	/**
	 * Updates the slot trade activity timer. It reassigns all widget field variables,
	 * as they sometimes get unloaded and therefore won't point to the right widget objects.
	 */
	public void updateTimerDisplay()
	{
		if (slotWidget == null)
		{
			return;
		}

		if (slotWidget.isHidden() || plugin.getCurrentlyLoggedInAccount() == null || currentOffer == null || offerOccurredAtUnknownTime || tradeStartTime == null)
		{
			slotStateWidget.setFontId(496);
			slotStateWidget.setXTextAlignment(1);
			return;
		}


		//Reload offerSlot widget in case it got unloaded previously. We need to do this bc the old object we have
		//doesn't respond to changes (like setText) after a ge slot redraw or some other script that fires.
		Widget offerSlot = client.getWidget(InterfaceID.GRAND_EXCHANGE, WidgetConstants.SLOT_CONTAINER).getStaticChildren()[slotIndex + 1];

		//Ideally this shouldn't be triggered, but just in case.
		if (offerSlot == null)
		{
			return;
		}

		//Reassign widgets
		slotWidget = offerSlot;
		slotStateWidget = slotWidget.getChild(16);
		slotStateString = slotStateWidget.getText();

		if (!isSlotFilled())
		{
			//should i set current offer to null?
			//The slot hasn't been filled with an offer, so default to Jagex format.
			slotStateWidget.setText("Empty");
			slotStateWidget.setFontId(496);
			slotStateWidget.setXTextAlignment(1);
			return;
		}

		setText(createFormattedTimeString());
		slotStateWidget.setFontId(FONT_ID);
		slotStateWidget.setXTextAlignment(0);
	}

	/**
	 * Appends the offer state text widget with the up-to-date time string.
	 *
	 * @param timeString Formatted timer string.
	 */
	private void setText(String timeString)
	{
		String spacer;
		Color stateTextColor;

		//switching comps, going on mobile, etc can leave a stale offer in there, so we have to verify using the actual
		//offer from the client.
		GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
		GrandExchangeOffer clientOffer = offers[slotIndex];
		if (clientOffer.getState() == GrandExchangeOfferState.BOUGHT || clientOffer.getState() == GrandExchangeOfferState.BUYING || clientOffer.getState() == GrandExchangeOfferState.CANCELLED_BUY) {
			slotStateString = "Buy";
			spacer = BUY_SPACER;
			stateTextColor = plugin.getConfig().slotTimerBuyColor();
		}
		else
		{
			slotStateString = "Sell";
			spacer = SELL_SPACER;
			stateTextColor = plugin.getConfig().slotTimerSellColor();
		}

		Color timeColor = isSlotStagnant() ? CustomColors.OUTDATED_COLOR : Color.WHITE;

		if (clientOffer.getState() == GrandExchangeOfferState.CANCELLED_BUY || clientOffer.getState() == GrandExchangeOfferState.CANCELLED_SELL || clientOffer.getState() == GrandExchangeOfferState.BOUGHT || clientOffer.getState() == GrandExchangeOfferState.SOLD)
		{
			//Override to completion color
			timeColor = new Color(0, 180, 0);
		}

		if (timeString.length() > 9)
		{
			//Make sure we don't overflow the text
			timeString = "   --:--:--";
		}

		slotStateWidget.setText("  <html>" + ColorUtil.wrapWithColorTag(slotStateString, stateTextColor) + spacer + ColorUtil.wrapWithColorTag(timeString, timeColor) + "</html>");
	}

	/**
	 * Resets the offer state text to default Jagex format.
	 */
	public void resetToDefault()
	{
		try {
			if (!isSlotFilled())
			{
				slotStateWidget.setText("Empty");
			}
			else if (currentOffer.isBuy())
			{
				slotStateWidget.setText("Buy");
			}
			else if (!currentOffer.isBuy())
			{
				slotStateWidget.setText("Sell");
			}
			slotStateWidget.setFontId(496);
			slotStateWidget.setXTextAlignment(1);
		}
		catch (NullPointerException e) {
			log.info("npe when resetting slot visuals. This is ok");
		}
	}

	/**
	 * Finds whether the slot is filled with an offer or if it's empty.
	 *
	 * @return Returns true if the slot is filled and false if it's empty.
	 */
	private boolean isSlotFilled()
	{
		GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
		return offers[slotIndex].getItemId() != 0;
	}

	/**
	 * Returns whether the slot contains a stagnant offer as defined by the user config.
	 * Has to be run after createFormattedTimeString() else the timerBase won't be sufficiently up to date.
	 */
	private boolean isSlotStagnant()
	{
		return lastUpdate.isBefore(Instant.now().minus(plugin.getConfig().tradeStagnationTime(), ChronoUnit.MINUTES));
	}


	public String createFormattedTimeString()
	{
		if (currentOffer == null || tradeStartTime == null || lastUpdate == null || offerOccurredAtUnknownTime) {
			return null;
		}

		if (currentOffer.isComplete())
		{
			return TimeFormatters.formatDuration(tradeStartTime, lastUpdate);
		}

		else
		{
			return TimeFormatters.formatDuration(lastUpdate, Instant.now());
		}
	}
}
package com.flippingutilities.ui.widgets;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.ui.uiutilities.*;
import com.flippingutilities.utilities.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.FontID;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.*;
import javax.swing.*;
import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * This class is responsible for enhancing slots in the ge interface. It
 * 1. adds color to slots to mark the offers as competitive or not
 * 2. adds a widget that shows some preview info on the competitiveness of the offer
 * <p>
 * <p>
 * This class requires two pieces/types of data for drawing on/enhancing the slots which are change frequently:
 * 1. wiki margins
 * 2. actual slot widgets
 * <p>
 * It is fed this data everytime it changes by the plugin (see onWikiRequest and setSlotWidgets). Everytime
 * it is fed new data, it builds a representation of what it should draw (see createSlotRepresentation),
 * and then draws it on the slot (see drawWrapper)
 *
 * Also note that this doesn't make requests to our api for the predicted slot state, it just uses the local slots.
 */
@Slf4j
public class SlotStateDrawer {
    FlippingPlugin plugin;
    WikiRequest wikiRequest;
    Widget[] slotWidgets;
    Map<Integer, Widget> slotIdxToQuickLookWidget = new HashMap<>();
    JPopupMenu popup = new JPopupMenu();
    QuickLookPanel quickLookPanel = new QuickLookPanel();
    List<Optional<SlotInfo>> slotInfos = new ArrayList<>();

    public SlotStateDrawer(FlippingPlugin plugin) {
        this.plugin = plugin;
        popup.add(quickLookPanel);
    }

    public void onWikiRequest(WikiRequest wikiRequest) {
        this.wikiRequest = wikiRequest;
        drawWrapper();
    }

    public void setSlotWidgets(Widget[] slotWidgets) {
        if (slotWidgets == null) {
            return;
        }
        this.slotWidgets = slotWidgets;
        drawWrapper();
    }

    public void hideQuickLookPanel() {
        popup.setVisible(false);
    }

    /**
     * Thin wrapper around draw to decide if drawing should take place.
     */
    public void drawWrapper() {
        if (
            slotWidgets == null ||
                plugin.getCurrentlyLoggedInAccount() == null ||
                !plugin.getApiAuthHandler().isPremium() ||
                !plugin.shouldEnhanceSlots()
        ) {
            return;
        }
        this.slotInfos = createSlotRepresentation();
        plugin.getClientThread().invokeLater(() -> draw(slotInfos));
    }

    /**
     * Draws the enhancements on the slot
     */
    private void draw(List<Optional<SlotInfo>> slots) {
        for (int i = 0; i < slots.size(); i++) {
            Optional<SlotInfo> slot = slots.get(i);
            Widget slotWidget = slotWidgets[i + 1];
            if (!slot.isPresent()) {
                resetSlot(i, slotWidget);
            } else {
                drawOnSlot(slot.get(), slotWidget);
            }
        }
    }

    public void resetAllSlots() {
        if (slotWidgets == null) {
            return;
        }
        for (int i = 0; i < 8; i++) {
            Widget slotWidget = slotWidgets[i + 1];
            resetSlot(i, slotWidget);
        }
    }

    /**
     * Hides all the slot enhancements that were previously drawn on the slot. This is
     * done when the slot was once populated with an offer but is now empty.
     */
    private void resetSlot(int slotIdx, Widget slotWidget) {
        Map<Integer, Integer> spriteIdMap = GeSpriteLoader.CHILDREN_IDX_TO_DEFAULT_SPRITE_ID;
        GeSpriteLoader.DYNAMIC_CHILDREN_IDXS.forEach(idx -> {
            Widget child = slotWidget.getChild(idx);
            int spriteId = spriteIdMap.get(idx);
            if (child != null) {
                child.setSpriteId(spriteId);
            }
        });

        Widget quickLookWidget = slotIdxToQuickLookWidget.get(slotIdx);
        if (quickLookWidget != null) {
            quickLookWidget.setHidden(true);
            slotIdxToQuickLookWidget.remove(slotIdx);
        }
    }

    private void drawOnSlot(SlotInfo slot, Widget slotWidget) {
        if (slotWidget.isHidden()) {
            return;
        }
        Map<Integer, Integer> spriteMap = GeSpriteLoader.CHILDREN_IDX_TO_RED_SPRITE_ID;
        if (slot.getPredictedState() == SlotPredictedState.IN_RANGE) {
            spriteMap = GeSpriteLoader.CHILDREN_IDX_TO_BLUE_SPRITE_ID;
        } else if (slot.getPredictedState() == SlotPredictedState.OUT_OF_RANGE) {
            spriteMap = GeSpriteLoader.CHILDREN_IDX_TO_RED_SPRITE_ID;
        } else if (slot.getPredictedState() == SlotPredictedState.BETTER_THAN_WIKI) {
            spriteMap = GeSpriteLoader.CHILDREN_IDX_TO_GREEN_SPRITE_ID;
        }

        Map<Integer, Integer> finalSpriteMap = spriteMap;
        GeSpriteLoader.DYNAMIC_CHILDREN_IDXS.forEach(idx -> {
            Widget child = slotWidget.getChild(idx);
            int spriteId = finalSpriteMap.get(idx);
            child.setSpriteId(spriteId);
        });

        addQuicklookWidget(slotWidget, slot);
    }

    /**
     * This is the image widget (the magnifying glass widget) that a user can hover over to
     * see some quick details about the competitiveness of their offer.
     */
    private void addQuicklookWidget(Widget slotWidget, SlotInfo slot) {
        Widget existingQuickLookWidget = slotIdxToQuickLookWidget.get(slot.getIndex());
        if (existingQuickLookWidget == null || !isWidgetStillAttached(existingQuickLookWidget)) {
            Widget quicklookWidget = createQuicklookWidget(slotWidget, slot);
            slotIdxToQuickLookWidget.put(slot.getIndex(), quicklookWidget);
        } else {
            existingQuickLookWidget.setHidden(false);
        }
    }

    private Widget createQuicklookWidget(Widget slotWidget, SlotInfo slot) {
        Widget quickLookWidget = slotWidget.createChild(-1, WidgetType.GRAPHIC);
        quickLookWidget.setFontId(FontID.PLAIN_11);
        quickLookWidget.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
        quickLookWidget.setOriginalX(90);
        quickLookWidget.setOriginalY(52);
        quickLookWidget.setSpriteId(SpriteID.BANK_SEARCH);
        quickLookWidget.setWidthMode(WidgetSizeMode.ABSOLUTE);
        quickLookWidget.setOriginalHeight(22);
        quickLookWidget.setOriginalWidth(22);
        quickLookWidget.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
        quickLookWidget.setXTextAlignment(WidgetTextAlignment.LEFT);
        quickLookWidget.setTextShadowed(true);
        quickLookWidget.setHasListener(true);

        quickLookWidget.setOnMouseOverListener((JavaScriptCallback) ev -> {
            SwingUtilities.invokeLater(() -> {
                if (this.wikiRequest == null) {
                    quickLookPanel.updateDetails(null, null);
                    return;
                }
                Optional<SlotInfo> slotInfo = slotInfos.get(slot.getIndex());
                if (!slotInfo.isPresent()) {
                    quickLookPanel.updateDetails(null, null);
                    return;
                }

                int itemId = slotInfo.get().getItemId();
                WikiItemMargins margins = this.wikiRequest.getData().get(itemId);
                PointerInfo a = MouseInfo.getPointerInfo();
                Point p = a.getLocation();
                quickLookPanel.updateDetails(slotInfo.get(), margins);
                popup.pack();
                popup.setLocation(p.x + 25, p.y);
                popup.setVisible(true);
            });
        });

        quickLookWidget.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
            SwingUtilities.invokeLater(() -> {
                popup.setVisible(false);
            });
        });

        quickLookWidget.revalidate();
        return quickLookWidget;
    }

    /**
     * Determines if the widget is still actually on the screen. This is useful for deciding
     * whether we should reuse the old widget, or create a new one.
     */
    private boolean isWidgetStillAttached(Widget widget) {
        Widget parent = widget.getParent();
        Widget[] siblings = parent.getDynamicChildren();
        return widget.getIndex() < siblings.length && siblings[widget.getIndex()] != null;
    }

    /**
     * Builds a representation of the slots to draw
     */
    private List<Optional<SlotInfo>> createSlotRepresentation() {
        List<Optional<SlotInfo>> slots = new ArrayList<>();
        GrandExchangeOffer[] currentOffers = plugin.getClient().getGrandExchangeOffers();

        for (int i = 0; i < currentOffers.length; i++) {
            GrandExchangeOffer localSlot = currentOffers[i];

            if (localSlot.getState() == GrandExchangeOfferState.EMPTY) {
                slots.add(Optional.empty());
                continue;
            }

            slots.add(clientGeOfferToSlotInfo(i, localSlot));
        }
        return slots;
    }

    private Optional<SlotInfo> clientGeOfferToSlotInfo(int index, GrandExchangeOffer offer) {
        if (wikiRequest == null) {
            return Optional.empty();
        }

        int itemId = offer.getItemId();
        WikiItemMargins margins = this.wikiRequest.getData().get(itemId);
        if (margins == null) {
            return Optional.empty();
        }

        int listedPrice = offer.getPrice();
        boolean isBuy = offer.getState() == GrandExchangeOfferState.BUYING;
        SlotPredictedState predictedState = SlotPredictedState.getPredictedState(isBuy, listedPrice, margins.getLow(), margins.getHigh());

        return Optional.of(new SlotInfo(index, predictedState, itemId, listedPrice, isBuy));
    }
}
/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.widgets;

import com.flippingutilities.ui.uiutilities.Icons;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.VarClientStr;
import net.runelite.api.widgets.*;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;

public class OfferEditor {
    private final Client client;
    private Widget bottomText;
    private Widget nonWikiText;
    private Widget wikiText;

    public OfferEditor(Widget parent, Client client) {
        this.client = client;

        if (parent == null) {
            return;
        }

        bottomText = parent.createChild(-1, WidgetType.TEXT);
        nonWikiText = parent.createChild(-1, WidgetType.TEXT);
        wikiText = parent.createChild(-1, WidgetType.TEXT);

        prepareTextWidget(nonWikiText, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 5, 10);
        prepareTextWidget(wikiText, WidgetTextAlignment.LEFT, WidgetPositionMode.ABSOLUTE_TOP, 20, 10);
        prepareTextWidget(bottomText, WidgetTextAlignment.CENTER, WidgetPositionMode.ABSOLUTE_BOTTOM, 5, 0);
    }


    private void prepareTextWidget(Widget widget, int xAlignment, int yMode, int yOffset, int xOffset) {
        widget.setTextColor(0x800000);
        widget.setFontId(FontID.VERDANA_11_BOLD);
        widget.setYPositionMode(yMode);
        widget.setOriginalX(xOffset);
        widget.setOriginalY(yOffset);
        widget.setOriginalHeight(20);
        widget.setXTextAlignment(xAlignment);
        widget.setWidthMode(WidgetSizeMode.MINUS);
        widget.setHasListener(true);
        widget.setOnMouseRepeatListener((JavaScriptCallback) ev -> widget.setTextColor(0xFFFFFF));
        widget.setOnMouseLeaveListener((JavaScriptCallback) ev -> widget.setTextColor(0x800000));
        widget.revalidate();
    }

    public void showQuantityWidgets(int quantity) {
        bottomText.setText("OR click this to use the price editor hotkeys for more flexibility!");
        bottomText.setAction(1, "pic");
        bottomText.setOnOpListener((JavaScriptCallback) ev -> {
            SwingUtilities.invokeLater(() -> {
                JOptionPane.showMessageDialog(null, Icons.QUANTITY_EDITOR_PIC);
            });
        });

        nonWikiText.setText("set to remaining GE limit: " + quantity);
        nonWikiText.setAction(1, "Set quantity");
        nonWikiText.setOnOpListener((JavaScriptCallback) ev ->
        {
            client.getWidget(ComponentID.CHATBOX_FULL_INPUT).setText(quantity + "*");
            client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(quantity));
        });
    }

    public void showInstaSellPrices(int instaSellPrice, int wikiInstaSellPrice) {
        bottomText.setText("OR click this to use the price editor hotkeys for more flexibility!");
        bottomText.setAction(1, "pic");
        bottomText.setOnOpListener((JavaScriptCallback) ev -> {
            SwingUtilities.invokeLater(() -> {
                JOptionPane.showMessageDialog(null, Icons.PRICE_EDITOR_PIC);
            });
        });

        if (instaSellPrice != 0) {
            nonWikiText.setText("set to your insta sell: " + String.format("%,d", instaSellPrice) + " gp");
            nonWikiText.setAction(0, "Set price");
            nonWikiText.setOnOpListener((JavaScriptCallback) ev ->
            {
                client.getWidget(ComponentID.CHATBOX_FULL_INPUT).setText(instaSellPrice + "*");
                client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(instaSellPrice));
            });
        } else {
            nonWikiText.setText("no sell tracked");
        }

        if (wikiInstaSellPrice != 0) {
            wikiText.setText("set to wiki insta sell: " + String.format("%,d", wikiInstaSellPrice) + " gp");
            wikiText.setAction(1, "Set wiki price");
            wikiText.setOnOpListener((JavaScriptCallback) ev ->
            {
                client.getWidget(ComponentID.CHATBOX_FULL_INPUT).setText(wikiInstaSellPrice + "*");
                client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(wikiInstaSellPrice));
            });
        } else {
            wikiText.setText("No wiki data");
        }
    }

    public void showInstaBuyPrices(int instaBuyPrice, int wikiInstaBuyPrice) {
        bottomText.setText("OR click this to use the price editor hotkeys for more flexibility!");
        bottomText.setAction(1, "pic");
        bottomText.setOnOpListener((JavaScriptCallback) ev -> {
            SwingUtilities.invokeLater(() -> {
                JOptionPane.showMessageDialog(null, Icons.PRICE_EDITOR_PIC);
            });
        });

        if (instaBuyPrice != 0) {
            nonWikiText.setText("set to your insta buy: " + String.format("%,d", instaBuyPrice) + " gp");
            nonWikiText.setAction(0, "Set price");
            nonWikiText.setOnOpListener((JavaScriptCallback) ev ->
            {
                client.getWidget(ComponentID.CHATBOX_FULL_INPUT).setText(instaBuyPrice + "*");
                client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(instaBuyPrice));
            });
        } else {
            nonWikiText.setText("no buy tracked");
        }

        if (wikiInstaBuyPrice != 0) {
            wikiText.setText("set to wiki insta buy: " + String.format("%,d", wikiInstaBuyPrice) + " gp");
            wikiText.setAction(1, "Set wiki price");
            wikiText.setOnOpListener((JavaScriptCallback) ev ->
            {
                client.getWidget(ComponentID.CHATBOX_FULL_INPUT).setText(wikiInstaBuyPrice + "*");
                client.setVarcStrValue(VarClientStr.INPUT_TEXT, String.valueOf(wikiInstaBuyPrice));
            });
        } else {
            wikiText.setText("No wiki data");
        }
    }

}
package com.flippingutilities.ui.offereditor;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.Option;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.utilities.InvalidOptionException;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ColorUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.NumberFormat;
import java.util.Locale;

@Slf4j
public class OptionPanel extends JPanel {
    private FlippingPlugin plugin;
    @Getter
    private Option option;
    private JLabel resultingValueLabel;
    private JLabel dotIcon;
    private boolean isHighlighted;
    private Icon lastIcon;

    public OptionPanel(Option option, FlippingPlugin plugin) {
        this.option = option;
        this.plugin = plugin;

        setLayout(new BorderLayout());
        setBackground(CustomColors.DARK_GRAY);
        setBorder(new EmptyBorder(5, 0, 5, 5));

        resultingValueLabel = new JLabel("", JLabel.CENTER);
        resultingValueLabel.setFont(FontManager.getRunescapeSmallFont());

        dotIcon = createDotIcon();

        add(resultingValueLabel, BorderLayout.SOUTH);
        add(createBodyPanel(), BorderLayout.CENTER);
        add(dotIcon, BorderLayout.WEST);
        setResultingValue();
    }

    public JPanel createBodyPanel() {
        JPanel body = new JPanel();
        body.setBackground(CustomColors.DARK_GRAY);

        JTextField keyInputField = new JTextField(2);
        //keyInputField.setPreferredSize(new Dimension(30, 25));
        keyInputField.setText(option.getKey());
        keyInputField.addActionListener(e -> {
            plugin.markAccountTradesAsHavingChanged(FlippingPlugin.ACCOUNT_WIDE);
            option.setKey(keyInputField.getText());
            setResultingValue();
        });
        keyInputField.setToolTipText("Press enter after inputting a key to save your changes");

        JComboBox propertiesSelector = new JComboBox(option.isQuantityOption()? Option.QUANTITY_OPTIONS: Option.PRICE_OPTIONS);
        propertiesSelector.setPreferredSize(new Dimension(88, 25));
        propertiesSelector.setSelectedItem(option.getProperty());
        propertiesSelector.addActionListener(e -> {
            if (propertiesSelector.getSelectedItem() != null) {
                plugin.markAccountTradesAsHavingChanged(FlippingPlugin.ACCOUNT_WIDE);
                option.setProperty((String) propertiesSelector.getSelectedItem());
                setResultingValue();
            }
        });

        JTextField optionalEditor = new JTextField(5);
        //optionalEditor.setPreferredSize(new Dimension(30, 25));
        optionalEditor.setText(option.getModifier());
        optionalEditor.addActionListener(e -> {
            plugin.markAccountTradesAsHavingChanged(FlippingPlugin.ACCOUNT_WIDE);
            option.setModifier(optionalEditor.getText());
            setResultingValue();
        });
        optionalEditor.setToolTipText("press enter after inputting something to save your changes");

        body.add(keyInputField);
        body.add(propertiesSelector);
        body.add(optionalEditor);

        return body;
    }

    private String createResultingValueText(int resultingValue) {
        String keyText = String.format("<span style='color:%s;'>%s</span>",ColorUtil.colorToHexCode(ColorScheme.GRAND_EXCHANGE_ALCH), option.getKey());
        String typeText = option.isQuantityOption()? "quantity":"price";
        String value = NumberFormat.getInstance(Locale.getDefault()).format(resultingValue);
        String valueText = String.format("<span style='color:%s;'>%s</span>", ColorUtil.colorToHexCode(ColorScheme.GRAND_EXCHANGE_PRICE), value);
        return String.format("<html><body width='170' style='text-align:center;'>Press %s to set %s to %s</body></html>",keyText,typeText,valueText);
    }

    private JLabel createDotIcon() {
        dotIcon = new JLabel(Icons.GRAY_DOT);
        lastIcon = dotIcon.getIcon();
        dotIcon.setBorder(new EmptyBorder(8, 12, 0, 0));
        dotIcon.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (dotIcon.getIcon().equals(Icons.DELETE_ICON)) {
                    plugin.getFlippingPanel().getOfferEditorContainerPanel().deleteOption(option);
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                lastIcon = dotIcon.getIcon();
                dotIcon.setIcon(Icons.DELETE_ICON);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                dotIcon.setIcon(lastIcon);
            }
        });
        return dotIcon;
    }

    private void setResultingValue() {
        plugin.getClientThread().invokeLater(() -> {
            String errorMessage = null;
            int val = 0;
            try {
                val = plugin.calculateOptionValue(option);
            } catch (InvalidOptionException e) {
                errorMessage = e.getMessage();
            }
            String finalErrorMessage = errorMessage;
            int finalVal = val;
            SwingUtilities.invokeLater(() -> {
                dotIcon.setIcon(Icons.GRAY_DOT);
                if (finalErrorMessage != null) {
                    showError(finalErrorMessage);
                } else {
                    resultingValueLabel.setText(createResultingValueText(finalVal));
                }
                revalidate();
                repaint();
            });
        });
    }

    private void showError(String msg) {
        String color = ColorUtil.colorToHexCode(CustomColors.TOMATO);
        resultingValueLabel.setText(String.format("<html><body width='170'style='text-align:center;color:%s'>%s</body></html>", color,msg));
        dotIcon.setIcon(Icons.RED_DOT);
    }

    public void highlight() {
        isHighlighted = true;
        dotIcon.setIcon(Icons.GREEN_DOT);
    }

    public void deHighlight() {
        if (isHighlighted) {
            dotIcon.setIcon(Icons.GRAY_DOT);
            isHighlighted = false;
        }
    }
}

package com.flippingutilities.ui.offereditor;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.Option;

import java.util.List;
import java.util.stream.Collectors;

public class QuantityEditorPanel extends AbstractOfferEditorPanel{
    public QuantityEditorPanel(FlippingPlugin plugin) {
        super(plugin);
    }

    @Override
    public List<Option> getOptions() {
        return plugin.getDataHandler().viewAccountWideData().getOptions().stream().filter(option -> option.isQuantityOption()).collect(Collectors.toList());
    }

    @Override
    public void addOptionPanel() {
        plugin.getDataHandler().getAccountWideData().getOptions().add(0,Option.defaultQuantityOption());
        rebuild(getOptions());
    }

    @Override
    public void onTemplateClicked() {
        List<Option> options = plugin.getDataHandler().getAccountWideData().getOptions();
        options.add(new Option("p", Option.GE_LIMIT, "+0", true));
        options.add(new Option("l", Option.REMAINING_LIMIT, "+0", true));
        options.add(new Option("o", Option.CASHSTACK, "+0", true));
    }
}

package com.flippingutilities.ui.offereditor;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.Option;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.FastTabGroup;
import com.flippingutilities.ui.uiutilities.Icons;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.materialtabs.MaterialTab;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class OfferEditorContainerPanel extends JPanel {
    public static final String QUANTITY_EDITOR = "quantity";
    public static final String PRICE_EDITOR = "price";
    public AbstractOfferEditorPanel quantityEditorPanel;
    public AbstractOfferEditorPanel priceEditorPanel;
    FastTabGroup tabGroup;
    MaterialTab quantityEditorTab;
    MaterialTab priceEditorTab;

    public OfferEditorContainerPanel(FlippingPlugin plugin) {
        setLayout(new BorderLayout());
        setBorder(new CompoundBorder(
                new EmptyBorder(0,0,0,0),
                new MatteBorder(0, 0, 5, 5, ColorScheme.DARKER_GRAY_COLOR.darker())));
        JPanel mainDisplay = new JPanel();

        quantityEditorPanel = new QuantityEditorPanel(plugin);
        priceEditorPanel = new PriceEditorPanel(plugin);

        add(createTitlePanel(mainDisplay), BorderLayout.NORTH);
        add(mainDisplay, BorderLayout.CENTER);
    }

    private JPanel createTitlePanel(JPanel mainDisplay) {
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBorder(new EmptyBorder(5,0,5,0));
        titlePanel.setBackground(CustomColors.DARK_GRAY);

        tabGroup = new FastTabGroup(mainDisplay);
        quantityEditorTab = new MaterialTab(QUANTITY_EDITOR, tabGroup, quantityEditorPanel);
        priceEditorTab = new MaterialTab(PRICE_EDITOR, tabGroup, priceEditorPanel);
        tabGroup.addTab(quantityEditorTab);
        tabGroup.addTab(priceEditorTab);

        JLabel plusIconLabel = new JLabel(Icons.PLUS_ICON);
        plusIconLabel.setBorder(new EmptyBorder(0,0,0,8));
        plusIconLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                addOptionPanel();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                plusIconLabel.setIcon(Icons.PLUS_ICON_OFF);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                plusIconLabel.setIcon(Icons.PLUS_ICON);
            }
        });

        JLabel helpIconLabel = new JLabel(Icons.HELP);
        helpIconLabel.setBorder(new EmptyBorder(0,8,0,0));
        helpIconLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                JOptionPane.showMessageDialog(helpIconLabel, createHelpText());
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                helpIconLabel.setIcon(Icons.HELP_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                helpIconLabel.setIcon(Icons.HELP);

            }
        });

        titlePanel.add(tabGroup, BorderLayout.CENTER);
        titlePanel.add(helpIconLabel, BorderLayout.WEST);
        titlePanel.add(plusIconLabel, BorderLayout.EAST);
        return titlePanel;
    }

    private void addOptionPanel() {
        AbstractOfferEditorPanel editorPanel = (AbstractOfferEditorPanel) tabGroup.getCurrentlySelectedTab();
        editorPanel.addOptionPanel();
        revalidate();
        repaint();
    }

    private String createHelpText() {
        return "<html><body width='500'>"
                + "<h1> What is the quantity editor?</h1>"
                + "The quantity editor helps you input quantities much faster when buying items. It does so by allowing you to map a key to a certain value. This mapping is referred to as an Option."
                + "<h1> Options </h1>"
                + "As stated above, options are the term for this key to value mapping.<br><br>"
                + "Options have three inputs: The key you press to trigger the option, the property the option's value is based on, and an optional" +
                " modifier that will change the value however you want."
                + "<h2> Properties</h2>"
                + "Properties refer to the text in the dropdown box of an option<br>"
                + "<ul> <li> ge limit: selecting this will make the option's value dependent on the ge limit of the item</li>"
                + "<li> rem limit: selecting this will make the option's value dependent on the remaining ge limit of the item </li>"
                + "<li> cashstack: selecting this will make the option's value the max amount of items you can buy with the cash in your inventory </li></ul>"
                + "<h2> Modifers </h2>"
                + "Modifers are the text in the third box (last box) of an option."
                + " Modifiers are any of these symbols +,-,* followed by a positive whole number. For example, all of these are valid: +0, +10, *2, -15, etc<br><br>"
                + "Once you input a modifier, press enter to save it"
                + "<h1> Getting Started! </h1>"
                + "Press the plus button to create an option<br><br>"
                + "Input a key into the first box and press enter to save the key<br><br>"
                + "Change the default property in the dropdown box if you want to<br><br>"
                + "Add an additional modifier if you are not satisfied with the option's value<br><br>"
                + "Now, instead of typing a quantity for an item when you are buying it, just press the key associated with the option!<br><br>"
                + "You can create as many options as you want and you can also edit existing options by changing their keys, properties, or modifiers";
    }

    public boolean currentlyViewingQuantityEditor() {
        return tabGroup.getLastSelectedTab().equals(QUANTITY_EDITOR);
    }

    public void highlightPressedOption(String key) {
        AbstractOfferEditorPanel editorPanel = (AbstractOfferEditorPanel) tabGroup.getCurrentlySelectedTab();
        editorPanel.highlightPressedOption(key);
    }

    public void deleteOption(Option option) {
        AbstractOfferEditorPanel editorPanel = (AbstractOfferEditorPanel) tabGroup.getCurrentlySelectedTab();
        editorPanel.deleteOption(option);
        revalidate();
        repaint();
    }

    public void selectQuantityEditor() {
        tabGroup.select(quantityEditorTab);
    }

    public void selectPriceEditor() {
        tabGroup.select(priceEditorTab);
    }

}

package com.flippingutilities.ui.offereditor;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.Option;

import java.util.List;
import java.util.stream.Collectors;

public class PriceEditorPanel extends AbstractOfferEditorPanel{
    public PriceEditorPanel(FlippingPlugin plugin) {
        super(plugin);
    }

    @Override
    public List<Option> getOptions() {
        return plugin.getDataHandler().viewAccountWideData().getOptions().stream().filter(option -> !option.isQuantityOption()).collect(Collectors.toList());
    }

    @Override
    public void addOptionPanel() {
        plugin.getDataHandler().getAccountWideData().getOptions().add(0,Option.defaultPriceOption());
        rebuild(getOptions());
    }

    @Override
    public void onTemplateClicked() {
        List<Option> options = plugin.getDataHandler().getAccountWideData().getOptions();
        options.add(new Option("n", Option.WIKI_SELL, "+0", false));
        options.add(new Option("j", Option.WIKI_BUY, "+0", false));
        options.add(new Option("u", Option.LAST_SELL, "+0", false));
        options.add(new Option("o", Option.LAST_BUY, "+0", false));
        options.add(new Option("l", Option.INSTA_SELL, "+0", false));
        options.add(new Option("p", Option.INSTA_BUY, "+0", false));
    }
}

package com.flippingutilities.ui.offereditor;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.Option;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

public abstract class AbstractOfferEditorPanel extends JPanel {
    JPanel optionsContainer;
    FlippingPlugin plugin;
    List<OptionPanel> optionPanels = new ArrayList<>();
    JPanel descriptionPanel;

    public abstract List<Option> getOptions();

    public abstract void addOptionPanel();

    public abstract void onTemplateClicked();

    public AbstractOfferEditorPanel(FlippingPlugin plugin) {
        this.plugin = plugin;
        setLayout(new BorderLayout());
        setBackground(CustomColors.DARK_GRAY);
        setBorder(new EmptyBorder(5,0,10,0));

        optionsContainer = new JPanel();
        optionsContainer.setLayout(new BoxLayout(optionsContainer, BoxLayout.Y_AXIS));
        optionsContainer.setBackground(CustomColors.DARK_GRAY);

        //i need thsi wrapper because when using the tab group and if one tab is larger than the other,
        // having the optionsContainer be in BorderLayout.CENTER causes the optionpanel to take up all the space. This is because
        //when the tabs are diff lenghts the shorter tab is forced to be the same size as teh larger tab and so the option
        //panel is stretched to fill in when its in BorderLayout.CENTER
        //the option panels to take up
        JPanel wrapper = new JPanel(new BorderLayout());
        wrapper.add(createTitlePanel(), BorderLayout.NORTH);
        wrapper.add(optionsContainer, BorderLayout.CENTER);

        add(wrapper, BorderLayout.NORTH);
        rebuild(getOptions());
    }

    private JPanel createTitlePanel() {
        descriptionPanel = new JPanel();
        descriptionPanel.setBorder(new EmptyBorder(10,0,0,0));
        descriptionPanel.setBackground(CustomColors.DARK_GRAY);
        JLabel keyDescriptionLabel = new JLabel("<html><u>Key</u></html>", JLabel.CENTER);
        keyDescriptionLabel.setToolTipText("<html>The key you can press to trigger the option.<br> Make sure to hit enter after editing a key so that your changes are saved</html>");
        keyDescriptionLabel.setFont(FontManager.getRunescapeSmallFont());
        JLabel propertyDescriptionLabel = new JLabel("<html><u>Property</u></html>",  JLabel.CENTER);
        propertyDescriptionLabel.setToolTipText("The property an option's value is dependent on");
        propertyDescriptionLabel.setFont(FontManager.getRunescapeSmallFont());
        propertyDescriptionLabel.setBorder(new EmptyBorder(0,25,0,25));
        JLabel modifierDescriptionLabel = new JLabel("<html><u>Modifier</u></html>", JLabel.CENTER);
        modifierDescriptionLabel.setToolTipText("<html>Any of these symbols +,-,*, followed by a positive whole number.<br> Examples: +0, +10, -5, *2. Make sure to hit enter after editing a modifier to save your changes</html>");
        modifierDescriptionLabel.setFont(FontManager.getRunescapeSmallFont());

        descriptionPanel.add(keyDescriptionLabel);
        descriptionPanel.add(propertyDescriptionLabel);
        descriptionPanel.add(modifierDescriptionLabel);
        return descriptionPanel;
    }

    public void highlightPressedOption(String key) {
        boolean alreadyHighlightedOne = false;
        for (OptionPanel panel: optionPanels) {
            String keyInOption = panel.getOption().getKey();
            //in case a user has put multiple options with the same key, don't highlight multiple.
            if (key.equals(keyInOption) && !alreadyHighlightedOne) {
                panel.highlight();
                alreadyHighlightedOne = true;
            }
            else {
                panel.deHighlight();
            }
        }
    }

    public void deleteOption(Option option) {
        plugin.getDataHandler().getAccountWideData().getOptions().remove(option);
        rebuild(getOptions());
    }

    public void rebuild(List<Option> options) {
        SwingUtilities.invokeLater(() -> {
            optionsContainer.removeAll();
            if (options.isEmpty()) {
                descriptionPanel.setVisible(false);
                optionsContainer.add(createWelcomePanel());
            }
            else {
                descriptionPanel.setVisible(true);
            }

            optionPanels.clear();
            for (Option option:options) {
                OptionPanel newPanel = new OptionPanel(option, plugin);
                optionPanels.add(newPanel);
                optionsContainer.add(newPanel);
            }
            revalidate();
            repaint();
        });
    }

    private JPanel createWelcomePanel() {
        JPanel welcomePanel = new JPanel(new BorderLayout());
        welcomePanel.setBackground(CustomColors.DARK_GRAY);
        welcomePanel.setBorder(new EmptyBorder(20,0,20,0));

        String text = "<html><div style=width:200;text-align: center;>" +
                "Click the plus icon above to create an option<br><br>" +
                "or<br><br>" +
                "get started quickly with multiple default options by pressing the button below!" +
                "</div></html>";

        JLabel descriptionText = new JLabel(text, JLabel.CENTER);
        descriptionText.setFont(FontManager.getRunescapeSmallFont());

        JLabel templateButton = new JLabel(Icons.TEMPLATE);
        templateButton.setBorder(new EmptyBorder(15,0,0,0));
        templateButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                onTemplateClicked();
                rebuild(getOptions());
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                templateButton.setIcon(Icons.TEMPLATE_HOVER);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                templateButton.setIcon(Icons.TEMPLATE);
            }
        });

        welcomePanel.add(descriptionText, BorderLayout.NORTH);

        welcomePanel.add(templateButton, BorderLayout.CENTER);
        return welcomePanel;
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.settings;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.ui.uiutilities.Icons;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * This class is a panel which allows a user to select which account to modify. Currently, a user can only delete their
 * account. This panel is displayed in a modal that pops up when a user clicks on the settings button in the master panel.
 */
public class SettingsPanel extends JPanel
{

	int ACCOUNT_LABEL_HEIGHT = 45;

	FlippingPlugin plugin;

	JPanel accountSelectionPanel;

	JPanel settingsBasePanel;

	List<JLabel> accountLabels = new ArrayList<>();

	JLabel selectedAccountLabel;


	public SettingsPanel(FlippingPlugin plugin)
	{
		this.plugin = plugin;
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		accountSelectionPanel = accountSelectionPanel();

		JScrollPane accountScroller = new JScrollPane(accountSelectionPanel);

		settingsBasePanel = new JPanel();
		settingsBasePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		add(accountScroller, BorderLayout.WEST);
		add(new JScrollPane(settingsBasePanel), BorderLayout.CENTER);
	}

	/**
	 * This is the panel that holds the vertically stacked account labels.
	 *
	 * @return
	 */
	private JPanel accountSelectionPanel()
	{
		JPanel accountSelectionPanel = new JPanel();
		accountSelectionPanel.setLayout(new BoxLayout(accountSelectionPanel, BoxLayout.Y_AXIS));
		accountSelectionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		return accountSelectionPanel;
	}

	/**
	 * Creates the account labels that a user can click on to select which account's settings they want to change. These
	 * labels are in the account selection panel.
	 *
	 * @param name name of the account
	 * @return
	 */
	private JLabel accountLabel(String name)
	{
		JLabel accountLabel = new JLabel(Icons.GNOME_CHILD, JLabel.LEFT);
		accountLabel.setOpaque(true);
		accountLabel.setMaximumSize(new Dimension(170, ACCOUNT_LABEL_HEIGHT));
		accountLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		accountLabel.setText(name);
		accountLabel.setFont(FontManager.getRunescapeBoldFont());
		accountLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				setSelectedAccountLabel(accountLabel);
				revalidate();
				repaint();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				accountLabel.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
				accountLabel.setSize(accountLabel.getWidth(), ACCOUNT_LABEL_HEIGHT + 10);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (accountLabel != selectedAccountLabel)
				{
					accountLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
					accountLabel.setSize(accountLabel.getWidth(), ACCOUNT_LABEL_HEIGHT);
				}
			}
		});
		return accountLabel;
	}

	public void rebuild()
	{
        accountSelectionPanel.removeAll();
        settingsBasePanel.removeAll();
        accountLabels.clear();
        Set<String> accountsWithHistory = new HashSet<>(plugin.getCurrentDisplayNames());
        for (String name : accountsWithHistory) {
            JLabel accountLabel = accountLabel(name);
            accountLabels.add(accountLabel);
            accountSelectionPanel.add(accountLabel);
            accountSelectionPanel.add(Box.createRigidArea(new Dimension(0, 2)));
        }
        if (!accountLabels.isEmpty()) {
            setSelectedAccountLabel(accountLabels.get(0));
        }
        repaint();
        revalidate();
	}

	private void setSelectedAccountLabel(JLabel accountLabel)
	{
		selectedAccountLabel = accountLabel;
		accountLabel.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);

		for (JLabel label : accountLabels)
		{
			if (label != accountLabel)
			{
				label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			}
		}

		settingsBasePanel.removeAll();
		settingsBasePanel.add(optionsPanel(accountLabel.getText()));
	}

	/**
	 * Creates the button which deletes the associated account if pressed. This button is located on the options panel.
	 */
	private JLabel accountDeleteButton()
	{
		JLabel deleteButton = new JLabel(Icons.DELETE_BUTTON);
		deleteButton.setToolTipText("Deletes the file that stores all of this account's trades. This cannot" +
			"be undone!");
		deleteButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				String selectedAccountName = selectedAccountLabel.getText();
				if (selectedAccountName.equals(plugin.getCurrentlyLoggedInAccount()))
				{
					JOptionPane.showMessageDialog(null, "You cannot delete a currently logged in account", "Alert", JOptionPane.ERROR_MESSAGE);
				}

				else
				{
					int result = JOptionPane.showOptionDialog(deleteButton, "Are you sure you want to delete this account?",
						"Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
						null, new String[] {"Yes", "No"}, "No");

					if (result == JOptionPane.YES_OPTION)
					{
						plugin.deleteAccount(selectedAccountName);
						rebuild();
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				deleteButton.setIcon(Icons.HIGHLIGHT_DELETE_BUTTON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				deleteButton.setIcon(Icons.DELETE_BUTTON);
			}
		});

		return deleteButton;
	}


	/**
	 * Creates a panel that represents all the settings options for the account with the given name. Currently, the
	 * only option is the ability to delete the account.
	 *
	 * @param name the name of the account the options are for.
	 * @return
	 */
	private JPanel optionsPanel(String name)
	{
		JPanel basePanel = new JPanel(new BorderLayout());
		basePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		JLabel title = new JLabel("currently viewing " + name, SwingConstants.CENTER);
		title.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		title.setFont(new Font("Roboto", Font.ITALIC + Font.BOLD, 10));
		title.setBorder(new EmptyBorder(0, 0, 10, 0));

		JLabel deleteButton = accountDeleteButton();

		JPanel optionBody = new JPanel();
		optionBody.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		basePanel.add(title, BorderLayout.NORTH);
		basePanel.add(optionBody, BorderLayout.CENTER);
		basePanel.add(deleteButton, BorderLayout.SOUTH);

		return basePanel;
	}
}

package com.flippingutilities.ui.uiutilities;

import java.awt.*;

public class CustomColors {
    public static final Color OUTDATED_COLOR = new Color(250, 74, 75);
    public static final Color PROFIT_COLOR = new Color(255, 175, 55);
    public static final Color DARK_GRAY = new Color(27, 27, 27);
    public static final Color TOMATO = new Color(255,99,71);
    public static final Color DARK_GRAY_LIGHTER = new Color(32, 32, 32);
    public static final Color OFF_WHITE = new Color(207, 201, 201);
    public static final Color CHEESE = new Color(255, 197, 0);
    public static final Color SOFT_ALCH = new Color(202, 186, 153);
    public static final Color IN_RANGE = new Color(53, 109, 169);
    public static final Color DMM = new Color(172, 55, 55);
    public static final Color IN_RANGE_SLOTS_TAB = new Color(55, 70, 70);
    public static final Color BETTER_THAN_WIKI_SLOTS_TAB = new Color(55, 70, 50);
    public static final Color OUT_OF_RANGE_SLOTS_TAB = new Color(67, 50, 50);
}

package com.flippingutilities.ui.uiutilities;

import com.flippingutilities.controller.FlippingPlugin;
import net.runelite.api.Client;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Loads the sprite images into memory and then sets them in the
 * client sprite overrides. Also maintains a mapping of the dynamic
 * children indices and the custom sprite ids they map to.
 */
public class GeSpriteLoader {
    //the indexes of the widgets in the dynamic child list of the slot widget
    public static final int TOP_CHILD_IDX = 5;
    public static final int BOTTOM_CHILD_IDX = 6;
    public static final int LEFT_CHILD_IDX = 7;
    public static final int RIGHT_CHILD_IDX = 8;
    public static final int TOP_LEFT_CHILD_IDX = 9;
    public static final int TOP_RIGHT_CHILD_IDX = 10;
    public static final int BOTTOM_LEFT_CHILD_IDX = 11;
    public static final int BOTTOM_RIGHT_CHILD_IDX = 12;
    public static final int HORIZONTAL_CHILD_IDX = 13;
    public static final int LEFT_INTERSECTION_CHILD_IDX = 14;
    public static final int RIGHT_INTERSECTION_CHILD_IDX = 15;
    public static final int ITEM_BOX_CHILD_IDX = 17;

    public static final List<Integer> DYNAMIC_CHILDREN_IDXS = Arrays.asList(
        BOTTOM_CHILD_IDX, BOTTOM_LEFT_CHILD_IDX,BOTTOM_RIGHT_CHILD_IDX,
        TOP_LEFT_CHILD_IDX, TOP_RIGHT_CHILD_IDX, HORIZONTAL_CHILD_IDX,
        LEFT_INTERSECTION_CHILD_IDX, RIGHT_INTERSECTION_CHILD_IDX,
        LEFT_CHILD_IDX, RIGHT_CHILD_IDX, TOP_CHILD_IDX, ITEM_BOX_CHILD_IDX);

    public static Map<Integer, Integer> CHILDREN_IDX_TO_DEFAULT_SPRITE_ID = createChildIdxToSpriteIdMap(CustomSpriteIds.DEFAULT_SLOT_SPRITES);
    public static Map<Integer, Integer> CHILDREN_IDX_TO_RED_SPRITE_ID = createChildIdxToSpriteIdMap(CustomSpriteIds.RED_SLOT_SPRITES);
    public static Map<Integer, Integer> CHILDREN_IDX_TO_BLUE_SPRITE_ID = createChildIdxToSpriteIdMap(CustomSpriteIds.BLUE_SLOT_SPRITES);
    public static Map<Integer, Integer> CHILDREN_IDX_TO_GREEN_SPRITE_ID = createChildIdxToSpriteIdMap(CustomSpriteIds.GREEN_SLOT_SPRITES);

    private static List<String> FILE_NAMES = Arrays.asList(
        "border_offer_bottom.png",
        "border_offer_corner_bottom_left.png",
        "border_offer_corner_bottom_right.png",
        "border_offer_corner_top_left.png",
        "border_offer_corner_top_right.png",
        "border_offer_horizontal.png",
        "border_offer_intersection_left.png",
        "border_offer_intersection_right.png",
        "border_offer_left.png",
        "border_offer_right.png",
        "border_offer_top.png",
        "selected_item_box.png"
    );

    public static void setClientSpriteOverrides(Client client) {
        setClientSpriteOverrides(client, "red", CustomSpriteIds.RED_SLOT_SPRITES);
        setClientSpriteOverrides(client, "green", CustomSpriteIds.GREEN_SLOT_SPRITES);
        setClientSpriteOverrides(client, "blue", CustomSpriteIds.BLUE_SLOT_SPRITES);
    }

    /**
     * Associates the custom sprite ids with the sprite image. To actually change a sprite on screen, we later make
     * the widget with the sprite we want to change have its sprite id = to some custom sprite id here
     */
    private static void setClientSpriteOverrides(Client client, String color, List<Integer> spriteIds) {
        for (int i = 0; i < spriteIds.size(); i++) {
            int spriteId = spriteIds.get(i);
            String filename = FILE_NAMES.get(i);
            BufferedImage image = ImageUtil.loadImageResource(FlippingPlugin.class, "/ge-sprites/" + color +  "/" + filename);
            client.getSpriteOverrides().put(spriteId, ImageUtil.getImageSpritePixels(image, client));
        }
    }

    private static Map<Integer, Integer> createChildIdxToSpriteIdMap(List<Integer> spriteIds) {
        Map<Integer, Integer> childIdToSpriteIdMap = new HashMap<>();
        for (int i = 0; i < spriteIds.size(); i++) {
            childIdToSpriteIdMap.put(DYNAMIC_CHILDREN_IDXS.get(i), spriteIds.get(i));
        }

        return childIdToSpriteIdMap;
    }

}


package com.flippingutilities.ui.uiutilities;

import com.google.common.collect.ImmutableMap;

import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class TimeFormatters {
    public static ImmutableMap<Object, Object> stringToTimeUnit = ImmutableMap.builder()
            .put("h", 1)
            .put("d", 24)
            .put("w", 24*7)
            .put("m", 24*30)
            .put("y", 365*24)
            .build();
    /**
     * Formats a duration into HH:MM:SS
     *
     * @param duration
     * @return Formatted (HH:MM:SS) string
     */
    public static String formatDuration(Duration duration)
    {
        long seconds = duration.toMillis() / 1000;
        return String.format("%02d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, (seconds % 60));
    }


    /**
     * Formats an instant into a duration between the parameter and now.
     *
     * @return Formatted (HH:MM:SS) string
     */
    public static String formatDuration(Instant fromInstant)
    {
        return formatDuration(Duration.between(fromInstant, Instant.now()));
    }

    /**
     * Formats the duration between one instant to an end instant.
     *
     * @param startInstant Start of duration
     * @param endInstant   End of duration
     * @return Formatted (HH:MM:SS) string
     */
    public static String formatDuration(Instant startInstant, Instant endInstant)
    {
        return formatDuration(Duration.between(startInstant, endInstant));
    }

    /**
     * This method formats a string time from an instant from the time, as specified by the parameter, until now.
     * It truncates the time representation to the greatest unit. For example, 65 seconds will become a minute
     * (not a minute and 5 seconds), 70 minutes will become an hour (not an hour and 10 minutes), etc. This is to
     * save space on the panels.
     *
     * @param fromInstant The start of the duration
     * @return A formatted string.
     */
    public static String formatDurationTruncated(Instant fromInstant)
    {
        if (fromInstant != null)
        {
            long toInstant = Instant.now().getEpochSecond();

            //Time since trade was done.
            long timeAgo = (toInstant - fromInstant.getEpochSecond());

            String result = timeAgo + (timeAgo == 1 ? " second" : " seconds");
            if (timeAgo >= 60)
            {
                //Seconds to minutes.
                long timeAgoMinutes = timeAgo / 60;
                result = timeAgoMinutes + (timeAgoMinutes == 1 ? " minute" : " minutes");

                if (timeAgoMinutes >= 60)
                {
                    //Minutes to hours
                    int timeAgoHours = (int) (timeAgoMinutes / 60);
                    result = timeAgoHours + (timeAgoHours == 1 ? " hour" : " hours");
                    if (timeAgoHours > 24)
                    {
                        int timeAgoDays = timeAgoHours / 24;
                        result = timeAgoDays + (timeAgoDays == 1 ? " day" : " days");
                    }
                }
            }
            return result;
        }
        else
        {
            return "";
        }
    }

    /**
     * This method formats a time instant into a string of hours and minutes.
     *
     * @param time             The time that needs to be formatted
     * @param twelveHourFormat Determines if the returned string should be formatted with 12-hour or 24-hour format
     * @param includeDate      Include the day and month in the format string.
     * @return A formatted string of hours and minutes dependent on user config (hh:mm a  or  HH:mm)
     */
    public static String formatTime(Instant time, boolean twelveHourFormat, boolean includeDate)
    {
        DateTimeFormatter timeFormatter;
        String pattern = "";

        if (includeDate)
        {
            //Example:	04 Sep
            pattern = "dd MMM ";
        }

        if (twelveHourFormat)
        {
            //Example:	2:53 PM
            pattern += "hh:mm a";
        }
        else
        {
            //Example:	14:53
            pattern += "HH:mm";
        }
        timeFormatter = DateTimeFormatter.ofPattern(pattern).withZone(ZoneId.systemDefault());
        return timeFormatter.format(time);
    }

    public static String formatInstantToDate(Instant time) {
        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd hh:mm a").withZone(ZoneId.systemDefault());
        return timeFormatter.format(time);
    }

}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.uiutilities;

import com.flippingutilities.ui.flipping.FlippingPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.*;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.font.TextAttribute;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * This class contains various methods that the UI uses to format their visuals.
 */
@Slf4j
public class UIUtilities
{
	private static final NumberFormat PRECISE_DECIMAL_FORMATTER = new DecimalFormat(
		"#,###.###",
		DecimalFormatSymbols.getInstance(Locale.ENGLISH)
	);
	private static final NumberFormat DECIMAL_FORMATTER = new DecimalFormat(
		"#,###.#",
		DecimalFormatSymbols.getInstance(Locale.ENGLISH)
	);

	/**
	 * This method calculates the red-yellow-green gradient factored by the percentage or max gradient.
	 *
	 * @param percentage  The percentage representing the value that needs to be gradiated.
	 * @param gradientMax The max value representation before the gradient tops out on green.
	 * @return A color representing a value on a red-yellow-green gradient.
	 */
	public static Color gradiatePercentage(float percentage, int gradientMax)
	{
		if (percentage < gradientMax * 0.5)
		{
			return (percentage <= 0) ? CustomColors.TOMATO
				: ColorUtil.colorLerp(CustomColors.TOMATO, ColorScheme.GRAND_EXCHANGE_ALCH, percentage / gradientMax * 2);
		}
		else
		{
			return (percentage >= gradientMax) ? ColorScheme.GRAND_EXCHANGE_PRICE
				: ColorUtil.colorLerp(ColorScheme.GRAND_EXCHANGE_ALCH, ColorScheme.GRAND_EXCHANGE_PRICE, percentage / gradientMax * 0.5);
		}
	}

	/**
	 * Functionally the same as {@link QuantityFormatter#quantityToRSDecimalStack(int, boolean)},
	 * except this allows for formatting longs.
	 *
	 * @param quantity Long to format
	 * @param precise  If true, allow thousandths precision if {@code currentQuantityInTrade} is larger than 1 million.
	 *                 Otherwise have at most a single decimal
	 * @return Formatted number string.
	 */
	public static synchronized String quantityToRSDecimalStack(long quantity, boolean precise)
	{
		if (Long.toString(quantity).length() <= 4)
		{
			return QuantityFormatter.formatNumber(quantity);
		}

		long power = (long) Math.log10(quantity);

		// Output thousandths for values above a million
		NumberFormat format = precise && power >= 6
			? PRECISE_DECIMAL_FORMATTER
			: DECIMAL_FORMATTER;

		return format.format(quantity / Math.pow(10, (Long.divideUnsigned(power, 3)) * 3))
			+ new String[] {"", "K", "M", "B", "T"}[(int) (power / 3)];
	}

	public static JDialog createModalFromPanel(Component parent, JComponent panel)
	{
		JDialog modal = new JDialog();
		modal.add(panel);
		modal.setLocationRelativeTo(parent);
		return modal;
	}

	public static JPanel stackPanelsVertically(List<JPanel> panels, int gap) {
		JPanel mainPanel = new JPanel();
		stackPanelsVertically(panels, mainPanel, gap);
		return mainPanel;
	}

	//make this take a supplier to supply it with the desired margin wrapper.
	public static void stackPanelsVertically(List<JPanel> panels, JPanel mainPanel, int vGap)
	{
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));

		int index = 0;
		for (JPanel panel : panels)
		{
			if (index == 0)
			{
				mainPanel.add(panel);
				index++;
			}
			else
			{
				mainPanel.add(Box.createVerticalStrut(vGap));
				mainPanel.add(panel);
			}
		}
	}

	/**
	 * for some reason ColorUtil.wrapWithColorTag() doesn't work sometimes, but using this
	 * diff method of coloring does
	 */
	public static String colorText(String s, Color color) {
		return String.format("<span style='color:%s;'>%s</span>",ColorUtil.colorToHexCode(color), s);
	}

	/**
	 * on popups, setForeground doesn't color things appropriately, its always more
	 * dull than the actual color. This method uses html to specify the
	 * color which for some reason displays a much more accurate color than setForeground.
	 */
	public static void recolorLabel(JLabel label, Color c) {
		label.setText("<html>" + colorText(label.getText(), c) + "</html>");
	}

	public static String buildWikiLink(int itemId) {
		//https://prices.runescape.wiki/osrs/item/2970
		return "https://prices.runescape.wiki/osrs/item/" + itemId;
	}

	public static String buildOurWebsiteLink(int itemId) {
		return "https://prices.osrs.cloud/item/" + itemId + "?utm_source=plugin";
	}

	public static IconTextField createSearchBar(ScheduledExecutorService executor, Consumer<IconTextField> onSearch) {
		final Future<?>[] runningRequest = {null};
		IconTextField searchBar = new IconTextField();
		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 32));
		searchBar.setBackground(CustomColors.DARK_GRAY_LIGHTER);
		searchBar.setHoverBackgroundColor(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		searchBar.setMinimumSize(new Dimension(0, 35));
		searchBar.addActionListener(e -> executor.execute(() -> onSearch.accept(searchBar)));
		searchBar.addClearListener(()-> onSearch.accept(searchBar));
		searchBar.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if (runningRequest[0] != null)
				{
					runningRequest[0].cancel(false);
				}
				runningRequest[0] = executor.schedule(() -> onSearch.accept(searchBar), 250, TimeUnit.MILLISECONDS);
			}
		});
		return searchBar;
	}

	public static void makeLabelUnderlined(JLabel label) {
		Font font = label.getFont();
		Map attributes = font.getAttributes();
		attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
		label.setFont(font.deriveFont(attributes));
	}

	public static JToggleButton createToggleButton() {
		JToggleButton toggleButton = new JToggleButton(Icons.TOGGLE_OFF);
		toggleButton.setSelectedIcon(Icons.TOGGLE_ON);
		SwingUtil.removeButtonDecorations(toggleButton);
		//toggleButton.setPreferredSize(new Dimension(25, 0));
		SwingUtil.addModalTooltip(toggleButton, "Turn off", "Turn on");
		return toggleButton;
	}

	public static void addPopupOnHover(JComponent component, JPopupMenu popup, boolean above) {
		//can't really achieve this well with a modal (Jdialog) cause it opens up a window with an "X" button
		//and so on. Whereas this just opens up popup menu with no border so this is more suited for the on hover
		//popups.
		//TODO why does thus even have to be a popup menu? Can't this just be a jlabel or jpanel?
		//^ bc the jlabel and jpanel can't just show anywhere on the screen unfortunately. Maybe I'm doing something
		//wrong but it seems only things like popups can be arbitrarily rendered anywhere
		component.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				Point location  = component.getLocationOnScreen();
				int y = above? location.y - popup.getHeight(): location.y + component.getHeight();
				popup.setLocation(location.x, y);
				popup.setVisible(true);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				popup.setVisible(false);
			}
		});
	}

	public static JLabel createIcon(ImageIcon base, ImageIcon hover, String url, String tooltip) {
		JLabel iconLabel = new JLabel(base);
		iconLabel.setToolTipText(tooltip);
		iconLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				LinkBrowser.browse(url);
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				iconLabel.setIcon(hover);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				iconLabel.setIcon(base);
			}
		});
		return iconLabel;
	}

	public static String maybePluralize(String word, int count) {
		if (count > 1) {
			return word + "s";
		}
		return word;
	}

	/**
	 * Example:
	 * You have the string "1234567", which is too large for displaying purposes.
	 * You want a string of only length 6 and it should clearly convey some truncation
	 * occurred, like "123..."
	 *
	 * truncateText("12345678999999", 6) = "123..."
	 * truncateText("1234567", 6) = "123..."
	 * truncateText("123456", 6) = "123456"
	 *
	 * @param text text to be truncated
	 * @param length desired length, including the ellipses
	 * @return truncated text
	 */
	public static String truncateText(String text, int length) {
		String ellipses = "...";
		if (length <= ellipses.length()) {
			return text;
		}
		if (text.length() <= length) {
			return text;
		}

		return text.substring(0, length - ellipses.length()) + ellipses;
	}
}

package com.flippingutilities.ui.uiutilities;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class Paginator extends JPanel
{
	@Getter
	@Setter
	private int pageNumber = 1;
	private int totalPages;
	@Getter
	private JLabel statusText;
	@Setter
	private JLabel arrowRight;
	@Setter
	private JLabel arrowLeft;
	Runnable onPageChange;
	@Setter
	private int pageSize = 20;

	public Paginator(Runnable onPageChange)
	{
		this.onPageChange = onPageChange;
		this.statusText = new JLabel("Page 1 of 1", SwingUtilities.CENTER);
		this.statusText.setFont(FontManager.getRunescapeBoldFont());
		this.arrowLeft = new JLabel(Icons.ARROW_LEFT);
		this.arrowRight = new JLabel(Icons.ARROW_RIGHT);
		this.arrowRight.setForeground(Color.blue);
		setLayout(new FlowLayout());
		add(arrowLeft);
		add(statusText);
		add(arrowRight);
		setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		setBorder(new EmptyBorder(3, 0, 0, 0));
		arrowLeft.addMouseListener(onMouse(false));
		arrowRight.addMouseListener(onMouse(true));
	}

	public void updateTotalPages(int numItems)
	{
		if (numItems <= pageSize) {
			totalPages = 1;
		}
		else {
			totalPages = (int) Math.ceil((float)numItems/ pageSize);
		}

		statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
	}

	private MouseAdapter onMouse(boolean isIncrease)
	{
		return new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (isIncrease)
				{
					if (pageNumber < totalPages)
					{
						pageNumber++;
						try
						{
							onPageChange.run();
						}
						catch (Exception exc)
						{
							log.info("couldn't increase page number cause callback failed");
							pageNumber--;
						}
					}
				}
				else
				{
					if (pageNumber > 1)
					{
						pageNumber--;
						try
						{
							onPageChange.run();
						}
						catch (Exception exc)
						{
							log.info("couldn't decrease page number cause callback failed");
							pageNumber++;
						}

					}
				}
				statusText.setText(String.format("Page %d of %d", pageNumber, totalPages));
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (isIncrease)
				{
					arrowRight.setIcon(Icons.ARROW_RIGHT_HOVER);
				}
				else
				{
					arrowLeft.setIcon(Icons.ARROW_LEFT_HOVER);
				}
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (isIncrease)
				{
					arrowRight.setIcon(Icons.ARROW_RIGHT);
				}
				else
				{
					arrowLeft.setIcon(Icons.ARROW_LEFT);
				}
			}
		};
	}

	public <T> List<T> getCurrentPageItems(List<T> items)
	{
		List<T> pageItems = new ArrayList<>();
		int startIndex = (pageNumber - 1) * pageSize;
		int endIndex = Math.min(startIndex + pageSize, items.size());
		for (int i = startIndex; i < endIndex; i++)
		{
			pageItems.add(items.get(i));
		}
		return pageItems;
	}
}

package com.flippingutilities.ui.uiutilities;

import com.flippingutilities.utilities.SlotInfo;
import com.flippingutilities.utilities.SlotPredictedState;
import com.flippingutilities.utilities.WikiItemMargins;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * The panel that is displayed when you hover over the magnifying glass widget. This panel
 * contains the wiki margins of the item, and whether your offer is competitive or not
 * and what you can do to make it competitive. This essentially provides a faster way
 * to get margin info then finding the item in the sidebar (via searching or clicking on the offer).
 */
@Slf4j
public class QuickLookPanel extends JPanel {
    JLabel wikiInstaBuy = new JLabel("", JLabel.RIGHT);
    JLabel wikiInstaSell = new JLabel("", JLabel.RIGHT);
    JLabel wikiInstaBuyAge = new JLabel("", JLabel.RIGHT);
    JLabel wikiInstaSellAge = new JLabel("", JLabel.RIGHT);
    JLabel offerCompetitivenessText = new JLabel("", JLabel.CENTER);
    JLabel toMakeOfferCompetitiveTest = new JLabel("", JLabel.CENTER);

    public QuickLookPanel() {
        super();
        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10, 15, 10, 15));

        offerCompetitivenessText.setFont(FontManager.getRunescapeBoldFont());
        toMakeOfferCompetitiveTest.setFont(FontManager.getRunescapeSmallFont());
        toMakeOfferCompetitiveTest.setBorder(new EmptyBorder(3, 0, 0, 0));

        wikiInstaBuy.setForeground(Color.WHITE);
        wikiInstaSell.setForeground(Color.WHITE);

        JLabel title = new JLabel("Quick Look", JLabel.CENTER);
        title.setFont(new Font("Whitney", Font.BOLD + Font.ITALIC, 12));

        JLabel wikiInstaBuyDesc = new JLabel("Wiki Insta Buy", JLabel.LEFT);
        JLabel wikiInstaSellDesc = new JLabel("Wiki Insta Sell", JLabel.LEFT);
        JLabel wikiInstaBuyAgeDesc = new JLabel("Wiki Insta Buy Age", JLabel.LEFT);
        JLabel wikiInstaSellAgeDesc = new JLabel("Wiki Insta Sell Age", JLabel.LEFT);

        //being lazy...just want to separate the rows that hold the wiki price vals from the rows that hold the wiki time
        //vals
        wikiInstaBuyAgeDesc.setBorder(new EmptyBorder(5, 0, 0, 0));
        wikiInstaBuyAge.setBorder(new EmptyBorder(5, 0, 0, 0));

        Arrays.asList(wikiInstaBuyDesc, wikiInstaSellDesc, wikiInstaBuyAgeDesc, wikiInstaSellAgeDesc, wikiInstaBuy,
            wikiInstaSell, wikiInstaBuyAge, wikiInstaSellAge).forEach(l -> l.setFont(FontManager.getRunescapeSmallFont()));

        JPanel wikiPanel = new JPanel(new DynamicGridLayout(4, 2, 10, 2));
        wikiPanel.setBorder(new EmptyBorder(10, 10, 0, 10));
        wikiPanel.add(wikiInstaBuyDesc);
        wikiPanel.add(wikiInstaBuy);
        wikiPanel.add(wikiInstaSellDesc);
        wikiPanel.add(wikiInstaSell);

        wikiPanel.add(wikiInstaBuyAgeDesc);
        wikiPanel.add(wikiInstaBuyAge);
        wikiPanel.add(wikiInstaSellAgeDesc);
        wikiPanel.add(wikiInstaSellAge);

        JPanel summaryPanel = new JPanel(new DynamicGridLayout(2, 1));
        summaryPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
        summaryPanel.add(offerCompetitivenessText);
        summaryPanel.add(toMakeOfferCompetitiveTest);

        add(title, BorderLayout.NORTH);
        add(wikiPanel, BorderLayout.CENTER);
        add(summaryPanel, BorderLayout.SOUTH);
    }

    public void updateDetails(SlotInfo slot, WikiItemMargins wikiItemInfo) {
        Arrays.asList(wikiInstaBuy, wikiInstaSell, wikiInstaBuyAge, wikiInstaSellAge).forEach(l -> l.setForeground(Color.WHITE));
        if (wikiItemInfo == null || slot == null) {
            Arrays.asList(wikiInstaBuy, wikiInstaSell, wikiInstaBuyAge, wikiInstaSellAge).forEach(l -> l.setText("No data"));
            return;
        }
        Map<Integer, JLabel> wikiMarginToLabel = new HashMap<>();
        wikiMarginToLabel.put(wikiItemInfo.getHigh(), wikiInstaBuy);
        wikiMarginToLabel.put(wikiItemInfo.getLow(), wikiInstaSell);

        wikiInstaBuyAge.setText(wikiItemInfo.getHighTime() == 0 ? "No data" : TimeFormatters.formatDuration(Instant.ofEpochSecond(wikiItemInfo.getHighTime())));
        wikiInstaSellAge.setText(wikiItemInfo.getLowTime() == 0 ? "No data" : TimeFormatters.formatDuration(Instant.ofEpochSecond(wikiItemInfo.getLowTime())));
        wikiInstaBuy.setText(wikiItemInfo.getHigh() == 0 ? "No data" : QuantityFormatter.formatNumber(wikiItemInfo.getHigh()) + " gp");
        wikiInstaSell.setText(wikiItemInfo.getLow() == 0 ? "No data" : QuantityFormatter.formatNumber(wikiItemInfo.getLow()) + " gp");

        toMakeOfferCompetitiveTest.setText("");
        offerCompetitivenessText.setText("");

        int max = Math.max(wikiItemInfo.getHigh(), wikiItemInfo.getLow());
        int min = Math.min(wikiItemInfo.getHigh(), wikiItemInfo.getLow());

        if (slot.isBuyOffer() && slot.getPredictedState() == SlotPredictedState.BETTER_THAN_WIKI) {
            UIUtilities.recolorLabel(wikiMarginToLabel.get(max), ColorScheme.GRAND_EXCHANGE_PRICE);
            offerCompetitivenessText.setText(
                String.format("<html> buy offer is ultra competitive: %s &gt= %s </html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(slot.getOfferPrice()), Color.WHITE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(max), ColorScheme.GRAND_EXCHANGE_PRICE)
                ));
        } else if (slot.isBuyOffer() && slot.getPredictedState() == SlotPredictedState.IN_RANGE) {
            UIUtilities.recolorLabel(wikiMarginToLabel.get(min), CustomColors.IN_RANGE);
            UIUtilities.recolorLabel(wikiMarginToLabel.get(max), ColorScheme.GRAND_EXCHANGE_PRICE);
            offerCompetitivenessText.setText(
                String.format("<html> buy offer is competitive: %s &lt= %s &lt %s </html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(min), CustomColors.IN_RANGE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(slot.getOfferPrice()), Color.WHITE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(max), ColorScheme.GRAND_EXCHANGE_PRICE)
                ));
        } else if (slot.isBuyOffer() && slot.getPredictedState() == SlotPredictedState.OUT_OF_RANGE) {
            UIUtilities.recolorLabel(wikiMarginToLabel.get(min), CustomColors.TOMATO);
            offerCompetitivenessText.setText(
                String.format("<html> buy offer is not competitive: %s &lt %s </html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(slot.getOfferPrice()), Color.WHITE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(min), CustomColors.TOMATO)
                ));
            toMakeOfferCompetitiveTest.setText(
                String.format("<html> set price to &gt= %s </html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(min), CustomColors.TOMATO)
                ));
        } else if (!slot.isBuyOffer() && slot.getPredictedState() == SlotPredictedState.BETTER_THAN_WIKI) {
            UIUtilities.recolorLabel(wikiMarginToLabel.get(min), ColorScheme.GRAND_EXCHANGE_PRICE);
            offerCompetitivenessText.setText(
                String.format("<html> sell offer is ultra competitive: %s &lt= %s </html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(slot.getOfferPrice()), Color.WHITE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(min), ColorScheme.GRAND_EXCHANGE_PRICE)
                ));
        } else if (!slot.isBuyOffer() && slot.getPredictedState() == SlotPredictedState.IN_RANGE) {
            UIUtilities.recolorLabel(wikiMarginToLabel.get(min), ColorScheme.GRAND_EXCHANGE_PRICE);
            UIUtilities.recolorLabel(wikiMarginToLabel.get(max), CustomColors.IN_RANGE);
            offerCompetitivenessText.setText(
                String.format("<html> sell offer is competitive: %s &lt %s &lt= %s </html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(min), ColorScheme.GRAND_EXCHANGE_PRICE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(slot.getOfferPrice()), Color.WHITE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(max), CustomColors.IN_RANGE)
                ));
        } else if (!slot.isBuyOffer() && slot.getPredictedState() == SlotPredictedState.OUT_OF_RANGE) {
            UIUtilities.recolorLabel(wikiMarginToLabel.get(max), CustomColors.TOMATO);
            offerCompetitivenessText.setText(
                String.format("<html> sell offer is not competitive: %s &gt %s</html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(slot.getOfferPrice()), Color.WHITE),
                    UIUtilities.colorText(QuantityFormatter.formatNumber(max), CustomColors.TOMATO)
                ));
            toMakeOfferCompetitiveTest.setText(
                String.format("<html> set price to &lt= %s </html>",
                    UIUtilities.colorText(QuantityFormatter.formatNumber(max), CustomColors.TOMATO)
                ));
        }
    }
}
package com.flippingutilities.ui.uiutilities;

public class WidgetConstants {
    public static final int SLOT_CONTAINER = 5;
}

package com.flippingutilities.ui.uiutilities;
import net.runelite.client.ui.FontManager;
import java.awt.*;

public class CustomFonts {
    public static Font SMALLER_RS_BOLD_FONT = FontManager.getRunescapeBoldFont().deriveFont(14.0F);
}

package com.flippingutilities.ui.uiutilities;

import com.flippingutilities.controller.FlippingPlugin;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;

public class Icons {
    public static final Dimension ICON_SIZE = new Dimension(32, 32);
    public static final int TOOLBAR_BUTTON_SIZE = 20;
    private static final int OPTION_DOT_WIDTH = 6;
    private static final int OPTION_DOT_HEIGHT = 6;

    public static final ImageIcon OPEN_ICON;
    public static final ImageIcon CLOSE_ICON;

    public static final ImageIcon RESET_ICON;
    public static final ImageIcon RESET_HOVER_ICON;

    public static final ImageIcon DELETE_ICON;

    public static final ImageIcon SETTINGS_ICON;
    public static final ImageIcon SETTINGS_ICON_OFF;

    public static final ImageIcon GNOME_CHILD;

    public static final ImageIcon DELETE_BUTTON;

    public static final ImageIcon HIGHLIGHT_DELETE_BUTTON;

    public static final ImageIcon STAR_ON_ICON;
    public static final ImageIcon STAR_HOVER_ICON;
    public static final ImageIcon STAR_OFF_ICON;

    public static final ImageIcon SMALL_STAR_ON_ICON;
    public static final ImageIcon SMALL_STAR_HOVER_ICON;
    public static final ImageIcon SMALL_STAR_OFF_ICON;

    public static final ImageIcon ARROW_LEFT;
    public static final ImageIcon ARROW_RIGHT;
    public static final ImageIcon ARROW_LEFT_HOVER;
    public static final ImageIcon ARROW_RIGHT_HOVER;

    public static final ImageIcon HEART_ICON;

    public static final ImageIcon TRASH_ICON;
    public static final ImageIcon TRASH_ICON_OFF;

    public static final ImageIcon DOWNLOAD_ICON;
    public static final ImageIcon DONWLOAD_ICON_OFF;

    public static final ImageIcon GITHUB_ICON;
    public static final ImageIcon GITHUB_ICON_ON;

    public static final ImageIcon DISCORD_ICON;
    public static final ImageIcon DISCORD_ICON_ON;
    public static final ImageIcon DISCORD_CHEESE;

    public static final ImageIcon TWITTER_ICON;
    public static final ImageIcon TWITTER_ICON_ON;

    public static final ImageIcon PLUS_ICON;
    public static final ImageIcon PLUS_ICON_OFF;

    public static final ImageIcon GREEN_DOT;
    public static final ImageIcon GRAY_DOT;
    public static final ImageIcon RED_DOT;

    public static final ImageIcon HELP;
    public static final ImageIcon HELP_HOVER;

    public static final ImageIcon TEMPLATE;
    public static final ImageIcon TEMPLATE_HOVER;

    public static final ImageIcon QUANTITY_EDITOR_PIC;
    public static final ImageIcon PRICE_EDITOR_PIC;

    public static final ImageIcon SEARCH;
    public static final ImageIcon SEARCH_HOVER;

    public static final ImageIcon REFRESH;
    public static final ImageIcon REFRESH_HOVER;

    public static final ImageIcon TOGGLE_ON;
    public static final ImageIcon TOGGLE_OFF;

    public static final ImageIcon TRASH_CAN_ON;
    public static final ImageIcon TRASH_CAN_OFF;

    public static final ImageIcon QUESTION_MARK;

    public static final ImageIcon USER;
    public static final ImageIcon USER_HOVER;
    public static final ImageIcon USER_LOGGED_IN;

    public static final ImageIcon FU_ICON;

    public static final ImageIcon KEY;

    public static final ImageIcon FLASH;

    public static final ImageIcon RIGHT_ARROW_LARGE;
    public static final ImageIcon LEFT_ARROW_LARGE;

    public static final ImageIcon SORT;
    public static final ImageIcon SORT_HOVER;

    public static final ImageIcon CONSTRUCTION;

    public static final ImageIcon RECIPE_HELP;

    public static final ImageIcon MAGNIFYING_GLASS;
    public static final ImageIcon MAGNIFYING_GLASS_HOVER;

    static
    {
        final BufferedImage openIcon = ImageUtil
                .getResourceStreamFromClass(FlippingPlugin.class, "/small_open_arrow.png");
        CLOSE_ICON = new ImageIcon(openIcon);
        OPEN_ICON = new ImageIcon(ImageUtil.rotateImage(openIcon, Math.toRadians(90)));

        final BufferedImage resetIcon = ImageUtil
                .getResourceStreamFromClass(FlippingPlugin.class, "/reset.png");
        RESET_ICON = new ImageIcon(resetIcon);
        RESET_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(resetIcon, 0.53f));

        final BufferedImage deleteIcon = ImageUtil
                .getResourceStreamFromClass(FlippingPlugin.class, "/delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteIcon);

        final BufferedImage settingsIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/settings_icon.png");
        SETTINGS_ICON = new ImageIcon(settingsIcon);
        SETTINGS_ICON_OFF = new ImageIcon(ImageUtil.alphaOffset(settingsIcon, 0.53f));

        final BufferedImage accountIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/gnome.png");
        GNOME_CHILD = new ImageIcon(accountIcon);

        final BufferedImage deleteButton = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/deleteButton.png");
        DELETE_BUTTON = new ImageIcon(deleteButton);

        final BufferedImage highlightDeleteButton = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/highlightDeleteButton.png");
        HIGHLIGHT_DELETE_BUTTON = new ImageIcon(highlightDeleteButton);


        final BufferedImage starOn = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/star-gold.png");
        final BufferedImage starOff = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/star_off_white.png");

        STAR_ON_ICON = new ImageIcon(starOn.getScaledInstance(TOOLBAR_BUTTON_SIZE, TOOLBAR_BUTTON_SIZE, Image.SCALE_SMOOTH));

        STAR_HOVER_ICON = new ImageIcon(starOff.getScaledInstance(TOOLBAR_BUTTON_SIZE, TOOLBAR_BUTTON_SIZE, Image.SCALE_SMOOTH));

        STAR_OFF_ICON = new ImageIcon(ImageUtil.alphaOffset(starOff, 0.53f).getScaledInstance(TOOLBAR_BUTTON_SIZE, TOOLBAR_BUTTON_SIZE, Image.SCALE_SMOOTH));

        SMALL_STAR_ON_ICON = new ImageIcon(starOn.getScaledInstance(13, 13, Image.SCALE_SMOOTH));
        SMALL_STAR_HOVER_ICON = new ImageIcon(starOff.getScaledInstance(13, 13, Image.SCALE_SMOOTH));
        SMALL_STAR_OFF_ICON = new ImageIcon(ImageUtil.alphaOffset(starOff, 0.53f).getScaledInstance(13, 13, Image.SCALE_SMOOTH));

        final BufferedImage arrowLeft = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/left-arrow.png");
        ARROW_LEFT = new ImageIcon(ImageUtil.alphaOffset(arrowLeft,0.70f));

        final BufferedImage arrowRight = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/right-arrow.png");
        ARROW_RIGHT = new ImageIcon(ImageUtil.alphaOffset(arrowRight,0.70f));

        ARROW_LEFT_HOVER = new ImageIcon(arrowLeft);
        ARROW_RIGHT_HOVER = new ImageIcon(arrowRight);

        final BufferedImage heart = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/heart.png");
        HEART_ICON = new ImageIcon(heart);

        final BufferedImage trashIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/trash.png");
        TRASH_ICON = new ImageIcon(trashIcon);
        TRASH_ICON_OFF = new ImageIcon(ImageUtil.alphaOffset(trashIcon, 0.53f));

        final BufferedImage downloadIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/download.png");
        DOWNLOAD_ICON = new ImageIcon(downloadIcon);
        DONWLOAD_ICON_OFF = new ImageIcon(ImageUtil.alphaOffset(downloadIcon, 0.53f));

        final BufferedImage githubIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/github-alch.png");
        final BufferedImage githubIconOn = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/githubon.png");
        GITHUB_ICON = new ImageIcon(githubIcon);
        GITHUB_ICON_ON = new ImageIcon(githubIconOn);

        final BufferedImage twitterIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/twitter-alch.png");
        final BufferedImage twitterIconOn = ImageUtil.loadImageResource(FlippingPlugin.class, "/twitteron.png");
        TWITTER_ICON = new ImageIcon(twitterIcon);
        TWITTER_ICON_ON = new ImageIcon(twitterIconOn);

        final BufferedImage discordIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/discord-alch.png");
        final BufferedImage discordIconOn = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/discordon.png");
        final BufferedImage discordCheese = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/discord-cheese.png");
        DISCORD_ICON = new ImageIcon(discordIcon);
        DISCORD_ICON_ON = new ImageIcon(discordIconOn);
        DISCORD_CHEESE = new ImageIcon(discordCheese);

        final BufferedImage plusIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/plus.png");
        PLUS_ICON = new ImageIcon(plusIcon.getScaledInstance(24,24,Image.SCALE_SMOOTH));
        PLUS_ICON_OFF = new ImageIcon(ImageUtil.alphaOffset(plusIcon, 0.53f).getScaledInstance(24,24,Image.SCALE_SMOOTH));

        final BufferedImage greenDot = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/greendot.png");
        GREEN_DOT = new ImageIcon(greenDot.getScaledInstance(OPTION_DOT_WIDTH,OPTION_DOT_HEIGHT,Image.SCALE_SMOOTH));

        final BufferedImage grayDot = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/graydot.png");
        GRAY_DOT = new ImageIcon(grayDot.getScaledInstance(OPTION_DOT_WIDTH,OPTION_DOT_HEIGHT,Image.SCALE_SMOOTH));

        final BufferedImage redDot = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/reddot.png");
        RED_DOT = new ImageIcon(redDot.getScaledInstance(OPTION_DOT_WIDTH,OPTION_DOT_HEIGHT,Image.SCALE_SMOOTH));

        final BufferedImage help = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/help.png");
        HELP = new ImageIcon(help);
        HELP_HOVER = new ImageIcon(ImageUtil.alphaOffset(help, 0.53f));

        final BufferedImage template = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/template.png");
        TEMPLATE = new ImageIcon(template);
        TEMPLATE_HOVER = new ImageIcon(ImageUtil.alphaOffset(template, 0.53f));

        final BufferedImage quantityEditorPic = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/quantityeditorpic.png");
        QUANTITY_EDITOR_PIC = new ImageIcon(quantityEditorPic);

        final BufferedImage priceEditorPic = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/priceeditorpic.png");
        PRICE_EDITOR_PIC = new ImageIcon(priceEditorPic);

        final BufferedImage searchIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/search.png");
        SEARCH = new ImageIcon(searchIcon.getScaledInstance(12,12,Image.SCALE_SMOOTH));

        final BufferedImage searchIconHover = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/search.png");
        SEARCH_HOVER = new ImageIcon(ImageUtil.alphaOffset(searchIconHover,.53f).getScaledInstance(12,12,Image.SCALE_SMOOTH));

        final BufferedImage refreshIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/refresh.png");
        REFRESH = new ImageIcon(refreshIcon.getScaledInstance(12,12,Image.SCALE_SMOOTH));

        final BufferedImage refreshIconHover = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/refresh.png");
        REFRESH_HOVER = new ImageIcon(ImageUtil.alphaOffset(refreshIconHover,.53f).getScaledInstance(12,12,Image.SCALE_SMOOTH));

        final BufferedImage toggleOn = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/toggle_on.png");
        TOGGLE_ON = new ImageIcon(toggleOn);

        TOGGLE_OFF = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(toggleOn),
                        0.61f
                ),
                true,
                false
        ));

        final BufferedImage trashCanIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/trashicon.png");
        TRASH_CAN_ON = new ImageIcon(trashCanIcon.getScaledInstance(10,10,Image.SCALE_SMOOTH));
        TRASH_CAN_OFF = new ImageIcon(ImageUtil.alphaOffset(trashCanIcon, 0.53f).getScaledInstance(10,10, Image.SCALE_SMOOTH));

        final BufferedImage questionMark = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/question-mark.png");
        QUESTION_MARK = new ImageIcon(questionMark);

        final BufferedImage userIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/user-alch.png");
        final BufferedImage userIconCheese = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/user-cheese.png");
        final BufferedImage userIconLoggedIn = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/user-loggedin.png");
        USER_HOVER = new ImageIcon(userIconCheese);
        USER = new ImageIcon(userIcon);
        USER_LOGGED_IN = new ImageIcon(userIconLoggedIn);

        final BufferedImage fuIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/graph_icon_green.png");
        FU_ICON = new ImageIcon(fuIcon);

        final BufferedImage keyIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/key.png");
        KEY = new ImageIcon(keyIcon);

        final BufferedImage flashIcon = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/flash-cheese.png");
        FLASH = new ImageIcon(flashIcon);

        final BufferedImage rightArrowLarge = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/right-arrow-large.png");
        RIGHT_ARROW_LARGE = new ImageIcon(rightArrowLarge);

        final BufferedImage leftArrowLarge = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/left-arrow-large.png");
        LEFT_ARROW_LARGE = new ImageIcon(leftArrowLarge);

        final BufferedImage sort = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/sort.png");
        SORT = new ImageIcon(ImageUtil.alphaOffset(sort, 0.53f));

        final BufferedImage sortHover = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/sort.png");
        SORT_HOVER = new ImageIcon(sort);

        final BufferedImage construction = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/construction.png");
        CONSTRUCTION = new ImageIcon(construction);

        final BufferedImage recipeHelp = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/recipehelp.png");
        RECIPE_HELP = new ImageIcon(recipeHelp);

        final BufferedImage magnifyingGlass = ImageUtil.getResourceStreamFromClass(FlippingPlugin.class, "/magnifying-glass.png");
        MAGNIFYING_GLASS = new ImageIcon(magnifyingGlass);
        MAGNIFYING_GLASS_HOVER = new ImageIcon(ImageUtil.alphaOffset(magnifyingGlass,.53f));
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.uiutilities;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

//have to extend MaterialTabGroup just to make it compatible with MaterialTab...not actually using any functionality
//from the parent. The difference between this TabGroup and MaterialTabGroup is just that this uses a card layout
//cause its faster when switching between different views
@Slf4j
public class FastTabGroup extends MaterialTabGroup
{
	/* The panel on which the tab's content or the view will be displayed on. */
	private final JPanel display;
	/* A list of all the tabs contained in this group. */
	private final List<MaterialTab> tabs = new ArrayList<>();
	@Getter
	private String lastSelectedTab;
	@Getter
	private JComponent currentlySelectedTab;
	private boolean currentlyShowingView = false;

	public FastTabGroup(JPanel display)
	{
		this.display = display;
		this.display.setLayout(new CardLayout());
		setLayout(new FlowLayout(FlowLayout.CENTER, 8, 0));
	}

	public void addTab(MaterialTab tab)
	{
		tabs.add(tab);
		display.add(tab.getContent(), tab.getText());
		add(tab, BorderLayout.NORTH);
	}

	/**
	 * A "view" is just a Jpanel. It just doesn't have a tab that can be selected by the user to display it. As such, a view
	 * is displayed programatically when it needs to be. For example, the GeHistoryTabPanel is a "view" and doesn't have
	 * a tab. It is displayed only when the user looks at their ge history.
	 * @param panel the view to add to the main display panel
	 * @param name the name of the view. This name is so that the view can be shown using it.
	 */
	public void addView(JPanel panel, String name) {
		display.add(panel, name);
	}

	public boolean select(MaterialTab selectedTab)
	{
		// If the OnTabSelected returned false, exit the method to prevent tab switching
		if (!selectedTab.select())
		{
			return false;
		}
		currentlyShowingView = false;
		lastSelectedTab = selectedTab.getText();
		currentlySelectedTab = selectedTab.getContent();
		CardLayout cardLayout = (CardLayout) display.getLayout();
		cardLayout.show(display, selectedTab.getText());

		//Unselect all other tabs
		for (MaterialTab tab : tabs)
		{
			if (!tab.equals(selectedTab))
			{
				tab.unselect();
			}
		}
		return true;
	}

	public void unselectAll() {
		tabs.forEach(tab-> tab.unselect());
	}

	public void showView(String name) {
		currentlyShowingView = true;
		unselectAll();
		CardLayout cardLayout = (CardLayout) display.getLayout();
		cardLayout.show(display, name);
	}

	public void revertToSafeDisplay() {
		if (currentlyShowingView) {

			selectPreviouslySelectedTab();
		}
	}

	public void selectPreviouslySelectedTab() {
		for (MaterialTab tab: tabs) {
			if (tab.getText().equals(lastSelectedTab)) {
				select(tab);
				break;
			}
		}
	}
}

package com.flippingutilities.ui.uiutilities;

import net.runelite.api.SpriteID;

import java.util.Arrays;
import java.util.List;

public class CustomSpriteIds {
    public static final int DEFAULT_GE_SLOT_BOTTOM = 989;
    public static final int DEFAULT_GE_SLOT_BOTTOM_LEFT = 993;
    public static final int DEFAULT_GE_SLOT_BOTTOM_RIGHT = 994;
    public static final int DEFAULT_GE_SLOT_TOP_LEFT = 991;
    public static final int DEFAULT_GE_SLOT_TOP_RIGHT = 992;
    public static final int DEFAULT_GE_SLOT_HORIZONTAL = 995;
    public static final int DEFAULT_GE_SLOT_INTERSECTION_LEFT = 996;
    public static final int DEFAULT_GE_SLOT_INTERSECTION_RIGHT = 997;
    public static final int DEFAULT_GE_SLOT_LEFT = 988;
    public static final int DEFAULT_GE_SLOT_RIGHT = 990;
    public static final int DEFAULT_GE_SLOT_TOP = 987;
    public static final int DEFAULT_GE_SLOT_ITEM_BOX = SpriteID.GE_SELECTED_ITEM_BOX;
    public static List<Integer> DEFAULT_SLOT_SPRITES = Arrays.asList(
        DEFAULT_GE_SLOT_BOTTOM, DEFAULT_GE_SLOT_BOTTOM_LEFT, DEFAULT_GE_SLOT_BOTTOM_RIGHT,
        DEFAULT_GE_SLOT_TOP_LEFT, DEFAULT_GE_SLOT_TOP_RIGHT, DEFAULT_GE_SLOT_HORIZONTAL,
        DEFAULT_GE_SLOT_INTERSECTION_LEFT, DEFAULT_GE_SLOT_INTERSECTION_RIGHT, DEFAULT_GE_SLOT_LEFT,
        DEFAULT_GE_SLOT_RIGHT, DEFAULT_GE_SLOT_TOP, DEFAULT_GE_SLOT_ITEM_BOX);

    public static final int RED_GE_SLOT_BOTTOM = 189546140;
    public static final int RED_GE_SLOT_BOTTOM_LEFT = 189546141;
    public static final int RED_GE_SLOT_BOTTOM_RIGHT = 189546142;
    public static final int RED_GE_SLOT_TOP_LEFT = 189546143;
    public static final int RED_GE_SLOT_TOP_RIGHT = 189546144;
    public static final int RED_GE_SLOT_HORIZONTAL = 189546145;
    public static final int RED_GE_SLOT_INTERSECTION_LEFT = 189546146;
    public static final int RED_GE_SLOT_INTERSECTION_RIGHT = 189546147;
    public static final int RED_GE_SLOT_LEFT = 189546148;
    public static final int RED_GE_SLOT_RIGHT = 189546149;
    public static final int RED_GE_SLOT_TOP = 189546150;
    public static final int RED_GE_SLOT_ITEM_BOX = 189546151;
    public static List<Integer> RED_SLOT_SPRITES = Arrays.asList(
        RED_GE_SLOT_BOTTOM, RED_GE_SLOT_BOTTOM_LEFT, RED_GE_SLOT_BOTTOM_RIGHT,
        RED_GE_SLOT_TOP_LEFT, RED_GE_SLOT_TOP_RIGHT, RED_GE_SLOT_HORIZONTAL,
        RED_GE_SLOT_INTERSECTION_LEFT, RED_GE_SLOT_INTERSECTION_RIGHT, RED_GE_SLOT_LEFT,
        RED_GE_SLOT_RIGHT, RED_GE_SLOT_TOP, RED_GE_SLOT_ITEM_BOX);

    public static final int BLUE_GE_SLOT_BOTTOM = 189546152;
    public static final int BLUE_GE_SLOT_BOTTOM_LEFT = 189546153;
    public static final int BLUE_GE_SLOT_BOTTOM_RIGHT = 189546154;
    public static final int BLUE_GE_SLOT_TOP_LEFT = 189546155;
    public static final int BLUE_GE_SLOT_TOP_RIGHT = 189546156;
    public static final int BLUE_GE_SLOT_HORIZONTAL = 189546157;
    public static final int BLUE_GE_SLOT_INTERSECTION_LEFT = 189546158;
    public static final int BLUE_GE_SLOT_INTERSECTION_RIGHT = 189546159;
    public static final int BLUE_GE_SLOT_LEFT = 189546160;
    public static final int BLUE_GE_SLOT_RIGHT = 189546161;
    public static final int BLUE_GE_SLOT_TOP = 189546162;
    public static final int BLUE_GE_SLOT_ITEM_BOX = 189546163;
    public static List<Integer> BLUE_SLOT_SPRITES = Arrays.asList(
        BLUE_GE_SLOT_BOTTOM, BLUE_GE_SLOT_BOTTOM_LEFT, BLUE_GE_SLOT_BOTTOM_RIGHT,
        BLUE_GE_SLOT_TOP_LEFT, BLUE_GE_SLOT_TOP_RIGHT, BLUE_GE_SLOT_HORIZONTAL,
        BLUE_GE_SLOT_INTERSECTION_LEFT, BLUE_GE_SLOT_INTERSECTION_RIGHT, BLUE_GE_SLOT_LEFT,
        BLUE_GE_SLOT_RIGHT, BLUE_GE_SLOT_TOP, BLUE_GE_SLOT_ITEM_BOX);

    public static final int GREEN_GE_SLOT_BOTTOM = 189546164;
    public static final int GREEN_GE_SLOT_BOTTOM_LEFT = 189546165;
    public static final int GREEN_GE_SLOT_BOTTOM_RIGHT = 189546166;
    public static final int GREEN_GE_SLOT_TOP_LEFT = 189546167;
    public static final int GREEN_GE_SLOT_TOP_RIGHT = 189546168;
    public static final int GREEN_GE_SLOT_HORIZONTAL = 189546169;
    public static final int GREEN_GE_SLOT_INTERSECTION_LEFT = 189546170;
    public static final int GREEN_GE_SLOT_INTERSECTION_RIGHT = 189546171;
    public static final int GREEN_GE_SLOT_LEFT = 189546172;
    public static final int GREEN_GE_SLOT_RIGHT = 189546173;
    public static final int GREEN_GE_SLOT_TOP = 189546174;
    public static final int GREEN_GE_SLOT_ITEM_BOX = 189546175;
    public static List<Integer> GREEN_SLOT_SPRITES = Arrays.asList(
        GREEN_GE_SLOT_BOTTOM, GREEN_GE_SLOT_BOTTOM_LEFT, GREEN_GE_SLOT_BOTTOM_RIGHT,
        GREEN_GE_SLOT_TOP_LEFT, GREEN_GE_SLOT_TOP_RIGHT, GREEN_GE_SLOT_HORIZONTAL,
        GREEN_GE_SLOT_INTERSECTION_LEFT, GREEN_GE_SLOT_INTERSECTION_RIGHT, GREEN_GE_SLOT_LEFT,
        GREEN_GE_SLOT_RIGHT, GREEN_GE_SLOT_TOP, GREEN_GE_SLOT_ITEM_BOX);
}

package com.flippingutilities.ui.flipping;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.Section;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.List;

@Slf4j
public class CustomizationPanel extends JPanel {
    FlippingPlugin plugin;
    List<Section> sections;

    public CustomizationPanel(FlippingPlugin plugin) {
        this.plugin = plugin;
        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(Color.BLACK.darker());
        setBorder(new EmptyBorder(10,10,10,10));
    }

    private JPanel createSectionPanel(Section section) {
        JPanel sectionPanel = new JPanel();
        sectionPanel.setBackground(Color.BLACK.darker());
        sectionPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
        sectionPanel.setLayout(new BoxLayout(sectionPanel, BoxLayout.Y_AXIS));

        JLabel titleLabel = new JLabel("Section name: " + section.getName());
        titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        titleLabel.setFont(FontManager.getRunescapeBoldFont());

        JPanel makeSectionDefaultExpandedPanel = new JPanel(new FlowLayout());
        makeSectionDefaultExpandedPanel.setBackground(Color.BLACK.darker());
        JLabel shouldMakeSectionExpandedLabel = new JLabel("expand section by default");
        shouldMakeSectionExpandedLabel.setFont(new Font(FontManager.getRunescapeSmallFont().getName(), Font.ITALIC, FontManager.getRunescapeSmallFont().getSize()));

        JToggleButton toggleButton = UIUtilities.createToggleButton();
        toggleButton.setSelected(section.isDefaultExpanded());
        toggleButton.addItemListener(i ->
        {
            section.setDefaultExpanded(toggleButton.isSelected());
            onSectionChange();
        });
        makeSectionDefaultExpandedPanel.add(shouldMakeSectionExpandedLabel);
        makeSectionDefaultExpandedPanel.add(toggleButton);

        sectionPanel.add(titleLabel);
        sectionPanel.add(makeSectionDefaultExpandedPanel);
        sectionPanel.add(Box.createVerticalStrut(10));

        for (String labelName : Section.possibleLabels) {
            sectionPanel.add(createPanelForSectionLabel(section, labelName));
            sectionPanel.add(Box.createVerticalStrut(3));
        }
        return sectionPanel;
    }

    private boolean labelUsedInAnotherSection(Section section, String labelName) {
        for (Section otherSection: sections) {
            if (section != otherSection) {
                if (otherSection.isShowingLabel(labelName)) {
                    return true;
                }
            }
        }
        return false;
    }

    private JPanel createPanelForSectionLabel(Section section, String labelName) {
        boolean labelUsedInOtherSection = labelUsedInAnotherSection(section, labelName);
        JPanel sectionLabelPanel = new JPanel(new BorderLayout());
        sectionLabelPanel.setBackground(Color.BLACK.darker());
        JLabel sectionLabel = new JLabel(labelUsedInOtherSection? labelName + " (disabled: used in other section)" :labelName);
        sectionLabel.setFont(FontManager.getRunescapeSmallFont());
        sectionLabel.setForeground(labelUsedInOtherSection? ColorScheme.MEDIUM_GRAY_COLOR : Color.WHITE);
        JToggleButton sectionLabelToggle = UIUtilities.createToggleButton();
        sectionLabelToggle.setSelected(section.isShowingLabel(labelName));
        sectionLabelToggle.setEnabled(!labelUsedInOtherSection);
        sectionLabelToggle.setDisabledIcon(Icons.TOGGLE_OFF);

        sectionLabelToggle.addItemListener(i ->
        {
            section.showLabel(labelName, sectionLabelToggle.isSelected());
            onSectionChange();
        });

        sectionLabelPanel.add(sectionLabel, BorderLayout.WEST);
        sectionLabelPanel.add(sectionLabelToggle, BorderLayout.EAST);
        return sectionLabelPanel;
    }

    private void onSectionChange() {
        rebuild(sections);
        plugin.getFlippingPanel().rebuild(plugin.viewItemsForCurrentView());
        plugin.getDataHandler().markDataAsHavingChanged(FlippingPlugin.ACCOUNT_WIDE);
    }

    public void rebuild(List<Section> sections) {
        this.sections = sections;
        removeAll();
        sections.forEach(section -> add(createSectionPanel(section)));
        revalidate();
        repaint();

    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.flipping;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.offereditor.OfferEditorContainerPanel;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.Paginator;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import com.flippingutilities.utilities.Constants;
import com.flippingutilities.utilities.WikiRequestWrapper;
import com.google.common.base.Strings;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.http.api.item.ItemPrice;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class FlippingPanel extends JPanel
{
	@Getter
	private static final String WELCOME_PANEL = "WELCOME_PANEL";
	private static final String ITEMS_PANEL = "ITEMS_PANEL";

	private final FlippingPlugin plugin;
	private final ItemManager itemManager;

	public final CardLayout cardLayout = new CardLayout();

	private final JPanel flippingItemsPanel = new JPanel();
	public final JPanel flippingItemContainer = new JPanel(cardLayout);

	//Keeps track of all items currently displayed on the panel.
	private ArrayList<FlippingItemPanel> activePanels = new ArrayList<>();

	@Getter
	@Setter
	private boolean itemHighlighted = false;

	@Getter
	private Paginator paginator;

	@Getter
	private OfferEditorContainerPanel offerEditorContainerPanel;
	private IconTextField searchBar;

	private boolean currentlySearching;
	private boolean favoriteSelected;

	public FlippingPanel(final FlippingPlugin plugin)
	{
		super(false);

		this.plugin = plugin;
		this.itemManager = plugin.getItemManager();


		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		//Holds all the item panels
		flippingItemsPanel.setLayout(new BoxLayout(flippingItemsPanel, BoxLayout.Y_AXIS));
		flippingItemsPanel.setBorder((new EmptyBorder(0, 8, 0, 7)));
		flippingItemsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel wrapper = new JPanel(new BorderLayout());
		wrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wrapper.add(flippingItemsPanel, BorderLayout.NORTH);

		JScrollPane scrollPane = new JScrollPane(wrapper);
		scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));

		//Contains a greeting message when the items panel is empty.
		JPanel welcomeWrapper = new JPanel(new BorderLayout());
		welcomeWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		PluginErrorPanel welcomePanel = new PluginErrorPanel();
		welcomeWrapper.add(welcomePanel, BorderLayout.NORTH);

		//The welcome panel instructs the user on how to use the plugin
		//Shown whenever there are no items on the panel
		welcomePanel.setContent("Flipping Utilities",
			"Make offers for items to show up!");

		flippingItemContainer.add(scrollPane, ITEMS_PANEL);
		flippingItemContainer.add(welcomeWrapper, WELCOME_PANEL);

		searchBar = UIUtilities.createSearchBar(plugin.getExecutor(),
				(sBar) -> plugin.getClientThread().invoke(() -> this.updateSearch(sBar)));
		searchBar.setBorder(BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()));

		final JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBorder(new EmptyBorder(0,8,2,10));
		topPanel.add(searchBar, BorderLayout.CENTER);
		topPanel.add(this.createFavoriteButton(), BorderLayout.EAST);

		paginator = new Paginator(() -> rebuild(plugin.viewItemsForCurrentView()));
		paginator.setBackground(ColorScheme.DARK_GRAY_COLOR);
		paginator.setBorder(new MatteBorder(1,0,0,2, ColorScheme.DARK_GRAY_COLOR.darker()));
		paginator.setPageSize(10);

		//To switch between greeting and items panels
		cardLayout.show(flippingItemContainer, WELCOME_PANEL);
		add(topPanel, BorderLayout.NORTH);
		add(flippingItemContainer, BorderLayout.CENTER);
		add(paginator, BorderLayout.SOUTH);
		setBorder(new EmptyBorder(5,0,0,0));
	}

	/**
	 * Creates and renders the panel using the flipping items in the listed parameter.
	 * An item is only displayed if it contains a valid OfferInfo object in its history.
	 *
	 * @param flippingItems List of flipping items that the rebuildItemsDisplay will render.
	 */
	public void rebuild(List<FlippingItem> flippingItems)
	{
		SwingUtilities.invokeLater(() ->
		{
			activePanels.forEach(p -> p.popup.setVisible(false));
			activePanels.clear();
			flippingItemsPanel.removeAll();
			if (flippingItems == null)
			{
				cardLayout.show(flippingItemContainer, WELCOME_PANEL);
				return;
			}
			int vGap = 8;
			cardLayout.show(flippingItemContainer, ITEMS_PANEL);
			List<FlippingItem> itemsToDisplay = getItemsToDisplay(flippingItems);
			List<FlippingItem> itemsThatShouldHavePanels = itemsToDisplay.stream().filter(item -> item.getValidFlippingPanelItem()).collect(Collectors.toList());
			paginator.updateTotalPages(itemsThatShouldHavePanels.size());
			List<FlippingItem> itemsOnCurrentPage = paginator.getCurrentPageItems(itemsThatShouldHavePanels);
			List<FlippingItemPanel> newPanels = itemsOnCurrentPage.stream().map(item -> new FlippingItemPanel(plugin, itemManager.getImage(item.getItemId()), item)).collect(Collectors.toList());
			flippingItemsPanel.add(Box.createVerticalStrut(vGap));
			UIUtilities.stackPanelsVertically((List) newPanels, flippingItemsPanel, vGap);
			flippingItemsPanel.add(Box.createVerticalStrut(vGap));
			activePanels.addAll(newPanels);

			if (isItemHighlighted()) {
				offerEditorContainerPanel = new OfferEditorContainerPanel(plugin);
				offerEditorContainerPanel.selectPriceEditor();
				flippingItemsPanel.add(offerEditorContainerPanel);
				flippingItemsPanel.add(Box.createVerticalStrut(vGap));
			}

			if (activePanels.isEmpty() && !itemHighlighted)
			{
				cardLayout.show(flippingItemContainer, WELCOME_PANEL);
			}

			revalidate();
			repaint();
		});

	}

	/**
	 * Handles rebuilding the flipping panel when a new offer event comes in. There are several cases
	 * where we don't want to rebuildItemsDisplay either because it is unnecessary or visually annoying for a user.
	 * @param offerEvent the new offer that just came in
	 */
	public void onNewOfferEventRebuild(OfferEvent offerEvent) {
		boolean newOfferEventAlreadyAtTop = activePanels.size() > 0 && activePanels.get(0).getFlippingItem().getItemId() == offerEvent.getItemId();
		if (newOfferEventAlreadyAtTop) {
			refreshPricesForFlippingItemPanel(offerEvent.getItemId());
			return;
		}
		//it's annoying when you have searched an item up or an item is
		//highlighted and then the panel is rebuilt due to an offer coming in. This guard prevents that.
		if (!isItemHighlighted() && !currentlySearching) {
			rebuild(plugin.viewItemsForCurrentView());
		}
	}

	private List<FlippingItem> getItemsToDisplay(List<FlippingItem> tradeList) {
		List<FlippingItem> result = new ArrayList<>(tradeList);

		if (favoriteSelected && !isItemHighlighted()) {
			result = result.stream().filter(FlippingItem::isFavorite).collect(Collectors.toList());
		}
		result = getResultsForCurrentSearchQuery(result);
		sortByTime(result);
		return result;
	}

	private List<FlippingItem> getResultsForCurrentSearchQuery(List<FlippingItem> items) {
		String lookup = searchBar.getText().toLowerCase();
		if (!currentlySearching || Strings.isNullOrEmpty(lookup)) {
			return items;
		}
		Map<Integer, FlippingItem> currentFlippingItems = items.stream().collect(Collectors.toMap(f -> f.getItemId(), f -> f));
		List<FlippingItem> matchesInHistory = new ArrayList<>();
		List<FlippingItem> matchesNotInHistory = new ArrayList<>();
		for (ItemPrice itemInfo:  itemManager.search(lookup)) {
			if (currentFlippingItems.containsKey(itemInfo.getId())) {
				FlippingItem flippingItem = currentFlippingItems.get(itemInfo.getId());
				flippingItem.setValidFlippingPanelItem(true);
				matchesInHistory.add(flippingItem);
			}
			else {
				FlippingItem dummyFlippingItem = new FlippingItem(itemInfo.getId(), itemInfo.getName(), 0, Constants.DUMMY_ITEM);
				dummyFlippingItem.setValidFlippingPanelItem(true);
				matchesNotInHistory.add(dummyFlippingItem);
			}
		}

		List<FlippingItem> allMatches = new ArrayList<>();
		allMatches.addAll(matchesInHistory);
		allMatches.addAll(matchesNotInHistory);
		return allMatches;
	}

	private void sortByTime(List<FlippingItem> items) {
		items.sort((item1, item2) ->
		{
			if (item1 == null || item2 == null)
			{
				return -1;
			}
			if (item1.getLatestActivityTime() == null || item2.getLatestActivityTime() == null) {
				return -1;
			}

			return item2.getLatestActivityTime().compareTo(item1.getLatestActivityTime());
		});
	}

	//Clears all other items, if the item in the offer setup slot is presently available on the panel
	public void highlightItem(FlippingItem item)
	{
		SwingUtilities.invokeLater(() -> {
			paginator.setPageNumber(1);
			itemHighlighted = true;
			rebuild(Collections.singletonList(item));
		});
	}

	private JLabel createFavoriteButton() {
		JLabel favoriteButton = new JLabel(Icons.SMALL_STAR_OFF_ICON);
		favoriteButton.setBorder(new EmptyBorder(0,5,0,0));
		favoriteButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (favoriteSelected) {
					favoriteButton.setIcon(Icons.SMALL_STAR_OFF_ICON);
				}
				else {
					favoriteButton.setIcon(Icons.SMALL_STAR_ON_ICON);
				}
				favoriteSelected = !favoriteSelected;
				rebuild(plugin.viewItemsForCurrentView());
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				if (!favoriteSelected) {
					favoriteButton.setIcon(Icons.SMALL_STAR_HOVER_ICON);
				}
			}

			@Override
			public void mouseExited(MouseEvent e) {
				if (favoriteSelected) {
					favoriteButton.setIcon(Icons.SMALL_STAR_ON_ICON);
				}
				else {
					favoriteButton.setIcon(Icons.SMALL_STAR_OFF_ICON);
				}
			}
		});
		return favoriteButton;
	}

	//This is run whenever the PlayerVar containing the GE offer slot changes to its empty value (-1)
	// or if the GE is closed/history tab opened
	public void dehighlightItem()
	{
		if (!itemHighlighted)
		{
			return;
		}
		itemHighlighted = false;
		rebuild(plugin.viewItemsForCurrentView());
	}

	/**
	 * Checks if a FlippingItem's margins (buy and sell price) are outdated and updates the tooltip.
	 * This method is called in FlippingPlugin every second by the scheduler.
	 */
	public void updateTimerDisplays()
	{
		for (FlippingItemPanel activePanel : activePanels)
		{
			activePanel.updateTimerDisplays();
			activePanel.updateWikiTimeLabels();
		}
	}

	public void onWikiRequest(WikiRequestWrapper wikiRequestWrapper, Instant timeOfRequestCompletion) {
		activePanels.forEach(panel -> panel.onWikiRequest(wikiRequestWrapper, timeOfRequestCompletion));
	}


	private void updateSearch(IconTextField searchBar)
	{
		String lookup = searchBar.getText().toLowerCase();

		//Just so we don't mess with the highlight.
		if (isItemHighlighted())
		{
			currentlySearching = false;
			return;
		}

		//When the clear button is pressed, this is run.
		if (Strings.isNullOrEmpty(lookup))
		{
			paginator.setPageNumber(1);
			currentlySearching = false;
			rebuild(plugin.viewItemsForCurrentView());
			return;
		}

		searchBar.setIcon(IconTextField.Icon.SEARCH);
		currentlySearching = true;
		paginator.setPageNumber(1);
		rebuild(plugin.viewItemsForCurrentView());
	}

	public void refreshPricesForFlippingItemPanel(int itemId) {
		for (FlippingItemPanel panel:activePanels) {
			if (panel.getFlippingItem().getItemId() == itemId) {
				panel.setValueLabels();
			}
		}
	}
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.flipping;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.jobs.WikiDataFetcherJob;
import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.model.Section;
import com.flippingutilities.ui.uiutilities.*;
import com.flippingutilities.utilities.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.List;

/**
 * Represents an instance of one of the many panels on the FlippingPanel. It is used to display information such as
 * the margin check prices of the flipping item, the ge limit left, when the ge limit will refresh, the ROI, etc.
 */
@Slf4j
public class FlippingItemPanel extends JPanel
{
	private static final String NUM_FORMAT = "%,d";

	@Getter
	private final FlippingItem flippingItem;
	private FlippingPlugin plugin;

	//All the labels that hold the actual values for these properties.
	JLabel wikiBuyVal = new JLabel();
	JLabel wikiSellVal = new JLabel();
	JLabel wikiBuyTimeVal = new JLabel();
	JLabel wikiSellTimeVal = new JLabel();
	JLabel instaSellVal = new JLabel();
	JLabel instaBuyVal = new JLabel();
	JLabel latestBuyPriceVal = new JLabel();
	JLabel latestSellPriceVal = new JLabel();
	JLabel wikiProfitEachVal = new JLabel();
	JLabel wikiPotentialProfitVal = new JLabel();
	JLabel wikiRoiLabelVal = new JLabel();
	JLabel geLimitVal = new JLabel();
	JLabel marginCheckProfitEachVal = new JLabel();
	JLabel geRefreshCountdownLabel = new JLabel();
	JLabel wikiRequestCountDownTimer = new JLabel();
	//local time the ge limit will reset
	JLabel geRefreshAtLabel = new JLabel();

	//description labels
	JLabel wikiBuyText = new JLabel("Wiki insta buy: ");
	JLabel wikiSellText = new JLabel("Wiki insta sell: ");
	JLabel wikiBuyTimeText = new JLabel("Wiki insta buy age: ");
	JLabel wikiSellTimeText = new JLabel("Wiki insta sell age: ");
	JLabel instaSellText = new JLabel("Last insta sell: ");
	JLabel instaBuyText = new JLabel("Last insta buy: ");
	JLabel latestBuyPriceText = new JLabel("Last buy price: ");
	JLabel latestSellPriceText = new JLabel("Last sell price: ");
	JLabel wikiProfitEachText = new JLabel("Wiki profit ea: ");
	JLabel marginCheckProfitEachText = new JLabel("MC profit ea: ");
	JLabel wikiPotentialProfitText = new JLabel("Potential profit: ");
	JLabel wikiRoiText = new JLabel("ROI:", JLabel.CENTER);
	JLabel geLimitText = new JLabel("GE limit:",JLabel.CENTER);

	JPanel itemInfo;

	JLabel searchCodeLabel;
	JLabel refreshIconLabel = new JLabel();

	WikiRequestWrapper wikiRequestWrapper;
	Instant timeOfRequestCompletion;

	JPopupMenu popup;

	FlippingItemPanel(final FlippingPlugin plugin, AsyncBufferedImage itemImage, final FlippingItem flippingItem)
	{
		this.flippingItem = flippingItem;
		this.plugin = plugin;
		flippingItem.validateGeProperties();
		setBackground(CustomColors.DARK_GRAY);
		setLayout(new BorderLayout());
		setBorder(new CompoundBorder(
				new MatteBorder(2, 2, 2, 2, ColorScheme.DARKER_GRAY_COLOR.darker()),
				new EmptyBorder(10,5,0,0)));

		setToolTipText("Flipped by " + flippingItem.getFlippedBy());

		styleDescriptionLabels();
		styleValueLabels();
		setValueLabels();
		updateTimerDisplays();

		JPanel titlePanel = createTitlePanel(createItemIcon(itemImage), createItemNameLabel(), createFavoriteIcon());
		itemInfo = createItemInfoPanel();
		add(titlePanel, BorderLayout.NORTH);
		add(itemInfo, BorderLayout.CENTER);
		add(createBottomPanel(), BorderLayout.SOUTH);

		//if it is enabled, the itemInfo panel is visible by default so no reason to check it
		if (!plugin.getConfig().verboseViewEnabled())
		{
			collapse();
		}

		//if user has "overridden" the config option by expanding/collapsing that item, use what they set instead of the config value.
		if (flippingItem.getExpand() != null)
		{
			if (flippingItem.getExpand())
			{
				expand();
			}
			else
			{
				collapse();
			}
		}
	}

	/**
	 * Creates the panel which contains all the info about the item like its price check prices, limit
	 * remaining, etc.
	 * @return
	 */
	private JPanel createItemInfoPanel()
	{
		JPanel itemInfo = new JPanel();
		itemInfo.setLayout(new BoxLayout(itemInfo, BoxLayout.Y_AXIS));
		itemInfo.setBackground(getBackground());
		itemInfo.setBorder(new EmptyBorder(20,6,8,8));
		List<Section> sections = plugin.getDataHandler().viewAccountWideData().getSections();
		for (Section section : sections) {
			itemInfo.add(createSectionPanel(section));
			itemInfo.add(Box.createVerticalStrut(5));
		}
		return itemInfo;
	}

	private JPanel createSectionPanel(Section section) {
		JPanel sectionPanel = new JPanel(new BorderLayout());
		sectionPanel.setBackground(getBackground());

		JLabel arrowIconLabel = new JLabel(section.isDefaultExpanded()? Icons.OPEN_ICON : Icons.CLOSE_ICON);
		arrowIconLabel.setVerticalAlignment(JLabel.NORTH);
		arrowIconLabel.setFont(FontManager.getRunescapeBoldFont());
		arrowIconLabel.setBorder(new EmptyBorder(0,0,0,5));

		sectionPanel.add(arrowIconLabel, BorderLayout.WEST);

		JPanel sectionItemsPanel = new JPanel();
		sectionItemsPanel.setLayout(new BoxLayout(sectionItemsPanel, BoxLayout.Y_AXIS));
		sectionItemsPanel.setBackground(getBackground());
		if (!section.isDefaultExpanded()) {
			arrowIconLabel.setText(section.getName());
			sectionItemsPanel.setVisible(false);
		}

		sectionPanel.add(sectionItemsPanel, BorderLayout.CENTER);
		arrowIconLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (sectionItemsPanel.isVisible()) {
					sectionItemsPanel.setVisible(false);
					arrowIconLabel.setIcon(Icons.CLOSE_ICON);
					arrowIconLabel.setText(section.getName());
				}
				else {
					sectionItemsPanel.setVisible(true);
					arrowIconLabel.setIcon(Icons.OPEN_ICON);
					arrowIconLabel.setText("");
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				super.mouseEntered(e);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				super.mouseExited(e);
			}
		});

		List<String> labelsToShow = new ArrayList<>();
		for (String labelName: section.getLabels().keySet()) {
			if (section.getLabels().get(labelName)) {
				labelsToShow.add(labelName);
			}
		}
		boolean isFirstInPair = true;
		for (String labelName : labelsToShow) {
			JPanel panel = createPanelForSectionLabel(labelName);
			if (isFirstInPair) {
				panel.setBorder(new EmptyBorder(6,0,3,0));
			}
			else {
				panel.setBorder(new EmptyBorder(2,0,8,0));
			}
			isFirstInPair = !isFirstInPair;
			sectionItemsPanel.add(panel);
		}

		return sectionPanel;
	}

	private JPanel createPanelForSectionLabel(String labelName) {
		JPanel panel = new JPanel(new BorderLayout());
		panel.setBackground(getBackground());
		JComponent descriptionLabel;
		JComponent valueLabel;
		switch (labelName) {
			case Section.WIKI_BUY_PRICE:
				descriptionLabel = wikiBuyText;
				valueLabel = wikiBuyVal;
				break;
			case Section.WIKI_SELL_PRICE:
				descriptionLabel = wikiSellText;
				valueLabel = wikiSellVal;
				break;
			case Section.LAST_INSTA_SELL_PRICE:
				JLabel instaSellPreTaxLabel = new JLabel("Pre tax");
				instaSellPreTaxLabel.setFont(new Font("Whitney", Font.ITALIC, 6));

				JPanel instaSellDescPanel = new JPanel(new DynamicGridLayout(2,1));
				instaSellDescPanel.setBackground(CustomColors.DARK_GRAY);
				instaSellDescPanel.add(instaSellText);
				instaSellDescPanel.add(instaSellPreTaxLabel);

				descriptionLabel = instaSellDescPanel;
				valueLabel = instaSellVal;
				break;
			case Section.LAST_INSTA_BUY_PRICE:
				descriptionLabel = instaBuyText;
				valueLabel = instaBuyVal;
				makePropertyPanelEditable(panel, instaBuyVal, instaBuyText);
				break;
			case Section.LAST_BUY_PRICE:
				descriptionLabel = latestBuyPriceText;
				valueLabel = latestBuyPriceVal;
				makePropertyPanelEditable(panel, latestBuyPriceVal, latestBuyPriceText);
				break;
			case Section.LAST_SELL_PRICE:
				JLabel preTaxLabel = new JLabel("Pre tax");
				preTaxLabel.setFont(new Font("Whitney", Font.ITALIC, 6));

				JPanel sellDescPanel = new JPanel(new DynamicGridLayout(2,1));
				sellDescPanel.setBackground(CustomColors.DARK_GRAY);
				sellDescPanel.add(latestSellPriceText);
				sellDescPanel.add(preTaxLabel);

				descriptionLabel = sellDescPanel;
				valueLabel = latestSellPriceVal;
				break;
			case Section.WIKI_PROFIT_EACH:
				descriptionLabel = wikiProfitEachText;
				valueLabel = wikiProfitEachVal;
				break;
			case Section.POTENTIAL_PROFIT:
				descriptionLabel = wikiPotentialProfitText;
				valueLabel = wikiPotentialProfitVal;
				break;
			case Section.ROI:
				descriptionLabel = wikiRoiText;
				valueLabel = wikiRoiLabelVal;
				break;
			case Section.REMAINING_GE_LIMIT:
				descriptionLabel = geLimitText;
				valueLabel = geLimitVal;
				break;
			case Section.GE_LIMIT_REFRESH_TIMER:
				//no description or value label for this. The timer is a panel itself.
				return createGeTimerPanel();
			case Section.MARGIN_CHECK_PROFIT_EACH:
				descriptionLabel = marginCheckProfitEachText;
				valueLabel = marginCheckProfitEachVal;
				break;
			default:
				//this should never be reached
				return new JPanel();
		}
		panel.add(descriptionLabel, BorderLayout.WEST);
		panel.add(valueLabel, BorderLayout.EAST);
		return panel;
	}

	private JPanel createBottomPanel() {
		JPanel bottomPanel = new JPanel(new BorderLayout());
		bottomPanel.setBackground(CustomColors.DARK_GRAY);
		bottomPanel.setBorder(new EmptyBorder(8,8,8,8));

		JLabel searchIconLabel = new JLabel(Icons.SEARCH);
		searchIconLabel.setToolTipText("Click to search realtime prices for this item!");
		searchIconLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				LinkBrowser.browse(UIUtilities.buildOurWebsiteLink(flippingItem.getItemId()));
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				searchIconLabel.setIcon(Icons.SEARCH_HOVER);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				searchIconLabel.setIcon(Icons.SEARCH);
			}
		});

		TextField searchCodeTextField = new TextField(10);

		JPanel searchCodePanel = new JPanel();
		searchCodePanel.setBorder(new EmptyBorder(0,0,0,4));
		searchCodePanel.setBackground(CustomColors.DARK_GRAY);
		searchCodePanel.setPreferredSize(new Dimension(0,20));
		searchCodeLabel = new JLabel("<html> quick search code: " + UIUtilities.colorText(flippingItem.getFavoriteCode(), ColorScheme.GRAND_EXCHANGE_ALCH) + "</html>", JLabel.CENTER);
		if (flippingItem.isFavorite()) {
			searchCodeLabel.setText("<html> quick search code: " + UIUtilities.colorText(flippingItem.getFavoriteCode(), ColorScheme.GRAND_EXCHANGE_PRICE) + "</html>");
		}
		else {
			searchCodeLabel.setText("<html> quick search code: " + UIUtilities.colorText("N/A", ColorScheme.GRAND_EXCHANGE_ALCH) + "</html>");
		}
		searchCodeLabel.setToolTipText("<html>If you have favorited this item, you can type the search code when you are <br>" +
				"searching for items in the ge to populate your ge results with any item with this code</html>");
		searchCodeLabel.setFont(FontManager.getRunescapeSmallFont());

		searchCodePanel.add(searchCodeLabel);

		final boolean[] isHighlighted = {false};
		MouseListener l = new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (!flippingItem.isFavorite()) {
					JOptionPane.showMessageDialog(searchCodeLabel, "<html>Item is not favorited.<br> Favorite the item to be able to use/edit the quick search code</html>");
					return;
				}

				if (isHighlighted[0]) {
					searchCodePanel.remove(searchCodeTextField);
					searchCodePanel.add(searchCodeLabel);
					isHighlighted[0] = false;
				}
				else {
					searchCodePanel.remove(searchCodeLabel);
					searchCodePanel.add(searchCodeTextField);
					isHighlighted[0] = true;
				}
				repaint();
				revalidate();
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				searchCodePanel.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				searchCodePanel.setBackground(getBackground());
			}
		};
		searchCodePanel.addMouseListener(l);
		searchCodeLabel.addMouseListener(l);

		searchCodeTextField.setBackground(ColorScheme.DARK_GRAY_COLOR);
		searchCodeTextField.setText(flippingItem.getFavoriteCode());
		searchCodeTextField.addActionListener(e -> {
			isHighlighted[0] = false;
			if (plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE)) {
				plugin.setFavoriteCodeOnAllAccounts(flippingItem, searchCodeTextField.getText());
			}
			else {
				plugin.markAccountTradesAsHavingChanged(plugin.getAccountCurrentlyViewed());
			}

			flippingItem.setFavoriteCode(searchCodeTextField.getText());

			searchCodeLabel.setText("<html> quick search code: " + UIUtilities.colorText(flippingItem.getFavoriteCode(), ColorScheme.GRAND_EXCHANGE_ALCH) + "</html>");

			searchCodePanel.remove(searchCodeTextField);
			searchCodePanel.add(searchCodeLabel);
			repaint();
			revalidate();
		});

		JPanel refreshIconPanel = new JPanel();
		refreshIconPanel.setLayout(new BoxLayout(refreshIconPanel, BoxLayout.X_AXIS));
		refreshIconPanel.setBackground(getBackground());

		refreshIconLabel.setIcon(Icons.REFRESH);
		refreshIconLabel.setDisabledIcon(Icons.REFRESH_HOVER);

		refreshIconPanel.add(refreshIconLabel);
		refreshIconPanel.add(Box.createHorizontalStrut(2));
		refreshIconPanel.add(wikiRequestCountDownTimer);

		bottomPanel.add(refreshIconPanel, BorderLayout.WEST);
		bottomPanel.add(searchIconLabel, BorderLayout.EAST);
		bottomPanel.add(searchCodePanel, BorderLayout.CENTER);
		return bottomPanel;
	}

	private void makePropertyPanelEditable(JPanel propertyPanel, JLabel valueLabel, JLabel descriptionLabel) {
		final boolean[] isHighlighted = {false};
		TextField textField = new TextField(10);
		textField.setBackground(ColorScheme.DARK_GRAY_COLOR);
		String currentText = valueLabel.getText();
		String textWithoutGp = currentText.substring(0, currentText.length()-3);
		textField.setText(textWithoutGp);
		textField.addActionListener((e1 -> {
			isHighlighted[0] = false;
			try {
				int num = Integer.parseInt(textField.getText().replace(",", ""));
				if (num <= 0) {
					JOptionPane.showMessageDialog(this,"You cannot input zero or a negative number");
					return;
				}
				valueLabel.setText(String.format(NUM_FORMAT, num) + " gp");
				OfferEvent dummyOffer;
				if (valueLabel == instaSellVal) {
					dummyOffer = OfferEvent.dummyOffer(false, true, num, flippingItem.getItemId(), flippingItem.getItemName());
					flippingItem.setLatestInstaSell(Optional.of(dummyOffer));
				}
				else if (valueLabel == instaBuyVal){
					dummyOffer = OfferEvent.dummyOffer(true, true, num, flippingItem.getItemId(), flippingItem.getItemName());
					flippingItem.setLatestInstaBuy(Optional.of(dummyOffer));
				}
				else if (valueLabel == latestBuyPriceVal){
					dummyOffer = OfferEvent.dummyOffer(true, false, num, flippingItem.getItemId(), flippingItem.getItemName());
					flippingItem.setLatestBuy(Optional.of(dummyOffer));
				}
				else {
					dummyOffer = OfferEvent.dummyOffer(false, false, num, flippingItem.getItemId(), flippingItem.getItemName());
					flippingItem.setLatestSell(Optional.of(dummyOffer));
				}

				setValueLabels();
			}
			catch (NumberFormatException e) {
				JOptionPane.showMessageDialog(this, "You need to input a number");
				return;
			}
			propertyPanel.remove(textField);
			propertyPanel.add(valueLabel, BorderLayout.EAST);
			revalidate();
			repaint();
		}));
		MouseAdapter m = new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (isHighlighted[0]) {
					isHighlighted[0] = false;
					propertyPanel.remove(textField);
					propertyPanel.add(valueLabel, BorderLayout.EAST);
				}
				else {
					isHighlighted[0] = true;
					propertyPanel.remove(valueLabel);
					propertyPanel.add(textField, BorderLayout.EAST);
				}
				revalidate();
				repaint();
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				propertyPanel.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				propertyPanel.setBackground(CustomColors.DARK_GRAY);
			}
		};
		propertyPanel.addMouseListener(m);
		descriptionLabel.addMouseListener(m);
	}

	private JPanel createGeTimerPanel() {
		JPanel geRefreshTimePanel = new JPanel(new DynamicGridLayout(2,1,0, 2));
		geRefreshTimePanel.setBorder(new EmptyBorder(8,0,5,30));
		geRefreshTimePanel.setBackground(CustomColors.DARK_GRAY);
		geRefreshTimePanel.add(geRefreshCountdownLabel);
		geRefreshTimePanel.add(geRefreshAtLabel);
		return geRefreshTimePanel;
	}

	private void styleValueLabels() {
		Arrays.asList(latestBuyPriceVal, latestSellPriceVal, instaSellVal, instaBuyVal, wikiProfitEachVal, marginCheckProfitEachVal, wikiPotentialProfitVal,
			wikiRoiLabelVal, geLimitVal).
				forEach(label -> {
					label.setHorizontalAlignment(JLabel.RIGHT);
					label.setFont(plugin.getFont());
				});

		instaSellVal.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		instaBuyVal.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);

		wikiProfitEachVal.setForeground(CustomColors.PROFIT_COLOR);
		marginCheckProfitEachVal.setForeground(CustomColors.SOFT_ALCH);
		wikiPotentialProfitVal.setForeground(CustomColors.PROFIT_COLOR);

		geRefreshCountdownLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		geRefreshCountdownLabel.setFont(FontManager.getRunescapeBoldFont());
		geRefreshCountdownLabel.setHorizontalAlignment(JLabel.CENTER);
		geRefreshCountdownLabel.setToolTipText("This is a timer displaying how much time is left before the GE limit refreshes for this item");
		geRefreshCountdownLabel.setBorder(new EmptyBorder(0,0,0,20));

		geRefreshAtLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		geRefreshAtLabel.setFont(FontManager.getRunescapeSmallFont());
		geRefreshAtLabel.setHorizontalAlignment(JLabel.CENTER);
		geRefreshAtLabel.setToolTipText("This shows the local time when the ge limit will refresh");
		geRefreshAtLabel.setBorder(new EmptyBorder(0,0,0,20));

		wikiRoiLabelVal.setToolTipText("<html>Return on investment:<br>Percentage of profit relative to gp invested</html>");

		wikiBuyVal.setFont(CustomFonts.SMALLER_RS_BOLD_FONT);
		wikiBuyVal.setForeground(Color.WHITE);
		wikiSellVal.setFont(CustomFonts.SMALLER_RS_BOLD_FONT);
		wikiSellVal.setForeground(Color.WHITE);

		wikiRequestCountDownTimer.setAlignmentY(JLabel.TOP);
		wikiRequestCountDownTimer.setFont(new Font(Font.SERIF, Font.PLAIN, 9));

		popup = new JPopupMenu();
		popup.add(createWikiHoverTimePanel());
		UIUtilities.addPopupOnHover(wikiBuyVal, popup, true);
		UIUtilities.addPopupOnHover(wikiSellVal, popup, true);
	}

	private void styleDescriptionLabels() {
		Arrays.asList(wikiBuyText, wikiSellText, latestBuyPriceText, latestSellPriceText, instaSellText, instaBuyText, wikiProfitEachText, marginCheckProfitEachText, wikiPotentialProfitText, geLimitText, wikiRoiText).
				forEach(label -> {
					label.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
					label.setFont(plugin.getFont());
				});

		/* Tooltips */
		instaSellText.setToolTipText("This is the price you insta sold the item for (pre tax)");
		instaBuyText.setToolTipText("This is the price you insta bought the item for");
		latestBuyPriceText.setToolTipText("The last price you bought this item for");
		latestSellPriceText.setToolTipText("The last price you sold this item for (pre tax)");
		wikiProfitEachText.setToolTipText("The profit margin according to the wiki insta buy and insta sell prices, after tax");
		marginCheckProfitEachText.setToolTipText("The profit margin according to your last insta buy and insta sell price, after tax");
		wikiPotentialProfitText.setToolTipText("The potential profit according to the wiki profit margin and the item's limit");
		geLimitText.setToolTipText("Remaining ge limit");

		if (flippingItem.getTotalGELimit() <= 0) {
			geLimitText.setText("Bought:");
			geLimitText.setToolTipText("Item has unknown limit, so this just displays how many you have bought in a 4 hour window");
		}
	}

	/**
	 * Creates the title panel which holds the item icon, delete button (shows up only when you hover over the item icon),
	 * the item name label, and the favorite button.
	 *
	 * @param itemIcon
	 * @param itemNameLabel
	 * @param favoriteButton
	 * @return
	 */
	private JPanel createTitlePanel(JLabel itemIcon, JLabel itemNameLabel, JLabel favoriteButton)
	{
		CustomizationPanel customizationPanel = new CustomizationPanel(plugin);
		JDialog customizationModal = UIUtilities.createModalFromPanel(this, customizationPanel);

		JLabel customizeLabel = new JLabel("customize look", JLabel.CENTER);
		Color c = customizeLabel.getForeground();
		customizeLabel.setFont(FontManager.getRunescapeSmallFont());
		Font font=new Font(customizeLabel.getFont().getName(),Font.ITALIC,customizeLabel.getFont().getSize());
		customizeLabel.setFont(font);
		UIUtilities.makeLabelUnderlined(customizeLabel);
		customizeLabel.setHorizontalAlignment(JLabel.CENTER);
		customizeLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				customizationPanel.rebuild(plugin.getDataHandler().viewAccountWideData().getSections());
				customizationModal.setVisible(true);
				customizationModal.pack();
				customizationModal.setLocation(getLocationOnScreen().x - customizationModal.getWidth() - 10 , Math.max(getLocationOnScreen().y - customizationModal.getHeight()/2,0));
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				customizeLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				customizeLabel.setForeground(c);
			}
		});

		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBackground(getBackground());
		titlePanel.add(itemIcon, BorderLayout.WEST);
		titlePanel.add(itemNameLabel, BorderLayout.CENTER);
		titlePanel.add(favoriteButton, BorderLayout.EAST);
		titlePanel.add(customizeLabel, BorderLayout.SOUTH);
		return titlePanel;
	}

	/**
	 * Creates the image icon located on the title panel
	 *
	 * @param itemImage the image of the item as given by the ItemManager
	 * @return
	 */
	private JLabel createItemIcon(AsyncBufferedImage itemImage)
	{
		Icon itemIcon = new ImageIcon(itemImage);
		JLabel itemIconLabel = new JLabel(itemIcon);
		itemIconLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		itemIconLabel.setPreferredSize(Icons.ICON_SIZE);

		itemIconLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				flippingItem.setValidFlippingPanelItem(false);
				if (!plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE)) {
					plugin.markAccountTradesAsHavingChanged(plugin.getAccountCurrentlyViewed());
				}
				plugin.getFlippingPanel().rebuild(plugin.viewItemsForCurrentView());
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				itemIconLabel.setIcon(Icons.DELETE_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				itemIconLabel.setIcon(itemIcon);
			}
		});

		return itemIconLabel;
	}

	/**
	 * Creates the item name label that is located on the title panel. The item name label can be clicked on to
	 * expand or collapse the itemInfo panel
	 *
	 * @return
	 */
	private JLabel createItemNameLabel()
	{
		JLabel itemNameLabel = new JLabel(flippingItem.getItemName(), SwingConstants.CENTER);
		itemNameLabel.setFont(FontManager.getRunescapeBoldFont());
		itemNameLabel.setPreferredSize(new Dimension(0, 0)); //Make sure the item name fits
		itemNameLabel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (isCollapsed())
				{
					expand();
					flippingItem.setExpand(true);
				}
				else
				{
					collapse();
					flippingItem.setExpand(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (isCollapsed())
				{
					itemNameLabel.setText("Expand");
				}
				else
				{
					itemNameLabel.setText("Collapse");
				}
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				itemNameLabel.setText(flippingItem.getItemName());
			}
		});
		return itemNameLabel;
	}

	/**
	 * Creates the favorite icon used for favoriting items.
	 *
	 * @return
	 */
	private JLabel createFavoriteIcon() {
		JLabel favoriteIcon = new JLabel();
		favoriteIcon.setIcon(flippingItem.isFavorite() ? Icons.STAR_ON_ICON : Icons.STAR_OFF_ICON);
		favoriteIcon.setAlignmentX(Component.RIGHT_ALIGNMENT);
		favoriteIcon.setPreferredSize(new Dimension(24, 24));
		favoriteIcon.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				boolean wasDummy = false;
				if (Constants.DUMMY_ITEM.equals(flippingItem.getFlippedBy())) {
					wasDummy = true;
					plugin.addFavoritedItem(flippingItem);
				}

				if (plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE))
				{
					plugin.setFavoriteOnAllAccounts(flippingItem, !flippingItem.isFavorite());
				}
				else {
					plugin.markAccountTradesAsHavingChanged(plugin.getAccountCurrentlyViewed());
				}

				//if it was a dummy item and in the accountwide view, it has already had its favorite set by setFavoriteOnAllAccounts
				boolean wasDummyAndAccountwide = wasDummy && plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE);
				if (!wasDummyAndAccountwide) {
					flippingItem.setFavorite(!flippingItem.isFavorite());
				}

				favoriteIcon.setIcon(flippingItem.isFavorite()? Icons.STAR_ON_ICON:Icons.STAR_OFF_ICON);

				if (flippingItem.isFavorite()) {
					searchCodeLabel.setText("<html> quick search code: " + UIUtilities.colorText(flippingItem.getFavoriteCode(), ColorScheme.GRAND_EXCHANGE_PRICE) + "</html>");
				}
				else {
					searchCodeLabel.setText("<html> quick search code: " + UIUtilities.colorText("N/A", ColorScheme.GRAND_EXCHANGE_ALCH) + "</html>");
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (!flippingItem.isFavorite())
				{
					favoriteIcon.setIcon(Icons.STAR_HOVER_ICON);
				}
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (!flippingItem.isFavorite())
				{
					favoriteIcon.setIcon(Icons.STAR_OFF_ICON);
				}
			}
		});

		return favoriteIcon;
	}

	public void expand()
	{
		if (isCollapsed())
		{
			itemInfo.setVisible(true);
		}
	}

	public void collapse()
	{
		if (!isCollapsed())
		{
			itemInfo.setVisible(false);
		}
	}

	public boolean isCollapsed()
	{
		return !itemInfo.isVisible();
	}

	public void setValueLabels() {
		Optional<OfferEvent> latestInstaBuy = flippingItem.getLatestInstaBuy();
		Optional<OfferEvent> latestInstaSell = flippingItem.getLatestInstaSell();

		Optional<OfferEvent> latestBuy = flippingItem.getLatestBuy();
		Optional<OfferEvent> latestSell = flippingItem.getLatestSell();


		Optional<Integer> profitEach = flippingItem.getCurrentProfitEach();
		Optional<Float> roi =  flippingItem.getCurrentRoi();

		instaSellVal.setText(latestInstaSell.isPresent() ? String.format(NUM_FORMAT, latestInstaSell.get().getPreTaxPrice()) + " gp":"N/A");
		instaBuyVal.setText(latestInstaBuy.isPresent() ? String.format(NUM_FORMAT, latestInstaBuy.get().getPrice()) + " gp" : "N/A");

		latestBuyPriceVal.setText(latestBuy.isPresent() ? String.format(NUM_FORMAT, latestBuy.get().getPrice()) + " gp" : "N/A");
		latestSellPriceVal.setText(latestSell.isPresent() ? String.format(NUM_FORMAT, latestSell.get().getPreTaxPrice()) + " gp" : "N/A");

		marginCheckProfitEachVal.setText(profitEach.isPresent()? QuantityFormatter.quantityToRSDecimalStack(profitEach.get()) + " gp": "N/A");

		//the three of these will be set by wiki vals as they are dependent on em
		wikiProfitEachVal.setText("N/A");
		wikiPotentialProfitVal.setText("N/A");
		wikiRoiLabelVal.setText("N/A");

		if (flippingItem.getTotalGELimit() > 0) {
			geLimitVal.setText(String.format(NUM_FORMAT, flippingItem.getRemainingGeLimit()));
		} else {
			geLimitVal.setText(String.format(NUM_FORMAT, flippingItem.getItemsBoughtThisLimitWindow()));
		}
		onWikiRequest(plugin.getLastWikiRequestWrapper(), plugin.getTimeOfLastWikiRequest());
	}

	public void updateTimerDisplays() {
		flippingItem.validateGeProperties();

		geRefreshCountdownLabel.setText(flippingItem.getGeLimitResetTime() == null?
				TimeFormatters.formatDuration(Duration.ZERO):
				TimeFormatters.formatDuration(Instant.now(), flippingItem.getGeLimitResetTime()));

		//need to update this so it can be reset when the timer runs down.
		if (flippingItem.getTotalGELimit() > 0) {
			geLimitVal.setText(String.format(NUM_FORMAT, flippingItem.getRemainingGeLimit()));
		} else {
			geLimitVal.setText(String.format(NUM_FORMAT, flippingItem.getItemsBoughtThisLimitWindow()));
		}

		geRefreshAtLabel.setText(flippingItem.getGeLimitResetTime() == null? "Now": TimeFormatters.formatTime(flippingItem.getGeLimitResetTime(), true, false));
	}

	public void onWikiRequest(WikiRequestWrapper wr, Instant requestCompletionTime) {
		timeOfRequestCompletion = requestCompletionTime;
		wikiRequestWrapper = wr;

		if (wikiRequestWrapper == null) {
			wikiBuyVal.setText("N/A");
			wikiSellVal.setText("N/A");
			return;
		}

		if (wikiRequestWrapper.getWikiDataSource() == WikiDataSource.DMM) {
			wikiBuyText.setForeground(CustomColors.DMM);
			wikiSellText.setForeground(CustomColors.DMM);
		}
		else {
			wikiBuyText.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
			wikiSellText.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}

		WikiItemMargins wikiItemInfo = wikiRequestWrapper.getWikiRequest().getData().get(flippingItem.getItemId());
		if (wikiItemInfo == null) {
			wikiBuyVal.setText("N/A");
			wikiSellVal.setText("N/A");
			return;
		}
		wikiBuyVal.setText(wikiItemInfo.getHigh()==0? "No data":QuantityFormatter.formatNumber(wikiItemInfo.getHigh()) + " gp");
		wikiSellVal.setText(wikiItemInfo.getLow()==0? "No data":QuantityFormatter.formatNumber(wikiItemInfo.getLow()) + " gp");

		if (wikiItemInfo.getHigh() != 0 && wikiItemInfo.getLow() != 0) {
			int profitEach = GeTax.getPostTaxPrice(wikiItemInfo.getHigh()) - wikiItemInfo.getLow();
			wikiProfitEachVal.setText(QuantityFormatter.quantityToRSDecimalStack(profitEach) + " gp");

			float roi = ((float)profitEach/ wikiItemInfo.getLow()) * 100;
			wikiRoiLabelVal.setText(String.format("%.2f", roi) + "%");
			//Color gradient red-yellow-green depending on ROI.
			wikiRoiLabelVal.setForeground(UIUtilities.gradiatePercentage(roi, plugin.getConfig().roiGradientMax()));
			int geLimit = plugin.getConfig().geLimitProfit()? flippingItem.getRemainingGeLimit() : flippingItem.getTotalGELimit();
			if (flippingItem.getTotalGELimit() > 0) {
				int potentialProfit = profitEach * geLimit;
				wikiPotentialProfitVal.setText(QuantityFormatter.quantityToRSDecimalStack(potentialProfit) + " gp");
			}
		}
		updateWikiTimeLabels();
	}

	public void updateWikiTimeLabels() {
		//can be called before wikiRequest is set cause is is called in the repeating task which can start before the
		//request is completed
		if (wikiRequestWrapper == null) {
			wikiBuyTimeVal.setText("Request not made yet");
			wikiSellTimeVal.setText("Request not made yet");
			wikiRequestCountDownTimer.setText("N/A");
			return;
		}
		//probably don't need this. Should always be non null if wikiRequest is not null
		if (timeOfRequestCompletion != null) {
			long secondsSinceLastRequestCompleted = Instant.now().getEpochSecond() - timeOfRequestCompletion.getEpochSecond();
			if (secondsSinceLastRequestCompleted >= WikiDataFetcherJob.requestInterval) {
				wikiRequestCountDownTimer.setText("0");
				refreshIconLabel.setEnabled(true);
			}
			else {
				refreshIconLabel.setEnabled(false);
				wikiRequestCountDownTimer.setText(String.valueOf(WikiDataFetcherJob.requestInterval - secondsSinceLastRequestCompleted));
			}
		}

		WikiItemMargins wikiItemInfo = wikiRequestWrapper.getWikiRequest().getData().get(flippingItem.getItemId());
		if (wikiItemInfo == null) {
			return;
		}
		if (wikiItemInfo.getHighTime() == 0) {
			wikiBuyTimeVal.setText("No data");
		}
		else {
			wikiBuyTimeVal.setText(TimeFormatters.formatDuration(Instant.ofEpochSecond(wikiItemInfo.getHighTime())));
		}
		if (wikiItemInfo.getLowTime() == 0) {
			wikiBuyTimeVal.setText("No data");
		}
		else {
			wikiSellTimeVal.setText(TimeFormatters.formatDuration(Instant.ofEpochSecond(wikiItemInfo.getLowTime())));
		}
	}

	//panel that is shown when someone hovers over the wiki buy/sell value labels
	private JPanel createWikiHoverTimePanel() {
		wikiBuyTimeText.setFont(FontManager.getRunescapeSmallFont());
		wikiBuyTimeText.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		wikiSellTimeText.setFont(FontManager.getRunescapeSmallFont());
		wikiSellTimeText.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);

		wikiSellTimeVal.setFont(FontManager.getRunescapeSmallFont());
		wikiBuyTimeVal.setFont(FontManager.getRunescapeSmallFont());

		JPanel wikiTimePanel = new JPanel();
		wikiTimePanel.setLayout(new BoxLayout(wikiTimePanel, BoxLayout.Y_AXIS));
		wikiTimePanel.setBorder(new EmptyBorder(5,5,5,5));

		JPanel buyTimePanel = new JPanel(new BorderLayout());
		buyTimePanel.add(wikiBuyTimeText, BorderLayout.WEST);
		buyTimePanel.add(wikiBuyTimeVal, BorderLayout.EAST);

		JPanel sellTimePanel = new JPanel(new BorderLayout());
		sellTimePanel.add(wikiSellTimeText, BorderLayout.WEST);
		sellTimePanel.add(wikiSellTimeVal, BorderLayout.EAST);

		wikiTimePanel.add(buyTimePanel);
		wikiTimePanel.add(Box.createVerticalStrut(5));
		wikiTimePanel.add(sellTimePanel);

		return wikiTimePanel;
	}

}

package com.flippingutilities.ui.statistics.recipes;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.RecipeFlipGroup;
import com.flippingutilities.ui.statistics.StatsPanel;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.Paginator;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class RecipeGroupContainerPanel extends JPanel {
    private JPanel recipeGroupContainer;
    private List<RecipeFlipGroupPanel> activePanels = new ArrayList<>();
    private Paginator paginator;
    private FlippingPlugin plugin;

    public RecipeGroupContainerPanel(FlippingPlugin flippingPlugin) {
        plugin = flippingPlugin;
        recipeGroupContainer = createRecipeGroupContainer();
        paginator = createPaginator();

        JScrollPane scrollPane = createScrollPane(recipeGroupContainer);

        setLayout(new BorderLayout());

        add(scrollPane, BorderLayout.CENTER);
        add(paginator, BorderLayout.SOUTH);
    }

    public void resetPaginator() {
        paginator.setPageNumber(1);
    }

    public void rebuild(List<RecipeFlipGroup> recipeFlipGroups) {
        activePanels.clear();
        recipeGroupContainer.removeAll();
        paginator.updateTotalPages(recipeFlipGroups.size());

        if (!recipeFlipGroups.isEmpty()) {
            List<RecipeFlipGroup> itemsOnCurrentPage = paginator.getCurrentPageItems(recipeFlipGroups);
            List<RecipeFlipGroupPanel> newPanels = itemsOnCurrentPage.stream().map(rfg -> new RecipeFlipGroupPanel(plugin, rfg)).collect(Collectors.toList());
            UIUtilities.stackPanelsVertically((List) newPanels, recipeGroupContainer, 5);
            activePanels.addAll(newPanels);
        }
        else {
            recipeGroupContainer.add(createHelpPanel());
        }
    }

    public void showPanel(JPanel panel) {
        activePanels.clear();
        recipeGroupContainer.removeAll();
        recipeGroupContainer.add(panel);
    }

    private JPanel createHelpPanel() {
        JLabel picDesc = new JLabel(
            "<html><body width='220' style='text-align:center;'>" +
                "Create a recipe flip by going to an offer for an item " +
                "and clicking on the recipe flip button.<br><br> ", SwingConstants.CENTER);
        picDesc.setFont(new Font("Whitney", Font.PLAIN, 15));
        picDesc.setIcon(Icons.RECIPE_HELP);
        picDesc.setBorder(new EmptyBorder(20,5,0,0));
        picDesc.setHorizontalTextPosition(JLabel.CENTER);
        picDesc.setVerticalTextPosition(JLabel.NORTH);

        JLabel additionalInfoLabel = new JLabel("<html><body width='220' style='text-align:center;'>" +
            "This button will only be there if that item has a recipe associated with it</b>.<br><br> ",
            SwingConstants.CENTER);
        additionalInfoLabel.setFont(new Font("Whitney", Font.PLAIN, 10));

        JLabel contactUsLabel = new JLabel("<html><body width='220' style='text-align:center;'>" +
            "If a recipe is missing, contact us on discord and we will add it!", SwingConstants.CENTER);
        contactUsLabel.setFont(new Font("Whitney", Font.ITALIC, 10));

        JPanel helpPanel = new JPanel(new DynamicGridLayout(3,1));
        helpPanel.setAlignmentX(Component.CENTER_ALIGNMENT);
        helpPanel.add(picDesc);
        helpPanel.add(additionalInfoLabel);
        helpPanel.add(contactUsLabel);

        return helpPanel;
    }

    private JPanel createRecipeGroupContainer() {
        JPanel statItemPanelsContainer = new JPanel();
        statItemPanelsContainer.setLayout(new BoxLayout(statItemPanelsContainer, BoxLayout.Y_AXIS));
        return statItemPanelsContainer;
    }

    private JScrollPane createScrollPane(JPanel recipeGroupContainer) {
        JPanel statItemPanelsContainerWrapper = new JPanel(new BorderLayout());
        statItemPanelsContainerWrapper.setBorder(new EmptyBorder(0,0,0,3));
        statItemPanelsContainerWrapper.add(recipeGroupContainer, BorderLayout.NORTH);

        JScrollPane scrollPane = new JScrollPane(statItemPanelsContainerWrapper);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setBorder(new EmptyBorder(5, 0, 0, 0));
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));

        return scrollPane;
    }

    private Paginator createPaginator() {
        paginator = new Paginator(() -> SwingUtilities.invokeLater(() -> {
            StatsPanel statsPanel = plugin.getStatPanel();
            Instant rebuildStart = Instant.now();
            rebuild(statsPanel.getRecipeFlipGroupsToDisplay(plugin.viewRecipeFlipGroupsForCurrentView()));
            revalidate();
            repaint();
            log.debug("page change took {}", Duration.between(rebuildStart, Instant.now()).toMillis());
        }));
        paginator.setBackground(ColorScheme.DARK_GRAY_COLOR);
        paginator.setBorder(new MatteBorder(1,0,0,0, ColorScheme.DARK_GRAY_COLOR.darker()));
        return paginator;
    }

    public void updateTimeDisplay() {
        activePanels.forEach(RecipeFlipGroupPanel::updateTimeLabels);
    }
}

package com.flippingutilities.ui.statistics.recipes;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.RecipeFlip;
import com.flippingutilities.model.PartialOffer;
import com.flippingutilities.model.RecipeFlipGroup;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.TimeFormatters;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import com.flippingutilities.utilities.Recipe;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * The visual representation of a RecipeFlip. RecipeFlipPanels
 * are shown in the "combos" tab of the trade history section of an item in the
 * statistics tab.
 */
@Slf4j
public class RecipeFlipPanel extends JPanel {
    private JLabel timeDisplay;
    private RecipeFlip recipeFlip;
    private FlippingPlugin plugin;
    private Recipe recipe;
    private RecipeFlipGroup recipeFlipGroup;

    public RecipeFlipPanel(RecipeFlipGroup recipeFlipGroup, RecipeFlip recipeFlip, Recipe recipe, FlippingPlugin plugin) {
        this.recipeFlipGroup = recipeFlipGroup;
        this.recipeFlip = recipeFlip;
        this.plugin = plugin;
        this.recipe = recipe;
        setBackground(CustomColors.DARK_GRAY);
        setBorder(new EmptyBorder(5,5,5,5));
        setLayout(new BorderLayout());

        timeDisplay = createTimeDisplay(recipeFlip);

        add(createTitlePanel(), BorderLayout.NORTH);
        add(createProfitPanel(), BorderLayout.CENTER);
        add(createDetailsPanel(), BorderLayout.SOUTH);
    }


    private JPanel createTitlePanel() {
        JPanel titlePanel = new JPanel();
        titlePanel.setLayout(new DynamicGridLayout(2,1));
        titlePanel.setBackground(CustomColors.DARK_GRAY);

        String recipeQuantity = QuantityFormatter.formatNumber(recipeFlip.getRecipeCountMade(recipe));

        JLabel quantityLabel = new JLabel(recipeQuantity + "x");
        quantityLabel.setFont(FontManager.getRunescapeSmallFont());

        JPanel quantityAndTimePanel = new JPanel();
        quantityAndTimePanel.setBackground(CustomColors.DARK_GRAY);
        quantityAndTimePanel.add(quantityLabel);
        quantityAndTimePanel.add(timeDisplay);

        String recipeDisplayName = UIUtilities.truncateText(recipe.getName(), 40);
        JLabel itemNameAndActionLabel = new JLabel(recipeDisplayName, SwingConstants.CENTER);
        itemNameAndActionLabel.setFont(FontManager.getRunescapeSmallFont());
        itemNameAndActionLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);

        titlePanel.add(itemNameAndActionLabel);
        titlePanel.add(quantityAndTimePanel);
        return titlePanel;
    }

    private JLabel createTimeDisplay(RecipeFlip recipeFlip) {
        JLabel timeDisplay = new JLabel(
                "(" + TimeFormatters.formatDurationTruncated(recipeFlip.getTimeOfCreation()) + " ago)",
                SwingConstants.CENTER);
        timeDisplay.setFont(FontManager.getRunescapeSmallFont());
        return timeDisplay;
    }

    private JPanel createComponentGroupPanel(Map<Integer, Map<String, PartialOffer>> partialOffers, boolean outputs) {

        JLabel titleLabel = new JLabel(outputs? "OUTPUTS":"INPUTS", SwingConstants.CENTER);
        titleLabel.setFont(new Font("Whitney", Font.PLAIN, 10));
        titleLabel.setBorder(new EmptyBorder(0,0,5,0));

        boolean userAddedCoinsThatWereNotInRecipe = recipeFlip.getCoinCost() > 0 && !partialOffers.containsKey(995);
        int rowSizeForUserAddedCoins = userAddedCoinsThatWereNotInRecipe? 1:0;
        JPanel componentGroupPanel = new JPanel(new DynamicGridLayout(1 + partialOffers.size() + rowSizeForUserAddedCoins, 1));
        componentGroupPanel.setBackground(CustomColors.DARK_GRAY);
        componentGroupPanel.add(titleLabel);

        //if the recipe does not contain coins but the user added coins to the input by using the coin selector
        if (userAddedCoinsThatWereNotInRecipe) {
            componentGroupPanel.add(createComponentPanel("Coins", recipeFlip.getCoinCost(), 1));
        }

        partialOffers.forEach((itemId, partialOfferMap) -> {
            String itemName;
            long quantity;
            long avgPrice;

            if (itemId == 995) {
                itemName = "Coins";
                quantity = recipeFlip.getCoinCost();
                avgPrice = 1;
            }
            else {
                List<PartialOffer> partialOfferList = new ArrayList<>(partialOfferMap.values());
                itemName = partialOfferList.get(0).offer.getItemName();
                quantity = partialOfferList.stream().mapToInt(po -> po.amountConsumed).sum();
                avgPrice =  partialOfferList.stream().mapToLong(po -> po.getOffer().getPrice() * po.amountConsumed).sum()/quantity;
            }

            componentGroupPanel.add(createComponentPanel(itemName, quantity, avgPrice));
        });

        return componentGroupPanel;
    }

    private JPanel createComponentPanel(String itemName, long quantity, long avgPrice){
        if (quantity == 0) {
            JPanel panel = new JPanel(new BorderLayout());
            panel.setBackground(CustomColors.DARK_GRAY);
            JLabel label = new JLabel("Corrupted recipe flip (delete it)", SwingConstants.CENTER);
            label.setFont(FontManager.getRunescapeSmallFont());
            label.setForeground(CustomColors.TOMATO);
            panel.add(label, BorderLayout.CENTER);
            return panel;
        }

        JLabel itemNameLabel = new JLabel(itemName, SwingConstants.CENTER);
        itemNameLabel.setFont(FontManager.getRunescapeSmallFont());

        JPanel quantityPanel = new JPanel(new BorderLayout());
        quantityPanel.setBackground(CustomColors.DARK_GRAY);
        JLabel quantityLabel = new JLabel("Quantity", SwingConstants.CENTER);
        quantityLabel.setFont(FontManager.getRunescapeSmallFont());
        JLabel quantityValueLabel = new JLabel(QuantityFormatter.formatNumber(quantity));
        quantityValueLabel.setFont(FontManager.getRunescapeSmallFont());
        quantityPanel.add(quantityLabel, BorderLayout.WEST);
        quantityPanel.add(quantityValueLabel, BorderLayout.EAST);

        JPanel pricePanel = new JPanel(new BorderLayout());
        pricePanel.setBackground(CustomColors.DARK_GRAY);
        JLabel priceLabel = new JLabel("Avg Price", SwingConstants.CENTER);
        priceLabel.setFont(FontManager.getRunescapeSmallFont());
        JLabel priceValueLabel = new JLabel(itemName.equals("Coins")? "N/A": QuantityFormatter.formatNumber(avgPrice) + " gp");
        priceValueLabel.setFont(FontManager.getRunescapeSmallFont());
        pricePanel.add(priceLabel, BorderLayout.WEST);
        pricePanel.add(priceValueLabel, BorderLayout.EAST);

        JPanel itemPanel = new JPanel(new DynamicGridLayout(3,1));
        itemPanel.setBackground(CustomColors.DARK_GRAY);
        itemPanel.add(itemNameLabel);
        itemPanel.add(quantityPanel);
        itemPanel.add(pricePanel);

        return itemPanel;
    }

    private JPanel createDetailsPanel() {
        JPanel inputPanel = createComponentGroupPanel(recipeFlip.getInputs(), false);
        JPanel outputPanel = createComponentGroupPanel(recipeFlip.getOutputs(), true);

        JPanel inputsAndOutputsPanel = new JPanel(new DynamicGridLayout(2,1));
        inputsAndOutputsPanel.setBorder(new EmptyBorder(5,0,0,0));
        inputsAndOutputsPanel.setBackground(CustomColors.DARK_GRAY);
        inputsAndOutputsPanel.setVisible(false);

        inputsAndOutputsPanel.add(inputPanel);
        inputsAndOutputsPanel.add(outputPanel);

        JLabel expandDetailsLabel = new JLabel("Expand Details", SwingConstants.CENTER);
        Color c = expandDetailsLabel.getForeground();
        expandDetailsLabel.setFont(FontManager.getRunescapeSmallFont());
        Font font=new Font(expandDetailsLabel.getFont().getName(),Font.ITALIC,expandDetailsLabel.getFont().getSize());
        expandDetailsLabel.setFont(font);
        UIUtilities.makeLabelUnderlined(expandDetailsLabel);
        expandDetailsLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                inputsAndOutputsPanel.setVisible(!inputsAndOutputsPanel.isVisible());
                expandDetailsLabel.setText(inputsAndOutputsPanel.isVisible()? "Collapse Details": "Expand Details");
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                expandDetailsLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                expandDetailsLabel.setForeground(c);
            }
        });

        JPanel expandDetailsPanel = new JPanel(new BorderLayout());
        expandDetailsPanel.setBorder(new EmptyBorder(8,0,0,0));
        expandDetailsPanel.setBackground(CustomColors.DARK_GRAY);
        expandDetailsPanel.add(expandDetailsLabel, BorderLayout.CENTER);
        expandDetailsPanel.add(createDeleteIcon(), BorderLayout.WEST);

        JPanel detailsPanel = new JPanel(new BorderLayout());
        detailsPanel.setBackground(CustomColors.DARK_GRAY);
        detailsPanel.setBorder(new EmptyBorder(5,0,0,0));
        detailsPanel.add(expandDetailsPanel, BorderLayout.NORTH);
        detailsPanel.add(inputsAndOutputsPanel, BorderLayout.CENTER);

        return detailsPanel;
    }

    private JLabel createDeleteIcon() {
        JLabel deleteIcon = new JLabel(Icons.TRASH_CAN_OFF);
        deleteIcon.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE)) {
                    JOptionPane.showMessageDialog(null, "You cannot delete recipe flips in the Accountwide view");
                    return;
                }
                final int result = JOptionPane.showOptionDialog(deleteIcon, "Are you sure you want to delete this recipe flip?",
                        "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                        null, new String[]{"Yes", "No"}, "No");

                if (result == JOptionPane.YES_OPTION) {
                    recipeFlipGroup.deleteFlip(recipeFlip);
                    plugin.setUpdateSinceLastRecipeFlipGroupAccountWideBuild(true);
                    plugin.markAccountTradesAsHavingChanged(plugin.getAccountCurrentlyViewed());
                    plugin.getStatPanel().rebuildItemsDisplay(plugin.viewItemsForCurrentView());
                    plugin.getStatPanel().rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                deleteIcon.setIcon(Icons.TRASH_CAN_ON);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                deleteIcon.setIcon(Icons.TRASH_CAN_OFF);
            }
        });

        return deleteIcon;
    }

    private JPanel createProfitPanel() {
        long quantity = recipeFlip.getRecipeCountMade(recipe);
        if (quantity == 0) {
            JPanel panel = new JPanel(new BorderLayout());
            panel.setBackground(CustomColors.DARK_GRAY);
            JLabel label = new JLabel("Mismatched recipe flip (delete it)", SwingConstants.CENTER);
            label.setFont(FontManager.getRunescapeSmallFont());
            label.setForeground(CustomColors.TOMATO);
            panel.add(label, BorderLayout.CENTER);
            return panel;
        }
        long profit = recipeFlip.getProfit();
        long profitEach = profit/quantity;
        String profitString = UIUtilities.quantityToRSDecimalStack(profit, true) + " gp";
        String profitEachString = quantity == 1? "": " (" + UIUtilities.quantityToRSDecimalStack(profitEach, false) + " gp ea)";
        String profitDescription = profit < 0? "Loss": "Profit:";

        JLabel profitValLabel = new JLabel(profitString + profitEachString);
        profitValLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel profitDescriptionLabel = new JLabel(profitDescription);
        profitDescriptionLabel.setFont(FontManager.getRunescapeSmallFont());

        profitDescriptionLabel.setForeground(profit >= 0? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);

        JPanel profitPanel = new JPanel(new BorderLayout());
        profitPanel.setBackground(CustomColors.DARK_GRAY);

        profitPanel.add(profitDescriptionLabel, BorderLayout.WEST);
        profitPanel.add(profitValLabel, BorderLayout.EAST);

        return profitPanel;
    }

    public void updateTimeLabels() {
        timeDisplay.setText("(" + TimeFormatters.formatDurationTruncated(recipeFlip.getTimeOfCreation()) + " ago)");
    }
 }

package com.flippingutilities.ui.statistics.recipes;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.*;
import com.flippingutilities.ui.statistics.StatsPanel;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.Paginator;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import com.flippingutilities.utilities.Recipe;
import lombok.Getter;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class RecipeFlipGroupPanel extends JPanel {

    private FlippingPlugin plugin;
    @Getter
    private RecipeFlipGroup recipeFlipGroup;

    private StatsPanel statsPanel;

    private JLabel recipeProfitAndQuantityLabel = new JLabel();
    private JPanel itemIconTitlePanel = new JPanel(new BorderLayout());

    private JLabel totalProfitValLabel = new JLabel("", SwingConstants.RIGHT);
    private JLabel profitEachValLabel = new JLabel("", SwingConstants.RIGHT);
    private JLabel quantityFlipped = new JLabel("", SwingConstants.RIGHT);
    private JLabel roiValLabel = new JLabel("", SwingConstants.RIGHT);

    private List<RecipeFlipPanel> recipeFlipPanels;
    private Paginator recipeFlipPaginator;
    private JPanel recipeFlipsBackgroundPanel = createRecipeFlipsBackgroundPanel();


    RecipeFlipGroupPanel(FlippingPlugin plugin, RecipeFlipGroup recipeFlipGroup) {
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, ColorScheme.DARKER_GRAY_COLOR.darker()));

        this.plugin = plugin;
        this.recipeFlipGroup = recipeFlipGroup;
        this.statsPanel = plugin.getStatPanel();

        List<RecipeFlip> flips = recipeFlipGroup.getFlipsInInterval(statsPanel.getStartOfInterval());

        this.recipeFlipPaginator = createPaginator(() -> updateBackgroundPanel(flips));
        recipeFlipPaginator.updateTotalPages(flips.size());

        recipeFlipPanels = createRecipeFlipPanels(flips);
        putPanelsOnBackgroundPanel(new ArrayList<>(recipeFlipPanels), recipeFlipsBackgroundPanel, recipeFlipPaginator);

        JLabel[] descriptionLabels = {new JLabel("Total Profit: "), new JLabel("Avg. Profit ea: "), new JLabel("Avg. ROI: "), new JLabel("Recipes Made: ")};

        JLabel[] valueLabels = {totalProfitValLabel, profitEachValLabel, roiValLabel, quantityFlipped};

        JPanel subInfoPanel = createSubInfoPanel(descriptionLabels, valueLabels);
        JPanel tradeHistoryPanel = createTradeHistoryPanel(recipeFlipsBackgroundPanel);
        JPanel subInfoAndHistoryContainer = createSubInfoAndHistoryContainer(subInfoPanel, tradeHistoryPanel);
        JPanel titlePanel = createTitlePanel(createIconPanel(plugin.getItemManager()), createNameAndProfitPanel(), createCollapseIcon(), subInfoAndHistoryContainer);

        updateLabels(flips);

        add(titlePanel, BorderLayout.NORTH);
        add(subInfoAndHistoryContainer, BorderLayout.CENTER);
    }

    private JPanel createSubInfoAndHistoryContainer(JPanel subInfoPanel, JPanel tradeHistoryPanel) {
        JPanel subInfoAndHistoryContainer = new JPanel(new BorderLayout());
        //Set background and border of container with sub infos and trade history
        subInfoAndHistoryContainer.setBackground(CustomColors.DARK_GRAY_LIGHTER);
        subInfoAndHistoryContainer.add(subInfoPanel, BorderLayout.CENTER);
        subInfoAndHistoryContainer.add(tradeHistoryPanel, BorderLayout.SOUTH);
        subInfoAndHistoryContainer.setVisible(false);
        return subInfoAndHistoryContainer;
    }

    private JPanel createRecipeFlipsBackgroundPanel() {
        JPanel recipeFlipsBackgroundPanel = new JPanel();
        recipeFlipsBackgroundPanel.setVisible(false);
        return recipeFlipsBackgroundPanel;
    }

    private Paginator createPaginator(Runnable runnable) {
        Paginator paginator = new Paginator(runnable);
        paginator.setPageSize(10);
        paginator.setBackground(CustomColors.DARK_GRAY);
        paginator.getStatusText().setFont(FontManager.getRunescapeSmallFont());
        paginator.setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, ColorScheme.DARKER_GRAY_COLOR.darker()));
        return paginator;
    }

    private void putPanelsOnBackgroundPanel(List<JPanel> panels, JPanel backgroundPanel, Paginator paginator) {
        List<JPanel> panelsAndPaginator = new ArrayList<>();
        JPanel paginatorWrapper = new JPanel();
        paginatorWrapper.add(paginator);
        panelsAndPaginator.add(paginatorWrapper);
        panelsAndPaginator.addAll(panels);
        backgroundPanel.removeAll();
        UIUtilities.stackPanelsVertically(panelsAndPaginator, backgroundPanel, 2);
        if (panels.isEmpty()) {
            //if i don't wrap the label, the box layout places it weird....
            JPanel labelWrapper = new JPanel();
            JLabel noDataLabel = new JLabel("Nothing here...", SwingConstants.CENTER);
            noDataLabel.setForeground(CustomColors.TOMATO);
            noDataLabel.setFont(new Font("Whitney", Font.PLAIN, 10));
            labelWrapper.add(noDataLabel);
            backgroundPanel.add(labelWrapper);
        }
        repaint();
        revalidate();
    }

    private List<RecipeFlipPanel> createRecipeFlipPanels(List<RecipeFlip> recipeFlips) {
        List<RecipeFlip> flipsCopy = new ArrayList<>(recipeFlips);
        Collections.reverse(flipsCopy);
        List<RecipeFlip> flipsOnCurrentPage = recipeFlipPaginator.getCurrentPageItems(flipsCopy);
        return flipsOnCurrentPage.stream().map(rf -> new RecipeFlipPanel(recipeFlipGroup, rf, recipeFlipGroup.getRecipe(), plugin)).collect(Collectors.toList());
    }

    private void updateBackgroundPanel(List<RecipeFlip> flips) {
        recipeFlipPanels = createRecipeFlipPanels(flips);
        putPanelsOnBackgroundPanel(new ArrayList<>(recipeFlipPanels), recipeFlipsBackgroundPanel, recipeFlipPaginator);
    }

    private JPanel createTitlePanel(JPanel itemIconPanel, JPanel nameAndProfitPanel, JLabel collapseIcon, JPanel subInfoAndHistoryContainer) {
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBackground(CustomColors.DARK_GRAY);
        titlePanel.setBorder(new EmptyBorder(5, 4, 5, 4));

        titlePanel.add(itemIconPanel, BorderLayout.WEST);
        titlePanel.add(nameAndProfitPanel, BorderLayout.CENTER);
        titlePanel.add(collapseIcon, BorderLayout.EAST);

        titlePanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON1) {
                    if (subInfoAndHistoryContainer.isVisible()) {
                        collapseIcon.setIcon(Icons.CLOSE_ICON);
                        subInfoAndHistoryContainer.setVisible(false);
                    } else {
                        collapseIcon.setIcon(Icons.OPEN_ICON);
                        subInfoAndHistoryContainer.setVisible(true);
                    }
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                titlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                nameAndProfitPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                for (Component component : nameAndProfitPanel.getComponents()) {
                    component.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                }
                itemIconTitlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                titlePanel.setBackground(CustomColors.DARK_GRAY);
                nameAndProfitPanel.setBackground(CustomColors.DARK_GRAY);
                for (Component component : nameAndProfitPanel.getComponents()) {
                    component.setBackground(CustomColors.DARK_GRAY);
                }
                itemIconTitlePanel.setBackground(CustomColors.DARK_GRAY);
            }
        });

        return titlePanel;
    }

    private JPanel createSubInfoPanel(JLabel[] descriptionLabels, JLabel[] valueLabels) {
        JPanel subInfoContainer = new JPanel();
        subInfoContainer.setBackground(CustomColors.DARK_GRAY_LIGHTER);
        subInfoContainer.setLayout(new DynamicGridLayout(valueLabels.length, descriptionLabels.length));
        subInfoContainer.setBorder(new EmptyBorder(10, 6, 6, 6));

        for (int i = 0; i < descriptionLabels.length; i++) {
            JLabel textLabel = descriptionLabels[i];
            JLabel valLabel = valueLabels[i];
            JPanel panel = new JPanel(new BorderLayout());

            panel.add(textLabel, BorderLayout.WEST);
            panel.add(valLabel, BorderLayout.EAST);

            panel.setBorder(new EmptyBorder(4, 2, 4, 2));
            panel.setBackground(CustomColors.DARK_GRAY_LIGHTER);

            textLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);

            textLabel.setFont(FontManager.getRunescapeSmallFont());
            valLabel.setFont(FontManager.getRunescapeSmallFont());

            subInfoContainer.add(panel);
        }

        return subInfoContainer;
    }

    private JPanel createTradeHistoryPanel(JPanel recipeFlipsBackgroundPanel) {
        JPanel recipeFlipHistoryTitlePanel = new JPanel(new BorderLayout());
        recipeFlipHistoryTitlePanel.setBackground(CustomColors.DARK_GRAY);
        recipeFlipHistoryTitlePanel.setBorder(new EmptyBorder(4, 0, 4, 0));

        JLabel collapseTradeHistoryIconLabel = new JLabel(Icons.OPEN_ICON);
        JLabel recipeFlipHistoryTitleLabel = new JLabel("View Recipe Flips", SwingConstants.CENTER);
        recipeFlipHistoryTitleLabel.setFont(new Font("Whitney", Font.ITALIC, 10));
        recipeFlipHistoryTitlePanel.add(recipeFlipHistoryTitleLabel, BorderLayout.CENTER);
        recipeFlipHistoryTitlePanel.add(collapseTradeHistoryIconLabel, BorderLayout.EAST);
        recipeFlipHistoryTitlePanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON1) {
                    if (recipeFlipsBackgroundPanel.isVisible()) {
                        recipeFlipsBackgroundPanel.setVisible(false);
                        collapseTradeHistoryIconLabel.setIcon(Icons.CLOSE_ICON);
                    } else {
                        recipeFlipsBackgroundPanel.setVisible(true);
                        collapseTradeHistoryIconLabel.setIcon(Icons.OPEN_ICON);
                    }
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                recipeFlipHistoryTitlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                recipeFlipHistoryTitlePanel.setBackground(CustomColors.DARK_GRAY);
            }
        });

        JPanel tradeHistoryPanel = new JPanel(new BorderLayout());
        tradeHistoryPanel.add(recipeFlipHistoryTitlePanel, BorderLayout.NORTH);
        tradeHistoryPanel.add(recipeFlipsBackgroundPanel, BorderLayout.CENTER);

        return tradeHistoryPanel;
    }

    /**
     * Creates icon panel that contains the item image and the delete icon which shows when
     * you hover over the item image.
     */
    private JPanel createIconPanel(ItemManager itemManager) {
        JLabel deleteLabel = new JLabel(Icons.DELETE_ICON);
        deleteLabel.setPreferredSize(new Dimension(24, 24));
        deleteLabel.setVisible(false);

        JLabel itemLabel = new JLabel(Icons.CONSTRUCTION);

        itemIconTitlePanel.add(itemLabel, BorderLayout.WEST);
        itemIconTitlePanel.add(deleteLabel, BorderLayout.EAST);
        itemIconTitlePanel.setBackground(CustomColors.DARK_GRAY);
        itemIconTitlePanel.setBorder(new EmptyBorder(5, 2, 0, 5));
        itemIconTitlePanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE)) {
                    JOptionPane.showMessageDialog(null, "You cannot delete recipe flips in the Accountwide view");
                    return;
                }
                int result = JOptionPane.showOptionDialog(itemIconTitlePanel, "Are you sure you want to delete this recipe's flips from this time interval?",
                    "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                    null, new String[]{"Yes", "No"}, "No");

                if (result == JOptionPane.YES_OPTION) {
                    deletePanel();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                itemLabel.setVisible(false);
                deleteLabel.setVisible(true);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                itemLabel.setVisible(true);
                deleteLabel.setVisible(false);
            }
        });

        return itemIconTitlePanel;
    }

    private JPanel createNameAndProfitPanel() {
        JPanel nameAndProfitPanel = new JPanel(new BorderLayout());
        nameAndProfitPanel.setBackground(CustomColors.DARK_GRAY);
        JLabel itemNameLabel = new JLabel(recipeFlipGroup.getRecipe().getName());
        nameAndProfitPanel.add(itemNameLabel, BorderLayout.NORTH);
        nameAndProfitPanel.add(recipeProfitAndQuantityLabel, BorderLayout.SOUTH);
        nameAndProfitPanel.setPreferredSize(new Dimension(0, 0));
        return nameAndProfitPanel;
    }

    private JLabel createCollapseIcon() {
        JLabel collapseIconLabel = new JLabel();
        collapseIconLabel.setIcon(Icons.OPEN_ICON);
        collapseIconLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
        return collapseIconLabel;
    }

    public void updateLabels(List<RecipeFlip> recipeFlips) {
        quantityFlipped.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

        Recipe recipe = recipeFlipGroup.getRecipe();

        int recipesMade = recipeFlips.stream().mapToInt(rf -> rf.getRecipeCountMade(recipe)).sum();
        long revenue = recipeFlips.stream().mapToLong(RecipeFlip::getRevenue).sum();
        long expense = recipeFlips.stream().mapToLong(RecipeFlip::getExpense).sum();
        long profit = revenue - expense;

        updateTitleLabels(profit, recipesMade);
        updateFlippingLabels(expense, revenue, recipesMade);
        updateTimeLabels();
    }

    /**
     * Updates the labels on the title panel. This includes the profit label which shows how much profit you made
     * from flipping that item and the number of times you flipped that item.
     */
    private void updateTitleLabels(long profitFromFlips, long numItemsFlipped) {
        String totalProfitString = (profitFromFlips >= 0 ? "+" : "") + UIUtilities.quantityToRSDecimalStack(profitFromFlips, true) + " gp";
        totalProfitString += " (x " + QuantityFormatter.formatNumber(numItemsFlipped) + ")";

        recipeProfitAndQuantityLabel.setText(totalProfitString);
        recipeProfitAndQuantityLabel.setForeground((profitFromFlips >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
        recipeProfitAndQuantityLabel.setBorder(new EmptyBorder(0, 0, 2, 0));
        recipeProfitAndQuantityLabel.setFont(FontManager.getRunescapeSmallFont());
    }

    private void updateFlippingLabels(long flippingExpense, long flippingRevenue, int itemsFlipped) {
        long profitFromFlips = flippingRevenue - flippingExpense;
        totalProfitValLabel.setText(UIUtilities.quantityToRSDecimalStack(profitFromFlips, true) + " gp");
        totalProfitValLabel.setForeground((profitFromFlips >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
        totalProfitValLabel.setToolTipText(QuantityFormatter.formatNumber(profitFromFlips) + " gp");

        String profitEach = UIUtilities.quantityToRSDecimalStack(itemsFlipped > 0 ? (profitFromFlips / itemsFlipped) : 0, true) + " gp/ea";
        profitEachValLabel.setText(profitEach);
        profitEachValLabel.setForeground((profitFromFlips >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
        profitEachValLabel.setToolTipText(QuantityFormatter.formatNumber(itemsFlipped > 0 ? profitFromFlips / itemsFlipped : 0) + " gp/ea");

        quantityFlipped.setText(QuantityFormatter.formatNumber(itemsFlipped) + " Items");

        float roi = (float) flippingExpense > 0 ? (float) profitFromFlips / flippingExpense * 100 : 0;

        roiValLabel.setText(String.format("%.2f", roi) + "%");
        roiValLabel.setForeground(UIUtilities.gradiatePercentage(roi, plugin.getConfig().roiGradientMax()));
        roiValLabel.setToolTipText("<html>Return on investment:<br>Percentage of profit relative to gp invested</html>");
    }

    public void updateTimeLabels() {
        recipeFlipPanels.forEach(RecipeFlipPanel::updateTimeLabels);
    }

    private void deletePanel() {
        statsPanel.deleteRecipeFlipGroupPanel(this);
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.statistics;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.*;
import com.flippingutilities.ui.statistics.items.FlippingItemPanel;
import com.flippingutilities.ui.statistics.items.FlippingItemContainerPanel;
import com.flippingutilities.ui.statistics.recipes.RecipeFlipGroupPanel;
import com.flippingutilities.ui.statistics.recipes.RecipeGroupContainerPanel;
import com.flippingutilities.ui.uiutilities.*;
import com.flippingutilities.utilities.SORT;
import com.flippingutilities.utilities.Searchable;
import com.google.common.base.Strings;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.text.StyleContext;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.File;
import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
public class StatsPanel extends JPanel
{
	private static final String[] TIME_INTERVAL_STRINGS = {"-1h (Past Hour)", "-4h (Past 4 Hours)", "-12h (Past 12 Hours)", "-1d (Past Day)", "-1w (Past Week)", "-1m (Past Month)", "Session", "All"};
	private static final Dimension ICON_SIZE = new Dimension(16, 16);

	private FlippingPlugin plugin;

	//Holds the sub info labels.
	private JPanel subInfoPanel;

	//Combo box that selects the time interval that startOfInterval contains.
	private JComboBox<String> timeIntervalDropdown = this.createTimeIntervalDropdown();

	//Represents the total profit made in the selected time interval.
	private JLabel totalProfitVal = new JLabel();

	/* Subinfo text labels */
	private final JLabel hourlyProfitText = new JLabel("Hourly Profit: ");
	private final JLabel roiText = new JLabel("ROI: ");
	private final JLabel totalFlipsText = new JLabel("Total Flips Made: ");
	private final JLabel taxPaidText = new JLabel("Tax paid: ");
	private final JLabel sessionTimeText = new JLabel("Session Time: ");
	private final JLabel[] textLabelArray = {hourlyProfitText, roiText, totalFlipsText, taxPaidText, sessionTimeText};

	/* Subinfo value labels */
	private final JLabel hourlyProfitVal = new JLabel("", SwingConstants.RIGHT);
	private final JLabel roiVal = new JLabel("", SwingConstants.RIGHT);
	private final JLabel totalFlipsVal = new JLabel("", SwingConstants.RIGHT);
	private final JLabel taxPaidVal = new JLabel("", SwingConstants.RIGHT);
	private final JLabel sessionTimeVal = new JLabel("", SwingConstants.RIGHT);
	private final JLabel[] valLabelArray = {hourlyProfitVal, roiVal, totalFlipsVal, taxPaidVal, sessionTimeVal};

	private final JPanel hourlyProfitPanel = new JPanel(new BorderLayout());
	private final JPanel roiPanel = new JPanel(new BorderLayout());
	private final JPanel totalFlipsPanel = new JPanel(new BorderLayout());
	private final JPanel taxPaidPanel = new JPanel(new BorderLayout());
	private final JPanel sessionTimePanel = new JPanel(new BorderLayout());
	private final JPanel[] subInfoPanelArray = {hourlyProfitPanel, roiPanel, totalFlipsPanel, taxPaidPanel, sessionTimePanel};

	//Contains the unix time of the start of the interval.
	@Getter
	private Instant startOfInterval;
	@Getter
	private String startOfIntervalName = "Session";

	@Getter
	private SORT selectedSort = SORT.TIME;

	@Getter
	private Set<String> expandedItems = new HashSet<>();
	@Getter
	private Set<String> expandedTradeHistories = new HashSet<>();
	@Getter
	private Set<Integer> itemsWithOffersTabSelected = new HashSet<>();

	private boolean currentlySearching;
	private IconTextField searchBar;
	private FlippingItemContainerPanel flippingItemContainerPanel;
	private RecipeGroupContainerPanel recipeGroupContainerPanel;
	/**
	 * The statistics panel shows various stats about trades the user has made over a selectable time interval.
	 * This represents the front-end Statistics Tab.
	 * It is shown when it has been selected by the tab manager.
	 *
	 * @param plugin  Used to access the config and list of trades.
	 */
	public StatsPanel(final FlippingPlugin plugin)
	{
		super(false);
		this.plugin = plugin;
		this.startOfInterval = plugin.viewStartOfSessionForCurrentView();
		this.prepareLabels();

		searchBar = createSearchBar();
		flippingItemContainerPanel = new FlippingItemContainerPanel(plugin);
		recipeGroupContainerPanel = new RecipeGroupContainerPanel(plugin);

		JPanel mainDisplay = new JPanel();
		FastTabGroup tabGroup = createTabGroup(mainDisplay, flippingItemContainerPanel, recipeGroupContainerPanel);

		setLayout(new BorderLayout());
		add(createTopPanel(searchBar), BorderLayout.NORTH);
		add(createTabGroupContainer(tabGroup, mainDisplay), BorderLayout.CENTER);
		setBorder(new EmptyBorder(5,7,0,7));
	}

	private JPanel createTabGroupContainer(FastTabGroup tabGroup, JPanel mainDisplay) {
		JPanel tabGroupContainer = new JPanel(new BorderLayout());

		JPanel tabGroupPanel = new JPanel(new BorderLayout());
		tabGroupPanel.add(tabGroup, BorderLayout.CENTER);
		tabGroupPanel.add(createSortIcon(), BorderLayout.EAST);

		tabGroupContainer.add(tabGroupPanel, BorderLayout.NORTH);
		tabGroupContainer.add(mainDisplay, BorderLayout.CENTER);

		return tabGroupContainer;
	}

	private JLabel createSortIcon() {
		JLabel sortIcon = new JLabel(Icons.SORT);
		sortIcon.setBorder(new EmptyBorder(0,0,0,15));
		sortIcon.setToolTipText("Use this to sort the list!");

		JPopupMenu popupMenu = new JPopupMenu("Sort");
		//handles deselecting the other buttons when one is selected
		ButtonGroup group = new ButtonGroup();
		Stream.of(SORT.values()).forEach(sortEnum -> {
			JMenuItem menuItem = new JRadioButtonMenuItem(sortEnum.name().replace("_", " "));
			menuItem.setFont(new Font("Whitney", Font.PLAIN, 12));
			group.add(menuItem);
			if (sortEnum == SORT.TIME) {
				menuItem.setSelected(true);
			}
			menuItem.addItemListener(i -> {
				if (i.getStateChange() == ItemEvent.SELECTED) {
					selectedSort = sortEnum;
					this.rebuildItemsDisplay(plugin.viewItemsForCurrentView());
					this.rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
				}
			});
			popupMenu.add(menuItem);
		});

		sortIcon.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				if (SwingUtilities.isLeftMouseButton(e)) {
					popupMenu.show(sortIcon, e.getX(), e.getY());
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				sortIcon.setIcon(Icons.SORT_HOVER);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				sortIcon.setIcon(Icons.SORT);
			}
		});
		return sortIcon;
	}

	private FastTabGroup createTabGroup(JPanel mainDisplay, FlippingItemContainerPanel statItemTabPanel, RecipeGroupContainerPanel recipeTabPanel) {
		FastTabGroup tabGroup = new FastTabGroup(mainDisplay);
		tabGroup.setBorder(new EmptyBorder(0,16 + 15,0,0));

		MaterialTab statItemTab = new MaterialTab("Items", tabGroup, statItemTabPanel);
		MaterialTab RecipeTab = new MaterialTab("Recipes", tabGroup, recipeTabPanel);

		tabGroup.addTab(statItemTab);
		tabGroup.addTab(RecipeTab);
		tabGroup.select(statItemTab);

		return tabGroup;
	}

	public void resetPaginators() {
		flippingItemContainerPanel.resetPaginator();
		recipeGroupContainerPanel.resetPaginator();
	}

	public void rebuildItemsDisplay(List<FlippingItem> flippingItems) {
		SwingUtilities.invokeLater(() -> {
			List<FlippingItem> itemsToDisplay = getItemsToDisplay(flippingItems);
			flippingItemContainerPanel.rebuild(itemsToDisplay);
			updateCumulativeDisplays(itemsToDisplay, getRecipeFlipGroupsToDisplay(plugin.viewRecipeFlipGroupsForCurrentView()));
			if (itemsToDisplay.isEmpty() && currentlySearching) flippingItemContainerPanel.showPanel(createEmptySearchPanel());
			revalidate();
			repaint();
		});
	}

	public void rebuildRecipesDisplay(List<RecipeFlipGroup> recipeFlipGroups) {
		SwingUtilities.invokeLater(() -> {
			List<RecipeFlipGroup> recipeFlipGroupsToDisplay = getRecipeFlipGroupsToDisplay(recipeFlipGroups);
			recipeGroupContainerPanel.rebuild(recipeFlipGroupsToDisplay);
			updateCumulativeDisplays(getItemsToDisplay(plugin.viewItemsForCurrentView()), recipeFlipGroupsToDisplay);
			if (recipeFlipGroupsToDisplay.isEmpty() && currentlySearching) recipeGroupContainerPanel.showPanel(createEmptySearchPanel());
			revalidate();
			repaint();
		});
	}

	/**
	 * The panel shown when a user's search query returns no results.
	 */
	private JPanel createEmptySearchPanel() {
		JPanel emptySearchPanel = new JPanel(new DynamicGridLayout(2,1));
		emptySearchPanel.setBorder(new EmptyBorder(10,0,0,0));
		String lookup = searchBar.getText().toLowerCase();
		JLabel searchLabel = new JLabel(String.format(
				"<html><body style='text-align: center'>The search for <br> <b><u>%s</u></b> <br> yielded no results :(</html>", lookup),
				SwingConstants.CENTER);
		searchLabel.setFont(new Font("Whitney", Font.PLAIN, 12));
		searchLabel.setBorder(new EmptyBorder(0,0,10,0));

		emptySearchPanel.add(searchLabel);
		emptySearchPanel.add(new JLabel(Icons.GNOME_CHILD));

		return emptySearchPanel;
	}

	private void updateSearch(IconTextField searchBar)
	{
		String lookup = searchBar.getText().toLowerCase();

		//When the clear button is pressed, this is run.
		if (Strings.isNullOrEmpty(lookup)) {
			searchBar.setIcon(IconTextField.Icon.SEARCH);
			currentlySearching = false;
			this.flippingItemContainerPanel.resetPaginator();
			this.recipeGroupContainerPanel.resetPaginator();
			this.rebuildItemsDisplay(plugin.viewItemsForCurrentView());
			this.rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
			return;
		}
		currentlySearching = true;
		this.flippingItemContainerPanel.resetPaginator();
		this.recipeGroupContainerPanel.resetPaginator();
		this.rebuildItemsDisplay(plugin.viewItemsForCurrentView());
		this.rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
	}

	private <T extends Searchable> List<T> getSearchResults(List<T> objs, String lookup) {
		return objs.stream().filter(
			obj ->
				obj.getNameForSearch().toLowerCase().contains(lookup) && obj.isInInterval(startOfInterval)).
			collect(Collectors.toList());
	}

	/**
	 * Filters the items based on what is currently being searched for. If nothing is being searched
	 * for, it just returns the original list
	 * @param objs all the objs (flipping item or recipe flip group) that could be in the current view
	 */
	private <T extends Searchable> List<T> getResultsForCurrentSearchQuery(List<T> objs) {
		String lookup = searchBar.getText().toLowerCase();
		if (currentlySearching && !Strings.isNullOrEmpty(lookup)) {
			return getSearchResults(objs, lookup);
		}
		return objs;
	}

	public List<FlippingItem> getItemsToDisplay(List<FlippingItem> items) {
		return plugin.sortItems(getResultsForCurrentSearchQuery(getObjsInInterval(items)), selectedSort, startOfInterval);
	}

	public List<RecipeFlipGroup> getRecipeFlipGroupsToDisplay(List<RecipeFlipGroup> recipeFlipGroups) {
		return plugin.sortRecipeFlipGroups(getResultsForCurrentSearchQuery(getObjsInInterval(recipeFlipGroups)), selectedSort, startOfInterval);
	}

	private IconTextField createSearchBar() {
		IconTextField searchBar = UIUtilities.createSearchBar(plugin.getExecutor(), this::updateSearch);
		searchBar.setBorder(BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()));
		return searchBar;
	}

	private JComboBox createTimeIntervalDropdown() {
		JComboBox<String> timeIntervalDropdown = new JComboBox<>(TIME_INTERVAL_STRINGS);
		timeIntervalDropdown.setRenderer(new TitleCaseListCellRenderer());
		timeIntervalDropdown.setEditable(true);
		timeIntervalDropdown.setBorder(BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()));
		timeIntervalDropdown.setBackground(CustomColors.DARK_GRAY_LIGHTER);
		//setting the selected item as session before the item listener is attached so it doesn't fire a rebuildItemsDisplay.
		timeIntervalDropdown.setSelectedItem("Session");
		timeIntervalDropdown.setToolTipText("Specify the time span you would like to see the statistics of");
		timeIntervalDropdown.addItemListener(event ->
		{
			if (event.getStateChange() == ItemEvent.SELECTED)
			{
				String interval = (String) event.getItem();
				if (interval == null) {
					return;
				}
				//remove the helper text. so something like "1w (Past week)" becomes just "1w"
				String justTheInterval = interval.split(" \\(")[0];
				ItemListener[] itemListeners = timeIntervalDropdown.getItemListeners();
				//have to remove item listeners so setSelectedItem doesn't cause another rebuildItemsDisplay.
				for (ItemListener listener : itemListeners) {
					timeIntervalDropdown.removeItemListener(listener);
				}
				timeIntervalDropdown.setSelectedItem(justTheInterval);
				for (ItemListener itemListener : itemListeners) {
					timeIntervalDropdown.addItemListener(itemListener);
				}
				setTimeInterval(justTheInterval);
			}
		});
		return timeIntervalDropdown;
	}

	public void updateCumulativeDisplays(List<FlippingItem> tradesList, List<RecipeFlipGroup> recipeFlipGroups)
	{
		if (!Objects.equals(timeIntervalDropdown.getSelectedItem(), "Session"))
		{
			subInfoPanel.remove(sessionTimePanel);
			subInfoPanel.remove(hourlyProfitPanel);
		}
		else {
			subInfoPanel.add(sessionTimePanel);
			subInfoPanel.add(hourlyProfitPanel);
		}

		long totalProfit = 0;
		long totalExpenses = 0;
		long totalFlips = 0;
		long taxPaid = 0;

		for (FlippingItem item : tradesList)
		{
			Map<String, PartialOffer> offerIdToPartialOffer = plugin.getOfferIdToPartialOffer(item.getItemId());
			List<OfferEvent> intervalHistory = item.getIntervalHistory(startOfInterval);
			if (intervalHistory.isEmpty()) {
				continue;
			}

			List<OfferEvent> adjustedOffers = FlippingItem.getPartialOfferAdjustedView(intervalHistory, offerIdToPartialOffer);

			taxPaid += adjustedOffers.stream().mapToLong(OfferEvent::getTaxPaid).sum();
			totalProfit += FlippingItem.getProfit(adjustedOffers);
			totalExpenses += FlippingItem.getValueOfMatchedOffers(adjustedOffers, true);
			totalFlips += FlippingItem.getFlips(adjustedOffers).size();
		}

		for (RecipeFlipGroup recipeFlipGroup : recipeFlipGroups) {
			List<RecipeFlip> recipeFlips = recipeFlipGroup.getFlipsInInterval(startOfInterval);
			if (recipeFlips.isEmpty()) continue;
			taxPaid += recipeFlips.stream().mapToLong(RecipeFlip::getTaxPaid).sum();
			totalProfit += recipeFlips.stream().mapToLong(RecipeFlip::getProfit).sum();
			totalExpenses += recipeFlips.stream().mapToLong(RecipeFlip::getExpense).sum();
			totalFlips += recipeFlips.size();
		}

		updateTotalProfitDisplay(totalProfit);
		if (Objects.equals(timeIntervalDropdown.getSelectedItem(), "Session"))
		{
			Duration accumulatedTime = plugin.viewAccumulatedTimeForCurrentView();
			updateSessionTimeDisplay(accumulatedTime);
			updateHourlyProfitDisplay(totalProfit, accumulatedTime);
		}
		updateRoiDisplay(totalProfit, totalExpenses);
		updateTotalFlipsDisplay(totalFlips);
		updateTaxPaidDisplay(taxPaid);
	}

	/**
	 * Responsible for updating the total profit label at the very top.
	 * Sets the new total profit value from the items in tradesList from {@link FlippingPlugin#getItemsForCurrentView()}.
	 */
	private void updateTotalProfitDisplay(long totalProfit)
	{
		if (plugin.viewItemsForCurrentView() == null)
		{
			totalProfitVal.setText("0");
			totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
			totalProfitVal.setToolTipText("Total Profit: 0 gp");
			return;
		}

		totalProfitVal.setText(((totalProfit >= 0) ? "" : "-") + UIUtilities.quantityToRSDecimalStack(Math.abs(totalProfit), true) + " gp");
		totalProfitVal.setToolTipText("Total Profit: " + QuantityFormatter.formatNumber(totalProfit) + " gp");

		//Reproduce the RuneScape stack size colors
		if (totalProfit < 0)
		{
			//]-inf, 0[
			totalProfitVal.setForeground(CustomColors.OUTDATED_COLOR);
		}
		else if (totalProfit <= 100000)
		{
			//[0,100k)
			totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		}
		else if (totalProfit <= 10000000)
		{
			//[100k,10m)
			totalProfitVal.setForeground(CustomColors.OFF_WHITE);
		}
		else
		{
			//[10m,inf)
			totalProfitVal.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}
	}

	/**
	 * Updates the hourly profit value display. Also checks and sets the font color according to profit/loss.
	 */
	private void updateHourlyProfitDisplay(long totalProfit, Duration accumulatedTime)
	{
		String profitString;
		double divisor = accumulatedTime.toMillis() / 1000 * 1.0 / (60 * 60);

		if (divisor != 0)
		{
			profitString = UIUtilities.quantityToRSDecimalStack((long) (totalProfit / divisor), true);
		}
		else
		{
			profitString = "0";
		}

		hourlyProfitVal.setText(profitString + " gp/hr");
		hourlyProfitVal.setForeground(totalProfit >= 0 ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
		hourlyProfitPanel.setToolTipText("Hourly profit as determined by the session time");
	}

	/**
	 * Updates the total ROI value display. Also checks and sets the font color according to profit/loss.
	 */
	private void updateRoiDisplay(long totalProfit, long totalExpenses)
	{
		float roi = (float) totalProfit / totalExpenses * 100;

		if (totalExpenses == 0)
		{
			roiVal.setText("0.00%");
			roiVal.setForeground(CustomColors.TOMATO);
			return;
		}
		else
		{
			roiVal.setText(String.format("%.2f", (float) totalProfit / totalExpenses * 100) + "%");
		}

		roiVal.setForeground(UIUtilities.gradiatePercentage(roi, plugin.getConfig().roiGradientMax()));
		roiPanel.setToolTipText("<html>Return on investment:<br>Percentage of profit relative to gp invested</html>");
	}

	private void updateTotalFlipsDisplay(long totalFlips)
	{
		totalFlipsVal.setText(QuantityFormatter.formatNumber(totalFlips));
		totalFlipsVal.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		totalFlipsPanel.setToolTipText("<html>Total amount of flips completed" +
			"<br>Does not count margin checks</html>");
	}

	private void updateTaxPaidDisplay(long taxPaid)
	{
		String taxPaidText = UIUtilities.quantityToRSDecimalStack(taxPaid, true) + " gp";
		taxPaidVal.setText(taxPaidText);
		taxPaidVal.setToolTipText("Tax paid after its implementation");
		taxPaidVal.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		taxPaidPanel.setToolTipText("<html>Tax paid after its implementation</html>");
	}

	/**
	 * This is called every second by the executor service in FlippingPlugin
	 */
	public void updateTimeDisplay()
	{
		flippingItemContainerPanel.updateTimeDisplay();
		recipeGroupContainerPanel.updateTimeDisplay();
	}

	/**
	 * This is called by updateSessionTime in FlippingPlugin, which itself is called every second by
	 * the executor service.
	 *
	 * @param accumulatedTime The total time the user has spent flipping since the client started up.
	 */
	public void updateSessionTimeDisplay(Duration accumulatedTime)
	{
		sessionTimeVal.setText(TimeFormatters.formatDuration(accumulatedTime));
	}

	/**
	 * Invalidates a FlippingItems offers for the currently picked time interval.
	 * This means the panel will not be built upon the next rebuildItemsDisplay calls of StatPanel for that time interval.
	 *
	 * @param itemPanel The panel which holds the FlippingItem to be terminated.
	 */
	public void deleteItemPanel(FlippingItemPanel itemPanel) {
		FlippingItem item = itemPanel.getItem();
		plugin.deleteOffers(item.getIntervalHistory(startOfInterval), item);
		this.rebuildItemsDisplay(plugin.viewItemsForCurrentView());
		this.rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
	}

	public void deleteRecipeFlipGroupPanel(RecipeFlipGroupPanel recipeFlipGroupPanel) {
		recipeFlipGroupPanel.getRecipeFlipGroup().deleteFlips(startOfInterval);
		plugin.setUpdateSinceLastRecipeFlipGroupAccountWideBuild(true);
		plugin.markAccountTradesAsHavingChanged(plugin.getAccountCurrentlyViewed());
		this.rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
		this.rebuildItemsDisplay(plugin.viewItemsForCurrentView());
	}

	/**
	 * Gets called every time the time interval combobox has its selection changed.
	 * Sets the start interval of the profit calculation.
	 *
	 * @param selectedInterval The string from TIME_INTERVAL_STRINGS that is selected in the time interval combobox
	 */
	public void setTimeInterval(String selectedInterval)
	{
		if (selectedInterval == null)
		{
			return;
		}

		Instant timeNow = Instant.now();

		if (selectedInterval.equals("Session")) {
			startOfInterval = plugin.viewStartOfSessionForCurrentView();
			startOfIntervalName = "Session";
		}
		else if (selectedInterval.equals("All")) {
			startOfInterval = Instant.EPOCH;
			startOfIntervalName = "All";
		}
		else {
			if (selectedInterval.length() < 3) {
				JOptionPane.showMessageDialog(timeIntervalDropdown, "Invalid input. Valid input is a negative whole number followed by an abbreviated unit of time. For example," +
						"-123h or -2d or -55w or -2m or -1y are valid inputs.", "Invalid Input",  JOptionPane.ERROR_MESSAGE);
				return;
			}

			String timeUnitString = String.valueOf(selectedInterval.charAt(selectedInterval.length() - 1));
			if (!TimeFormatters.stringToTimeUnit.containsKey(timeUnitString)) {
				JOptionPane.showMessageDialog(timeIntervalDropdown, "Invalid input. Valid input is a negative whole number followed by an abbreviated unit of time. For example," +
						"-123h or -2d or -55w or -2m or -1y are valid inputs.", "Invalid Input",  JOptionPane.ERROR_MESSAGE);
				return;
			}

			try {
				int amountToSubtract = Integer.parseInt(selectedInterval.substring(1, selectedInterval.length() - 1)) * (int) TimeFormatters.stringToTimeUnit.get(timeUnitString);
				startOfInterval = timeNow.minus(amountToSubtract, ChronoUnit.HOURS);
				startOfIntervalName = selectedInterval;

			} catch (NumberFormatException e) {
				JOptionPane.showMessageDialog(timeIntervalDropdown, "Invalid input. Valid input is a negative whole number followed by an abbreviated unit of time. For example," +
						"-123h or -2d or -55w or -2m or -1y are valid inputs.", "Invalid Input",  JOptionPane.ERROR_MESSAGE);
				return;
			}
		}
		this.flippingItemContainerPanel.resetPaginator();
		this.recipeGroupContainerPanel.resetPaginator();
		this.rebuildItemsDisplay(plugin.viewItemsForCurrentView());
		this.rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
	}

	/**
	 * Chooses the font that is used for the sub information based on user config.
	 */
	private void updateSubInfoFont()
	{
		for (int i = 0; i < textLabelArray.length; i++)
		{
			textLabelArray[i].setFont(plugin.getFont());
			valLabelArray[i].setFont(plugin.getFont());
		}
	}

	private <T extends Searchable> List<T> getObjsInInterval(List<T> objs) {
		if (objs == null) {
			return new ArrayList<>();
			}

		return objs.stream().filter(obj -> obj != null && obj.isInInterval(startOfInterval)).collect(Collectors.toList());
	}

	private JLabel createResetButton() {
		JLabel resetIcon = new JLabel(Icons.TRASH_ICON_OFF);
		resetIcon.setBorder(new EmptyBorder(0,12,0,0));
		resetIcon.setPreferredSize(Icons.ICON_SIZE);
		resetIcon.setToolTipText("Reset Statistics");
		resetIcon.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					//Display warning message
					final int result = JOptionPane.showOptionDialog(resetIcon, "<html>Are you sure you want to reset the statistics?" +
									"<br>This only resets the statistics within the currently selected time interval</html>",
							"Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
							null, new String[]{"Yes", "No"}, "No");

					//If the user pressed "Yes"
					if (result == JOptionPane.YES_OPTION)
					{
						plugin.deleteOffers(startOfInterval);
						StatsPanel.this.rebuildItemsDisplay(plugin.viewItemsForCurrentView());
						StatsPanel.this.rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				resetIcon.setIcon(Icons.TRASH_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				resetIcon.setIcon(Icons.TRASH_ICON_OFF);
			}
		});
		return resetIcon;
	}

	private JLabel createDownloadButton() {
		JPanel parent = this;
		JLabel downloadIcon = new JLabel(Icons.DONWLOAD_ICON_OFF);
		downloadIcon.setBorder(new EmptyBorder(0,12,0,0));
		downloadIcon.setPreferredSize(Icons.ICON_SIZE);
		downloadIcon.setToolTipText("Export to CSV");
		downloadIcon.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				JFileChooser f = new JFileChooser();
				f.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
				f.showSaveDialog(parent);
				File selectedDirectory = f.getSelectedFile();
				if (selectedDirectory == null) {
					return;
				}
				log.info("exporting to csv in folder {}", f.getSelectedFile());
				try {
					plugin.exportToCsv(f.getSelectedFile(), startOfInterval, startOfIntervalName);
					JOptionPane.showMessageDialog(
							parent,
							String.format("Successfully saved csv file to %s/%s.csv", f.getSelectedFile().toString(), plugin.getAccountCurrentlyViewed()),
							"Successfully saved CSV!",
							JOptionPane.INFORMATION_MESSAGE
					);
				}
				catch (Exception exc) {
					JOptionPane.showMessageDialog(
							parent,
							String.format("Could not save CSV file. Error: %s", exc.toString()),
							"Could not save csv file",
							JOptionPane.ERROR_MESSAGE);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				downloadIcon.setIcon(Icons.DOWNLOAD_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				downloadIcon.setIcon(Icons.DONWLOAD_ICON_OFF);
			}
		});
		return downloadIcon;
	}

	private JPanel createTopPanel(IconTextField searchBar) {
		JPanel topPanel = new JPanel(new BorderLayout());

		JPanel searchAndDownloadPanel = new JPanel(new BorderLayout());
		searchAndDownloadPanel.add(searchBar, BorderLayout.CENTER);
		searchAndDownloadPanel.add(createResetButton(), BorderLayout.EAST);
		searchAndDownloadPanel.setBorder(new EmptyBorder(5,0,0,0));

		JPanel timeIntervalDropdownAndResetPanel = new JPanel(new BorderLayout());
		timeIntervalDropdownAndResetPanel.add(timeIntervalDropdown, BorderLayout.CENTER);
		timeIntervalDropdownAndResetPanel.add(createDownloadButton(), BorderLayout.EAST);

		topPanel.add(timeIntervalDropdownAndResetPanel, BorderLayout.NORTH);
		topPanel.add(searchAndDownloadPanel, BorderLayout.CENTER);
		topPanel.add(createProfitAndSubInfoContainer(), BorderLayout.SOUTH);
		topPanel.setBorder(new EmptyBorder(0,0,2,0));

		return topPanel;
	}

	private void prepareLabels() {
		Arrays.stream(textLabelArray).forEach(l -> l.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH));

		sessionTimeVal.setText(TimeFormatters.formatDuration(plugin.viewAccumulatedTimeForCurrentView()));
		sessionTimeVal.setPreferredSize(new Dimension(200, 0));
		sessionTimeVal.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);

		//Profit total over the selected time interval
		totalProfitVal.setFont(StyleContext.getDefaultStyleContext()
			.getFont(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 28));
		totalProfitVal.setHorizontalAlignment(SwingConstants.CENTER);
		totalProfitVal.setToolTipText("");

		updateSubInfoFont();
	}

	private JPanel createTotalProfitPanel(JPanel subInfoPanel) {
		//Title text for the big total profit label.
		final JLabel profitText = new JLabel("Total Profit: ", SwingConstants.CENTER);
		profitText.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		profitText.setFont(FontManager.getRunescapeBoldFont());

		JLabel arrowIcon = new JLabel(Icons.OPEN_ICON);
		arrowIcon.setPreferredSize(ICON_SIZE);

		//Make sure the profit label is centered
		JLabel padLabel = new JLabel();
		padLabel.setPreferredSize(ICON_SIZE);

		//Formats the profit text and value.
		JPanel profitTextAndVal = new JPanel(new BorderLayout());
		profitTextAndVal.setBackground(CustomColors.DARK_GRAY);
		profitTextAndVal.setBorder(new EmptyBorder(5,0,3,0));
		profitTextAndVal.add(totalProfitVal, BorderLayout.CENTER);
		profitTextAndVal.add(profitText, BorderLayout.NORTH);

		//Contains the total profit information.
		JPanel totalProfitPanel = new JPanel(new BorderLayout());
		totalProfitPanel.setBackground(CustomColors.DARK_GRAY);
		totalProfitPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(1,1,0,1, ColorScheme.DARKER_GRAY_COLOR.darker()),
				new EmptyBorder(7,0,7,0)));
		totalProfitPanel.add(profitTextAndVal, BorderLayout.CENTER);
		totalProfitPanel.add(arrowIcon, BorderLayout.EAST);
		totalProfitPanel.add(padLabel, BorderLayout.WEST);

		//Controls the collapsible sub info function
		MouseAdapter collapseOnClick = new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					if (subInfoPanel.isVisible())
					{
						//Collapse sub info
						arrowIcon.setIcon(Icons.CLOSE_ICON);
						subInfoPanel.setVisible(false);
						totalProfitPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()),
								new EmptyBorder(7,0,7,0)));
					}
					else
					{
						//Expand sub info
						arrowIcon.setIcon(Icons.OPEN_ICON);
						subInfoPanel.setVisible(true);
						totalProfitPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createMatteBorder(1,1,0,1, ColorScheme.DARKER_GRAY_COLOR.darker()),
								new EmptyBorder(7,0,7,0)));
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				totalProfitPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				profitTextAndVal.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				totalProfitPanel.setBackground(CustomColors.DARK_GRAY);
				profitTextAndVal.setBackground(CustomColors.DARK_GRAY);
			}
		};

		totalProfitPanel.addMouseListener(collapseOnClick);
		totalProfitVal.addMouseListener(collapseOnClick);

		return totalProfitPanel;
	}

	private JPanel createSubInfoPanel() {
		JPanel subInfoPanel = new JPanel();
		/* Subinfo represents the less-used general historical stats */
		subInfoPanel.setLayout(new DynamicGridLayout(subInfoPanelArray.length, 1));

		for (JPanel panel : subInfoPanelArray)
		{
			panel.setBorder(new EmptyBorder(4, 2, 4, 2));
			panel.setBackground(CustomColors.DARK_GRAY);
			//these are added in update displays if the time interval is set to "Session"
			if (panel != hourlyProfitPanel && panel != sessionTimePanel) {
				subInfoPanel.add(panel);
			}
		}

		//All labels should already be sorted in their arrays.
		for (int i = 0; i < subInfoPanelArray.length; i++)
		{
			subInfoPanelArray[i].add(textLabelArray[i], BorderLayout.WEST);
			subInfoPanelArray[i].add(valLabelArray[i], BorderLayout.EAST);
		}

		subInfoPanel.setBackground(CustomColors.DARK_GRAY);
		subInfoPanel.setBorder(new EmptyBorder(9, 5, 5, 5));
		subInfoPanel.setBorder(BorderFactory.createCompoundBorder(
				BorderFactory.createMatteBorder(0,2,2,2, ColorScheme.DARKER_GRAY_COLOR.darker()),
				new EmptyBorder(2, 5, 5, 5)));
		return subInfoPanel;
	}

	private JPanel createProfitAndSubInfoContainer() {
		subInfoPanel = this.createSubInfoPanel();
		JPanel profitAndSubInfoContainer = new JPanel(new BorderLayout());
		profitAndSubInfoContainer.add(this.createTotalProfitPanel(subInfoPanel), BorderLayout.NORTH);
		profitAndSubInfoContainer.add(subInfoPanel, BorderLayout.SOUTH);
		profitAndSubInfoContainer.setBorder(new EmptyBorder(5, 0, 5, 0));
		return profitAndSubInfoContainer;
	}
}
package com.flippingutilities.ui.statistics.items;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.model.PartialOffer;
import com.flippingutilities.ui.MasterPanel;
import com.flippingutilities.ui.recipeflips.RecipeFlipCreationPanel;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.TimeFormatters;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * The offer panel displays an offer's price, quantity, time bought, total cost,
 * and gives the option to delete it.
 */
public class OfferPanel extends JPanel {
    private final JLabel timeDisplay;
    private final OfferEvent offer;
    private final FlippingPlugin plugin;
    private final FlippingItem item;
    //flag used to decide whether the icons such as the delete icon and recipe flip icon should be shown.
    //when these panels are being displayed in the recipeFlipPanel, we don't want to show those icons.
    private boolean plainMode;
    private JLabel offerDescriptionLabel;

    public OfferPanel(FlippingPlugin plugin, FlippingItem item, OfferEvent offer, boolean plainMode) {
        setLayout(new BorderLayout());
        this.offer = offer;
        this.plugin = plugin;
        this.item = item;
        this.plainMode = plainMode;
        this.timeDisplay = createTimeDisplayLabel();
        this.offerDescriptionLabel = createOfferDescriptionLabel();
        add(createTitlePanel(offerDescriptionLabel, timeDisplay), BorderLayout.NORTH);
        add(createBodyPanel(), BorderLayout.CENTER);

        setBackground(CustomColors.DARK_GRAY);
        setBorder(createBorder(false));
    }

    /**
     * Is called by a background task to continuously update the time display
     */
    public void updateTimeDisplay() {
        if (offer.isComplete()) {
            timeDisplay.setText("(" + TimeFormatters.formatDurationTruncated(offer.getTime()) + " ago)");
        }
        else {
            timeDisplay.setText(TimeFormatters.formatDurationTruncated(offer.getTime()) + " ago");
        }
    }

    private JPanel createTitlePanel(JLabel offerDescription, JLabel timeDisplay) {
        JPanel titlePanel = new JPanel();
        titlePanel.setBorder(new EmptyBorder(0,0,2,0));
        titlePanel.setBackground(CustomColors.DARK_GRAY);
        if (!offer.isComplete()) {
            //idk why but when i set the dynamic grid layout the offer description label has
            //no distance from the top, but this doesn't happen when the title panel is the default layout (flowlayout)
            titlePanel.setBorder(new EmptyBorder(5,0,2,0));
            titlePanel.setLayout(new DynamicGridLayout(2, 1));
        }

        titlePanel.add(offerDescription);
        titlePanel.add(timeDisplay);
        return titlePanel;
    }

    private JLabel createTimeDisplayLabel() {
        JLabel timeDisplay = new JLabel("", SwingConstants.CENTER);
        timeDisplay.setBackground(CustomColors.DARK_GRAY);
        timeDisplay.setOpaque(true);
        timeDisplay.setFont(FontManager.getRunescapeSmallFont());
        timeDisplay.setForeground(offer.isBuy() ? CustomColors.OUTDATED_COLOR : ColorScheme.GRAND_EXCHANGE_PRICE);
        if (!offer.isComplete()) {
            timeDisplay.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        }

        if (offer.isComplete()) {
            timeDisplay.setText("(" + TimeFormatters.formatDurationTruncated(offer.getTime()) + " ago)");
        }
        else {
            timeDisplay.setText(TimeFormatters.formatDurationTruncated(offer.getTime()) + " ago");
        }

        return timeDisplay;
    }
    private JLabel createOfferDescriptionLabel() {
        JLabel offerDescriptionLabel = new JLabel("", SwingConstants.CENTER);
        offerDescriptionLabel.setBackground(CustomColors.DARK_GRAY);
        offerDescriptionLabel.setOpaque(true);
        offerDescriptionLabel.setFont(FontManager.getRunescapeSmallFont());

        if (!offer.isComplete()) {
            offerDescriptionLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
            offerDescriptionLabel.setText(
                    QuantityFormatter.formatNumber(offer.getCurrentQuantityInTrade()) + " " + getOfferDescription() + " (ongoing)");
        }
        else {
            offerDescriptionLabel.setForeground(offer.isBuy() ? CustomColors.OUTDATED_COLOR : ColorScheme.GRAND_EXCHANGE_PRICE);
            offerDescriptionLabel.setText(
                    QuantityFormatter.formatNumber(offer.getCurrentQuantityInTrade()) + " " + getOfferDescription()
            );
        }
        return offerDescriptionLabel;
    }

    /**
     * The body panel contains everything but the title, currently this means
     * it holds the prices and the icons
     */
    private JPanel createBodyPanel() {
        JPanel body = new JPanel(new DynamicGridLayout(3, 0, 0, 2));
        body.setBackground(CustomColors.DARK_GRAY);
        body.setBorder(new EmptyBorder(0, 2, 1, 2));

        JLabel priceLabel = new JLabel("Price:");
        JLabel priceVal = new JLabel(QuantityFormatter.formatNumber(offer.getPrice()) + " gp", SwingConstants.RIGHT);

        JLabel totalPriceLabel = new JLabel("Total:");
        JLabel totalPriceVal = new JLabel(QuantityFormatter.formatNumber(offer.getPrice() * offer.getCurrentQuantityInTrade()) + " gp", SwingConstants.RIGHT);

        JLabel[] descriptions = {priceLabel, totalPriceLabel};
        JLabel[] vals = {priceVal, totalPriceVal};

        for (int i = 0; i < descriptions.length; i++) {
            JLabel descriptionLabel = descriptions[i];
            JLabel valLabel = vals[i];

            descriptionLabel.setFont(FontManager.getRunescapeSmallFont());
            descriptionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            valLabel.setFont(FontManager.getRunescapeSmallFont());
            valLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

            JPanel infoPanel = new JPanel(new BorderLayout());
            infoPanel.setBackground(CustomColors.DARK_GRAY);
            infoPanel.add(descriptionLabel, BorderLayout.WEST);
            infoPanel.add(valLabel, BorderLayout.EAST);
            body.add(infoPanel);
        }

        if (!plainMode) {
            body.add(createIconPanel());
        }

        return body;
    }

    /**
     * Creates the panel which holds the delete icon and recipe flip
     * icon (if needed)
     */
    private JPanel createIconPanel() {
        JPanel iconPanel = new JPanel(new BorderLayout());
        iconPanel.setBackground(CustomColors.DARK_GRAY);
        boolean hasRecipe = !plugin.getApplicableRecipes(offer.getItemId(), offer.isBuy()).isEmpty();
        //need it to be complete because in HistoryManager.updateHistory we delete the previous offer events to only
        //keep the complete one.
        if (hasRecipe && offer.isComplete()) {
            JLabel deleteIcon = createDeleteIcon();
            deleteIcon.setBorder(new EmptyBorder(0,5,0,0));
            iconPanel.add(createRecipeFlipIcon(), BorderLayout.EAST);
            iconPanel.add(deleteIcon, BorderLayout.WEST);
        }
        else {
            iconPanel.add(createDeleteIcon(), BorderLayout.CENTER);
        }

        return iconPanel;
    }

    private JComponent createRecipeFlipIcon() {
        PartialOffer po = plugin.getOfferIdToPartialOffer(item.getItemId()).get(offer.getUuid());
        if (po != null && po.amountConsumed == offer.getCurrentQuantityInTrade()) {
            JLabel recipeFlipLabel = new JLabel("Fully consumed");
            recipeFlipLabel.setFont(new Font("Whitney", Font.PLAIN, 10));
            recipeFlipLabel.setForeground(CustomColors.TOMATO);
            return recipeFlipLabel;
        }
        JButton recipeFlipButton = new JButton("Recipe Flip +");
        recipeFlipButton.setToolTipText("<html>A recipe flip is when you combine several items into one to sell it, <br>" +
                "or break apart an item into parts to sell them. <br>If that's what you did with this offer, click me!</html>");
        recipeFlipButton.setFocusPainted(false);
        recipeFlipButton.setFont(new Font("Whitney", Font.PLAIN, 10));
        recipeFlipButton.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        recipeFlipButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE)) {
                    JOptionPane.showMessageDialog(null, "You cannot create recipe flips in the Accountwide view");
                    return;
                }
                MasterPanel m = plugin.getMasterPanel();
                RecipeFlipCreationPanel recipeFlipCreationPanel = new RecipeFlipCreationPanel(plugin, offer);
                JDialog recipeFlipCreationModal = UIUtilities.createModalFromPanel(m, recipeFlipCreationPanel);
                recipeFlipCreationPanel.setModal(recipeFlipCreationModal);
                recipeFlipCreationModal.pack();
                recipeFlipCreationModal.setLocation(
                    Math.max(20, m.getLocationOnScreen().x - recipeFlipCreationModal.getWidth() - 10),
                    Math.max(m.getLocationOnScreen().y - recipeFlipCreationModal.getHeight()/2, 0) + 100);
                recipeFlipCreationModal.setVisible(true);
            }
        });
        return recipeFlipButton;
    }

    /**
     * Creates the panel which holds the delete icon to delete that specific offer
     */
    private JLabel createDeleteIcon() {
        JLabel deleteIcon = new JLabel(Icons.TRASH_CAN_OFF);
        deleteIcon.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                if (plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE)) {
                    JOptionPane.showMessageDialog(null, "You cannot delete offers in the Accountwide view");
                    return;
                }
                //Display warning message
                final int result = JOptionPane.showOptionDialog(deleteIcon, "Are you sure you want to delete this offer?",
                        "Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
                        null, new String[]{"Yes", "No"}, "No");

                //If the user pressed "Yes"
                if (result == JOptionPane.YES_OPTION) {
                    plugin.deleteOffers(new ArrayList<>(Arrays.asList(offer)), item);
                    plugin.getStatPanel().rebuildItemsDisplay(plugin.viewItemsForCurrentView());
                    plugin.getStatPanel().rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());

                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                deleteIcon.setIcon(Icons.TRASH_CAN_ON);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                deleteIcon.setIcon(Icons.TRASH_CAN_OFF);
            }
        });

        return deleteIcon;
    }

    private String getOfferDescription() {
        if (offer.isBuy() && offer.isMarginCheck()) {
            return "Insta Bought";
        } else if (offer.isBuy() && !offer.isMarginCheck()) {
            return "Bought";
        } else if (!offer.isBuy() && offer.isMarginCheck()) {
            return "Insta Sold";
        } else if (!offer.isBuy() && !offer.isMarginCheck()) {
            return "Sold";
        } else {
            return "";
        }
    }

    /**
     * Used in the RecipeFlipPanel to show that this offer panel is selected or not
     */
    public void setSelected(boolean selected) {
        setBorder(createBorder(selected));
    }

    private Border createBorder(boolean selected) {
        Color outerBorderColor = selected? ColorScheme.GRAND_EXCHANGE_PRICE.darker():ColorScheme.DARKER_GRAY_COLOR.darker();
        return new CompoundBorder(
                BorderFactory.createMatteBorder(1,1,1,1, outerBorderColor),
                new EmptyBorder(1,3,3,3));
    }

    /**
     * I really hate java swing, having to approximate the damn width of this using this really stupid code. For
     * some reason the layout manager is not respecting sizes and i have to set it manually on the scrollpane.
     * I'm probably doing something wrong, but don't feel like going any deeper into java swing....
     */
    public int getHackySize() {
        int timeDisplayWidth = (timeDisplay.getText().length() * 8) + 5;
        int gapBetweenDescAndTimeDisplays = 10;
        int descriptionDisplayWidth = (offerDescriptionLabel.getText().length() * 6) + 5;
        return timeDisplayWidth + gapBetweenDescAndTimeDisplays + descriptionDisplayWidth;
    }
}

package com.flippingutilities.ui.statistics.items;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.ui.statistics.StatsPanel;
import com.flippingutilities.ui.uiutilities.Paginator;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class FlippingItemContainerPanel extends JPanel {

    private JPanel flippingItemPanelsContainer;
    private List<FlippingItemPanel> activePanels = new ArrayList<>();
    private Paginator paginator;
    private FlippingPlugin plugin;

    public FlippingItemContainerPanel(FlippingPlugin flippingPlugin) {
        plugin = flippingPlugin;
        flippingItemPanelsContainer = createStatItemsPanelContainer();
        paginator = createPaginator();

        JScrollPane scrollPane = createScrollPane(flippingItemPanelsContainer);

        setLayout(new BorderLayout());

        add(scrollPane, BorderLayout.CENTER);
        add(paginator, BorderLayout.SOUTH);
    }

    public void resetPaginator() {
        paginator.setPageNumber(1);
    }

    public void rebuild(List<FlippingItem> flippingItems) {
        activePanels.clear();
        flippingItemPanelsContainer.removeAll();
        paginator.updateTotalPages(flippingItems.size());

        if (!flippingItems.isEmpty()) {
            List<FlippingItem> itemsOnCurrentPage = paginator.getCurrentPageItems(flippingItems);
            List<FlippingItemPanel> newPanels = itemsOnCurrentPage.stream().map(item -> new FlippingItemPanel(plugin, item)).collect(Collectors.toList());
            UIUtilities.stackPanelsVertically((List) newPanels, flippingItemPanelsContainer, 5);
            activePanels.addAll(newPanels);
        }
        else {
            flippingItemPanelsContainer.add(createHelpLabel());
        }
    }

    public void showPanel(JPanel panel) {
        activePanels.clear();
        flippingItemPanelsContainer.removeAll();
        flippingItemPanelsContainer.add(panel);
    }

    private JLabel createHelpLabel() {
        JLabel helpLabel = new JLabel(
            "<html><body width='220' style='text-align:center;'>" +
                "Make some trades to see your item history here!");
        helpLabel.setFont(new Font("Whitney", Font.PLAIN, 15));
        helpLabel.setBorder(new EmptyBorder(40,5,0,0));
        helpLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        return helpLabel;
    }

    private JPanel createStatItemsPanelContainer() {
        JPanel statItemPanelsContainer = new JPanel();
        statItemPanelsContainer.setLayout(new BoxLayout(statItemPanelsContainer, BoxLayout.Y_AXIS));
        return statItemPanelsContainer;
    }

    private JScrollPane createScrollPane(JPanel statItemPanelsContainer) {
        JPanel statItemPanelsContainerWrapper = new JPanel(new BorderLayout());
        statItemPanelsContainerWrapper.setBorder(new EmptyBorder(0,0,0,3));
        statItemPanelsContainerWrapper.add(statItemPanelsContainer, BorderLayout.NORTH);

        JScrollPane scrollPane = new JScrollPane(statItemPanelsContainerWrapper);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setBorder(new EmptyBorder(5, 0, 0, 0));
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));

        return scrollPane;
    }

    private Paginator createPaginator() {
        paginator = new Paginator(() -> SwingUtilities.invokeLater(() -> {
            StatsPanel statsPanel = plugin.getStatPanel();
            Instant rebuildStart = Instant.now();
            rebuild(statsPanel.getItemsToDisplay(plugin.viewItemsForCurrentView()));
            revalidate();
            repaint();
            log.debug("page change took {}", Duration.between(rebuildStart, Instant.now()).toMillis());
        }));
        paginator.setBackground(ColorScheme.DARK_GRAY_COLOR);
        paginator.setBorder(new MatteBorder(1,0,0,0, ColorScheme.DARK_GRAY_COLOR.darker()));
        return paginator;
    }

    public void updateTimeDisplay() {
        activePanels.forEach(FlippingItemPanel::updateTimeLabels);
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.statistics.items;

import com.flippingutilities.model.Flip;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.TimeFormatters;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class FlipPanel extends JPanel
{
	JLabel title = new JLabel("", SwingConstants.CENTER);

	private Flip flip;

	FlipPanel(Flip flip)
	{
		this.flip = flip;

		setLayout(new BorderLayout());
		setBackground(CustomColors.DARK_GRAY);
		setBorder(new EmptyBorder(2,2,2,2));


		int profitEach = flip.getSellPrice() - flip.getBuyPrice();
		int profitTotal = profitEach * flip.getQuantity();

		title.setOpaque(true);
		title.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		title.setFont(FontManager.getRunescapeSmallFont());
		title.setBorder(new EmptyBorder(0,0,2,0));
		updateTitleAndTimeDisplay();

		JLabel buyPriceText = new JLabel("Buy Price:");
		JLabel sellPriceText = new JLabel("Sell Price:");
		JLabel profitText = new JLabel((profitTotal >= 0) ? "Profit: " : "Loss: ");

		JLabel buyPriceVal = new JLabel(QuantityFormatter.formatNumber(flip.getBuyPrice()) + " gp", SwingConstants.RIGHT);
		JLabel sellPriceVal = new JLabel(QuantityFormatter.formatNumber(flip.getSellPrice()) + " gp", SwingConstants.RIGHT);

		String profitString = UIUtilities.quantityToRSDecimalStack(profitTotal, true) + " gp"
			+ ((flip.getQuantity() <= 1) ? "" : " (" + UIUtilities.quantityToRSDecimalStack(profitEach, false) + " gp ea)");

		JLabel profitVal = new JLabel(profitString);

		JLabel[] labelList = {buyPriceText, buyPriceVal, sellPriceText, sellPriceVal, profitText, profitVal};

		for (JLabel label : labelList)
		{
			label.setFont(FontManager.getRunescapeSmallFont());
			label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		}

		profitText.setForeground((profitTotal >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
		profitVal.setForeground((profitTotal >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);

		JPanel buyPricePanel = new JPanel(new BorderLayout());
		buyPricePanel.setBackground(CustomColors.DARK_GRAY);

		JPanel sellPricePanel = new JPanel(new BorderLayout());
		sellPricePanel.setBackground(CustomColors.DARK_GRAY);

		JPanel profitPanel = new JPanel(new BorderLayout());
		profitPanel.setBackground(CustomColors.DARK_GRAY);

		buyPricePanel.add(buyPriceText, BorderLayout.WEST);
		buyPricePanel.add(buyPriceVal, BorderLayout.EAST);

		sellPricePanel.add(sellPriceText, BorderLayout.WEST);
		sellPricePanel.add(sellPriceVal, BorderLayout.EAST);

		profitPanel.add(profitText, BorderLayout.WEST);
		profitPanel.add(profitVal, BorderLayout.EAST);

		JPanel infoContainer = new JPanel(new DynamicGridLayout(3, 2, 0, 2));
		infoContainer.setBackground(CustomColors.DARK_GRAY);

		infoContainer.add(buyPricePanel);
		infoContainer.add(sellPricePanel);
		infoContainer.add(profitPanel);

		infoContainer.setBorder(new EmptyBorder(0, 2, 1, 2));

		add(title, BorderLayout.NORTH);
		add(infoContainer, BorderLayout.CENTER);
	}

	public void updateTitleAndTimeDisplay()
	{
		if (flip.isMarginCheck())
		{
			title.setText("Margin Checked " + "(" + TimeFormatters.formatDurationTruncated(flip.getTime()) + " ago)");
			title.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}

		else if (flip.isOngoing())
		{
			title.setText(QuantityFormatter.formatNumber(flip.getQuantity()) + " Flipped (ongoing)");
			title.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		}

		else
		{
			title.setText(QuantityFormatter.formatNumber(flip.getQuantity()) + " Flipped (" + TimeFormatters.formatDurationTruncated(flip.getTime()) + " ago)");
			title.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}
	}

}


/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.ui.statistics.items;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.*;
import com.flippingutilities.ui.statistics.StatsPanel;
import com.flippingutilities.ui.uiutilities.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
public class FlippingItemPanel extends JPanel
{
	private FlippingPlugin plugin;
	@Getter
	private FlippingItem item;

	private StatsPanel statsPanel;

	private JLabel itemProfitAndQuantityLabel = new JLabel();
	private JPanel itemIconTitlePanel = new JPanel(new BorderLayout());

	private JLabel totalProfitValLabel = new JLabel("", SwingConstants.RIGHT);
	private JLabel profitEachValLabel = new JLabel("", SwingConstants.RIGHT);
	private JLabel quantityFlipped = new JLabel("", SwingConstants.RIGHT);
	private JLabel roiValLabel = new JLabel("", SwingConstants.RIGHT);
	private JLabel avgBuyPriceValLabel = new JLabel("", SwingConstants.RIGHT);
	private JLabel avgSellPriceValLabel = new JLabel("", SwingConstants.RIGHT);
	private JLabel quantityBoughtLabel = new JLabel("", SwingConstants.RIGHT);
	private JLabel quantitySoldLabel = new JLabel("", SwingConstants.RIGHT);

	private List<FlipPanel> flipPanels = new ArrayList<>();
	private List<OfferPanel> offerPanels = new ArrayList<>();

	private Paginator flipPaginator;
	private Paginator offerPaginator;

	private JPanel offersBackgroundPanel = new JPanel();
	private JPanel flipsBackgroundPanel = new JPanel();

	/**
	 * This panel represents the middle layer of information. It contains general information about the item
	 * along with being the container for the trade history of that item.
	 *
	 * @param plugin       Used to access the plugin user config.
	 * @param item The item that the panel represents.
	 */

	FlippingItemPanel(FlippingPlugin plugin, FlippingItem item)
	{
		setLayout(new BorderLayout());
		setBorder(BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()));

		this.plugin = plugin;
		this.item = item;
		this.statsPanel = plugin.getStatPanel();

		List<OfferEvent> offers = item.getIntervalHistory(statsPanel.getStartOfInterval());
		Map<String, PartialOffer> offerIdToPartialOffer = plugin.getOfferIdToPartialOffer(item.getItemId());
		List<OfferEvent> adjustedOffers = FlippingItem.getPartialOfferAdjustedView(offers, offerIdToPartialOffer);
		List<Flip> flips = FlippingItem.getFlips(adjustedOffers);

		this.flipPaginator = createPaginator(() -> buildAllFlipsPanel(flips));
		this.offerPaginator = createPaginator(() -> buildAllOffersPanels(offers));

		offerPaginator.updateTotalPages(offers.size());
		flipPaginator.updateTotalPages(flips.size());

		buildAllFlipsPanel(flips);
		buildAllOffersPanels(offers);

		JLabel[] descriptionLabels = {new JLabel("Total Profit: "), new JLabel("Avg. Profit ea: "), new JLabel("Avg. ROI: "), new JLabel("Quantity Flipped: "),
			new JLabel(" "), new JLabel("Quantity Bought: "), new JLabel("Quantity Sold: "), new JLabel("Avg. Buy Price: "), new JLabel("Avg. Sell Price: ")};

		JLabel[] valueLabels = {totalProfitValLabel, profitEachValLabel, roiValLabel, quantityFlipped,
			new JLabel(" "), quantityBoughtLabel, quantitySoldLabel, avgBuyPriceValLabel,
			avgSellPriceValLabel};

		JPanel subInfoPanel = createSubInfoPanel(descriptionLabels, valueLabels);
		JPanel tradeHistoryPanel = createTradeHistoryPanel(offersBackgroundPanel, flipsBackgroundPanel);
		JPanel subInfoAndHistoryContainer = createSubInfoAndHistoryContainer(subInfoPanel, tradeHistoryPanel);
        JPanel titlePanel = createTitlePanel(createIconPanel(plugin.getItemManager()), createNameAndProfitPanel(), createCollapseIcon(), subInfoAndHistoryContainer);

        updateLabels(offers, adjustedOffers);

        add(titlePanel, BorderLayout.NORTH);
        add(subInfoAndHistoryContainer, BorderLayout.CENTER);
	}

	private JPanel createSubInfoAndHistoryContainer(JPanel subInfoPanel, JPanel tradeHistoryPanel) {
        JPanel subInfoAndHistoryContainer = new JPanel(new BorderLayout());
        //Set background and border of container with sub infos and trade history
        subInfoAndHistoryContainer.setBackground(CustomColors.DARK_GRAY_LIGHTER);
        subInfoAndHistoryContainer.add(subInfoPanel, BorderLayout.CENTER);
        subInfoAndHistoryContainer.add(tradeHistoryPanel, BorderLayout.SOUTH);
        subInfoAndHistoryContainer.setVisible(statsPanel.getExpandedItems().contains(item.getItemName()));
        return subInfoAndHistoryContainer;
    }

	private Paginator createPaginator(Runnable runnable) {
        Paginator paginator = new Paginator(runnable);
        paginator.setPageSize(10);
        paginator.setBackground(CustomColors.DARK_GRAY);
        paginator.getStatusText().setFont(FontManager.getRunescapeSmallFont());
        paginator.setBorder(BorderFactory.createMatteBorder(1,1,1,1, ColorScheme.DARKER_GRAY_COLOR.darker()));
        return paginator;
    }

    private void putPanelsOnBackgroundPanel(List<JPanel> panels, JPanel backgroundPanel, Paginator paginator) {
		List<JPanel> panelsAndPaginator = new ArrayList<>();
		JPanel paginatorWrapper = new JPanel();
		paginatorWrapper.add(paginator);
		panelsAndPaginator.add(paginatorWrapper);
		panelsAndPaginator.addAll(panels);
		backgroundPanel.removeAll();
		UIUtilities.stackPanelsVertically(panelsAndPaginator, backgroundPanel, 2);
		if (panels.isEmpty()) {
			//if i don't wrap the label, the box layout places it weird....
			JPanel labelWrapper = new JPanel();
			JLabel noDataLabel = new JLabel("Nothing here...", SwingConstants.CENTER);
			noDataLabel.setForeground(CustomColors.TOMATO);
			noDataLabel.setFont(new Font("Whitney", Font.PLAIN, 10));
			labelWrapper.add(noDataLabel);
			backgroundPanel.add(labelWrapper);
		}
		repaint();
		revalidate();
	}

	private void buildAllOffersPanels(List<OfferEvent> offers) {
        List<OfferEvent> reversedHistory = new ArrayList<>(offers);
        Collections.reverse(reversedHistory);
        List<OfferEvent> offersOnCurrentPage = offerPaginator.getCurrentPageItems(reversedHistory);
        offerPanels = offersOnCurrentPage.stream().map(
                offerEvent -> new OfferPanel(
                        plugin, item, offerEvent, false))
                .collect(Collectors.toList());
		putPanelsOnBackgroundPanel(new ArrayList<>(offerPanels), offersBackgroundPanel, offerPaginator);
	}

	private void buildAllFlipsPanel(List<Flip> flips) {
		List<Flip> flipsCopy = new ArrayList<>(flips);
		Collections.reverse(flipsCopy);
        List<Flip> flipsOnCurrentPage = flipPaginator.getCurrentPageItems(flipsCopy);
        flipPanels = flipsOnCurrentPage.stream().map(FlipPanel::new).collect(Collectors.toList());
		putPanelsOnBackgroundPanel(new ArrayList<>(flipPanels), flipsBackgroundPanel, flipPaginator);
	}

	private JPanel createTitlePanel(JPanel itemIconPanel, JPanel nameAndProfitPanel, JLabel collapseIcon, JPanel subInfoAndHistoryContainer)
	{
		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBackground(CustomColors.DARK_GRAY);
		titlePanel.setBorder(new EmptyBorder(5, 4, 5, 4));

		titlePanel.add(itemIconPanel, BorderLayout.WEST);
		titlePanel.add(nameAndProfitPanel, BorderLayout.CENTER);
		titlePanel.add(collapseIcon, BorderLayout.EAST);

		titlePanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (e.getButton() == MouseEvent.BUTTON1)
				{
					if (subInfoAndHistoryContainer.isVisible())
					{
						collapseIcon.setIcon(Icons.CLOSE_ICON);
						subInfoAndHistoryContainer.setVisible(false);
						statsPanel.getExpandedItems().remove(item.getItemName());
					}
					else
					{
						collapseIcon.setIcon(Icons.OPEN_ICON);
						subInfoAndHistoryContainer.setVisible(true);
						statsPanel.getExpandedItems().add(item.getItemName());
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				titlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				nameAndProfitPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				for (Component component : nameAndProfitPanel.getComponents()) {
					component.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				}
				itemIconTitlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				titlePanel.setBackground(CustomColors.DARK_GRAY);
				nameAndProfitPanel.setBackground(CustomColors.DARK_GRAY);
				for (Component component : nameAndProfitPanel.getComponents()) {
					component.setBackground(CustomColors.DARK_GRAY);
				}
				itemIconTitlePanel.setBackground(CustomColors.DARK_GRAY);
			}
		});

		return titlePanel;
	}

	private JPanel createSubInfoPanel(JLabel[] descriptionLabels, JLabel[] valueLabels)
	{
		JPanel subInfoContainer = new JPanel();
		subInfoContainer.setBackground(CustomColors.DARK_GRAY_LIGHTER);
		subInfoContainer.setLayout(new DynamicGridLayout(valueLabels.length, descriptionLabels.length));
		subInfoContainer.setBorder(new EmptyBorder(10,6,6,6));

		for (int i = 0; i < descriptionLabels.length; i++)
		{
			JLabel textLabel = descriptionLabels[i];
			JLabel valLabel = valueLabels[i];
			JPanel panel = new JPanel(new BorderLayout());

			panel.add(textLabel, BorderLayout.WEST);
			panel.add(valLabel, BorderLayout.EAST);

			panel.setBorder(new EmptyBorder(4, 2, 4, 2));
			panel.setBackground(CustomColors.DARK_GRAY_LIGHTER);

			textLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);

			textLabel.setFont(FontManager.getRunescapeSmallFont());
			valLabel.setFont(FontManager.getRunescapeSmallFont());

			subInfoContainer.add(panel);
		}

		return subInfoContainer;
	}

	private JPanel createTradeHistoryPanel(JPanel offersPanel, JPanel flipsPanel)
	{
		boolean shouldExpandTradeHistory = statsPanel.getExpandedTradeHistories().contains(item.getItemName());
		boolean shouldSelectOffersTab = statsPanel.getItemsWithOffersTabSelected().contains(item.getItemId());
		JPanel tradeHistoryTitlePanel = new JPanel(new BorderLayout());
		tradeHistoryTitlePanel.setBackground(CustomColors.DARK_GRAY);
		tradeHistoryTitlePanel.setBorder(new EmptyBorder(4,0,4,0));

		JPanel mainDisplay = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(mainDisplay);
		MaterialTab offersTab = new MaterialTab("Offers", tabGroup, offersPanel);
		offersTab.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				statsPanel.getItemsWithOffersTabSelected().add(item.getItemId());
			}
		});
		MaterialTab flipsTab = new MaterialTab("Flips", tabGroup, flipsPanel);
		flipsTab.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				statsPanel.getItemsWithOffersTabSelected().remove(item.getItemId());
			}
		});

		tabGroup.setBorder(new EmptyBorder(5, 0, 7, 0));
		tabGroup.addTab(offersTab);
		tabGroup.addTab(flipsTab);

		tabGroup.select(shouldSelectOffersTab? offersTab: flipsTab);
		mainDisplay.setVisible(shouldExpandTradeHistory);
		tabGroup.setVisible(shouldExpandTradeHistory);

		JLabel collapseTradeHistoryIconLabel = new JLabel(shouldExpandTradeHistory ? Icons.OPEN_ICON : Icons.CLOSE_ICON);
		JLabel tradeHistoryTitleLabel = new JLabel("View Trade History", SwingConstants.CENTER);
		tradeHistoryTitleLabel.setFont(new Font("Whitney", Font.ITALIC, 10));
		tradeHistoryTitlePanel.add(tradeHistoryTitleLabel, BorderLayout.CENTER);
		tradeHistoryTitlePanel.add(collapseTradeHistoryIconLabel, BorderLayout.EAST);
		tradeHistoryTitlePanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (e.getButton() == MouseEvent.BUTTON1)
				{
					if (tabGroup.isVisible())
					{
						tabGroup.setVisible(false);
						mainDisplay.setVisible(false);
						collapseTradeHistoryIconLabel.setIcon(Icons.CLOSE_ICON);
						statsPanel.getExpandedTradeHistories().remove(item.getItemName());
					}
					else
					{
						tabGroup.setVisible(true);
						mainDisplay.setVisible(true);
						collapseTradeHistoryIconLabel.setIcon(Icons.OPEN_ICON);
						statsPanel.getExpandedTradeHistories().add(item.getItemName());
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				tradeHistoryTitlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				tradeHistoryTitlePanel.setBackground(CustomColors.DARK_GRAY);
			}
		});


		JPanel tradeHistoryBody = new JPanel(new BorderLayout());
		tradeHistoryBody.add(tabGroup, BorderLayout.NORTH);
		tradeHistoryBody.add(mainDisplay, BorderLayout.CENTER);
		tradeHistoryBody.setBackground(CustomColors.DARK_GRAY);

		JPanel tradeHistoryPanel = new JPanel(new BorderLayout());
		tradeHistoryPanel.add(tradeHistoryTitlePanel, BorderLayout.NORTH);
		tradeHistoryPanel.add(tradeHistoryBody, BorderLayout.CENTER);

		return tradeHistoryPanel;
	}

    /**
     * Creates icon panel that contains the item image and the delete icon which shows when
     * you hover over the item image.
     */
	private JPanel createIconPanel(ItemManager itemManager)
	{
		JLabel deleteLabel = new JLabel(Icons.DELETE_ICON);
		deleteLabel.setPreferredSize(new Dimension(24, 24));
		deleteLabel.setVisible(false);

		AsyncBufferedImage itemImage = itemManager.getImage(item.getItemId());
		JLabel itemLabel = new JLabel();
		Runnable resize = () ->
		{
			BufferedImage subIcon = itemImage.getSubimage(0, 0, 32, 32);
			ImageIcon itemIcon = new ImageIcon(subIcon.getScaledInstance(24, 24, Image.SCALE_SMOOTH));
			itemLabel.setIcon(itemIcon);
		};
		itemImage.onLoaded(resize);
		resize.run();

		itemIconTitlePanel.add(itemLabel, BorderLayout.WEST);
		itemIconTitlePanel.add(deleteLabel, BorderLayout.EAST);
		itemIconTitlePanel.setBackground(CustomColors.DARK_GRAY);
		itemIconTitlePanel.setBorder(new EmptyBorder(5, 2, 0, 5));
		itemIconTitlePanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (plugin.getAccountCurrentlyViewed().equals(FlippingPlugin.ACCOUNT_WIDE)) {
					JOptionPane.showMessageDialog(null, "You cannot delete offers in the Accountwide view");
					return;
				}
				int result = JOptionPane.showOptionDialog(itemIconTitlePanel, "Are you sure you want to delete this item's offers from this time interval?",
					"Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
					null, new String[] {"Yes", "No"}, "No");

				if (result == JOptionPane.YES_OPTION)
				{
					deletePanel();
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				itemLabel.setVisible(false);
				deleteLabel.setVisible(true);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				itemLabel.setVisible(true);
				deleteLabel.setVisible(false);
			}
		});

		return itemIconTitlePanel;
	}

	private JPanel createNameAndProfitPanel()
	{
		JPanel nameAndProfitPanel = new JPanel(new BorderLayout());
		nameAndProfitPanel.setBackground(CustomColors.DARK_GRAY);
		JLabel itemNameLabel = new JLabel(item.getItemName());
		nameAndProfitPanel.add(itemNameLabel, BorderLayout.NORTH);
		nameAndProfitPanel.add(itemProfitAndQuantityLabel, BorderLayout.SOUTH);
		nameAndProfitPanel.setPreferredSize(new Dimension(0, 0));
		return nameAndProfitPanel;
	}

	private JLabel createCollapseIcon()
	{
		JLabel collapseIconLabel = new JLabel();
		collapseIconLabel.setIcon(statsPanel.getExpandedItems().contains(item.getItemName()) ? Icons.OPEN_ICON : Icons.CLOSE_ICON);
		collapseIconLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
		return collapseIconLabel;
	}

	public void updateLabels(List<OfferEvent> offers, List<OfferEvent> adjustedOffers)
	{
        quantityFlipped.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        avgBuyPriceValLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        avgSellPriceValLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        quantityBoughtLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        quantitySoldLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		long totalItemsBought = 0;
		long totalItemsSold = 0;
		for (OfferEvent offer : offers)
		{
			if (offer.isBuy())
			{
				totalItemsBought += offer.getCurrentQuantityInTrade();
			}
			else
			{
				totalItemsSold += offer.getCurrentQuantityInTrade();
			}
		}

		int itemCountFlipped = FlippingItem.countFlipQuantity(adjustedOffers);
		long revenueFromFlippedItems = FlippingItem.getValueOfMatchedOffers(adjustedOffers, false);
		long expenseFromFlippedItems = FlippingItem.getValueOfMatchedOffers(adjustedOffers, true);
		long totalRevenue = FlippingItem.getTotalRevenueOrExpense(offers, false);
		long totalExpense = FlippingItem.getTotalRevenueOrExpense(offers, true);
		long profit = revenueFromFlippedItems - expenseFromFlippedItems;

		updateTitleLabels(profit, itemCountFlipped);
		updateFlippingLabels(expenseFromFlippedItems, revenueFromFlippedItems, itemCountFlipped);
		updateGeneralLabels(totalRevenue, totalExpense, totalItemsBought, totalItemsSold);
		updateTimeLabels();
	}

	/**
	 * Updates the labels on the title panel. This includes the profit label which shows how much profit you made
	 * from flipping that item and the number of times you flipped that item.
	 */
	private void updateTitleLabels(long profitFromFlips, long numItemsFlipped)
	{
		String totalProfitString = (profitFromFlips >= 0? "+": "") + UIUtilities.quantityToRSDecimalStack(profitFromFlips, true) + " gp";
		totalProfitString += " (x " + QuantityFormatter.formatNumber(numItemsFlipped) + ")";

		itemProfitAndQuantityLabel.setText(totalProfitString);
		itemProfitAndQuantityLabel.setForeground((profitFromFlips >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
		itemProfitAndQuantityLabel.setBorder(new EmptyBorder(0, 0, 2, 0));
		itemProfitAndQuantityLabel.setFont(FontManager.getRunescapeSmallFont());
	}

	private void updateFlippingLabels(long flippingExpense, long flippingRevenue, int itemsFlipped) {
		long profitFromFlips = flippingRevenue - flippingExpense;
		totalProfitValLabel.setText(UIUtilities.quantityToRSDecimalStack(profitFromFlips, true) + " gp");
		totalProfitValLabel.setForeground((profitFromFlips >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
		totalProfitValLabel.setToolTipText(QuantityFormatter.formatNumber(profitFromFlips) + " gp");

		String profitEach = UIUtilities.quantityToRSDecimalStack(itemsFlipped > 0 ? (profitFromFlips / itemsFlipped) : 0, true) + " gp/ea";
		profitEachValLabel.setText(profitEach);
		profitEachValLabel.setForeground((profitFromFlips >= 0) ? ColorScheme.GRAND_EXCHANGE_PRICE : CustomColors.OUTDATED_COLOR);
		profitEachValLabel.setToolTipText(QuantityFormatter.formatNumber(itemsFlipped > 0 ? profitFromFlips / itemsFlipped : 0) + " gp/ea");

		quantityFlipped.setText(QuantityFormatter.formatNumber(itemsFlipped) + " Items");

		float roi = (float) flippingExpense >0? (float) profitFromFlips / flippingExpense * 100: 0;

		roiValLabel.setText(String.format("%.2f", roi) + "%");
		roiValLabel.setForeground(UIUtilities.gradiatePercentage(roi, plugin.getConfig().roiGradientMax()));
		roiValLabel.setToolTipText("<html>Return on investment:<br>Percentage of profit relative to gp invested</html>");
	}

	private void updateGeneralLabels(long totalRevenue, long totalExpense, long numBuys, long numSells) {
		avgBuyPriceValLabel.setText(QuantityFormatter.formatNumber((int) numBuys > 0? (totalExpense / numBuys) : 0) + " gp");
		avgSellPriceValLabel.setText(QuantityFormatter.formatNumber((int) numSells > 0? (totalRevenue / numSells) : 0) + " gp");

		quantityBoughtLabel.setText("" + numBuys);
		quantitySoldLabel.setText("" + numSells);
	}

	public void updateTimeLabels()
	{
		flipPanels.forEach(FlipPanel::updateTitleAndTimeDisplay);
		offerPanels.forEach(OfferPanel::updateTimeDisplay);
	}

	private void deletePanel()
	{
		statsPanel.deleteItemPanel(this);
	}
}
package com.flippingutilities.ui.recipeflips;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.MasterPanel;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import com.flippingutilities.utilities.Recipe;
import lombok.Setter;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.util.AsyncBufferedImage;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * This is the panel that shows the available recipes when you click to create a recipe flip from an offer.
 */
public class RecipeFlipCreationPanel extends JPanel {
    static boolean offerSelectionPanelOpen = false;
    FlippingPlugin plugin;
    OfferEvent sourceOffer;
    @Setter
    JDialog modal;

    public RecipeFlipCreationPanel(FlippingPlugin plugin, OfferEvent sourceOffer) {
        this.plugin = plugin;
        this.sourceOffer = sourceOffer;
        List<Recipe> recipes = plugin.getApplicableRecipes(sourceOffer.getItemId(), sourceOffer.isBuy());
        recipes.sort(Comparator.comparing(r -> r.getIds().size()));
        Collections.reverse(recipes);

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(10,10,10,10));

        add(createTitlePanel(recipes), BorderLayout.NORTH);
        add(createRecipeScrollPane(recipes), BorderLayout.CENTER);

    }

    private JScrollPane createRecipeScrollPane(List<Recipe> recipes) {
        JPanel recipePanelContainer = new JPanel(new DynamicGridLayout(recipes.size(), 1,0,3));
        recipes.forEach(r -> {
            recipePanelContainer.add(createRecipePanel(r));
        });

        JPanel wrapper = new JPanel(new BorderLayout());
        wrapper.setBackground(Color.BLACK);
        wrapper.add(recipePanelContainer, BorderLayout.NORTH);

        JScrollPane scrollPane = new JScrollPane(wrapper);
        scrollPane.setBackground(Color.BLACK);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setPreferredSize(new Dimension(45 * (recipes.get(0).getIds().size() + 1), Math.min(500, 75 * recipes.size())));
        return scrollPane;
    }

    private JPanel createRecipePanel(Recipe recipe) {
        JPanel recipePanel = new JPanel(new BorderLayout());
        recipePanel.setBorder(new EmptyBorder(5,0,8,0));
        recipePanel.setBackground(Color.BLACK);

        recipePanel.setBorder(new CompoundBorder(
            new MatteBorder(1, 1, 1, 1, CustomColors.DARK_GRAY),
            new EmptyBorder(5,0,8,0)));

        JPanel recipeIconPanel = new JPanel();
        recipeIconPanel.setBackground(Color.BLACK);

        recipePanel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (offerSelectionPanelOpen) {
                    JOptionPane.showMessageDialog(null, "You must close the other recipe creation menu before opening another one");
                    return;
                }
                modal.dispose();
                MasterPanel m = plugin.getMasterPanel();
                RecipeOfferSelectionPanel recipeOfferSelectionPanel = new RecipeOfferSelectionPanel(plugin, sourceOffer, recipe);
                offerSelectionPanelOpen = true;
                JDialog recipeOfferSelectionModal = UIUtilities.createModalFromPanel(m, recipeOfferSelectionPanel);
                recipeOfferSelectionModal.addComponentListener(new ComponentAdapter() {
                    @Override
                    public void componentHidden(ComponentEvent e) {
                        recipeOfferSelectionModal.dispose();
                        offerSelectionPanelOpen = false;
                    }
                });
                recipeOfferSelectionModal.pack();
                recipeOfferSelectionModal.setLocation(
                    Math.max(20, m.getLocationOnScreen().x - recipeOfferSelectionModal.getWidth() - 10),
                    Math.max(m.getLocationOnScreen().y - recipeOfferSelectionModal.getHeight()/2, 0) + 100);
                recipeOfferSelectionModal.setVisible(true);

                revalidate();
                repaint();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                recipePanel.setBackground(Color.DARK_GRAY);
                recipeIconPanel.setBackground(Color.DARK_GRAY);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                recipePanel.setBackground(Color.BLACK);
                recipeIconPanel.setBackground(Color.BLACK);
            }
        });

        recipe.getInputIds().forEach( id -> {
            AsyncBufferedImage itemImage = plugin.getItemManager().getImage(id);
            JLabel iconLabel = new JLabel();
            itemImage.addTo(iconLabel);
            recipeIconPanel.add(iconLabel);
        });

        recipeIconPanel.add(new JLabel(Icons.RIGHT_ARROW_LARGE));

        recipe.getOutputIds().forEach( id -> {
            AsyncBufferedImage itemImage = plugin.getItemManager().getImage(id);
            JLabel iconLabel = new JLabel();
            itemImage.addTo(iconLabel);
            recipeIconPanel.add(iconLabel);
        });

        JLabel recipeNameLabel = new JLabel(recipe.getName(), SwingConstants.CENTER);
        recipeNameLabel.setFont(new Font("Whitney", Font.PLAIN, 12));
        recipeNameLabel.setBorder(new EmptyBorder(3,0,0,0));

        recipePanel.add(recipeIconPanel, BorderLayout.CENTER);
        recipePanel.add(recipeNameLabel, BorderLayout.SOUTH);

        return recipePanel;
    }

    private JPanel createTitlePanel(List<Recipe> recipes) {
        JLabel titleLabel = new JLabel("Select a Recipe", SwingConstants.CENTER);
        titleLabel.setFont(new Font("Whitney", Font.PLAIN, 16));

        JLabel numRecipesLabel = new JLabel(
            String.format(
                "Showing %d %s for %s %s",
                recipes.size(),
                UIUtilities.maybePluralize("recipe", recipes.size()),
                sourceOffer.isBuy()? "buying":"selling",
                sourceOffer.getItemName()
            ),
            SwingConstants.CENTER);
        numRecipesLabel.setFont(new Font("Whitney", Font.ITALIC, 10));

        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBorder(new EmptyBorder(0,0,10,0));
        titlePanel.add(titleLabel, BorderLayout.CENTER);
        titlePanel.add(numRecipesLabel, BorderLayout.SOUTH);

        return titlePanel;
    }
}

package com.flippingutilities.ui.recipeflips;

import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;

/**
 * Holds the item icon and multiplier text label along with the target value label
 */
public class RecipeItemHeaderPanel extends JPanel {

    JLabel targetValueLabel;
    JLabel itemIconAndConsumedAmountLabel;

    public RecipeItemHeaderPanel(AsyncBufferedImage itemImage) {
        setBackground(Color.BLACK);

        itemIconAndConsumedAmountLabel = new JLabel();
        itemIconAndConsumedAmountLabel.setHorizontalTextPosition(SwingConstants.RIGHT);
        itemIconAndConsumedAmountLabel.setFont(new Font("Whitney", Font.PLAIN, 20));
        itemIconAndConsumedAmountLabel.setText("x0");
        itemImage.addTo(itemIconAndConsumedAmountLabel);

        targetValueLabel = new JLabel("/0");
        targetValueLabel.setFont(new Font("Whitney", Font.PLAIN, 12));

        add(itemIconAndConsumedAmountLabel);
        add(targetValueLabel);
    }

    public void setConsumedAmountDisplay(int amount) {
        itemIconAndConsumedAmountLabel.setText("x" + QuantityFormatter.formatNumber(amount));
    }

    public void setTargetValueDisplay(int targetValue) {
        targetValueLabel.setText("/" + QuantityFormatter.formatNumber(targetValue));
    }

    public void setConsumedAmountDisplayColor(Color color) {
        itemIconAndConsumedAmountLabel.setForeground(color);
    }
}

package com.flippingutilities.ui.recipeflips;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.RecipeFlip;
import com.flippingutilities.model.FlippingItem;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.statistics.items.OfferPanel;
import com.flippingutilities.ui.uiutilities.CustomColors;
import com.flippingutilities.ui.uiutilities.Icons;
import com.flippingutilities.model.PartialOffer;
import com.flippingutilities.ui.uiutilities.UIUtilities;
import com.flippingutilities.utilities.Recipe;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.ChangeEvent;
import java.awt.*;
import java.time.Instant;
import java.util.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;

/**
 * The panel the user interacts with when creating a recipe flip
 */
@Slf4j
public class RecipeOfferSelectionPanel extends JPanel {
    FlippingPlugin plugin;
    //the offer the user clicked on to bring up this panel.
    OfferEvent sourceOffer;
    //used to track which offers a user has selected to be in the recipe flip and how much of the
    //offer is contributed.
    //This is a map of item id to a map of offer id to selected offer.
    Map<Integer, Map<String, PartialOffer>> selectedOffers;
    JButton finishButton = new JButton("Combine!");
    JLabel profitNumberLabel = new JLabel("+0");
    JSpinner coinOffset = new JSpinner();
    Recipe recipe;
    Map<Integer, RecipeItemHeaderPanel> idToHeader;
    List<JSpinner> numberPickers = new ArrayList<>();

    public RecipeOfferSelectionPanel(FlippingPlugin plugin, OfferEvent sourceOffer, Recipe recipe) {
        this.plugin = plugin;
        this.sourceOffer = sourceOffer;
        this.recipe = recipe;

        Map<Integer, Optional<FlippingItem>> itemsInRecipe = plugin.getItemsInRecipe(recipe);

        selectedOffers = initSelectedOffers(itemsInRecipe);
        idToHeader = createRecipeItemHeaderPanel(selectedOffers);

        setBackground(Color.BLACK);
        setLayout(new BorderLayout());

        //All the partial offers for every item in the recipe in this time range
        Map<Integer, List<PartialOffer>> itemIdToPartialOffers = createItemIdToPartialOffers(
                itemsInRecipe,
                plugin.getStatPanel().getStartOfInterval());
        add(createTitle(), BorderLayout.NORTH);
        add(createBody(itemIdToPartialOffers), BorderLayout.CENTER);
        add(createBottomPanel(itemIdToPartialOffers), BorderLayout.SOUTH);

        setBorder(new EmptyBorder(8, 8, 8, 8));

    }

    private Map<Integer, Map<String, PartialOffer>> initSelectedOffers(Map<Integer, Optional<FlippingItem>> itemsInRecipe) {
        selectedOffers = new HashMap<>();
        itemsInRecipe.keySet().forEach(id -> {
            selectedOffers.put(id, new HashMap<>());
        });
        return selectedOffers;
    }

    /**
     * The body holds the item icons and multiplier labels in the first row and the offer panels with the number
     * pickers in the second row.
     */
    private JPanel createBody(
            Map<Integer, List<PartialOffer>> itemIdToPartialOffers
    ) {
        Set<Integer> allIds = selectedOffers.keySet();

        JPanel bodyPanel = new JPanel();
        bodyPanel.setBackground(Color.BLACK);
        bodyPanel.setLayout(new DynamicGridLayout(2, allIds.size() + 1, 10, 5));

        addHeaderPanelRow(bodyPanel);
        addOfferPanelRow(
                bodyPanel,
                itemIdToPartialOffers
        );

        return bodyPanel;
    }

    /**
     * Creates the offer panels with the number picker for all the offers passed in
     */
    private JComponent createOffersPanel(
            int itemId,
            List<PartialOffer> partialOffers,
            RecipeItemHeaderPanel headerPanel,
            int targetSelectionValue) {
        JPanel offersPanel = new JPanel();
        offersPanel.setBackground(Color.BLACK);

        if (partialOffers.size() > 0) {
            return createOffersScrollPane(partialOffers, headerPanel, targetSelectionValue, offersPanel);
        }

        if (itemId == 995) {
            JLabel coinsLabel = new JLabel("coins automatically accounted for");
            coinsLabel.setForeground(Color.GREEN);
            offersPanel.add(coinsLabel);
        }
        else {
            String type = sourceOffer.isBuy() ? "sell" : "buy";
            JLabel noTradesLabel = new JLabel(String.format("No recorded %s for this item", type));
            noTradesLabel.setForeground(Color.RED);
            offersPanel.add(noTradesLabel);
        }

        headerPanel.setForeground(CustomColors.TOMATO);
        return offersPanel;
    }

    /**
     * Creates the scroll pane which contains the offer panels with the number pickers.
     * @param partialOffers the item's offers
     * @param headerPanel the panel containing the item icon, consumed amount, and target value.
     * @param targetSelectionValue the initial amount to select
     * @param offersPanel the panel the offer panels are placed on
     */
    private JScrollPane createOffersScrollPane(
        List<PartialOffer> partialOffers,
        RecipeItemHeaderPanel headerPanel,
        int targetSelectionValue,
        JPanel offersPanel
    ) {
        offersPanel.setLayout(new BoxLayout(offersPanel, BoxLayout.Y_AXIS));

        JPanel wrapper = new JPanel(new BorderLayout());
        wrapper.setBackground(Color.BLACK);
        wrapper.add(offersPanel, BorderLayout.NORTH);

        JScrollPane scrollPane = new JScrollPane(wrapper);
        scrollPane.setBackground(Color.BLACK);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(2, 0));
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        int maxHackySize = 0;
        for (int i = 0; i < partialOffers.size(); i++) {
            PartialOffer partialOffer = partialOffers.get(i);
            OfferPanel offerPanel = new OfferPanel(plugin, null, partialOffer.getOffer(), true);
            int amountToSelect;
            int actualQuantityInOffer = partialOffer.getOffer().getCurrentQuantityInTrade() - partialOffer.amountConsumed;
            amountToSelect = Math.min(actualQuantityInOffer, targetSelectionValue);
            targetSelectionValue -= amountToSelect;

            int numPickerSize = 40 + (String.valueOf(actualQuantityInOffer).length() * 10);
            maxHackySize = Math.max(maxHackySize, offerPanel.getHackySize() + numPickerSize);

            JPanel offerPanelWithPicker = createOfferPanelWithPicker(
                offerPanel,
                headerPanel,
                partialOffer,
                amountToSelect
            );
            offersPanel.add(offerPanelWithPicker);

            if (i < Math.min(partialOffers.size(), 10) - 1) {
                offersPanel.add(Box.createVerticalStrut(4));
            }

            //Prevents scoll pane from being unnecessarily large if there are few panels
            int scrollPaneHeight = Math.min(350, (partialOffers.size() * 65) + 40);
            scrollPane.setPreferredSize(new Dimension(maxHackySize, scrollPaneHeight));

            setDisplaysAndStateBasedOnSelection(amountToSelect, partialOffer.getOffer(), offerPanel, headerPanel);
        }

        return scrollPane;
    }

    /**
     * Creates the offer panel with the number selector used to select how much of
     * an offer you want to consume
     */
    private JPanel createOfferPanelWithPicker(
            OfferPanel offerPanel,
            RecipeItemHeaderPanel headerPanel,
            PartialOffer partialOffer,
            int amountToSelect) {
        JPanel offerPanelWithPicker = new JPanel(new BorderLayout());
        offerPanelWithPicker.setBackground(Color.BLACK);
        JSpinner numberPicker = new JSpinner(
                new SpinnerNumberModel(
                        amountToSelect,
                        0, //min val
                        partialOffer.getOffer().getCurrentQuantityInTrade() - partialOffer.amountConsumed, //max val
                        1));
        numberPicker.setForeground(CustomColors.CHEESE);
        numberPicker.setSize(new Dimension(0, 70));
        numberPicker.addChangeListener(e -> {
            this.numberPickerHandler(e, partialOffer.getOffer(), offerPanel, headerPanel);
        });
        numberPickers.add(numberPicker);

        offerPanelWithPicker.add(numberPicker, BorderLayout.WEST);
        offerPanelWithPicker.add(offerPanel, BorderLayout.CENTER);
        if (partialOffer.amountConsumed > 0) {
            boolean completelyConsumed = partialOffer.amountConsumed == partialOffer.getOffer().getCurrentQuantityInTrade();
            JPanel alreadyUsedPanel = new JPanel();
            alreadyUsedPanel.setBackground(Color.BLACK);

            JLabel alreadyUsedLabel = new JLabel(
                    String.format("<html><body width='150' style='text-align:center;'> " +
                                    "%d/%d items in this offer already used in other recipe flips</body></html>",
                            partialOffer.amountConsumed,
                            partialOffer.getOffer().getCurrentQuantityInTrade())
                    , SwingConstants.CENTER);
            alreadyUsedLabel.setFont(new Font("Whitney", Font.PLAIN, 10));
            alreadyUsedLabel.setForeground(completelyConsumed? CustomColors.TOMATO.darker():CustomColors.CHEESE.darker());
            alreadyUsedPanel.add(alreadyUsedLabel);

            offerPanelWithPicker.add(alreadyUsedPanel, BorderLayout.SOUTH);
        }
        return offerPanelWithPicker;

    }

    /**
     * Creates all the item icons and text for the first row in the dynamic grid layout
     *
     * @return a mapping of item id to a label which contains the item icon and consumed amount text, and
     * target consumption text.
     */
    private Map<Integer, RecipeItemHeaderPanel> createRecipeItemHeaderPanel(Map<Integer, Map<String, PartialOffer>> selectedOffers) {
        Set<Integer> allIds = selectedOffers.keySet();
        Map<Integer, RecipeItemHeaderPanel> idToIconLabel = new HashMap<>();
        allIds.forEach(id -> {
            AsyncBufferedImage itemImage = plugin.getItemManager().getImage(id);
            idToIconLabel.put(id, new RecipeItemHeaderPanel(itemImage));
        });

        return idToIconLabel;
    }

    /**
     * Adds the labels containing the item icon and selected amount amount to the body panel
     *
     * @param bodyPanel the panel which the item labels are being added to
     */
    private void addHeaderPanelRow(JPanel bodyPanel) {
        recipe.getInputIds().forEach(itemId -> {
            JPanel headerPanel = idToHeader.get(itemId);
            bodyPanel.add(headerPanel);
        });

        bodyPanel.add(new JLabel(Icons.RIGHT_ARROW_LARGE));

        recipe.getOutputIds().forEach(itemId -> {
            JPanel headerPanel = idToHeader.get(itemId);
            bodyPanel.add(headerPanel);
        });
    }

    /**
     * @param itemIdToItem all the items in the recipe
     * @return a map of ALL the items in the recipe and the partial offers that should be rendered. We don't
     * simply return OfferEvents because we want to know if any of the OfferEvents have some of their quantity
     * already consumed by other recipe flips for these items. If that is the case, we want to render them as
     * such.
     */
    private Map<Integer, List<PartialOffer>> createItemIdToPartialOffers(
            Map<Integer, Optional<FlippingItem>> itemIdToItem,
            Instant startOfInterval
    ) {
        Map<Integer, List<PartialOffer>> itemIdToPartialOffers = new HashMap<>();

        itemIdToItem.forEach((itemId, item) -> {
            List<PartialOffer> partialOffers = item.map(fitem -> {
                Map<String, PartialOffer> offerIdToPartialOffer = plugin.getOfferIdToPartialOffer(itemId);
                List<OfferEvent> offers = itemId == sourceOffer.getItemId()? new ArrayList<>(Arrays.asList(sourceOffer)): fitem.getIntervalHistory(startOfInterval);
                Collections.reverse(offers);

                return offers.stream().filter(o -> o.isBuy() == recipe.isInput(itemId) && o.isComplete()).
                        map(o -> {
                            if (offerIdToPartialOffer.containsKey(o.getUuid())) {
                                return offerIdToPartialOffer.get(o.getUuid());
                            }
                            return new PartialOffer(o, 0);
                        }).
                        collect(Collectors.toList());
            }).orElse(new ArrayList<>());
            itemIdToPartialOffers.put(itemId, partialOffers);
        });

        return itemIdToPartialOffers;
    }

    /**
     * Adds the second row to the body panel. The second row contains all the offer panels
     *
     * @param bodyPanel                   the panel the offer panels are being added to
     *                                    a reference to this label in this method so we can change the multiplier text
     * @param itemIdToPartialOffers              a map of all the items in the recipe and the offers that should be rendered
     */
    private void addOfferPanelRow(JPanel bodyPanel,
                                  Map<Integer, List<PartialOffer>> itemIdToPartialOffers) {
        Map<Integer, Integer> targetValues = plugin.getTargetValuesForMaxRecipeCount(recipe, itemIdToPartialOffers, true);

        recipe.getInputIds().forEach(id -> addOfferPanel(bodyPanel, id, itemIdToPartialOffers, targetValues));

        //empty panel occupies the space under the arrow
        JPanel emptyPanel = new JPanel();
        emptyPanel.setBackground(Color.BLACK);
        bodyPanel.add(emptyPanel);

        recipe.getOutputIds().forEach(id -> addOfferPanel(bodyPanel, id, itemIdToPartialOffers, targetValues));

        handleItemsHittingTargetConsumptionValues();
    }

    private void addOfferPanel(
        JPanel bodyPanel,
        int itemId,
        Map<Integer, List<PartialOffer>> itemIdToPartialOffers,
        Map<Integer, Integer> targetValues
    ) {
            int targetValue = targetValues.get(itemId);
            List<PartialOffer> partialOffers = itemIdToPartialOffers.get(itemId);
            RecipeItemHeaderPanel recipeItemHeaderPanel = idToHeader.get(itemId);
            recipeItemHeaderPanel.setTargetValueDisplay(targetValue);
            if (itemId == 995) {
                recipeItemHeaderPanel.setConsumedAmountDisplay(targetValue);
            }
            bodyPanel.add(createOffersPanel(itemId, partialOffers, recipeItemHeaderPanel, targetValue));
    }

    /**
     * Handles the what happens when the number picker's value changes.
     */
    private void numberPickerHandler(ChangeEvent e, OfferEvent offer, OfferPanel offerPanel,
                                     RecipeItemHeaderPanel headerPanel) {
        JSpinner numberPicker = (JSpinner) e.getSource();
        int numberPickerValue = (int) numberPicker.getValue();

        setDisplaysAndStateBasedOnSelection(numberPickerValue, offer, offerPanel, headerPanel);
        handleItemsHittingTargetConsumptionValues();
    }

    /**
     * Sets the consumed amount display and the selected offers based on the the number picker value.
     * This is used in the number picker handler method too.
     */
    private void setDisplaysAndStateBasedOnSelection(int numberPickerValue, OfferEvent offer, OfferPanel offerPanel,
                                                     RecipeItemHeaderPanel headerPanel) {
        int itemId = offer.getItemId();

        offerPanel.setSelected(numberPickerValue > 0);
        Map<String, PartialOffer> selectedOffersForThisItem = selectedOffers.get(itemId);

        //if the user has already selected this offer, just make the amount consumed for that offer what they
        //just selected
        if (selectedOffersForThisItem.containsKey(offer.getUuid())) {
            selectedOffersForThisItem.get(offer.getUuid()).amountConsumed = numberPickerValue;
        } else {
            selectedOffersForThisItem.put(offer.getUuid(), new PartialOffer(offer, numberPickerValue));
        }

        int totalConsumedAmount = selectedOffersForThisItem.values().stream().mapToInt(o -> o.amountConsumed).sum();
        headerPanel.setConsumedAmountDisplay(totalConsumedAmount);
    }

    /**
     * Enables/disables the finish button based on all items have hit their targets along with adjusting the
     * target value display for all the items.
     */
    private void handleItemsHittingTargetConsumptionValues() {
        //if the parent quantity in the recipe is not 1, gonna have to do the modding and stuff
        Map<Integer, List<PartialOffer>> idToPartialOffersSelected = selectedOffers.entrySet().stream().
            map(e -> new AbstractMap.SimpleEntry<>(e.getKey(), new ArrayList<>(e.getValue().values()))).
            collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

        Map<Integer, Integer> idToTargetValues = plugin.getTargetValuesForMaxRecipeCount(recipe, idToPartialOffersSelected, false);

        AtomicBoolean allMatchTargetValues = new AtomicBoolean(true);
        selectedOffers.forEach((itemId, partialOfferMap) -> {
            RecipeItemHeaderPanel itemHeaderPanel = idToHeader.get(itemId);
            int amountConsumed = partialOfferMap.values().stream().mapToInt(o -> o.amountConsumed).sum();
            int targetConsumedAmount = idToTargetValues.get(itemId);

            itemHeaderPanel.setTargetValueDisplay(targetConsumedAmount);
            if (itemId == 995) {
                itemHeaderPanel.setConsumedAmountDisplay(targetConsumedAmount);
            }

            if ((amountConsumed == targetConsumedAmount && targetConsumedAmount != 0) || itemId == 995) {
                itemHeaderPanel.setConsumedAmountDisplayColor(ColorScheme.GRAND_EXCHANGE_PRICE);
            } else {
                allMatchTargetValues.set(false);
                itemHeaderPanel.setConsumedAmountDisplayColor(CustomColors.CHEESE);
            }
        });

        if (allMatchTargetValues.get()) {
            finishButton.setEnabled(true);
            finishButton.setForeground(Color.GREEN);
            long profit = Math.round(calculateProfit()) - (Integer)coinOffset.getValue();
            String prefix = profit < 0 ? "" : "+";
            profitNumberLabel.setText(prefix + QuantityFormatter.formatNumber(profit) + " gp");
            profitNumberLabel.setForeground(profit < 0 ? Color.RED : Color.GREEN);
        }
        else {
            finishButton.setEnabled(false);
            finishButton.setForeground(Color.GRAY);
            profitNumberLabel.setText("+0");
            profitNumberLabel.setForeground(CustomColors.CHEESE);
        }
    }

    /**
     * The bottom panel holds the "Combine!" button, the profit label, and the text that
     * shows when a recipe flip can't be created due to insufficient items.
     */
    private JPanel createBottomPanel(
            Map<Integer, List<PartialOffer>> itemIdToPartialOffers) {
        JPanel bottomPanel = new JPanel();
        bottomPanel.setBorder(new EmptyBorder(5, 0, 0, 0));
        bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
        bottomPanel.setBackground(Color.BLACK);

        // Add the option of GP modifier for special expenses
        JLabel coinOffsetLabel = new JLabel("Unaccounted for GP used in recipe: ");
        coinOffsetLabel.setBackground(Color.BLACK);
        coinOffsetLabel.setFont(new Font("Whitney", Font.PLAIN, 14));
        coinOffsetLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        coinOffsetLabel.setBorder(new EmptyBorder(10,30,5,60));
        coinOffset.setFont(new Font("Whitney", Font.PLAIN, 14));
        coinOffset.setAlignmentX(Component.CENTER_ALIGNMENT);
        coinOffset.setBorder(new EmptyBorder(10,30,5,60));
        coinOffset.addChangeListener(e -> {
            handleItemsHittingTargetConsumptionValues();
        });
        JPanel coinOffsetPanel = new JPanel();
        coinOffsetPanel.setBackground(Color.BLACK);
        coinOffsetPanel.add(coinOffsetLabel);
        coinOffsetPanel.add(coinOffset);
        bottomPanel.add(coinOffsetPanel);

        int itemsThatCanMakeZeroRecipes = (int) plugin.getItemIdToMaxRecipesThatCanBeMade(recipe, itemIdToPartialOffers, true).entrySet().stream().
                filter(e -> e.getValue() == 0).count();

        if (itemsThatCanMakeZeroRecipes > 0) {
            JLabel missingItemsLabel = new JLabel("No recipe flip can be made as some items don't have enough" +
                    " trades", SwingConstants.CENTER);
            missingItemsLabel.setForeground(CustomColors.TOMATO);
            missingItemsLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
            missingItemsLabel.setFont(new Font("Whitney", Font.PLAIN, 16));
            missingItemsLabel.setBorder(new EmptyBorder(0,0,10,0));
            bottomPanel.add(missingItemsLabel);
        }

        profitNumberLabel.setFont(new Font("Whitney", Font.PLAIN, 16));
        profitNumberLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
        profitNumberLabel.setBorder(new EmptyBorder(10,0,5,0));

        finishButton.setBorder(new EmptyBorder(10, 10, 10, 10));
        finishButton.setAlignmentX(Component.CENTER_ALIGNMENT);
        finishButton.setFont(new Font("Whitney", Font.PLAIN, 16));
        finishButton.setFocusPainted(false);
        finishButton.addActionListener(e -> {
            try {
                coinOffset.commitEdit();
            } catch ( java.text.ParseException ex ) { log.info("Failed to parse coin offset", ex); }
            int coinOffsetValue = (Integer) coinOffset.getValue();
            RecipeFlip recipeFlip = new RecipeFlip(recipe, selectedOffers, getCoinsCost() + coinOffsetValue);
            plugin.addRecipeFlip(recipeFlip, recipe);
            plugin.getStatPanel().rebuildRecipesDisplay(plugin.viewRecipeFlipGroupsForCurrentView());
            plugin.getStatPanel().rebuildItemsDisplay(plugin.viewItemsForCurrentView());

            numberPickers.forEach(picker -> picker.setEnabled(false));

            bottomPanel.removeAll();

            JLabel successLabel = new JLabel("Success! This flip will now show up in the Recipes tab", SwingConstants.CENTER);
            successLabel.setBorder(new EmptyBorder(0, 0, 10, 0));
            successLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
            successLabel.setFont(new Font("Whitney", Font.PLAIN, 16));
            successLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

            bottomPanel.add(successLabel);
            revalidate();
            repaint();
        });

        bottomPanel.add(profitNumberLabel);
        bottomPanel.add(finishButton);

        return bottomPanel;
    }

    private JPanel createTitle() {
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBorder(new EmptyBorder(5, 0, 25, 0));
        titlePanel.setBackground(Color.BLACK);

        JLabel title = new JLabel(recipe.getName(), JLabel.CENTER);
        title.setBorder(new EmptyBorder(0, 0, 20, 0));
        title.setFont(new Font("Whitney", Font.PLAIN, 20));

        JPanel intervalPanel = new JPanel();
        intervalPanel.setBackground(Color.BLACK);

        String intervalName = plugin.getStatPanel().getStartOfIntervalName();

        JLabel intervalDescLabel = new JLabel("You are looking at offers from the interval: ");
        intervalDescLabel.setFont(new Font("Whitney", Font.PLAIN, 14));

        JLabel intervalNameLabel = new JLabel(intervalName);
        intervalNameLabel.setFont(new Font("Whitney", Font.PLAIN, 16));
        intervalNameLabel.setForeground(CustomColors.CHEESE);
        UIUtilities.makeLabelUnderlined(intervalNameLabel);

        intervalPanel.add(intervalDescLabel);
        intervalPanel.add(intervalNameLabel);

        JLabel desc = new JLabel("Only completed offers show up here", SwingConstants.CENTER);
        desc.setForeground(CustomColors.CHEESE);
        desc.setFont(new Font("Whitney", Font.PLAIN, 12));

        titlePanel.add(title, BorderLayout.NORTH);
        titlePanel.add(intervalPanel, BorderLayout.CENTER);
        titlePanel.add(desc, BorderLayout.SOUTH);

        return titlePanel;
    }

    private long calculateProfit() {
        return RecipeFlip.calculateProfit(selectedOffers) - getCoinsCost();
    }

    private long getCoinsCost() {
        Map<Integer, List<PartialOffer>> idToPartialOffersSelected = selectedOffers.entrySet().stream().
            map(e -> new AbstractMap.SimpleEntry<>(e.getKey(), new ArrayList<>(e.getValue().values()))).
            collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        Map<Integer, Integer> idToTargetValues = plugin.getTargetValuesForMaxRecipeCount(recipe, idToPartialOffersSelected, false);
        if (idToTargetValues.containsKey(995)) {
            return idToTargetValues.get(995);
        }
        return 0;
    }
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities.jobs;

import com.flippingutilities.db.TradePersister;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * Updates the cache in real time as files are changed in the directory being monitored. It monitors the directory
 * where the accounts' data is stored and fires any registered callbacks when it detects a change for an account.
 * The reason it accepts callbacks is so that this class is not tied to any specific component's way of handling a file
 * change. This decoupling allows the cache updater to be used easily by any component that wishes to fire an action
 * when a file for an account is changed.
 */
@Slf4j
public class CacheUpdaterJob
{
	ScheduledExecutorService executor;

	List<Consumer<String>> subscribers = new ArrayList<>();

	boolean isBeingShutdownByClient = false;

	Future realTimeUpdateTask;

	Map<String, Long> lastEvents = new HashMap<>();

	int requiredMinMsSinceLastUpdate = 5;
	int failureCount;
	int failureThreshold = 2;


	public CacheUpdaterJob()
	{
		this.executor = Executors.newSingleThreadScheduledExecutor();
	}

	public void subscribe(Consumer<String> callback)
	{
		subscribers.add(callback);
	}

	public void start()
	{
		realTimeUpdateTask = executor.schedule(this::updateCacheRealTime, 1000, TimeUnit.MILLISECONDS);
	}

	public void stop()
	{
		isBeingShutdownByClient = true;
		realTimeUpdateTask.cancel(true);
	}

	public void updateCacheRealTime()
	{
		try
		{
			log.info("starting cache updator job!");
			WatchService watchService = FileSystems.getDefault().newWatchService();

			Path path = TradePersister.PARENT_DIRECTORY.toPath();

			path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_MODIFY);

			WatchKey key;
			while ((key = watchService.take()) != null)
			{
				for (WatchEvent<?> event : key.pollEvents())
				{
					log.info("change in directory for {} with event: {}", event.context(), event.kind());
					if (!isDuplicateEvent(event.context().toString()))
					{
						log.info("not duplicate event, firing callbacks");
						subscribers.forEach(subscriber -> subscriber.accept(event.context().toString()));
					}
					else
					{
						log.info("duplicate event, not firing callbacks");
					}

				}
				//put the key back in the queue so we can take out more events when they occur
				key.reset();
				failureCount = 0;
			}
		}

		catch (IOException | InterruptedException e)
		{
			if (!isBeingShutdownByClient)
			{
				log.info("exception in updateCacheRealTime, Error = {}", e);
				onUnexpectedError();
			}

			else
			{
				onClientShutdown();
			}
		}

		catch (Exception e)
		{
			log.info("unknown exception in updateCacheRealTime, task is going to stop. Error = {}", e);
		}
	}

	private void onUnexpectedError()
	{
		log.info("Failure number: {} Error not caused by client shutdown", failureCount);
		failureCount++;
		if (failureCount > failureThreshold)
		{
			log.info("number of failures exceeds failure threshold, not scheduling task again");
			return;
		}

		else
		{
			log.info("failure count below threshold, scheduling task again");
			realTimeUpdateTask = executor.schedule(this::updateCacheRealTime, 1000, TimeUnit.MILLISECONDS);
		}
	}

	private void onClientShutdown()
	{
		log.info("shutting down cache updater due to the client shutdown");
	}

	private boolean isDuplicateEvent(String fileName)
	{
		long lastModified = TradePersister.lastModified(fileName);
		if (lastEvents.containsKey(fileName))
		{
			long prevModificationTime = lastEvents.get(fileName);
			long diffSinceLastModification = Math.abs(lastModified - prevModificationTime);
			if (diffSinceLastModification < requiredMinMsSinceLastUpdate)
			{
				return true;
			}
			else
			{
				lastEvents.put(fileName, lastModified);
				return false;
			}
		}
		else
		{
			lastEvents.put(fileName, lastModified);
			return false;
		}
	}
}
package com.flippingutilities.jobs;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.ui.widgets.SlotActivityTimer;
import com.flippingutilities.utilities.SlotState;
import com.flippingutilities.utilities.AccountSlotsUpdate;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.events.GrandExchangeOfferChanged;
import okhttp3.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Consumer;

@Slf4j
public class SlotSenderJob {
    FlippingPlugin plugin;
    ScheduledExecutorService executor;
    OkHttpClient httpClient;
    Future slotStateSenderTask;
    AccountSlotsUpdate previouslySentSlotUpdate;
    List<Consumer<Integer>> subscribers = new ArrayList<>();
    public static int PERIOD = 10; //seconds
    public boolean justLoggedIn = false;

    public SlotSenderJob(FlippingPlugin plugin, OkHttpClient httpClient) {
        this.plugin = plugin;
        this.httpClient = httpClient;
        this.executor = Executors.newSingleThreadScheduledExecutor();
    }

    public void subscribe(Consumer<Integer> subscriber) {
        subscribers.add(subscriber);
    }

    public void start() {
        slotStateSenderTask = executor.scheduleAtFixedRate(this::sendSlots, 10, PERIOD, TimeUnit.SECONDS);
        log.info("started slot sender job");
    }

    public void stop() {
        if (!slotStateSenderTask.isCancelled()) {
            slotStateSenderTask.cancel(true);
            log.info("shut down slot sender job");
        }
    }

    private void sendSlots() {
        if (!plugin.getApiAuthHandler().canCommunicateWithApi(plugin.getCurrentlyLoggedInAccount())) {
            return;
        }

        List<SlotState> currentSlotStates = this.getCurrentSlots();
        AccountSlotsUpdate accountSlotsUpdate = new AccountSlotsUpdate(plugin.getCurrentlyLoggedInAccount(), currentSlotStates);
        if (accountSlotsUpdate.equals(this.previouslySentSlotUpdate) && !justLoggedIn) {
            log.debug("no updates to slots since the last time I sent them, not sending any requests.");
            subscribers.forEach(subscriber -> subscriber.accept(0));
            return;
        }
        justLoggedIn = false;
        plugin.getApiRequestHandler().updateGeSlots(accountSlotsUpdate)
                .whenComplete((response, exception) -> {
                    if (exception != null) {
                        log.debug("could not send slot update successfully", exception);
                        subscribers.forEach(subscriber -> subscriber.accept(2));

                    } else {
                        previouslySentSlotUpdate = accountSlotsUpdate;
                        subscribers.forEach(subscriber -> subscriber.accept(1));
                        log.debug("sent slot update successfully!");

                    }
                });
    }

    /**
     * Gets the current slots by looking at both the history tracked by the plugin (lastOffers in the DataHandler) and
     * the current slots returned by client.getGrandExchangeOffers(). client.getGrandExchangeOffers is always correct.
     * The reason we don't solely rely on it is because it simply tells us the current offers in the ge and is missing
     * additional info such as when the trade for that offer was created. And the reason we can't solely rely on the
     * offers in lastOffers in DataHandler is because it may not always reflect the current state of the slot. For
     * example, if someone collected an offer on mobile and then logged into runelite, the slot is empty, but lastOffers
     * won't reflect that.
     * <p>
     * Whenever the offer in lastOffers reflects the offer actually in the slot, we prefer to use it over the
     * offer in client.getGrandExchangeOffers(). This is because the offer in lastOffers is decorated with additional
     * info such as the time the trade for the offer was created.
     * <p>
     * Whenever the offer in lastOffers does not reflect the offer actually in the slot, we use the offer from
     * client.getGrandExchangeOffers(). However, in this case, the slotState object will have its createdAt field be null
     * as the offer from client.getGrandExchangeOffers() is missing that information.
     */
    private List<SlotState> getCurrentSlots() {
        Map<Integer, OfferEvent> lastOfferEventForEachSlot = plugin.getDataHandler().getAccountData(plugin.getCurrentlyLoggedInAccount()).getLastOffers();
        List<SlotActivityTimer> slotActivityTimers = plugin.getDataHandler().getAccountData(plugin.getCurrentlyLoggedInAccount()).getSlotTimers();
        List<SlotState> slotStates = new ArrayList<>();
        for (int i = 0; i < 8; i++) {
            GrandExchangeOffer grandExchangeOffer = plugin.getClient().getGrandExchangeOffers()[i];
            //the offer event constructed from the true offer retrieved from client.getGrandExchangeOffers()
            OfferEvent trueOfferInSlot = this.getOfferEventConstructedFromClient(i);

            if (lastOfferEventForEachSlot.containsKey(i)) {
                OfferEvent lastOfferEventForSlotTrackedByPlugin = lastOfferEventForEachSlot.get(i);
                lastOfferEventForSlotTrackedByPlugin.setListedPrice(grandExchangeOffer.getPrice());
                lastOfferEventForSlotTrackedByPlugin.setSpent(grandExchangeOffer.getSpent());
                if (i < slotActivityTimers.size()) {
                    lastOfferEventForSlotTrackedByPlugin.setBeforeLogin(slotActivityTimers.get(i).offerOccurredAtUnknownTime);
                    lastOfferEventForSlotTrackedByPlugin.setTradeStartedAt(slotActivityTimers.get(i).tradeStartTime);
                }
                //when tracked offer is the same, prefer to use it as it has more info.
                if (lastOfferEventForSlotTrackedByPlugin.isDuplicate(trueOfferInSlot)) {
                    slotStates.add(SlotState.fromOfferEvent(lastOfferEventForSlotTrackedByPlugin));
                }
                //sometimes tracked offer can be incongruent with slot (collected an offer on mobile). In that case, use
                //the true offer from the client object.
                else {
                    trueOfferInSlot.setBeforeLogin(true); //we don't know when this offer came in as it wasn't tracked
                    if (trueOfferInSlot.isCausedByEmptySlot()) {
                        slotStates.add(SlotState.createEmptySlot(i));
                    }
                    else {
                        slotStates.add(SlotState.fromOfferEvent(trueOfferInSlot));
                    }
                }
            }
            //in the case when there is no tracked offer for the slot
            else {
                //check if the slot is actually empty
                if (trueOfferInSlot.isCausedByEmptySlot()) {
                    slotStates.add(SlotState.createEmptySlot(i));
                }
                //if it is not actually empty, add the true offer we got from client.getGrandExchangeOffers()
                else {
                    slotStates.add(SlotState.fromOfferEvent(trueOfferInSlot));
                }
            }
        }
        return slotStates;
    }

    /**
     * Converts a GrandExchangeOffer from client.getGrandExchangeOffers into an OfferEvent object which is our
     * representation of offer events with extra methods that make it easier to deal with.
     */
    private OfferEvent getOfferEventConstructedFromClient(int slot) {
        GrandExchangeOffer clientOffer = this.plugin.getClient().getGrandExchangeOffers()[slot];
        GrandExchangeOfferChanged grandExchangeOfferChanged = new GrandExchangeOfferChanged();
        grandExchangeOfferChanged.setSlot(slot);
        grandExchangeOfferChanged.setOffer(clientOffer);
        return OfferEvent.fromGrandExchangeEvent(grandExchangeOfferChanged);
    }
}
package com.flippingutilities.jobs;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.utilities.WikiDataSource;
import com.flippingutilities.utilities.WikiRequest;
import com.flippingutilities.utilities.WikiRequestWrapper;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.WorldType;
import okhttp3.*;

import java.io.IOException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;

/**
 * Responsible for handling all of the requests for wiki realtime data and ensuring too many requests aren't being made.
 */
@Slf4j
public class WikiDataFetcherJob {
    public static int requestInterval = 60; //seconds
    static final String API = "https://prices.runescape.wiki/api/v1/osrs/latest";
    static final String DEADMAN_API = "https://prices.runescape.wiki/api/v1/dmm/latest";
    FlippingPlugin plugin;
    ScheduledExecutorService executor;
    OkHttpClient httpClient;
    List<BiConsumer<WikiRequestWrapper, Instant>> subscribers = new ArrayList<>();
    Future wikiDataFetchTask;
    Instant timeOfLastRequestCompletion;
    boolean inFlightRequest = false;
    String apiUrl = API;


    public WikiDataFetcherJob(FlippingPlugin plugin, OkHttpClient httpClient) {
        this.plugin = plugin;
        this.httpClient = httpClient;
        this.executor = Executors.newSingleThreadScheduledExecutor();
    }

    public void subscribe(BiConsumer<WikiRequestWrapper, Instant> subscriber) {
        subscribers.add(subscriber);
    }

    public void start() {
        wikiDataFetchTask = executor.scheduleAtFixedRate(() -> this.attemptToFetchWikiData(false), 5,1, TimeUnit.SECONDS);
        log.info("started wiki fetching job");
    }

    public void stop() {
        if (!wikiDataFetchTask.isCancelled() && !wikiDataFetchTask.isCancelled()) {
            wikiDataFetchTask.cancel(true);
            log.info("shut down wiki fetching job");
        }
    }

    public void onWorldSwitch(EnumSet<WorldType> worldType) {
        if (worldType.contains(WorldType.DEADMAN)) {
            log.info("Switching to requesting deadman api");
            apiUrl = DEADMAN_API;
        }
        else {
            apiUrl = API;
        }

        attemptToFetchWikiData(true);
    }

    private WikiDataSource getWikiDataSourceType() {
        if (apiUrl.equals(DEADMAN_API)) {
            return WikiDataSource.DMM;
        }
        return WikiDataSource.REGULAR;
    }


    //only problem with this is that then master panel will be visible even if they have opened and then closed flipping utils
    //as long as they haven't opened another plugin. But if they have another plugin open or they haven't opened flipping utils
    //then masterpanel.isVisible() will correctly return false.
    private boolean shouldFetch() {
        boolean lastRequestOldEnough = timeOfLastRequestCompletion == null || Instant.now().minus(requestInterval, ChronoUnit.SECONDS).isAfter(timeOfLastRequestCompletion);
        //for the purpose of SlotStateDrawer, we need wiki data even if the master panel is not visible, but only
        //if the user is premium.
        return (plugin.getMasterPanel().isVisible() || plugin.getApiAuthHandler().isPremium()) && !inFlightRequest && lastRequestOldEnough;
    }

    public void attemptToFetchWikiData(boolean force) {
        if (!force && !shouldFetch()) {
            return;
        }
        inFlightRequest = true;
        Request request = new Request.Builder().header("User-Agent", "FlippingUtilities").url(apiUrl).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                timeOfLastRequestCompletion = Instant.now();
                inFlightRequest = false;
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (!response.isSuccessful()) {
                        timeOfLastRequestCompletion = Instant.now();
                        inFlightRequest = false;
                        return;
                    }
                    try {
                        timeOfLastRequestCompletion = Instant.now();
                        inFlightRequest = false;
                        WikiRequest wikiRequest = plugin.gson.fromJson(responseBody.string(), WikiRequest.class);
                        WikiRequestWrapper wikiRequestWrapper = new WikiRequestWrapper(wikiRequest, getWikiDataSourceType());
                        subscribers.forEach(subscriber -> subscriber.accept(wikiRequestWrapper, timeOfLastRequestCompletion));
                    }
                    catch (JsonSyntaxException e) { }
                }
            }
        });
    }
}


package com.flippingutilities;

import com.flippingutilities.model.OfferEvent;
import net.runelite.api.GrandExchangeOfferState;

import java.time.Instant;
import java.util.UUID;

public class Utils
{
	//constructs an OfferEvent when you don't care about tick specific info.
	public static OfferEvent offer(boolean isBuy, int currentQuantityInTrade, int price, Instant time, int slot, GrandExchangeOfferState state, int totalQuantityInTrade)
	{
		return new OfferEvent(UUID.randomUUID().toString(), isBuy, 1, currentQuantityInTrade, price, time, slot, state, 0, 10, totalQuantityInTrade, null, false, "gooby", null,0,0);
	}

	public static OfferEvent offer(boolean isBuy, int currentQuantityInTrade, int price, Instant time, int slot, GrandExchangeOfferState state, int totalQuantityInTrade, int tickSinceFirstOffer)
	{
		return new OfferEvent(UUID.randomUUID().toString(), isBuy, 1, currentQuantityInTrade, price, time, slot, state, 0, tickSinceFirstOffer, totalQuantityInTrade, null,false, "gooby", null,0,0);
	}

	public static OfferEvent offer(boolean isBuy, int currentQuantityInTrade, int price, Instant time, int slot, GrandExchangeOfferState state, int tickArrivedAt, int tickSinceFirstOffer, int totalQuantityInTrade) {
		return new OfferEvent(UUID.randomUUID().toString(), isBuy, 1, currentQuantityInTrade, price, time, slot, state, tickArrivedAt, tickSinceFirstOffer, totalQuantityInTrade, null, false,"gooby", null,0,0);
	}
}

/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities;


import com.flippingutilities.model.Flip;
import com.flippingutilities.model.HistoryManager;
import com.flippingutilities.model.OfferEvent;
import net.runelite.api.GrandExchangeOfferState;
import org.junit.Before;
import org.junit.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.junit.Assert.assertEquals;

public class HistoryManagerTest
{
	private static HistoryManager historyManager;
	private static Instant baseTime = Instant.now();


	@Before
	public void setUp()
	{
		List<OfferEvent> offerEvents = new ArrayList<>();

		//overall bought 24+3+20=47
		//overall sold 7 + 3 + 30 = 40
		//5gp profit each

		offerEvents.add(Utils.offer(true, 7, 100, baseTime.minus(40, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BUYING, 24));
		offerEvents.add(Utils.offer(true, 13, 100, baseTime.minus(30, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BUYING, 24));
		offerEvents.add(Utils.offer(true, 24, 100, baseTime.minus(20, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 24));

		offerEvents.add(Utils.offer(false, 7, 105, baseTime.minus(15, ChronoUnit.MINUTES), 3, GrandExchangeOfferState.SOLD, 7));
		offerEvents.add(Utils.offer(false, 3, 105, baseTime.minus(12, ChronoUnit.MINUTES), 4, GrandExchangeOfferState.SELLING, 5));
		offerEvents.add(Utils.offer(false, 3, 105, baseTime.minus(12, ChronoUnit.MINUTES), 4, GrandExchangeOfferState.CANCELLED_SELL, 5));

		offerEvents.add(Utils.offer(true, 3, 100, baseTime.minus(10, ChronoUnit.MINUTES), 2, GrandExchangeOfferState.BOUGHT, 3));
		offerEvents.add(Utils.offer(true, 10, 100, baseTime.minus(9, ChronoUnit.MINUTES), 2, GrandExchangeOfferState.BUYING, 20));
		offerEvents.add(Utils.offer(true, 20, 100, baseTime.minus(7, ChronoUnit.MINUTES), 2, GrandExchangeOfferState.BOUGHT, 20));

		offerEvents.add(Utils.offer(false, 10, 105, baseTime.minus(6, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SELLING, 30));
		offerEvents.add(Utils.offer(false, 20, 105, baseTime.minus(5, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SELLING, 30));
		offerEvents.add(Utils.offer(false, 30, 105, baseTime.minus(4, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 30));

		historyManager = new HistoryManager();
		for (OfferEvent offerEvent : offerEvents)
		{
			historyManager.updateHistory(offerEvent);
		}
	}

	/**
	 * Tests that updating the history manager standardizes the offers correctly, truncates them appropriately, and
	 * manages state such as ge properties correctly.
	 */
	@Test
	public void historyManagerCorrectlyUpdatedTest()
	{
		List<OfferEvent> recordedOffers = new ArrayList<>();

		recordedOffers.add(Utils.offer(true, 24, 100, baseTime.minus(20, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 24));
		recordedOffers.add(Utils.offer(false, 7, 105, baseTime.minus(15, ChronoUnit.MINUTES), 3, GrandExchangeOfferState.SOLD, 7));
		recordedOffers.add(Utils.offer(false, 3, 105, baseTime.minus(12, ChronoUnit.MINUTES), 4, GrandExchangeOfferState.CANCELLED_SELL, 5));
		recordedOffers.add(Utils.offer(true, 3, 100, baseTime.minus(10, ChronoUnit.MINUTES), 2, GrandExchangeOfferState.BOUGHT, 3));
		recordedOffers.add(Utils.offer(true, 20, 100, baseTime.minus(7, ChronoUnit.MINUTES), 2, GrandExchangeOfferState.BOUGHT, 20));
		recordedOffers.add(Utils.offer(false, 30, 105, baseTime.minus(4, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 30));

		assertEquals(recordedOffers, historyManager.getCompressedOfferEvents());

		assertEquals(47, historyManager.getItemsBoughtThisLimitWindow());

		//first buy was 40 mins before baseTime, so ge refresh should be at after 3 hours and 20 minutes which is 200 minutes
		assertEquals(baseTime.plus(200, ChronoUnit.MINUTES), historyManager.getNextGeLimitRefresh());
	}

	@Test
	public void getProfitCorrectnessTest()
	{
		List<OfferEvent> tradesList;
		tradesList = historyManager.getIntervalsHistory(baseTime.minus(1, ChronoUnit.HOURS));
		assertEquals(200, historyManager.getProfit(tradesList));

		//sell 5 more of the item
		historyManager.updateHistory(Utils.offer(false, 5, 105, baseTime.minus(4, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 5, 0));

		tradesList = historyManager.getIntervalsHistory(baseTime.minus(1, ChronoUnit.HOURS));
		assertEquals(225, historyManager.getProfit(tradesList)); //47 buys and 45 sells, so looks for 45 items and profit is 5 gp ea.

		//when no trades are present given the interval
		tradesList = historyManager.getIntervalsHistory(baseTime);
		assertEquals(0, historyManager.getProfit(tradesList));
	}

	@Test
	public void gePropertiesCorrectnessTest()
	{
		HistoryManager historyManager = new HistoryManager();

		OfferEvent offer1 = Utils.offer(true, 7, 100, baseTime.minus(4, ChronoUnit.HOURS), 1, GrandExchangeOfferState.BUYING, 10, 0);

		//buy 7 of an item 4 hours ago
		historyManager.updateHistory(offer1);
		assertEquals(7, historyManager.getItemsBoughtThisLimitWindow());
		assertEquals(offer1.getTime().plus(4, ChronoUnit.HOURS), historyManager.getNextGeLimitRefresh());

		//buy another 3 of that item 3 hours ago, so the amount you bought before the ge limit has refreshed is now 10
		OfferEvent offer2 = Utils.offer(true, 10, 100, baseTime.minus(3, ChronoUnit.HOURS), 1, GrandExchangeOfferState.BOUGHT, 10, 0);
		historyManager.updateHistory(offer2);
		assertEquals(10, historyManager.getItemsBoughtThisLimitWindow());
		assertEquals(offer1.getTime().plus(4, ChronoUnit.HOURS), historyManager.getNextGeLimitRefresh());

		//buy another 1 of that item, but 1 minute in the future, so more than 4 hours from the first purchase of the item. By this time, the ge limit has reset
		//so the amount you bought after the last ge refresh is 1.
		OfferEvent offer3 = Utils.offer(true, 1, 100, baseTime.plus(1, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BUYING, 2, 0);
		historyManager.updateHistory(offer3);
		assertEquals(1, historyManager.getItemsBoughtThisLimitWindow());
		assertEquals(offer3.getTime().plus(4, ChronoUnit.HOURS), historyManager.getNextGeLimitRefresh());
	}

	@Test
	public void testCreateFlips()
	{
		//in setup we defined a bunch of offers. The offers signify the following: The user bought 24 of that item, then
		//sold 7 of that item, then sold 3 of that item, then bought 3 of that item, then bought 20 of that item, then
		//sold 30 of that item. So, get flips should return flips that represent all of those complete transaction.
		List<Flip> generatedFlips;

		ArrayList<Flip> flips = new ArrayList<>();
		flips.add(new Flip(100, 105, 7, baseTime.minus(15, ChronoUnit.MINUTES), false, false));
		flips.add(new Flip(100, 105, 3, baseTime.minus(12, ChronoUnit.MINUTES), false, false));
		flips.add(new Flip(100, 105, 30, baseTime.minus(4, ChronoUnit.MINUTES), false,false));
		generatedFlips = historyManager.createFlips(historyManager.getCompressedOfferEvents());

		assertEquals(flips, generatedFlips);

		//now lets add some margin checks in there!!!!!!!
		OfferEvent marginBuy = Utils.offer(true, 1, 105, baseTime.minus(3, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 0, 1);
		OfferEvent marginSell = Utils.offer(false, 1, 100, baseTime.minus(3, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 0, 1);

		historyManager.updateHistory(marginBuy);
		historyManager.updateHistory(marginSell);
		generatedFlips = historyManager.createFlips(historyManager.getCompressedOfferEvents());

		generatedFlips.sort(Comparator.comparing(Flip::getTime));

		//add the flip generated by the margin check
		flips.add(new Flip(105, 100, 1, baseTime.minus(3, ChronoUnit.MINUTES), true, false));
		assertEquals(flips, generatedFlips);
	}


	//tests that flips are correctly generated even when there are an uneven amount of margins checks. The
	//unpaired margin check should be paired with the a regular non margin check offer at a time close to it.
	@Test
	public void createFlipsUnEvenMarginChecks()
	{
		HistoryManager historyManager = new HistoryManager();
		List<OfferEvent> standardizedOffers = new ArrayList<>();
		List<Flip> flips = new ArrayList<>();

		//add a buy margin check and a sell margin check
		standardizedOffers.add(Utils.offer(true, 1, 2, baseTime.minus(10, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));
		standardizedOffers.add(Utils.offer(false, 1, 1, baseTime.minus(10, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));

		standardizedOffers.add(Utils.offer(false, 1, 2, baseTime.minus(9, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 100));
		standardizedOffers.add(Utils.offer(true, 10, 1, baseTime.minus(8, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 10, 10, 100));

		standardizedOffers.add(Utils.offer(false, 1, 2, baseTime.minus(7, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 100));

		standardizedOffers.add(Utils.offer(false, 1, 2, baseTime.minus(7, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.CANCELLED_SELL, 6, 1, 100));

		//some random buy margin check, for example this can be the case when a user just wants to instabuy something and see if its
		//sell price has changed
		standardizedOffers.add(Utils.offer(true, 1, 2, baseTime.minus(6, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));

		standardizedOffers.add(Utils.offer(false, 8, 2, baseTime.minus(5, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 8, 8));

		flips.add(new Flip(2, 1, 1, baseTime.minus(10, ChronoUnit.MINUTES), true, false));
		flips.add(new Flip(1, 2, 1, baseTime.minus(9, ChronoUnit.MINUTES), false, false));
		flips.add(new Flip(1, 2, 1, baseTime.minus(7, ChronoUnit.MINUTES), false, false));
		flips.add(new Flip(1, 2, 1, baseTime.minus(7, ChronoUnit.MINUTES), false, false));
		flips.add(new Flip(1, 2, 8, baseTime.minus(5, ChronoUnit.MINUTES), false, false));


		List<Flip> calculatedFlips = historyManager.createFlips(standardizedOffers);

		assertEquals(flips, calculatedFlips);
	}

	//Tests pairing margin checks when you have intermediate "half margin checks" that shouldn't
	//be matched with another offer. For example, a random insta buy that was never followed by a insta sell
	//at a reasonable time.
	@Test
	public void pairUnevenMarginChecksTest()
	{
		List<Flip> flips = new ArrayList<>();
		List<OfferEvent> expectedRemainder = new ArrayList<>();

		List<OfferEvent> buyMarginChecks = new ArrayList<>();
		List<OfferEvent> sellMarginChecks = new ArrayList<>();
		List<OfferEvent> remainder = new ArrayList<>();
		//initial buy margin check
		buyMarginChecks.add(Utils.offer(true, 1, 2, baseTime.minus(10, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));
		//sell margin check
		sellMarginChecks.add(Utils.offer(false, 1, 1, baseTime.minus(10, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));

		//random half margin check if user is just checking out optimal sell price
		buyMarginChecks.add(Utils.offer(true, 1, 3, baseTime.minus(8, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));

		//another buy margin check
		buyMarginChecks.add(Utils.offer(true, 1, 2, baseTime.minus(6, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));
		//accompanied by sell margin check
		sellMarginChecks.add(Utils.offer(false, 1, 1, baseTime.minus(6, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));

		//some random half margin check to check optimal buy price
		sellMarginChecks.add(Utils.offer(false, 1, 1, baseTime.minus(5, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));


		flips.add(new Flip(2, 1, 1, baseTime.minus(10, ChronoUnit.MINUTES), true, false));
		flips.add(new Flip(2, 1, 1, baseTime.minus(6, ChronoUnit.MINUTES), true, false));


		assertEquals(flips, historyManager.pairMarginChecks(buyMarginChecks, sellMarginChecks, remainder));

		//add both the half margin checks that should be unpaired
		expectedRemainder.add(Utils.offer(true, 1, 3, baseTime.minus(8, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));
		expectedRemainder.add(Utils.offer(false, 1, 1, baseTime.minus(5, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));

		assertEquals(expectedRemainder, remainder);
	}

	//this test checks that flips are created correctly when there are not only uneven margin checks
	//but there are half margin checks mixed in. As such, this will functionally also test that unpaired
	//margin checks get matched to the most appropriate offer.
	@Test
	public void createFlipsUnevenAndIntermediateMarginChecks()
	{
		List<OfferEvent> offers = new ArrayList<>();

		List<Flip> expectedFlips = new ArrayList<>();

		//a full margin check (a buy margin check followed by a sell margin check)
		offers.add(Utils.offer(true, 1, 2, baseTime.minus(20, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));
		offers.add(Utils.offer(false, 1, 1, baseTime.minus(20, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));

		//some random offers
		offers.add(Utils.offer(false, 1, 2, baseTime.minus(19, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 10));
		offers.add(Utils.offer(true, 5, 1, baseTime.minus(17, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 5, 5));

		//half margin check to see optimal sell price
		offers.add(Utils.offer(true, 1, 3, baseTime.minus(17, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));

		offers.add(Utils.offer(false, 5, 3, baseTime.minus(15, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 5, 5));

		//you start flipping it again so u do a full margin check
		//a full margin check (a buy margin check followed by a sell margin check)
		offers.add(Utils.offer(true, 1, 7, baseTime.minus(14, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));
		offers.add(Utils.offer(false, 1, 4, baseTime.minus(14, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));

		offers.add(Utils.offer(true, 5, 4, baseTime.minus(12, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 5, 5));

		//half margin check to see optimal sell price
		offers.add(Utils.offer(true, 1, 8, baseTime.minus(12, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));

		offers.add(Utils.offer(false, 3, 8, baseTime.minus(11, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 3, 3));

		//half margin check to see optimal sell price
		offers.add(Utils.offer(true, 1, 8, baseTime.minus(12, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));

		offers.add(Utils.offer(false, 3, 8, baseTime.minus(10, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 3, 3));

		//you think about buying it again for more, so you insta sell your last one to see optimal buy price
		offers.add(Utils.offer(false, 1, 3, baseTime.minus(10, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1));

		expectedFlips.add(new Flip(2, 1, 1, baseTime.minus(20, ChronoUnit.MINUTES), true, false));
		expectedFlips.add(new Flip(1, 2, 1, baseTime.minus(19, ChronoUnit.MINUTES), false, false));
		expectedFlips.add(new Flip(1, 3, 5, baseTime.minus(15, ChronoUnit.MINUTES), false, false));
		expectedFlips.add(new Flip(7, 4, 1, baseTime.minus(14, ChronoUnit.MINUTES), true, false));
		expectedFlips.add(new Flip(4, 8, 3, baseTime.minus(11, ChronoUnit.MINUTES), false, false));
		expectedFlips.add(new Flip(5, 8, 3, baseTime.minus(10, ChronoUnit.MINUTES), false, false));
		expectedFlips.add(new Flip(8, 3, 1, baseTime.minus(10, ChronoUnit.MINUTES), false, false));

		List<Flip> generatedFlips = historyManager.createFlips(offers);
		generatedFlips.sort(Comparator.comparing(Flip::getTime));

		assertEquals(expectedFlips, generatedFlips);
	}

	//tests that un unpaired margin check is paired with an appropriate offer, this was also covered in the
	//last test, but this is testing only that.
	@Test
	public void unpairedMarginCheckPairedWithAppropriateOffer()
	{
		List<Flip> expectedFlips = new ArrayList<>();

		List<OfferEvent> offers = new ArrayList<>();

		//a full margin check (a buy margin check followed by a sell margin check)
		offers.add(Utils.offer(true, 1, 2, baseTime.minus(20, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 1, 1, 1));
		offers.add(Utils.offer(false, 1, 1, baseTime.minus(20, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1, 1));

		//some random offers
		offers.add(Utils.offer(false, 1, 2, baseTime.minus(19, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1));
		offers.add(Utils.offer(true, 5, 1, baseTime.minus(17, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 5, 5));
		offers.add(Utils.offer(false, 4, 2, baseTime.minus(16, ChronoUnit.MINUTES),1, GrandExchangeOfferState.SOLD,4,4));


		//half margin check that should be paired with the next sell offer
		offers.add(Utils.offer(true, 1, 20, baseTime.minus(10, ChronoUnit.MINUTES),1, GrandExchangeOfferState.BOUGHT, 1,1));

		offers.add(Utils.offer(true, 5, 1, baseTime.minus(9, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.BOUGHT, 5, 5));

		offers.add(Utils.offer(false, 1, 2, baseTime.minus(9, ChronoUnit.MINUTES), 1, GrandExchangeOfferState.SOLD, 1, 1));

		expectedFlips.add(new Flip(2,1,1,baseTime.minus(20, ChronoUnit.MINUTES),true, false));
		expectedFlips.add(new Flip(1,2,1,baseTime.minus(19, ChronoUnit.MINUTES),false, false));
		expectedFlips.add(new Flip(1,2,4,baseTime.minus(16,ChronoUnit.MINUTES),false, false));
		expectedFlips.add(new Flip(20,2,1, baseTime.minus(9, ChronoUnit.MINUTES), false, false));

		List<Flip> generatedFlips = historyManager.createFlips(offers);
		generatedFlips.sort(Comparator.comparing(Flip::getTime));

		assertEquals(expectedFlips, generatedFlips);
	}

	@Test
	public void offersCorrectlyTruncatedTest()
	{
		HistoryManager historyManager = new HistoryManager();

		ArrayList<OfferEvent> expectedCompressedEvents = new ArrayList<>();

		//test truncation on incomplete offers
		historyManager.updateHistory(Utils.offer(true, 10, 100, baseTime, 1, GrandExchangeOfferState.BUYING, 50));
		historyManager.updateHistory(Utils.offer(true, 5, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 1));
		historyManager.updateHistory(Utils.offer(true, 30, 100, baseTime, 1, GrandExchangeOfferState.BUYING, 50));

		expectedCompressedEvents.add(Utils.offer(true, 5, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 1));
		expectedCompressedEvents.add(Utils.offer(true, 30, 100, baseTime, 1, GrandExchangeOfferState.BUYING, 50));

		assertEquals(historyManager.getCompressedOfferEvents(), expectedCompressedEvents);

		//now lets add a completed offer for slot 1.
		historyManager.updateHistory(Utils.offer(true, 50, 100, baseTime, 1, GrandExchangeOfferState.BOUGHT, 50));

		//rebuildItemsDisplay the compressed offers list
		expectedCompressedEvents.clear();
		expectedCompressedEvents.add(Utils.offer(true, 5, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 1));
		expectedCompressedEvents.add(Utils.offer(true, 50, 100, baseTime, 1, GrandExchangeOfferState.BOUGHT, 50));

		historyManager.deletePreviousOffersForTrade(Utils.offer(true, 50, 100, baseTime, 1, GrandExchangeOfferState.BOUGHT, 50));
		assertEquals(historyManager.getCompressedOfferEvents(), expectedCompressedEvents);

		//lets add a complete offer for slot 3, this offer has no previous offers in that same trade
		historyManager.updateHistory(Utils.offer(false, 20, 100, baseTime, 3, GrandExchangeOfferState.SOLD, 20 ));

		expectedCompressedEvents.add(Utils.offer(false, 20, 100, baseTime, 3, GrandExchangeOfferState.SOLD, 20));

		assertEquals(historyManager.getCompressedOfferEvents(), expectedCompressedEvents);
	}
}

package com.flippingutilities;

import com.flippingutilities.controller.FlippingPlugin;
import com.flippingutilities.model.AccountData;
import com.flippingutilities.model.OfferEvent;
import net.runelite.api.GrandExchangeOfferState;
import org.junit.Before;
import org.junit.Test;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import static org.junit.Assert.assertEquals;


public class FlippingPluginTest
{
	FlippingPlugin plugin;

	@Before
	public void preparePluginForTests()
	{
		plugin = new FlippingPlugin();
		plugin.setCurrentlyLoggedInAccount("testacc");
		//TODO better testing process for this
//		plugin.getDataHandler().getacc
//		plugin.setAccountCache(Collections.singletonMap("testacc", new AccountData()));
//		plugin.getAccountCache().get("testacc").setSlotTimers(plugin.setupSlotTimers());
	}

	/**
	 * This test will replicate the offer events that come in during a typical interaction with the GE by a user
	 */
	@Test
	public void screenOfferTest()
	{
		Instant baseTime = Instant.now();

		List<OfferEvent> offerEvents = new ArrayList<>();
		//some empty slot events on login
		offerEvents.add(Utils.offer(false,0,0,baseTime,5,GrandExchangeOfferState.EMPTY,0,0,0));
		offerEvents.add(Utils.offer(false,0,0,baseTime,6,GrandExchangeOfferState.EMPTY,0,0,0));
		offerEvents.add(Utils.offer(false,0,0,baseTime,7,GrandExchangeOfferState.EMPTY,0,0,0));

		//user sets an offer and receives start of trade event and then also a duplicate start of trade event on the next tick
		offerEvents.add(Utils.offer(true,0, 0, baseTime, 2, GrandExchangeOfferState.BUYING, 10, 0,3));
		offerEvents.add(Utils.offer(true,0, 0, baseTime, 2, GrandExchangeOfferState.BUYING, 11, 0,3));

		//offer completes and user gets a redundant BUYING offer event and then a BOUGHT offer event saying that the offer is complete a tick later
		offerEvents.add(Utils.offer(true, 3, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 20, 0,3));
		offerEvents.add(Utils.offer(true, 3, 100, baseTime, 2, GrandExchangeOfferState.BOUGHT, 21, 0,3));

		//user places another trade and receives two start of trade events again
		offerEvents.add(Utils.offer(true,0, 0, baseTime, 2, GrandExchangeOfferState.BUYING, 40, 0,1));
		offerEvents.add(Utils.offer(true,0, 0, baseTime, 2, GrandExchangeOfferState.BUYING, 41, 0,1));

		//as the item buys, user receives multiple duplicate BUYING offer events, the only difference being that one arrived a tick later
		offerEvents.add(Utils.offer(true, 2, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 45, 0, 10));
		offerEvents.add(Utils.offer(true, 2, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 46, 0, 10));

		offerEvents.add(Utils.offer(true, 5, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 50, 0, 10));
		offerEvents.add(Utils.offer(true, 5, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 51, 0, 10));

		//offer completes and user gets a redundant BUYING offer and then a BOUGHT offer event a tick later
		offerEvents.add(Utils.offer(true, 10, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 55, 0,10));
		offerEvents.add(Utils.offer(true, 10, 100, baseTime, 2, GrandExchangeOfferState.BOUGHT, 56, 0,10));

		//These are copied and pasted from the offers above that should have passed the screening with one difference which is that the tickSinceFirstOffer is changed to what it should be.
		List<OfferEvent> expectedOfferEvents = new ArrayList<>();
		expectedOfferEvents.add(Utils.offer(true, 3, 100, baseTime, 2, GrandExchangeOfferState.BOUGHT, 21, 11,3));
		expectedOfferEvents.add(Utils.offer(true, 2, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 45, 5, 10));
		expectedOfferEvents.add(Utils.offer(true, 5, 100, baseTime, 2, GrandExchangeOfferState.BUYING, 50, 10, 10));
		expectedOfferEvents.add(Utils.offer(true, 10, 100, baseTime, 2, GrandExchangeOfferState.BOUGHT, 56, 16,10));

//		List<OfferEvent> actualScreenedOffers = offerEvents.stream().map(plugin::screenOfferEvent).filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList());
//
//		assertEquals(expectedOfferEvents, actualScreenedOffers);
	}
}
package com.flippingutilities;

import com.flippingutilities.model.OfferEvent;
import com.flippingutilities.utilities.Constants;
import org.junit.Test;

import java.time.Instant;
import static org.junit.Assert.assertEquals;


public class GeTaxTest {

    @Test
    public void testGeTaxLow() {
        OfferEvent offerEvent = new OfferEvent();
        offerEvent.setBuy(false);
        offerEvent.setTime(Instant.ofEpochSecond(Constants.GE_TAX_START + 100));
        offerEvent.setPrice(50);

        assertEquals(offerEvent.getPrice(), 50);
    }

    @Test
    public void testGeTaxHigh() {
        OfferEvent offerEvent = new OfferEvent();
        offerEvent.setBuy(false);
        offerEvent.setTime(Instant.ofEpochSecond(Constants.GE_TAX_START + 100));
        offerEvent.setPrice(2147000000);

        assertEquals(offerEvent.getPrice(), 2147000000 - Constants.GE_TAX_CAP);
    }

    @Test
    public void testGeTaxSimple() {
        OfferEvent offerEvent = new OfferEvent();
        offerEvent.setBuy(false);
        offerEvent.setTime(Instant.ofEpochSecond(Constants.GE_TAX_START + 100));
        offerEvent.setPrice(975);

        assertEquals(offerEvent.getPrice(), 975 - 9);
    }

    @Test
    public void testBeforeTax() {
        OfferEvent offerEvent = new OfferEvent();
        offerEvent.setBuy(false);
        offerEvent.setTime(Instant.ofEpochSecond(Constants.GE_TAX_START - 1));
        offerEvent.setPrice(975);

        assertEquals(offerEvent.getPrice(), 975);
    }

    @Test
    public void testNonSellAfterTax() {
        OfferEvent offerEvent = new OfferEvent();
        offerEvent.setBuy(true);
        offerEvent.setTime(Instant.ofEpochSecond(Constants.GE_TAX_START + 100));
        offerEvent.setPrice(975);

        assertEquals(offerEvent.getPrice(), 975);
    }
}

package com.flippingutilities;

import com.flippingutilities.controller.FlippingPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginRunner
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlippingPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2020, Belieal <https://github.com/Belieal>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flippingutilities;

import org.junit.runner.RunWith;
import org.junit.runners.Suite;

/**
 * This class is responsible for running each test class so you don't have to run each file manually,
 * just add your test class below, inside @Suite.SuiteClasses({}).
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({
	HistoryManagerTest.class,
	FlippingPluginTest.class
})
public class TestRunner {

}
