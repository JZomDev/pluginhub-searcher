package com.kagof.runelite.plugins.brimhavenagility;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("brimhavenagility")
public interface BrimhavenAgilityConfig extends Config
{

	// this config option is not useful at this time since this is the only feature of the plugin currently.
	//	@ConfigItem(keyName = "drawpath",
	//		name = "Draw path",
	//		description = "Whether or not to draw the shortest path to the currently active dispenser",
	//		position = 0)
	//	default boolean drawPath()
	//	{
	//		return true;
	//	}

	@Alpha
	@ConfigItem(keyName = "pathcolour",
		name = "Path colour",
		description = "The colour used to draw the path to the currently active dispenser",
		position = 1)
	default Color pathColour()
	{
		return new Color(255, 255, 255, 191);
	}

	@ConfigSection(
		name = "Obstacles to avoid",
		description = "Configuration of obstacles to avoid when computing the path to the active dispenser",
		position = 2)
	String obstaclesAvoid = "obstaclesavoid";

	@ConfigItem(keyName = "bladeavoid",
		name = "Avoid Blade",
		description = "If checked, the recommended path will not contain the blade obstacle",
		section = obstaclesAvoid)
	default boolean bladeAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "ropeswingavoid",
		name = "Avoid Rope swing",
		description = "If checked, the recommended path will not contain the rope swing obstacle",
		section = obstaclesAvoid)
	default boolean ropeSwingAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "lowwallavoid",
		name = "Avoid Low wall",
		description = "If checked, the recommended path will not contain the low wall obstacle",
		section = obstaclesAvoid)
	default boolean lowWallAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "plankavoid",
		name = "Avoid Plank",
		description = "If checked, the recommended path will not contain the plank obstacle",
		section = obstaclesAvoid)
	default boolean plankAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "balancingropeavoid",
		name = "Avoid Balancing rope",
		description = "If checked, the recommended path will not contain the balancing rope obstacle",
		section = obstaclesAvoid)
	default boolean balancingRopeAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "logbalanceavoid",
		name = "Avoid Log balance",
		description = "If checked, the recommended path will not contain the log balance obstacle",
		section = obstaclesAvoid)
	default boolean logBalanceAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "balancingledgeavoid",
		name = "Avoid Balancing ledge",
		description = "If checked, the recommended path will not contain the balancing ledge obstacle",
		section = obstaclesAvoid)
	default boolean balancingLedgeAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "monkeybarsavoid",
		name = "Avoid Monkey bars",
		description = "If checked, the recommended path will not contain the monkey bars obstacle",
		section = obstaclesAvoid)
	default boolean monkeyBarsAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "pillaravoid",
		name = "Avoid Pillar",
		description = "If checked, the recommended path will not contain the pillar obstacle",
		section = obstaclesAvoid)
	default boolean pillarAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "pressurepadavoid",
		name = "Avoid Pressure pad",
		description = "If checked, the recommended path will not contain the pressure pad obstacle",
		section = obstaclesAvoid)
	default boolean pressurePadAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "floorspikesavoid",
		name = "Avoid Floor spikes",
		description = "If checked, the recommended path will not contain the floor spikes obstacle",
		section = obstaclesAvoid)
	default boolean floorSpikesAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "handholdsavoid",
		name = "Avoid Hand holds",
		description = "If checked, the recommended path will not contain the hand holds obstacle",
		section = obstaclesAvoid)
	default boolean handHoldsAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "spinningbladesavoid",
		name = "Avoid Spinning blades",
		description = "If checked, the recommended path will not contain the spinning blades obstacle",
		section = obstaclesAvoid)
	default boolean spinningBladesAvoid()
	{
		return false;
	}

	@ConfigItem(keyName = "dartsavoid",
		name = "Avoid Darts",
		description = "If checked, the recommended path will not contain the darts obstacle",
		section = obstaclesAvoid)
	default boolean dartsAvoid()
	{
		return false;
	}
}

package com.kagof.runelite.plugins.brimhavenagility;

import com.google.common.collect.Lists;
import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaLocation;
import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaNeighbour;
import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaPath;
import com.kagof.runelite.plugins.brimhavenagility.model.MapWithDefault;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

/**
 * Uses the A* path finding algorithm to find the shortest (weighted) path from the player's current location, to the
 * target dispenser. Adapted from <a href="https://en.wikipedia.org/wiki/A*_search_algorithm#Pseudocode">Wikipedia's
 * pseudocode</a> implementation.
 */
@Slf4j
public final class BrimhavenAgilityPathFinder
{
	//belts & braces to ensure we never have an infinite loop

	private static final int MAX_VISITED_NODES = 25;

	// There are 25 nodes in the arena, each with at most 4 neighbours; we should never exceed this number
	private static final int MAX_TOTAL_NEIGHBOURS = 100;

	// not MAX_INT to avoid overflows
	public static final int NEVER_USE_WEIGHT = 999999;

	// lower than the NEVER_USER_WEIGHT so a valid path can still be found if too many obstacles are avoided
	public static final int AVOID_WEIGHT = 999;

	private BrimhavenAgilityPathFinder()
	{
	}

	public static BrimhavenAgilityArenaPath findPath(final WorldPoint playerLocation,
													 final WorldPoint dispenserLocation,
													 final int playerAgilityLevel,
													 final BrimhavenAgilityConfig config)
	{
		final BrimhavenAgilityArenaLocation start = BrimhavenAgilityArenaLocation.fromWorldPoint(playerLocation);
		final BrimhavenAgilityArenaLocation end = BrimhavenAgilityArenaLocation.fromWorldPoint(dispenserLocation);

		if (start == null || end == null)
		{
			return null;
		}

		Map<BrimhavenAgilityArenaLocation, Integer> gScore = new MapWithDefault<>(999999);
		gScore.put(start, 0);

		Map<BrimhavenAgilityArenaLocation, Integer> fScore = new MapWithDefault<>(999999);
		fScore.put(start, 0);

		PriorityQueue<BrimhavenAgilityArenaLocation> openSet = new PriorityQueue<>(Comparator.comparing(fScore::get));
		openSet.add(start);

		Map<BrimhavenAgilityArenaLocation, BrimhavenAgilityArenaLocation> cameFrom = new HashMap<>();

		int numVisitedNodes = 0;
		int totalNeighboursExamined = 0;
		while (!openSet.isEmpty())
		{
			final BrimhavenAgilityArenaLocation current = openSet.poll();
			numVisitedNodes++;
			if (current.equals(end))
			{
				return reconstructPath(cameFrom, current);
			}
			if (numVisitedNodes > MAX_VISITED_NODES)
			{
				log.warn("exceeded maximum number of nodes {}. This indicates a potential infinite loop", MAX_VISITED_NODES);
				return null;
			}

			openSet.remove(current);
			for (BrimhavenAgilityArenaNeighbour neighbour : BrimhavenAgilityArenaNeighbourDigest.getNeighbours(current))
			{
				totalNeighboursExamined++;
				if (totalNeighboursExamined > MAX_TOTAL_NEIGHBOURS)
				{
					log.warn("exceeded maximum number of neighbours examined {}. This indicates a potential infinite loop", MAX_TOTAL_NEIGHBOURS);
					return null;
				}
				if (neighbour.getLocation().equals(current))
				{
					log.warn("node {} marked as neighbour of itself", current);
					continue;
				}
				int tentativeGScore = gScore.get(current) + weightedDistance(neighbour, playerAgilityLevel, config);
				if (tentativeGScore < gScore.get(neighbour.getLocation()))
				{
					cameFrom.put(neighbour.getLocation(), current);
					gScore.put(neighbour.getLocation(), tentativeGScore);
					fScore.put(neighbour.getLocation(), tentativeGScore + heuristic(start, neighbour.getLocation()));
					if (!openSet.contains(neighbour.getLocation()))
					{
						openSet.add(neighbour.getLocation());
					}
				}
			}
		}
		return null;
	}

	private static int weightedDistance(BrimhavenAgilityArenaNeighbour neighbour, int agilityLevel, BrimhavenAgilityConfig config)
	{
		if (neighbour.getObstacle().getMinLevel() > agilityLevel)
		{
			return NEVER_USE_WEIGHT;
		}
		if (neighbour.getObstacle().getAvoidFunction().apply(config))
		{
			return AVOID_WEIGHT;
		}

		return neighbour.getObstacle().getWeight();
	}

	private static BrimhavenAgilityArenaPath reconstructPath(final Map<BrimhavenAgilityArenaLocation, BrimhavenAgilityArenaLocation> cameFrom, final BrimhavenAgilityArenaLocation end)
	{
		List<BrimhavenAgilityArenaLocation> path = new ArrayList<>();
		path.add(end);
		BrimhavenAgilityArenaLocation current = end;
		while (cameFrom.containsKey(current) && path.size() < MAX_VISITED_NODES)
		{
			current = cameFrom.get(current);
			path.add(current);
		}
		return new BrimhavenAgilityArenaPath(List.copyOf(Lists.reverse(path)));
	}

	/**
	 * The heuristic is the taxicab distance as the player can only move between platforms in this way.
	 */
	private static int heuristic(final BrimhavenAgilityArenaLocation start, final BrimhavenAgilityArenaLocation end)
	{
		return Math.abs(end.getX() - start.getX()) + Math.abs(end.getY() - start.getY());
	}
}

package com.kagof.runelite.plugins.brimhavenagility;

import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaLocation;
import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaNeighbour;
import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaObstacle;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.extern.slf4j.Slf4j;

/**
 * Keeps track of all neighbours of all platforms in the Brimhaven agility arena.
 */
@Slf4j
public final class BrimhavenAgilityArenaNeighbourDigest
{

	private static final String COMMENT_CHAR = "#";

	private BrimhavenAgilityArenaNeighbourDigest()
	{
	}

	private static volatile boolean loaded = false;
	private static final Map<BrimhavenAgilityArenaLocation, List<BrimhavenAgilityArenaNeighbour>> neighbours = new HashMap<>();
	;

	public static List<BrimhavenAgilityArenaNeighbour> getNeighbours(final BrimhavenAgilityArenaLocation location)
	{
		if (!loaded)
		{
			loadNeighbours();
		}
		return neighbours.getOrDefault(location, List.of());
	}

	/**
	 * Loads the layout of the agility arena from the arena_layout.txt file. This file records all neighbours of
	 * platforms. Each line of the file is 5 characters:
	 * <ol>
	 *     <li>source x coordinate</li>
	 *     <li>source y coordinate</li>
	 *     <li>{@link BrimhavenAgilityArenaObstacle} short code</li>
	 *     <li>destination x coordinate</li>
	 *     <li>destination y coordinate</li>
	 * </ol>
	 * Where the x,y coordinates are in the {@link BrimhavenAgilityArenaLocation} space (ie, 0 to 4).
	 */
	private static synchronized void loadNeighbours()
	{
		if (loaded)
		{
			return;
		}
		log.info("Loading Brimhaven agility arena neighbours from file");
		try (InputStream is = BrimhavenAgilityArenaNeighbourDigest.class.getClassLoader().getResourceAsStream("arena_layout.txt"))
		{
			if (is == null)
			{
				log.error("Neighbours file not found");
			}
			else
			{
				try (InputStreamReader isr = new InputStreamReader(is);
					 BufferedReader br = new BufferedReader(isr))
				{
					br.lines().forEach(l -> {
						try
						{
							String line = l.split(COMMENT_CHAR, 2)[0].trim();
							if (line.isBlank())
							{
								return;
							}
							int srcx = Integer.parseInt(line.substring(0, 1));
							int srcy = Integer.parseInt(line.substring(1, 2));
							char obs = line.charAt(2);
							int dstx = Integer.parseInt(line.substring(3, 4));
							int dsty = Integer.parseInt(line.substring(4, 5));
							neighbours.merge(BrimhavenAgilityArenaLocation.of(srcx, srcy),
								List.of(BrimhavenAgilityArenaNeighbour.of(dstx, dsty, BrimhavenAgilityArenaObstacle.from(obs))),
								(l1, l2) -> Stream.concat(l1.stream(), l2.stream()).collect(Collectors.toUnmodifiableList()));
						}
						catch (Exception e)
						{
							log.error("exception when handling line {}", l, e);
						}
					});
					loaded = true;
				}
			}
		}
		catch (IOException e)
		{
			log.error("failed to load Brimhaven agility arena layout file", e);
		}
	}

	public synchronized static void unload()
	{
		neighbours.clear();
		loaded = false;
	}
}

package com.kagof.runelite.plugins.brimhavenagility.model;

import lombok.ToString;
import lombok.Value;

@Value
@ToString
public class BrimhavenAgilityArenaNeighbour
{
	BrimhavenAgilityArenaLocation location;
	BrimhavenAgilityArenaObstacle obstacle;

	public static BrimhavenAgilityArenaNeighbour of(int x, int y, BrimhavenAgilityArenaObstacle obstacle)
	{
		return new BrimhavenAgilityArenaNeighbour(BrimhavenAgilityArenaLocation.of(x, y), obstacle);
	}
}

package com.kagof.runelite.plugins.brimhavenagility.model;

import com.kagof.runelite.plugins.brimhavenagility.BrimhavenAgilityConfig;
import com.kagof.runelite.plugins.brimhavenagility.BrimhavenAgilityPathFinder;
import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum BrimhavenAgilityArenaObstacle
{
	// Blade takes 4 to 6 ticks, so averaging it as 5
	BLADE('b', 1, 5, BrimhavenAgilityConfig::bladeAvoid),
	ROPE_SWING('s', 1, 4, BrimhavenAgilityConfig::ropeSwingAvoid),
	LOW_WALL('w', 1, 5, BrimhavenAgilityConfig::lowWallAvoid),
	PLANK('p', 1, 9, BrimhavenAgilityConfig::plankAvoid),
	BALANCING_ROPE('r', 1, 9, BrimhavenAgilityConfig::balancingRopeAvoid),
	LOG_BALANCE('o', 1, 9, BrimhavenAgilityConfig::logBalanceAvoid),
	BALANCING_LEDGE('l', 1, 9, BrimhavenAgilityConfig::balancingLedgeAvoid),
	MONKEY_BARS('m', 1, 13, BrimhavenAgilityConfig::monkeyBarsAvoid),
	PILLAR('i', 1, 9, BrimhavenAgilityConfig::pillarAvoid),
	PRESSURE_PAD('a', 20, 4, BrimhavenAgilityConfig::pressurePadAvoid),
	FLOOR_SPIKES('f', 20, 4, BrimhavenAgilityConfig::floorSpikesAvoid),
	HAND_HOLDS('h', 20, 10, BrimhavenAgilityConfig::handHoldsAvoid),
	SPINNING_BLADES('n', 40, 5, BrimhavenAgilityConfig::spinningBladesAvoid),
	DARTS('d', 40, 10, BrimhavenAgilityConfig::dartsAvoid),
	IMPASSABLE('x', 999999, BrimhavenAgilityPathFinder.NEVER_USE_WEIGHT, i -> true);

	private final char shortForm;
	private final int minLevel;
	private final int weight; // weights are taken from the number of ticks each obstacle takes according to the wiki
	private final Function<BrimhavenAgilityConfig, Boolean> avoidFunction;

	private static final Map<Character, BrimhavenAgilityArenaObstacle> shortToObs = Arrays
		.stream(BrimhavenAgilityArenaObstacle.values())
		.collect(Collectors.toMap(BrimhavenAgilityArenaObstacle::getShortForm, Function.identity()));

	public static BrimhavenAgilityArenaObstacle from(char shortForm)
	{
		return shortToObs.getOrDefault(shortForm, IMPASSABLE);
	}
}

package com.kagof.runelite.plugins.brimhavenagility.model;

import java.util.HashMap;

/**
 * A {@link HashMap} that always provides a default value if one isn't found in the map.
 */
public class MapWithDefault<T, V> extends HashMap<T, V>
{
	private final V def;

	public MapWithDefault(final V def)
	{
		this.def = def;
	}

	@Override
	public V get(final Object key)
	{
		return super.getOrDefault(key, def);
	}
}

package com.kagof.runelite.plugins.brimhavenagility.model;

import java.util.List;
import java.util.stream.Collectors;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;

/**
 * A path between two points in the agility arena.
 */
@Value
public class BrimhavenAgilityArenaPath
{
	List<BrimhavenAgilityArenaLocation> locations;

	public int size()
	{
		return locations.size();
	}

	public boolean hasPathChanged(final WorldPoint playerLocation, final WorldPoint dispenserLocation)
	{
		if (locations.isEmpty())
		{
			return true;
		}
		return !locations.get(0).equals(BrimhavenAgilityArenaLocation.fromWorldPoint(playerLocation))
			|| !locations.get(locations.size() - 1).equals(BrimhavenAgilityArenaLocation.fromWorldPoint(dispenserLocation));
	}

	/**
	 * @return the sub-path of this path which starts at the {@code newStartLocation} and ends at the
	 * {@code newEndLocation}. If such a sub-path does not exist, returns {@code null}.
	 */
	public BrimhavenAgilityArenaPath subPath(final WorldPoint newStartLocation, final WorldPoint newEndLocation)
	{
		BrimhavenAgilityArenaLocation sl = BrimhavenAgilityArenaLocation.fromWorldPoint(newStartLocation);
		BrimhavenAgilityArenaLocation el = BrimhavenAgilityArenaLocation.fromWorldPoint(newEndLocation);
		int sIndex = locations.indexOf(sl);
		if (sIndex < 0)
		{
			return null;
		}
		int eIndex = locations.indexOf(el);
		if (eIndex < 0)
		{
			return null;
		}
		if (eIndex < sIndex)
		{
			return null;
		}
		if (sIndex == 0 && eIndex == locations.size() - 1)
		{
			return this;
		}
		return new BrimhavenAgilityArenaPath(List.copyOf(locations.subList(sIndex, eIndex + 1)));
	}

	public List<WorldPoint> toWorldPoints()
	{
		return locations.stream()
			.map(BrimhavenAgilityArenaLocation::toCenteredWorldPoint)
			.collect(Collectors.toList());
	}

	@Override
	public String toString()
	{
		return locations.stream()
			.map(BrimhavenAgilityArenaLocation::toString)
			.collect(Collectors.joining("->"));
	}
}

package com.kagof.runelite.plugins.brimhavenagility.model;

import com.kagof.runelite.plugins.brimhavenagility.BrimhavenAgilityPlugin;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;

/**
 * A location of a platform in the Agility Arena. Each platform is given an x & y coordinate from 0 to 4, starting from
 * the southwest corner. These points may be mapped to or from a {@link WorldPoint}.
 */
@Value
@EqualsAndHashCode
public class BrimhavenAgilityArenaLocation
{
	private static final int PLATFORM_CENTER_OFFSET = 5;
	private static final int PLATFORM_WIDTH = 11;
	private static final int PLATFORM_HEIGHT = 11;
	private static final int PLATFORM_START_X = 9;
	private static final int PLATFORM_START_Y = 10;
	private static final int PLANE = 3;

	int x;
	int y;

	/**
	 * @return the WorldPoint of the center of the platform.
	 */
	public WorldPoint toCenteredWorldPoint()
	{
		return WorldPoint.fromRegion(BrimhavenAgilityPlugin.AGILITY_ARENA_REGION_ID,
			PLATFORM_START_X + (x * PLATFORM_WIDTH),
			PLATFORM_START_Y + (y * PLATFORM_HEIGHT),
			3);
	}

	public static BrimhavenAgilityArenaLocation fromWorldPoint(WorldPoint worldPoint)
	{
		if (worldPoint == null)
		{
			return null;
		}
		if (worldPoint.getRegionID() != BrimhavenAgilityPlugin.AGILITY_ARENA_REGION_ID)
		{
			return null;
		}

		// adding the offset changes the origin from the center of the platform to the sw corner.
		// dividing by width/height rounds down to choose the correct platform.
		int x = (worldPoint.getRegionX() + PLATFORM_CENTER_OFFSET - PLATFORM_START_X) / PLATFORM_WIDTH;
		int y = (worldPoint.getRegionY() + PLATFORM_CENTER_OFFSET - PLATFORM_START_Y) / PLATFORM_HEIGHT;

		if (x < 0 || y < 0 || x > 4 || y > 4)
		{
			return null; // not on a platform
		}
		return new BrimhavenAgilityArenaLocation(x, y);
	}

	public static BrimhavenAgilityArenaLocation of(int x, int y)
	{
		return new BrimhavenAgilityArenaLocation(x, y);
	}

	@Override
	public String toString()
	{
		return "(" + x + ", " + y + ")";
	}
}

package com.kagof.runelite.plugins.brimhavenagility;

import com.google.inject.Provides;
import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaPath;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "Brimhaven Agility"
)
public class BrimhavenAgilityPlugin extends Plugin
{
	public static final int AGILITY_ARENA_REGION_ID = 11157;

	@Getter
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BrimhavenAgilityOverlay overlay;

	@Inject
	private BrimhavenAgilityConfig config;

	@Getter
	private int agilityLevel;
	@Getter
	private BrimhavenAgilityArenaPath currentPath;
	@Getter
	private boolean ticketAvailable;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		agilityLevel = client.getBoostedSkillLevel(Skill.AGILITY);
		currentPath = null;
		ticketAvailable = true;
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		BrimhavenAgilityArenaNeighbourDigest.unload();
		agilityLevel = 0;
		currentPath = null;
		ticketAvailable = true;
	}

	@Subscribe
	public void onGameTick(final GameTick tick)
	{
		recomputePathIfNeeded();
	}

	@Subscribe
	public void onVarbitChanged(final VarbitChanged event)
	{
		if (event.getVarbitId() == VarbitID.AGILITYARENA_TICKETAVAILABLE)
		{
			ticketAvailable = event.getValue() > 0;
		}
	}

	private void recomputePathIfNeeded()
	{
		boolean changed = false;
		if (isInAgilityArena() && ticketAvailable)
		{
			WorldPoint ticketPosition = client.getHintArrowPoint();
			WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
			if (currentPath != null)
			{
				if (currentPath.hasPathChanged(playerLocation, ticketPosition))
				{
					// see if we can use a sub-path
					currentPath = currentPath.subPath(playerLocation, ticketPosition);
					changed = true;
				}
			}
			if (currentPath == null)
			{
				currentPath = BrimhavenAgilityPathFinder.findPath(playerLocation, ticketPosition, agilityLevel, config);
				changed = true;
			}
		}
		else if (currentPath != null)
		{
			currentPath = null;
			ticketAvailable = true;
			changed = true;
		}
		if (changed)
		{
			log.debug("New Brimhaven Agility Arena path: {}", currentPath);
		}
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged configChanged)
	{
		if (configChanged.getGroup().equals("brimhavenagility"))
		{
			currentPath = null;
			clientThread.invokeLater(this::recomputePathIfNeeded);
		}
	}

	@Subscribe
	public void onStatChanged(final StatChanged statChanged)
	{
		if (statChanged.getSkill() == Skill.AGILITY)
		{
			agilityLevel = statChanged.getBoostedLevel();
			currentPath = null;
			recomputePathIfNeeded();
		}

	}

	@Provides
	BrimhavenAgilityConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BrimhavenAgilityConfig.class);
	}


	public boolean isInAgilityArena()
	{
		Player local = client.getLocalPlayer();
		if (local == null)
		{
			return false;
		}

		WorldPoint location = local.getWorldLocation();
		if (location == null)
		{
			return false;
		}
		return location.getRegionID() == AGILITY_ARENA_REGION_ID;
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.kagof.runelite.plugins.brimhavenagility.questhelper;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;

/**
 * The contents of this file were taken from the <a href="https://github.com/Zoinkwiz/quest-helper">Quest Helper plugin</a>.
 */
public class WorldLines
{
	public static Line2D.Double getWorldLines(Client client, LocalPoint startLocation, LocalPoint endLocation)
	{
		final int plane = client.getPlane();

		final int startX = startLocation.getX();
		final int startY = startLocation.getY();
		final int endX = endLocation.getX();
		final int endY = endLocation.getY();

		final int sceneX = startLocation.getSceneX();
		final int sceneY = startLocation.getSceneY();

		if (sceneX < 0 || sceneY < 0 || sceneX >= Constants.SCENE_SIZE || sceneY >= Constants.SCENE_SIZE)
		{
			return null;
		}

		final int startHeight = Perspective.getTileHeight(client, startLocation, plane);
		final int endHeight = Perspective.getTileHeight(client, endLocation, plane);

		Point p1 = Perspective.localToCanvas(client, startX, startY, startHeight);
		Point p2 = Perspective.localToCanvas(client, endX, endY, endHeight);

		if (p1 == null || p2 == null)
		{
			return null;
		}

		return new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
	}

	public static void drawLinesOnWorld(Graphics2D graphics, Client client, List<WorldPoint> linePoints,
										Color color)
	{
		for (int i = 0; i < linePoints.size() - 1; i++)
		{
			LocalPoint startLp = QuestPerspective.getInstanceLocalPoint(client, linePoints.get(i));
			LocalPoint endLp = QuestPerspective.getInstanceLocalPoint(client, linePoints.get(i + 1));
			if (startLp == null || endLp == null)
			{
				continue;
			}

			Line2D.Double newLine = getWorldLines(client, startLp, endLp);
			if (newLine != null)
			{
				OverlayUtil.renderPolygon(graphics, newLine, color);
			}
		}
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.kagof.runelite.plugins.brimhavenagility.questhelper;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import net.runelite.api.Client;
import static net.runelite.api.Constants.CHUNK_SIZE;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;


/**
 * The contents of this file were taken from the <a href="https://github.com/Zoinkwiz/quest-helper">Quest Helper plugin</a>.
 */
public class QuestPerspective
{
	public static Collection<WorldPoint> toLocalInstance(Client client, WorldPoint worldPoint)
	{
		if (!client.isInInstancedRegion())
		{
			return Collections.singleton(worldPoint);
		}

		// find instance chunks using the template point. there might be more than one.
		List<WorldPoint> worldPoints = new ArrayList<>();

		int[][][] instanceTemplateChunks = client.getInstanceTemplateChunks();
		for (int z = 0; z < instanceTemplateChunks.length; ++z)
		{
			for (int x = 0; x < instanceTemplateChunks[z].length; ++x)
			{
				for (int y = 0; y < instanceTemplateChunks[z][x].length; ++y)
				{
					int chunkData = instanceTemplateChunks[z][x][y];
					int rotation = chunkData >> 1 & 0x3;
					int templateChunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
					int templateChunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
					if (worldPoint.getX() >= templateChunkX && worldPoint.getX() < templateChunkX + CHUNK_SIZE
						&& worldPoint.getY() >= templateChunkY && worldPoint.getY() < templateChunkY + CHUNK_SIZE)
					{
						WorldPoint p =
							new WorldPoint(client.getBaseX() + x * CHUNK_SIZE + (worldPoint.getX() & (CHUNK_SIZE - 1)),
								client.getBaseY() + y * CHUNK_SIZE + (worldPoint.getY() & (CHUNK_SIZE - 1)),
								z);
						p = rotate(p, rotation);
						if (p.isInScene(client))
						{
							worldPoints.add(p);
						}
					}
				}
			}
		}
		return worldPoints;
	}

	private static WorldPoint rotate(WorldPoint point, int rotation)
	{
		int chunkX = point.getX() & ~(CHUNK_SIZE - 1);
		int chunkY = point.getY() & ~(CHUNK_SIZE - 1);
		int x = point.getX() & (CHUNK_SIZE - 1);
		int y = point.getY() & (CHUNK_SIZE - 1);
		switch (rotation)
		{
			case 1:
				return new WorldPoint(chunkX + y, chunkY + (CHUNK_SIZE - 1 - x), point.getPlane());
			case 2:
				return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - x), chunkY + (CHUNK_SIZE - 1 - y), point.getPlane());
			case 3:
				return new WorldPoint(chunkX + (CHUNK_SIZE - 1 - y), chunkY + x, point.getPlane());
		}
		return point;
	}

	public static LocalPoint getInstanceLocalPoint(Client client, WorldPoint wp)
	{
		WorldPoint instanceWorldPoint = getInstanceWorldPoint(client, wp);
		if (instanceWorldPoint == null)
		{
			return null;
		}

		return LocalPoint.fromWorld(client, instanceWorldPoint);
	}

	public static WorldPoint getInstanceWorldPoint(Client client, WorldPoint wp)
	{
		Collection<WorldPoint> points = QuestPerspective.toLocalInstance(client, wp);

		for (WorldPoint point : points)
		{
			if (point != null)
			{
				return point;
			}
		}
		return null;
	}
}

package com.kagof.runelite.plugins.brimhavenagility;

import com.kagof.runelite.plugins.brimhavenagility.model.BrimhavenAgilityArenaPath;
import com.kagof.runelite.plugins.brimhavenagility.questhelper.WorldLines;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class BrimhavenAgilityOverlay extends Overlay
{
	private final BrimhavenAgilityPlugin plugin;
	private final BrimhavenAgilityConfig config;

	@Inject
	public BrimhavenAgilityOverlay(BrimhavenAgilityPlugin plugin, BrimhavenAgilityConfig config)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		if (!plugin.isInAgilityArena() || !plugin.isTicketAvailable())
		{
			return null;
		}
		BrimhavenAgilityArenaPath currentPath = plugin.getCurrentPath();
		if (currentPath != null && currentPath.size() > 1)
		{
			WorldLines.drawLinesOnWorld(graphics2D, plugin.getClient(), currentPath.toWorldPoints(), config.pathColour());
		}
		return null;
	}
}

package com.kagof.runelite.plugins.brimhavenagility;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BrimhavenAgilityPluginTest
{
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BrimhavenAgilityPlugin.class);
		RuneLite.main(args);
	}
}

