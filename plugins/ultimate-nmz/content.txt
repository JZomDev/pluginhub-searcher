package com.github.iant89.ultimatenmz;

import com.github.iant89.ultimatenmz.drivers.SineDriver;

public class AlphaSineDriverTest {

    public static void main(String[] args) {

        // 30 = 1906
        // 31 = 1968, 1953
        SineDriver alphaDriver = new SineDriver(0.125f, 0.75f, 20);

        System.out.println("Step = " + alphaDriver.getStep());

        boolean minReached = false;
        boolean maxReached = false;

        long startTimer = System.currentTimeMillis();

        StringBuilder sb = new StringBuilder();

        float previousValue = Float.MAX_VALUE;
        while(true) {
            float value = alphaDriver.getValue();

            if(value == alphaDriver.getMaximum()) {
                maxReached = true;
            } else if(value == alphaDriver.getMinimum()) {
                minReached = true;
            }

            if(minReached && maxReached) {
                final long endTime = System.currentTimeMillis();
                double seconds = ((endTime - startTimer) / 1000.0);
                long milliseconds = endTime - startTimer;
                if(seconds < 1) {
                    sb.append("Done, Took " + seconds + " Seconds\n\n");
                } else {
                    sb.append("Done, Took " + milliseconds + " Milliseconds.");
                }

                break;
            }

            if(previousValue != Float.MAX_VALUE) {
                if(previousValue != value) {
                    sb.append("" + value + "\n");
                    previousValue = value;
                }
            } else {
                previousValue = value;
            }
        }

        System.out.println("" + sb.toString());

    }

}

package com.github.iant89.ultimatenmz;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class UltimateNMZPluginTest {

	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(UltimateNMZPlugin.class);
		RuneLite.main(args);
	}
}
package com.github.iant89.ultimatenmz;

import com.github.iant89.ultimatenmz.notifications.VisualNotificationEffectType;
import com.github.iant89.ultimatenmz.notifications.VisualNotificationSpeed;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("ultimatenmz")
public interface UltimateNMZConfig extends Config {


    @ConfigSection(
            name = "General",
            description = "General Configuration",
            position = 50,
            closedByDefault = false
    )
    String generalSection = "general";

    @ConfigSection(
            name = "Minimum Hitpoints",
            description = "Options pertaining to Minimum Hitpoints.",
            position = 51,
            closedByDefault = false
    )
    String minimumHitpointsSection = "minimumHitpoints";

    @ConfigSection(
            name = "Maximum Hitpoints",
            description = "Options pertaining to Maximum Hitpoints.",
            position = 52,
            closedByDefault = false
    )
    String maximumHitpointsSection = "maximumHitpoints";

    @ConfigSection(
            name = "Recurrent Damage Power-Up",
            description = "Options pertaining to Recurrent Damage Power-Ups.",
            position = 53,
            closedByDefault = false
    )
    String recurrentDamagePowerupSection = "recurrentDamagePowerup";

    @ConfigSection(
            name = "Zapper Power-Up",
            description = "Options pertaining to Zapper Power-Ups.",
            position = 54,
            closedByDefault = false
    )
    String zapperPowerupSection = "zapperPowerup";

    @ConfigSection(
            name = "Power Surge Power-Up",
            description = "Options pertaining to Power Surge Power-Ups.",
            position = 55,
            closedByDefault = false
    )
    String powerSurgePowerupSection = "powerSurgePowerup";

    @ConfigSection(
            name = "Ultimate Force Power-Up",
            description = "Options pertaining to Ultimate Force Power-Ups.",
            position = 56,
            closedByDefault = false
    )
    String ultimateForcePowerupSection = "ultimateForcePowerup";

    @ConfigSection(
            name = "Absorption",
            description = "Options pertaining to Absorption Potions.",
            position = 57,
            closedByDefault = false
    )
    String absorptionSection = "absorption";

    @ConfigSection(
            name = "Overload",
            description = "Options pertaining to Overloads Potions.",
            position = 58,
            closedByDefault = false
    )
    String overloadSection = "overloads";

    /*
    @ConfigSection(
            name = "Super Magic Potions",
            description = "Options pertaining to Super Magic Potions.",
            position = 59,
            closedByDefault = false
    )
    String superMagicPotionSection = "supermagic";

    @ConfigSection(
            name = "Super Ranging Potions",
            description = "Options pertaining to Super Ranging Potions.",
            position = 60,
            closedByDefault = false
    )
    String superRangingPotionSection = "superranging";
     */

    @ConfigSection(
            name = "Paint",
            description = "Options pertaining to the Paint.",
            position = 59,
            closedByDefault = false
    )
    String paintSection = "paint";

    /*
     * GENERAL SECTION
     */

    @ConfigItem(
            keyName = "visualAlerts",
            name = "Visual Notifications",
            description = "Toggles visual notifications.",
            position = 0,
            section = generalSection
    )
    default boolean visualAlerts() {
        return true;
    }

    @ConfigItem(
            keyName = "nativeAlerts",
            name = "Native Notifications",
            description = "Toggles native notifications.",
            position = 1,
            section = generalSection
    )
    default boolean nativeAlerts() {
        return true;
    }

    /*
     * MINIMUM HP SECTION
     */

    @ConfigItem(
            keyName = "minimumHPNotification",
            name = "Show Notifications",
            description = "Enables notifications when your HP gets below the threshold.",
            position = 0,
            section = minimumHitpointsSection
    )
    default boolean minimumHPNotification() {
        return true;
    }

    @ConfigItem(
            keyName = "minimumHPThresholdValue",
            name = "Threshold",
            description = "The Minimum HP before triggering a alert.",
            position = 1,
            section = minimumHitpointsSection
    )
    default int minimumHPThresholdValue() {
        return 1;
    }

    @ConfigItem(
            keyName = "showMinimumHPIcon",
            name = "Show Icon",
            description = "Toggles if the Hitpoints icon is drawn on the visual notification.",
            position = 2,
            section = minimumHitpointsSection
    )
    default boolean showMinimumHPIcon() {
        return true;
    }

    @ConfigItem(
            keyName = "minimumHPAlertColor",
            name = "Color",
            description = "The color of the Hitpoints BELOW Threshold Notification.",
            position = 3,
            section = minimumHitpointsSection
    )
    default Color minimumHPAlertColor() {
        return new Color(221, 79, 1);
    }

    @ConfigItem(
            keyName = "minimumHPEffectType",
            name = "Effect",
            description = "The type of effect for Hitpoints BELOW Threshold Notification.",
            position = 4,
            section = minimumHitpointsSection
    )
    default VisualNotificationEffectType minimumHPEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "minimumHPEffectSpeed",
            name = "Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 5,
            section = minimumHitpointsSection
    )
    default VisualNotificationSpeed minimumHPEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * MAXIMUM HP SECTION
     */

    @ConfigItem(
            keyName = "maximumHPNotification",
            name = "Show Notifications",
            description = "Enables notifications when your HP gets above the threshold.",
            position = 0,
            section = maximumHitpointsSection
    )
    default boolean maximumHPNotification() {
        return true;
    }

    @ConfigItem(
            keyName = "maximumHPThreshold",
            name = "Threshold",
            description = "The Maximum HP before triggering a alert.",
            position = 1,
            section = maximumHitpointsSection
    )
    default int maximumHPThresholdValue() {
        return 2;
    }

    @ConfigItem(
            keyName = "showMaximumHPIcon",
            name = "Show Icon",
            description = "Toggles if the Hitpoints icon is drawn on the visual notification.",
            position = 2,
            section = maximumHitpointsSection
    )
    default boolean showMaximumHPIcon() {
        return true;
    }

    @ConfigItem(
            keyName = "maximumHPAlertColor",
            name = "Color",
            description = "The color of the Hitpoints ABOVE Threshold Notification.",
            position = 3,
            section = maximumHitpointsSection
    )
    default Color maximumHPAlertColor() {
        return new Color(221, 79, 1);
    }

    @ConfigItem(
            keyName = "maximumHPEffectType",
            name = "Effect",
            description = "The type of effect for Hitpoints ABOVE Threshold Notification.",
            position = 4,
            section = maximumHitpointsSection
    )
    default VisualNotificationEffectType maximumHPEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "maximumHPEffectSpeed",
            name = "Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 5,
            section = maximumHitpointsSection
    )
    default VisualNotificationSpeed maximumHPEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * RECURRENT DAMAGE POWER UP SECTION
     */

    @ConfigItem(
            keyName = "drawrecurrentdamagelocation",
            name = "Show Spawn Location",
            description = "Toggles highlighting the tile where the Recurrent Damage Spawned.",
            position = 0,
            section = recurrentDamagePowerupSection
    )
    default boolean drawRecurrentDamageLocation() {
        return true;
    }

    @ConfigItem(
            keyName = "recurrentdamagenotification",
            name = "Recurrent Damage Notification",
            description = "Toggles notifications when a Recurrent Damage Power-up is Spawned.",
            position = 1,
            section = recurrentDamagePowerupSection
    )
    default boolean recurrentDamageNotification() {
        return true;
    }

    @ConfigItem(
            keyName = "recurrentdamageAlertColor",
            name = "Color",
            description = "The color of the Recurrent Damage Power-Up Notification.",
            position = 2,
            section = recurrentDamagePowerupSection
    )
    default Color recurrentDamageAlertColor() {
        return new Color(255, 0, 21);
    }

    @ConfigItem(
            keyName = "recurrentDamageEffectType",
            name = "Effect",
            description = "The type of effect for Recurrent Damage Power-Up Notification.",
            position = 3,
            section = recurrentDamagePowerupSection
    )
    default VisualNotificationEffectType recurrentDamageEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "recurrentDamageEffectSpeed",
            name = "Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 4,
            section = recurrentDamagePowerupSection
    )
    default VisualNotificationSpeed recurrentDamageEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * ZAPPER POWER UP SECTION
     */

    @ConfigItem(
            keyName = "drawzapperlocation",
            name = "Show Spawn Location",
            description = "Toggles highlighting the tile where the Zapper Spawned.",
            position = 0,
            section = zapperPowerupSection
    )
    default boolean drawZapperLocation() {
        return true;
    }

    @ConfigItem(
            keyName = "zappernotification",
            name = "Zapper Notification",
            description = "Toggles notifications when a Zapper Power-up is Spawned.",
            position = 1,
            section = zapperPowerupSection
    )
    default boolean zapperNotification() {
        return true;
    }

    @ConfigItem(
            keyName = "zapperAlertColor",
            name = "Color",
            description = "The color of the Zapper Power-Up Notification.",
            position = 2,
            section = zapperPowerupSection
    )
    default Color zapperAlertColor() {
        return new Color(161, 0, 255);
    }

    @ConfigItem(
            keyName = "zapperEffectType",
            name = "Effect",
            description = "The type of effect for Zapper Power-Up Notification.",
            position = 3,
            section = zapperPowerupSection
    )
    default VisualNotificationEffectType zapperEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "zapperEffectSpeed",
            name = "Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 4,
            section = zapperPowerupSection
    )
    default VisualNotificationSpeed zapperEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * POWER SURGE POWER UP SECTION
     */

    @ConfigItem(
            keyName = "drawpowersurgelocation",
            name = "Show Spawn Location",
            description = "Toggles highlighting the tile where the Power Surge Spawned.",
            position = 0,
            section = powerSurgePowerupSection
    )
    default boolean drawPowerSurgeLocation() {
        return true;
    }

    @ConfigItem(
            keyName = "powersurgenotification",
            name = "Power Surge Notification",
            description = "Toggles notifications when a Power Surge Power-up is Spawned.",
            position = 1,
            section = powerSurgePowerupSection
    )
    default boolean powerSurgeNotification() {
        return true;
    }

    @ConfigItem(
            keyName = "powerSurgeAlertColor",
            name = "Color",
            description = "The color of the Power Surge Power-Up Notification.",
            position = 2,
            section = powerSurgePowerupSection
    )
    default Color powerSurgeAlertColor() {
        return new Color(255, 221, 0);
    }

    @ConfigItem(
            keyName = "powerSurgeEffectType",
            name = "Effect",
            description = "The type of effect for Power Surge Power-Up Notification.",
            position = 3,
            section = powerSurgePowerupSection
    )
    default VisualNotificationEffectType powerSurgeEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "powerSurgeEffectSpeed",
            name = "Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 4,
            section = powerSurgePowerupSection
    )
    default VisualNotificationSpeed powerSurgeEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * ULTIMATE FORCE POWER UP SECTION
     */

    @ConfigItem(
            keyName = "ultimateforcelocation",
            name = "Show Spawn Location",
            description = "Toggles highlighting the tile where the Ultimate Force Spawned.",
            position = 0,
            section = ultimateForcePowerupSection
    )
    default boolean drawUltimateForceLocation() {
        return true;
    }

    @ConfigItem(
            keyName = "ultimateforcenotification",
            name = "Ultimate Force Notification",
            description = "Toggles notifications when a Ultimate Force Power-up is Spawned.",
            position = 1,
            section = ultimateForcePowerupSection
    )
    default boolean ultimateForceNotification() {
        return true;
    }

    @ConfigItem(
            keyName = "ultimateForceAlertColor",
            name = "Color",
            description = "The color of the Ultimate Force Power-Up Notification.",
            position = 2,
            section = ultimateForcePowerupSection
    )
    default Color ultimateForceAlertColor() {
        return new Color(255, 255, 255);
    }

    @ConfigItem(
            keyName = "ultimateForceEffectType",
            name = "Effect",
            description = "The type of effect for Ultimate Force Power-Up Notification.",
            position = 3,
            section = ultimateForcePowerupSection
    )
    default VisualNotificationEffectType ultimateForceEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "ultimateForceEffectSpeed",
            name = "Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 4,
            section = ultimateForcePowerupSection
    )
    default VisualNotificationSpeed ultimateForceEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * OVERLOAD SECTION
     */
    @ConfigItem(
            keyName = "overloadRunoutNotification",
            name = "Warning Notification",
            description = "Toggles notifications when your overload is about to run out.",
            position = 0,
            section = overloadSection
    )
    default boolean overloadRunoutNotification() {
        return true;
    }

    @Range(
            min = 0,
            max = 120
    )
    @ConfigItem(
            keyName = "overloadRunoutTime",
            name = "Warning Seconds",
            description = "The length in seconds before your Overload runs out, to notify you.",
            position = 1,
            section = overloadSection
    )
    default int overloadRunoutTime() {
        return 20;
    }

    @ConfigItem(
            keyName = "showOverloadIcon",
            name = "Show Icon",
            description = "Toggles if a Overload Potion icon is drawn on the visual notification.",
            position = 2,
            section = overloadSection
    )
    default boolean showOverloadIcon() {
        return true;
    }

    @ConfigItem(
            keyName = "overloadRunOutColor",
            name = "Warning Color",
            description = "The color of the Overload Run-out Warning Notification.",
            position = 3,
            section = overloadSection
    )
    default Color overloadRunOutColor() {
        return new Color(93, 91, 91);
    }

    @ConfigItem(
            keyName = "overloadRunOutEffectType",
            name = "Warning Effect",
            description = "The type of effect for Overload Run-out Warning Notification.",
            position = 4,
            section = overloadSection
    )
    default VisualNotificationEffectType overloadRunOutEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "overloadRunOutEffectSpeed",
            name = "Warning Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 5,
            section = overloadSection
    )
    default VisualNotificationSpeed overloadRunOutEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    @ConfigItem(
            keyName = "overloadExpiredNotification",
            name = "Expired Notification",
            description = "Toggles notifications when your overload is has run out.",
            position = 6,
            section = overloadSection
    )
    default boolean overloadExpiredNotification() {
        return true;
    }
    @ConfigItem(
            keyName = "overloadExpiredColor",
            name = "Expired Color",
            description = "The color of the Overload Expired Notification.",
            position = 7,
            section = overloadSection
    )
    default Color overloadExpiredColor() {
        return new Color(35, 35, 35);
    }

    @ConfigItem(
            keyName = "overloadExpiredEffectType",
            name = "Expired Effect",
            description = "The type of effect for Overload Expired Notification.",
            position = 8,
            section = overloadSection
    )
    default VisualNotificationEffectType overloadExpiredEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "overloadExpiredEffectSpeed",
            name = "Expired Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 9,
            section = overloadSection
    )
    default VisualNotificationSpeed overloadExpiredEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * ABSORPTION SECTION
     */

    @ConfigItem(
            keyName = "absorptionnotification",
            name = "Absorption Notification",
            description = "Toggles notifications when your absorption points gets below your threshold",
            position = 0,
            section = absorptionSection
    )
    default boolean absorptionNotification() {
        return true;
    }


    @ConfigItem(
            keyName = "absorptionthreshold",
            name = "Minimum Threshold",
            description = "The Minimum Absorption before triggering a alert.",
            position = 1,
            section = absorptionSection
    )
    default int absorptionThreshold() {
        return 50;
    }

    @ConfigItem(
            keyName = "showAbsorptionIcon",
            name = "Show Icon",
            description = "Toggles if a Absorption Potion icon is drawn on the visual notification.",
            position = 2,
            section = absorptionSection
    )
    default boolean showAbsorptionIcon() {
        return true;
    }

    @ConfigItem(
            keyName = "absorptionAlertColor",
            name = "Color",
            description = "The color of the Absorption BELOW Threshold Notification.",
            position = 3,
            section = absorptionSection
    )
    default Color absorptionAlertColor() {
        return new Color(0, 179, 255);
    }

    @ConfigItem(
            keyName = "absorptionEffectType",
            name = "Effect",
            description = "The type of effect for Absorption BELOW Threshold Notification.",
            position = 4,
            section = absorptionSection
    )
    default VisualNotificationEffectType absorptionEffectType() {
        return VisualNotificationEffectType.FADE_IN_OUT;
    }

    @ConfigItem(
            keyName = "absorptionEffectSpeed",
            name = "Speed",
            description = "The speed of the notification effect, This does nothing if effect type is `SOLID`.",
            position = 5,
            section = absorptionSection
    )
    default VisualNotificationSpeed absorptionEffectSpeed() {
        return VisualNotificationSpeed.DEFAULT;
    }

    /*
     * PAINT SECTION
     */

    @ConfigItem(
            keyName = "removeNMZOverlay",
            name = "Override NMZ overlay",
            description = "Removes the Nightmare Zone Point overlay.",
            position = 0,
            section = paintSection
    )
    default boolean removeNMZOverlay() {
        return true;
    }

    @ConfigItem(
            keyName = "showPointsPerHour",
            name = "Show Points Per Hour",
            description = "Shows the Estimated Points Per Hour",
            position = 1,
            section = paintSection
    )
    default boolean showPointsPerHour() {
        return true;
    }

    @ConfigItem(
            keyName = "showTotalPoints",
            name = "Show Total Points Earned",
            description = "Shows the total points you have earned.",
            position = 2,
            section = paintSection
    )
    default boolean showTotalPoints() {
        return true;
    }
}

package com.github.iant89.ultimatenmz.notifications;

public enum VisualNotificationEffectType {
    FADE_IN_OUT("Fade IN/OUT"),
    FLASH("Flash"),
    SOLID("Solid"),

    ;

    final String name;

    VisualNotificationEffectType(String name) {
        this.name = name;
    }

    public String toString() {
        return this.name;
    }
}

package com.github.iant89.ultimatenmz.notifications;

import com.github.iant89.ultimatenmz.UltimateNMZConfig;
import com.github.iant89.ultimatenmz.drivers.ConstantDriver;
import com.github.iant89.ultimatenmz.drivers.SineDriver;
import com.github.iant89.ultimatenmz.drivers.ValueDriver;
import com.github.iant89.ultimatenmz.utils.InventoryUtils;
import net.runelite.api.Client;
import net.runelite.api.ItemID;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class VisualNotificationManager {

    private static ArrayList<VisualNotification> notificationList = new ArrayList<>();
    private static HashMap<VisualNotificationType, Long> notificationBlockMap = new HashMap<>();
    @Inject
    private Client client;

    @Inject
    private UltimateNMZConfig config;


    @Inject
    protected VisualNotificationManager(Client client, UltimateNMZConfig config) {
        this.client = client;
        this.config = config;
    }

    public void blockNotification(VisualNotificationType type, int seconds) {
        cleanNotifications();

        if(seconds <= 0) {
            return;
        }

        if(notificationBlockMap.containsKey(type)) {
            notificationBlockMap.remove(type);
        }

        notificationBlockMap.put(type, System.currentTimeMillis() + (seconds * 1000));
    }

    public void addNotification(VisualNotification notification) {
        cleanNotifications();

        if(notificationBlockMap.containsKey(notification.getType())) {
            return;
        }

        notificationList.add(notification);
    }

    public synchronized void removeAll() {
        notificationList.clear();
    }

    public synchronized void createNotification(VisualNotificationType type) {
        VisualNotification visualNotification = getNotificationByType(type);
        long notificationLength = -1;

        cleanNotifications();

        if(notificationBlockMap.containsKey(type)) {
            return;
        }

        if(visualNotification != null) {
            if(visualNotification.getLength() == -1) {
                return;
            } else {
                removeNotification(type);
            }
        }

        switch (type) {

            case HP_ABOVE_THRESHOLD:
            case OVERLOAD_ALMOST_EXPIRED:
                notificationLength = -1;
                break;

            case OVERLOAD_EXPIRED:
                // Only allow creation of alert if we have OVERLOAD pots in inventory.
                if(!InventoryUtils.hasOneOfItems(client, ItemID.OVERLOAD_4, ItemID.OVERLOAD_3, ItemID.OVERLOAD_2, ItemID.OVERLOAD_1)) {
                    return;
                }

                notificationLength = -1;

                break;

            case ABSORPTION_BELOW_THRESHOLD:
                // Only allow creation of alert if we have ABSORPTION pots in inventory.
                if(!InventoryUtils.hasOneOfItems(client, ItemID.ABSORPTION_4, ItemID.ABSORPTION_3, ItemID.ABSORPTION_2, ItemID.ABSORPTION_1)) {
                    return;
                }
                notificationLength = -1;

                break;

            case HP_BELOW_THRESHOLD:
            case ZAPPER_SPAWNED:
            case ULTIMATE_FORCE_SPAWNED:
            case POWER_SURGE_SPAWNED:
            case RECURRENT_DAMAGE_SPAWNED:
                notificationLength = 10;
                break;

            default:
                // Invalid Notification...
                return;
        }

        if(notificationLength > -1) {
            notificationLength = notificationLength * 1000;
        }

        visualNotification = new VisualNotification(config, type, notificationLength);

        notificationList.add(visualNotification);
    }



    public int getNotificationCount() {
        return notificationList.size();
    }

    public synchronized ArrayList<VisualNotification> getNotifications() {
        return new ArrayList<>(notificationList);
    }

    public synchronized void cleanNotifications() {
        notificationList.removeIf(VisualNotification::isExpired);

        for(Map.Entry<VisualNotificationType, Long> entry : notificationBlockMap.entrySet()) {
            if(System.currentTimeMillis() >= entry.getValue()) {
                notificationBlockMap.remove(entry.getKey());
            }
        }
    }

    public ArrayList<VisualNotification> getNotificationsByPriority(int priority) {
        final ArrayList<VisualNotification> priorityList = new ArrayList<>();

        Iterator<VisualNotification> notificationIterator = notificationList.iterator();
        while (notificationIterator.hasNext()) {
            VisualNotification notification = notificationIterator.next();

            if(notification.isExpired()) {
                notificationIterator.remove();
            }

            if(notification.getType().getPriority() == priority) {
                priorityList.add(notification);
            }
        }

        return priorityList;
    }

    public synchronized boolean hasNotificationType(VisualNotificationType type) {
        return (getNotificationByType(type) != null);
    }

    public synchronized VisualNotification getNotificationByType(VisualNotificationType type) {
        for(VisualNotification notification : notificationList) {
            if(notification.getType() == type) {
                return notification;
            }
        }

        return null;
    }

    public void removeNotification(VisualNotificationType type) {
        Iterator<VisualNotification> notificationIterator = notificationList.iterator();
        while (notificationIterator.hasNext()) {
            VisualNotification notification = notificationIterator.next();

            if(notification.getType() == type) {
                notificationIterator.remove();
                break;
            }
        }
    }

    public void configUpdated() {
        if(!config.visualAlerts()) {
            notificationList.clear();
        } else {
            if(!config.overloadRunoutNotification()) {
                removeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);
            }
            if(!config.overloadExpiredNotification()) {
                removeNotification(VisualNotificationType.OVERLOAD_EXPIRED);
            }
            if(!config.overloadRunoutNotification()) {
                removeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);
            }
            if(!config.overloadExpiredNotification()) {
                removeNotification(VisualNotificationType.OVERLOAD_EXPIRED);
            }
            if(!config.absorptionNotification()) {
                removeNotification(VisualNotificationType.ABSORPTION_BELOW_THRESHOLD);
            }
            if(!config.maximumHPNotification()) {
                removeNotification(VisualNotificationType.HP_ABOVE_THRESHOLD);
            }
            if(!config.minimumHPNotification()) {
                removeNotification(VisualNotificationType.HP_BELOW_THRESHOLD);
            }
            if(!config.powerSurgeNotification()) {
                removeNotification(VisualNotificationType.POWER_SURGE_SPAWNED);
            }
            if(!config.zapperNotification()) {
                removeNotification(VisualNotificationType.ZAPPER_SPAWNED);
            }
            if(!config.recurrentDamageNotification()) {
                removeNotification(VisualNotificationType.RECURRENT_DAMAGE_SPAWNED);
            }
            if(!config.ultimateForceNotification()) {
                removeNotification(VisualNotificationType.ULTIMATE_FORCE_SPAWNED);
            }
        }

        for(VisualNotification notification : notificationList) {
            notification.configUpdated();
        }
    }

    public void clearNotifications() {
        notificationList.clear();
    }
}

package com.github.iant89.ultimatenmz.notifications;

public enum VisualNotificationSpeed {
    SLOW("Slow", 75),
    MEDIUM("Medium", 50),
    DEFAULT("Default", 25),
    FAST("Fast", 15),
    EXTREME("Extreme", 8),

    ;

    String name;
    int ms;

    VisualNotificationSpeed(String name, int delay) {
        this.name = name;
        ms = delay;
    }

    public String toString() {
        return this.name;
    }

    public int getDelay() {
        return this.ms;
    }
}

package com.github.iant89.ultimatenmz.notifications;

import com.github.iant89.ultimatenmz.UltimateNMZConfig;
import com.github.iant89.ultimatenmz.drivers.ConstantDriver;
import com.github.iant89.ultimatenmz.drivers.SineDriver;
import com.github.iant89.ultimatenmz.drivers.StepDriver;
import com.github.iant89.ultimatenmz.drivers.ValueDriver;

import java.awt.*;

public class VisualNotification {

    private VisualNotificationType notificationType;

    private ValueDriver opacityDriver;
    private ValueDriver animationDriver;

    private long notificationLength = -1;
    private long notificationExpireTime = -1;
    private boolean notificationExpired = false;
    private boolean notificationVisible = true;

    private long nextFlashTime = -1;
    private long flashDelay = 500;

    private UltimateNMZConfig config;

    public VisualNotification(final UltimateNMZConfig config, final VisualNotificationType type, final long length) {
        this.config = config;
        this.notificationType = type;
        this.notificationLength = length;

        if(length != -1) {
            notificationExpireTime = System.currentTimeMillis() + length;
        }

        switch (getEffect()) {
            case FADE_IN_OUT:
                opacityDriver = new SineDriver(0.125f, 0.55f, getEffectSpeed().getDelay());
                break;

            case FLASH:
            case SOLID:
                flashDelay = getEffectSpeed().getDelay() * 20;
                nextFlashTime = System.currentTimeMillis() + flashDelay;
                opacityDriver = new ConstantDriver(0.55f);
                break;

            default:
                opacityDriver = new ConstantDriver(1f);
                break;
        }

        animationDriver = new StepDriver(0, 4, 300);
    }

    public void configUpdated() {
        float previousValue = -1;
        if(getOpacityDriver() != null && (getOpacityDriver() instanceof SineDriver)) {
            previousValue = ((SineDriver)getOpacityDriver()).getValue().floatValue();
        }

        switch (getEffect()) {
            case FADE_IN_OUT:
                opacityDriver = new SineDriver(0.125f, 0.55f, getEffectSpeed().getDelay());
                break;

            case FLASH:
            case SOLID:
                flashDelay = getEffectSpeed().getDelay() * 20;
                nextFlashTime = System.currentTimeMillis() + flashDelay;
                opacityDriver = new ConstantDriver(0.55f);
                break;

            default:
                opacityDriver = new ConstantDriver(1f);
                break;
        }

        if(opacityDriver != null) {
            if(previousValue > 0) {
                opacityDriver.setValue(previousValue);
            }
        }
    }

    public VisualNotificationType getType() {
        return notificationType;
    }

    public long getLength() {
        return notificationLength;
    }

    public boolean isVisible() {
        return notificationVisible;
    }

    public void setVisible(boolean visible) {
        notificationVisible = visible;
    }

    public void extendLength(final long length) {
        if(notificationExpireTime == -1 || isExpired()) {
            notificationExpireTime = System.currentTimeMillis() + length;
        } else {
            notificationExpireTime += length;
        }
    }

    public void expire() {
        notificationExpired = true;
    }

    public boolean isExpired() {
        if(!notificationExpired) {
            if (notificationExpireTime == -1) {
                return false;
            }

            if (System.currentTimeMillis() >= notificationExpireTime) {
                notificationExpired = true;
            }
        }

        return notificationExpired;
    }

    public void renderNotification(Graphics2D graphics, Rectangle bounds) {

        switch (getEffect()) {
            case FADE_IN_OUT:
                renderFadeNotification(graphics, bounds);
                break;

            case FLASH:
                renderFlashNotification(graphics, bounds);
                break;
            case SOLID:
                renderSolidNotification(graphics, bounds);
                break;
        }

    }

    private void renderBorder(Graphics2D graphics, Rectangle bounds, Color color, float size) {
        graphics.setColor(color);
        graphics.setStroke(new BasicStroke(size));
        graphics.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);
        graphics.setStroke(new BasicStroke(1f));
    }

    private void renderFadeNotification(Graphics2D graphics, Rectangle bounds) {
        if(getOpacityDriver() == null) {
            return;
        }

        Composite originalComposite = graphics.getComposite();

        graphics.setColor(getColor());
        graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) getOpacityDriver().getValue()));
        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        // Draw Border
        renderBorder(graphics, bounds, getColor(), 2f);

        graphics.setComposite(originalComposite);
    }

    private void renderFlashNotification(Graphics2D graphics, Rectangle bounds) {
        if(isVisible()) {
            if(System.currentTimeMillis() >= nextFlashTime) {
                setVisible(false);
                nextFlashTime = System.currentTimeMillis() + flashDelay;
            }
        } else {
            if(System.currentTimeMillis() >= nextFlashTime) {
                setVisible(true);
                nextFlashTime = System.currentTimeMillis() + flashDelay;
            } else {
                return;
            }
        }

        Composite originalComposite = graphics.getComposite();
        graphics.setColor(getColor());

        if (getOpacityDriver() == null) {
            return;
        }

        graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) getOpacityDriver().getValue()));

        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        // Draw Border
        renderBorder(graphics, bounds, getColor(), 2f);

        graphics.setComposite(originalComposite);
    }

    public void renderSolidNotification(Graphics2D graphics, Rectangle bounds) {
        Composite originalComposite = graphics.getComposite();
        graphics.setColor(getColor());

        if(getOpacityDriver() == null) {
            return;
        }

        graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, (float) getOpacityDriver().getValue()));

        graphics.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

        // Draw Border
        renderBorder(graphics, bounds, getColor(), 2f);

        graphics.setComposite(originalComposite);
    }

    public Color getColor() {

        switch (getType()) {
            case HP_BELOW_THRESHOLD:
                return config.minimumHPAlertColor();

            case HP_ABOVE_THRESHOLD:
                return config.maximumHPAlertColor();

            case ABSORPTION_BELOW_THRESHOLD:
                return config.absorptionAlertColor();

            case OVERLOAD_ALMOST_EXPIRED:
                return config.overloadRunOutColor();

            case OVERLOAD_EXPIRED:
                return config.overloadExpiredColor();

            case ZAPPER_SPAWNED:
                return config.zapperAlertColor();

            case POWER_SURGE_SPAWNED:
                return config.powerSurgeAlertColor();

            case RECURRENT_DAMAGE_SPAWNED:
                return config.recurrentDamageAlertColor();

            case ULTIMATE_FORCE_SPAWNED:
                return config.ultimateForceAlertColor();

            default:
                return null;
        }
    }


    public VisualNotificationEffectType getEffect() {

        switch (getType()) {
            case HP_BELOW_THRESHOLD:
                return config.minimumHPEffectType();

            case HP_ABOVE_THRESHOLD:
                return config.maximumHPEffectType();

            case ABSORPTION_BELOW_THRESHOLD:
                return config.absorptionEffectType();

            case OVERLOAD_ALMOST_EXPIRED:
                return config.overloadRunOutEffectType();

            case OVERLOAD_EXPIRED:
                return config.overloadExpiredEffectType();

            case ZAPPER_SPAWNED:
                return config.zapperEffectType();

            case POWER_SURGE_SPAWNED:
                return config.powerSurgeEffectType();

            case RECURRENT_DAMAGE_SPAWNED:
                return config.recurrentDamageEffectType();

            case ULTIMATE_FORCE_SPAWNED:
                return config.ultimateForceEffectType();

            default:
                return null;
        }
    }

    public VisualNotificationSpeed getEffectSpeed() {

        switch (getType()) {
            case HP_BELOW_THRESHOLD:
                return config.minimumHPEffectSpeed();

            case HP_ABOVE_THRESHOLD:
                return config.maximumHPEffectSpeed();

            case ABSORPTION_BELOW_THRESHOLD:
                return config.absorptionEffectSpeed();

            case OVERLOAD_ALMOST_EXPIRED:
                return config.overloadRunOutEffectSpeed();

            case OVERLOAD_EXPIRED:
                return config.overloadExpiredEffectSpeed();

            case ZAPPER_SPAWNED:
                return config.zapperEffectSpeed();

            case POWER_SURGE_SPAWNED:
                return config.powerSurgeEffectSpeed();

            case RECURRENT_DAMAGE_SPAWNED:
                return config.recurrentDamageEffectSpeed();

            case ULTIMATE_FORCE_SPAWNED:
                return config.ultimateForceEffectSpeed();

            default:
                return null;
        }
    }

    public ValueDriver getOpacityDriver() {
        return opacityDriver;
    }

    public ValueDriver getAnimationDriver() { return animationDriver; }
}

package com.github.iant89.ultimatenmz.notifications;

public enum VisualNotificationType {
    HP_BELOW_THRESHOLD("HP_BELOW_THRESHOLD", 7),
    HP_ABOVE_THRESHOLD("HP_ABOVE_THRESHOLD",2),
    ABSORPTION_BELOW_THRESHOLD("ABSORPTION_BELOW_THRESHOLD",1),

    /*
     * Overload Notifications
     */

    OVERLOAD_ALMOST_EXPIRED("", 1),
    OVERLOAD_EXPIRED("", 2),


    /*
     * Power-Up Spawn Notifications
     */
    ZAPPER_SPAWNED("ZAPPER_SPAWNED",3),
    POWER_SURGE_SPAWNED("POWER_SURGE_SPAWNED",4),
    RECURRENT_DAMAGE_SPAWNED("RECURRENT_DAMAGE_SPAWNED",5),
    ULTIMATE_FORCE_SPAWNED("ULTIMATE_FORCE_SPAWNED",6),
    ;

    final String name;
    final int priority;

    VisualNotificationType(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    public int getPriority() {
        return priority;
    }

    public String toString() {
        return "" + name;
    }
}

package com.github.iant89.ultimatenmz;

import net.runelite.api.ObjectID;

import java.awt.*;

public class Constants {

    public static final int OBJECT_ZAPPER = ObjectID.ZAPPER_26256;
    public static final int OBJECT_POWER_SURGE = ObjectID.POWER_SURGE;
    public static final int OBJECT_RECURRENT_DAMAGE = ObjectID.RECURRENT_DAMAGE;
    public static final int OBJECT_ULTIMATE_FORCE = ObjectID.ULTIMATE_FORCE;

}

package com.github.iant89.ultimatenmz;




import com.github.iant89.ultimatenmz.notifications.*;
import com.github.iant89.ultimatenmz.overlays.CountdownOverlay;
import com.github.iant89.ultimatenmz.overlays.PowerUpOverlay;
import com.github.iant89.ultimatenmz.overlays.UltimateNMZOverlay;
import com.github.iant89.ultimatenmz.overlays.VisualNotificationOverlay;
import com.github.iant89.ultimatenmz.utils.InventoryUtils;
import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;

@Slf4j
@PluginDescriptor(
	name = "Ultimate NMZ",
	description = "AFK at Nightmare Zone, While watching youtube or playing a game? Say no more!",
	tags = { "nmz", "afk", "nightmare", "nightmare zone", "info", "alert", "overlay", "combat", "boosts"}
)
public class UltimateNMZPlugin extends Plugin {

	private static final int[] NMZ_MAP_REGION = {9033};

	private static final Duration HOUR = Duration.ofHours(1);

	private static final Duration OVERLOAD_DURATION = Duration.ofMinutes(5);

	@Inject
	private Client client;

	@Inject
	private Notifier notifier;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private UltimateNMZConfig config;

	@Inject
	private SkillIconManager iconManager;

	@Inject
	private UltimateNMZOverlay ultimateNmzOverlay;

	@Inject
	private VisualNotificationManager notificationManager;

	@Inject
	private VisualNotificationOverlay notificationOverlay;

	@Inject
	private CountdownOverlay countdownOverlay;

	@Inject
	private PowerUpOverlay powerUpOverlay;

	@Getter
	public int pointsPerHour;

	private Instant nmzSessionStartTime;

	// Has the NMZ Started?
	private boolean nmzStarted = false;

	private boolean absorptionNotificationSend = true;

	// Overload Variables
	private boolean overloadNotificationSend = true;


	/*
	 * Timers for Anti-Spamming of Native Notifications.
	 */
	private Instant lastHPAboveThresholdNotification;
	private Instant lastHPBelowThresholdNotification;
	private Instant lastAbsorptionBelowThresholdNotification;
	private Instant lastOverloadWarningNotification;
	private Instant lastOverloadExpiredNotification;
	private Instant lastZapperNotification;
	private Instant lastRecurrentDamageNotification;
	private Instant lastUltimateForceNotification;
	private Instant lastPowerSurgeNotification;


	private Instant lastOverload;

	private long overloadTimer = -1;

	private Instant sessionStart;
	private Duration sessionDuration;
	private Instant sessionEnd;

	@Override
	protected void startUp() throws Exception {
		overlayManager.add(countdownOverlay);
		overlayManager.add(powerUpOverlay);
		overlayManager.add(notificationOverlay);
		overlayManager.add(ultimateNmzOverlay);

		if(client.getGameState() == GameState.LOGGED_IN) {
			clientThread.invoke(this::start);
		}
	}

	private void start() {

	}

	public VisualNotificationManager getNotificationManager() {
		return notificationManager;
	}

	@Override
	protected void shutDown() throws Exception {
		overlayManager.remove(countdownOverlay);
		overlayManager.remove(ultimateNmzOverlay);
		overlayManager.remove(notificationOverlay);
		overlayManager.remove(powerUpOverlay);

		// Restore Nightmare Zone Widget Visibility
		Widget nmzWidget = client.getWidget(WidgetInfo.NIGHTMARE_ZONE);
		if (nmzWidget != null) {
			nmzWidget.setHidden(false);
		}

	}

	@Subscribe
	private void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals("ultimatenmz")) {
			return;
		}

		getNotificationManager().configUpdated();
		ultimateNmzOverlay.updateConfig();
	}

	@Provides
	UltimateNMZConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(UltimateNMZConfig.class);
	}

	public UltimateNMZOverlay getUltimateNmzOverlay() {
		return ultimateNmzOverlay;
	}


	public Duration getOverloadDurationLeft() {

		if(overloadTimer == -1) {
			return null;
		}

		if(System.currentTimeMillis() >= overloadTimer) {
			return null;
		}

		return Duration.ofSeconds((overloadTimer - System.currentTimeMillis()) / 1000);
	}

	public Instant getSessionStart() {
		return sessionStart;
	}

	public Instant getSessionEnd() {
		return sessionEnd;
	}

	public Duration getSessionDuration() {
		if(sessionEnd != null) {
			return Duration.between(sessionStart, sessionEnd);
		}

		return Duration.between(sessionStart, Instant.now());
	}

	@Subscribe
	private void onChatMessage(ChatMessage event) {
		String msg = Text.removeTags(event.getMessage());

		if(msg.contains("You drink some of your overload potion.")) {

			// Drinking an Overload Potion
			log.debug("Player drank a overload potion");

			overloadTimer = System.currentTimeMillis() + ((5 * 60) * 1000);

			final Instant now = Instant.now();
			lastOverload = now;
			overloadNotificationSend = true;

			getNotificationManager().removeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);
			getNotificationManager().removeNotification(VisualNotificationType.OVERLOAD_EXPIRED);

			if(config.maximumHPNotification()) {
				int hpLeft = client.getBoostedSkillLevel(Skill.HITPOINTS) - 50;

				if(hpLeft <= config.maximumHPThresholdValue()) {
					getNotificationManager().removeNotification(VisualNotificationType.HP_ABOVE_THRESHOLD);
					getNotificationManager().blockNotification(VisualNotificationType.HP_ABOVE_THRESHOLD, 15);
				}
			}
			return;

		}

		// Check to see if we are in the NMZ before we process any of the other messages.
		if(!isInNightmareZone()) {
			return;
		}

		if (msg.contains("effects of overload have worn off")) {

			getNotificationManager().blockNotification(VisualNotificationType.HP_ABOVE_THRESHOLD, 2);

			overloadTimer = -1;
			// Overload Potion worn off
			if (config.overloadExpiredNotification()) {
				if(InventoryUtils.hasOneOfItems(client, ItemID.OVERLOAD_4, ItemID.OVERLOAD_3, ItemID.OVERLOAD_2, ItemID.OVERLOAD_1)) {
					notificationManager.removeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);

					if(config.visualAlerts()) {
						getNotificationManager().createNotification(VisualNotificationType.OVERLOAD_EXPIRED);
					}
				} else {
					getNotificationManager().removeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);
					getNotificationManager().removeNotification(VisualNotificationType.OVERLOAD_EXPIRED);
				}
			}

			sendNativeNotification(VisualNotificationType.OVERLOAD_EXPIRED);

			lastOverload = null;

		} else if(msg.contains("You wake up feeling refreshed")) {

			// NMZ has ended...
			endSession();

		} else if(msg.contains("25 secs to")) {

			// Started NMZ...
			startSession();

		} else if(msg.contains("You activate the")) {

			// Activated Zapper
			if(msg.contains("zapper")) {
				getNotificationManager().removeNotification(VisualNotificationType.ZAPPER_SPAWNED);
			}

		} else if(msg.contains("You now have")) {

			// Activated Recurrent Damage
			if(msg.contains("recurrent damage")) {
				getNotificationManager().removeNotification(VisualNotificationType.RECURRENT_DAMAGE_SPAWNED);
			}

		} else if(msg.contains("You feel a surge of special")) {

			// Activated Power-Surge
			getNotificationManager().removeNotification(VisualNotificationType.POWER_SURGE_SPAWNED);

		} else if (msg.contains("A power-up has spawned:")) {

			if (msg.contains("Power surge")) {

				// Power-Surge Spawned
				if (config.powerSurgeNotification()) {
					if(config.visualAlerts()) {
						getNotificationManager().createNotification(VisualNotificationType.POWER_SURGE_SPAWNED);
					}
				}

				sendNativeNotification(VisualNotificationType.POWER_SURGE_SPAWNED);

			} else if (msg.contains("Recurrent damage")) {

				// Recurrent Damage Spawned
				if (config.recurrentDamageNotification()) {
					if(config.visualAlerts()) {
						getNotificationManager().createNotification(VisualNotificationType.RECURRENT_DAMAGE_SPAWNED);
					}
				}

				sendNativeNotification(VisualNotificationType.RECURRENT_DAMAGE_SPAWNED);

			} else if (msg.contains("Zapper")) {

				// Zapper Spawned
				if (config.zapperNotification()) {
					if(config.visualAlerts()) {
						getNotificationManager().createNotification(VisualNotificationType.ZAPPER_SPAWNED);
					}
				}

				sendNativeNotification(VisualNotificationType.ZAPPER_SPAWNED);

			} else if (msg.contains("Ultimate force")) {

				// Ultimate Force Spawned
				if (config.ultimateForceNotification()) {
					if(config.visualAlerts()) {
						getNotificationManager().createNotification(VisualNotificationType.ULTIMATE_FORCE_SPAWNED);
					}
				}

				sendNativeNotification(VisualNotificationType.ULTIMATE_FORCE_SPAWNED);
			}
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event) {

	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event) {
		switch (event.getGameObject().getId()) {
			case Constants.OBJECT_POWER_SURGE:
				getNotificationManager().removeNotification(VisualNotificationType.POWER_SURGE_SPAWNED);
				break;

			case Constants.OBJECT_RECURRENT_DAMAGE:
				getNotificationManager().removeNotification(VisualNotificationType.RECURRENT_DAMAGE_SPAWNED);
				break;

			case Constants.OBJECT_ZAPPER:
				getNotificationManager().removeNotification(VisualNotificationType.ZAPPER_SPAWNED);
				break;

			case Constants.OBJECT_ULTIMATE_FORCE:
				getNotificationManager().removeNotification(VisualNotificationType.ULTIMATE_FORCE_SPAWNED);
				break;
		}
	}

	private int getAbsorptionPoints() {
		return client.getVar(Varbits.NMZ_ABSORPTION);
	}

	private void checkAbsorption() {
		int absorptionPoints = client.getVar(Varbits.NMZ_ABSORPTION);

		if(absorptionPoints < config.absorptionThreshold()) {
			if(config.absorptionNotification()) {
				if(InventoryUtils.hasOneOfItems(client, ItemID.ABSORPTION_1, ItemID.ABSORPTION_2, ItemID.ABSORPTION_3, ItemID.ABSORPTION_4)) {
					notificationManager.createNotification(VisualNotificationType.ABSORPTION_BELOW_THRESHOLD);

					sendNativeNotification(VisualNotificationType.ABSORPTION_BELOW_THRESHOLD);
				} else {
					notificationManager.removeNotification(VisualNotificationType.ABSORPTION_BELOW_THRESHOLD);
				}

			}
		}
	}

	private void checkOverload() {
		if(overloadTimer == -1) {
			return;
		}

		if(System.currentTimeMillis() >= overloadTimer) {
			overloadTimer = -1;

			if(InventoryUtils.hasOneOfItems(client, ItemID.ABSORPTION_1, ItemID.ABSORPTION_2, ItemID.ABSORPTION_3, ItemID.ABSORPTION_4)) {
				if(config.overloadExpiredNotification()) {
					notificationManager.removeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);
					notificationManager.createNotification(VisualNotificationType.OVERLOAD_EXPIRED);

					sendNativeNotification(VisualNotificationType.OVERLOAD_EXPIRED);
				}
			} else {
				notificationManager.removeNotification(VisualNotificationType.OVERLOAD_EXPIRED);
				notificationManager.removeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);
			}
			return;
		} else if(System.currentTimeMillis() >= (overloadTimer - (config.overloadRunoutTime() * 1000))) {
			if(config.overloadRunoutNotification()) {

				// If we don't check before creating it will spam native notifications every 30 seconds.
				if(!notificationManager.hasNotificationType(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED)) {
					notificationManager.createNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);

					sendNativeNotification(VisualNotificationType.OVERLOAD_ALMOST_EXPIRED);
				}
			}
		}
	}

	public boolean isInNightmareZone() {
		if (client.getLocalPlayer() == null) {
			return false;
		}

		// NMZ and the KBD lair uses the same region ID but NMZ uses planes 1-3 and KBD uses plane 0
		return client.getLocalPlayer().getWorldLocation().getPlane() > 0 && Arrays.equals(client.getMapRegions(), NMZ_MAP_REGION);
	}

	private int calculatePointsPerHour() {
		Instant now = Instant.now();
		final int currentPoints = client.getVar(Varbits.NMZ_POINTS);

		if (nmzSessionStartTime == null) {
			nmzSessionStartTime = now;
		}

		Duration timeSinceStart = Duration.between(nmzSessionStartTime, now);

		if (!timeSinceStart.isZero()) {
			return (int) ((double) currentPoints * (double) HOUR.toMillis() / (double) timeSinceStart.toMillis());
		}

		return 0;
	}

	private void resetPointsPerHour() {
		nmzSessionStartTime = null;
		pointsPerHour = 0;
	}

	@Subscribe
	private void onGameTick(GameTick event) {
		if (!isInNightmareZone()) {
			if (!absorptionNotificationSend) {
				absorptionNotificationSend = true;
			}
			if(!overloadNotificationSend) {
				overloadNotificationSend = true;
			}

			if (nmzSessionStartTime != null) {
				resetPointsPerHour();
			}

			return;
		}

		if (config.absorptionNotification()) {
			checkAbsorption();
		}

		if(config.overloadExpiredNotification() || config.overloadRunoutNotification()) {
			checkOverload();
		}

		pointsPerHour = calculatePointsPerHour();

		final int currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);

		boolean aboveHPThreshold = false;
		boolean belowHPThreshold = false;

		if(config.minimumHPNotification() && config.maximumHPNotification()) {
			if(currentHP < config.minimumHPThresholdValue() && config.minimumHPThresholdValue() != -1) {
				belowHPThreshold = true;
			} else if(currentHP > config.maximumHPThresholdValue() && config.maximumHPThresholdValue() != -1) {
				aboveHPThreshold = true;
			}
		} else if(config.minimumHPNotification()) {
			if(currentHP < config.minimumHPThresholdValue() && config.minimumHPThresholdValue() != -1) {
				belowHPThreshold = true;
			}
		} else if(config.maximumHPNotification()) {
			if(currentHP > config.maximumHPThresholdValue() && config.maximumHPThresholdValue() != -1) {
				aboveHPThreshold = true;
			}
		}

		if(config.visualAlerts()) {
			// Absorption
			if(config.absorptionNotification()){
				if (getAbsorptionPoints() <= config.absorptionThreshold()) {
					getNotificationManager().createNotification(VisualNotificationType.ABSORPTION_BELOW_THRESHOLD);
				} else {
					getNotificationManager().removeNotification(VisualNotificationType.ABSORPTION_BELOW_THRESHOLD);
				}
			} else {
				getNotificationManager().removeNotification(VisualNotificationType.ABSORPTION_BELOW_THRESHOLD);
			}

			// Overload Expired
			if(config.overloadExpiredNotification()) {

			}

			// Overload Expire Warning
			if(config.overloadRunoutNotification()) {

			}

			// Hitpoints
			if(config.minimumHPNotification() && config.maximumHPNotification()) {
				if (belowHPThreshold) {
					getNotificationManager().createNotification(VisualNotificationType.HP_BELOW_THRESHOLD);
				} else {
					getNotificationManager().removeNotification(VisualNotificationType.HP_BELOW_THRESHOLD);
				}
				if(aboveHPThreshold) {
					getNotificationManager().createNotification(VisualNotificationType.HP_ABOVE_THRESHOLD);
				} else {
					getNotificationManager().removeNotification(VisualNotificationType.HP_ABOVE_THRESHOLD);
				}
			} else if(config.minimumHPNotification()) {
				if (belowHPThreshold) {
					getNotificationManager().createNotification(VisualNotificationType.HP_BELOW_THRESHOLD);
				} else {
					getNotificationManager().removeNotification(VisualNotificationType.HP_BELOW_THRESHOLD);
				}
			} else if(config.maximumHPNotification()) {
				if (aboveHPThreshold) {
					getNotificationManager().createNotification(VisualNotificationType.HP_ABOVE_THRESHOLD);
				} else {
					getNotificationManager().removeNotification(VisualNotificationType.HP_ABOVE_THRESHOLD);
				}
			}


		} else {
			getNotificationManager().clearNotifications();
		}
	}

	private void startSession() {

		sessionStart = Instant.now();
		sessionEnd = null;
		ultimateNmzOverlay.nightmareZoneStarted();
		countdownOverlay.triggerCountdown(Instant.now().plus(Duration.ofSeconds(25)));

		if(config.nativeAlerts()) {
			notifier.notify("Nightmare Zone has started!", TrayIcon.MessageType.INFO);
		}

		resetPointsPerHour();
	}
	private void endSession() {

		// Grab the Time, to calculate total session length
		sessionEnd = Instant.now();

		ultimateNmzOverlay.nightmareZoneEnded();

		// Clear Tracking Variables
		lastOverload = null;

		// Remove all notifications, if they havent already been removed.
		getNotificationManager().removeAll();

		if(config.nativeAlerts()) {
			notifier.notify("You have left the Nightmare Zone.", TrayIcon.MessageType.INFO);
		}
	}

	/**
	 * Checks if the time between now and instant has been atleast the duration seconds.
	 *
	 * @param instant
	 * @return
	 */
	private boolean checkDurationForNotification(Instant instant, Duration duration) {
		if(instant == null) {
			return true;
		}

		if(Duration.between(Instant.now(), instant).getSeconds() > duration.getSeconds()) {
			return true;
		}

		return false;
	}
	private void sendNativeNotification(VisualNotificationType type) {
		if(!config.nativeAlerts()) {
			return;
		}

		switch (type) {
			case HP_BELOW_THRESHOLD:
				if(!config.minimumHPNotification()) {
					break;
				}

				if(checkDurationForNotification(lastHPBelowThresholdNotification, Duration.ofSeconds(30))) {
					lastHPBelowThresholdNotification = Instant.now();
					notifier.notify("Your Hitpoints are below " + config.minimumHPThresholdValue(), TrayIcon.MessageType.INFO);
				}
				break;

			case HP_ABOVE_THRESHOLD:
				if(!config.maximumHPNotification()) {
					break;
				}

				if(checkDurationForNotification(lastHPAboveThresholdNotification, Duration.ofSeconds(30))) {
					lastHPAboveThresholdNotification = Instant.now();
					notifier.notify("Your Hitpoints are above " + config.maximumHPThresholdValue(), TrayIcon.MessageType.INFO);
				}
				break;
			case ABSORPTION_BELOW_THRESHOLD:
				if(!config.absorptionNotification()) {
					break;
				}

				if(InventoryUtils.hasOneOfItems(client, ItemID.ABSORPTION_4, ItemID.ABSORPTION_3, ItemID.ABSORPTION_2, ItemID.ABSORPTION_1)) {
					if (checkDurationForNotification(lastAbsorptionBelowThresholdNotification, Duration.ofSeconds(30))) {
						lastAbsorptionBelowThresholdNotification = Instant.now();
						notifier.notify("Absorption Points is below threshold: " + getAbsorptionPoints(), TrayIcon.MessageType.INFO);
					}
				}
				break;

			case OVERLOAD_ALMOST_EXPIRED:
				if(!config.overloadRunoutNotification()) {
					break;
				}

				if(InventoryUtils.hasOneOfItems(client, ItemID.OVERLOAD_4, ItemID.OVERLOAD_3, ItemID.OVERLOAD_2, ItemID.OVERLOAD_1)) {
					if (checkDurationForNotification(lastOverloadWarningNotification, Duration.ofSeconds(30))) {
						lastOverloadWarningNotification = Instant.now();
						notifier.notify("Your Overload Potion is about to expire.", TrayIcon.MessageType.INFO);
					}
				}
				break;

			case OVERLOAD_EXPIRED:
				if(!config.overloadExpiredNotification()) {
					break;
				}

				if(InventoryUtils.hasOneOfItems(client, ItemID.OVERLOAD_4, ItemID.OVERLOAD_3, ItemID.OVERLOAD_2, ItemID.OVERLOAD_1)) {
					if (checkDurationForNotification(lastOverloadExpiredNotification, Duration.ofSeconds(60))) {
						lastOverloadExpiredNotification = Instant.now();
						notifier.notify("Your Overload Potion has expired.", TrayIcon.MessageType.INFO);
					}
				}
				break;

			case ZAPPER_SPAWNED:
				if(!config.zapperNotification()) {
					break;
				}

				if (checkDurationForNotification(lastZapperNotification, Duration.ofSeconds(60))) {
					lastZapperNotification = Instant.now();
					notifier.notify("A Zapper Power-Up has Spawned!", TrayIcon.MessageType.INFO);
				}
				break;

			case POWER_SURGE_SPAWNED:
				if(!config.powerSurgeNotification()) {
					break;
				}

				if (checkDurationForNotification(lastPowerSurgeNotification, Duration.ofSeconds(60))) {
					lastPowerSurgeNotification = Instant.now();
					notifier.notify("A Power Surge Power-Up has Spawned!", TrayIcon.MessageType.INFO);
				}
				break;

			case RECURRENT_DAMAGE_SPAWNED:
				if(!config.recurrentDamageNotification()) {
					break;
				}

				if (checkDurationForNotification(lastRecurrentDamageNotification, Duration.ofSeconds(60))) {
					lastRecurrentDamageNotification = Instant.now();
					notifier.notify("A Recurrent Damage Power-Up has Spawned!", TrayIcon.MessageType.INFO);
				}
				break;

			case ULTIMATE_FORCE_SPAWNED:
				if(!config.ultimateForceNotification()) {
					break;
				}

				if (checkDurationForNotification(lastUltimateForceNotification, Duration.ofSeconds(60))) {
					lastUltimateForceNotification = Instant.now();
					notifier.notify("A Ultimate Force Power-Up has Spawned!", TrayIcon.MessageType.INFO);
				}
				break;
		}
	}
}

package com.github.iant89.ultimatenmz.drivers;

public class StepDriver extends ValueDriver<Integer> {

    private int minimum;
    private int maximum;
    private int value;
    private long delay;

    private boolean driveDown = false;

    private long nextStepTimer = -1;

    public StepDriver(int min, int max, long delay) {
        this.minimum = min;
        this.maximum = max;
        this.delay = delay;
        this.value = min;

        calculateValue();
    }

    public int getMinimum() {
        return minimum;
    }

    public void setMinimum(int minimum) {
        this.minimum = minimum;
    }

    public int getMaximum() {
        return maximum;
    }

    public void setMaximum(int maximum) {
        this.maximum = maximum;
    }

    public void setDelay(long delay) {
        this.delay = delay;
    }

    public long getDelay() {
        return this.delay;
    }


    @Override
    public void setValue(Integer value) {
        this.value = value;
    }

    public void calculateValue() {
        if(nextStepTimer == -1) {
            nextStepTimer = System.currentTimeMillis() + getDelay();
        } else {
            if(System.currentTimeMillis() >= nextStepTimer) {
                nextStepTimer = System.currentTimeMillis() + getDelay();
            } else {
                return;
            }
        }

        if(driveDown) {
            value -= 1;

            if(value <= getMinimum()) {
                value = getMinimum();
                driveDown = false;
            }
        } else {
            value += 1;

            if(value >= getMaximum()) {
                value = getMaximum();
                driveDown = true;
            }
        }
    }

    public Integer getValue() {
        calculateValue();

        return value;
    }
}

package com.github.iant89.ultimatenmz.drivers;

public class SineDriver extends ValueDriver<Float> {

	private float minimum;
	private float maximum;
	private float value;
	private long duration;

	private boolean driveDown = false;

	private long nextStepTimer = -1;

	public SineDriver(float min, float max, long duration) {
		this.minimum = min;
		this.maximum = max;
		this.duration = duration;
		this.value = min;

		calculateValue();
	}

	public float getMinimum() {
		return minimum;
	}

	public void setMinimum(float minimum) {
		this.minimum = minimum;
	}

	public float getMaximum() {
		return maximum;
	}

	public void setMaximum(float maximum) {
		this.maximum = maximum;
	}

	public void setDuration(long duration) {
		this.duration = duration;
	}

	public long getDuration() {
		return this.duration;
	}

	public float getStep() {
		return (getMaximum() - getMinimum()) / getDuration();
	}

	@Override
	public void setValue(Float value) {
		this.value = value;
	}

	public void calculateValue() {
		if(nextStepTimer == -1) {
			nextStepTimer = System.currentTimeMillis() + getDuration();
		} else {
			if(System.currentTimeMillis() >= nextStepTimer) {
				nextStepTimer = System.currentTimeMillis() + getDuration();
			} else {
				return;
			}
		}

		float step = (getMaximum() - getMinimum()) / getDuration();

		if(driveDown) {
			value -= step;

			if(value <= getMinimum()) {
				value = getMinimum();
				driveDown = false;
			}
		} else {
			value += step;

			if(value >= getMaximum()) {
				value = getMaximum();
				driveDown = true;
			}
		}
	}

	public Float getValue() {
		calculateValue();

		return value;
	}
}
package com.github.iant89.ultimatenmz.drivers;

public abstract class ValueDriver<T extends Number> {

    protected T value;

    public abstract void setValue(T value);

    protected abstract void calculateValue();

    public abstract T getValue();
}

package com.github.iant89.ultimatenmz.drivers;

public class ConstantDriver extends ValueDriver {

    public ConstantDriver() {

    }

    public ConstantDriver(Number value) {
        this.value = value;
    }

    @Override
    public void setValue(Number value) {
        this.value = value;
    }

    @Override
    public void calculateValue() {

    }

    @Override
    public Number getValue() {
        return this.value;
    }
}

package com.github.iant89.ultimatenmz.overlays;

import com.github.iant89.ultimatenmz.UltimateNMZConfig;
import com.github.iant89.ultimatenmz.UltimateNMZPlugin;
import com.github.iant89.ultimatenmz.utils.DurationUtils;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;

import java.awt.*;
import java.time.Duration;
import java.time.Instant;

import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class CountdownOverlay extends OverlayPanel {


    private final Client client;
    private final UltimateNMZConfig config;
    private final UltimateNMZPlugin plugin;

    private Instant endTime;

    @Inject
    private CountdownOverlay(Client client, UltimateNMZConfig config, UltimateNMZPlugin plugin) {
        super(plugin);

        this.plugin = plugin;
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.BOTTOM_LEFT);
        setPriority(OverlayPriority.HIGH);
        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Ultimate-NMZ Overlay."));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if(endTime == null) {
            return super.render(graphics);
        }

        long secondsRemaining = DurationUtils.toSecondsPart(Duration.between(Instant.now(), endTime));

        if(secondsRemaining > 0) {
            panelComponent.getChildren().add(TitleComponent.builder().text("NMZ STARTING IN").build());
            panelComponent.getChildren().add(TitleComponent.builder().text("" + secondsRemaining + " SECOND" + (secondsRemaining > 1 ? "S" : "") + ".").color(Color.GREEN).build());
        } else {
            endTime = null;
        }

        return super.render(graphics);
    }

    public void triggerCountdown(Instant endTime) {
        this.endTime = endTime;
    }
}

package com.github.iant89.ultimatenmz.overlays;

import com.github.iant89.ultimatenmz.utils.DurationUtils;
import com.github.iant89.ultimatenmz.utils.InventoryUtils;
import com.github.iant89.ultimatenmz.utils.NumberUtils;
import com.github.iant89.ultimatenmz.UltimateNMZConfig;
import com.github.iant89.ultimatenmz.UltimateNMZPlugin;
import net.runelite.api.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.QuantityFormatter;

import javax.inject.Inject;
import java.awt.*;
import java.time.Duration;

import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class UltimateNMZOverlay extends OverlayPanel {



    private final Client client;
    private final UltimateNMZConfig config;
    private final UltimateNMZPlugin plugin;

    private boolean nmzStarted = false;
    private long nmzStartTimer = -1;



    @Inject
    private UltimateNMZOverlay(Client client, UltimateNMZConfig config, UltimateNMZPlugin plugin) {
        super(plugin);

        this.plugin = plugin;
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.BOTTOM_LEFT);
        setPriority(OverlayPriority.HIGH);
        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Ultimate-NMZ Overlay."));
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        if (!plugin.isInNightmareZone()) {

            Widget nmzWidget = client.getWidget(WidgetInfo.NIGHTMARE_ZONE);
            if (nmzWidget != null) {
                nmzWidget.setHidden(false);
            }

            return null;
        }

        if(!nmzStarted && nmzStartTimer > -1) {
            if(System.currentTimeMillis() > nmzStartTimer) {
                nmzStarted = true;
                nmzStartTimer = -1;
            }
        }

        if(!nmzStarted) {
            return super.render(graphics);
        }

        Widget nmzWidget = client.getWidget(WidgetInfo.NIGHTMARE_ZONE);
        if(nmzWidget != null) {
            nmzWidget.setHidden(config.removeNMZOverlay());
        }

        panelComponent.getChildren().add(TitleComponent.builder().text("-- Ultimate NMZ --").color(Color.GREEN).build());

        final int currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
        Color hpColor;
        Color absorptionColor;
        String str;

        boolean aboveHPThreshold = false;
        boolean belowHPThreshold = false;

        if(config.minimumHPNotification() && config.maximumHPNotification()) {
            if(currentHP < config.minimumHPThresholdValue() && config.minimumHPThresholdValue() != -1) {
                belowHPThreshold = true;
            } else if(currentHP > config.maximumHPThresholdValue() && config.maximumHPThresholdValue() != -1) {
                aboveHPThreshold = true;
            }
        } else if(config.minimumHPNotification()) {
            if(currentHP < config.minimumHPThresholdValue() && config.minimumHPThresholdValue() != -1) {
                belowHPThreshold = true;
            }
        } else if(config.maximumHPNotification()) {
            if(currentHP > config.maximumHPThresholdValue() && config.maximumHPThresholdValue() != -1) {
                aboveHPThreshold = true;
            }
        }

        if(aboveHPThreshold) {
            hpColor = Color.RED;
        } else if(belowHPThreshold) {
            hpColor = Color.YELLOW;
        } else {
            hpColor = Color.GREEN;
        }

        str = ColorUtil.prependColorTag(Integer.toString(currentHP), hpColor);

        final int currentPoints = client.getVar(Varbits.NMZ_POINTS);
        final int totalPoints = currentPoints + client.getVar(VarPlayer.NMZ_REWARD_POINTS);
        final int absorptionPoints = client.getVar(Varbits.NMZ_ABSORPTION);

        panelComponent.getChildren().add(LineComponent.builder().left("Session:").right(DurationUtils.toSessionTimeString(plugin.getSessionDuration())).rightColor(Color.GREEN).build());
        panelComponent.getChildren().add(LineComponent.builder().left("").build());

        panelComponent.getChildren().add(LineComponent.builder().left("Hitpoints:").right(str).rightColor(hpColor).build());

        panelComponent.getChildren().add(LineComponent.builder().left("").build());

        if(absorptionPoints == 0) {
            if(InventoryUtils.hasOneOfItems(client, ItemID.ABSORPTION_4, ItemID.ABSORPTION_3, ItemID.ABSORPTION_2, ItemID.ABSORPTION_1)) {
                panelComponent.getChildren().add(LineComponent.builder().left("Absorption:").right("0").rightColor(Color.RED).build());
            }
        } else if(absorptionPoints <= config.absorptionThreshold()) {
            panelComponent.getChildren().add(LineComponent.builder().left("Absorption:").right(QuantityFormatter.formatNumber(absorptionPoints)).rightColor(Color.RED).build());
        } else {
            panelComponent.getChildren().add(LineComponent.builder().left("Absorption:").right(QuantityFormatter.formatNumber(absorptionPoints)).rightColor(Color.GREEN).build());
        }

        Color overloadColor = Color.GREEN;
        if(plugin.getOverloadDurationLeft() != null) {
            Duration overloadDuration = plugin.getOverloadDurationLeft();

            if(overloadDuration.toMinutes() > 0 || overloadDuration.getSeconds() > 0) {
                if(config.overloadRunoutTime() >= overloadDuration.getSeconds()) {
                    overloadColor = Color.RED;
                }

                panelComponent.getChildren().add(LineComponent.builder().left("Overload:").right(DurationUtils.toCountDownTimeString(overloadDuration)).rightColor(overloadColor).build());
            }
        }

        if(config.showPointsPerHour() || config.showTotalPoints() || config.removeNMZOverlay()) {
            panelComponent.getChildren().add(LineComponent.builder().left("").build());
        }

        if(config.removeNMZOverlay()) {
            panelComponent.getChildren().add(LineComponent.builder().left("Points:").right(NumberUtils.format(currentPoints)).build());
        }

        if(config.showPointsPerHour()) {
            panelComponent.getChildren().add(LineComponent.builder().left("Points/Hour:").right(NumberUtils.format(plugin.getPointsPerHour())).build());
        }

        if(config.showTotalPoints()) {
            panelComponent.getChildren().add(LineComponent.builder().left("Total Points:").right(NumberUtils.format(totalPoints)).build());
        }

        return super.render(graphics);
    }

    public void updateConfig() {

    }

    public boolean hasNightmareZoneStarted() {
        return nmzStarted;
    }

    public void nightmareZoneStarted() {
        nmzStartTimer = System.currentTimeMillis() + (25 * 1000);
    }

    public void nightmareZoneEnded() {
        nmzStarted = false;
        nmzStartTimer = -1;
    }
}

package com.github.iant89.ultimatenmz.overlays;

import com.github.iant89.ultimatenmz.UltimateNMZConfig;
import com.github.iant89.ultimatenmz.UltimateNMZPlugin;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.*;

import javax.inject.Inject;

import java.awt.*;

import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class PowerUpOverlay extends OverlayPanel {

    public static final int OBJECT_ZAPPER = ObjectID.ZAPPER_26256;
    public static final int OBJECT_POWER_SURGE = ObjectID.POWER_SURGE;
    public static final int OBJECT_RECURRENT_DAMAGE = ObjectID.RECURRENT_DAMAGE;
    public static final int OBJECT_ULTIMATE_FORCE = ObjectID.ULTIMATE_FORCE;

    private final Client client;
    private final UltimateNMZConfig config;
    private final UltimateNMZPlugin plugin;

    @Inject
    private PowerUpOverlay(Client client, UltimateNMZConfig config, UltimateNMZPlugin plugin) {
        super(plugin);

        this.plugin = plugin;
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setMovable(false);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(OverlayPriority.HIGH);
        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Ultimate NMZ Overlay."));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if(!plugin.isInNightmareZone()) {
            return super.render(graphics);
        }

        renderTileObjects(graphics);

        return super.render(graphics);
    }

    public void renderTileObjects(Graphics2D graphics) {
        if(!plugin.isInNightmareZone()) {
            return;
        }

        Scene scene = client.getScene();
        Tile[][][] tiles = scene.getTiles();

        int z = client.getPlane();

        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];

                if (tile == null) {
                    continue;
                }

                renderGameObjects(graphics, tile, client.getLocalPlayer());
            }
        }
    }

    private void renderGameObjects(Graphics2D graphics, Tile tile, Player player) {
        GameObject[] gameObjects = tile.getGameObjects();



        if (gameObjects != null) {
            for (GameObject gameObject : gameObjects) {
                if(gameObject == null) {
                    continue;
                }

                String objectName;
                Color objectColor;

                switch(gameObject.getId()) {
                    case OBJECT_POWER_SURGE:
                        if(!config.drawPowerSurgeLocation()) {
                            continue;
                        }
                        objectName = "POWER SURGE";
                        objectColor = config.powerSurgeAlertColor();
                        break;
                    case OBJECT_RECURRENT_DAMAGE:
                        if(!config.drawRecurrentDamageLocation()) {
                            continue;
                        }
                        objectName = "RECURRENT DAMAGE";
                        objectColor = config.recurrentDamageAlertColor();
                        break;
                    case OBJECT_ZAPPER:
                        if(!config.drawZapperLocation()) {
                            continue;
                        }
                        objectName = "ZAPPER";
                        objectColor = config.zapperAlertColor();
                        break;
                    case OBJECT_ULTIMATE_FORCE:
                        if(!config.drawUltimateForceLocation()) {
                            continue;
                        }
                        objectName = "ULTIMATE FORCE";
                        objectColor = config.ultimateForceAlertColor();
                        break;

                    default:
                        continue;
                }

                if(gameObject.getSceneMinLocation().equals(tile.getSceneLocation())) {
                    if (player.getLocalLocation().distanceTo(gameObject.getLocalLocation()) <= 3500) {
                        LocalPoint lp = gameObject.getLocalLocation();
                        Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, 1);

                        OverlayUtil.renderPolygon(graphics, tilePoly, objectColor, new BasicStroke(2f));

                        Point textLocation = gameObject.getCanvasTextLocation(graphics, objectName, (int) (gameObject.getCanvasTilePoly().getBounds2D().getHeight() + 140));
                        OverlayUtil.renderTextLocation(graphics, textLocation, objectName, objectColor);
                    }
                }
            }
        }
    }

}

package com.github.iant89.ultimatenmz.overlays;

import com.github.iant89.ultimatenmz.UltimateNMZConfig;
import com.github.iant89.ultimatenmz.UltimateNMZPlugin;
import com.github.iant89.ultimatenmz.drivers.ConstantDriver;
import com.github.iant89.ultimatenmz.drivers.SineDriver;
import com.github.iant89.ultimatenmz.drivers.ValueDriver;
import com.github.iant89.ultimatenmz.icons.IconManager;
import com.github.iant89.ultimatenmz.notifications.*;
import com.github.iant89.ultimatenmz.utils.InventoryUtils;
import net.runelite.api.*;
import net.runelite.client.game.*;
import net.runelite.client.ui.overlay.*;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;

import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class VisualNotificationOverlay extends OverlayPanel {

    private final Client client;
    private final UltimateNMZConfig config;
    private final UltimateNMZPlugin plugin;
    private final VisualNotificationManager notificationManager;
    private final SkillIconManager skillIconManager;
    private final ItemManager itemManager;

    @Inject
    private IconManager iconManager;
    private ValueDriver iconSizeDriver = new SineDriver(2f, 5f, 25);

    @Inject
    private VisualNotificationOverlay(Client client, UltimateNMZConfig config, UltimateNMZPlugin plugin, VisualNotificationManager notificationManager, SkillIconManager skillIconManager, ItemManager itemManager) {
        super(plugin);

        this.plugin = plugin;
        this.client = client;
        this.config = config;
        this.notificationManager = notificationManager;
        this.skillIconManager = skillIconManager;
        this.itemManager = itemManager;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        setPriority(OverlayPriority.HIGH);
        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Ultimate-NMZ Notification Overlay."));
    }

    @Override
    public Dimension render(Graphics2D graphics) {


        if(!config.visualAlerts() || !plugin.isInNightmareZone()) {
            return super.render(graphics);
        }

        if(!plugin.getUltimateNmzOverlay().hasNightmareZoneStarted()) {
            return super.render(graphics);
        }


        // Clean time-based notifications
        notificationManager.cleanNotifications();

        // Make sure we have notifications to show
        if(notificationManager.getNotificationCount() == 0) {
            return super.render(graphics);
        }

        // Get all active notifications
        ArrayList<VisualNotification> notificationList = notificationManager.getNotifications();

        // Sort Notifications based on priority
        notificationList.sort(Comparator.comparingInt(o -> o.getType().getPriority()));

        Iterator notificationIterator = notificationList.iterator();

        int x = 0;
        int width = client.getCanvasWidth() / notificationList.size();

        Rectangle notificationBounds;
        while(notificationIterator.hasNext()) {
            VisualNotification visualNotification = (VisualNotification) notificationIterator.next();

            if(visualNotification.isExpired()) {
                notificationIterator.remove();
                continue;
            }

            ValueDriver opacityDriver = visualNotification.getOpacityDriver();

            if (opacityDriver == null) {
                opacityDriver = new ConstantDriver();
                opacityDriver.setValue(1f);
            }

            notificationBounds = new Rectangle(x, 0, width, client.getCanvasHeight());

            graphics.setClip(notificationBounds);

            visualNotification.renderNotification(graphics, notificationBounds);

            graphics.setClip(null);

            BufferedImage icon = iconManager.getIconForNotification(visualNotification);

            if(icon != null) {
                final Composite originalComposite = graphics.getComposite();
                double iconSize = iconSizeDriver.getValue().doubleValue();

                switch (visualNotification.getType()) {
                    case ZAPPER_SPAWNED:
                    case ULTIMATE_FORCE_SPAWNED:
                    case POWER_SURGE_SPAWNED:
                    case RECURRENT_DAMAGE_SPAWNED:
                        iconSize /= 4;
                        break;
                }

                int iW = (int) (icon.getWidth() * iconSize);
                int iH = (int) (icon.getHeight() * iconSize);

                float iconOpacity = 1f - opacityDriver.getValue().floatValue();

                if(opacityDriver instanceof ConstantDriver) {
                    iconOpacity = opacityDriver.getValue().floatValue();
                }

                graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, iconOpacity));
                graphics.drawImage(icon, (x + (width / 2)) - (iW / 2), (client.getCanvasHeight() / 2) - (iH / 2), iW, iH, null);
                graphics.setComposite(originalComposite);
            }

            x += width;
        }

        return super.render(graphics);
    }


}

package com.github.iant89.ultimatenmz.icons;

import com.github.iant89.ultimatenmz.UltimateNMZConfig;
import com.github.iant89.ultimatenmz.notifications.VisualNotification;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.IOException;

public class IconManager {

    @Inject
    private UltimateNMZConfig config;
    @Inject
    private SkillIconManager skillIconManager;
    @Inject
    private ItemManager itemManager;

    private static BufferedImage[] powerupIcons;

    @Inject
    protected IconManager(UltimateNMZConfig config, SkillIconManager skillIconManager, ItemManager itemManager) {
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.itemManager = itemManager;

        loadPowerupIcons();
    }

    private void loadPowerupIcons() {
        powerupIcons = new BufferedImage[4];

        // 0 - Zapper
        powerupIcons[0] = loadImageFromResources("/zapper.png");

        // 1 - Recurrent Damage
        powerupIcons[1] = loadImageFromResources("/recurrent_damage.png");

        // 2 - Ultimate Force
        powerupIcons[2] = loadImageFromResources("/ultimate_force.png");

        // 3 - Power Surge
        powerupIcons[3] = loadImageFromResources("/power_surge.png");

    }

    private BufferedImage loadImageFromResources(String url) {
        BufferedImage image = null;

        try {
            image = ImageIO.read(IconManager.class.getResource(url));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return image;
    }

    public BufferedImage getIconForNotification(VisualNotification visualNotification) {
        switch (visualNotification.getType()) {
            case ZAPPER_SPAWNED:
                return powerupIcons[0];

            case RECURRENT_DAMAGE_SPAWNED:
                return powerupIcons[1];

            case ULTIMATE_FORCE_SPAWNED:
                return powerupIcons[2];

            case POWER_SURGE_SPAWNED:
                return powerupIcons[3];

            case HP_BELOW_THRESHOLD:
                if(config.showMinimumHPIcon()) {
                    return skillIconManager.getSkillImage(Skill.HITPOINTS);
                }

                return null;

            case HP_ABOVE_THRESHOLD:
                if(config.showMaximumHPIcon()) {
                    return skillIconManager.getSkillImage(Skill.HITPOINTS);
                }

                return null;

            case OVERLOAD_ALMOST_EXPIRED:
            case OVERLOAD_EXPIRED:
                if(!config.showOverloadIcon()) {
                    return null;
                }

                switch (visualNotification.getAnimationDriver().getValue().intValue()) {
                    case 0:
                        return itemManager.getImage(ItemID.OVERLOAD_4);

                    case 1:
                        return itemManager.getImage(ItemID.OVERLOAD_3);

                    case 2:
                        return itemManager.getImage(ItemID.OVERLOAD_2);

                    case 3:
                        return itemManager.getImage(ItemID.OVERLOAD_1);

                    case 4:
                        return itemManager.getImage(ItemID.VIAL);

                }
                return null;

            case ABSORPTION_BELOW_THRESHOLD:
                if(!config.showAbsorptionIcon()) {
                    return null;
                }

                switch (visualNotification.getAnimationDriver().getValue().intValue()) {
                    case 0:
                        return itemManager.getImage(ItemID.ABSORPTION_4);

                    case 1:
                        return itemManager.getImage(ItemID.ABSORPTION_3);

                    case 2:
                        return itemManager.getImage(ItemID.ABSORPTION_2);

                    case 3:
                        return itemManager.getImage(ItemID.ABSORPTION_1);

                    case 4:
                        return itemManager.getImage(ItemID.VIAL);

                }
                return null;

            default:
                return null;
        }
    }
}

package com.github.iant89.ultimatenmz.utils;

import net.runelite.api.*;

public class InventoryUtils {

    public static boolean hasItem(Client client, int itemId) {
        ItemContainer container = client.getItemContainer(InventoryID.INVENTORY);

        if (container != null) {
            for (Item item : container.getItems()) {
                if(item.getId() == itemId) {
                    return true;
                }
            }
        }

        return false;
    }

    public static boolean hasOneOfItems(Client client, int... ids) {
        ItemContainer container = client.getItemContainer(InventoryID.INVENTORY);

        if (container != null) {
            for (Item item : container.getItems()) {
                for(int id : ids) {
                    if(item.getId() == id) {
                        return true;
                    }
                }
            }
        }


        return false;
    }
}

package com.github.iant89.ultimatenmz.utils;

import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;

public class NumberUtils {

    private static final NavigableMap<Long, String> suffixes = new TreeMap<>();

    static {
        suffixes.put(1_000L, "k");
        suffixes.put(1_000_000L, "m");
        suffixes.put(1_000_000_000L, "b");
    }

    public static String format(long value) {
        //Long.MIN_VALUE == -Long.MIN_VALUE so we need an adjustment here
        if (value == Long.MIN_VALUE) return format(Long.MIN_VALUE + 1);
        if (value < 0) return "-" + format(-value);
        if (value < 1000) return Long.toString(value); //deal with easy case

        Map.Entry<Long, String> e = suffixes.floorEntry(value);
        Long divideBy = e.getKey();
        String suffix = e.getValue();

        long truncated = value / (divideBy / 10); //the number part of the output times 10
        boolean hasDecimal = truncated < 100 && (truncated / 10d) != (truncated / 10);
        return hasDecimal ? (truncated / 10d) + suffix : (truncated / 10) + suffix;
    }
}

package com.github.iant89.ultimatenmz.utils;

import java.time.Duration;

public class DurationUtils {

    public static long toSecondsPart(Duration duration) {
        return duration.getSeconds() % 60;
    }

    public static long toMinutesPart(Duration duration) {
        return (duration.getSeconds() % 3600) / 60;
    }

    public static long toHoursPart(Duration duration) {
        return duration.getSeconds() / 3600;
    }

    public static String toSessionTimeString(Duration duration) {
        long totalSeconds = duration.getSeconds();

        long hours = totalSeconds / 3600;
        long minutes = (totalSeconds % 3600) / 60;
        long seconds = totalSeconds % 60;

        return String.format("%02d:%02d:%02d", hours, minutes, seconds);
    }

    public static String toCountDownTimeString(Duration duration) {
        long totalSeconds = duration.getSeconds();

        long hours = totalSeconds / 3600;
        long minutes = (totalSeconds % 3600) / 60;
        long seconds = totalSeconds % 60;

        String timeString = "";

        if(hours > 0) {
            return String.format("%02d:%02d:%02d", hours, minutes, seconds);
        } else {
            return String.format("%02d:%02d", minutes, seconds);
        }
    }
}
