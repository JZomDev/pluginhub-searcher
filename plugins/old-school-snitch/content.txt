package ch.oldschoolsnit;

import ch.oldschoolsnit.models.ModelSnapshot;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Desktop;
import java.awt.Dimension;
import java.net.URI;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

@Slf4j
public class OldSchoolSnitchPanel extends PluginPanel
{
	private ScheduledExecutorService executor;

	private final EventBus eventBus;

	private final String websiteUrl = "https://oldschoolsnit.ch/";

	@Inject
	public OldSchoolSnitchPanel(ScheduledExecutorService executor, EventBus eventBus)
	{
		super();

		this.executor = executor;
		this.eventBus = eventBus;


		var basePanel = new JPanel();
		basePanel.setLayout(new BoxLayout(basePanel, BoxLayout.Y_AXIS));


		var headerPanel = new JPanel();
		headerPanel.setLayout(new BorderLayout());
		headerPanel.setBackground(ColorScheme.BRAND_ORANGE);

		JLabel headerLabel = new JLabel("Old School Snitch");
		headerLabel.setFont(FontManager.getRunescapeBoldFont());
		headerLabel.setForeground(Color.BLACK);
		headerLabel.setHorizontalAlignment(JLabel.CENTER);
		headerPanel.add(headerLabel, BorderLayout.NORTH);

		basePanel.add(headerPanel);
		basePanel.add(Box.createRigidArea(new Dimension(0, 15)));

		var modelPanel = new JPanel();
		modelPanel.setLayout(new BorderLayout());
		JLabel modelPanelHeader = new JLabel("Player Model Integration");
		modelPanelHeader.setFont(FontManager.getRunescapeBoldFont());
		modelPanelHeader.setHorizontalAlignment(JLabel.CENTER);
		modelPanel.add(modelPanelHeader, BorderLayout.NORTH);
		var getPlayerModel = new JButton("Send Player Model");
		getPlayerModel.addActionListener(a ->
		{
			eventBus.post(new ModelSnapshot());
		});
		//TODO: Disable the button if the api key is null or whitespace.
		modelPanel.add(getPlayerModel, BorderLayout.CENTER);

		basePanel.add(modelPanel);
		basePanel.add(Box.createRigidArea(new Dimension(0, 15)));

		var websitePanel = new JPanel();
		websitePanel.setLayout(new BorderLayout());
		JLabel websitePanelHeader = new JLabel("About");
		websitePanelHeader.setFont(FontManager.getRunescapeBoldFont());
		websitePanelHeader.setHorizontalAlignment(JLabel.CENTER);
		websitePanel.add(websitePanelHeader, BorderLayout.NORTH);

		var openWebsite = new JButton("Open Website");
		openWebsite.addActionListener(a -> {
			try
			{
				Desktop desktop = java.awt.Desktop.getDesktop();
				URI homepage = new URI(websiteUrl);
				desktop.browse(homepage);
			}
			catch (Exception ex)
			{
				log.error("Error attempting to open the Old School Snitch Website", ex);
			}
		});
		websitePanel.add(openWebsite, BorderLayout.CENTER);

		basePanel.add(websitePanel);
		basePanel.add(Box.createRigidArea(new Dimension(0, 15)));

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));
		add(basePanel, BorderLayout.CENTER);

		//Grabs the config and checks for length
		//Add a button to test connection or something.
		//Show XP Drops sent this session
		//Show NPC Kills sent this session
		//Show Item Drops sent this session
		//Show Locations sent this session

	}

}

package ch.oldschoolsnit.models;

public class BufferView
{
	//The index of the respective buffer this view references
	public int buffer;
	public int byteOffset;
	public int byteLength;
	public int target;

	public BufferView(int bufferId, int byteOffset, int byteLength, int targetDataType){
		this.buffer = bufferId;
		this.byteOffset = byteOffset;
		this.byteLength = byteLength;
		this.target = targetDataType;

	}

}

package ch.oldschoolsnit.models;

import java.util.ArrayList;

public class Mesh
{
	public ArrayList<Primitive> primitives = new ArrayList<>();
}

package ch.oldschoolsnit.models;

public class Asset
{
	public String version = "2.0";
}

package ch.oldschoolsnit.models;

import java.util.ArrayList;

public class Node
{
	public Integer mesh = 0;
}

package ch.oldschoolsnit.models;

import java.util.ArrayList;

public class Scene
{
	public ArrayList<Integer> nodes = new ArrayList<>();
}

package ch.oldschoolsnit.models;

import java.nio.ByteBuffer;
import java.util.Base64;

public class Buffer
{
	public String uri = "data:application/gltf-buffer;base64,";
	public int byteLength;

	public Buffer(ByteBuffer inputBuffer)
	{
		var roBuffer = inputBuffer.asReadOnlyBuffer();
		roBuffer.position(0);
		byte[] bytes = new byte[roBuffer.limit()];
		roBuffer.get(bytes, 0, bytes.length);
		var base64 = Base64.getEncoder().encodeToString(bytes);

		uri += base64;
		byteLength = roBuffer.limit();
	}
}

/*
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ch.oldschoolsnit.models;


import java.awt.*;

// Originally from RuneLite cache
// Additions made for calculating average of 3 colors
// Additions made by Bram91 for the model dumper plugin.
public final class JagexColor
{
	public static final double BRIGHTNESS_MAX = .6;
	public static final double BRIGHTNESS_HIGH = .7;
	public static final double BRIGHTNESS_LOW = .8;
	public static final double BRIGHTNESS_MIN = .9;

	private static final double HUE_OFFSET = (.5 / 64.D);
	private static final double SATURATION_OFFSET = (.5 / 8.D);

	private JagexColor()
	{
	}

	// take 3 Jagex HSL colors and make a single RGB color to represent them
	public static Color HSLtoRGBAvg(int hsl1, int hsl2, int hsl3)
	{
		Color c1 = new Color(HSLtoRGB((short) hsl1, BRIGHTNESS_MIN));
		Color c2 = new Color(HSLtoRGB((short) hsl2, BRIGHTNESS_MIN));
		Color c3 = new Color(HSLtoRGB((short) hsl3, BRIGHTNESS_MIN));

		// compute color average using squares
		// uses squared approach from https://sighack.com/post/averaging-rgb-colors-the-right-way
		int r = c1.getRed() * c1.getRed() + c2.getRed() * c2.getRed() + c3.getRed() * c3.getRed();
		int g = c1.getGreen() * c1.getGreen() + c2.getGreen() * c2.getGreen() + c3.getGreen() * c3.getGreen();
		int b = c1.getBlue() * c1.getBlue() + c2.getBlue() * c2.getBlue() + c3.getBlue() * c3.getBlue();

		r = (int) Math.round(Math.sqrt((double) r / 3.0d));
		g = (int) Math.round(Math.sqrt((double) g / 3.0d));
		b = (int) Math.round(Math.sqrt((double) b / 3.0d));

		return new Color(r, g, b);
	}

	public static short packHSL(int hue, int saturation, int luminance)
	{
		return (short) ((short) (hue & 63) << 10
			| (short) (saturation & 7) << 7
			| (short) (luminance & 127));
	}

	public static int unpackHue(short hsl)
	{
		return hsl >> 10 & 63;
	}

	public static int unpackSaturation(short hsl)
	{
		return hsl >> 7 & 7;
	}

	public static int unpackLuminance(short hsl)
	{
		return hsl & 127;
	}

	public static String formatHSL(short hsl)
	{
		return String.format("%02Xh%Xs%02Xl", unpackHue(hsl), unpackSaturation(hsl), unpackLuminance(hsl));
	}

	public static int HSLtoRGB(short hsl, double brightness)
	{
		double hue = (double) unpackHue(hsl) / 64.D + HUE_OFFSET;
		double saturation = (double) unpackSaturation(hsl) / 8.D + SATURATION_OFFSET;
		double luminance = (double) unpackLuminance(hsl) / 128.D;

		// This is just a standard hsl to rgb transform
		// the only difference is the offsets above and the brightness transform below
		double chroma = (1.D - Math.abs((2.D * luminance) - 1.D)) * saturation;
		double x = chroma * (1 - Math.abs(((hue * 6.D) % 2.D) - 1.D));
		double lightness = luminance - (chroma / 2);

		double r = lightness, g = lightness, b = lightness;
		switch ((int) (hue * 6.D))
		{
			case 0:
				r += chroma;
				g += x;
				break;
			case 1:
				g += chroma;
				r += x;
				break;
			case 2:
				g += chroma;
				b += x;
				break;
			case 3:
				b += chroma;
				g += x;
				break;
			case 4:
				b += chroma;
				r += x;
				break;
			default:
				r += chroma;
				b += x;
				break;
		}

		int rgb = ((int) (r * 256.0D) << 16)
			| ((int) (g * 256.0D) << 8)
			| (int) (b * 256.0D);

		rgb = adjustForBrightness(rgb, brightness);

		if (rgb == 0)
		{
			rgb = 1;
		}
		return rgb;
	}

	public static int adjustForBrightness(int rgb, double brightness)
	{
		double r = (double) (rgb >> 16) / 256.0D;
		double g = (double) (rgb >> 8 & 255) / 256.0D;
		double b = (double) (rgb & 255) / 256.0D;

		r = Math.pow(r, brightness);
		g = Math.pow(g, brightness);
		b = Math.pow(b, brightness);

		return ((int) (r * 256.0D) << 16)
			| ((int) (g * 256.0D) << 8)
			| (int) (b * 256.0D);
	}

	public static int[] createPalette(double brightness)
	{
		int[] colorPalette = new int[65536];
		for (int i = 0; i < colorPalette.length; i++)
		{
			colorPalette[i] = HSLtoRGB((short) i, brightness);
		}
		return colorPalette;
	}
}

package ch.oldschoolsnit.models;

import java.lang.reflect.Array;

public class Accessor
{
	public int bufferView;
	public int byteOffset;
	public String type;
	public int componentType;
	public int count;
	public Float[] max;
	public Float[] min;

	public Accessor(int bufferView, int byteOffset, String type, int componentType, int count)
	{
		this.bufferView = bufferView;
		this.byteOffset = byteOffset;
		this.type = type;
		this.componentType = componentType;
		this.count = count;
	}
}

package ch.oldschoolsnit.models;

import java.util.ArrayList;

public class Primitive
{
	public Attribute attributes;

	/*
	By default, the geometry data is assumed to describe a triangle mesh. For the case of indexed geometry,
	this means that three consecutive elements of the indices accessor are assumed to contain the indices of a single triangle.
	For non-indexed geometry, three elements of the vertex attribute accessors are assumed to contain the attributes of the three vertices of a triangle.
	 */
	public int indices;
	public int material; //The id of the material for the mesh.
	public int mode = 4;
}

package ch.oldschoolsnit.models;

import java.util.ArrayList;
import java.util.Collections;

public class VecUtil
{
	public static Float[] GetMin(ArrayList<Float> values)
	{
		var list1 = new ArrayList<Float>();
		var list2 = new ArrayList<Float>();
		var list3 = new ArrayList<Float>();

		for (int i = 0; i < 9; i++)
		{
			switch (i % 3)
			{
				case 0:
					list1.add(values.get(i));
					break;
				case 1:
					list2.add(values.get(i));
					break;
				case 2:
					list3.add(values.get(i));
					break;
			}
		}

		var retVal = new Float[3];
		retVal[0] = Collections.min(list1);
		retVal[1] = Collections.min(list2);
		retVal[2] = Collections.min(list3);
		return retVal;
	}

	public static Float[] GetMax(ArrayList<Float> values)
	{
		var list1 = new ArrayList<Float>();
		var list2 = new ArrayList<Float>();
		var list3 = new ArrayList<Float>();

		for (int i = 0; i < 9; i++)
		{
			switch (i % 3)
			{
				case 0:
					list1.add(values.get(i));
					break;
				case 1:
					list2.add(values.get(i));
					break;
				case 2:
					list3.add(values.get(i));
					break;
			}
		}

		var retVal = new Float[3];
		retVal[0] = Collections.max(list1);
		retVal[1] = Collections.max(list2);
		retVal[2] = Collections.max(list3);
		return retVal;
	}
}

package ch.oldschoolsnit.models;

public class Material
{
	public PbrMetallicRoughness pbrMetallicRoughness = new PbrMetallicRoughness();
	public boolean doubleSided = true;

}

package ch.oldschoolsnit.models;

public class Attribute
{
	public int POSITION;
}

package ch.oldschoolsnit.models;

import ch.oldschoolsnit.TextureColor;
import static ch.oldschoolsnit.models.JagexColor.createPalette;
import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import java.awt.Color;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.List;
import net.runelite.api.Model;

public class GLTF
{
	public int scene = 0;
	public ArrayList<Node> nodes = new ArrayList<>();
	public ArrayList<Scene> scenes = new ArrayList<>();
	public ArrayList<Mesh> meshes = new ArrayList<>();
	/*
	Too lazy to deal with byte alignment and all that, so we just have two different buffers:
	0: Vertex Buffer
	1: Facet Buffer
	 */
	public Buffer[] buffers = new Buffer[2];
	public ArrayList<Material> materials = new ArrayList<>();
	public ArrayList<BufferView> bufferViews = new ArrayList<>();
	public ArrayList<Accessor> accessors = new ArrayList<>();
	public Asset asset = new Asset();
	private final transient int VERTEX_BUFFER_ID = 0;
	private final transient int FACET_BUFFER_ID = 1;
	/*
	Stolen off of Stackoverflow:
	GL_ELEMENT_ARRAY_BUFFER is used to indicate the buffer you're presenting contains the indices of each element in the "other" (GL_ARRAY_BUFFER) buffer.
	 */
	private final transient int GL_ARRAY_BUFFER = 34962;
	private final transient int GL_ELEMENT_ARRAY_BUFFER = 34963;
	private final transient int FLOAT_BYTE_LENGTH = 4;
	private final transient int SHORT_BYTE_LENGTH = 2;
	private final transient String VEC3 = "VEC3";
	private final transient String SCALAR = "SCALAR";
	private final transient int GL_FLOAT = 5126;
	private final transient int GLTF_UNSIGNED_SHORT = 5123;
	private transient int bufferViewIndex = 0;
	private transient int accessorIndex = 0;
	private final static int[] colorPalette = createPalette(JagexColor.BRIGHTNESS_MIN);
	private transient List<Color> knownColors = new ArrayList<>();

	public GLTF(Model model)
	{
		int vertex_index = 0;
		var vertex_buffer_size = model.getFaceCount() * 3 * 3 * FLOAT_BYTE_LENGTH; //3 floats per position, 3 positions per triangle
		var vertex_buffer = ByteBuffer.allocate(vertex_buffer_size);
		vertex_buffer.order(ByteOrder.LITTLE_ENDIAN);

		var idx_buffer_size = model.getFaceCount() * 3 * SHORT_BYTE_LENGTH; // 3 positions per face.
		var index_buffer = ByteBuffer.allocate(idx_buffer_size);
		index_buffer.order(ByteOrder.LITTLE_ENDIAN);

		var faceIndexes1 = model.getFaceIndices1();
		var faceIndexes2 = model.getFaceIndices2();
		var faceIndexes3 = model.getFaceIndices3();

		var vertsX = model.getVerticesX();
		var vertsY = model.getVerticesY();
		var vertsZ = model.getVerticesZ();

		var mesh = new Mesh();

		int materialIndex = 0;
		boolean hasTextures = model.getFaceTextures() != null;

		for (int faceIndex = 0; faceIndex < model.getFaceCount(); ++faceIndex)
		{
			int vi1 = faceIndexes1[faceIndex];
			int vi2 = faceIndexes2[faceIndex];
			int vi3 = faceIndexes3[faceIndex];

			//The indexes are always local to the accessor.
			index_buffer.putShort((short) 0);
			index_buffer.putShort((short) 1);
			index_buffer.putShort((short) 2);

			int byteOffset = faceIndex * 3 * SHORT_BYTE_LENGTH;
			int byteLength = 3 * SHORT_BYTE_LENGTH;

			var bView = new BufferView(FACET_BUFFER_ID, byteOffset, byteLength, GL_ELEMENT_ARRAY_BUFFER);
			bufferViews.add(bView);
			var accessor = new Accessor(bufferViewIndex, 0, SCALAR, GLTF_UNSIGNED_SHORT, 3);
			accessors.add(accessor);
			bufferViewIndex++;

			//Then create the bufferview and accessor that is for ALL 3 verts.
			int vertByteOffset = vertex_index * 9 * FLOAT_BYTE_LENGTH;
			int vertByteLength = 9 * FLOAT_BYTE_LENGTH;

			var vertBView = new BufferView(VERTEX_BUFFER_ID, vertByteOffset, vertByteLength, GL_ARRAY_BUFFER);
			bufferViews.add(vertBView);
			var vertAccessor = new Accessor(bufferViewIndex, 0, VEC3, GL_FLOAT, 3);
			bufferViewIndex++;
			var coords = new ArrayList<Float>();

			//Add the 3 verts to the vert buffer
			var coord1 = AddVert(vi1, vertsX, vertsY, vertsZ, vertex_buffer);
			var coord2 = AddVert(vi2, vertsX, vertsY, vertsZ, vertex_buffer);
			var coord3 = AddVert(vi3, vertsX, vertsY, vertsZ, vertex_buffer);

			coords.addAll(List.of(coord1));
			coords.addAll(List.of(coord2));
			coords.addAll(List.of(coord3));

			vertAccessor.min = VecUtil.GetMin(coords);
			vertAccessor.max = VecUtil.GetMax(coords);

			accessors.add(vertAccessor);

			var prim = new Primitive();
			prim.indices = accessorIndex;
			var attr = new Attribute();
			attr.POSITION = accessorIndex + 1;
			prim.attributes = attr;

			//Create the material here

			//This is practically lifted from Bram91's obj exporter. Therefore:
			/*
			 * BSD 2-Clause License
			 *
			 * Copyright (c) 2020, bram91
			 * All rights reserved.
			 *
			 * Redistribution and use in source and binary forms, with or without
			 * modification, are permitted provided that the following conditions are met:
			 *
			 * 1. Redistributions of source code must retain the above copyright notice, this
			 *    list of conditions and the following disclaimer.
			 *
			 * 2. Redistributions in binary form must reproduce the above copyright notice,
			 *    this list of conditions and the following disclaimer in the documentation
			 *    and/or other materials provided with the distribution.
			 *
			 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
			 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
			 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
			 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
			 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
			 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
			 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
			 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
			 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
			 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
			 */

			//Sometimes we can get the color off of the texture
			Color c;
			if (hasTextures)
			{
				var textureId = model.getFaceTextures()[faceIndex];
				c = TextureColor.getColor(textureId);
			}
			//Sometimes we have to get it from the average colors of the vertices.
			else
			{
				if (model.getFaceColors3()[faceIndex] == -1)
				{
					// face should be shaded flat
					int colorIndex = model.getFaceColors1()[faceIndex];
					int rgbColor = colorPalette[colorIndex];
					c = new Color(rgbColor);
				}
				else
				{
					// get average color of vertices
					int c1 = model.getFaceColors1()[faceIndex];
					int c2 = model.getFaceColors2()[faceIndex];
					int c3 = model.getFaceColors3()[faceIndex];
					c = JagexColor.HSLtoRGBAvg(c1, c2, c3);
				}
			}

			int ci = knownColors.indexOf(c);
			var mat = new Material();
			if (ci == -1)
			{
				knownColors.add(c);

				double r = (double) c.getRed() / 255.0d;
				double g = (double) c.getGreen() / 255.0d;
				double b = (double) c.getBlue() / 255.0d;


				var roughness = new PbrMetallicRoughness();
				roughness.baseColorFactor = new double[]{r, g, b, 0.0D};
				mat.pbrMetallicRoughness = roughness;
				materials.add(mat);

				prim.material = materialIndex;
				materialIndex++;
			}
			else
			{
				prim.material = ci;
			}

			//Bram91 plagiarism end

			mesh.primitives.add(prim);

			accessorIndex += 2;
			vertex_index++;
		}

		buffers[0] = new Buffer(vertex_buffer);
		buffers[1] = new Buffer(index_buffer);
		meshes.add(mesh);
		var node = new Node();
		nodes.add(node);
		var scene = new Scene();
		scene.nodes.add(0);
		scenes.add(scene);
	}

	public Float[] AddVert(int vertIndex, float[] vertsX, float[] vertsY, float[] vertsZ, ByteBuffer vertexBuffer)
	{
		float x = vertsX[vertIndex];
		float y = -vertsY[vertIndex];
		float z = -vertsZ[vertIndex];

		vertexBuffer.putFloat(x);
		vertexBuffer.putFloat(y);
		vertexBuffer.putFloat(z);

		return new Float[]{x, y, z};
	}

	public String ToJson(Gson gson)
	{
		var built = gson.newBuilder()
			.setFieldNamingPolicy(FieldNamingPolicy.IDENTITY)
			.create();
		return built.toJson(this);
	}
}
package ch.oldschoolsnit.models;

public class PbrMetallicRoughness
{
	public Float metallicFactor = 0.0F;
	public Float roughnessFactor = 1.0F;
	public double[] baseColorFactor = {0.0F, 0.0F, 0.0F, 0.0F};
}

package ch.oldschoolsnit.models;

public class ModelSnapshot
{
}

package ch.oldschoolsnit.records;

public class NpcKill
{
	private int NpcId;
	private String apiKey;
	private Long accountHash;

	public NpcKill(int npcId, String apiKey, Long accountHash)
	{
		NpcId = npcId;
		this.apiKey = apiKey;
		this.accountHash = accountHash;
	}
}
package ch.oldschoolsnit.records;

public class ModelUpdate
{
	private String minifiedGltf;
	private Long accountHash;
	private String apiKey;

	public ModelUpdate(String minifiedGltf, Long accountHash, String apiKey)
	{
		this.minifiedGltf = minifiedGltf;
		this.accountHash = accountHash;
		this.apiKey = apiKey;
	}
}

package ch.oldschoolsnit.records;

public class BlastMineVarbitChangeInfo
{
	public Integer ItemId;
	public Integer ItemQuantity;

	public BlastMineVarbitChangeInfo(Integer itemId, Integer itemCount)
	{
		ItemId = itemId;
		ItemQuantity = itemCount;
	}
}

package ch.oldschoolsnit.records;

public class XpDrop
{
	private String skill;
	private Integer amount;
	private Integer currentTotal;
	private String apiKey;
	private Long accountHash;

	public XpDrop(String skill, Integer amount, Integer currentTotal, String apiKey, Long accountHash)
	{
		this.skill = skill;
		this.amount = amount;
		this.currentTotal = currentTotal;
		this.apiKey = apiKey;
		this.accountHash = accountHash;
	}
}


package ch.oldschoolsnit.records;

public class UserLocation
{
	private int x_coord;
	private int y_coord;
	private String apiKey;

	private Long accountHash;

	public UserLocation(int xCoord, int yCoord, String apiKey, Long accountHash)
	{
		x_coord = xCoord;
		y_coord = yCoord;
		this.apiKey = apiKey;
		this.accountHash = accountHash;
	}
}

package ch.oldschoolsnit.records;

public class ItemDrop
{
	private Integer itemId;
	private Integer amount;
	private String apiKey;
	private Long accountHash;
	private Integer npcId = null;

	public ItemDrop(int itemId, int amount, String apiKey, Long accountHash)
	{
		this.itemId = itemId;
		this.amount = amount;
		this.apiKey = apiKey;
		this.accountHash = accountHash;
	}

	public ItemDrop(int itemId, int amount, int npcId, String apiKey, Long accountHash)
	{
		this.itemId = itemId;
		this.amount = amount;
		this.npcId = npcId;
		this.apiKey = apiKey;
		this.accountHash = accountHash;
	}
}


package ch.oldschoolsnit.records;

public class NameSignIn
{
	private String runescapeName;
	private String apiKey;
	private Long accountHash;
	private Integer accountType;

	public NameSignIn(String runescapeName, String apiKey, Long accountHash, Integer accountType)
	{
		this.runescapeName = runescapeName;
		this.apiKey = apiKey;
		this.accountHash = accountHash;
		this.accountType = accountType;
	}
}

package ch.oldschoolsnit;

import ch.oldschoolsnit.models.GLTF;
import ch.oldschoolsnit.records.*;
import com.google.gson.FieldNamingPolicy;
import com.google.gson.Gson;
import net.runelite.api.Client;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;

@Slf4j
public class OldSchoolSnitchClient
{
	@Inject
	private OldSchoolSnitchConfig config;
	@Inject
	private Client gameClient;
	private final OkHttpClient client;
	private final Gson gson;
	public static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
	private final String baseUrl = "https://oldschoolsnit.ch";


	@Inject
	private OldSchoolSnitchClient(OkHttpClient client, Gson gson)
	{
		this.client = client;
		this.gson = gson.newBuilder()
			.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES)
			.create();
	}

	public void SignIn(NameSignIn name)
	{
		RequestBody body = RequestBody.create(JSON, gson.toJson(name));
		Request request = new Request.Builder()
			.url(baseUrl + "/api/name")
			.post(body)
			.build();

		makeRequest(request);
	}

	public void sendXP(XpDrop xpDrop)
	{
		RequestBody body = RequestBody.create(JSON, gson.toJson(xpDrop));
		Request request = new Request.Builder()
			.url(baseUrl + "/api/xp")
			.post(body)
			.build();

		makeRequest(request);
	}

	public void sendKill(NpcKill kill)
	{
		RequestBody body = RequestBody.create(JSON, gson.toJson(kill));
		Request request = new Request.Builder()
			.url(baseUrl + "/api/kill")
			.post(body)
			.build();

		makeRequest(request);
	}

	public void sendItem(ItemDrop itemDrop)
	{
		RequestBody body = RequestBody.create(JSON, gson.toJson(itemDrop));
		Request request = new Request.Builder()
			.url(baseUrl + "/api/item")
			.post(body)
			.build();
		makeRequest(request);
	}

	public void sendLocation(UserLocation location)
	{
		RequestBody body = RequestBody.create(JSON, gson.toJson(location));
		Request request = new Request.Builder()
			.url(baseUrl + "/api/location")
			.post(body)
			.build();
		makeRequest(request);
	}

	public void sendModel(GLTF model, long accountHash, String apiKey)
	{
		String gltfJson = model.ToJson(gson);
		var mUpdate = new ModelUpdate(gltfJson, accountHash, apiKey);
		RequestBody body = RequestBody.create(JSON, gson.toJson(mUpdate));
		Request request = new Request.Builder()
			.url(baseUrl + "/api/model")
			.post(body)
			.build();
		makeRequest(request);
	}

	private final Callback callback = new Callback()
	{
		@Override
		public void onFailure(Call call, IOException e)
		{
			log.error("Error in OldSchoolSnitchClient", e);
		}

		@Override
		public void onResponse(Call call, Response response) throws IOException
		{
			response.close();
		}
	};

	public void makeRequest(Request request)
	{
		client.newCall(request).enqueue(callback);
	}

}

package ch.oldschoolsnit;

import ch.oldschoolsnit.models.GLTF;
import ch.oldschoolsnit.models.ModelSnapshot;
import java.awt.image.BufferedImage;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.game.ItemStack;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.loottracker.LootRecordType;

import com.google.inject.Provides;
import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;

import java.util.Arrays;
import java.util.EnumMap;
import java.util.Map;
import java.util.regex.Pattern;

import ch.oldschoolsnit.records.*;

@Slf4j
@PluginDescriptor(
	name = "Old School Snitch"
)
public class OldSchoolSnitchPlugin extends Plugin
{
	private static OldSchoolSnitchPlugin instance;

	public static Client getClient()
	{
		return instance.client;
	}

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	ScheduledExecutorService executor;

	@Inject
	private EventBus eventBus;

	@Inject
	private OldSchoolSnitchClient snitchClient;

	@Inject
	private OldSchoolSnitchConfig config;

	@Inject
	private ClientToolbar clientToolbar;
	private OldSchoolSnitchPanel oldSchoolSnitchPanel;
	private NavigationButton navButton;
	private final Map<Skill, Integer> previousSkillExpTable = new EnumMap<>(Skill.class);
	private static final Pattern WOOD_CUT_PATTERN = Pattern.compile("You get (?:some|an)[\\w ]+(?:logs?|mushrooms)\\.");
	private static final Pattern MINING_PATTERN = Pattern.compile(
		"You " +
			"(?:manage to|just)" +
			" (?:mined?|quarry) " +
			"(?:some|an?) " +
			"(?:copper|tin|clay|iron|silver|coal|gold|mithril|adamantite|runite|amethyst|sandstone|granite|barronite shards|barronite deposit|Opal|piece of Jade|Red Topaz|Emerald|Sapphire|Ruby|Diamond)" +
			"(?:\\.|!)");

	private Multiset<Integer> previousInventorySnapshot;
	private Integer containerChangedCount = 0;
	private Integer pendingInventoryUpdates = 0;
	private WorldPoint currentLocation = null;
	private String playerName = "";
	private BlastMineTrackingHelper blastMineTrackingHelper = new BlastMineTrackingHelper();

	private Multiset<Integer> getInventorySnapshot()
	{
		final ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
		Multiset<Integer> inventorySnapshot = HashMultiset.create();

		if (inventory != null)
		{
			Arrays.stream(inventory.getItems())
				.forEach(item -> inventorySnapshot.add(item.getId(), item.getQuantity()));
		}

		return inventorySnapshot;
	}


	@Override
	protected void startUp() throws Exception
	{
		log.debug("Old School Snitch started!");

		oldSchoolSnitchPanel = injector.getInstance(OldSchoolSnitchPanel.class);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
			.tooltip("Old School Snitch")
			.icon(icon)
			.priority(3)
			.panel(oldSchoolSnitchPanel)
			.build();

		clientToolbar.addNavigation(navButton);

		OldSchoolSnitchPlugin.instance = this;
	}

	@Subscribe
	public void onPlayerChanged(PlayerChanged playerChanged)
	{
		if (playerChanged.getPlayer().getId() == client.getLocalPlayer().getId() && !config.apiKey().isBlank())
		{
			var name = client.getLocalPlayer().getName();
			if(!Objects.equals(name, playerName)){
				var apiKey = config.apiKey();
				var accountHash = client.getAccountHash();
				var accountType = client.getVarbitValue(Varbits.ACCOUNT_TYPE);
				snitchClient.SignIn(new NameSignIn(name, apiKey, accountHash, accountType));
				playerName = name;
			}
			else{
				log.debug("Skipping name update");
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			previousInventorySnapshot = getInventorySnapshot();
		}

		else if (event.getGameState() == GameState.LOGIN_SCREEN)
		{
			previousSkillExpTable.clear();
			pendingInventoryUpdates = 0;
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.debug("Old School Snitch stopped!");
		clientToolbar.removeNavigation(navButton);
	}

	private boolean doLocation(){
		return !isTempWorld() && !config.apiKey().isBlank() && config.locationTrackingCheckbox();
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		if (doLocation())
		{
			Long accountHash = this.client.getAccountHash();
			String apiKey = config.apiKey();
			var loc = client.getLocalPlayer().getWorldLocation();
			int x = loc.getX();
			int y = loc.getY();
			int plane = loc.getPlane();

			if (loc != null && currentLocation != null && (x != currentLocation.getX() || y != currentLocation.getY() || plane != currentLocation.getPlane()))
			{
				snitchClient.sendLocation(new UserLocation(x, y, apiKey, accountHash));
			}
			currentLocation = loc;
		}
	}

	private boolean isTempWorld()
	{
		var worldType = client.getWorldType();
		return worldType.contains(WorldType.BETA_WORLD)
			|| worldType.contains(WorldType.DEADMAN)
			|| worldType.contains(WorldType.FRESH_START_WORLD)
			|| worldType.contains(WorldType.LAST_MAN_STANDING)
			|| worldType.contains(WorldType.NOSAVE_MODE)
			|| worldType.contains(WorldType.PVP_ARENA)
			|| worldType.contains(WorldType.QUEST_SPEEDRUNNING)
			|| worldType.contains(WorldType.SEASONAL)
			|| worldType.contains(WorldType.TOURNAMENT_WORLD);
	}

	private boolean doLoot(){
		return !isTempWorld() && !config.apiKey().isBlank() && config.killAndDropTrackingCheckbox();
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (!doLoot())
		{
			return;
		}
		Long accountHash = this.client.getAccountHash();
		String apiKey = config.apiKey();
		// check to see that the container is the equipment or inventory
		ItemContainer container = event.getItemContainer();

		if (containerChangedCount < 1 && container == client.getItemContainer(InventoryID.INVENTORY))
		{
			log.debug("Setting baseline snapshot");
			previousInventorySnapshot = getInventorySnapshot();
			log.debug("Inventory count: " + previousInventorySnapshot.elementSet().size());

		}
		else if (containerChangedCount > 1 && container == client.getItemContainer(InventoryID.INVENTORY))
		{
			log.debug("Inventory changed!");
			log.debug("Pending requested updates: " + pendingInventoryUpdates);
			if (pendingInventoryUpdates > 0)
			{
				Multiset<Integer> currentInventorySnapshot = getInventorySnapshot();
				final Multiset<Integer> itemsReceived = Multisets.difference(currentInventorySnapshot, previousInventorySnapshot);
				//final Multiset<Integer> itemsRemoved = Multisets.difference(previousInventorySnapshot, currentInventorySnapshot);
				previousInventorySnapshot = currentInventorySnapshot;
				if (containerChangedCount > 1)
				{
					var set = itemsReceived.elementSet();
					log.debug("Items delta: " + set.size());
					for (var itemId : set)
					{
						var count = itemsReceived.count(itemId);
						if (config.debugMessagesCheckbox())
						{
							client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", ("Got " + count + " of " + itemId), null);
						}
						snitchClient.sendItem(new ItemDrop(itemId, count, apiKey, accountHash));
					}
				}
				pendingInventoryUpdates--;
			}
			else if (pendingInventoryUpdates == 0)
			{
				//Still need to update the inventory snapshot on say dropping items, getting non-skilling ones, etc.
				previousInventorySnapshot = getInventorySnapshot();
			}
			else
			{
				log.error("Somehow managed to get pendingInvUpdates < 0. This is a problem");
			}
		}
		containerChangedCount++;

	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (isTempWorld())
		{
			return;
		}
		var message = event.getMessage();
		if (event.getType() != ChatMessageType.SPAM)
		{
			return;
		}
		else if (WOOD_CUT_PATTERN.matcher(message).matches())
		{
			pendingInventoryUpdates++;
			log.debug("Woodcutting increasing pending inv");
		}
		else if (MINING_PATTERN.matcher(event.getMessage()).matches())
		{
			pendingInventoryUpdates++;
			log.debug("Mining increasing pending inv");
		}
		else if (message.contains("You catch a") || message.contains("You catch some") ||
			message.equals("Your cormorant returns with its catch."))
		{
			pendingInventoryUpdates++;
			log.debug("Fishing increasing pending inv");
		}
	}

	private boolean doXp()
	{
		return !isTempWorld() && !config.apiKey().isBlank();
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged)
	{
		if (doXp())
		{
			final Skill skill = statChanged.getSkill();
			final int xp = statChanged.getXp();
			Long accountHash = this.client.getAccountHash();
			String apiKey = config.apiKey();

			Integer previous = previousSkillExpTable.put(skill, xp);
			//Since we get all the skills upon login/load/whenever, we dont have to worry about seeding the table.
			if (previous != null)
			{
				int delta = xp - previous;
				if (delta > 0)
				{
					if (config.debugMessagesCheckbox())
					{
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", delta + "XP acquired in " + skill.name(), null);
					}

					snitchClient.sendXP(new XpDrop(skill.name(), delta, xp, apiKey, accountHash));

					if (statChanged.getSkill() == Skill.RUNECRAFT)
					{
						pendingInventoryUpdates++;
						log.debug("Runecrafting increasing pending inv");
					}
				}
			}
			else
			{
				snitchClient.sendXP(new XpDrop(skill.name(), 0, xp, apiKey, accountHash));
			}
		}
	}

	@Subscribe
	public void onServerNpcLoot(final ServerNpcLoot serverNpcLoot)
	{
		if (doLoot())
		{
			Long accountHash = this.client.getAccountHash();
			String apiKey = config.apiKey();
			final NPCComposition npc = serverNpcLoot.getComposition();
			if (config.debugMessagesCheckbox())
			{
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", npc.getName() + " Killed", null);
			}
			snitchClient.sendKill(new NpcKill(npc.getId(), apiKey, accountHash));
			for (ItemStack item : serverNpcLoot.getItems())
			{
				if (config.debugMessagesCheckbox())
				{
					client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", item.getQuantity() + " of item " + item.getId(), null);
				}
				snitchClient.sendItem(new ItemDrop(item.getId(), item.getQuantity(), npc.getId(), apiKey, accountHash));
			}
		}
	}

	@Subscribe
	public void onLootReceived(final LootReceived lootReceived)
	{
		if (doLoot())
		{
			Long accountHash = this.client.getAccountHash();
			String apiKey = config.apiKey();
			if (lootReceived.getType() != LootRecordType.NPC)
			{
				log.debug("Adding loot from non-npc Loot Received");
				for (ItemStack item : lootReceived.getItems())
				{
					if (config.debugMessagesCheckbox())
					{
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", item.getQuantity() + " of item " + item.getId(), null);
					}
					snitchClient.sendItem(new ItemDrop(item.getId(), item.getQuantity(), apiKey, accountHash));
				}
			}
		}
	}

	@Subscribe
	public void onModelSnapshot(final ModelSnapshot modelSnapshot)
	{
		clientThread.invokeLater(() -> {
			var model = client.getLocalPlayer().getModel();
			String apiKey = config.apiKey();
			var gltf = new GLTF(model);
			snitchClient.sendModel(gltf, client.getAccountHash(), apiKey);
		});
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		var result = this.blastMineTrackingHelper.varbitChangedHandler(varbitChanged);
		if (result.ItemQuantity > 0)
		{
			log.debug("Item Id: {}, Item Quantity: {}", result.ItemId, result.ItemQuantity);
			Long accountHash = this.client.getAccountHash();
			String apiKey = config.apiKey();
			snitchClient.sendItem(new ItemDrop(result.ItemId, result.ItemQuantity, apiKey, accountHash));
		}
	}


	@Provides
	OldSchoolSnitchConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(OldSchoolSnitchConfig.class);
	}
}

package ch.oldschoolsnit;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("Old School Snitch")
public interface OldSchoolSnitchConfig extends Config
{
	@ConfigItem(keyName = "apiKey", name = "Api Key", description = "API Key for the character to send the data for", secret = true)
	default String apiKey()
	{
		return "";
	}

	@ConfigItem(keyName = "enableLocationTracking", name = "Enable Location Tracking", description = "Send your in-game location to Old School Snitch")
	default boolean locationTrackingCheckbox()
	{
		return false;
	}

	@ConfigItem(keyName = "enableKillAndDropTracking", name = "Enable Kill and Drop Tracking", description = "Send NPC Kills and Drops to Old School Snitch")
	default boolean killAndDropTrackingCheckbox()
	{
		return false;
	}

	@ConfigItem(keyName = "enableDebugMessages", name = "Enable Debug Log Messages", description = "Enable Debug Log Messages")
	default boolean debugMessagesCheckbox()
	{
		return false;
	}
}

package ch.oldschoolsnit;

import ch.oldschoolsnit.records.BlastMineVarbitChangeInfo;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;

public class BlastMineTrackingHelper
{
	private Boolean coal_loaded = false;
	private Boolean gold_loaded = false;
	private Boolean mithril_loaded = false;
	private Boolean adamantite_loaded = false;
	private Boolean runite_loaded = false;

	private int coal_count = 0;
	private int gold_count = 0;
	private int mithril_count = 0;
	private int adamantite_count = 0;
	private int runite_count = 0;


	public BlastMineVarbitChangeInfo varbitChangedHandler(VarbitChanged varbitChanged)
	{
		switch (varbitChanged.getVarbitId())
		{
			case VarbitID.LOVAKENGJ_ORE_COAL_BIGGER:
				if (!this.coal_loaded)
				{
					this.coal_loaded = true;
					this.coal_count = varbitChanged.getValue();
					return new BlastMineVarbitChangeInfo(453, 0);
				}
				else
				{
					var previousCount = this.coal_count;
					var newCount = varbitChanged.getValue();
					var delta = newCount - previousCount;
					this.coal_count = newCount;
					return new BlastMineVarbitChangeInfo(453, delta);
				}

			case VarbitID.LOVAKENGJ_ORE_GOLD_BIGGER:
				if (!this.gold_loaded)
				{
					this.gold_loaded = true;
					this.gold_count = varbitChanged.getValue();
					return new BlastMineVarbitChangeInfo(444, 0);
				}
				else
				{
					var previousCount = this.gold_count;
					var newCount = varbitChanged.getValue();
					var delta = newCount - previousCount;
					this.gold_count = newCount;
					return new BlastMineVarbitChangeInfo(444, delta);
				}

			case VarbitID.LOVAKENGJ_ORE_MITHRIL_BIGGER:
				if (!this.mithril_loaded)
				{
					this.mithril_loaded = true;
					this.mithril_count = varbitChanged.getValue();
					return new BlastMineVarbitChangeInfo(447, 0);
				}
				else
				{
					var previousCount = this.mithril_count;
					var newCount = varbitChanged.getValue();
					var delta = newCount - previousCount;
					this.mithril_count = newCount;
					return new BlastMineVarbitChangeInfo(447, delta);
				}

			case VarbitID.LOVAKENGJ_ORE_ADAMANTITE_BIGGER:
				if (!this.adamantite_loaded)
				{
					this.adamantite_loaded = true;
					this.adamantite_count = varbitChanged.getValue();
					return new BlastMineVarbitChangeInfo(449, 0);
				}
				else
				{
					var previousCount = this.adamantite_count;
					var newCount = varbitChanged.getValue();
					var delta = newCount - previousCount;
					this.adamantite_count = newCount;
					return new BlastMineVarbitChangeInfo(449, delta);
				}

			case VarbitID.LOVAKENGJ_ORE_RUNITE_BIGGER:
				if (!this.runite_loaded)
				{
					this.runite_loaded = true;
					this.runite_count = varbitChanged.getValue();
					return new BlastMineVarbitChangeInfo(451, 0);
				}
				else
				{
					var previousCount = this.runite_count;
					var newCount = varbitChanged.getValue();
					var delta = newCount - previousCount;
					this.runite_count = newCount;
					return new BlastMineVarbitChangeInfo(451, delta);
				}

			default:
				return new BlastMineVarbitChangeInfo(1, 0);
		}
	}
}

/*
 * BSD 2-Clause License
 *
 * Copyright (c) 2020, bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ch.oldschoolsnit;

import net.runelite.api.Client;

import java.awt.Color;
import java.util.HashMap;
import java.util.Map;

public class TextureColor
{
	private static final Map<Integer, Color> colorCache = new HashMap<>();

	// get single average color from Jagex texture id
	public static Color getColor(int textureId)
	{
		if (colorCache.containsKey(textureId))
			return colorCache.get(textureId);

		Client client = OldSchoolSnitchPlugin.getClient();
		if (client == null)
			return new Color(255, 255, 255);
		int[] pixels = client.getTextureProvider().load(textureId);

		int r = 0;
		int g = 0;
		int b = 0;
		int n = 0;
		for (int pixel : pixels)
		{
			// skip transparent (black)
			if (pixel == 0)
				continue;

			Color c = new Color(pixel);
			r += c.getRed();
			g += c.getGreen();
			b += c.getBlue();
			n++;
		}

		Color c = new Color(r/n, g/n, b/n);
		colorCache.put(textureId, c);
		return c;
	}

}

package ch.oldschoolsnit;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class OldSchoolSnitchPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(OldSchoolSnitchPlugin.class);
		RuneLite.main(args);
	}
}
package ch.oldschoolsnit;

import ch.oldschoolsnit.models.VecUtil;
import java.util.ArrayList;
import java.util.Arrays;
import static org.junit.jupiter.api.Assertions.assertArrayEquals;
import org.junit.jupiter.api.Test;

public class VecUtilTest
{
	@Test
	public void testMin()
	{
		var values = new ArrayList<Float>();
		values.addAll(Arrays.asList(0f, 0f, 0f, 1f, 1f, 1f, 2f, 2f, 2f));
		Float[] expected = {0.0f, 0.0f, 0.0f};
		assertArrayEquals(expected, VecUtil.GetMin(values));
	}

	@Test
	public void testMax()
	{
		var values = new ArrayList<Float>();
		values.addAll(Arrays.asList(0f, 2f, 0f, 1f, 0f, 1f, 2f, 1f, 2f));
		Float[] expected = {2f, 2f, 2f};
		assertArrayEquals(expected, VecUtil.GetMax(values));
	}
}

