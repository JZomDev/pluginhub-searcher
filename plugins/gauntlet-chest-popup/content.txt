package com.github.ldavid432;

import static com.github.ldavid432.GauntletLootUtil.BACKGROUND_HEIGHT;
import static com.github.ldavid432.GauntletLootUtil.BACKGROUND_WIDTH;
import static com.github.ldavid432.GauntletLootUtil.IMAGE_CACHE_LIMIT;
import static com.github.ldavid432.GauntletLootUtil.getMousePosition;
import static com.github.ldavid432.GauntletLootUtil.rectangleFromImage;
import com.github.ldavid432.loot.Loot;
import com.github.ldavid432.loot.image.LootImage;
import com.github.ldavid432.loot.item.LootItem;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.tuple.Pair;

public class GauntletLootOverlay extends Overlay
{
	private final GauntletLootPlugin plugin;
	private final Client client;
	private final ItemManager itemManager;
	private final SpriteManager spriteManager;

	private BufferedImage closeButtonImage;
	private BufferedImage closeButtonHoveredImage;
	private final BufferedImage backgroundImage;
	private final ArrayList<Pair<String, BufferedImage>> imageCache = new ArrayList<>();

	private Rectangle closeButtonBounds;
	private final List<LootItemBounds> itemBounds = new ArrayList<>();

	@Value
	private static class LootItemBounds
	{
		LootItem item;
		Rectangle bounds;
	}

	@Inject
	public GauntletLootOverlay(GauntletLootPlugin plugin, Client client, ItemManager itemManager, SpriteManager spriteManager)
	{
		super(plugin);
		this.plugin = plugin;
		this.client = client;
		this.itemManager = itemManager;
		this.spriteManager = spriteManager;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(200.0f);
		setMovable(true);
		// Start at the correct x and y so the overlay doesn't jump the first time it's opened
		setBounds(getOverlayBounds(0, 0));

		backgroundImage = ImageUtil.loadImageResource(getClass(), "background.png");
	}

	@Nullable
	private BufferedImage getCloseButtonImage()
	{
		if (isInCloseButtonBounds(getMousePosition(client)))
		{
			if (closeButtonHoveredImage == null)
			{
				closeButtonHoveredImage = spriteManager.getSprite(SpriteID.SteelborderCloseButton._1, 0);
			}
			return closeButtonHoveredImage;
		}
		else
		{
			if (closeButtonImage == null)
			{
				closeButtonImage = spriteManager.getSprite(SpriteID.SteelborderCloseButton._0, 0);
			}
			return closeButtonImage;
		}
	}

	@Nullable
	private BufferedImage getImage(String imagePath)
	{
		BufferedImage image = imageCache.stream()
			.filter(pair -> Objects.equals(pair.getKey(), imagePath))
			.findFirst()
			.map(Pair::getValue)
			.orElse(null);

		if (image == null)
		{
			image = ImageUtil.loadImageResource(getClass(), imagePath);
			if (image != null)
			{
				imageCache.add(Pair.of(imagePath, image));
				if (imageCache.size() > IMAGE_CACHE_LIMIT)
				{
					imageCache.remove(0);
				}
			}
		}
		return image;
	}

	// Originally based on https://github.com/lalochazia/missed-clues
	@Override
	public Dimension render(Graphics2D graphics)
	{
		Loot loot = plugin.getLoot();

		if (loot == null)
		{
			resetBounds();
			return null;
		}

		if (backgroundImage != null)
		{
			setBounds(getOverlayBounds(BACKGROUND_WIDTH, BACKGROUND_HEIGHT));
			graphics.drawImage(backgroundImage, 0, 0, null);

			LootImage lootImage = loot.getImage();
			BufferedImage image = getImage(lootImage.getPath());
			if (image != null)
			{
				lootImage.renderImage(graphics, image);
			}

			renderTitle(graphics, loot.getTitle());

			final BufferedImage closeButtonImage = getCloseButtonImage();
			if (closeButtonImage != null)
			{
				renderCloseButton(graphics, closeButtonImage);
			}

			renderItems(graphics, loot.getItems());
		}

		return getBounds().getSize();
	}

	private void renderTitle(Graphics2D graphics, String title)
	{
		graphics.setFont(FontManager.getRunescapeBoldFont());

		// Measure
		Rectangle titleBounds = graphics.getFontMetrics().getStringBounds(title, graphics).getBounds();
		int titleX = (backgroundImage.getWidth() / 2) - ((int) titleBounds.getWidth() / 2);
		int titleY = 25;

		// Draw shadow
		graphics.setColor(Color.BLACK);
		graphics.drawString(title, titleX + 1, titleY + 1);

		// Draw actual text
		graphics.setColor(JagexColors.DARK_ORANGE_INTERFACE_TEXT);
		graphics.drawString(title, titleX, titleY);
	}

	private void renderCloseButton(Graphics2D graphics, BufferedImage closeButtonImage)
	{
		int closeX = backgroundImage.getWidth() - closeButtonImage.getWidth() - 8;
		int closeY = 7;

		closeButtonBounds = rectangleFromImage(
			closeX,
			closeY,
			closeButtonImage
		);

		graphics.drawImage(closeButtonImage, closeX, closeY, null);
	}

	private void renderItems(Graphics2D graphics, List<LootItem> items)
	{
		int x = 110;
		int y = 40;

		itemBounds.clear();

		for (int i = 0; i < items.size(); i++)
		{
			LootItem item = items.get(i);
			int itemId = item.getId();
			int quantity = item.getQuantity();

			BufferedImage itemImage;
			if (quantity > 1)
			{
				itemImage = itemManager.getImage(itemId, quantity, true);
			}
			else
			{
				itemImage = itemManager.getImage(itemId);
			}

			if (itemImage != null)
			{
				graphics.drawImage(itemImage, x, y, null);

				itemBounds.add(new LootItemBounds(item, rectangleFromImage(x, y, itemImage)));

				if ((i + 1) % 3 == 0)
				{
					x = x - (itemImage.getWidth() + 5) * 2;
					y += itemImage.getHeight() + 5;
				}
				else
				{
					x += itemImage.getWidth() + 5;
				}
			}
		}
	}

	private void resetBounds()
	{
		setBounds(getOverlayBounds(0, 0));
		closeButtonBounds = null;
		itemBounds.clear();
	}

	public boolean isInBounds(Point point)
	{
		return getBounds() != null && getBounds().contains(point);
	}

	public boolean isInCloseButtonBounds(Point point)
	{
		return closeButtonBounds != null && getBounds() != null && getOffsetBounds(closeButtonBounds).contains(point);
	}

	public LootItem getItemClicked(Point point)
	{
		if (getBounds() == null)
		{
			return null;
		}

		return itemBounds.stream()
			.filter(item -> getOffsetBounds(item.getBounds()).contains(point))
			.findFirst()
			.map(LootItemBounds::getItem)
			.orElse(null);
	}

	// Translate bounds from inside the overlay to their global position in the window/canvas
	private Rectangle getOffsetBounds(Rectangle boundsInOverlay)
	{
		return new Rectangle(
			boundsInOverlay.x + getBounds().x,
			boundsInOverlay.y + getBounds().y,
			boundsInOverlay.width,
			boundsInOverlay.height
		);
	}

	private Rectangle getOverlayBounds(int width, int height)
	{
		int x;
		int y;

		// Default positon is centered-ish
		if (getPreferredLocation() == null)
		{
			// Technically `(client.getCanvasWidth() - BACKGROUND_WIDTH) / 2` is more correctly centered but
			//  since the inventory is usually on the right we can do this to keep it more to the left
			x = (client.getCanvasWidth() / 2) - BACKGROUND_WIDTH;
			y = (client.getCanvasHeight() / 2) - BACKGROUND_HEIGHT;
		}
		else
		{
			x = getPreferredLocation().x;
			y = getPreferredLocation().y;
		}

		return new Rectangle(x, y, width, height);
	}

	public void shutDown()
	{
		resetBounds();
		imageCache.clear();
	}
}

package com.github.ldavid432;

import com.github.ldavid432.config.GauntletChestColor;
import com.github.ldavid432.config.GauntletTitle;
import com.github.ldavid432.config.GauntletTitle2;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(GauntletLootConfig.GROUP)
public interface GauntletLootConfig extends Config
{
	String GROUP = "gauntletchestpopup";
	String CHEST_COLOR = "chestSpriteColor";
	String CHEST_TITLE = "chestTitleText2";
	int CURRENT_VERSION = 1;

	@ConfigItem(
		name = "Click outside to dismiss",
		description = "Allows clicking outside the popup to dismiss it",
		keyName = "clickOutsideToDismiss",
		position = 0
	)
	default boolean isClickOutsideToDismissEnabled()
	{
		return true;
	}

	@ConfigSection(
		name = "Chest theme",
		description = "Configure the look of the chest loot UI",
		position = 2
	)
	String chestSection = "chestSection";

	@ConfigItem(
		name = "Chest Sprite Color",
		description = "Select the color for the chest sprite on the UI (Does not recolor the physical chest object)<br>" +
			"'Auto' selects either original or corrupted based on what you completed<br>" +
			"'Random' selects a random solid color each time you open the chest",
		keyName = CHEST_COLOR,
		section = chestSection,
		position = 0
	)
	default GauntletChestColor getChestSpriteColor()
	{
		return GauntletChestColor.AUTO;
	}

	@ConfigItem(
		name = "Chest Title (legacy)",
		description = "Customize the title text (legacy)",
		keyName = "chestTitleText",
		section = chestSection,
		position = 1,
		hidden = true
	)
	default GauntletTitle getChestTitleLegacy()
	{
		return GauntletTitle.UNSET;
	}

	@ConfigItem(
		name = "",
		description = "",
		keyName = "chestTitleText"
	)
	void setChestTitleLegacy(GauntletTitle title);

	@ConfigItem(
		name = "Chest Title",
		description = "Customize the title text<br>" +
			"Gauntlet - Either 'The Gauntlet' or 'The Corrupted Gauntlet'<br>" +
			"Hunllef - Either 'Crystalline Hunllef' or 'Corrupted Hunllef'<br>" +
			"Custom - Title set in 'Custom title' below ",
		keyName = CHEST_TITLE,
		section = chestSection,
		position = 1
	)
	default GauntletTitle2 getChestTitle2()
	{
		return GauntletTitle2.GAUNTLET;
	}

	@ConfigItem(
		name = "",
		description = "",
		keyName = CHEST_TITLE
	)
	void setChestTitle2(GauntletTitle2 title);

	@ConfigItem(
		name = "Custom title",
		description = "Custom title text, used if 'Chest Title' is set to 'Custom'",
		keyName = "chestCustomTitleText",
		section = chestSection,
		position = 2
	)
	default String getChestCustomTitle()
	{
		return "Red Prison";
	}

	@ConfigSection(
		name = "Rare item sounds",
		description = "Choose which items to play the rare item sound for",
		position = 3
	)
	String soundsSection = "soundsSection";

	@ConfigItem(
		name = "Weapon seed",
		description = "Play rare item sound for Weapon seeds",
		keyName = "playWeaponSeedSound",
		section = soundsSection,
		position = 0
	)
	default boolean shouldPlayWeaponSeedSound()
	{
		return false;
	}

	@ConfigItem(
		name = "Armour seed",
		description = "Play rare item sound for Armour seeds",
		keyName = "playArmourSeedSound",
		section = soundsSection,
		position = 1
	)
	default boolean shouldPlayArmourSeedSound()
	{
		return true;
	}

	@ConfigItem(
		name = "Enhanced Weapon seed",
		description = "Play rare item sound for Enhanced Weapon seeds",
		keyName = "playEnhancedSeedSound",
		section = soundsSection,
		position = 2
	)
	default boolean shouldPlayEnhancedSeedSound()
	{
		return true;
	}

	// Could make this handle elite clues AND scroll boxes but not worth the effort besides,
	//  who the hell is in priff without X marks the spot?
	@ConfigItem(
		name = "Elite Scroll Box",
		description = "Play rare item sound for Elite Clue Scroll boxes",
		keyName = "playEliteClueSound",
		section = soundsSection,
		position = 3
	)
	default boolean shouldPlayEliteClueSound()
	{
		return false;
	}

	@ConfigItem(
		name = "Youngllef",
		description = "Play rare item sound for the Youngllef pet",
		keyName = "playPetSound",
		section = soundsSection,
		position = 4
	)
	default boolean shouldPlayPetSound()
	{
		return true;
	}

	@ConfigItem(
		name = "",
		description = "",
		keyName = "lastSeenVersion",
		hidden = true
	)
	default int getLastSeenVersion()
	{
		return -1;
	}

	@ConfigItem(
		name = "",
		description = "",
		keyName = "lastSeenVersion",
		hidden = true
	)
	void setLastSeenVersion(int version);

}

package com.github.ldavid432.config;

import java.util.Random;

public enum GauntletChestColor
{
	ORIGINAL,
	CORRUPTED,
	BLUE,
	GREEN,
	PURPLE,
	WHITE,
	YELLOW,
	AUTO {
		@Override
		protected String getPathPart(GauntletChestColor autoColor)
		{
			// autoColor should never be AUTO, but just in case to prevent recursion
			return autoColor != AUTO ? autoColor.getPathPart(autoColor) : ORIGINAL.getPathPart(autoColor);
		}
	},
	RANDOM {
		@Override
		protected String getPathPart(GauntletChestColor autoColor)
		{
			// should never return AUTO so the autoColor doesn't actually matter here
			return values()[random.nextInt(values().length - 2)].getPathPart(ORIGINAL);
		}
	};

	private static final Random random = new Random();

	protected String getPathPart(GauntletChestColor autoColor)
	{
		return name().toLowerCase();
	}

	public String getPath(GauntletChestColor autoColor)
	{
		return "chest_" + getPathPart(autoColor) + ".png";
	}

}

package com.github.ldavid432.config;

@Deprecated
public enum GauntletTitle
{
	GAUNTLET,
	CORRUPTED_GAUNTLET,
	CUSTOM,
	UNSET
}

package com.github.ldavid432.config;

import com.github.ldavid432.GauntletLootConfig;
import com.github.ldavid432.GauntletLootUtil;
import javax.annotation.Nonnull;

public enum GauntletTitle2
{
	GAUNTLET,
	HUNLLEF,
	CUSTOM;

	@Nonnull
	public String getText(GauntletLootConfig config, String hunllefText, String gauntletText)
	{
		switch (this)
		{
			case GAUNTLET:
				return gauntletText;
			case CUSTOM:
				return config.getChestCustomTitle();
			case HUNLLEF:
				// Fall-through
			default:
				return hunllefText;
		}
	}
}

package com.github.ldavid432;

import com.github.ldavid432.loot.item.RareItem;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import net.runelite.api.Client;
import net.runelite.api.MenuEntry;

public class GauntletLootUtil
{
	static Rectangle rectangleFromImage(int x, int y, BufferedImage image)
	{
		return new Rectangle(x, y, image.getWidth(), image.getHeight());
	}

	static boolean anyMenuEntry(Client client, Predicate<MenuEntry> predicate)
	{
		return Arrays.stream(client.getMenu().getMenuEntries()).anyMatch(predicate);
	}

	static Point getMousePosition(Client client)
	{
		net.runelite.api.Point rlMousePos = client.getMouseCanvasPosition();
		return new Point(rlMousePos.getX(), rlMousePos.getY());
	}

	public static boolean isVowel(char c) {
		return "AEIOUaeiou".indexOf(c) != -1;
	}

	public static final int BACKGROUND_WIDTH = 230;
	public static final int BACKGROUND_HEIGHT = 200;

	public static final int CHEST_WIDTH = 112;
	public static final int CHEST_HEIGHT = 126;
	public static final int CHEST_OFFSET = 7;

	public static final String HUNLLEF = "Crystalline Hunllef";
	public static final String CORRUPTED_HUNLLEF = "Corrupted Hunllef";
	public static final List<RareItem> GAUNTLET_ITEMS = List.of(
		RareItem.CRYSTAL_WEAPON_SEED,
		RareItem.CRYSTAL_ARMOUR_SEED,
		RareItem.ENHANCED_WEAPON_SEED,
		RareItem.YOUNGLLEF,
		RareItem.ELITE_SCROLL_BOX,
		RareItem.GAUNTLET_CAPE,
		RareItem.CRYSTAL_SHARD
	);

	public static final int IMAGE_CACHE_LIMIT = 10;
}

package com.github.ldavid432.loot;

import com.github.ldavid432.GauntletLootConfig;
import static com.github.ldavid432.GauntletLootUtil.CORRUPTED_HUNLLEF;
import static com.github.ldavid432.GauntletLootUtil.GAUNTLET_ITEMS;
import static com.github.ldavid432.GauntletLootUtil.HUNLLEF;
import com.github.ldavid432.config.GauntletChestColor;
import com.github.ldavid432.loot.image.GauntletLootImage;
import com.github.ldavid432.loot.image.LootImage;
import com.github.ldavid432.loot.item.RareItem;
import java.util.List;
import java.util.function.Function;
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Sources to get loot
 */
@AllArgsConstructor
public enum LootSource
{
	GAUNTLET(
		HUNLLEF,
		config -> config.getChestTitle2().getText(config, HUNLLEF, "The Gauntlet"),
		config -> new GauntletLootImage(config, GauntletChestColor.ORIGINAL),
		GAUNTLET_ITEMS
	),
	CORRUPTED_GAUNTLET(
		CORRUPTED_HUNLLEF,
		config -> config.getChestTitle2().getText(config, CORRUPTED_HUNLLEF, "The Corrupted Gauntlet"),
		config -> new GauntletLootImage(config, GauntletChestColor.CORRUPTED),
		GAUNTLET_ITEMS
	),
	;

	@Getter
	private final String sourceName;
	private final Function<GauntletLootConfig, String> getTitle;
	@Getter
	private final Function<GauntletLootConfig, LootImage> getImage;
	@Getter
	private final List<RareItem> rareItems;

	LootSource(String sourceName, LootImage image, RareItem... rareItems)
	{
		this(sourceName, c -> sourceName, c -> image, List.of(rareItems));
	}

	LootSource(String sourceName, Function<GauntletLootConfig, String> getTitle, Function<GauntletLootConfig, LootImage> getImage, RareItem... rareItems)
	{
		this(sourceName, getTitle, getImage, List.of(rareItems));
	}

	public String getTitle(GauntletLootConfig config)
	{
		return getTitle.apply(config);
	}

	public LootImage getImage(GauntletLootConfig config)
	{
		return getImage.apply(config);
	}
}

package com.github.ldavid432.loot.image;

import com.github.ldavid432.GauntletLootConfig;
import static com.github.ldavid432.GauntletLootUtil.BACKGROUND_HEIGHT;
import static com.github.ldavid432.GauntletLootUtil.CHEST_HEIGHT;
import static com.github.ldavid432.GauntletLootUtil.CHEST_OFFSET;
import com.github.ldavid432.config.GauntletChestColor;

public class GauntletLootImage extends LootImage
{
	public GauntletLootImage(GauntletLootConfig config, GauntletChestColor autoColor)
	{
		super(config.getChestSpriteColor().getPath(autoColor), CHEST_OFFSET, BACKGROUND_HEIGHT - CHEST_HEIGHT - CHEST_OFFSET);
	}
}

package com.github.ldavid432.loot.image;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import lombok.Data;

@Data
public class LootImage
{
	private final String path;
	private final int x;
	private final int y;

	// render function so we can adjust the offset/positioning of the image as needed
	public void renderImage(Graphics2D graphics, BufferedImage image)
	{
		graphics.drawImage(image, x, y, null);
	}
}

package com.github.ldavid432.loot.item;

import com.github.ldavid432.GauntletLootConfig;
import java.util.function.Function;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;

/**
 * "Rare" or notable items to play a sound for and/or make examinable in the popup
 */
@AllArgsConstructor
public enum RareItem
{
	// Gauntlet
	CRYSTAL_WEAPON_SEED(ItemID.CRYSTAL_SEED_OLD, "A seed to be sung into the finest crystal weapons.", GauntletLootConfig::shouldPlayWeaponSeedSound),
	CRYSTAL_ARMOUR_SEED(ItemID.PRIF_ARMOUR_SEED, "A seed to be sung into the finest crystal armour.", GauntletLootConfig::shouldPlayArmourSeedSound),
	ENHANCED_WEAPON_SEED(ItemID.PRIF_WEAPON_SEED_ENHANCED, "A seed to be sung into the most powerful crystal weaponry.", GauntletLootConfig::shouldPlayEnhancedSeedSound),
	YOUNGLLEF(ItemID.GAUNTLETPET, "Looks like a bit of a nightmare.", GauntletLootConfig::shouldPlayPetSound),
	ELITE_SCROLL_BOX(ItemID.LEAGUE_CLUE_BOX_ELITE, "Contains an elite clue scroll.", GauntletLootConfig::shouldPlayEliteClueSound),
	GAUNTLET_CAPE(ItemID.GAUNTLET_CRYSTALLINE_CAPE, "Earned by only the most accomplished warriors of Prifddinas."),
	CRYSTAL_SHARD(ItemID.PRIF_CRYSTAL_SHARD, "A shard of the finest crystal, from the crystal city itself."),
	;

	@Getter
	private final int itemId;
	@Getter
	private final String examineText;
	private final Function<GauntletLootConfig, Boolean> shouldPlaySound;

	public boolean shouldPlaySound(GauntletLootConfig config)
	{
		return shouldPlaySound.apply(config);
	}

	// Examine text only constructor
	RareItem(int itemId, String examineText)
	{
		this(itemId, examineText, c -> false);
	}

}

package com.github.ldavid432.loot.item;

import static com.github.ldavid432.GauntletLootUtil.isVowel;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * Item to display in the popup, could be rare or just a basic item
 */
@AllArgsConstructor(access = AccessLevel.PRIVATE)
public class LootItem
{
	@Getter
	private final int id;
	@Getter
	private final String examineText;
	@Getter
	private final int quantity;
	@Getter
	private final String itemName;

	public static LootItem fromRareItem(RareItem item, int quantity, String itemName)
	{
		return new LootItem(item.getItemId(), item.getExamineText(), quantity, itemName);
	}

	public static LootItem fromBasicItem(int itemId, int quantity, String itemName){
		return new LootItem(itemId, basicExamineText(itemName, quantity), quantity, itemName);
	}

	private static String basicExamineText(String itemName, int quantity)
	{
		if (quantity <= 1)
		{
			if (!itemName.isEmpty() && isVowel(itemName.charAt(0)))
			{
				return "An " + itemName;
			}
			else
			{
				return "A " + itemName;
			}
		}
		else
		{
			return itemName + " x " + quantity;
		}
	}
}

package com.github.ldavid432.loot;

import com.github.ldavid432.GauntletLootConfig;
import com.github.ldavid432.loot.image.LootImage;
import com.github.ldavid432.loot.item.LootItem;
import com.github.ldavid432.loot.item.RareItem;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;

/**
 * Items received and their source
 * <p>
 * Image and title are decided upon loot being received in order to support things like random images
 */
@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
public class Loot
{
	@Nonnull
	private final LootSource source;
	@Nonnull
	@Getter
	private final List<LootItem> items;
	@Nonnull
	@Getter
	private LootImage image;
	@Nonnull
	@Getter
	private String title;

	public void updateImage(GauntletLootConfig config)
	{
		image = source.getImage(config);
	}

	public void updateTitle(GauntletLootConfig config)
	{
		title = source.getTitle(config);
	}

	public static Loot of(LootSource source, Collection<ItemStack> items, GauntletLootConfig config, ItemManager itemManager, Runnable playSound)
	{
		AtomicBoolean playedSound = new AtomicBoolean(false);

		return new Loot(
			source,
			items.stream()
				.map(stack -> {
					String itemName = itemManager.getItemComposition(stack.getId()).getName();
					RareItem rareItem = source.getRareItems()
						.stream()
						.filter(item -> item.getItemId() == stack.getId())
						.findFirst()
						.orElse(null);

					if (rareItem != null && rareItem.shouldPlaySound(config) && !playedSound.getAndSet(true))
					{
						playSound.run();
					}

					return rareItem != null ? LootItem.fromRareItem(rareItem, stack.getQuantity(), itemName) : LootItem.fromBasicItem(stack.getId(), stack.getQuantity(), itemName);
				})
				.collect(Collectors.toList()),
			source.getImage(config),
			source.getTitle(config)
		);
	}
}

package com.github.ldavid432;

import static com.github.ldavid432.GauntletLootUtil.anyMenuEntry;
import static com.github.ldavid432.GauntletLootUtil.getMousePosition;
import com.github.ldavid432.config.GauntletTitle;
import com.github.ldavid432.config.GauntletTitle2;
import com.github.ldavid432.loot.Loot;
import com.github.ldavid432.loot.LootSource;
import com.github.ldavid432.loot.item.LootItem;
import com.google.common.collect.ImmutableList;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Point;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.util.Arrays;
import java.util.Collection;
import java.util.Objects;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuShouldLeftClick;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.input.MouseAdapter;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;

@Slf4j
@PluginDescriptor(
	name = "Gauntlet Chest Popup",
	description = "Barrows chest style UI for the gauntlet chest!",
	tags = {"gauntlet", "loot", "chest", "sound", "hunllef", "hunlef"}
)
public class GauntletLootPlugin extends Plugin
{
	private static final int MENU_EXAMINE_ID = -1_337_000;

	@Inject
	private Client client;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private GauntletLootOverlay overlay;

	@Inject
	private GauntletLootConfig config;

	@Getter
	@Setter
	private Loot loot = null;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		mouseManager.registerMouseListener(mouseListener);
		client.getCanvas().addKeyListener(keyListener);

		if (config.getChestTitleLegacy() != GauntletTitle.UNSET)
		{
			// Migrate if custom
			if (config.getChestTitleLegacy() == GauntletTitle.CUSTOM)
			{
				config.setChestTitle2(GauntletTitle2.CUSTOM);
			}

			config.setChestTitleLegacy(GauntletTitle.UNSET);
		}

		// Since last seen version wasn't in 1.0 checking for only it will trigger for everyone who installs the plugin.
		//  By only triggering this during startup while not logged in we can "better" attempt to determine if this is a previous install or not.
		//  Still not totally accurate but better than nothing.
		if (config.getLastSeenVersion() < GauntletLootConfig.CURRENT_VERSION)
		{
			if (client.getGameState() != GameState.LOGGED_IN)
			{
				chatMessageManager.queue(
					QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(ColorUtil.wrapWithColorTag("Gauntlet Chest Popup has been updated! The popup is now movable!", Color.RED))
						.build()
				);
			}
			config.setLastSeenVersion(GauntletLootConfig.CURRENT_VERSION);
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		clearLoot();
		client.getCanvas().removeKeyListener(keyListener);
		mouseManager.unregisterMouseListener(mouseListener);
		overlay.shutDown();
		overlayManager.remove(overlay);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (Objects.equals(configChanged.getGroup(), GauntletLootConfig.GROUP))
		{
			if (isDisplayed())
			{
				if (Objects.equals(configChanged.getKey(), GauntletLootConfig.CHEST_COLOR))
				{
					loot.updateImage(config);
				}
				else if (Objects.equals(configChanged.getKey(), GauntletLootConfig.CHEST_TITLE))
				{
					loot.updateTitle(config);
				}
			}
		}
	}

	boolean isDisplayed()
	{
		return loot != null;
	}

	private void clearLoot()
	{
		loot = null;
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted event)
	{
		// For debugging and previewing your theme
		if (event.getCommand().equals("gauntletlootpreview"))
		{
			log.debug("Displaying Gauntlet loot preview");

			LootSource source = LootSource.GAUNTLET;
			if (event.getArguments().length >= 1 && event.getArguments()[0].equalsIgnoreCase("corrupted"))
			{
				source = LootSource.CORRUPTED_GAUNTLET;
			}

			processLoot(
				source.getSourceName(),
				ImmutableList.of(
					new ItemStack(ItemID.NATURERUNE, 130),
					new ItemStack(ItemID.PRIF_CRYSTAL_SHARD, 8),
					new ItemStack(ItemID.RUNE_FULL_HELM + 1, 4),
					new ItemStack(ItemID.RUNE_PICKAXE + 1, 3)
				)
			);
		}
	}

	@Subscribe
	public void onServerNpcLoot(ServerNpcLoot event)
	{
		if (event.getComposition() == null ||
			event.getComposition().getName() == null
		)
		{
			return;
		}

		processLoot(event.getComposition().getName(), event.getItems());
	}

	@Subscribe
	public void onLootReceived(LootReceived event)
	{
		if (event.getName() == null)
		{
			return;
		}

		processLoot(event.getName(), event.getItems());
	}

	private void processLoot(String sourceName, Collection<ItemStack> lootItems)
	{
		Arrays.stream(LootSource.values())
			.filter(source -> source.getSourceName().equals(sourceName))
			.findFirst()
			.ifPresent(source -> {
				log.debug("Displaying Gauntlet popup. Source: {}", source.getSourceName());

				loot = Loot.of(source, lootItems, config, itemManager, () -> {
					log.debug("Playing rare item sound for Gauntlet loot");
					// Rare item sound
					client.playSoundEffect(6765);
				});
			});
	}

	@Provides
	GauntletLootConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GauntletLootConfig.class);
	}

	private final KeyListener keyListener = new KeyAdapter()
	{
		@Override
		public void keyPressed(KeyEvent e)
		{
			if (isDisplayed() && e.getKeyCode() == KeyEvent.VK_ESCAPE)
			{
				clearLoot();
			}
		}
	};

	private final MouseListener mouseListener = new MouseAdapter()
	{
		@Override
		public MouseEvent mousePressed(MouseEvent event)
		{
			if (isDisplayed() && SwingUtilities.isLeftMouseButton(event))
			{
				if (overlay.isInBounds(event.getPoint()))
				{
					if (!client.isMenuOpen())
					{
						if (overlay.isInCloseButtonBounds(event.getPoint()))
						{
							log.debug("Gauntlet popup closed");
							clearLoot();
						}
						else
						{
							LootItem item = overlay.getItemClicked(event.getPoint());
							if (item != null)
							{
								// Don't consume event so the menu can be triggered
								return event;
							}
						}

						// Either Random click somewhere on the popup or close button
						event.consume();
					}
				}
				else if (config.isClickOutsideToDismissEnabled() &&
					anyMenuEntry(client, (entry -> Objects.equals(entry.getOption(), "Walk here"))))
				{
					// Dismiss if clicked outside in the world (somewhere with 'Walk here')
					//  This prevents dismissing when clicking UI elements like the inventory or chat
					log.debug("Dismissing Gauntlet popup");
					clearLoot();
				}
			}

			return event;
		}
	};

	@Subscribe
	public void onClientTick(ClientTick clientTick)
	{
		if (isDisplayed() && !client.isMenuOpen())
		{
			Point mousePos = getMousePosition(client);

			LootItem item = overlay.getItemClicked(mousePos);

			if (item != null)
			{
				final Menu menu = client.getMenu();

				MenuEntry examine = menu.createMenuEntry(-1)
					.setOption("Examine")
					.setTarget(ColorUtil.wrapWithColorTag(item.getItemName(), JagexColors.MENU_TARGET))
					.setType(MenuAction.RUNELITE)
					.setItemId(item.getId())
					.setIdentifier(MENU_EXAMINE_ID)
					.onClick(
						entry -> {
							log.debug("Examining Gauntlet popup item");
							client.addChatMessage(ChatMessageType.ITEM_EXAMINE, "", item.getExamineText(), "");
						}
					);

				MenuEntry cancel = menu.createMenuEntry(-1)
					.setOption("Cancel")
					.setType(MenuAction.CANCEL);

				menu.setMenuEntries(new MenuEntry[]{cancel, examine});
			}
			else if (overlay.isInCloseButtonBounds(mousePos))
			{
				final Menu menu = client.getMenu();

				MenuEntry close = menu.createMenuEntry(-1)
					.setOption("Close")
					.setType(MenuAction.RUNELITE)
					.onClick(entry -> clearLoot());

				MenuEntry cancel = menu.createMenuEntry(-1)
					.setOption("Cancel")
					.setType(MenuAction.CANCEL);

				menu.setMenuEntries(new MenuEntry[]{cancel, close});
			}
			else if (overlay.isInBounds(mousePos))
			{
				// Prevent actions from behind the overlay from showing
				final Menu menu = client.getMenu();

				MenuEntry cancel = menu.createMenuEntry(-1)
					.setOption("Cancel")
					.setType(MenuAction.CANCEL);

				menu.setMenuEntries(new MenuEntry[]{cancel});
			}
		}
	}

	@Subscribe
	public void onMenuShouldLeftClick(MenuShouldLeftClick event)
	{
		// Make the menu open on a left click when over an item
		if (anyMenuEntry(client, entry -> entry.getIdentifier() == MENU_EXAMINE_ID))
		{
			event.setForceRightClick(true);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		// Reset on logout
		if (event.getGameState() == GameState.LOGIN_SCREEN && isDisplayed())
		{
			clearLoot();
		}
	}

}

package com.github.ldavid432;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GauntletLootTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GauntletLootPlugin.class);
		RuneLite.main(args);
	}
}

