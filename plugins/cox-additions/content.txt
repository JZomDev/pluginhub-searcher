
package de0.coxthieving;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Arrays;
import java.util.List;

import javax.inject.Inject;

import de0.coxthieving.CoxThievingPlugin.GrubCollection;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class CoxThievingDatabox extends OverlayPanel {

  private CoxThievingPlugin plugin;
  private CoxThievingConfig config;

  @Inject
  public CoxThievingDatabox(CoxThievingPlugin plugin, CoxThievingConfig config) {
    super(plugin);
    this.plugin = plugin;
    this.config = config;
  }

  @Override
  public Dimension render(Graphics2D graphics) {
    int myindex;
    if (plugin.gc_local == null || plugin.gc_local.num_with_grubs == 0) {
      myindex = -1;
    } else {
      myindex = Arrays.binarySearch(plugin.gc_others, 0, plugin.gc_others_count,
          plugin.gc_local, plugin.comparator);
      if (myindex < 0)
        myindex = -myindex - 1;
    }
    int sum_grubs = plugin.num_grubs;
    for (int i = 0; i < plugin.gc_others_count; i++)
      sum_grubs += plugin.gc_others[i].num_with_grubs * config.grubRate() / 100;

    List<LayoutableRenderableEntity> elems = panelComponent.getChildren();
    elems.add(TitleComponent.builder().color(Color.WHITE).text(
        (sum_grubs == plugin.num_grubs ? "Grub count: " : "Est. grub count: ")
            + sum_grubs)
        .build());
    for (int i = 0; i < plugin.gc_others_count; i++) {
      if (i == myindex)
        add_gc_line(elems, plugin.gc_local);
      add_gc_line(elems, plugin.gc_others[i]);
    }
    if (myindex == plugin.gc_others_count)
      add_gc_line(elems, plugin.gc_local);
    return super.render(graphics);
  }

  private void add_gc_line(List<LayoutableRenderableEntity> elems,
      GrubCollection gc) {
    elems.add(LineComponent.builder().left(gc.displayname)
                           .right(String.valueOf(gc.num_with_grubs)).build());
  }

}

package de0.coxthieving;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class ScavHighlight extends Overlay {

  private Client client;

  @Inject
  public ScavHighlight(CoxThievingPlugin plugin, Client client) {
    super(plugin);
    this.client = client;
    setPosition(OverlayPosition.DYNAMIC);
    setLayer(OverlayLayer.ABOVE_SCENE);
  }

  @Override
  public Dimension render(Graphics2D g) {
    NPC scav = null;
    for (NPC npc : client.getNpcs()) {
      if (npc == null)
        continue;
      if (npc.getId() == 7602 || npc.getId() == 7603)
        scav = npc;
    }
    if (scav == null)
      return null;

    g.setFont(FontManager.getRunescapeBoldFont());
    String str;
    if (client.getVarbitValue(5424) == 1) {
      str = Integer.toString((scav.getHealthRatio() + 2) * 3 / 10);
    } else {
      str = scav.getHealthRatio() + "%";
    }
    Point point = scav.getCanvasTextLocation(g, str, scav.getLogicalHeight());
    if (point == null)
      return null;
    point = new Point(point.getX(), point.getY() + 20);
    OverlayUtil.renderTextLocation(g, point, str, Color.GREEN);
    return null;
  }

}

package de0.coxthieving;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;

import javax.inject.Inject;

import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Tile;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class ChestHighlight extends Overlay {

  private Client client;
  private CoxThievingPlugin plugin;
  private CoxThievingConfig config;

  private final int A = 0x50;
  private final Color[] palette = new Color[10];
  private final Color pcolor = new Color(0, 255, 0, A);

  private int last_gdfactor = -1;

  @Inject
  public ChestHighlight(Client client, CoxThievingPlugin plugin,
      CoxThievingConfig config) {
    super(plugin);
    this.client = client;
    this.plugin = plugin;
    this.config = config;
    setPosition(OverlayPosition.DYNAMIC);
    setLayer(OverlayLayer.ABOVE_SCENE);
  }

  @Override
  public Dimension render(Graphics2D g) {
    if (!config.highlightBatChests())
      return null;
    byte[][] solns = ChestData.CHEST_SOLNS[plugin.wind][plugin.rot];
    byte[][] locs = ChestData.CHEST_LOCS[plugin.wind];
    int gdfactor = config.gumdropFactor();
    if (gdfactor != last_gdfactor) {
      final float h0 = 1f / 6f;
      final float hf = gdfactor / 20.0f;
      final float s = 0.95f;
      final float b = 0.80f;
      int[] rgb = new int[10];
      rgb[0] = Color.HSBtoRGB(h0 + hf * -1.0f, s, b);
      rgb[1] = Color.HSBtoRGB(h0 + hf * -0.8f, s, b);
      rgb[2] = Color.HSBtoRGB(h0 + hf * -0.6f, s, b);
      rgb[3] = Color.HSBtoRGB(h0 + hf * -0.4f, s, b);
      rgb[4] = Color.HSBtoRGB(h0 + hf * -0.2f, s, b);
      rgb[5] = Color.HSBtoRGB(h0, s, b);
      rgb[6] = Color.HSBtoRGB(h0 + hf * 0.2f, s, b);
      rgb[7] = Color.HSBtoRGB(h0 + hf * 0.4f, s, b);
      rgb[8] = Color.HSBtoRGB(h0 + hf * 0.6f, s, b);
      rgb[9] = Color.HSBtoRGB(h0 + hf * 0.8f, s, b);
      for (int i = 0; i < 10; i++) {
        palette[i] = new Color(A << 24 | rgb[i] & 0xffffff, true);
      }
      last_gdfactor = gdfactor;
    }
    if (plugin.soln == -1) {
      for (byte n = 0; n < solns.length; n++) {
        if (plugin.not_solns.contains(n))
          continue;
        for (int i = 0; i < 4; i++) {
          Tile t = findChest(locs[solns[n][i] - 1], plugin.rot);
          if (t != null)
            highlightChest(t, palette[n], g);
        }
      }
    } else {
      byte[] b = solns[plugin.soln];
      for (int i = 0; i < b.length; i++) {
        Tile t = findChest(locs[b[i] - 1], plugin.rot);
        if (t != null) // tile outside of view
          highlightChest(t, pcolor, g);
      }
    }
    return null;
  }

  private void highlightChest(Tile t, Color c, Graphics2D g) {
    GameObject chest = t.getGameObjects()[0];
    if (chest == null)
      return;
    if (chest.getId() == CoxThievingPlugin.CCHEST
        || chest.getId() == CoxThievingPlugin.PCHEST) {
      g.setColor(c);
      if (chest.getCanvasLocation() != null)
        g.fill(chest.getConvexHull());
    }
  }

  private Tile findChest(byte[] coords, int rot) {
    // convert room coords to scene coords
    int rx = coords[0];
    int ry = coords[1];
    int chestX = plugin.room_base_x;
    int chestY = plugin.room_base_y;
    if (rot == 0) {
      chestX += rx;
      chestY += ry;
    } else if (rot == 1) {
      chestX += ry;
      chestY -= rx;
    } else if (rot == 2) {
      chestX -= rx;
      chestY -= ry;
    } else {
      chestX -= ry;
      chestY += rx;
    }
    if (chestX < 0 || chestY < 0 || chestX >= 104 || chestY >= 104)
      return null;
    return client.getScene().getTiles()[client.getPlane()][chestX][chestY];
  }

}

package de0.coxthieving;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("thieving")
public interface CoxThievingConfig extends Config {

  @ConfigItem(keyName = "highlightBats", name = "Highlight Potential Bats", description = "Highlight bat chests")
  default boolean highlightBatChests() {
    return true;
  }

  @ConfigItem(keyName = "gumdropFactor", name = "Gumdrop Highlight Factor", description = "Highlight bat chests in pretty colors")
  default int gumdropFactor() {
    return 0;
  }

  @ConfigItem(keyName = "grubRate", name = "Expected Grubs per Chest", description = "Average grubs per chest that contained some, for use in team count estimation")
  default int grubRate() {
    return 225;
  }

}
package de0.coxthieving;

public class ChestData {

  static byte[][] CCW_CHEST_LOCS = { { 19, 3 }, { 21, 4 }, { 15, 5 }, { 23, 6 },
      { 17, 6 }, { 20, 7 }, { 19, 8 }, { 22, 8 }, { 24, 8 }, { 13, 9 },
      { 16, 9 }, { 21, 10 }, { 26, 10 }, { 11, 11 }, { 23, 11 }, { 24, 11 },
      { 17, 12 }, { 27, 12 }, { 16, 13 }, { 21, 13 }, { 25, 13 }, { 19, 14 },
      { 21, 14 }, { 24, 14 }, { 26, 14 }, { 18, 15 }, { 25, 15 }, { 28, 15 },
      { 15, 16 }, { 12, 17 }, { 15, 17 }, { 20, 17 }, { 21, 17 }, { 27, 17 },
      { 11, 18 }, { 13, 18 }, { 24, 18 }, { 12, 19 }, { 17, 19 }, { 21, 19 },
      { 23, 19 }, { 25, 19 }, { 10, 20 }, { 19, 20 }, { 21, 20 }, { 24, 20 },
      { 8, 21 }, { 16, 21 }, { 13, 22 }, { 17, 22 }, { 20, 22 }, { 12, 23 },
      { 14, 23 }, { 19, 23 }, { 21, 23 }, { 13, 24 }, { 20, 24 }, { 24, 24 },
      { 17, 25 }, { 22, 25 }, { 15, 26 }, { 21, 26 }, { 16, 27 }, { 19, 27 } };

  static byte[][] THRU_CHEST_LOCS = { { 12, 2 }, { 9, 3 }, { 11, 3 }, { 8, 5 },
      { 14, 5 }, { 6, 6 }, { 11, 6 }, { 16, 6 }, { 21, 6 }, { 23, 6 }, { 8, 7 },
      { 9, 7 }, { 11, 7 }, { 14, 7 }, { 19, 7 }, { 24, 7 }, { 4, 8 }, { 13, 8 },
      { 15, 8 }, { 17, 8 }, { 21, 8 }, { 22, 8 }, { 6, 9 }, { 10, 9 },
      { 14, 9 }, { 17, 9 }, { 24, 9 }, { 6, 10 }, { 9, 10 }, { 20, 10 },
      { 25, 10 }, { 4, 11 }, { 12, 11 }, { 18, 11 }, { 21, 11 }, { 5, 12 },
      { 10, 12 }, { 16, 12 }, { 26, 12 }, { 13, 13 }, { 15, 13 }, { 17, 13 },
      { 20, 13 }, { 24, 13 }, { 4, 14 }, { 7, 14 }, { 8, 14 }, { 16, 14 },
      { 24, 14 }, { 11, 15 }, { 14, 15 }, { 21, 15 }, { 22, 15 }, { 27, 15 },
      { 5, 16 }, { 7, 16 }, { 13, 16 }, { 18, 16 }, { 26, 16 }, { 9, 17 },
      { 11, 17 }, { 13, 18 }, { 16, 18 }, { 20, 17 }, { 26, 18 }, { 14, 3 } };

  static byte[][] CW_CHEST_LOCS = { { 10, 29 }, { 6, 29 }, { 14, 28 },
      { 12, 28 }, { 17, 27 }, { 6, 27 }, { 2, 27 }, { 15, 26 }, { 14, 26 },
      { 11, 26 }, { 10, 26 }, { 8, 26 }, { 19, 25 }, { 2, 25 }, { 17, 24 },
      { 13, 24 }, { 9, 24 }, { 6, 24 }, { 17, 23 }, { 15, 23 }, { 12, 23 },
      { 7, 23 }, { 3, 23 }, { 10, 22 }, { 9, 22 }, { 17, 21 }, { 13, 21 },
      { 6, 21 }, { 3, 21 }, { 18, 20 }, { 15, 20 }, { 11, 20 }, { 7, 20 },
      { 5, 20 }, { 12, 19 }, { 9, 19 }, { 6, 19 }, { 17, 18 }, { 14, 18 },
      { 4, 18 }, { 15, 17 }, { 13, 17 }, { 10, 17 }, { 7, 17 }, { 6, 17 },
      { 18, 16 }, { 14, 16 }, { 4, 16 }, { 22, 15 }, { 18, 15 }, { 12, 15 },
      { 11, 15 }, { 8, 15 }, { 5, 15 }, { 21, 14 }, { 15, 14 }, { 9, 14 },
      { 7, 14 }, { 16, 13 }, { 12, 13 }, { 8, 13 }, { 5, 13 }, { 18, 12 },
      { 12, 11 }, { 9, 10 }, { 5, 10 }, { 10, 9 }, { 8, 9 }, { 9, 8 },
      { 12, 6 }, { 6, 7 }, { 12, 3 }, { 10, 4 }, { 8, 5 } };

  // Entrance angles: south=0, west=1, north=2, east=3
  static byte[][][] CCW_SOLNS = { // 3 (L)
      // rot 0
      { { 1, 17, 38, 54 }, { 2, 7, 36, 51 }, { 3, 5, 19, 30 },
          { 4, 22, 33, 49 }, { 6, 26, 32, 52 }, { 8, 14, 41, 43 },
          { 10, 11, 15, 35 }, { 12, 40, 53, 56 }, { 20, 29, 45, 61 },
          { 23, 31, 47, 55 } },
      // rot 1
      { { 1, 16, 17, 55 }, { 2, 7, 21, 37 }, { 3, 11, 15, 40 },
          { 4, 22, 27, 46 }, { 5, 9, 19, 45 }, { 6, 24, 26, 41 },
          { 8, 10, 28, 33 }, { 12, 13, 42, 54 }, { 14, 18, 23, 51 },
          { 20, 25, 32, 34 } },
      // rot 2
      { { 7, 13, 44, 59 }, { 8, 9, 40, 46 }, { 12, 18, 32, 57 },
          { 15, 16, 42, 45 }, { 20, 28, 51, 62 }, { 21, 39, 41, 58 },
          { 22, 25, 54, 64 }, { 23, 33, 37, 60 }, { 24, 34, 48, 55 },
          { 26, 27, 50, 63 } },
      // rot 3
      { { 8, 31, 47, 50 }, { 10, 30, 32, 59 }, { 14, 35, 54, 63 },
          { 15, 43, 44, 58 }, { 29, 39, 41, 61 }, { 33, 46, 52, 57 },
          { 34, 45, 49, 60 }, { 36, 40, 42, 62 }, { 37, 38, 51, 64 },
          { 48, 53, 55, 56 } } };

  // 20/20
  static byte[][][] THRU_SOLNS = { // 0 (S)
      {},
      // rot 1
      { { 1, 39, 43, 51 }, { 2, 15, 20, 53 }, { 3, 10, 42, 44 },
          { 4, 14, 38, 52 }, { 5, 6, 35, 41 }, { 7, 16, 34, 49 },
          { 8, 11, 22, 48 }, { 9, 12, 26, 27 }, { 13, 25, 30, 31 },
          { 19, 21, 54, 66 } },
      {},
      // rot 3
      { { 17, 24, 34, 58 }, { 18, 23, 35, 57 }, { 19, 26, 47, 65 },
          { 22, 25, 46, 55 }, { 28, 40, 52, 62 }, { 29, 41, 42, 63 },
          { 30, 32, 37, 64 }, { 43, 45, 50, 60 }, { 51, 53, 56, 59 },
          { 21, 33, 36, 61 } } };

  // 40/40
  static byte[][][] CW_SOLNS = { // 1 (R)
      // rot 0
      { { 2, 33, 51, 68 }, { 6, 20, 44, 60 }, { 7, 37, 41, 52 },
          { 14, 45, 67, 71 }, { 18, 28, 31, 64 }, { 22, 29, 56, 61 },
          { 23, 53, 66, 74 }, { 34, 57, 58, 70 }, { 40, 54, 65, 72 },
          { 48, 62, 69, 73 } },
      // rot 1
      { { 19, 21, 63, 69 }, { 20, 51, 68, 72 }, { 26, 35, 53, 59 },
          { 27, 30, 55, 57 }, { 31, 58, 60, 73 }, { 38, 56, 61, 70 },
          { 39, 52, 62, 71 }, { 41, 54, 64, 74 }, { 42, 46, 50, 65 },
          { 47, 49, 66, 67 } },
      // rot 2
      { { 1, 42, 55, 60 }, { 3, 31, 43, 46 }, { 4, 38, 47, 56 },
          { 5, 17, 35, 63 }, { 8, 20, 24, 30 }, { 9, 19, 25, 41 },
          { 10, 27, 49, 51 }, { 11, 13, 21, 50 }, { 12, 15, 32, 59 },
          { 16, 26, 36, 39 } },
      // rot 3
      { { 1, 6, 28, 41 }, { 2, 10, 31, 44 }, { 3, 5, 21, 48 },
          { 4, 20, 24, 33 }, { 7, 17, 45, 47 }, { 8, 13, 40, 42 },
          { 9, 15, 23, 35 }, { 11, 18, 37, 39 }, { 12, 14, 27, 34 },
          { 16, 22, 29, 32 } } };

  static byte[][][] CHEST_LOCS = { THRU_CHEST_LOCS, CW_CHEST_LOCS, null,
      CCW_CHEST_LOCS };
  static byte[][][][] CHEST_SOLNS = { THRU_SOLNS, CW_SOLNS, null, CCW_SOLNS };

}

package de0.coxthieving;

import com.google.inject.Provides;
import de0.util.CoxUtil;
import static de0.util.CoxUtil.THIEVING;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Set;
import java.util.function.ToIntFunction;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemID;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.Varbits;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(name = "CoX Thieving", description = "Finds bat chests and counts grubs at thieving room in CoX")
public class CoxThievingPlugin extends Plugin {

  @Inject
  private Client client;

  @Inject
  private OverlayManager overlayManager;

  @Inject
  private ChestHighlight overlay;

  @Inject
  private CoxThievingDatabox grubOverlay;

  @Inject
  private ScavHighlight scavOverlay;

  @Inject
  private CoxThievingConfig config;

  static final int CCHEST = 29742; // closed chest
  static final int PCHEST = 29743; // poison chest
  static final int GCHEST = 29745; // grubs chest

  private int roomtype = -1;

  private int plane, base_x, base_y;

  int room_base_x, room_base_y;
  int rot, wind;
  byte soln = -1;

  Set<Byte> not_solns = new HashSet<>();

  class GrubCollection {
    String displayname;
    int num_with_grubs;
  }

  private int last_grubs;
  int num_grubs;
  GrubCollection gc_local;
  GrubCollection gc_others[] = new GrubCollection[99];
  int gc_others_count = 0;

  @Provides
  CoxThievingConfig getConfig(ConfigManager configManager) {
    return configManager.getConfig(CoxThievingConfig.class);
  }

  @Subscribe
  public void onGameTick(GameTick e) {
    if (client.getVarbitValue(Varbits.IN_RAID) == 0) {
      // player has left the raid
      if (roomtype != -1)
        try {
          shutDown();
        } catch (Exception ex) {
          ex.printStackTrace();
        }
      return;
    }
	WorldView wv = client.getTopLevelWorldView();
    int plane = wv.getPlane();
    int base_x = wv.getBaseX();
    int base_y = wv.getBaseY();
    if (this.base_x != base_x || this.base_y != base_y || this.plane != plane) {
      // scene was reloaded
      this.base_x = base_x;
      this.base_y = base_y;
      this.plane = plane;
      searchForThieving();
    }
    WorldPoint wp = client.getLocalPlayer().getWorldLocation();
    int x = wp.getX() - wv.getBaseX();
    int y = wp.getY() - wv.getBaseY();
    int type = CoxUtil.getroom_type(wv.getInstanceTemplateChunks()[plane][x / 8][y / 8]);
    if (type != this.roomtype) {
      if (type == THIEVING) {
        // player has entered thieving room
        overlayManager.add(overlay);
        overlayManager.add(grubOverlay);
        overlayManager.add(scavOverlay);
      } else if (this.roomtype == THIEVING) {
        // player has left thieving room
        overlayManager.remove(overlay);
        overlayManager.remove(grubOverlay);
        overlayManager.remove(scavOverlay);
      }
      this.roomtype = type;
    }
  }

  @Subscribe
  public void onGameObjectSpawned(GameObjectSpawned e) {
    GameObject obj = e.getGameObject();
    if (obj.getId() != PCHEST && obj.getId() != GCHEST)
      return;

    Point p = e.getTile().getSceneLocation();
    int x = p.getX();
    int y = p.getY();
    int chestX, chestY;
    if (rot == 0) {
      chestX = x - room_base_x;
      chestY = y - room_base_y;
    } else if (rot == 1) {
      chestX = room_base_y - y;
      chestY = x - room_base_x;
    } else if (rot == 2) {
      chestX = room_base_x - x;
      chestY = room_base_y - y;
    } else {
      chestX = y - room_base_y;
      chestY = room_base_x - x;
    }
    byte chestno = coordToChestNo(chestX, chestY);
    boolean opened = false;
    boolean grub = false;
    if (obj.getId() == GCHEST) {
      byte notsoln = solve(chestno);
      if (notsoln != -1)
        not_solns.add(notsoln);
      opened = true;
    }
    if (obj.getId() == GCHEST) { // found grubs
      grub = true;
    } else if (obj.getId() == PCHEST && soln == -1) { // found bats or poison
      soln = solve(chestno);
    }
    if (opened) {
	  WorldView wv = client.getTopLevelWorldView();
      int angle = obj.getOrientation() >> 9;
      int px = x + (angle == 1 ? -1 : angle == 3 ? 1 : 0);
      int py = y + (angle == 0 ? -1 : angle == 2 ? 1 : 0);
      for (Player pl : wv.players()) {
        WorldPoint wp = pl.getWorldLocation();

        int plx = wp.getX() - wv.getBaseX();// p.getPathX()[0];
        int ply = wp.getY() - wv.getBaseY();// p.getPathY()[0];
        if (plx == px && ply == py) {
          if (grub && pl == client.getLocalPlayer()) {
            add_grubs_local();
          } else if (grub) {
            add_grubs_other(pl);
          }
          break;
        }
      }
    }
  }

  Comparator<GrubCollection> comparator = Comparator
      .comparingInt(new ToIntFunction<GrubCollection>() {
        @Override
        public int applyAsInt(GrubCollection v) {
          if (v == gc_local)
            return -num_grubs;
          return -v.num_with_grubs * config.grubRate() / 100;
        }
      });

  private void add_grubs_local() {
    GrubCollection gc = gc_local;
    if (gc == null) {
      gc = gc_local = new GrubCollection();
      gc.displayname = client.getLocalPlayer().getName();
    }
    int grubs = client.getItemContainer(InventoryID.INVENTORY)
        .count(ItemID.CAVERN_GRUBS);
    num_grubs += grubs - last_grubs;
    last_grubs = grubs;
    gc.num_with_grubs++;
  }

  private void add_grubs_other(Player pl) {
    GrubCollection gc = null;
    int hash = pl.getName().hashCode();
    for (int i = 0; i < gc_others_count; i++) {
      if (hash == gc_others[i].displayname.hashCode()) {
        gc = gc_others[i];
        break;
      }
    }
    if (gc == null) {
      gc = gc_others[gc_others_count++] = new GrubCollection();
      gc.displayname = pl.getName();
    }
    gc.num_with_grubs++;
    Arrays.sort(gc_others, 0, gc_others_count, comparator);
  }

  @Subscribe
  public void onItemContainerChanged(ItemContainerChanged e) {
    if (e.getContainerId() == 93) {
      last_grubs = e.getItemContainer().count(ItemID.CAVERN_GRUBS);
    }
  }

  private void searchForThieving() {
	WorldView wv = client.getTopLevelWorldView();
    int[][] templates = wv.getInstanceTemplateChunks()[this.plane];
    for (int cx = 0; cx < 13; cx += 4) {
      for (int cy = 0; cy < 13; cy += 4) {
        int template = templates[cx][cy];
        // PP_XXXXXXXXXX_YYYYYYYYYYY_RR0
        int tx = template >> 14 & 0x3FF;
        int ty = template >> 3 & 0x7FF;
        if (CoxUtil.getroom_type(template) == THIEVING) {
          rot = CoxUtil.room_rot(template);
          if (rot == 0) {
            room_base_x = (cx - (tx & 0x3)) << 3;
            room_base_y = (cy - (ty & 0x3)) << 3;
          } else if (rot == 1) {
            room_base_x = (cx - (ty & 0x3)) << 3;
            room_base_y = (cy + (tx & 0x3)) << 3 | 7;
          } else if (rot == 2) {
            room_base_x = (cx + (tx & 0x3)) << 3 | 7;
            room_base_y = (cy + (ty & 0x3)) << 3 | 7;
          } else if (rot == 3) {
            room_base_x = (cx + (ty & 0x3)) << 3 | 7;
            room_base_y = (cy - (tx & 0x3)) << 3;
          }

          wind = CoxUtil.room_winding(template);
        }
      }
    }
  }

  @Override
  protected void shutDown() throws Exception {
    overlayManager.remove(overlay);
    overlayManager.remove(grubOverlay);
    overlayManager.remove(scavOverlay);
    not_solns.clear();
    gc_local = null;
    for (int i = 0; i < gc_others_count; i++)
      gc_others[i] = null;
    gc_others_count = 0;
    num_grubs = 0;
    last_grubs = 0;
    soln = -1;
    roomtype = -1;
  }

  private byte solve(byte poisonchestno) {
    byte[][] solns = ChestData.CHEST_SOLNS[wind][rot];
    for (byte i = 0; i < solns.length; i++)
      for (byte j = 0; j < solns[i].length; j++)
        if (solns[i][j] == poisonchestno)
          return i;
    return -1;
  }

  private byte coordToChestNo(int x, int y) {
    byte[][] locs = ChestData.CHEST_LOCS[wind];
    for (byte i = 0; i < locs.length; i++)
      if (locs[i][0] == x && locs[i][1] == y)
        return (byte) (i + 1);
    return -1;
  }

}

package de0.util;

public class CoxUtil {

  // p=plane, y=y_8, x=x_8, r=rot pp_xxxxxxxxxx_yyyyyyyyyy_rr0
  private static final int COX_ROOM_MASK = 0b11_1111111100_11111111100_00_0;

  private static final int FL_END1 = 0 << 24 | 102 << 16 | 160 << 5;

  private static final int FL_END2 = 0 << 24 | 102 << 16 | 161 << 5;
  private static final int FL_END3 = 0 << 24 | 103 << 16 | 161 << 5;

  private static final int LOBBY_CCW = 0 << 24 | 102 << 16 | 162 << 5;
  private static final int LOBBY_THRU = 0 << 24 | 103 << 16 | 162 << 5;
  private static final int LOBBY_CW = 0 << 24 | 104 << 16 | 162 << 5;

  private static final int SCAVS_SM_CCW = 0 << 24 | 102 << 16 | 163 << 5;
  private static final int SCAVS_SM_THRU = 0 << 24 | 103 << 16 | 163 << 5;
  private static final int SCAVS_SM_CW = 0 << 24 | 104 << 16 | 163 << 5;

  private static final int SHAMANS_CCW = 0 << 24 | 102 << 16 | 164 << 5;
  private static final int SHAMANS_THRU = 0 << 24 | 103 << 16 | 164 << 5;
  private static final int SHAMANS_CW = 0 << 24 | 104 << 16 | 164 << 5;

  private static final int VASA_CCW = 0 << 24 | 102 << 16 | 165 << 5;
  private static final int VASA_THRU = 0 << 24 | 103 << 16 | 165 << 5;
  private static final int VASA_CW = 0 << 24 | 104 << 16 | 165 << 5;

  private static final int VANGUARDS_CCW = 0 << 24 | 102 << 16 | 166 << 5;
  private static final int VANGUARDS_THRU = 0 << 24 | 103 << 16 | 166 << 5;
  private static final int VANGUARDS_CW = 0 << 24 | 104 << 16 | 166 << 5;

  private static final int ICE_DEMON_CCW = 0 << 24 | 102 << 16 | 167 << 5;
  private static final int ICE_DEMON_THRU = 0 << 24 | 103 << 16 | 167 << 5;
  private static final int ICE_DEMON_CW = 0 << 24 | 104 << 16 | 167 << 5;

  private static final int THIEVING_CCW = 0 << 24 | 102 << 16 | 168 << 5;
  private static final int THIEVING_THRU = 0 << 24 | 103 << 16 | 168 << 5;
  private static final int THIEVING_CW = 0 << 24 | 104 << 16 | 168 << 5;

  private static final int FARM_FISH_CCW = 0 << 24 | 102 << 16 | 170 << 5;
  private static final int FARM_FISH_THRU = 0 << 24 | 103 << 16 | 170 << 5;
  private static final int FARM_FISH_CW = 0 << 24 | 104 << 16 | 170 << 5;

  private static final int FL_START1_CCW = 0 << 24 | 102 << 16 | 178 << 5;
  private static final int FL_START1_THRU = 0 << 24 | 103 << 16 | 178 << 5;
  private static final int FL_START1_CW = 0 << 24 | 104 << 16 | 178 << 5;

  private static final int FL_START2_CCW = 0 << 24 | 102 << 16 | 179 << 5;
  private static final int FL_START2_THRU = 0 << 24 | 103 << 16 | 179 << 5;
  private static final int FL_START2_CW = 0 << 24 | 104 << 16 | 179 << 5;

  private static final int SCAVS_LG_CCW = 1 << 24 | 102 << 16 | 163 << 5;
  private static final int SCAVS_LG_THRU = 1 << 24 | 103 << 16 | 163 << 5;
  private static final int SCAVS_LG_CW = 1 << 24 | 104 << 16 | 163 << 5;

  private static final int MYSTICS_CCW = 1 << 24 | 102 << 16 | 164 << 5;
  private static final int MYSTICS_THRU = 1 << 24 | 103 << 16 | 164 << 5;
  private static final int MYSTICS_CW = 1 << 24 | 104 << 16 | 164 << 5;

  private static final int TEKTON_CCW = 1 << 24 | 102 << 16 | 165 << 5;
  private static final int TEKTON_THRU = 1 << 24 | 103 << 16 | 165 << 5;
  private static final int TEKTON_CW = 1 << 24 | 104 << 16 | 165 << 5;

  private static final int MUTTADILES_CCW = 1 << 24 | 102 << 16 | 166 << 5;
  private static final int MUTTADILES_THRU = 1 << 24 | 103 << 16 | 166 << 5;
  private static final int MUTTADILES_CW = 1 << 24 | 104 << 16 | 166 << 5;

  private static final int TIGHTROPE_CCW = 1 << 24 | 102 << 16 | 167 << 5;
  private static final int TIGHTROPE_THRU = 1 << 24 | 103 << 16 | 167 << 5;
  private static final int TIGHTROPE_CW = 1 << 24 | 104 << 16 | 167 << 5;

  private static final int FARM_BATS_CCW = 1 << 24 | 102 << 16 | 170 << 5;
  private static final int FARM_BATS_THRU = 1 << 24 | 103 << 16 | 170 << 5;
  private static final int FARM_BATS_CW = 1 << 24 | 104 << 16 | 170 << 5;

  private static final int GUARDIANS_CCW = 2 << 24 | 102 << 16 | 164 << 5;
  private static final int GUARDIANS_THRU = 2 << 24 | 103 << 16 | 164 << 5;
  private static final int GUARDIANS_CW = 2 << 24 | 104 << 16 | 164 << 5;

  private static final int VESPULA_CCW = 2 << 24 | 102 << 16 | 165 << 5;
  private static final int VESPULA_THRU = 2 << 24 | 103 << 16 | 165 << 5;
  private static final int VESPULA_CW = 2 << 24 | 104 << 16 | 165 << 5;

  private static final int CRABS_CCW = 2 << 24 | 102 << 16 | 167 << 5;
  private static final int CRABS_THRU = 2 << 24 | 103 << 16 | 167 << 5;
  private static final int CRABS_CW = 2 << 24 | 104 << 16 | 167 << 5;

  private static final int OLM_ROOM_MASK = 0b11_1111111000_11111111000_00_0;

  private static final int OLM_ = 0 << 24 | 50 << 17 | 89 << 6;

  public static final int FL_START = 0;
  public static final int FL_END = 1;
  public static final int SCAVENGERS = 2;
  public static final int FARMING = 3;

  public static final int SHAMANS = 4;
  public static final int VASA = 5;
  public static final int VANGUARDS = 6;
  public static final int MYSTICS = 7;
  public static final int TEKTON = 8;
  public static final int MUTTADILES = 9;
  public static final int GUARDIANS = 10;
  public static final int VESPULA = 11;

  public static final int ICE_DEMON = 12;
  public static final int THIEVING = 13;
  public static final int TIGHTROPE = 14;
  public static final int CRABS = 15;
  public static final int OLM = 16;

  public static final int UNKNOWN = 17;

  private static final char[] ROOM_SORTS = new char[] { '*', '*', 'S', 'F', 'C',
      'C', 'C', 'C', 'C', 'C', 'C', 'C', 'P', 'P', 'P', 'P', 'O' };

  private static final String[] ROOM_NAMES = new String[] { "Floor start",
      "Floor end", "Scavengers", "Farming", "Shamans", "Vasa", "Vanguards",
      "Mystics", "Tekton", "Muttadiles", "Guardians", "Vespula", "Ice demon",
      "Thieving", "Tightrope", "Crabs", "Olm" };

  public static int getroom_type(int zonecode) {
    switch (zonecode & COX_ROOM_MASK) {
    case LOBBY_CCW:
    case LOBBY_THRU:
    case LOBBY_CW:
    case FL_START1_CCW:
    case FL_START1_THRU:
    case FL_START1_CW:
    case FL_START2_CCW:
    case FL_START2_THRU:
    case FL_START2_CW:
      return FL_START;
    case FL_END1:
    case FL_END2:
    case FL_END3:
      return FL_END;
    case SCAVS_SM_CCW:
    case SCAVS_SM_THRU:
    case SCAVS_SM_CW:
    case SCAVS_LG_CCW:
    case SCAVS_LG_THRU:
    case SCAVS_LG_CW:
      return SCAVENGERS;
    case FARM_FISH_CCW:
    case FARM_FISH_THRU:
    case FARM_FISH_CW:
    case FARM_BATS_CCW:
    case FARM_BATS_THRU:
    case FARM_BATS_CW:
      return FARMING;
    case SHAMANS_CCW:
    case SHAMANS_THRU:
    case SHAMANS_CW:
      return SHAMANS;
    case VASA_CCW:
    case VASA_THRU:
    case VASA_CW:
      return VASA;
    case VANGUARDS_CCW:
    case VANGUARDS_THRU:
    case VANGUARDS_CW:
      return VANGUARDS;
    case MYSTICS_CCW:
    case MYSTICS_THRU:
    case MYSTICS_CW:
      return MYSTICS;
    case TEKTON_CCW:
    case TEKTON_THRU:
    case TEKTON_CW:
      return TEKTON;
    case MUTTADILES_CCW:
    case MUTTADILES_THRU:
    case MUTTADILES_CW:
      return MUTTADILES;
    case GUARDIANS_CCW:
    case GUARDIANS_THRU:
    case GUARDIANS_CW:
      return GUARDIANS;
    case VESPULA_CCW:
    case VESPULA_THRU:
    case VESPULA_CW:
      return VESPULA;
    case ICE_DEMON_CCW:
    case ICE_DEMON_THRU:
    case ICE_DEMON_CW:
      return ICE_DEMON;
    case THIEVING_CCW:
    case THIEVING_THRU:
    case THIEVING_CW:
      return THIEVING;
    case TIGHTROPE_CCW:
    case TIGHTROPE_THRU:
    case TIGHTROPE_CW:
      return TIGHTROPE;
    case CRABS_CCW:
    case CRABS_THRU:
    case CRABS_CW:
      return CRABS;
    }

    if ((zonecode & OLM_ROOM_MASK) == OLM_)
      return OLM;

    return UNKNOWN;
  }

  public static char getroom_sort(int roomtype) {
    if (roomtype >= 0 && roomtype < UNKNOWN)
      return ROOM_SORTS[roomtype];

    return '?';
  }

  public static String getroom_name(int roomtype) {
    if (roomtype >= 0 && roomtype < UNKNOWN)
      return ROOM_NAMES[roomtype];

    return "Unknown";
  }

  public static int room_winding(int zonecode) {
    return (((zonecode >> 16) & 0xff) - 103) & 0x3;
  }

  public static int room_rot(int zonecode) {
    return zonecode >> 1 & 0x3;
  }

  public static int room_exitside(int zonecode) {
    return (room_winding(zonecode) + room_rot(zonecode)) & 0x3;
  }

}

package de0.util;

public class MiscUtil {

  public static String to_mmss(int ticks) {
    int m = ticks / 100;
    int s = (ticks - m * 100) * 6 / 10;
    return new StringBuilder().append(m).append(s < 10 ? ":0" : ":").append(s)
        .toString();
  }

  public static String to_mmss_precise(int ticks) {
    int min = ticks / 100;
    int tmp = (ticks - min * 100) * 6;
    int sec = tmp / 10;
    int sec_tenth = tmp - sec * 10;
    return new StringBuilder().append(min).append(sec < 10 ? ":0" : ":")
        .append(sec).append(".").append(sec_tenth).toString();
  }

}

package de0.coxtimers;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("coxtimers")
public interface CoxTimersConfig extends Config {

  @ConfigItem(position = 0, keyName = "preciseTimers", name = "Precise Timers", description = "Respect in-game precise timer setting")
  default PreciseTimersSetting preciseTimers() {
    return PreciseTimersSetting.RESPECT_INGAME_SETTING;
  }

  @ConfigItem(position = 1, keyName = "showIcePopTime", name = "Time Ice demon pop-out", description = "Partial room timer for Ice Demon")
  default boolean showIcePopTime() {
    return true;
  }

  @ConfigItem(position = 2, keyName = "showOlmPhaseTimers", name = "Time Olm phases", description = "Phase timers for Olm")
  default boolean showOlmPhaseTimers() {
    return true;
  }

  @ConfigItem(position = 3, keyName = "showMuttadileTreeCutTime", name = "Time Muttadile tree cut", description = "Partial room timer for Muttadiles")
  default boolean showMuttadileTreeCutTime() {
    return true;
  }

}

package de0.coxtimers;

public enum PreciseTimersSetting {

  TICK_PRECISION,
  SECOND_PRECISION,
  RESPECT_INGAME_SETTING
  
}

package de0.coxtimers;

import com.google.inject.Provides;
import de0.util.CoxUtil;
import de0.util.MiscUtil;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.ObjectID;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

import javax.inject.Inject;

import static de0.util.CoxUtil.ICE_DEMON;
import static de0.util.CoxUtil.getroom_name;
import static de0.util.CoxUtil.getroom_sort;
import static de0.util.CoxUtil.getroom_type;

@PluginDescriptor(name = "CoX Timers", description = "Time tracking for CoX rooms")
public class CoxTimersPlugin extends Plugin {

  @Inject
  private Client client;

  @Inject
  private CoxTimersConfig config;

  // Room state
  private boolean in_raid;
  private int split, split_fl, split_sub; // Splits for room/floor/sub-room
  private int cryp[] = new int[16], cryx[] = new int[16], cryy[] = new int[16];

  // Olm state
  private int olm_phase;

  // Misc state
  private boolean iceout, treecut;

  @Provides
  CoxTimersConfig provideConfig(ConfigManager configManager) {
    return configManager.getConfig(CoxTimersConfig.class);
  }

  @Subscribe
  public void onClientTick(ClientTick e) {
    if (client.getGameState() != GameState.LOGGED_IN)
      return;

    if (clock() == 0 || !client.isInInstancedRegion()) {
      in_raid = false;
      return;
    }
    if (!in_raid) {
      in_raid = true;
      split = 0;
      split_fl = 0;
      split_sub = 0;
      olm_phase = ~0;
      iceout = false;
      treecut = false;
    }
    for (int i = 0; i < 16; i++) {
      if (this.cryp[i] == -1)
        continue;
      int p = cryp[i];
      int x = cryx[i] - client.getBaseX();
      int y = cryy[i] - client.getBaseY();
      if (p != client.getPlane() || x < 0 || x >= 104 || y < 0 || y >= 104) {
        this.cryp[i] = -1;
        continue;
      }
      int flags = client.getCollisionMaps()[p].getFlags()[x][y];
      if ((flags & 0x100) == 0) {
        StringBuilder mes = new StringBuilder();
        mes.append(getroom_sort(i) == 'C' ? "Combat room `" : "Puzzle `");
        mes.append(getroom_name(i));
        mes.append("` complete! Duration: <col=ff0000>");
        mes.append(to_mmss(clock() - split));
        mes.append("</col> Total: <col=ff0000>");
        mes.append(to_mmss(clock()));
        mes.append("</col>");

        fc_mes(mes.toString());
        split = split_sub = clock();
        this.cryp[i] = -1;
      }
    }
  }

  private static final String FL_COMPLETE_MES = "level complete! Duration: </col><col=ff0000>";

  @Subscribe
  public void onChatMessage(ChatMessage e) {
    if (!in_raid)
      return;

    String mes = e.getMessage();
    if (e.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION
        && mes.contains("Congratulations - your raid is complete!")) {
      e.getMessageNode().setValue(mes + " Olm duration: <col=ff0000>" + to_mmss(clock() - split_fl) + "</col>");
    } else if (e.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION
             && mes.contains(FL_COMPLETE_MES)) {
      int duration = mes.indexOf(FL_COMPLETE_MES);

      if (!mes.contains("Upper")) {
        String before = mes.substring(0, duration + FL_COMPLETE_MES.length());
        String after = mes.substring(duration + FL_COMPLETE_MES.length());
        e.getMessageNode().setValue(before + to_mmss(clock() - split_fl)
            + "</col> Total: <col=ff0000>" + after);
      }

      split = split_sub = split_fl = clock();
    } else if (config.showOlmPhaseTimers()
        && e.getType() == ChatMessageType.GAMEMESSAGE && mes.equals(
            "The Great Olm is giving its all. This is its final stand.")) {
      splitphase();
      olm_phase = 99;
    }
  }

  private void splitphase() {
    StringBuilder mes = new StringBuilder();
    if (olm_phase == 99) {
      mes.append("Olm head");
    } else {
      mes.append("Olm phase ");
      mes.append(++olm_phase);
    }
    mes.append(" duration: <col=ff0000>");
    mes.append(to_mmss(clock() - split));
    mes.append("</col>");
    if (olm_phase != 99) {
      mes.append(" Total: <col=ff0000>");
      mes.append(to_mmss(clock()));
      mes.append("</col>");
    }

    fc_mes(mes.toString());
    split = clock();
  }

  @Subscribe
  public void onGameObjectSpawned(GameObjectSpawned e) {
    GameObject go = e.getGameObject();
    switch (go.getId()) {
    case 29881: // Olm spawned
      if (olm_phase < 0) {
        split = clock();
        olm_phase = ~olm_phase;
      }
      break;
    case 29767:
      // Muttadile tendrils spawned (only use for regs)
      if (client.getVarbitValue(6385) == 0)
        split_sub = clock();
      break;
    case 30013:
      // Muttadile tree placeholder spawned after tree cut
      if (config.showMuttadileTreeCutTime() && !treecut) {
        StringBuilder mes = new StringBuilder(
            "Muttadile tree cut duration: <col=ff0000>");
        mes.append(to_mmss(clock() - split_sub));
        mes.append("</col>");
        mes.append(" Total: <col=ff0000>");
        mes.append(to_mmss(clock()));
        mes.append("</col>");
        fc_mes(mes.toString());
        treecut = true;
      }
      break;
    case 26209: // shamans/thieving/guardians
    case 29741: // mystics
    case 29749: // tightrope
    case 29753: // crabs
    case 29754:
    case 29755:
    case 29756:
    case 29757:
    case 29876: // ice
    case 30016: // vasa
    case 30017: // tekton/vanguards
    case 30018: // mutt
    case 30070: // vespula
      Point pt = go.getSceneMinLocation();
      int p = go.getPlane();
      int x = pt.getX();
      int y = pt.getY();
      int template = client.getInstanceTemplateChunks()[p][x / 8][y / 8];
      int roomtype = getroom_type(template);
      if (roomtype < 16) {
        // add obstacle to list
        cryp[roomtype] = p;
        cryx[roomtype] = x + client.getBaseX();
        cryy[roomtype] = y + client.getBaseY();
      }
      break;
    }
  }

  @Subscribe
  public void onGameObjectDespawned(GameObjectDespawned e) {
    if (config.showOlmPhaseTimers()
        && e.getGameObject().getId() == ObjectID.LARGE_HOLE_29881) {
      splitphase();
      olm_phase = ~olm_phase;
    }
  }

  private static final int SMOKE_PUFF = 188;

  @Subscribe
  public void onGraphicsObjectCreated(GraphicsObjectCreated e) {
    if (config.showIcePopTime() && e.getGraphicsObject().getId() == SMOKE_PUFF
        && !iceout) {
      WorldPoint wp = WorldPoint.fromLocal(client,
          e.getGraphicsObject().getLocation());
      int p = client.getPlane();
      int x = wp.getX() - client.getBaseX();
      int y = wp.getY() - client.getBaseY();
      int template = client.getInstanceTemplateChunks()[p][x / 8][y / 8];
      if (CoxUtil.getroom_type(template) == ICE_DEMON) {
        StringBuilder mes = new StringBuilder(
            "Ice Demon pop duration: <col=ff0000>");
        mes.append(to_mmss(clock() - split));
        mes.append("</col>");
        mes.append(" Total: <col=ff0000>");
        mes.append(to_mmss(clock()));
        mes.append("</col>");
        fc_mes(mes.toString());
        iceout = true;
      }
    }
  }

  private void fc_mes(String mes) {
    client.addChatMessage(ChatMessageType.FRIENDSCHATNOTIFICATION, "", mes,
        null);
  }

  private int clock() {
    return client.getVarbitValue(6386);
  }

  private String to_mmss(int ticks) {
    PreciseTimersSetting setting = config.preciseTimers();
    boolean ingame_setting = client.getVarbitValue(11866) == 1;
    if (setting == PreciseTimersSetting.TICK_PRECISION
        || (setting == PreciseTimersSetting.RESPECT_INGAME_SETTING
            && ingame_setting))
      return MiscUtil.to_mmss_precise(ticks);

    return MiscUtil.to_mmss(ticks);
  }

}

package de0.coxvanguards;

import java.awt.Color;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("vanguards")
public interface CoxVanguardsConfig extends Config {

  @ConfigItem(position = 0, keyName = "showHps", name = "Show HPs", description = "Show Vanguard HPs")
  default boolean showHps() {
    return true;
  }

  @ConfigItem(position = 1, keyName = "showDmgToReset", name = "Show dmg to reset (solo)", description = "Show Vanguard dmg amount till reset")
  default boolean showDmgToReset() {
    return true;
  }

  @ConfigItem(position = 2, keyName = "highlight", name = "Highlight", description = "Highlights Vanguards of their respective color.")
  default boolean highlight() {
    return true;
  }

  @ConfigItem(position = 3, keyName = "showDatabox", name = "Show HPs in a databox", description = "Show Vanguard HPs databox")
  default boolean showDatabox() {
    return false;
  }

  @ConfigItem(position = 4, keyName = "meleeColor", name = "Melee Vanguard color", description = "Highlight color for melee Vanguard")
  default Color getMeleeColor() {
    return Color.RED;
  }

  @ConfigItem(position = 5, keyName = "rangeColor", name = "Range Vanguard color", description = "Highlight color for range Vanguard")
  default Color getRangeColor() {
    return Color.GREEN;
  }

  @ConfigItem(position = 6, keyName = "mageColor", name = "Mage Vanguard color", description = "Highlight color for mage Vanguard")
  default Color getMageColor() {
    return Color.CYAN;
  }

  @ConfigItem(position = 7, keyName = "wanderRange", name ="Show melee wander range", description = "Show how far you need to go before losing agro from melee")
  default boolean wanderRange() {
    return false;
  }

  @ConfigItem(position = 8, keyName = "wanderColor", name = "Melee Vanguard wander color", description = "Highlight color for melee Vanguard wander range")
  default Color getMeleeWanderColor() {
    return new Color(0xC35364);
  }

}

package de0.coxvanguards;

import com.google.inject.Provides;

import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.HitsplatID;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(name = "CoX Vanguards", description = "Adds a highlight and indicates HPs for Vanguards")
public class CoxVanguardsPlugin extends Plugin {

  @Inject
  private OverlayManager overlayManager;

  @Inject
  private Client client;

  @Inject
  private CoxVanguardsHighlight highlight;

  @Inject
  private CoxVanguardsDatabox databox;

  private boolean in_raid;

  int solo_base_hp;

  WorldPoint meleeSpawn;

  NPC melee, range, mage;
  int melhp, rnghp, maghp;
  int melhp_fine, rnghp_fine, maghp_fine;

  protected void startUp() throws Exception {
    overlayManager.add(highlight);
    overlayManager.add(databox);
  }

  protected void shutDown() throws Exception {
    overlayManager.remove(highlight);
    overlayManager.remove(databox);
  }

  @Provides
  CoxVanguardsConfig provideConfig(ConfigManager configManager) {
    return (CoxVanguardsConfig) configManager.getConfig(CoxVanguardsConfig.class);
  }

  @Subscribe
  public void onGameTick(GameTick e) {
    boolean in_raid = client.getVarbitValue(5432) != 0;
    if (this.in_raid != in_raid) {
      if (in_raid) {
        melhp_fine = rnghp_fine = maghp_fine = solo_base_hp = getSoloBaseHp();
      } else {
        melee = range = mage = null;
        overlayManager.remove(databox);
      }
      this.in_raid = in_raid;
    }
  }

  @Subscribe
  public void onClientTick(ClientTick e) {
    if (melee != null && melee.getHealthRatio() > 0)
      melhp = melee.getHealthRatio();

    if (range != null && range.getHealthRatio() > 0)
      rnghp = range.getHealthRatio();

    if (mage != null && mage.getHealthRatio() > 0)
      maghp = mage.getHealthRatio();
  }

  @Subscribe
  public void onNpcSpawned(NpcSpawned e) {
    NPC npc = e.getNpc();
    if (melee == null && npc.getId() == NpcID.RAIDS_VANGUARD_MELEE) {
      melee = npc;
    } else if (range == null && npc.getId() == NpcID.RAIDS_VANGUARD_RANGED)
      range = npc;
    else if (mage == null && npc.getId() == NpcID.RAIDS_VANGUARD_MAGIC)
      mage = npc;
  }

  @Subscribe
  public void onNpcChanged(NpcChanged e) {
    NPC npc = e.getNpc();
    if (npc.getId() == NpcID.RAIDS_VANGUARD_MELEE) {
      if (melee == null)
        melee = npc;
      // Only set the melee location on digs, can have been dragged if late otherwise.
      if (meleeSpawn == null)
        meleeSpawn = npc.getWorldLocation().dx(1).dy(1);
    } else if (npc.getId() == NpcID.RAIDS_VANGUARD_RANGED && range == null)
      range = npc;
    else if (npc.getId() == NpcID.RAIDS_VANGUARD_MAGIC && mage == null)
      mage = npc;
    else if (npc.getId() == NpcID.RAIDS_VANGUARD_WALKING) {
      if (npc == melee) {
        melhp_fine = Math.min(solo_base_hp, melhp_fine + 1);
      } else if (npc == range) {
        rnghp_fine = Math.min(solo_base_hp, rnghp_fine + 1);
      } else if (npc == mage) {
        maghp_fine = Math.min(solo_base_hp, maghp_fine + 1);
      }
    }
  }

  @Subscribe
  public void onNpcDespawned(NpcDespawned e) {
    NPC npc = e.getNpc();
    if (npc == melee) {
      melee = null;
      meleeSpawn = null;
    } else if (npc == range)
      range = null;
    else if (npc == mage)
      mage = null;
  }

  @Subscribe
  public void onHitsplatApplied(HitsplatApplied e) {
    if (!isSolo())
      return;

    if (!(e.getActor() instanceof NPC))
      return;

    NPC npc = (NPC) e.getActor();
    if (npc == null || npc.getId() < 7526 || npc.getId() > 7529)
      return;

    int hs = e.getHitsplat().getHitsplatType();
    if (hs == HitsplatID.HEAL) {
      this.melhp_fine = solo_base_hp;
      this.rnghp_fine = solo_base_hp;
      this.maghp_fine = solo_base_hp;
    } else if (hs == HitsplatID.DAMAGE_ME || hs == HitsplatID.DAMAGE_OTHER
        || hs == HitsplatID.DAMAGE_MAX_ME || hs == HitsplatID.BURN) {
      int amt = e.getHitsplat().getAmount();
      if (npc == melee) {
        this.melhp_fine -= amt;
      } else if (npc == range) {
        this.rnghp_fine -= amt;
      } else if (npc == mage) {
        this.maghp_fine -= amt;
      }
    }
  }

  boolean isSolo() {
    return client.getVarbitValue(VarbitID.RAIDS_CLIENT_PARTYSIZE_SCALED) == 1;
  }

  int getSoloBaseHp() {
    int base_hp = 180;
    base_hp = base_hp * client.getLocalPlayer().getCombatLevel() / 126;
    boolean cm = client.getVarbitValue(VarbitID.RAIDS_CHALLENGE_MODE) != 0;
    if (cm)
      base_hp = base_hp * 3 / 2;

    return base_hp;
  }

}

package de0.coxvanguards;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;

import javax.inject.Inject;

import de0.util.CoxUtil;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import static de0.util.CoxUtil.*;

public class CoxVanguardsDatabox extends Overlay {

  private CoxVanguardsPlugin plugin;
  private CoxVanguardsConfig config;
  private Client client;
  private PanelComponent panelComponent;

  @Inject
  public CoxVanguardsDatabox(CoxVanguardsPlugin plugin, CoxVanguardsConfig config,
      Client client) {
    super(plugin);
    this.plugin = plugin;
    this.config = config;
    this.client = client;
    setPosition(OverlayPosition.TOP_LEFT);
    panelComponent = new PanelComponent();
    panelComponent.getChildren()
        .add(TitleComponent.builder().text("Vanguards").build());
    panelComponent.getChildren().add(
        LineComponent.builder().left("Melee").leftColor(Color.RED).build());
    panelComponent.getChildren().add(
        LineComponent.builder().left("Range").leftColor(Color.GREEN).build());
    panelComponent.getChildren().add(
        LineComponent.builder().left("Mage").leftColor(Color.CYAN).build());
  }

  @Override
  public Dimension render(Graphics2D g) {
    if (!config.showDatabox())
      return null;

    WorldPoint wp = client.getLocalPlayer().getWorldLocation();
    int plane = client.getPlane();
    int x = wp.getX() - client.getBaseX();
    int y = wp.getY() - client.getBaseY();
    int type = CoxUtil
        .getroom_type(client.getInstanceTemplateChunks()[plane][x / 8][y / 8]);
    if (type == VANGUARDS) {
      List<LayoutableRenderableEntity> elems = panelComponent.getChildren();
      ((LineComponent) elems.get(1))
          .setRight(Integer.toString(plugin.melhp * 100 / 30));
      ((LineComponent) elems.get(2))
          .setRight(Integer.toString(plugin.rnghp * 100 / 30));
      ((LineComponent) elems.get(3))
          .setRight(Integer.toString(plugin.maghp * 100 / 30));
      return this.panelComponent.render(g);
    }

    return null;
  }
}

package de0.coxvanguards;

import java.awt.*;

import javax.inject.Inject;

import lombok.NonNull;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import static java.lang.Math.max;
import static java.lang.Math.min;

public class CoxVanguardsHighlight extends Overlay {

  @Inject
  private Client client;

  @Inject
  private CoxVanguardsPlugin plugin;

  @Inject
  private CoxVanguardsConfig config;

  @Inject
  protected void init() {
    setPosition(OverlayPosition.DYNAMIC);
    setLayer(OverlayLayer.ABOVE_SCENE);
  }

  @Override
  public Dimension render(Graphics2D g) {
    if (plugin.melee != null)
      renderVanguard(plugin.melee, plugin.melhp, plugin.melhp_fine, g,
          config.getMeleeColor());
    if (plugin.range != null)
      renderVanguard(plugin.range, plugin.rnghp, plugin.rnghp_fine, g,
          config.getRangeColor());
    if (plugin.mage != null)
      renderVanguard(plugin.mage, plugin.maghp, plugin.maghp_fine, g,
          config.getMageColor());
    if (plugin.meleeSpawn != null && config.wanderRange()) {
      renderBox(g, plugin.meleeSpawn);
    }
    return null;
  }

  private Point getTileCorner(Client client, WorldView vw, WorldPoint wp, int plane, int cornerIndex)
  {
    LocalPoint lp = LocalPoint.fromWorld(vw, wp);
    if (lp == null)
    {
      return null;
    }

    Polygon poly = Perspective.getCanvasTilePoly(client, lp, plane);
    if (poly == null || poly.npoints < 4)
    {
      return null;
    }

    // Indices: 0 = TL, 1 = TR, 2 = BR, 3 = BL
    return new Point(poly.xpoints[cornerIndex], poly.ypoints[cornerIndex]);
  }

  private void renderBox(Graphics2D g, @NonNull WorldPoint spawn) {
    WorldView vw = client.getWorldView(-1);
    int plane = vw.getPlane();
    int radius = 9;

    // Define the 4 corner tiles of the square
    WorldPoint topLeft = spawn.dx(-radius).dy(-radius);
    WorldPoint topRight = spawn.dx(radius).dy(-radius);
    WorldPoint bottomRight = spawn.dx(radius).dy(radius);
    WorldPoint bottomLeft = spawn.dx(-radius).dy(radius);

    // Get the relevant corners of each tile (see note below)
    Point tl = getTileCorner(client, vw, topLeft, plane, 0); // Top-left
    Point tr = getTileCorner(client, vw, topRight, plane, 1); // Top-right
    Point br = getTileCorner(client, vw, bottomRight, plane, 2); // Bottom-right
    Point bl = getTileCorner(client, vw, bottomLeft, plane, 3); // Bottom-left

    if (tl != null && tr != null && br != null && bl != null)
    {
      Polygon outline = new Polygon();
      outline.addPoint(tl.getX(), tl.getY());
      outline.addPoint(tr.getX(), tr.getY());
      outline.addPoint(br.getX(), br.getY());
      outline.addPoint(bl.getX(), bl.getY());

      g.setColor(config.getMeleeWanderColor());
      g.drawPolygon(outline);
      g.drawPolygon(Perspective.getCanvasTilePoly(client, LocalPoint.fromWorld(vw, spawn)));
    }
  }

  private void renderVanguard(NPC van, int last_hp, int hp_fine, Graphics2D g,
                              Color c) {
    if (van.getId() < 7525 || van.getId() > 7529)
      return;

    if (config.highlight()) {
      Shape s = van.getConvexHull();
      if (s != null) {
        g.setColor(new Color(c.getRed(), c.getGreen(), c.getBlue(), 50));
        g.fill(s);
      }
    }
    if (config.showDmgToReset() && plugin.isSolo()) {
      int rt = plugin.solo_base_hp * 4 / 10 - 1;
      int mel = plugin.melhp_fine;
      int rng = plugin.rnghp_fine;
      int mag = plugin.maghp_fine;
      int hi = max(max(mel, rng), mag);
      int lo = min(min(mel, rng), mag);
      int mid = mel ^ rng ^ mag ^ hi ^ lo;
      int thres = max(0, (hp_fine == hi ? mid : hi) - rt);
      int dist = hp_fine - thres;

      boolean goodToKill = hp_fine < rt;
      boolean goodToClear = mel < rt && rng < rt && mag < rt;

      if (!goodToClear) {
        String str = goodToKill ? "*" + dist : Integer.toString(dist);
        npctext(g, van, str, c);
      }
    } else if (config.showHps()) {
      int hp = van.getHealthRatio();
      if (hp < 0)
        hp = last_hp;
      int hpPercent = hp * 100 / 30;
      String str = Integer.toString(hpPercent);
      npctext(g, van, str, c);
    }
  }

  private void npctext(Graphics2D g, NPC npc, String str, Color c) {
    Point point = npc.getCanvasTextLocation(g, str, npc.getLogicalHeight());
    if (point == null)
      return;
    point = new Point(point.getX(), point.getY() + 20);
    g.setFont(FontManager.getRunescapeBoldFont());
    OverlayUtil.renderTextLocation(g, point, str, c);
  }

}

package de0;

import de0.coxthieving.CoxThievingPlugin;
import de0.coxtimers.CoxTimersPlugin;
import de0.coxvanguards.CoxVanguardsPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CoxPluginsTest {

  @SuppressWarnings("unchecked")
  public static void main(String[] args) throws Exception {
    ExternalPluginManager.loadBuiltin(CoxTimersPlugin.class,
        CoxVanguardsPlugin.class, CoxThievingPlugin.class);
    RuneLite.main(args);
  }

}

