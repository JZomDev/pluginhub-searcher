package com.fauxbingo;

import com.fauxbingo.handlers.EventHandler;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;

/**
 * Central event processing engine that manages and delegates events to registered handlers.
 */
@Slf4j
public class EventProcessor
{
	private final Map<Class<?>, List<EventHandler<?>>> handlers = new HashMap<>();

	public <T> void registerHandler(EventHandler<T> handler)
	{
		Class<T> eventType = handler.getEventType();
		handlers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(handler);
		log.debug("Registered handler {} for event type {}", handler.getClass().getSimpleName(), eventType.getSimpleName());
	}

	public <T> void unregisterHandler(EventHandler<T> handler)
	{
		Class<T> eventType = handler.getEventType();
		List<EventHandler<?>> handlerList = handlers.get(eventType);
		if (handlerList != null)
		{
			handlerList.remove(handler);
			log.debug("Unregistered handler {} for event type {}", handler.getClass().getSimpleName(), eventType.getSimpleName());
		}
	}

	@SuppressWarnings("unchecked")
	public <T> void processEvent(T event)
	{
		List<EventHandler<?>> handlerList = handlers.get(event.getClass());
		if (handlerList != null && !handlerList.isEmpty())
		{
			for (EventHandler<?> handler : handlerList)
			{
				try
				{
					((EventHandler<T>) handler).handle(event);
				}
				catch (Exception e)
				{
					log.error("Error in handler {} processing event {}", 
						handler.getClass().getSimpleName(), 
						event.getClass().getSimpleName(), e);
				}
			}
		}
	}

	public void clearHandlers()
	{
		handlers.clear();
		log.debug("Cleared all event handlers");
	}
}

package com.fauxbingo;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup("fauxbingo")
public interface FauxBingoConfig extends Config
{
	@ConfigSection(
		name = "Team Overlay",
		description = "Configure team name and timestamp overlay display",
		position = 0
	)
	String overlaySection = "overlay";

	@ConfigSection(
		name = "WiseOldMan Auto-Update",
		description = "Automatically update your WiseOldMan stats",
		position = 1
	)
	String wiseOldManSection = "wiseOldMan";

	@ConfigSection(
		name = "Discord Alerts",
		description = "Configure Discord webhook notifications",
		position = 2
	)
	String discordAlertsSection = "discordAlerts";

	@ConfigSection(
		name = "Logging API",
		description = "Configure external data logging API",
		position = 3
	)
	String loggingApiSection = "loggingApi";

	@ConfigSection(
		name = "Bingo Tiles",
		description = "Configure specific items to track regardless of value",
		position = 4
	)
	String bingoTilesSection = "bingoTiles";

	// ========== Team Overlay Configuration ==========

	@ConfigItem(
		keyName = "displayOverlay",
		name = "Display Overlay",
		description = "Displays the team name and timestamp overlay on your game screen",
		position = 1,
		section = overlaySection
	)
	default boolean displayOverlay()
	{
		return false;
	}

	@ConfigItem(
		keyName = "displayDateTime",
		name = "Date & Time",
		description = "Adds the date and time to the overlay",
		position = 2,
		section = overlaySection
	)
	default boolean displayDateTime()
	{
		return true;
	}

	@ConfigItem(
		keyName = "teamName",
		name = "Team Name",
		description = "Your team name to display in the overlay",
		position = 3,
		section = overlaySection
	)
	default String teamName()
	{
		return "";
	}

	@ConfigItem(
		keyName = "teamNameColor",
		name = "Team Name Color",
		description = "The color of the team name in the overlay",
		position = 4,
		section = overlaySection
	)
	default Color teamNameColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "dateTimeColor",
		name = "Date & Time Color",
		description = "The color of the date and time in the overlay",
		position = 5,
		section = overlaySection
	)
	default Color dateTimeColor()
	{
		return Color.WHITE;
	}

	// ========== WiseOldMan Auto-Update Configuration ==========

	@ConfigItem(
		keyName = "enableWomAutoUpdate",
		name = "Enable Auto-Update",
		description = "Automatically update your WiseOldMan stats on logout or when gaining 10k+ XP",
		position = 1,
		section = wiseOldManSection
	)
	default boolean enableWomAutoUpdate()
	{
		return false;
	}

	// ========== Discord Alerts Configuration ==========

	@ConfigItem(
		keyName = "webhookUrl",
		name = "Webhook URL",
		description = "The Discord Webhook URL(s) to send loot notifications to, separated by newlines",
		position = 1,
		section = discordAlertsSection
	)
	default String webhookUrl()
	{
		return "";
	}

	@ConfigItem(
		keyName = "sendScreenshot",
		name = "Send Screenshot",
		description = "Whether to take and send a screenshot with notifications",
		position = 2,
		section = discordAlertsSection
	)
	default boolean sendScreenshot()
	{
		return true;
	}

	@ConfigItem(
		keyName = "manualScreenshotKeybind",
		name = "Manual Screenshot Keybind",
		description = "Keybind to manually send a screenshot to the webhook",
		position = 3,
		section = discordAlertsSection
	)
	default Keybind manualScreenshotKeybind()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "screenshotHidePrivateMessages",
		name = "Hide PMs in Screenshots",
		description = "Hide private message windows before taking webhook screenshots, then restore them",
		position = 4,
		section = discordAlertsSection
	)
	default boolean screenshotHidePrivateMessages()
	{
		return false;
	}

	@ConfigItem(
		keyName = "screenshotHideChat",
		name = "Hide Chat in Screenshots",
		description = "Hide the main chat area before taking webhook screenshots, then restore it",
		position = 5,
		section = discordAlertsSection
	)
	default boolean screenshotHideChat()
	{
		return false;
	}

	@ConfigItem(
		keyName = "includePets",
		name = "Include Pets",
		description = "Send webhook notification when receiving a pet",
		position = 6,
		section = discordAlertsSection
	)
	default boolean includePets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeCollectionLog",
		name = "Include Collection Log",
		description = "Send webhook notification for new collection log entries",
		position = 7,
		section = discordAlertsSection
	)
	default boolean includeCollectionLog()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeValuableDrops",
		name = "Include Valuable Drops",
		description = "Send webhook notification for valuable drops above threshold",
		position = 8,
		section = discordAlertsSection
	)
	default boolean includeValuableDrops()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeRaidLoot",
		name = "Include Raid Loot",
		description = "Send webhook notification for raid unique drops (COX/TOB)",
		position = 9,
		section = discordAlertsSection
	)
	default boolean includeRaidLoot()
	{
		return true;
	}

	@ConfigItem(
		keyName = "minLootValue",
		name = "Min Loot Value",
		description = "Min value (gp) for loot webhooks. Valuable drops, NPC/player loot, raid chests.",
		position = 10,
		section = discordAlertsSection
	)
	default int minLootValue()
	{
		return 1000000;
	}

	// ========== Logging API Configuration ==========

	@ConfigItem(
		keyName = "enableLoggingApi",
		name = "Enable Logging API",
		description = "Sends loot data to an api to be used for verification and post bingo statistics.",
		warning = "This feature submits your IP address, RSN, and information about your drops to a 3rd-party server not controlled or verified by Runelite developers. This data will be used for bingo tile verification, and post bingo statistics.",
		position = 1,
		section = loggingApiSection
	)
	default boolean enableLoggingApi()
	{
		return false;
	}

	@ConfigItem(
		keyName = "loggingApiUrl",
		name = "API URL",
		description = "The endpoint URL for the external logging API (Please do not change unless you know what you're doing)",
		position = 2,
		section = loggingApiSection
	)
	default String loggingApiUrl()
	{
		return "https://faux-api.thatohio.me/api/logs";
	}

	// ========== Bingo Tiles Configuration ==========

	@ConfigItem(
		keyName = "coxBingoItems",
		name = "Chambers of Xeric",
		description = "Items to track from COX, separated by commas",
		position = 1,
		section = bingoTilesSection
	)
	default String coxBingoItems()
	{
		return "";
	}

	@ConfigItem(
		keyName = "tobBingoItems",
		name = "Theatre of Blood",
		description = "Items to track from TOB, separated by commas",
		position = 2,
		section = bingoTilesSection
	)
	default String tobBingoItems()
	{
		return "";
	}

	@ConfigItem(
		keyName = "toaBingoItems",
		name = "Tombs of Amascut",
		description = "Items to track from TOA, separated by commas",
		position = 3,
		section = bingoTilesSection
	)
	default String toaBingoItems()
	{
		return "";
	}

	@ConfigItem(
		keyName = "otherBingoItems",
		name = "Other Items",
		description = "Items to track from any source, separated by commas",
		position = 4,
		section = bingoTilesSection
	)
	default String otherBingoItems()
	{
		return "";
	}
}

package com.fauxbingo;

import com.fauxbingo.handlers.CollectionLogHandler;
import com.fauxbingo.handlers.LootEventHandler;
import com.fauxbingo.handlers.ManualScreenshotHandler;
import com.fauxbingo.handlers.PetChatHandler;
import com.fauxbingo.handlers.RaidLootHandler;
import com.fauxbingo.handlers.ValuableDropHandler;
import com.fauxbingo.overlay.TeamOverlay;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import com.fauxbingo.services.WiseOldManService;
import net.runelite.client.callback.ClientThread;
import com.fauxbingo.trackers.XpTracker;
import com.google.gson.Gson;
import com.google.inject.Provides;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.UsernameChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.overlay.OverlayManager;
import okhttp3.OkHttpClient;

@Slf4j
@PluginDescriptor(
	name = "Faux Bingo",
	description = "Helper plugin for Bingo events ran in the Faux Clan/Community",
	tags = {"faux", "bingo"}
)
public class FauxBingoPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private FauxBingoConfig config;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private DrawManager drawManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private KeyManager keyManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private TeamOverlay teamOverlay;

	@Inject
	private Gson gson;

	private EventProcessor eventProcessor;
	private WebhookService webhookService;
	private ScreenshotService screenshotService;
	private WiseOldManService wiseOldManService;
	private LogService logService;
	private LootEventHandler lootEventHandler;
	private PetChatHandler petChatHandler;
	private CollectionLogHandler collectionLogHandler;
	private ValuableDropHandler valuableDropHandler;
	private RaidLootHandler raidLootHandler;
	private ManualScreenshotHandler manualScreenshotHandler;
	private XpTracker xpTracker;

	@Override
	protected void startUp() throws Exception
	{
		log.info("Faux Bingo started!");

		// Initialize services
		webhookService = new WebhookService(client, okHttpClient, executor);
		screenshotService = new ScreenshotService(client, clientThread, drawManager, config);
		wiseOldManService = new WiseOldManService(client, config, okHttpClient, gson);
		logService = new LogService(client, config, okHttpClient, gson, executor);
		eventProcessor = new EventProcessor();

		// Initialize trackers
		xpTracker = new XpTracker(client, config, wiseOldManService);

		// Initialize handlers
		lootEventHandler = new LootEventHandler(client, config, itemManager, webhookService, logService, screenshotService, executor);
		petChatHandler = new PetChatHandler(client, config, webhookService, logService, screenshotService, executor);
		collectionLogHandler = new CollectionLogHandler(client, config, webhookService, logService, screenshotService, executor);
		valuableDropHandler = new ValuableDropHandler(client, config, webhookService, logService, screenshotService, executor);
		raidLootHandler = new RaidLootHandler(client, config, webhookService, logService, screenshotService, executor, itemManager);
		manualScreenshotHandler = new ManualScreenshotHandler(client, config, webhookService, screenshotService, executor, keyManager);

		// Register event handlers
		eventProcessor.registerHandler(lootEventHandler.createNpcLootHandler());
		eventProcessor.registerHandler(lootEventHandler.createPlayerLootHandler());
		eventProcessor.registerHandler(petChatHandler);
		eventProcessor.registerHandler(collectionLogHandler.createChatHandler());
		eventProcessor.registerHandler(collectionLogHandler.createScriptHandler());
		eventProcessor.registerHandler(valuableDropHandler);
		eventProcessor.registerHandler(raidLootHandler.createChatHandler());
		eventProcessor.registerHandler(raidLootHandler.createWidgetHandler());
		eventProcessor.registerHandler(raidLootHandler.createItemContainerHandler());

		// Register manual screenshot hotkey
		manualScreenshotHandler.register();

		// Register overlay
		overlayManager.add(teamOverlay);

		log.info("Event processor initialized with all handlers");
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Faux Bingo stopped!");

		// Unregister overlay
		overlayManager.remove(teamOverlay);

		// Unregister manual screenshot hotkey
		if (manualScreenshotHandler != null)
		{
			manualScreenshotHandler.unregister();
		}

		// Clean up event processor
		if (eventProcessor != null)
		{
			eventProcessor.clearHandlers();
		}

		// Reset XP tracker
		if (xpTracker != null)
		{
			xpTracker.reset();
		}

		// Reset state
		resetState();
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived event)
	{
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onPlayerLootReceived(PlayerLootReceived event)
	{
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event)
	{
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		eventProcessor.processEvent(event);
	}
	
	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onUsernameChanged(UsernameChanged event)
	{
		resetState();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.LOGGING_IN)
		{
			resetState();
		}

		// Pass event to XP tracker
		if (xpTracker != null)
		{
			xpTracker.onGameStateChanged(event);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		// Pass event to XP tracker
		if (xpTracker != null)
		{
			xpTracker.onStatChanged(event);
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		// Pass event to XP tracker
		if (xpTracker != null)
		{
			xpTracker.onGameTick();
		}
	}

	private void resetState()
	{
		if (collectionLogHandler != null)
		{
			collectionLogHandler.resetState();
		}

		if (raidLootHandler != null)
		{
			raidLootHandler.resetState();
		}
	}

	@Provides
	FauxBingoConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FauxBingoConfig.class);
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import com.fauxbingo.services.data.LootRecord;
import java.util.Collections;
import java.util.concurrent.ScheduledExecutorService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.util.Text;

/**
 * Handles collection log events.
 * Detects new collection log items through both chat messages and notification scripts.
 */
@Slf4j
public class CollectionLogHandler
{
	private static final String COLLECTION_LOG_TEXT = "New item added to your collection log: ";

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final LogService logService;
	private final ScreenshotService screenshotService;
	private final ScheduledExecutorService executor;

	private boolean notificationStarted = false;

	public CollectionLogHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		LogService logService,
		ScreenshotService screenshotService,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.logService = logService;
		this.screenshotService = screenshotService;
		this.executor = executor;
	}

	public EventHandler<ChatMessage> createChatHandler()
	{
		return new EventHandler<ChatMessage>()
		{
			@Override
			public void handle(ChatMessage event)
			{
				if (!config.includeCollectionLog())
				{
					return;
				}

				if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
				{
					return;
				}

				String chatMessage = event.getMessage();
				if (chatMessage.startsWith(COLLECTION_LOG_TEXT) && 
					client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION) == 1)
				{
					String entry = Text.removeTags(chatMessage).substring(COLLECTION_LOG_TEXT.length());
					sendCollectionLogNotification(entry);
				}
			}

			@Override
			public Class<ChatMessage> getEventType()
			{
				return ChatMessage.class;
			}
		};
	}

	public EventHandler<ScriptPreFired> createScriptHandler()
	{
		return new EventHandler<ScriptPreFired>()
		{
			@Override
			public void handle(ScriptPreFired event)
			{
				if (!config.includeCollectionLog())
				{
					return;
				}

				switch (event.getScriptId())
				{
					case ScriptID.NOTIFICATION_START:
						notificationStarted = true;
						break;
					case ScriptID.NOTIFICATION_DELAY:
						if (!notificationStarted)
						{
							return;
						}
						String notificationTopText = client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT);
						String notificationBottomText = client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT);
						if (notificationTopText.equalsIgnoreCase("Collection log"))
						{
							String entry = Text.removeTags(notificationBottomText).substring("New item:".length()).trim();
							sendCollectionLogNotification(entry);
						}
						notificationStarted = false;
						break;
				}
			}

			@Override
			public Class<ScriptPreFired> getEventType()
			{
				return ScriptPreFired.class;
			}
		};
	}

	private void sendCollectionLogNotification(String itemName)
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** just received a new collection log item: **%s**!", 
			playerName, itemName);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message, itemName);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message, null, itemName, WebhookService.WebhookCategory.COLLECTION_LOG);
		}

		logCollectionLogItem(itemName);
	}

	private void logCollectionLogItem(String itemName)
	{
		LootRecord lootRecord = LootRecord.builder()
			.source("Collection Log")
			.items(Collections.singletonList(LootRecord.LootItem.builder()
				.name(itemName)
				.quantity(1)
				.build()))
			.build();

		logService.log("COLLECTION_LOG", lootRecord);
	}

	private void takeScreenshotAndSend(String message, String itemName)
	{
		screenshotService.requestScreenshot(image -> executor.execute(() -> {
			try
			{
				webhookService.sendWebhook(config.webhookUrl(), message, image, itemName, WebhookService.WebhookCategory.COLLECTION_LOG);
			}
			catch (Exception e)
			{
				log.error("Error sending webhook with screenshot for collection log", e);
			}
		}));
	}

	public void resetState()
	{
		notificationStarted = false;
	}
}

package com.fauxbingo.handlers;

public interface EventHandler<T>
{
	void handle(T event);

	Class<T> getEventType();
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import com.fauxbingo.services.data.LootRecord;
import com.fauxbingo.util.LootMatcher;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;

/**
 * Handles loot-related events from NPCs and players.
 * Calculates total loot value and triggers webhook notifications when threshold is met.
 */
@Slf4j
public class LootEventHandler
{
	private final Client client;
	private final FauxBingoConfig config;
	private final ItemManager itemManager;
	private final WebhookService webhookService;
	private final LogService logService;
	private final ScreenshotService screenshotService;
	private final ScheduledExecutorService executor;

	public LootEventHandler(
		Client client,
		FauxBingoConfig config,
		ItemManager itemManager,
		WebhookService webhookService,
		LogService logService,
		ScreenshotService screenshotService,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.itemManager = itemManager;
		this.webhookService = webhookService;
		this.logService = logService;
		this.screenshotService = screenshotService;
		this.executor = executor;
	}

	public EventHandler<NpcLootReceived> createNpcLootHandler()
	{
		return new EventHandler<NpcLootReceived>()
		{
			@Override
			public void handle(NpcLootReceived event)
			{
				processLoot(event.getNpc().getName(), event.getItems());
			}

			@Override
			public Class<NpcLootReceived> getEventType()
			{
				return NpcLootReceived.class;
			}
		};
	}

	public EventHandler<PlayerLootReceived> createPlayerLootHandler()
	{
		return new EventHandler<PlayerLootReceived>()
		{
			@Override
			public void handle(PlayerLootReceived event)
			{
				processLoot(event.getPlayer().getName(), event.getItems());
			}

			@Override
			public Class<PlayerLootReceived> getEventType()
			{
				return PlayerLootReceived.class;
			}
		};
	}

	private void processLoot(String source, Collection<ItemStack> items)
	{
		long totalValue = 0;
		StringBuilder lootString = new StringBuilder();

		for (ItemStack itemStack : items)
		{
			int itemId = itemStack.getId();
			int quantity = itemStack.getQuantity();
			int price = itemManager.getItemPrice(itemId);
			totalValue += (long) price * quantity;

			String itemName = itemManager.getItemComposition(itemId).getName();
			if (lootString.length() > 0)
			{
				lootString.append(", ");
			}
			lootString.append(quantity).append(" x ").append(itemName);
		}

		if (totalValue >= config.minLootValue())
		{
			String message = String.format("Loot received from %s: %s (Total value: %,d gp)",
				source, lootString.toString(), totalValue);
			
			String itemName = items.size() == 1 ? itemManager.getItemComposition(items.iterator().next().getId()).getName() : null;

			if (config.sendScreenshot())
			{
				takeScreenshotAndSend(message, itemName, WebhookService.WebhookCategory.LOOT);
			}
			else
			{
				webhookService.sendWebhook(config.webhookUrl(), message, null, itemName, WebhookService.WebhookCategory.LOOT);
			}
		}

		// Always log to the external API if enabled
		logLoot(source, items, totalValue);

		// Check for other bingo items
		checkOtherBingoItems(source, items);
	}

	private void checkOtherBingoItems(String source, Collection<ItemStack> items)
	{
		String otherItemsConfig = config.otherBingoItems();
		if (otherItemsConfig == null || otherItemsConfig.isEmpty())
		{
			return;
		}

		List<String> otherBingoItems = Arrays.stream(otherItemsConfig.split("[\n,]"))
			.map(String::trim)
			.filter(s -> !s.isEmpty())
			.collect(Collectors.toList());

		for (ItemStack itemStack : items)
		{
			String itemName = itemManager.getItemComposition(itemStack.getId()).getName();
			if (LootMatcher.matchesAny(itemName, otherBingoItems))
			{
				sendBingoNotification(source, itemName, itemStack.getQuantity());
			}
		}
	}

	private void sendBingoNotification(String source, String itemName, int quantity)
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** just received a special item from %s: **%d x %s**!",
			playerName, source, quantity, itemName);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message, itemName, WebhookService.WebhookCategory.BINGO_LOOT);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message, null, itemName, WebhookService.WebhookCategory.BINGO_LOOT);
		}
	}

	private void logLoot(String source, Collection<ItemStack> items, long totalValue)
	{
		List<LootRecord.LootItem> lootItems = items.stream()
			.map(item -> LootRecord.LootItem.builder()
				.id(item.getId())
				.name(itemManager.getItemComposition(item.getId()).getName())
				.quantity(item.getQuantity())
				.price(itemManager.getItemPrice(item.getId()))
				.build())
			.collect(Collectors.toList());

		LootRecord lootRecord = LootRecord.builder()
			.source(source)
			.items(lootItems)
			.totalValue(totalValue)
			.build();

		logService.log("LOOT", lootRecord);
	}

	private void takeScreenshotAndSend(String message, String itemName, WebhookService.WebhookCategory category)
	{
		screenshotService.requestScreenshot(image -> executor.execute(() -> {
			try
			{
				webhookService.sendWebhook(config.webhookUrl(), message, image, itemName, category);
			}
			catch (Exception e)
			{
				log.error("Error sending webhook with screenshot for {}", category, e);
			}
		}));
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import java.util.concurrent.ScheduledExecutorService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.input.KeyManager;
import net.runelite.client.util.HotkeyListener;

/**
 * Handles manual screenshot capture via keybind.
 */
@Slf4j
public class ManualScreenshotHandler
{
	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final ScreenshotService screenshotService;
	private final ScheduledExecutorService executor;
	private final KeyManager keyManager;

	private final HotkeyListener hotkeyListener;

	public ManualScreenshotHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		ScreenshotService screenshotService,
		ScheduledExecutorService executor,
		KeyManager keyManager)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.screenshotService = screenshotService;
		this.executor = executor;
		this.keyManager = keyManager;

		this.hotkeyListener = new HotkeyListener(() -> config.manualScreenshotKeybind())
		{
			@Override
			public void hotkeyPressed()
			{
				sendManualScreenshot();
			}
		};
	}

	public void register()
	{
		keyManager.registerKeyListener(hotkeyListener);
		log.debug("Manual screenshot hotkey registered");
	}

	public void unregister()
	{
		keyManager.unregisterKeyListener(hotkeyListener);
		log.debug("Manual screenshot hotkey unregistered");
	}

	private void sendManualScreenshot()
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** sent a manual screenshot", playerName);

		screenshotService.requestScreenshot(image -> executor.execute(() -> {
			try
			{
				webhookService.sendWebhook(config.webhookUrl(), message, image);
				log.info("Manual screenshot sent");
			}
			catch (Exception e)
			{
				log.error("Error sending manual screenshot", e);
			}
		}));
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import com.fauxbingo.services.data.LootRecord;
import com.google.common.collect.ImmutableList;
import java.util.Collections;
import java.util.concurrent.ScheduledExecutorService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

/**
 * Handles chat message events to detect pet drops.
 */
@Slf4j
public class PetChatHandler implements EventHandler<ChatMessage>
{
	private static final ImmutableList<String> PET_MESSAGES = ImmutableList.of(
		"You have a funny feeling like you're being followed",
		"You feel something weird sneaking into your backpack",
		"You have a funny feeling like you would have been followed"
	);

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final LogService logService;
	private final ScreenshotService screenshotService;
	private final ScheduledExecutorService executor;

	public PetChatHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		LogService logService,
		ScreenshotService screenshotService,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.logService = logService;
		this.screenshotService = screenshotService;
		this.executor = executor;
	}

	@Override
	public void handle(ChatMessage event)
	{
		if (!config.includePets())
		{
			return;
		}

		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String message = event.getMessage();

		// Check if message indicates a pet drop
		if (PET_MESSAGES.stream().anyMatch(message::contains))
		{
			handlePetDrop();
		}
	}

	@Override
	public Class<ChatMessage> getEventType()
	{
		return ChatMessage.class;
	}

	private void handlePetDrop()
	{
		log.info("Pet drop detected");

		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String webhookMessage = String.format("**%s** just received a new pet!", playerName);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(webhookMessage, "Pet");
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), webhookMessage, null, "Pet", WebhookService.WebhookCategory.PET);
		}

		logPetDrop();
	}

	private void logPetDrop()
	{
		LootRecord lootRecord = LootRecord.builder()
			.source("Pet")
			.items(Collections.singletonList(LootRecord.LootItem.builder()
				.name("Pet")
				.quantity(1)
				.build()))
			.build();

		logService.log("PET", lootRecord);
	}

	private void takeScreenshotAndSend(String message, String itemName)
	{
		screenshotService.requestScreenshot(image -> executor.execute(() -> {
			try
			{
				webhookService.sendWebhook(config.webhookUrl(), message, image, itemName, WebhookService.WebhookCategory.PET);
			}
			catch (Exception e)
			{
				log.error("Error sending webhook with screenshot for pet drop", e);
			}
		}));
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import com.fauxbingo.services.data.LootRecord;
import com.fauxbingo.util.LootMatcher;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.Text;

/**
 * Handles raid loot notifications for Chambers of Xeric and Theatre of Blood.
 * Tracks raid completions and unique drops from both raids.
 */
@Slf4j
public class RaidLootHandler
{
	private static final Pattern COX_UNIQUE_MESSAGE_PATTERN = Pattern.compile("(.+) - (.+)");
	private static final String COX_DUST_MESSAGE_TEXT = "Dust recipients: ";
	private static final String COX_KIT_MESSAGE_TEXT = "Twisted Kit recipients: ";
	private static final Pattern TOB_UNIQUE_MESSAGE_PATTERN = Pattern.compile("(.+) found something special: (.+)");
	private static final Pattern TOA_UNIQUE_MESSAGE_PATTERN = Pattern.compile("Loot recipient: (.+) - (.+)");
	private static final Pattern KC_MESSAGE_PATTERN = Pattern.compile("([0-9]+)");

	private static final int CoX_Interface_Id = InterfaceID.RAIDS_REWARDS;
	private static final int ToB_Interface_Id = InterfaceID.TOB_CHESTS;
	private static final int ToA_Interface_Id = 775; // InterfaceID.TOA_REWARD_CHEST might not be available in all versions

	private static final int CoX_Container_Id = 581;
	private static final int ToB_Container_Id = 612;
	private static final int ToA_Container_Id = 801;

	enum RaidType
	{
		COX,
		COX_CM,
		TOB,
		TOB_SM,
		TOB_HM,
		TOA_ENTRY,
		TOA_NORMAL,
		TOA_EXPERT
	}

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final LogService logService;
	private final ScreenshotService screenshotService;
	private final ScheduledExecutorService executor;
	private final ItemManager itemManager;

	private RaidType raidType;
	private Integer raidKc;
	private final List<String> rareDrops = new ArrayList<>();
	private boolean raidProcessed = false;
	private long lastProcessedTime = 0;

	public RaidLootHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		LogService logService,
		ScreenshotService screenshotService,
		ScheduledExecutorService executor,
		ItemManager itemManager)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.logService = logService;
		this.screenshotService = screenshotService;
		this.executor = executor;
		this.itemManager = itemManager;
	}

	public EventHandler<ChatMessage> createChatHandler()
	{
		return new EventHandler<ChatMessage>()
		{
			@Override
			public void handle(ChatMessage event)
			{
				if (!config.includeRaidLoot())
				{
					return;
				}

				if (event.getType() != ChatMessageType.GAMEMESSAGE
					&& event.getType() != ChatMessageType.SPAM
					&& event.getType() != ChatMessageType.TRADE
					&& event.getType() != ChatMessageType.FRIENDSCHATNOTIFICATION)
				{
					return;
				}

				String chatMessage = event.getMessage();
				handleRaidChatMessage(chatMessage);
			}

			@Override
			public Class<ChatMessage> getEventType()
			{
				return ChatMessage.class;
			}
		};
	}

	public EventHandler<WidgetLoaded> createWidgetHandler()
	{
		return new EventHandler<WidgetLoaded>()
		{
			@Override
			public void handle(WidgetLoaded event)
			{
				if (!config.includeRaidLoot())
				{
					return;
				}

				int groupId = event.getGroupId();

				if (groupId == CoX_Interface_Id || groupId == ToB_Interface_Id || groupId == ToA_Interface_Id)
				{
					handleRaidRewardWidget(groupId);
				}
			}

			@Override
			public Class<WidgetLoaded> getEventType()
			{
				return WidgetLoaded.class;
			}
		};
	}

	public EventHandler<ItemContainerChanged> createItemContainerHandler()
	{
		return new EventHandler<ItemContainerChanged>()
		{
			@Override
			public void handle(ItemContainerChanged event)
			{
				if (!config.includeRaidLoot())
				{
					return;
				}

				int containerId = event.getContainerId();
				if (containerId == CoX_Container_Id || containerId == ToB_Container_Id || containerId == ToA_Container_Id)
				{
					handleRaidInventory(containerId, event.getItemContainer());
				}
			}

			@Override
			public Class<ItemContainerChanged> getEventType()
			{
				return ItemContainerChanged.class;
			}
		};
	}

	private void handleRaidChatMessage(String chatMessage)
	{
		String cleanMessage = Text.removeTags(chatMessage);

		// Check for completion messages - these mark the start of a new raid loot sequence
		if (cleanMessage.startsWith("Your completed Chambers of Xeric count is:") ||
			cleanMessage.startsWith("Your completed Theatre of Blood") ||
			(cleanMessage.contains("Tombs of Amascut") && cleanMessage.contains("completion count is")))
		{
			// Reset state for new raid loot
			resetState();
		}

		// Check for COX completion
		if (cleanMessage.startsWith("Your completed Chambers of Xeric count is:"))
		{
			Matcher matcher = KC_MESSAGE_PATTERN.matcher(cleanMessage);
			if (matcher.find())
			{
				raidType = cleanMessage.contains("Challenge Mode") ? RaidType.COX_CM : RaidType.COX;
				raidKc = Integer.valueOf(matcher.group());
				return;
			}
		}

		// Check for TOB completion
		if (cleanMessage.startsWith("Your completed Theatre of Blood"))
		{
			Matcher matcher = KC_MESSAGE_PATTERN.matcher(cleanMessage);
			if (matcher.find())
			{
				raidType = cleanMessage.contains("Hard Mode") ? RaidType.TOB_HM :
					(cleanMessage.contains("Story Mode") ? RaidType.TOB_SM : RaidType.TOB);
				raidKc = Integer.valueOf(matcher.group());
				return;
			}
		}

		// Check for TOA completion
		if (cleanMessage.contains("Tombs of Amascut") && cleanMessage.contains("completion count is"))
		{
			Matcher matcher = KC_MESSAGE_PATTERN.matcher(cleanMessage);
			if (matcher.find())
			{
				if (cleanMessage.contains("Expert Mode"))
				{
					raidType = RaidType.TOA_EXPERT;
				}
				else if (cleanMessage.contains("Entry Mode"))
				{
					raidType = RaidType.TOA_ENTRY;
				}
				else
				{
					raidType = RaidType.TOA_NORMAL;
				}
				raidKc = Integer.valueOf(matcher.group());
				return;
			}
		}

		// Check for TOA unique drops
		Matcher toaUnique = TOA_UNIQUE_MESSAGE_PATTERN.matcher(chatMessage);
		if (toaUnique.matches())
		{
			final String lootRecipient = Text.sanitize(toaUnique.group(1)).trim();
			if (lootRecipient.equalsIgnoreCase(getLocalPlayerName()))
			{
				rareDrops.add(toaUnique.group(2).trim());
			}
			return;
		}

		// Check for COX unique drops
		Matcher coxUnique = COX_UNIQUE_MESSAGE_PATTERN.matcher(chatMessage);
		if (coxUnique.matches())
		{
			final String lootRecipient = Text.sanitize(coxUnique.group(1)).trim();
			if (lootRecipient.equalsIgnoreCase(getLocalPlayerName()))
			{
				rareDrops.add(coxUnique.group(2).trim());
			}
			return;
		}

		// Check for COX metamorphic dust
		if (cleanMessage.startsWith(COX_DUST_MESSAGE_TEXT))
		{
			if (cleanMessage.toLowerCase().contains(getLocalPlayerName().toLowerCase()))
			{
				rareDrops.add("Metamorphic dust");
			}
			return;
		}

		// Check for COX twisted kit
		if (cleanMessage.startsWith(COX_KIT_MESSAGE_TEXT))
		{
			if (cleanMessage.toLowerCase().contains(getLocalPlayerName().toLowerCase()))
			{
				rareDrops.add("Twisted ancestral colour kit");
			}
			return;
		}

		// Check for TOB unique drops
		Matcher tobUnique = TOB_UNIQUE_MESSAGE_PATTERN.matcher(chatMessage);
		if (tobUnique.matches())
		{
			final String lootRecipient = Text.sanitize(tobUnique.group(1)).trim();
			if (lootRecipient.equalsIgnoreCase(getLocalPlayerName()))
			{
				rareDrops.add(tobUnique.group(2).trim());
			}
			return;
		}
	}

	private void handleRaidRewardWidget(int groupId)
	{
		// Widget loading is a good signal that we're looking at loot.
		// If we haven't processed for a while, we can assume it's a new attempt.
		if (System.currentTimeMillis() - lastProcessedTime > 60000)
		{
			raidProcessed = false;
		}
	}

	private void handleRaidInventory(int containerId, ItemContainer itemContainer)
	{
		if (itemContainer == null || raidProcessed)
		{
			return;
		}

		String raidName = getRaidName(containerId);
		if (raidName == null)
		{
			return;
		}

		// Only process if container has items
		Item[] items = itemContainer.getItems();
		if (items == null || items.length == 0 || Arrays.stream(items).allMatch(i -> i.getId() == -1))
		{
			return;
		}

		try
		{
			processRaidLoot(raidName, itemContainer);
		}
		finally
		{
			// Clear per-raid rare drop state after loot is processed to avoid replaying on later chests.
			rareDrops.clear();
		}
		raidProcessed = true;
		lastProcessedTime = System.currentTimeMillis();
	}

	private void processRaidLoot(String raidName, ItemContainer itemContainer)
	{
		List<String> raidBingoItemsConfig = getBingoItemsForRaid(raidName);
		List<String> otherBingoItemsConfig = getOtherBingoItems();

		long totalValue = 0;
		List<LootRecord.LootItem> allItems = new ArrayList<>();
		List<LootRecord.LootItem> bingoItemsFound = new ArrayList<>();

		for (Item item : itemContainer.getItems())
		{
			int itemId = item.getId();
			if (itemId != -1)
			{
				String itemName = itemManager.getItemComposition(itemId).getName();
				int quantity = item.getQuantity();
				int price = itemManager.getItemPrice(itemId);
				totalValue += (long) price * quantity;

				LootRecord.LootItem lootItem = LootRecord.LootItem.builder()
					.id(itemId)
					.name(itemName)
					.quantity(quantity)
					.price(price)
					.build();

				allItems.add(lootItem);

				if (LootMatcher.matchesAny(itemName, raidBingoItemsConfig) || LootMatcher.matchesAny(itemName, otherBingoItemsConfig))
				{
					bingoItemsFound.add(lootItem);
				}
			}
		}

		// Also check if any rareDrops from chat are not in the container (e.g. Dust/Kits might be special)
		// Actually they are in the container, but we have them in rareDrops list already.
		
		boolean hasRareDrop = !rareDrops.isEmpty();
		boolean hasBingoItem = !bingoItemsFound.isEmpty();
		boolean isValuable = totalValue >= config.minLootValue();

		if (hasRareDrop || hasBingoItem || isValuable)
		{
			sendConsolidatedRaidNotification(raidName, allItems, bingoItemsFound, totalValue);
		}
		else
		{
			logGeneralLoot(allItems, totalValue, raidName, raidKc);
		}
	}

	private List<String> getBingoItemsForRaid(String raidName)
	{
		String configItems = "";
		if (raidName.contains("Chambers of Xeric"))
		{
			configItems = config.coxBingoItems();
		}
		else if (raidName.contains("Theatre of Blood"))
		{
			configItems = config.tobBingoItems();
		}
		else if (raidName.contains("Tombs of Amascut"))
		{
			configItems = config.toaBingoItems();
		}

		if (configItems == null || configItems.isEmpty())
		{
			return Collections.emptyList();
		}

		return Arrays.stream(configItems.split("[\n,]"))
			.map(String::trim)
			.filter(s -> !s.isEmpty())
			.collect(Collectors.toList());
	}

	private void sendConsolidatedRaidNotification(String raidName, List<LootRecord.LootItem> allItems, List<LootRecord.LootItem> bingoItems, long totalValue)
	{
		String playerName = getLocalPlayerName();
		StringBuilder message = new StringBuilder();
		
		String category = "Loot";
		WebhookService.WebhookCategory webhookCategory = WebhookService.WebhookCategory.RAID_LOOT;
		String bundlingItem = null;

		if (!rareDrops.isEmpty())
		{
			category = "a Rare Drop";
			bundlingItem = rareDrops.get(0);
			message.append(String.format("**%s** just received a rare drop from %s: **%s**!\n",
				playerName, raidName, String.join(", ", rareDrops)));
		}
		else if (!bingoItems.isEmpty())
		{
			category = "Bingo Loot";
			webhookCategory = WebhookService.WebhookCategory.BINGO_LOOT;
			bundlingItem = bingoItems.get(0).getName();
			String itemsString = bingoItems.stream()
				.map(i -> i.getQuantity() + " x " + i.getName())
				.collect(Collectors.joining(", "));
			message.append(String.format("**%s** just received Bingo loot from %s: **%s**!\n",
				playerName, raidName, itemsString));
		}
		else
		{
			message.append(String.format("**%s** just received loot from %s:\n", playerName, raidName));
		}

		// Add all loot details
		StringBuilder lootList = new StringBuilder();
		for (LootRecord.LootItem item : allItems)
		{
			if (lootList.length() > 0) lootList.append(", ");
			lootList.append(item.getQuantity()).append(" x ").append(item.getName());
		}
		message.append("Loot: ").append(lootList).append(String.format(" (Total value: %,d gp)", totalValue));

		if (raidKc != null && raidKc > 0)
		{
			message.append(String.format("\nKill Count: **%d**", raidKc));
		}

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message.toString(), bundlingItem, webhookCategory);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message.toString(), null, bundlingItem, webhookCategory);
		}

		// Log everything
		if (!bingoItems.isEmpty())
		{
			for (LootRecord.LootItem item : bingoItems)
			{
				logBingoLoot(item.getName(), item.getQuantity(), raidName, raidKc);
			}
		}
		
		logGeneralLoot(allItems, totalValue, raidName, raidKc);
	}

	private String getRaidName(int id)
	{
		if (id == CoX_Interface_Id || id == CoX_Container_Id)
		{
			if (raidType == RaidType.COX_CM)
			{
				return "Chambers of Xeric Challenge Mode";
			}
			return "Chambers of Xeric";
		}
		else if (id == ToB_Interface_Id || id == ToB_Container_Id)
		{
			if (raidType == RaidType.TOB_SM)
			{
				return "Theatre of Blood Story Mode";
			}
			else if (raidType == RaidType.TOB_HM)
			{
				return "Theatre of Blood Hard Mode";
			}
			return "Theatre of Blood";
		}
		else if (id == ToA_Interface_Id || id == ToA_Container_Id)
		{
			if (raidType == RaidType.TOA_EXPERT)
			{
				return "Tombs of Amascut Expert Mode";
			}
			else if (raidType == RaidType.TOA_ENTRY)
			{
				return "Tombs of Amascut Entry Mode";
			}
			return "Tombs of Amascut";
		}
		return null;
	}

	private void logGeneralLoot(List<LootRecord.LootItem> items, long totalValue, String raidName, Integer kc)
	{
		LootRecord lootRecord = LootRecord.builder()
			.source(raidName)
			.items(items)
			.totalValue(totalValue)
			.kc(kc)
			.build();

		logService.log("RAID_LOOT", lootRecord);
	}

	private List<String> getOtherBingoItems()
	{
		String otherItems = config.otherBingoItems();
		if (otherItems == null || otherItems.isEmpty())
		{
			return Collections.emptyList();
		}

		return Arrays.stream(otherItems.split("[\n,]"))
			.map(String::trim)
			.filter(s -> !s.isEmpty())
			.collect(Collectors.toList());
	}

	private void logBingoLoot(String itemName, int quantity, String raidName, Integer kc)
	{
		LootRecord lootRecord = LootRecord.builder()
			.source(raidName)
			.items(Collections.singletonList(LootRecord.LootItem.builder()
				.name(itemName)
				.quantity(quantity)
				.build()))
			.kc(kc)
			.build();

		logService.log("BINGO_LOOT", lootRecord);
	}

	private void takeScreenshotAndSend(String message, String itemName, WebhookService.WebhookCategory category)
	{
		screenshotService.requestScreenshot(image -> executor.execute(() -> {
			try
			{
				webhookService.sendWebhook(config.webhookUrl(), message, image, itemName, category);
			}
			catch (Exception e)
			{
				log.error("Error sending webhook with screenshot for raid loot", e);
			}
		}));
	}

	public void resetState()
	{
		raidType = null;
		raidKc = null;
		rareDrops.clear();
	}

	private String getLocalPlayerName()
	{
		return client.getLocalPlayer() != null ? Text.sanitize(client.getLocalPlayer().getName()) : "Player";
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import com.fauxbingo.services.data.LootRecord;
import com.fauxbingo.util.LootMatcher;
import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

/**
 * Handles valuable drop notifications from chat messages.
 * Detects when the game announces a valuable drop. Logs all; webhook only when >= minLootValue.
 */
@Slf4j
public class ValuableDropHandler implements EventHandler<ChatMessage>
{
	private static final Pattern VALUABLE_DROP_PATTERN = Pattern.compile(
		".*Valuable drop: ([^<>]+?\\(((?:\\d+,?)+) coins\\))(?:</col>)?"
	);

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final LogService logService;
	private final ScreenshotService screenshotService;
	private final ScheduledExecutorService executor;

	public ValuableDropHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		LogService logService,
		ScreenshotService screenshotService,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.logService = logService;
		this.screenshotService = screenshotService;
		this.executor = executor;
	}

	@Override
	public void handle(ChatMessage event)
	{
		if (!config.includeValuableDrops())
		{
			return;
		}

		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String chatMessage = event.getMessage();
		Matcher matcher = VALUABLE_DROP_PATTERN.matcher(chatMessage);
		
		if (matcher.matches())
		{
			long valuableDropValue = Long.parseLong(matcher.group(2).replaceAll(",", ""));
			String[] valuableDrop = matcher.group(1).split(" \\(");
			String valuableDropName = (String) Array.get(valuableDrop, 0);
			String valuableDropValueString = matcher.group(2);

			logValuableDrop(valuableDropName, valuableDropValueString);
			if (valuableDropValue >= config.minLootValue())
			{
				sendValuableDropNotification(valuableDropName, valuableDropValueString);
			}

			checkOtherBingoItems(valuableDropName);
		}
	}

	private void checkOtherBingoItems(String itemNameWithQuantity)
	{
		String otherItemsConfig = config.otherBingoItems();
		if (otherItemsConfig == null || otherItemsConfig.isEmpty())
		{
			return;
		}

		List<String> otherBingoItems = Arrays.stream(otherItemsConfig.split("[\n,]"))
			.map(String::trim)
			.filter(s -> !s.isEmpty())
			.collect(Collectors.toList());

		String itemName = cleanItemName(itemNameWithQuantity);
		if (LootMatcher.matchesAny(itemName, otherBingoItems))
		{
			int quantity = 1;
			Pattern quantityPattern = Pattern.compile("^([0-9,]+) x ");
			Matcher quantityMatcher = quantityPattern.matcher(itemNameWithQuantity);
			if (quantityMatcher.find())
			{
				quantity = Integer.parseInt(quantityMatcher.group(1).replaceAll(",", ""));
			}

			sendBingoNotification(itemName, quantity);
		}
	}

	private void sendBingoNotification(String itemName, int quantity)
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** just received a special item: **%d x %s**!",
			playerName, quantity, itemName);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message, itemName, WebhookService.WebhookCategory.BINGO_LOOT);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message, null, itemName, WebhookService.WebhookCategory.BINGO_LOOT);
		}
	}

	@Override
	public Class<ChatMessage> getEventType()
	{
		return ChatMessage.class;
	}

	private void sendValuableDropNotification(String itemName, String itemValue)
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** just received a valuable drop: **%s**!\nApprox Value: **%s coins**", 
			playerName, itemName, itemValue);

		String bundlingKey = cleanItemName(itemName);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message, bundlingKey, WebhookService.WebhookCategory.VALUABLE_DROP);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message, null, bundlingKey, WebhookService.WebhookCategory.VALUABLE_DROP);
		}
	}

	private String cleanItemName(String itemName)
	{
		if (itemName == null)
		{
			return null;
		}
		// Strip quantity prefix like "30 x " or "1,000 x " to help with bundling across different handlers
		return itemName.replaceAll("^[0-9,]+ x ", "");
	}

	private void logValuableDrop(String itemName, String itemValue)
	{
		long value = Long.parseLong(itemValue.replaceAll(",", ""));

		LootRecord lootRecord = LootRecord.builder()
			.source("Valuable Drop")
			.items(Collections.singletonList(LootRecord.LootItem.builder()
				.name(itemName)
				.quantity(1)
				.price((int) value) // might overflow if > 2B, but item prices are usually ints
				.build()))
			.totalValue(value)
			.build();

		logService.log("VALUABLE_DROP", lootRecord);
	}

	private void takeScreenshotAndSend(String message, String itemName, WebhookService.WebhookCategory category)
	{
		screenshotService.requestScreenshot(image -> executor.execute(() -> {
			try
			{
				webhookService.sendWebhook(config.webhookUrl(), message, image, itemName, category);
			}
			catch (Exception e)
			{
				log.error("Error sending webhook with screenshot for {}", category, e);
			}
		}));
	}
}

package com.fauxbingo.overlay;

import com.fauxbingo.FauxBingoConfig;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

/**
 * Overlay that displays team name and current date/time in UTC.
 * Used for verification purposes when screenshots are sent to Discord webhooks.
 */
public class TeamOverlay extends OverlayPanel
{
	private final FauxBingoConfig config;

	@Inject
	public TeamOverlay(FauxBingoConfig config)
	{
		this.config = config;
		setPosition(OverlayPosition.TOP_CENTER);
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Faux Bingo overlay"));
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Only render if overlay is enabled and team name is set
		if (!config.displayOverlay() || config.teamName().trim().isEmpty())
		{
			return null;
		}

		String teamName = config.teamName();
		Color teamNameColor = config.teamNameColor();
		Color dateTimeColor = config.dateTimeColor();

		// Ensure colors are different, fallback to defaults if they match
		if (teamNameColor.equals(dateTimeColor))
		{
			teamNameColor = Color.GREEN;
			dateTimeColor = Color.WHITE;
		}

		// Build the full text for width calculation
		String fullText = teamName;
		if (config.displayDateTime())
		{
			fullText = teamName + " " + getUtcDateTime();
		}

		// Add team name as the left component
		panelComponent.getChildren().add(LineComponent.builder()
			.left(teamName)
			.leftColor(teamNameColor)
			.build());

		// Add date/time as the right component if enabled
		if (config.displayDateTime())
		{
			List<LayoutableRenderableEntity> children = panelComponent.getChildren();
			LineComponent line = (LineComponent) children.get(0);
			line.setRight(getUtcDateTime());
			line.setRightColor(dateTimeColor);
		}

		// Set preferred size based on text width
		panelComponent.setPreferredSize(new Dimension(
			graphics.getFontMetrics().stringWidth(fullText) + 10, 0));

		return super.render(graphics);
	}

	private String getUtcDateTime()
	{
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
		return sdf.format(date) + " UTC";
	}
}

package com.fauxbingo.services.data;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class LogEntry
{
	private String player;
	private String type;
	private long timestamp;
	private Object data;
}

package com.fauxbingo.services.data;

import java.util.List;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class LootRecord
{
	private String source;
	private List<LootItem> items;
	private long totalValue;
	private Integer kc;

	@Data
	@Builder
	public static class LootItem
	{
		private int id;
		private String name;
		private int quantity;
		private int price;
	}
}

package com.fauxbingo.services;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.data.LogEntry;
import com.google.gson.Gson;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * Service responsible for queueing and sending data logs to an external API for post Bingo statistics
 */
@Slf4j
public class LogService
{
	private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
	private static final int BATCH_SIZE = 10;
	private static final int FLUSH_INTERVAL_SECONDS = 30;

	private final Client client;
	private final FauxBingoConfig config;
	private final OkHttpClient okHttpClient;
	private final Gson gson;
	private final Queue<LogEntry> queue = new ConcurrentLinkedQueue<>();

	public LogService(Client client, FauxBingoConfig config, OkHttpClient okHttpClient, Gson gson, ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.okHttpClient = okHttpClient;
		this.gson = gson;

		executor.scheduleAtFixedRate(this::flushQueue, FLUSH_INTERVAL_SECONDS, FLUSH_INTERVAL_SECONDS, TimeUnit.SECONDS);
	}

	/**
	 * Adds an entry to the queue.
	 */
	public void log(String type, Object data)
	{
		if (!config.enableLoggingApi() || config.loggingApiUrl().isEmpty() || client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : null;
		
		LogEntry entry = LogEntry.builder()
			.player(playerName)
			.type(type)
			.timestamp(System.currentTimeMillis())
			.data(data)
			.build();

		queue.add(entry);

		if (queue.size() >= BATCH_SIZE)
		{
			flushQueue();
		}
	}

	private synchronized void flushQueue()
	{
		if (queue.isEmpty() || config.loggingApiUrl().isEmpty())
		{
			return;
		}

		List<LogEntry> batch = new ArrayList<>();
		LogEntry entry;
		while (batch.size() < BATCH_SIZE && (entry = queue.poll()) != null)
		{
			batch.add(entry);
		}

		if (batch.isEmpty())
		{
			return;
		}

		sendBatch(batch);
	}

	private void sendBatch(List<LogEntry> batch)
	{
		String json = gson.toJson(batch);
		Request request = new Request.Builder()
			.url(config.loggingApiUrl())
			.post(RequestBody.create(JSON, json))
			.build();

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Error sending batch to API", e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				if (!response.isSuccessful())
				{
					log.error("API returned error: {} {}", response.code(), response.message());
				}
				response.close();
			}
		});
	}
}

package com.fauxbingo.services;

import com.fauxbingo.FauxBingoConfig;
import java.awt.image.BufferedImage;
import java.util.function.Consumer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.DrawManager;

/**
 * Centralized screenshot capture with optional chat/PM hiding for privacy.
 * Hides private messages and/or main chat (per config) before capture, then unhides after.
 */
@Slf4j
public class ScreenshotService
{
	private final Client client;
	private final ClientThread clientThread;
	private final DrawManager drawManager;
	private final FauxBingoConfig config;

	public ScreenshotService(
		Client client,
		ClientThread clientThread,
		DrawManager drawManager,
		FauxBingoConfig config)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.drawManager = drawManager;
		this.config = config;
	}

	/**
	 * Request a screenshot. Hides PM and/or main chat per config before capture, then unhides after.
	 * The onImage callback receives the captured image, run any I/O (e.g. webhook) on a background executor.
	 * Safe to call from any thread (e.g. AWT for hotkeys), hide/show and frame capture run on the client thread.
	 *
	 * @param onImage consumer for the captured image, typically called from the frame listener
	 */
	public void requestScreenshot(Consumer<BufferedImage> onImage)
	{
		boolean hidePm = config.screenshotHidePrivateMessages();
		boolean hideChat = config.screenshotHideChat();

		clientThread.invokeLater(() -> {
			boolean pmHidden = hideWidget(hidePm, InterfaceID.PmChat.CONTAINER);
			boolean chatHidden = hideWidget(hideChat, InterfaceID.Chatbox.CHATAREA);

			drawManager.requestNextFrameListener(image -> {
				BufferedImage buffered = image instanceof BufferedImage ? (BufferedImage) image : null;
				if (buffered != null)
				{
					onImage.accept(buffered);
				}
				else
				{
					log.warn("DrawManager did not provide a BufferedImage. Skipping screenshot callback.");
				}

				unhideWidget(pmHidden, InterfaceID.PmChat.CONTAINER);
				unhideWidget(chatHidden, InterfaceID.Chatbox.CHATAREA);
			});
		});
	}

	/**
	 * Hide a widget if shouldHide is true. Call on client thread.
	 *
	 * @return true if the widget was hidden by this call
	 */
	private boolean hideWidget(boolean shouldHide, int componentId)
	{
		if (!shouldHide)
		{
			return false;
		}
		Widget widget = client.getWidget(componentId);
		if (widget == null || widget.isHidden())
		{
			return false;
		}
		widget.setHidden(true);
		return true;
	}

	/**
	 * Unhide a widget if we had hidden it. Must run on client thread, uses ClientThread.invoke.
	 */
	private void unhideWidget(boolean shouldUnhide, int componentId)
	{
		if (!shouldUnhide)
		{
			return;
		}
		clientThread.invoke(() -> {
			Widget widget = client.getWidget(componentId);
			if (widget != null)
			{
				widget.setHidden(false);
			}
		});
	}
}

package com.fauxbingo.services;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import javax.imageio.ImageIO;
import lombok.Builder;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * Service responsible for sending discord webhook notifications with optional screenshots.
 */
@Slf4j
public class WebhookService
{
	private final OkHttpClient okHttpClient;
	private final ScheduledExecutorService executor;
	private final Client client;
	private final List<QueuedWebhook> queue = new ArrayList<>();
	private ScheduledFuture<?> flushTask = null;

	public enum WebhookCategory
	{
		PET(1),
		RAID_LOOT(2),
		BINGO_LOOT(3),
		VALUABLE_DROP(4),
		COLLECTION_LOG(5),
		LOOT(6),
		MISC(7);

		private final int priority;

		WebhookCategory(int priority)
		{
			this.priority = priority;
		}

		public int getPriority()
		{
			return priority;
		}
	}

	@Data
	@Builder
	private static class QueuedWebhook
	{
		private final String webhookUrls;
		private final String message;
		private final BufferedImage image;
		private final String itemName;
		private final WebhookCategory category;
	}

	public WebhookService(Client client, OkHttpClient okHttpClient, ScheduledExecutorService executor)
	{
		this.client = client;
		this.okHttpClient = okHttpClient;
		this.executor = executor;
	}

	public void sendWebhook(String webhookUrls, String message, BufferedImage image)
	{
		sendWebhook(webhookUrls, message, image, null, WebhookCategory.MISC, false);
	}

	/**
	 * Send a webhook message to the configured URLs with an optional item name for bundling.
	 *
	 * @param webhookUrls Newline-separated list of webhook URLs
	 * @param message The message content to send
	 * @param image Optional screenshot to attach (can be null)
	 * @param itemName Optional item name to use for bundling related events
	 * @param category The category of the webhook for priority and bundling
	 */
	public void sendWebhook(String webhookUrls, String message, BufferedImage image, String itemName, WebhookCategory category)
	{
		sendWebhook(webhookUrls, message, image, itemName, category, true);
	}

	/**
	 * Send a webhook message to the configured URLs with an optional item name for bundling.
	 *
	 * @param webhookUrls Newline-separated list of webhook URLs
	 * @param message The message content to send
	 * @param image Optional screenshot to attach (can be null)
	 * @param itemName Optional item name to use for bundling related events
	 * @param category The category of the webhook for priority and bundling
	 * @param checkGameState Whether to check if the player is logged in before sending
	 */
	public synchronized void sendWebhook(String webhookUrls, String message, BufferedImage image, String itemName, WebhookCategory category, boolean checkGameState)
	{
		if (checkGameState && client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if (webhookUrls == null || webhookUrls.isEmpty())
		{
			return;
		}

		queue.add(QueuedWebhook.builder()
			.webhookUrls(webhookUrls)
			.message(message)
			.image(image)
			.itemName(itemName)
			.category(category)
			.build());

		if (flushTask == null || flushTask.isDone())
		{
			flushTask = executor.schedule(this::flushBatch, 3, TimeUnit.SECONDS);
		}
	}

	private synchronized void flushBatch()
	{
		if (queue.isEmpty())
		{
			return;
		}

		// Group by webhookUrls first, in case they are different
		Map<String, List<QueuedWebhook>> byUrls = queue.stream()
			.collect(Collectors.groupingBy(QueuedWebhook::getWebhookUrls));

		for (Map.Entry<String, List<QueuedWebhook>> urlEntry : byUrls.entrySet())
		{
			String urls = urlEntry.getKey();
			List<QueuedWebhook> urlQueue = urlEntry.getValue();

			// Separate items with names and those without
			List<QueuedWebhook> namedItems = urlQueue.stream()
				.filter(q -> q.getItemName() != null)
				.collect(Collectors.toList());

			List<QueuedWebhook> unnamedItems = urlQueue.stream()
				.filter(q -> q.getItemName() == null)
				.collect(Collectors.toList());

			// Group named items by item name
			Map<String, List<QueuedWebhook>> groupedItems = namedItems.stream()
				.collect(Collectors.groupingBy(QueuedWebhook::getItemName));

			for (List<QueuedWebhook> group : groupedItems.values())
			{
				if (group.size() == 1)
				{
					QueuedWebhook single = group.get(0);
					processWebhook(urls, single.getMessage(), single.getImage());
				}
				else
				{
					sendCombinedWebhook(urls, group);
				}
			}

			for (QueuedWebhook unnamed : unnamedItems)
			{
				processWebhook(urls, unnamed.getMessage(), unnamed.getImage());
			}
		}

		queue.clear();
		flushTask = null;
	}

	private void sendCombinedWebhook(String urls, List<QueuedWebhook> group)
	{
		// Sort by priority (lower number is higher priority)
		group.sort(Comparator.comparingInt(q -> q.getCategory().getPriority()));

		QueuedWebhook primary = group.get(0);
		StringBuilder combinedMessage = new StringBuilder(primary.getMessage());

		for (int i = 1; i < group.size(); i++)
		{
			QueuedWebhook other = group.get(i);

			// Only append if it's not exactly the same message
			if (!other.getMessage().equals(primary.getMessage()))
			{
				String additionalText = getAdditionalText(other);
				if (additionalText != null)
				{
					combinedMessage.append("\n").append(additionalText);
				}
				else
				{
					combinedMessage.append("\n").append(other.getMessage());
				}
			}
		}

		// Use the first image available in the group
		BufferedImage image = group.stream()
			.map(QueuedWebhook::getImage)
			.filter(img -> img != null)
			.findFirst()
			.orElse(null);

		processWebhook(urls, combinedMessage.toString(), image);
	}

	private String getAdditionalText(QueuedWebhook webhook)
	{
		switch (webhook.getCategory())
		{
			case COLLECTION_LOG:
				return "*This item was also added to their collection log!*";
			case VALUABLE_DROP:
				return "*This was also a valuable drop!*";
			case PET:
				return "*They also received a pet!*";
			case RAID_LOOT:
				return "";
			case BINGO_LOOT:
				return "*This item is on the bingo list!*";
			default:
				return null;
		}
	}

	private void processWebhook(String webhookUrls, String message, BufferedImage image)
	{
		String[] urls = webhookUrls.split("[\n,]");

		byte[] imageBytes = null;
		if (image != null)
		{
			imageBytes = convertImageToBytes(image);
		}

		for (String url : urls)
		{
			final String finalUrl = url.trim();
			if (finalUrl.isEmpty())
			{
				continue;
			}

			sendToUrl(finalUrl, message, imageBytes);
		}
	}

	private byte[] convertImageToBytes(BufferedImage image)
	{
		try (ByteArrayOutputStream out = new ByteArrayOutputStream())
		{
			ImageIO.write(image, "png", out);
			return out.toByteArray();
		}
		catch (IOException e)
		{
			log.error("Error converting image to bytes", e);
			return null;
		}
	}

	private void sendToUrl(String url, String message, byte[] imageBytes)
	{
		HttpUrl httpUrl = HttpUrl.parse(url);
		if (httpUrl == null)
		{
			log.warn("Invalid webhook URL: {}", url);
			return;
		}

		MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
			.setType(MultipartBody.FORM)
			.addFormDataPart("content", message);

		if (imageBytes != null)
		{
			requestBodyBuilder.addFormDataPart("file", "screenshot.png",
				RequestBody.create(MediaType.parse("image/png"), imageBytes));
		}

		Request request = new Request.Builder()
			.url(httpUrl)
			.post(requestBodyBuilder.build())
			.build();

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Error submitting webhook to {}", url, e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				response.close();
			}
		});
	}
}

package com.fauxbingo.services;

import com.fauxbingo.FauxBingoConfig;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

import java.io.IOException;

/**
 * Service for interacting with the WiseOldMan API.
 */
@Slf4j
public class WiseOldManService
{
	private static final String WOM_API_HOST = "api.wiseoldman.net";
	private static final String WOM_API_VERSION = "v2";
	private static final String USER_AGENT = "FauxBingo-RuneLite-Plugin";

	private final Client client;
	private final FauxBingoConfig config;
	private final OkHttpClient okHttpClient;
	private final Gson gson;

	public WiseOldManService(Client client, FauxBingoConfig config, OkHttpClient okHttpClient, Gson gson)
	{
		this.client = client;
		this.config = config;
		this.okHttpClient = okHttpClient;
		this.gson = gson;
	}

	public void updatePlayer(String username)
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		if (username == null || username.isEmpty())
		{
			log.warn("Cannot update WiseOldMan: username is null or empty");
			return;
		}

		long accountHash = client.getAccountHash();

		// Build the API URL: POST /v2/players/{username}
		HttpUrl url = new HttpUrl.Builder()
			.scheme("https")
			.host(WOM_API_HOST)
			.addPathSegment(WOM_API_VERSION)
			.addPathSegment("players")
			.addPathSegment(username)
			.build();

		// Create payload with account hash for verification
		WomPlayerUpdate payload = new WomPlayerUpdate(accountHash);
		String json = gson.toJson(payload);

		RequestBody body = RequestBody.create(
			MediaType.parse("application/json; charset=utf-8"),
			json
		);

		Request request = new Request.Builder()
			.url(url)
			.header("User-Agent", USER_AGENT)
			.post(body)
			.build();

		// Send the request asynchronously
		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.debug("Failed to update WiseOldMan stats for {}: {}", username, e.getMessage());
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					if (response.isSuccessful())
					{
						log.info("Successfully updated WiseOldMan stats for {}", username);
					}
					else
					{
						log.debug("WiseOldMan update returned status {}: {}", 
							response.code(), response.message());
					}
				}
				finally
				{
					response.close();
				}
			}
		});
	}

	private static class WomPlayerUpdate
	{
		private final long accountHash;

		public WomPlayerUpdate(long accountHash)
		{
			this.accountHash = accountHash;
		}
	}
}

package com.fauxbingo.trackers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WiseOldManService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.StatChanged;

import java.util.EnumMap;
import java.util.Map;

/**
 * Tracks player XP and level changes to trigger WiseOldMan updates.
 * Updates are triggered when:
 * - Player logs out and gained 10k+ XP
 * - Player levels up during the session
 */
@Slf4j
public class XpTracker
{
	private static final int XP_THRESHOLD = 10_000;

	private final Client client;
	private final FauxBingoConfig config;
	private final WiseOldManService wiseOldManService;

	private final Map<Skill, Integer> previousSkillLevels = new EnumMap<>(Skill.class);
	private long lastTotalXp = 0;
	private boolean levelUpThisSession = false;
	private boolean fetchXp = false;
	private String playerName;
	private long accountHash;

	public XpTracker(Client client, FauxBingoConfig config, WiseOldManService wiseOldManService)
	{
		this.client = client;
		this.config = config;
		this.wiseOldManService = wiseOldManService;
	}

	public void onStatChanged(StatChanged event)
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		Skill skill = event.getSkill();
		int levelAfter = client.getRealSkillLevel(skill);
		int levelBefore = previousSkillLevels.getOrDefault(skill, -1);

		if (levelBefore != -1 && levelAfter > levelBefore)
		{
			levelUpThisSession = true;
			log.debug("Level up detected in {}: {} -> {}", skill, levelBefore, levelAfter);
		}

		previousSkillLevels.put(skill, levelAfter);
	}

	public void onGameStateChanged(GameStateChanged event)
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		GameState state = event.getGameState();

		switch (state)
		{
			case LOGGED_IN:
				// Check if account changed
				if (accountHash != client.getAccountHash())
				{
					fetchXp = true;
				}
				break;

			case LOGIN_SCREEN:
			case HOPPING:
				Player local = client.getLocalPlayer();
				if (local == null)
				{
					return;
				}

				playerName = local.getName();
				long currentTotalXp = client.getOverallExperience();

				// Only update if XP threshold is reached or player leveled up
				if (Math.abs(currentTotalXp - lastTotalXp) > XP_THRESHOLD || levelUpThisSession)
				{
					log.debug("Triggering WiseOldMan update for {} (XP change: {}, Level up: {})",
						playerName,
						Math.abs(currentTotalXp - lastTotalXp),
						levelUpThisSession);

					wiseOldManService.updatePlayer(playerName);
					lastTotalXp = currentTotalXp;
					levelUpThisSession = false;
				}
				break;
		}
	}

	public void onGameTick()
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		if (fetchXp)
		{
			lastTotalXp = client.getOverallExperience();
			accountHash = client.getAccountHash();
			fetchXp = false;

			Player local = client.getLocalPlayer();
			if (local != null)
			{
				playerName = local.getName();
			}

			// Save current skill levels
			saveCurrentLevels();
		}
	}

	private void saveCurrentLevels()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		previousSkillLevels.clear();
		for (Skill skill : Skill.values())
		{
			previousSkillLevels.put(skill, client.getRealSkillLevel(skill));
		}
	}

	public void reset()
	{
		previousSkillLevels.clear();
		lastTotalXp = 0;
		levelUpThisSession = false;
		fetchXp = false;
		playerName = null;
		accountHash = 0;
	}
}

package com.fauxbingo.util;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

public class LootMatcher
{
	public static boolean matches(String itemName, String configItem)
	{
		if (itemName == null || configItem == null)
		{
			return false;
		}

		Set<String> itemCandidates = buildCandidates(itemName);
		Set<String> configCandidates = buildCandidates(configItem);

		for (String configCandidate : configCandidates)
		{
			if (configCandidate.contains("*"))
			{
				for (String itemCandidate : itemCandidates)
				{
					if (matchesWildcard(itemCandidate, configCandidate))
					{
						return true;
					}
				}
				continue;
			}

			for (String itemCandidate : itemCandidates)
			{
				if (matchesWithPluralRules(itemCandidate, configCandidate))
				{
					return true;
				}
			}
		}

		for (String configCandidate : configCandidates)
		{
			if (configCandidate.contains("*"))
			{
				continue;
			}
			for (String itemCandidate : itemCandidates)
			{
				if (isFuzzyMatch(itemCandidate, configCandidate))
				{
					return true;
				}
			}
		}

		return false;
	}

	public static boolean matchesAny(String itemName, List<String> configItems)
	{
		if (itemName == null || configItems == null)
		{
			return false;
		}

		for (String configItem : configItems)
		{
			if (matches(itemName, configItem))
			{
				return true;
			}
		}
		return false;
	}

	private static Set<String> buildCandidates(String input)
	{
		Set<String> candidates = new HashSet<>();
		String normalized = normalize(input);
		candidates.add(normalized);
		candidates.add(normalizePossessive(normalized));
		return candidates;
	}

	private static String normalize(String input)
	{
		return input == null ? "" : input.toLowerCase().trim();
	}

	private static String normalizePossessive(String input)
	{
		String withoutPluralPossessive = input.replaceAll("s'(?=\\s|$)", "s");
		return withoutPluralPossessive.replaceAll("'s(?=\\s|$)", "");
	}

	private static boolean matchesWithPluralRules(String item, String config)
	{
		if (item.equals(config))
		{
			return true;
		}

		String configPlural = pluralize(config);
		if (!configPlural.isEmpty() && item.equals(configPlural))
		{
			return true;
		}

		String itemPlural = pluralize(item);
		return !itemPlural.isEmpty() && config.equals(itemPlural);
	}

	private static String pluralize(String input)
	{
		if (input.isEmpty())
		{
			return input;
		}

		int lastSpace = input.lastIndexOf(' ');
		String prefix = lastSpace >= 0 ? input.substring(0, lastSpace + 1) : "";
		String word = lastSpace >= 0 ? input.substring(lastSpace + 1) : input;

		String pluralWord = pluralizeWord(word);
		return pluralWord.isEmpty() ? input : prefix + pluralWord;
	}

	private static String pluralizeWord(String word)
	{
		int length = word.length();
		if (length == 0)
		{
			return word;
		}

		if (word.endsWith("y") && length > 1 && !isVowel(word.charAt(length - 2)))
		{
			return word.substring(0, length - 1) + "ies";
		}

		if (word.endsWith("s") || word.endsWith("x") || word.endsWith("z") || word.endsWith("ch") || word.endsWith("sh"))
		{
			return word + "es";
		}

		if (word.endsWith("fe") && length > 2)
		{
			return word.substring(0, length - 2) + "ves";
		}

		if (word.endsWith("f") && length > 1)
		{
			return word.substring(0, length - 1) + "ves";
		}

		return word + "s";
	}

	private static boolean isVowel(char letter)
	{
		return letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u';
	}

	private static boolean matchesWildcard(String input, String wildcard)
	{
		String regex = wildcardToRegex(wildcard);
		return Pattern.matches(regex, input);
	}

	private static String wildcardToRegex(String wildcard)
	{
		String[] parts = wildcard.split("\\*", -1);
		StringBuilder regex = new StringBuilder("^");
		for (int i = 0; i < parts.length; i++)
		{
			regex.append(Pattern.quote(parts[i]));
			if (i < parts.length - 1)
			{
				regex.append(".*");
			}
		}
		regex.append("$");
		return regex.toString();
	}

	private static boolean isFuzzyMatch(String item, String config)
	{
		if (item.length() < 4 || config.length() < 4)
		{
			return false;
		}
		return isEditDistanceAtMostOne(item, config);
	}

	private static boolean isEditDistanceAtMostOne(String left, String right)
	{
		int lengthDiff = Math.abs(left.length() - right.length());
		if (lengthDiff > 1)
		{
			return false;
		}

		int leftIndex = 0;
		int rightIndex = 0;
		int edits = 0;

		while (leftIndex < left.length() && rightIndex < right.length())
		{
			if (left.charAt(leftIndex) == right.charAt(rightIndex))
			{
				leftIndex++;
				rightIndex++;
				continue;
			}

			edits++;
			if (edits > 1)
			{
				return false;
			}

			if (left.length() > right.length())
			{
				leftIndex++;
			}
			else if (right.length() > left.length())
			{
				rightIndex++;
			}
			else
			{
				leftIndex++;
				rightIndex++;
			}
		}

		if (leftIndex < left.length() || rightIndex < right.length())
		{
			edits++;
		}

		return edits <= 1;
	}
}

package com.fauxbingo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FauxBingoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FauxBingoPlugin.class);
		RuneLite.main(args);
	}
}
package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.ScriptID;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ScriptPreFired;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class CollectionLogHandlerTest
{
	@Mock
	private Client client;

	@Mock
	private FauxBingoConfig config;

	@Mock
	private WebhookService webhookService;

	@Mock
	private LogService logService;

	@Mock
	private ScreenshotService screenshotService;

	@Mock
	private ScheduledExecutorService executor;

	@Mock
	private Player player;

	private CollectionLogHandler collectionLogHandler;

	@Before
	public void before()
	{
		collectionLogHandler = new CollectionLogHandler(client, config, webhookService, logService, screenshotService, executor);
		when(client.getLocalPlayer()).thenReturn(player);
		when(player.getName()).thenReturn("TestPlayer");
		when(config.webhookUrl()).thenReturn("http://webhook");
		when(config.includeCollectionLog()).thenReturn(true);
		when(config.sendScreenshot()).thenReturn(false);
	}

	@Test
	public void testChatMessageCollectionLog()
	{
		when(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION)).thenReturn(1);
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("New item added to your collection log: Abyssal whip");

		collectionLogHandler.createChatHandler().handle(event);

		verify(webhookService).sendWebhook(anyString(), contains("Abyssal whip"), isNull(), eq("Abyssal whip"), eq(WebhookService.WebhookCategory.COLLECTION_LOG));
		verify(logService).log(eq("COLLECTION_LOG"), any());
	}

	@Test
	public void testChatMessageCollectionLogDisabled()
	{
		when(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION)).thenReturn(0);
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("New item added to your collection log: Abyssal whip");

		collectionLogHandler.createChatHandler().handle(event);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), anyString(), any());
	}

	@Test
	public void testScriptCollectionLog()
	{
		// NOTIFICATION_START
		ScriptPreFired startEvent = new ScriptPreFired(ScriptID.NOTIFICATION_START);
		collectionLogHandler.createScriptHandler().handle(startEvent);

		// NOTIFICATION_DELAY
		when(client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT)).thenReturn("Collection log");
		when(client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT)).thenReturn("New item: Abyssal whip");
		ScriptPreFired delayEvent = new ScriptPreFired(ScriptID.NOTIFICATION_DELAY);
		collectionLogHandler.createScriptHandler().handle(delayEvent);

		verify(webhookService).sendWebhook(anyString(), contains("Abyssal whip"), isNull(), eq("Abyssal whip"), eq(WebhookService.WebhookCategory.COLLECTION_LOG));
	}

	@Test
	public void testScriptCollectionLogWrongTopText()
	{
		// NOTIFICATION_START
		ScriptPreFired startEvent = new ScriptPreFired(ScriptID.NOTIFICATION_START);
		collectionLogHandler.createScriptHandler().handle(startEvent);

		// NOTIFICATION_DELAY
		when(client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT)).thenReturn("Quest complete");
		when(client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT)).thenReturn("New item: Abyssal whip");
		ScriptPreFired delayEvent = new ScriptPreFired(ScriptID.NOTIFICATION_DELAY);
		collectionLogHandler.createScriptHandler().handle(delayEvent);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), anyString(), any());
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import java.util.Arrays;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class LootEventHandlerTest
{
	@Mock
	private Client client;

	@Mock
	private FauxBingoConfig config;

	@Mock
	private ItemManager itemManager;

	@Mock
	private WebhookService webhookService;

	@Mock
	private LogService logService;

	@Mock
	private ScreenshotService screenshotService;

	@Mock
	private ScheduledExecutorService executor;

	@Mock
	private NPC npc;

	@Mock
	private Player player;

	@Mock
	private ItemComposition itemComposition;

	private LootEventHandler lootEventHandler;

	@Before
	public void before()
	{
		lootEventHandler = new LootEventHandler(client, config, itemManager, webhookService, logService, screenshotService, executor);
		when(config.webhookUrl()).thenReturn("http://webhook");
		when(config.minLootValue()).thenReturn(1000000);
		when(config.sendScreenshot()).thenReturn(false);

		when(itemManager.getItemComposition(anyInt())).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Dragon bones");
		when(itemManager.getItemPrice(anyInt())).thenReturn(2500);
	}

	@Test
	public void testNpcLoot()
	{
		when(npc.getName()).thenReturn("Vorkath");
		ItemStack item = new ItemStack(536, 400, null); // 400 * 2500 = 1,000,000
		NpcLootReceived event = new NpcLootReceived(npc, Arrays.asList(item));

		lootEventHandler.createNpcLootHandler().handle(event);

		verify(webhookService).sendWebhook(anyString(), contains("Vorkath"), isNull(), eq("Dragon bones"), eq(WebhookService.WebhookCategory.LOOT));
		verify(logService).log(eq("LOOT"), any());
	}

	@Test
	public void testPlayerLoot()
	{
		when(player.getName()).thenReturn("PKedPlayer");
		ItemStack item = new ItemStack(536, 400, null);
		PlayerLootReceived event = new PlayerLootReceived(player, Arrays.asList(item));

		lootEventHandler.createPlayerLootHandler().handle(event);

		verify(webhookService).sendWebhook(anyString(), contains("PKedPlayer"), isNull(), eq("Dragon bones"), eq(WebhookService.WebhookCategory.LOOT));
		verify(logService).log(eq("LOOT"), any());
	}

	@Test
	public void testMultipleItems()
	{
		when(npc.getName()).thenReturn("Vorkath");
		ItemStack item1 = new ItemStack(536, 200, null); // 500,000
		ItemStack item2 = new ItemStack(537, 200, null); // 500,000
		NpcLootReceived event = new NpcLootReceived(npc, Arrays.asList(item1, item2));

		lootEventHandler.createNpcLootHandler().handle(event);

		verify(webhookService).sendWebhook(anyString(), contains("Vorkath"), isNull(), isNull(), eq(WebhookService.WebhookCategory.LOOT));
		verify(logService).log(eq("LOOT"), any());
	}

	@Test
	public void testBelowThreshold()
	{
		when(npc.getName()).thenReturn("Vorkath");
		ItemStack item = new ItemStack(536, 1, null);
		NpcLootReceived event = new NpcLootReceived(npc, Arrays.asList(item));

		lootEventHandler.createNpcLootHandler().handle(event);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), anyString(), any());
		verify(logService).log(eq("LOOT"), any()); // Should still log to external API
	}

	@Test
	public void testOtherBingoItem()
	{
		when(config.otherBingoItems()).thenReturn("Dragon bones");
		when(npc.getName()).thenReturn("Vorkath");
		ItemStack item = new ItemStack(536, 1, null); // Only 1 bone, way below 1M threshold
		NpcLootReceived event = new NpcLootReceived(npc, Arrays.asList(item));

		lootEventHandler.createNpcLootHandler().handle(event);

		// Should send bingo notification even though it's below minLootValue
		verify(webhookService).sendWebhook(anyString(), contains("1 x Dragon bones"), any(), eq("Dragon bones"), eq(WebhookService.WebhookCategory.BINGO_LOOT));
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.input.KeyManager;
import net.runelite.client.util.HotkeyListener;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ManualScreenshotHandlerTest
{
	@Mock
	private Client client;

	@Mock
	private FauxBingoConfig config;

	@Mock
	private WebhookService webhookService;

	@Mock
	private ScreenshotService screenshotService;

	@Mock
	private ScheduledExecutorService executor;

	@Mock
	private KeyManager keyManager;

	@Mock
	private Player player;

	private ManualScreenshotHandler manualScreenshotHandler;

	@Before
	public void before()
	{
		manualScreenshotHandler = new ManualScreenshotHandler(client, config, webhookService, screenshotService, executor, keyManager);
		lenient().when(client.getLocalPlayer()).thenReturn(player);
		lenient().when(player.getName()).thenReturn("TestPlayer");
		lenient().when(config.webhookUrl()).thenReturn("http://webhook");
	}

	@Test
	public void testRegister()
	{
		manualScreenshotHandler.register();
		verify(keyManager).registerKeyListener(any());
	}

	@Test
	public void testUnregister()
	{
		manualScreenshotHandler.unregister();
		verify(keyManager).unregisterKeyListener(any());
	}

	@Test
	public void testHotkeyTriggersScreenshot()
	{
		ArgumentCaptor<HotkeyListener> captor = ArgumentCaptor.forClass(HotkeyListener.class);
		manualScreenshotHandler.register();
		verify(keyManager).registerKeyListener(captor.capture());

		HotkeyListener listener = captor.getValue();
		listener.hotkeyPressed();

		verify(screenshotService).requestScreenshot(any());
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class PetChatHandlerTest
{
	@Mock
	private Client client;

	@Mock
	private FauxBingoConfig config;

	@Mock
	private WebhookService webhookService;

	@Mock
	private LogService logService;

	@Mock
	private ScreenshotService screenshotService;

	@Mock
	private ScheduledExecutorService executor;

	@Mock
	private Player player;

	private PetChatHandler petChatHandler;

	@Before
	public void before()
	{
		petChatHandler = new PetChatHandler(client, config, webhookService, logService, screenshotService, executor);
		when(client.getLocalPlayer()).thenReturn(player);
		when(player.getName()).thenReturn("TestPlayer");
		when(config.webhookUrl()).thenReturn("http://webhook");
		when(config.includePets()).thenReturn(true);
		when(config.sendScreenshot()).thenReturn(false);
	}

	@Test
	public void testPetFollowMessage()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("You have a funny feeling like you're being followed.");

		petChatHandler.handle(event);

		verify(webhookService).sendWebhook(anyString(), contains("TestPlayer"), isNull(), eq("Pet"), eq(WebhookService.WebhookCategory.PET));
		verify(logService).log(eq("PET"), any());
	}

	@Test
	public void testPetInventoryMessage()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("You feel something weird sneaking into your backpack.");

		petChatHandler.handle(event);

		verify(webhookService).sendWebhook(anyString(), anyString(), any(), any(), eq(WebhookService.WebhookCategory.PET));
	}

	@Test
	public void testPetDuplicateMessage()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("You have a funny feeling like you would have been followed.");

		petChatHandler.handle(event);

		verify(webhookService).sendWebhook(anyString(), anyString(), any(), any(), eq(WebhookService.WebhookCategory.PET));
	}

	@Test
	public void testNotPetMessage()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("You catch a shrimp.");

		petChatHandler.handle(event);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), any(), any());
	}

	@Test
	public void testDisabled()
	{
		when(config.includePets()).thenReturn(false);
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("You have a funny feeling like you're being followed.");

		petChatHandler.handle(event);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), any(), any());
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class RaidLootHandlerTest
{
	@Mock
	private Client client;

	@Mock
	private FauxBingoConfig config;

	@Mock
	private WebhookService webhookService;

	@Mock
	private LogService logService;

	@Mock
	private ScreenshotService screenshotService;

	@Mock
	private ScheduledExecutorService executor;

	@Mock
	private ItemManager itemManager;

	@Mock
	private Player player;

	@Mock
	private Widget rewardWidget;

	@Mock
	private Widget itemWidget;

	@Mock
	private ItemComposition itemComposition;

	@Mock
	private ItemContainer itemContainer;

	private RaidLootHandler raidLootHandler;

	@Before
	public void before()
	{
		raidLootHandler = new RaidLootHandler(client, config, webhookService, logService, screenshotService, executor, itemManager);
		when(client.getLocalPlayer()).thenReturn(player);
		when(player.getName()).thenReturn("TestPlayer");
		when(config.webhookUrl()).thenReturn("http://webhook");
		when(config.includeRaidLoot()).thenReturn(true);
		when(config.sendScreenshot()).thenReturn(false);
	}

	@Test
	public void testCoxLootSequence()
	{
		// 1. KC Message
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Chambers of Xeric count is: 100.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// 2. Unique Message
		ChatMessage uniqueEvent = new ChatMessage();
		uniqueEvent.setType(ChatMessageType.FRIENDSCHATNOTIFICATION);
		uniqueEvent.setMessage("TestPlayer - Twisted bow");
		raidLootHandler.createChatHandler().handle(uniqueEvent);

		// 3. Container Changed
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(20997, 1)});
		when(itemManager.getItemComposition(20997)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Twisted bow");

		ItemContainerChanged containerEvent = new ItemContainerChanged(581, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		verify(webhookService).sendWebhook(
			anyString(), 
			argThat(s -> s.contains("Twisted bow") && s.contains("Kill Count: **100**") && s.contains("1 x Twisted bow")), 
			isNull(), 
			eq("Twisted bow"), 
			eq(WebhookService.WebhookCategory.RAID_LOOT)
		);
		verify(logService, atLeastOnce()).log(eq("RAID_LOOT"), any());
	}

	@Test
	public void testTobLootSequence()
	{
		// 1. KC Message
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Theatre of Blood count is: 50.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// 2. Unique Message
		ChatMessage uniqueEvent = new ChatMessage();
		uniqueEvent.setType(ChatMessageType.GAMEMESSAGE);
		uniqueEvent.setMessage("TestPlayer found something special: Scythe of vitur (Uncharged)");
		raidLootHandler.createChatHandler().handle(uniqueEvent);

		// 3. Container Changed
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(22477, 1)});
		when(itemManager.getItemComposition(22477)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Scythe of vitur (Uncharged)");

		ItemContainerChanged containerEvent = new ItemContainerChanged(612, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		verify(webhookService).sendWebhook(anyString(), contains("Scythe of vitur"), isNull(), eq("Scythe of vitur (Uncharged)"), eq(WebhookService.WebhookCategory.RAID_LOOT));
	}

	@Test
	public void testNoUniqueAndNotValuable()
	{
		// 1. KC Message
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Chambers of Xeric count is: 100.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// 2. Container Changed with cheap items
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(1234, 100)});
		when(itemManager.getItemComposition(1234)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Pure essence");
		when(itemManager.getItemPrice(1234)).thenReturn(2);
		when(config.minLootValue()).thenReturn(1000000);

		ItemContainerChanged containerEvent = new ItemContainerChanged(581, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), anyString(), any());
		// Should still log it
		verify(logService).log(eq("RAID_LOOT"), any());
	}

	@Test
	public void testCoxBingoItem()
	{
		// Config
		when(config.coxBingoItems()).thenReturn("Dynamite, Prayer scroll");
		
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(1234, 100)});
		when(itemManager.getItemComposition(1234)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Dynamite");

		// 1. KC Message
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Chambers of Xeric count is: 100.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// 2. Container Changed
		ItemContainerChanged containerEvent = new ItemContainerChanged(581, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		verify(webhookService).sendWebhook(
			anyString(), 
			contains("100 x Dynamite"), 
			isNull(), 
			eq("Dynamite"), 
			eq(WebhookService.WebhookCategory.BINGO_LOOT)
		);
		verify(logService).log(eq("BINGO_LOOT"), any());
	}

	@Test
	public void testTobBingoItem()
	{
		// Config
		when(config.tobBingoItems()).thenReturn("Vial of blood");
		
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(22444, 50)});
		when(itemManager.getItemComposition(22444)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Vial of blood");

		// 1. KC Message
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Theatre of Blood count is: 50.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// 2. Container Changed
		ItemContainerChanged containerEvent = new ItemContainerChanged(612, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		verify(webhookService).sendWebhook(
			anyString(), 
			contains("50 x Vial of blood"), 
			isNull(), 
			eq("Vial of blood"), 
			eq(WebhookService.WebhookCategory.BINGO_LOOT)
		);
	}

	@Test
	public void testToaBingoItem()
	{
		// Config
		when(config.toaBingoItems()).thenReturn("Lily of the sands");
		
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(27272, 25)});
		when(itemManager.getItemComposition(27272)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Lily of the sands");

		// 1. KC Message
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your Tombs of Amascut: Normal Mode completion count is 10.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// 2. Container Changed
		ItemContainerChanged containerEvent = new ItemContainerChanged(801, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		verify(webhookService).sendWebhook(
			anyString(), 
			argThat(s -> s.contains("25 x Lily of the sands") && s.contains("Tombs of Amascut") && s.contains("Kill Count: **10**")), 
			isNull(), 
			eq("Lily of the sands"), 
			eq(WebhookService.WebhookCategory.BINGO_LOOT)
		);
	}

	@Test
	public void testConsolidatedNotification()
	{
		// Test multiple rare drops and bingo items in one raid
		when(config.coxBingoItems()).thenReturn("Soul rune");
		
		// 1. KC
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Chambers of Xeric count is: 100.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// 2. Unique 1
		ChatMessage u1 = new ChatMessage();
		u1.setType(ChatMessageType.FRIENDSCHATNOTIFICATION);
		u1.setMessage("TestPlayer - Twisted bow");
		raidLootHandler.createChatHandler().handle(u1);

		// 3. Unique 2 (Dust)
		ChatMessage u2 = new ChatMessage();
		u2.setType(ChatMessageType.GAMEMESSAGE);
		u2.setMessage("Dust recipients: TestPlayer");
		raidLootHandler.createChatHandler().handle(u2);

		// 4. Container
		when(itemContainer.getItems()).thenReturn(new Item[]{
			new Item(20997, 1), // T-bow
			new Item(1234, 100), // Soul runes
			new Item(5678, 1)    // Dust (assuming it's in container)
		});
		
		ItemComposition tbowComp = mock(ItemComposition.class);
		when(tbowComp.getName()).thenReturn("Twisted bow");
		when(itemManager.getItemComposition(20997)).thenReturn(tbowComp);

		ItemComposition soulComp = mock(ItemComposition.class);
		when(soulComp.getName()).thenReturn("Soul runes");
		when(itemManager.getItemComposition(1234)).thenReturn(soulComp);

		ItemComposition dustComp = mock(ItemComposition.class);
		when(dustComp.getName()).thenReturn("Metamorphic dust");
		when(itemManager.getItemComposition(5678)).thenReturn(dustComp);

		ItemContainerChanged containerEvent = new ItemContainerChanged(581, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		// Should send ONE webhook with everything
		verify(webhookService, times(1)).sendWebhook(anyString(), argThat(s -> 
			s.contains("Twisted bow") && s.contains("Metamorphic dust") && s.contains("100 x Soul runes")
		), any(), anyString(), eq(WebhookService.WebhookCategory.RAID_LOOT));
	}

	@Test
	public void testOtherBingoItem()
	{
		// Config has "Dragon bones" in Other Items
		when(config.otherBingoItems()).thenReturn("Dragon bones");
		
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(536, 50)});
		when(itemManager.getItemComposition(536)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Dragon bones");

		// Set raid context
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Chambers of Xeric count is: 100.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		ItemContainerChanged containerEvent = new ItemContainerChanged(581, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(containerEvent);

		verify(webhookService).sendWebhook(anyString(), contains("50 x Dragon bones"), any(), eq("Dragon bones"), eq(WebhookService.WebhookCategory.BINGO_LOOT));
	}

	@Test
	public void testValuableLootNotification()
	{
		when(config.minLootValue()).thenReturn(1000000);

		when(itemContainer.getItems()).thenReturn(new Item[]{
			new Item(1, 100), // Dragon arrow
			new Item(2, 1)    // Dexterous prayer scroll
		});

		ItemComposition arrowComp = mock(ItemComposition.class);
		when(arrowComp.getName()).thenReturn("Dragon arrow");
		when(itemManager.getItemComposition(1)).thenReturn(arrowComp);
		when(itemManager.getItemPrice(1)).thenReturn(2000);

		ItemComposition scrollComp = mock(ItemComposition.class);
		when(scrollComp.getName()).thenReturn("Dexterous prayer scroll");
		when(itemManager.getItemComposition(2)).thenReturn(scrollComp);
		when(itemManager.getItemPrice(2)).thenReturn(1200000);

		// KC Message to set context
		ChatMessage kcEvent = new ChatMessage();
		kcEvent.setType(ChatMessageType.GAMEMESSAGE);
		kcEvent.setMessage("Your completed Chambers of Xeric count is: 100.");
		raidLootHandler.createChatHandler().handle(kcEvent);

		// Container Changed event
		ItemContainerChanged event = new ItemContainerChanged(581, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(event);

		// Should send a webhook because total value is above threshold
		verify(webhookService).sendWebhook(
			anyString(),
			contains("Total value: 1,400,000 gp"),
			isNull(),
			any(),
			any()
		);
	}

	@Test
	public void testToaTeammateUniqueIgnored()
	{
		// ToA unique drop message for teammate
		ChatMessage uniqueEvent = new ChatMessage();
		uniqueEvent.setType(ChatMessageType.GAMEMESSAGE);
		uniqueEvent.setMessage("Loot recipient: Teammate - Tumeken's shadow (uncharged)");
		raidLootHandler.createChatHandler().handle(uniqueEvent);

		// Container change for ToA
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(1, 1)}); // Just some loot
		when(itemManager.getItemComposition(1)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Coins");
		when(itemManager.getItemPrice(1)).thenReturn(1);
		when(config.minLootValue()).thenReturn(1000000);

		ItemContainerChanged event = new ItemContainerChanged(801, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(event);

		verify(webhookService, never()).sendWebhook(anyString(), contains("received a rare drop"), any(), anyString(), any());
	}

	@Test
	public void testMissingKcMessageStillProcesses()
	{
		// NO KC message received

		// Container Changed event
		when(itemContainer.getItems()).thenReturn(new Item[]{new Item(20997, 1)});
		when(itemManager.getItemComposition(20997)).thenReturn(itemComposition);
		when(itemComposition.getName()).thenReturn("Twisted bow");
		
		// Set it as a rare drop via chat anyway (unlikely if KC missed but possible)
		ChatMessage uniqueEvent = new ChatMessage();
		uniqueEvent.setType(ChatMessageType.FRIENDSCHATNOTIFICATION);
		uniqueEvent.setMessage("TestPlayer - Twisted bow");
		raidLootHandler.createChatHandler().handle(uniqueEvent);

		ItemContainerChanged event = new ItemContainerChanged(581, itemContainer);
		raidLootHandler.createItemContainerHandler().handle(event);

		// Should still process and use default raid name
		verify(webhookService).sendWebhook(
			anyString(), 
			contains("Chambers of Xeric"), 
			any(), 
			eq("Twisted bow"), 
			any()
		);
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.LogService;
import com.fauxbingo.services.ScreenshotService;
import com.fauxbingo.services.WebhookService;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class ValuableDropHandlerTest
{
	@Mock
	private Client client;

	@Mock
	private FauxBingoConfig config;

	@Mock
	private WebhookService webhookService;

	@Mock
	private LogService logService;

	@Mock
	private ScreenshotService screenshotService;

	@Mock
	private ScheduledExecutorService executor;

	@Mock
	private Player player;

	private ValuableDropHandler valuableDropHandler;

	@Before
	public void before()
	{
		valuableDropHandler = new ValuableDropHandler(client, config, webhookService, logService, screenshotService, executor);
		when(client.getLocalPlayer()).thenReturn(player);
		when(player.getName()).thenReturn("TestPlayer");
		when(config.webhookUrl()).thenReturn("http://webhook");
		when(config.includeValuableDrops()).thenReturn(true);
		when(config.minLootValue()).thenReturn(1000000);
		when(config.sendScreenshot()).thenReturn(false);
	}

	@Test
	public void testValuableDrop()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("Valuable drop: Dragon metal sheet (1,155,320 coins)");

		valuableDropHandler.handle(event);

		verify(webhookService).sendWebhook(anyString(), contains("Dragon metal sheet"), isNull(), eq("Dragon metal sheet"), eq(WebhookService.WebhookCategory.VALUABLE_DROP));
		verify(logService).log(eq("VALUABLE_DROP"), any());
	}

	@Test
	public void testValuableDropWithTags()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("<col=ef1020>Valuable drop: Dragon metal sheet (1,155,320 coins)</col>");

		valuableDropHandler.handle(event);

		verify(webhookService).sendWebhook(anyString(), contains("Dragon metal sheet"), isNull(), eq("Dragon metal sheet"), eq(WebhookService.WebhookCategory.VALUABLE_DROP));
	}

	@Test
	public void testBelowThreshold()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("Valuable drop: Dragon bones (2,500 coins)");

		valuableDropHandler.handle(event);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), anyString(), any());
		verify(logService).log(eq("VALUABLE_DROP"), any());
	}

	@Test
	public void testDisabled()
	{
		when(config.includeValuableDrops()).thenReturn(false);
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("Valuable drop: Dragon metal sheet (1,155,320 coins)");

		valuableDropHandler.handle(event);

		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), anyString(), any());
	}

	@Test
	public void testScreenshotRequested()
	{
		when(config.sendScreenshot()).thenReturn(true);
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("Valuable drop: Dragon metal sheet (1,155,320 coins)");

		valuableDropHandler.handle(event);

		verify(screenshotService).requestScreenshot(any());
		verify(webhookService, never()).sendWebhook(anyString(), anyString(), any(), anyString(), any());
	}

	@Test
	public void testValuableDropWithQuantity()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("Valuable drop: 30 x Chaos rune (1,680 coins)");

		when(config.minLootValue()).thenReturn(1000);

		valuableDropHandler.handle(event);

		// The bundling key (cleaned) should be "Chaos rune"
		verify(webhookService).sendWebhook(anyString(), contains("30 x Chaos rune"), isNull(), eq("Chaos rune"), eq(WebhookService.WebhookCategory.VALUABLE_DROP));
	}

	@Test
	public void testValuableDropWithLargeQuantity()
	{
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("Valuable drop: 1,000 x Chaos rune (56,000 coins)");

		when(config.minLootValue()).thenReturn(1000);

		valuableDropHandler.handle(event);

		// The bundling key (cleaned) should be "Chaos rune"
		verify(webhookService).sendWebhook(anyString(), contains("1,000 x Chaos rune"), isNull(), eq("Chaos rune"), eq(WebhookService.WebhookCategory.VALUABLE_DROP));
	}

	@Test
	public void testOtherBingoItem()
	{
		when(config.otherBingoItems()).thenReturn("Soul rune");
		ChatMessage event = new ChatMessage();
		event.setType(ChatMessageType.GAMEMESSAGE);
		event.setMessage("Valuable drop: 100 x Soul rune (15,000 coins)");

		// minLootValue is 1M, so 15k is below
		valuableDropHandler.handle(event);

		// Should NOT send valuable drop notification
		verify(webhookService, never()).sendWebhook(anyString(), contains("valuable drop"), any(), anyString(), eq(WebhookService.WebhookCategory.VALUABLE_DROP));
		
		// Should send bingo notification
		verify(webhookService).sendWebhook(anyString(), contains("100 x Soul rune"), any(), eq("Soul rune"), eq(WebhookService.WebhookCategory.BINGO_LOOT));
	}
}

package com.fauxbingo.services;

import com.fauxbingo.FauxBingoConfig;
import com.google.gson.Gson;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import okhttp3.OkHttpClient;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class LogServiceTest
{
    @Mock
    private Client client;

    @Mock
    private FauxBingoConfig config;

    @Mock
    private OkHttpClient okHttpClient;

    @Mock
    private ScheduledExecutorService executor;

    @Mock
    private Player player;

    private LogService logService;
    private Gson gson = new Gson();

    @Before
    public void before()
    {
        when(config.enableLoggingApi()).thenReturn(true);
        when(config.loggingApiUrl()).thenReturn("http://api");
        when(client.getLocalPlayer()).thenReturn(player);
        when(player.getName()).thenReturn("TestPlayer");
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        
        logService = new LogService(client, config, okHttpClient, gson, executor);
    }

    @Test
    public void testLogWhenLoggedIn()
    {
        logService.log("TEST", "data");
        // Should use client to get player name
        verify(client, atLeastOnce()).getLocalPlayer();
    }

    @Test
    public void testLogWhenNotLoggedIn()
    {
        when(client.getGameState()).thenReturn(GameState.LOGIN_SCREEN);
        logService.log("TEST", "data");
        // Should return early and not even check for local player
        verify(client, never()).getLocalPlayer();
    }
}

package com.fauxbingo.services;

import java.awt.image.BufferedImage;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import okhttp3.Call;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class WebhookServiceTest
{
    @Mock
    private Client client;

    @Mock
    private OkHttpClient okHttpClient;

    @Mock
    private ScheduledExecutorService executor;

    @Mock
    private Call call;

    @Mock
    private ScheduledFuture<?> scheduledFuture;

    private WebhookService webhookService;

    @Before
    public void before()
    {
        webhookService = new WebhookService(client, okHttpClient, executor);
        when(okHttpClient.newCall(any())).thenReturn(call);
        doReturn(scheduledFuture).when(executor).schedule(any(Runnable.class), anyLong(), any());
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
    }

    @Test
    public void testGameStateCheck()
    {
        when(client.getGameState()).thenReturn(GameState.LOGIN_SCREEN);
        webhookService.sendWebhook("http://webhook", "Message", null, "Item", WebhookService.WebhookCategory.VALUABLE_DROP);
        
        // Should not be scheduled
        verify(executor, never()).schedule(any(Runnable.class), anyLong(), any());
    }

    @Test
    public void testManualBypass()
    {
        // No stubbing for client.getGameState() needed as it should be bypassed
        webhookService.sendWebhook("http://webhook", "Manual", null);
        
        // Should be scheduled even if not logged in
        verify(executor).schedule(any(Runnable.class), eq(3L), eq(TimeUnit.SECONDS));
        verify(client, never()).getGameState();
    }

    @Test
    public void testBundling()
    {
        String urls = "http://webhook";
        BufferedImage img1 = new BufferedImage(10, 10, BufferedImage.TYPE_INT_RGB);
        
        webhookService.sendWebhook(urls, "Valuable drop: Fang", img1, "Fang", WebhookService.WebhookCategory.VALUABLE_DROP);
        webhookService.sendWebhook(urls, "Collection log: Fang", null, "Fang", WebhookService.WebhookCategory.COLLECTION_LOG);

        // Verify scheduled task
        ArgumentCaptor<Runnable> runnableCaptor = ArgumentCaptor.forClass(Runnable.class);
        verify(executor).schedule(runnableCaptor.capture(), eq(3L), eq(TimeUnit.SECONDS));

        // Run the task
        runnableCaptor.getValue().run();

        // Verify only one call was made
        verify(okHttpClient, times(1)).newCall(any());
        
        // Capture the request to check combined message
        ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
        verify(okHttpClient).newCall(requestCaptor.capture());
        
        // We can't easily check the body because it's a MultipartBody, but we've verified bundling happened
    }

    @Test
    public void testDifferentItems()
    {
        String urls = "http://webhook";
        
        webhookService.sendWebhook(urls, "Item 1", null, "Item 1", WebhookService.WebhookCategory.LOOT);
        webhookService.sendWebhook(urls, "Item 2", null, "Item 2", WebhookService.WebhookCategory.LOOT);

        ArgumentCaptor<Runnable> runnableCaptor = ArgumentCaptor.forClass(Runnable.class);
        verify(executor).schedule(runnableCaptor.capture(), eq(3L), eq(TimeUnit.SECONDS));
        runnableCaptor.getValue().run();

        // Verify two calls were made
        verify(okHttpClient, times(2)).newCall(any());
    }

    @Test
    public void testBingoBundling()
    {
        String urls = "http://webhook";
        
        webhookService.sendWebhook(urls, "Loot: 100 x Soul rune", null, "Soul rune", WebhookService.WebhookCategory.LOOT);
        webhookService.sendWebhook(urls, "Special item: 100 x Soul rune", null, "Soul rune", WebhookService.WebhookCategory.BINGO_LOOT);

        ArgumentCaptor<Runnable> runnableCaptor = ArgumentCaptor.forClass(Runnable.class);
        verify(executor).schedule(runnableCaptor.capture(), eq(3L), eq(TimeUnit.SECONDS));
        runnableCaptor.getValue().run();

        // BINGO_LOOT (3) has higher priority than LOOT (6), so BINGO_LOOT should be primary
        verify(okHttpClient).newCall(argThat(request -> {
            // This is hard to check accurately without deep-inspecting MultipartBody, 
            // but we can at least verify it happened.
            return request.url().toString().equals("http://webhook/");
        }));
    }

    @Test
    public void testWebhookUrlSplitting()
    {
        // Test various separators and whitespace: comma, newline, and mixed
        String urls = "http://url1, http://url2\nhttp://url3, \n http://url4";
        webhookService.sendWebhook(urls, "Message", null);

        ArgumentCaptor<Runnable> runnableCaptor = ArgumentCaptor.forClass(Runnable.class);
        verify(executor).schedule(runnableCaptor.capture(), eq(3L), eq(TimeUnit.SECONDS));
        runnableCaptor.getValue().run();

        // Should be 4 separate calls
        verify(okHttpClient, times(4)).newCall(any());

        ArgumentCaptor<Request> requestCaptor = ArgumentCaptor.forClass(Request.class);
        verify(okHttpClient, times(4)).newCall(requestCaptor.capture());

        List<Request> requests = requestCaptor.getAllValues();
        assertEquals("http://url1/", requests.get(0).url().toString());
        assertEquals("http://url2/", requests.get(1).url().toString());
        assertEquals("http://url3/", requests.get(2).url().toString());
        assertEquals("http://url4/", requests.get(3).url().toString());
    }
}

package com.fauxbingo.util;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.Arrays;
import java.util.List;

public class LootMatcherTest
{
	@Test
	public void testExactMatch()
	{
		assertTrue(LootMatcher.matches("Soul rune", "Soul rune"));
		assertTrue(LootMatcher.matches("soul rune", "SOUL RUNE"));
		assertTrue(LootMatcher.matches("  Soul rune  ", "soul rune"));
	}

	@Test
	public void testPluralWithS()
	{
		// Config is singular, item is plural
		assertTrue(LootMatcher.matches("Soul runes", "Soul rune"));
		// Config is plural, item is singular
		assertTrue(LootMatcher.matches("Soul rune", "Soul runes"));
	}

	@Test
	public void testPluralWithApostropheS()
	{
		// Config is singular, item is plural
		assertTrue(LootMatcher.matches("Dragon's bones", "Dragon's bone"));
		// Config is plural, item is singular
		assertTrue(LootMatcher.matches("Dragon's bone", "Dragon's bones"));
	}

	@Test
	public void testPluralWithIES()
	{
		// Config is singular, item is plural
		assertTrue(LootMatcher.matches("Dragon berries", "Dragon berry"));
		// Config is plural, item is singular
		assertTrue(LootMatcher.matches("Dragon berry", "Dragon berries"));
	}

	@Test
	public void testPluralWithES()
	{
		assertTrue(LootMatcher.matches("Bosses", "Boss"));
		assertTrue(LootMatcher.matches("Box", "Boxes"));
	}

	@Test
	public void testPluralWithVES()
	{
		assertTrue(LootMatcher.matches("Knife", "Knives"));
		assertTrue(LootMatcher.matches("Leaf", "Leaves"));
	}

	@Test
	public void testPossessivePluralEndingInS()
	{
		assertTrue(LootMatcher.matches("Scurrius' spine", "Scurrius spine"));
		assertTrue(LootMatcher.matches("Scurrius spine", "Scurrius' spine"));
	}

	@Test
	public void testFuzzyMatch()
	{
		assertTrue(LootMatcher.matches("Blood runes", "Blod runes"));
	}

	@Test
	public void testWildcardMatch()
	{
		assertTrue(LootMatcher.matches("Blood rune", "*rune"));
		assertTrue(LootMatcher.matches("Blood rune", "blood*"));
		assertTrue(LootMatcher.matches("Blood rune", "*oo*"));
		assertFalse(LootMatcher.matches("Dragon bones", "*rune"));
	}

	@Test
	public void testNoMatch()
	{
		assertFalse(LootMatcher.matches("Soul rune", "Blood rune"));
		assertFalse(LootMatcher.matches("Dragon bone", "Dragon stone"));
	}

	@Test
	public void testMatchesAny()
	{
		List<String> configItems = Arrays.asList("Soul rune", "Dragon bone", "Twisted bowz");
		assertTrue(LootMatcher.matchesAny("Soul runes", configItems));
		assertTrue(LootMatcher.matchesAny("Dragon bone", configItems));
		assertTrue(LootMatcher.matchesAny("Twisted bow", configItems));
		assertFalse(LootMatcher.matchesAny("Blood rune", configItems));
	}
}

