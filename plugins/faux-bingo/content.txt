package com.fauxbingo;

import com.fauxbingo.handlers.EventHandler;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;

/**
 * Central event processing engine that manages and delegates events to registered handlers.
 */
@Slf4j
public class EventProcessor
{
	private final Map<Class<?>, List<EventHandler<?>>> handlers = new HashMap<>();

	public <T> void registerHandler(EventHandler<T> handler)
	{
		Class<T> eventType = handler.getEventType();
		handlers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(handler);
		log.debug("Registered handler {} for event type {}", handler.getClass().getSimpleName(), eventType.getSimpleName());
	}

	public <T> void unregisterHandler(EventHandler<T> handler)
	{
		Class<T> eventType = handler.getEventType();
		List<EventHandler<?>> handlerList = handlers.get(eventType);
		if (handlerList != null)
		{
			handlerList.remove(handler);
			log.debug("Unregistered handler {} for event type {}", handler.getClass().getSimpleName(), eventType.getSimpleName());
		}
	}

	@SuppressWarnings("unchecked")
	public <T> void processEvent(T event)
	{
		List<EventHandler<?>> handlerList = handlers.get(event.getClass());
		if (handlerList != null && !handlerList.isEmpty())
		{
			for (EventHandler<?> handler : handlerList)
			{
				try
				{
					((EventHandler<T>) handler).handle(event);
				}
				catch (Exception e)
				{
					log.error("Error in handler {} processing event {}", 
						handler.getClass().getSimpleName(), 
						event.getClass().getSimpleName(), e);
				}
			}
		}
	}

	public void clearHandlers()
	{
		handlers.clear();
		log.debug("Cleared all event handlers");
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WebhookService;
import java.awt.image.BufferedImage;
import java.util.concurrent.ScheduledExecutorService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.input.KeyManager;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.HotkeyListener;

/**
 * Handles manual screenshot capture via keybind.
 */
@Slf4j
public class ManualScreenshotHandler
{
	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final DrawManager drawManager;
	private final ScheduledExecutorService executor;
	private final KeyManager keyManager;

	private final HotkeyListener hotkeyListener;

	public ManualScreenshotHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		DrawManager drawManager,
		ScheduledExecutorService executor,
		KeyManager keyManager)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.drawManager = drawManager;
		this.executor = executor;
		this.keyManager = keyManager;

		this.hotkeyListener = new HotkeyListener(() -> config.manualScreenshotKeybind())
		{
			@Override
			public void hotkeyPressed()
			{
				sendManualScreenshot();
			}
		};
	}

	public void register()
	{
		keyManager.registerKeyListener(hotkeyListener);
		log.debug("Manual screenshot hotkey registered");
	}

	public void unregister()
	{
		keyManager.unregisterKeyListener(hotkeyListener);
		log.debug("Manual screenshot hotkey unregistered");
	}

	private void sendManualScreenshot()
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** sent a manual screenshot", playerName);

		drawManager.requestNextFrameListener(image -> {
			executor.execute(() -> {
				try
				{
					webhookService.sendWebhook(config.webhookUrl(), message, (BufferedImage) image);
					log.info("Manual screenshot sent");
				}
				catch (Exception e)
				{
					log.error("Error sending manual screenshot", e);
				}
			});
		});
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WebhookService;
import java.awt.image.BufferedImage;
import java.lang.reflect.Array;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.ui.DrawManager;

/**
 * Handles valuable drop notifications from chat messages.
 * Detects when the game announces a valuable drop above the configured threshold.
 */
@Slf4j
public class ValuableDropHandler implements EventHandler<ChatMessage>
{
	private static final Pattern VALUABLE_DROP_PATTERN = Pattern.compile(
		".*Valuable drop: ([^<>]+?\\(((?:\\d+,?)+) coins\\))(?:</col>)?"
	);

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final DrawManager drawManager;
	private final ScheduledExecutorService executor;

	public ValuableDropHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		DrawManager drawManager,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.drawManager = drawManager;
		this.executor = executor;
	}

	@Override
	public void handle(ChatMessage event)
	{
		if (!config.includeValuableDrops())
		{
			return;
		}

		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String chatMessage = event.getMessage();
		Matcher matcher = VALUABLE_DROP_PATTERN.matcher(chatMessage);
		
		if (matcher.matches())
		{
			int valuableDropValue = Integer.parseInt(matcher.group(2).replaceAll(",", ""));
			
			if (valuableDropValue >= config.valuableDropThreshold())
			{
				String[] valuableDrop = matcher.group(1).split(" \\(");
				String valuableDropName = (String) Array.get(valuableDrop, 0);
				String valuableDropValueString = matcher.group(2);
				
				sendValuableDropNotification(valuableDropName, valuableDropValueString);
			}
		}
	}

	@Override
	public Class<ChatMessage> getEventType()
	{
		return ChatMessage.class;
	}

	private void sendValuableDropNotification(String itemName, String itemValue)
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** just received a valuable drop: **%s**!\nApprox Value: **%s coins**", 
			playerName, itemName, itemValue);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message, null);
		}
	}

	private void takeScreenshotAndSend(String message)
	{
		drawManager.requestNextFrameListener(image -> {
			executor.execute(() -> {
				try
				{
					webhookService.sendWebhook(config.webhookUrl(), message, (BufferedImage) image);
				}
				catch (Exception e)
				{
					log.error("Error sending webhook with screenshot for valuable drop", e);
				}
			});
		});
	}
}

package com.fauxbingo.handlers;

public interface EventHandler<T>
{
	void handle(T event);

	Class<T> getEventType();
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WebhookService;
import java.awt.image.BufferedImage;
import java.util.concurrent.ScheduledExecutorService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.Text;

/**
 * Handles collection log events.
 * Detects new collection log items through both chat messages and notification scripts.
 */
@Slf4j
public class CollectionLogHandler
{
	private static final String COLLECTION_LOG_TEXT = "New item added to your collection log: ";

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final DrawManager drawManager;
	private final ScheduledExecutorService executor;

	private boolean notificationStarted = false;

	public CollectionLogHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		DrawManager drawManager,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.drawManager = drawManager;
		this.executor = executor;
	}

	public EventHandler<ChatMessage> createChatHandler()
	{
		return new EventHandler<ChatMessage>()
		{
			@Override
			public void handle(ChatMessage event)
			{
				if (!config.includeCollectionLog())
				{
					return;
				}

				if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
				{
					return;
				}

				String chatMessage = event.getMessage();
				if (chatMessage.startsWith(COLLECTION_LOG_TEXT) && 
					client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION) == 1)
				{
					String entry = Text.removeTags(chatMessage).substring(COLLECTION_LOG_TEXT.length());
					sendCollectionLogNotification(entry);
				}
			}

			@Override
			public Class<ChatMessage> getEventType()
			{
				return ChatMessage.class;
			}
		};
	}

	public EventHandler<ScriptPreFired> createScriptHandler()
	{
		return new EventHandler<ScriptPreFired>()
		{
			@Override
			public void handle(ScriptPreFired event)
			{
				if (!config.includeCollectionLog())
				{
					return;
				}

				switch (event.getScriptId())
				{
					case ScriptID.NOTIFICATION_START:
						notificationStarted = true;
						break;
					case ScriptID.NOTIFICATION_DELAY:
						if (!notificationStarted)
						{
							return;
						}
						String notificationTopText = client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT);
						String notificationBottomText = client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT);
						if (notificationTopText.equalsIgnoreCase("Collection log"))
						{
							String entry = Text.removeTags(notificationBottomText).substring("New item:".length()).trim();
							sendCollectionLogNotification(entry);
						}
						notificationStarted = false;
						break;
				}
			}

			@Override
			public Class<ScriptPreFired> getEventType()
			{
				return ScriptPreFired.class;
			}
		};
	}

	private void sendCollectionLogNotification(String itemName)
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String message = String.format("**%s** just received a new collection log item: **%s**!", 
			playerName, itemName);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message, null);
		}
	}

	private void takeScreenshotAndSend(String message)
	{
		drawManager.requestNextFrameListener(image -> {
			executor.execute(() -> {
				try
				{
					webhookService.sendWebhook(config.webhookUrl(), message, (BufferedImage) image);
				}
				catch (Exception e)
				{
					log.error("Error sending webhook with screenshot for collection log", e);
				}
			});
		});
	}

	public void resetState()
	{
		notificationStarted = false;
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WebhookService;
import java.awt.image.BufferedImage;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.Text;

/**
 * Handles raid loot notifications for Chambers of Xeric and Theatre of Blood.
 * Tracks raid completions and unique drops from both raids.
 */
@Slf4j
public class RaidLootHandler
{
	private static final Pattern COX_UNIQUE_MESSAGE_PATTERN = Pattern.compile("(.+) - (.+)");
	private static final String COX_DUST_MESSAGE_TEXT = "Dust recipients: ";
	private static final String COX_KIT_MESSAGE_TEXT = "Twisted Kit recipients: ";
	private static final Pattern TOB_UNIQUE_MESSAGE_PATTERN = Pattern.compile("(.+) found something special: (.+)");
	private static final Pattern KC_MESSAGE_PATTERN = Pattern.compile("([0-9]+)");

	private static final int CoX_Interface_Id = InterfaceID.RAIDS_REWARDS;
	private static final int ToB_Interface_Id = InterfaceID.TOB_CHESTS;

	enum RaidType
	{
		COX,
		COX_CM,
		TOB,
		TOB_SM,
		TOB_HM
	}

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final DrawManager drawManager;
	private final ScheduledExecutorService executor;

	private RaidType raidType;
	private Integer raidKc;
	private String raidItemName;

	public RaidLootHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		DrawManager drawManager,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.drawManager = drawManager;
		this.executor = executor;
	}

	public EventHandler<ChatMessage> createChatHandler()
	{
		return new EventHandler<ChatMessage>()
		{
			@Override
			public void handle(ChatMessage event)
			{
				if (!config.includeRaidLoot())
				{
					return;
				}

				if (event.getType() != ChatMessageType.GAMEMESSAGE
					&& event.getType() != ChatMessageType.SPAM
					&& event.getType() != ChatMessageType.TRADE
					&& event.getType() != ChatMessageType.FRIENDSCHATNOTIFICATION)
				{
					return;
				}

				String chatMessage = event.getMessage();
				handleRaidChatMessage(chatMessage);
			}

			@Override
			public Class<ChatMessage> getEventType()
			{
				return ChatMessage.class;
			}
		};
	}

	public EventHandler<WidgetLoaded> createWidgetHandler()
	{
		return new EventHandler<WidgetLoaded>()
		{
			@Override
			public void handle(WidgetLoaded event)
			{
				if (!config.includeRaidLoot())
				{
					return;
				}

				int groupId = event.getGroupId();

				if (groupId == CoX_Interface_Id || groupId == ToB_Interface_Id)
				{
					handleRaidRewardWidget(groupId);
				}
			}

			@Override
			public Class<WidgetLoaded> getEventType()
			{
				return WidgetLoaded.class;
			}
		};
	}

	private void handleRaidChatMessage(String chatMessage)
	{
		// Check for COX completion
		if (chatMessage.startsWith("Your completed Chambers of Xeric count is:"))
		{
			Matcher matcher = KC_MESSAGE_PATTERN.matcher(Text.removeTags(chatMessage));
			if (matcher.find())
			{
				raidType = chatMessage.contains("Challenge Mode") ? RaidType.COX_CM : RaidType.COX;
				raidKc = Integer.valueOf(matcher.group());
				return;
			}
		}

		// Check for TOB completion
		if (chatMessage.startsWith("Your completed Theatre of Blood"))
		{
			Matcher matcher = KC_MESSAGE_PATTERN.matcher(Text.removeTags(chatMessage));
			if (matcher.find())
			{
				raidType = chatMessage.contains("Hard Mode") ? RaidType.TOB_HM : 
					(chatMessage.contains("Story Mode") ? RaidType.TOB_SM : RaidType.TOB);
				raidKc = Integer.valueOf(matcher.group());
				return;
			}
		}

		// Check for COX unique drops
		Matcher coxUnique = COX_UNIQUE_MESSAGE_PATTERN.matcher(chatMessage);
		if (coxUnique.matches())
		{
			final String lootRecipient = Text.sanitize(coxUnique.group(1)).trim();
			final String dropName = coxUnique.group(2).trim();

			if (lootRecipient.equals(Text.sanitize(Objects.requireNonNull(client.getLocalPlayer().getName()))))
			{
				raidItemName = dropName;
				// Note: COX uniques are sent when widget loads
			}
		}

		// Check for COX metamorphic dust
		if (chatMessage.startsWith(COX_DUST_MESSAGE_TEXT))
		{
			final String dustRecipient = Text.removeTags(chatMessage).substring(COX_DUST_MESSAGE_TEXT.length());
			
			if (dustRecipient.equals(Text.sanitize(Objects.requireNonNull(client.getLocalPlayer().getName()))))
			{
				raidItemName = "Metamorphic dust";
			}
		}

		// Check for COX twisted kit
		if (chatMessage.startsWith(COX_KIT_MESSAGE_TEXT))
		{
			final String kitRecipient = Text.removeTags(chatMessage).substring(COX_KIT_MESSAGE_TEXT.length());
			
			if (kitRecipient.equals(Text.sanitize(Objects.requireNonNull(client.getLocalPlayer().getName()))))
			{
				raidItemName = "Twisted ancestral colour kit";
			}
		}

		// Check for TOB unique drops
		Matcher tobUnique = TOB_UNIQUE_MESSAGE_PATTERN.matcher(chatMessage);
		if (tobUnique.matches())
		{
			final String lootRecipient = Text.sanitize(tobUnique.group(1)).trim();
			final String dropName = tobUnique.group(2).trim();

			if (lootRecipient.equals(Text.sanitize(Objects.requireNonNull(client.getLocalPlayer().getName()))))
			{
				raidItemName = dropName;
				// Note: TOB uniques are sent when widget loads
			}
		}
	}

	private void handleRaidRewardWidget(int groupId)
	{
		if (raidItemName == null)
		{
			return;
		}

		String raidName = null;

		if (groupId == CoX_Interface_Id)
		{
			if (raidType == RaidType.COX)
			{
				raidName = "Chambers of Xeric";
			}
			else if (raidType == RaidType.COX_CM)
			{
				raidName = "Chambers of Xeric Challenge Mode";
			}
		}
		else if (groupId == ToB_Interface_Id)
		{
			if (raidType == RaidType.TOB)
			{
				raidName = "Theatre of Blood";
			}
			else if (raidType == RaidType.TOB_SM)
			{
				raidName = "Theatre of Blood Story Mode";
			}
			else if (raidType == RaidType.TOB_HM)
			{
				raidName = "Theatre of Blood Hard Mode";
			}
		}

		if (raidName != null)
		{
			sendRaidLootNotification(raidItemName, raidName, raidKc);
		}

		// Reset state
		raidItemName = null;
		raidType = null;
		raidKc = null;
	}

	private void sendRaidLootNotification(String itemName, String raidName, Integer kc)
	{
		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		StringBuilder message = new StringBuilder();
		message.append(String.format("**%s** just received a rare drop from %s: **%s**!", 
			playerName, raidName, itemName));
		
		if (kc != null && kc > 0)
		{
			message.append(String.format("\nKill Count: **%d**", kc));
		}

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(message.toString());
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), message.toString(), null);
		}
	}

	private void takeScreenshotAndSend(String message)
	{
		drawManager.requestNextFrameListener(image -> {
			executor.execute(() -> {
				try
				{
					webhookService.sendWebhook(config.webhookUrl(), message, (BufferedImage) image);
				}
				catch (Exception e)
				{
					log.error("Error sending webhook with screenshot for raid loot", e);
				}
			});
		});
	}

	public void resetState()
	{
		raidType = null;
		raidKc = null;
		raidItemName = null;
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WebhookService;
import java.awt.image.BufferedImage;
import java.util.Collection;
import java.util.concurrent.ScheduledExecutorService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.ui.DrawManager;

/**
 * Handles loot-related events from NPCs and players.
 * Calculates total loot value and triggers webhook notifications when threshold is met.
 */
@Slf4j
public class LootEventHandler
{
	private final FauxBingoConfig config;
	private final ItemManager itemManager;
	private final WebhookService webhookService;
	private final DrawManager drawManager;
	private final ScheduledExecutorService executor;

	public LootEventHandler(
		FauxBingoConfig config,
		ItemManager itemManager,
		WebhookService webhookService,
		DrawManager drawManager,
		ScheduledExecutorService executor)
	{
		this.config = config;
		this.itemManager = itemManager;
		this.webhookService = webhookService;
		this.drawManager = drawManager;
		this.executor = executor;
	}

	public EventHandler<NpcLootReceived> createNpcLootHandler()
	{
		return new EventHandler<NpcLootReceived>()
		{
			@Override
			public void handle(NpcLootReceived event)
			{
				processLoot(event.getNpc().getName(), event.getItems());
			}

			@Override
			public Class<NpcLootReceived> getEventType()
			{
				return NpcLootReceived.class;
			}
		};
	}

	public EventHandler<PlayerLootReceived> createPlayerLootHandler()
	{
		return new EventHandler<PlayerLootReceived>()
		{
			@Override
			public void handle(PlayerLootReceived event)
			{
				processLoot(event.getPlayer().getName(), event.getItems());
			}

			@Override
			public Class<PlayerLootReceived> getEventType()
			{
				return PlayerLootReceived.class;
			}
		};
	}

	private void processLoot(String source, Collection<ItemStack> items)
	{
		long totalValue = 0;
		StringBuilder lootString = new StringBuilder();

		for (ItemStack itemStack : items)
		{
			int itemId = itemStack.getId();
			int quantity = itemStack.getQuantity();
			int price = itemManager.getItemPrice(itemId);
			totalValue += (long) price * quantity;

			String itemName = itemManager.getItemComposition(itemId).getName();
			if (lootString.length() > 0)
			{
				lootString.append(", ");
			}
			lootString.append(quantity).append(" x ").append(itemName);
		}

		if (totalValue >= config.minLootValue())
		{
			String message = String.format("Loot received from %s: %s (Total value: %,d gp)",
				source, lootString.toString(), totalValue);
			
			if (config.sendScreenshot())
			{
				takeScreenshotAndSend(message);
			}
			else
			{
				webhookService.sendWebhook(config.webhookUrl(), message, null);
			}
		}
	}

	private void takeScreenshotAndSend(String message)
	{
		drawManager.requestNextFrameListener(image -> {
			executor.execute(() -> {
				try
				{
					webhookService.sendWebhook(config.webhookUrl(), message, (BufferedImage) image);
				}
				catch (Exception e)
				{
					log.error("Error sending webhook with screenshot", e);
				}
			});
		});
	}
}

package com.fauxbingo.handlers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WebhookService;
import com.google.common.collect.ImmutableList;
import java.awt.image.BufferedImage;
import java.util.concurrent.ScheduledExecutorService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.ui.DrawManager;

/**
 * Handles chat message events to detect pet drops.
 */
@Slf4j
public class PetChatHandler implements EventHandler<ChatMessage>
{
	private static final ImmutableList<String> PET_MESSAGES = ImmutableList.of(
		"You have a funny feeling like you're being followed",
		"You feel something weird sneaking into your backpack",
		"You have a funny feeling like you would have been followed"
	);

	private final Client client;
	private final FauxBingoConfig config;
	private final WebhookService webhookService;
	private final DrawManager drawManager;
	private final ScheduledExecutorService executor;

	public PetChatHandler(
		Client client,
		FauxBingoConfig config,
		WebhookService webhookService,
		DrawManager drawManager,
		ScheduledExecutorService executor)
	{
		this.client = client;
		this.config = config;
		this.webhookService = webhookService;
		this.drawManager = drawManager;
		this.executor = executor;
	}

	@Override
	public void handle(ChatMessage event)
	{
		if (!config.includePets())
		{
			return;
		}

		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String message = event.getMessage();

		// Check if message indicates a pet drop
		if (PET_MESSAGES.stream().anyMatch(message::contains))
		{
			handlePetDrop();
		}
	}

	@Override
	public Class<ChatMessage> getEventType()
	{
		return ChatMessage.class;
	}

	private void handlePetDrop()
	{
		log.info("Pet drop detected");

		String playerName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : "Player";
		String webhookMessage = String.format("**%s** just received a new pet!", playerName);

		if (config.sendScreenshot())
		{
			takeScreenshotAndSend(webhookMessage);
		}
		else
		{
			webhookService.sendWebhook(config.webhookUrl(), webhookMessage, null);
		}
	}

	private void takeScreenshotAndSend(String message)
	{
		drawManager.requestNextFrameListener(image -> {
			executor.execute(() -> {
				try
				{
					webhookService.sendWebhook(config.webhookUrl(), message, (BufferedImage) image);
				}
				catch (Exception e)
				{
					log.error("Error sending webhook with screenshot for pet drop", e);
				}
			});
		});
	}
}

package com.fauxbingo;

import com.fauxbingo.handlers.CollectionLogHandler;
import com.fauxbingo.handlers.LootEventHandler;
import com.fauxbingo.handlers.ManualScreenshotHandler;
import com.fauxbingo.handlers.PetChatHandler;
import com.fauxbingo.handlers.RaidLootHandler;
import com.fauxbingo.handlers.ValuableDropHandler;
import com.fauxbingo.overlay.TeamOverlay;
import com.fauxbingo.services.WebhookService;
import com.fauxbingo.services.WiseOldManService;
import com.fauxbingo.trackers.XpTracker;
import com.google.gson.Gson;
import com.google.inject.Provides;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.UsernameChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.overlay.OverlayManager;
import okhttp3.OkHttpClient;

@Slf4j
@PluginDescriptor(
	name = "Faux Bingo",
	description = "Helper plugin for Bingo events ran in the Faux Clan/Community",
	tags = {"faux", "bingo"}
)
public class FauxBingoPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private FauxBingoConfig config;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private DrawManager drawManager;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private KeyManager keyManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private TeamOverlay teamOverlay;

	@Inject
	private Gson gson;

	private EventProcessor eventProcessor;
	private WebhookService webhookService;
	private WiseOldManService wiseOldManService;
	private LootEventHandler lootEventHandler;
	private PetChatHandler petChatHandler;
	private CollectionLogHandler collectionLogHandler;
	private ValuableDropHandler valuableDropHandler;
	private RaidLootHandler raidLootHandler;
	private ManualScreenshotHandler manualScreenshotHandler;
	private XpTracker xpTracker;

	private boolean shouldSendMessage = false;

	@Override
	protected void startUp() throws Exception
	{
		log.info("Faux Bingo started!");

		// Initialize services
		webhookService = new WebhookService(okHttpClient);
		wiseOldManService = new WiseOldManService(client, config, okHttpClient, gson);
		eventProcessor = new EventProcessor();

		// Initialize trackers
		xpTracker = new XpTracker(client, config, wiseOldManService);

		// Initialize handlers
		lootEventHandler = new LootEventHandler(config, itemManager, webhookService, drawManager, executor);
		petChatHandler = new PetChatHandler(client, config, webhookService, drawManager, executor);
		collectionLogHandler = new CollectionLogHandler(client, config, webhookService, drawManager, executor);
		valuableDropHandler = new ValuableDropHandler(client, config, webhookService, drawManager, executor);
		raidLootHandler = new RaidLootHandler(client, config, webhookService, drawManager, executor);
		manualScreenshotHandler = new ManualScreenshotHandler(client, config, webhookService, drawManager, executor, keyManager);

		// Register event handlers
		eventProcessor.registerHandler(lootEventHandler.createNpcLootHandler());
		eventProcessor.registerHandler(lootEventHandler.createPlayerLootHandler());
		eventProcessor.registerHandler(petChatHandler);
		eventProcessor.registerHandler(collectionLogHandler.createChatHandler());
		eventProcessor.registerHandler(collectionLogHandler.createScriptHandler());
		eventProcessor.registerHandler(valuableDropHandler);
		eventProcessor.registerHandler(raidLootHandler.createChatHandler());
		eventProcessor.registerHandler(raidLootHandler.createWidgetHandler());

		// Register manual screenshot hotkey
		manualScreenshotHandler.register();

		// Register overlay
		overlayManager.add(teamOverlay);

		log.info("Event processor initialized with all handlers");
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Faux Bingo stopped!");

		// Unregister overlay
		overlayManager.remove(teamOverlay);

		// Unregister manual screenshot hotkey
		if (manualScreenshotHandler != null)
		{
			manualScreenshotHandler.unregister();
		}

		// Clean up event processor
		if (eventProcessor != null)
		{
			eventProcessor.clearHandlers();
		}

		// Reset XP tracker
		if (xpTracker != null)
		{
			xpTracker.reset();
		}

		// Reset state
		resetState();
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived event)
	{
		if (!shouldSendMessage) return;
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onPlayerLootReceived(PlayerLootReceived event)
	{
		if (!shouldSendMessage) return;
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!shouldSendMessage) return;
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event)
	{
		if (!shouldSendMessage) return;
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (!shouldSendMessage) return;
		eventProcessor.processEvent(event);
	}

	@Subscribe
	public void onUsernameChanged(UsernameChanged event)
	{
		resetState();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGIN_SCREEN)
		{
			resetState();
		}
		else
		{
			shouldSendMessage = true;
		}

		// Pass event to XP tracker
		if (xpTracker != null)
		{
			xpTracker.onGameStateChanged(event);
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		// Pass event to XP tracker
		if (xpTracker != null)
		{
			xpTracker.onStatChanged(event);
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		// Pass event to XP tracker
		if (xpTracker != null)
		{
			xpTracker.onGameTick();
		}
	}

	private void resetState()
	{
		shouldSendMessage = false;

		if (collectionLogHandler != null)
		{
			collectionLogHandler.resetState();
		}

		if (raidLootHandler != null)
		{
			raidLootHandler.resetState();
		}
	}

	@Provides
	FauxBingoConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FauxBingoConfig.class);
	}
}

package com.fauxbingo.trackers;

import com.fauxbingo.FauxBingoConfig;
import com.fauxbingo.services.WiseOldManService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.StatChanged;

import java.util.EnumMap;
import java.util.Map;

/**
 * Tracks player XP and level changes to trigger WiseOldMan updates.
 * Updates are triggered when:
 * - Player logs out and gained 10k+ XP
 * - Player levels up during the session
 */
@Slf4j
public class XpTracker
{
	private static final int XP_THRESHOLD = 10_000;

	private final Client client;
	private final FauxBingoConfig config;
	private final WiseOldManService wiseOldManService;

	private final Map<Skill, Integer> previousSkillLevels = new EnumMap<>(Skill.class);
	private long lastTotalXp = 0;
	private boolean levelUpThisSession = false;
	private boolean fetchXp = false;
	private String playerName;
	private long accountHash;

	public XpTracker(Client client, FauxBingoConfig config, WiseOldManService wiseOldManService)
	{
		this.client = client;
		this.config = config;
		this.wiseOldManService = wiseOldManService;
	}

	public void onStatChanged(StatChanged event)
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		Skill skill = event.getSkill();
		int levelAfter = client.getRealSkillLevel(skill);
		int levelBefore = previousSkillLevels.getOrDefault(skill, -1);

		if (levelBefore != -1 && levelAfter > levelBefore)
		{
			levelUpThisSession = true;
			log.debug("Level up detected in {}: {} -> {}", skill, levelBefore, levelAfter);
		}

		previousSkillLevels.put(skill, levelAfter);
	}

	public void onGameStateChanged(GameStateChanged event)
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		GameState state = event.getGameState();

		switch (state)
		{
			case LOGGED_IN:
				// Check if account changed
				if (accountHash != client.getAccountHash())
				{
					fetchXp = true;
				}
				break;

			case LOGIN_SCREEN:
			case HOPPING:
				Player local = client.getLocalPlayer();
				if (local == null)
				{
					return;
				}

				playerName = local.getName();
				long currentTotalXp = client.getOverallExperience();

				// Only update if XP threshold is reached or player leveled up
				if (Math.abs(currentTotalXp - lastTotalXp) > XP_THRESHOLD || levelUpThisSession)
				{
					log.debug("Triggering WiseOldMan update for {} (XP change: {}, Level up: {})",
						playerName,
						Math.abs(currentTotalXp - lastTotalXp),
						levelUpThisSession);

					wiseOldManService.updatePlayer(playerName);
					lastTotalXp = currentTotalXp;
					levelUpThisSession = false;
				}
				break;
		}
	}

	public void onGameTick()
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		if (fetchXp)
		{
			lastTotalXp = client.getOverallExperience();
			accountHash = client.getAccountHash();
			fetchXp = false;

			Player local = client.getLocalPlayer();
			if (local != null)
			{
				playerName = local.getName();
			}

			// Save current skill levels
			saveCurrentLevels();
		}
	}

	private void saveCurrentLevels()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		previousSkillLevels.clear();
		for (Skill skill : Skill.values())
		{
			previousSkillLevels.put(skill, client.getRealSkillLevel(skill));
		}
	}

	public void reset()
	{
		previousSkillLevels.clear();
		lastTotalXp = 0;
		levelUpThisSession = false;
		fetchXp = false;
		playerName = null;
		accountHash = 0;
	}
}

package com.fauxbingo;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

@ConfigGroup("fauxbingo")
public interface FauxBingoConfig extends Config
{
	@ConfigSection(
		name = "Team Overlay",
		description = "Configure team name and timestamp overlay display",
		position = 0
	)
	String overlaySection = "overlay";

	@ConfigSection(
		name = "WiseOldMan Auto-Update",
		description = "Automatically update your WiseOldMan stats",
		position = 1
	)
	String wiseOldManSection = "wiseOldMan";

	@ConfigSection(
		name = "Discord Alerts",
		description = "Configure Discord webhook notifications",
		position = 2
	)
	String discordAlertsSection = "discordAlerts";

	// ========== Team Overlay Configuration ==========

	@ConfigItem(
		keyName = "displayOverlay",
		name = "Display Overlay",
		description = "Displays the team name and timestamp overlay on your game screen",
		position = 1,
		section = overlaySection
	)
	default boolean displayOverlay()
	{
		return false;
	}

	@ConfigItem(
		keyName = "displayDateTime",
		name = "Date & Time",
		description = "Adds the date and time to the overlay",
		position = 2,
		section = overlaySection
	)
	default boolean displayDateTime()
	{
		return true;
	}

	@ConfigItem(
		keyName = "teamName",
		name = "Team Name",
		description = "Your team name to display in the overlay",
		position = 3,
		section = overlaySection
	)
	default String teamName()
	{
		return "";
	}

	@ConfigItem(
		keyName = "teamNameColor",
		name = "Team Name Color",
		description = "The color of the team name in the overlay",
		position = 4,
		section = overlaySection
	)
	default Color teamNameColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "dateTimeColor",
		name = "Date & Time Color",
		description = "The color of the date and time in the overlay",
		position = 5,
		section = overlaySection
	)
	default Color dateTimeColor()
	{
		return Color.WHITE;
	}

	// ========== WiseOldMan Auto-Update Configuration ==========

	@ConfigItem(
		keyName = "enableWomAutoUpdate",
		name = "Enable Auto-Update",
		description = "Automatically update your WiseOldMan stats on logout or when gaining 10k+ XP",
		position = 1,
		section = wiseOldManSection
	)
	default boolean enableWomAutoUpdate()
	{
		return false;
	}

	// ========== Discord Alerts Configuration ==========

	@ConfigItem(
		keyName = "webhookUrl",
		name = "Webhook URL",
		description = "The Discord Webhook URL(s) to send loot notifications to, separated by newlines",
		position = 1,
		section = discordAlertsSection
	)
	default String webhookUrl()
	{
		return "";
	}

	@ConfigItem(
		keyName = "sendScreenshot",
		name = "Send Screenshot",
		description = "Whether to take and send a screenshot with notifications",
		position = 2,
		section = discordAlertsSection
	)
	default boolean sendScreenshot()
	{
		return true;
	}

	@ConfigItem(
		keyName = "manualScreenshotKeybind",
		name = "Manual Screenshot Keybind",
		description = "Keybind to manually send a screenshot to the webhook",
		position = 3,
		section = discordAlertsSection
	)
	default Keybind manualScreenshotKeybind()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
		keyName = "includePets",
		name = "Include Pets",
		description = "Send webhook notification when receiving a pet",
		position = 4,
		section = discordAlertsSection
	)
	default boolean includePets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeCollectionLog",
		name = "Include Collection Log",
		description = "Send webhook notification for new collection log entries",
		position = 5,
		section = discordAlertsSection
	)
	default boolean includeCollectionLog()
	{
		return true;
	}

	@ConfigItem(
		keyName = "includeValuableDrops",
		name = "Include Valuable Drops",
		description = "Send webhook notification for valuable drops above threshold",
		position = 6,
		section = discordAlertsSection
	)
	default boolean includeValuableDrops()
	{
		return true;
	}

	@ConfigItem(
		keyName = "valuableDropThreshold",
		name = "Valuable Drop Threshold",
		description = "Minimum value in coins for valuable drop notifications",
		position = 7,
		section = discordAlertsSection
	)
	default int valuableDropThreshold()
	{
		return 1000000;
	}

	@ConfigItem(
		keyName = "includeRaidLoot",
		name = "Include Raid Loot",
		description = "Send webhook notification for raid unique drops (COX/TOB)",
		position = 8,
		section = discordAlertsSection
	)
	default boolean includeRaidLoot()
	{
		return true;
	}

	@ConfigItem(
		keyName = "minLootValue",
		name = "Min Loot Value",
		description = "Minimum value of regular loot to be logged",
		position = 9,
		section = discordAlertsSection
	)
	default int minLootValue()
	{
		return 1000000;
	}
}

package com.fauxbingo.overlay;

import com.fauxbingo.FauxBingoConfig;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

/**
 * Overlay that displays team name and current date/time in UTC.
 * Used for verification purposes when screenshots are sent to Discord webhooks.
 */
public class TeamOverlay extends OverlayPanel
{
	private final FauxBingoConfig config;

	@Inject
	public TeamOverlay(FauxBingoConfig config)
	{
		this.config = config;
		setPosition(OverlayPosition.TOP_CENTER);
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Faux Bingo overlay"));
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Only render if overlay is enabled and team name is set
		if (!config.displayOverlay() || config.teamName().trim().isEmpty())
		{
			return null;
		}

		String teamName = config.teamName();
		Color teamNameColor = config.teamNameColor();
		Color dateTimeColor = config.dateTimeColor();

		// Ensure colors are different, fallback to defaults if they match
		if (teamNameColor.equals(dateTimeColor))
		{
			teamNameColor = Color.GREEN;
			dateTimeColor = Color.WHITE;
		}

		// Build the full text for width calculation
		String fullText = teamName;
		if (config.displayDateTime())
		{
			fullText = teamName + " " + getUtcDateTime();
		}

		// Add team name as the left component
		panelComponent.getChildren().add(LineComponent.builder()
			.left(teamName)
			.leftColor(teamNameColor)
			.build());

		// Add date/time as the right component if enabled
		if (config.displayDateTime())
		{
			List<LayoutableRenderableEntity> children = panelComponent.getChildren();
			LineComponent line = (LineComponent) children.get(0);
			line.setRight(getUtcDateTime());
			line.setRightColor(dateTimeColor);
		}

		// Set preferred size based on text width
		panelComponent.setPreferredSize(new Dimension(
			graphics.getFontMetrics().stringWidth(fullText) + 10, 0));

		return super.render(graphics);
	}

	private String getUtcDateTime()
	{
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
		sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
		return sdf.format(date) + " UTC";
	}
}

package com.fauxbingo.services;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import javax.imageio.ImageIO;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * Service responsible for sending discord webhook notifications with optional screenshots.
 */
@Slf4j
public class WebhookService
{
	private final OkHttpClient okHttpClient;

	public WebhookService(OkHttpClient okHttpClient)
	{
		this.okHttpClient = okHttpClient;
	}

	/**
	 * Send a webhook message to the configured URLs.
	 *
	 * @param webhookUrls Newline-separated list of webhook URLs
	 * @param message The message content to send
	 * @param image Optional screenshot to attach (can be null)
	 */
	public void sendWebhook(String webhookUrls, String message, BufferedImage image)
	{
		if (webhookUrls == null || webhookUrls.isEmpty())
		{
			return;
		}

		String[] urls = webhookUrls.split("\n");

		byte[] imageBytes = null;
		if (image != null)
		{
			imageBytes = convertImageToBytes(image);
		}

		for (String url : urls)
		{
			final String finalUrl = url.trim();
			if (finalUrl.isEmpty())
			{
				continue;
			}

			sendToUrl(finalUrl, message, imageBytes);
		}
	}

	private byte[] convertImageToBytes(BufferedImage image)
	{
		try (ByteArrayOutputStream out = new ByteArrayOutputStream())
		{
			ImageIO.write(image, "png", out);
			return out.toByteArray();
		}
		catch (IOException e)
		{
			log.error("Error converting image to bytes", e);
			return null;
		}
	}

	private void sendToUrl(String url, String message, byte[] imageBytes)
	{
		HttpUrl httpUrl = HttpUrl.parse(url);
		if (httpUrl == null)
		{
			log.warn("Invalid webhook URL: {}", url);
			return;
		}

		MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
			.setType(MultipartBody.FORM)
			.addFormDataPart("content", message);

		if (imageBytes != null)
		{
			requestBodyBuilder.addFormDataPart("file", "screenshot.png",
				RequestBody.create(MediaType.parse("image/png"), imageBytes));
		}

		Request request = new Request.Builder()
			.url(httpUrl)
			.post(requestBodyBuilder.build())
			.build();

		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Error submitting webhook to {}", url, e);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				response.close();
			}
		});
	}
}

package com.fauxbingo.services;

import com.fauxbingo.FauxBingoConfig;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

import java.io.IOException;

/**
 * Service for interacting with the WiseOldMan API.
 */
@Slf4j
public class WiseOldManService
{
	private static final String WOM_API_HOST = "api.wiseoldman.net";
	private static final String WOM_API_VERSION = "v2";
	private static final String USER_AGENT = "FauxBingo-RuneLite-Plugin";

	private final Client client;
	private final FauxBingoConfig config;
	private final OkHttpClient okHttpClient;
	private final Gson gson;

	public WiseOldManService(Client client, FauxBingoConfig config, OkHttpClient okHttpClient, Gson gson)
	{
		this.client = client;
		this.config = config;
		this.okHttpClient = okHttpClient;
		this.gson = gson;
	}

	public void updatePlayer(String username)
	{
		if (!config.enableWomAutoUpdate())
		{
			return;
		}

		if (username == null || username.isEmpty())
		{
			log.warn("Cannot update WiseOldMan: username is null or empty");
			return;
		}

		long accountHash = client.getAccountHash();

		// Build the API URL: POST /v2/players/{username}
		HttpUrl url = new HttpUrl.Builder()
			.scheme("https")
			.host(WOM_API_HOST)
			.addPathSegment(WOM_API_VERSION)
			.addPathSegment("players")
			.addPathSegment(username)
			.build();

		// Create payload with account hash for verification
		WomPlayerUpdate payload = new WomPlayerUpdate(accountHash);
		String json = gson.toJson(payload);

		RequestBody body = RequestBody.create(
			MediaType.parse("application/json; charset=utf-8"),
			json
		);

		Request request = new Request.Builder()
			.url(url)
			.header("User-Agent", USER_AGENT)
			.post(body)
			.build();

		// Send the request asynchronously
		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.debug("Failed to update WiseOldMan stats for {}: {}", username, e.getMessage());
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try
				{
					if (response.isSuccessful())
					{
						log.info("Successfully updated WiseOldMan stats for {}", username);
					}
					else
					{
						log.debug("WiseOldMan update returned status {}: {}", 
							response.code(), response.message());
					}
				}
				finally
				{
					response.close();
				}
			}
		});
	}

	private static class WomPlayerUpdate
	{
		private final long accountHash;

		public WomPlayerUpdate(long accountHash)
		{
			this.accountHash = accountHash;
		}
	}
}

package com.fauxbingo;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FauxBingoPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FauxBingoPlugin.class);
		RuneLite.main(args);
	}
}
