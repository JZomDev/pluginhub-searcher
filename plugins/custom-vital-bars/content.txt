/*
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;

@Getter
@AllArgsConstructor
enum Viewport
{
	RESIZED_BOX(ComponentID.RESIZABLE_VIEWPORT_INTERFACE_CONTAINER,
			new Point(20, -4), new Point(0, -4)),
	RESIZED_BOTTOM(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INTERFACE_CONTAINER,
			new Point(61, -12), new Point(35, -12)),
	FIXED(ComponentID.FIXED_VIEWPORT_INTERFACE_CONTAINER,
			new Point(20, -4), new Point(0, -4)),
	FIXED_BANK(ComponentID.BANK_INVENTORY_ITEM_CONTAINER,
			new Point(20, -4), new Point(0, -4));

	private final int viewport;
	private final Point offsetLeft;
	private final Point offsetRight;
}

package net.runelite.client.plugins.customvitalbars;

import net.runelite.client.config.*;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import java.awt.*;

@ConfigGroup("Custom Vital Bars")
public interface CustomVitalBarsConfig extends Config
{
	String GROUP = "vitalbars";

	@ConfigItem(
			position = 1,
			keyName = "showHitpoints",
			name = "Show Hitpoints",
			description = "Render Hitpoints bar"
	)
	default boolean renderHitpoints() { return false; }

	@ConfigSection(
			position = 2,
			name = "Hitpoints Bar Settings",
			description = "Hitpoints Bar Settings"
	)
	String hitpointsSettingsSection = "hitpointsSettings";

	@ConfigItem(
			position = 3,
			keyName = "hitpointsSize",
			name = "Hitpoints Bar Size",
			description = "Choose the size of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default Dimension hitpointsSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 4,
			keyName = "hitpointsFullnessDirection",
			name = "Hitpoints Fullness Direction",
			description = "Choose the direction of fullness of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default FullnessDirection hitpointsFullnessDirection()
	{
		return FullnessDirection.RIGHT;
	}

	@ConfigItem(
			position = 5,
			keyName = "hitpointsTextFormat",
			name = "Hitpoints Text Format",
			description = "Choose the formatting of the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	default TextFormatting hitpointsTextFormat()
	{
		return TextFormatting.SHOW_CURRENT_AND_MAXIMUM;
	}

	@ConfigItem(
			position = 6,
			keyName = "hitpointsTextPosition",
			name = "Hitpoints Text Position",
			description = "Choose the general location of the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	default PlacementDirection hitpointsTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 7,
			keyName = "hitpointstextOffsetX",
			name = "Hitpoints Text Offset - X axis",
			description = "Choose the X-offset for the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsTextOffsetX() { return 0; }

	@ConfigItem(
			position = 8,
			keyName = "hitpointsTextOffsetY",
			name = "Hitpoints Text Offset - Y axis",
			description = "Choose the Y-offset for the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsTextOffsetY() { return 0; }

	@ConfigItem(
			position = 9,
			keyName = "hitpointsGlowThresholdMode",
			name = "Hitpoints Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default ThresholdGlowMode hitpointsGlowThresholdMode()
	{
		return ThresholdGlowMode.BELOW_PERCENTAGE;
	}

	@ConfigItem(
			position = 10,
			keyName = "hitpointsGlowThresholdValue",
			name = "Hitpoints Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default int hitpointsGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 11,
			keyName = "hitpointsOutlineThickness",
			name = "Hitpoints Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Hitpoints bar to show regeneration.",
			section = hitpointsSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int hitpointsOutlineThickness() { return 3; }

	@ConfigItem(
			position = 12,
			keyName = "hitpointsOutlineProgressThreshold",
			name = "Hitpoints Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default OutlineProgressThreshold hitpointsOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }


	@ConfigItem(
			position = 13,
			keyName = "hitpointsIconScale",
			name = "Hitpoints Bar Icon Image Scale",
			description = "Choose the size scaling of the Hitpoints bar icon",
			section = hitpointsSettingsSection
	)
	default double hitpointsIconScale() { return 0d; }

	@ConfigItem(
			position = 14,
			keyName = "hitpointsIconPosition",
			name = "Hitpoints Bar Icon Position",
			description = "Choose the general location of the Hitpoints bar icon",
			section = hitpointsSettingsSection
	)
	default PlacementDirection hitpointsIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 15,
			keyName = "hitpointsIconOffsetX",
			name = "Hitpoints Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsIconOffsetX() { return 0; }

	@ConfigItem(
			position = 16,
			keyName = "hitpointsIconOffsetY",
			name = "Hitpoints Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsIconOffsetY() { return 0; }

	@ConfigItem(
			position = 17,
			keyName = "showPrayer",
			name = "Show Prayer",
			description = "Render Prayer bar"
	)
	default boolean renderPrayer() { return false; }

	@ConfigSection(
			position = 18,
			name = "Prayer Bar Settings",
			description = "Prayer Bar Settings"
	)
	String prayerSettingsSection = "prayerSettings";

	@ConfigItem(
			position = 19,
			keyName = "prayerSize",
			name = "Prayer Bar Size",
			description = "Choose the size of the Prayer bar",
			section = prayerSettingsSection
	)
	default Dimension prayerSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 20,
			keyName = "prayerFullnessDirection",
			name = "Prayer Fullness Direction",
			description = "Choose the direction of fullness of the Prayer bar",
			section = prayerSettingsSection
	)
	default FullnessDirection prayerFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 21,
			keyName = "prayerTextFormat",
			name = "Prayer Text Formatting",
			description = "Choose the formatting of the Prayer bar's text",
			section = prayerSettingsSection
	)
	default TextFormatting prayerTextFormat()
	{
		return TextFormatting.SHOW_CURRENT_AND_MAXIMUM;
	}

	@ConfigItem(
			position = 22,
			keyName = "prayerTextPosition",
			name = "Prayer Text Position",
			description = "Choose the general location of the Prayer bar's text",
			section = prayerSettingsSection
	)
	default PlacementDirection prayerTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 23,
			keyName = "prayerTextOffsetX",
			name = "Prayer Bar Text Offset - X axis",
			description = "The X-offset for the text of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerTextOffsetX() { return 0; }

	@ConfigItem(
			position = 24,
			keyName = "prayerTextOffsetY",
			name = "Prayer Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerTextOffsetY() { return 0; }

	@ConfigItem(
			position = 25,
			keyName = "prayerGlowThresholdMode",
			name = "Prayer Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Prayer bar",
			section = prayerSettingsSection
	)
	default ThresholdGlowMode prayerGlowThresholdMode()
	{
		return ThresholdGlowMode.BELOW_PERCENTAGE;
	}

	@ConfigItem(
			position = 26,
			keyName = "prayerGlowThresholdValue",
			name = "Prayer Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Prayer bar",
			section = prayerSettingsSection
	)
	default int prayerGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 27,
			keyName = "prayerOutlineThickness",
			name = "Prayer Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Prayer bar to show Prayer point consumption progress or Prayer Regeneration Potion regeneration.",
			section = prayerSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int prayerOutlineThickness() { return 3; }

	@ConfigItem(
			position = 28,
			keyName = "prayerOutlineProgressThreshold",
			name = "Prayer Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Prayer bar",
			section = prayerSettingsSection
	)
	default OutlineProgressThreshold prayerOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 29,
			keyName = "prayerIconScale",
			name = "Prayer Bar Icon Image Scale",
			description = "Choose the size scaling of the Prayer bar icon",
			section = prayerSettingsSection
	)
	default double prayerIconScale() { return 0d; }

	@ConfigItem(
			position = 30,
			keyName = "prayerIconPosition",
			name = "Prayer Bar Icon Position",
			description = "Choose the general location of the Prayer bar icon",
			section = prayerSettingsSection
	)
	default PlacementDirection prayerIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 31,
			keyName = "prayerIconOffsetX",
			name = "Prayer Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerIconOffsetX() { return 0; }

	@ConfigItem(
			position = 32,
			keyName = "prayerIconOffsetY",
			name = "Prayer Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerIconOffsetY() { return 0; }

	@ConfigItem(
			position = 33,
			keyName = "showEnergy",
			name = "Show Energy",
			description = "Render Run Energy bar"
	)
	default boolean renderEnergy() { return false; }

	@ConfigSection(
			position = 34,
			name = "Energy Bar Settings",
			description = "Energy Bar Settings"
	)
	String energySettingsSection = "energySettings";

	@ConfigItem(
			position = 35,
			keyName = "energySize",
			name = "Energy Bar Size",
			description = "Choose the size of the Energy bar",
			section = energySettingsSection
	)
	default Dimension energySize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 36,
			keyName = "energyFullnessDirection",
			name = "Energy Fullness Direction",
			description = "Choose the direction of fullness of the Energy bar",
			section = energySettingsSection
	)
	default FullnessDirection energyFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 37,
			keyName = "energyTexFormat",
			name = "Energy Text Formatting",
			description = "Choose the formatting of the Energy bar's text",
			section = energySettingsSection
	)
	default TextFormatting energyTextFormat()
	{
		return TextFormatting.SHOW_CURRENT;
	}

	@ConfigItem(
			position = 38,
			keyName = "energyTextPosition",
			name = "Energy Text Position",
			description = "Choose the general location of the Energy bar's text",
			section = energySettingsSection
	)
	default PlacementDirection energyTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 39,
			keyName = "energyTextOffsetX",
			name = "Energy Bar Text Offset - X axis",
			description = "The X-offset for the text of the Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyTextOffsetX() { return 0; }

	@ConfigItem(
			position = 40,
			keyName = "energyTextOffsetY",
			name = "Energy Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyTextOffsetY() { return 0; }

	@ConfigItem(
			position = 41,
			keyName = "energyGlowThresholdMode",
			name = "Energy Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Energy bar",
			section = energySettingsSection
	)
	default ThresholdGlowMode energyGlowThresholdMode()
	{
		return ThresholdGlowMode.BELOW_PERCENTAGE;
	}

	@ConfigItem(
			position = 42,
			keyName = "energyGlowThresholdValue",
			name = "Energy Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Energy bar",
			section = energySettingsSection
	)
	default int energyGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 43,
			keyName = "energyOutlineThickness",
			name = "Energy Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Energy bar to show regeneration or Stamina Potion duration.",
			section = energySettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int energyOutlineThickness() { return 3; }

	@ConfigItem(
			position = 44,
			keyName = "energyOutlineProgressThreshold",
			name = "Energy Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Energy bar",
			section = energySettingsSection
	)
	default OutlineProgressThreshold energyOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 45,
			keyName = "energyIconScale",
			name = "Energy Bar Icon Image Scale",
			description = "Choose the size scaling of the Energy bar icon",
			section = energySettingsSection
	)
	default double energyIconScale() { return 0d; }

	@ConfigItem(
			position = 46,
			keyName = "energyIconPosition",
			name = "Energy Bar Icon Position",
			description = "Choose the general location of the Energy bar icon",
			section = energySettingsSection
	)
	default PlacementDirection energyIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 47,
			keyName = "energyIconOffsetX",
			name = "Energy Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyIconOffsetX() { return 0; }

	@ConfigItem(
			position = 48,
			keyName = "energyIconOffsetY",
			name = "Energy Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyIconOffsetY() { return 0; }

	@ConfigItem(
			position = 49,
			keyName = "showSpecial",
			name = "Show Special",
			description = "Render Special Attack bar"
	)
	default boolean renderSpecial() { return false; }

	@ConfigSection(
			position = 50,
			name = "Special Bar Settings",
			description = "Special Bar Settings"
	)
	String specialSettingsSection = "specialSettings";

	@ConfigItem(
			position = 51,
			keyName = "specialSize",
			name = "Special Bar Size",
			description = "Choose the size of the Special bar",
			section = specialSettingsSection
	)
	default Dimension specialSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 52,
			keyName = "specialFullnessDirection",
			name = "Special Fullness Direction",
			description = "Choose the direction of fullness of the Special bar",
			section = specialSettingsSection
	)
	default FullnessDirection specialFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 53,
			keyName = "specialTextFormat",
			name = "Special Text Formatting",
			description = "Choose the formatting of the Special bar's text",
			section = specialSettingsSection
	)
	default TextFormatting specialTextFormat()
	{
		return TextFormatting.SHOW_CURRENT;
	}

	@ConfigItem(
			position = 54,
			keyName = "specialTextPosition",
			name = "Special Text Position",
			description = "Choose the general location of the Special bar's Text",
			section = specialSettingsSection
	)
	default PlacementDirection specialTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 55,
			keyName = "specialTextOffsetX",
			name = "Special Bar Text Offset - X axis",
			description = "The X-offset for the text of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialTextOffsetX() { return 0; }

	@ConfigItem(
			position = 56,
			keyName = "specialTextOffsetY",
			name = "Special Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialTextOffsetY() { return 0; }

	@ConfigItem(
			position = 57,
			keyName = "specialGlowThresholdMode",
			name = "Special Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Special bar",
			section = specialSettingsSection
	)
	default ThresholdGlowMode specialGlowThresholdMode()
	{
		return ThresholdGlowMode.ABOVE_PERCENTAGE;
	}

	@ConfigItem(
			position = 58,
			keyName = "specialGlowThresholdValue",
			name = "Special Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Special bar",
			section = specialSettingsSection
	)
	default int specialGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 59,
			keyName = "specialOutlineThickness",
			name = "Special Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Special bar to show regeneration.",
			section = specialSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int specialOutlineThickness() { return 3; }

	@ConfigItem(
			position = 60,
			keyName = "specialOutlineProgressThreshold",
			name = "Special Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Special bar",
			section = specialSettingsSection
	)
	default OutlineProgressThreshold specialOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 61,
			keyName = "specialIconScale",
			name = "Special Bar Icon Image Scale",
			description = "Choose the size scaling of the Special bar icon",
			section = specialSettingsSection
	)
	default double specialIconScale() { return 0d; }

	@ConfigItem(
			position = 62,
			keyName = "specialIconPosition",
			name = "Special Bar Icon Position",
			description = "Choose the general location of the Special bar icon",
			section = specialSettingsSection
	)
	default PlacementDirection specialIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 63,
			keyName = "specialIconOffsetX",
			name = "Special Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialIconOffsetX() { return 0; }

	@ConfigItem(
			position = 64,
			keyName = "specialIconOffsetY",
			name = "Special Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialIconOffsetY() { return 0; }

	@ConfigItem(
			position = 65,
			keyName = "showWarmth",
			name = "Show Warmth",
			description = "Render Warmth overlay"
	)
	default boolean renderWarmth() { return false; }

	@ConfigSection(
			position = 66,
			name = "Warmth Bar Settings",
			description = "Warmth Bar Settings"
	)
	String warmthSettingsSection = "warmthSettings";

	@ConfigItem(
			position = 67,
			keyName = "warmthSize",
			name = "Warmth Bar Size",
			description = "Choose the size of the Warmth bar",
			section = warmthSettingsSection
	)
	default Dimension warmthSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 68,
			keyName = "warmthFullnessDirection",
			name = "Warmth Fullness Direction",
			description = "Choose the direction of fullness of the Warmth bar",
			section = warmthSettingsSection
	)
	default FullnessDirection warmthFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 69,
			keyName = "warmthTextFormat",
			name = "Warmth Text Formatting",
			description = "Choose the formatting of the Warmth bar's text",
			section = warmthSettingsSection
	)
	default TextFormatting warmthTextFormat()
	{
		return TextFormatting.SHOW_CURRENT;
	}

	@ConfigItem(
			position = 70,
			keyName = "warmthTextPosition",
			name = "Warmth Text Position",
			description = "Choose the general location of the Warmth bar's Text",
			section = warmthSettingsSection
	)
	default PlacementDirection warmthTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 71,
			keyName = "warmthTextOffsetX",
			name = "Warmth Bar Text Offset - X axis",
			description = "The X-offset for the text of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthTextOffsetX() { return 0; }

	@ConfigItem(
			position = 72,
			keyName = "warmthTextOffsetY",
			name = "Warmth Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthTextOffsetY() { return 0; }

	@ConfigItem(
			position = 73,
			keyName = "warmthGlowThresholdMode",
			name = "Warmth Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Warmth bar",
			section = warmthSettingsSection
	)
	default ThresholdGlowMode warmthGlowThresholdMode()
	{
		return ThresholdGlowMode.ABOVE_PERCENTAGE;
	}

	@ConfigItem(
			position = 74,
			keyName = "warmthGlowThresholdValue",
			name = "Warmth Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Warmth bar",
			section = warmthSettingsSection
	)
	default int warmthGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 75,
			keyName = "warmthOutlineThickness",
			name = "Warmth Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Warmth bar to show regeneration (TO-DO).",
			section = warmthSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int warmthOutlineThickness() { return 3; }

	@ConfigItem(
			position = 76,
			keyName = "warmthOutlineProgressThreshold",
			name = "Warmth Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Warmth bar",
			section = warmthSettingsSection
	)
	default OutlineProgressThreshold warmthOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 77,
			keyName = "warmthIconScale",
			name = "Warmth Bar Icon Image Scale",
			description = "Choose the size scaling of the Warmth bar icon",
			section = warmthSettingsSection
	)
	default double warmthIconScale() { return 0d; }

	@ConfigItem(
			position = 78,
			keyName = "warmthIconPosition",
			name = "Warmth Bar Icon Position",
			description = "Choose the general location of the Warmth bar icon",
			section = warmthSettingsSection
	)
	default PlacementDirection warmthIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 79,
			keyName = "warmthIconOffsetX",
			name = "Warmth Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthIconOffsetX() { return 0; }

	@ConfigItem(
			position = 80,
			keyName = "warmthIconOffsetY",
			name = "Warmth Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthIconOffsetY() { return 0; }



	@ConfigItem(
			position = 81,
			keyName = "enableRestorationBars",
			name = "Show Restores",
			description = "Visually shows how much will be restored to your vital bars."
	)
	default boolean enableRestorationBars() { return true; }

	@ConfigItem(
			position = 82,
			keyName = "hideAfterCombatDelay",
			name = "Hide after combat delay",
			description = "Amount of ticks before hiding vital bars after no longer in combat. 0 = always show status bars."
	)
	@Units(Units.TICKS)
	default int hideAfterCombatDelay() { return 0; }

	@ConfigItem(
			position = 83,
			keyName = "hideWhenLargeInterfacePanelsOpen",
			name = "Hide when large UI elements are open",
			description = "Whether or not to hide the vital bars when large UI elements are open (ie Bank, Clue Scroll text)"
	)
	default boolean hideWhenLargeInterfacePanelsOpen() { return true; }

	@ConfigItem(
			position = 84,
			keyName = "hideWhenSidebarPanelClosed",
			name = "Hide when sidebar is closed",
			description = "Whether or not to hide the vital bars when sidebar is closed (ie the panel with the inventory/prayers/spells)"
	)
	default boolean hideWhenSidebarPanelClosed() { return false; }
}

package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum PlacementDirection
{
    TOP("Top"),
    BOTTOM("Bottom"),
    LEFT("Left"),
    RIGHT("Right"),
    CENTRE("Centre");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum Vital
{
    HITPOINTS(0),
    PRAYER(1),
    RUN_ENERGY(2),
    SPECIAL_ENERGY(3),
    WARMTH(4);

    private final int value;

    @Override
    public String toString()
    {
        return value + "";
    }
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Raqes <j.raqes@gmail.com>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package net.runelite.client.plugins.customvitalbars;

import java.awt.*;
import java.awt.image.BufferedImage;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class CustomVitalBarsPrayerOverlay extends OverlayPanel{

    private static final Color PRAYER_COLOR = new Color(50, 200, 200, 175);
    private static final Color ACTIVE_PRAYER_COLOR = new Color(57, 255, 186, 225);
    private static final Color PRAYER_HEAL_COLOR = new Color(57, 255, 186, 75);
    private static final Color PRAYER_REGEN_COLOR = new Color(109, 125, 119, 255);
    private static final Color ACTIVE_PRAYER_AND_PRAYER_REGEN_COLOR = new Color(120, 124, 102, 255);

    private static final int PRAYER_REGENERATION_INTERVAL_TICKS = 12;
    private static final long PRAYER_REGENERATION_INTERVAL_MILLISECONDS = (long)(PRAYER_REGENERATION_INTERVAL_TICKS * 0.6 * 1000);

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean regenPotionEffectActive = false;
    private boolean uiElementsOpen = false;
    private int prayerBonus;

    private long deltaTime;
    private long lastTime;

    private long elapsedPrayerTimeInMilliseconds;
    private double elapsedPrayerTimeInTicks;
    private double prayerConsumptionRateOrRegeneration;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    CustomVitalBarsPrayerOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager)
    {
        super(plugin);

        //setPriority(OverlayPriority.LOW);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;

        initRenderer();
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.PRAYER),
                () -> client.getBoostedSkillLevel(Skill.PRAYER),
                () -> getRestoreValue(Skill.PRAYER.getName()),
                () ->
                {
                    Color prayerColor = regenPotionEffectActive ? PRAYER_REGEN_COLOR : PRAYER_COLOR;
                    for (Prayer pray : Prayer.values())
                    {
                        if (client.isPrayerActive(pray))
                        {
                            prayerColor = regenPotionEffectActive ? ACTIVE_PRAYER_AND_PRAYER_REGEN_COLOR : ACTIVE_PRAYER_COLOR;
                            break;
                        }
                    }

                    return prayerColor;
                },
                () -> PRAYER_HEAL_COLOR,
                () -> prayerConsumptionRateOrRegeneration,
                () -> skillIconManager.getSkillImage(Skill.PRAYER, true)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        if ( !regenPotionEffectActive )
        {
            double prayerTimeCost = getCurrentPrayerTimeCost();
            if (prayerTimeCost == -1) {
                prayerConsumptionRateOrRegeneration = 0;
                elapsedPrayerTimeInMilliseconds = 0;
            } else {
                elapsedPrayerTimeInMilliseconds = (long) ((elapsedPrayerTimeInMilliseconds + deltaTime) % prayerTimeCost);
                prayerConsumptionRateOrRegeneration = 1 - elapsedPrayerTimeInMilliseconds / prayerTimeCost;
            }
        }
        else
        {
            elapsedPrayerTimeInMilliseconds = (elapsedPrayerTimeInMilliseconds + deltaTime) % PRAYER_REGENERATION_INTERVAL_MILLISECONDS;

            prayerConsumptionRateOrRegeneration = (double)elapsedPrayerTimeInMilliseconds / PRAYER_REGENERATION_INTERVAL_MILLISECONDS;
        }

        if ( config.hideWhenSidebarPanelClosed() ) {
            Viewport curViewport = null;
            Widget curWidget = null;

            for (Viewport viewport : Viewport.values()) {
                final Widget viewportWidget = client.getWidget(viewport.getViewport());
                if (viewportWidget != null && !viewportWidget.isHidden()) {
                    curViewport = viewport;
                    curWidget = viewportWidget;
                    break;
                }
            }

            if (curViewport == null) {
                return null;
            }
        }

        if ( plugin.isBarsDisplayed() && config.renderPrayer() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.PRAYER );

            return config.prayerSize();
        }

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    private boolean inLms()
    {
        return client.getWidget(ComponentID.LMS_INGAME_INFO) != null;
    }

    @Subscribe
    public void onItemContainerChanged(final ItemContainerChanged event)
    {
        final int id = event.getContainerId();
        if (id == InventoryID.EQUIPMENT.getId())
        {
            prayerBonus = totalPrayerBonus(event.getItemContainer().getItems());
        }
    }

    public void onGameTick( GameTick gameTick )
    {
        if ( !regenPotionEffectActive )
        {
            if ( isAnyPrayerActive() )
            {
                double _prayerTimeCost = getCurrentPrayerTimeCost();

                elapsedPrayerTimeInTicks = (elapsedPrayerTimeInTicks + 1) % (_prayerTimeCost / 1000 / 0.6d);
                elapsedPrayerTimeInMilliseconds = (long)((elapsedPrayerTimeInTicks * 0.6 * 1000) % _prayerTimeCost);

                prayerConsumptionRateOrRegeneration = 1 - elapsedPrayerTimeInMilliseconds / _prayerTimeCost;
            }
            else
            {
                elapsedPrayerTimeInTicks = 0;
                elapsedPrayerTimeInMilliseconds = 0;

                prayerConsumptionRateOrRegeneration = 0;
            }
        }
        else
        {
            elapsedPrayerTimeInTicks = (elapsedPrayerTimeInTicks + 1) % PRAYER_REGENERATION_INTERVAL_TICKS;
            elapsedPrayerTimeInMilliseconds = (long)((elapsedPrayerTimeInTicks * 0.6 * 1000) % PRAYER_REGENERATION_INTERVAL_MILLISECONDS);

            prayerConsumptionRateOrRegeneration = elapsedPrayerTimeInTicks / PRAYER_REGENERATION_INTERVAL_TICKS;
        }
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    @Subscribe
    protected void onVarbitChanged( VarbitChanged change )
    {
        // much love to supalosa's Prayer Regeneration Timer plugin
        if ( change.getVarbitId() == Varbits.BUFF_PRAYER_REGENERATION )
        {
            prayerConsumptionRateOrRegeneration = 0;
            elapsedPrayerTimeInTicks = 0;
            elapsedPrayerTimeInMilliseconds = 0;
            int value = change.getValue();
            regenPotionEffectActive = (value > 0);
        }
    }

    private boolean isAnyPrayerActive()
    {
        for (Prayer pray : Prayer.values())//Check if any prayers are active
        {
            if (client.isPrayerActive(pray))
            {
                return true;
            }
        }

        return false;
    }

    private int totalPrayerBonus(Item[] items)
    {
        int total = 0;
        for (Item item : items)
        {
            //ItemStats is = itemManager.getItemStats(item.getId(), false);
            ItemStats is = itemManager.getItemStats(item.getId());
            if (is != null && is.getEquipment() != null)
            {
                total += is.getEquipment().getPrayer();
            }
        }
        return total;
    }

    private int getDrainEffect(Client client)
    {
        int drainEffect = 0;

        for (PrayerType prayerType : PrayerType.values())
        {
            if (client.isPrayerActive(prayerType.getPrayer()))
            {
                drainEffect += prayerType.getDrainEffect();
            }
        }

        return drainEffect;
    }

    private double getCurrentPrayerTimeCost()
    {
        final int drainEffect = getDrainEffect(client);

        if (drainEffect == 0)
        {
            return -1;
        }

        // Calculate how many milliseconds each prayer points last so the prayer bonus can be applied
        // https://oldschool.runescape.wiki/w/Prayer#Prayer_drain_mechanics
        int drainResistance = 2 * prayerBonus + 60;
        return 1000 * 0.6d * (double)drainResistance / drainEffect;
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }
}

package net.runelite.client.plugins.customvitalbars;

import java.awt.*;
import java.awt.image.BufferedImage;
import javax.inject.Inject;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.AlternateSprites;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ImageUtil;

public class CustomVitalBarsHitpointsOverlay extends OverlayPanel{

    private static final Color HEALTH_COLOR = new Color(225, 35, 0, 125);
    private static final Color POISONED_COLOR = new Color(0, 145, 0, 150);
    private static final Color VENOMED_COLOR = new Color(0, 65, 0, 150);
    private static final Color HEAL_COLOR = new Color(255, 112, 6, 150);
    private static final Color DISEASE_COLOR = new Color(255, 193, 75, 181);
    private static final Color PARASITE_COLOR = new Color(196, 62, 109, 181);

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;

    private static final int NORMAL_HP_REGEN_TICKS = 100;

    @Getter
    private double hitpointsRegenerationPercentage;
    private int ticksSinceHPRegen;

    private long millisecondsSinceHPRegen;
    private long deltaTime;
    private long lastTime;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;
    private final Image heartDisease;
    private final Image heartPoison;
    private final Image heartVenom;

    @Inject
    CustomVitalBarsHitpointsOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager)
    {
        super(plugin);

        //setPriority(OverlayPriority.LOW);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);

        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;

        heartDisease = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.DISEASE_HEART);
        heartPoison = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.POISON_HEART);
        heartVenom = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.VENOM_HEART);

        initRenderer();
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.HITPOINTS),
                () -> client.getBoostedSkillLevel(Skill.HITPOINTS),
                () -> getRestoreValue(Skill.HITPOINTS.getName()),
                () ->
                {
                    final int poisonState = client.getVarpValue(VarPlayer.POISON);

                    if (poisonState >= 1000000)
                    {
                        return VENOMED_COLOR;
                    }

                    if (poisonState > 0)
                    {
                        return POISONED_COLOR;
                    }

                    if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0)
                    {
                        return DISEASE_COLOR;
                    }

                    if (client.getVarbitValue(Varbits.PARASITE) >= 1)
                    {
                        return PARASITE_COLOR;
                    }

                    return HEALTH_COLOR;
                },
                () -> HEAL_COLOR,
                () -> hitpointsRegenerationPercentage,
                () ->
                {
                    final int poisonState = client.getVarpValue(VarPlayer.POISON);

                    if (poisonState > 0 && poisonState < 50)
                    {
                        return heartPoison;
                    }

                    if (poisonState >= 1000000)
                    {
                        return heartVenom;
                    }

                    if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0)
                    {
                        return heartDisease;
                    }

                    return loadSprite(SpriteID.MINIMAP_ORB_HITPOINTS_ICON);
                }
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        long millisecondsPerHPRegen = (long)(NORMAL_HP_REGEN_TICKS * 0.6 * 1000);
        if (client.isPrayerActive(Prayer.RAPID_HEAL))
        {
            millisecondsPerHPRegen /= 2;
        }

        millisecondsSinceHPRegen = (millisecondsSinceHPRegen + deltaTime) % millisecondsPerHPRegen;
        hitpointsRegenerationPercentage = millisecondsSinceHPRegen / (double) millisecondsPerHPRegen;

        int currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
        int maxHP = client.getRealSkillLevel(Skill.HITPOINTS);
        if ( currentHP == maxHP && config.hitpointsOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
        {
            hitpointsRegenerationPercentage = 0;
        }
        else if ( currentHP > maxHP )
        {
            // Show it going down
            hitpointsRegenerationPercentage = 1 - hitpointsRegenerationPercentage;
        }

        if ( config.hideWhenSidebarPanelClosed() ) {
            Viewport curViewport = null;
            Widget curWidget = null;

            for (Viewport viewport : Viewport.values()) {
                final Widget viewportWidget = client.getWidget(viewport.getViewport());
                if (viewportWidget != null && !viewportWidget.isHidden()) {
                    curViewport = viewport;
                    curWidget = viewportWidget;
                    break;
                }
            }

            if (curViewport == null) {
                return null;
            }
        }

        if ( plugin.isBarsDisplayed() && config.renderHitpoints() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.HITPOINTS );
            return config.hitpointsSize();
        }

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    private boolean inLms()
    {
        return client.getWidget(ComponentID.LMS_INGAME_INFO) != null;
    }


    public void onGameStateChanged(GameStateChanged ev)
    {
        if (ev.getGameState() == GameState.HOPPING || ev.getGameState() == GameState.LOGIN_SCREEN)
        {
            ticksSinceHPRegen = -2; // For some reason this makes this accurate
            millisecondsSinceHPRegen = (long)(ticksSinceHPRegen * 0.6 * 1000);
        }
    }

    public void onVarbitChanged(VarbitChanged ev)
    {
        if (ev.getVarbitId() == Varbits.PRAYER_RAPID_HEAL)
        {
            ticksSinceHPRegen = 0;
            millisecondsSinceHPRegen = 0;
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        int ticksPerHPRegen = NORMAL_HP_REGEN_TICKS;
        if (client.isPrayerActive(Prayer.RAPID_HEAL))
        {
            ticksPerHPRegen /= 2;
        }

        ticksSinceHPRegen = (ticksSinceHPRegen + 1) % ticksPerHPRegen;
        millisecondsSinceHPRegen = (long) (ticksSinceHPRegen * 0.6 * 1000);
        hitpointsRegenerationPercentage = ticksSinceHPRegen / (double) ticksPerHPRegen;

        int currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
        int maxHP = client.getRealSkillLevel(Skill.HITPOINTS);
        if ( currentHP == maxHP && config.hitpointsOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
        {
            hitpointsRegenerationPercentage = 0;
        }
        else if ( currentHP > maxHP )
        {
            // Show it going down
            hitpointsRegenerationPercentage = 1 - hitpointsRegenerationPercentage;
        }
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }
}

/*
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2019, Rheon <https://github.com/Rheon-D>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.customvitalbars;

import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.util.function.Supplier;
import lombok.RequiredArgsConstructor;
import java.math.RoundingMode;
import java.text.DecimalFormat;

import net.runelite.api.Client;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;

@RequiredArgsConstructor
class CustomVitalBarsComponent
{
    @Inject
    private Client client;

    private static final Color BACKGROUND = new Color(0, 0, 0, 150);
    private static final Color OVERHEAL_COLOR = new Color(216, 255, 139, 150);
    private static final int BORDER_SIZE = 1;
    private static final DecimalFormat df = new DecimalFormat("0");

    private final Supplier<Integer> maxValueSupplier;
    private final Supplier<Integer> currentValueSupplier;
    private final Supplier<Integer> healSupplier;
    private final Supplier<Color> colorSupplier;
    private final Supplier<Color> healColorSupplier;
    private final Supplier<Double> timeBasedEffectCounterSupplier;
    private final Supplier<Image> iconSupplier;
    private int maxValue;
    private int currentValue;

    private boolean pulseColour = false;
    private static final int PULSE_COLOUR_ALPHA_MIN = 50;
    private static final int PULSE_COLOUR_ALPHA_MAX = 255;
    private int pulseColourAlpha = 255;
    private int pulseColourDirection = -1;
    private int pulseColourIncrement = 3;

    private PanelComponent boundingBox =  null;

    private void refreshSkills()
    {
        maxValue = maxValueSupplier.get();
        currentValue = currentValueSupplier.get();
    }

    void renderBar( CustomVitalBarsConfig config, Graphics2D graphics, PanelComponent component, Vital whichVital )
    {
        FullnessDirection dir = null;
        TextFormatting textFormat = null;
        PlacementDirection textLoc = null;
        int textOffsetX = 0, textOffsetY = 0;
        ThresholdGlowMode thresholdGlowMode = null;
        OutlineProgressThreshold thresholdOutlineProgress = null;
        int thresholdGlowValue = 0, outlineThickness = 0, width = 0, height = 0;
        double iconScale = 0d;
        PlacementDirection iconLoc = null;
        int iconOffsetX = 0, iconOffsetY = 0;

        if ( whichVital == Vital.HITPOINTS )
        {
            dir = config.hitpointsFullnessDirection();
            textFormat = config.hitpointsTextFormat();
            textLoc = config.hitpointsTextPosition();
            textOffsetX = config.hitpointsTextOffsetX();
            textOffsetY = config.hitpointsTextOffsetY();
            thresholdGlowMode = config.hitpointsGlowThresholdMode();
            thresholdOutlineProgress = config.hitpointsOutlineProgressThreshold();
            thresholdGlowValue = config.hitpointsGlowThresholdValue();
            outlineThickness = config.hitpointsOutlineThickness();
            iconScale = config.hitpointsIconScale();
            iconLoc = config.hitpointsIconPosition();
            iconOffsetX = config.hitpointsIconOffsetX();
            iconOffsetY = config.hitpointsIconOffsetY();
            width = config.hitpointsSize().width;
            height = config.hitpointsSize().height;
        }
        else if ( whichVital == Vital.PRAYER )
        {
            dir = config.prayerFullnessDirection();
            textFormat = config.prayerTextFormat();
            textLoc = config.prayerTextPosition();
            textOffsetX = config.prayerTextOffsetX();
            textOffsetY = config.prayerTextOffsetY();
            thresholdGlowMode = config.prayerGlowThresholdMode();
            thresholdOutlineProgress = config.prayerOutlineProgressThreshold();
            thresholdGlowValue = config.prayerGlowThresholdValue();
            outlineThickness = config.prayerOutlineThickness();
            iconScale = config.prayerIconScale();
            iconLoc = config.prayerIconPosition();
            iconOffsetX = config.prayerIconOffsetX();
            iconOffsetY = config.prayerIconOffsetY();
            width = config.prayerSize().width;
            height = config.prayerSize().height;
        }
        else if ( whichVital == Vital.RUN_ENERGY )
        {
            dir = config.energyFullnessDirection();
            textFormat = config.energyTextFormat();
            textLoc = config.energyTextPosition();
            textOffsetX = config.energyTextOffsetX();
            textOffsetY = config.energyTextOffsetY();
            thresholdGlowMode = config.energyGlowThresholdMode();
            thresholdOutlineProgress = config.energyOutlineProgressThreshold();
            thresholdGlowValue = config.energyGlowThresholdValue();
            outlineThickness = config.energyOutlineThickness();
            iconScale = config.energyIconScale();
            iconLoc = config.energyIconPosition();
            iconOffsetX = config.energyIconOffsetX();
            iconOffsetY = config.energyIconOffsetY();
            width = config.energySize().width;
            height = config.energySize().height;
        }
        else if ( whichVital == Vital.SPECIAL_ENERGY )
        {
            dir = config.specialFullnessDirection();
            textFormat = config.specialTextFormat();
            textLoc = config.specialTextPosition();
            textOffsetX = config.specialTextOffsetX();
            textOffsetY = config.specialTextOffsetY();
            thresholdGlowMode = config.specialGlowThresholdMode();
            thresholdOutlineProgress = config.specialOutlineProgressThreshold();
            thresholdGlowValue = config.specialGlowThresholdValue();
            outlineThickness = config.specialOutlineThickness();
            iconScale = config.specialIconScale();
            iconLoc = config.specialIconPosition();
            iconOffsetX = config.specialIconOffsetX();
            iconOffsetY = config.specialIconOffsetY();
            width = config.specialSize().width;
            height = config.specialSize().height;
        }

        if ( boundingBox == null )
        {
            boundingBox = new PanelComponent();
            component.getChildren().add( boundingBox );
        }

        boundingBox.setBorder( new Rectangle( component.getBounds().x, component.getBounds().y, width, height ) );
        boundingBox.setPreferredSize( new Dimension( width, height ) );

        if ( outlineThickness > 0 )
        {
            renderOutline( config, graphics, component, dir, outlineThickness, thresholdOutlineProgress, width, height );
        }

        // start by assuming the bar will be filled rightward
        int eX = component.getBounds().x;
        int eY = component.getBounds().y;
        int filledWidth = getBarSize(maxValue, currentValue, width);
        int filledHeight = height;

        if ( dir == FullnessDirection.TOP )
        {
            filledHeight = getBarSize( maxValue, currentValue, height );
            filledWidth = width;
            eY = height - filledHeight;
        }
        else if ( dir == FullnessDirection.BOTTOM )
        {
            filledHeight = getBarSize( maxValue, currentValue, height );
            filledWidth = width;
        }
        else if ( dir == FullnessDirection.LEFT )
        {
            eX = width - filledWidth;
        }

        //final Color fill = colorSupplier.get();
        Color fill = colorSupplier.get();

        refreshSkills();

        graphics.setColor(BACKGROUND);
        graphics.drawRect(component.getBounds().x, component.getBounds().y, width, height);
        graphics.fillRect(component.getBounds().x, component.getBounds().y, width, height );

        pulseColour = false;
        if ( thresholdGlowMode == ThresholdGlowMode.ABOVE_PERCENTAGE )
        {
            if ( currentValue * 100d / maxValue > thresholdGlowValue )
            {
                pulseColour = true;
            }
        }
        else if ( thresholdGlowMode == ThresholdGlowMode.ABOVE_FLAT_VALUE )
        {
            if ( currentValue > thresholdGlowValue )
            {
                pulseColour = true;
            }
        }
        else if ( thresholdGlowMode == ThresholdGlowMode.BELOW_PERCENTAGE )
        {
            if ( currentValue * 100d / maxValue < thresholdGlowValue )
            {
                pulseColour = true;
            }
        }
        else if ( thresholdGlowMode == ThresholdGlowMode.BELOW_FLAT_VALUE )
        {
            if ( currentValue < thresholdGlowValue )
            {
                pulseColour = true;
            }
        }

        if ( pulseColour )
        {
            pulseColourAlpha += pulseColourDirection * pulseColourIncrement;
            if ( pulseColourAlpha > PULSE_COLOUR_ALPHA_MAX )
            {
                pulseColourAlpha = PULSE_COLOUR_ALPHA_MAX;
                pulseColourDirection = -1;
            }
            else if ( pulseColourAlpha < PULSE_COLOUR_ALPHA_MIN )
            {
                pulseColourAlpha = PULSE_COLOUR_ALPHA_MIN;
                pulseColourDirection = 1;
            }
            fill = new Color( fill.getRed(), fill.getGreen(), fill.getBlue(), pulseColourAlpha );
        }

        graphics.setColor(fill);
        graphics.fillRect(eX + BORDER_SIZE,
                eY + BORDER_SIZE,
                filledWidth - BORDER_SIZE,
                filledHeight - BORDER_SIZE);

        if ( config.enableRestorationBars() )
        {
            renderRestore(config, graphics, dir, component.getBounds().x, component.getBounds().y, width, height);
        }

        if ( textFormat != TextFormatting.HIDE )
        {
            renderText(config, graphics, textFormat, textLoc, textOffsetX, textOffsetY, outlineThickness, component.getBounds().x, component.getBounds().y, width, height );
        }

        if ( iconScale > 0d )
        {
            renderIcon( config, graphics, iconScale, iconLoc, iconOffsetX, iconOffsetY, outlineThickness, component.getBounds().x, component.getBounds().y, width, height );
        }
    }

    private void renderOutline( CustomVitalBarsConfig config, Graphics2D graphics, PanelComponent component, FullnessDirection dir, int outlineSize, OutlineProgressThreshold thresholdOutlineProgress, int width, int height )
    {
        graphics.setColor( BACKGROUND );
        graphics.drawRect( component.getBounds().x - outlineSize - 1, component.getBounds().y - outlineSize - 1, width + 2 * outlineSize + BORDER_SIZE + 1, height + 2 * outlineSize + BORDER_SIZE + 1 );

        if ( thresholdOutlineProgress == OutlineProgressThreshold.ALWAYS_OFF )
        {
            return;
        }

        graphics.setColor( colorSupplier.get() );
        if ( dir == FullnessDirection.TOP )
        {
            final int fullSize = height + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( component.getBounds().x - outlineSize, component.getBounds().y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(component.getBounds().x - outlineSize, component.getBounds().y - outlineSize + (fullSize - filledCurrentSize), width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE - (fullSize - filledCurrentSize) );
            graphics.setClip( oldClip );
        }
        else if ( dir == FullnessDirection.BOTTOM )
        {
            final int fullSize = height + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( component.getBounds().x - outlineSize, component.getBounds().y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(component.getBounds().x - outlineSize, component.getBounds().y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, filledCurrentSize );
            graphics.setClip( oldClip );
        }
        else if ( dir == FullnessDirection.LEFT )
        {
            final int fullSize = width + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( component.getBounds().x - outlineSize, component.getBounds().y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(component.getBounds().x - outlineSize + (fullSize - filledCurrentSize), component.getBounds().y - outlineSize,  (fullSize - filledCurrentSize), height + 2 * outlineSize + BORDER_SIZE );
            graphics.setClip( oldClip );
        }
        else if ( dir == FullnessDirection.RIGHT )
        {
            final int fullSize = width + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( component.getBounds().x - outlineSize, component.getBounds().y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(component.getBounds().x - outlineSize, component.getBounds().y - outlineSize, filledCurrentSize, height + 2 * outlineSize + BORDER_SIZE );
            graphics.setClip( oldClip );
        }
    }

    private void renderText(CustomVitalBarsConfig config, Graphics2D graphics, TextFormatting textFormat, PlacementDirection textLoc, int textOffsetX, int textOffsetY, int outlineSize, int x, int y, int barWidth, int barHeight )
    {
        graphics.setFont(FontManager.getRunescapeSmallFont());

        String counterText = Integer.toString(currentValue);
        if ( textFormat == TextFormatting.SHOW_CURRENT_AND_MAXIMUM )
        {
            counterText = currentValue + " / " + maxValue;
        }
        else if ( textFormat == TextFormatting.SHOW_PERCENTAGE )
        {
            df.setRoundingMode( RoundingMode.DOWN );
            counterText = df.format( (float) (currentValue * 100) / maxValue ) + "%";
        }

        int sizeOfCounterX = graphics.getFontMetrics().stringWidth(counterText);
        int sizeOfCounterY = graphics.getFontMetrics().getHeight();
        int xOffset = (barWidth / 2) - (sizeOfCounterX / 2);
        int yOffset = -(int) Math.floor(outlineSize * 1.75);

        if ( textLoc == PlacementDirection.CENTRE )
        {
            xOffset = (barWidth / 2) - (sizeOfCounterX / 2);
            yOffset = (barHeight / 2) + (sizeOfCounterY / 2);
        }
        else if ( textLoc == PlacementDirection.BOTTOM )
        {
            yOffset = barHeight + sizeOfCounterY + (int) Math.floor(outlineSize * 1.75);
        }
        else if ( textLoc == PlacementDirection.LEFT )
        {
            xOffset = -(int) Math.floor(sizeOfCounterX * 1.125) - (int) Math.floor(outlineSize * 1.75);
            yOffset = (barHeight / 2) + (sizeOfCounterY / 2);
        }
        else if ( textLoc == PlacementDirection.RIGHT )
        {
            xOffset = barWidth + 4 + (int) Math.floor(outlineSize * 1.75);
            yOffset = (barHeight / 2) + (sizeOfCounterY / 2);
        }

        final TextComponent textComponent = new TextComponent();
        textComponent.setText( counterText );
        textComponent.setPosition( new Point(x + xOffset + textOffsetX, y + yOffset + textOffsetY) );
        textComponent.render( graphics );

    }
    private void renderIcon( CustomVitalBarsConfig config, Graphics2D graphics, double iconScale, PlacementDirection iconLoc, int iconOffsetX, int iconOffsetY, int outlineSize, int x, int y, int barWidth, int barHeight )
    {
        final Image icon = iconSupplier.get();
        if (icon != null)
        {
            double iconWidth  = icon.getWidth( null ) * iconScale;
            double iconHeight = icon.getHeight( null ) * iconScale;
            int xOffset = (int) ((barWidth / 2) - (iconWidth / 2));
            int yOffset = -(barHeight + (int)Math.floor(outlineSize * 1.75));
            if ( iconLoc == PlacementDirection.CENTRE )
            {
                xOffset = (int) ((barWidth / 2) - (iconWidth / 2));
                yOffset = 0;
            }
            else if ( iconLoc == PlacementDirection.BOTTOM )
            {
                yOffset = barHeight + (int) Math.floor(outlineSize * 1.75);
            }
            else if ( iconLoc == PlacementDirection.LEFT )
            {
                xOffset = -(int) Math.floor(iconWidth * 1.125) - (int) Math.floor(outlineSize * 1.75);
                yOffset = 0;
            }
            else if ( iconLoc == PlacementDirection.RIGHT )
            {
                xOffset = barWidth + 4 + (int) Math.floor(outlineSize * 1.75);
                yOffset = 0;
            }

            graphics.drawImage(icon, x + xOffset + iconOffsetX, y + yOffset + iconOffsetY, (int) iconWidth, (int) iconHeight,null);
        }
    }

    private void renderRestore(CustomVitalBarsConfig config, Graphics2D graphics, FullnessDirection dir, int x, int y, int width, int height)
    {
        final Color color = healColorSupplier.get();
        final int heal = healSupplier.get();

        if (heal <= 0)
        {
            return;
        }

        int filledCurrentSize = getBarSize(maxValue, currentValue, width);
        int filledHealSize = getBarSize(maxValue, heal, width);
        int fillX = x, fillY = y, fillWidth = width, fillHeight = height, fillThreshold = width;
        graphics.setColor(color);

        if ( dir == FullnessDirection.TOP )
        {
            fillThreshold = height;
            filledCurrentSize = getBarSize( maxValue, currentValue, height );
            filledHealSize = getBarSize( maxValue, heal, height );

            fillX = x;
            fillY = y + height - filledCurrentSize - filledHealSize;

            fillWidth = width;
            fillHeight = filledHealSize + 1;
        }
        else if ( dir == FullnessDirection.BOTTOM )
        {
            fillThreshold = height;
            filledCurrentSize = getBarSize( maxValue, currentValue, height );
            filledHealSize = getBarSize( maxValue, heal, height );

            //fillX = x;
            fillY = y + filledCurrentSize - 1;

            fillWidth = width;
            fillHeight = filledHealSize + 1;
        }
        else if ( dir == FullnessDirection.LEFT )
        {
            //fillThreshold = width;
            filledCurrentSize = getBarSize( maxValue, currentValue, width );
            filledHealSize = getBarSize( maxValue, heal, width );

            fillX = x + width - filledCurrentSize - filledHealSize;
            fillY = y;

            fillWidth = filledHealSize + 1;
            fillHeight = height;
        }
        else if ( dir == FullnessDirection.RIGHT )
        {
            //fillThreshold = width;
            filledCurrentSize = getBarSize( maxValue, currentValue, width );
            filledHealSize = getBarSize( maxValue, heal, width );

            fillX = x + filledCurrentSize - 1;
            fillY = y;

            fillWidth = filledHealSize + 1;
            fillHeight = height;
        }

        if ( filledHealSize + filledCurrentSize > fillThreshold )
        {
            graphics.setColor( OVERHEAL_COLOR );

            if ( dir == FullnessDirection.TOP )
            {
                fillHeight = height - filledCurrentSize + 1;
                fillY = y;
            }
            else if ( dir == FullnessDirection.BOTTOM )
            {
                fillHeight = height - filledCurrentSize + 1;
            }
            else if ( dir == FullnessDirection.LEFT )
            {
                fillWidth = width - filledCurrentSize + 1;
                fillX = x;
            }
            else if ( dir == FullnessDirection.RIGHT )
            {
                fillWidth = width - filledCurrentSize + 1;
            }
        }

        graphics.fillRect( fillX + BORDER_SIZE , fillY + BORDER_SIZE, fillWidth - BORDER_SIZE, fillHeight - BORDER_SIZE );
    }

    private static int getBarSize(int base, int current, int size)
    {
        final double ratio = (double) current / base;

        if (ratio >= 1)
        {
            return size;
        }

        return (int) Math.round(ratio * size);
    }

    static public Shape getOutsideEdge( Graphics gc, Rectangle bb, int top, int lft, int btm, int rgt )
    {
        int                                 ot=bb.y            , it=(ot+top);
        int                                 ol=bb.x            , il=(ol+lft);
        int                                 ob=(bb.y+bb.height), ib=(ob-btm);
        int                                 or=(bb.x+bb.width ), ir=(or-rgt);

        return new Polygon(
                new int[]{ ol, ol, or, or, ol, ol,   il, ir, ir, il, il },
                new int[]{ it, ot, ot, ob, ob, it,   it, it, ib, ib, it },
                11
        );
    }
}
package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum OutlineProgressThreshold
{
    RELATED_STAT_AT_MAX("Related stat = max"),
    ALWAYS_ON("Always progresses"),
    ALWAYS_OFF("Always disabled");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2019, Sean Dewar <https://github.com/seandewar>
 * Copyright (c) 2018, Abex
 * Copyright (c) 2018, Zimaya <https://github.com/Zimaya>
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.customvitalbars;

import javax.inject.Inject;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.itemstats.ItemStatPlugin;
import net.runelite.client.ui.overlay.OverlayManager;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.Set;

import static net.runelite.api.ItemID.*;
import static net.runelite.api.ItemID.MAX_CAPE;

@PluginDescriptor(
	name = "Custom Vital Bars",
	description = "Draws configurable bars showing HP, Prayer, special/run energy and their respective healing amounts"
)
@PluginDependency(ItemStatPlugin.class)
public class CustomVitalBarsPlugin extends Plugin
{
	@Inject
	private CustomVitalBarsHitpointsOverlay healthOverlay;
	@Inject
	private CustomVitalBarsPrayerOverlay prayerOverlay;
	@Inject
	private CustomVitalBarsEnergyOverlay energyOverlay;
	@Inject
	private CustomVitalBarsSpecialOverlay specialOverlay;
	@Inject
	private CustomVitalBarsWarmthOverlay warmthOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private CustomVitalBarsConfig config;

	@Inject
	private ClientThread clientThread;

	@Getter(AccessLevel.PACKAGE)
	private boolean barsDisplayed;
	private boolean hideWhenBigUIOpen;

	private int lastCombatActionTickCount;



	@Override
	protected void startUp() throws Exception
	{
		clientThread.invokeLater(this::checkCustomVitalBars);
		overlayManager.add( healthOverlay );
		overlayManager.add( prayerOverlay );
		overlayManager.add( energyOverlay );
		overlayManager.add( specialOverlay );
		hideWhenBigUIOpen = config.hideWhenLargeInterfacePanelsOpen();
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove( healthOverlay );
		overlayManager.remove( prayerOverlay );
		overlayManager.remove( energyOverlay );
		overlayManager.remove( specialOverlay );
		barsDisplayed = false;
	}

	@Provides
	CustomVitalBarsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CustomVitalBarsConfig.class);
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged ev)
	{
		healthOverlay.onGameStateChanged( ev );
		energyOverlay.onGameStateChanged( ev );
		specialOverlay.onGameStateChanged( ev );
	}

	@Subscribe
	public void onItemContainerChanged( ItemContainerChanged event )
	{
		specialOverlay.onItemContainerChanged( event );
		prayerOverlay.onItemContainerChanged( event );
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged ev)
	{
		healthOverlay.onVarbitChanged( ev );
		prayerOverlay.onVarbitChanged( ev );
		energyOverlay.onVarbitChanged( ev );
	}

	@Subscribe
	public void onGameTick( GameTick gameTick )
	{
		checkCustomVitalBars();
		healthOverlay.onGameTick( gameTick );
		specialOverlay.onGameTick( gameTick );
		prayerOverlay.onGameTick( gameTick );
		energyOverlay.onGameTick( gameTick );
		warmthOverlay.onGameTick( gameTick );
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (CustomVitalBarsConfig.GROUP.equals(event.getGroup()) && event.getKey().equals("hideAfterCombatDelay")) {
			clientThread.invokeLater(this::checkCustomVitalBars);
		}
		hideWhenBigUIOpen = config.hideWhenLargeInterfacePanelsOpen();
	}

	@Subscribe
	public void onWidgetLoaded( WidgetLoaded widgetLoaded )
	{
		if ( !hideWhenBigUIOpen )
		{
			return;
		}

		if (    widgetLoaded.getGroupId() == InterfaceID.BANK ||
				widgetLoaded.getGroupId() == InterfaceID.BANK_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.BANK_PIN ||
				widgetLoaded.getGroupId() == InterfaceID.DEPOSIT_BOX ||
				widgetLoaded.getGroupId() == InterfaceID.FAIRY_RING_PANEL ||
				widgetLoaded.getGroupId() == InterfaceID.SEED_VAULT_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.ACHIEVEMENT_DIARY_SCROLL ||
				widgetLoaded.getGroupId() == InterfaceID.ADVENTURE_LOG ||
				widgetLoaded.getGroupId() == InterfaceID.BARROWS_PUZZLE ||
				widgetLoaded.getGroupId() == InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_PRIVATE ||
				widgetLoaded.getGroupId() == InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_SHARED ||
				widgetLoaded.getGroupId() == InterfaceID.GROUP_STORAGE ||
				widgetLoaded.getGroupId() == InterfaceID.GROUP_STORAGE_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.GENERIC_SCROLL ||
				widgetLoaded.getGroupId() == InterfaceID.CLUESCROLL ||
				widgetLoaded.getGroupId() == InterfaceID.CLUESCROLL_REWARD ||
				widgetLoaded.getGroupId() == InterfaceID.TRADE_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.SHOP_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.DUEL_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.GRAND_EXCHANGE_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.GUIDE_PRICES_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.EQUIPMENT_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.KEPT_ON_DEATH ||
				widgetLoaded.getGroupId() == InterfaceID.COLLECTION_LOG ||
				widgetLoaded.getGroupId() == InterfaceID.KILL_LOG ||
				widgetLoaded.getGroupId() == InterfaceID.WORLD_MAP )
		{
			healthOverlay.onWidgetLoaded(widgetLoaded);
			prayerOverlay.onWidgetLoaded(widgetLoaded);
			energyOverlay.onWidgetLoaded(widgetLoaded);
			specialOverlay.onWidgetLoaded(widgetLoaded);
			warmthOverlay.onWidgetLoaded(widgetLoaded);
		}
	}

	@Subscribe
	public void onWidgetClosed( WidgetClosed widgetClosed )
	{
		healthOverlay.onWidgetClosed( widgetClosed );
		prayerOverlay.onWidgetClosed( widgetClosed );
		energyOverlay.onWidgetClosed( widgetClosed );
		specialOverlay.onWidgetClosed( widgetClosed );
		warmthOverlay.onWidgetClosed( widgetClosed );
	}

	private void checkCustomVitalBars()
	{
		final Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return;
		}

		final Actor interacting = localPlayer.getInteracting();

		if (config.hideAfterCombatDelay() == 0)
		{
			barsDisplayed = true;
		}
		else if ((interacting instanceof NPC && ArrayUtils.contains(((NPC) interacting).getComposition().getActions(), "Attack"))
			|| (interacting instanceof Player && client.getVarbitValue(Varbits.PVP_SPEC_ORB) == 1))
		{
			lastCombatActionTickCount = client.getTickCount();
			barsDisplayed = true;
		}
		else if (client.getTickCount() - lastCombatActionTickCount >= config.hideAfterCombatDelay())
		{
			barsDisplayed = false;
		}
	}
}


package net.runelite.client.plugins.customvitalbars;

import java.awt.*;
import java.awt.image.BufferedImage;
import javax.inject.Inject;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class CustomVitalBarsSpecialOverlay extends OverlayPanel{

    private static final Color SPECIAL_ATTACK_COLOR = new Color(3, 153, 0, 195);
    private static final int MAX_SPECIAL_ATTACK_VALUE = 100;

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;

    private static final int SPEC_REGEN_TICKS = 50;
    @Getter
    private double specialPercentage;

    private int ticksSinceSpecRegen;
    private boolean wearingLightbearer;

    private long millisecondsSinceSpecRegen;
    private long deltaTime;
    private long lastTime;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;

    @Inject
    CustomVitalBarsSpecialOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager)
    {
        super(plugin);

        //setPriority(OverlayPriority.LOW);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;

        initRenderer();
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> MAX_SPECIAL_ATTACK_VALUE,
                () -> client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10,
                () -> 0,
                () -> SPECIAL_ATTACK_COLOR,
                () -> SPECIAL_ATTACK_COLOR,
                () -> specialPercentage,
                () -> loadSprite(SpriteID.MINIMAP_ORB_SPECIAL_ICON)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        if ( client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) == 1000 )
        {
            millisecondsSinceSpecRegen = 0;
            specialPercentage = 0;
        }
        else
        {
            double millisecondsPerSpecRegen = wearingLightbearer ? SPEC_REGEN_TICKS / 2 : SPEC_REGEN_TICKS;
            millisecondsPerSpecRegen *= 0.6d * 1000;

            millisecondsSinceSpecRegen = (long)((millisecondsSinceSpecRegen + deltaTime) % millisecondsPerSpecRegen);
            specialPercentage = millisecondsSinceSpecRegen / millisecondsPerSpecRegen;
        }

        if ( config.hideWhenSidebarPanelClosed() ) {
            Viewport curViewport = null;
            Widget curWidget = null;

            for (Viewport viewport : Viewport.values()) {
                final Widget viewportWidget = client.getWidget(viewport.getViewport());
                if (viewportWidget != null && !viewportWidget.isHidden()) {
                    curViewport = viewport;
                    curWidget = viewportWidget;
                    break;
                }
            }

            if (curViewport == null) {
                return null;
            }
        }

        if ( plugin.isBarsDisplayed() && config.renderSpecial() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.SPECIAL_ENERGY );

            return config.specialSize();
        }

        return null;
    }

    public void onGameStateChanged(GameStateChanged ev)
    {
        if (ev.getGameState() == GameState.HOPPING || ev.getGameState() == GameState.LOGIN_SCREEN)
        {
            ticksSinceSpecRegen = 0;
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (event.getContainerId() != InventoryID.EQUIPMENT.getId())
        {
            return;
        }

        ItemContainer equipment = event.getItemContainer();
        final boolean hasLightbearer = equipment.contains(ItemID.LIGHTBEARER);
        if (hasLightbearer == wearingLightbearer)
        {
            return;
        }

        ticksSinceSpecRegen = 0;
        wearingLightbearer = hasLightbearer;
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        final int ticksPerSpecRegen = wearingLightbearer ? SPEC_REGEN_TICKS / 2 : SPEC_REGEN_TICKS;

        if ( client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) < 1000 )
        {
            ticksSinceSpecRegen = (ticksSinceSpecRegen + 1) % ticksPerSpecRegen;
            millisecondsSinceSpecRegen = (long) (ticksSinceSpecRegen * 0.6 * 1000);
        }
        else
        {
            ticksSinceSpecRegen = 0;
            millisecondsSinceSpecRegen = 0;
        }
        specialPercentage = ticksSinceSpecRegen / (double) ticksPerSpecRegen;
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }
}

/*
 * Copyright (c) 2018, Sean Dewar <https://github.com/seandewar>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.customvitalbars;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.util.Arrays;
import java.util.Set;
import java.util.function.IntPredicate;
import java.util.function.IntUnaryOperator;
import javax.inject.Inject;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.util.RSTimeUnit;

import static net.runelite.api.ItemID.*;
import static net.runelite.api.ItemID.MAX_CAPE;

public class CustomVitalBarsEnergyOverlay extends OverlayPanel
{
    // love to RunEnergyPlugin
    @Getter
    protected enum GracefulEquipmentSlot
    {
        HEAD(EquipmentInventorySlot.HEAD.getSlotIdx(), 3, GRACEFUL_HOOD),
        BODY(EquipmentInventorySlot.BODY.getSlotIdx(), 4, GRACEFUL_TOP),
        LEGS(EquipmentInventorySlot.LEGS.getSlotIdx(), 4, GRACEFUL_LEGS),
        GLOVES(EquipmentInventorySlot.GLOVES.getSlotIdx(), 3, GRACEFUL_GLOVES),
        BOOTS(EquipmentInventorySlot.BOOTS.getSlotIdx(), 3, GRACEFUL_BOOTS),
        // Agility skill capes and the non-cosmetic Max capes also count for the Graceful set effect
        CAPE(EquipmentInventorySlot.CAPE.getSlotIdx(), 3, GRACEFUL_CAPE, AGILITY_CAPE, MAX_CAPE);

        private final int index;
        private final int boost;
        private final Set<Integer> items;

        GracefulEquipmentSlot(int index, int boost, int... baseItems)
        {
            this.index = index;
            this.boost = boost;

            final ImmutableSet.Builder<Integer> itemsBuilder = ImmutableSet.builder();
            for (int item : baseItems)
            {
                itemsBuilder.addAll(ItemVariationMapping.getVariations(item));
            }
            items = itemsBuilder.build();
        }

        private static final int TOTAL_BOOSTS = Arrays.stream(values()).mapToInt(GracefulEquipmentSlot::getBoost).sum();
    }
    // Full set grants an extra 10% boost to recovery rate
    private static final int GRACEFUL_FULL_SET_BOOST_BONUS = 10;

    private static final Color ENERGY_HEAL_COLOR = new Color (199,  118, 0, 218);
    private final Color RUN_STAMINA_COLOR = new Color(160, 124, 72, 255);
    private final Color ENERGY_COLOR = new Color(199, 174, 0, 220);
    private final int MAX_RUN_ENERGY_VALUE = 100;

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;

    private double staminaDurationRemainingOrRegeneration = 0;

    private int staminaEffectActive = 0;

    private int ticksSinceRunEnergyRegen = 0;

    private int nextHighestRunEnergyMark = 0;
    private int ticksToRunEnergyRegen;
    private long millisecondsToRunEnergyRegen;

    private boolean localPlayerRunningToDestination = false;
    private boolean lastLocalPlayerRunningToDestination = false;
    private boolean regenAlreadyStarted = false;

    private int lastLocalPlayerRunEnergy = 0;

    private WorldPoint prevLocalPlayerLocation;

    private long millisecondsSinceRunEnergyRegen;
    private long deltaTime;
    private long lastTime;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;


    @Inject
    CustomVitalBarsEnergyOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager)
    {
        super(plugin);

        setPriority(OverlayPriority.HIGH);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;

        initRenderer();
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> MAX_RUN_ENERGY_VALUE,
                () -> client.getEnergy() / 100,
                () -> getRestoreValue("Run Energy"),
                () ->
                {
                    if (client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE) != 0)
                    {
                        return RUN_STAMINA_COLOR;
                    }
                    else
                    {
                        return ENERGY_COLOR;
                    }
                },
                () -> ENERGY_HEAL_COLOR,
                () -> staminaDurationRemainingOrRegeneration,
                () -> loadSprite(SpriteID.MINIMAP_ORB_WALK_ICON)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        if ( client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE) == 0 )
        {
            if ( !localPlayerRunningToDestination )
            {
                if ( client.getEnergy() == MAX_RUN_ENERGY_VALUE * 100 )
                {
                    nextHighestRunEnergyMark = 0;
                    if (config.energyOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX)
                    {
                        staminaDurationRemainingOrRegeneration = 0;
                    }
                }
                else if ( client.getEnergy() >= nextHighestRunEnergyMark )
                {
                    int rawRunEnergyRegenPerTick = (int)Math.floor( (1 + (getGracefulRecoveryBoost() / 100.0d)) * (Math.floor( client.getBoostedSkillLevel( Skill.AGILITY ) / 10.0d ) + 15));

                    nextHighestRunEnergyMark = ((client.getEnergy() + 99) / 100) * 100;

                    ticksToRunEnergyRegen = (int) (Math.ceil((nextHighestRunEnergyMark - client.getEnergy()) / (double) rawRunEnergyRegenPerTick));
                    millisecondsToRunEnergyRegen = (long)(ticksToRunEnergyRegen * 0.6 * 1000);

                    millisecondsSinceRunEnergyRegen = 0;
                    ticksSinceRunEnergyRegen = 0;
                    staminaDurationRemainingOrRegeneration = 0;
                }
                else {
                    if (millisecondsToRunEnergyRegen > 0) {
                        millisecondsSinceRunEnergyRegen = (millisecondsSinceRunEnergyRegen + deltaTime) % millisecondsToRunEnergyRegen;
                        staminaDurationRemainingOrRegeneration = millisecondsSinceRunEnergyRegen / (double) millisecondsToRunEnergyRegen;
                    } else {
                        millisecondsSinceRunEnergyRegen = 0;
                        staminaDurationRemainingOrRegeneration = 0;
                    }
                }
            }
        }

        if ( config.hideWhenSidebarPanelClosed() ) {
            Viewport curViewport = null;
            Widget curWidget = null;

            for (Viewport viewport : Viewport.values()) {
                final Widget viewportWidget = client.getWidget(viewport.getViewport());
                if (viewportWidget != null && !viewportWidget.isHidden()) {
                    curViewport = viewport;
                    curWidget = viewportWidget;
                    break;
                }
            }

            if (curViewport == null) {
                return null;
            }
        }

        if ( plugin.isBarsDisplayed() && config.renderEnergy() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.RUN_ENERGY );
            return config.energySize();
        }

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    public void onVarbitChanged( VarbitChanged event )
    {
        if (event.getVarbitId() == Varbits.RUN_SLOWED_DEPLETION_ACTIVE
                || event.getVarbitId() == Varbits.STAMINA_EFFECT
                || event.getVarbitId() == Varbits.RING_OF_ENDURANCE_EFFECT)
        {
            // staminaEffectActive is checked to match https://github.com/Joshua-F/cs2-scripts/blob/741271f0c3395048c1bad4af7881a13734516adf/scripts/%5Bproc%2Cbuff_bar_get_value%5D.cs2#L25
            staminaEffectActive = client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE);
            int staminaPotionEffectVarb = client.getVarbitValue(Varbits.STAMINA_EFFECT);
            int enduranceRingEffectVarb = client.getVarbitValue(Varbits.RING_OF_ENDURANCE_EFFECT);

            final int totalStaminaEffect = staminaPotionEffectVarb + enduranceRingEffectVarb;
            if ( staminaEffectActive == 1 )
            {
                updateStaminaTimer( totalStaminaEffect, i -> i * 10 );
            }
        }
    }

    public void onGameStateChanged(GameStateChanged ev)
    {
        if (ev.getGameState() == GameState.HOPPING || ev.getGameState() == GameState.LOGIN_SCREEN)
        {
            ticksSinceRunEnergyRegen = -2; // For some reason this makes this accurate
            millisecondsSinceRunEnergyRegen = (long)(ticksSinceRunEnergyRegen * 0.6 * 1000); // I guess I follow suit
        }
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    private void updateStaminaTimer( final int varValue, final IntUnaryOperator tickDuration )
    {
        updateStaminaTimer( varValue, i -> i == 0, tickDuration );
    }

    private void updateStaminaTimer( final int varValue, final IntPredicate removeTimerCheck, final IntUnaryOperator tickDuration )
    {
        int ticks = tickDuration.applyAsInt(varValue);
        final Duration duration = Duration.of(ticks, RSTimeUnit.GAME_TICKS);
        staminaDurationRemainingOrRegeneration = duration.getSeconds();
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if ( client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE) == 0 )
        {
            lastLocalPlayerRunningToDestination = localPlayerRunningToDestination;
            localPlayerRunningToDestination =
                    prevLocalPlayerLocation != null &&
                            client.getLocalDestinationLocation() != null &&
                            prevLocalPlayerLocation.distanceTo(client.getLocalPlayer().getWorldLocation()) > 1;
            prevLocalPlayerLocation = client.getLocalPlayer().getWorldLocation();

            if ( !localPlayerRunningToDestination && !lastLocalPlayerRunningToDestination && !regenAlreadyStarted )
            {
                ticksSinceRunEnergyRegen = 0;
                millisecondsSinceRunEnergyRegen = 0;
                staminaDurationRemainingOrRegeneration = 0;

                regenAlreadyStarted = true;
            }

            if ( localPlayerRunningToDestination )
            {
                ticksSinceRunEnergyRegen = 0;
                millisecondsSinceRunEnergyRegen = 0;
                staminaDurationRemainingOrRegeneration = 0;

                regenAlreadyStarted = false;
            }
            else
            {
                int currentRunEnergy = client.getEnergy();
                if ( currentRunEnergy == MAX_RUN_ENERGY_VALUE * 100 )
                {
                    nextHighestRunEnergyMark = 0;
                    if (config.energyOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX)
                    {
                        staminaDurationRemainingOrRegeneration = 0;
                    }
                }
                if ( currentRunEnergy >= nextHighestRunEnergyMark )
                {
                    int rawRunEnergyRegenPerTick = (int) Math.floor((1 + (getGracefulRecoveryBoost() / 100.0d)) * (Math.floor(client.getBoostedSkillLevel(Skill.AGILITY) / 10.0d ) + 15));

                    nextHighestRunEnergyMark = ((currentRunEnergy + 99) / 100) * 100;

                    ticksToRunEnergyRegen = (int)(Math.ceil((nextHighestRunEnergyMark - currentRunEnergy) / (double) rawRunEnergyRegenPerTick));
                    millisecondsToRunEnergyRegen = (long)(ticksToRunEnergyRegen * 0.6 * 1000);

                    ticksSinceRunEnergyRegen = 0;
                    millisecondsSinceRunEnergyRegen = 0;
                    staminaDurationRemainingOrRegeneration = 0;
                }
                else {
                    if (ticksToRunEnergyRegen > 0) {
                        ticksSinceRunEnergyRegen = (ticksSinceRunEnergyRegen + 1) % ticksToRunEnergyRegen;
                        millisecondsSinceRunEnergyRegen = (long) (ticksSinceRunEnergyRegen * 0.6 * 1000);
                        staminaDurationRemainingOrRegeneration = ticksSinceRunEnergyRegen / (double) ticksToRunEnergyRegen;
                    } else {
                        ticksSinceRunEnergyRegen = 0;
                        millisecondsSinceRunEnergyRegen = 0;
                        staminaDurationRemainingOrRegeneration = 0;
                    }
                }
            }
        }
    }

    private int getGracefulRecoveryBoost()
    {
        final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);

        if (equipment == null)
        {
            return 0;
        }

        final Item[] items = equipment.getItems();

        int boost = 0;

        for (final GracefulEquipmentSlot slot : GracefulEquipmentSlot.values())
        {
            if (items.length <= slot.getIndex())
            {
                continue;
            }

            final Item wornItem = items[slot.getIndex()];

            if (wornItem != null && slot.getItems().contains(wornItem.getId()))
            {
                boost += slot.getBoost();
            }
        }

        if (boost == GracefulEquipmentSlot.TOTAL_BOOSTS)
        {
            boost += GRACEFUL_FULL_SET_BOOST_BONUS;
        }

        return boost;
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }
}

package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum ThresholdGlowMode
{
    ABOVE_PERCENTAGE("Percentage, above threshold"),
    ABOVE_FLAT_VALUE("Flat value, above threshold"),
    BELOW_PERCENTAGE("Percentage, below threshold"),
    BELOW_FLAT_VALUE("Flat value, below threshold"),
    NONE("Disable glow");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum LabelPlacement
{
    TOP("Top"),
    BOTTOM("Bottom"),
    LEFT("Left"),
    RIGHT("Right"),
    CENTRE("Centre");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TextFormatting
{
    SHOW_CURRENT_AND_MAXIMUM("CURRENT / MAXIMUM"),
    SHOW_CURRENT("CURRENT"),
    SHOW_PERCENTAGE("CURRENT %"),
    HIDE("Hide label");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2018, Raqes <j.raqes@gmail.com>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Prayer;
import net.runelite.api.SpriteID;

@AllArgsConstructor
@Getter
enum PrayerType
{
	THICK_SKIN("Thick Skin", Prayer.THICK_SKIN, "+5% Defence", SpriteID.PRAYER_THICK_SKIN, false, 3),
	BURST_OF_STRENGTH("Burst of Strength", Prayer.BURST_OF_STRENGTH, "+5% Strength", SpriteID.PRAYER_BURST_OF_STRENGTH, false, 3),
	CLARITY_OF_THOUGHT("Clarity of Thought", Prayer.CLARITY_OF_THOUGHT, "+5% Attack", SpriteID.PRAYER_CLARITY_OF_THOUGHT, false, 3),
	SHARP_EYE("Sharp Eye", Prayer.SHARP_EYE, "+5% Ranged", SpriteID.PRAYER_SHARP_EYE, false, 3),
	MYSTIC_WILL("Mystic Will", Prayer.MYSTIC_WILL, "+5% Magical attack and defence", SpriteID.PRAYER_MYSTIC_WILL, false, 3),
	ROCK_SKIN("Rock Skin", Prayer.ROCK_SKIN, "+10% Defence", SpriteID.PRAYER_ROCK_SKIN, false, 6),
	SUPERHUMAN_STRENGTH("Superhuman Strength", Prayer.SUPERHUMAN_STRENGTH, "+10% Strength", SpriteID.PRAYER_SUPERHUMAN_STRENGTH, false, 6),
	IMPROVED_REFLEXES("Improved Reflexes", Prayer.IMPROVED_REFLEXES, "+10% Attack", SpriteID.PRAYER_IMPROVED_REFLEXES, false, 6),
	RAPID_RESTORE("Rapid Restore", Prayer.RAPID_RESTORE, "2 x Restore rate for all skills except Hitpoints and Prayer", SpriteID.PRAYER_RAPID_RESTORE, false, 1),
	RAPID_HEAL("Rapid Heal", Prayer.RAPID_HEAL, "2 x Restore rate for Hitpoints", SpriteID.PRAYER_RAPID_HEAL, false, 2),
	PROTECT_ITEM("Protect Item", Prayer.PROTECT_ITEM, "Player keeps 1 extra item when they die", SpriteID.PRAYER_PROTECT_ITEM, false, 2),
	HAWK_EYE("Hawk Eye", Prayer.HAWK_EYE, "+10% Ranged", SpriteID.PRAYER_HAWK_EYE, false, 6),
	MYSTIC_LORE("Mystic Lore", Prayer.MYSTIC_LORE, "+10% Magical attack and defence", SpriteID.PRAYER_MYSTIC_LORE, false, 6),
	STEEL_SKIN("Steel Skin", Prayer.STEEL_SKIN, "+15% Defence", SpriteID.PRAYER_STEEL_SKIN, false, 12),
	ULTIMATE_STRENGTH("Ultimate Strength", Prayer.ULTIMATE_STRENGTH, "+15% Strength", SpriteID.PRAYER_ULTIMATE_STRENGTH, false, 12),
	INCREDIBLE_REFLEXES("Incredible reflexes", Prayer.INCREDIBLE_REFLEXES, "+15% Attack", SpriteID.PRAYER_INCREDIBLE_REFLEXES, false, 12),
	PROTECT_FROM_MAGIC("protect from magic", Prayer.PROTECT_FROM_MAGIC, "Protects against magic attacks", SpriteID.PRAYER_PROTECT_FROM_MAGIC, true, 12),
	PROTECT_FROM_MISSILES("Protect from missiles", Prayer.PROTECT_FROM_MISSILES, "Protects against ranged attacks", SpriteID.PRAYER_PROTECT_FROM_MISSILES, true, 12),
	PROTECT_FROM_MELEE("Protect from melee", Prayer.PROTECT_FROM_MELEE, "Protects against melee attacks", SpriteID.PRAYER_PROTECT_FROM_MELEE, true, 12),
	EAGLE_EYE("Eagle Eye", Prayer.EAGLE_EYE, "+15% Ranged", SpriteID.PRAYER_EAGLE_EYE, false, 12),
	MYSTIC_MIGHT("Mystic Might", Prayer.MYSTIC_MIGHT, "+15% Magical attack and defence", SpriteID.PRAYER_MYSTIC_MIGHT, false, 12),
	RETRIBUTION("Retribution", Prayer.RETRIBUTION, "Deals damage up to 25% of your Prayer level to nearby targets upon the user's death", SpriteID.PRAYER_RETRIBUTION, true, 3),
	REDEMPTION("Redemption", Prayer.REDEMPTION, "Heals the player if they fall below 10% health", SpriteID.PRAYER_REDEMPTION, true, 6),
	SMITE("Smite", Prayer.SMITE, "Removes 1 Prayer point from an enemy for every 4 damage inflicted on the enemy", SpriteID.PRAYER_SMITE, true, 18),
	PRESERVE("Preserve", Prayer.PRESERVE, "Boosted stats last 50% longer", SpriteID.PRAYER_PRESERVE, false, 2),
	CHIVALRY("Chivalry", Prayer.CHIVALRY, "+15% Attack, +18% Strength, +20% Defence", SpriteID.PRAYER_CHIVALRY, false, 24),
	PIETY("Piety", Prayer.PIETY, "+20% Attack, +23% Strength, +25% Defence", SpriteID.PRAYER_PIETY, false, 24),
	RIGOUR("Rigour", Prayer.RIGOUR, "+20% Ranged attack, +23% Ranged strength, +25% Defence", SpriteID.PRAYER_RIGOUR, false, 24),
	AUGURY("Augury", Prayer.AUGURY, "+25% Magical attack and defence, +25% Defence", SpriteID.PRAYER_AUGURY, false, 24),

	RP_REJUVENATION("Rejuvenation", Prayer.RP_REJUVENATION, "3x Restore rate for Hitpoints", SpriteID.PRAYER_RP_REJUVENATION, false, 4),
	RP_ANCIENT_STRENGTH("Ancient Strength", Prayer.RP_ANCIENT_STRENGTH, "+20% Attack and Strength", SpriteID.PRAYER_RP_ANCIENT_STRENGTH, false, 18),
	RP_ANCIENT_SIGHT("Ancient Sight", Prayer.RP_ANCIENT_SIGHT, "+20% Ranged Attack & Strength", SpriteID.PRAYER_RP_ANCIENT_SIGHT, false, 18),
	RP_ANCIENT_WILL("Ancient Will", Prayer.RP_ANCIENT_WILL, "+20% Magic Attack", SpriteID.PRAYER_RP_ANCIENT_WILL, false, 18),
	RP_PROTECT_ITEM("Protect Item", Prayer.RP_PROTECT_ITEM, "Keep one extra item upon death", SpriteID.PRAYER_RP_PROTECT_ITEM, false, 18),
	RP_RUINOUS_GRACE("Ruinous Grace", Prayer.RP_RUINOUS_GRACE, "Prayer points are drained in place of run energy whilst running", SpriteID.PRAYER_RP_RUINOUS_GRACE, false, 1),
	RP_DAMPEN_MAGIC("Dampen Magic", Prayer.RP_DAMPEN_MAGIC, "100% protection from magic attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_MAGIC, true, 14),
	RP_DAMPEN_RANGE("Dampen Ranged", Prayer.RP_DAMPEN_RANGED, "100% protection from ranged attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_RANGED, true, 14),
	RP_DAMPEN_MELEE("Dampen Melee", Prayer.RP_DAMPEN_MELEE, "100% protection from melee attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_MELEE, true, 14),
	RP_TRINITAS("Trinitas", Prayer.RP_TRINITAS, "+15% Melee Attack and Strength, +15% Ranged Attack and Strength, and +15% Magic Attack", SpriteID.PRAYER_RP_TRINITAS, false, 22),
	RP_BERSERKER("Berserker", Prayer.RP_BERSERKER, "Boosted combat stats last 50% longer", SpriteID.PRAYER_RP_BERSERKER, false, 2),
	RP_PURGE("Purge", Prayer.RP_PURGE, "Reduces the player's and opponent's prayer points by 33% of damage dealt", SpriteID.PRAYER_RP_PURGE, true, 18),
	RP_METABOLISE("Metabolise", Prayer.RP_METABOLISE, "25 ticks (15 seconds) after activation, allows players to attack 1 tick earlier after eating a piece of food", SpriteID.PRAYER_RP_METABOLISE, false, 12),
	RP_REBUKE("Rebuke", Prayer.RP_REBUKE, "Increases recoil damage by 50%", SpriteID.PRAYER_RP_REBUKE, true, 12),
	RP_VINDICATION("Vindication", Prayer.RP_VINDICATION, "Heals the player by 25% of their base Prayer level if they fall below 10% health, draining their prayer points fully", SpriteID.PRAYER_RP_VINDICATION, true, 9),
	RP_DECIMATE("Decimate", Prayer.RP_DECIMATE, "+25% Attack, +27% Strength", SpriteID.PRAYER_RP_DECIMATE, false, 28),
	RP_ANNIHILATE("Annihilate", Prayer.RP_ANNIHILATE, "+25% Ranged Attack, +27% Ranged Strength", SpriteID.PRAYER_RP_ANNIHILATE, false, 28),
	RP_VAPORISE("Vaporise", Prayer.RP_VAPORISE, "+25% Magic Attack, +4% Magic Damage", SpriteID.PRAYER_RP_VAPORISE, false, 28),
	RP_FUMUS_VOW("Fumus' Vow", Prayer.RP_FUMUS_VOW, "Attacks that inflict poison will deal poison damage instantly", SpriteID.PRAYER_RP_FUMUS_VOW, false, 14),
	RP_UMBRAS_VOW("Umbra's Vow", Prayer.RP_UMBRA_VOW, "Attacks drain 5% of the opponent's Defence, up to 15% of their base level", SpriteID.PRAYER_RP_UMBRAS_VOW, false, 14),
	RP_CRUORS_VOW("Cruor's Vow", Prayer.RP_CRUORS_VOW, "Heals 3 Hitpoints and drains 3 Prayer points upon killing a target", SpriteID.PRAYER_RP_CRUORS_VOW, false, 14),
	RP_GLACIES_VOW("Glacies' Vow", Prayer.RP_GLACIES_VOW, "Attacks drain 5% of the opponent's Magic, up to 15% of their base level", SpriteID.PRAYER_RP_GLACIES_VOW, false, 14),
	RP_WRATH("Wrath", Prayer.RP_WRATH, "Upon death, deals damage up to 25% of the player's base Prayer level to targets in a 5x5 radius", SpriteID.PRAYER_RP_WRATH, false, 3),
	RP_INTENSIFY("Intensify", Prayer.RP_INTENSIFY, "+40% accuracy in all attack styles", SpriteID.PRAYER_RP_INTENSIFY, false, 28),
	;

	private final String name;
	private final Prayer prayer;
	private final String description;
	private final int spriteID;
	private final boolean overhead;
	private final int drainEffect;
}

package net.runelite.client.plugins.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum FullnessDirection
{
    LEFT("Left"),
    RIGHT("Right"),
    TOP("Top"),
    BOTTOM("Bottom");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2018, Sean Dewar <https://github.com/seandewar>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.customvitalbars;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.util.RSTimeUnit;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.util.Arrays;
import java.util.Set;
import java.util.function.IntPredicate;
import java.util.function.IntUnaryOperator;

import static net.runelite.api.ItemID.*;

public class CustomVitalBarsWarmthOverlay extends OverlayPanel
{
    // love to StatusBars
    private static final Color WARMTH_COLOUR = new Color(244, 97, 0);

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;

    private long deltaTime;
    private long lastTime;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;


    @Inject
    CustomVitalBarsWarmthOverlay(Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager)
    {
        super(plugin);

        setPriority(OverlayPriority.HIGH);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;

        initRenderer();
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> 100,
                () -> client.getVarbitValue(Varbits.WINTERTODT_WARMTH) / 10,
                () -> 0,
                () -> WARMTH_COLOUR,
                () -> null,
                () -> 0d,
                () -> skillIconManager.getSkillImage(Skill.FIREMAKING, true)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        if ( config.hideWhenSidebarPanelClosed() ) {
            Viewport curViewport = null;
            Widget curWidget = null;

            for (Viewport viewport : Viewport.values()) {
                final Widget viewportWidget = client.getWidget(viewport.getViewport());
                if (viewportWidget != null && !viewportWidget.isHidden()) {
                    curViewport = viewport;
                    curWidget = viewportWidget;
                    break;
                }
            }

            if (curViewport == null) {
                return null;
            }
        }

        if ( plugin.isBarsDisplayed() && config.renderEnergy() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.RUN_ENERGY );
            return config.energySize();
        }

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }
}

package com.neur0tox1n_.customvitalbars;


import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CustomVitalBarsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CustomVitalBarsPlugin.class);
		RuneLite.main(args);
	}
}
