/*
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;

@Getter
@AllArgsConstructor
enum Viewport
{
	RESIZED_BOX(ComponentID.RESIZABLE_VIEWPORT_INTERFACE_CONTAINER,
			new Point(20, -4), new Point(0, -4)),
	RESIZED_BOTTOM(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INTERFACE_CONTAINER,
			new Point(61, -12), new Point(35, -12)),
	FIXED(ComponentID.FIXED_VIEWPORT_INTERFACE_CONTAINER,
			new Point(20, -4), new Point(0, -4)),
	FIXED_BANK(ComponentID.BANK_INVENTORY_ITEM_CONTAINER,
			new Point(20, -4), new Point(0, -4));

	private final int viewport;
	private final Point offsetLeft;
	private final Point offsetRight;
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

import java.util.HashMap;
import java.util.Map;

@AllArgsConstructor
public enum SpecialEnergyRestoration
{
    SURGE_POTION_1(ItemID.SURGE_POTION1, 300000),
    SURGE_POTION_2(ItemID.SURGE_POTION2, 300000),
    SURGE_POTION_3(ItemID.SURGE_POTION3, 300000),
    SURGE_POTION_4(ItemID.SURGE_POTION4, 300000);

    @Getter
    private final int itemId;
    @Getter
    private final int cooldown;

    private static final Map<Integer, SpecialEnergyRestoration> ITEM_MAP = new HashMap<>();

    static
    {
        for (SpecialEnergyRestoration heal : SpecialEnergyRestoration.values())
        {
            ITEM_MAP.put(heal.itemId, heal);
        }
    }

    public static SpecialEnergyRestoration getSpecialRestorationByItemId(int itemId)
    {
        return ITEM_MAP.get(itemId);
    }

}

package com.neur0tox1n_.customvitalbars;

import net.runelite.client.config.*;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import java.awt.*;


@ConfigGroup("Custom Vital Bars")
public interface CustomVitalBarsConfig extends Config
{
	String GROUP = "Custom Vital Bars";

	@ConfigItem(
			position = 1,
			keyName = "showHitpoints",
			name = "Show Hitpoints",
			description = "Render Hitpoints bar"
	)
	default boolean renderHitpoints() { return false; }

	@ConfigSection(
			position = 2,
			name = "Hitpoints Bar Settings",
			description = "Hitpoints Bar Settings"
	)
	String hitpointsSettingsSection = "hitpointsSettings";

	@ConfigItem(
			position = 3,
			keyName = "hitpointsSize",
			name = "Hitpoints Bar Size",
			description = "Choose the size of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default Dimension hitpointsSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 4,
			keyName = "hitpointsFullnessDirection",
			name = "Hitpoints Fullness Direction",
			description = "Choose the direction of fullness of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default FullnessDirection hitpointsFullnessDirection()
	{
		return FullnessDirection.RIGHT;
	}

	@ConfigItem(
			position = 5,
			keyName = "hitpointsTextFormat",
			name = "Hitpoints Text Format",
			description = "Choose the formatting of the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	default TextFormatting hitpointsTextFormat()
	{
		return TextFormatting.SHOW_CURRENT_AND_MAXIMUM;
	}

	@ConfigItem(
			position = 6,
			keyName = "hitpointsTextPosition",
			name = "Hitpoints Text Position",
			description = "Choose the general location of the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	default PlacementDirection hitpointsTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 7,
			keyName = "hitpointstextOffsetX",
			name = "Hitpoints Text Offset - X axis",
			description = "Choose the X-offset for the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsTextOffsetX() { return 0; }

	@ConfigItem(
			position = 8,
			keyName = "hitpointsTextOffsetY",
			name = "Hitpoints Text Offset - Y axis",
			description = "Choose the Y-offset for the Hitpoints bar's text",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsTextOffsetY() { return 0; }

	@ConfigItem(
			position = 9,
			keyName = "hitpointsGlowThresholdMode",
			name = "Hitpoints Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default ThresholdGlowMode hitpointsGlowThresholdMode()
	{
		return ThresholdGlowMode.BELOW_PERCENTAGE;
	}

	@ConfigItem(
			position = 10,
			keyName = "hitpointsGlowThresholdValue",
			name = "Hitpoints Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default int hitpointsGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 11,
			keyName = "hitpointsOutlineThickness",
			name = "Hitpoints Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int hitpointsOutlineThickness() { return 3; }

	@ConfigItem(
			position = 12,
			keyName = "hitpointsOutlineProgressSelection",
			name = "Hitpoints Bar Outline Progress Selection",
			description = "What to show with the progress of the outline of the Hitpoints bar (natural regen / Hunter meats)",
			section = hitpointsSettingsSection
	)
	default OutlineProgressSelection hitpointsOutlineProgressSelection() { return OutlineProgressSelection.SHOW_NATURAL_AND_CONSUMABLE_PROGRESS; }

	@ConfigItem(
			position = 13,
			keyName = "hitpointsOutlineProgressThreshold",
			name = "Hitpoints Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	default OutlineProgressThreshold hitpointsOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 14,
			keyName = "hitpointsIconScale",
			name = "Hitpoints Bar Icon Image Scale",
			description = "Choose the size scaling of the Hitpoints bar icon",
			section = hitpointsSettingsSection
	)
	default double hitpointsIconScale() { return 0d; }

	@ConfigItem(
			position = 15,
			keyName = "hitpointsIconPosition",
			name = "Hitpoints Bar Icon Position",
			description = "Choose the general location of the Hitpoints bar icon",
			section = hitpointsSettingsSection
	)
	default PlacementDirection hitpointsIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 16,
			keyName = "hitpointsIconOffsetX",
			name = "Hitpoints Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsIconOffsetX() { return 0; }

	@ConfigItem(
			position = 17,
			keyName = "hitpointsIconOffsetY",
			name = "Hitpoints Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Hitpoints bar",
			section = hitpointsSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int hitpointsIconOffsetY() { return 0; }

    @ConfigItem(
            position = 18,
            keyName = "hitpointsRelativeToSidebarPanel",
            name = "Lock Hitpoints bar relative to sidebar",
            description = "Whether or not to move the Hitpoints bar relative to the sidebar (panel with inventory/prayers/spells)",
            section = hitpointsSettingsSection
    )
    default boolean hitpointsRelativeToInventory() { return false; }

    @ConfigItem(
            position = 19,
            keyName = "hideHitpointsWhenSidebarPanelClosed",
            name = "Hide Hitpoints bar when sidebar is closed",
            description = "Whether or not to hide the Hitpoints bar when sidebar is closed (panel with inventory/prayers/spells)",
            section = hitpointsSettingsSection
    )
    default boolean hideHitpointsWhenSidebarPanelClosed() { return false; }

    @ConfigItem(
            position = 20,
            keyName = "hideHitpointsAfterCombatDelay",
            name = "Hide Hitpoints bar after combat delay",
            description = "Amount of ticks after combat has ended to hide the Hitpoints bar (0 = always show)",
            section = hitpointsSettingsSection
    )
    @Units(Units.TICKS)
    default int hideHitpointsAfterCombatDelay() { return 0; }

    @Alpha
    @ConfigItem(
            position = 21,
            keyName = "hitpointsTextColour",
            name = "Hitpoints Bar - Text Colour",
            description = "Colour of the text of the Hitpoints bar",
            section = hitpointsSettingsSection
    )
    default Color hitpointsTextColour() { return Color.WHITE; }

    @ConfigItem(
            position = 22,
            keyName = "hitpointsTextOutline",
            name = "Hitpoints Bar - Text Outlining",
            description = "Whether or not to outline the text of the Hitpoints bar",
            section = hitpointsSettingsSection
    )
    default boolean hitpointsTextOutline()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
            position = 23,
            keyName = "hitpointsFramesColour",
            name = "Hitpoints Bar - Frame and Outline Frame Colour",
            description = "Colour of the Hitpoints bar Frame and Outline Frame",
            section = hitpointsSettingsSection
    )
    default Color hitpointsFramesColour() { return new Color(0, 0, 0, 255); }

    @Alpha
    @ConfigItem(
            position = 24,
            keyName = "hitpointsBackgroundColour",
            name = "Hitpoints Bar - Background Colour",
            description = "Background colour of the Hitpoints bar",
            section = hitpointsSettingsSection
    )
    default Color hitpointsBackgroundColour() { return new Color(0, 0, 0, 150); }

    @Alpha
    @ConfigItem(
            position = 25,
            keyName = "hitpointsMainColour",
            name = "Hitpoints Bar - Main Colour",
            description = "Default colour of the Hitpoints bar",
            section = hitpointsSettingsSection
    )
    default Color hitpointsMainColour()
    {
        return new Color(225, 35, 0, 175);
    }

    @Alpha
    @ConfigItem(
            position = 26,
            keyName = "hitpointsHealColour",
            name = "Hitpoints Bar - Heal Colour",
            description = "Colour of the part of the Hitpoints bar showing potential restoration",
            section = hitpointsSettingsSection
    )
    default Color hitpointsHealColour() { return new Color(255, 112, 6, 75 ); }

    @Alpha
    @ConfigItem(
            position = 27,
            keyName = "hitpointsOverhealColour",
            name = "Hitpoints Bar - Overheal Colour",
            description = "Colour of the part of the Hitpoints bar showing potential restoration when it would go over the maximum",
            section = hitpointsSettingsSection
    )
    default Color hitpointsOverhealColour() { return new Color(216, 255, 139, 75); }

    @Alpha
    @ConfigItem(
            position = 28,
            keyName = "hitpointsDelayedHealColour",
            name = "Hitpoints Bar - Delayed Heal Colour",
            description = "Colour of Hitpoints bar when a Hunter food item heal is pending",
            section = hitpointsSettingsSection
    )
    default Color hitpointsDelayedHealColour() { return new Color(255, 35, 111, 175 ); }

    @Alpha
    @ConfigItem(
            position = 29,
            keyName = "hitpointsPoisonedColour",
            name = "Hitpoints Bar - Poisoned Colour",
            description = "Colour of Hitpoints bar while Poisoned",
            section = hitpointsSettingsSection
    )
    default Color hitpointsPoisonedColour()
    {
        return new Color(0, 145, 0, 175 );
    }

    @Alpha
    @ConfigItem(
            position = 30,
            keyName = "hitpointsEnvenomedColour",
            name = "Hitpoints Bar - Envenomed Colour",
            description = "Colour of Hitpoints bar while Envenomed",
            section = hitpointsSettingsSection
    )
    default Color hitpointsEnvenomedColour() { return new Color(0, 65, 0, 175 ); }

    @Alpha
    @ConfigItem(
            position = 31,
            keyName = "hitpointsDiseasedColour",
            name = "Hitpoints Bar - Diseased Colour",
            description = "Colour of Hitpoints bar while Diseased",
            section = hitpointsSettingsSection
    )
    default Color hitpointsDiseasedColour() { return new Color(255, 193, 75, 175 ); }

    @Alpha
    @ConfigItem(
            position = 32,
            keyName = "hitpointsParasiteColour",
            name = "Hitpoints Bar - Parasite Infestation Colour",
            description = "Colour of Hitpoints bar while infested with a Parasite",
            section = hitpointsSettingsSection
    )
    default Color hitpointsParasiteColour() { return new Color(196, 62, 109, 175 ); }

    @ConfigItem(
			position = 33,
			keyName = "showPrayer",
			name = "Show Prayer",
			description = "Render Prayer bar"
	)
	default boolean renderPrayer() { return false; }

	@ConfigSection(
			position = 34,
			name = "Prayer Bar Settings",
			description = "Prayer Bar Settings"
	)
	String prayerSettingsSection = "prayerSettings";

	@ConfigItem(
			position = 35,
			keyName = "prayerSize",
			name = "Prayer Bar Size",
			description = "Choose the size of the Prayer bar",
			section = prayerSettingsSection
	)
	default Dimension prayerSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 36,
			keyName = "prayerFullnessDirection",
			name = "Prayer Fullness Direction",
			description = "Choose the direction of fullness of the Prayer bar",
			section = prayerSettingsSection
	)
	default FullnessDirection prayerFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 37,
			keyName = "prayerTextFormat",
			name = "Prayer Text Formatting",
			description = "Choose the formatting of the Prayer bar's text",
			section = prayerSettingsSection
	)
	default TextFormatting prayerTextFormat()
	{
		return TextFormatting.SHOW_CURRENT_AND_MAXIMUM;
	}

	@ConfigItem(
			position = 38,
			keyName = "prayerTextPosition",
			name = "Prayer Text Position",
			description = "Choose the general location of the Prayer bar's text",
			section = prayerSettingsSection
	)
	default PlacementDirection prayerTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 39,
			keyName = "prayerTextOffsetX",
			name = "Prayer Bar Text Offset - X axis",
			description = "The X-offset for the text of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerTextOffsetX() { return 0; }

	@ConfigItem(
			position = 40,
			keyName = "prayerTextOffsetY",
			name = "Prayer Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerTextOffsetY() { return 0; }

	@ConfigItem(
			position = 41,
			keyName = "prayerGlowThresholdMode",
			name = "Prayer Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Prayer bar",
			section = prayerSettingsSection
	)
	default ThresholdGlowMode prayerGlowThresholdMode()
	{
		return ThresholdGlowMode.BELOW_PERCENTAGE;
	}

	@ConfigItem(
			position = 42,
			keyName = "prayerGlowThresholdValue",
			name = "Prayer Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Prayer bar",
			section = prayerSettingsSection
	)
	default int prayerGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 43,
			keyName = "prayerOutlineThickness",
			name = "Prayer Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int prayerOutlineThickness() { return 3; }

	@ConfigItem(
			position = 44,
			keyName = "prayerOutlineProgressSelection",
			name = "Prayer Bar Outline Progress Selection",
			description = "What to show with the progress of the outline of the Prayer bar (Prayer degen / Prayer Regeneration Potion)",
			section = prayerSettingsSection
	)
	default OutlineProgressSelection prayerOutlineProgressSelection() { return OutlineProgressSelection.SHOW_NATURAL_AND_CONSUMABLE_PROGRESS; }

	@ConfigItem(
			position = 45,
			keyName = "prayerOutlineProgressThreshold",
			name = "Prayer Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Prayer bar",
			section = prayerSettingsSection
	)
	default OutlineProgressThreshold prayerOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 46,
			keyName = "prayerIconScale",
			name = "Prayer Bar Icon Image Scale",
			description = "Choose the size scaling of the Prayer bar icon",
			section = prayerSettingsSection
	)
	default double prayerIconScale() { return 0d; }

	@ConfigItem(
			position = 47,
			keyName = "prayerIconPosition",
			name = "Prayer Bar Icon Position",
			description = "Choose the general location of the Prayer bar icon",
			section = prayerSettingsSection
	)
	default PlacementDirection prayerIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 48,
			keyName = "prayerIconOffsetX",
			name = "Prayer Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerIconOffsetX() { return 0; }

	@ConfigItem(
			position = 49,
			keyName = "prayerIconOffsetY",
			name = "Prayer Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Prayer bar",
			section = prayerSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int prayerIconOffsetY() { return 0; }

    @ConfigItem(
            position = 50,
            keyName = "prayerRelativeToSidebarPanel",
            name = "Lock Prayer bar relative to sidebar",
            description = "Whether or not to move the Prayer bar relative to the sidebar (panel with inventory/prayers/spells)",
            section = prayerSettingsSection
    )
    default boolean prayerRelativeToInventory() { return false; }

    @ConfigItem(
            position = 51,
            keyName = "hidePrayerWhenSidebarPanelClosed",
            name = "Hide Prayer bar when sidebar is closed",
            description = "Whether or not to hide the Prayer bar when sidebar is closed (panel with inventory/prayers/spells)",
            section = prayerSettingsSection
    )
    default boolean hidePrayerWhenSidebarPanelClosed() { return false; }

    @ConfigItem(
            position = 52,
            keyName = "hidePrayerAfterCombatDelay",
            name = "Hide Prayer bar after combat delay",
            description = "Amount of ticks after combat has ended to hide the Prayer bar (0 = always show)",
            section = prayerSettingsSection
    )
    @Units(Units.TICKS)
    default int hidePrayerAfterCombatDelay() { return 0; }

    @Alpha
    @ConfigItem(
            position = 53,
            keyName = "prayerTextColour",
            name = "Prayer Bar - Text Colour",
            description = "Colour of the text of the Prayer bar",
            section = prayerSettingsSection
    )
    default Color prayerTextColour() { return Color.WHITE; }

    @ConfigItem(
            position = 54,
            keyName = "prayerTextOutline",
            name = "Prayer Bar - Text Outlining",
            description = "Whether or not to outline the text of the Prayer bar",
            section = prayerSettingsSection
    )
    default boolean prayerTextOutline()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
            position = 55,
            keyName = "prayerFramesColour",
            name = "Prayer Bar - Frame and Outline Frame Colour",
            description = "Colour of the Prayer bar Frame and Outline Frame",
            section = prayerSettingsSection
    )
    default Color prayerFramesColour() { return new Color(0, 0, 0, 255); }

    @Alpha
    @ConfigItem(
            position = 56,
            keyName = "prayerBackgroundColour",
            name = "Prayer Bar - Background Colour",
            description = "Background colour of the Prayer bar",
            section = prayerSettingsSection
    )
    default Color prayerBackgroundColour()
    {
        return new Color(0, 0, 0, 150);
    }

    @Alpha
    @ConfigItem(
            position = 57,
            keyName = "prayerMainColour",
            name = "Prayer Bar - Main Colour",
            description = "Default colour of the Prayer bar",
            section = prayerSettingsSection
    )
    default Color prayerMainColour()
    {
        return new Color(50, 200, 200, 175);
    }

    @Alpha
    @ConfigItem(
            position = 58,
            keyName = "prayerHealColour",
            name = "Prayer Bar - Heal Colour",
            description = "Colour of the part of the Prayer bar showing potential restoration",
            section = prayerSettingsSection
    )
    default Color prayerHealColour() { return new Color(57, 255, 186, 75); }

    @Alpha
    @ConfigItem(
            position = 59,
            keyName = "prayerOverhealColour",
            name = "Prayer Bar - Overheal Colour",
            description = "Colour of the part of the Prayer bar showing potential restoration when it would go over the maximum",
            section = prayerSettingsSection
    )
    default Color prayerOverhealColour() { return new Color(216, 255, 139, 75); }

    @Alpha
    @ConfigItem(
            position = 60,
            keyName = "prayerActiveColour",
            name = "Prayer Bar - Prayer Active Colour",
            description = "Colour of Prayer bar while any Prayer is active",
            section = prayerSettingsSection
    )
    default Color prayerActiveColour() { return new Color(57, 255, 186, 175); }

    @Alpha
    @ConfigItem(
            position = 61,
            keyName = "prayerRegenActiveColour",
            name = "Prayer Bar - Prayer Regeneration Potion Active",
            description = "Colour of Prayer bar while a Prayer Regeneration potion is active",
            section = prayerSettingsSection
    )
    default Color prayerRegenActiveColour() { return new Color(15, 164, 112, 175); }

    @Alpha
    @ConfigItem(
            position = 62,
            keyName = "prayerRegenPrayerActiveColour",
            name = "Prayer Bar - Prayer Active Colour While Prayer Regeneration Potion Active",
            description = "Colour of Prayer bar while any Prayer is active and a Prayer Regeneration potion is also active",
            section = prayerSettingsSection
    )
    default Color prayerRegenActivePrayerActiveColour() { return new Color(120, 124, 102, 175); }

    @ConfigItem(
			position = 63,
			keyName = "showEnergy",
			name = "Show Energy",
			description = "Render Run Energy bar"
	)
	default boolean renderEnergy() { return false; }

	@ConfigSection(
			position = 64,
			name = "Energy Bar Settings",
			description = "Run Energy Bar Settings"
	)
	String energySettingsSection = "energySettings";

	@ConfigItem(
			position = 65,
			keyName = "energySize",
			name = "Energy Bar Size",
			description = "Choose the size of the Run Energy bar",
			section = energySettingsSection
	)
	default Dimension energySize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 66,
			keyName = "energyFullnessDirection",
			name = "Energy Fullness Direction",
			description = "Choose the direction of fullness of the Run Energy bar",
			section = energySettingsSection
	)
	default FullnessDirection energyFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 67,
			keyName = "energyTexFormat",
			name = "Energy Text Formatting",
			description = "Choose the formatting of the Run Energy bar's text",
			section = energySettingsSection
	)
	default TextFormatting energyTextFormat()
	{
		return TextFormatting.SHOW_CURRENT;
	}

	@ConfigItem(
			position = 68,
			keyName = "energyTextPosition",
			name = "Energy Text Position",
			description = "Choose the general location of the Run Energy bar's text",
			section = energySettingsSection
	)
	default PlacementDirection energyTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 69,
			keyName = "energyTextOffsetX",
			name = "Energy Bar Text Offset - X axis",
			description = "The X-offset for the text of the Run Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyTextOffsetX() { return 0; }

	@ConfigItem(
			position = 70,
			keyName = "energyTextOffsetY",
			name = "Energy Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Run Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyTextOffsetY() { return 0; }

	@ConfigItem(
			position = 71,
			keyName = "energyGlowThresholdMode",
			name = "Energy Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Run Energy bar",
			section = energySettingsSection
	)
	default ThresholdGlowMode energyGlowThresholdMode()
	{
		return ThresholdGlowMode.BELOW_PERCENTAGE;
	}

	@ConfigItem(
			position = 72,
			keyName = "energyGlowThresholdValue",
			name = "Energy Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Run Energy bar",
			section = energySettingsSection
	)
	default int energyGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 73,
			keyName = "energyOutlineThickness",
			name = "Energy Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Run Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int energyOutlineThickness() { return 3; }

	@ConfigItem(
			position = 74,
			keyName = "energyOutlineProgressSelection",
			name = "Energy Bar Outline Progress Selection",
			description = "What to show with the progress of the outline of the Run Energy bar (natural regen / Stamina Potion duration)",
			section = energySettingsSection
	)
	default OutlineProgressSelection energyOutlineProgressSelection() { return OutlineProgressSelection.SHOW_NATURAL_AND_CONSUMABLE_PROGRESS; }

	@ConfigItem(
			position = 75,
			keyName = "energyOutlineProgressThreshold",
			name = "Energy Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Run Energy bar",
			section = energySettingsSection
	)
	default OutlineProgressThreshold energyOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 76,
			keyName = "energyIconScale",
			name = "Energy Bar Icon Image Scale",
			description = "Choose the size scaling of the Run Energy bar icon",
			section = energySettingsSection
	)
	default double energyIconScale() { return 0d; }

	@ConfigItem(
			position = 77,
			keyName = "energyIconPosition",
			name = "Energy Bar Icon Position",
			description = "Choose the general location of the Run Energy bar icon",
			section = energySettingsSection
	)
	default PlacementDirection energyIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 78,
			keyName = "energyIconOffsetX",
			name = "Energy Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Run Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyIconOffsetX() { return 0; }

	@ConfigItem(
			position = 79,
			keyName = "energyIconOffsetY",
			name = "Energy Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Run Energy bar",
			section = energySettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int energyIconOffsetY() { return 0; }

    @ConfigItem(
            position = 80,
            keyName = "energyRelativeToSidebarPanel",
            name = "Lock Run Energy bar relative to sidebar",
            description = "Whether or not to move the Run Energy bar relative to the sidebar (panel with inventory/prayers/spells)",
            section = energySettingsSection
    )
    default boolean energyRelativeToInventory() { return false; }

    @ConfigItem(
            position = 81,
            keyName = "hideEnergyWhenSidebarPanelClosed",
            name = "Hide Run Energy bar when sidebar is closed",
            description = "Whether or not to hide the Run Energy bar when sidebar is closed (panel with inventory/prayers/spells)",
            section = energySettingsSection
    )
    default boolean hideEnergyWhenSidebarPanelClosed() { return false; }

    @ConfigItem(
            position = 82,
            keyName = "hideEnergyAfterCombatDelay",
            name = "Hide Run Energy bar after combat delay",
            description = "Amount of ticks after combat has ended to hide the Run Energy bar (0 = always show)",
            section = energySettingsSection
    )
    @Units(Units.TICKS)
    default int hideEnergyAfterCombatDelay() { return 0; }

    @Alpha
    @ConfigItem(
            position = 83,
            keyName = "energyTextColour",
            name = "Run Energy Bar - Text Colour",
            description = "Colour of the text of the Run Energy bar",
            section = energySettingsSection
    )
    default Color energyTextColour() { return Color.WHITE; }

    @ConfigItem(
            position = 84,
            keyName = "energyTextOutline",
            name = "Run Energy Bar - Text Outlining",
            description = "Whether or not to outline the text of the Run Energy bar",
            section = energySettingsSection
    )
    default boolean energyTextOutline()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
            position = 85,
            keyName = "energyFramesColour",
            name = "Run Energy Bar - Frame and Outline Frame Colour",
            description = "Colour of the Run Energy bar Frame and Outline Frame",
            section = energySettingsSection
    )
    default Color energyFramesColour() { return new Color(0, 0, 0, 255); }

    @Alpha
    @ConfigItem(
            position = 86,
            keyName = "energyBackgroundColour",
            name = "Run Energy Bar - Background Colour",
            description = "Background colour of the Run Energy bar",
            section = energySettingsSection
    )
    default Color energyBackgroundColour()
    {
        return new Color(0, 0, 0, 150);
    }

    @Alpha
    @ConfigItem(
            position = 87,
            keyName = "energyMainColour",
            name = "Run Energy Bar - Main Colour",
            description = "Default colour of the Run Energy bar",
            section = energySettingsSection
    )
    default Color energyMainColour()
    {
        return new Color(199, 174, 0, 175);
    }

    @Alpha
    @ConfigItem(
            position = 88,
            keyName = "energyHealColour",
            name = "Run Energy Bar - Heal Colour",
            description = "Colour of the part of the Run Energy bar showing potential restoration",
            section = energySettingsSection
    )
    default Color energyHealColour() { return new Color (199,  118, 0, 75); }

    @Alpha
    @ConfigItem(
            position = 89,
            keyName = "energyOverhealColour",
            name = "Run Energy Bar - Overheal Colour",
            description = "Colour of the part of the Run Energy bar showing potential restoration when it would go over the maximum",
            section = energySettingsSection
    )
    default Color energyOverhealColour() { return new Color(216, 255, 139, 75); }

    @Alpha
    @ConfigItem(
            position = 90,
            keyName = "energyStaminaColour",
            name = "Run Energy Bar - Stamina Potion Active Colour",
            description = "Colour of Run Energy bar while a Stamina Potion is active",
            section = energySettingsSection
    )
    default Color energyStaminaColour() { return new Color(160, 124, 72, 175); };

    @ConfigItem(
			position = 91,
			keyName = "showSpecial",
			name = "Show Special",
			description = "Render Special Attack bar"
	)
	default boolean renderSpecial() { return false; }

	@ConfigSection(
			position = 92,
			name = "Special Bar Settings",
			description = "Special Bar Settings"
	)
	String specialSettingsSection = "specialSettings";

	@ConfigItem(
			position = 93,
			keyName = "specialSize",
			name = "Special Bar Size",
			description = "Choose the size of the Special bar",
			section = specialSettingsSection
	)
	default Dimension specialSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 94,
			keyName = "specialFullnessDirection",
			name = "Special Fullness Direction",
			description = "Choose the direction of fullness of the Special bar",
			section = specialSettingsSection
	)
	default FullnessDirection specialFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 95,
			keyName = "specialTextFormat",
			name = "Special Text Formatting",
			description = "Choose the formatting of the Special bar's text",
			section = specialSettingsSection
	)
	default TextFormatting specialTextFormat() { return TextFormatting.SHOW_CURRENT; }

	@ConfigItem(
			position = 96,
			keyName = "specialTextPosition",
			name = "Special Text Position",
			description = "Choose the general location of the Special bar's Text",
			section = specialSettingsSection
	)
	default PlacementDirection specialTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 97,
			keyName = "specialTextOffsetX",
			name = "Special Bar Text Offset - X axis",
			description = "The X-offset for the text of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialTextOffsetX() { return 0; }

	@ConfigItem(
			position = 98,
			keyName = "specialTextOffsetY",
			name = "Special Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialTextOffsetY() { return 0; }

	@ConfigItem(
			position = 99,
			keyName = "specialGlowThresholdMode",
			name = "Special Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Special bar",
			section = specialSettingsSection
	)
	default ThresholdGlowMode specialGlowThresholdMode()
	{
		return ThresholdGlowMode.ABOVE_PERCENTAGE;
	}

	@ConfigItem(
			position = 100,
			keyName = "specialGlowThresholdValue",
			name = "Special Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Special bar",
			section = specialSettingsSection
	)
	default int specialGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 101,
			keyName = "specialOutlineThickness",
			name = "Special Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int specialOutlineThickness() { return 3; }

	@ConfigItem(
			position = 102,
			keyName = "specialOutlineProgressSelection",
			name = "Special Bar Outline Progress Selection",
			description = "What to show with the progress of the outline of the Special bar (currently only supports natural regen)",
			section = specialSettingsSection
	)
	default OutlineProgressSelection specialOutlineProgressSelection() { return OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY; }

	@ConfigItem(
			position = 103,
			keyName = "specialOutlineProgressThreshold",
			name = "Special Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Special bar",
			section = specialSettingsSection
	)
	default OutlineProgressThreshold specialOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 104,
			keyName = "specialIconScale",
			name = "Special Bar Icon Image Scale",
			description = "Choose the size scaling of the Special bar icon",
			section = specialSettingsSection
	)
	default double specialIconScale() { return 0d; }

	@ConfigItem(
			position = 105,
			keyName = "specialIconPosition",
			name = "Special Bar Icon Position",
			description = "Choose the general location of the Special bar icon",
			section = specialSettingsSection
	)
	default PlacementDirection specialIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 106,
			keyName = "specialIconOffsetX",
			name = "Special Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialIconOffsetX() { return 0; }

	@ConfigItem(
			position = 107,
			keyName = "specialIconOffsetY",
			name = "Special Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Special bar",
			section = specialSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int specialIconOffsetY() { return 0; }

    @ConfigItem(
            position = 108,
            keyName = "specialRelativeToSidebarPanel",
            name = "Lock Special bar relative to sidebar",
            description = "Whether or not to move the Special bar relative to the sidebar (panel with inventory/prayers/spells)",
            section = specialSettingsSection
    )
    default boolean specialRelativeToInventory() { return false; }

    @ConfigItem(
            position = 109,
            keyName = "hideSpecialWhenSidebarPanelClosed",
            name = "Hide Special bar when sidebar is closed",
            description = "Whether or not to hide the Special bar when sidebar is closed (panel with inventory/prayers/spells)",
            section = specialSettingsSection
    )
    default boolean hideSpecialWhenSidebarPanelClosed() { return false; }

    @ConfigItem(
            position = 110,
            keyName = "hideSpecialAfterCombatDelay",
            name = "Hide Special bar after combat delay",
            description = "Amount of ticks after combat has ended to hide the Special bar (0 = always show)",
            section = specialSettingsSection
    )
    @Units(Units.TICKS)
    default int hideSpecialAfterCombatDelay() { return 0; }

    @Alpha
    @ConfigItem(
            position = 111,
            keyName = "specialTextColour",
            name = "Special Bar - Text Colour",
            description = "Colour of the text of the Special bar",
            section = specialSettingsSection
    )
    default Color specialTextColour() { return Color.WHITE; }

    @ConfigItem(
            position = 112,
            keyName = "specialTextOutline",
            name = "Special Bar - Text Outlining",
            description = "Whether or not to outline the text of the Special bar",
            section = specialSettingsSection
    )
    default boolean specialTextOutline()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
            position = 113,
            keyName = "specialFramesColour",
            name = "Special Bar - Frame and Outline Frame Colour",
            description = "Colour of the Special bar Frame and Outline Frame",
            section = specialSettingsSection
    )
    default Color specialFramesColour() { return new Color(0, 0, 0, 255); }

    @Alpha
    @ConfigItem(
            position = 114,
            keyName = "specialBackgroundColour",
            name = "Special Bar - Background Colour",
            description = "Background colour of the Special bar",
            section = specialSettingsSection
    )
    default Color specialBackgroundColour()
    {
        return new Color(0, 0, 0, 150);
    }

    @Alpha
    @ConfigItem(
            position = 115,
            keyName = "specialMainColour",
            name = "Special Bar - Main Colour",
            description = "Default colour of the Special bar",
            section = specialSettingsSection
    )
    default Color specialMainColour()
    {
        return new Color(3, 153, 0, 175);
    }

    @Alpha
    @ConfigItem(
            position = 116,
            keyName = "specialHealColour",
            name = "Special Bar - Heal Colour",
            description = "Colour of the part of the Special bar showing potential restoration",
            section = specialSettingsSection
    )
    default Color specialHealColour() { return new Color (2,  89, 0, 75); }

    @Alpha
    @ConfigItem(
            position = 117,
            keyName = "specialOverhealColour",
            name = "Special Bar - Overheal Colour",
            description = "Colour of the part of the Special bar showing potential restoration when it would go over the maximum",
            section = specialSettingsSection
    )
    default Color specialOverhealColour() { return new Color(216, 255, 139, 75); }

    @Alpha
    @ConfigItem(
            position = 118,
            keyName = "specialSurgeCooldownColour",
            name = "Special Bar - Surge Potion Cooldown Colour",
            description = "Colour of Special bar while Surge Potions are on cooldown",
            section = specialSettingsSection
    )
    default Color specialSurgeCooldownColour() { return new Color(106, 200, 104, 175); };

    @ConfigItem(
            position = 119,
            keyName = "showWarmthWithOptions",
            name = "Show Warmth (Conditionally?)",
            description = "Choose whether to hide, always show, or dynamically show the Warmth bar. Dynamically showing means the Warmth bar will display while the Hitpoints bar is hidden."
    )
    default WarmthRenderOptions renderWarmthWithOptions() { return WarmthRenderOptions.SHOW_DYNAMICALLY; }

    @ConfigSection(
            position = 120,
            name = "Warmth Bar Settings",
            description = "Warmth Bar Settings"
    )
    String warmthSettingsSection = "warmthSettings";

	@ConfigItem(
			position = 121,
			keyName = "warmthSize",
			name = "Warmth Bar Size",
			description = "Choose the size of the Warmth bar",
			section = warmthSettingsSection
	)
	default Dimension warmthSize() { return new Dimension(ComponentConstants.STANDARD_WIDTH, 15 ); }

	@ConfigItem(
			position = 122,
			keyName = "warmthFullnessDirection",
			name = "Warmth Fullness Direction",
			description = "Choose the direction of fullness of the Warmth bar",
			section = warmthSettingsSection
	)
	default FullnessDirection warmthFullnessDirection() { return FullnessDirection.RIGHT; }

	@ConfigItem(
			position = 123,
			keyName = "warmthTextFormat",
			name = "Warmth Text Formatting",
			description = "Choose the formatting of the Warmth bar's text",
			section = warmthSettingsSection
	)
	default TextFormatting warmthTextFormat()
	{
		return TextFormatting.SHOW_CURRENT;
	}

	@ConfigItem(
			position = 124,
			keyName = "warmthTextPosition",
			name = "Warmth Text Position",
			description = "Choose the general location of the Warmth bar's Text",
			section = warmthSettingsSection
	)
	default PlacementDirection warmthTextPosition()
	{
		return PlacementDirection.TOP;
	}

	@ConfigItem(
			position = 125,
			keyName = "warmthTextOffsetX",
			name = "Warmth Bar Text Offset - X axis",
			description = "The X-offset for the text of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthTextOffsetX() { return 0; }

	@ConfigItem(
			position = 126,
			keyName = "warmthTextOffsetY",
			name = "Warmth Bar Text Offset - Y axis",
			description = "The Y-offset for the text of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthTextOffsetY() { return 0; }

	@ConfigItem(
			position = 127,
			keyName = "warmthGlowThresholdMode",
			name = "Warmth Bar Glow Threshold Mode",
			description = "Choose how to determine the critical threshold at which to glow the Warmth bar",
			section = warmthSettingsSection
	)
	default ThresholdGlowMode warmthGlowThresholdMode()
	{
		return ThresholdGlowMode.ABOVE_PERCENTAGE;
	}

	@ConfigItem(
			position = 128,
			keyName = "warmthGlowThresholdValue",
			name = "Warmth Bar Glow Threshold Value",
			description = "Choose what value of the chosen mode to start glowing the Warmth bar",
			section = warmthSettingsSection
	)
	default int warmthGlowThresholdValue() { return 10; }

	@ConfigItem(
			position = 129,
			keyName = "warmthOutlineThickness",
			name = "Warmth Bar Outline Effects Thickness",
			description = "How thick to draw an outline around the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = 0,
			max = 5
	)
	default int warmthOutlineThickness() { return 3; }

	@ConfigItem(
			position = 130,
			keyName = "warmthOutlineProgressSelection",
			name = "Warmth Bar Outline Progress Selection",
			description = "What to show with the progress of the outline of the Warmth bar (currently only supports natural regen)",
			section = warmthSettingsSection
	)
	default OutlineProgressSelection warmthOutlineProgressSelection() { return OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY; }

	@ConfigItem(
			position = 131,
			keyName = "warmthOutlineProgressThreshold",
			name = "Warmth Bar Outline Progress Threshold",
			description = "When to stop progress on the outline of the Warmth bar",
			section = warmthSettingsSection
	)
	default OutlineProgressThreshold warmthOutlineProgressThreshold() { return OutlineProgressThreshold.RELATED_STAT_AT_MAX; }

	@ConfigItem(
			position = 132,
			keyName = "warmthIconScale",
			name = "Warmth Bar Icon Image Scale",
			description = "Choose the size scaling of the Warmth bar icon",
			section = warmthSettingsSection
	)
	default double warmthIconScale() { return 0d; }

	@ConfigItem(
			position = 133,
			keyName = "warmthIconPosition",
			name = "Warmth Bar Icon Position",
			description = "Choose the general location of the Warmth bar icon",
			section = warmthSettingsSection
	)
	default PlacementDirection warmthIconPosition() { return PlacementDirection.LEFT; }

	@ConfigItem(
			position = 134,
			keyName = "warmthIconOffsetX",
			name = "Warmth Bar Icon Offset - X axis",
			description = "The X-offset for the icon of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthIconOffsetX() { return 0; }

	@ConfigItem(
			position = 135,
			keyName = "warmthIconOffsetY",
			name = "Warmth Bar Icon Offset - Y axis",
			description = "The Y-offset for the icon of the Warmth bar",
			section = warmthSettingsSection
	)
	@Range(
			min = -9999,
			max = 9999
	)
	default int warmthIconOffsetY() { return 0; }

    @ConfigItem(
            position = 136,
            keyName = "warmthRelativeToSidebarPanel",
            name = "Lock Warmth bar relative to sidebar",
            description = "Whether or not to move the Warmth bar relative to the sidebar (panel with inventory/prayers/spells)",
            section = warmthSettingsSection
    )
    default boolean warmthRelativeToInventory() { return false; }

    @ConfigItem(
            position = 137,
            keyName = "hideWarmthWhenSidebarPanelClosed",
            name = "Hide Warmth bar when sidebar is closed",
            description = "Whether or not to hide the Warmth bar when sidebar is closed (panel with inventory/prayers/spells)",
            section = warmthSettingsSection
    )
    default boolean hideWarmthWhenSidebarPanelClosed() { return false; }

    @ConfigItem(
            position = 138,
            keyName = "hideWarmthAfterCombatDelay",
            name = "Hide Warmth bar after combat delay",
            description = "Amount of ticks after combat has ended to hide the Warmth bar (0 = always show)",
            section = warmthSettingsSection
    )
    @Units(Units.TICKS)
    default int hideWarmthAfterCombatDelay() { return 0; }

    @Alpha
    @ConfigItem(
            position = 139,
            keyName = "warmthTextColour",
            name = "Warmth Bar - Text Colour",
            description = "Colour of the text of the Warmth bar",
            section = warmthSettingsSection
    )
    default Color warmthTextColour() { return Color.WHITE; }

    @ConfigItem(
            position = 140,
            keyName = "warmthTextOutline",
            name = "Warmth Bar - Text Outlining",
            description = "Whether or not to outline the text of the Warmth bar",
            section = warmthSettingsSection
    )
    default boolean warmthTextOutline()
    {
        return false;
    }

    @Alpha
    @ConfigItem(
            position = 141,
            keyName = "warmthFramesColour",
            name = "Warmth Bar - Frame and Outline Frame Colour",
            description = "Colour of the Warmth bar Frame and Outline Frame",
            section = warmthSettingsSection
    )
    default Color warmthFramesColour() { return new Color(0, 0, 0, 255); }

    @Alpha
    @ConfigItem(
            position = 142,
            keyName = "warmthBackgroundColour",
            name = "Warmth Bar - Background Colour",
            description = "Background colour of the Warmth bar",
            section = warmthSettingsSection
    )
    default Color warmthBackgroundColour()
    {
        return new Color(0, 0, 0, 150);
    }

    @Alpha
    @ConfigItem(
            position = 143,
            keyName = "warmthMainColour",
            name = "Warmth Bar - Main Colour",
            description = "Default colour of the Warmth bar",
            section = warmthSettingsSection
    )
    default Color warmthMainColour()
    {
        return new Color(244, 97, 0, 175);
    }

    @Alpha
    @ConfigItem(
            position = 144,
            keyName = "warmthHealColour",
            name = "Warmth Bar - Heal Colour",
            description = "Colour of the part of the Warmth bar showing potential restoration",
            section = warmthSettingsSection
    )
    default Color warmthHealColour() { return new Color (187,  75, 0, 75); }

    @Alpha
    @ConfigItem(
            position = 145,
            keyName = "warmthOverhealColour",
            name = "Warmth Bar - Overheal Colour",
            description = "Colour of the part of the Warmth bar showing potential restoration when it would go over the maximum",
            section = warmthSettingsSection
    )
    default Color warmthOverhealColour() { return new Color(216, 255, 139, 75); }

    @ConfigItem(
			position = 146,
			keyName = "enableRestorationBars",
			name = "Show Restores",
			description = "Visually shows how much will be restored to your vital bars."
	)
	default boolean enableRestorationBars() { return true; }

	@ConfigItem(
			position = 147,
			keyName = "hideWhenLargeInterfacePanelsOpen",
			name = "Hide when large UI elements are open",
			description = "Whether or not to hide the vital bars when large UI elements are open (ie Bank, Clue Scroll text)"
	)
	default boolean hideWhenLargeInterfacePanelsOpen() { return true; }

    @ConfigSection(
            position = 148,
            name = "DEBUG",
            description = "various debug config variables to store coordinate data. please don't touch!"
    )
    String debugSection = "debugSection";

    @ConfigItem(
            position = 149,
            keyName = "debugSidebarPanelX",
            name = "debugSidebarPanelX",
            description = "debugSidebarPanelX",
            section = debugSection
    )
    default int debugSidebarPanelX() { return 0; }

    @ConfigItem(
            position = 150,
            keyName = "debugSidebarPanelY",
            name = "debugSidebarPanelY",
            description = "debugSidebarPanelY",
            section = debugSection
    )
    default int debugSidebarPanelY() { return 0; }

    @ConfigItem(
            position = 151,
            keyName = "debugEnergyDeltaX",
            name = "debugEnergyDeltaX",
            description = "debugEnergyDeltaX",
            section = debugSection
    )
    default int debugEnergyDeltaX() { return 0; }

    @ConfigItem(
            position = 152,
            keyName = "debugEnergyDeltaY",
            name = "debugEnergyDeltaY",
            description = "debugEnergyDeltaY",
            section = debugSection
    )
    default int debugEnergyDeltaY() { return 0; }

    @ConfigItem(
            position = 153,
            keyName = "debugHitpointsDeltaX",
            name = "debugHitpointsDeltaX",
            description = "debugHitpointsDeltaX",
            section = debugSection
    )
    default int debugHitpointsDeltaX() { return 0; }

    @ConfigItem(
            position = 154,
            keyName = "debugHitpointsDeltaY",
            name = "debugHitpointsDeltaY",
            description = "debugHitpointsDeltaY",
            section = debugSection
    )
    default int debugHitpointsDeltaY() { return 0; }

    @ConfigItem(
            position = 155,
            keyName = "debugPrayerDeltaX",
            name = "debugPrayerDeltaX",
            description = "debugPrayerDeltaX",
            section = debugSection
    )
    default int debugPrayerDeltaX() { return 0; }

    @ConfigItem(
            position = 156,
            keyName = "debugPrayerDeltaY",
            name = "debugPrayerDeltaY",
            description = "debugPrayerDeltaY",
            section = debugSection
    )
    default int debugPrayerDeltaY() { return 0; }

    @ConfigItem(
            position = 157,
            keyName = "debugSpecialDeltaX",
            name = "debugSpecialDeltaX",
            description = "debugSpecialDeltaX",
            section = debugSection
    )
    default int debugSpecialDeltaX() { return 0; }

    @ConfigItem(
            position = 158,
            keyName = "debugSpecialDeltaY",
            name = "debugSpecialDeltaY",
            description = "debugSpecialDeltaY",
            section = debugSection
    )
    default int debugSpecialDeltaY() { return 0; }

    @ConfigItem(
            position = 159,
            keyName = "debugWarmthDeltaX",
            name = "debugWarmthDeltaX",
            description = "debugWarmthDeltaX",
            section = debugSection
    )
    default int debugWarmthDeltaX() { return 0; }

    @ConfigItem(
            position = 160,
            keyName = "debugWarmthDeltaY",
            name = "debugWarmthDeltaY",
            description = "debugWarmthDeltaY",
            section = debugSection
    )
    default int debugWarmthDeltaY() { return 0; }
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum PlacementDirection
{
    TOP("Top"),
    BOTTOM("Bottom"),
    LEFT("Left"),
    RIGHT("Right"),
    CENTRE("Centre");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;
import net.runelite.client.ui.overlay.infobox.Timer;

import java.time.Duration;
import java.time.temporal.ChronoUnit;

class TimerTimer extends Timer
{
	private final GameTimer timer;
	int ticks;

	TimerTimer(GameTimer timer, Duration duration, Plugin plugin)
	{
		super(duration.toMillis(), ChronoUnit.MILLIS, null, plugin);
		this.timer = timer;
		setPriority(InfoBoxPriority.MED);
	}

	public GameTimer getTimer()
	{
		return timer;
	}

	@Override
	public String getName()
	{
		return timer.name();
	}
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum Vital
{
    HITPOINTS(0),
    PRAYER(1),
    RUN_ENERGY(2),
    SPECIAL_ENERGY(3),
    WARMTH(4);

    private final int value;

    @Override
    public String toString()
    {
        return value + "";
    }
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Raqes <j.raqes@gmail.com>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.neur0tox1n_.customvitalbars;

import java.awt.*;
import java.awt.image.BufferedImage;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class CustomVitalBarsPrayerOverlay extends OverlayPanel{

    private static final int PRAYER_REGENERATION_INTERVAL_TICKS = 12;
    private static final long PRAYER_REGENERATION_INTERVAL_MILLISECONDS = (long)(PRAYER_REGENERATION_INTERVAL_TICKS * 0.6 * 1000);

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean regenPotionEffectActive = false;
    private boolean uiElementsOpen = false;
    private int prayerBonus;

    private long deltaTime;
    private long lastTime;

    private long elapsedPrayerTimeInMilliseconds;
    private double elapsedPrayerTimeInTicks;
    private double prayerConsumptionRateOrRegeneration;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;

    private int deltaX = 0, deltaY = 0;
    private int lastKnownSidebarX = 0, lastKnownSidebarY = 0;
    private int lastX = 0, lastY = 0;

    private Color prayerMainColour, prayerHealColour, prayerActiveColour, prayerRegenActiveColour, prayerRegenActivePrayerActiveColour;

    private int lastPrayerValue = 0;

    @Inject
    private OverlayManager overlayManager;

    private final ConfigManager configManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    CustomVitalBarsPrayerOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager, ConfigManager configManager )
    {
        super(plugin);

        //setPriority(OverlayPriority.LOW);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;
        this.configManager = configManager;

        lastKnownSidebarX = config.debugSidebarPanelX();
        lastKnownSidebarY = config.debugSidebarPanelY();

        prayerMainColour = config.prayerMainColour();
        prayerHealColour = config.prayerHealColour();
        prayerActiveColour = config.prayerActiveColour();
        prayerRegenActiveColour = config.prayerRegenActiveColour();
        prayerRegenActivePrayerActiveColour = config.prayerRegenActivePrayerActiveColour();

        initRenderer();

        if ( config.prayerRelativeToInventory() )
        {
            toggleLock( true );
        }
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.PRAYER),
                () -> client.getBoostedSkillLevel(Skill.PRAYER),
                () -> getRestoreValue(Skill.PRAYER.getName()),
                () ->
                {
                    OutlineProgressSelection outlineOption = config.prayerOutlineProgressSelection();
                    Color prayerColor = (outlineOption == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY ? prayerMainColour : (regenPotionEffectActive ? prayerRegenActiveColour : prayerMainColour));
                    for (Prayer pray : Prayer.values())
                    {
                        if (client.isPrayerActive(pray))
                        {
                            prayerColor = (outlineOption == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY ? prayerActiveColour : (regenPotionEffectActive ? prayerRegenActiveColour : prayerActiveColour));

                            break;
                        }
                    }

                    return prayerColor;
                },
                () -> prayerHealColour,
                () -> prayerConsumptionRateOrRegeneration,
                () -> skillIconManager.getSkillImage(Skill.PRAYER, true)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        if ( !regenPotionEffectActive || (config.prayerOutlineProgressSelection() == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY) )
        {
            double prayerTimeCost = getCurrentPrayerTimeCost();
            if (prayerTimeCost == -1) {
                prayerConsumptionRateOrRegeneration = 0;
                elapsedPrayerTimeInMilliseconds = 0;
            } else {
                elapsedPrayerTimeInMilliseconds = (long) ((elapsedPrayerTimeInMilliseconds + deltaTime) % prayerTimeCost);
                prayerConsumptionRateOrRegeneration = 1 - elapsedPrayerTimeInMilliseconds / prayerTimeCost;
            }
        }
        else
        {
            elapsedPrayerTimeInMilliseconds = (elapsedPrayerTimeInMilliseconds + deltaTime) % PRAYER_REGENERATION_INTERVAL_MILLISECONDS;

            prayerConsumptionRateOrRegeneration = (double)elapsedPrayerTimeInMilliseconds / PRAYER_REGENERATION_INTERVAL_MILLISECONDS;
        }

        Viewport curViewport = null;
        Widget curWidget = null;

        for (Viewport viewport : Viewport.values())
        {
            final Widget viewportWidget = client.getWidget(viewport.getViewport());
            if ( viewportWidget != null )
            {
                if ( !viewportWidget.isHidden() )
                {
                    curViewport = viewport;
                    curWidget = viewportWidget;

                    final net.runelite.api.Point location = viewportWidget.getCanvasLocation();
                    lastKnownSidebarX = location.getX();
                    lastKnownSidebarY = location.getY();

                    break;
                }
            }
        }

        if ( config.hidePrayerWhenSidebarPanelClosed() )
        {
            if (curViewport == null)
            {
                return null;
            }
        }

        if ( config.prayerRelativeToInventory() )
        {
            if (curViewport != null)
            {
                final net.runelite.api.Point location = curWidget.getCanvasLocation();

                if ( deltaX != 0 && deltaY != 0 )
                {
                    int newDeltaX = (int) (location.getX() + deltaX);
                    int newDeltaY = (int) (location.getY() + deltaY);
                    this.setPreferredLocation( new java.awt.Point(newDeltaX, newDeltaY) );

                    if ( lastX != newDeltaX || lastY != newDeltaY )
                    {
                        overlayManager.saveOverlay(this);
                    }
                    lastX = newDeltaX;
                    lastY = newDeltaY;
                }
            }
        }

        if ( plugin.isPrayerDisplayed() && config.renderPrayer() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.PRAYER, regenPotionEffectActive, client );

            return config.prayerSize();
        }

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    private boolean inLms()
    {
        return client.getWidget(ComponentID.LMS_INGAME_INFO) != null;
    }

    @Subscribe
    public void onItemContainerChanged(final ItemContainerChanged event)
    {
        final int id = event.getContainerId();
        if (id == InventoryID.EQUIPMENT.getId())
        {
            prayerBonus = totalPrayerBonus(event.getItemContainer().getItems());
        }
    }

    @Subscribe
    public void onConfigChanged( ConfigChanged event )
    {
        if ( CustomVitalBarsConfig.GROUP.equals(event.getGroup()) && event.getKey().equals("prayerRelativeToSidebarPanel") )
        {
            toggleLock( false );
        }
        else if ( event.getKey().equals("prayerMainColour") )
        {
            prayerMainColour = config.prayerMainColour();
        }
        else if ( event.getKey().equals("prayerHealColour") )
        {
            prayerHealColour = config.prayerHealColour();
        }
        else if ( event.getKey().equals("prayerActiveColour") )
        {
            prayerActiveColour = config.prayerActiveColour();
        }
        else if ( event.getKey().equals("prayerRegenActiveColour") )
        {
            prayerRegenActiveColour = config.prayerRegenActiveColour();
        }
        else if ( event.getKey().equals("prayerRegenActivePrayerActiveColour") )
        {
            prayerRegenActivePrayerActiveColour = config.prayerRegenActivePrayerActiveColour();
        }
    }

    @Subscribe
    public void onGameTick( GameTick gameTick )
    {
        if ( !regenPotionEffectActive || (config.prayerOutlineProgressSelection() == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY) )
        {
            if ( isAnyPrayerActive() )
            {
                if ( lastPrayerValue != client.getBoostedSkillLevel(Skill.PRAYER) )
                {
                    elapsedPrayerTimeInTicks = 0;
                    elapsedPrayerTimeInMilliseconds = 0;

                    prayerConsumptionRateOrRegeneration = 0;
                }
                else
                {
                    double _prayerTimeCost = getCurrentPrayerTimeCost();

                    elapsedPrayerTimeInTicks = (elapsedPrayerTimeInTicks + 1) % (_prayerTimeCost / 1000 / 0.6d);
                    elapsedPrayerTimeInMilliseconds = (long)((elapsedPrayerTimeInTicks * 0.6 * 1000) % _prayerTimeCost);

                    prayerConsumptionRateOrRegeneration = 1 - elapsedPrayerTimeInMilliseconds / _prayerTimeCost;
                }
                lastPrayerValue = client.getBoostedSkillLevel(Skill.PRAYER);
            }
            else
            {
                elapsedPrayerTimeInTicks = 0;
                elapsedPrayerTimeInMilliseconds = 0;

                prayerConsumptionRateOrRegeneration = 0;
            }
        }
        else
        {
            elapsedPrayerTimeInTicks = (elapsedPrayerTimeInTicks + 1) % PRAYER_REGENERATION_INTERVAL_TICKS;
            elapsedPrayerTimeInMilliseconds = (long)((elapsedPrayerTimeInTicks * 0.6 * 1000) % PRAYER_REGENERATION_INTERVAL_MILLISECONDS);

            prayerConsumptionRateOrRegeneration = elapsedPrayerTimeInTicks / PRAYER_REGENERATION_INTERVAL_TICKS;
        }
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    @Subscribe
    protected void onVarbitChanged( VarbitChanged change )
    {
        // much love to supalosa's Prayer Regeneration Timer plugin
        if ( change.getVarbitId() == Varbits.BUFF_PRAYER_REGENERATION )
        {
            prayerConsumptionRateOrRegeneration = 0;
            elapsedPrayerTimeInTicks = 0;
            elapsedPrayerTimeInMilliseconds = 0;
            int value = change.getValue();
            regenPotionEffectActive = (value > 0);
        }
    }

    private boolean isAnyPrayerActive()
    {
        for (Prayer pray : Prayer.values())//Check if any prayers are active
        {
            if (client.isPrayerActive(pray))
            {
                return true;
            }
        }

        return false;
    }

    private int totalPrayerBonus(Item[] items)
    {
        int total = 0;
        for (Item item : items)
        {
            //ItemStats is = itemManager.getItemStats(item.getId(), false);
            ItemStats is = itemManager.getItemStats(item.getId());
            if (is != null && is.getEquipment() != null)
            {
                total += is.getEquipment().getPrayer();
            }
        }
        return total;
    }

    private int getDrainEffect(Client client)
    {
        int drainEffect = 0;

        for (PrayerType prayerType : PrayerType.values())
        {
            if (client.isPrayerActive(prayerType.getPrayer()))
            {
                drainEffect += prayerType.getDrainEffect();
            }
        }

        return drainEffect;
    }

    private double getCurrentPrayerTimeCost()
    {
        final int drainEffect = getDrainEffect(client);

        if (drainEffect == 0)
        {
            return -1;
        }

        // Calculate how many milliseconds each prayer points last so the prayer bonus can be applied
        // https://oldschool.runescape.wiki/w/Prayer#Prayer_drain_mechanics
        int drainResistance = 2 * prayerBonus + 60;
        return 1000 * 0.6d * (double)drainResistance / drainEffect;
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }

    public void toggleLock( boolean start )
    {
        if ( deltaX == 0 && deltaY == 0 )
        {
            if ( start )
            {
                deltaX = config.debugPrayerDeltaX();
                deltaY = config.debugPrayerDeltaY();
            }
            else
            {
                deltaX = (int) (this.getPreferredLocation().getX() - lastKnownSidebarX);
                deltaY = (int) (this.getPreferredLocation().getY() - lastKnownSidebarY);
            }
        }
        else
        {
            deltaX = 0;
            deltaY = 0;
        }
        configManager.setConfiguration( "Custom Vital Bars", "debugPrayerDeltaX", (int) deltaX );
        configManager.setConfiguration( "Custom Vital Bars", "debugPrayerDeltaY", (int) deltaY );
    }
}

// credits to DapperMickie for DelayedHeals code

package com.neur0tox1n_.customvitalbars;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.AlternateSprites;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

public class CustomVitalBarsHitpointsOverlay extends OverlayPanel{

    private static final int WINTERTODT_REGION = 6462;

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;
    private boolean isWearingHPCape = false;
    private boolean isWearingRegenBracelet = false;

    private static final int NORMAL_HP_REGEN_TICKS = 100;

    @Getter
    private double hitpointsRegenerationPercentage, hitpointsRecoveryPercentage;
    private int ticksSinceHPRegen, ticksToDelayedRecovery, initialTicksToDelayedRecovery;
    private long millisecondsSinceHPRegen, millisecondsToDelayedRecovery;

    private long deltaTime;
    private long lastTime;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;
    private final Image heartDisease;
    private final Image heartPoison;
    private final Image heartVenom;

    private final Map<Integer, Integer> previousInventory = new HashMap<>();
    private boolean isEating = false;

    private int deltaX = 0, deltaY = 0;
    private int lastKnownSidebarX = 0, lastKnownSidebarY = 0;
    private int lastX = 0, lastY = 0;

    private Color hitpointsMainColour, hitpointsHealColour, hitpointsDelayedHealColour;
    private Color hitpointsPoisonedColour, hitpointsEnvenomedColour, hitpointsDiseasedColour, hitpointsParasiteColour;

    @Inject
    private OverlayManager overlayManager;

    private final ConfigManager configManager;


    @Inject
    CustomVitalBarsHitpointsOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager, ConfigManager configManager )
    {
        super(plugin);

        //setPriority(OverlayPriority.LOW);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);

        setMovable( true );
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;
        this.configManager = configManager;

        heartDisease = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.DISEASE_HEART);
        heartPoison = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.POISON_HEART);
        heartVenom = ImageUtil.loadImageResource(AlternateSprites.class, AlternateSprites.VENOM_HEART);

        lastKnownSidebarX = config.debugSidebarPanelX();
        lastKnownSidebarY = config.debugSidebarPanelY();

        hitpointsMainColour = config.hitpointsMainColour();
        hitpointsHealColour = config.hitpointsHealColour();
        hitpointsDelayedHealColour = config.hitpointsDelayedHealColour();
        hitpointsPoisonedColour = config.hitpointsPoisonedColour();
        hitpointsEnvenomedColour = config.hitpointsEnvenomedColour();
        hitpointsDiseasedColour = config.hitpointsDiseasedColour();
        hitpointsParasiteColour = config.hitpointsParasiteColour();

        initRenderer();

        if ( config.hitpointsRelativeToInventory() )
        {
            toggleLock( true );
        }
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> inLms() ? Experience.MAX_REAL_LEVEL : client.getRealSkillLevel(Skill.HITPOINTS),
                () -> client.getBoostedSkillLevel(Skill.HITPOINTS),
                () -> getRestoreValue(Skill.HITPOINTS.getName()),
                () ->
                {
                    final int poisonState = client.getVarpValue(VarPlayer.POISON);

                    if (poisonState >= 1000000)
                    {
                        return hitpointsEnvenomedColour;
                    }

                    if (poisonState > 0)
                    {
                        return hitpointsPoisonedColour;
                    }

                    if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0)
                    {
                        return hitpointsDiseasedColour;
                    }

                    if (client.getVarbitValue(Varbits.PARASITE) >= 1)
                    {
                        return hitpointsParasiteColour;
                    }

                    if ( ticksToDelayedRecovery > 0 )
                    {
                        return hitpointsDelayedHealColour;
                    }

                    return hitpointsMainColour;
                },
                () -> hitpointsHealColour,
                () ->
                {
                    if ( config.hitpointsOutlineProgressSelection() == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY )
                    {
                        return hitpointsRegenerationPercentage;
                    }
                    else if ( config.hitpointsOutlineProgressSelection() == OutlineProgressSelection.SHOW_CONSUMABLE_PROGRESS_ONLY )
                    {
                        return hitpointsRecoveryPercentage;
                    }

                    return (ticksToDelayedRecovery > 0 ? hitpointsRecoveryPercentage : hitpointsRegenerationPercentage);
                },
                () ->
                {
                    final int poisonState = client.getVarpValue(VarPlayer.POISON);

                    if (poisonState > 0 && poisonState < 50)
                    {
                        return heartPoison;
                    }

                    if (poisonState >= 1000000)
                    {
                        return heartVenom;
                    }

                    if (client.getVarpValue(VarPlayer.DISEASE_VALUE) > 0)
                    {
                        return heartDisease;
                    }

                    return loadSprite(SpriteID.MINIMAP_ORB_HITPOINTS_ICON);
                }
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        long millisecondsPerHPRegen = (long)(getTicksPerHPRegen() * 0.6 * 1000);

        millisecondsSinceHPRegen = (millisecondsSinceHPRegen + deltaTime) % millisecondsPerHPRegen;
        hitpointsRegenerationPercentage = millisecondsSinceHPRegen / (double) millisecondsPerHPRegen;

        int currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
        int maxHP = client.getRealSkillLevel(Skill.HITPOINTS);
        if ( currentHP == maxHP && config.hitpointsOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
        {
            hitpointsRegenerationPercentage = 0;
        }
        else if ( currentHP > maxHP )
        {
            // Show it going down
            hitpointsRegenerationPercentage = 1 - hitpointsRegenerationPercentage;
        }

        if ( ticksToDelayedRecovery > 0 )
        {
            long millisecondsToHPRecovery = (long)(initialTicksToDelayedRecovery * 0.6 * 1000);

            millisecondsToDelayedRecovery = (millisecondsToDelayedRecovery - deltaTime) % millisecondsToHPRecovery;
            hitpointsRecoveryPercentage = millisecondsToDelayedRecovery / (double) millisecondsToHPRecovery;
        }

        Viewport curViewport = null;
        Widget curWidget = null;

        for (Viewport viewport : Viewport.values())
        {
            final Widget viewportWidget = client.getWidget(viewport.getViewport());
            if ( viewportWidget != null )
            {
                if ( !viewportWidget.isHidden() )
                {
                    curViewport = viewport;
                    curWidget = viewportWidget;

                    final net.runelite.api.Point location = viewportWidget.getCanvasLocation();
                    lastKnownSidebarX = location.getX();
                    lastKnownSidebarY = location.getY();

                    break;
                }
            }
        }

        if ( config.hideHitpointsWhenSidebarPanelClosed() )
        {
            if (curViewport == null)
            {
                return null;
            }
        }

        if ( config.hitpointsRelativeToInventory() )
        {
            if (curViewport != null)
            {
                final net.runelite.api.Point location = curWidget.getCanvasLocation();

                if ( deltaX != 0 && deltaY != 0 )
                {
                    int newDeltaX = (int) (location.getX() + deltaX);
                    int newDeltaY = (int) (location.getY() + deltaY);
                    this.setPreferredLocation( new java.awt.Point(newDeltaX, newDeltaY) );

                    if ( lastX != newDeltaX || lastY != newDeltaY )
                    {
                        overlayManager.saveOverlay(this);
                    }
                    lastX = newDeltaX;
                    lastY = newDeltaY;
                }
            }
        }

        if ( !(config.renderWarmthWithOptions() == WarmthRenderOptions.SHOW_DYNAMICALLY && isInWintertodtRegion()) && plugin.isHitpointsDisplayed() && config.renderHitpoints() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.HITPOINTS, (ticksToDelayedRecovery > 0), client );
            return config.hitpointsSize();
        }

        //this.setPreferredLocation( new Point( x, y ) );

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    private boolean inLms()
    {
        return client.getWidget(ComponentID.LMS_INGAME_INFO) != null;
    }


    @Subscribe
    public void onGameStateChanged( GameStateChanged ev )
    {
        if ( ev.getGameState() == GameState.HOPPING || ev.getGameState() == GameState.LOGIN_SCREEN )
        {
            ticksSinceHPRegen = -2; // For some reason this makes this accurate
            millisecondsSinceHPRegen = (long)(ticksSinceHPRegen * 0.6 * 1000);
        }

        if ( ev.getGameState().equals( GameState.LOGGED_IN ) )
        {
            isEating = false;
            updateInventoryState();
        }
    }

    @Subscribe
    public void onConfigChanged( ConfigChanged event )
    {
        if ( event.getKey().equals("hitpointsRelativeToSidebarPanel") )
        {
            toggleLock( false );
        }
        else if ( event.getKey().equals("hitpointsMainColour") )
        {
            hitpointsMainColour = config.hitpointsMainColour();
        }
        else if ( event.getKey().equals("hitpointsHealColour") )
        {
            hitpointsHealColour = config.hitpointsHealColour();
        }
        else if ( event.getKey().equals("hitpointsDelayedHealColour") )
        {
            hitpointsDelayedHealColour = config.hitpointsDelayedHealColour();
        }
        else if ( event.getKey().equals("hitpointsPoisonedColour") )
        {
            hitpointsPoisonedColour = config.hitpointsPoisonedColour();
        }
        else if ( event.getKey().equals("hitpointsEnvenomedColour") )
        {
            hitpointsEnvenomedColour = config.hitpointsEnvenomedColour();
        }
        else if ( event.getKey().equals("hitpointsDiseasedColour") )
        {
            hitpointsDiseasedColour = config.hitpointsDiseasedColour();
        }
        else if ( event.getKey().equals("hitpointsParasiteColour") )
        {
            hitpointsParasiteColour = config.hitpointsParasiteColour();
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged ev)
    {
        if (ev.getVarbitId() == Varbits.PRAYER_RAPID_HEAL)
        {
            ticksSinceHPRegen = 0;
            millisecondsSinceHPRegen = 0;
        }
    }

    @Subscribe
    public void onGameTick( GameTick event )
    {
        int ticksPerHPRegen = getTicksPerHPRegen();

        ticksSinceHPRegen = (ticksSinceHPRegen + 1) % ticksPerHPRegen;
        millisecondsSinceHPRegen = (long) (ticksSinceHPRegen * 0.6 * 1000);
        hitpointsRegenerationPercentage = ticksSinceHPRegen / (double) ticksPerHPRegen;

        int currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
        int maxHP = client.getRealSkillLevel(Skill.HITPOINTS);
        if ( currentHP == maxHP && config.hitpointsOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
        {
            hitpointsRegenerationPercentage = 0;
        }
        else if ( currentHP > maxHP )
        {
            // Show it going down
            hitpointsRegenerationPercentage = 1 - hitpointsRegenerationPercentage;
        }

        if ( ticksToDelayedRecovery > 0 )
        {
            int ticksToHPRecovery = initialTicksToDelayedRecovery;

            ticksToDelayedRecovery = (ticksToDelayedRecovery - 1) % ticksToHPRecovery;
            millisecondsToDelayedRecovery = (long) (ticksToDelayedRecovery * 0.6 * 1000);
            hitpointsRecoveryPercentage = (double) ticksToDelayedRecovery / ticksToHPRecovery;
        }
        else
        {
            ticksToDelayedRecovery = 0;
            millisecondsToDelayedRecovery = 0;
            initialTicksToDelayedRecovery = 0;
        }


        isEating = false;
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if ( event.getContainerId() == InventoryID.EQUIPMENT.getId() )
        {
            ItemContainer equipment = event.getItemContainer();
            final boolean hasHPCape = (equipment.contains(ItemID.HITPOINTS_CAPE) || equipment.contains(ItemID.HITPOINTS_CAPET));
            final boolean hasRegenBracelet = equipment.contains(ItemID.REGEN_BRACELET);

            if ( hasHPCape != isWearingHPCape )
            {
                ticksSinceHPRegen = 0;
                isWearingHPCape = hasHPCape;
            }
            if ( hasRegenBracelet != isWearingRegenBracelet )
            {
                ticksSinceHPRegen = 0;
                isWearingRegenBracelet = hasRegenBracelet;
            }
        }
        else if ( event.getContainerId() == InventoryID.INVENTORY.getId() || event.getContainerId() == InventoryID.BANK.getId())
        {
            if ( isEating )
            {
                detectConsumableUsage();
                isEating = false;
            }
            updateInventoryState();
        }
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        String menuOption = Text.removeTags( event.getMenuOption() );
        if ( menuOption.equals( "Eat" ) && isApplicableConsumable( event.getItemId() ) )
        {
            isEating = true;
        }
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }

    private int getTicksPerHPRegen()
    {
        int ticksPerHPRegen = NORMAL_HP_REGEN_TICKS;
        if ( client.isPrayerActive( Prayer.RAPID_HEAL ) || isWearingHPCape )
        {
            ticksPerHPRegen /= 2;
        }
        if ( isWearingRegenBracelet )
        {
            ticksPerHPRegen /= 2;
        }

        return ticksPerHPRegen;
    }

    private boolean isInWintertodtRegion()
    {
        if (client.getLocalPlayer() != null)
        {
            return client.getLocalPlayer().getWorldLocation().getRegionID() == WINTERTODT_REGION;
        }

        return false;
    }

    private void updateInventoryState()
    {
        previousInventory.clear();
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null)
        {
            for (Item item : inventory.getItems())
            {
                previousInventory.merge(item.getId(), item.getQuantity(), Integer::sum);
            }
        }
    }

    private void detectConsumableUsage()
    {
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory == null)
        {
            return;
        }

        Map<Integer, Integer> currentInventory = new HashMap<>();
        for (Item item : inventory.getItems())
        {
            currentInventory.merge(item.getId(), item.getQuantity(), Integer::sum);
        }

        for (Map.Entry<Integer, Integer> entry : previousInventory.entrySet())
        {
            int itemID = entry.getKey();
            int previousItemQuantity = entry.getValue();
            if (previousItemQuantity > currentInventory.getOrDefault(itemID, 0) && isApplicableConsumable(itemID))
            {
                handleConsumable(itemID);
            }
        }
    }

    private boolean isApplicableConsumable(int itemId)
    {
        DelayedHeals item = DelayedHeals.getDelayedHealByItemId(itemId);
        return item != null;
    }

    private void handleConsumable(int itemId)
    {
        DelayedHeals item = DelayedHeals.getDelayedHealByItemId(itemId);

        ticksToDelayedRecovery = item.getTickDelay();
        initialTicksToDelayedRecovery = item.getTickDelay();
    }

    public void toggleLock( boolean start )
    {
        if ( deltaX == 0 && deltaY == 0 )
        {
            if ( start )
            {
                deltaX = config.debugHitpointsDeltaX();
                deltaY = config.debugHitpointsDeltaY();
            }
            else
            {
                deltaX = (int) (this.getPreferredLocation().getX() - lastKnownSidebarX);
                deltaY = (int) (this.getPreferredLocation().getY() - lastKnownSidebarY);
            }
        }
        else
        {
            deltaX = 0;
            deltaY = 0;
        }
        configManager.setConfiguration( "Custom Vital Bars", "debugHitpointsDeltaX", (int) deltaX );
        configManager.setConfiguration( "Custom Vital Bars", "debugHitpointsDeltaY", (int) deltaY );
    }

}

/*
 * Copyright (c) 2019, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2019, Rheon <https://github.com/Rheon-D>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.util.function.Supplier;
import lombok.RequiredArgsConstructor;
import java.math.RoundingMode;
import java.text.DecimalFormat;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.Notification;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import com.neur0tox1n_.customvitalbars.Viewport;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

import javax.inject.Inject;


import lombok.extern.slf4j.Slf4j;

@RequiredArgsConstructor
class CustomVitalBarsComponent
{
    @Inject
    private Client client;

    private CustomVitalBarsConfig config;

    @Inject
    private ConfigManager configManager;

    private static final int BORDER_SIZE = 1;
    private static final DecimalFormat df = new DecimalFormat("0");

    private final Supplier<Integer> maxValueSupplier;
    private final Supplier<Integer> currentValueSupplier;
    private final Supplier<Integer> healSupplier;
    private final Supplier<Color> colorSupplier;
    private final Supplier<Color> healColorSupplier;
    private final Supplier<Double> timeBasedEffectCounterSupplier;
    private final Supplier<Image> iconSupplier;
    private int maxValue;
    private int currentValue;

    private boolean pulseColour = false;
    private static final int PULSE_COLOUR_ALPHA_MIN = 50;
    private static final int PULSE_COLOUR_ALPHA_MAX = 255;
    private int pulseColourAlpha = 255;
    private int pulseColourDirection = -1;
    private int pulseColourIncrement = 3;

    private int initialX = 200, initialY = 200;
    private Color vitalBackgroundColour, vitalOverhealColour, vitalFramesColour, vitalTextColour;
    private boolean vitalTextOutline = false;
    private Vital thisVital;

    private PanelComponent boundingBox =  null;

    private void refreshSkills()
    {
        maxValue = maxValueSupplier.get();
        currentValue = currentValueSupplier.get();
    }

    void renderBar( CustomVitalBarsConfig config, Graphics2D graphics, PanelComponent component, Vital whichVital, boolean isConsumableActive, Client client )
    {
        FullnessDirection dir = null;
        TextFormatting textFormat = null;
        PlacementDirection textLoc = null;
        int textOffsetX = 0, textOffsetY = 0;
        ThresholdGlowMode thresholdGlowMode = null;
        OutlineProgressSelection selectionOutlineProgress = null;
        OutlineProgressThreshold thresholdOutlineProgress = null;
        int thresholdGlowValue = 0, outlineThickness = 0, width = 0, height = 0;
        double iconScale = 0d;
        PlacementDirection iconLoc = null;
        int iconOffsetX = 0, iconOffsetY = 0;
        boolean lockRelativeToInventory = false;

        this.config = config;
        thisVital = whichVital;

        if ( whichVital == Vital.HITPOINTS )
        {
            dir = config.hitpointsFullnessDirection();
            textFormat = config.hitpointsTextFormat();
            textLoc = config.hitpointsTextPosition();
            textOffsetX = config.hitpointsTextOffsetX();
            textOffsetY = config.hitpointsTextOffsetY();
            thresholdGlowMode = config.hitpointsGlowThresholdMode();
            selectionOutlineProgress = config.hitpointsOutlineProgressSelection();
            thresholdOutlineProgress = config.hitpointsOutlineProgressThreshold();
            thresholdGlowValue = config.hitpointsGlowThresholdValue();
            outlineThickness = config.hitpointsOutlineThickness();
            iconScale = config.hitpointsIconScale();
            iconLoc = config.hitpointsIconPosition();
            iconOffsetX = config.hitpointsIconOffsetX();
            iconOffsetY = config.hitpointsIconOffsetY();
            width = config.hitpointsSize().width;
            height = config.hitpointsSize().height;
            lockRelativeToInventory = config.hitpointsRelativeToInventory();
            vitalBackgroundColour = config.hitpointsBackgroundColour();
            vitalOverhealColour = config.hitpointsOverhealColour();
            vitalFramesColour = config.hitpointsFramesColour();
            vitalTextColour = config.hitpointsTextColour();
            vitalTextOutline = config.hitpointsTextOutline();
        }
        else if ( whichVital == Vital.PRAYER )
        {
            dir = config.prayerFullnessDirection();
            textFormat = config.prayerTextFormat();
            textLoc = config.prayerTextPosition();
            textOffsetX = config.prayerTextOffsetX();
            textOffsetY = config.prayerTextOffsetY();
            thresholdGlowMode = config.prayerGlowThresholdMode();
            selectionOutlineProgress = config.prayerOutlineProgressSelection();
            thresholdOutlineProgress = config.prayerOutlineProgressThreshold();
            thresholdGlowValue = config.prayerGlowThresholdValue();
            outlineThickness = config.prayerOutlineThickness();
            iconScale = config.prayerIconScale();
            iconLoc = config.prayerIconPosition();
            iconOffsetX = config.prayerIconOffsetX();
            iconOffsetY = config.prayerIconOffsetY();
            width = config.prayerSize().width;
            height = config.prayerSize().height;
            lockRelativeToInventory = config.prayerRelativeToInventory();
            vitalBackgroundColour = config.prayerBackgroundColour();
            vitalOverhealColour = config.prayerOverhealColour();
            vitalFramesColour = config.prayerFramesColour();
            vitalTextColour = config.prayerTextColour();
            vitalTextOutline = config.prayerTextOutline();
        }
        else if ( whichVital == Vital.RUN_ENERGY )
        {
            dir = config.energyFullnessDirection();
            textFormat = config.energyTextFormat();
            textLoc = config.energyTextPosition();
            textOffsetX = config.energyTextOffsetX();
            textOffsetY = config.energyTextOffsetY();
            thresholdGlowMode = config.energyGlowThresholdMode();
            selectionOutlineProgress = config.energyOutlineProgressSelection();
            thresholdOutlineProgress = config.energyOutlineProgressThreshold();
            thresholdGlowValue = config.energyGlowThresholdValue();
            outlineThickness = config.energyOutlineThickness();
            iconScale = config.energyIconScale();
            iconLoc = config.energyIconPosition();
            iconOffsetX = config.energyIconOffsetX();
            iconOffsetY = config.energyIconOffsetY();
            width = config.energySize().width;
            height = config.energySize().height;
            lockRelativeToInventory = config.energyRelativeToInventory();
            vitalBackgroundColour = config.energyBackgroundColour();
            vitalOverhealColour = config.energyOverhealColour();
            vitalFramesColour = config.energyFramesColour();
            vitalTextColour = config.energyTextColour();
            vitalTextOutline = config.energyTextOutline();
        }
        else if ( whichVital == Vital.SPECIAL_ENERGY )
        {
            dir = config.specialFullnessDirection();
            textFormat = config.specialTextFormat();
            textLoc = config.specialTextPosition();
            textOffsetX = config.specialTextOffsetX();
            textOffsetY = config.specialTextOffsetY();
            thresholdGlowMode = config.specialGlowThresholdMode();
            selectionOutlineProgress = config.specialOutlineProgressSelection();
            thresholdOutlineProgress = config.specialOutlineProgressThreshold();
            thresholdGlowValue = config.specialGlowThresholdValue();
            outlineThickness = config.specialOutlineThickness();
            iconScale = config.specialIconScale();
            iconLoc = config.specialIconPosition();
            iconOffsetX = config.specialIconOffsetX();
            iconOffsetY = config.specialIconOffsetY();
            width = config.specialSize().width;
            height = config.specialSize().height;
            lockRelativeToInventory = config.specialRelativeToInventory();
            vitalBackgroundColour = config.specialBackgroundColour();
            vitalOverhealColour = config.specialOverhealColour();
            vitalFramesColour = config.specialFramesColour();
            vitalTextColour = config.specialTextColour();
            vitalTextOutline = config.specialTextOutline();
        }
        else if ( whichVital == Vital.WARMTH ) {
            dir = config.warmthFullnessDirection();
            textFormat = config.warmthTextFormat();
            textLoc = config.warmthTextPosition();
            textOffsetX = config.warmthTextOffsetX();
            textOffsetY = config.warmthTextOffsetY();
            thresholdGlowMode = config.warmthGlowThresholdMode();
            selectionOutlineProgress = config.warmthOutlineProgressSelection();
            thresholdOutlineProgress = config.warmthOutlineProgressThreshold();
            thresholdGlowValue = config.warmthGlowThresholdValue();
            outlineThickness = config.warmthOutlineThickness();
            iconScale = config.warmthIconScale();
            iconLoc = config.warmthIconPosition();
            iconOffsetX = config.warmthIconOffsetX();
            iconOffsetY = config.warmthIconOffsetY();
            width = config.warmthSize().width;
            height = config.warmthSize().height;
            lockRelativeToInventory = config.warmthRelativeToInventory();
            vitalBackgroundColour = config.warmthBackgroundColour();
            vitalOverhealColour = config.warmthOverhealColour();
            vitalFramesColour = config.warmthFramesColour();
            vitalTextColour = config.warmthTextColour();
            vitalTextOutline = config.warmthTextOutline();
        }

        if ( boundingBox == null )
        {
            boundingBox = new PanelComponent();
            component.getChildren().add(boundingBox);
        }
        else
        {
            initialX = component.getBounds().x;
            initialY = component.getBounds().y;
        }

        if ( outlineThickness > 0 )
        {
            renderOutline( config, graphics, initialX, initialY, dir, outlineThickness, selectionOutlineProgress, thresholdOutlineProgress, width, height, isConsumableActive );
        }

        // start by assuming the bar will be filled rightward
        //int eX = component.getBounds().x;
        //int eY = component.getBounds().y;
        int eX = initialX;
        int eY = initialY;
        int filledWidth = getBarSize(maxValue, currentValue, width);
        int filledHeight = height;

        if ( dir == FullnessDirection.TOP )
        {
            filledHeight = getBarSize( maxValue, currentValue, height );
            filledWidth = width;
            eY += height - filledHeight;
        }
        else if ( dir == FullnessDirection.BOTTOM )
        {
            filledHeight = getBarSize( maxValue, currentValue, height );
            filledWidth = width;
        }
        else if ( dir == FullnessDirection.LEFT )
        {
            eX += width - filledWidth;
        }

        Color fill = colorSupplier.get();

        refreshSkills();

        graphics.setColor( vitalFramesColour );
        graphics.drawRect(initialX, initialY, width, height);
        graphics.setColor( vitalBackgroundColour );
        graphics.fillRect(initialX, initialY, width, height );

        pulseColour = false;
        if ( thresholdGlowMode == ThresholdGlowMode.ABOVE_PERCENTAGE )
        {
            if ( currentValue * 100d / maxValue > thresholdGlowValue )
            {
                pulseColour = true;
            }
        }
        else if ( thresholdGlowMode == ThresholdGlowMode.ABOVE_FLAT_VALUE )
        {
            if ( currentValue > thresholdGlowValue )
            {
                pulseColour = true;
            }
        }
        else if ( thresholdGlowMode == ThresholdGlowMode.BELOW_PERCENTAGE )
        {
            if ( currentValue * 100d / maxValue < thresholdGlowValue )
            {
                pulseColour = true;
            }
        }
        else if ( thresholdGlowMode == ThresholdGlowMode.BELOW_FLAT_VALUE )
        {
            if ( currentValue < thresholdGlowValue )
            {
                pulseColour = true;
            }
        }

        if ( pulseColour )
        {
            pulseColourAlpha += pulseColourDirection * pulseColourIncrement;
            if ( pulseColourAlpha > PULSE_COLOUR_ALPHA_MAX )
            {
                pulseColourAlpha = PULSE_COLOUR_ALPHA_MAX;
                pulseColourDirection = -1;
            }
            else if ( pulseColourAlpha < PULSE_COLOUR_ALPHA_MIN )
            {
                pulseColourAlpha = PULSE_COLOUR_ALPHA_MIN;
                pulseColourDirection = 1;
            }
            fill = new Color( fill.getRed(), fill.getGreen(), fill.getBlue(), pulseColourAlpha );
        }

        graphics.setColor(fill);
        graphics.fillRect(eX + BORDER_SIZE,
                eY + BORDER_SIZE,
                filledWidth - BORDER_SIZE,
                filledHeight - BORDER_SIZE);

        if ( config.enableRestorationBars() )
        {
            renderRestore(config, graphics, dir, initialX, initialY, width, height);
        }

        if ( textFormat != TextFormatting.HIDE )
        {
            renderText(config, graphics, textFormat, textLoc, textOffsetX, textOffsetY, outlineThickness, initialX, initialY, width, height );
        }

        if ( iconScale > 0d )
        {
            renderIcon( config, graphics, iconScale, iconLoc, iconOffsetX, iconOffsetY, outlineThickness, initialX, initialY, width, height );
        }

        //boundingBox.setBorder( new Rectangle( 0, 0, width, height ) );
        //boundingBox.setPreferredLocation( new Point( initialX, initialY ) );
        //boundingBox.setPreferredSize( new Dimension( width, height ) );
    }

    private void renderOutline( CustomVitalBarsConfig config, Graphics2D graphics, int _x, int _y, FullnessDirection dir, int outlineSize, OutlineProgressSelection selectionOutlineProgress, OutlineProgressThreshold thresholdOutlineProgress, int width, int height, boolean isConsumableActive )
    {
        graphics.setColor( vitalFramesColour );
        graphics.drawRect( _x - outlineSize - 1, _y - outlineSize - 1, width + 2 * outlineSize + BORDER_SIZE + 1, height + 2 * outlineSize + BORDER_SIZE + 1 );
        graphics.setColor( vitalBackgroundColour );
        if (    selectionOutlineProgress == OutlineProgressSelection.HIDE ||
                (selectionOutlineProgress == OutlineProgressSelection.SHOW_CONSUMABLE_PROGRESS_ONLY && !isConsumableActive) )
        {
            return;
        }

        graphics.setColor( colorSupplier.get() );
        if ( dir == FullnessDirection.TOP )
        {
            final int fullSize = height + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( _x - outlineSize, _y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(_x - outlineSize, _y - outlineSize + (fullSize - filledCurrentSize), width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE - (fullSize - filledCurrentSize) );
            graphics.setClip( oldClip );
        }
        else if ( dir == FullnessDirection.BOTTOM )
        {
            final int fullSize = height + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( _x - outlineSize, _y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(_x - outlineSize, _y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, filledCurrentSize );
            graphics.setClip( oldClip );
        }
        else if ( dir == FullnessDirection.LEFT )
        {
            final int fullSize = width + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( _x - outlineSize, _y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(_x - outlineSize + (fullSize - filledCurrentSize), _y - outlineSize,  _x + fullSize, height + 2 * outlineSize + BORDER_SIZE );
            graphics.setClip( oldClip );
        }
        else if ( dir == FullnessDirection.RIGHT )
        {
            final int fullSize = width + outlineSize * 2 + BORDER_SIZE;
            final int filledCurrentSize = getBarSize( 100, (int) Math.floor( timeBasedEffectCounterSupplier.get() * 100 ), fullSize );

            Shape oldClip = graphics.getClip();
            graphics.setClip( getOutsideEdge( graphics, new Rectangle( _x - outlineSize, _y - outlineSize, width + 2 * outlineSize + BORDER_SIZE, height + 2 * outlineSize + BORDER_SIZE ), outlineSize, outlineSize, outlineSize, outlineSize ) );
            graphics.fillRect(_x - outlineSize, _y - outlineSize, filledCurrentSize, height + 2 * outlineSize + BORDER_SIZE );
            graphics.setClip( oldClip );
        }
    }

    private void renderText(CustomVitalBarsConfig config, Graphics2D graphics, TextFormatting textFormat, PlacementDirection textLoc, int textOffsetX, int textOffsetY, int outlineSize, int x, int y, int barWidth, int barHeight )
    {
        graphics.setFont(FontManager.getRunescapeSmallFont());

        String counterText = Integer.toString(currentValue);
        if ( textFormat == TextFormatting.SHOW_CURRENT_AND_MAXIMUM )
        {
            counterText = currentValue + " / " + maxValue;
        }
        else if ( textFormat == TextFormatting.SHOW_PERCENTAGE )
        {
            df.setRoundingMode( RoundingMode.DOWN );
            counterText = df.format( (float) (currentValue * 100) / maxValue ) + "%";
        }

        int sizeOfCounterX = graphics.getFontMetrics().stringWidth(counterText);
        int sizeOfCounterY = graphics.getFontMetrics().getHeight();
        int xOffset = (barWidth / 2) - (sizeOfCounterX / 2);
        int yOffset = -(int) Math.floor(outlineSize * 1.75);

        if ( textLoc == PlacementDirection.CENTRE )
        {
            xOffset = (barWidth / 2) - (sizeOfCounterX / 2);
            yOffset = (barHeight / 2) + (sizeOfCounterY / 2);
        }
        else if ( textLoc == PlacementDirection.BOTTOM )
        {
            yOffset = barHeight + sizeOfCounterY + (int) Math.floor(outlineSize * 1.75);
        }
        else if ( textLoc == PlacementDirection.LEFT )
        {
            xOffset = -(int) Math.floor(sizeOfCounterX * 1.125) - (int) Math.floor(outlineSize * 1.75);
            yOffset = (barHeight / 2) + (sizeOfCounterY / 2);
        }
        else if ( textLoc == PlacementDirection.RIGHT )
        {
            xOffset = barWidth + 4 + (int) Math.floor(outlineSize * 1.75);
            yOffset = (barHeight / 2) + (sizeOfCounterY / 2);
        }

        final TextComponent textComponent = new TextComponent();
        textComponent.setColor( vitalTextColour );
        textComponent.setOutline( vitalTextOutline );
        textComponent.setText( counterText );
        textComponent.setPosition( new Point(x + xOffset + textOffsetX, y + yOffset + textOffsetY) );
        textComponent.render( graphics );

    }

    private void renderIcon( CustomVitalBarsConfig config, Graphics2D graphics, double iconScale, PlacementDirection iconLoc, int iconOffsetX, int iconOffsetY, int outlineSize, int x, int y, int barWidth, int barHeight )
    {
        final Image icon = iconSupplier.get();
        if (icon != null)
        {
            double iconWidth  = icon.getWidth( null ) * iconScale;
            double iconHeight = icon.getHeight( null ) * iconScale;
            int xOffset = (int) ((barWidth / 2) - (iconWidth / 2));
            int yOffset = -(barHeight + (int)Math.floor(outlineSize * 1.75));
            if ( iconLoc == PlacementDirection.CENTRE )
            {
                xOffset = (int) ((barWidth / 2) - (iconWidth / 2));
                yOffset = 0;
            }
            else if ( iconLoc == PlacementDirection.BOTTOM )
            {
                yOffset = barHeight + (int) Math.floor(outlineSize * 1.75);
            }
            else if ( iconLoc == PlacementDirection.LEFT )
            {
                xOffset = -(int) Math.floor(iconWidth * 1.125) - (int) Math.floor(outlineSize * 1.75);
                yOffset = 0;
            }
            else if ( iconLoc == PlacementDirection.RIGHT )
            {
                xOffset = barWidth + 4 + (int) Math.floor(outlineSize * 1.75);
                yOffset = 0;
            }

            graphics.drawImage(icon, x + xOffset + iconOffsetX, y + yOffset + iconOffsetY, (int) iconWidth, (int) iconHeight,null);
        }
    }

    private void renderRestore(CustomVitalBarsConfig config, Graphics2D graphics, FullnessDirection dir, int x, int y, int width, int height)
    {
        final Color color = healColorSupplier.get();
        final int heal = healSupplier.get();

        if (heal <= 0)
        {
            return;
        }

        int filledCurrentSize = getBarSize(maxValue, currentValue, width);
        int filledHealSize = getBarSize(maxValue, heal, width);
        int fillX = x, fillY = y, fillWidth = width, fillHeight = height, fillThreshold = width;
        graphics.setColor(color);

        if ( dir == FullnessDirection.TOP )
        {
            fillThreshold = height;
            filledCurrentSize = getBarSize( maxValue, currentValue, height );
            filledHealSize = getBarSize( maxValue, heal, height );

            fillX = x;
            fillY = y + height - filledCurrentSize - filledHealSize;

            fillWidth = width;
            fillHeight = filledHealSize + 1;
        }
        else if ( dir == FullnessDirection.BOTTOM )
        {
            fillThreshold = height;
            filledCurrentSize = getBarSize( maxValue, currentValue, height );
            filledHealSize = getBarSize( maxValue, heal, height );

            //fillX = x;
            fillY = y + filledCurrentSize - 1;

            fillWidth = width;
            fillHeight = filledHealSize + 1;
        }
        else if ( dir == FullnessDirection.LEFT )
        {
            //fillThreshold = width;
            filledCurrentSize = getBarSize( maxValue, currentValue, width );
            filledHealSize = getBarSize( maxValue, heal, width );

            fillX = x + width - filledCurrentSize - filledHealSize;
            fillY = y;

            fillWidth = filledHealSize + 1;
            fillHeight = height;
        }
        else if ( dir == FullnessDirection.RIGHT )
        {
            //fillThreshold = width;
            filledCurrentSize = getBarSize( maxValue, currentValue, width );
            filledHealSize = getBarSize( maxValue, heal, width );

            fillX = x + filledCurrentSize - 1;
            fillY = y;

            fillWidth = filledHealSize + 1;
            fillHeight = height;
        }

        if ( filledHealSize + filledCurrentSize > fillThreshold )
        {
            graphics.setColor( vitalOverhealColour );

            if ( dir == FullnessDirection.TOP )
            {
                fillHeight = height - filledCurrentSize + 1;
                fillY = y;
            }
            else if ( dir == FullnessDirection.BOTTOM )
            {
                fillHeight = height - filledCurrentSize + 1;
            }
            else if ( dir == FullnessDirection.LEFT )
            {
                fillWidth = width - filledCurrentSize + 1;
                fillX = x;
            }
            else if ( dir == FullnessDirection.RIGHT )
            {
                fillWidth = width - filledCurrentSize + 1;
            }
        }

        graphics.fillRect( fillX + BORDER_SIZE , fillY + BORDER_SIZE, fillWidth - BORDER_SIZE, fillHeight - BORDER_SIZE );
    }

    private static int getBarSize(int base, int current, int size)
    {
        final double ratio = (double) current / base;

        if (ratio >= 1)
        {
            return size;
        }

        return (int) Math.round(ratio * size);
    }

    static public Shape getOutsideEdge( Graphics gc, Rectangle bb, int top, int lft, int btm, int rgt )
    {
        int                                 ot=bb.y            , it=(ot+top);
        int                                 ol=bb.x            , il=(ol+lft);
        int                                 ob=(bb.y+bb.height), ib=(ob-btm);
        int                                 or=(bb.x+bb.width ), ir=(or-rgt);

        return new Polygon(
                new int[]{ ol, ol, or, or, ol, ol,   il, ir, ir, il, il },
                new int[]{ it, ot, ot, ob, ob, it,   it, it, ib, ib, it },
                11
        );
    }

    @Subscribe
    public void onConfigChanged( ConfigChanged event )
    {
        if ( thisVital == Vital.HITPOINTS )
        {
            if ( event.getKey().equals("hitpointsFramesColour") )
            {
                vitalFramesColour = config.hitpointsFramesColour();
            }
            else if ( event.getKey().equals("hitpointsBackgroundColour") )
            {
                vitalBackgroundColour = config.hitpointsBackgroundColour();
            }
            else if ( event.getKey().equals("hitpointsOverhealColour") )
            {
                vitalOverhealColour = config.hitpointsOverhealColour();
            }
            else if ( event.getKey().equals("hitpointsTextColour") )
            {
                vitalTextColour = config.hitpointsTextColour();
            }
            else if ( event.getKey().equals("hitpointsTextOutline") )
            {
                vitalTextOutline = config.hitpointsTextOutline();
            }
        }
        else if ( thisVital == Vital.PRAYER )
        {
            if ( event.getKey().equals("prayerFramesColour") )
            {
                vitalFramesColour = config.prayerFramesColour();
            }
            else if ( event.getKey().equals("prayerBackgroundColour") )
            {
                vitalBackgroundColour = config.prayerBackgroundColour();
            }
            else if ( event.getKey().equals("prayerOverhealColour") )
            {
                vitalOverhealColour = config.prayerOverhealColour();
            }
            else if ( event.getKey().equals("prayerTextColour") )
            {
                vitalTextColour = config.prayerTextColour();
            }
            else if ( event.getKey().equals("prayerTextOutline") )
            {
                vitalTextOutline = config.prayerTextOutline();
            }
        }
        else if ( thisVital == Vital.RUN_ENERGY )
        {
            if ( event.getKey().equals("energyFramesColour") )
            {
                vitalFramesColour = config.energyFramesColour();
            }
            else if ( event.getKey().equals("energyBackgroundColour") )
            {
                vitalBackgroundColour = config.energyBackgroundColour();
            }
            else if ( event.getKey().equals("energyOverhealColour") )
            {
                vitalOverhealColour = config.energyOverhealColour();
            }
            else if ( event.getKey().equals("energyTextColour") )
            {
                vitalTextColour = config.energyTextColour();
            }
            else if ( event.getKey().equals("energyTextOutline") )
            {
                vitalTextOutline = config.energyTextOutline();
            }
        }
        else if ( thisVital == Vital.SPECIAL_ENERGY )
        {
            if ( event.getKey().equals("specialFramesColour") )
            {
                vitalFramesColour = config.specialFramesColour();
            }
            else if ( event.getKey().equals("specialBackgroundColour") )
            {
                vitalBackgroundColour = config.specialBackgroundColour();
            }
            else if ( event.getKey().equals("specialOverhealColour") )
            {
                vitalOverhealColour = config.specialOverhealColour();
            }
            else if ( event.getKey().equals("specialTextColour") )
            {
                vitalTextColour = config.specialTextColour();
            }
            else if ( event.getKey().equals("specialTextOutline") )
            {
                vitalTextOutline = config.specialTextOutline();
            }
        }
        else if ( thisVital == Vital.WARMTH )
        {
            if ( event.getKey().equals("warmthFramesColour") )
            {
                vitalFramesColour = config.warmthFramesColour();
            }
            else if ( event.getKey().equals("warmthBackgroundColour") )
            {
                vitalBackgroundColour = config.warmthBackgroundColour();
            }
            else if ( event.getKey().equals("warmthOverhealColour") )
            {
                vitalOverhealColour = config.warmthOverhealColour();
            }
            else if ( event.getKey().equals("warmthTextColour") )
            {
                vitalTextColour = config.warmthTextColour();
            }
            else if ( event.getKey().equals("warmthTextOutline") )
            {
                vitalTextOutline = config.warmthTextOutline();
            }
        }
    }
}
package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum WarmthRenderOptions
{
    HIDE("Hide"),
    SHOW_ALWAYS("Always Show"),
    SHOW_DYNAMICALLY("Dynamically Show");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

// huge shoutout to DapperMickie of DelayedHeals plugin

package com.neur0tox1n_.customvitalbars;

import java.util.HashMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

@AllArgsConstructor
public enum DelayedHeals
{
    COOKED_WILD_KEBBIT(ItemID.COOKED_WILD_KEBBIT, 7),
    COOKED_LARUPIA(ItemID.COOKED_LARUPIA, 7),
    COOKED_BARBTAILED_KEBBIT(ItemID.COOKED_BARBTAILED_KEBBIT, 7),
    COOKED_GRAAHK(ItemID.COOKED_GRAAHK, 7),
    COOKED_KYATT(ItemID.COOKED_KYATT, 7),
    COOKED_PYRE_FOX(ItemID.COOKED_PYRE_FOX, 7),
    COOKED_DASHING_KEBBIT(ItemID.COOKED_DASHING_KEBBIT, 7),
    COOKED_SUNLIGHT_ANTELOPE(ItemID.COOKED_SUNLIGHT_ANTELOPE, 7),
    COOKED_MOONLIGHT_ANTELOPE(ItemID.COOKED_MOONLIGHT_ANTELOPE, 7);

    @Getter
    private final int itemId;
    @Getter
    private final int tickDelay;

    private static final Map<Integer, DelayedHeals> ITEM_MAP = new HashMap<>();

    static
    {
        for (DelayedHeals heal : DelayedHeals.values())
        {
            ITEM_MAP.put(heal.itemId, heal);
        }
    }

    public static DelayedHeals getDelayedHealByItemId(int itemId)
    {
        return ITEM_MAP.get(itemId);
    }
}
package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum OutlineProgressThreshold
{
    RELATED_STAT_AT_MAX("Related stat = max"),
    NO_THRESHOLD("Always progresses");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2019, Sean Dewar <https://github.com/seandewar>
 * Copyright (c) 2018, Abex
 * Copyright (c) 2018, Zimaya <https://github.com/Zimaya>
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Jos <Malevolentdev@gmail.com>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import javax.inject.Inject;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.itemstats.ItemStatPlugin;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.Set;

import static net.runelite.api.ItemID.*;
import static net.runelite.api.ItemID.MAX_CAPE;

@PluginDescriptor(
	name = "Custom Vital Bars",
	description = "Draws configurable bars showing HP, Prayer, Run energy, Special energy, Warmth, and their respective restoration amounts",
		tags = {"status","vital","vitals","custom","bar","health","hp","hitpoints","pray","run","energy","stamina","special","combat","regen","heal","warmth","wintertodt","Hunter","food","potion"}
)
@PluginDependency(ItemStatPlugin.class)
public class CustomVitalBarsPlugin extends Plugin
{
	@Inject
	private CustomVitalBarsHitpointsOverlay healthOverlay;
	@Inject
	private CustomVitalBarsPrayerOverlay prayerOverlay;
	@Inject
	private CustomVitalBarsEnergyOverlay energyOverlay;
	@Inject
	private CustomVitalBarsSpecialOverlay specialOverlay;
	@Inject
	private CustomVitalBarsWarmthOverlay warmthOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private CustomVitalBarsConfig config;

	@Inject
	private ClientThread clientThread;

	@Getter(AccessLevel.PACKAGE)
	private boolean hitpointsDisplayed;
    @Getter(AccessLevel.PACKAGE)
	private boolean prayerDisplayed;
    @Getter(AccessLevel.PACKAGE)
	private boolean energyDisplayed;
    @Getter(AccessLevel.PACKAGE)
	private boolean specialDisplayed;
    @Getter(AccessLevel.PACKAGE)
	private boolean warmthDisplayed;
	private boolean hideWhenBigUIOpen;

	private int lastCombatActionTickCount;


    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(CustomVitalBarsComponent.class);

	@Override
	protected void startUp() throws Exception
	{
		clientThread.invokeLater(this::checkCustomVitalBars);
		overlayManager.add( healthOverlay );
		overlayManager.add( prayerOverlay );
		overlayManager.add( energyOverlay );
		overlayManager.add( specialOverlay );
		overlayManager.add( warmthOverlay );
		hideWhenBigUIOpen = config.hideWhenLargeInterfacePanelsOpen();
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove( healthOverlay );
		overlayManager.remove( prayerOverlay );
		overlayManager.remove( energyOverlay );
		overlayManager.remove( specialOverlay );
		overlayManager.remove( warmthOverlay );
		hitpointsDisplayed = false;
		prayerDisplayed = false;
		energyDisplayed = false;
		specialDisplayed = false;
		warmthDisplayed = false;
	}

	@Provides
	CustomVitalBarsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CustomVitalBarsConfig.class);
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged ev)
	{
		healthOverlay.onGameStateChanged( ev );
		energyOverlay.onGameStateChanged( ev );
		specialOverlay.onGameStateChanged( ev );
	}

	@Subscribe
	public void onItemContainerChanged( ItemContainerChanged event )
	{
		healthOverlay.onItemContainerChanged( event );
		specialOverlay.onItemContainerChanged( event );
		prayerOverlay.onItemContainerChanged( event );
		warmthOverlay.onItemContainerChanged( event );
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged ev)
	{
		healthOverlay.onVarbitChanged( ev );
		prayerOverlay.onVarbitChanged( ev );
		energyOverlay.onVarbitChanged( ev );
		warmthOverlay.onVarbitChanged( ev );
	}

	@Subscribe
	public void onGameTick( GameTick gameTick )
	{
		checkCustomVitalBars();
		healthOverlay.onGameTick( gameTick );
		specialOverlay.onGameTick( gameTick );
		prayerOverlay.onGameTick( gameTick );
		energyOverlay.onGameTick( gameTick );
		warmthOverlay.onGameTick( gameTick );
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if ( CustomVitalBarsConfig.GROUP.equals(event.getGroup()) && event.getKey().contains( "AfterCombatDelay" ) )
        {
			clientThread.invokeLater( this::checkCustomVitalBars );
		}
        if ( CustomVitalBarsConfig.GROUP.equals(event.getGroup()) && event.getKey().equals("hideWhenLargeInterfacePanelsOpen") )
        {
            hideWhenBigUIOpen = config.hideWhenLargeInterfacePanelsOpen();
        }

        if ( CustomVitalBarsConfig.GROUP.equals(event.getGroup()) )
        {
            healthOverlay.onConfigChanged( event );
            specialOverlay.onConfigChanged( event );
            prayerOverlay.onConfigChanged( event );
            energyOverlay.onConfigChanged( event );
            warmthOverlay.onConfigChanged( event );
        }
	}

	@Subscribe
	public void onWidgetLoaded( WidgetLoaded widgetLoaded )
	{
		if ( !hideWhenBigUIOpen )
		{
			return;
		}

		if (    widgetLoaded.getGroupId() == InterfaceID.BANK ||
				widgetLoaded.getGroupId() == InterfaceID.BANK_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.BANK_PIN ||
				widgetLoaded.getGroupId() == InterfaceID.DEPOSIT_BOX ||
				widgetLoaded.getGroupId() == InterfaceID.FAIRY_RING_PANEL ||
				widgetLoaded.getGroupId() == InterfaceID.SEED_VAULT_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.ACHIEVEMENT_DIARY_SCROLL ||
				widgetLoaded.getGroupId() == InterfaceID.ADVENTURE_LOG ||
				widgetLoaded.getGroupId() == InterfaceID.BARROWS_PUZZLE ||
				widgetLoaded.getGroupId() == InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_PRIVATE ||
				widgetLoaded.getGroupId() == InterfaceID.CHAMBERS_OF_XERIC_STORAGE_UNIT_SHARED ||
				widgetLoaded.getGroupId() == InterfaceID.GROUP_STORAGE ||
				widgetLoaded.getGroupId() == InterfaceID.GROUP_STORAGE_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.GENERIC_SCROLL ||
				widgetLoaded.getGroupId() == InterfaceID.CLUESCROLL ||
				widgetLoaded.getGroupId() == InterfaceID.CLUESCROLL_REWARD ||
				widgetLoaded.getGroupId() == InterfaceID.TRADE_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.SHOP_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.DUEL_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.GRAND_EXCHANGE_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.GUIDE_PRICES_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.EQUIPMENT_INVENTORY ||
				widgetLoaded.getGroupId() == InterfaceID.KEPT_ON_DEATH ||
				widgetLoaded.getGroupId() == InterfaceID.COLLECTION_LOG ||
				widgetLoaded.getGroupId() == InterfaceID.KILL_LOG ||
				widgetLoaded.getGroupId() == InterfaceID.WORLD_MAP )
		{
			healthOverlay.onWidgetLoaded(widgetLoaded);
			prayerOverlay.onWidgetLoaded(widgetLoaded);
			energyOverlay.onWidgetLoaded(widgetLoaded);
			specialOverlay.onWidgetLoaded(widgetLoaded);
			warmthOverlay.onWidgetLoaded(widgetLoaded);
		}
	}

	@Subscribe
	public void onWidgetClosed( WidgetClosed widgetClosed )
	{
		healthOverlay.onWidgetClosed( widgetClosed );
		prayerOverlay.onWidgetClosed( widgetClosed );
		energyOverlay.onWidgetClosed( widgetClosed );
		specialOverlay.onWidgetClosed( widgetClosed );
		warmthOverlay.onWidgetClosed( widgetClosed );
	}

	@Subscribe
	public void onMenuOptionClicked( MenuOptionClicked event )
	{
		healthOverlay.onMenuOptionClicked( event );
        specialOverlay.onMenuOptionClicked( event );
	}

	private void checkCustomVitalBars()
	{
		final Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return;
		}

		final Actor interacting = localPlayer.getInteracting();
        int hideHitpointAfterCombatDelay = config.hideHitpointsAfterCombatDelay();
        int hidePrayerAfterCombatDelay = config.hidePrayerAfterCombatDelay();
        int hideEnergyAfterCombatDelay = config.hideEnergyAfterCombatDelay();
        int hideSpecialAfterCombatDelay = config.hideSpecialAfterCombatDelay();
        int hideWarmthAfterCombatDelay = config.hideWarmthAfterCombatDelay();
        boolean doInteractionCheck = false;

        if ( hideHitpointAfterCombatDelay == 0 )
        {
            hitpointsDisplayed = true;
        }
        else
        {
            doInteractionCheck = true;
        }
        if ( hidePrayerAfterCombatDelay == 0 )
        {
            prayerDisplayed = true;
        }
        else
        {
            doInteractionCheck = true;
        }
        if ( hideEnergyAfterCombatDelay == 0 )
        {
            energyDisplayed = true;
        }
        else
        {
            doInteractionCheck = true;
        }
        if ( hideSpecialAfterCombatDelay == 0 )
        {
            specialDisplayed = true;
        }
        else
        {
            doInteractionCheck = true;
        }
        if ( hideWarmthAfterCombatDelay == 0 )
        {
            warmthDisplayed = true;
        }
        else
        {
            doInteractionCheck = true;
        }

		if ( doInteractionCheck && (interacting instanceof NPC && ArrayUtils.contains(((NPC) interacting).getComposition().getActions(), "Attack"))
                || (interacting instanceof Player && client.getVarbitValue(Varbits.PVP_SPEC_ORB) == 1) )
		{
			lastCombatActionTickCount = client.getTickCount();

            if ( config.hideHitpointsAfterCombatDelay() > 0 )
            {
                hitpointsDisplayed = true;
            }
            if ( config.hidePrayerAfterCombatDelay() > 0 )
            {
                prayerDisplayed = true;
            }
            if ( config.hideEnergyAfterCombatDelay() > 0 )
            {
                energyDisplayed = true;
            }
            if ( config.hideSpecialAfterCombatDelay() > 0 )
            {
                specialDisplayed = true;
            }
            if ( config.hideWarmthAfterCombatDelay() > 0 )
            {
                warmthDisplayed = true;
            }
		}
		else if ( doInteractionCheck )
		{
            if ( (client.getTickCount() - lastCombatActionTickCount >= hideHitpointAfterCombatDelay) && hideHitpointAfterCombatDelay > 0 )
            {
                hitpointsDisplayed = false;
            }
            if ( (client.getTickCount() - lastCombatActionTickCount >= hidePrayerAfterCombatDelay) && hidePrayerAfterCombatDelay > 0 )
            {
                prayerDisplayed = false;
            }
            if ( (client.getTickCount() - lastCombatActionTickCount >= hideEnergyAfterCombatDelay) && hideEnergyAfterCombatDelay > 0 )
            {
                energyDisplayed = false;
            }
            if ( (client.getTickCount() - lastCombatActionTickCount >= hideSpecialAfterCombatDelay) && hideSpecialAfterCombatDelay > 0 )
            {
                specialDisplayed = false;
            }
            if ( (client.getTickCount() - lastCombatActionTickCount >= hideWarmthAfterCombatDelay) && hideWarmthAfterCombatDelay > 0 )
            {
                warmthDisplayed = false;
            }
		}
	}
}


package com.neur0tox1n_.customvitalbars;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;

import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.Text;

public class CustomVitalBarsSpecialOverlay extends OverlayPanel
{
    private static final int MAX_SPECIAL_ATTACK_VALUE = 100;

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;

    private static final int SPEC_REGEN_TICKS = 50;
    private static final int SURGE_POTION_BASE_COOLDOWN_MILLISECONDS = 300000;
    @Getter
    private double specialPercentageOrSurgeCooldown;

    private int ticksSinceSpecRegen;
    private boolean wearingLightbearer;

    private long millisecondsSinceSpecRegen;
    private long deltaTime;
    private long lastTime;

    private long surgePotionCooldown = 0;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;

    private int deltaX = 0, deltaY = 0;
    private int lastKnownSidebarX = 0, lastKnownSidebarY = 0;
    private int lastX = 0, lastY = 0;

    private Color specialMainColour, specialHealColour, specialSurgeCooldownColour;

    private boolean isDrinking = false;
    private final Map<Integer, Integer> previousInventory = new HashMap<>();

    @Inject
    private OverlayManager overlayManager;

    private final ConfigManager configManager;


    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(CustomVitalBarsComponent.class);


    @Inject
    CustomVitalBarsSpecialOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager, ConfigManager configManager )
    {
        super(plugin);

        //setPriority(OverlayPriority.LOW);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;
        this.configManager = configManager;

        lastKnownSidebarX = config.debugSidebarPanelX();
        lastKnownSidebarY = config.debugSidebarPanelY();

        specialMainColour = config.specialMainColour();
        specialHealColour = config.specialHealColour();
        specialSurgeCooldownColour = config.specialSurgeCooldownColour();

        initRenderer();

        if ( config.specialRelativeToInventory() )
        {
            toggleLock( true );
        }
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> MAX_SPECIAL_ATTACK_VALUE,
                () -> client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10,
                () -> 0,
                () -> (surgePotionCooldown > 0 ? specialSurgeCooldownColour : specialMainColour),
                () -> specialHealColour,
                () -> specialPercentageOrSurgeCooldown,
                () -> loadSprite(SpriteID.MINIMAP_ORB_SPECIAL_ICON)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        if ( client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) == 1000 && surgePotionCooldown <= 0 )
        {
            millisecondsSinceSpecRegen = 0;
            specialPercentageOrSurgeCooldown = 0;
            surgePotionCooldown = 0;
        }
        else
        {
            double millisecondsPerSpecRegen = wearingLightbearer ? SPEC_REGEN_TICKS / 2 : SPEC_REGEN_TICKS;
            millisecondsPerSpecRegen *= 0.6d * 1000;
            millisecondsSinceSpecRegen = (long)((millisecondsSinceSpecRegen + deltaTime) % millisecondsPerSpecRegen);


            if ( surgePotionCooldown <= 0 )
            {
                surgePotionCooldown = 0;
                specialPercentageOrSurgeCooldown = millisecondsSinceSpecRegen / millisecondsPerSpecRegen;
            }
            else
            {
                surgePotionCooldown -= deltaTime;

                OutlineProgressSelection outlineOption = config.specialOutlineProgressSelection();
                if ( outlineOption == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY )
                {
                    specialPercentageOrSurgeCooldown = millisecondsSinceSpecRegen / millisecondsPerSpecRegen;
                }
                else if ( outlineOption == OutlineProgressSelection.SHOW_CONSUMABLE_PROGRESS_ONLY || outlineOption == OutlineProgressSelection.SHOW_NATURAL_AND_CONSUMABLE_PROGRESS )
                {
                    specialPercentageOrSurgeCooldown = (double) surgePotionCooldown / SURGE_POTION_BASE_COOLDOWN_MILLISECONDS;
                }
            }
        }

        Viewport curViewport = null;
        Widget curWidget = null;

        for (Viewport viewport : Viewport.values())
        {
            final Widget viewportWidget = client.getWidget(viewport.getViewport());
            if ( viewportWidget != null )
            {
                if ( !viewportWidget.isHidden() )
                {
                    curViewport = viewport;
                    curWidget = viewportWidget;

                    final net.runelite.api.Point location = viewportWidget.getCanvasLocation();
                    lastKnownSidebarX = location.getX();
                    lastKnownSidebarY = location.getY();

                    break;
                }
            }
        }

        if ( config.hideSpecialWhenSidebarPanelClosed() )
        {
            if (curViewport == null)
            {
                return null;
            }
        }

        if ( config.specialRelativeToInventory() )
        {
            if (curViewport != null)
            {
                final net.runelite.api.Point location = curWidget.getCanvasLocation();

                if ( deltaX != 0 && deltaY != 0 )
                {
                    int newDeltaX = (int) (location.getX() + deltaX);
                    int newDeltaY = (int) (location.getY() + deltaY);
                    this.setPreferredLocation( new java.awt.Point(newDeltaX, newDeltaY) );

                    if ( lastX != newDeltaX || lastY != newDeltaY )
                    {
                        overlayManager.saveOverlay(this);
                    }
                    lastX = newDeltaX;
                    lastY = newDeltaY;
                }
            }
        }

        if ( plugin.isSpecialDisplayed() && config.renderSpecial() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.SPECIAL_ENERGY, (surgePotionCooldown > 0), client );

            return config.specialSize();
        }

        return null;
    }

    @Subscribe
    public void onConfigChanged( ConfigChanged event )
    {
        if ( CustomVitalBarsConfig.GROUP.equals(event.getGroup()) && event.getKey().equals("specialRelativeToSidebarPanel") )
        {
            toggleLock( false );
        }
        else if ( event.getKey().equals("specialMainColour") )
        {
            specialMainColour = config.specialMainColour();
        }
        else if ( event.getKey().equals("specialHealColour") )
        {
            specialHealColour = config.specialHealColour();
        }
        else if ( event.getKey().equals("specialSurgeCooldownColour") )
        {
            specialSurgeCooldownColour = config.specialSurgeCooldownColour();
        }
    }

    private void updateInventoryState()
    {
        previousInventory.clear();
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory != null)
        {
            for (Item item : inventory.getItems())
            {
                previousInventory.merge(item.getId(), item.getQuantity(), Integer::sum);
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged ev)
    {
        if (ev.getGameState() == GameState.HOPPING || ev.getGameState() == GameState.LOGIN_SCREEN)
        {
            ticksSinceSpecRegen = 0;
        }

        if ( ev.getGameState().equals( GameState.LOGGED_IN ) )
        {
            isDrinking = false;
            updateInventoryState();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if ( event.getContainerId() == InventoryID.INVENTORY.getId() || event.getContainerId() == InventoryID.BANK.getId())
        {
            if ( isDrinking )
            {
                detectConsumableUsage();
                isDrinking = false;
            }
            updateInventoryState();
        }
        else if (event.getContainerId() != InventoryID.EQUIPMENT.getId())
        {
            return;
        }

        ItemContainer equipment = event.getItemContainer();
        final boolean hasLightbearer = equipment.contains(ItemID.LIGHTBEARER);
        if (hasLightbearer == wearingLightbearer)
        {
            return;
        }

        ticksSinceSpecRegen = 0;
        wearingLightbearer = hasLightbearer;
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        final int ticksPerSpecRegen = wearingLightbearer ? SPEC_REGEN_TICKS / 2 : SPEC_REGEN_TICKS;

        if ( client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) < 1000 )
        {
            ticksSinceSpecRegen = (ticksSinceSpecRegen + 1) % ticksPerSpecRegen;
            millisecondsSinceSpecRegen = (long) (ticksSinceSpecRegen * 0.6 * 1000);
        }
        else if ( surgePotionCooldown == 0 )
        {
            ticksSinceSpecRegen = 0;
            millisecondsSinceSpecRegen = 0;
        }

        if ( surgePotionCooldown > 0 )
        {
            OutlineProgressSelection outlineOption = config.specialOutlineProgressSelection();
            if ( outlineOption == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY )
            {
                specialPercentageOrSurgeCooldown = ticksSinceSpecRegen / (double) ticksPerSpecRegen;
            }
            else if ( outlineOption == OutlineProgressSelection.SHOW_CONSUMABLE_PROGRESS_ONLY || outlineOption == OutlineProgressSelection.SHOW_NATURAL_AND_CONSUMABLE_PROGRESS )
            {
                specialPercentageOrSurgeCooldown = (double) surgePotionCooldown / SURGE_POTION_BASE_COOLDOWN_MILLISECONDS;
            }
        }
        else
        {
            //surgePotionCooldown = 0;
            specialPercentageOrSurgeCooldown = ticksSinceSpecRegen / (double) ticksPerSpecRegen;
        }

        isDrinking = false;
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }

    public void toggleLock( boolean start )
    {
        if ( deltaX == 0 && deltaY == 0 )
        {
            if ( start )
            {
                deltaX = config.debugSpecialDeltaX();
                deltaY = config.debugSpecialDeltaY();
            }
            else
            {
                deltaX = (int) (this.getPreferredLocation().getX() - lastKnownSidebarX);
                deltaY = (int) (this.getPreferredLocation().getY() - lastKnownSidebarY);
            }
        }
        else
        {
            deltaX = 0;
            deltaY = 0;
        }
        configManager.setConfiguration( "Custom Vital Bars", "debugSpecialDeltaX", (int) deltaX );
        configManager.setConfiguration( "Custom Vital Bars", "debugSpecialDeltaY", (int) deltaY );
    }

    @Subscribe
    public void onMenuOptionClicked( MenuOptionClicked event )
    {
        String menuOption = Text.removeTags( event.getMenuOption() );
        if ( menuOption.equals( "Drink" ) && isApplicableConsumable( event.getItemId() ) )
        {
            isDrinking = true;
        }
    }

    private boolean isApplicableConsumable(int itemId)
    {
        SpecialEnergyRestoration item = SpecialEnergyRestoration.getSpecialRestorationByItemId(itemId);
        return item != null;
    }

    private void detectConsumableUsage()
    {
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory == null)
        {
            return;
        }

        Map<Integer, Integer> currentInventory = new HashMap<>();
        for (Item item : inventory.getItems())
        {
            currentInventory.merge(item.getId(), item.getQuantity(), Integer::sum);
        }

        for (Map.Entry<Integer, Integer> entry : previousInventory.entrySet())
        {
            int itemID = entry.getKey();
            int previousItemQuantity = entry.getValue();
            if (previousItemQuantity > currentInventory.getOrDefault(itemID, 0) && isApplicableConsumable(itemID))
            {
                handleConsumable(itemID);
            }
        }
    }

    private void handleConsumable(int itemId)
    {
        SpecialEnergyRestoration item = SpecialEnergyRestoration.getSpecialRestorationByItemId(itemId);

        surgePotionCooldown = item.getCooldown();
    }
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum OutlineProgressSelection
{
    SHOW_NATURAL_AND_CONSUMABLE_PROGRESS("Show all progress"),
    SHOW_NATURAL_PROGRESS_ONLY("Show progress related to natural regen/degen only"),
    SHOW_CONSUMABLE_PROGRESS_ONLY("Show progress related to consumables only"),
    HIDE("Always disabled");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2018, Sean Dewar <https://github.com/seandewar>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.util.RSTimeUnit;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;
import java.util.function.IntPredicate;
import java.util.function.IntUnaryOperator;

import static com.neur0tox1n_.customvitalbars.GameTimer.STAMINA;
import static net.runelite.api.ItemID.*;

public class CustomVitalBarsEnergyOverlay extends OverlayPanel
{
    // love to RunEnergyPlugin
    @Getter
    protected enum GracefulEquipmentSlot
    {
        HEAD(EquipmentInventorySlot.HEAD.getSlotIdx(), 3, GRACEFUL_HOOD),
        BODY(EquipmentInventorySlot.BODY.getSlotIdx(), 4, GRACEFUL_TOP),
        LEGS(EquipmentInventorySlot.LEGS.getSlotIdx(), 4, GRACEFUL_LEGS),
        GLOVES(EquipmentInventorySlot.GLOVES.getSlotIdx(), 3, GRACEFUL_GLOVES),
        BOOTS(EquipmentInventorySlot.BOOTS.getSlotIdx(), 3, GRACEFUL_BOOTS),
        // Agility skill capes and the non-cosmetic Max capes also count for the Graceful set effect
        CAPE(EquipmentInventorySlot.CAPE.getSlotIdx(), 3, GRACEFUL_CAPE, AGILITY_CAPE, MAX_CAPE);

        private final int index;
        private final int boost;
        private final Set<Integer> items;

        GracefulEquipmentSlot(int index, int boost, int... baseItems)
        {
            this.index = index;
            this.boost = boost;

            final ImmutableSet.Builder<Integer> itemsBuilder = ImmutableSet.builder();
            for (int item : baseItems)
            {
                itemsBuilder.addAll(ItemVariationMapping.getVariations(item));
            }
            items = itemsBuilder.build();
        }

        private static final int TOTAL_BOOSTS = Arrays.stream(values()).mapToInt(GracefulEquipmentSlot::getBoost).sum();
    }
    // Full set grants an extra 10% boost to recovery rate
    private static final int GRACEFUL_FULL_SET_BOOST_BONUS = 10;

    private final int MAX_RUN_ENERGY_VALUE = 100;
    private final int STAMINA_DURATION_TICKS = 200;

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;

    private double staminaDurationRemainingPercentage = 0;
    private double runEnergyRegenerationPercentage = 0;

    private int lastStaminaEffectActive = 0;
    private int staminaEffectActive = 0;

    private int nextHighestRunEnergyMark = 0;
    private int ticksSinceRunEnergyRegen = 0;
    private int ticksToRunEnergyRegen;
    private long millisecondsToRunEnergyRegen;
    private long millisecondsSinceRunEnergyRegen;

    private long millisecondsSinceStaminaPotionDrink;
    private long ticksSinceStaminaPotionDrink;

    private boolean localPlayerRunningToDestination = false;
    private boolean lastLocalPlayerRunningToDestination = false;
    private boolean regenAlreadyStarted = false;

    private int baseStaminaDurationTicks = STAMINA_DURATION_TICKS;
    private int maxStaminaTicks = STAMINA_DURATION_TICKS;

    private WorldPoint prevLocalPlayerLocation;

    private long deltaTime;
    private long lastTime;

    private final Map<GameTimer, TimerTimer> varTimers = new EnumMap<>(GameTimer.class);

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;

    private int deltaX = 0, deltaY = 0;
    private int lastKnownSidebarX = 0, lastKnownSidebarY = 0;
    private int lastX = 0, lastY = 0;

    private int lastEnergyValue = 0;

    private Color energyMainColour, energyHealColour, energyStaminaColour;

    @Inject
    private OverlayManager overlayManager;

    private final ConfigManager configManager;

    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(CustomVitalBarsComponent.class);


    @Inject
    CustomVitalBarsEnergyOverlay( Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager, ConfigManager configManager  )
    {
        super(plugin);

        setPriority(OverlayPriority.HIGH);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;
        this.configManager = configManager;

        lastKnownSidebarX = config.debugSidebarPanelX();
        lastKnownSidebarY = config.debugSidebarPanelY();

        energyMainColour = config.energyMainColour();
        energyHealColour = config.energyHealColour();
        energyStaminaColour = config.energyStaminaColour();

        initRenderer();

        if ( config.energyRelativeToInventory() )
        {
            toggleLock( true );
        }
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> MAX_RUN_ENERGY_VALUE,
                () -> client.getEnergy() / 100,
                () -> getRestoreValue("Run Energy"),
                () ->
                {
                    if ( client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE) != 0 )
                    {
                        return energyStaminaColour;
                    }
                    else
                    {
                        return energyMainColour;
                    }
                },
                () -> energyHealColour,
                () ->
                {
                    if ( config.energyOutlineProgressSelection() == OutlineProgressSelection.SHOW_NATURAL_PROGRESS_ONLY )
                    {
                        return runEnergyRegenerationPercentage;
                    }
                    else if ( config.energyOutlineProgressSelection() == OutlineProgressSelection.SHOW_CONSUMABLE_PROGRESS_ONLY )
                    {
                        return staminaDurationRemainingPercentage;
                    }

                    return ((staminaEffectActive == 1) ? staminaDurationRemainingPercentage : runEnergyRegenerationPercentage);
                },
                () -> loadSprite(SpriteID.MINIMAP_ORB_WALK_ICON)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        if ( !localPlayerRunningToDestination )
        {
            if ( client.getEnergy() == MAX_RUN_ENERGY_VALUE * 100 )
            {
                nextHighestRunEnergyMark = 0;
                if ( config.energyOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
                {
                    runEnergyRegenerationPercentage = 0;
                }
            }
            else if ( client.getEnergy() >= nextHighestRunEnergyMark )
            {
                nextHighestRunEnergyMark = ((client.getEnergy() + 99) / 100) * 100;
                int rawRunEnergyRegenPerTick = (int)Math.floor( (1 + (getGracefulRecoveryBoost() / 100.0d)) * (Math.floor( client.getBoostedSkillLevel( Skill.AGILITY ) / 10.0d ) + 15));

                ticksToRunEnergyRegen = (int) (Math.ceil((nextHighestRunEnergyMark - client.getEnergy()) / (double) rawRunEnergyRegenPerTick) );
                millisecondsToRunEnergyRegen = (long)(ticksToRunEnergyRegen * 0.6 * 1000);

                millisecondsSinceRunEnergyRegen = 0;
                ticksSinceRunEnergyRegen = 0;
                runEnergyRegenerationPercentage = 0;
            }
            else {
                nextHighestRunEnergyMark = ((client.getEnergy() + 99) / 100) * 100;
                if (millisecondsToRunEnergyRegen > 0) {
                    millisecondsSinceRunEnergyRegen = (millisecondsSinceRunEnergyRegen + deltaTime) % millisecondsToRunEnergyRegen;
                    runEnergyRegenerationPercentage = millisecondsSinceRunEnergyRegen / (double) millisecondsToRunEnergyRegen;
                } else {
                    millisecondsSinceRunEnergyRegen = 0;
                    runEnergyRegenerationPercentage = 0;
                }
            }
        }

        /*
        if ( staminaEffectActive == 1 )
        {
            long millisecondsToStaminaPotionExpire = (long)(baseStaminaDurationTicks * 0.6 * 1000);

            millisecondsSinceStaminaPotionDrink = (millisecondsSinceStaminaPotionDrink + deltaTime) % millisecondsToStaminaPotionExpire;
            staminaDurationRemainingPercentage = 1 - ((double) millisecondsSinceStaminaPotionDrink / millisecondsToStaminaPotionExpire);
        }

         */

        Viewport curViewport = null;
        Widget curWidget = null;

        for (Viewport viewport : Viewport.values())
        {
            final Widget viewportWidget = client.getWidget(viewport.getViewport());
            if ( viewportWidget != null )
            {
                if ( !viewportWidget.isHidden() )
                {
                    curViewport = viewport;
                    curWidget = viewportWidget;

                    final net.runelite.api.Point location = viewportWidget.getCanvasLocation();
                    lastKnownSidebarX = location.getX();
                    lastKnownSidebarY = location.getY();
                    configManager.setConfiguration( "Custom Vital Bars", "debugSidebarPanelX", lastKnownSidebarX );
                    configManager.setConfiguration( "Custom Vital Bars", "debugSidebarPanelY", lastKnownSidebarY );

                    break;
                }
            }
        }

        if ( config.hideEnergyWhenSidebarPanelClosed() )
        {
            if (curViewport == null)
            {
                return null;
            }
        }

        if ( config.energyRelativeToInventory() )
        {
            if (curViewport != null)
            {
                final net.runelite.api.Point location = curWidget.getCanvasLocation();

                if ( deltaX != 0 && deltaY != 0 )
                {
                    int newDeltaX = (int) (location.getX() + deltaX);
                    int newDeltaY = (int) (location.getY() + deltaY);
                    this.setPreferredLocation( new java.awt.Point(newDeltaX, newDeltaY) );
                    if ( lastX != newDeltaX || lastY != newDeltaY )
                    {
                        overlayManager.saveOverlay(this);
                    }
                    lastX = newDeltaX;
                    lastY = newDeltaY;
                }
            }
        }

        if ( plugin.isEnergyDisplayed() && config.renderEnergy() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.RUN_ENERGY, (staminaEffectActive == 1), client );
            return config.energySize();
        }

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    public void onVarbitChanged( VarbitChanged event )
    {
        if (event.getVarbitId() == Varbits.RUN_SLOWED_DEPLETION_ACTIVE
                || event.getVarbitId() == Varbits.STAMINA_EFFECT
                || event.getVarbitId() == Varbits.RING_OF_ENDURANCE_EFFECT)
        {
            // staminaEffectActive is checked to match https://github.com/Joshua-F/cs2-scripts/blob/741271f0c3395048c1bad4af7881a13734516adf/scripts/%5Bproc%2Cbuff_bar_get_value%5D.cs2#L25
            lastStaminaEffectActive = staminaEffectActive;
            staminaEffectActive = client.getVarbitValue(Varbits.RUN_SLOWED_DEPLETION_ACTIVE);
            int staminaPotionEffectVarb = client.getVarbitValue(Varbits.STAMINA_EFFECT);
            int enduranceRingEffectVarb = client.getVarbitValue(Varbits.RING_OF_ENDURANCE_EFFECT);

            final int totalStaminaEffect = staminaPotionEffectVarb + enduranceRingEffectVarb;
            if ( staminaEffectActive == 1 )
            {
                updateVarTimer( STAMINA, totalStaminaEffect, i -> i * 10 );
            }
        }
    }

    public void onGameStateChanged(GameStateChanged ev)
    {
        if (ev.getGameState() == GameState.HOPPING || ev.getGameState() == GameState.LOGIN_SCREEN)
        {
            ticksSinceRunEnergyRegen = -2; // For some reason this makes this accurate
            millisecondsSinceRunEnergyRegen = (long)(ticksSinceRunEnergyRegen * 0.6 * 1000); // I guess I follow suit
        }
    }

    @Subscribe
    public void onConfigChanged( ConfigChanged event )
    {
        if ( barRenderer != null )
        {
            barRenderer.onConfigChanged( event );
        }

        if ( event.getKey().equals("energyRelativeToSidebarPanel") )
        {
            toggleLock( false );
        }
        else if ( event.getKey().equals("energyMainColour") )
        {
            energyMainColour = config.energyMainColour();
        }
        else if ( event.getKey().equals("energyHealColour") )
        {
            energyHealColour = config.energyHealColour();
        }
        else if ( event.getKey().equals("energyStaminaColour") )
        {
            energyStaminaColour = config.energyStaminaColour();
        }
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        lastLocalPlayerRunningToDestination = localPlayerRunningToDestination;
        localPlayerRunningToDestination =
                prevLocalPlayerLocation != null &&
                        client.getLocalDestinationLocation() != null &&
                        prevLocalPlayerLocation.distanceTo(client.getLocalPlayer().getWorldLocation()) > 1;
        prevLocalPlayerLocation = client.getLocalPlayer().getWorldLocation();

        if (!localPlayerRunningToDestination && !lastLocalPlayerRunningToDestination && !regenAlreadyStarted) {
            ticksSinceRunEnergyRegen = 0;
            millisecondsSinceRunEnergyRegen = 0;
            runEnergyRegenerationPercentage = 0;

            regenAlreadyStarted = true;
        }

        if ( localPlayerRunningToDestination )
        {
            ticksSinceRunEnergyRegen = 0;
            millisecondsSinceRunEnergyRegen = 0;
            runEnergyRegenerationPercentage = 0;

            regenAlreadyStarted = false;
        }
        else
        {
            int currentRunEnergy = client.getEnergy();
            if ( currentRunEnergy == MAX_RUN_ENERGY_VALUE * 100 )
            {
                nextHighestRunEnergyMark = 0;
                if ( config.energyOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
                {
                    runEnergyRegenerationPercentage = 0;
                }
            }
            else
            {
                // synchronise
                if ( lastEnergyValue < client.getEnergy() / 100 )
                {
                    ticksSinceRunEnergyRegen = 0;
                    millisecondsSinceRunEnergyRegen = 0;
                    runEnergyRegenerationPercentage = 0;
                }
                else
                {
                    if (currentRunEnergy >= nextHighestRunEnergyMark) {
                        int rawRunEnergyRegenPerTick = (int) Math.floor((1 + (getGracefulRecoveryBoost() / 100.0d)) * (Math.floor(client.getBoostedSkillLevel(Skill.AGILITY) / 10.0d) + 15));

                        nextHighestRunEnergyMark = ((currentRunEnergy + 99) / 100) * 100;

                        ticksToRunEnergyRegen = (int) (Math.ceil((nextHighestRunEnergyMark - currentRunEnergy) / (double) rawRunEnergyRegenPerTick ));
                        millisecondsToRunEnergyRegen = (long) (ticksToRunEnergyRegen * 0.6 * 1000);

                        ticksSinceRunEnergyRegen = 0;
                        millisecondsSinceRunEnergyRegen = 0;
                        runEnergyRegenerationPercentage = 0;
                    } else {
                        nextHighestRunEnergyMark = ((currentRunEnergy + 99) / 100) * 100;
                        if (ticksToRunEnergyRegen > 0) {
                            ticksSinceRunEnergyRegen = (ticksSinceRunEnergyRegen + 1) % ticksToRunEnergyRegen;
                            millisecondsSinceRunEnergyRegen = (long) (ticksSinceRunEnergyRegen * 0.6 * 1000);
                            runEnergyRegenerationPercentage = ticksSinceRunEnergyRegen / (double) ticksToRunEnergyRegen;
                        } else {
                            ticksSinceRunEnergyRegen = 0;
                            millisecondsSinceRunEnergyRegen = 0;
                            runEnergyRegenerationPercentage = 0;
                        }
                    }
                }
                lastEnergyValue = client.getEnergy() / 100;
            }
        }
    }


    private int getGracefulRecoveryBoost()
    {
        final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);

        if (equipment == null)
        {
            return 0;
        }

        final Item[] items = equipment.getItems();

        int boost = 0;

        for (final GracefulEquipmentSlot slot : GracefulEquipmentSlot.values())
        {
            if (items.length <= slot.getIndex())
            {
                continue;
            }

            final Item wornItem = items[slot.getIndex()];

            if (wornItem != null && slot.getItems().contains(wornItem.getId()))
            {
                boost += slot.getBoost();
            }
        }

        if (boost == GracefulEquipmentSlot.TOTAL_BOOSTS)
        {
            boost += GRACEFUL_FULL_SET_BOOST_BONUS;
        }

        return boost;
    }

    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }

    private void updateVarTimer( final GameTimer gameTimer, final int varValue, final IntUnaryOperator tickDuration )
    {
        updateVarTimer( gameTimer, varValue, i -> i == 0, tickDuration);
    }

    private void updateVarTimer( final GameTimer gameTimer, final int varValue, final IntPredicate removeTimerCheck, final IntUnaryOperator tickDuration )
    {
        TimerTimer timer = varTimers.get(gameTimer);
        int ticks = tickDuration.applyAsInt( varValue );
        final Duration duration = Duration.of( ticks, RSTimeUnit.GAME_TICKS );

        if ( removeTimerCheck.test( varValue ) )
        {
            removeVarTimer( gameTimer );
            ticks = 0;
        }
        // Reset the timer when its duration increases in order to allow it to turn red at the correct time even when refreshed early
        else if (timer == null || ticks > timer.ticks)
        {
            timer = createGameTimer(gameTimer, duration);
            timer.ticks = ticks;
            varTimers.put(gameTimer, timer);
        }
        else
        {
            timer.ticks = ticks;
            timer.updateDuration(duration);
        }

        staminaDurationRemainingPercentage = (double) ticks / maxStaminaTicks;
    }

    private TimerTimer createGameTimer(final GameTimer timer, Duration duration)
    {
        TimerTimer t = new TimerTimer(timer, duration, plugin);
        return t;
    }

    private void removeVarTimer( GameTimer gameTimer )
    {
        varTimers.remove( gameTimer );
    }

    public void toggleLock( boolean start )
    {
        if ( deltaX == 0 && deltaY == 0 )
        {
            if ( start )
            {
                deltaX = config.debugEnergyDeltaX();
                deltaY = config.debugEnergyDeltaY();
            }
            else
            {
                deltaX = (int) (this.getPreferredLocation().getX() - lastKnownSidebarX);
                deltaY = (int) (this.getPreferredLocation().getY() - lastKnownSidebarY);
            }
        }
        else
        {
            deltaX = 0;
            deltaY = 0;
        }
        configManager.setConfiguration( "Custom Vital Bars", "debugEnergyDeltaX", (int) deltaX );
        configManager.setConfiguration( "Custom Vital Bars", "debugEnergyDeltaY", (int) deltaY );
    }
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum ThresholdGlowMode
{
    ABOVE_PERCENTAGE("Percentage, above threshold"),
    ABOVE_FLAT_VALUE("Flat value, above threshold"),
    BELOW_PERCENTAGE("Percentage, below threshold"),
    BELOW_FLAT_VALUE("Flat value, below threshold"),
    NONE("Disable glow");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum LabelPlacement
{
    TOP("Top"),
    BOTTOM("Bottom"),
    LEFT("Left"),
    RIGHT("Right"),
    CENTRE("Centre");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TextFormatting
{
    SHOW_CURRENT_AND_MAXIMUM("CURRENT / MAXIMUM"),
    SHOW_CURRENT("CURRENT"),
    SHOW_PERCENTAGE("CURRENT %"),
    HIDE("Hide label");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2018, Raqes <j.raqes@gmail.com>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Prayer;
import net.runelite.api.SpriteID;

@AllArgsConstructor
@Getter
enum PrayerType
{
	THICK_SKIN("Thick Skin", Prayer.THICK_SKIN, "+5% Defence", SpriteID.PRAYER_THICK_SKIN, false, 3),
	BURST_OF_STRENGTH("Burst of Strength", Prayer.BURST_OF_STRENGTH, "+5% Strength", SpriteID.PRAYER_BURST_OF_STRENGTH, false, 3),
	CLARITY_OF_THOUGHT("Clarity of Thought", Prayer.CLARITY_OF_THOUGHT, "+5% Attack", SpriteID.PRAYER_CLARITY_OF_THOUGHT, false, 3),
	SHARP_EYE("Sharp Eye", Prayer.SHARP_EYE, "+5% Ranged", SpriteID.PRAYER_SHARP_EYE, false, 3),
	MYSTIC_WILL("Mystic Will", Prayer.MYSTIC_WILL, "+5% Magical attack and defence", SpriteID.PRAYER_MYSTIC_WILL, false, 3),
	ROCK_SKIN("Rock Skin", Prayer.ROCK_SKIN, "+10% Defence", SpriteID.PRAYER_ROCK_SKIN, false, 6),
	SUPERHUMAN_STRENGTH("Superhuman Strength", Prayer.SUPERHUMAN_STRENGTH, "+10% Strength", SpriteID.PRAYER_SUPERHUMAN_STRENGTH, false, 6),
	IMPROVED_REFLEXES("Improved Reflexes", Prayer.IMPROVED_REFLEXES, "+10% Attack", SpriteID.PRAYER_IMPROVED_REFLEXES, false, 6),
	RAPID_RESTORE("Rapid Restore", Prayer.RAPID_RESTORE, "2 x Restore rate for all skills except Hitpoints and Prayer", SpriteID.PRAYER_RAPID_RESTORE, false, 1),
	RAPID_HEAL("Rapid Heal", Prayer.RAPID_HEAL, "2 x Restore rate for Hitpoints", SpriteID.PRAYER_RAPID_HEAL, false, 2),
	PROTECT_ITEM("Protect Item", Prayer.PROTECT_ITEM, "Player keeps 1 extra item when they die", SpriteID.PRAYER_PROTECT_ITEM, false, 2),
	HAWK_EYE("Hawk Eye", Prayer.HAWK_EYE, "+10% Ranged", SpriteID.PRAYER_HAWK_EYE, false, 6),
	MYSTIC_LORE("Mystic Lore", Prayer.MYSTIC_LORE, "+10% Magical attack and defence", SpriteID.PRAYER_MYSTIC_LORE, false, 6),
	STEEL_SKIN("Steel Skin", Prayer.STEEL_SKIN, "+15% Defence", SpriteID.PRAYER_STEEL_SKIN, false, 12),
	ULTIMATE_STRENGTH("Ultimate Strength", Prayer.ULTIMATE_STRENGTH, "+15% Strength", SpriteID.PRAYER_ULTIMATE_STRENGTH, false, 12),
	INCREDIBLE_REFLEXES("Incredible reflexes", Prayer.INCREDIBLE_REFLEXES, "+15% Attack", SpriteID.PRAYER_INCREDIBLE_REFLEXES, false, 12),
	PROTECT_FROM_MAGIC("protect from magic", Prayer.PROTECT_FROM_MAGIC, "Protects against magic attacks", SpriteID.PRAYER_PROTECT_FROM_MAGIC, true, 12),
	PROTECT_FROM_MISSILES("Protect from missiles", Prayer.PROTECT_FROM_MISSILES, "Protects against ranged attacks", SpriteID.PRAYER_PROTECT_FROM_MISSILES, true, 12),
	PROTECT_FROM_MELEE("Protect from melee", Prayer.PROTECT_FROM_MELEE, "Protects against melee attacks", SpriteID.PRAYER_PROTECT_FROM_MELEE, true, 12),
	EAGLE_EYE("Eagle Eye", Prayer.EAGLE_EYE, "+15% Ranged", SpriteID.PRAYER_EAGLE_EYE, false, 12),
	MYSTIC_MIGHT("Mystic Might", Prayer.MYSTIC_MIGHT, "+15% Magical attack and defence", SpriteID.PRAYER_MYSTIC_MIGHT, false, 12),
	RETRIBUTION("Retribution", Prayer.RETRIBUTION, "Deals damage up to 25% of your Prayer level to nearby targets upon the user's death", SpriteID.PRAYER_RETRIBUTION, true, 3),
	REDEMPTION("Redemption", Prayer.REDEMPTION, "Heals the player if they fall below 10% health", SpriteID.PRAYER_REDEMPTION, true, 6),
	SMITE("Smite", Prayer.SMITE, "Removes 1 Prayer point from an enemy for every 4 damage inflicted on the enemy", SpriteID.PRAYER_SMITE, true, 18),
	PRESERVE("Preserve", Prayer.PRESERVE, "Boosted stats last 50% longer", SpriteID.PRAYER_PRESERVE, false, 2),
	CHIVALRY("Chivalry", Prayer.CHIVALRY, "+15% Attack, +18% Strength, +20% Defence", SpriteID.PRAYER_CHIVALRY, false, 24),
	PIETY("Piety", Prayer.PIETY, "+20% Attack, +23% Strength, +25% Defence", SpriteID.PRAYER_PIETY, false, 24),
	RIGOUR("Rigour", Prayer.RIGOUR, "+20% Ranged attack, +23% Ranged strength, +25% Defence", SpriteID.PRAYER_RIGOUR, false, 24),
	AUGURY("Augury", Prayer.AUGURY, "+25% Magical attack and defence, +25% Defence", SpriteID.PRAYER_AUGURY, false, 24),

	RP_REJUVENATION("Rejuvenation", Prayer.RP_REJUVENATION, "3x Restore rate for Hitpoints", SpriteID.PRAYER_RP_REJUVENATION, false, 4),
	RP_ANCIENT_STRENGTH("Ancient Strength", Prayer.RP_ANCIENT_STRENGTH, "+20% Attack and Strength", SpriteID.PRAYER_RP_ANCIENT_STRENGTH, false, 18),
	RP_ANCIENT_SIGHT("Ancient Sight", Prayer.RP_ANCIENT_SIGHT, "+20% Ranged Attack & Strength", SpriteID.PRAYER_RP_ANCIENT_SIGHT, false, 18),
	RP_ANCIENT_WILL("Ancient Will", Prayer.RP_ANCIENT_WILL, "+20% Magic Attack", SpriteID.PRAYER_RP_ANCIENT_WILL, false, 18),
	RP_PROTECT_ITEM("Protect Item", Prayer.RP_PROTECT_ITEM, "Keep one extra item upon death", SpriteID.PRAYER_RP_PROTECT_ITEM, false, 18),
	RP_RUINOUS_GRACE("Ruinous Grace", Prayer.RP_RUINOUS_GRACE, "Prayer points are drained in place of run energy whilst running", SpriteID.PRAYER_RP_RUINOUS_GRACE, false, 1),
	RP_DAMPEN_MAGIC("Dampen Magic", Prayer.RP_DAMPEN_MAGIC, "100% protection from magic attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_MAGIC, true, 14),
	RP_DAMPEN_RANGE("Dampen Ranged", Prayer.RP_DAMPEN_RANGED, "100% protection from ranged attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_RANGED, true, 14),
	RP_DAMPEN_MELEE("Dampen Melee", Prayer.RP_DAMPEN_MELEE, "100% protection from melee attacks (40% in PvP), but increases damage taken by 10%", SpriteID.PRAYER_RP_DAMPEN_MELEE, true, 14),
	RP_TRINITAS("Trinitas", Prayer.RP_TRINITAS, "+15% Melee Attack and Strength, +15% Ranged Attack and Strength, and +15% Magic Attack", SpriteID.PRAYER_RP_TRINITAS, false, 22),
	RP_BERSERKER("Berserker", Prayer.RP_BERSERKER, "Boosted combat stats last 50% longer", SpriteID.PRAYER_RP_BERSERKER, false, 2),
	RP_PURGE("Purge", Prayer.RP_PURGE, "Reduces the player's and opponent's prayer points by 33% of damage dealt", SpriteID.PRAYER_RP_PURGE, true, 18),
	RP_METABOLISE("Metabolise", Prayer.RP_METABOLISE, "25 ticks (15 seconds) after activation, allows players to attack 1 tick earlier after eating a piece of food", SpriteID.PRAYER_RP_METABOLISE, false, 12),
	RP_REBUKE("Rebuke", Prayer.RP_REBUKE, "Increases recoil damage by 50%", SpriteID.PRAYER_RP_REBUKE, true, 12),
	RP_VINDICATION("Vindication", Prayer.RP_VINDICATION, "Heals the player by 25% of their base Prayer level if they fall below 10% health, draining their prayer points fully", SpriteID.PRAYER_RP_VINDICATION, true, 9),
	RP_DECIMATE("Decimate", Prayer.RP_DECIMATE, "+25% Attack, +27% Strength", SpriteID.PRAYER_RP_DECIMATE, false, 28),
	RP_ANNIHILATE("Annihilate", Prayer.RP_ANNIHILATE, "+25% Ranged Attack, +27% Ranged Strength", SpriteID.PRAYER_RP_ANNIHILATE, false, 28),
	RP_VAPORISE("Vaporise", Prayer.RP_VAPORISE, "+25% Magic Attack, +4% Magic Damage", SpriteID.PRAYER_RP_VAPORISE, false, 28),
	RP_FUMUS_VOW("Fumus' Vow", Prayer.RP_FUMUS_VOW, "Attacks that inflict poison will deal poison damage instantly", SpriteID.PRAYER_RP_FUMUS_VOW, false, 14),
	RP_UMBRAS_VOW("Umbra's Vow", Prayer.RP_UMBRA_VOW, "Attacks drain 5% of the opponent's Defence, up to 15% of their base level", SpriteID.PRAYER_RP_UMBRAS_VOW, false, 14),
	RP_CRUORS_VOW("Cruor's Vow", Prayer.RP_CRUORS_VOW, "Heals 3 Hitpoints and drains 3 Prayer points upon killing a target", SpriteID.PRAYER_RP_CRUORS_VOW, false, 14),
	RP_GLACIES_VOW("Glacies' Vow", Prayer.RP_GLACIES_VOW, "Attacks drain 5% of the opponent's Magic, up to 15% of their base level", SpriteID.PRAYER_RP_GLACIES_VOW, false, 14),
	RP_WRATH("Wrath", Prayer.RP_WRATH, "Upon death, deals damage up to 25% of the player's base Prayer level to targets in a 5x5 radius", SpriteID.PRAYER_RP_WRATH, false, 3),
	RP_INTENSIFY("Intensify", Prayer.RP_INTENSIFY, "+40% accuracy in all attack styles", SpriteID.PRAYER_RP_INTENSIFY, false, 28),
	;

	private final String name;
	private final Prayer prayer;
	private final String description;
	private final int spriteID;
	private final boolean overhead;
	private final int drainEffect;
}

/*
 * Copyright (c) 2017, Seth <Sethtroll3@gmail.com>
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Jordan Atwood <jordan.atwood423@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.ItemID;

import javax.annotation.Nullable;
import java.time.Duration;
import java.time.temporal.TemporalUnit;


@Getter(AccessLevel.PACKAGE)
enum GameTimer
{
	STAMINA(ItemID.STAMINA_POTION4, "Stamina", false),
	PRAYER_REGENERATION(ItemID.PRAYER_REGENERATION_POTION4, "Prayer regeneration", false),
	;

	@Nullable
	private final Duration duration;
	@Nullable
	private final Integer graphicId;
	private final String description;
	private final boolean removedOnDeath;
	private final int imageId;

	GameTimer(int imageId, String description, Integer graphicId, long time, TemporalUnit unit, boolean removedOnDeath)
	{
		this.description = description;
		this.graphicId = graphicId;
		this.duration = Duration.of(time, unit);
		this.imageId = imageId;
		this.removedOnDeath = removedOnDeath;
	}

	GameTimer(int imageId, String description, long time, TemporalUnit unit, boolean removeOnDeath)
	{
		this(imageId, description, null, time, unit, removeOnDeath);
	}

	GameTimer(int imageId, String description, long time, TemporalUnit unit)
	{
		this(imageId, description, null, time, unit, false);
	}

	GameTimer(int imageId, String description, boolean removedOnDeath)
	{
		this.duration = null;
		this.graphicId = null;
		this.description = description;
		this.removedOnDeath = removedOnDeath;
		this.imageId = imageId;
	}
}

package com.neur0tox1n_.customvitalbars;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum FullnessDirection
{
    LEFT("Left"),
    RIGHT("Right"),
    TOP("Top"),
    BOTTOM("Bottom");

    private final String name;

    @Override
    public String toString()
    {
        return getName();
    }
}

/*
 * Copyright (c) 2018, Sean Dewar <https://github.com/seandewar>
 * Copyright (c) 2024, Seung <swhahm94@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.neur0tox1n_.customvitalbars;

import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.itemstats.Effect;
import net.runelite.client.plugins.itemstats.ItemStatChangesService;
import net.runelite.client.plugins.itemstats.StatChange;
import net.runelite.client.ui.overlay.*;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

public class CustomVitalBarsWarmthOverlay extends OverlayPanel
{
    // love to StatusBars

    private static final int WINTERTODT_REGION = 6462;

    private final Client client;

    private final CustomVitalBarsPlugin plugin;

    private final CustomVitalBarsConfig config;

    private final ItemStatChangesService itemStatService;

    private CustomVitalBarsComponent barRenderer;

    private boolean uiElementsOpen = false;
    private boolean isWearingHPCape = false;
    private boolean isWearingRegenBracelet = false;

    private static final int NORMAL_WARMTH_REGEN_TICKS = 100;

    private double warmthRegenerationPercentage;
    private int ticksSinceWarmthRegen;
    private long millisecondsSinceWarmthRegen;

    private long deltaTime;
    private long lastTime;

    private final SkillIconManager skillIconManager;
    private final SpriteManager spriteManager;

    private int deltaX = 0, deltaY = 0;
    private int lastKnownSidebarX = 0, lastKnownSidebarY = 0;
    private int lastX = 0, lastY = 0;

    private Color warmthMainColour, warmthHealColour;

    @Inject
    private OverlayManager overlayManager;

    private final ConfigManager configManager;

    @Inject
    CustomVitalBarsWarmthOverlay(Client client, CustomVitalBarsPlugin plugin, CustomVitalBarsConfig config, SkillIconManager skillIconManager, ItemStatChangesService itemstatservice, SpriteManager spriteManager, ConfigManager configManager )
    {
        super(plugin);

        setPriority(OverlayPriority.HIGH);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setMovable(true);
        setResizable( false );
        setSnappable( true );
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.skillIconManager = skillIconManager;
        this.spriteManager = spriteManager;
        this.itemStatService = itemstatservice;
        this.configManager = configManager;

        lastKnownSidebarX = config.debugSidebarPanelX();
        lastKnownSidebarY = config.debugSidebarPanelY();

        warmthMainColour = config.warmthMainColour();
        warmthHealColour = config.warmthHealColour();

        initRenderer();

        if ( config.warmthRelativeToInventory() )
        {
            toggleLock( true );
        }
    }

    private void initRenderer()
    {
        barRenderer = new CustomVitalBarsComponent(
                () -> 100,
                () -> client.getVarbitValue(Varbits.WINTERTODT_WARMTH) / 10,
                () -> 0,
                () -> warmthMainColour,
                () -> warmthHealColour,
                () -> warmthRegenerationPercentage,
                () -> skillIconManager.getSkillImage(Skill.FIREMAKING, true)
        );
    }

    @Override
    public Dimension render( Graphics2D g )
    {
        deltaTime = java.time.Instant.now().toEpochMilli() - lastTime;
        lastTime = java.time.Instant.now().toEpochMilli();

        long millisecondsPerWarmthRegen = (long)(getTicksPerWarmthRegen() * 0.6 * 1000);

        millisecondsSinceWarmthRegen = (millisecondsSinceWarmthRegen + deltaTime) % millisecondsPerWarmthRegen;
        warmthRegenerationPercentage = millisecondsSinceWarmthRegen / (double) millisecondsPerWarmthRegen;

        int currentWarmth = client.getVarbitValue(Varbits.WINTERTODT_WARMTH) / 10;
        int maxWarmth = 100;
        if ( currentWarmth == maxWarmth && config.warmthOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
        {
            warmthRegenerationPercentage = 0;
        }

        Viewport curViewport = null;
        Widget curWidget = null;

        for (Viewport viewport : Viewport.values())
        {
            final Widget viewportWidget = client.getWidget(viewport.getViewport());
            if ( viewportWidget != null )
            {
                if ( !viewportWidget.isHidden() )
                {
                    curViewport = viewport;
                    curWidget = viewportWidget;

                    final net.runelite.api.Point location = viewportWidget.getCanvasLocation();
                    lastKnownSidebarX = location.getX();
                    lastKnownSidebarY = location.getY();

                    break;
                }
            }
        }

        if ( config.hideWarmthWhenSidebarPanelClosed() )
        {
            if (curViewport == null)
            {
                return null;
            }
        }

        if ( config.warmthRelativeToInventory() )
        {
            if (curViewport != null)
            {
                final net.runelite.api.Point location = curWidget.getCanvasLocation();

                if ( deltaX != 0 && deltaY != 0 )
                {
                    int newDeltaX = (int) (location.getX() + deltaX);
                    int newDeltaY = (int) (location.getY() + deltaY);
                    this.setPreferredLocation( new java.awt.Point(newDeltaX, newDeltaY) );

                    if ( lastX != newDeltaX || lastY != newDeltaY )
                    {
                        overlayManager.saveOverlay(this);
                    }
                    lastX = newDeltaX;
                    lastY = newDeltaY;
                }
            }
        }

        if ( ((config.renderWarmthWithOptions() == WarmthRenderOptions.SHOW_DYNAMICALLY && isInWintertodtRegion()) || config.renderWarmthWithOptions() == WarmthRenderOptions.SHOW_ALWAYS) && plugin.isWarmthDisplayed() && !uiElementsOpen )
        {
            barRenderer.renderBar( config, g, panelComponent, Vital.WARMTH, false, client );
            return config.warmthSize();
        }

        return null;
    }

    private int getRestoreValue(String skill)
    {
        final MenuEntry[] menu = client.getMenuEntries();
        final int menuSize = menu.length;
        if (menuSize == 0)
        {
            return 0;
        }

        final MenuEntry entry = menu[menuSize - 1];
        final Widget widget = entry.getWidget();
        int restoreValue = 0;

        if (widget != null && widget.getId() == ComponentID.INVENTORY_CONTAINER)
        {
            final Effect change = itemStatService.getItemStatChanges(widget.getItemId());

            if (change != null)
            {
                for (final StatChange c : change.calculate(client).getStatChanges())
                {
                    final int value = c.getTheoretical();

                    if (value != 0 && c.getStat().getName().equals(skill))
                    {
                        restoreValue = value;
                    }
                }
            }
        }

        return restoreValue;
    }

    @Subscribe
    public void onWidgetLoaded( WidgetLoaded widgetLoaded )
    {
        uiElementsOpen = true;
    }

    @Subscribe
    public void onWidgetClosed( WidgetClosed widgetClosed )
    {
        uiElementsOpen = false;
    }

    @Subscribe
    public void onConfigChanged( ConfigChanged event )
    {
        if ( CustomVitalBarsConfig.GROUP.equals(event.getGroup()) && event.getKey().equals("warmthRelativeToSidebarPanel") )
        {
            toggleLock( false );
        }
        else if ( event.getKey().equals("warmthMainColour") )
        {
            warmthMainColour = config.warmthMainColour();
        }
        else if ( event.getKey().equals("warmthHealColour") )
        {
            warmthHealColour = config.warmthHealColour();
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (event.getContainerId() != InventoryID.EQUIPMENT.getId())
        {
            return;
        }

        ItemContainer equipment = event.getItemContainer();
        final boolean hasHPCape = (equipment.contains(ItemID.HITPOINTS_CAPE) || equipment.contains(ItemID.HITPOINTS_CAPET));
        final boolean hasRegenBracelet = equipment.contains(ItemID.REGEN_BRACELET);

        if ( hasHPCape != isWearingHPCape )
        {
            ticksSinceWarmthRegen = 0;
            millisecondsSinceWarmthRegen = 0;
            isWearingHPCape = hasHPCape;
        }
        if ( hasRegenBracelet != isWearingRegenBracelet )
        {
            ticksSinceWarmthRegen = 0;
            millisecondsSinceWarmthRegen = 0;
            isWearingRegenBracelet = hasRegenBracelet;
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        int ticksPerWarmthRegen = getTicksPerWarmthRegen();

        ticksSinceWarmthRegen = (ticksSinceWarmthRegen + 1) % ticksPerWarmthRegen;
        millisecondsSinceWarmthRegen = (long) (ticksSinceWarmthRegen * 0.6 * 1000);
        warmthRegenerationPercentage = ticksSinceWarmthRegen / (double) ticksPerWarmthRegen;

        int currentWarmth = client.getVarbitValue(Varbits.WINTERTODT_WARMTH) / 10;
        int maxWarmth = 100;
        if ( currentWarmth == maxWarmth && config.warmthOutlineProgressThreshold() == OutlineProgressThreshold.RELATED_STAT_AT_MAX )
        {
            warmthRegenerationPercentage = 0;
        }
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged ev)
    {
        if (ev.getVarbitId() == Varbits.PRAYER_RAPID_HEAL)
        {
            ticksSinceWarmthRegen = 0;
            millisecondsSinceWarmthRegen = 0;
        }
    }


    private BufferedImage loadSprite(int spriteId)
    {
        return spriteManager.getSprite(spriteId, 0);
    }

    private int getTicksPerWarmthRegen()
    {
        int ticksPerWarmthRegen = NORMAL_WARMTH_REGEN_TICKS;
        if ( client.isPrayerActive( Prayer.RAPID_HEAL ) || isWearingHPCape )
        {
            ticksPerWarmthRegen /= 2;
        }
        if ( isWearingRegenBracelet )
        {
            ticksPerWarmthRegen /= 2;
        }

        return ticksPerWarmthRegen;
    }

    private boolean isInWintertodtRegion()
    {
        if (client.getLocalPlayer() != null)
        {
            return client.getLocalPlayer().getWorldLocation().getRegionID() == WINTERTODT_REGION;
        }

        return false;
    }

    public void toggleLock( boolean start )
    {
        if ( deltaX == 0 && deltaY == 0 )
        {
            if ( start )
            {
                deltaX = config.debugWarmthDeltaX();
                deltaY = config.debugWarmthDeltaY();
            }
            else
            {
                deltaX = (int) (this.getPreferredLocation().getX() - lastKnownSidebarX);
                deltaY = (int) (this.getPreferredLocation().getY() - lastKnownSidebarY);
            }
        }
        else
        {
            deltaX = 0;
            deltaY = 0;
        }
        configManager.setConfiguration( "Custom Vital Bars", "debugWarmthDeltaX", (int) deltaX );
        configManager.setConfiguration( "Custom Vital Bars", "debugWarmthDeltaY", (int) deltaY );
    }
}

package net.runelite.client.plugins.customvitalbars.src.test.java.com.neur0tox1n_.customvitalbars;


import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import com.neur0tox1n_.customvitalbars.CustomVitalBarsPlugin;

public class CustomVitalBarsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CustomVitalBarsPlugin.class);
		RuneLite.main(args);
	}
}
