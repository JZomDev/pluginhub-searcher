package com.BaPB;

import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.inject.Inject;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

@Slf4j
public class BaPBService
{
    private static final String TOKEN_ISSUER_URL   = "https://osrs-ba-api-7f97e40f532b.herokuapp.com/api/v1/tokens/public/";
    private static final String SUBMIT_RUN_URL   = "https://osrs-ba-api-7f97e40f532b.herokuapp.com/api/v1/rounds/";

    private static final String SIGNING_SECRET = "ba-4-all";
    private String cachedToken = null;
    private Instant cachedTokenExpiry = null;

    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    private final OkHttpClient http;
    private final Gson gson;
    private final BaPBConfig config;

    @Inject
    public BaPBService(OkHttpClient http, Gson gson, BaPBConfig config)
    {
        this.http = http;
        this.gson = gson;
        this.config = config;
    }

    public void shutdown()
    {
        executor.shutdown();
    }

    private boolean isTokenValid()
    {
        if (cachedToken == null || cachedToken.isEmpty()) return false;
        if (cachedTokenExpiry == null ) return false;

        // Expire 30 seconds early to avoid edge cases
        Instant bufferExpiry = cachedTokenExpiry.minusSeconds(30);
        return Instant.now().isBefore(bufferExpiry);
    }

    private void fetchToken(String currentPlayer) throws Exception
    {
        String timestamp = String.valueOf(Instant.now().toEpochMilli());
        String nonce = UUID.randomUUID().toString();
        String signature = generateHmacSha256(SIGNING_SECRET, timestamp + nonce);

        // Create JSON body
        Map<String, String> bodyMap = new HashMap<>();
        bodyMap.put("description", currentPlayer);
        String jsonBody = gson.toJson(bodyMap);

        RequestBody body = RequestBody.create(JSON, jsonBody);

        Request req = new Request.Builder()
                .url(TOKEN_ISSUER_URL)
                .header("X-Timestamp", timestamp)
                .header("X-Nonce", nonce)
                .header("X-Signature", signature)
                .post(body)
                .build();

        try (Response resp = http.newCall(req).execute())
        {
            if (!resp.isSuccessful() || resp.body() == null)
                throw new RuntimeException("Failed to fetch API token: " + resp.code() + " " + resp.message());


            String rawResponse = resp.body().string();  // read raw response

            log.debug("Raw API response: {}", rawResponse);

            TokenWrapper wrapper = gson.fromJson(rawResponse, TokenWrapper.class);
            if (wrapper == null || wrapper.data == null || wrapper.data.token == null || wrapper.data.token.isEmpty())
                throw new RuntimeException("Token issuer returned no 'token' key");

            cachedToken = wrapper.data.token;

            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSS");
            LocalDateTime ldt = LocalDateTime.parse(wrapper.data.expiresAt, formatter);
            cachedTokenExpiry = ldt.toInstant(ZoneOffset.UTC);
        }
    }

    private void submitRunToAPI(
            Map<String, String> currentTeam,
            String roundFormat,
            Timers timers,
            boolean scroller,
            String submittedBy,
            String userUuid
    ) throws IOException
    {
        // Prepare players
        List<PlayerEntry> players = new ArrayList<>();
        for (Map.Entry<String, String> e : currentTeam.entrySet())
        {
            String uuid = (userUuid != null && e.getKey().equals(submittedBy)) ? userUuid : null;
            players.add(new PlayerEntry(e.getKey(), e.getValue(), uuid));
        }

        // Prepare wave data
        List<WaveEntry> waveData = new ArrayList<>();
        for (Map.Entry<Integer, Timers.WaveData> entry : timers.getWaveData().entrySet()) {
            int waveNumber = entry.getKey();
            Timers.WaveData data = entry.getValue();

            double waveTime = 0;
            int qsTime = 0;
            boolean goodPremove = false;
            boolean reset = false;
            Lobby.RelativePoint rp = null;

            if (data != null) {
                waveTime = data.getWaveTimer().getElapsedSeconds(scroller, false); // true = isLeader/scroller
                qsTime = data.getQsTimer().roundTicks;
                goodPremove = data.isGoodPremove();
                reset = data.getLobbyCount() > 1;
                rp = data.getRelativePoint();
            }

            waveData.add(new WaveEntry(waveNumber, waveTime, qsTime, goodPremove, reset, rp));
        }

        // Prepare round time
        double roundTime = timers.getRoundTimer().getElapsedSeconds(scroller);

        SubmitPayload payload = new SubmitPayload(
                roundFormat,
                roundTime,
                submittedBy,
                scroller,
                players,
                waveData
        );

        RequestBody body = RequestBody.create(JSON, gson.toJson(payload));
        Request req = new Request.Builder()
                .url(SUBMIT_RUN_URL)
                .addHeader("Authorization", "Bearer " + cachedToken)
                .post(body)
                .build();

        try (Response resp = http.newCall(req).execute())
        {
            if (resp.isSuccessful())
            {
                log.info("Successfully submitted run to API");
            }
            else
            {
                log.warn("API submission failed: {} {}", resp.code(), resp.message());
            }
        }
    }

    public void handleRoundEnd(
            Map<String, String> currentTeam,
            String roundFormat,
            Timers timers,
            boolean scroller,
            String submittedBy
    )
    {
        if (!config.SubmitRuns() || roundFormat == null)
        {
            log.debug("SubmitRuns is disabled or roundFormat is null. Skipping round submission.");
            return;
        }

        String userUuid = config.uuid_key();

        executor.execute(() -> {
            try {
                // Validate token
                if (!isTokenValid()) {
                    log.info("API token invalid or expired. Fetching a new one...");
                    fetchToken(submittedBy);
                }

                submitRunToAPI(currentTeam, roundFormat, timers, scroller, submittedBy, userUuid);

            } catch (Exception e) {
                log.warn("Failed during token check or run submission", e);
            }
        });
    }

    private String generateHmacSha256(String key, String data) throws Exception
    {
        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "HmacSHA256"));
        byte[] rawHmac = mac.doFinal(data.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(rawHmac);
    }

    private static class TokenWrapper {
        String status;
        TokenResponse data;
        Object error;
    }

    private static class TokenResponse
    {
        @SerializedName("token")
        String token;

        @SerializedName("expires_at")
        String expiresAt;
    }

    private static class WaveEntry {
        @SerializedName("wave_number")
        final int waveNumber;

        @SerializedName("wave_time")
        final double waveTime;

        @SerializedName("qs_time")
        final int qsTime;

        @SerializedName("good_premove")
        final boolean goodPremove;

        @SerializedName("reset")
        final Boolean reset;

        @SerializedName("x_qs_spawn")
        final Integer xSpawn;

        @SerializedName("y_qs_spawn")
        final Integer ySpawn;

        WaveEntry(int waveNumber, double waveTime, int qsTime, boolean goodPremove, boolean reset, Lobby.RelativePoint relativePoint) {
            this.waveNumber = waveNumber;
            this.waveTime = waveTime;
            this.qsTime = qsTime;
            this.goodPremove = goodPremove;
            this.reset = reset;

            if (relativePoint != null) {
                this.xSpawn = relativePoint.getX();
                this.ySpawn = relativePoint.getY();
            } else {
                this.xSpawn = null;
                this.ySpawn = null;
            }
        }
    }

    private static class PlayerEntry
    {
        @SerializedName("character_name")
        final String characterName;

        @SerializedName("role")
        final String role;

        @SerializedName("uuid_key")
        final String uuidKey; // optional

        PlayerEntry(String characterName, String role, String uuidKey)
        {
            this.characterName = characterName;
            this.role = role;
            this.uuidKey = uuidKey;
        }
    }

    private static class SubmitPayload
    {
        @SerializedName("format")
        final String format;
        @SerializedName("round_time")
        final double roundTime;
        @SerializedName("scroller")
        final boolean scroller;
        @SerializedName("submitted_by")
        final String submittedBy;
        @SerializedName("players")
        final List<PlayerEntry> players;
        @SerializedName("wave_data")
        final List<WaveEntry> waveData;

        SubmitPayload(String format, double roundTime, String submittedBy, boolean scroller, List<PlayerEntry> players, List<WaveEntry> waveData)
        {
            this.format = format;
            this.roundTime = roundTime;
            this.submittedBy = submittedBy;
            this.scroller = scroller;
            this.players = players;
            this.waveData = waveData;
        }
    }
}

package com.BaPB;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Map;

/**
 * Holds GameTimers for:
 * 1. Individual wave timers
 * 2. Queue/Lobby (QS) timers
 * 3. Global round timer
 * Provides methods to start/stop/reset and tick all timers.
 */
@Slf4j
public class Timers
{
    @Setter
    @Getter
    public static class WaveData {
        private final GameTimer waveTimer;
        private final GameTimer qsTimer;
        private boolean goodPremove;
        private int lobbyCount;
        private Lobby.RelativePoint relativePoint;

        public WaveData() {
            this.waveTimer = new GameTimer();
            this.qsTimer = new GameTimer();
            this.goodPremove = false;
            this.lobbyCount = 0;
        }

        public void onGameTick() {
            waveTimer.onGameTick();
            qsTimer.onGameTick();
        }

        public void stopTimers() {
            waveTimer.stop();
            qsTimer.stop();
        }

        public void incrementLobbyCount() {
            this.lobbyCount++;
        }
    }

    // Per-wave meta data, wave # -> meta data
    @Getter
    private final Map<Integer, WaveData> waveData = new HashMap<>();

    // Global round timer
    @Getter
    private final GameTimer roundTimer = new GameTimer();

    public int lastWave = 0; // 0 = not in a wave
    public int lastLobby = 0;  // 0 = not in a lobby

    /* -------------------- Wave Timer Methods -------------------- **/

    public GameTimer getWaveTimer(int waveNumber)
    {
        return waveData
                .computeIfAbsent(waveNumber, k -> new WaveData())
                .getWaveTimer();
    }

    public void startWave(int waveNumber)
    {
        if (waveNumber > 0) getWaveTimer(waveNumber).start();
    }

    public void stopWave(int waveNumber)
    {
        WaveData data = waveData.get(waveNumber);
        if (data != null) data.getWaveTimer().stop();
    }

    /* -------------------- QS Timer Methods -------------------- **/

    public GameTimer getQSTimer(int waveNumber) {
        return waveData
                .computeIfAbsent(waveNumber, k -> new WaveData())
                .getQsTimer();
    }

    public void startQS(int waveNumber) {
        if (waveNumber > 0) getQSTimer(waveNumber).start();
    }

    public void stopQS(int waveNumber)
    {
        WaveData data = waveData.get(waveNumber);
        if (data != null) data.getQsTimer().stop();
    }

    /* -------------------- Round Timer Methods -------------------- **/

    public void startRound()
    {
        roundTimer.start();
    }

    public double getRoundSeconds(boolean isLeader)
    {
        return roundTimer.getElapsedSeconds(isLeader);
    }

    /* -------------------- Tick Update -------------------- **/

    /**
     * Call once per game tick to update all timers
     */
    public void onGameTick() {
        roundTimer.onGameTick();
        waveData.values().forEach(WaveData::onGameTick);
    }

    /* -------------------- Reset Methods -------------------- **/

    /**
     * Resets all timers: round, waves, and QS
     */
    public void resetAll() {
        roundTimer.clear();
        waveData.clear();
        lastWave = 0;
        lastLobby = 0;
    }

    /**
     * Stops the round timer, all wave timers, and all QS timers.
     */
    public void stopAll()
    {
        // Stop round
        roundTimer.stop();

        // Stop all per-wave timers
        waveData.values().forEach(WaveData::stopTimers);
    }

    /* -------------------- Core flow methods -------------------- */

    /**
     * Update timers based on the detected wave/lobby state.
     */
    public void updateState(int currentWave, int currentLobby, boolean goodPremove, Lobby.RelativePoint relPoint)
    {
        // --- Transition: Lobby → Wave ---
        if (lastWave == 0 && currentWave > 0)
        {
            startWave(currentWave);
            stopQS(lastLobby);

            // Set premove for this wave (which produce the next lobby premove)
            if (currentWave + 1 <= 10) {
                WaveData data = waveData.computeIfAbsent(currentWave + 1, k -> new WaveData());
                data.setGoodPremove(goodPremove);
            }
        }

        // --- Transition: Wave → Lobby ---
        else if (lastWave > 0 && currentWave == 0)
        {
            stopWave(lastWave);
            startQS(currentLobby);

            if (relPoint != null)
            {
                WaveData data = waveData.computeIfAbsent(currentLobby, k -> new WaveData());
                data.setRelativePoint(relPoint);
            }

            // Detect resets
            WaveData data = waveData.get(currentLobby);
            if (data != null) data.incrementLobbyCount();

        }

        // Save latest state
        lastWave = currentWave;
        lastLobby = currentLobby;
    }

    public void logWaveData()
    {
        if (waveData.isEmpty())
        {
            log.debug("No wave data available.");
            return;
        }

        log.debug("----- WaveData Dump -----");
        for (Map.Entry<Integer, WaveData> entry : waveData.entrySet())
        {
            int waveNumber = entry.getKey();
            WaveData data = entry.getValue();

            String relPointStr = (data.getRelativePoint() != null)
                    ? "(" + data.getRelativePoint().getX() + "," + data.getRelativePoint().getY() + ")"
                    : "null";

            log.debug("Wave {}: waveTimer={}s, qsTimer={}s, goodPremove={}, lobbyCount={}, relativePoint={}",
                    waveNumber,
                    data.getWaveTimer().getElapsedSeconds(true),
                    data.getQsTimer().getElapsedSeconds(true),
                    data.isGoodPremove(),
                    data.getLobbyCount(),
                    relPointStr
            );
        }
        log.debug("-------------------------");
    }
}

/*
 * Copyright (c) 2018, Cameron <https://github.com/noremac201>
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.BaPB;

import com.google.inject.Provides;
import java.io.*;
import java.time.Instant;
import java.util.concurrent.ScheduledExecutorService;
import java.util.Map;
import java.util.HashMap;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.chat.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ChatInput;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.Text;
import net.runelite.client.chat.ChatClient;
import org.apache.commons.text.WordUtils;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@PluginDescriptor(
	name = "Barbarian Assault Personal Bests",
	description = "Emulates the normal plugin as well as saving personal bests",
	tags = {"minigame", "overlay", "timer", "Personal Bests","Time"}
)
@Slf4j
public class BaPBPlugin extends Plugin
{
	private static final int BA_WAVE_NUM_INDEX = 2;
	private static final int START_WAVE = 1;
    private static final int PREMOVE_Y_THRESHOLD = 5300;
	private static final String ENDGAME_REWARD_NEEDLE_TEXT = "<br>5";
	private double currentpb; //This is to load overall pb
	private double rolecurrentpb; //This is to load role specific pb's and gets set when the role is determined
	private static final String BA_COMMAND_STRING = "!ba";

    // Constants for role-specific widget group IDs
    private static final int BA_ATTACKER_GROUP_ID = 485;
    private static final int BA_COLLECTOR_GROUP_ID = 486;
    private static final int BA_DEFENDER_GROUP_ID = 487;
    private static final int BA_HEALER_GROUP_ID = 488;

	private int gc;

	@Getter(AccessLevel.PACKAGE)
	private int inGameBit = 0;
    private int currentWave = 0;
    private Timers timers = new Timers();
    private Lobby lobby = new Lobby();
	private String round_role;
	private Boolean scanning;
	private int round_roleID;
	private String roundFormat;
    private Map<String, String> currentTeam = new HashMap<>();
    private Boolean isLeader = false;
	//defines all of my specific widgets and icon names could I do it better yes, but like it works
	private Integer BaRoleWidget = 256;
	private Integer BaScrollWidget = 159;
	private Integer leaderID = 8;
	private Integer player1ID = 9;
	private Integer player2ID = 10;
	private Integer player3ID = 11;
	private Integer player4ID = 12;
	private Integer leadericonID = 18;
	private Integer player1iconID = 19;
	private Integer player2iconID = 20;
	private Integer player3iconID = 21;
	private Integer player4iconID = 22;
	private Integer attackerIcon = 20561;
	private Integer defenderIcon = 20566;
	private Integer collectorIcon = 20563;
	private Integer healerIcon = 20569;
	private PrintWriter out;
	private BufferedWriter bw;
	private FileWriter fw;



	@Inject
	private Client client;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BaPBConfig config;

    @Inject
    private BaPBService service;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private ChatClient chatClient;

	@Inject
	private ScheduledExecutorService executor;

	@Provides
	BaPBConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BaPBConfig.class);
	}


	StringBuilder str = new StringBuilder();
	@Override
	protected void startUp() throws Exception
	{
		File logFile = new File(RUNELITE_DIR, "barbarian-assault-pbs.csv");
		fw = new FileWriter(logFile, true);
		bw = new BufferedWriter(fw);
		out = new PrintWriter(bw);
		//configManager.setRSProfileConfiguration("BaPB", "Recent", roleToDouble("Leech " + "Defender"));

		chatCommandManager.registerCommandAsync(BA_COMMAND_STRING, this::baLookup, this::baSubmit);
		scanning = false;
		str = new StringBuilder();
        currentTeam.clear();
        timers.resetAll();
	}

	@Override
	protected void shutDown() throws Exception
	{
		chatCommandManager.unregisterCommand(BA_COMMAND_STRING);
		scanning = false;
		shutDownActions();
		out.close();
		bw.close();
		fw.close();
		str = new StringBuilder();
        currentTeam.clear();
        timers.resetAll();
        service.shutdown();
	}

	private void shutDownActions() throws IOException
	{
		out.flush();
		bw.flush();
		fw.flush();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) throws IOException//exception required to run .flush()
	{
		switch (event.getGroupId())
		{
			case InterfaceID.BARBASSAULT_WAVECOMPLETE:
			{
                Widget rewardWidget = client.getWidget(InterfaceID.BarbassaultWavecomplete.BARBASSAULT_COMPL_QUEENREWARDS);
                double roundSeconds = timers.getRoundSeconds(isLeader);
                if (rewardWidget != null && rewardWidget.getText().contains(ENDGAME_REWARD_NEEDLE_TEXT) && roundSeconds > 0)
				{
                    timers.stopAll();

					if ((roundSeconds < rolecurrentpb || rolecurrentpb == 0.0) && config.Seperate())
					{
						configManager.setRSProfileConfiguration("BaPB", round_role, roundSeconds);
						log.debug("Personal best of: {} saved in {}",roundSeconds, round_role);
					}
					currentpb = getCurrentPB("Barbarian Assault");
					if ((roundSeconds < currentpb || currentpb == 0.0))
					{
						configManager.setRSProfileConfiguration("BaPB", "Barbarian Assault", roundSeconds);
						log.debug("Personal best of: {} saved in Barbarian Assault",roundSeconds);
					}
					//log.info(round_role);
					//log.info(String.valueOf(gameTime.getPBTime()));
					//log.info(String.valueOf(roleToDouble(round_role)));
					//log.info(String.valueOf((gameTime.getPBTime() + roleToDouble(round_role))));
					configManager.setRSProfileConfiguration("BaPB", "Recent", (roundSeconds + roleToDouble(round_role)));
					if(config.Logging())
					{
						str
							.append(Instant.now().toString())
							.append(",")
							.append(String.valueOf(roundSeconds));
						out.println(str);
						str = new StringBuilder();
						shutDownActions();//this guarantees the new line is written to disk(prevents having to do weird jank turn plugin on/off behavior)
					}
                    service.handleRoundEnd(currentTeam, roundFormat, timers, isLeader, client.getLocalPlayer().getName());
					roundFormat = null;
				}

				break;
			}
			case InterfaceID.BARBASSAULT_OVER_RECRUIT_PLAYER_NAMES: {
				scanning = true;
				roundFormat = null;
			}
			case 159: {//this is to set scanning true when scroll is used on someone
				scanning = true;
			}
			case 158: {//this is to set scanning true when scroll is used on someone
				scanning = true;
			}
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event){
		if (event.getGroupId() == BaRoleWidget) scanning = false;//sets scanning to false when leaving w1 or leaving for any reason
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
        WorldPoint wp = client.getLocalPlayer().getWorldLocation();
        
        int detectedWave = inWave();
        int detectedLobby = lobby.getLobbyId(wp);
        boolean goodPremove = isGoodPremove(wp);

        // Only scroller should calculate relative spawn point
        Lobby.RelativePoint relPoint = isLeader && config.SubmitQS() ? lobby.getRelativeCoordinates(wp, detectedLobby) : null;

        timers.updateState(detectedWave, detectedLobby, goodPremove, relPoint);
        timers.onGameTick();

		if(scanning) {
			final String player;
			player = client.getLocalPlayer().getName();
			Widget leader = client.getWidget(BaRoleWidget,leaderID);
			Widget leaderIcon = client.getWidget(BaRoleWidget, leadericonID);
			Widget player1 = client.getWidget(BaRoleWidget,player1ID);
			Widget player1Icon = client.getWidget(BaRoleWidget,player1iconID);
			Widget player2 = client.getWidget(BaRoleWidget,player2ID);
			Widget player2Icon = client.getWidget(BaRoleWidget,player2iconID);
			Widget player3 = client.getWidget(BaRoleWidget,player3ID);
			Widget player3Icon = client.getWidget(BaRoleWidget,player3iconID);
			Widget player4 = client.getWidget(BaRoleWidget, player4ID);
			Widget player4Icon = client.getWidget(BaRoleWidget, player4iconID);
			log.debug("Scanning Team");

			if ((player4Icon.getModelId() != leaderIcon.getModelId()) &&  (player4Icon.getModelId() != 65535) && (leaderIcon.getModelId() != 65535)){//this number is the blank icon
				log.debug("Scanning Complete");
				log.debug("Leader is {}", leader.getText());
				log.debug("Player1 is {}", player1.getText());
				log.debug("Player2 is {}", player2.getText());
				log.debug("Player3 is {}", player3.getText());
				log.debug("Player4 is {}", player4.getText());


				if(str.length() == 0  && config.Logging()){
					log.debug("Created Log start");
					str
						.append(leader.getText())
						.append(",")
						.append(IDfinder(leaderIcon.getModelId()))
						.append(",")
						.append(player1.getText())
						.append(",")
						.append(IDfinder(player1Icon.getModelId()))
						.append(",")
						.append(player2.getText())
						.append(",")
						.append(IDfinder(player2Icon.getModelId()))
						.append(",")
						.append(player3.getText())
						.append(",")
						.append(IDfinder(player3Icon.getModelId()))
						.append(",")
						.append(player4.getText())
						.append(",")
						.append(IDfinder(player4Icon.getModelId()))
						.append(",");
				}
				scanning = false;


				for (int i = 8; i < 13; i++) {
					String player_in_list = (client.getWidget(BaRoleWidget, i).getText());
					String playerRole = IDfinder(client.getWidget(BaRoleWidget, (i+10)).getModelId());
					if (player.compareTo(player_in_list) == 0){
						//this checks which location the client is in the scroll
					round_roleID = client.getWidget(BaRoleWidget, (i+10)).getModelId();
					round_role = IDfinder(round_roleID);
					log.debug("Your role has been identified as {}",round_role);
					}
				}




				if((leaderIcon.getModelId() == attackerIcon)&&(player1Icon.getModelId() == collectorIcon)&&(player2Icon.getModelId() == healerIcon)&&(player4Icon.getModelId() == defenderIcon)){
					round_role = "Leech "+round_role;
					log.debug("This has been identified as a leech run as {}",round_role);
					roundFormat = "leech";
				} else if ((leaderIcon.getModelId() == attackerIcon)&&(player1Icon.getModelId() == attackerIcon)&&(player2Icon.getModelId() == healerIcon)&&(player3Icon.getModelId() == collectorIcon)&&(player4Icon.getModelId() == defenderIcon)) {
                    log.debug("This has been identified as a five man run as {}",round_role);
                    roundFormat = "five_man";
                } else {
                    roundFormat = null;
                }


                if(player.contains(leader.getText())){
                    if (leaderIcon.getModelId() == attackerIcon && !"leech".equals(roundFormat)) {
                        round_role = "Main Attacker";
                        log.debug("You have been identified as Main Attacker");
                    }
                    isLeader = true;
				} else {
                    isLeader = false;
                }

                // Save team data for API call
                if(config.SubmitRuns())
                {
                    currentTeam.clear();

                    // Only save current team if leech / five_man
                    if ("five_man".equals(roundFormat) || "leech".equals(roundFormat)) {
                        // Change to Main/2nd Attackers for 5 man
                        if ("five_man".equals(roundFormat)) {
                            // We've already validated the team composition so just set them manually
                            currentTeam.put(leader.getText(), "Main Attacker");
                            currentTeam.put(player1.getText(), "2nd Attacker");
                        } else {
                            currentTeam.put(leader.getText(), IDfinder(leaderIcon.getModelId()));
                            currentTeam.put(player1.getText(), IDfinder(player1Icon.getModelId()));
                        }

                        currentTeam.put(player2.getText(), IDfinder(player2Icon.getModelId()));

                        // Player 3 omitted if leech
                        if ("five_man".equals(roundFormat)) {
                            currentTeam.put(player3.getText(), IDfinder(player3Icon.getModelId()));
                        }

                        currentTeam.put(player4.getText(), IDfinder(player4Icon.getModelId()));
                        log.debug("Current Team: {}", currentTeam);
                    } else {
                        log.debug("Not a valid leech or five man run");
                    }
                }


				if(config.Message())
				{
					chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage("Run identified as " + round_role + " good luck :)")
						.build());
				}
				//log.info(round_role);
				//log.info(String.valueOf(gameTime.getPBTime()));
				//log.info(String.valueOf(roleToDouble(round_role)));
				rolecurrentpb = getCurrentPB(round_role);
			}




        }
    }


	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() == ChatMessageType.GAMEMESSAGE
			&& event.getMessage().startsWith("---- Wave:"))
		{
			String[] message = event.getMessage().split(" ");
			currentWave = Integer.parseInt(message[BA_WAVE_NUM_INDEX]);

			if (currentWave == START_WAVE)
			{
                timers.resetAll();
                timers.startRound();
			}
		}
	}

    private boolean isGoodPremove(WorldPoint wp)
    {
        return wp.getY() < PREMOVE_Y_THRESHOLD;
    }

    private int inWave()
    {
        // This method centralizes wave detection by combining multiple checks:
        // 1. Verifies inGameBit is 1 (player is in a BA game).
        // 2. Confirms the player is in an instanced region (BA is always instanced).
        // 3. Checks for a role-specific horn in the inventory.
        // 4. Ensures a role-specific widget is loaded (indicating the player has a role).
        // 5. Validates that currentWave is a valid number between 1 and 10.
        // Returns the wave number (1-10) if one condition is met; otherwise, returns 1.

        if ((inGameBit == 1 || hasRoleHorn() || hasRoleWidget()) && client.getTopLevelWorldView().isInstance()) {
            if (currentWave < 1 || currentWave > 10) {
                return 0;
            }
            return currentWave;
        }
        return 0;
    }

    private boolean hasRoleHorn()
    {
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        if (inventory == null)
        {
            return false;
        }

        for (Item item : inventory.getItems())
        {
            if (item == null)
            {
                continue;
            }

            int id = item.getId();
            if (id == net.runelite.api.gameval.ItemID.BARBASSAULT_ATT_HORN_01 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_ATT_HORN_02 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_ATT_HORN_03 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_ATT_HORN_04 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_ATT_HORN_05 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_DEFENDER_HORN ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_HORN_COLLECTOR ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_HEAL_HORN_01 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_HEAL_HORN_02 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_HEAL_HORN_03 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_HEAL_HORN_04 ||
                    id == net.runelite.api.gameval.ItemID.BARBASSAULT_HEAL_HORN_05)
            {
                return true;
            }
        }
        return false;
    }

    private boolean hasRoleWidget()
    {
        return client.getWidget(BA_ATTACKER_GROUP_ID, 0) != null ||
                client.getWidget(BA_COLLECTOR_GROUP_ID, 0) != null ||
                client.getWidget(BA_DEFENDER_GROUP_ID, 0) != null ||
                client.getWidget(BA_HEALER_GROUP_ID, 0) != null;
    }

	private double getCurrentPB(String pbKey)
	{
		try
		{
			return configManager.getRSProfileConfiguration("BaPB", pbKey, double.class);
		}
		catch (Exception e)
		{
			return 0.0;
		}
	}

	void recentLookup(ChatMessage chatMessage, String message){
		ChatMessageType type = chatMessage.getType();
		String search = message.substring(BA_COMMAND_STRING.length() + 1);
		final String player;
		if (type.equals(ChatMessageType.PRIVATECHATOUT))
		{
			player = client.getLocalPlayer().getName();
		}
		else
		{
			player = Text.removeTags(chatMessage.getName())
				.replace('\u00A0', ' ');
		}




		net.runelite.http.api.chat.Task task;
		final double BaPb;
		try
		{
			BaPb = chatClient.getPb(player, "Recent");
		}
		catch (IOException ex)
		{
			log.debug("unable to retrieve PB", ex);
			return;
		}

		//now we grab the current role which was saved in the ._x of the double :)
        int hundredthsDigit = ((int) Math.round(BaPb * 100)) % 10;

		double roleDouble = hundredthsDigit / 100.0;

		log.debug(String.valueOf(roleDouble));
		String role = doubleToRole(roleDouble);

		int minutes = (int) (Math.floor(BaPb) / 60);
		int seconds = (int)BaPb % 60;
        int decimal = (int) ((BaPb * 10) % 10);

		final String time =  String.format("%d:%02d.%d", minutes, seconds, decimal);

		String response = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append("Recent ")
			.append(ChatColorType.NORMAL)
			.append(role)
			.append(" run: ")
			.append(ChatColorType.HIGHLIGHT)
			.append(time)
			.build();

		log.debug("Setting response {}", response);
		final MessageNode messageNode = chatMessage.getMessageNode();
		messageNode.setRuneLiteFormatMessage(response);
		client.refreshChat();
	}

	void baLookup(ChatMessage chatMessage, String message)
	{

		ChatMessageType type = chatMessage.getType();
		String search = message.substring(BA_COMMAND_STRING.length() + 1);
		final String player;
		if (type.equals(ChatMessageType.PRIVATECHATOUT))
		{
			player = client.getLocalPlayer().getName();
		}
		else
		{
			player = Text.removeTags(chatMessage.getName())
				.replace('\u00A0', ' ');
		}

		search = longBossName(search);

		if(search == "Recent"){
			recentLookup(chatMessage, message);
			return;
		}

		net.runelite.http.api.chat.Task task;
		final double BaPb;
		try
		{
			BaPb = chatClient.getPb(player, search);
		}
		catch (IOException ex)
		{
			log.debug("unable to retrieve PB", ex);
			return;
		}
		int minutes = (int) (Math.floor(BaPb) / 60);
		double seconds = BaPb % 60;

		// If the seconds is an integer, it is ambiguous if the pb is a precise
		// pb or not. So we always show it without the trailing .00.
		final String time = Math.floor(seconds) == seconds ?
			String.format("%d:%02d", minutes, (int) seconds) :
			String.format("%d:%05.2f", minutes, seconds);

		String response = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(search)
			.append(ChatColorType.NORMAL)
			.append(" personal best: ")
			.append(ChatColorType.HIGHLIGHT)
			.append(time)
			.build();

		log.debug("Setting response {}", response);
		final MessageNode messageNode = chatMessage.getMessageNode();
		messageNode.setRuneLiteFormatMessage(response);
		client.refreshChat();
	}
	private boolean baSubmit(ChatInput chatInput, String value)
	{
		int idx = value.indexOf(' ');
		final String boss = longBossName(value.substring(idx + 1));

		final double pb = configManager.getRSProfileConfiguration("BaPB", boss, double.class);

		if (pb <= 0)
		{
			return false;
		}

		final String playerName = client.getLocalPlayer().getName();

		executor.execute(() ->
		{
			try
			{
				chatClient.submitPb(playerName, boss, pb);
			}
			catch (Exception ex)
			{
				log.warn("unable to submit personal best", ex);
			}
			finally
			{
				chatInput.resume();
			}
		});

		return true;
	}

	private String IDfinder(int roleID){
		if (roleID == attackerIcon) return "Attacker";
		if (roleID == defenderIcon) return "Defender";
		if (roleID == collectorIcon) return "Collector";
		if (roleID == healerIcon) return "Healer";
		return "";
	}

	private String doubleToRole(double time){
        if(time == .01) return "Attacker";
		if(time == .02) return "Defender";
		if(time == .03) return "Collector";
		if(time == .04) return "Healer";
		if(time == .05) return "Leech Attacker";
		if(time == .06) return "Leech Defender";
		if(time == .07) return "Leech Collector";
		if(time == .08) return "Leech Healer";
		if(time == .09) return "Main Attacker";
		return "Please relaunch client and do another run to fix this bug";
	}

    private double roleToDouble(String role){
        if(role.equals("Attacker")) return .01;
        if(role.equals("Defender")) return .02;
        if(role.equals("Collector")) return .03;
        if(role.equals("Healer")) return .04;
        if(role.equals("Leech Attacker")) return .05;
        if(role.equals("Leech Defender")) return .06;
        if(role.equals("Leech Collector")) return .07;
        if(role.equals("Leech Healer")) return .08;
        if(role.equals("Main Attacker")) return .09;
        return .00;
    }


	private static String longBossName(String boss)
	{
		switch (boss.toLowerCase())
		{
			case "att":
			case "a":
			case "main":
				return "Main Attacker";

			case "2a":
				return "Attacker";

			case "la":
				return "Leech Attacker";

			case "heal":
			case "h":
				return "Healer";

			case "lh":
				return "Leech Healer";

			case "def":
			case "d":
				return "Defender";

			case "ld":
				return "Leech Defender";

			case "eggboi":
			case "coll":
			case "col":
			case "c":
				return "Collector";

			case "lc":
				return "Leech Collector";

			case "":
			case " ":
			case "ba":
				return "Barbarian Assault";

			case "r":
				return "Recent";

			case "gc":
				return "Gc";

			default:
				return WordUtils.capitalize(boss);
		}
	}
}
/*
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.BaPB;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.time.Duration;

import static net.runelite.client.util.RSTimeUnit.GAME_TICKS;

@Slf4j
public class GameTimer
{
    @Getter
    public int roundTicks = 0;
    private boolean running = false;

    public void start()
    {
        running = true;
    }

    public void stop()
    {
        running = false;
    }

    public void clear()
    {
        running = false;
        roundTicks = 0;
    }

    public void onGameTick()
    {
        if (running)
        {
            roundTicks++;
        }
    }

    public double getElapsedSeconds(Boolean isLeader) {
        // Default behavior: subtract ticks based on leader
        return getElapsedSeconds(isLeader, true);
    }

    public double getElapsedSeconds(Boolean isLeader, boolean offset)
    {
        int numTicks = 0;

        if (offset) {
            numTicks = isLeader ? 2 : 1;
        }

        int adjustedTicks = Math.max(0, roundTicks - numTicks);

        Duration duration = Duration.of(adjustedTicks, GAME_TICKS);
        return duration.toMillis() / 1000.0;
    }
}

package com.BaPB;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import java.util.HashMap;
import java.util.Map;

/**
 * Maps a WorldPoint to a lobby ID (int).
 */
public class Lobby
{
    public static class LobbyRegion
    {
        private final int xMin, xMax, yMin, yMax;

        public LobbyRegion(int xMin, int yMin)
        {
            this.xMin = xMin;
            this.yMin = yMin;
            this.xMax = xMin + 7; // 8x8 lobbies
            this.yMax = yMin + 7; // 8x8 lobbies
        }

        public boolean contains(WorldPoint point)
        {
            return point.getX() >= xMin && point.getX() <= xMax
                    && point.getY() >= yMin && point.getY() <= yMax;
        }
    }

    @Getter
    public static class RelativePoint
    {
        private final int x;
        private final int y;

        public RelativePoint(int x, int y)
        {
            this.x = x;
            this.y = y;
        }

        @Override
        public String toString()
        {
            return "(" + x + "," + y + ")";
        }
    }

    // Key = lobbyId, Value = region
    private final Map<Integer, LobbyRegion> regions = new HashMap<>();

    public Lobby()
    {
        regions.put(1, new LobbyRegion(2576, 5291));
        regions.put(2, new LobbyRegion(2584, 5291));
        regions.put(3, new LobbyRegion(2595, 5291));
        regions.put(4, new LobbyRegion(2603, 5291));
        regions.put(5, new LobbyRegion(2576, 5281));
        regions.put(6, new LobbyRegion(2584, 5281));
        regions.put(7, new LobbyRegion(2595, 5281));
        regions.put(8, new LobbyRegion(2603, 5281));
        regions.put(9, new LobbyRegion(2576, 5271));
        regions.put(10, new LobbyRegion(2584, 5271));
    }

    /**
     * Returns the lobby ID containing this point, or 0 if none.
     */
    public int getLobbyId(WorldPoint point)
    {
        for (Map.Entry<Integer, LobbyRegion> entry : regions.entrySet())
        {
            if (entry.getValue().contains(point))
            {
                return entry.getKey();
            }
        }
        return 0;
    }

    /**
     * Returns all LobbyRegion objects
     */
    public Iterable<LobbyRegion> getAllRegions()
    {
        return regions.values();
    }

    /**
     * Returns the relative coordinates (x, y) within the given lobby.
     * Returns null if the lobbyId is invalid.
     */
    public RelativePoint getRelativeCoordinates(WorldPoint point, int lobbyId)
    {
        LobbyRegion region = regions.get(lobbyId);
        if (region == null)
        {
            return null;
        }

        int relativeX = point.getX() - region.xMin;
        int relativeY = point.getY() - region.yMin;

        return new RelativePoint(relativeX, relativeY);
    }
}

/*
 * Copyright (c) 2018, Cameron <https://github.com/noremac201>
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.BaPB;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("BaPb")
public interface

BaPBConfig extends Config
{
	@ConfigItem(
			position = 1,
		keyName = "baPB",
		name = "Save role PB different then Overall PB",
		description = "Turning this on will save your round time into a specific role round time as well as into the overall pb"
	)
	default boolean Seperate()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
		keyName = "msg",
		name = "Turn round msg on/off",
		description = "Turning this on will display a nice lil message at the start of the round"
	)
		default boolean Message() {return true;}
	@ConfigItem(
			position = 3,
		keyName = "log",
		name = "logger",
		description = "Allows to log your times to a file in your .runelite file turn off/on to update file"
	)
	default boolean Logging() {return false;}

	@ConfigItem(
			position = 4,
			keyName = "sub_runs",
			name = "Submit Runs",
			warning = "This portion of the plugin submits data to a 3rd party website not controlled or verified by the RuneLite Developers.",
			description = "This will submit runs to osrs-ba.com"
	)
	default boolean SubmitRuns() { return false; }

    @ConfigItem(
            position = 5,
            keyName = "sub_qs",
            name = "Submit QS Stats",
            description = "This will submit QS statistics to osrs-ba.com. Only used when \"Submit Runs\" is enabled."
    )
    default boolean SubmitQS() { return false; }


    @ConfigItem(
			position = 6,
			keyName = "uuid_key",
			name = "UUID Key",
			description = "Key used for linking ALT accounts, you can get one by logging into osrs-ba.com/accounts. Only used when \"Submit Runs\" is enabled."
	)
	default String uuid_key() { return null; }

}

package com.BaPB;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BaPBPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BaPBPlugin.class);
		RuneLite.main(args);
	}
}
