package com.BaPB;

import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import javax.inject.Inject;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

@Slf4j
public class BaPBService
{
    private static final String TOKEN_ISSUER_URL   = "https://osrs-ba-api-7f97e40f532b.herokuapp.com/api/v1/tokens/public/";
    private static final String SUBMIT_RUN_URL   = "https://osrs-ba-api-7f97e40f532b.herokuapp.com/api/v1/rounds/";

    private static final String SIGNING_SECRET = "ba-4-all";
    private String cachedToken = null;
    private Instant cachedTokenExpiry = null;

    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    private final ExecutorService executor = Executors.newSingleThreadExecutor();
    private final OkHttpClient http;
    private final Gson gson;
    private final BaPBConfig config;

    @Inject
    public BaPBService(OkHttpClient http, Gson gson, BaPBConfig config)
    {
        this.http = http;
        this.gson = gson;
        this.config = config;
    }

    public void shutdown()
    {
        executor.shutdown();
    }

    private boolean isTokenValid()
    {
        if (cachedToken == null || cachedToken.isEmpty()) return false;
        if (cachedTokenExpiry == null ) return false;

        // Expire 30 seconds early to avoid edge cases
        Instant bufferExpiry = cachedTokenExpiry.minusSeconds(30);
        return Instant.now().isBefore(bufferExpiry);
    }

    private void fetchToken(String currentPlayer) throws Exception
    {
        String timestamp = String.valueOf(Instant.now().toEpochMilli());
        String nonce = UUID.randomUUID().toString();
        String signature = generateHmacSha256(SIGNING_SECRET, timestamp + nonce);

        // Create JSON body
        Map<String, String> bodyMap = new HashMap<>();
        bodyMap.put("description", currentPlayer);
        String jsonBody = gson.toJson(bodyMap);

        RequestBody body = RequestBody.create(JSON, jsonBody);

        Request req = new Request.Builder()
                .url(TOKEN_ISSUER_URL)
                .header("X-Timestamp", timestamp)
                .header("X-Nonce", nonce)
                .header("X-Signature", signature)
                .post(body)
                .build();

        try (Response resp = http.newCall(req).execute())
        {
            if (!resp.isSuccessful() || resp.body() == null)
                throw new RuntimeException("Failed to fetch API token: " + resp.code() + " " + resp.message());


            String rawResponse = resp.body().string();  // read raw response

            log.debug("Raw API response: {}", rawResponse);

            TokenWrapper wrapper = gson.fromJson(rawResponse, TokenWrapper.class);
            if (wrapper == null || wrapper.data == null || wrapper.data.token == null || wrapper.data.token.isEmpty())
                throw new RuntimeException("Token issuer returned no 'token' key");

            cachedToken = wrapper.data.token;

            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSS");
            LocalDateTime ldt = LocalDateTime.parse(wrapper.data.expiresAt, formatter);
            cachedTokenExpiry = ldt.toInstant(ZoneOffset.UTC);
        }
    }

    private void submitRunToAPI(
            Map<String, String> currentTeam,
            String roundFormat,
            double gameTime,
            String submittedBy,
            String userUuid
    ) throws IOException
    {
        List<PlayerEntry> players = new ArrayList<>();
        for (Map.Entry<String, String> e : currentTeam.entrySet())
        {
            String uuid = (userUuid != null && e.getKey().equals(submittedBy)) ? userUuid : null;
            players.add(new PlayerEntry(e.getKey(), e.getValue(), uuid));
        }

        SubmitPayload payload = new SubmitPayload(
                roundFormat,
                gameTime,
                submittedBy,
                players
        );

        RequestBody body = RequestBody.create(JSON, gson.toJson(payload));
        Request req = new Request.Builder()
                .url(SUBMIT_RUN_URL)
                .addHeader("Authorization", "Bearer " + cachedToken)
                .post(body)
                .build();

        try (Response resp = http.newCall(req).execute())
        {
            if (resp.isSuccessful())
            {
                log.info("Successfully submitted run to API");
            }
            else
            {
                log.warn("API submission failed: {} {}", resp.code(), resp.message());
            }
        }
    }

    public void handleRoundEnd(
            Map<String, String> currentTeam,
            String roundFormat,
            double gameTime,
            String submittedBy
    )
    {
        if (!config.SubmitRuns() || roundFormat == null)
        {
            log.debug("SubmitRuns is disabled or roundFormat is null. Skipping round submission.");
            return;
        }

        String userUuid = config.uuid_key();

        executor.execute(() -> {
            try {
                // Validate token
                if (!isTokenValid()) {
                    log.info("API token invalid or expired. Fetching a new one...");
                    fetchToken(submittedBy);
                }

                submitRunToAPI(currentTeam, roundFormat, gameTime, submittedBy, userUuid);

            } catch (Exception e) {
                log.warn("Failed during token check or run submission", e);
            }
        });
    }

    private String generateHmacSha256(String key, String data) throws Exception
    {
        Mac mac = Mac.getInstance("HmacSHA256");
        mac.init(new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), "HmacSHA256"));
        byte[] rawHmac = mac.doFinal(data.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(rawHmac);
    }

    private static class TokenWrapper {
        String status;
        TokenResponse data;
        Object error;
    }

    private static class TokenResponse
    {
        @SerializedName("token")
        String token;

        @SerializedName("expires_at")
        String expiresAt;
    }

    private static class PlayerEntry
    {
        @SerializedName("character_name")
        final String characterName;

        @SerializedName("role")
        final String role;

        @SerializedName("uuid_key")
        final String uuidKey; // optional

        PlayerEntry(String characterName, String role, String uuidKey)
        {
            this.characterName = characterName;
            this.role = role;
            this.uuidKey = uuidKey;
        }
    }

    private static class SubmitPayload
    {
        @SerializedName("format")
        final String format;
        @SerializedName("round_time")
        final double roundTime;
        @SerializedName("submitted_by")
        final String submittedBy;
        @SerializedName("players")
        final List<PlayerEntry> players;

        SubmitPayload(String format, double roundTime, String submittedBy, List<PlayerEntry> players)
        {
            this.format = format;
            this.roundTime = roundTime;
            this.submittedBy = submittedBy;
            this.players = players;
        }
    }
}

/*
 * Copyright (c) 2018, Cameron <https://github.com/noremac201>
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.BaPB;

import com.google.inject.Provides;
import java.io.*;
import java.time.Instant;
import java.util.concurrent.ScheduledExecutorService;
import java.util.Map;
import java.util.HashMap;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.chat.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ChatInput;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.Text;
import net.runelite.client.chat.ChatClient;
import org.apache.commons.text.WordUtils;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@PluginDescriptor(
	name = "Barbarian Assault Personal Bests",
	description = "Emulates the normal plugin as well as saving personal bests",
	tags = {"minigame", "overlay", "timer", "Personal Bests","Time"}
)
@Slf4j
public class BaPBPlugin extends Plugin
{
	private static final int BA_WAVE_NUM_INDEX = 2;
	private static final String START_WAVE = "1";
	private static final String ENDGAME_REWARD_NEEDLE_TEXT = "<br>5";
	private double currentpb; //This is to load overall pb
	private double rolecurrentpb; //This is to load role specific pb's and gets set when the role is determined
	private static final String BA_COMMAND_STRING = "!ba";

	private int gc;

	@Getter(AccessLevel.PACKAGE)
	private int inGameBit = 0;
	private String currentWave = START_WAVE;
    private GameTimer gameTime = new GameTimer();
	private String round_role;
	private Boolean scanning;
	private int round_roleID;
	private String roundFormat;
    private Map<String, String> currentTeam = new HashMap<>();
    private Boolean isLeader = false;
	//defines all of my specific widgets and icon names could I do it better yes, but like it works
	private Integer BaRoleWidget = 256;
	private Integer BaScrollWidget = 159;
	private Integer leaderID = 8;
	private Integer player1ID = 9;
	private Integer player2ID = 10;
	private Integer player3ID = 11;
	private Integer player4ID = 12;
	private Integer leadericonID = 18;
	private Integer player1iconID = 19;
	private Integer player2iconID = 20;
	private Integer player3iconID = 21;
	private Integer player4iconID = 22;
	private Integer attackerIcon = 20561;
	private Integer defenderIcon = 20566;
	private Integer collectorIcon = 20563;
	private Integer healerIcon = 20569;
	private PrintWriter out;
	private BufferedWriter bw;
	private FileWriter fw;



	@Inject
	private Client client;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BaPBConfig config;

    @Inject
    private BaPBService service;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private ChatClient chatClient;

	@Inject
	private ScheduledExecutorService executor;

	@Provides
	BaPBConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BaPBConfig.class);
	}


	StringBuilder str = new StringBuilder();
	@Override
	protected void startUp() throws Exception
	{
		File logFile = new File(RUNELITE_DIR, "barbarian-assault-pbs.csv");
		fw = new FileWriter(logFile, true);
		bw = new BufferedWriter(fw);
		out = new PrintWriter(bw);
		//configManager.setRSProfileConfiguration("BaPB", "Recent", roleToDouble("Leech " + "Defender"));

		chatCommandManager.registerCommandAsync(BA_COMMAND_STRING, this::baLookup, this::baSubmit);
		scanning = false;
		str = new StringBuilder();
        currentTeam.clear();
	}

	@Override
	protected void shutDown() throws Exception
	{
		chatCommandManager.unregisterCommand(BA_COMMAND_STRING);
		scanning = false;
		shutDownActions();
		out.close();
		bw.close();
		fw.close();
		str = new StringBuilder();
        currentTeam.clear();
        service.shutdown();
	}

	private void shutDownActions() throws IOException
	{
		out.flush();
		bw.flush();
		fw.flush();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) throws IOException//exception required to run .flush()
	{
		switch (event.getGroupId())
		{
			case InterfaceID.BARBASSAULT_WAVECOMPLETE:
			{
                Widget rewardWidget = client.getWidget(InterfaceID.BarbassaultWavecomplete.BARBASSAULT_COMPL_QUEENREWARDS);
				if (rewardWidget != null && rewardWidget.getText().contains(ENDGAME_REWARD_NEEDLE_TEXT) && gameTime.getElapsedSeconds(isLeader) > 0)
				{
                    gameTime.stop();
                    log.debug("gameTime final duration is {}", gameTime.getElapsedSeconds(isLeader));
					if ((gameTime.getElapsedSeconds(isLeader) < rolecurrentpb || rolecurrentpb == 0.0) && config.Seperate())
					{
						configManager.setRSProfileConfiguration("BaPB", round_role, gameTime.getElapsedSeconds(isLeader));
						log.debug("Personal best of: {} saved in {}",gameTime.getElapsedSeconds(isLeader), round_role);
					}
					currentpb = getCurrentPB("Barbarian Assault");
					if ((gameTime.getElapsedSeconds(isLeader) < currentpb || currentpb == 0.0))
					{
						configManager.setRSProfileConfiguration("BaPB", "Barbarian Assault", gameTime.getElapsedSeconds(isLeader));
						log.debug("Personal best of: {} saved in Barbarian Assault",gameTime.getElapsedSeconds(isLeader));
					}
					//log.info(round_role);
					//log.info(String.valueOf(gameTime.getPBTime()));
					//log.info(String.valueOf(roleToDouble(round_role)));
					//log.info(String.valueOf((gameTime.getPBTime() + roleToDouble(round_role))));
					configManager.setRSProfileConfiguration("BaPB", "Recent", (gameTime.getElapsedSeconds(isLeader) + roleToDouble(round_role)));
					if(config.Logging())
					{
						str
							.append(Instant.now().toString())
							.append(",")
							.append(String.valueOf(gameTime.getElapsedSeconds(isLeader)));
						out.println(str);
						str = new StringBuilder();
						shutDownActions();//this guarantees the new line is written to disk(prevents having to do weird jank turn plugin on/off behavior)
					}

                    service.handleRoundEnd(currentTeam, roundFormat, gameTime.getElapsedSeconds(isLeader), client.getLocalPlayer().getName());
					roundFormat = null;
				}

				break;
			}
			case InterfaceID.BARBASSAULT_OVER_RECRUIT_PLAYER_NAMES: {
				scanning = true;
				roundFormat = null;
			}
			case 159: {//this is to set scanning true when scroll is used on someone
				scanning = true;
			}
			case 158: {//this is to set scanning true when scroll is used on someone
				scanning = true;
			}
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event){
		if (event.getGroupId() == BaRoleWidget) scanning = false;//sets scanning to false when leaving w1 or leaving for any reason
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
        gameTime.onGameTick();

		if(scanning) {
			final String player;
			player = client.getLocalPlayer().getName();
			Widget leader = client.getWidget(BaRoleWidget,leaderID);
			Widget leaderIcon = client.getWidget(BaRoleWidget, leadericonID);
			Widget player1 = client.getWidget(BaRoleWidget,player1ID);
			Widget player1Icon = client.getWidget(BaRoleWidget,player1iconID);
			Widget player2 = client.getWidget(BaRoleWidget,player2ID);
			Widget player2Icon = client.getWidget(BaRoleWidget,player2iconID);
			Widget player3 = client.getWidget(BaRoleWidget,player3ID);
			Widget player3Icon = client.getWidget(BaRoleWidget,player3iconID);
			Widget player4 = client.getWidget(BaRoleWidget, player4ID);
			Widget player4Icon = client.getWidget(BaRoleWidget, player4iconID);
			log.debug("Scanning Team");

			if ((player4Icon.getModelId() != leaderIcon.getModelId()) &&  (player4Icon.getModelId() != 65535) && (leaderIcon.getModelId() != 65535)){//this number is the blank icon
				log.debug("Scanning Complete");
				log.debug("Leader is {}", leader.getText());
				log.debug("Player1 is {}", player1.getText());
				log.debug("Player2 is {}", player2.getText());
				log.debug("Player3 is {}", player3.getText());
				log.debug("Player4 is {}", player4.getText());


				if(str.length() == 0  && config.Logging()){
					log.debug("Created Log start");
					str
						.append(leader.getText())
						.append(",")
						.append(IDfinder(leaderIcon.getModelId()))
						.append(",")
						.append(player1.getText())
						.append(",")
						.append(IDfinder(player1Icon.getModelId()))
						.append(",")
						.append(player2.getText())
						.append(",")
						.append(IDfinder(player2Icon.getModelId()))
						.append(",")
						.append(player3.getText())
						.append(",")
						.append(IDfinder(player3Icon.getModelId()))
						.append(",")
						.append(player4.getText())
						.append(",")
						.append(IDfinder(player4Icon.getModelId()))
						.append(",");
				}
				scanning = false;


				for (int i = 8; i < 13; i++) {
					String player_in_list = (client.getWidget(BaRoleWidget, i).getText());
					String playerRole = IDfinder(client.getWidget(BaRoleWidget, (i+10)).getModelId());
					if (player.compareTo(player_in_list) == 0){
						//this checks which location the client is in the scroll
					round_roleID = client.getWidget(BaRoleWidget, (i+10)).getModelId();
					round_role = IDfinder(round_roleID);
					log.debug("Your role has been identified as {}",round_role);
					}
				}




				if((leaderIcon.getModelId() == attackerIcon)&&(player1Icon.getModelId() == collectorIcon)&&(player2Icon.getModelId() == healerIcon)&&(player4Icon.getModelId() == defenderIcon)){
					round_role = "Leech "+round_role;
					log.debug("This has been identified as a leech run as {}",round_role);
					roundFormat = "leech";
				} else if ((leaderIcon.getModelId() == attackerIcon)&&(player1Icon.getModelId() == attackerIcon)&&(player2Icon.getModelId() == healerIcon)&&(player3Icon.getModelId() == collectorIcon)&&(player4Icon.getModelId() == defenderIcon)) {
                    log.debug("This has been identified as a five man run as {}",round_role);
                    roundFormat = "five_man";
                } else {
                    roundFormat = null;
                }


                if(player.contains(leader.getText())){
                    if (leaderIcon.getModelId() == attackerIcon && !"leech".equals(roundFormat)) {
                        round_role = "Main Attacker";
                        log.debug("You have been identified as Main Attacker");
                    }
                    isLeader = true;
				} else {
                    isLeader = false;
                }

                // Save team data for API call
                if(config.SubmitRuns())
                {
                    currentTeam.clear();

                    // Only save current team if leech / five_man
                    if ("five_man".equals(roundFormat) || "leech".equals(roundFormat)) {
                        // Change to Main/2nd Attackers for 5 man
                        if ("five_man".equals(roundFormat)) {
                            // We've already validated the team composition so just set them manually
                            currentTeam.put(leader.getText(), "Main Attacker");
                            currentTeam.put(player1.getText(), "2nd Attacker");
                        } else {
                            currentTeam.put(leader.getText(), IDfinder(leaderIcon.getModelId()));
                            currentTeam.put(player1.getText(), IDfinder(player1Icon.getModelId()));
                        }

                        currentTeam.put(player2.getText(), IDfinder(player2Icon.getModelId()));

                        // Player 3 omitted if leech
                        if ("five_man".equals(roundFormat)) {
                            currentTeam.put(player3.getText(), IDfinder(player3Icon.getModelId()));
                        }

                        currentTeam.put(player4.getText(), IDfinder(player4Icon.getModelId()));
                        log.debug("Current Team: {}", currentTeam);
                    } else {
                        log.debug("Not a valid leech or five man run");
                    }
                }


				if(config.Message())
				{
					chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage("Run identified as " + round_role + " good luck :)")
						.build());
				}
				//log.info(round_role);
				//log.info(String.valueOf(gameTime.getPBTime()));
				//log.info(String.valueOf(roleToDouble(round_role)));
				rolecurrentpb = getCurrentPB(round_role);
			}




        }
    }


	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() == ChatMessageType.GAMEMESSAGE
			&& event.getMessage().startsWith("---- Wave:"))
		{
			String[] message = event.getMessage().split(" ");
			currentWave = message[BA_WAVE_NUM_INDEX];

			if (currentWave.equals(START_WAVE))
			{
                gameTime.start();
			}
		}
	}

	private double getCurrentPB(String pbKey)
	{
		try
		{
			return configManager.getRSProfileConfiguration("BaPB", pbKey, double.class);
		}
		catch (Exception e)
		{
			return 0.0;
		}
	}

	void recentLookup(ChatMessage chatMessage, String message){
		ChatMessageType type = chatMessage.getType();
		String search = message.substring(BA_COMMAND_STRING.length() + 1);
		final String player;
		if (type.equals(ChatMessageType.PRIVATECHATOUT))
		{
			player = client.getLocalPlayer().getName();
		}
		else
		{
			player = Text.removeTags(chatMessage.getName())
				.replace('\u00A0', ' ');
		}




		net.runelite.http.api.chat.Task task;
		final double BaPb;
		try
		{
			BaPb = chatClient.getPb(player, "Recent");
		}
		catch (IOException ex)
		{
			log.debug("unable to retrieve PB", ex);
			return;
		}

		//now we grab the current role which was saved in the ._x of the double :)
        int hundredthsDigit = ((int) Math.round(BaPb * 100)) % 10;

		double roleDouble = hundredthsDigit / 100.0;

		log.debug(String.valueOf(roleDouble));
		String role = doubleToRole(roleDouble);

		int minutes = (int) (Math.floor(BaPb) / 60);
		int seconds = (int)BaPb % 60;
        int decimal = (int) ((BaPb * 10) % 10);

		final String time =  String.format("%d:%02d.%d", minutes, seconds, decimal);

		String response = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append("Recent ")
			.append(ChatColorType.NORMAL)
			.append(role)
			.append(" run: ")
			.append(ChatColorType.HIGHLIGHT)
			.append(time)
			.build();

		log.debug("Setting response {}", response);
		final MessageNode messageNode = chatMessage.getMessageNode();
		messageNode.setRuneLiteFormatMessage(response);
		client.refreshChat();
	}

	void baLookup(ChatMessage chatMessage, String message)
	{

		ChatMessageType type = chatMessage.getType();
		String search = message.substring(BA_COMMAND_STRING.length() + 1);
		final String player;
		if (type.equals(ChatMessageType.PRIVATECHATOUT))
		{
			player = client.getLocalPlayer().getName();
		}
		else
		{
			player = Text.removeTags(chatMessage.getName())
				.replace('\u00A0', ' ');
		}

		search = longBossName(search);

		if(search == "Recent"){
			recentLookup(chatMessage, message);
			return;
		}

		net.runelite.http.api.chat.Task task;
		final double BaPb;
		try
		{
			BaPb = chatClient.getPb(player, search);
		}
		catch (IOException ex)
		{
			log.debug("unable to retrieve PB", ex);
			return;
		}
		int minutes = (int) (Math.floor(BaPb) / 60);
		double seconds = BaPb % 60;

		// If the seconds is an integer, it is ambiguous if the pb is a precise
		// pb or not. So we always show it without the trailing .00.
		final String time = Math.floor(seconds) == seconds ?
			String.format("%d:%02d", minutes, (int) seconds) :
			String.format("%d:%05.2f", minutes, seconds);

		String response = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(search)
			.append(ChatColorType.NORMAL)
			.append(" personal best: ")
			.append(ChatColorType.HIGHLIGHT)
			.append(time)
			.build();

		log.debug("Setting response {}", response);
		final MessageNode messageNode = chatMessage.getMessageNode();
		messageNode.setRuneLiteFormatMessage(response);
		client.refreshChat();
	}
	private boolean baSubmit(ChatInput chatInput, String value)
	{
		int idx = value.indexOf(' ');
		final String boss = longBossName(value.substring(idx + 1));

		final double pb = configManager.getRSProfileConfiguration("BaPB", boss, double.class);

		if (pb <= 0)
		{
			return false;
		}

		final String playerName = client.getLocalPlayer().getName();

		executor.execute(() ->
		{
			try
			{
				chatClient.submitPb(playerName, boss, pb);
			}
			catch (Exception ex)
			{
				log.warn("unable to submit personal best", ex);
			}
			finally
			{
				chatInput.resume();
			}
		});

		return true;
	}

	private String IDfinder(int roleID){
		if (roleID == attackerIcon) return "Attacker";
		if (roleID == defenderIcon) return "Defender";
		if (roleID == collectorIcon) return "Collector";
		if (roleID == healerIcon) return "Healer";
		return "";
	}

	private String doubleToRole(double time){
        if(time == .01) return "Attacker";
		if(time == .02) return "Defender";
		if(time == .03) return "Collector";
		if(time == .04) return "Healer";
		if(time == .05) return "Leech Attacker";
		if(time == .06) return "Leech Defender";
		if(time == .07) return "Leech Collector";
		if(time == .08) return "Leech Healer";
		if(time == .09) return "Main Attacker";
		return "Please relaunch client and do another run to fix this bug";
	}

    private double roleToDouble(String role){
        if(role.equals("Attacker")) return .01;
        if(role.equals("Defender")) return .02;
        if(role.equals("Collector")) return .03;
        if(role.equals("Healer")) return .04;
        if(role.equals("Leech Attacker")) return .05;
        if(role.equals("Leech Defender")) return .06;
        if(role.equals("Leech Collector")) return .07;
        if(role.equals("Leech Healer")) return .08;
        if(role.equals("Main Attacker")) return .09;
        return .00;
    }


	private static String longBossName(String boss)
	{
		switch (boss.toLowerCase())
		{
			case "att":
			case "a":
			case "main":
				return "Main Attacker";

			case "2a":
				return "Attacker";

			case "la":
				return "Leech Attacker";

			case "heal":
			case "h":
				return "Healer";

			case "lh":
				return "Leech Healer";

			case "def":
			case "d":
				return "Defender";

			case "ld":
				return "Leech Defender";

			case "eggboi":
			case "coll":
			case "col":
			case "c":
				return "Collector";

			case "lc":
				return "Leech Collector";

			case "":
			case " ":
			case "ba":
				return "Barbarian Assault";

			case "r":
				return "Recent";

			case "gc":
				return "Gc";

			default:
				return WordUtils.capitalize(boss);
		}
	}
}
/*
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.BaPB;

import lombok.extern.slf4j.Slf4j;

import java.time.Duration;

import static net.runelite.client.util.RSTimeUnit.GAME_TICKS;

@Slf4j
public class GameTimer
{
    private int roundTicks = 0;
    private boolean running = false;

    public void start()
    {
        roundTicks = 0;
        running = true;
    }

    public void stop()
    {
        running = false;
    }

    public void onGameTick()
    {
        if (running)
        {
            roundTicks++;
        }
    }

    public double getElapsedSeconds(Boolean isLeader)
    {
        // The number of ticks to remove is +1 if leader. May have to do with timing of loading in/out
        int numTicks = isLeader ? 2 : 1;
        int adjustedTicks = Math.max(0, roundTicks - numTicks);

        Duration duration = Duration.of(adjustedTicks, GAME_TICKS);
        return duration.toMillis() / 1000.0;
    }

}

/*
 * Copyright (c) 2018, Cameron <https://github.com/noremac201>
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.BaPB;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("BaPb")
public interface

BaPBConfig extends Config
{
	@ConfigItem(
			position = 1,
		keyName = "baPB",
		name = "Save role PB different then Overall PB",
		description = "Turning this on will save your round time into a specific role round time as well as into the overall pb"
	)
	default boolean Seperate()
	{
		return true;
	}

	@ConfigItem(
			position = 2,
		keyName = "msg",
		name = "Turn round msg on/off",
		description = "Turning this on will display a nice lil message at the start of the round"
	)
		default boolean Message() {return true;}
	@ConfigItem(
			position = 3,
		keyName = "log",
		name = "logger",
		description = "Allows to log your times to a file in your .runelite file turn off/on to update file"
	)
	default boolean Logging() {return false;}

	@ConfigItem(
			position = 4,
			keyName = "sub_runs",
			name = "Submit Runs",
			warning = "This portion of the plugin submits data to a 3rd part website not controlled or verified by the RuneLite Developers.",
			description = "This will submit runs to osrs-ba.com"
	)
	default boolean SubmitRuns() { return false; }

	@ConfigItem(
			position = 5,
			keyName = "uuid_key",
			name = "UUID Key",
			description = "Key used for linking ALT accounts, you can get one by logging into osrs-ba.com/accounts. Only used when \"Submit Runs\" is enabled."
	)
	default String uuid_key() { return null; }

}

package com.BaPB;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BaPBPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BaPBPlugin.class);
		RuneLite.main(args);
	}
}
