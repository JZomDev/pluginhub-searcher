package com.LandSurveyor;

import net.runelite.client.RuneLite;

import java.io.*;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;


public class csvExport {
    private final static String PATH = RuneLite.RUNELITE_DIR + "//landSurveyor//";
    private static final DateFormat TIME_FORMAT = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss");

    private static File csvFile;
    private static BufferedWriter writer;
    private static boolean isWriting = false;

    /// Cache to prevent duplicates: key = "x,y", value = elevation
    private static final Map<String, Integer> tileCache = new HashMap<>();

    private static final Logger logger = Logger.getLogger(csvExport.class.getName());

    public static void updateWritingState(boolean writeToFile)
    {
        if (writeToFile && !isWriting)
        {
            startNewCsv();
        }
        else if (!writeToFile && isWriting)
        {
            stopCsv();
        }
    }


     /// Creates a new CSV file
    private static void startNewCsv()
    {
        try
        {
            File folder = new File(PATH);
            if (!folder.exists())
            {
                folder.mkdirs();
            }

            String timestamp = TIME_FORMAT.format(new Date());
            csvFile = new File(folder, timestamp + ".csv");

            writer = new BufferedWriter(new FileWriter(csvFile, true));
            writer.write("X,Y,Elevation");
            writer.newLine();

            tileCache.clear();
            isWriting = true;
        }
        catch (IOException e)
        {
            logger.log(Level.SEVERE, "Failed to start new CSV file", e);
            stopCsv();
        }
    }

     /// Stops CSV logging and closes the writer
    private static void stopCsv()
    {
        try
        {
            if (writer != null)
            {
                writer.flush();
                writer.close();
            }
        }
        catch (IOException e)
        {
            logger.log(Level.SEVERE, "Error while closing CSV writer", e);
        }
        finally
        {
            writer = null;
            csvFile = null;
            isWriting = false;
            tileCache.clear();
        }
    }

    /// Writes a tile's data if not already written, or updates it if elevation changed
    public static void writeTile(int x, int y, int elevation)
    {
        if (!isWriting || writer == null)
        {
            return;
        }

        String key = x + "," + y;

        // If tile is new, write it
        if (!tileCache.containsKey(key))
        {
            appendTile(x, y, elevation);
            tileCache.put(key, elevation);
            return;
        }

        // Tile exists, check elevation change
        int oldElevation = tileCache.get(key);
        if (oldElevation != elevation)
        {
            tileCache.put(key, elevation);
            rewriteCsv();
        }
    }

     /// Appends a single tile to the CSV without reprocessing the entire file
    private static void appendTile(int x, int y, int elevation)
    {
        try
        {
            writer.write(x + "," + y + "," + elevation);
            writer.newLine();
            writer.flush();
        }
        catch (IOException e)
        {
            logger.log(Level.SEVERE, "Error writing tile to CSV", e);
        }
    }

    private static void rewriteCsv()
    {
        try
        {
            writer.close();
            writer = new BufferedWriter(new FileWriter(csvFile, false));

            // Write header again
            writer.write("X,Y,Elevation");
            writer.newLine();

            // Re-dump cache contents
            for (Map.Entry<String, Integer> entry : tileCache.entrySet())
            {
                writer.write(entry.getKey() + "," + entry.getValue());
                writer.newLine();
            }

            writer.flush();
        }
        catch (IOException e)
        {
            logger.log(Level.SEVERE, "Error rewriting CSV file", e);
        }
    }
}

package com.LandSurveyor;

import net.runelite.client.config.*;
import java.awt.Color;

@ConfigGroup("LandSurveyor")
public interface LandSurveyorConfig extends Config
{
	@ConfigItem(
		keyName = "tileDistance",
		name = "Tiles from Player",
		description = "How many tiles from the player to obtain elevation for",
		position = 1
	)
	@Range(max = 50)
	default int tileDistance()
	{
		return 5;
	}

	@ConfigItem(
			keyName = "textColor",
			name = "Text Color",
			description = "Color of the elevation text",
			position = 2
	)
	default Color textColor(){
		return Color.YELLOW;
	}

	@ConfigSection(
			name = "Hypsometric Options",
			description = "Settings for Hypsometric coloring",
			position = 100,
			closedByDefault = true
	)
	String hypsometricSection = "hypsometricSection";
	@ConfigItem(
			keyName = "hypsometricMode",
			name = "Hypsometric Mode",
			description = "Choose where to apply elevation-based coloring",
			section = hypsometricSection,
			position = 0
	)
	default HypsometricMode hypsometricMode(){
		return HypsometricMode.OFF;
	}

	@ConfigItem(
			keyName = "hypsometricColorLow",
			name = "Hypso Color Low",
			description = "Low elevation color (default: green)",
			section = hypsometricSection,
			position = 1
	)
	default Color hypsometricColorLow(){
		return Color.GREEN;
	}

	@ConfigItem(
			keyName = "hypsometricColorHigh",
			name = "Hypso Color High",
			description = "High elevation color (default: red)",
			section = hypsometricSection,
			position = 2
	)
	default Color hypsometricColorHigh(){
		return Color.RED;
	}

	@ConfigItem(
			keyName = "gradientSensitivity",
			name = "Gradient Sensitivity",
			description = "Adjust the hypsometric gradient (default = 1.0)",
			section = hypsometricSection,
			position = 3
	)
	@Range(max = 5)
	default double gradientSensitivity(){
		return 1.0;
	}

	@ConfigItem(
			keyName = "tileOpacity",
			name = "Tile Opacity",
			description = "Opacity of the hypsometric tile overlay (0.0 = fully transparent, 1.0 = fully opaque)",
			section = hypsometricSection,
			position = 4
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int tileOpacityPercent()
	{
		return 50;
	}

	@ConfigItem(
			keyName = "writeToFile",
			name = "Write to File",
			description = "Actively writes elevation data to a CSV file in the .runelite/landSurveyor directory",
			position = 3
	)
	default boolean writeToFile() {
		return false;
	}
}

package com.LandSurveyor;

public enum HypsometricMode {
    OFF,
    TEXT,
    TILE,
    BOTH
}

package com.LandSurveyor;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "Land Surveyor"
)
public class LandSurveyorPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private LandSurveyorConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ElevationOverlay elevationOverlay;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(elevationOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(elevationOverlay);
	}

	@Provides
	LandSurveyorConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LandSurveyorConfig.class);
	}
}

package com.LandSurveyor;

import javax.inject.Inject;
import java.awt.*;
import net.runelite.api.Point;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.api.Perspective;


public class ElevationOverlay extends Overlay {

    private final LandSurveyorConfig config;

    private final Client client;

    @Inject
    public ElevationOverlay(Client client, LandSurveyorConfig config)
    {
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.UNDER_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        csvExport.updateWritingState(config.writeToFile());

        if (client.getLocalPlayer() == null)
        {
            return null;
        }

        LocalPoint localLocation = client.getLocalPlayer().getLocalLocation();
        int plane = client.getPlane();
        int radius = config.tileDistance();

        for (int dx = -radius; dx <= radius; dx++)
        {
            for (int dy = -radius; dy <= radius; dy++)
            {
                int x = localLocation.getSceneX() + dx;
                int y = localLocation.getSceneY() + dy;

                if (x < 0 || x >= 104 || y < 0 || y >= 104)
                    continue;

                LocalPoint lp = LocalPoint.fromScene(x, y);
                if (lp == null)
                    continue;

                int height = -Perspective.getTileHeight(client, lp, plane);

                csvExport.writeTile(x, y, height);

                // Draw filled tile if mode is TILE or BOTH
                if (config.hypsometricMode() == HypsometricMode.TILE || config.hypsometricMode() == HypsometricMode.BOTH)
                {
                    Polygon tilePoly = Perspective.getCanvasTilePoly(client, lp);
                    if (tilePoly != null)
                    {
                        Color baseColor = getColorForHeight(height);
                        int alpha = Math.max(0, Math.min(255, (int)(config.tileOpacityPercent() / 100.0 * 255)));

                        Color transparentColor = new Color(baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), alpha);

                        graphics.setColor(transparentColor);
                        graphics.fillPolygon(tilePoly);
                    }
                }

                // Draw text if mode is TEXT or BOTH
                if (config.hypsometricMode() == HypsometricMode.TEXT || config.hypsometricMode() == HypsometricMode.BOTH)
                {
                    Point canvasPoint = Perspective.getCanvasTextLocation(client, graphics, lp, String.valueOf(height), 0);
                    if (canvasPoint != null)
                    {
                        graphics.setComposite(AlphaComposite.SrcOver.derive(1.0f));
                        graphics.setColor(getColorForHeight(height));
                        graphics.drawString(String.valueOf(height), canvasPoint.getX(), canvasPoint.getY());
                    }
                }
                else
                {
                    // Not in TEXT or BOTH mode, but still show text in user-selected color
                    Point canvasPoint = Perspective.getCanvasTextLocation(client, graphics, lp, String.valueOf(height), 0);
                    if (canvasPoint != null)
                    {
                        graphics.setColor(config.textColor());
                        graphics.drawString(String.valueOf(height), canvasPoint.getX(), canvasPoint.getY());
                    }
                }
            }
        }

        return null;
    }
    private Color getColorForHeight(int height)
    {
        final int min = 0;
        final int max = 1000;

        int clamped = Math.max(min, Math.min(max, height));
        float ratio = (float)(clamped - min) / (max - min);

        // Apply user-controlled sensitivity
        ratio = Math.min(1.0f, ratio * (float) config.gradientSensitivity());

        Color low = config.hypsometricColorLow();
        Color high = config.hypsometricColorHigh();

        // Convert RGB colors to HSB
        float[] lowHSB = Color.RGBtoHSB(low.getRed(), low.getGreen(), low.getBlue(), null);
        float[] highHSB = Color.RGBtoHSB(high.getRed(), high.getGreen(), high.getBlue(), null);

        // Interpolate hue circularly (hue is angle 0..1)
        float hue = interpolateHue(lowHSB[0], highHSB[0], ratio);
        // Interpolate saturation and brightness linearly
        float saturation = lerp(lowHSB[1], highHSB[1], ratio);
        float brightness = lerp(lowHSB[2], highHSB[2], ratio);

        Color hsbColor = Color.getHSBColor(hue, saturation, brightness);

        // Return fully opaque color
        return new Color(hsbColor.getRed(), hsbColor.getGreen(), hsbColor.getBlue(), 255);
    }

    private float lerp(float start, float end, float t)
    {
        return start + t * (end - start);
    }

    private float interpolateHue(float h1, float h2, float t)
    {
        // Handle hue wrap-around (hue ranges from 0 to 1, circular)
        float dh = h2 - h1;

        if (Math.abs(dh) > 0.5f)
        {
            if (h2 > h1)
            {
                h1 += 1.0f;  // Wrap h1 around
            }
            else
            {
                h2 += 1.0f;  // Wrap h2 around
            }
        }

        float h = lerp(h1, h2, t);
        if (h > 1.0f)
            h -= 1.0f;

        return h;
    }

}

package com.LandSurveyor;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LandSurveyorPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LandSurveyorPlugin.class);
		RuneLite.main(args);
	}
}
