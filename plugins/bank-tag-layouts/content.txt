package com.banktaglayouts;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import com.google.common.collect.LinkedListMultimap;
import com.google.common.collect.Multimap;
import com.google.common.util.concurrent.Runnables;
import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.IntPredicate;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.MessageNode;
import net.runelite.api.Point;
import net.runelite.api.ScriptEvent;
import net.runelite.api.ScriptID;
import net.runelite.api.Varbits;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.DraggingWidgetChanged;
import net.runelite.api.events.FocusChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.MenuShouldLeftClick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.ConfigProfile;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.bank.BankSearch;
import net.runelite.client.plugins.banktags.BankTagsPlugin;
import net.runelite.client.plugins.banktags.BankTagsService;
import net.runelite.client.plugins.banktags.TagManager;
import net.runelite.client.plugins.banktags.tabs.AutoLayout;
import net.runelite.client.plugins.banktags.tabs.LayoutManager;
import net.runelite.client.plugins.banktags.tabs.TabInterface;
import net.runelite.client.plugins.banktags.tabs.TabManager;
import net.runelite.client.plugins.banktags.tabs.TagTab;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Bank Tag Layouts",
	description = "Right click a bank tag tabs and click \"Enable layout\", select the tag tab, then drag items in the tag to reposition them.",
	tags = {"bank", "tag", "layout"}
)
@PluginDependency(BankTagsPlugin.class)
public class BankTagLayoutsPlugin extends Plugin implements MouseListener
{
	public static final IntPredicate FILTERED_CHARS = c -> "</>:".indexOf(c) == -1;

	public static final Color itemTooltipColor = new Color(0xFF9040);

	public static final String CONFIG_GROUP = "banktaglayouts";
	public static final String LAYOUT_CONFIG_KEY_PREFIX = "layout_";
	public static final String INVENTORY_SETUPS_LAYOUT_CONFIG_KEY_PREFIX = "inventory_setups_layout_";
	public static final String BANK_TAG_STRING_PREFIX = "banktaglayoutsplugin:";
	public static final String LAYOUT_EXPLICITLY_DISABLED = "DISABLED";

	public static final String ENABLE_LAYOUT = "Enable layout";
	public static final String DISABLE_LAYOUT = "Delete layout";
	public static final String IMPORT_LAYOUT = "Import tag tab with layout";
	public static final String EXPORT_LAYOUT = "Export tag tab with layout";
	public static final String REMOVE_FROM_LAYOUT_MENU_OPTION = "Remove-layout";
	public static final String PREVIEW_AUTO_LAYOUT = "Preview auto layout";
	public static final String DUPLICATE_ITEM = "Duplicate-item";
	public static final String REMOVE_DUPLICATE_ITEM = "Remove-duplicate-item";

	public static final int BANK_ITEM_WIDTH = 36;
	public static final int BANK_ITEM_HEIGHT = 32;

	@Inject public Client client;
	@Inject public OverlayManager overlayManager;
	@Inject public MouseManager mouseManager;
	@Inject public KeyManager keyManager;
	@Inject public SpriteManager spriteManager;
	@Inject public ItemManager itemManager;
	@Inject public ConfigManager configManager;
	@Inject public ClientThread clientThread;
	@Inject public TabInterface tabInterface;
	@Inject public TagManager tagManager;
	@Inject public BankTagsService bankTagsService;
	@Inject public FakeItemOverlay fakeItemOverlay;
	@Inject public BankSearch bankSearch;
	@Inject public ChatboxPanelManager chatboxPanelManager;
	@Inject public BankTagLayoutsConfig config;
	@Inject public Gson gson;
	@Inject public UsedToBeReflection copyPaste;
	@Inject public LayoutManager layoutManager;

	// The current indexes for where each widget should appear in the custom bank layout. Should be ignored if there is not tab active.
	private final Map<Integer, Widget> indexToWidget = new HashMap<>();

	private Widget showLayoutPreviewButton = null;
	private Widget applyLayoutPreviewButton = null;
	private Widget cancelLayoutPreviewButton = null;

	private LayoutableThing lastLayoutable = null;
	private int lastHeight = Integer.MAX_VALUE;

	final AntiDragPluginUtil antiDrag = new AntiDragPluginUtil(this);
	private final LayoutGenerator layoutGenerator = new LayoutGenerator(this);

	private void updateButton() {
		Widget parent = client.getWidget(ComponentID.BANK_CONTENT_CONTAINER);
		if (parent == null) return;

		boolean found = false;
		if (showLayoutPreviewButton != null) {
			for (Widget dynamicChild : parent.getDynamicChildren())
			{
				if (dynamicChild == showLayoutPreviewButton) {
					found = true;
					break;
				}
			}
		}
		if (!found || showLayoutPreviewButton == null) {
			showLayoutPreviewButton = parent.createChild(-1, WidgetType.GRAPHIC);

			showLayoutPreviewButton.setOriginalHeight(18);
			showLayoutPreviewButton.setOriginalWidth(18);
			showLayoutPreviewButton.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM);
			showLayoutPreviewButton.setOriginalX(434);
			showLayoutPreviewButton.setOriginalY(45);
			showLayoutPreviewButton.setSpriteId(Sprites.AUTO_LAYOUT.getSpriteId());

			showLayoutPreviewButton.setOnOpListener((JavaScriptCallback) (e) -> showLayoutPreview());
			showLayoutPreviewButton.setHasListener(true);
			showLayoutPreviewButton.revalidate();
			showLayoutPreviewButton.setAction(0, PREVIEW_AUTO_LAYOUT);

			applyLayoutPreviewButton = parent.createChild(-1, WidgetType.GRAPHIC);

			applyLayoutPreviewButton.setOriginalHeight(18);
			applyLayoutPreviewButton.setOriginalWidth(18);
			applyLayoutPreviewButton.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM);
			applyLayoutPreviewButton.setOriginalX(434 - 30);
			applyLayoutPreviewButton.setOriginalY(45);
			applyLayoutPreviewButton.setSpriteId(Sprites.APPLY_PREVIEW.getSpriteId());
			applyLayoutPreviewButton.setNoClickThrough(true);

			applyLayoutPreviewButton.setOnOpListener((JavaScriptCallback) (e) -> applyLayoutPreview());
			applyLayoutPreviewButton.setHasListener(true);
			applyLayoutPreviewButton.revalidate();
			applyLayoutPreviewButton.setAction(0, "Use this layout");

			cancelLayoutPreviewButton = parent.createChild(-1, WidgetType.GRAPHIC);

			cancelLayoutPreviewButton.setOriginalHeight(18);
			cancelLayoutPreviewButton.setOriginalWidth(18);
			cancelLayoutPreviewButton.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM);
			cancelLayoutPreviewButton.setOriginalX(434);
			cancelLayoutPreviewButton.setOriginalY(45);
			cancelLayoutPreviewButton.setSpriteId(Sprites.CANCEL_PREVIEW.getSpriteId());
			cancelLayoutPreviewButton.setNoClickThrough(true);

			cancelLayoutPreviewButton.setOnOpListener((JavaScriptCallback) (e) -> cancelLayoutPreview());
			cancelLayoutPreviewButton.setHasListener(true);
			cancelLayoutPreviewButton.revalidate();
			cancelLayoutPreviewButton.setAction(0, "Cancel preview");
		}

		hideLayoutPreviewButtons(!isShowingPreview());
		LayoutableThing layoutable = getCurrentLayoutableThing();
		showLayoutPreviewButton.setHidden(!(config.showAutoLayoutButton() && layoutable != null && !isVanillaLayoutEnabled(layoutable) && !isShowingPreview()));
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == InterfaceID.BANK) showLayoutPreviewButton = null; // when the bank widget is unloaded or loaded (not sure which) the button is removed from it somehow. So, set it to null so that it will be regenerated.
	}

	@Override
	protected void startUp()
	{
		layoutManager.unregisterAutoLayout("Zigzag");
		layoutManager.registerAutoLayout(this, "Zigzag", new AutoLayout()
		{
			@Override
			public net.runelite.client.plugins.banktags.tabs.Layout generateLayout(net.runelite.client.plugins.banktags.tabs.Layout currentLayout)
			{
				List<Integer> equippedGear = getEquippedGear();
				List<Integer> inventory = getInventory();
				if (equippedGear.stream().noneMatch(id -> id > 0) && inventory.stream().noneMatch(id -> id > 0)) {
					chatMessage("This feature uses your equipped items and inventory to automatically create a bank tag layout, but you don't have any items equipped or in your inventory.");
					return null;
				}

//				System.out.println("=============layout:");
				Layout l = new Layout();
				for (int i = 0; i < currentLayout.getLayout().length; i++)
				{
					int itemId = currentLayout.getLayout()[i];
					if (itemId == -1) continue;
//					System.out.println(itemNameWithId(itemId) + " " + i);
					l.putItem(itemId, i);
				}
//				System.out.println("=============item widgets:");
				Widget widget = client.getWidget(ComponentID.BANK_ITEM_CONTAINER);
				for (Widget dynamicChild : widget.getDynamicChildren())
				{
					if (dynamicChild.getItemId() == -1) continue;
//					System.out.println(itemNameWithId(dynamicChild.getItemId()));
				}

				Layout previewLayout = layoutGenerator.basicBankTagLayout(equippedGear, inventory, config.autoLayoutIncludeRunePouchRunes() ? getRunePouchRunes() : Collections.emptyList(), Collections.emptyList(), l, getAutoLayoutDuplicateLimit(), config.autoLayoutStyle());
				net.runelite.client.plugins.banktags.tabs.Layout l2 = new net.runelite.client.plugins.banktags.tabs.Layout(currentLayout.getTag());
				for (Map.Entry<Integer, Integer> pair : previewLayout.allPairs())
				{
					l2.setItemAtPos(pair.getValue(), pair.getKey());
				}
//				System.out.println("==========================here");
				for (int i = 0; i < l2.getLayout().length; i++)
				{
					int itemId = l2.getLayout()[i];
					if (itemId == -1) continue;
//					System.out.println(itemNameWithId(itemId) + " " + i);
				}
				return l2;
			}
		});
		lastProfile = configManager.getProfile();

		overlayManager.add(fakeItemOverlay);
		spriteManager.addSpriteOverrides(Sprites.values());
		mouseManager.registerMouseListener(this);
		keyManager.registerKeyListener(antiDrag);

		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN) {
				showLayoutPreviewButton = null;
				updateButton();
				bankSearch.layoutBank();
			}
		});
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(fakeItemOverlay);
		spriteManager.removeSpriteOverrides(Sprites.values());
		mouseManager.unregisterMouseListener(this);
		keyManager.unregisterKeyListener(antiDrag);

		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN) {
				indexToWidget.clear();
				cancelLayoutPreview();
				if (showLayoutPreviewButton != null) showLayoutPreviewButton.setHidden(true);

				bankSearch.layoutBank();
			}
		});
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (CONFIG_GROUP.equals(event.getGroup())) {
			if ("layoutEnabledByDefault".equals(event.getKey())) {
				clientThread.invokeLater(() -> applyCustomBankTagItemPositions());
			} else if ("showAutoLayoutButton".equals(event.getKey())) {
				clientThread.invokeLater(this::updateButton);
			} else if ("useWithInventorySetups".equals(event.getKey())) {
				clientThread.invokeLater(bankSearch::layoutBank);
			}
		} else if (BankTagsPlugin.CONFIG_GROUP.equals(event.getGroup()) && BankTagsPlugin.TAG_TABS_CONFIG.equals(event.getKey())) {
			handlePotentialTagRename(event);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		GameState gameState = gameStateChanged.getGameState();
		if (gameState == GameState.LOGGED_IN) {
			checkVersionUpgrade();
		}
	}

	private void onVersionUpgraded(VersionNumber previousVersion, VersionNumber newVersion) {
		if (previousVersion.compareTo(new VersionNumber(1, 4, 10)) < 0)
		{
			if (config.updateMessages())
			{
				clientThread.invokeLater(() -> {
					chatMessage(ColorUtil.wrapWithColorTag("Bank Tag Layouts ", Color.RED) + "new version: " + "1.4.10");
					chatMessage(" - " + "New Auto-layout mode \"Presets\" shows your gear and inventory in a prettier way. You can switch to it in the plugin's config.");
				});
			}
		}
		if (previousVersion.compareTo(new VersionNumber(1, 4, 11)) < 0)
		{
			String prefix = CONFIG_GROUP + "." + INVENTORY_SETUPS_LAYOUT_CONFIG_KEY_PREFIX;
			for (String key : configManager.getConfigurationKeys(prefix))
			{
				String inventorySetupName = key.substring(prefix.length());
				String layoutString = configManager.getConfiguration(CONFIG_GROUP, INVENTORY_SETUPS_LAYOUT_CONFIG_KEY_PREFIX + inventorySetupName);
				String escapedKey = LayoutableThing.inventorySetup(inventorySetupName).configKey();
				configManager.setConfiguration(CONFIG_GROUP, escapedKey, layoutString);
			}
		}
	}

	void checkVersionUpgrade() {
		try (InputStream is = BankTagLayoutsPlugin.class.getResourceAsStream("/version.txt"))
		{
			Properties props = new Properties();

			try
			{
				props.load(is);
			}
			catch (IOException e)
			{
				log.error("unable to load version number", e);
				return;
			}

			VersionNumber buildVersion = new VersionNumber(props.getProperty("version"));
			String previousVersionString = configManager.getConfiguration(CONFIG_GROUP, "version");
			// This is a best guess - they could have had the plugin installed previously but if they don't have any layouts set they probably don't use it.
			boolean assumeFreshInstall =
				previousVersionString == null
				&& configManager.getConfigurationKeys(CONFIG_GROUP + "." + LAYOUT_CONFIG_KEY_PREFIX).size() == 0
				&& configManager.getConfigurationKeys(CONFIG_GROUP + "." + INVENTORY_SETUPS_LAYOUT_CONFIG_KEY_PREFIX).size() == 0;
			VersionNumber previousVersion = new VersionNumber(previousVersionString);
			if (buildVersion.compareTo(previousVersion) > 0 && !assumeFreshInstall)
			{
				onVersionUpgraded(previousVersion, buildVersion);
			}
			configManager.setConfiguration(CONFIG_GROUP, "version", buildVersion);
		}
		catch (IOException e) {
			log.error("unable to close version file.", e);
		}
	}

	private ConfigProfile lastProfile = null;

	@Subscribe
	public void onProfileChanged(ProfileChanged e) {
		lastProfile = configManager.getProfile();
	}

	private void handlePotentialTagRename(ConfigChanged event) {
		// Profile changes can look like tag renames sometimes, but we do not want to modify the config in that case
		// because it can cause people to lose their data.
		// The order is 1) configManager.getProfile() changes 2) ConfigChanged events 3) ProfileChanged event
		if (lastProfile.getId() != configManager.getProfile().getId()) {
			return;
		}

		String oldValue = event.getOldValue();
		String newValue = event.getNewValue();
		Set<String> oldTags = new HashSet<>(Text.fromCSV(oldValue == null ? "" : oldValue));
		Set<String> newTags = new HashSet<>(Text.fromCSV(newValue == null ? "" : newValue));
		// Compute the diff between the two lists.
		Iterator<String> iter = oldTags.iterator();
		while (iter.hasNext()) {
			String oldTag = iter.next();
			if (newTags.remove(oldTag)) {
				iter.remove();
			}
		}

		// Check if it's a rename or something else.
		if (oldTags.size() != 1 || newTags.size() != 1) return;

		LayoutableThing oldName = LayoutableThing.bankTag(oldTags.iterator().next());
		String newName = newTags.iterator().next();

		Layout oldLayout = getBankOrderNonPreview(oldName);
		if (oldLayout != null) {
			saveLayout(LayoutableThing.bankTag(newName), oldLayout);
			configManager.unsetConfiguration(CONFIG_GROUP, oldName.configKey());
		}
	}

	@Provides
	BankTagLayoutsConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BankTagLayoutsConfig.class);
	}

	private void applyLayoutPreview() {
		if (previewLayoutable.isBankTab()) {
			for (Integer itemId : previewLayout.getAllUsedItemIds()) {
				if (!copyPaste.findTag(itemId, previewLayoutable.name)) {
					log.debug("adding item " + itemNameWithId(itemId) + " to tag");
					tagManager.addTag(itemId, previewLayoutable.name, false);
				}
			}
		}

		saveLayoutNonPreview(previewLayoutable, previewLayout);

		cancelLayoutPreview();
		bankSearch.layoutBank();
	}

	private void hideLayoutPreviewButtons(boolean hide) {
		if (applyLayoutPreviewButton != null) applyLayoutPreviewButton.setHidden(hide);
		if (cancelLayoutPreviewButton != null) cancelLayoutPreviewButton.setHidden(hide);
		if (showLayoutPreviewButton != null && config.showAutoLayoutButton() && getCurrentLayoutableThing() != null) showLayoutPreviewButton.setHidden(!hide);
	}

	private void cancelLayoutPreview() {
		previewLayout = null;
		previewLayoutable = null;

		hideLayoutPreviewButtons(true);

		applyCustomBankTagItemPositions();
	}

	/** null indicates that there should not be a preview shown. */
	private Layout previewLayout = null;
	private LayoutableThing previewLayoutable = null;

	private void showLayoutPreview() {

		if (isShowingPreview()) return;
		LayoutableThing currentLayoutableThing = getCurrentLayoutableThing();
		if (currentLayoutableThing == null) {
			chatMessage("Select a tag tab before using this feature.");
			return;
		} else if (isVanillaLayoutEnabled(currentLayoutableThing)) {
			chatErrorMessage("This tag is using the new non-plugin-hub version of bank tag layouts. Disable it before using the plugin-hub version, by right-clicking the tag tab and selecting \"Disable layout\".");
			return;
		} else {
			// TODO allow creation of new tab.
		}

		if (currentLayoutableThing.isBankTab()) {
			List<Integer> equippedGear = getEquippedGear();
			List<Integer> inventory = getInventory();
			if (equippedGear.stream().noneMatch(id -> id > 0) && inventory.stream().noneMatch(id -> id > 0)) {
				chatMessage("This feature uses your equipped items and inventory to automatically create a bank tag layout, but you don't have any items equipped or in your inventory.");
				return;
			}

			hideLayoutPreviewButtons(false);

			Layout currentLayout = getBankOrderNonPreview(currentLayoutableThing);
			if (currentLayout == null) currentLayout = Layout.emptyLayout();

			previewLayout = layoutGenerator.basicBankTagLayout(equippedGear, inventory, config.autoLayoutIncludeRunePouchRunes() ? getRunePouchRunes() : Collections.emptyList(), Collections.emptyList(), currentLayout, getAutoLayoutDuplicateLimit(), config.autoLayoutStyle());
		} else {
			throw new UnsupportedOperationException();
		}

		hideLayoutPreviewButtons(false);

		previewLayoutable = currentLayoutableThing;

		applyCustomBankTagItemPositions();
	}

	private int getAutoLayoutDuplicateLimit() {
		return !config.autoLayoutDuplicatesEnabled() ? 0 : config.autoLayoutDuplicateLimit();
	}

	private List<Integer> getEquippedGear() {
		ItemContainer container = client.getItemContainer(InventoryID.EQUIPMENT);
		if (container == null) return Collections.emptyList();
		return Arrays.stream(container.getItems()).map(Item::getId).collect(Collectors.toList());
	}

	/**
	 * empty spaces before an item are always -1, empty spaces after an item may be -1 or may not be included in the
	 * list at all.
	 */
	private List<Integer> getInventory() {
		ItemContainer container = client.getItemContainer(InventoryID.INVENTORY);
		if (container == null) return Collections.emptyList();
		return Arrays.stream(container.getItems()).map(w -> w.getId()).collect(Collectors.toList());
	}

	private boolean isShowingPreview() {
		return previewLayout != null;
	}

	@Subscribe
	public void onClientTick(ClientTick clientTick) {
		if (checkInventorySetup + 1 == client.getGameCycle()) {
			updateInventorySetupShown();
		}

		if (!client.isMenuOpen()) {
			addBankTagTabMenuEntries();
		}

		Widget widget = client.getWidget(ComponentID.BANK_CONTAINER);
		if (widget == null || widget.isHidden()) {
			return;
		}

		// This fixes a vanilla bug where it's possible open a placeholder's right-click menu while trying to withdraw an item - see https://github.com/geheur/bank-tag-custom-layouts/issues/33 for more info.
		// I would do this in onMenuEntryAdded but client.getDraggedOnWidget() does not feel trustworthy at that point in the client tick - it is often null when it shouldn't bee - consistently and circumventable, but this makes me not trust the return value.
		if (
				config.preventVanillaPlaceholderMenuBug() &&
						client.getDraggedWidget() != null &&
						client.getDraggedOnWidget() != null
		) {
			MenuEntry[] menuEntries = client.getMenuEntries();
			if (menuEntries.length >= 1)
			{
				MenuEntry menuEntry = menuEntries[menuEntries.length - 1];
				if (
						WidgetUtil.componentToInterface(menuEntry.getParam1()) == InterfaceID.BANK &&
								menuEntry.getOption().equals("Release")
				) {
					menuEntry.setType(MenuAction.CC_OP);
				}
			}
		}

		sawMenuEntryAddedThisClientTick = false;
	}

	private static final int[] AMOUNT_VARBITS = {Varbits.RUNE_POUCH_AMOUNT1, Varbits.RUNE_POUCH_AMOUNT2, Varbits.RUNE_POUCH_AMOUNT3, Varbits.RUNE_POUCH_AMOUNT4};
	private static final int[] RUNE_VARBITS = {Varbits.RUNE_POUCH_RUNE1, Varbits.RUNE_POUCH_RUNE2, Varbits.RUNE_POUCH_RUNE3, Varbits.RUNE_POUCH_RUNE4};
	private List<Integer> getRunePouchRunes() {
		List<Integer> runes = new ArrayList<>(AMOUNT_VARBITS.length);
		EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
		for (int i = 0; i < AMOUNT_VARBITS.length; i++)
		{
			int amount = client.getVarbitValue(AMOUNT_VARBITS[i]);
			if (amount <= 0) {
				continue;
			}
			int runeId = client.getVarbitValue(RUNE_VARBITS[i]);
			int runeItemId = runepouchEnum.getIntValue(runeId);
			runes.add(runeItemId);
		}
		return runes;
	}

	private String inventorySetup = null;
	private void updateInventorySetupShown() {
		if (client.getVarbitValue(Varbits.CURRENT_BANK_TAB) == 15 /* potion storage */) {
			inventorySetup = null;
			return;
		}

		Widget bankTitleBar = client.getWidget(ComponentID.BANK_TITLE_BAR);
		String newSetup = null;
		if (bankTitleBar != null)
		{
			String bankTitle = bankTitleBar.getText();
			Matcher matcher = Pattern.compile("Inventory Setup <col=ff0000>(?<setup>.*) - (?<subfilter>.*)</col>.*").matcher(bankTitle);
			if (matcher.matches())
			{
				newSetup = matcher.group("setup");
			}
		}

		inventorySetup = newSetup;
	}

	int checkInventorySetup = 0;

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed) {
		if (widgetClosed.getGroupId() == InterfaceID.BANK) {
			checkInventorySetup = client.getGameCycle();
		}
	}

	@Subscribe(priority = -1f) // "Bank Tags" plugin also sets the scroll bar height; run after it. We also need to run after "Inventory Setups" to get the bank title it sets.
	public void onScriptPreFired(ScriptPreFired event) {
		if (event.getScriptId() != ScriptID.BANKMAIN_FINISHBUILDING) {
			return;
		}

		updateInventorySetupShown();

		LayoutableThing layoutable = getCurrentLayoutableThing();
		if (layoutable == null) {
			return;
		}

		Layout layout = getBankOrder(layoutable);
		if (layout == null) {
			return;
		}

		int maxIndex = layout.getAllUsedIndexes().stream().max(Integer::compare).orElse(0);
		int height = getYForIndex(maxIndex) + BANK_ITEM_HEIGHT;

		// This is prior to bankmain_finishbuilding running, so the arguments are still on the stack. Overwrite
		// argument int12 (7 from the end) which is the height passed to if_setscrollsize
		client.getIntStack()[client.getIntStackSize() - 7] = height;
	}

	@Subscribe(priority = -1f) // I want to run after the Bank Tags plugin does, since it will interfere with the layout-ing if hiding tab separators is enabled.
	public void onScriptPostFired(ScriptPostFired event) {
		if (event.getScriptId() == ScriptID.BANKMAIN_BUILD) {
			LayoutableThing layoutable = getCurrentLayoutableThing();
			if (layoutable == null || !layoutable.equals(lastLayoutable) || isVanillaLayoutEnabled(layoutable)) {
				cancelLayoutPreview();
			}

			applyCustomBankTagItemPositions(false);

			lastLayoutable = layoutable;

			// invokelater is required for when you open the bank with a tag tab already open.
			clientThread.invokeLater(this::updateButton);
		}
	}

	private void importLayout() {
		final String clipboardData;
		try {
			clipboardData = Toolkit
					.getDefaultToolkit()
					.getSystemClipboard()
					.getData(DataFlavor.stringFlavor)
					.toString()
					.trim();
		} catch (UnsupportedFlavorException | IOException e) {
			chatErrorMessage("import failed:", " couldn't get an import string from the clipboard");
			return;
		}

		if (!clipboardData.startsWith(BANK_TAG_STRING_PREFIX)) {
			// TODO try to import the tag as a normal tag?.
			if (Pattern.compile("[^,]+,\\d+(,[\\d-]+)*").matcher(clipboardData).matches() || clipboardData.startsWith("banktag")) {
				chatErrorMessage("import failed:", " This looks like a regular bank tag, try using \"Import tag tab\" instead of \"" + IMPORT_LAYOUT + "\".");
			} else {
				chatErrorMessage("import failed:", " Invalid format. layout-ed tag data starts with \"" + BANK_TAG_STRING_PREFIX + "\"; did you copy the wrong thing?");
			}
			return;
		}

		String[] split = clipboardData.split(",banktag:");
		if (split.length != 2) {
			chatErrorMessage("import failed:", " invalid format. layout string doesn't include regular bank tag data (It should say \"banktag:\" somewhere in the import string). Maybe you didn't copy the whole thing?");
			return;
		}

		String prefixRemoved = split[0].substring(BANK_TAG_STRING_PREFIX.length());

		String name;
		String layoutString;
		int firstCommaIndex = prefixRemoved.indexOf(",");
		if (firstCommaIndex == -1) { // There are no items in this layout.
			name = prefixRemoved;
			layoutString = "";
		} else {
			name = prefixRemoved.substring(0, firstCommaIndex);
			layoutString = prefixRemoved.substring(name.length() + 1);
		}

		name = validateTagName(name);
		if (name == null) return; // it was invalid.

		Layout layout;
		try {
			layout = Layout.fromString(layoutString);
		} catch (NumberFormatException e) {
			chatErrorMessage("import failed:", " something in the layout data is not a number");
			return;
		}
		String tagString = split[1];

		log.debug("import string: {}, {}, {}", name, layoutString, split[1]);

		// If the tag has no items in it, it will not trigger the overwrite warning. This is not intuitive, but I don't care enough to fix it.
		if (!tagManager.getItemsForTag(name).isEmpty()) {
			String finalName = name;
			chatboxPanelManager.openTextMenuInput("Tag tab with same name (" + name + ") already exists.")
					.option("Keep both, renaming imported tab", () -> {
						clientThread.invokeLater(() -> { // If the option is selected by a key, this will not be on the client thread.
							String newName = generateUniqueName(finalName);
							if (newName == null) {
								chatErrorMessage("import failed:", " couldn't find a unique name. do you literally have 100 similarly named tags???????????");
								return;
							}
							importLayout(newName, layout, tagString);
						});
					})
					.option("Overwrite existing tab", () -> {
						clientThread.invokeLater(() -> { // If the option is selected by a key, this will not be on the client thread.
							importLayout(finalName, layout, tagString);
						});
					})
					.option("Cancel", Runnables::doNothing)
					.build();
		} else {
			importLayout(name, layout, tagString);
		}
	}

	private String generateUniqueName(String name) {
		for (int i = 2; i < 100; i++) {
			String newName = "(" + i + ") " + name;
			if (tagManager.getItemsForTag(newName).isEmpty()) {
				return newName;
			}
		}
		return null;
	}

	private void importLayout(String name, Layout layout, String tagString) {
		boolean successful = importBankTag(name, tagString);
		if (!successful) return;

		layoutManager.saveLayout(new net.runelite.client.plugins.banktags.tabs.Layout(name, new int[0])); // disable vanilla layout
		saveLayout(LayoutableThing.bankTag(name), layout);

		chatMessage("Imported layout-ed tag tab \"" + name + "\"");

		applyCustomBankTagItemPositions();
	}

	void saveLayout(LayoutableThing layoutable, Layout layout) {
		if (isShowingPreview()) {
			previewLayout = layout;
			return;
		}

		saveLayoutNonPreview(layoutable, layout);
	}

	private void saveLayoutNonPreview(LayoutableThing layoutable, Layout layout) {
		configManager.setConfiguration(CONFIG_GROUP, layoutable.configKey(), layout.toString());
	}

	private String validateTagName(String name) {
		StringBuilder sb = new StringBuilder();
		for (char c : name.toCharArray()) {
			if (FILTERED_CHARS.test(c)) {
				sb.append(c);
			}
		}

		if (sb.length() == 0) {
			chatErrorMessage("import failed:", " tag name does not contain any valid characters.");
			return null;
		}

		return sb.toString().toLowerCase();
	}

	// TODO what is the purpose of the return value.
	private boolean importBankTag(String name, String tagString) {
		log.debug("importing tag data. " + tagString);
		final Iterator<String> dataIter = Text.fromCSV(tagString).iterator();
		dataIter.next(); // skip name.

		final String icon = dataIter.next();

		copyPaste.setIcon(name, icon);

		tagManager.removeTag(name);
		while (dataIter.hasNext()) {
			int itemId = Integer.parseInt(dataIter.next());
			tagManager.addTag(itemId, name, itemId < 0);
		}

		copyPaste.saveNewTab(name);
		copyPaste.loadTab(name);

		return true;
	}

	@Inject TabManager tabManager;

	private void enableLayout(LayoutableThing layoutable) {
		TagTab tagTab = tabManager.find(layoutable.name);
		net.runelite.client.plugins.banktags.tabs.Layout layout = layoutManager.loadLayout(layoutable.name);
		if (layout != null) {
			chatErrorMessage("This tag is using the new non-plugin-hub version of bank tag layouts. Disable it before enabling the plugin-hub version, by right-clicking the tag tab and selecting \"Disable layout\".");
			return;
		}
		saveLayout(layoutable, Layout.emptyLayout());
		if (layoutable.equals(getCurrentLayoutableThing())) {
			applyCustomBankTagItemPositions();
		}
	}

	private void disableLayout(String bankTagName) {
		chatboxPanelManager.openTextMenuInput("Delete layout for " + bankTagName + "?")
				.option("Yes", () ->
						clientThread.invoke(() ->
						{
							configManager.setConfiguration(CONFIG_GROUP, LAYOUT_CONFIG_KEY_PREFIX + bankTagName, LAYOUT_EXPLICITLY_DISABLED);
							if (tabInterface.getActiveTag() != null && bankTagName.equals(tabInterface.getActiveTag())) {
								bankSearch.layoutBank();
							}
						})
				)
				.option("No", Runnables::doNothing)
				.build();
	}

	private void applyCustomBankTagItemPositions() {
		applyCustomBankTagItemPositions(true);
	}

	private void applyCustomBankTagItemPositions(boolean setScroll) {
		fakeItems.clear();

		LayoutableThing layoutable = getCurrentLayoutableThing();
		if (layoutable == null) {
			return;
		}

		log.debug("applyCustomBankTagItemPositions: " + layoutable);

		indexToWidget.clear();

		Layout layout = getBankOrder(layoutable);
		if (layout == null) {
			return; // layout not enabled.
		}

		List<Widget> bankItems = Arrays.stream(client.getWidget(ComponentID.BANK_ITEM_CONTAINER).getDynamicChildren())
				.filter(bankItem -> !bankItem.isHidden() && bankItem.getItemId() >= 0)
				.collect(Collectors.toList());

		if (!hasVanillaOrHubLayoutEnabled(layoutable)) {
			for (Widget bankItem : bankItems) {
				bankItem.setOnDragCompleteListener((JavaScriptCallback) (ev) -> {
					boolean tutorialShown = tutorialMessage();

					if (!tutorialShown) bankReorderWarning(ev);
				});
			}
			return;
		}

		if (!isShowingPreview()) { // I don't want to clean layout items when displaying a preview. This could result in some layout placeholders being auto-removed due to not being in the tab.
			cleanItemsNotInBankTag(layout, layoutable);
		}

		indexToWidget.putAll(assignItemPositions(layout, bankItems));
		moveDuplicateItem();
		updateFakeItems(layout);

		for (Widget bankItem : bankItems) {
			bankItem.setOnDragCompleteListener((JavaScriptCallback) (ev) -> customBankTagOrderInsert(layoutable, ev.getSource()));
		}

		setItemPositions(indexToWidget);

		// Necessary as applyCustomBankTagItemPositions can be called after an item's layout position is changed. This doesn't fire BANKMAIN_BUILD, so our PreScriptFired subscriber doesn't change the scrollbar height, and the item's movement can change the height of the layout if it is moved below the last row or if it is the last item in the layout and is alone on its own row and was moved upwards.
		int maxIndex = layout.getAllUsedIndexes().stream().max(Integer::compare).orElse(0);
		int height = getYForIndex(maxIndex) + BANK_ITEM_HEIGHT + 8;
		if (setScroll && layoutable.equals(lastLayoutable) && height != lastHeight)
		{
			resizeBankContainerScrollbar(height, lastHeight);
		}
		lastHeight = height;

		saveLayout(layoutable, layout);
		log.debug("saved tag " + layoutable);
	}

	/**
	 * Generates a map of widgets to the bank indexes where they should show up in the laid-out tag. Does not update fake items.
	 */
	Map<Integer, Widget> assignItemPositions(Layout layout, List<Widget> bankItems)
	{
		Map<Integer, Widget> indexToWidget = new HashMap<>();
		assignVariantItemPositions(layout, bankItems, indexToWidget);
		// TODO check if the existance of this method is just a performance boost.
		assignNonVariantItemPositions(layout, bankItems, indexToWidget);
		return indexToWidget;
	}

	private void updateFakeItems(Layout layout)
	{
		fakeItems = calculateFakeItems(layout, indexToWidget);
	}

	// TODO this is n^2. There are multiple places I think where I do such an operation, so doing something about this would be nice.
	Set<FakeItem> calculateFakeItems(Layout layout, Map<Integer, Widget> indexToWidget)
	{
		Set<FakeItem> fakeItems = new HashSet<>();
		for (Map.Entry<Integer, Integer> entry : layout.allPairs()) {
			Integer index = entry.getKey();
			if (indexToWidget.containsKey(index)) continue;

			int itemId = entry.getValue();
			Optional<Widget> any = layout.allPairs().stream()
					.filter(e -> e.getValue() == itemId)
					.map(e -> indexToWidget.get(e.getKey()))
					.filter(widget -> widget != null)
					.findAny();

			boolean isLayoutPlaceholder = !any.isPresent();
			int quantity = any.isPresent() ? any.get().getItemQuantity() : -1;
			int fakeItemItemId = any.isPresent() ? any.get().getItemId() : itemId;
//			fakeItems.add(new FakeItem(index, getNonPlaceholderId(fakeItemItemId), isLayoutPlaceholder, quantity));
			fakeItems.add(new FakeItem(index, fakeItemItemId, isLayoutPlaceholder, quantity));
		}
		return fakeItems;
	}

	LayoutableThing getCurrentLayoutableThing() {
		String activeTag = tabInterface.getActiveTag();

		// This completely disables Inventory Setups integration.
		// Inventory Setups now uses core Bank Tags.
		if (activeTag != null && activeTag.startsWith("_invsetup_")) return null;

		boolean isBankTag = activeTag != null && !activeTag.equals("tagtabs");
		if (!isBankTag && !(inventorySetup != null && config.useWithInventorySetups())) {
			return null;
		}
		String name = isBankTag ? activeTag : inventorySetup;
		return new LayoutableThing(name, isBankTag);
	}

	private void bankReorderWarning(ScriptEvent ev) {
		if (
				config.warnForAccidentalBankReorder()
						&& ev.getSource().getId() == ComponentID.BANK_ITEM_CONTAINER && tabInterface.getActiveTag() != null
						&& client.getDraggedOnWidget() != null
						&& client.getDraggedOnWidget().getId() == ComponentID.BANK_ITEM_CONTAINER && tabInterface.getActiveTag() != null
						&& !hasVanillaOrHubLayoutEnabled(getCurrentLayoutableThing())
						&& !Boolean.parseBoolean(configManager.getConfiguration(BankTagsPlugin.CONFIG_GROUP, "preventTagTabDrags"))
		) {
			chatErrorMessage("You just reordered your actual bank!");
			chatMessage("If you wanted to use a bank tag layout, make sure you enable it for this tab first.");
			chatMessage("You should consider enabling \"Prevent tag tab item dragging\" in the Bank Tags plugin.");
			chatMessage("You can disable this warning in the Bank Tag Layouts config.");
		}
	}

	private boolean tutorialMessageShown = false;
	private boolean tutorialMessage() {
		if (!config.tutorialMessage()) return false;

		for (String key : configManager.getConfigurationKeys(CONFIG_GROUP)) {
			if (key.startsWith(CONFIG_GROUP + "." + LAYOUT_CONFIG_KEY_PREFIX)) { // They probably already know what to do if they have a key like this set.
				return false;
			}
		}

		if (!tutorialMessageShown) {
			tutorialMessageShown = true;
			chatMessage("If you want to use Bank Tag Layouts, enable it for the tab by right clicking the tag tab and clicking \"Enable layout\".");
			chatMessage("To disable this message, to go the Bank Tag Layouts config and disable \"Layout enable tutorial message\".");
			return true;
		}
		return false;
	}

	private void assignNonVariantItemPositions(Layout layout, List<Widget> bankItems, Map<Integer, Widget> indexToWidget) {
		for (Widget bankItem : bankItems) {
			int itemId = bankItem.getItemId();

			int nonPlaceholderId = getNonPlaceholderId(itemId);

			if (!itemShouldBeTreatedAsHavingVariants(nonPlaceholderId)) {
//				log.debug("\tassigning position for " + itemName(itemId) + itemId + ": ");

				Integer indexForItem = layout.getIndexForItem(itemId);
				if (indexForItem == -1) {
					// swap the item with its placeholder (or vice versa) and try again.
					int otherItemId = switchPlaceholderId(itemId);
					indexForItem = layout.getIndexForItem(otherItemId);
				}

				if (indexForItem == -1) {
					// The item is not in the layout.
					indexForItem = layout.getFirstEmptyIndex();
					layout.putItem(itemId, indexForItem);
				}
				indexToWidget.put(indexForItem, bankItem);
			}
		}
	}

	public Set<FakeItem> fakeItems = new HashSet<>();

	@Override
	public MouseEvent mouseClicked(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	public volatile int draggedItemIndex = -1; // Used for fake items only, not real items.
	public int dragStartX = 0;
	public int dragStartY = 0;
	public int dragStartScroll = 0;

	@Override
	public MouseEvent mousePressed(MouseEvent mouseEvent) {
		mouseIsPressed = true;
		if (mouseEvent.getButton() != MouseEvent.BUTTON1 || !hasLayoutEnabled(getCurrentLayoutableThing()) || !config.showLayoutPlaceholders() || client.isMenuOpen()) return mouseEvent;
		if (isShowingPreview() && applyLayoutPreviewButton != null && applyLayoutPreviewButton.contains(client.getMouseCanvasPosition())) {
			return mouseEvent;
		}
		int index = getIndexForMousePosition(true);
		FakeItem fakeItem = fakeItems.stream().filter(fake -> fake.index == index).findAny().orElse(null);
		if (fakeItem != null) {
			draggedItemIndex = fakeItem.index;
			dragStartX = mouseEvent.getX();
			dragStartY = mouseEvent.getY();
			dragStartScroll = client.getWidget(ComponentID.BANK_ITEM_CONTAINER).getScrollY();
			antiDrag.startDrag();
			mouseEvent.consume();
		}
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent mouseEvent) {
		mouseIsPressed = false;
		if (mouseEvent.getButton() != MouseEvent.BUTTON1 || !hasLayoutEnabled(getCurrentLayoutableThing())) return mouseEvent;
		if (draggedItemIndex == -1) return mouseEvent;

		if (config.showLayoutPlaceholders()) {
			int draggedOnIndex = getIndexForMousePositionNoLowerLimit();
			clientThread.invokeLater(() -> {
				if (draggedOnIndex != -1 && antiDrag.mayDrag()) {
					customBankTagOrderInsert(getCurrentLayoutableThing(), draggedItemIndex, draggedOnIndex);
				}
				antiDrag.endDrag();
				draggedItemIndex = -1;
			});
		}

		mouseEvent.consume();
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	@Data
	public static class FakeItem {
		public final int index;
		public final int itemId;
		public final boolean layoutPlaceholder;
		public final int quantity;
	}

	/**
	 * Used to run code in onMenuEntryAdded only once per client tick. Client tick events occur after MenuEntryAdded,
	 * so this flag is set in MenuEntryAdded and reset in ClientTick.
	 */
	boolean sawMenuEntryAddedThisClientTick = false;
	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded menuEntryAdded)
	{
		Widget widget = client.getWidget(ComponentID.BANK_CONTAINER);
		if (widget == null || widget.isHidden()) {
			return;
		}

		if (!sawMenuEntryAddedThisClientTick) {
			sawMenuEntryAddedThisClientTick = true;

			// If you move the items when you're dragging an item over its duplicates, undesirable behavior occurs.
			if (!mouseIsPressed)
			{
				boolean movedItemWidget = moveDuplicateItem();
				if (movedItemWidget)
				{
					updateFakeItems(getBankOrder(getCurrentLayoutableThing()));
					setItemPositions(indexToWidget);
				}
			}
		}

		addFakeItemMenuEntries(menuEntryAdded);
		addDuplicateItemMenuEntries(menuEntryAdded);
	}

	private void addBankTagTabMenuEntries()
	{
		String bankTagName = null;
		for (MenuEntry menuEntry : client.getMenuEntries()) {
			if (WidgetUtil.componentToInterface(menuEntry.getParam1()) == InterfaceID.BANK) {
				if ("View tag tab".equals(menuEntry.getOption())) {
					bankTagName = Text.removeTags(menuEntry.getTarget()).replace("\u00a0"," ");
				} else if ("New tag tab".equals(menuEntry.getOption())) {
					if (!config.showAutoLayoutButton()) {
						addEntry("", PREVIEW_AUTO_LAYOUT);
					}
					addEntry("", IMPORT_LAYOUT);
					return;
				}
			}
		}
		if (bankTagName != null) {
			LayoutableThing layoutable = LayoutableThing.bankTag(bankTagName);
			if (!config.showCoreRuneliteLayoutOptions() && !isVanillaLayoutEnabled(layoutable)) {
				// remove vanilla menu entries.
				MenuEntry[] menuEntries = client.getMenuEntries();
				List<MenuEntry> newEntries = new ArrayList<>();
				for (int i = 0; i < menuEntries.length; i++) {
					MenuEntry menuEntry = menuEntries[i];
					if (!"Enable layout".equals(menuEntry.getOption()) && !"Disable layout".equals(menuEntry.getOption())) {
						newEntries.add(menuEntry);
					}
				}
				client.setMenuEntries(newEntries.toArray(new MenuEntry[]{}));
			} else {
				for (MenuEntry menuEntry : client.getMenuEntries()) {
					if ("Enable layout".equals(menuEntry.getOption()) || "Disable layout".equals(menuEntry.getOption())) {
						menuEntry.setOption("(base runelite) " + menuEntry.getOption());
					}
				}
			}

			if (hasLayoutEnabled(layoutable)) {
				addEntry(bankTagName, EXPORT_LAYOUT);
			}

			addEntry(bankTagName, hasLayoutEnabled(layoutable) ? DISABLE_LAYOUT : ENABLE_LAYOUT);
		}
	}

	private void addEntry(String menuTarget, String menuOption) {
		client.createMenuEntry(1)
			.setOption(menuOption)
			.setTarget(ColorUtil.wrapWithColorTag(menuTarget, itemTooltipColor))
			.setType(MenuAction.RUNELITE);
	}

	private volatile boolean mouseIsPressed = false;

	/**
	 * Makes sure there is a real item under the mouse cursor if the mouse is over or near a duplicated item.
	 * @return true if an item widget was moved, false otherwise. If true, fake items should be updated and
	 * setItemPositions should be called, since this method does not do that.
	 */
	private boolean moveDuplicateItem()
	{
		if (getCurrentLayoutableThing() == null)
		{
			return false;
		}

		int mousePositionIndex = getIndexForMousePosition();
		Layout layout = getBankOrder(getCurrentLayoutableThing());
		if (layout == null) return false;
		int itemId = layout.getItemAtIndex(mousePositionIndex);

		if (itemId == -1)
		{
			return false;
		}

		int count = 0;
		List<Integer> indexes = new ArrayList<>();
		for (Map.Entry<Integer, Integer> entry : layout.allPairs())
		{
			if (entry.getValue() == itemId) {
				count++;
				indexes.add(entry.getKey());
			}
		}
		if (count > 1) {
			for (Integer index : indexes)
			{
				if (indexToWidget.containsKey(index) && index != mousePositionIndex) {
					Widget widget = indexToWidget.get(index);
					indexToWidget.remove(index);
					indexToWidget.put(mousePositionIndex, widget);
					return true;
				}
			}
		}
		return false;
	}

	private void addDuplicateItemMenuEntries(MenuEntryAdded menuEntryAdded)
	{
		if (config.shiftModifierForExtraBankItemOptions() && !client.isKeyPressed(KeyCode.KC_SHIFT)) return;

		LayoutableThing layoutable = getCurrentLayoutableThing();
		if (layoutable == null) return;
		Layout layout = getBankOrder(layoutable);
		if (layout == null) return;

		int index = getIndexForMousePosition(true);
		if (index == -1) return;
		int itemIdAtIndex = layout.getItemAtIndex(index);

		if (itemIdAtIndex == -1) return;

		boolean isRealItem = indexToWidget.containsKey(index);
		if (!menuEntryAdded.getOption().equals("Examine") && isRealItem) return;

		boolean isLayoutPlaceholder = fakeItems.stream()
				.filter(fakeItem -> fakeItem.getIndex() == index && fakeItem.isLayoutPlaceholder()).findAny().isPresent();

		int itemCount = layout.countItemsWithId(itemIdAtIndex);
		if (itemCount > 1 && !isLayoutPlaceholder) {
			client.createMenuEntry(-1)
					.setOption(REMOVE_DUPLICATE_ITEM)
					.setTarget(ColorUtil.wrapWithColorTag(itemName(itemIdAtIndex), itemTooltipColor))
					.setType(MenuAction.RUNELITE_OVERLAY)
					.setParam0(index);
		}

		client.createMenuEntry(-1)
				.setOption(DUPLICATE_ITEM)
				.setTarget(ColorUtil.wrapWithColorTag(itemName(itemIdAtIndex), itemTooltipColor))
				.setType(MenuAction.RUNELITE_OVERLAY)
				.setParam0(index);

		if (!isRealItem) return; // layout placeholders already have "remove-layout" menu option which does the same thing as remove-duplicate-item.
	}

	private void addFakeItemMenuEntries(MenuEntryAdded menuEntryAdded) {
		if (!menuEntryAdded.getOption().equalsIgnoreCase("cancel")) return;

		LayoutableThing currentLayoutableThing = getCurrentLayoutableThing();
		if (!config.showLayoutPlaceholders() || !hasLayoutEnabled(currentLayoutableThing)) {
			return;
		}
		Layout layout = getBankOrder(currentLayoutableThing);

		int index = getIndexForMousePosition(true);
		if (index == -1) return;
		int itemIdAtIndex = layout.getItemAtIndex(index);

		if (itemIdAtIndex != -1 && !indexToWidget.containsKey(index)) {
			boolean preventPlaceholderMenuBug =
					config.preventVanillaPlaceholderMenuBug() &&
							client.getDraggedWidget() != null;

			client.createMenuEntry(-1)
					.setOption(REMOVE_FROM_LAYOUT_MENU_OPTION)
					.setType(preventPlaceholderMenuBug ? MenuAction.CC_OP : MenuAction.RUNELITE_OVERLAY)
					.setTarget(ColorUtil.wrapWithColorTag(itemName(itemIdAtIndex), itemTooltipColor))
					.setParam0(index);
		}
	}

	/**
	 * @return -1 if the mouse is not over a location where a bank item can be.
	 */
	int getIndexForMousePositionNoLowerLimit() {
		return getIndexForMousePosition(false, true);
	}

	/**
	 * @return -1 if the mouse is not over a location where a bank item can be.
	 */
	int getIndexForMousePosition() {
		return getIndexForMousePosition(false);
	}

	/**
	 * @param dontEnlargeClickbox If this is false, the clickbox used to calculate the clickbox will be larger (2 larger up and down, 6 larger left to right), so that there are no gaps between clickboxes in the bank interface.
	 * @return -1 if the mouse is not over a location where a bank item can be.
	 */
	int getIndexForMousePosition(boolean dontEnlargeClickbox) {
		return getIndexForMousePosition(dontEnlargeClickbox, false);
	}

	/**
	 * @param dontEnlargeClickbox If this is false, the clickbox used to calculate the clickbox will be larger (2 larger up and down, 6 larger left to right), so that there are no gaps between clickboxes in the bank interface.
	 * @param noLowerLimit Still return indexes when the mouse is below the bank container.
	 * @return -1 if the mouse is not over a location where a bank item can be.
	 */
	int getIndexForMousePosition(boolean dontEnlargeClickbox, boolean noLowerLimit) {
		Widget bankItemContainer = client.getWidget(ComponentID.BANK_ITEM_CONTAINER);
		if (bankItemContainer == null) return -1;
		Point mouseCanvasPosition = client.getMouseCanvasPosition();

		int mouseX = mouseCanvasPosition.getX();
		int mouseY = mouseCanvasPosition.getY();
		Rectangle bankBounds = bankItemContainer.getBounds();

		if (
				noLowerLimit && (mouseX < bankBounds.getMinX() || mouseX > bankBounds.getMaxX() || mouseY < bankBounds.getMinY())
						|| !noLowerLimit && !bankBounds.contains(new java.awt.Point(mouseX, mouseY))) {
			return -1;
		}

		Point canvasLocation = bankItemContainer.getCanvasLocation();
		int scrollY = bankItemContainer.getScrollY();
		int row = (mouseY - canvasLocation.getY() + scrollY + 2) / BANK_ITEM_WIDTH;
		int col = (int) Math.floor((mouseX - canvasLocation.getX() - 51 + 6) / 48f);
		int index = row * 8 + col;
		if (row < 0 || col < 0 || col > 7 || index < 0) return -1;
		if (dontEnlargeClickbox) {
			int xDistanceIntoItem = (mouseX - canvasLocation.getX() - 51 + 6) % 48;
			int yDistanceIntoItem = (mouseY - canvasLocation.getY() + scrollY + 2) % BANK_ITEM_WIDTH;
			if (xDistanceIntoItem < 6 || xDistanceIntoItem >= 42 || yDistanceIntoItem < 2 || yDistanceIntoItem >= 34) {
				return -1;
			}
		}
		return index;
	}

	// TODO do I actually want to remove variant items from the tag? What if I'm just removing one of the layout items, and do not actually want to remove it from the tag? That seems very reasonable.
	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		Widget widget = client.getWidget(ComponentID.BANK_CONTAINER);
		if (widget == null || widget.isHidden()) {
			return;
		}

		// This fixes a vanilla bug where it's possible to release a placeholder without clicking "Release" - see https://github.com/geheur/bank-tag-custom-layouts/issues/33 for more info.
		if (
				config.preventVanillaPlaceholderMenuBug() &&
						!client.isMenuOpen() &&
						WidgetUtil.componentToInterface(event.getParam1()) == InterfaceID.BANK &&
						event.getMenuOption().equals("Release")
		) {
			event.consume();
			return;
		}

		if (!(event.getMenuAction() == MenuAction.RUNELITE_OVERLAY || event.getMenuAction() == MenuAction.RUNELITE)) return;

		String menuTarget = Text.removeTags(event.getMenuTarget()).replace("\u00a0"," ");

		// If this is on a real item, then the bank tags plugin will remove it from the tag, and this plugin only needs
		// to remove it from the layout. If this is on a fake item, this plugin must do both (unless the "Remove-layout"
		// option was clicked, then the tags are not touched).
		String menuOption = event.getMenuOption();
		boolean consume = true;
		if (menuOption.startsWith(REMOVE_FROM_LAYOUT_MENU_OPTION)) {
			removeFromLayout(event.getParam0());
		} else if (ENABLE_LAYOUT.equals(menuOption)) {
			enableLayout(LayoutableThing.bankTag(menuTarget));
		} else if (DISABLE_LAYOUT.equals(menuOption)) {
			disableLayout(menuTarget);
		} else if (EXPORT_LAYOUT.equals(menuOption)) {
			exportLayout(menuTarget);
		} else if (IMPORT_LAYOUT.equals(menuOption)) {
			importLayout();
		} else if (PREVIEW_AUTO_LAYOUT.equals(menuOption)) {
			showLayoutPreview();
		} else if (DUPLICATE_ITEM.equals(menuOption)) {
			duplicateItem(event.getParam0());
		} else if (REMOVE_DUPLICATE_ITEM.equals(menuOption)) {
			removeFromLayout(event.getParam0());
		} else {
			consume = false;
		}
		if (consume) event.consume();
	}

	private void removeFromLayout(int index)
	{
		LayoutableThing layoutable = getCurrentLayoutableThing();
		Layout layout = getBankOrder(layoutable);
		layout.clearIndex(index);
		saveLayout(layoutable, layout);

		applyCustomBankTagItemPositions();
	}

	@VisibleForTesting
	void duplicateItem(int clickedItemIndex)
	{
		LayoutableThing layoutable = getCurrentLayoutableThing();
		Layout layout = getBankOrder(layoutable);

		layout.duplicateItem(clickedItemIndex, getIdForIndexInRealBank(clickedItemIndex));
		saveLayout(layoutable, layout);

		applyCustomBankTagItemPositions();
	}

	// TODO consider using tagManager.getItemsForTag(bankTagName) because unlike findTag it is api.
	private void cleanItemsNotInBankTag(Layout layout, LayoutableThing layoutable) {
		Predicate<Integer> containsId;
		if (layoutable.isBankTab()) {
			containsId = id -> copyPaste.findTag(id, layoutable.name);
		}
		else
		{
			throw new UnsupportedOperationException();
		}

		Iterator<Map.Entry<Integer, Integer>> iter = layout.allPairsIterator();
		while (iter.hasNext()) {
			int itemId = iter.next().getValue();

			if (!containsId.test(itemId))
			{
				log.debug("removing " + itemNameWithId(itemId) + " because it is no longer in the thing");
				iter.remove();
			}
		}
	}

	// TODO this logic needs looking at re: barrows items.
	private void assignVariantItemPositions(Layout layout, List<Widget> bankItems, Map<Integer, Widget> indexToWidget) {
		// Remove duplicate item id widgets.
		Set<Object> seen = ConcurrentHashMap.newKeySet();
		bankItems = new ArrayList<>(bankItems.stream().filter(widget -> seen.add(widget.getItemId())).collect(Collectors.toList()));

		Multimap<Integer, Widget> variantItemsInBank = LinkedListMultimap.create(); // key is the variant base id; the list contains the item widgets that go in this variant base id;
		for (Widget bankItem : bankItems) {
			int nonPlaceholderId = getNonPlaceholderId(bankItem.getItemId());
			if (itemShouldBeTreatedAsHavingVariants(nonPlaceholderId)) {
				int variationBaseId = getVariationBaseId(nonPlaceholderId);
				variantItemsInBank.put(variationBaseId, bankItem);
			}
		}

		Multimap<Integer, Integer> variantItemsInLayout = LinkedListMultimap.create(); // key is the variant base id; the list contains the item ids;
		for (Map.Entry<Integer, Integer> pair : layout.allPairs()) {
			int nonPlaceholderId = getNonPlaceholderId(pair.getValue());
			if (itemShouldBeTreatedAsHavingVariants(nonPlaceholderId)) {
				int variationBaseId = getVariationBaseId(nonPlaceholderId);
				variantItemsInLayout.put(variationBaseId, pair.getValue());
			}
		}

		for (Integer variationBaseId : variantItemsInBank.keySet()) {
			List<Widget> notYetPositionedWidgets = new ArrayList<>(variantItemsInBank.get(variationBaseId));

			// first, figure out if there is a perfect match.
			assignitemstrashname(indexToWidget, variantItemsInLayout, variationBaseId, notYetPositionedWidgets, (itemIdsInLayoutForVariant, itemId) -> itemIdsInLayoutForVariant.contains(itemId) ? layout.getIndexForItem(itemId) : -1, "pass 1 (exact itemid match)");

			// check matches of placeholders or placeholders matching items.
			assignitemstrashname(indexToWidget, variantItemsInLayout, variationBaseId, notYetPositionedWidgets, (itemIdsInLayoutForVariant, itemId) -> {
				itemId = switchPlaceholderId(itemId);
				return itemIdsInLayoutForVariant.contains(itemId) ? layout.getIndexForItem(itemId) : -1;
			}, "pass 2 (placeholder match)");

			// match any variant item.
			assignitemstrashname(indexToWidget, variantItemsInLayout, variationBaseId, notYetPositionedWidgets, (itemIdsInLayoutForVariant, itemId) -> {
				for (Integer id : itemIdsInLayoutForVariant) {
					int index = layout.getIndexForItem(id);
					if (!indexToWidget.containsKey(index)) {
						return index;
					}
				}
				return -1;
			}, "pass 3 (variant item match)");

			if (!notYetPositionedWidgets.isEmpty()) {
				for (Widget notYetPositionedWidget : notYetPositionedWidgets) {
					int itemId = notYetPositionedWidget.getItemId();
					int layoutIndex = layout.getIndexForItem(itemId);
					if (layoutIndex != -1) continue; // Prevents an issue where items with the same id that take up multiple bank slots, e.g. items that have their charges stored on the item, can be added into two slots during this stage.
					int index = layout.getFirstEmptyIndex();
					layout.putItem(itemId, index);
					log.debug("item " + itemNameWithId(itemId) + " assigned on pass 4 (assign to empty spot) to index " + index);
					indexToWidget.put(index, notYetPositionedWidget);
				}
			}
		}
	}

	private int getVariationBaseId(int nonPlaceholderId)
	{
		int runeliteBaseId = ItemVariationMapping.map(nonPlaceholderId);
		if (runeliteBaseId == 713) {
			ItemComposition itemComposition = itemManager.getItemComposition(nonPlaceholderId);
			int iconId = itemComposition.getInventoryModel();
			if (iconId == 37162) { // beginner
				return nonPlaceholderId; // All share the same id.
			}
			else if (iconId == 37202) { // easy
				return 2677; // Lowest id of this clue type.
			}
			else if (iconId == 37152) { // medium
				return 2801; // Lowest id of this clue type.
			}
			else if (iconId == 37181) { // hard
				return 2722; // Lowest id of this clue type.
			}
			else if (iconId == 37167) { // elite
				return 12073; // Lowest id of this clue type.
			}
			else if (iconId == 37183) { // master
				return nonPlaceholderId; // All share the same id.
			}
			// this is either a (likely unobtainable) pink skirt or a sote quest item. I don't care how either of these items are handled.
		}
		return runeliteBaseId;
	}

	@FunctionalInterface
	private interface functionalinterfacetrashname {
		int getIndex(Collection<Integer> itemIds, int itemId);
	}

	private void assignitemstrashname(Map<Integer, Widget> indexToWidget, Multimap<Integer, Integer> variantItemsInLayout, Integer variationBaseId, List<Widget> notYetPositionedWidgets, functionalinterfacetrashname getIndex, String debugDescription)
	{
		Iterator<Widget> iter = notYetPositionedWidgets.iterator();
		while (iter.hasNext()) {
			Widget widget = iter.next();
			int itemId = widget.getItemId();

			Collection<Integer> itemIds = variantItemsInLayout.get(variationBaseId);
			if (itemIds == null) continue; // this could happen because I removed all the widgets at this key.

			int index = getIndex.getIndex(itemIds, itemId);

			if (index != -1 && !indexToWidget.containsKey(index)) {
				log.debug("item " + itemNameWithId(itemId) + " assigned on " + debugDescription + " to index " + index);
				indexToWidget.put(index, widget);
				iter.remove();
			}
		}
	}

	/**
	 */
	private boolean itemHasVariants(int nonPlaceholderItemId) {
		return ItemVariationMapping.getVariations(ItemVariationMapping.map(nonPlaceholderItemId)).size() > 1;
	}

	/**
	 * Whether this item should be treated as having variants for the purpose of custom bank layouts.
	 * If true, this means that the item should occupy the next available position in the custom layout which matches either its own id or any of its variants.
	 * This includes placeholders for the item.
	 * This does mean that the order that items appear in in the normal bank has an impact on the custom layout. Not something you'd expect from this feature, lol.
	 */
	boolean itemShouldBeTreatedAsHavingVariants(int nonPlaceholderItemId) {
		return itemHasVariants(nonPlaceholderItemId);
	}

	public boolean hasLayoutEnabled(LayoutableThing layoutable) {
		if (layoutable == null) return false;
		if (isShowingPreview()) return true;
		TagTab tagTab = tabManager.find(layoutable.name);
		if (layoutable.isBankTab && tagTab != null && hasRuneliteLayout(layoutable.name)) return false;

		String configuration = configManager.getConfiguration(CONFIG_GROUP, layoutable.configKey());
		if (LAYOUT_EXPLICITLY_DISABLED.equals(configuration)) return false;
		return configuration != null || (layoutable.isBankTab() && config.layoutEnabledByDefault()) || (layoutable.isInventorySetup() && config.useWithInventorySetups());
	}

	public boolean hasVanillaOrHubLayoutEnabled(LayoutableThing layoutable) {
		if (layoutable == null) return false;
		if (isShowingPreview()) return true;
		TagTab tagTab = tabManager.find(layoutable.name);
		if (tagTab != null && hasRuneliteLayout(layoutable.name)) return true;

		String configuration = configManager.getConfiguration(CONFIG_GROUP, layoutable.configKey());
		if (LAYOUT_EXPLICITLY_DISABLED.equals(configuration)) return false;
		return configuration != null || (layoutable.isBankTab() && config.layoutEnabledByDefault()) || (layoutable.isInventorySetup() && config.useWithInventorySetups());
	}

	public boolean isVanillaLayoutEnabled(LayoutableThing layoutable) {
		if (layoutable == null) return false;
		TagTab tagTab = tabManager.find(layoutable.name);
		return tagTab != null && hasRuneliteLayout(layoutable.name);
	}

	public boolean hasRuneliteLayout(String tag) {
		return this.configManager.getConfiguration("banktags", "layout_" + Text.standardize(tag)) != null;
	}

	/**
	 * the bank order which is actually used.
	 */
	Layout getBankOrder(LayoutableThing layoutable) {
		if (isShowingPreview()) {
			return previewLayout;
		}

		if (isVanillaLayoutEnabled(layoutable)) return null;
		return getBankOrderNonPreview(layoutable);
	}

	/**
	 * unlike getBankOrder, this will not return a preview layout when one is currently being show.
	 */
	private Layout getBankOrderNonPreview(LayoutableThing layoutable) {
		String configuration = configManager.getConfiguration(CONFIG_GROUP, layoutable.configKey());
		if (LAYOUT_EXPLICITLY_DISABLED.equals(configuration)) return null;
		if (configuration == null) {
			if (layoutable.isBankTab() && !config.layoutEnabledByDefault() || layoutable.isInventorySetup() && !config.useWithInventorySetups()) {
				return null;
			} else if (layoutable.isInventorySetup()) {
				throw new UnsupportedOperationException();
			}

			configuration = "";
		}
		return Layout.fromString(configuration, true);
	}

	private void exportLayout(String tagName) {
		String exportString = BANK_TAG_STRING_PREFIX + tagName;
		String layout = getBankOrder(LayoutableThing.bankTag(tagName)).toString();
		if (!layout.isEmpty()) {
			exportString += ",";
		}
		exportString += layout;

		List<String> tabNames = Text.fromCSV(MoreObjects.firstNonNull(configManager.getConfiguration(BankTagsPlugin.CONFIG_GROUP, BankTagsPlugin.TAG_TABS_CONFIG), ""));
		if (!tabNames.contains(tagName)) {
			chatErrorMessage("Couldn't export layout-ed tag tab - tag tab doesn't see to exist?");
		}

		List<String> data = new ArrayList<>();
		data.add(tagName);
		String tagTabIconItemId = copyPaste.getIcon(tagName);
		if (tagTabIconItemId == null) {
			tagTabIconItemId = "" + ItemID.SPADE;
		}
		data.add(tagTabIconItemId);

		for (Integer item : tagManager.getItemsForTag(tagName)) {
			data.add(String.valueOf(item));
		}

		exportString += ",banktag:" + Text.toCSV(data);

		putInClipboard(exportString);
		chatMessage("Copied layout-ed tag \"" + tagName + "\" to clipboard");
	}

	private void putInClipboard(String exportString) {
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(exportString), null);
	}

	private MessageNode chatErrorMessage(String message) {
		return chatMessage(ColorUtil.wrapWithColorTag(message, Color.RED));
	}

	private MessageNode chatErrorMessage(String redMessage, String regularMessage) {
		return chatMessage(ColorUtil.wrapWithColorTag(redMessage, Color.RED) + regularMessage);
	}

	private MessageNode chatMessage(String message) {
		return client.addChatMessage(ChatMessageType.GAMEMESSAGE, "bla", message, "bla");
	}

	static int getXForIndex(int index) {
		return (index % 8) * 48 + 51;
	}

	static int getYForIndex(int index) {
		return (index / 8) * BANK_ITEM_WIDTH;
	}

	private void setItemPositions(Map<Integer, Widget> indexToWidget) {
		Widget container = client.getWidget(ComponentID.BANK_ITEM_CONTAINER);
		// Hide all widgets not in indexToWidget.
		outer_loop:
		for (Widget child : container.getDynamicChildren()) {
			if (child.isHidden()) continue;
			for (Map.Entry<Integer, Widget> integerWidgetEntry : indexToWidget.entrySet()) {
				if (integerWidgetEntry.getValue().equals(child)) {
					continue outer_loop;
				}
			}

			child.setHidden(true);
			child.revalidate();
		}

		for (Map.Entry<Integer, Widget> entry : indexToWidget.entrySet()) {
			Widget widget = entry.getValue();
			int index = entry.getKey();

			widget.setOriginalX(getXForIndex(index));
			widget.setOriginalY(getYForIndex(index));
			widget.revalidate();
		}
	}

	@RequiredArgsConstructor
	@EqualsAndHashCode
	static final class LayoutableThing {
		public final String name;
		/** false means it's an inventory setup. */
		public final boolean isBankTab;

		public static LayoutableThing bankTag(String tagName) {
			return new LayoutableThing(tagName, true);
		}

		public static LayoutableThing inventorySetup(String inventorySetupName) {
			return new LayoutableThing(inventorySetupName, false);
		}

		@Override
		public String toString() {
			return name + " " + (isBankTab ? "(bank tab)" : "(inventory setup)");
		}

		public String configKey() {
			if (isBankTab) {
				return LAYOUT_CONFIG_KEY_PREFIX + name;
			} else {
				return INVENTORY_SETUPS_LAYOUT_CONFIG_KEY_PREFIX + escapeColonCharactersInInventorySetupName(name);
			}
		}

		static String escapeColonCharactersInInventorySetupName(String s)
		{
			return s.replaceAll("&", "&amp;").replaceAll(":", "&#58;");
		}

		public boolean isBankTab() {
			return isBankTab;
		}

		public boolean isInventorySetup() {
			return !isBankTab;
		}
	}

	private void resizeBankContainerScrollbar(int height, int lastHeight) {
		Widget container = client.getWidget(ComponentID.BANK_ITEM_CONTAINER);

		container.setScrollHeight(height); // This change requires the script below to run to take effect.

		int itemContainerScroll = (height > lastHeight) ? height : container.getScrollY();

		clientThread.invokeLater(() ->
				client.runScript(ScriptID.UPDATE_SCROLLBAR,
						ComponentID.BANK_SCROLLBAR,
						ComponentID.BANK_ITEM_CONTAINER,
						itemContainerScroll)
		);
	}

	public String itemName(Integer itemId) {
		return (itemId == null) ? "null" : itemManager.getItemComposition(itemId).getName();
	}

	public String itemNameWithId(Integer itemId) {
		return ((itemId == null) ? "null" : itemManager.getItemComposition(itemId).getName()) + " (" + itemId + (isPlaceholder(itemId) ? ",ph" : "") + ")";
	}

	private int getPlaceholderId(int id) {
		ItemComposition itemComposition = itemManager.getItemComposition(id);
		return (itemComposition.getPlaceholderTemplateId() == 14401) ? id : itemComposition.getPlaceholderId();
	}

	int getNonPlaceholderId(int id) {
		ItemComposition itemComposition = itemManager.getItemComposition(id);
		return (itemComposition.getPlaceholderTemplateId() == 14401) ? itemComposition.getPlaceholderId() : id;
	}

	int switchPlaceholderId(int id) {
		ItemComposition itemComposition = itemManager.getItemComposition(id);
		return itemComposition.getPlaceholderId();
	}

	public boolean isPlaceholder(int id) {
		ItemComposition itemComposition = itemManager.getItemComposition(id);
		return itemComposition.getPlaceholderTemplateId() == 14401;
	}

	private void customBankTagOrderInsert(LayoutableThing layoutable, Widget draggedItem) {
		int draggedOnItemIndex = getIndexForMousePositionNoLowerLimit();
		if (draggedOnItemIndex == -1) return;

		int draggedItemIndex = -1;
		for (Map.Entry<Integer, Widget> entry : indexToWidget.entrySet()) {
			if (entry.getValue().equals(draggedItem)) {
				draggedItemIndex = entry.getKey();
			}
		}

		customBankTagOrderInsert(layoutable, draggedItemIndex, draggedOnItemIndex);
	}

	private void customBankTagOrderInsert(LayoutableThing layoutable, int draggedItemIndex, int draggedOnItemIndex) {
		Layout layout = getBankOrder(layoutable);
		if (layout == null) return;

		// Currently I'm just spilling the variant items out in bank order, so I don't care exactly what item id was there - although if I ever decide to change this, this section will become much more complicated, since if I drag a (2) charge onto a regular item, but there was supposed to be a (3) charge there then I have to move the (2) but also deal with where the (2)'s saved position is... At least that's how it'll go if I decide to handle jewellery that way.

		Integer currentDraggedItemId = getIdForIndexInRealBank(draggedItemIndex);

		layout.moveItem(draggedItemIndex, draggedOnItemIndex, currentDraggedItemId);

		saveLayout(layoutable, layout);

		applyCustomBankTagItemPositions();
	}

	private Integer getIdForIndexInRealBank(int index) {
		if (index == -1) return -1;
		Widget widget = indexToWidget.get(index);
		if (widget == null) return -1;
		return widget.getItemId();
	}

	// Disable reordering your real bank while any tag tab is active, as if the Bank Tags Plugin's "Prevent tag tab item dragging" was enabled.
	@Subscribe(priority = -1f) // run after bank tags, otherwise you can't drag items into other tabs while a tab is open.
	public void onDraggingWidgetChanged(DraggingWidgetChanged event) {
		Widget widget = client.getWidget(ComponentID.BANK_CONTAINER);
		if (widget == null || widget.isHidden()) {
			return;
		}

		Widget draggedWidget = client.getDraggedWidget();

		// Returning early or nulling the drag release listener has no effect. Hence, we need to
		// null the draggedOnWidget instead.
		if (draggedWidget.getId() == ComponentID.BANK_ITEM_CONTAINER && hasLayoutEnabled(getCurrentLayoutableThing())) {
			client.setDraggedOnWidget(null);
		}
	}

	@Subscribe
	public void onFocusChanged(FocusChanged focusChanged)
	{
		antiDrag.focusChanged(focusChanged);
	}

	@Subscribe
	public void onMenuShouldLeftClick(MenuShouldLeftClick event)
	{
		Widget widget = client.getWidget(ComponentID.BANK_CONTAINER);
		if (widget == null || widget.isHidden()) {
			return;
		}

		MenuEntry[] menuEntries = client.getMenuEntries();
		for (MenuEntry entry : menuEntries)
		{
			// checking the type is kinda hacky because really both preview auto layout entries should have the runelite id... but it works.
			if (entry.getOption().equals(PREVIEW_AUTO_LAYOUT) && entry.getType() != MenuAction.RUNELITE)
			{
				event.setForceRightClick(true);
				return;
			}
		}
	}
}

package com.banktaglayouts;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
public class Layout {

    // Maps indexes to items.
    private Map<Integer, Integer> layoutMap = new HashMap<>();

    public static Layout fromString(String layoutString) {
        return fromString(layoutString, false);
    }

    public static Layout fromString(String layoutString, boolean ignoreNfe) {
        Layout layout = Layout.emptyLayout();
        if (layoutString.isEmpty()) return layout;
        for (String s1 : layoutString.split(",")) {
            String[] split = s1.split(":");
            try {
                int itemId = Integer.parseInt(split[0]);
                int index = Integer.parseInt(split[1]);
                if (index >= 0) {
                    layout.putItem(itemId, index);
                } else {
                    log.debug("Removed item " + itemId + " due to it having a negative index (" + index + ")");
                }
            } catch (NumberFormatException e) {
                if (!ignoreNfe) throw e;
                log.debug("input string \"" + layoutString + "\"");
            }
        }
        return layout;
    }

    public static Layout emptyLayout() {
        return new Layout();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<Integer, Integer> integerIntegerEntry : allPairs()) {
            sb.append(integerIntegerEntry.getValue() + ":" + integerIntegerEntry.getKey() + ",");
        }
        if (sb.length() > 0) {
            sb.delete(sb.length() - 1, sb.length());
        }
        return sb.toString();
    }

    public void putItem(int itemId, int index) {
        if (itemId <= 0) {
            layoutMap.remove(index);
            return;
        }
        layoutMap.put(index, itemId);
    }

    /** returns -1 if there is no item there. */
    public int getItemAtIndex(int index) {
        return layoutMap.getOrDefault(index, -1);
    }

    public Iterator<Map.Entry<Integer, Integer>> allPairsIterator() {
        return layoutMap.entrySet().iterator();
    }

    /**
     * Finds the index for the EXACT itemId. Does not factor in placeholders or variation items. For duplicated items,
     * it returns one of the indexes where the itemId can be found.
     * If there's no index for this itemId, then it returns -1.
     */
    public Integer getIndexForItem(int itemId) {
        return allPairs().stream()
                .filter(e -> e.getValue() == itemId)
                .map(e -> e.getKey())
                .findAny().orElse(-1);
    }

    /**
     * Finds the indexes for the EXACT itemId. Does not factor in placeholders or variation items.
     * If there're no indexes for this itemId, then it returns an empty list.
     */
    private List<Integer> getIndexesForItem(int itemId)
    {
        return allPairs().stream()
                .filter(e -> e.getValue() == itemId)
                .map(e -> e.getKey())
                .collect(Collectors.toList());
    }

    public Collection<Integer> getAllUsedItemIds() {
        return new HashSet<>(layoutMap.values());
    }

    public Collection<Integer> getAllUsedIndexes() {
        return layoutMap.keySet();
    }

    public Collection<Map.Entry<Integer, Integer>> allPairs() {
        return layoutMap.entrySet();
    }

    public int getFirstEmptyIndex() {
        return getFirstEmptyIndex(-1);
    }

    public int getFirstEmptyIndex(int afterThisIndex) {
        List<Integer> indexes = new ArrayList<>(getAllUsedIndexes());
        indexes.sort(Integer::compare);
        for (Integer integer : indexes) {
            if (integer < afterThisIndex) continue;

            if (integer - afterThisIndex > 1) {
                break;
            }
            afterThisIndex = integer;
        }
        return afterThisIndex + 1;
    }

    public void clearIndex(int index) {
        layoutMap.remove(index);
    }

    /**
     * @param draggedItemIndex dragged item's original index.
     * @param targetIndex target location's index.
     * @param draggedItemId the dragged item widget's item id.
     */
    public void moveItem(int draggedItemIndex, int targetIndex, int draggedItemId) {
        int layoutItemId = getItemAtIndex(draggedItemIndex);
        if (draggedItemId == -1) { // dragging a layout placeholder, or bad input.
            draggedItemId = layoutItemId;
            assert draggedItemId != -1;
        } else if (layoutItemId != draggedItemId) {
            // Modifying a layout should use the real item there, NOT the item id stored in the layout (which can be
            // different due to how variant items are assigned indexes), because the item the user sees themselves
            // moving is the item id in the widget, not the item id in the layout. Therefore, the duplicates must be
            // updated to use that id as well.
            for (Integer index : getIndexesForItem(layoutItemId)) {
                putItem(draggedItemId, index);
            }
        }

        int targetItemId = getItemAtIndex(targetIndex);

        clearIndex(draggedItemIndex);
        clearIndex(targetIndex);
        putItem(draggedItemId, targetIndex);
        if (targetItemId != -1) {
            putItem(targetItemId, draggedItemIndex);
        }
    }

    public boolean isEmpty()
    {
        return layoutMap.isEmpty();
    }

    public int countItemsWithId(int idAtIndex)
    {
        int count = 0;
        for (Map.Entry<Integer, Integer> pair : allPairs())
        {
            if (pair.getValue() == idAtIndex) {
                count++;
            }
        }
        return count;
    }

    // TODO create test.
    public void duplicateItem(int clickedItemIndex, int itemIdAtIndex)
    {
        int duplicatedItemIndex = getFirstEmptyIndex(clickedItemIndex);

        int layoutItemId = getItemAtIndex(clickedItemIndex);
        if (itemIdAtIndex == -1) itemIdAtIndex = layoutItemId;
        if (layoutItemId != itemIdAtIndex) {
            // Modifying a layout should always use the real item there, NOT the item id stored in the layout (which can
            // be different due to how variant items are assigned indexes).
            // Therefore, the duplicates must be updated to use that id as well.
            List<Integer> indexesToChange = getIndexesForItem(layoutItemId);
            for (Integer index : indexesToChange) {
                putItem(itemIdAtIndex, index);
            }
        }

        putItem(itemIdAtIndex, duplicatedItemIndex);
    }
}

package com.banktaglayouts;

import lombok.RequiredArgsConstructor;
import net.runelite.api.events.FocusChanged;
import net.runelite.client.input.KeyListener;

import java.awt.event.KeyEvent;

/**
 * Utilities for simulating the AntiDrag plugin.
 */
@RequiredArgsConstructor
public class AntiDragPluginUtil implements KeyListener {

    private final BankTagLayoutsPlugin plugin;

    private boolean ctrlDown = false;
    private boolean shiftDown = false;

    /** necessary to prevent the item snapping back if you start a drag and then tap control. */
    private boolean earlyAllowDrag = false;
    private long dragStart = -1;

    public boolean isAntiDragPluginEnabled() {
        return Boolean.parseBoolean(plugin.configManager.getConfiguration("runelite", "antidragplugin"));
    }

    /**
     * @return drag delay in client ticks (20ms increments).
     */
    public int getDragDelay() {
        int dragDelay;
        try {
            dragDelay = Integer.parseInt(plugin.configManager.getConfiguration("antiDrag", "dragDelay"));
        } catch (NumberFormatException e) {
            return 30; // default value.
        }
        return dragDelay;
    }

    public boolean disableOnCtrl() {
        return Boolean.parseBoolean(plugin.configManager.getConfiguration("antiDrag", "disableOnCtrl"));
    }

    public boolean onShiftOnly() {
        String configuration = plugin.configManager.getConfiguration("antiDrag", "onShiftOnly");
        if (configuration == null) return true; // default value is true for this setting.
        return Boolean.parseBoolean(configuration);
    }

    /**
     * Factors in plugin enabled, and keyboard key state.
     */
    public int getCurrentDragDelay() {
        if (!isAntiDragPluginEnabled()) return 5;
        if (onShiftOnly()) {
            return shiftDown ? getDragDelay() : 5;
        }
        if (disableOnCtrl() && ctrlDown) return 5;
        return getDragDelay();
    }

    public boolean mayDrag() {
        if (dragStart == -1) return true;
        if (earlyAllowDrag) return true;
        return System.currentTimeMillis() - dragStart > getCurrentDragDelay() * 20;
    }

    public void startDrag() {
        dragStart = System.currentTimeMillis();
        earlyAllowDrag = false;
    }

    public void endDrag() {
        dragStart = -1;
    }

    @Override
    public void keyTyped(KeyEvent e) {
        // do nothing.
    }

    @Override
    public void keyPressed(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_CONTROL)
        {
            ctrlDown = true;
            earlyAllowDrag = true;
        }
        else if (e.getKeyCode() == KeyEvent.VK_SHIFT)
        {
            shiftDown = true;
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        if (e.getKeyCode() == KeyEvent.VK_CONTROL)
        {
            ctrlDown = false;
        }
        else if (e.getKeyCode() == KeyEvent.VK_SHIFT)
        {
            shiftDown = false;
        }
    }

    public void focusChanged(FocusChanged focusChanged) {
        if (!focusChanged.isFocused()) {
            ctrlDown = false;
            shiftDown = false;
        }
    }
}

package com.banktaglayouts;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

@Slf4j
public class FakeItemOverlay extends Overlay {
    @Inject
    private Client client;

    @Inject
    private ItemManager itemManager;

    @Inject
    private BankTagLayoutsPlugin plugin;

    @Inject
    private BankTagLayoutsConfig config;

    FakeItemOverlay()
    {
        drawAfterLayer(ComponentID.BANK_ITEM_CONTAINER);
        setLayer(OverlayLayer.MANUAL);
        setPosition(OverlayPosition.DYNAMIC);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        BankTagLayoutsPlugin.LayoutableThing currentLayoutableThing = plugin.getCurrentLayoutableThing();
        if (currentLayoutableThing == null) return null;

        Layout layout = plugin.getBankOrder(currentLayoutableThing);
        if (layout == null) return null;

        Widget bankItemContainer = client.getWidget(ComponentID.BANK_ITEM_CONTAINER);
        if (bankItemContainer == null) return null;
		int scrollY = bankItemContainer.getScrollY();
        Point canvasLocation = bankItemContainer.getCanvasLocation();

		int yOffset = 0;
		Widget widget = bankItemContainer;
        while (widget.getParent() != null) {
			yOffset += widget.getRelativeY();
        	widget = widget.getParent();
		}

		Rectangle bankItemArea = new Rectangle(canvasLocation.getX() + 51 - 6, yOffset, bankItemContainer.getWidth() - 51 + 6, bankItemContainer.getHeight());

        graphics.clip(bankItemArea);

		for (BankTagLayoutsPlugin.FakeItem fakeItem : plugin.fakeItems) {
			if (fakeItem.isLayoutPlaceholder() && !config.showLayoutPlaceholders()) continue;

			int dragDeltaX = 0;
			int dragDeltaY = 0;
			if (fakeItem.index == plugin.draggedItemIndex && plugin.antiDrag.mayDrag()) {
				dragDeltaX = client.getMouseCanvasPosition().getX() - plugin.dragStartX;
				dragDeltaY = client.getMouseCanvasPosition().getY() - plugin.dragStartY;
				dragDeltaY += bankItemContainer.getScrollY() - plugin.dragStartScroll;
			}
			int fakeItemId = fakeItem.getItemId();

			int x = BankTagLayoutsPlugin.getXForIndex(fakeItem.index) + canvasLocation.getX() + dragDeltaX;
			int y = BankTagLayoutsPlugin.getYForIndex(fakeItem.index) + yOffset - scrollY + dragDeltaY;
			if (y + BankTagLayoutsPlugin.BANK_ITEM_HEIGHT > bankItemArea.getMinY() && y < bankItemArea.getMaxY())
			{
				if (fakeItem.isLayoutPlaceholder())
				{
					graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.3f));
					BufferedImage image = itemManager.getImage(fakeItemId, 1000, false);
					graphics.drawImage(image, x, y, image.getWidth(), image.getHeight(), null);
					BufferedImage outline = itemManager.getItemOutline(fakeItemId, 1000, Color.GRAY);
					graphics.drawImage(outline, x, y, null);
				} else {
					if (fakeItem.quantity == 0) {
						// placeholder.
						graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));
					} else {
						graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));
					}
					boolean showQuantity = itemManager.getItemComposition(fakeItemId).isStackable() || fakeItem.quantity != 1;
					BufferedImage image = itemManager.getImage(fakeItemId, fakeItem.quantity, showQuantity);
					graphics.drawImage(image, x, y, image.getWidth(), image.getHeight(), null);
				}
			}
		}

        return null;
    }
}

package com.banktaglayouts;

import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.plugins.banktags.BankTagsPlugin;
import net.runelite.client.util.Text;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;

import static net.runelite.client.plugins.banktags.BankTagsPlugin.*;

/**
 * Class I made when I changed this plugin from using reflection to access private parts of Bank Tags.
 */
public class UsedToBeReflection {

    static final String ITEM_KEY_PREFIX = "item_";

    @Inject private Client client;
	@Inject private ConfigManager configManager;
	@Inject private ItemManager itemManager;

	String getIcon(final String tag)
	{
		return configManager.getConfiguration(CONFIG_GROUP, TAG_ICON_PREFIX + Text.standardize(tag));
	}

	void setIcon(final String tag, final String icon)
    {
        configManager.setConfiguration(CONFIG_GROUP, TAG_ICON_PREFIX + Text.standardize(tag), icon);
    }

    boolean findTag(int itemId, String bankTagName) {
        Collection<String> tags = getTags(itemId, false);
        tags.addAll(getTags(itemId, true));
        return tags.stream().anyMatch(tag -> tag.startsWith(Text.standardize(bankTagName)));
    }

    Collection<String> getTags(int itemId, boolean variation)
    {
        return new LinkedHashSet<>(Text.fromCSV(getTagString(itemId, variation).toLowerCase()));
    }

    String getTagString(int itemId, boolean variation)
    {
        itemId = getItemId(itemId, variation);

        String config = configManager.getConfiguration(CONFIG_GROUP, ITEM_KEY_PREFIX + itemId);
        if (config == null)
        {
            return "";
        }

        return config;
    }

    private int getItemId(int itemId, boolean variation)
    {
        itemId = Math.abs(itemId);
        itemId = itemManager.canonicalize(itemId);

        if (variation)
        {
            itemId = ItemVariationMapping.map(itemId) * -1;
        }

        return itemId;
    }

    public void saveNewTab(String newTabName) {
		String configuration = configManager.getConfiguration(CONFIG_GROUP, TAG_TABS_CONFIG);
		if (configuration == null) configuration = "";
		List<String> tabs = new ArrayList<>(Text.fromCSV(configuration));
        tabs.add(newTabName);
        String tags = Text.toCSV(tabs);
        configManager.setConfiguration(BankTagsPlugin.CONFIG_GROUP, TAG_TABS_CONFIG, tags);
    }

    public void loadTab(String name) {
		Widget w = client.getWidget(ComponentID.BANK_CONTAINER);
		if (w == null) return;

		ScriptEvent scriptEvent = client.createScriptEvent(w.getOnLoadListener()).setSource(w);
		configManager.setConfiguration(BankTagsPlugin.CONFIG_GROUP, "useTabs", false);
		scriptEvent.run();
		configManager.setConfiguration(BankTagsPlugin.CONFIG_GROUP, "useTabs", true);
		scriptEvent.run();
    }

    public void openTag(String tag) {
    }

    public void scrollTab(int i) {
    }
}

package com.banktaglayouts;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("banktaglayouts")
public interface BankTagLayoutsConfig extends Config {
    @ConfigItem(
            keyName = "layoutEnabledByDefault",
            name = "Enable layout by default",
            description = "When opening a tag tab without layout enabled, automatically enable layout on the tab.",
            position = 1
    )
    default boolean layoutEnabledByDefault() {
        return false;
    }

    @ConfigItem(
            keyName = "showLayoutPlaceholders",
            name = "Show Layout Placeholders",
            description = "Show the location of items that are in the layout and in the tag, but not in your bank.",
            position = 2
    )
    default boolean showLayoutPlaceholders()
    {
        return true;
    }

    @ConfigItem(
            keyName = "warnForAccidentalBankReorder",
            name = "Bank reorder warning",
            description = "Warns you know when you reorder items in your actual bank and not in a layout.",
            position = 3
    )
    default boolean warnForAccidentalBankReorder() {
        return true;
    }

    @ConfigItem(
            keyName = "tutorialMessage",
            name = "Layout enable tutorial message",
            description = "Lets you know how to enable layouts if you drag an item in a tag tab without layout enabled, and do not currently have any layout-ed bank tag tabs.",
            position = 4
    )
    default boolean tutorialMessage() {
        return true;
    }

	@ConfigItem(
		keyName = "useWithInventorySetups",
		name = "Use with Inventory Setups",
		description = "Allows laying out of filters applied by the Inventory Setups plugin.",
		position = 6,
		hidden = true
	)
	default boolean useWithInventorySetups() {
		return false;
	}

	@ConfigItem(
		keyName = "shiftModifierForExtraBankItemOptions",
		name = "Require Shift key for extra bank item options",
		description = "When enabled, the menu entries for adding duplicate items aren't shown unless shift is held when right-clicking",
		position = 7
	)
	default boolean shiftModifierForExtraBankItemOptions() {
		return false;
	}

	@ConfigItem(
		keyName = "preventVanillaPlaceholderMenuBug",
		name = "Prevent placeholder menu bug",
		description = "Prevents bug in the vanilla client that can prevent item withdrawal and inadvertent placeholder removal. See https://github.com/geheur/bank-tag-custom-layouts/issues/33 for more info.",
		position = 11
	)
	default boolean preventVanillaPlaceholderMenuBug() { return true; }

	@ConfigItem(
		keyName = "updateMessages",
		name = "Plugin update message",
		description = "Show a message about new features when the plugin updates.",
		position = 12
	)
	default boolean updateMessages() { return true; }

	@ConfigSection(
		name = "Auto-layout",
		description = "Auto-layout lays out your tab automatically using items from your equipment and inventory.",
		position = 100
	)
	String autoLayout = "autoLayout";

	enum LayoutStyles {
		ZIGZAG,
		PRESETS,
	}

	@ConfigItem(
            keyName = "autoLayoutStyle",
            name = "Auto-layout style",
            description = "The method auto-layout will choose.",
            position = 1,
            section = autoLayout
    )
    default LayoutStyles autoLayoutStyle() { return LayoutStyles.ZIGZAG; }

    @ConfigItem(
            keyName = "autoLayoutDuplicatesEnabled",
            name = "ZigZag: Create duplicates",
            description = "Whether or not to create duplicates when there are multiple of the same item when using auto-layout.",
            position = 2,
            section = autoLayout
    )
    default boolean autoLayoutDuplicatesEnabled() {
        return true;
    }

    @ConfigItem(
            keyName = "autoLayoutDuplicateLimit",
            name = "ZigZag: Duplicate limit",
            description = "The maximum number of items in a row to create duplicates for with auto-layout. Set to 28 to create duplicates for every item. To disable duplicate creation, toggle the \"Auto-layout: Create duplicates\" option off.",
            position = 3,
            section = autoLayout
    )
    default int autoLayoutDuplicateLimit() {
        return 4;
    }

	@ConfigItem(
		keyName = "autoLayoutIncludeRunePouchRunes",
		name = "Include Rune Pouch Runes",
		description = "Include the runes in the rune pouch when making the layout. In bank tag tabs, the runes will not be added to the tag, while in Inventory Setups they will just not be positioned.",
		position = 4,
		section = autoLayout
	)
	default boolean autoLayoutIncludeRunePouchRunes() {
		return true;
	}

	@ConfigItem(
		keyName = "showAutoLayoutButton",
		name = "Auto Layout button",
		description = "Disabling this hides the auto layout button and adds auto layout to the menu where you import tags.",
		position = 5,
		section = autoLayout
	)
	default boolean showAutoLayoutButton() {
		return true;
	}

	@ConfigItem(
		keyName = "showCoreRuneliteLayoutOptions",
		name = "RuneLite layouts options",
		description = "Shows RuneLite's layout options at the same time as bank tag layouts, e.g. on the tag tab right-click menu.",
		position = 20
	)
	default boolean showCoreRuneliteLayoutOptions() {
		return false;
	}
}

package com.banktaglayouts;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.game.SpriteOverride;

@RequiredArgsConstructor
public enum Sprites implements SpriteOverride
{
    APPLY_PREVIEW(-3192, "confirm_icon.png"), // 3192 is definitely not my bank pin.
    CANCEL_PREVIEW(-3193, "delete.png"),
    AUTO_LAYOUT(-3194, "auto_layout.png"),
    ;

    @Getter
    private final int spriteId;

    @Getter
    private final String fileName;
}

package com.banktaglayouts;

class VersionNumber implements Comparable<Object>
{

	final int n1;
	final int n2;
	final int n3;

	public VersionNumber(String versionString)
	{
		if (versionString == null || versionString.isEmpty())
		{
			this.n1 = 0;
			this.n2 = 0;
			this.n3 = 0;
		}
		else
		{
			String[] split = versionString.split("\\.");
			this.n1 = Integer.parseInt(split[0]);
			this.n2 = Integer.parseInt(split[1]);
			this.n3 = Integer.parseInt(split[2]);
		}
	}

	public VersionNumber(int n1, int n2, int n3)
	{
		this.n1 = n1;
		this.n2 = n2;
		this.n3 = n3;
	}

	@Override
	public int compareTo(Object obj)
	{
		VersionNumber o = (VersionNumber) obj;
		if (this.n1 > o.n1)
		{
			return 1;
		}
		if (this.n1 < o.n1)
		{
			return -1;
		}
		if (this.n2 > o.n2)
		{
			return 1;
		}
		if (this.n2 < o.n2)
		{
			return -1;
		}
		if (this.n3 > o.n3)
		{
			return 1;
		}
		if (this.n3 < o.n3)
		{
			return -1;
		}
		return 0;
	}

	@Override
	public String toString() {
		return n1 + "." + n2 + "." + n3;
	}

}

package com.banktaglayouts;

import java.util.*;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.function.Predicate;
import java.util.stream.Collectors;

import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemVariationMapping;

@Slf4j
@RequiredArgsConstructor
public class LayoutGenerator {
	private final BankTagLayoutsPlugin plugin;

	public Layout basicBankTagLayout(List<Integer> equippedItems, List<Integer> inventory, List<Integer> runePouch, List<Integer> additionalItems, Layout currentLayout, int duplicateLimit, BankTagLayoutsConfig.LayoutStyles layoutStyle) {
		return generateLayout(equippedItems, inventory, runePouch, additionalItems, currentLayout, duplicateLimit, layoutStyle);
	}

	public Layout generateLayout(List<Integer> equippedItems, List<Integer> inventory, List<Integer> runePouch, List<Integer> additionalItems, Layout currentLayout, int duplicateLimit, BankTagLayoutsConfig.LayoutStyles layoutStyle) {
		if (!hasRunePouch(inventory)) {
			runePouch = null;
		}
		equippedItems = equippedItems.stream()
			.map(itemId -> plugin.itemManager.canonicalize(itemId)) // Weight reducing items have different ids when equipped; this fixes that.
			.collect(Collectors.toList());

		switch (layoutStyle){
			case ZIGZAG:
				return zigzagLayout(equippedItems, inventory, runePouch, additionalItems, currentLayout, duplicateLimit);
			case PRESETS:
				return presetsLayout(equippedItems, inventory, runePouch, additionalItems, currentLayout);
			default:
				throw new IllegalArgumentException("Please supply a layout style to this method.");
		}
	}

	private boolean hasRunePouch(List<Integer> inventory)
	{
		Collection<Integer> runePouchVariations = ItemVariationMapping.getVariations(ItemID.RUNE_POUCH);
		Collection<Integer> divineRunePouchVariations = ItemVariationMapping.getVariations(ItemID.DIVINE_RUNE_POUCH);
		return inventory.stream().filter(itemId -> runePouchVariations.contains(itemId) || divineRunePouchVariations.contains(itemId)).findAny().isPresent();
	}

	public Layout presetsLayout(List<Integer> equippedItems, List<Integer> inventory, List<Integer> runePouch, List<Integer> additionalItems, Layout currentLayout) {
		Layout previewLayout = Layout.emptyLayout();

		// lay out equipped items.
		// if the player hasn't equipped anything since launching the game this array will not come back with the expected -1 values. so we will just add them in ourselves.
		while (equippedItems.size() < 14) {
			equippedItems.add(-1);
		}
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.HEAD.getSlotIdx()), 1);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.CAPE.getSlotIdx()), 8);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.AMULET.getSlotIdx()), 9);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.WEAPON.getSlotIdx()), 16);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.BODY.getSlotIdx()), 17);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.SHIELD.getSlotIdx()), 18);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.AMMO.getSlotIdx()), 10);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.LEGS.getSlotIdx()), 25);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.GLOVES.getSlotIdx()), 32);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.BOOTS.getSlotIdx()), 33);
		previewLayout.putItem(equippedItems.get(EquipmentInventorySlot.RING.getSlotIdx()), 34);


		int invRow = 0;
		int invCol = 4;
		int width = 8;
		for(Integer i: inventory) {
			previewLayout.putItem(i, invCol + (invRow * width));
			if (invCol == 7) {
				invCol = 4;
				invRow++;
			} else {
				invCol++;
			}
		}
		boolean hasPouch = runePouch != null;
		if (hasPouch) {
			int c = 0;
			for (Integer r : runePouch) {
				previewLayout.putItem(r, c + 40);
				c++;
			}
		}

		// If the item is in a safe spot copy it over from the old layout
		for (Map.Entry<Integer, Integer> e: currentLayout.allPairs()) {
			if (indexInAllowedSpace(inventory, e.getKey())) {
				previewLayout.putItem(e.getValue(), e.getKey());
			}
		}
		// If the item is in an invalid spot move it to a valid spot in the sandbox area
		for (Map.Entry<Integer, Integer> e: currentLayout.allPairs()) {
			if (!indexInAllowedSpace(inventory, e.getKey())) {
				if (inventory.contains(e.getValue()) || equippedItems.contains(e.getValue()) || (hasPouch && runePouch.contains(e.getValue()))) {
					continue;
				}
				int index = 0;
				while (!indexInAllowedSpace(inventory, index) || (previewLayout.getItemAtIndex(index) != -1)) {
					index++;
				}

                if (!layoutContainsItem(e.getValue(), previewLayout)) {
					previewLayout.putItem(e.getValue(), index);
				}
			}
		}

		// Add additional items
		for (Integer i: additionalItems) {
			if (previewLayout.countItemsWithId(i) > 0) {
				continue;
			}
			int index = 0;
			while (!indexInAllowedSpace(inventory, index) || (previewLayout.getItemAtIndex(index) > 0)) {
				index++;
			}
			previewLayout.putItem(i, index);
		}

		return previewLayout;
	}

	private boolean indexInAllowedSpace(List<Integer> inventory, int index) {
		int inventoryHeight = 0;
		int c = 1;
		for (Integer i : inventory) {
			if (i > 0) {
				inventoryHeight = (int) (Math.ceil(c / 4.0));
			}
			c++;
		}
		// 1 means the inventory spaces are occupied
		int[][] mask = {
				{1, 1, 1, 1, 1, 1, 1, 1},
				{1, 1, 1, 1, 1, 1, 1, 1},
				{1, 1, 1, 1, 1, 1, 1, 1},
				{1, 1, 1, 1, 1, 1, 1, 1},
				{1, 1, 1, 1, 1, 1, 1, 1},
				{1, 1, 1, 1, 1, 1, 1, 1},
				{0, 0, 0, 0, 1, 1, 1, 1},
		};
		for (int x = 0; x < inventoryHeight; x++) {
			if (x == 6) {
				mask[x] = new int[]{0, 0, 0, 0, 1, 1, 1, 1};
			} else {
				mask[x] = new int[]{1, 1, 1, 1, 1, 1, 1, 1};
			}
		}
		int[] flatMask = Arrays.stream(mask).flatMapToInt(Arrays::stream).toArray();
		return index >= 56 || flatMask[index] == 0;
	}

	public Layout zigzagLayout(List<Integer> equippedItems, List<Integer> inventory, List<Integer> runePouch, List<Integer> additionalItems, Layout currentLayout, int duplicateLimit) {
		Layout previewLayout = Layout.emptyLayout();
		List<Integer> displacedItems = new ArrayList<>();

		log.debug("generate layout");
		log.debug("equipped gear is " + equippedItems);
		log.debug("inventory is " + inventory);

		int i = 0;

		// lay out equipped items.
		i = layoutItems(equippedItems, currentLayout, previewLayout, displacedItems, i, true);

		inventory = inventory.stream().filter(integer -> integer != -1).collect(Collectors.toList());

		// lay out the inventory items.
		if (duplicateLimit <= 0)
		{
			// distinct leaves the first duplicate it encounters and removes only duplicates coming after the first.
			inventory = inventory.stream().distinct().collect(Collectors.toList());
		}
		else
		{
			inventory = limitDuplicates(inventory, duplicateLimit);
		}

		i = layoutItems(inventory, currentLayout, previewLayout, displacedItems, i, true);

		if (runePouch != null)
		{
			i = layoutItems(runePouch, currentLayout, previewLayout, displacedItems, i, false);
		}

		i = layoutItems(additionalItems, currentLayout, previewLayout, displacedItems, i, false);

		int displacedItemsStart = i;

		// copy items from current layout into the empty spots.
		for (Map.Entry<Integer, Integer> itemPosition : currentLayout.allPairs()) {
			int index = itemPosition.getKey();
			int currentItemAtIndex = itemPosition.getValue();
			int previewItemAtIndex = previewLayout.getItemAtIndex(index);

			if (currentItemAtIndex != -1 && previewItemAtIndex == -1) {
				previewLayout.putItem(currentItemAtIndex, index);
			}
		}

		// Remove items that were placed as part of the gear or inventory.
		displacedItems = displacedItems.stream().filter(id -> !layoutContainsItem(id, previewLayout)).collect(Collectors.toList());

		int j = displacedItemsStart;
		while (displacedItems.size() > 0 && j < 2000 / 38 * 8) {
			int currentItemAtIndex = currentLayout.getItemAtIndex(j);
			if (currentItemAtIndex == -1) {
				Integer itemId = displacedItems.remove(0);
				previewLayout.putItem(itemId, j);
			}

			j++;
		}

		return previewLayout;
	}

	private List<Integer> limitDuplicates(List<Integer> inventory, int duplicateLimit)
	{
		List<Map.Entry<Integer, Integer>> groupedInventory = new ArrayList<>();

		int inARow = 0;
		int lastItemId = -1;
		for (Integer itemId : inventory)
		{
			if (lastItemId != itemId)
			{
				int quantity = inARow > duplicateLimit ? 1 : inARow;
				groupedInventory.add(new AbstractMap.SimpleEntry<>(lastItemId, quantity));
				inARow = 0;
			}
			inARow++;

			lastItemId = itemId;
		}
		int quantity = inARow > duplicateLimit ? 1 : inARow;
		if (quantity > 0) groupedInventory.add(new AbstractMap.SimpleEntry<>(lastItemId, quantity));

		inventory = groupedInventory.stream().flatMap(entry -> Collections.nCopies(entry.getValue(), entry.getKey()).stream()).collect(Collectors.toList());
		return inventory;
	}

	private int layoutItems(List<Integer> inventory, Layout currentLayout, Layout previewLayout, List<Integer> displacedItems, int i, boolean useZigZag) {
		for (Integer itemId : inventory) {
			if (itemId == -1) continue;
			int index = useZigZag ? toZigZagIndex(i, 0, 0) : i;
			previewLayout.putItem(itemId, index);
			int currentLayoutItem = currentLayout.getItemAtIndex(index);
			if (currentLayoutItem != -1) displacedItems.add(currentLayoutItem);
			i++;
		}
		if (!inventory.isEmpty()) {
			Optional<Integer> highestUsedIndex = previewLayout.getAllUsedIndexes().stream().max(Integer::compare);
			if (highestUsedIndex.isPresent()) {
				if (useZigZag) {
					i = (highestUsedIndex.get() / 16 * 2 + 2) * 8;
				} else {
					i = (highestUsedIndex.get() / 8 + 1) * 8;
				}
			}
		}
		return i;
	}

	private boolean layoutContainsItem(int id, Layout previewLayout) {
		int baseId = ItemVariationMapping.map(plugin.getNonPlaceholderId(id));
		for (Integer item : previewLayout.getAllUsedItemIds()) {
			if (baseId == ItemVariationMapping.map(plugin.getNonPlaceholderId(item))) {
				return true;
			}
		}
		return false;
	}

	private static int toZigZagIndex(int inventoryIndex, int row, int col) {
		if (inventoryIndex < 0 || row < 0 || col < 0) throw new IllegalArgumentException();

		row += (inventoryIndex / 16) * 2; // Does this cover multiple pairs of rows?
		inventoryIndex -= (inventoryIndex / 16) * 16;
		int index = 0;
		index += inventoryIndex % 2 == 0 ? 0 : 8; // top or bottom row?
		index += inventoryIndex / 2; // column.
		index += row * 8 + col; // offset.
		return index;
	}
}

package com.banktaglayouts;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.bank.BankSearch;
import net.runelite.client.plugins.banktags.TagManager;
import net.runelite.client.plugins.banktags.tabs.TabInterface;
import net.runelite.client.ui.overlay.OverlayManager;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.anyInt;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;
import org.slf4j.LoggerFactory;

@RunWith(MockitoJUnitRunner.class)
public class BankLayoutTest
{
    @Mock
    @Bind
    private Client client;

    @Mock
    @Bind
    private ConfigManager configManager;

    @Mock
    @Bind
    private ItemManager itemManager;

    @Mock
    @Bind
    private OverlayManager overlayManager;

    @Mock
    @Bind
    private BankTagLayoutsConfig config;

    @Mock
    @Bind
    private FakeItemOverlay fakeItemOverlay;

    @Mock
    @Bind
    private MouseManager mouseManager;

    @Mock
    @Bind
    private KeyManager keyManager;

    @Mock
    @Bind
    private SpriteManager spriteManager;

    @Mock
    @Bind
    private ClientThread clientThread;

    @Mock
    @Bind
    private TabInterface tabInterface;

    @Mock
    @Bind
    private TagManager tagManager;

    @Mock
    @Bind
    private BankSearch bankSearch;

    @Mock
    @Bind
    private ChatboxPanelManager chatboxPanelManager;

    // TODO uncomment when Adam's spritemanager fix is available.
    @Mock
    @Bind
    private RuneLiteConfig runeliteConfig;

    @Inject
    private BankTagLayoutsPlugin plugin;

    // TODO import/export tests.

    @Before
    public void before()
    {
        final Logger logger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
        logger.setLevel(Level.DEBUG);
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
        plugin = Mockito.spy(plugin);
		Mockito.when(itemManager.canonicalize(anyInt())).thenAnswer(invocation -> {
			ItemComposition itemComposition = generateItemComposition(invocation.getArgument(0));
			return itemComposition.getPlaceholderTemplateId() != -1 ?
				itemComposition.getPlaceholderId() :
				itemComposition.getId();
		});
		Mockito.when(itemManager.getItemComposition(anyInt())).thenAnswer(invocation -> generateItemComposition(invocation.getArgument(0)));
    }

    Layout currentLayout;

    private static final Map<Integer, Item> itemsById = new HashMap<>();

    private static final Item MAGIC_LOGS = new Item("Magic logs", 1513, 13982, -1);
    private static final Item MAGIC_LOGS_PH = new Item("Magic logs ph", 13982, 1513, -1, true);

	private static final Item RUNE_PLATEBODY = new Item("rune platebody", 1127, 14106, -1);
	private static final Item RUNE_PLATEBODY_PH = new Item("rune platebody ph", 14106, 1127, -1);

	private static final Item GAMES_NECKLACE_1_PH = new Item("Games necklace (1) ph", 21460, 3867, 3867, true);
    private static final Item GAMES_NECKLACE_8_PH = new Item("Games necklace (8) ph", 16362, 3852, 3867, true);
    private static final Item GAMES_NECKLACE_8 = new Item("Games necklace (8)", 3867, 16362, 3867);
    private static final Item GAMES_NECKLACE_7 = new Item("Games necklace (7)", 3865, -1, 3867);
    private static final Item GAMES_NECKLACE_6 = new Item("Games necklace (6)", 3863, -1, 3867);
    private static final Item GAMES_NECKLACE_5 = new Item("Games necklace (5)", 3861, -1, 3867);
    private static final Item GAMES_NECKLACE_4 = new Item("Games necklace (4)", 3859, -1, 3867);
    private static final Item GAMES_NECKLACE_3 = new Item("Games necklace (3)", 3857, -1, 3867);
    private static final Item GAMES_NECKLACE_2 = new Item("Games necklace (2)", 3855, -1, 3867);
    private static final Item GAMES_NECKLACE_1 = new Item("Games necklace (1)", 3853, 21460, 3867);

    private static final Item STRANGE_LOCKPICK_FULL = new Item("Strange lockpick (full)", 24740, 24742, 24738);
    private static final Item STRANGE_LOCKPICK_FULL_PH = new Item("Strange lockpick (full) ph", 24742, 24740, 24738, true);
    private static final Item STRANGE_LOCKPICK_USED = new Item("Strange lockpick (used)", 24738, 24739, 24738);
    private static final Item STRANGE_LOCKPICK_USED_PH = new Item("Strange lockpick (used) ph", 24739, 24738, 24738, true);

    /*
    Things to test both variant and non-variant.
        Moving (including updating the duplicates).
        Adding new item.
        Duplicating (including updating the duplicates with the currently present item).
        Removing duplicates.
    variant items only:
     */

    @Test
    public void testAddNewItemVariant() {
        currentLayout = generateLayout(
        );
        List<Widget> bankItems = Arrays.asList(
                createBankItemWidget(GAMES_NECKLACE_8)
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                0, BankSlot.realItem(GAMES_NECKLACE_8)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    @Test
    public void testAddNewItemNonVariant() {
        currentLayout = generateLayout(
        );
        List<Widget> bankItems = Arrays.asList(
                createBankItemWidget(MAGIC_LOGS)
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                0, BankSlot.realItem(MAGIC_LOGS)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    @Test
    public void testMoveItems() {
        List<Item> layoutItems = Arrays.asList(GAMES_NECKLACE_8, GAMES_NECKLACE_8_PH, MAGIC_LOGS);
        List<Item> realItems = Arrays.asList(GAMES_NECKLACE_8, GAMES_NECKLACE_8_PH, MAGIC_LOGS);
		List<BankSlot.Type> targetTypes = Arrays.asList(BankSlot.Type.DUPLICATE_ITEM, BankSlot.Type.LAYOUT_PLACEHOLDER, BankSlot.Type.REAL_ITEM, null);
		for (Item targetLayoutItem : realItems)
		{
			for (BankSlot.Type targetType : targetTypes)
			{
				for (int i = 0; i < layoutItems.size(); i++)
				{
					Item layoutItem = layoutItems.get(i);
					Item realItem = realItems.get(i);
					if (targetLayoutItem.equals(layoutItem) || targetLayoutItem.equals(realItem)) continue;
					testMoveItem(layoutItem, layoutItem, targetLayoutItem, targetType);
					testMoveItem(layoutItem, realItem, targetLayoutItem, targetType);
					testMoveItem(layoutItem, layoutItem, targetLayoutItem, targetType);
					testMoveItem(layoutItem, realItem, targetLayoutItem, targetType);
				}
			}
		}
	}

    /*
    targetItem only matters if targetType is real or layout placeholder.

    BankSlot.Type is misused here as an argument.
    null means swap with empty spot
    duplicate means swap with the item's own duplicate
    layout placeholder means swap with a layout placeholder.
    real means swap with a different real item.
     */
    private void testMoveItem(Item layoutItem, Item realItem, Item targetLayoutItem, BankSlot.Type targetType)
    {
    	System.out.println("testMoveItem " + targetType + ": " + layoutItem + " (" + realItem + "), " + targetLayoutItem);
        /*
        indexes:
        1 - moved item
        2 - location of empty slot to move to
        4 - dupe of 1
        6 - location of other item to move to
        7 - dupe of 6
         */
        boolean isLayoutPlaceholder = realItem == null;
        int targetIndex = targetType == null ? 2 : targetType == BankSlot.Type.DUPLICATE_ITEM ? 4 : 6;

        currentLayout = generateLayout(
                new LayoutItem(layoutItem, 1),
                new LayoutItem(layoutItem, 4),
                new LayoutItem(targetLayoutItem, 6),
                new LayoutItem(targetLayoutItem, 7)
        );
        List<Widget> bankItems = new ArrayList<>();
        if (!isLayoutPlaceholder)
        {
            bankItems.add(createBankItemWidget(realItem));
        }
        if (targetType != BankSlot.Type.LAYOUT_PLACEHOLDER)
        {
            bankItems.add(createBankItemWidget(targetLayoutItem));
        }

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                1, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.realItem(realItem),
                4, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.duplicateItem(realItem),
                6, targetType == BankSlot.Type.LAYOUT_PLACEHOLDER ? BankSlot.layoutPlaceholder(targetLayoutItem) : BankSlot.realItem(targetLayoutItem),
                7, targetType == BankSlot.Type.LAYOUT_PLACEHOLDER ? BankSlot.layoutPlaceholder(targetLayoutItem) : BankSlot.duplicateItem(targetLayoutItem)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);

        currentLayout.moveItem(1, targetIndex, realItem != null ? realItem.id : layoutItem.id);

        laidOutBank = layOutBank(currentLayout, bankItems);
        expectedLaidOutBank = createLaidOutBank();
        if (targetType == null) {
			expectedLaidOutBank.add(2, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.realItem(realItem));
			expectedLaidOutBank.add(4, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.duplicateItem(realItem));
			expectedLaidOutBank.add(6, BankSlot.realItem(targetLayoutItem));
			expectedLaidOutBank.add(7, BankSlot.duplicateItem(targetLayoutItem));
			if (realItem != null)
			{
				checkCurrentLayout(2, realItem);
				checkCurrentLayout(4, realItem);
			}
		} else if (targetType == BankSlot.Type.DUPLICATE_ITEM) {
			expectedLaidOutBank.add(1, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.realItem(realItem));
			expectedLaidOutBank.add(4, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.duplicateItem(realItem));
			expectedLaidOutBank.add(6, BankSlot.realItem(targetLayoutItem));
			expectedLaidOutBank.add(7, BankSlot.duplicateItem(targetLayoutItem));
			if (realItem != null)
			{
				checkCurrentLayout(1, realItem);
				checkCurrentLayout(4, realItem);
			}
		} else if (targetType == BankSlot.Type.LAYOUT_PLACEHOLDER) {
			expectedLaidOutBank.add(4, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.realItem(realItem));
			expectedLaidOutBank.add(6, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.duplicateItem(realItem));
			expectedLaidOutBank.add(1, BankSlot.layoutPlaceholder(targetLayoutItem));
			expectedLaidOutBank.add(7, BankSlot.layoutPlaceholder(targetLayoutItem));
			if (realItem != null)
			{
				checkCurrentLayout(6, realItem);
				checkCurrentLayout(4, realItem);
			}
		} else if (targetType == BankSlot.Type.REAL_ITEM) {
			expectedLaidOutBank.add(4, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.realItem(realItem));
			expectedLaidOutBank.add(6, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(layoutItem) : BankSlot.duplicateItem(realItem));
			expectedLaidOutBank.add(1, BankSlot.realItem(targetLayoutItem));
			expectedLaidOutBank.add(7, BankSlot.duplicateItem(targetLayoutItem));
			if (realItem != null)
			{
				checkCurrentLayout(6, realItem);
				checkCurrentLayout(4, realItem);
			}
		}
		System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    @Test
    public void testDuplicateItems()
	{
		List<Item> layoutItems = Arrays.asList(GAMES_NECKLACE_8, GAMES_NECKLACE_8_PH, MAGIC_LOGS);
		List<Item> realItems = Arrays.asList(GAMES_NECKLACE_8, GAMES_NECKLACE_8_PH, MAGIC_LOGS);
		for (Item targetLayoutItem : realItems)
		{
			for (int i = 0; i < layoutItems.size(); i++)
			{
				Item layoutItem = layoutItems.get(i);
				Item realItem = realItems.get(i);
				if (targetLayoutItem.equals(layoutItem) || targetLayoutItem.equals(realItem)) continue;
				testDuplicateItem(layoutItem, layoutItem);
				testDuplicateItem(layoutItem, realItem);
				testDuplicateItem(layoutItem, layoutItem);
				testDuplicateItem(layoutItem, realItem);
			}
		}
	}

	private void testDuplicateItem(Item layoutItem, Item realItem)
	{
		boolean isLayoutPlaceholder = realItem == null;
		if (realItem == null) realItem = layoutItem;
		currentLayout = generateLayout(
			new LayoutItem(layoutItem, 1),
			new LayoutItem(layoutItem, 2)
		);
		List<Widget> bankItems = isLayoutPlaceholder
			? Collections.emptyList()
			: Arrays.asList(createBankItemWidget(realItem));

		LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
		LaidOutBank expectedLaidOutBank = createLaidOutBank(
			1, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.realItem(realItem),
			2, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.duplicateItem(realItem)
		);
		System.out.println("real bank: " + laidOutBank);
		System.out.println("expected bank: " + expectedLaidOutBank);
		assertEquals(expectedLaidOutBank, laidOutBank);

		currentLayout.duplicateItem(1, isLayoutPlaceholder ? -1 : realItem.id);

		laidOutBank = layOutBank(currentLayout, bankItems);
		expectedLaidOutBank = createLaidOutBank(
			1, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.realItem(realItem),
			2, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.duplicateItem(realItem),
			3, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.duplicateItem(realItem)
		);
		assertEquals(expectedLaidOutBank, laidOutBank);

		checkCurrentLayout(1, realItem);
		checkCurrentLayout(2, realItem);
		checkCurrentLayout(3, realItem);
	}

	@Test
	public void testRemoveDuplicateItems()
	{
		List<Item> layoutItems = Arrays.asList(GAMES_NECKLACE_8, GAMES_NECKLACE_8_PH, MAGIC_LOGS);
		List<Item> realItems = Arrays.asList(GAMES_NECKLACE_8, GAMES_NECKLACE_8_PH, MAGIC_LOGS);
		for (Item targetLayoutItem : realItems)
		{
			for (int i = 0; i < layoutItems.size(); i++)
			{
				Item layoutItem = layoutItems.get(i);
				Item realItem = realItems.get(i);
				if (targetLayoutItem.equals(layoutItem) || targetLayoutItem.equals(realItem)) continue;
				testRemoveDuplicateItem(layoutItem, layoutItem);
				testRemoveDuplicateItem(layoutItem, realItem);
				testRemoveDuplicateItem(layoutItem, layoutItem);
				testRemoveDuplicateItem(layoutItem, realItem);
			}
		}
	}

	private void testRemoveDuplicateItem(Item layoutItem, Item realItem)
	{
		boolean isLayoutPlaceholder = realItem == null;
		if (realItem == null) realItem = layoutItem;
		currentLayout = generateLayout(
			new LayoutItem(layoutItem, 1),
			new LayoutItem(layoutItem, 2),
			new LayoutItem(layoutItem, 3)
		);
		List<Widget> bankItems = isLayoutPlaceholder
			? Collections.emptyList()
			: Arrays.asList(createBankItemWidget(realItem));

		LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
		LaidOutBank expectedLaidOutBank = createLaidOutBank(
			1, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.realItem(realItem),
			2, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.duplicateItem(realItem),
			3, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.duplicateItem(realItem)
		);
		System.out.println("real bank: " + laidOutBank);
		System.out.println("expected bank: " + expectedLaidOutBank);
		assertEquals(expectedLaidOutBank, laidOutBank);

		currentLayout.clearIndex(2);

		laidOutBank = layOutBank(currentLayout, bankItems);
		expectedLaidOutBank = createLaidOutBank(
			1, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.realItem(realItem),
//			2, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.duplicateItem(realItem),
			3, isLayoutPlaceholder ? BankSlot.layoutPlaceholder(realItem) : BankSlot.duplicateItem(realItem)
		);
		System.out.println("real bank: " + laidOutBank);
		System.out.println("expected bank: " + expectedLaidOutBank);
		assertEquals(expectedLaidOutBank, laidOutBank);

		checkCurrentLayout(1, realItem);
//		checkLayout(2, realItem);
		checkCurrentLayout(3, realItem);
	}

    @Test
    public void testDuplicatingLayoutPlaceholder() {
        currentLayout = generateLayout(
                new LayoutItem(GAMES_NECKLACE_5, 4)
        );
        List<Widget> bankItems = Arrays.asList(
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                4, BankSlot.layoutPlaceholder(GAMES_NECKLACE_5)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);

        System.out.println("layout before: " + currentLayout);
        currentLayout.duplicateItem(4, -1);
        System.out.println("layout after: " + currentLayout);

        laidOutBank = layOutBank(currentLayout, bankItems);
        expectedLaidOutBank = createLaidOutBank(
                4, BankSlot.layoutPlaceholder(GAMES_NECKLACE_5),
                5, BankSlot.layoutPlaceholder(GAMES_NECKLACE_5)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    @Test
    public void testThatItemsThatShowUpMoreThanOnceInTheBankDoNotTakeUpPlaceholderSlots() {
        currentLayout = generateLayout(
                new LayoutItem(STRANGE_LOCKPICK_USED, 4),
                new LayoutItem(STRANGE_LOCKPICK_USED_PH, 7)
        );
        List<Widget> bankItems = Arrays.asList(
                createBankItemWidget(STRANGE_LOCKPICK_USED),
                createBankItemWidget(STRANGE_LOCKPICK_USED)
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                4, BankSlot.realItem(STRANGE_LOCKPICK_USED),
                7, BankSlot.layoutPlaceholder(STRANGE_LOCKPICK_USED_PH)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    @Test
    public void testThatItemsThatShowUpInMultipleRealBankSlotsOnlyAppearOnceInLaidOutBankTab() {
        currentLayout = generateLayout(
                new LayoutItem(STRANGE_LOCKPICK_USED, 4),
                new LayoutItem(STRANGE_LOCKPICK_FULL, 7)
        );
        List<Widget> bankItems = Arrays.asList(
                createBankItemWidget(STRANGE_LOCKPICK_USED),
                createBankItemWidget(STRANGE_LOCKPICK_FULL),
                createBankItemWidget(STRANGE_LOCKPICK_FULL),
                createBankItemWidget(STRANGE_LOCKPICK_USED)
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                4, BankSlot.realItem(STRANGE_LOCKPICK_USED),
                7, BankSlot.realItem(STRANGE_LOCKPICK_FULL)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    // If I move a games neck (5) that is at a layout spot that is something else like games neck (1), then all games
    // neck (1) parts of the layout should be updated to be games neck (5), but the item it's dragged on to should
    // continue to use the original id in the layout.
    @Test
    public void testMoveDuplicateItemUpdatesActualItemId() {
        currentLayout = generateLayout(
                new LayoutItem(GAMES_NECKLACE_5, 4),
                new LayoutItem(GAMES_NECKLACE_5, 5),

                new LayoutItem(GAMES_NECKLACE_1, 6),
                new LayoutItem(GAMES_NECKLACE_1, 7)
        );
        List<Widget> bankItems = Arrays.asList(
                createBankItemWidget(GAMES_NECKLACE_6),
                createBankItemWidget(GAMES_NECKLACE_2)
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                4, BankSlot.realItem(GAMES_NECKLACE_6),
                5, BankSlot.duplicateItem(GAMES_NECKLACE_6),

                6, BankSlot.realItem(GAMES_NECKLACE_2),
                7, BankSlot.duplicateItem(GAMES_NECKLACE_2)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);

        System.out.println("layout before: " + currentLayout);
        currentLayout.moveItem(4, 6, GAMES_NECKLACE_6.id);
        System.out.println("layout after: " + currentLayout);

        laidOutBank = layOutBank(currentLayout, bankItems);
        expectedLaidOutBank = createLaidOutBank(
                4, BankSlot.realItem(GAMES_NECKLACE_2),
                5, BankSlot.realItem(GAMES_NECKLACE_6),

                6, BankSlot.duplicateItem(GAMES_NECKLACE_6),
                7, BankSlot.duplicateItem(GAMES_NECKLACE_2)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);

        checkCurrentLayout(4, GAMES_NECKLACE_1);
        checkCurrentLayout(5, GAMES_NECKLACE_6);
        checkCurrentLayout(6, GAMES_NECKLACE_6);
        checkCurrentLayout(7, GAMES_NECKLACE_1);
    }

    // movement tests should always leave empty spots in the early slots of the bank, so that you don't get false
    // negatives from an item being moved to index 0.
    @Test
    public void testMoveVariantItemOntoLayoutPlaceholderOfSameBaseVariant() {
        currentLayout = generateLayout(
                new LayoutItem(GAMES_NECKLACE_5, 4),
                new LayoutItem(GAMES_NECKLACE_1, 5)
        );
        List<Widget> bankItems = Arrays.asList(
                createBankItemWidget(GAMES_NECKLACE_5)
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);
        LaidOutBank expectedLaidOutBank = createLaidOutBank(
                4, BankSlot.realItem(GAMES_NECKLACE_5),
                5, BankSlot.layoutPlaceholder(GAMES_NECKLACE_1.id)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);

        System.out.println("layout before: " + currentLayout);
        currentLayout.moveItem(4, 5, GAMES_NECKLACE_5.id);
        System.out.println("layout after: " + currentLayout);

        laidOutBank = layOutBank(currentLayout, bankItems);
        expectedLaidOutBank = createLaidOutBank(
                5, BankSlot.realItem(GAMES_NECKLACE_5),
                4, BankSlot.layoutPlaceholder(GAMES_NECKLACE_1.id)
        );
        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);
        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    @Test
    public void testLayout() {
        currentLayout = generateLayout(
                new LayoutItem(GAMES_NECKLACE_8, 1),
                new LayoutItem(GAMES_NECKLACE_1, 8),
                new LayoutItem(GAMES_NECKLACE_1_PH, 9)
        );
        List<Widget> bankItems = Arrays.asList(
                createBankItemWidget(GAMES_NECKLACE_8, 70),
                createBankItemWidget(GAMES_NECKLACE_1_PH)
        );

        LaidOutBank laidOutBank = layOutBank(currentLayout, bankItems);

        Map<Integer, BankSlot> expectedBank = new HashMap<>();
        expectedBank.put(1, BankSlot.realItem(GAMES_NECKLACE_8, 70));
        expectedBank.put(8, BankSlot.layoutPlaceholder(GAMES_NECKLACE_1.id));
        expectedBank.put(9, BankSlot.realItem(GAMES_NECKLACE_1_PH));
        LaidOutBank expectedLaidOutBank = new LaidOutBank(expectedBank);

        System.out.println("real bank: " + laidOutBank);
        System.out.println("expected bank: " + expectedLaidOutBank);

        assertEquals(expectedLaidOutBank, laidOutBank);
    }

    private LaidOutBank createLaidOutBank(Object... arr)
    {
        Map<Integer, BankSlot> map = new HashMap<>();
        assert arr.length % 2 == 0;
        for (int i = 0; i < arr.length; i += 2)
        {
            int index = (int) arr[i];
            BankSlot bankSlot = (BankSlot) arr[i + 1];
            map.put(index, bankSlot);
        }
        return new LaidOutBank(map);
    }

    public static class BankSlot {
        enum Type {
            REAL_ITEM, DUPLICATE_ITEM, LAYOUT_PLACEHOLDER
        }

        private final Type type;
        private final Widget widget;
        private final int id;
        private final int quantity;

        private BankSlot(Type type, int id, Widget widget, int quantity) {
            this.type = type;
            this.widget = widget;
            this.id = id;
            this.quantity = quantity;
        }

        public static BankSlot realItem(Item item) {
            int quantity = item.placeholder ? 0 : 1;
            return realItem(item, quantity);
        }

        public static BankSlot realItem(Item item, int quantity) {
            return new BankSlot(Type.REAL_ITEM, item.id, null, quantity);
        }

        public static BankSlot realItem(Widget widget) {
            return new BankSlot(Type.REAL_ITEM, widget.getItemId(), widget, widget.getItemQuantity());
        }

        // TODO what if I have a 1-dose ppot as a fake with duplicates - will a 4-dose fill all the spots of that?

        // TODO what if i create a duplicate when the wrong item is in a fake item? e.g. 1-dose ppot is in layout but there is a 4-dose appearing there, and I then duplicate that?

        public static BankSlot duplicateItem(int itemId, int quantity) {
            return new BankSlot(Type.DUPLICATE_ITEM, itemId, null, quantity);
        }

        public static BankSlot duplicateItem(Item item) {
            return duplicateItem(item, item.placeholder ? 0 : 1);
        }

        public static BankSlot duplicateItem(Item item, int quantity) {
            return new BankSlot(Type.DUPLICATE_ITEM, item.id, null, quantity);
        }

        public static BankSlot layoutPlaceholder(int itemId) {
            return new BankSlot(Type.LAYOUT_PLACEHOLDER, itemId, null, -1);
        }

        public static BankSlot layoutPlaceholder(Item item) {
            return new BankSlot(Type.LAYOUT_PLACEHOLDER, item.id, null, -1);
        }

        @Override
        public boolean equals(Object o)
        {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            BankSlot bankSlot = (BankSlot) o;
//            System.out.println(id + " " + bankSlot.id + " " + quantity + " " + bankSlot.quantity + " " + type + " " + bankSlot.type + " " );
            return id == bankSlot.id && quantity == bankSlot.quantity && type == bankSlot.type;
        }

        @Override
        public int hashCode()
        {
            return Objects.hash(type, widget, id, quantity);
        }

        @Override
        public String toString()
        {
            Item item = itemsById.get(id);
//            System.out.println("tostring: " + id + " " + item + " " + type);
            String typeString = type == Type.LAYOUT_PLACEHOLDER ? " lph" : type == Type.REAL_ITEM ? "" : " dup";
            return "{" +
                    item.name + typeString +
                    (type == Type.REAL_ITEM ? " (" + quantity + ")" : "") +
                    '}';
        }
    }

    private Widget createBankItemWidget(Item item)
    {
        return createBankItemWidget(item, item.placeholder ? 0 : 1);
    }

    private Widget createBankItemWidget(Item item, int quantity)
    {
        Widget widget = Mockito.mock(Widget.class);
        Mockito.when(widget.getItemId()).thenReturn(item.id);
        Mockito.when(widget.getItemQuantity()).thenReturn(quantity);
        return widget;
    }

    private LaidOutBank layOutBank(Layout layout, List<Widget> bankItems)
    {
        Map<Integer, BankSlot> laidOutBank = new HashMap<>();

        Map<Integer, Widget> indexToWidget = plugin.assignItemPositions(layout, bankItems);

        for (Map.Entry<Integer, Widget> entry : indexToWidget.entrySet())
        {
            assertFalse(laidOutBank.containsKey(entry.getKey()));
            laidOutBank.put(entry.getKey(), BankSlot.realItem(entry.getValue()));
        }

        Set<BankTagLayoutsPlugin.FakeItem> fakeItems = plugin.calculateFakeItems(layout, indexToWidget);

        for (BankTagLayoutsPlugin.FakeItem fakeItem : fakeItems)
        {
            assertFalse(laidOutBank.containsKey(fakeItem.getIndex()));
            laidOutBank.put(
                    fakeItem.getIndex(),
                    fakeItem.layoutPlaceholder ?
                            BankSlot.layoutPlaceholder(fakeItem.getItemId()) :
                            BankSlot.duplicateItem(fakeItem.getItemId(), fakeItem.getQuantity())
            );
        }

        return new LaidOutBank(laidOutBank);
    }

    private static class Item {
        final String name;
        final int id;
        final int placeholderId;
        final boolean placeholder;
        final int variantClass;

        public Item(String name, int id, int placeholderId, int variantClass) {
            this(name, id, placeholderId, variantClass, false);
        }

        public Item(String name, int id, int placeholderId, int variantClass, boolean placeholder) {
            this.name = name;
            this.id = id;
            this.placeholderId = placeholderId;
            this.variantClass = variantClass;
            this.placeholder = placeholder;
            itemsById.put(this.id, this);
        }
    }

    private static class LayoutItem {
        final Item item;
        final int index;

        public LayoutItem(Item item, int index) {
            this.item = item;
            this.index = index;
        }
    }

    private Layout generateLayout(LayoutItem... layoutItems) {
        Layout layout = new Layout();
        for (LayoutItem layoutItem : layoutItems)
        {
            layout.putItem(layoutItem.item.id, layoutItem.index);
        }
        return layout;
    }

    private void checkCurrentLayout(int index, Item item)
    {
        checkLayout(currentLayout, index, item);
    }

	private void checkLayout(Layout layout, int index, Item item)
	{
		checkLayout(layout, index, item.id);
	}

	private void checkLayout(Layout layout, int index, int itemId)
	{
		assertEquals(itemId, layout.getItemAtIndex(index));
	}

	private static class LaidOutBank {
        final Map<Integer, BankSlot> map;

        public LaidOutBank(Map<Integer, BankSlot> map) {
            this.map = map;
        }

        @Override
        public String toString()
        {
            String result = "\n";
            for (Map.Entry<Integer, BankSlot> entry : map.entrySet())
            {
                result += entry.getKey() + ": " + entry.getValue().toString() + "\n";
            }
            return result;
        }

        @Override
        public boolean equals(Object o)
        {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            LaidOutBank that = (LaidOutBank) o;
            return Objects.equals(map, that.map);
        }

        @Override
        public int hashCode()
        {
            return Objects.hash(map);
        }

        public void add(int index, BankSlot bankSlot)
		{
    		map.put(index, bankSlot);
		}
    }

    private ItemComposition generateItemComposition(int itemId)
    {
        Item item = itemsById.get(itemId);
        ItemComposition mock = Mockito.mock(ItemComposition.class);
        Mockito.when(mock.getName()).thenReturn(item.name);
        Mockito.when(mock.getPlaceholderTemplateId()).thenReturn(item.placeholder ? 14401 : -1);
        Mockito.when(mock.getPlaceholderId()).thenReturn(item.placeholderId);
		Mockito.when(mock.getId()).thenReturn(item.id);
		return mock;
    }

    @Test
	public void testLayoutGeneratorWithDuplicateItems() {
		LayoutGenerator layoutGenerator = new LayoutGenerator(plugin);
		Layout layout = layoutGenerator.generateLayout(Arrays.asList(GAMES_NECKLACE_8.id, RUNE_PLATEBODY.id), Arrays.asList(GAMES_NECKLACE_8.id, MAGIC_LOGS.id, MAGIC_LOGS.id), Collections.emptyList(), Collections.emptyList(), Layout.emptyLayout(), 28, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		checkLayout(layout, 0, GAMES_NECKLACE_8);
		checkLayout(layout, 8, RUNE_PLATEBODY);
		checkLayout(layout, 16, GAMES_NECKLACE_8);
		checkLayout(layout, 24, MAGIC_LOGS);
		checkLayout(layout, 17, MAGIC_LOGS);
	}

	@Test
	public void testLayoutGeneratorWithDuplicateLimit() {
		LayoutGenerator layoutGenerator = new LayoutGenerator(plugin);
		Layout layout = layoutGenerator.generateLayout(Collections.emptyList(), Arrays.asList(
			GAMES_NECKLACE_8.id,
			MAGIC_LOGS.id,
			MAGIC_LOGS.id,
			GAMES_NECKLACE_8.id,
			GAMES_NECKLACE_8.id,
			GAMES_NECKLACE_8.id,
			MAGIC_LOGS.id,
			MAGIC_LOGS.id,
			MAGIC_LOGS.id,
			MAGIC_LOGS.id,
			GAMES_NECKLACE_8.id),Collections.emptyList(), Collections.emptyList(), Layout.emptyLayout(), 3, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		checkLayout(layout, 0, GAMES_NECKLACE_8);
		checkLayout(layout, 8, MAGIC_LOGS);
		checkLayout(layout, 1, MAGIC_LOGS);
		checkLayout(layout, 9, GAMES_NECKLACE_8);
		checkLayout(layout, 2, GAMES_NECKLACE_8);
		checkLayout(layout, 10, GAMES_NECKLACE_8);
		checkLayout(layout, 3, MAGIC_LOGS);
		checkLayout(layout, 11, GAMES_NECKLACE_8);
		assertEquals(8, layout.allPairs().size());
	}

	/**
	 * https://github.com/geheur/bank-tag-custom-layouts/issues/32
	 */
	@Test
	public void testLayoutGeneratorWithMoreItemsThanDuplicateLimitAsTheFirstItemsInTheInventory() {
		LayoutGenerator layoutGenerator = new LayoutGenerator(plugin);
		Layout layout = layoutGenerator.generateLayout(Collections.emptyList(), Arrays.asList(
			MAGIC_LOGS.id,
			MAGIC_LOGS.id,
			MAGIC_LOGS.id,
			MAGIC_LOGS.id
			), Collections.emptyList(), Collections.emptyList(), Layout.emptyLayout(), 3, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		checkLayout(layout, 0, MAGIC_LOGS);
		assertEquals(1, layout.allPairs().size());
	}

	@Test
	public void testLayoutGeneratorWithEmptyInventory() {
		LayoutGenerator layoutGenerator = new LayoutGenerator(plugin);

		Layout layout = layoutGenerator.generateLayout(Collections.emptyList(), Arrays.asList(),Collections.emptyList(), Collections.emptyList(), Layout.emptyLayout(), 3, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		assertEquals(0, layout.allPairs().size());

		layout = layoutGenerator.generateLayout(Collections.emptyList(), Arrays.asList(-1),Collections.emptyList(), Collections.emptyList(), Layout.emptyLayout(), 3, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		assertEquals(0, layout.allPairs().size());

		layout = layoutGenerator.generateLayout(Collections.emptyList(), Collections.nCopies(28, -1),Collections.emptyList(), Collections.emptyList(), Layout.emptyLayout(), 3, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		assertEquals(0, layout.allPairs().size());
	}

	@Test
	public void testLayoutGeneratorDoesntDeleteDuplicateItems() {
		LayoutGenerator layoutGenerator = new LayoutGenerator(plugin);
		Layout initialLayout = generateLayout(
			new LayoutItem(MAGIC_LOGS, 0),
			new LayoutItem(MAGIC_LOGS, 8),
			new LayoutItem(MAGIC_LOGS, 1),

			new LayoutItem(MAGIC_LOGS, 9),
			new LayoutItem(MAGIC_LOGS, 2)
		);
		Layout layout = layoutGenerator.generateLayout(Collections.emptyList(), Arrays.asList(
			MAGIC_LOGS.id,
			MAGIC_LOGS.id,
			MAGIC_LOGS.id
		),Collections.emptyList(), Collections.emptyList(), initialLayout, 3, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		checkLayout(layout, 0, MAGIC_LOGS);
		checkLayout(layout, 8, MAGIC_LOGS);
		checkLayout(layout, 1, MAGIC_LOGS);
		checkLayout(layout, 9, MAGIC_LOGS);
		checkLayout(layout, 2, MAGIC_LOGS);
		assertEquals(5, layout.allPairs().size());
	}

	@Test
	public void testLayoutGeneratorWorksWithVariantItems() {
		LayoutGenerator layoutGenerator = new LayoutGenerator(plugin);
		Layout initialLayout = generateLayout(
			new LayoutItem(GAMES_NECKLACE_8, 0),
			new LayoutItem(GAMES_NECKLACE_7, 8)
		);
		Layout layout = layoutGenerator.generateLayout(Collections.emptyList(), Arrays.asList(
			GAMES_NECKLACE_8.id,
			GAMES_NECKLACE_6.id
		),Collections.emptyList(), Collections.emptyList(), initialLayout, 3, BankTagLayoutsConfig.LayoutStyles.ZIGZAG);
		checkLayout(layout, 0, GAMES_NECKLACE_8);
		checkLayout(layout, 8, GAMES_NECKLACE_6);
		System.out.println("layout: " + layout);
		assertEquals(2, layout.allPairs().size());
	}

	@Test
	public void testNameEscaping() {
		String name = "&:&cerberus: ghost skip&";
		String escapedName = BankTagLayoutsPlugin.LayoutableThing.inventorySetup(name).configKey().substring(BankTagLayoutsPlugin.INVENTORY_SETUPS_LAYOUT_CONFIG_KEY_PREFIX.length());
		assertEquals("&amp;&#58;&amp;cerberus&#58; ghost skip&amp;", escapedName);
//		String unescapedName = BankTagLayoutsPlugin.unescapeCharactersInConfigKey(escapedName);
//		assertEquals(name, unescapedName);
		/*
	static String unescapeCharactersInConfigKey(String s)
	{
		return s.replaceAll("&#58;", ":").replaceAll("&amp;", "&");
	}
		 */
	}
}

package com.banktaglayouts;

import javax.inject.Inject;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.banktags.BankTag;
import net.runelite.client.plugins.banktags.tabs.Layout;
import net.runelite.client.plugins.banktags.tabs.TagTab;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(
	name = "Bank Tag Layouts [Tools]",
	description = "tools",
	tags = {"bank", "tag", "layout"}
)
@PluginDependency(BankTagLayoutsPlugin.class)
public class BankTagLayoutsToolsPlugin extends Plugin
{
	@Inject private OverlayManager overlayManager;
	@Inject private ConfigManager configManager;
	@Inject private Client client;
	@Inject private BankTagLayoutsPlugin plugin;
	@Inject private BankTagLayoutsToolsOverlay overlay;

	@Override
	public void startUp() {
		overlayManager.add(overlay);
	}

	@Override
	public void shutDown() {
		overlayManager.remove(overlay);
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted) {
		if ("adamlayouts".equals(commandExecuted.getCommand())) {

//			BankTag bankTag = new BankTag()
//			{
//				@Override
//				public boolean contains(int i)
//				{
//					if (i == 11335 || i == 15584 || i == 7449) return true;
//					return false;
//				}
//
//				@Override
//				public Layout layout() {
//					Layout layout = new Layout();
//					layout.setItemAtPos(11335, 1);
//					layout.setItemAtPos(7449, 8);
//					return layout;
//				}
//			};
//			plugin.bankTagsService.openBankTag(bankTag);
//			plugin.tagManager.registerTag("mytag", bankTag);
//			TagTab tagTab = new TagTab();
//			tagTab.setTag("mytag");
////			tagTab.setLayout(layout);
//			plugin.clientThread.invokeLater(() -> {
//				plugin.bankTagsService.openBankTag(bankTag);
//			});
		}
		if ("clearversion".equals(commandExecuted.getCommand())) {
			configManager.unsetConfiguration(plugin.CONFIG_GROUP, "version");
			System.out.println("cleared version number.");
		}
		if ("checkversion".equals(commandExecuted.getCommand())) {
			System.out.println("checking version number");
			plugin.checkVersionUpgrade();
		}

		if ("itemname".equals(commandExecuted.getCommand())) {
			String[] arguments = commandExecuted.getArguments();
			client.addChatMessage(ChatMessageType.PUBLICCHAT, "Item name of " + arguments[0], plugin.itemName(Integer.valueOf(arguments[0])), "bla");
		}
		if ("placeholder".equals(commandExecuted.getCommand())) {
			String[] arguments = commandExecuted.getArguments();
			int itemId = Integer.parseInt(arguments[0]);
			client.addChatMessage(ChatMessageType.PUBLICCHAT, "" + itemId, plugin.itemName(itemId) + " is a " + plugin.isPlaceholder(itemId) + " and it's reversed id is " + plugin.switchPlaceholderId(itemId) + " and again " + plugin.switchPlaceholderId(plugin.switchPlaceholderId(itemId)), "bla");
		}
	}
}

package com.banktaglayouts;

import org.junit.Assert;
import org.junit.Test;

public class VersionNumberTest
{

	@Test
	public void testVersionNumbers() {
		VersionNumber v1 = new VersionNumber(1, 4, 10);
		VersionNumber v2 = new VersionNumber(1, 4, 11);
		VersionNumber v1s = new VersionNumber("1.4.10");
		VersionNumber v2s = new VersionNumber("1.4.11");

//		com.jogamp.common.util.VersionNumber jv1 = new com.jogamp.common.util.VersionNumber(1, 4, 10);
//		com.jogamp.common.util.VersionNumber jv2 = new com.jogamp.common.util.VersionNumber(1, 4, 11);
//		com.jogamp.common.util.VersionNumber jv1s = new com.jogamp.common.util.VersionNumber("1.4.10");
//		com.jogamp.common.util.VersionNumber jv2s = new com.jogamp.common.util.VersionNumber("1.4.11");

		Assert.assertEquals(0, v1.compareTo(v1s));
		Assert.assertEquals(0, v2.compareTo(v2s));
		Assert.assertEquals(-1, v1.compareTo(v2s));
		Assert.assertEquals(1, v2.compareTo(v1s));

//		Assert.assertEquals(0, jv1.compareTo(jv1s));
//		Assert.assertEquals(0, jv2.compareTo(jv2s));
//		Assert.assertEquals(-1, jv1.compareTo(jv2s));
//		Assert.assertEquals(1, jv2.compareTo(jv1s));
	}
}

package com.banktaglayouts;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

public class BankTagLayoutsToolsOverlay extends Overlay
{
	@Inject private BankTagLayoutsConfig config;
	@Inject private TooltipManager tooltipManager;
	@Inject private BankTagLayoutsToolsPlugin toolsPlugin;
	@Inject private BankTagLayoutsPlugin plugin;

	private Tooltip tooltip = null;

	BankTagLayoutsToolsOverlay() {
		drawAfterLayer(ComponentID.BANK_ITEM_CONTAINER);
		setLayer(OverlayLayer.MANUAL);
		setPosition(OverlayPosition.DYNAMIC);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		BankTagLayoutsPlugin.LayoutableThing currentLayoutableThing = plugin.getCurrentLayoutableThing();
		if (currentLayoutableThing == null) return null;

		Layout layout = plugin.getBankOrder(currentLayoutableThing);
		if (layout == null) return null;

		if (config.showLayoutPlaceholders()) updateTooltip(layout);

		return null;
	}

	private void updateTooltip(Layout layout) {
		tooltipManager.getTooltips().remove(tooltip);
		tooltip = null;

		int index = plugin.getIndexForMousePosition(true);
		if (plugin.fakeItems.stream().noneMatch(fakeItem -> fakeItem.index == index)) return;

		if (index != -1) {
			int itemIdForTooltip = layout.getItemAtIndex(index);
			if (itemIdForTooltip != -1 && tooltip == null) {
				String tooltipString = ColorUtil.wrapWithColorTag(plugin.itemName(itemIdForTooltip), BankTagLayoutsPlugin.itemTooltipColor);
				tooltipString += " (" + itemIdForTooltip + (plugin.isPlaceholder(itemIdForTooltip) ? ", ph" : "") + ")";
				tooltip = new Tooltip(tooltipString);
				tooltipManager.add(tooltip);
			}
		}
	}
}

package com.banktaglayouts;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.lang.reflect.Field;
import java.util.Properties;
import net.runelite.client.RuneLite;
import net.runelite.client.RuneLiteProperties;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		setWindowTitle("bank-tag-layouts (" + getCurrentGitBranch() + ") RL-" + RuneLiteProperties.getVersion());

		ExternalPluginManager.loadBuiltin(BankTagLayoutsPlugin.class, BankTagLayoutsToolsPlugin.class);
		RuneLite.main(args);
	}

	private static void setWindowTitle(String title) throws NoSuchFieldException, IllegalAccessException
	{
		Field propertiesField = RuneLiteProperties.class.getDeclaredField("properties");
		propertiesField.setAccessible(true);
		Properties properties = (Properties) propertiesField.get(null);
		properties.setProperty("runelite.title", title);
	}

	public static String getCurrentGitBranch() {
		try
		{
			Process process = Runtime.getRuntime().exec("git rev-parse --abbrev-ref HEAD");
			process.waitFor();

			BufferedReader reader = new BufferedReader(
				new InputStreamReader(process.getInputStream()));

			return reader.readLine();
		}catch (Exception e) {
			return "threw exception";
		}
	}
}
