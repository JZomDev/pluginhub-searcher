package com.templeosrs;

import com.templeosrs.util.CurrentTopRanges;
import com.templeosrs.util.PlayerRanges;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("TempleOSRS")
public interface TempleOSRSConfig extends Config
{
	String TEMPLE_OSRS_CONFIG_GROUP = "TempleOSRS";

	@ConfigSection(
		name = "General",
		description = "General Options",
		position = 0
	)
	String generalOptions = "generalOptions";

	@ConfigSection(
		name = "Ranks",
		description = "Rank Options",
		position = 10
	)
	String rankOptions = "rankOptions";

	@ConfigSection(
		name = "Clans",
		description = "Clan Options",
		position = 20
	)
	String clanOptions = "clanOptions";

	@ConfigSection(
		name = "Competitions",
		description = "Competition Options",
		position = 30
	)
	String compOptions = "compOptions";

	@ConfigSection(
		name = "Collection Log",
		description = "Collection Log Options",
		position = 40
	)
	String clogOptions = "clogOptions";

	@ConfigItem(
		keyName = "autocomplete",
		name = "Autocomplete",
		description = "Toggle name prediction when typing a name to lookup",
		position = 1,
		section = generalOptions
	)
	default boolean autocomplete()
	{
		return true;
	}

	@ConfigItem(
		keyName = "playerLookup",
		name = "Player Lookup",
		description = "Toggle TempleOSRS lookup option in players' right-click menus",
		position = 2,
		section = generalOptions
	)
	default boolean playerLookup()
	{
		return false;
	}

	@ConfigItem(
		keyName = "fetchDefaults",
		name = "Fetch Defaults",
		description = "Toggle whether or not to fetch defaults on startup",
		position = 3,
		section = generalOptions
	)
	default boolean fetchDefaults()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showSidebar",
		name = "Show sidebar icon",
		description = "Display TempleOSRS plugin in the sidebar.",
		position = 4,
		section = generalOptions
	)
	default boolean showSidebar()
	{
		return true;
	}

	@ConfigItem(
		keyName = "defaultPlayer",
		name = "Default Player",
		description = "Default player loaded on startup",
		position = 1,
		section = rankOptions
	)
	default String getDefaultPlayer()
	{
		return "";
	}

	@ConfigItem(
		keyName = "defaultRange",
		name = "Default Range",
		description = "Default time-period for player-ranks loaded on startup",
		position = 2,
		section = rankOptions
	)
	default PlayerRanges getDefaultRange()
	{
		return PlayerRanges.Week;
	}

	@ConfigItem(
		keyName = "autoUpdate",
		name = "Auto-Update",
		description = "Toggle whether or not to automatically update the player on TempleOSRS",
		position = 3,
		section = rankOptions
	)
	default boolean autoUpdate()
	{
		return false;
	}

	@ConfigItem(
		keyName = "clanAchievements",
		name = "Clan Achievements",
		description = "Toggle whether or not to display group-achievements when fetching group-information",
		position = 1,
		section = clanOptions
	)
	default boolean displayClanAchievements()
	{
		return true;
	}

	@ConfigItem(
		keyName = "clanMembers",
		name = "Clan Members",
		description = "Toggle whether or not to display group-members when fetching group-information",
		position = 2,
		section = clanOptions
	)
	default boolean displayClanMembers()
	{
		return false;
	}

	@ConfigItem(
		keyName = "clanCurrentTop",
		name = "Current Top Rankings",
		description = "Toggle whether or not to display weekly-top players for ehp and ehb when fetching group-information",
		position = 3,
		section = clanOptions
	)
	default boolean displayClanCurrentTop()
	{
		return true;
	}

	@ConfigItem(
		keyName = "currentTopRange",
		name = "Current Top Range",
		description = "Default time-period for current-top-ranks loaded on clan-fetch",
		position = 4,
		section = clanOptions
	)
	default CurrentTopRanges getCurrentTopRange()
	{
		return CurrentTopRanges.Week;
	}

	@ConfigItem(
		keyName = "defaultClan",
		name = "Default Clan",
		description = "Default clan loaded on startup",
		position = 5,
		section = clanOptions
	)
	default int getDefaultClan()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "clanKey",
		name = "Clan Key",
		description = "Required key to edit group-members using the TempleOSRS API",
		position = 6,
		secret = true,
		section = clanOptions
	)
	default String clanKey()
	{
		return "";
	}

	@ConfigItem(
		keyName = "ignoredRanks",
		name = "Ignored ranks",
		description = "A comma-separated list of excluded ranks from group-members sync (Case Sensitive).",
		position = 7,
		section = clanOptions
	)
	default String getIgnoredRanks()
	{
		return "";
	}

	@ConfigItem(
		keyName = "onlyAddMembers",
		name = "Only Add Members",
		description = "Toggle whether or not to only add members during clan-sync",
		position = 8,
		section = clanOptions
	)
	default boolean onlyAddMembers()
	{
		return false;
	}

	@ConfigItem(
		keyName = "defaultComp",
		name = "Default Competition",
		description = "Default competition loaded on startup",
		position = 1,
		section = compOptions
	)
	default int getDefaultComp()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "competitionWatchlist",
		name = "Competition Watchlist",
		description = "A comma-separated list of saved competition IDs.",
		position = 2,
		section = compOptions
	)
	default String getCompetitionWatchlist()
	{
		return "";
	}

	@ConfigItem(
		keyName = "competitionWatchlist",
		name = "",
		description = ""
	)
	void setCompetitionWatchlist(String key);

	@ConfigItem(
		keyName = "clogsyncbutton",
		name = "Collection Log Update Button",
		description = "Add a button to the collection log interface to update your collection log on TempleOSRS",
		position = 1,
		section = clogOptions
	)
	default boolean clogSyncButton()
	{
		return true;
	}

	@ConfigItem(
		keyName = "autoSyncClog",
		name = "Automatically sync Collection Log",
		description = "When enabled, TempleOSRS will automatically sync your collection log when you receive a new item",
		position = 2,
		section = clogOptions
	)
	default boolean autoSyncClog()
	{
		return false;
	}

	@Range(min = 50, max = 200)
	@ConfigItem(
		keyName = "maxCachedPlayers",
		name = "Max Cached Players",
		description = "Maximum number of players to keep in the database (excluding yourself)." +
			" The more players the more MB kept on database. " +
			"Default number of players in database is 50",
		position = 3,
		section = clogOptions
	)
	default int maxCachedPlayers()
	{
		return 50;
	}

	@ConfigItem(
		keyName = "enableClogChatCommand",
		name = "Enable !col chat command",
		description = "When enabled, the plugin will detect any !col chat messages and replace the contents with " +
			"TempleOSRS log data, if available",
		position = 4,
		section = clogOptions
	)
	default boolean enableClogChatCommand()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableClogChatCommandItemNameTooltip",
		name = "Enable !col item name tooltip",
		description = "When enabled, hovering over an item icon in the !col command's message will reveal the item's name.",
		position = 5,
		section = clogOptions
	)
	default boolean enableClogChatCommandItemNameTooltip()
	{
		return true;
	}
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs;

import com.google.inject.Provides;
import com.templeosrs.ui.TempleOSRSPanel;
import com.templeosrs.ui.clans.TempleClans;
import com.templeosrs.ui.competitions.TempleCompetitions;
import com.templeosrs.ui.ranks.TempleRanks;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.SyncButtonManager;
import com.templeosrs.util.collections.chatcommands.ChatItemNameTooltip;
import javax.inject.Inject;
import javax.inject.Provider;
import javax.swing.SwingUtilities;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.xpupdater.XpUpdaterConfig;
import net.runelite.client.plugins.xpupdater.XpUpdaterPlugin;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@PluginDependency(XpUpdaterPlugin.class)
@PluginDescriptor(name = "TempleOSRS", description = "A RuneLite plugin utilizing the TempleOSRS API.", tags = {"Temple", "ehp", "ehb"})
public class TempleOSRSPlugin extends Plugin
{
	private static final String TEMPLE = "Temple";

	private static final int XP_THRESHOLD = 10000;

	private static NavigationButton navButton;

	public TempleRanks ranks;

	public TempleClans clans;

	public TempleCompetitions competitions;

	public TempleOSRSPanel panel;

	private long lastAccount;

	private boolean fetchXp;

	private long lastXp;

	@Inject
	private Client client;

	@Inject
	private Provider<MenuManager> menuManager;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Getter
	@Inject
	private TempleOSRSConfig config;

	@Inject
	private XpUpdaterConfig xpUpdaterConfig;

	@Inject
	private XpUpdaterPlugin xpUpdaterPlugin;

	@Inject
	private TempleService service;

	@Inject
	private SyncButtonManager syncButtonManager;

	@Inject
	private CollectionLogManager clogManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ChatItemNameTooltip chatItemNameTooltip;

	@Override
	protected void startUp()
	{
		fetchXp = true;

		lastAccount = -1L;

		ranks = injector.getInstance(TempleRanks.class);

		clans = injector.getInstance(TempleClans.class);

		competitions = injector.getInstance(TempleCompetitions.class);

		panel = new TempleOSRSPanel(ranks, clans, competitions);
		navButton = NavigationButton.builder().tooltip("TempleOSRS").icon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "skills/skill_icon_ehp.png")).priority(5).panel(panel).build();

		if (config.showSidebar())
		{
			clientToolbar.addNavigation(navButton);
		}

		if (config.playerLookup() && client != null)
		{
			menuManager.get().addPlayerMenuItem(TEMPLE);
		}

		// Only display clog update button if enabled
		if (config.clogSyncButton())
		{
			syncButtonManager.startUp();
		}

		clogManager.startUp();

		if (config.enableClogChatCommand() && config.enableClogChatCommandItemNameTooltip())
		{
			overlayManager.add(chatItemNameTooltip);
		}
	}

	@Override
	protected void shutDown()
	{
		clientToolbar.removeNavigation(navButton);

		if (client != null)
		{
			menuManager.get().removePlayerMenuItem(TEMPLE);
		}

		ranks.shutdown();

		clogManager.shutDown();

		if (config.enableClogChatCommand() && config.enableClogChatCommandItemNameTooltip())
		{
			overlayManager.remove(chatItemNameTooltip);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals(TempleOSRSConfig.TEMPLE_OSRS_CONFIG_GROUP))
		{
			if (client != null)
			{
				menuManager.get().removePlayerMenuItem(TEMPLE);
				if (config.playerLookup())
				{
					menuManager.get().addPlayerMenuItem(TEMPLE);
				}

				// Show/Hide plugin icon in sidebar
				if (config.showSidebar())
				{
					clientToolbar.addNavigation(navButton);
				}
				else
				{
					clientToolbar.removeNavigation(navButton);
				}

				if (clans.clanAchievements != null)
				{
					clans.remove(clans.clanAchievements);
					if (config.displayClanAchievements())
					{
						clans.add(clans.clanAchievements);
					}
				}

				if (clans.clanCurrentTop != null)
				{
					clans.remove(clans.clanCurrentTop);
					if (config.displayClanCurrentTop())
					{
						clans.add(clans.clanCurrentTop);
					}
				}

				if (clans.clanMembers != null)
				{
					clans.remove(clans.clanMembers);
					if (config.displayClanMembers())
					{
						clans.add(clans.clanMembers);
					}
				}

				// Collection Log Related
				if (config.clogSyncButton())
				{
					syncButtonManager.startUp();
				}
				else
				{
					syncButtonManager.shutDown();
				}

				if (config.enableClogChatCommand() && config.enableClogChatCommandItemNameTooltip())
				{
					overlayManager.add(chatItemNameTooltip);
				}
				else
				{
					overlayManager.remove(chatItemNameTooltip);
				}

				clans.repaint();
				clans.revalidate();
			}

			competitions.rebuildWatchlist();
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if ((event.getType() != MenuAction.CC_OP.getId() && event.getType() != MenuAction.CC_OP_LOW_PRIORITY.getId()) || !config.playerLookup())
		{
			return;
		}

		String username = Text.toJagexName(Text.removeTags(event.getTarget()).toLowerCase().trim());

		final String option = event.getOption();
		final int componentId = event.getActionParam1();
		final int groupId = WidgetUtil.componentToInterface(componentId);

		if (groupId == InterfaceID.FRIEND_LIST && option.equals("Delete")
			|| groupId == InterfaceID.FRIENDS_CHAT && (option.equals("Add ignore") || option.equals("Remove friend"))
			|| groupId == InterfaceID.CHATBOX && (option.equals("Add ignore") || option.equals("Message"))
			|| groupId == InterfaceID.IGNORE_LIST && option.equals("Delete")
			|| (componentId == ComponentID.CLAN_MEMBERS || componentId == ComponentID.CLAN_GUEST_MEMBERS) && (option.equals("Add ignore") || option.equals("Remove friend"))
			|| groupId == InterfaceID.PRIVATE_CHAT && (option.equals("Add ignore") || option.equals("Message"))
			|| groupId == InterfaceID.GROUP_IRON && (option.equals("Add friend") || option.equals("Remove friend") || option.equals("Remove ignore"))
		)
		{
			client.createMenuEntry(-2).setOption(TEMPLE).setTarget(event.getTarget()).setType(MenuAction.RUNELITE).setIdentifier(event.getIdentifier()).onClick(e -> fetchUser(username));
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals(TEMPLE))
		{
			Player player = event.getMenuEntry().getPlayer();
			if (player == null)
			{
				return;
			}

			String username = player.getName();
			fetchUser(username);
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (fetchXp)
		{
			lastXp = client.getOverallExperience();
			fetchXp = false;
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState state = gameStateChanged.getGameState();
		if (state == GameState.LOGGED_IN)
		{
			if (lastAccount != client.getAccountHash())
			{
				lastAccount = client.getAccountHash();
				fetchXp = true;
			}
		}
		else if (state == GameState.LOGIN_SCREEN)
		{
			Player local = client.getLocalPlayer();
			if (local == null)
			{
				return;
			}

			long totalXp = client.getOverallExperience();
			String username = local.getName();

			/* Don't submit update if xp-threshold has not been reached or username is null
			   or config option for auto-update is disabled */
			if (Math.abs(totalXp - lastXp) > XP_THRESHOLD && username != null && config.autoUpdate())
			{
				updateUser(lastAccount, username.replace(" ", "+"));
				lastXp = totalXp;
			}
		}
	}

	@Provides
	TempleOSRSConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(TempleOSRSConfig.class);
	}

	public void fetchUser(String username)
	{
		SwingUtilities.invokeLater(() -> {
			clientToolbar.openPanel(navButton);

			/* select ranks-tab */
			panel.tabGroup.select(panel.ranksTab);
			ranks.fetchUser(username);
		});
	}

	public void updateUser(long accountHash, String username)
	{
		/* if XpUpdaterPlugin is disabled or XpUpdaterPlugin's config option for templeosrs is disabled */
		if (!pluginManager.isPluginEnabled(xpUpdaterPlugin) || !xpUpdaterConfig.templeosrs())
		{
			new Thread(() -> {
				try
				{
					service.addDatapointAsync(username, accountHash);
				}
				catch (Exception ignored)
				{

				}
			}).start();
		}
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

public class TempleClanAchievementRow extends JPanel
{
	TempleClanAchievementRow(TempleOSRSPlugin plugin, String name, String skill, HiscoreSkillType type, long xp, Color color)
	{
		setLayout(new BorderLayout());

		JPanel row = new JPanel();
		row.setLayout(new GridLayout(1, 3));
		row.setBorder(new EmptyBorder(2, 0, 2, 0));
		row.setPreferredSize(new Dimension(0, 25));
		row.setBackground(color);

		/* format name for file-path */
		String formattedName = skill.replaceAll("[^A-Za-z0-9]", "").toLowerCase();

		/* determine icon-path */
		String iconPath;
		if (type.equals(HiscoreSkillType.SKILL))
		{
			iconPath = "skills/skill_icon_" + formattedName + ".png";
		}
		else
		{
			iconPath = "bosses/game_icon_" + formattedName + ".png";
		}

		ImageIcon icon;
		try
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, iconPath));
		}
		catch (Exception e)
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "bosses/game_icon_null.png"));
		}

		/* add username to row */
		JLabel usernameLabel = createNewJLabel(name);
		row.add(usernameLabel);

		/* add achievement-value to row */
		String xpType = QuantityFormatter.quantityToStackSize(xp);
		JLabel xpLabel = createNewJLabel(xpType);

		xpLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		xpLabel.setHorizontalAlignment(JLabel.CENTER);
		row.add(xpLabel);

		/* add achievement-icon to row */
		JLabel iconLabel = new JLabel();
		iconLabel.setBorder(new EmptyBorder(0, 0, 0, 5));
		iconLabel.setIcon(icon);
		iconLabel.setToolTipText(skill);
		iconLabel.setHorizontalAlignment(JLabel.RIGHT);
		row.add(iconLabel);

		add(row);

		/* add on-click menu to username label */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + name + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(name));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		usernameLabel.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});
	}

	/* create a new achievement label of similar style */
	JLabel createNewJLabel(String text)
	{
		JLabel label = new JLabel(text);
		label.setToolTipText(text);
		label.setFont(FontManager.getRunescapeSmallFont());
		label.setBorder(new EmptyBorder(0, 5, 0, 0));
		return label;
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.clan.TempleClanAchievement;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanAchievements extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	TempleClanAchievements(TempleOSRSPlugin plugin, List<TempleClanAchievement> clanActivityList)
	{
		if (clanActivityList == null)
		{
			return;
		}

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* layout which holds all achievement-rows */
		JPanel clanActivity = new JPanel();
		clanActivity.setLayout(new GridLayout(0, 1));

		/* for each achievement in activity-list */
		for (int i = 0; i < clanActivityList.size(); i++)
		{
			TempleClanAchievement skill = clanActivityList.get(i);
			HiscoreSkillType type = skill.type.equals("Skill") ? HiscoreSkillType.SKILL : HiscoreSkillType.BOSS;

			/* create a new achievement-row and add to clan-activity layout */
			TempleClanAchievementRow row = new TempleClanAchievementRow(plugin, skill.username, skill.skill, type, skill.xp, COLORS[i % 2]);
			clanActivity.add(row);
		}

		/* add clan-activity list to main layout */
		layoutPanel.add(clanActivity, BorderLayout.SOUTH);

		/* create custom border */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), "Recent Activity");
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if list is too large -> add scroll-pane and set preferred dimensions */
		if (clanActivityList.size() > 10)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 275));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs.ui.clans;

import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

public class TempleClanCurrentTop extends PluginPanel
{
	TempleClanCurrentTop(TempleClanCurrentTopList Ehp, TempleClanCurrentTopList Ehb)
	{
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		/* tab group to switch between EHP and EHB */
		JPanel display = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(display);

		MaterialTab leadersTab = new MaterialTab("Hours Played", tabGroup, Ehp);
		MaterialTab membersTab = new MaterialTab("Hours Bossed", tabGroup, Ehb);

		tabGroup.addTab(leadersTab);
		tabGroup.addTab(membersTab);
		tabGroup.select(leadersTab);

		add(tabGroup);
		add(display);
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.CurrentTopRanges;
import com.templeosrs.util.clan.TempleClanCurrentTopPlayer;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.Map;
import java.util.Objects;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanCurrentTopList extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	TempleClanCurrentTopList(TempleOSRSPlugin plugin, Map<String, TempleClanCurrentTopPlayer> skill, CurrentTopRanges range)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel currentTop = new JPanel();
		currentTop.setLayout(new GridLayout(0, 1));

		/* create a list, if map is not null -> add map entries to list */
		ArrayList<TempleClanCurrentTopPlayer> players = new ArrayList<>();
		if (Objects.nonNull(skill))
		{
			players.addAll(skill.values());
		}

		/* for each member in the list of current-top players */
		for (int i = 0; i < players.size(); i++)
		{
			/* create a new member-row and add to current-top list */
			TempleClanCurrentTopPlayer player = players.get(i);
			TempleClanCurrentTopRow user = new TempleClanCurrentTopRow(plugin, i + 1, player.player, String.format("%.2f", player.xp), COLORS[i % 2]);
			currentTop.add(user);
		}

		/* add current-top list to main layout */
		layoutPanel.add(currentTop, BorderLayout.SOUTH);

		/* create custom border, add to (layout or scroll) */

		String title = "Current Top - " + range.getName();
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), title);
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if list is too large -> add scroll-pane and set preferred dimensions */
		if (players.size() > 10)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 275));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanCurrentTopRow extends JPanel
{
	TempleClanCurrentTopRow(TempleOSRSPlugin plugin, Integer rank, String name, String xp, Color color)
	{
		setLayout(new BorderLayout());
		setBackground(color);

		JPanel row = new JPanel();
		row.setLayout(new GridLayout(0, 2));
		row.setOpaque(false);
		row.setBorder(new EmptyBorder(2, 5, 2, 0));
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));

		/* add rank and username to row */
		JLabel username = new JLabel(rank + ". " + name);
		username.setFont(FontManager.getRunescapeSmallFont());
		username.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		row.add(username);

		/* add on-click menu to row */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + name + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(name));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		row.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});

		/* add ehp to row */
		JLabel ehp = new JLabel(xp);
		ehp.setFont(FontManager.getRunescapeSmallFont());
		ehp.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);

		row.add(ehp);

		add(row);
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanMember extends JPanel
{
	TempleClanMember(TempleOSRSPlugin plugin, String name, Color color)
	{
		setLayout(new BorderLayout());
		setBackground(color);

		JPanel row = new JPanel();
		row.setLayout(new GridLayout());
		row.setOpaque(false);
		row.setBorder(new EmptyBorder(2, 5, 2, 0));
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));

		/* add username to row */
		JLabel username = new JLabel(name);
		username.setFont(FontManager.getRunescapeSmallFont());
		username.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		row.add(username);

		/* add on-click menu to row */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + name + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(name));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		row.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});

		add(row);
	}
}

package com.templeosrs.ui.clans;

import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

public class TempleClanMembers extends PluginPanel
{
	public TempleClanMembers(TempleClanMembersList leaders, TempleClanMembersList members)
	{
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		/* tab group to switch between leaders and members */
		JPanel display = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(display);

		MaterialTab leadersTab = new MaterialTab("Leaders", tabGroup, leaders);
		MaterialTab membersTab = new MaterialTab("Members", tabGroup, members);

		tabGroup.addTab(leadersTab);
		tabGroup.addTab(membersTab);
		tabGroup.select(leadersTab);

		add(tabGroup);
		add(display);
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanMembersList extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	TempleClanMembersList(TempleOSRSPlugin plugin, String heading, String[] members)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel clanMembers = new JPanel();
		clanMembers.setLayout(new GridLayout(0, 1));

		/* for each member in members-list */
		for (int i = 0; i < members.length; i++)
		{
			/* create a new member-row and add to clan-members list */
			TempleClanMember user = new TempleClanMember(plugin, members[i], COLORS[i % 2]);
			clanMembers.add(user);
		}

		/* add clan-members list to main layout */
		layoutPanel.add(clanMembers, BorderLayout.SOUTH);

		/* create custom border, add to (layout or scroll) */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), heading);
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if list is too large -> add scroll-pane and set preferred dimensions */
		if (members.length > 10)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 275));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.clan.TempleClanOverviewInfo;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Objects;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

public class TempleClanOverview extends JPanel
{

	TempleClanOverview(TempleClanOverviewInfo info)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
		layoutPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* add name to layout */
		JLabel clanName = new JLabel(info.name);
		clanName.setBorder(new EmptyBorder(5, 5, 0, 0));
		clanName.setFont(FontManager.getRunescapeBoldFont());
		clanName.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		clanName.setAlignmentX(Component.CENTER_ALIGNMENT);
		clanName.setToolTipText(
			"<html> <table>" +
				"<tr><th style='text-align: left'>Total Xp: </th><td style='color:#6ee16e'>" + info.totalXp + "</td></tr>" +
				"<tr><th style='text-align: left'>Avg. Ehp: </th><td style='color:#6ee16e'>" + String.format("%.2f", info.averageEhp) + "</td></tr>" +
				"<tr><th style='text-align: left'>Avg. Ehb: </th><td style='color:#6ee16e'>" + String.format("%.2f", info.averageEhb) + "</td></tr>" +
				"</table> </html>");
		layoutPanel.add(clanName);

		JPanel fieldLayout = new JPanel();
		fieldLayout.setLayout(new FlowLayout());
		fieldLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* create and add members-count to layout */
		JLabel field = new JLabel("Members:");
		field.setBorder(new EmptyBorder(5, 5, 0, 0));
		field.setFont(FontManager.getRunescapeSmallFont());
		field.setAlignmentX(Component.CENTER_ALIGNMENT);
		fieldLayout.add(field);

		JLabel count = new JLabel(String.valueOf(info.memberCount));
		count.setBorder(new EmptyBorder(5, 0, 0, 0));
		count.setFont(FontManager.getRunescapeSmallFont());
		fieldLayout.add(count);

		layoutPanel.add(fieldLayout);

		/* create and add socials to layout */
		JPanel clanSocials = new JPanel();
		clanSocials.setPreferredSize(new Dimension(PANEL_WIDTH, 30));
		clanSocials.setLayout(new FlowLayout());
		clanSocials.setAlignmentX(Component.CENTER_ALIGNMENT);
		clanSocials.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* if social link exists, create and add button to socials-panel */
		if (Objects.nonNull(info.discordLink))
		{
			JButton social = createSocialsButton("https://discord.com/invite/" + info.discordLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/discord.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.twitterLink))
		{
			JButton social = createSocialsButton("https://twitter.com/" + info.twitterLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/twitter.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.youtubeLink))
		{
			JButton social = createSocialsButton("https://www.youtube.com/channel/" + info.youtubeLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/youtube.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.forumLink))
		{
			JButton social = createSocialsButton("https://secure.runescape.com/m=forum/sl=0/forums?" + info.forumLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/forums.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.twitchLink))
		{
			JButton social = createSocialsButton("https://www.twitch.tv/" + info.twitchLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/discord.png")));
			clanSocials.add(social);
		}

		/* if there is at least one social linked, add to layout */
		if (clanSocials.getComponentCount() > 0)
		{
			layoutPanel.add(clanSocials);
		}

		add(layoutPanel);
	}

	private JButton createSocialsButton(String link, ImageIcon icon)
	{
		JButton socialButton = new JButton();
		socialButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		socialButton.setBorder(new EmptyBorder(4, 4, 4, 4));

		JLabel socialLabel = new JLabel();
		socialLabel.setPreferredSize(new Dimension(16, 16));
		socialLabel.setIcon(icon);

		/* on social-icon click mouse-event, open link to social */
		socialButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				String url = link.trim();
				SwingUtilities.invokeLater(() -> LinkBrowser.browse(url));
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				socialButton.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				socialButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		socialButton.add(socialLabel);

		return socialButton;
	}
}

package com.templeosrs.ui.clans;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.clan.TempleClan;
import com.templeosrs.util.clan.TempleClanAchievement;
import com.templeosrs.util.clan.TempleClanOverviewInfo;
import com.templeosrs.util.sync.TempleSync;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.api.Client;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;

public class TempleClans extends PluginPanel
{
	private static final Pattern isNumeric = Pattern.compile("-?\\d+(\\.\\d+)?");

	public final IconTextField lookup;

	private final Client client;

	private final ClientThread thread;

	private final TempleOSRSPlugin plugin;

	private final TempleOSRSConfig config;

	private final PluginErrorPanel errorPanel = new PluginErrorPanel();

	private final JPanel fetchLayout;

	public TempleClanAchievements clanAchievements;

	public TempleClanMembers clanMembers;

	public TempleClanCurrentTop clanCurrentTop;

	public TempleService service;

	@Inject
	public TempleClans(TempleOSRSConfig config, TempleOSRSPlugin plugin, Client client, ClientThread thread, TempleService templeService)
	{
		this.plugin = plugin;
		this.client = client;
		this.thread = thread;
		this.config = config;
		this.service = templeService;

		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		fetchLayout = new JPanel();
		fetchLayout.setLayout(new BoxLayout(fetchLayout, BoxLayout.Y_AXIS));
		fetchLayout.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		fetchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* build and add search-text-field */
		JPanel searchLayout = new JPanel();
		searchLayout.setLayout(new BoxLayout(searchLayout, BoxLayout.X_AXIS));
		searchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lookup = buildTextField();
		searchLayout.add(lookup);

		JLabel actions = new JLabel();
		actions.setBorder(new EmptyBorder(0, 5, 0, 0));
		actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
		actions.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				JPopupMenu menu = new JPopupMenu();
				JMenuItem fetchPlayerMenuItem = new JMenuItem();
				fetchPlayerMenuItem.setText("Search");
				fetchPlayerMenuItem.addActionListener(ev -> fetchClan());
				menu.add(fetchPlayerMenuItem);

				JMenuItem openPlayerPageMenuItem = new JMenuItem();
				openPlayerPageMenuItem.setText("Open TempleOSRS");
				openPlayerPageMenuItem.addActionListener(ev -> open());
				menu.add(openPlayerPageMenuItem);

				JMenuItem syncClanMembersMenuItem = new JMenuItem();
				syncClanMembersMenuItem.setText("Sync Clan Members");
				syncClanMembersMenuItem.addActionListener(ev -> verify());
				menu.add(syncClanMembersMenuItem);

				actions.add(menu);
				menu.show(actions, e.getX(), e.getY());
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears_light.png")));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
			}

		});

		searchLayout.add(actions);
		fetchLayout.add(searchLayout);

		add(fetchLayout);

		/* add default, error-panel when clan has not been fetched yet */
		errorPanel.setContent("Clans", "You have not fetched clan information yet.");
		add(errorPanel);

		/* load default clan on start-up */
		if (config.fetchDefaults())
		{
			if (config.getDefaultClan() != 0)
			{
				lookup.setText(Integer.toString(config.getDefaultClan()));
				fetchClan();
			}
		}
	}

	private IconTextField buildTextField()
	{
		IconTextField lookup = new IconTextField();

		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
		lookup.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		lookup.setBackground(ColorScheme.SCROLL_TRACK_COLOR);

		/* fetch clan on action */
		lookup.addActionListener(e -> fetchClan());
		lookup.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (config.getDefaultClan() != 0 && SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2)
				{
					lookup.setText(Integer.toString(config.getDefaultClan()));
					fetchClan();
				}

				if (SwingUtilities.isRightMouseButton(e))
				{
					JPopupMenu menu = new JPopupMenu();
					JMenuItem fetchPlayerMenuItem = new JMenuItem();
					fetchPlayerMenuItem.setText("Search");
					fetchPlayerMenuItem.addActionListener(ev -> fetchClan());
					menu.add(fetchPlayerMenuItem);

					JMenuItem openPlayerPageMenuItem = new JMenuItem();
					openPlayerPageMenuItem.setText("Open TempleOSRS");
					openPlayerPageMenuItem.addActionListener(ev -> open());
					menu.add(openPlayerPageMenuItem);
					lookup.add(menu);

					JMenuItem syncClanMembersMenuItem = new JMenuItem();
					syncClanMembersMenuItem.setText("Sync Clan Members");
					syncClanMembersMenuItem.addActionListener(ev -> verify());
					menu.add(syncClanMembersMenuItem);
					lookup.add(menu);
					menu.show(lookup, e.getX(), e.getY());
				}
			}
		});

		/* reset on clear */
		lookup.addClearListener(() -> {
			completed();
			reset();
		});

		return lookup;
	}

	/* fetch clan from search-text-field */
	public void fetchClan()
	{
		final String id = lookup.getText();

		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		/* clan-id must be integer */
		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		loading();

		reset();

		/* create separate thread for completing clan-fetch/ panel rebuilds,
		 *  try to fetch clan,
		 *  when fetching completes, rebuild panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				service.fetchClanAsync(id, config.getCurrentTopRange().getRange()).whenCompleteAsync((result, err) -> response(id, result, err));
			}
			catch (Exception e)
			{
				error();
			}
		}).start();
	}

	/* reload fetched clan after syncing member-list */
	private void reload(String id)
	{
		loading();

		reset();

		try
		{
			service.fetchClanAsync(id, config.getCurrentTopRange().getRange()).whenCompleteAsync((result, err) -> response(id, result, err));
		}
		catch (Exception e)
		{
			error();
		}
	}

	private void rebuild(TempleClan result)
	{
		if (client == null)
		{
			return;
		}

		String[] leaders = result.clanOverview.data.leaders;
		String[] members = result.clanOverview.data.members;
		TempleClanOverviewInfo info = result.clanOverview.data.info;
		List<TempleClanAchievement> clanActivity = result.clanAchievements.data;
		/* Event-Dispatch-Thread necessary for adding/ removing new components */
		SwingUtilities.invokeLater(() -> {

			add(new TempleClanOverview(info));

			/* create achievements-component, only add if config option */
			clanAchievements = new TempleClanAchievements(plugin, clanActivity);
			if (config.displayClanAchievements())
			{
				add(clanAchievements);
			}

			/* create current-top-component, only add if config option enabled */
			TempleClanCurrentTopList clanCurrentTopEhp = new TempleClanCurrentTopList(plugin, result.clanCurrentTopEhp.list, config.getCurrentTopRange());
			TempleClanCurrentTopList clanCurrentTopEhb = new TempleClanCurrentTopList(plugin, result.clanCurrentTopEhb.list, config.getCurrentTopRange());

			clanCurrentTop = new TempleClanCurrentTop(clanCurrentTopEhp, clanCurrentTopEhb);
			if (config.displayClanCurrentTop())
			{
				add(clanCurrentTop);
			}

			/* create members-component, only add if config option */
			clanMembers = new TempleClanMembers(new TempleClanMembersList(plugin, "Leaders", leaders), new TempleClanMembersList(plugin, "Members", members));
			if (config.displayClanMembers())
			{
				add(clanMembers);
			}
		});

		completed();

		revalidate();
		repaint();
	}

	private void open()
	{
		String id = lookup.getText();
		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		/* if valid clan-id, open temple clan-page */
		loading();

		HttpUrl url = new HttpUrl.Builder()
			.scheme("https")
			.host("templeosrs.com")
			.addPathSegment("groups")
			.addPathSegment("overview.php")
			.addQueryParameter("id", id).build();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url.toString()));

		completed();
	}

	private void verify()
	{
		if (client == null)
		{
			return;
		}

		if (Strings.isNullOrEmpty(config.clanKey()))
		{
			return;
		}

		ClanSettings localClan = client.getClanSettings();

		if (localClan == null)
		{
			return;
		}

		/* add confirmation to sync clan-members with fetched clan (requires key) */
		final int confirmation = JOptionPane.showOptionDialog(lookup, "This will sync the fetched clan's TempleOSRS members-list to all members in the current account's clan (Requires Key).",
			"Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
			null, new String[]{
				"Yes",
				"No"
			}, "No");

		if (confirmation != JOptionPane.YES_OPTION)
		{
			return;
		}

		/* exclude certain clan ranks from members-sync */
		filter(localClan);
	}

	private void verify(List<String> filteredList)
	{
		loading();

		String id = lookup.getText();
		/* create separate thread for completing clan-post/ panel reload,
		 *  try to post clan members given clan-id, verification, and list,
		 *  when post completes, check response -> reload panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				if (config.onlyAddMembers())
				{
					service.addClanMembersAsync(id, config.clanKey(), filteredList).whenCompleteAsync((result, err) -> response(id, result, err));
				}
				else
				{
					service.syncClanMembersAsync(id, config.clanKey(), filteredList).whenCompleteAsync((result, err) -> response(id, result, err));
				}
			}
			catch (Exception e)
			{
				error();
			}
		}).start();
	}

	/* filter unwanted ranks for members-sync */
	private void filter(ClanSettings localClan)
	{
		List<String> clanList = new ArrayList<>();
		List<String> ignoredRanks = Text.fromCSV(config.getIgnoredRanks());

		/* ClientThread necessary for method titleForRank */
		thread.invoke(() -> {
			for (ClanMember member : localClan.getMembers())
			{
				ClanRank rank = member.getRank();
				ClanTitle clanTitle = localClan.titleForRank(rank);
				if (clanTitle != null)
				{
					String title = clanTitle.getName();
					if (!ignoredRanks.contains(title))
					{
						/* create a list of clan members retrieved from RuneLite, ignoring excluded ranks */
						clanList.add(format(member.getName()));
					}
				}
			}
			verify(clanList);
		});
	}

	/* Sync members response */
	private void response(String id, TempleSync response, Throwable e)
	{
		/* response is null, exception thrown, or error response */
		if (Objects.isNull(response) || Objects.nonNull(e) || response.error)
		{
			error();
			return;
		}
		reload(id);
	}

	/* Group information response */
	private void response(String id, TempleClan result, Throwable e)
	{
		remove(errorPanel);

		if (!lookup.getText().equals(id))
		{
			completed();
			return;
		}

		/* result is null, exception thrown, or error response */
		if (Objects.isNull(result) || Objects.nonNull(e) || result.error)
		{
			error();
			return;
		}
		rebuild(result);
	}

	/* reset clan tab to default */
	private void reset()
	{
		clanAchievements = null;
		clanMembers = null;

		removeAll();
		add(fetchLayout);
		add(errorPanel);

		repaint();
		revalidate();
	}

	/* set fields for error status */
	private void error()
	{
		lookup.setIcon(IconTextField.Icon.ERROR);
		lookup.setEditable(true);
	}

	/* set fields for loading status */
	private void loading()
	{
		lookup.setIcon(IconTextField.Icon.LOADING);
		lookup.setEditable(false);
	}

	/* set fields for completed status */
	private void completed()
	{
		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
	}

	/* format username to be accepted by Temple API */
	private String format(String text)
	{
		return text.replace('\u00A0', ' ');
	}
}

package com.templeosrs.ui.competitions;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.TempleHiscoreSkill;
import com.templeosrs.util.comp.TempleCompetitionInfo;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.FlowLayout;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class TempleCompetitionOverview extends JPanel
{

	TempleCompetitionOverview(TempleCompetitionInfo info, int memberCount)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
		layoutPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		layoutPanel.setOpaque(false);

		/* add competition name to layout */
		String name = info.name;
		JLabel compName = new JLabel(name);
		compName.setFont(FontManager.getRunescapeBoldFont());
		compName.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		compName.setAlignmentX(Component.CENTER_ALIGNMENT);
		compName.setToolTipText(name);
		layoutPanel.add(compName);

		/* add participants-count to layout */
		JPanel fieldLayout = new JPanel();
		fieldLayout.setLayout(new FlowLayout());
		fieldLayout.setOpaque(false);

		JLabel field = new JLabel("Participants:");
		field.setFont(FontManager.getRunescapeSmallFont());
		field.setAlignmentX(Component.CENTER_ALIGNMENT);
		fieldLayout.add(field);

		JLabel count = new JLabel(String.valueOf(memberCount));
		count.setFont(FontManager.getRunescapeSmallFont());
		fieldLayout.add(count);

		JPanel statusLayout = new JPanel();
		statusLayout.setLayout(new FlowLayout());
		statusLayout.setOpaque(false);

		/* add status to layout */
		JLabel statusLabel = new JLabel("Status:");
		statusLabel.setFont(FontManager.getRunescapeSmallFont());
		statusLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		statusLayout.add(statusLabel);

		String statusText = info.statusText;
		JLabel status = new JLabel(statusText);
		status.setFont(FontManager.getRunescapeSmallFont());

		/* add set status-text color */
		if (statusText.equals("Finished"))
		{
			status.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		}
		else if (statusText.equals("In progress"))
		{
			status.setForeground(ColorScheme.PROGRESS_INPROGRESS_COLOR);
		}
		else
		{
			status.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}

		statusLayout.add(status);

		layoutPanel.add(statusLayout);

		layoutPanel.add(fieldLayout);

		/* get HiscoreSkill by index */
		TempleHiscoreSkill skill = TempleHiscoreSkill.values()[info.skillIndex];

		String skillName = skill.getName();
		String formattedName = skillName.replaceAll("[^A-Za-z0-9]", "").toLowerCase();

		/* determine skill's icon-path */
		String iconPath;
		if (skill.getType().equals(HiscoreSkillType.SKILL))
		{
			iconPath = "skills/skill_icon_" + formattedName + ".png";
		}
		else
		{
			iconPath = "bosses/game_icon_" + formattedName + ".png";
		}

		JLabel iconLabel = new JLabel();

		/* add icon to layout */
		ImageIcon icon;
		try
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, iconPath));
		}
		catch (Exception e)
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "bosses/game_icon_null.png"));
		}
		iconLabel.setIcon(icon);
		iconLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		iconLabel.setToolTipText(info.skill);

		layoutPanel.add(iconLabel);

		add(layoutPanel);
	}
}

package com.templeosrs.ui.competitions;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.comp.TempleCompetitionParticipant;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.List;
import java.util.Objects;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleCompetitionRankings extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	public int i = 0;

	TempleCompetitionRankings(TempleOSRSPlugin plugin, List<TempleCompetitionParticipant> participantList)
	{
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, -2, 0, -2));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel compRankings = new JPanel();
		compRankings.setLayout(new GridLayout(0, 1));

		/* create header-bar for competitions (Name, Total) */
		JPanel compHeader = new JPanel();
		compHeader.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		compHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		compHeader.setPreferredSize(new Dimension(PANEL_WIDTH, 20));
		compHeader.setLayout(new GridLayout(0, 2));

		JLabel label = new JLabel("Name");
		label.setBorder(new EmptyBorder(0, 5, 0, 0));
		label.setFont(FontManager.getRunescapeSmallFont());
		compHeader.add(label);

		JLabel gain = new JLabel("Total");
		gain.setBorder(new EmptyBorder(0, 5, 0, 0));
		gain.setFont(FontManager.getRunescapeSmallFont());
		compHeader.add(gain);

		/* add header to rankings-panel */
		compRankings.add(compHeader);

		/* for each player in participant-list */
		for (TempleCompetitionParticipant player : participantList)
		{
			/* if participant has some skill-gain for competition */
			if (Objects.nonNull(player.xpGained) && player.xpGained > 0)
			{
				/* create and add new row for participant */
				TempleCompetitionRow row = new TempleCompetitionRow(plugin, player, i + 1, COLORS[i % 2]);
				compRankings.add(row);
				i++;
			}
		}

		/* add participant-list to layout */
		layoutPanel.add(compRankings, BorderLayout.SOUTH);

		/* create custom border */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), "Competition Rankings");
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if participant-count is too large -> add scroll-pane and set preferred dimensions */
		if (i > 15)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 425));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs.ui.competitions;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.comp.TempleCompetitionParticipant;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.QuantityFormatter;

public class TempleCompetitionRow extends JPanel
{
	TempleCompetitionRow(TempleOSRSPlugin plugin, TempleCompetitionParticipant player, int i, Color color)
	{
		setLayout(new BorderLayout());

		JPanel row = new JPanel();
		row.setLayout(new GridLayout());
		row.setBackground(color);
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		/* add start-point and current-end-point as tooltip-text */
		row.setToolTipText("<html>Start: <span style='color:#32a0fa'>" + QuantityFormatter.quantityToStackSize(player.startXp.longValue()) + "</span><br>End: <span style='color:#32a0fa'>" + QuantityFormatter.quantityToStackSize(player.endXp.longValue()) + "</span></html>");

		/* add player and ranking */
		JLabel name = new JLabel(i + ". " + player.username);
		name.setBorder(new EmptyBorder(0, 5, 0, 0));
		name.setFont(FontManager.getRunescapeSmallFont());
		row.add(name);

		/* add formatted total */
		JLabel xp = new JLabel(QuantityFormatter.quantityToStackSize(player.xpGained.longValue()));
		xp.setBorder(new EmptyBorder(0, 5, 0, 0));
		xp.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		xp.setFont(FontManager.getRunescapeSmallFont());
		row.add(xp);

		/* add on-click menu to row */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + player.username + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(player.username));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		row.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});

		add(row);
	}
}

package com.templeosrs.ui.competitions;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.comp.TempleCompetition;
import com.templeosrs.util.comp.TempleCompetitionInfo;
import com.templeosrs.util.comp.TempleCompetitionParticipant;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import okhttp3.HttpUrl;

public class TempleCompetitions extends PluginPanel
{
	private static final Pattern isNumeric = Pattern.compile("-?\\d+(\\.\\d+)?");

	public final IconTextField lookup;

	private final Client client;

	private final TempleOSRSPlugin plugin;

	private final TempleOSRSConfig config;

	private final PluginErrorPanel errorPanel = new PluginErrorPanel();

	private final JPanel fetchLayout;

	private final TempleService service;

	private TempleCompetitionWatchlist watchlist;

	@Inject
	public TempleCompetitions(TempleOSRSConfig config, TempleOSRSPlugin plugin, Client client, TempleService templeService)
	{
		this.plugin = plugin;
		this.client = client;
		this.config = config;
		this.service = templeService;

		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		fetchLayout = new JPanel();
		fetchLayout.setLayout(new BoxLayout(fetchLayout, BoxLayout.Y_AXIS));
		fetchLayout.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		fetchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* build and add search-text-field */
		JPanel searchLayout = new JPanel();
		searchLayout.setLayout(new BoxLayout(searchLayout, BoxLayout.X_AXIS));
		searchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lookup = buildTextField();
		searchLayout.add(lookup);

		JLabel actions = new JLabel();
		actions.setBorder(new EmptyBorder(0, 5, 0, 0));
		actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
		actions.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				JPopupMenu menu = new JPopupMenu();
				JMenuItem fetchPlayerMenuItem = new JMenuItem();
				fetchPlayerMenuItem.setText("Search");
				fetchPlayerMenuItem.addActionListener(ev -> fetchCompetition());
				menu.add(fetchPlayerMenuItem);

				JMenuItem openPlayerPageMenuItem = new JMenuItem();
				openPlayerPageMenuItem.setText("Open TempleOSRS");
				openPlayerPageMenuItem.addActionListener(ev -> open());
				menu.add(openPlayerPageMenuItem);

				JMenuItem addItemMenuItem = new JMenuItem();
				addItemMenuItem.setText("Add to Watchlist");
				addItemMenuItem.addActionListener(ev -> watchlist.addWatchlistItem(lookup.getText()));
				menu.add(addItemMenuItem);

				JMenuItem removeItemMenuItem = new JMenuItem();
				removeItemMenuItem.setText("Remove from Watchlist");
				removeItemMenuItem.addActionListener(ev -> watchlist.removeWatchlistItem(lookup.getText()));
				menu.add(removeItemMenuItem);

				actions.add(menu);
				menu.show(actions, e.getX(), e.getY());
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears_light.png")));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
			}
		});

		searchLayout.add(actions);
		fetchLayout.add(searchLayout);

		/* build and add duration selection */
		watchlist = new TempleCompetitionWatchlist(config, this);
		fetchLayout.add(watchlist);

		add(fetchLayout);

		/* add default, error-panel when competition has not been fetched yet */
		errorPanel.setContent("Competitions", "You have not fetched competition information yet.");
		add(errorPanel);

		/* load default competition on start-up */
		if (config.fetchDefaults())
		{
			if (config.getDefaultComp() != 0)
			{
				lookup.setText(Integer.toString(config.getDefaultComp()));
				fetchCompetition();
			}
		}
	}

	private IconTextField buildTextField()
	{
		IconTextField lookup = new IconTextField();

		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
		lookup.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		lookup.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		/* fetch competition on action */
		lookup.addActionListener(e -> fetchCompetition());
		lookup.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (config.getDefaultComp() != 0 && SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2)
				{
					lookup.setText(Integer.toString(config.getDefaultComp()));
					fetchCompetition();
				}
			}
		});

		/* reset on clear */
		lookup.addClearListener(() -> {
			completed();
			reset();
		});

		return lookup;
	}

	/* fetch competition from search-text-field */
	public void fetchCompetition()
	{
		final String id = lookup.getText();

		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		/* competition-id must be integer */
		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		loading();

		reset();

		/* create separate thread for completing competition-fetch/ panel rebuilds,
		 *  try to fetch competition,
		 *  when fetching completes, rebuild panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				service.fetchCompetitionAsync(id).whenCompleteAsync((result, err) -> response(id, result, err));
			}
			catch (Exception e)
			{
				error();
			}
		}).start();
	}

	private void response(String id, TempleCompetition result, Throwable e)
	{
		remove(errorPanel);

		if (!lookup.getText().equals(id))
		{
			completed();
			return;
		}

		/* result is null, exception thrown, or error response */
		if (Objects.isNull(result) || Objects.nonNull(e) || result.error)
		{
			error();
			return;
		}
		rebuild(result);
	}

	private void rebuild(TempleCompetition result)
	{
		if (client == null)
		{
			return;
		}

		TempleCompetitionInfo info = result.compOverview.data.info;
		List<TempleCompetitionParticipant> participants = result.compOverview.data.participants;

		/* Event-Dispatch-Thread necessary for adding/ removing new components */
		SwingUtilities.invokeLater(() -> {
			/* create and add rankings/ overview */
			TempleCompetitionRankings rankings = new TempleCompetitionRankings(plugin, participants);

			TempleCompetitionOverview compOverview = new TempleCompetitionOverview(info, rankings.i);

			add(compOverview);
			add(rankings);
		});

		completed();

		revalidate();
		repaint();
	}

	public void rebuildWatchlist()
	{
		watchlist = new TempleCompetitionWatchlist(config, this);

		/* watchlist is indexed at position one of fetchLayout */
		fetchLayout.remove(1);
		fetchLayout.add(watchlist);

		fetchLayout.revalidate();
		fetchLayout.repaint();
	}

	private void open()
	{
		String id = lookup.getText();
		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		/* if valid competition-id, open temple competition-page */
		loading();

		HttpUrl url = new HttpUrl.Builder()
			.scheme("https")
			.host("templeosrs.com")
			.addPathSegment("competitions")
			.addPathSegment("standings.php")
			.addQueryParameter("id", id).build();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url.toString()));

		completed();
	}

	/* reset completion tab to default */
	private void reset()
	{
		removeAll();
		add(fetchLayout);
		add(errorPanel);

		repaint();
		revalidate();
	}

	/* set fields for error status */
	private void error()
	{
		lookup.setIcon(IconTextField.Icon.ERROR);
		lookup.setEditable(true);
	}

	/* set fields for loading status */
	private void loading()
	{
		lookup.setIcon(IconTextField.Icon.LOADING);
		lookup.setEditable(false);
	}

	/* set fields for completed status */
	private void completed()
	{
		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
	}
}

package com.templeosrs.ui.competitions;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.LinkedHashSet;
import java.util.Set;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.Text;

public class TempleCompetitionWatchlist extends JPanel
{
	public static JComboBox<String> jComboBox;
	private final TempleOSRSConfig config;

	public TempleCompetitionWatchlist(TempleOSRSConfig config, TempleCompetitions panel)
	{
		this.config = config;

		String[] competitions = new String[Text.fromCSV(config.getCompetitionWatchlist()).size()];

		for (int i = 0; i < Text.fromCSV(config.getCompetitionWatchlist()).size(); i++)
		{
			competitions[i] = Text.fromCSV(config.getCompetitionWatchlist()).get(i);
		}

		setLayout(new BorderLayout());
		setOpaque(false);

		setMinimumSize(new Dimension(PANEL_WIDTH, 20));
		setBorder(new EmptyBorder(5, 0, 0, 0));

		jComboBox = new JComboBox<>(competitions);
		jComboBox.addActionListener(e -> {
			panel.lookup.setText((String) jComboBox.getSelectedItem());
			panel.fetchCompetition();
		});
		jComboBox.setSelectedItem(config.getDefaultComp());

		add(jComboBox);
	}

	void addWatchlistItem(String competitionId)
	{
		if (Strings.isNullOrEmpty(competitionId))
		{
			return;
		}

		Set<String> watchlist = new LinkedHashSet<>(Text.fromCSV(config.getCompetitionWatchlist()));
		if (!watchlist.contains(competitionId))
		{
			watchlist.add(competitionId);
			config.setCompetitionWatchlist(Text.toCSV(watchlist));
		}
	}

	void removeWatchlistItem(String competitionId)
	{
		if (Strings.isNullOrEmpty(competitionId))
		{
			return;
		}

		Set<String> watchlist = new LinkedHashSet<>(Text.fromCSV(config.getCompetitionWatchlist()));
		if (watchlist.contains(competitionId))
		{
			watchlist.remove(competitionId);
			config.setCompetitionWatchlist(Text.toCSV(watchlist));
		}
	}
}

package com.templeosrs.ui.ranks;

import com.google.common.collect.ImmutableList;
import com.templeosrs.util.TempleHiscoreSkill;
import static com.templeosrs.util.TempleHiscoreSkill.ABYSSAL_SIRE;
import static com.templeosrs.util.TempleHiscoreSkill.AGILITY;
import static com.templeosrs.util.TempleHiscoreSkill.ALCHEMICAL_HYDRA;
import static com.templeosrs.util.TempleHiscoreSkill.AMOXLIATL;
import static com.templeosrs.util.TempleHiscoreSkill.ARAXXOR;
import static com.templeosrs.util.TempleHiscoreSkill.ARTIO;
import static com.templeosrs.util.TempleHiscoreSkill.ATTACK;
import static com.templeosrs.util.TempleHiscoreSkill.BARROWS_CHESTS;
import static com.templeosrs.util.TempleHiscoreSkill.BRYOPHYTA;
import static com.templeosrs.util.TempleHiscoreSkill.CALLISTO;
import static com.templeosrs.util.TempleHiscoreSkill.CALVARION;
import static com.templeosrs.util.TempleHiscoreSkill.CERBERUS;
import static com.templeosrs.util.TempleHiscoreSkill.CHAMBERS_OF_XERIC;
import static com.templeosrs.util.TempleHiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE;
import static com.templeosrs.util.TempleHiscoreSkill.CHAOS_ELEMENTAL;
import static com.templeosrs.util.TempleHiscoreSkill.CHAOS_FANATIC;
import static com.templeosrs.util.TempleHiscoreSkill.COLLECTIONS;
import static com.templeosrs.util.TempleHiscoreSkill.COMMANDER_ZILYANA;
import static com.templeosrs.util.TempleHiscoreSkill.CONSTRUCTION;
import static com.templeosrs.util.TempleHiscoreSkill.COOKING;
import static com.templeosrs.util.TempleHiscoreSkill.CORPOREAL_BEAST;
import static com.templeosrs.util.TempleHiscoreSkill.CRAFTING;
import static com.templeosrs.util.TempleHiscoreSkill.CRAZY_ARCHAEOLOGIST;
import static com.templeosrs.util.TempleHiscoreSkill.DAGANNOTH_PRIME;
import static com.templeosrs.util.TempleHiscoreSkill.DAGANNOTH_REX;
import static com.templeosrs.util.TempleHiscoreSkill.DAGANNOTH_SUPREME;
import static com.templeosrs.util.TempleHiscoreSkill.DEFENCE;
import static com.templeosrs.util.TempleHiscoreSkill.DERANGED_ARCHAEOLOGIST;
import static com.templeosrs.util.TempleHiscoreSkill.DUKE_SUCELLUS;
import static com.templeosrs.util.TempleHiscoreSkill.FARMING;
import static com.templeosrs.util.TempleHiscoreSkill.FIREMAKING;
import static com.templeosrs.util.TempleHiscoreSkill.FISHING;
import static com.templeosrs.util.TempleHiscoreSkill.FLETCHING;
import static com.templeosrs.util.TempleHiscoreSkill.GENERAL_GRAARDOR;
import static com.templeosrs.util.TempleHiscoreSkill.GIANT_MOLE;
import static com.templeosrs.util.TempleHiscoreSkill.GROTESQUE_GUARDIANS;
import static com.templeosrs.util.TempleHiscoreSkill.HERBLORE;
import static com.templeosrs.util.TempleHiscoreSkill.HESPORI;
import static com.templeosrs.util.TempleHiscoreSkill.HITPOINTS;
import static com.templeosrs.util.TempleHiscoreSkill.HUEYCOATL;
import static com.templeosrs.util.TempleHiscoreSkill.HUNTER;
import static com.templeosrs.util.TempleHiscoreSkill.KALPHITE_QUEEN;
import static com.templeosrs.util.TempleHiscoreSkill.KING_BLACK_DRAGON;
import static com.templeosrs.util.TempleHiscoreSkill.KRAKEN;
import static com.templeosrs.util.TempleHiscoreSkill.KREEARRA;
import static com.templeosrs.util.TempleHiscoreSkill.KRIL_TSUTSAROTH;
import static com.templeosrs.util.TempleHiscoreSkill.LUNAR_CHESTS;
import static com.templeosrs.util.TempleHiscoreSkill.MAGIC;
import static com.templeosrs.util.TempleHiscoreSkill.MIMIC;
import static com.templeosrs.util.TempleHiscoreSkill.MINING;
import static com.templeosrs.util.TempleHiscoreSkill.NEX;
import static com.templeosrs.util.TempleHiscoreSkill.OBOR;
import static com.templeosrs.util.TempleHiscoreSkill.PHANTOM_MUSPAH;
import static com.templeosrs.util.TempleHiscoreSkill.PHOSANIS_NIGHTMARE;
import static com.templeosrs.util.TempleHiscoreSkill.PRAYER;
import static com.templeosrs.util.TempleHiscoreSkill.RANGED;
import static com.templeosrs.util.TempleHiscoreSkill.RUNECRAFT;
import static com.templeosrs.util.TempleHiscoreSkill.SARACHNIS;
import static com.templeosrs.util.TempleHiscoreSkill.SCORPIA;
import static com.templeosrs.util.TempleHiscoreSkill.SCURRIUS;
import static com.templeosrs.util.TempleHiscoreSkill.SKOTIZO;
import static com.templeosrs.util.TempleHiscoreSkill.SLAYER;
import static com.templeosrs.util.TempleHiscoreSkill.SMITHING;
import static com.templeosrs.util.TempleHiscoreSkill.SOL_HEREDIT;
import static com.templeosrs.util.TempleHiscoreSkill.SPINDEL;
import static com.templeosrs.util.TempleHiscoreSkill.STRENGTH;
import static com.templeosrs.util.TempleHiscoreSkill.TEMPOROSS;
import static com.templeosrs.util.TempleHiscoreSkill.THEATRE_OF_BLOOD;
import static com.templeosrs.util.TempleHiscoreSkill.THEATRE_OF_BLOOD_CHALLENGE_MODE;
import static com.templeosrs.util.TempleHiscoreSkill.THERMONUCLEAR_SMOKE_DEVIL;
import static com.templeosrs.util.TempleHiscoreSkill.THE_CORRUPTED_GAUNTLET;
import static com.templeosrs.util.TempleHiscoreSkill.THE_GAUNTLET;
import static com.templeosrs.util.TempleHiscoreSkill.THE_LEVIATHAN;
import static com.templeosrs.util.TempleHiscoreSkill.THE_NIGHTMARE;
import static com.templeosrs.util.TempleHiscoreSkill.THE_ROYAL_TITANS;
import static com.templeosrs.util.TempleHiscoreSkill.THE_WHISPERER;
import static com.templeosrs.util.TempleHiscoreSkill.THIEVING;
import static com.templeosrs.util.TempleHiscoreSkill.TOMBS_OF_AMASCUT;
import static com.templeosrs.util.TempleHiscoreSkill.TOMBS_OF_AMASCUT_EXPERT;
import static com.templeosrs.util.TempleHiscoreSkill.TZKAL_ZUK;
import static com.templeosrs.util.TempleHiscoreSkill.TZTOK_JAD;
import static com.templeosrs.util.TempleHiscoreSkill.VARDORVIS;
import static com.templeosrs.util.TempleHiscoreSkill.VENENATIS;
import static com.templeosrs.util.TempleHiscoreSkill.VETION;
import static com.templeosrs.util.TempleHiscoreSkill.VORKATH;
import static com.templeosrs.util.TempleHiscoreSkill.WINTERTODT;
import static com.templeosrs.util.TempleHiscoreSkill.WOODCUTTING;
import static com.templeosrs.util.TempleHiscoreSkill.ZALCANO;
import static com.templeosrs.util.TempleHiscoreSkill.ZULRAH;
import com.templeosrs.util.player.TemplePlayer;
import com.templeosrs.util.player.TemplePlayerData;
import com.templeosrs.util.player.TemplePlayerSkill;
import java.awt.Color;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;

public class TempleActivity extends JPanel
{
	public static final List<TempleHiscoreSkill> SKILLS = ImmutableList.of(
		ATTACK, DEFENCE, STRENGTH,
		HITPOINTS, RANGED, PRAYER,
		MAGIC, COOKING, WOODCUTTING,
		FLETCHING, FISHING, FIREMAKING,
		CRAFTING, SMITHING, MINING,
		HERBLORE, AGILITY, THIEVING,
		SLAYER, FARMING, RUNECRAFT,
		HUNTER, CONSTRUCTION
	);

	public static final List<TempleHiscoreSkill> BOSSES = ImmutableList.of(
		ABYSSAL_SIRE, ALCHEMICAL_HYDRA, AMOXLIATL, ARAXXOR, ARTIO, BARROWS_CHESTS,
		BRYOPHYTA, CALLISTO, CALVARION, CERBERUS,
		CHAMBERS_OF_XERIC, CHAMBERS_OF_XERIC_CHALLENGE_MODE, CHAOS_ELEMENTAL,
		CHAOS_FANATIC, COMMANDER_ZILYANA, CORPOREAL_BEAST,
		DAGANNOTH_PRIME, DAGANNOTH_REX, DAGANNOTH_SUPREME,
		CRAZY_ARCHAEOLOGIST, DERANGED_ARCHAEOLOGIST, DUKE_SUCELLUS, GENERAL_GRAARDOR,
		GIANT_MOLE, GROTESQUE_GUARDIANS, HESPORI,
		KALPHITE_QUEEN, KING_BLACK_DRAGON, KRAKEN,
		KREEARRA, KRIL_TSUTSAROTH, LUNAR_CHESTS, MIMIC,
		NEX, THE_NIGHTMARE, PHOSANIS_NIGHTMARE,
		OBOR, PHANTOM_MUSPAH, SARACHNIS, SCORPIA, SCURRIUS,
		SKOTIZO, SOL_HEREDIT, SPINDEL, TEMPOROSS, THE_GAUNTLET,
		THE_CORRUPTED_GAUNTLET, HUEYCOATL, THE_LEVIATHAN, THE_ROYAL_TITANS, THE_WHISPERER, THEATRE_OF_BLOOD, THEATRE_OF_BLOOD_CHALLENGE_MODE,
		THERMONUCLEAR_SMOKE_DEVIL, TOMBS_OF_AMASCUT, TOMBS_OF_AMASCUT_EXPERT, TZKAL_ZUK, TZTOK_JAD, VARDORVIS,
		VENENATIS, VETION, VORKATH,
		WINTERTODT, ZALCANO, ZULRAH, COLLECTIONS
	);

	private static final Color[] COLORS = {ColorScheme.DARKER_GRAY_COLOR, ColorScheme.DARK_GRAY_HOVER_COLOR};

	final Map<String, TempleActivityTableRow> map = new HashMap<>();

	final TempleActivitySortHeader sortPanel;

	final TempleActivityTableRow overall;

	ArrayList<TempleActivityTableRow> rows = new ArrayList<>();

	HiscoreSkillType hiscoreSkillType;

	long total;

	@Inject
	public TempleActivity(HiscoreSkillType type)
	{
		hiscoreSkillType = type;

		setLayout(new GridLayout(0, 1));
		setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		sortPanel = new TempleActivitySortHeader(this, hiscoreSkillType);

		overall = new TempleActivityTableRow("overall", "Overall", COLORS[1], HiscoreSkillType.OVERALL);

		initialize();
	}

	private void initialize()
	{
		/* reset rows */
		rows.clear();

		/* add default panels */
		add(sortPanel);
		add(overall);

		/* get correct list of HiscoreSkills */
		List<TempleHiscoreSkill> list = (hiscoreSkillType.equals(HiscoreSkillType.SKILL) ? SKILLS : BOSSES);

		/* for each skill in list */
		for (int i = 0; i < list.size(); i++)
		{
			TempleHiscoreSkill skill = list.get(i);
			String formattedKey = skill.getName().replaceAll("[^A-Za-z0-9]", "").toLowerCase();

			/* create a skill-row, add <key, row> to map, add row to rows-list */
			TempleActivityTableRow row = new TempleActivityTableRow(formattedKey, skill.getName(), COLORS[i % 2], hiscoreSkillType);
			map.put(formattedKey, row);
			rows.add(row);
			add(row);
		}
	}

	public void update(TemplePlayer result)
	{
		/* determine and get type of json */
		TemplePlayerData playerData = hiscoreSkillType.equals(HiscoreSkillType.SKILL) ? result.playerSkillsOverview.data : result.playerBossesOverview.data;

		/* for each entry in playerData */
		for (Map.Entry<String, TemplePlayerSkill> entry : playerData.table.entrySet())
		{
			/* get the HiscoreSkill of that entry by index */
			TempleHiscoreSkill skill;
			try
			{
				/* If a skill can't be found, continue */
				skill = TempleHiscoreSkill.values()[entry.getValue().index];
			}
			catch (IndexOutOfBoundsException ignored)
			{
				continue;
			}

			String formattedKey = skill.getName().replaceAll("[^A-Za-z0-9]", "").toLowerCase();

			/* if map contains this HighscoreSkill */
			if (map.containsKey(formattedKey))
			{
				/* get the mapped, skill-row */
				TempleActivityTableRow row = map.get(formattedKey);
				TemplePlayerSkill skillData = playerData.table.get(skill.getName());

				long total = Objects.nonNull(skillData.xp) ? skillData.xp.longValue() : 0;
				long levels = Objects.nonNull(skillData.level) ? skillData.level.longValue() : 0;
				long rank = Objects.nonNull(skillData.rank) ? skillData.rank.longValue() : 0;
				double ehp = hiscoreSkillType.equals(HiscoreSkillType.SKILL) ? (Objects.nonNull(skillData.ehp) ? skillData.ehp : 0) : (Objects.nonNull(skillData.ehb) ? skillData.ehb : 0);

				this.total += total;

				/* update skill-row's values */
				row.update(total, levels, rank, ehp);
			}
		}
	}

	/* update overall row */
	public void update(long rank, double ehp)
	{
		overall.update(total, 0, rank, ehp);
	}

	/* reset activity panel to defaults */
	public void reset()
	{
		total = 0;

		overall.reset();
		sortPanel.reset();

		removeAll();

		initialize();
	}

	/* re-build list of skills by sorted row-list */
	private void rebuild()
	{
		int i = 0;
		for (TempleActivityTableRow row : rows)
		{
			String skill = row.name;
			TempleActivityTableRow entry = map.get(skill);
			entry.setBackground(COLORS[i++ % 2]);
			add(entry);
		}

		repaint();
		revalidate();
	}

	/* sort row-list with comparator passed in through sort-filter mouse event */
	void sort(Comparator<TempleActivityTableRow> comparator)
	{
		rows.sort(comparator);
		rebuild();
	}
}

package com.templeosrs.ui.ranks;

import static com.templeosrs.ui.TempleOSRSPanel.DEFAULT;
import javax.swing.JLabel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

public class TempleActivityLabel extends JLabel
{
	TempleActivityLabel()
	{
		setText(DEFAULT);
		setFont(FontManager.getRunescapeSmallFont());
		setForeground(ColorScheme.LIGHT_GRAY_COLOR);
	}

	/* update activity-row label (xp, level, rank) */
	void update(long value)
	{
		setText(QuantityFormatter.quantityToStackSize(value));
		if (value == 0)
		{
			setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			setText(DEFAULT);
		}
		else if (value > 0)
		{
			setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}
		else
		{
			setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}
	}

	/* update (double) activity-row label (ehp, ehb) */
	void update(double value)
	{
		setText(String.format("%.2f", value));
		if (value == 0)
		{
			setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			setText(DEFAULT);
		}
		else if (value > 0)
		{
			setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}
		else
		{
			setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}
	}

	/* reset activity-row label to default */
	void reset()
	{
		setText(DEFAULT);
		setForeground(ColorScheme.LIGHT_GRAY_COLOR);
	}
}

package com.templeosrs.ui.ranks;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class TempleActivitySortFilter extends JPanel
{
	private final JLabel icon;

	boolean increasing;

	TempleActivitySortFilter(String text)
	{
		icon = new JLabel();

		JLabel label = new JLabel(text);
		label.setFont(FontManager.getRunescapeSmallFont());

		setLayout(new GridLayout(0, 2));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* on mouse-event, flip ascending/ descending icon */
		addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				increasing = !increasing;
				icon.setIcon(new ImageIcon(increasing ? ImageUtil.loadImageResource(TempleOSRSPlugin.class, "sorting/up.png") : ImageUtil.loadImageResource(TempleOSRSPlugin.class, "sorting/down.png")));
			}
		});

		add(label);
		add(icon);
	}

	void reset()
	{
		icon.setIcon(null);
	}
}

package com.templeosrs.ui.ranks;

import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Comparator;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleActivitySortHeader extends JPanel
{
	private final TempleActivitySortFilter name;

	private final TempleActivitySortFilter total;

	private final TempleActivitySortFilter rank;

	private final TempleActivitySortFilter ehp;

	TempleActivitySortHeader(TempleActivity panel, HiscoreSkillType type)
	{
		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
		setPreferredSize(new Dimension(PANEL_WIDTH, 20));

		/* create sorting-filters with unique comparators (Name, Total, Rank, Ehp),
		 * reset all other filters on selection */
		name = new TempleActivitySortFilter("Name");
		name.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(total, rank, ehp);
				Comparator<TempleActivityTableRow> comparator = name.increasing ? Comparator.comparing((TempleActivityTableRow row) -> row.name) : Comparator.comparing((TempleActivityTableRow row) -> row.name).reversed();
				/* resort skills-panel on click */
				panel.sort(comparator);
			}
		});

		total = new TempleActivitySortFilter("Total");
		total.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(name, rank, ehp);
				Comparator<TempleActivityTableRow> comparator = total.increasing ? Comparator.comparingDouble((TempleActivityTableRow row) -> row.total) : Comparator.comparingDouble((TempleActivityTableRow row) -> row.total).reversed();
				panel.sort(comparator);
			}
		});

		rank = new TempleActivitySortFilter("Rank");
		rank.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(total, name, ehp);
				Comparator<TempleActivityTableRow> comparator = rank.increasing ? Comparator.comparingDouble((TempleActivityTableRow row) -> row.rank) : Comparator.comparingDouble((TempleActivityTableRow row) -> row.rank).reversed();
				panel.sort(comparator);
			}
		});

		ehp = new TempleActivitySortFilter(type.equals(HiscoreSkillType.SKILL) ? "EHP" : "EHB");
		ehp.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(total, name, rank);
				Comparator<TempleActivityTableRow> comparator = ehp.increasing ? Comparator.comparingDouble((TempleActivityTableRow row) -> row.ehp) : Comparator.comparingDouble((TempleActivityTableRow row) -> row.ehp).reversed();
				panel.sort(comparator);
			}
		});

		JPanel display = new JPanel();
		display.setLayout(new GridLayout(1, 4));

		/* add filters to sort-panel */
		display.add(name);
		display.add(total);
		display.add(rank);
		display.add(ehp);

		add(display);
	}

	/* reset a list of filters to default */
	private void reset(TempleActivitySortFilter... types)
	{
		for (TempleActivitySortFilter t : types)
		{
			t.reset();
			t.increasing = false;
		}
	}

	/* reset all filters to default */
	void reset()
	{
		reset(name, total, rank, ehp);
	}
}

package com.templeosrs.ui.ranks;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.ImageUtil;

public class TempleActivityTableRow extends JPanel
{
	final String name;

	private final TempleActivityLabel skillGain;

	private final TempleActivityLabel rankGain;

	private final TempleActivityLabel ehpGain;

	long total;

	long rank;

	double ehp;

	HiscoreSkillType type;

	TempleActivityTableRow(String skillName, String tooltip, Color color, HiscoreSkillType type)
	{
		this.name = skillName;
		this.type = type;

		setLayout(new BorderLayout());
		setBackground(color);

		JPanel row = new JPanel();
		row.setLayout(new GridLayout());
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		row.setOpaque(false);

		JPanel iconPanel = new JPanel();
		iconPanel.setLayout(new BorderLayout());
		iconPanel.setOpaque(false);

		/* determine icon-path by skill type and formatted-name */
		String iconPath;
		if (type.equals(HiscoreSkillType.SKILL))
		{
			iconPath = "skills/skill_icon_" + skillName + ".png";
		}
		else if (type.equals(HiscoreSkillType.BOSS))
		{
			iconPath = "bosses/game_icon_" + skillName + ".png";
		}
		else
		{
			iconPath = "overall.png";
		}

		JLabel iconLabel = new JLabel();
		iconLabel.setBorder(new EmptyBorder(0, 5, 0, 0));

		/* load icon resource from path */
		ImageIcon icon;
		try
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, iconPath));
		}
		catch (Exception e)
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "skills/skill_icon_null.png"));
		}

		iconLabel.setIcon(icon);
		iconLabel.setToolTipText(tooltip);

		/* add icon to row */
		iconPanel.add(iconLabel);
		row.add(iconPanel, BorderLayout.WEST);

		/* create and add labels to row */
		skillGain = new TempleActivityLabel();
		rankGain = new TempleActivityLabel();
		ehpGain = new TempleActivityLabel();

		row.add(skillGain);
		row.add(rankGain);
		row.add(ehpGain);
		add(row);
	}

	/* update activity-row values */
	void update(long gain, long level, long rank, double ehp)
	{
		this.total = gain;
		this.rank = rank;
		this.ehp = ehp;

		/* add levels gained as tooltip-text if SKILL */
		skillGain.update(gain);
		skillGain.setToolTipText(type.equals(HiscoreSkillType.SKILL) ? "<html>Levels Gained: <span style='color:#32a0fa'>" + level + "</span></html>" : "");

		rankGain.update(rank);
		ehpGain.update(ehp);
	}

	/* reset activity-row values to default */
	void reset()
	{
		skillGain.reset();
		rankGain.reset();
		ehpGain.reset();
	}
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, dekvall
 * Copyright (c) 2021, Rorro
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.ui.ranks;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.NameAutocompleter;
import com.templeosrs.util.PlayerRanges;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.player.TemplePlayer;
import com.templeosrs.util.player.TemplePlayerData;
import com.templeosrs.util.player.TemplePlayerSkill;
import java.awt.Dimension;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Objects;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.api.Client;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import okhttp3.HttpUrl;

public class TempleRanks extends PluginPanel
{
	public final IconTextField lookup;

	private final Client client;

	private final TempleOSRSConfig config;

	private final NameAutocompleter nameAutocompleter;

	private final TempleActivity skills;

	private final TempleActivity bosses;

	private final TempleRanksOverview overview;

	private final TempleService service;

	@Inject
	public TempleRanks(TempleOSRSConfig config, Client client, TempleService templeService, NameAutocompleter nameAutocompleter)
	{
		this.client = client;
		this.config = config;
		this.nameAutocompleter = nameAutocompleter;
		this.service = templeService;

		skills = new TempleActivity(HiscoreSkillType.SKILL);
		bosses = new TempleActivity(HiscoreSkillType.BOSS);

		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		JPanel fetchLayout = new JPanel();
		fetchLayout.setLayout(new BoxLayout(fetchLayout, BoxLayout.Y_AXIS));
		fetchLayout.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		fetchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* build and add search-text-field */
		JPanel searchLayout = new JPanel();
		searchLayout.setLayout(new BoxLayout(searchLayout, BoxLayout.X_AXIS));
		searchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lookup = buildTextField();
		searchLayout.add(lookup);

		JLabel actions = new JLabel();
		actions.setBorder(new EmptyBorder(0, 5, 0, 0));
		actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
		actions.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				JPopupMenu menu = new JPopupMenu();
				JMenuItem fetchPlayerMenuItem = new JMenuItem();
				fetchPlayerMenuItem.setText("Search");
				fetchPlayerMenuItem.addActionListener(ev -> fetchUser());
				menu.add(fetchPlayerMenuItem);

				JMenuItem openPlayerPageMenuItem = new JMenuItem();
				openPlayerPageMenuItem.setText("Open TempleOSRS");
				openPlayerPageMenuItem.addActionListener(ev -> open());
				menu.add(openPlayerPageMenuItem);

				actions.add(menu);
				menu.show(actions, e.getX(), e.getY());
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears_light.png")));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
			}
		});

		searchLayout.add(actions);
		fetchLayout.add(searchLayout);

		/* build and add duration selection */
		TempleRanksDuration timeSelection = new TempleRanksDuration(config, this);
		fetchLayout.add(timeSelection);

		add(fetchLayout);

		/* build and add player overview */
		overview = new TempleRanksOverview();
		add(overview);

		/* material-tab-group for selecting view of Skills/ Bosses */
		JPanel display = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(display);

		MaterialTab skillsTab = new MaterialTab("Skills", tabGroup, skills);
		MaterialTab bossesTab = new MaterialTab("Bosses", tabGroup, bosses);

		tabGroup.addTab(skillsTab);
		tabGroup.addTab(bossesTab);
		tabGroup.select(skillsTab);
		add(tabGroup);

		add(display);

		/* add key listener for player-search autocomplete */
		addInputKeyListener(this.nameAutocompleter);

		/* load default player on start-up */
		if (config.fetchDefaults())
		{
			if (!Strings.isNullOrEmpty(config.getDefaultPlayer()))
			{
				fetchUser(config.getDefaultPlayer());
			}
		}
	}

	/* remove key listener for player-search autocomplete */
	public void shutdown()
	{
		removeInputKeyListener(this.nameAutocompleter);
	}

	private IconTextField buildTextField()
	{
		IconTextField lookup = new IconTextField();

		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
		lookup.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		lookup.setBackground(ColorScheme.SCROLL_TRACK_COLOR);

		/* add action listeners for fetching user / fetching local player */
		lookup.addActionListener(e -> fetchUser());
		lookup.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2)
				{
					String player = config.getDefaultPlayer();

					if (!Strings.isNullOrEmpty(player))
					{
						fetchUser(player);
					}
				}
			}
		});

		/* reset icons and panel on clear */
		lookup.addClearListener(() -> {
			completed();
			reset();
		});

		return lookup;
	}

	/* search-text-field double-click -> fetch local player */
	public void fetchUser(String username)
	{
		lookup.setText(username);
		fetchUser();
	}

	/* fetch player from search-text-field */
	public void fetchUser()
	{
		final String username = format(lookup.getText());

		if (Strings.isNullOrEmpty(username))
		{
			return;
		}

		/* maximum username length */
		if (username.length() > 12)
		{
			error();
			return;
		}

		loading();

		reset();

		String period = PlayerRanges.get(String.valueOf(TempleRanksDuration.jComboBox.getSelectedItem())).getRange();

		/* create separate thread for completing player-fetch/ panel rebuilds,
		 *  try to fetch player gains,
		 *  when fetching completes, rebuild panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				service.fetchUserGainsAsync(username, period).whenCompleteAsync((result, err) -> response(username, result, err));
			}
			catch (Exception e)
			{
				e.printStackTrace();
				error();
			}
		}).start();
	}

	private void response(String username, TemplePlayer result, Throwable e)
	{
		/* search-text-field has changed since start of fetching player data */
		if (!format(lookup.getText()).equals(username))
		{
			completed();
			return;
		}

		/* result is null, error is not null, or error response */
		if (Objects.isNull(result) || Objects.nonNull(e) || result.error)
		{
			error();
			return;
		}
		rebuild(result);
	}

	/* rebuild components */
	private void rebuild(TemplePlayer result)
	{
		skills.update(result);
		bosses.update(result);
		rebuildOverall(result);

		completed();
	}

	private void rebuildOverall(TemplePlayer result)
	{
		/* get player skills and bosses data from result */
		TemplePlayerData bossingData = result.playerBossesOverview.data;
		TemplePlayerData skillsData = result.playerSkillsOverview.data;

		TemplePlayerSkill ehbData = bossingData.table.get("Ehb");
		TemplePlayerSkill ehpData = skillsData.table.get("Ehp");
		TemplePlayerSkill xpData = skillsData.table.get("Overall");

		/* if not null, get overall totals, ranks, and gains for ehp/ehb/xp */
		double ehbRankTotal = Objects.nonNull(ehbData.rankTotal) ? ehbData.rankTotal : 0;
		double ehbTotal = Objects.nonNull(ehbData.xpTotal) ? ehbData.xpTotal : 0;

		double ehbRankGain = Objects.nonNull(ehbData.rank) ? ehbData.rank : 0;
		double ehbGain = Objects.nonNull(ehbData.xp) ? ehbData.xp : 0;

		double ehpRankTotal = Objects.nonNull(ehpData.rankTotal) ? ehpData.rankTotal : 0;
		double ehpTotal = Objects.nonNull(ehpData.xpTotal) ? ehpData.xpTotal : 0;

		double ehpRankGain = Objects.nonNull(ehpData.rank) ? ehpData.rank : 0;
		double ehpGain = Objects.nonNull(ehpData.xp) ? ehpData.xp : 0;

		double xpRankTotal = Objects.nonNull(xpData.rankTotal) ? xpData.rankTotal : 0;
		double xpTotal = Objects.nonNull(xpData.xpTotal) ? xpData.xpTotal : 0;

		/* update player-overview sections */
		overview.EHP.update((long) ehpRankTotal, (long) ehpTotal);
		overview.EHB.update((long) ehbRankTotal, (long) ehbTotal);
		overview.EXP.update((long) xpRankTotal, (long) xpTotal);

		/* update activity overall-row */
		bosses.update((long) ehbRankGain, ehbGain);
		skills.update((long) ehpRankGain, ehpGain);
	}

	private void open()
	{
		String username = format(lookup.getText());
		if (Strings.isNullOrEmpty(username))
		{
			return;
		}

		if (username.length() > 12)
		{
			error();
			return;
		}

		/* if valid username format, open temple player-profile */
		loading();

		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("player").addPathSegment("overview.php").addQueryParameter("player", username).build();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url.toString()));

		completed();
	}

	/* reset all panels */
	private void reset()
	{
		skills.reset();
		bosses.reset();
		overview.reset();

		repaint();
		revalidate();
	}

	/* set fields for error status */
	private void error()
	{
		lookup.setIcon(IconTextField.Icon.ERROR);
		lookup.setEditable(true);
	}

	/* set fields for loading status */
	private void loading()
	{
		lookup.setIcon(IconTextField.Icon.LOADING);
		lookup.setEditable(false);
	}

	/* set fields for completed status */
	private void completed()
	{
		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
	}

	private void addInputKeyListener(KeyListener l)
	{
		lookup.addKeyListener(l);
	}

	private void removeInputKeyListener(KeyListener l)
	{
		lookup.removeKeyListener(l);
	}

	/* format username to be accepted by Temple API */
	private String format(String text)
	{
		String formatted = text.replaceAll("\\s+", "+");
		return formatted.replace('\u00A0', '+');
	}
}


package com.templeosrs.ui.ranks;

import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.util.PlayerRanges;
import java.awt.BorderLayout;
import java.awt.Dimension;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleRanksDuration extends JPanel
{
	private static final String[] OPTIONS = new String[PlayerRanges.values().length];
	public static JComboBox<String> jComboBox;

	static
	{
		for (int i = 0; i < PlayerRanges.values().length; i++)
		{
			OPTIONS[i] = PlayerRanges.values()[i].getName();
		}
	}

	public TempleRanksDuration(TempleOSRSConfig config, TempleRanks panel)
	{
		setLayout(new BorderLayout());
		setOpaque(false);

		setMinimumSize(new Dimension(PANEL_WIDTH, 20));
		setBorder(new EmptyBorder(5, 0, 0, 0));

		jComboBox = new JComboBox<>(OPTIONS);
		jComboBox.addActionListener(e -> panel.fetchUser());
		jComboBox.setSelectedItem(config.getDefaultRange().getName());

		add(jComboBox);
	}
}

package com.templeosrs.ui.ranks;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public class TempleRanksOverview extends JPanel
{
	public final TempleRanksOverviewSection EXP;

	public final TempleRanksOverviewSection EHP;

	public final TempleRanksOverviewSection EHB;

	public TempleRanksOverview()
	{
		setLayout(new GridLayout(0, 1));
		setBorder(new EmptyBorder(5, -2, 5, -2));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* create custom border for player-overview */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), "Player Overview");
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		layoutPanel.setBorder(custom);

		JPanel playerOverview = new JPanel();
		playerOverview.setBorder(new EmptyBorder(3, 3, 3, 3));
		playerOverview.setLayout(new GridLayout(3, 1));
		playerOverview.setOpaque(false);

		/* create overview sections and add to player-overview panel */
		EHP = new TempleRanksOverviewSection("Ehp", "Efficient Hours Played", ColorScheme.DARK_GRAY_HOVER_COLOR);
		EHB = new TempleRanksOverviewSection("Ehb", "Efficient Hours Bossed", ColorScheme.DARKER_GRAY_COLOR);
		EXP = new TempleRanksOverviewSection("Xp", "Total Experience", ColorScheme.DARK_GRAY_HOVER_COLOR);

		playerOverview.add(EHP);
		playerOverview.add(EHB);
		playerOverview.add(EXP);

		layoutPanel.add(playerOverview, BorderLayout.SOUTH);
		add(layoutPanel);
	}

	/* reset player-overview sections */
	public void reset()
	{
		EHP.reset();
		EHB.reset();
		EXP.reset();
	}
}

package com.templeosrs.ui.ranks;

import static com.templeosrs.ui.TempleOSRSPanel.DEFAULT;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.QuantityFormatter;

public class TempleRanksOverviewSection extends JPanel
{
	JLabel total;

	JLabel rank;

	TempleRanksOverviewSection(String label, String tooltip, Color color)
	{
		this.total = createNewJLabel(label + " Total");
		this.rank = createNewJLabel(label + " Rank");

		setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		setBorder(new EmptyBorder(0, 10, 0, 0));
		setLayout(new GridLayout(1, 3));
		setBackground(color);

		/* add labels to layout */
		JLabel field = new JLabel(label.toUpperCase(), SwingConstants.LEFT);
		field.setFont(FontManager.getRunescapeSmallFont());
		field.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		field.setToolTipText(tooltip);

		add(field);
		add(total);
		add(rank);
	}

	/* update overview-section (rank, total) pair */
	public void update(long x, long x1)
	{
		rank.setText(x != 0 ? QuantityFormatter.quantityToStackSize(x) : DEFAULT);
		total.setText(x1 != 0 ? QuantityFormatter.quantityToStackSize(x1) : DEFAULT);
	}

	/* reset overview-section (rank, total) pair */
	void reset()
	{
		total.setText(DEFAULT);
		rank.setText(DEFAULT);
	}

	/* creates an overview-section label of similar style */
	private JLabel createNewJLabel(String tooltip)
	{
		JLabel label = new JLabel(DEFAULT);

		label.setFont(FontManager.getRunescapeSmallFont());
		label.setToolTipText(tooltip);

		return label;
	}
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * Copyright (c) 2019, Bram91 <https://github.com/bram91>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.ui;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.ui.clans.TempleClans;
import com.templeosrs.ui.competitions.TempleCompetitions;
import com.templeosrs.ui.ranks.TempleRanks;
import java.awt.BorderLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.time.Instant;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.border.EmptyBorder;
import static net.runelite.client.RuneLite.SCREENSHOT_DIR;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

public class TempleOSRSPanel extends PluginPanel
{
	public static final String DEFAULT = "--";

	private static final String SCREENSHOTS = SCREENSHOT_DIR + File.separator + "Temple-Snapshots" + File.separator;

	public final TempleRanks ranks;

	public final TempleClans groups;

	public final TempleCompetitions competitions;

	public final MaterialTabGroup tabGroup;

	public final MaterialTab ranksTab;

	public final MaterialTab groupsTab;

	public final MaterialTab competitionsTab;

	@Inject
	public TempleOSRSPanel(TempleRanks ranks, TempleClans groups, TempleCompetitions competitions)
	{
		this.ranks = ranks;
		this.groups = groups;
		this.competitions = competitions;

		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		getScrollPane().setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* material-tab-group for each API Endpoint (Players, Groups, Competitions)*/
		JPanel display = new JPanel();
		tabGroup = new MaterialTabGroup(display);

		ranksTab = new MaterialTab("Ranks", tabGroup, ranks);
		groupsTab = new MaterialTab("Clans", tabGroup, groups);
		competitionsTab = new MaterialTab("Competitions", tabGroup, competitions);

		tabGroup.addTab(ranksTab);
		tabGroup.addTab(groupsTab);
		tabGroup.addTab(competitionsTab);

		tabGroup.select(ranksTab);

		layoutPanel.add(tabGroup);
		layoutPanel.add(display);
		layoutPanel.add(buildScreenshots());

		add(layoutPanel);
	}

	/* build screenshots button */
	private JPanel buildScreenshots()
	{
		JPanel saveLayout = new JPanel(new BorderLayout());
		saveLayout.setBorder(new EmptyBorder(5, 5, 5, 5));
		saveLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* create menu and menu-options */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem takeScreenshot = new JMenuItem();
		takeScreenshot.setText("Take Screenshot of current view...");
		takeScreenshot.addActionListener(e -> screenshot(this));
		menu.add(takeScreenshot);

		JMenuItem openFolder = new JMenuItem();
		openFolder.setText("Open screenshot folder...");
		openFolder.addActionListener(e -> {
			if (SCREENSHOT_DIR.exists() || SCREENSHOT_DIR.mkdirs())
			{
				LinkBrowser.open(SCREENSHOT_DIR.getAbsolutePath());
			}
		});
		menu.add(openFolder);

		/* build button and add menu options to take-snapshot/open-snapshots-folder */
		JButton screenshotButton = new JButton();
		screenshotButton.setBorder(new EmptyBorder(5, 5, 5, 5));
		screenshotButton.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "save.png")));
		screenshotButton.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		screenshotButton.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(screenshotButton, e.getX(), e.getY());
			}
		});
		saveLayout.add(screenshotButton, BorderLayout.WEST);

		return saveLayout;
	}

	/* take a perfectly cropped image of the plugin-layout */
	private void screenshot(JPanel panel)
	{
		/* use epoch-time as unique file-name */
		String timestamp = String.valueOf(Instant.now().getEpochSecond());

		/* create directory if not exists,
		 * continue if success */
		File directory = new File(SCREENSHOTS);
		if (directory.exists() || directory.mkdirs())
		{
			/* create image */
			BufferedImage img = new BufferedImage(panel.getSize().width, panel.getSize().height, BufferedImage.TYPE_INT_RGB);
			panel.paint(img.createGraphics());
			File imageFile = new File(SCREENSHOTS + timestamp + ".png");

			/* attempt to save image-file to directory */
			try
			{
				if (imageFile.createNewFile())
				{
					ImageIO.write(img, "png", imageFile);
				}
			}
			catch (Exception ignored)
			{

			}
		}
	}
}

package com.templeosrs.util.api;

import com.google.gson.annotations.SerializedName;
import lombok.Value;

@Value
public class APIError
{
	@SerializedName("Code")
	int code;

	@SerializedName("Message")
	String message;

	public String toString()
	{
		return "HTTP " + code + ": " + message;
	}
}
package com.templeosrs.util.api;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class QuadraticBackoffStrategy
{
	@Getter
	@Setter
	private boolean submitting = false;

	private int requestAttemptCount = 0;
	private int cycleCount = 0;

	public void reset()
	{
		submitting = false;
		requestAttemptCount = 0;
		cycleCount = 0;
	}

	public void beginNewRequestAttempt()
	{
		requestAttemptCount++;
	}

	public void finishCycle()
	{
		submitting = false;
	}

	public boolean shouldSkipRequest()
	{
		cycleCount++;

		final boolean shouldSkip = Math.pow((int) Math.sqrt(cycleCount), 2) != cycleCount;

		if (shouldSkip)
		{
			setSubmitting(false);

			log.debug(" Skipping request due to backoff configuration");
		}
		else
		{
			beginNewRequestAttempt();
		}

		return shouldSkip;
	}

	public boolean isRequestLimitReached()
	{
		int maxRetries = 3;
		final boolean isRequestLimitReached = requestAttemptCount >= maxRetries;

		if (isRequestLimitReached)
		{
			log.error(" Maximum number of retries reached; aborting request!");

			reset();
		}

		return isRequestLimitReached;
	}
}

package com.templeosrs.util.api;

import com.google.gson.Gson;
import java.io.IOException;
import java.util.Objects;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import static net.runelite.http.api.RuneLiteAPI.JSON;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.jetbrains.annotations.NotNull;

@Slf4j
public class RequestManager
{
	protected final String scheme = "https";
	
	protected final String host = "templeosrs.com";

	@Inject
	OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	private Request.Builder buildRequest(@NotNull HttpUrl url)
	{
		String PLUGIN_USER_AGENT = "TempleOSRS RuneLite Plugin Collection Log Sync - For any issues/abuse Contact 44mikael on Discord (https://www.templeosrs.com)";

		return new Request.Builder()
			.addHeader("User-Agent", PLUGIN_USER_AGENT)
			.url(url);
	}

	/**
	 * Initiates a synchronous request with no timeout.
	 *
	 * @param request The request to be sent.
	 * @return The request data.
	 * @throws IOException The request error.
	 */
	private String doRequest(Request request) throws IOException
	{
		try (Response response = okHttpClient.newCall(request).execute())
		{
			if (!response.isSuccessful())
			{
				throw new IOException(String.format("HTTP error fetching %s: %s", request.url(), response.code()));
			}

			String body = Objects.requireNonNull(response.body()).string();

			if (body.isEmpty())
			{
				throw new IOException(String.format("Empty response body was returned from %s", request.url()));
			}

			return body;
		}
	}

	/**
	 * Initiates a synchronous GET request.
	 *
	 * @param url The URL to send the request to.
	 */
	protected String get(@NotNull HttpUrl url) throws IOException
	{
		final Request request = buildRequest(url).get().build();

		return doRequest(request);
	}

	/**
	 * Initiates a synchronous POST request with the given data.
	 *
	 * @param url  The URL to send the request to.
	 * @param data The data to be sent in the request body.
	 */
	protected String post(@NotNull HttpUrl url, @NotNull Object data) throws IOException
	{
		final Request request = buildRequest(url)
			.post(RequestBody.create(JSON, gson.toJson(data)))
			.build();

		return doRequest(request);
	}
}

package com.templeosrs.util.clan;

import com.google.gson.Gson;
import java.util.Objects;

public class TempleClan
{
	public boolean error = false;

	public TempleClanOverviewResponse clanOverview;

	public TempleClanAchievementResponse clanAchievements;

	public TempleClanCurrentTopResponse clanCurrentTopEhp;

	public TempleClanCurrentTopResponse clanCurrentTopEhb;

	public TempleClan(String clanOverviewJSON, String clanAchievementsJSON, String clanCurrentTopEhpJSON, String clanCurrentTopEhbJSON, Gson gson)
	{
		clanOverview = gson.fromJson(clanOverviewJSON, TempleClanOverviewResponse.class);

		clanAchievements = gson.fromJson(clanAchievementsJSON, TempleClanAchievementResponse.class);

		clanCurrentTopEhp = gson.fromJson(clanCurrentTopEhpJSON, TempleClanCurrentTopResponse.class);

		clanCurrentTopEhb = gson.fromJson(clanCurrentTopEhbJSON, TempleClanCurrentTopResponse.class);

		if (Objects.nonNull(clanOverview.error))
		{
			error = true;
		}
	}
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanAchievement
{
	@SerializedName("Username")
	public String username;

	@SerializedName("Date")
	public String date;

	@SerializedName("Skill")
	public String skill;

	@SerializedName("Type")
	public String type;

	@SerializedName("Xp")
	public Long xp;
}


package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;
import java.util.List;

public class TempleClanAchievementResponse
{
	@SerializedName("data")
	public List<TempleClanAchievement> data = null;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanCurrentTopPlayer
{
	@SerializedName("player")
	public String player;

	@SerializedName("xp")
	public Double xp;

	@SerializedName("rank")
	public Integer rank;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;
import java.util.Map;

public class TempleClanCurrentTopResponse
{
	@SerializedName(value = "Day", alternate = {"Week", "Month"})
	public Map<String, TempleClanCurrentTopPlayer> list;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanOverviewData
{
	@SerializedName("info")
	public TempleClanOverviewInfo info;

	@SerializedName("members")
	public String[] members;

	@SerializedName("leaders")
	public String[] leaders;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanOverviewInfo
{
	@SerializedName("id")
	public Integer id;

	@SerializedName("name")
	public String name;

	@SerializedName("youtube_link")
	public String youtubeLink;

	@SerializedName("twitter_link")
	public String twitterLink;

	@SerializedName("twitch_link")
	public String twitchLink;

	@SerializedName("discord_link")
	public String discordLink;

	@SerializedName("forum_link")
	public String forumLink;

	@SerializedName("total_xp")
	public Long totalXp;

	@SerializedName("average_xp")
	public Long averageXp;

	@SerializedName("total_ehp")
	public Double totalEhp;

	@SerializedName("average_ehp")
	public Double averageEhp;

	@SerializedName("total_ehb")
	public Double totalEhb;

	@SerializedName("average_ehb")
	public Double averageEhb;

	@SerializedName("clan_type")
	public String clanType;

	@SerializedName("member_count")
	public Integer memberCount;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TempleClanOverviewResponse
{
	@SerializedName("data")
	public TempleClanOverviewData data;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.collections.autosync;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;
import static net.runelite.client.util.Text.removeTags;

@Slf4j
public class CollectionLogAutoSyncChatMessageSubscriber
{
	private final Pattern NEW_COLLECTION_LOG_ITEM_PATTERN = Pattern.compile("New item added to your collection log: (.*)");

	@Inject
	private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

	/**
	 * This method watches for in-game chat messages that match the new collection log item pattern.
	 * If a matching message is found, it extracts the item name and adds it to the obtainedItemNames set,
	 * which is then used by the ItemContainerChanged and NpcLootReceived events to determine if the item should be synced.
	 */
	@Subscribe
	private void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		Matcher matcher = NEW_COLLECTION_LOG_ITEM_PATTERN.matcher(chatMessage.getMessage());

		if (matcher.matches())
		{
			String itemName = removeTags(matcher.group(1));

			collectionLogAutoSyncManager.obtainedItemNames.add(itemName);
		}
	}
}

package com.templeosrs.util.collections.autosync;

import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.collections.CollectionLogManager;
import java.util.Set;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
public class CollectionLogAutoSyncConfigChecker
{
	/**
	 * Potential values are:
	 * 0 = no notification
	 * 1 = chat notification only
	 * 2 = popup notification only
	 * 3 = chat and popup
	 * <p>
	 * We only care about 1 and 3 to indicate chat message notifications are enabled.
	 */
	private static final Set<Integer> enabledCollectionLogNotificationSettingValues = Set.of(1, 3);

	@Inject
	private Client client;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private TempleOSRSPlugin templeOSRSPlugin;

	@Inject
	private CollectionLogManager collectionLogManager;

	@Inject
	private LoggedInState loggedInState;
	
	private int lastShownCollectionLogSettingWarningTick = -1;

	void startUp()
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			collectionLogManager.getClientThread().invoke(() -> {
				checkAndWarnForCollectionLogNotificationSetting(client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM));
			});
		}
	}

	void shutDown()
	{
		lastShownCollectionLogSettingWarningTick = -1;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		GameState gameState = event.getGameState();

		if (gameState == GameState.CONNECTION_LOST || gameState == GameState.HOPPING || client.getGameState() == GameState.LOGGING_IN)
		{
			lastShownCollectionLogSettingWarningTick = client.getTickCount(); // avoid warning during DC, hopping or logging in
		}

		if (gameState == GameState.LOGIN_SCREEN)
		{
			lastShownCollectionLogSettingWarningTick = -1;
		}
	}

	/**
	 * Checks for OPTION_COLLECTION_NEW_ITEM varbit value changes and runs the warning message check.
	 * This is also ran when logging in, as the game doesn't load varbits immediately.
	 * Don't read varbits during a world hop because they seem to always be 0
	 */
	@Subscribe
	private void onVarbitChanged(VarbitChanged varbitChanged)
	{
		if (varbitChanged.getVarbitId() == VarbitID.OPTION_COLLECTION_NEW_ITEM && client.getGameState() != GameState.HOPPING)
		{
			checkAndWarnForCollectionLogNotificationSetting(varbitChanged.getValue());
		}
	}

	/**
	 * Warns user on config changes that auto sync requires a specific in-game setting to be enabled.
	 */
	@Subscribe
	private void onConfigChanged(ConfigChanged event)
	{
		// Exit if setting change isn't for auto sync, player isn't logged in or the required setting is already on
		if (!event.getGroup().equals(TempleOSRSConfig.TEMPLE_OSRS_CONFIG_GROUP) || !event.getKey().equals("autoSyncClog") || loggedInState.isLoggedOut() || !templeOSRSPlugin.getConfig().autoSyncClog())
		{
			return;
		}

		collectionLogManager.getClientThread().invoke(() -> {
			final int SETTING_STATUS = client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM);
			final boolean REQUIRED_SETTING_DISABLED = !enabledCollectionLogNotificationSettingValues.contains(SETTING_STATUS);

			if (REQUIRED_SETTING_DISABLED)
			{
				lastShownCollectionLogSettingWarningTick = client.getTickCount();
				sendEnableCollectionLogSettingsMessage();
			}
		});
	}

	/**
	 * If the auto-sync clog option is enabled, the warning has not been shown recently, and the
	 * clog notification option is disabled, shows a warning to the player to tell them to enable the in-game option.
	 */
	private void checkAndWarnForCollectionLogNotificationSetting(int collectionLogOptionVarbitValue)
	{
		if (
			!templeOSRSPlugin.getConfig().autoSyncClog() ||
				loggedInState.isLoggedOut() ||
				(lastShownCollectionLogSettingWarningTick != -1 && client.getTickCount() - lastShownCollectionLogSettingWarningTick < 16) ||
				enabledCollectionLogNotificationSettingValues.contains(collectionLogOptionVarbitValue)
		)
		{
			return;
		}

		lastShownCollectionLogSettingWarningTick = client.getTickCount();
		sendEnableCollectionLogSettingsMessage();
	}

	private void sendEnableCollectionLogSettingsMessage()
	{
		String highlightedMessage = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append("Please enable \"Collection log - New addition notification\" in your game settings for " +
				"TempleOSRS to automatically sync your collection log!")
			.build();

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(highlightedMessage)
			.build());
	}
}

package com.templeosrs.util.collections.autosync;

import com.templeosrs.util.api.QuadraticBackoffStrategy;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import java.util.HashSet;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class CollectionLogAutoSyncGameTickSubscriber
{
	@Inject
	private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

	@Inject
	private CollectionLogManager collectionLogManager;

	@Inject
	private Client client;

	@Inject
	private ScheduledExecutorService scheduledExecutorService;

	/**
	 * Listens for game ticks and checks if the sync countdown has completed.
	 * Once the countdown is complete, and there are items pending a sync
	 * it will upload any newly obtained items to the server.
	 */
	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		QuadraticBackoffStrategy backoffStrategy = collectionLogAutoSyncManager.getBackoffStrategy();

		if (backoffStrategy.isRequestLimitReached())
		{
			collectionLogAutoSyncManager.clearSyncCountdown();
			return;
		}

		if (backoffStrategy.isSubmitting() || collectionLogAutoSyncManager.isComputingDiff())
		{
			return;
		}

		final Integer gameTickToSync = collectionLogAutoSyncManager.getGameTickToSync();
		final HashSet<ObtainedCollectionItem> pendingSyncItems = collectionLogAutoSyncManager.getPendingSyncItems();

		// Add any diffed items to the pendingSync list when the log has been opened
		if (
			gameTickToSync != null &&
				client.getTickCount() >= gameTickToSync &&
				collectionLogAutoSyncManager.isLogOpenAutoSync() &&
				pendingSyncItems.isEmpty()
		)
		{
			collectionLogAutoSyncManager.setComputingDiff(true);
			scheduledExecutorService.execute(collectionLogAutoSyncManager::computeCollectionLogDiff);

			return;
		}

		if (gameTickToSync == null || pendingSyncItems.isEmpty())
		{
			return;
		}

		// Sync new collection log items when the game has reached correct tick.
		if (client.getTickCount() >= gameTickToSync)
		{
			backoffStrategy.setSubmitting(true);
			scheduledExecutorService.execute(collectionLogAutoSyncManager::uploadObtainedCollectionLogItems);
		}
	}
}

package com.templeosrs.util.collections.autosync;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import java.util.Arrays;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;

@Slf4j
public class CollectionLogAutoSyncItemContainerChangedSubscriber
{
	private final Multiset<Integer> inventoryItems = HashMultiset.create();

	@Inject
	private CollectionLogAutoSyncManager collectionLogAutoSyncManager;
	
	@Inject
	private ItemManager itemManager;

	/**
	 * This method is called when the item container changes, specifically when the inventory is updated.
	 * If any items in the inventory match the newly obtained collection log item names,
	 * they are added to a list of items awaiting a server sync and the sync countdown is started.
	 */
	@Subscribe
	private void onItemContainerChanged(ItemContainerChanged itemContainerChanged)
	{
		if (itemContainerChanged.getContainerId() != InventoryID.INV)
		{
			return;
		}

		final ItemContainer inventory = itemContainerChanged.getItemContainer();
		final Multiset<Integer> currentInventoryItems = HashMultiset.create();

		Arrays.stream(inventory.getItems()).forEach(
			item -> currentInventoryItems.add(item.getId(), item.getQuantity())
		);

		final Multiset<Integer> inventoryDifference = Multisets.difference(currentInventoryItems, inventoryItems);

		final int previousPendingSyncItemsCount = collectionLogAutoSyncManager.pendingSyncItems.size();

		inventoryDifference.entrySet().forEach(item -> {
			String itemName = itemManager.getItemComposition(item.getElement()).getName();
			int itemId = item.getElement();
			int itemCount = item.getCount();

			if (collectionLogAutoSyncManager.obtainedItemNames.contains(itemName))
			{
				collectionLogAutoSyncManager.pendingSyncItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
				collectionLogAutoSyncManager.obtainedItemNames.remove(itemName);
			}
		});

		// Overwrite the cached inventory items with the current inventory items
		// to provide a comparator for the next inventory change event
		inventoryItems.clear();
		inventoryItems.addAll(currentInventoryItems);

		if (previousPendingSyncItemsCount < collectionLogAutoSyncManager.pendingSyncItems.size())
		{
			collectionLogAutoSyncManager.startSyncCountdown();
		}
	}
}

package com.templeosrs.util.collections.autosync;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.gson.Gson;
import com.templeosrs.util.api.APIError;
import com.templeosrs.util.api.QuadraticBackoffStrategy;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.CollectionLogRequestManager;
import com.templeosrs.util.collections.data.CollectionLogSyncResponse;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.data.PlayerProfile;
import com.templeosrs.util.collections.database.CollectionDatabase;
import java.io.IOException;
import java.sql.Timestamp;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import lombok.Getter;
import lombok.Setter;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import org.jetbrains.annotations.Nullable;

@Slf4j
public class CollectionLogAutoSyncManager
{
	@Getter
	protected final HashSet<String> obtainedItemNames = new HashSet<>();

	/**
	 * Keeps track of what item IDs are pending a server sync
	 */
	@Getter
	protected final HashSet<ObtainedCollectionItem> pendingSyncItems = new HashSet<>();

	@Getter
	QuadraticBackoffStrategy backoffStrategy = new QuadraticBackoffStrategy();

	@Inject
	private CollectionLogAutoSyncChatMessageSubscriber collectionLogAutoSyncChatMessageSubscriber;

	@Inject
	private CollectionLogAutoSyncItemContainerChangedSubscriber collectionLogAutoSyncItemContainerChangedSubscriber;

	@Inject
	private CollectionLogAutoSyncServerNpcLootSubscriber collectionLogAutoSyncServerNpcLootSubscriber;

	@Inject
	private CollectionLogAutoSyncGameTickSubscriber collectionLogAutoSyncGameTickSubscriber;

	@Inject
	private CollectionLogAutoSyncConfigChecker collectionLogAutoSyncConfigChecker;

	@Inject
	private LoggedInState loggedInState;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CollectionLogRequestManager requestManager;

	@Inject
	private CollectionLogManager collectionLogManager;

	@Inject
	private Gson gson;

	@Getter
	@Nullable
	private Integer gameTickToSync;

	@Getter
	@Setter
	private boolean triggerSyncAllowed;

	@Getter
	@Setter
	private boolean logOpenAutoSync;

	@Getter
	@Setter
	private boolean computingDiff;

	public void startUp()
	{
		eventBus.register(this);
		eventBus.register(collectionLogAutoSyncChatMessageSubscriber);
		eventBus.register(collectionLogAutoSyncItemContainerChangedSubscriber);
		eventBus.register(collectionLogAutoSyncServerNpcLootSubscriber);
		eventBus.register(collectionLogAutoSyncGameTickSubscriber);
		eventBus.register(collectionLogAutoSyncConfigChecker);
		eventBus.register(loggedInState);

		collectionLogAutoSyncConfigChecker.startUp();
	}

	public void shutDown()
	{
		eventBus.unregister(this);
		eventBus.unregister(collectionLogAutoSyncChatMessageSubscriber);
		eventBus.unregister(collectionLogAutoSyncItemContainerChangedSubscriber);
		eventBus.unregister(collectionLogAutoSyncServerNpcLootSubscriber);
		eventBus.unregister(collectionLogAutoSyncGameTickSubscriber);
		eventBus.unregister(collectionLogAutoSyncConfigChecker);
		eventBus.unregister(loggedInState);

		collectionLogAutoSyncConfigChecker.shutDown();

		obtainedItemNames.clear();
		clearSyncCountdown();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() == InterfaceID.COLLECTION)
		{
			setLogOpenAutoSync(true);
			setTriggerSyncAllowed(true);

			// Clear the previously obtained item list to avoid duplicating items when counts change
			collectionLogManager.getObtainedCollectionLogItems().clear();
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		if (scriptPostFired.getScriptId() == 7797 && isTriggerSyncAllowed())
		{
			clientThread.invokeLater(() -> {
				client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
				client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Back", null);

				setTriggerSyncAllowed(false);

				gameTickToSync = client.getTickCount() + 3;
			});
		}
	}

	/**
	 * Starts the sync countdown.
	 * This utilises a 17-tick delay (which corresponds to a roughly 10-second wait) as a way to batch requests.
	 * This is useful for when multiple items are obtained in quick succession, such as Chompy Hats.
	 */
	public void startSyncCountdown()
	{
		final int syncDelayInTicks = 17;

		gameTickToSync = client.getTickCount() + syncDelayInTicks;
	}

	/**
	 * Resets the sync countdown.
	 * Used after the request has successfully completed.
	 */
	public void clearSyncCountdown()
	{
		backoffStrategy.reset();
		setLogOpenAutoSync(false);
		gameTickToSync = null;
	}

	public void computeCollectionLogDiff()
	{
		try
		{
			String username = client.getLocalPlayer().getName();

			if (username == null || !CollectionDatabase.hasPlayerData(username))
			{
				log.debug("No saved log items were found, falling back to a full sync for {}", username);

				clearSyncCountdown();

				return;
			}

			log.debug("Computing collection log diff for {}", username);

			Set<ObtainedCollectionItem> obtainedCollectionLogItems = collectionLogManager.getObtainedCollectionLogItems();

			final Multiset<Integer> collectionLogItemIdCountMap = HashMultiset.create();

			for (ObtainedCollectionItem item : obtainedCollectionLogItems)
			{
				final int itemId = item.getId();
				final int itemCount = item.getCount();

				collectionLogItemIdCountMap.add(itemId, itemCount);
			}

			final Multiset<Integer> itemDiff = CollectionDatabase.getCollectionLogDiff(username, collectionLogItemIdCountMap);

			if (itemDiff == null || itemDiff.isEmpty())
			{
				log.debug("No log items have been changed since the last sync for {}", username);

				// No items to sync, stop processing
				clearSyncCountdown();

				return;
			}

			log.debug("Found {} changed log item(s) since the last sync: {}", itemDiff.elementSet().size(), itemDiff);

			// Add the log items found in the diff to the pending sync items set
			obtainedCollectionLogItems
				.stream()
				// Name check isn't technically needed here, but it helps suppress warnings
				.filter(item -> itemDiff.contains(item.getId()) && item.getName() != null)
				.map(item -> new ObtainedCollectionItem(item.getId(), item.getName(), item.getCount()))
				.forEach(pendingSyncItems::add);
		}
		finally
		{
			setComputingDiff(false);
		}
	}

	/**
	 * Uploads the obtained collection log items to the server.
	 * This is called when the sync countdown has completed and there are items pending a sync.
	 */
	@Synchronized
	public void uploadObtainedCollectionLogItems()
	{
		if (backoffStrategy.shouldSkipRequest())
		{
			return;
		}

		String username = client.getLocalPlayer().getName();

		if (username == null)
		{
			return;
		}

		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
		PlayerProfile profileKey = new PlayerProfile(username, profileType);

		PlayerDataSync submission = new PlayerDataSync(
			profileKey.getUsername(),
			profileKey.getProfileType().name(),
			client.getAccountHash(),
			pendingSyncItems
		);

		try
		{
			String response = requestManager.uploadObtainedCollectionLogItems(submission);

			CollectionLogSyncResponse collectionLogSyncResponse = gson.fromJson(response, CollectionLogSyncResponse.class);
			String lastChangedTimestamp = getLastChangedTimestamp(collectionLogSyncResponse, response);

			log.debug("response: {}, lastChanged: {}", response, lastChangedTimestamp);

			// Saves the new/updated items to the API cache to prevent refetching the entire log
			CollectionDatabase.upsertItemsBatch(username, pendingSyncItems, Timestamp.valueOf(lastChangedTimestamp));

			obtainedItemNames.clear();
			pendingSyncItems.clear();

			clearSyncCountdown();

			log.debug("Successfully synchronised new log items for {}", submission.getUsername());
		}
		catch (IOException | NullPointerException e)
		{
			log.error(" Failed to upload obtained collection log items: {}", e.getMessage());
		}
		finally
		{
			backoffStrategy.finishCycle();
		}
	}

	private String getLastChangedTimestamp(CollectionLogSyncResponse collectionLogSyncResponse, String response) throws IOException
	{
		APIError error = collectionLogSyncResponse.getError();
		CollectionLogSyncResponse.Data data = collectionLogSyncResponse.getData();

		if (error == null && data == null)
		{
			clearSyncCountdown();

			throw new NullPointerException("Unexpected response format from the collection log sync endpoint: " + response);
		}

		if (error != null)
		{
			clearSyncCountdown();

			throw new IOException(String.valueOf(error));
		}

		return data.getLastChanged();
	}
}

package com.templeosrs.util.collections.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemManager;

@Slf4j
public class CollectionLogAutoSyncServerNpcLootSubscriber
{
	@Inject
	private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

	@Inject
	private ItemManager itemManager;

	/**
	 * This method is called when an NPC loot event is received.
	 * If any items in the loot match the newly obtained collection log item names,
	 * they are added to a list of items awaiting a server sync and the sync countdown is started.
	 */
	@Subscribe
	private void onServerNpcLoot(ServerNpcLoot serverNpcLoot)
	{
		if (collectionLogAutoSyncManager.obtainedItemNames.isEmpty())
		{
			return;
		}

		final int previousPendingSyncItemsCount = collectionLogAutoSyncManager.pendingSyncItems.size();

		serverNpcLoot.getItems().forEach(item ->
		{
			final int itemId = item.getId();
			final int itemCount = item.getQuantity();
			final String itemName = itemManager.getItemComposition(itemId).getName();

			if (collectionLogAutoSyncManager.obtainedItemNames.contains(itemName))
			{
				collectionLogAutoSyncManager.pendingSyncItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
				collectionLogAutoSyncManager.obtainedItemNames.remove(itemName);
			}
		});

		if (previousPendingSyncItemsCount < collectionLogAutoSyncManager.pendingSyncItems.size())
		{
			collectionLogAutoSyncManager.startSyncCountdown();
		}
	}
}

package com.templeosrs.util.collections.autosync;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;

@Singleton
public class LoggedInState
{
	private static final int LOGGED_OUT = -1;

	@Inject
	private Client client;

	private int lastLoggedInTick = LOGGED_OUT;

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		setForCurrentGameState(event.getGameState());
	}

	public void setForCurrentGameState(GameState gameState)
	{
		if (gameState == GameState.LOGGED_IN)
		{
			setLastLoginTick(client.getTickCount());
		}
		else
		{
			setLoggedOut();
		}
	}

	public boolean isLoggedOut()
	{
		return this.lastLoggedInTick == LOGGED_OUT;
	}

	public boolean onlyJustLoggedIn(int tickWindow)
	{
		return client.getTickCount() - this.lastLoggedInTick < tickWindow;
	}

	public void setLoggedOut()
	{
		this.lastLoggedInTick = LOGGED_OUT;
	}

	public void setLastLoginTick(int lastLoggedInTick)
	{
		this.lastLoggedInTick = lastLoggedInTick;
	}
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class PlayerDataSync
{
	private String username;
	private String profile;
	private long playerHash;
	private Set<ObtainedCollectionItem> items;
}
package com.templeosrs.util.collections.chatcommands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.utils.CollectionLogCategoryUtils;
import com.templeosrs.util.collections.utils.PlayerNameUtils;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.game.ItemManager;

@Slf4j
public abstract class ChatCommand
{
	/**
	 * If true, hide the message from all other players except the local player
	 */
	private final boolean onlyShowForLocalPlayer;

	/**
	 * The chat message that triggers the command, e.g. "!col help"
	 */
	public String trigger;

	/**
	 * The description given to the command when listed by the "!col help" command
	 */
	public String description;

	@Inject
	protected Client client;

	@Inject
	protected ClientThread clientThread;

	@Inject
	protected ChatMessageManager chatMessageManager;

	@Inject
	protected ItemManager itemManager;
	
	@Inject
	protected ItemSpriteManager itemSpriteManager;

	public ChatCommand(String trigger, String description, boolean onlyShowForLocalPlayer)
	{
		this.trigger = trigger;
		this.description = description;
		this.onlyShowForLocalPlayer = onlyShowForLocalPlayer;
	}

	/**
	 * Checks whether the message sender is the currently logged in player
	 *
	 * @param event the ChatMessage event
	 * @return true if the message sender if the currently logged in player
	 */
	public boolean isOtherPlayer(ChatMessage event)
	{
		String localName = PlayerNameUtils.normalizePlayerName(client.getLocalPlayer().getName());
		String senderName = PlayerNameUtils.normalizePlayerName(event.getName());

		return !senderName.equalsIgnoreCase(localName);
	}

	public String buildAvailableCategoriesMessage(String category)
	{
		return new ChatMessageBuilder()
			.append(ChatColorType.NORMAL)
			.append("Available ")
			.append(ChatColorType.HIGHLIGHT)
			.append(category)
			.append(ChatColorType.NORMAL)
			.append(" categories:")
			.build();
	}

	public void overwriteMessage(String newMessage, MessageNode messageNode)
	{
		messageNode.setRuneLiteFormatMessage(newMessage);
		client.refreshChat();
	}

	/**
	 * Outputs a list of all available collection log categories.
	 * As this is derived from the in-game cache,
	 * it will always be up-to-date with the latest changes (unless a new tab is added).
	 *
	 * @param categoryGroup The category group (i.e. tab) for which to list items
	 */
	public void listAvailableCollectionLogCategories(CollectionLogCategoryGroup categoryGroup)
	{
		clientThread.invoke(() -> {
			chatMessageManager.queue(
				QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(buildAvailableCategoriesMessage(categoryGroup.toString()))
					.build()
			);

			Set<String> categorySlugs = CollectionLogManager
				.getCollectionLogCategoryTabSlugs()
				.get(categoryGroup.getStructId());

			List<Integer> iconItemIds = categorySlugs.stream().map(slug -> {
				int structId = CollectionLogManager.getCollectionLogCategoryStructIdMap().get(slug);
				Set<Integer> categoryItems = CollectionLogManager.getCollectionLogCategoryItemMap().get(structId);

				return new ArrayList<>(categoryItems).get(0);
			}).collect(Collectors.toList());

			itemSpriteManager.loadItemSprites(iconItemIds);

			int i = 0;

			for (String categorySlug : categorySlugs)
			{
				int structId = CollectionLogManager.getCollectionLogCategoryStructIdMap().get(categorySlug);
				String categoryTitle = client.getStructComposition(structId).getStringValue(689);
				int iconIndex = itemSpriteManager.getItemSpriteIndexes().get(iconItemIds.get(i++));

				ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.img(iconIndex)
					.append(categoryTitle)
					.append(": ");

				Set<String> categoryAliases = CollectionLogCategoryUtils.INVERTED_ALIASES.get(categorySlug);

				chatMessageBuilder
					.append(ChatColorType.HIGHLIGHT)
					.append(
						categoryAliases == null
							? categorySlug
							: String.join(", ", categoryAliases)
					);

				chatMessageManager.queue(
					QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(chatMessageBuilder.build())
						.build()
				);
			}

			client.refreshChat();
		});
	}

	/**
	 * Executes the chat command handler.
	 * If it has been configured to only show for the current player, it will not be triggered for anyone else.
	 *
	 * @param event The chat message event
	 */
	public void execute(ChatMessage event)
	{
		if (onlyShowForLocalPlayer && isOtherPlayer(event))
		{
			return;
		}

		command(event);
	}

	public void command(ChatMessage event)
	{
	}

	public void shutDown()
	{
		itemSpriteManager.itemSpriteIndexes.clear();
		itemSpriteManager.loadedItemIds.clear();
	}
}

package com.templeosrs.util.collections.chatcommands;

import com.templeosrs.TempleOSRSConfig;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.Text;

@Slf4j
public class ChatItemNameTooltip extends Overlay
{
	private final Pattern itemIdPattern = Pattern.compile("<img=(\\d+)>(x\\d+(,\\s)?)");

	private final Pattern prefixPattern = Pattern.compile("([\\w\\s'()]+ \\(\\d+/\\d+\\): )");

	@Inject
	private TooltipManager tooltipManager;

	@Inject
	private ItemSpriteManager itemSpriteManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private Client client;

	@Inject
	private TempleOSRSConfig config;

	@Inject
	private ChatItemNameTooltip()
	{
		setPosition(OverlayPosition.TOOLTIP);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(PRIORITY_MED);
	}

	/**
	 * @param parent  The parent widget
	 * @param message The message widget
	 * @return true if the message is currently visible on the screen, else false.
	 */
	private boolean isMessageVisible(final Widget parent, final Widget message)
	{
		final int childNorthCoordinate = message.getRelativeY();
		final int childSouthCoordinate = childNorthCoordinate + message.getHeight();

		final int currentScrollNorthCoordinate = parent.getScrollY();
		final int currentScrollSouthCoordinate = currentScrollNorthCoordinate + parent.getHeight();

		if (childSouthCoordinate < currentScrollNorthCoordinate)
		{
			// The end of the message has been scrolled past
			return false;
		}

		// Returns true if the start of the message is currently visible, else false
		return childNorthCoordinate <= currentScrollSouthCoordinate;
	}

	/**
	 * Parses a chat message for its containing item icons, and map them to a matrix of rows & icon bounds.
	 *
	 * @param messageWidget The matched !col command message widget
	 * @param messagePrefix The text matching the command prefix, e.g. "Kree'arra (1/9): "
	 * @return A list of rows containing the icon bounds in that row
	 */
	private List<Map<Integer, Rectangle>> mapItemIcons(
		final Widget messageWidget,
		final String messagePrefix
	)
	{
		final Matcher iconIdMatcher = itemIdPattern.matcher(messageWidget.getText());
		final List<Map<Integer, Rectangle>> itemRows = new ArrayList<>(List.of(new HashMap<>()));

		final int textOffset = messageWidget.getFont().getTextWidth(messagePrefix);
		final int nbspWidth = messageWidget.getFont().getTextWidth(" ");

		final Rectangle chatMessageBounds = messageWidget.getBounds();
		final int chatMessageEastCoordinate = chatMessageBounds.x + chatMessageBounds.width;

		final AtomicInteger coordsX = new AtomicInteger(chatMessageBounds.x + textOffset);
		final AtomicInteger coordsY = new AtomicInteger(chatMessageBounds.y);
		final AtomicInteger row = new AtomicInteger(0);

		while (iconIdMatcher.find())
		{
			final int iconId = Integer.parseInt(iconIdMatcher.group(1));
			final String itemText = iconIdMatcher.group(2);
			final int itemId = itemSpriteManager.getSpriteItemIds().get(iconId);

			final int textWidth = ItemSpriteManager.SPRITE_WIDTH + messageWidget.getFont().getTextWidth(itemText);

			// The line heights differ between the chatbox and private messages,
			// which causes the tooltips to become misaligned if not dynamically calculated.
			final int messageLineHeight = messageWidget.getLineHeight();

			// The game ignores whitespace when rendering text at the edge of the chatbox,
			// hence it is subtracted in the calculation.
			// Otherwise, the icon coordinates can deviate wildly in longer lists.
			if (coordsX.get() + textWidth - nbspWidth > chatMessageEastCoordinate)
			{
				// If the new item would escape the bounds, move it onto a new line
				coordsX.set(chatMessageBounds.x);
				coordsY.addAndGet(messageLineHeight);

				itemRows.add(row.addAndGet(1), new HashMap<>());
			}

			final Rectangle itemCoordinates = new Rectangle(
				coordsX.get(),
				coordsY.get(),
				ItemSpriteManager.SPRITE_WIDTH,
				messageLineHeight
			);

			coordsX.addAndGet(textWidth);

			itemRows.get(row.get()).put(itemId, itemCoordinates);
		}

		return itemRows;
	}

	/**
	 * When a !col command chat message row is hovered,
	 * check to see if an item icon is being hovered and return its item name.
	 *
	 * @param iconCoordinates A map of icons in the currently hovered chat message row
	 * @param mouseX          The current X coordinate of the mouse
	 * @return The item name of the currently hovered icon, if found
	 */
	@Nullable()
	private String findHoveredItemName(final Map<Integer, Rectangle> iconCoordinates, final int mouseX)
	{
		for (Map.Entry<Integer, Rectangle> iconEntry : iconCoordinates.entrySet())
		{
			final Rectangle iconBounds = iconEntry.getValue();

			final int iconWestCoordinate = iconBounds.x;
			final int iconEastCoordinate = iconWestCoordinate + iconBounds.width;

			// Y coordinate bounds are done by filtering the rows based on the icon height
			// All we need to do here is check whether the X coordinate is hovered
			if (iconWestCoordinate <= mouseX && iconEastCoordinate >= mouseX)
			{
				final int hoveredItemId = iconEntry.getKey();

				return itemManager.getItemComposition(hoveredItemId).getName();
			}
		}

		return null;
	}

	/**
	 * Iterates through a list of chat messages, adding tooltip listeners to matching !col commands
	 *
	 * @param chatMessages     The chat messages from the interface widget
	 * @param messageContainer The interface widget that should be used to determine bounds
	 * @param mousePosition    The current mouse position
	 */
	private void addTooltipToChatMessages(
		final Widget[] chatMessages,
		final Widget messageContainer,
		final Point mousePosition
	)
	{
		for (Widget chatMessage : chatMessages)
		{
			final String messageText = chatMessage.getText();

			if (messageText.isEmpty())
			{
				continue;
			}

			final String strippedMessageText = Text.removeTags(messageText);
			final Matcher prefixMatcher = prefixPattern.matcher(strippedMessageText);

			if (
				prefixMatcher.find() &&
					itemIdPattern.matcher(messageText).find() &&
					isMessageVisible(messageContainer, chatMessage)
			)
			{
				final Rectangle bounds = chatMessage.getBounds();

				if (!bounds.contains(mousePosition.getX(), mousePosition.getY()))
				{
					continue;
				}

				final String messagePrefix = prefixMatcher.group();
				final List<Map<Integer, Rectangle>> itemIconRows = mapItemIcons(chatMessage, messagePrefix);
				final int hoveredRow = Math.floorDiv((int) (mousePosition.getY() - bounds.getY()), chatMessage.getLineHeight());
				final String hoveredItemName = findHoveredItemName(itemIconRows.get(hoveredRow), mousePosition.getX());

				if (hoveredItemName != null)
				{
					tooltipManager.add(new Tooltip(hoveredItemName));
				}
			}
		}
	}

	@Override
	public Dimension render(final Graphics2D graphics)
	{
		final Point mousePosition = client.getMouseCanvasPosition();
		final Widget chatBoxWidget = client.getWidget(InterfaceID.Chatbox.UNIVERSE);
		final Widget chatBoxScrollAreaWidget = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
		final Widget privateChatWidget = client.getWidget(InterfaceID.PmChat.CONTAINER);

		if (
			chatBoxWidget == null ||
				chatBoxScrollAreaWidget == null ||
				privateChatWidget == null ||
				(
					!chatBoxScrollAreaWidget.contains(mousePosition) &&
						!privateChatWidget.contains(mousePosition)
				)
		)
		{
			return null;
		}

		final Widget[] chatMessages = chatBoxScrollAreaWidget.getChildren();
		final Widget[] privateChatMessages = privateChatWidget.getChildren();

		if (chatMessages != null && chatBoxScrollAreaWidget.contains(mousePosition))
		{
			addTooltipToChatMessages(chatMessages, chatBoxScrollAreaWidget, mousePosition);
		}

		if (
			privateChatMessages != null &&
				privateChatWidget.contains(mousePosition) &&
				!chatBoxWidget.contains(mousePosition)
		)
		{
			addTooltipToChatMessages(privateChatMessages, privateChatWidget, mousePosition);
		}

		return null;
	}
}

package com.templeosrs.util.collections.chatcommands;

import com.templeosrs.util.collections.chatcommands.commands.DisplayPlayerCollectionLogChatCommand;
import com.templeosrs.util.collections.chatcommands.commands.ListAllBossCategoriesChatCommand;
import com.templeosrs.util.collections.chatcommands.commands.ListAllCluesCategoriesChatCommand;
import com.templeosrs.util.collections.chatcommands.commands.ListAllCustomCategoriesChatCommand;
import com.templeosrs.util.collections.chatcommands.commands.ListAllHelpCommandsChatCommand;
import com.templeosrs.util.collections.chatcommands.commands.ListAllMinigamesCategoriesChatCommand;
import com.templeosrs.util.collections.chatcommands.commands.ListAllOtherCategoriesChatCommand;
import com.templeosrs.util.collections.chatcommands.commands.ListAllRaidsCategoriesChatCommand;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class CollectionLogChatCommandChatMessageSubscriber
{
	public static Map<String, ChatCommand> chatCommands = new LinkedHashMap<>();

	private final Set<ChatMessageType> allowedMessageTypes = Set.of(
		ChatMessageType.PUBLICCHAT,
		ChatMessageType.FRIENDSCHAT,
		ChatMessageType.PRIVATECHAT,
		ChatMessageType.PRIVATECHATOUT,
		ChatMessageType.CLAN_CHAT,
		ChatMessageType.CLAN_GIM_MESSAGE,
		ChatMessageType.CLAN_GIM_CHAT,
		ChatMessageType.CLAN_GUEST_CHAT
	);

	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private DisplayPlayerCollectionLogChatCommand displayPlayerCollectionLogChatCommand;

	@Inject
	private ListAllHelpCommandsChatCommand helpCommandsChatCommand;

	@Inject
	private ListAllBossCategoriesChatCommand bossCategoriesChatCommand;

	@Inject
	private ListAllCluesCategoriesChatCommand cluesCategoriesChatCommand;

	@Inject
	private ListAllRaidsCategoriesChatCommand raidsCategoriesChatCommand;

	@Inject
	private ListAllCustomCategoriesChatCommand customCategoriesChatCommand;

	@Inject
	private ListAllMinigamesCategoriesChatCommand minigamesCategoriesChatCommand;

	@Inject
	private ListAllOtherCategoriesChatCommand otherCategoriesChatCommand;

	public void startUp()
	{
		eventBus.register(this);

		chatCommands.put(displayPlayerCollectionLogChatCommand.trigger, displayPlayerCollectionLogChatCommand);
		chatCommands.put(helpCommandsChatCommand.trigger, helpCommandsChatCommand);
		chatCommands.put(bossCategoriesChatCommand.trigger, bossCategoriesChatCommand);
		chatCommands.put(raidsCategoriesChatCommand.trigger, raidsCategoriesChatCommand);
		chatCommands.put(cluesCategoriesChatCommand.trigger, cluesCategoriesChatCommand);
		chatCommands.put(minigamesCategoriesChatCommand.trigger, minigamesCategoriesChatCommand);
		chatCommands.put(otherCategoriesChatCommand.trigger, otherCategoriesChatCommand);
		chatCommands.put(customCategoriesChatCommand.trigger, customCategoriesChatCommand);
	}

	public void shutDown()
	{
		eventBus.unregister(this);

		chatCommands.values().forEach(ChatCommand::shutDown);
		chatCommands.clear();
	}

	@Subscribe(priority = -2) // Run after ChatMessageManager
	public void onChatMessage(ChatMessage event)
	{
		final ChatMessageType type = event.getType();
		final String rawMessage = event.getMessage().trim();

		final String COLLECTION_LOG_CHAT_TRIGGER = "!col ";

		// Only react to public, private, or clan chat messages that begin with "!col "
		if (!allowedMessageTypes.contains(type) || !rawMessage.toLowerCase().startsWith(COLLECTION_LOG_CHAT_TRIGGER))
		{
			return;
		}

		ChatCommand chatCommand = chatCommands.get(rawMessage.toLowerCase());

		if (chatCommand != null)
		{
			chatCommand.execute(event);

			return;
		}

		displayPlayerCollectionLogChatCommand.command(event);
	}

	/**
	 * Prevents the help commands from being rendered to the chat for anyone with the plugin installed
	 */
	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!event.getEventName().equals("chatFilterCheck"))
		{
			return;
		}

		int[] intStack = client.getIntStack();
		int intStackSize = client.getIntStackSize();
		Object[] objectStack = client.getObjectStack();
		int objectStackSize = client.getObjectStackSize();

		final int messageType = intStack[intStackSize - 2];
		String message = (String) objectStack[objectStackSize - 1];
		ChatMessageType chatMessageType = ChatMessageType.of(messageType);

		if (!allowedMessageTypes.contains(chatMessageType))
		{
			return;
		}

		Set<String> hiddenChatCommands = Set.of("!col list", "!col help");

		for (String hiddenChatCommand : hiddenChatCommands)
		{
			if (message.toLowerCase().startsWith(hiddenChatCommand))
			{
				intStack[intStackSize - 3] = 0;

				break;
			}
		}
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.collections.CollectionLogCategorySlug;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.CollectionLogRequestManager;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import com.templeosrs.util.collections.data.CollectionLogCategory;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.data.PlayerInfoResponse;
import com.templeosrs.util.collections.database.CollectionDatabase;
import com.templeosrs.util.collections.parser.CollectionParser;
import com.templeosrs.util.collections.services.CollectionLogService;
import com.templeosrs.util.collections.utils.CollectionLogCategoryUtils;
import com.templeosrs.util.collections.utils.PlayerNameUtils;
import java.io.IOException;
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.StructComposition;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

@Slf4j
public class DisplayPlayerCollectionLogChatCommand extends ChatCommand
{
	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ScheduledExecutorService scheduledExecutorService;

	@Inject
	private CollectionLogRequestManager collectionLogRequestManager;

	@Inject
	private TempleOSRSPlugin templeOSRSPlugin;

	@Inject
	private CollectionParser collectionParser;

	@Inject
	private CollectionLogService collectionLogService;

	public DisplayPlayerCollectionLogChatCommand()
	{
		super("!col ", "Displays the player's collection log for a given boss. May also be used to display other players' logs, e.g. !col kree CousinOfKos", false);
	}

	@Override
	public void command(ChatMessage event)
	{
		final String rawMessage = event.getMessage().trim();

		final String[] parts = rawMessage.substring(5).trim().split(" ", 2);

		if (parts.length == 0)
		{
			return;
		}

		// Normalize boss name
		final String bossInput = parts[0].trim().replace(' ', '_').toLowerCase();
		final CollectionLogCategory category = getCategoryFromMessageInput(bossInput);

		// For outgoing PMs, the message should show the current player's log,
		// but the event contains the recipient's name.
		final String senderName = event.getType() == ChatMessageType.PRIVATECHATOUT
			? client.getLocalPlayer().getName()
			: event.getName();

		// Determine target player (specified or sender)
		final String playerName = (parts.length == 2) ? parts[1].trim() : senderName;

		final String normalizedPlayerName = PlayerNameUtils.normalizePlayerName(playerName);  // Normalize the player name for the API call
		final String localName = PlayerNameUtils.normalizePlayerName(client.getLocalPlayer().getName());
		final boolean isLocalPlayer = normalizedPlayerName.equalsIgnoreCase(localName);

		if (category == null)
		{
			if (isLocalPlayer)
			{
				log.warn(" No alias or category found for {}", bossInput);

				final String errorMessage = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append("Use ")
					.append(ChatColorType.HIGHLIGHT)
					.append("!col help")
					.append(ChatColorType.NORMAL)
					.append(" to help find the correct category.")
					.build();

				chatMessageManager.queue(
					QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(errorMessage)
						.build()
				);
			}

			overwriteMessage(
				new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append(bossInput)
					.append(ChatColorType.NORMAL)
					.append(" is not a valid collection log category or alias.")
					.build(),
				event.getMessageNode()
			);

			return;
		}

		scheduledExecutorService.execute(() ->
		{
			final PlayerInfoResponse.Data playerInfo = getPlayerInfo(normalizedPlayerName, event);

			if (playerInfo == null)
			{
				// Error messages are handled when getting the player info
				return;
			}

			final String prettyPlayerName = playerInfo.getPlayerNameWithCapitalization();

			if (playerInfo.getCollectionLog().getLastChanged() == null)
			{
				overwriteMessage(
					new ChatMessageBuilder()
						.append(ChatColorType.NORMAL)
						.append("No TempleOSRS collection log found for ")
						.append(ChatColorType.HIGHLIGHT)
						.append(prettyPlayerName)
						.append(".")
						.build(),
					event.getMessageNode()
				);

				return;
			}

			final String lastChanged = playerInfo.getCollectionLog().getLastChanged();

			final boolean isDataStale = !collectionLogService.isDataFresh(normalizedPlayerName, lastChanged);
			final boolean hasLocalData = CollectionDatabase.hasPlayerData(normalizedPlayerName);
			final boolean shouldUpdate = !hasLocalData || isDataStale;

			if (shouldUpdate)
			{
				log.debug(" No local data for '{}', fetching from API...", normalizedPlayerName);
				final String json = collectionLogRequestManager.getPlayerCollectionLog(normalizedPlayerName);

				if (json == null)
				{
					log.warn(" No data fetched for user: {}", normalizedPlayerName);

					overwriteMessage(
						new ChatMessageBuilder()
							.append(ChatColorType.NORMAL)
							.append("Failed to fetch log for ")
							.append(ChatColorType.HIGHLIGHT)
							.append(prettyPlayerName)
							.append(ChatColorType.NORMAL)
							.append(".")
							.build(),
						event.getMessageNode()
					);

					return;
				}

				if (!isLocalPlayer)
				{
					CollectionDatabase.pruneOldPlayers(localName, templeOSRSPlugin.getConfig().maxCachedPlayers());
				}

				collectionParser.parseAndStore(PlayerNameUtils.normalizePlayerName(playerName), json);
			}
			else
			{
				log.debug(" Found cached data for '{}'", normalizedPlayerName);
			}

			// Fetch the requested category
			final Set<ObtainedCollectionItem> items = CollectionDatabase.getItemsByCategory(
				normalizedPlayerName,
				new LinkedHashSet<>(category.getItems())
			);

			itemSpriteManager.loadItemSprites(
				items
					.stream()
					.map(ObtainedCollectionItem::getId)
					.collect(Collectors.toList())
			);

			final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder();
			final String categoryName = category.getTitle();

			assert senderName != null;

			// If sender's name is same as the player being queried, omit the player's name
			if (!senderName.equalsIgnoreCase(playerName))
			{
				chatMessageBuilder
					.append(ChatColorType.HIGHLIGHT)
					.append(prettyPlayerName + "'s ")
					.append(categoryName)
					.append(ChatColorType.NORMAL);
			}
			else
			{
				chatMessageBuilder.append(categoryName);
			}

			chatMessageBuilder
				.append(getLogProgress(items.size(), category.getItems().size()))
				.append(": ");

			if (items.isEmpty())
			{
				chatMessageBuilder.append("No obtained collection log items.");
			}
			else
			{
				int i = 0;

				for (ObtainedCollectionItem item : items)
				{
					final Integer iconIndex = itemSpriteManager.getItemSpriteIndexes().get(item.getId());

					if (iconIndex != null)
					{
						chatMessageBuilder.img(iconIndex);
					}

					chatMessageBuilder
						.append("x")
						.append(String.valueOf(item.getCount()));

					if (i++ < items.size() - 1)
					{
						chatMessageBuilder.append(", ");
					}
				}
			}

			overwriteMessage(chatMessageBuilder.build(), event.getMessageNode());
		});
	}

	private PlayerInfoResponse.Data getPlayerInfo(String playerName, ChatMessage chatMessage)
	{
		try
		{
			return collectionLogRequestManager.getPlayerInfo(playerName);
		}
		catch (NullPointerException e)
		{
			overwriteMessage(
				new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append("Unable to find ")
					.append(ChatColorType.HIGHLIGHT)
					.append(playerName)
					.append(ChatColorType.NORMAL)
					.append(" on TempleOSRS.")
					.build(),
				chatMessage.getMessageNode()
			);
		}
		catch (IOException e)
		{
			overwriteMessage(
				new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append("Failed to fetch from TempleOSRS.")
					.build(),
				chatMessage.getMessageNode()
			);
		}

		return null;
	}

	private String getCategoryKeyFromMessageInput(String bossInput)
	{
		try
		{
			final CollectionLogCategorySlug categorySlug = Objects.requireNonNullElseGet(
				CollectionLogCategoryUtils.CATEGORY_ALIASES.get(bossInput),
				() -> CollectionLogCategorySlug.valueOf(bossInput)
			);

			return categorySlug.toString();
		}
		catch (IllegalArgumentException e)
		{
			return bossInput;
		}
	}

	private CollectionLogCategory getCategoryFromMessageInput(String bossInput)
	{
		final String categoryKey = getCategoryKeyFromMessageInput(bossInput);
		final CollectionLogCategory customCategory = CollectionLogCategoryUtils.CUSTOM_CATEGORIES.get(bossInput);

		if (customCategory != null)
		{
			return customCategory;
		}

		try
		{
			final int structId = CollectionLogManager.getCollectionLogCategoryStructIdMap().get(categoryKey);

			final StructComposition categoryStruct = client.getStructComposition(structId);
			final String categoryTitle = categoryStruct.getStringValue(689);
			final Set<Integer> categoryItems = CollectionLogManager.getCollectionLogCategoryItemMap().get(categoryStruct.getId());

			return new CollectionLogCategory(categoryTitle, categoryItems);
		}
		catch (NullPointerException e)
		{
			return null;
		}
	}

	private String getLogProgress(int acquiredItemsCount, int totalItemsCount)
	{
		if (acquiredItemsCount == 0)
		{
			return "";
		}

		return " (" + acquiredItemsCount + "/" + totalItemsCount + ")";
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.ChatMessage;

@Slf4j
public class ListAllBossCategoriesChatCommand extends ChatCommand
{
	public ListAllBossCategoriesChatCommand()
	{
		super("!col list bosses", "Lists all available boss categories", true);
	}

	@Override
	public void command(ChatMessage event)
	{
		listAvailableCollectionLogCategories(CollectionLogCategoryGroup.bosses);
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllCluesCategoriesChatCommand extends ChatCommand
{
	public ListAllCluesCategoriesChatCommand()
	{
		super("!col list clues", "Lists all available clues categories", true);
	}

	@Override
	public void command(ChatMessage event)
	{
		listAvailableCollectionLogCategories(CollectionLogCategoryGroup.clues);
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.chatcommands.ChatCommand;
import com.templeosrs.util.collections.data.CollectionLogCategory;
import com.templeosrs.util.collections.utils.CollectionLogCategoryUtils;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;

public class ListAllCustomCategoriesChatCommand extends ChatCommand
{
	public ListAllCustomCategoriesChatCommand()
	{
		super("!col list custom", "Lists all available custom categories", true);
	}

	@Override
	public void command(ChatMessage event)
	{
		clientThread.invoke(() -> {
			chatMessageManager.queue(
				QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage(buildAvailableCategoriesMessage("custom"))
					.build()
			);

			List<Integer> iconItemIds = CollectionLogCategoryUtils.CUSTOM_CATEGORIES
				.values()
				.stream()
				.map(item -> item.getItems().iterator().next())
				.collect(Collectors.toList());

			itemSpriteManager.loadItemSprites(iconItemIds);

			int i = 0;

			for (Map.Entry<String, CollectionLogCategory> customCategory : CollectionLogCategoryUtils.CUSTOM_CATEGORIES.entrySet())
			{
				int iconIndex = itemSpriteManager.getItemSpriteIndexes().get(iconItemIds.get(i++));

				chatMessageManager.queue(
					QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(
							new ChatMessageBuilder()
								.append(ChatColorType.NORMAL)
								.img(iconIndex)
								.append(customCategory.getValue().getTitle())
								.append(": ")
								.append(ChatColorType.HIGHLIGHT)
								.append(customCategory.getKey())
								.build()
						)
						.build()
				);
			}

			client.refreshChat();
		});
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.chatcommands.ChatCommand;
import com.templeosrs.util.collections.chatcommands.CollectionLogChatCommandChatMessageSubscriber;
import java.util.Map;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.Text;

public class ListAllHelpCommandsChatCommand extends ChatCommand
{
	public ListAllHelpCommandsChatCommand()
	{
		super("!col help", "Lists all available help commands", true);
	}

	@Override
	public void command(ChatMessage event)
	{
		clientThread.invoke(() -> {
			chatMessageManager.queue(
				QueuedMessage.builder()
					.type(ChatMessageType.CONSOLE)
					.runeLiteFormattedMessage("Available help commands:")
					.build()
			);

			for (Map.Entry<String, ChatCommand> helpCommandMessage : CollectionLogChatCommandChatMessageSubscriber.chatCommands.entrySet())
			{
				// Output a list of all available help commands, excluding the current one
				// (the player must already know the command to even trigger this)
				if (!helpCommandMessage.getKey().equals(this.trigger))
				{
					chatMessageManager.queue(
						QueuedMessage.builder()
							.type(ChatMessageType.CONSOLE)
							.runeLiteFormattedMessage(
								new ChatMessageBuilder()
									.append(ChatColorType.HIGHLIGHT)
									.append(helpCommandMessage.getKey())
									.append(": ")
									.append(ChatColorType.NORMAL)
									.append(Text.escapeJagex(helpCommandMessage.getValue().description))
									.build()
							)
							.build()
					);
				}
			}

			client.refreshChat();
		});
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllMinigamesCategoriesChatCommand extends ChatCommand
{
	public ListAllMinigamesCategoriesChatCommand()
	{
		super("!col list minigames", "Lists all available minigames categories", true);
	}

	@Override
	public void command(ChatMessage event)
	{
		listAvailableCollectionLogCategories(CollectionLogCategoryGroup.minigames);
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllOtherCategoriesChatCommand extends ChatCommand
{
	public ListAllOtherCategoriesChatCommand()
	{
		super("!col list other", "Lists all available other categories", true);
	}

	@Override
	public void command(ChatMessage event)
	{
		listAvailableCollectionLogCategories(CollectionLogCategoryGroup.other);
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllRaidsCategoriesChatCommand extends ChatCommand
{
	public ListAllRaidsCategoriesChatCommand()
	{
		super("!col list raids", "Lists all available raids categories", true);
	}

	@Override
	public void command(ChatMessage event)
	{
		listAvailableCollectionLogCategories(CollectionLogCategoryGroup.raids);
	}
}

package com.templeosrs.util.collections.chatcommands;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

@Slf4j
@Singleton
public class ItemSpriteManager
{
	public static final int SPRITE_WIDTH = 18;
	public static final int SPRITE_HEIGHT = 14;

	/**
	 * Maintain a map of item IDs to their respective index in the sprite list
	 */
	@Getter
	protected final Map<Integer, Integer> itemSpriteIndexes = new HashMap<>();

	/**
	 * Maintain a map of sprite indexes to their respective item IDs
	 */
	@Getter
	protected final Map<Integer, Integer> spriteItemIds = new HashMap<>();

	/**
	 * Maintain a list of previously seen item sprites to avoid loading them twice
	 */
	protected final Set<Integer> loadedItemIds = new HashSet<>();

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	/**
	 * Loads the in-game icon sprites for a given item list, ready to be used in the chat message.
	 *
	 * @param itemIds The item list for which to load item sprites.
	 */
	public void loadItemSprites(List<Integer> itemIds)
	{
		// Starting with an empty list, we find which icons haven't previously been seen
		final List<Integer> newItems = new ArrayList<>();

		for (int itemId : itemIds)
		{
			if (!loadedItemIds.contains(itemId))
			{
				newItems.add(itemId);
				loadedItemIds.add(itemId);
			}
		}

		if (newItems.isEmpty())
		{
			return;
		}

		final IndexedSprite[] modIcons = client.getModIcons();

		assert modIcons != null;

		final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + itemIds.size());
		final int iconIndex = modIcons.length;

		client.setModIcons(newModIcons);

		int i = 0;

		for (int itemId : itemIds)
		{
			final AsyncBufferedImage img = itemManager.getImage(itemId);
			final int idx = iconIndex + i++;

			itemSpriteIndexes.put(itemId, idx);
			spriteItemIds.put(idx, itemId);

			img.onLoaded(() ->
			{
				final BufferedImage image = ImageUtil.resizeImage(img, SPRITE_WIDTH, SPRITE_HEIGHT);
				final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);

				// mod icons array might be replaced in between when we assign it and the callback,
				// so fetch mod icons again
				client.getModIcons()[idx] = sprite;
			});
		}
	}
}

package com.templeosrs.util.collections;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * All available category groups (i.e. tabs) mapped to their in-game struct IDs
 */
@RequiredArgsConstructor
public enum CollectionLogCategoryGroup
{
	bosses(471),
	raids(472),
	clues(473),
	minigames(474),
	other(475);

	@Getter
	private final int structId;
}
package com.templeosrs.util.collections;

import lombok.RequiredArgsConstructor;

/**
 * Categories that can be used in the chat command.
 * Note: the command falls back to the input value, so may capture items not in this list if it has not been updated
 *
 * @link <a href="https://templeosrs.com/api/collection-log/category_parameters.php">Full category list</a>
 */
@RequiredArgsConstructor
public enum CollectionLogCategorySlug
{
	// Bosses
	abyssal_sire,
	alchemical_hydra,
	amoxliatl,
	araxxor,
	barrows_chests,
	bryophyta,
	callisto_and_artio,
	cerberus,
	chaos_elemental,
	chaos_fanatic,
	commander_zilyana,
	corporeal_beast,
	crazy_archaeologist,
	dagannoth_kings,
	deranged_archaeologist,
	doom_of_mokhaiotl,
	duke_sucellus,
	the_fight_caves,
	fortis_colosseum,
	the_gauntlet,
	general_graardor,
	giant_mole,
	grotesque_guardians,
	hespori,
	the_hueycoatl,
	the_inferno,
	kalphite_queen,
	king_black_dragon,
	kraken,
	kreearra,
	kril_tsutsaroth,
	the_leviathan,
	moons_of_peril,
	nex,
	the_nightmare,
	obor,
	phantom_muspah,
	royal_titans,
	sarachnis,
	scorpia,
	scurrius,
	skotizo,
	tempoross,
	thermonuclear_smoke_devil,
	vardorvis,
	venenatis_and_spindel,
	vetion_and_calvarion,
	vorkath,
	the_whisperer,
	wintertodt,
	yama,
	zalcano,
	zulrah,

	// Raids
	chambers_of_xeric,
	theatre_of_blood,
	tombs_of_amascut,

	// Clues
	beginner_treasure_trails,
	easy_treasure_trails,
	medium_treasure_trails,
	hard_treasure_trails,
	elite_treasure_trails,
	master_treasure_trails,
	hard_treasure_trails_rare,
	elite_treasure_trails_rare,
	master_treasure_trails_rare,
	shared_treasure_trail_rewards,
	scroll_cases,

	// Minigames
	barbarian_assault,
	brimhaven_agility_arena,
	castle_wars,
	fishing_trawler,
	giants_foundry,
	gnome_restaurant,
	guardians_of_the_rift,
	hallowed_sepulchre,
	last_man_standing,
	magic_training_arena,
	mahogany_homes,
	mastering_mixology,
	pest_control,
	rogues_den,
	shades_of_mortton,
	soul_wars,
	temple_trekking,
	tithe_farm,
	trouble_brewing,
	vale_totems,
	volcanic_mine,

	// Other
	aerial_fishing,
	all_pets,
	camdozaal,
	champions_challenge,
	chompy_bird_hunting,
	colossal_wyrm_agility,
	creature_creation,
	cyclopes,
	elder_chaos_druids,
	forestry,
	fossil_island_notes,
	gloughs_experiments,
	hunter_guild,
	monkey_backpacks,
	motherlode_mine,
	my_notes,
	random_events,
	revenants,
	rooftop_agility,
	shayzien_armour,
	shooting_stars,
	skilling_pets,
	slayer,
	tormented_demons,
	tzhaar,
	miscellaneous,

	// Custom
	gilded,
	thirdage,
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.templeosrs.util.collections;

import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.api.QuadraticBackoffStrategy;
import com.templeosrs.util.collections.autosync.CollectionLogAutoSyncManager;
import com.templeosrs.util.collections.chatcommands.CollectionLogChatCommandChatMessageSubscriber;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.data.PlayerData;
import com.templeosrs.util.collections.data.PlayerDataSubmission;
import com.templeosrs.util.collections.data.PlayerProfile;
import com.templeosrs.util.collections.database.CollectionDatabase;
import com.templeosrs.util.collections.services.CollectionLogService;
import com.templeosrs.util.collections.utils.CollectionLogCacheData;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.GameState;
import net.runelite.api.StructComposition;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import org.jetbrains.annotations.Nullable;

@Slf4j
@Singleton
public class CollectionLogManager
{
	/**
	 * Maps in-game categories to the list of items they contain. Pulled from the in-game cache, where the key is the
	 * category struct ID (e.g. <a href="https://chisel.weirdgloop.org/structs/index.html?type=structs&id=493">STRUCT #493</a>)
	 * and the value is the contents of the enum found in <a href="https://chisel.weirdgloop.org/structs/index.html?type=params&id=690">PARAM #690</a>.
	 */
	@Getter
	private static final Map<Integer, Set<Integer>> collectionLogCategoryItemMap = new HashMap<>();

	/**
	 * Maps slugified category names (e.g. guardians_of_the_rift) to their in-game struct ID
	 */
	@Getter
	private static final Map<String, Integer> collectionLogCategoryStructIdMap = new HashMap<>();

	/**
	 * Maps top level tabs (e.g. "Bosses") to their containing categories.
	 * Used to list the available categories when using the "!col help ___" commands
	 */
	@Getter
	private static final Map<Integer, Set<String>> collectionLogCategoryTabSlugs = new LinkedHashMap<>();

	/**
	 * List of items found in the collection log, computed by reading the in-game enums/structs.
	 */
	private final Set<Integer> collectionLogItemsFromCache = new HashSet<>();

	/**
	 * Unique list of all obtained collection log items
	 */
	@Getter
	private final Set<ObtainedCollectionItem> obtainedCollectionLogItems = new HashSet<>();

	@Getter
	private final QuadraticBackoffStrategy backoffStrategy = new QuadraticBackoffStrategy();

	@Inject
	private ItemManager itemManager;

	@Inject
	private SyncButtonManager syncButtonManager;

	@Inject
	private ScheduledExecutorService scheduledExecutorService;

	@Getter
	@Inject
	private Client client;

	@Getter
	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

	@Inject
	private TempleOSRSPlugin templeOSRSPlugin;

	@Inject
	private CollectionLogRequestManager requestManager;

	@Inject
	private CollectionLogService collectionLogService;

	@Inject
	private CollectionLogChatCommandChatMessageSubscriber collectionLogChatCommandChatMessageSubscriber;

	@Inject
	private CollectionLogRequestManager collectionLogRequestManager;

	@Nullable
	private Integer gameTickToSync;

	public void startUp()
	{
		eventBus.register(this);

		CollectionDatabase.init();

		if (templeOSRSPlugin.getConfig().enableClogChatCommand())
		{
			collectionLogChatCommandChatMessageSubscriber.startUp();
		}

		if (templeOSRSPlugin.getConfig().autoSyncClog())
		{
			collectionLogAutoSyncManager.startUp();
		}

		clientThread.invoke(() -> {
			if (client.getIndexConfig() == null || client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())
			{
				return false;
			}

			CollectionLogCacheData collectionLogCacheData = parseCacheForClog();

			collectionLogItemsFromCache.addAll(collectionLogCacheData.getItemIds());
			collectionLogCategoryItemMap.putAll(collectionLogCacheData.getCategoryItems());
			collectionLogCategoryStructIdMap.putAll(collectionLogCacheData.getCategoryStructIds());
			collectionLogCategoryTabSlugs.putAll(collectionLogCacheData.getCategorySlugs());

			return true;
		});
	}

	public void shutDown()
	{
		eventBus.unregister(this);

		if (templeOSRSPlugin.getConfig().enableClogChatCommand())
		{
			collectionLogChatCommandChatMessageSubscriber.shutDown();
		}

		if (templeOSRSPlugin.getConfig().autoSyncClog())
		{
			collectionLogAutoSyncManager.shutDown();
		}

		syncButtonManager.shutDown();

		obtainedCollectionLogItems.clear();
		collectionLogItemsFromCache.clear();
		collectionLogCategoryItemMap.clear();
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(TempleOSRSConfig.TEMPLE_OSRS_CONFIG_GROUP))
		{
			return;
		}

		if (templeOSRSPlugin.getConfig().autoSyncClog())
		{
			collectionLogAutoSyncManager.startUp();
		}
		else
		{
			collectionLogAutoSyncManager.shutDown();
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (backoffStrategy.isRequestLimitReached())
		{
			gameTickToSync = null;

			return;
		}

		if (!backoffStrategy.isSubmitting() && gameTickToSync != null && client.getTickCount() >= gameTickToSync)
		{
			backoffStrategy.setSubmitting(true);
			scheduledExecutorService.execute(this::submitTask);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState state = gameStateChanged.getGameState();

		switch (state)
		{
			// When hopping, we need to clear any state related to the player
			case HOPPING:
			case LOGGING_IN:
			case CONNECTION_LOST:
				break;
			case LOGGED_IN:
			{
				// Attempt to synchronise the player's collection log on login
				clientThread.invokeLater(() -> {
					final String username = client.getLocalPlayer().getName();

					// Wait for username to be available
					if (username == null)
					{
						return false;
					}

					try
					{
						String lastChanged = collectionLogRequestManager
							.getPlayerInfo(username)
							.getCollectionLog()
							.getLastChanged();


						// Skip sync if the player's collection log doesn't exist, or has already been saved and is up-to-date
						if (
							lastChanged == null ||
								(collectionLogService.isDataFresh(username, lastChanged) && CollectionDatabase.hasPlayerData(username))
						)
						{
							return true;
						}

						collectionLogService.syncCollectionLog();

						return true;
					}
					catch (NullPointerException | IOException e)
					{
						// If an error occurs then bail early to avoid infinite retries
						return true;
					}
				});
			}
		}
	}

	/**
	 * Handles updating the collection log after the log has opened or the Temple sync button has been pressed.
	 */
	@Subscribe
	public void onScriptPreFired(ScriptPreFired preFired)
	{
		if (preFired.getScriptId() == 4100)
		{
			if (collectionLogItemsFromCache.isEmpty())
			{
				return;
			}

			// Submit the collection log data three ticks after the first script prefires
			// This gives the game time to build the obtained items set and resolves an issue
			// that caused players with large logs to miss items in their sync data
			gameTickToSync = client.getTickCount() + 3;

			Object[] args = preFired.getScriptEvent().getArguments();
			int itemId = (int) args[1];
			int itemCount = (int) args[2];
			String itemName = itemManager.getItemComposition(itemId).getName();

			obtainedCollectionLogItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
		}
	}

	@Synchronized
	public void submitTask()
	{
		// TODO: do we want other GameStates?
		if (client.getGameState() != GameState.LOGGED_IN || client.getLocalPlayer().getName() == null)
		{
			log.error(" Aborting sync as the player is no longer logged in");

			return;
		}

		if (backoffStrategy.shouldSkipRequest())
		{
			return;
		}

		String username = client.getLocalPlayer().getName();

		final boolean hasPlayerData = CollectionDatabase.hasPlayerData(username);

		if (hasPlayerData && !syncButtonManager.isFullSyncRequested())
		{
			backoffStrategy.reset();
			gameTickToSync = null;

			return;
		}

		// If no API player data exists or if the sync button has been pressed, upload the entire log
		submitPlayerData();
	}

	private void submitPlayerData()
	{
		String username = client.getLocalPlayer().getName();

		// Do not send if slot data wasn't generated
		if (obtainedCollectionLogItems.isEmpty())
		{
			log.error(" No obtained items have been set for {}", username);

			gameTickToSync = null;
			backoffStrategy.reset();

			return;
		}

		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
		PlayerProfile profileKey = new PlayerProfile(username, profileType);

		// Only IDs and counts are useful in the request
		Set<ObtainedCollectionItem> preparedItems = obtainedCollectionLogItems
			.stream()
			.map(item -> new ObtainedCollectionItem(item.getId(), item.getCount()))
			.collect(Collectors.toSet());

		int totalCollectionsAvailable = collectionLogItemsFromCache.size();

		PlayerData playerData = new PlayerData(totalCollectionsAvailable, preparedItems);

		PlayerDataSubmission submission = new PlayerDataSubmission(
			profileKey.getUsername(),
			profileKey.getProfileType().name(),
			client.getAccountHash(),
			playerData
		);

		try
		{
			requestManager.uploadFullCollectionLog(submission);
			syncButtonManager.setFullSyncRequested(false);
			gameTickToSync = null;

			log.debug("Successfully submitted collection log for {}", submission.getUsername());
		}
		catch (IOException e)
		{
			log.error(" Failed to upload collection log for {}", submission.getUsername());
		}
		finally
		{
			backoffStrategy.finishCycle();
		}
	}

	/**
	 * Parse the enums and structs in the cache to figure out which item ids exist in the collection log.
	 */
	private CollectionLogCacheData parseCacheForClog()
	{
		Set<Integer> items = new HashSet<>();
		Map<Integer, Set<Integer>> categoryItems = new HashMap<>();
		Map<String, Integer> categoryStructIds = new HashMap<>();
		Map<Integer, Set<String>> categorySlugs = new LinkedHashMap<>();

		final Pattern specialCharacterPattern = Pattern.compile("['()]", Pattern.CASE_INSENSITIVE);

		// Some items with data saved on them have replacements to fix a duping issue (satchels, flamtaer bag)
		// Enum 3721 contains a mapping of the item ids to replace -> ids to replace them with
		EnumComposition replacements = client.getEnum(3721);

		// 2102 - Struct that contains the highest level tabs in the collection log (Bosses, Raids, etc)
		// https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2102
		int[] topLevelTabStructIds = client.getEnum(2102).getIntVals();
		for (int topLevelTabStructIndex : topLevelTabStructIds)
		{
			// The collection log top level tab structs contain a param that points to the enum
			// that contains the pointers to sub tabs.
			// ex: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=471
			StructComposition topLevelTabStruct = client.getStructComposition(topLevelTabStructIndex);

			Set<String> singleCategorySlugSet = new LinkedHashSet<>();

			// Param 683 contains the pointer to the enum that contains the subtabs ids
			// ex: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2103
			int[] subtabStructIndices = client.getEnum(topLevelTabStruct.getIntValue(683)).getIntVals();
			for (int subtabStructIndex : subtabStructIndices)
			{

				// The subtab structs are for subtabs in the collection log (Commander Zilyana, Chambers of Xeric, etc.)
				// and contain a pointer to the enum that contains all the item ids for that tab.
				// ex subtab struct: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=476
				// ex subtab enum: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2109
				StructComposition subtabStruct = client.getStructComposition(subtabStructIndex);

				int[] clogItems = client.getEnum(subtabStruct.getIntValue(690)).getIntVals();

				// Gets a slugified version of the category title
				// (e.g. Master Treasure Trails (Rare) -> master_treasure_trails_rare)
				String normalizedCategoryName = specialCharacterPattern
					.matcher(
						subtabStruct.getStringValue(689)
							.toLowerCase()
							.replaceAll(" ", "_")
					)
					.replaceAll("");

				Set<Integer> itemSet = new LinkedHashSet<>();

				for (int clogItemId : clogItems)
				{
					final int replacementId = replacements.getIntValue(clogItemId);

					itemSet.add(
						replacementId == -1
							? clogItemId
							: replacementId
					);
				}

				items.addAll(itemSet);
				categoryItems.put(subtabStructIndex, itemSet);
				categoryStructIds.put(normalizedCategoryName, subtabStructIndex);
				singleCategorySlugSet.add(normalizedCategoryName);
			}

			categorySlugs.put(topLevelTabStructIndex, singleCategorySlugSet);
		}

		return new CollectionLogCacheData(items, categoryItems, categoryStructIds, categorySlugs);
	}
}

package com.templeosrs.util.collections;

import com.google.gson.Gson;
import com.templeosrs.util.api.APIError;
import com.templeosrs.util.api.RequestManager;
import com.templeosrs.util.collections.autosync.PlayerDataSync;
import com.templeosrs.util.collections.data.PlayerDataSubmission;
import com.templeosrs.util.collections.data.PlayerInfoResponse;
import java.io.IOException;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.HttpUrl;
import org.jetbrains.annotations.NotNull;

@Slf4j
public class CollectionLogRequestManager extends RequestManager
{
	@Inject
	private Gson gson;

	/**
	 * Uploads newly obtained collection log items to the server.
	 * Used by the auto-sync feature to automatically synchronise the collection log.
	 *
	 * @param data The data to be uploaded.
	 * @return The API response data
	 */
	public String uploadObtainedCollectionLogItems(@NotNull PlayerDataSync data) throws IOException
	{
		final HttpUrl url = new HttpUrl.Builder()
			.scheme(scheme)
			.host(host)
			.addPathSegments("api/collection-log/sync_new_collections.php")
			.build();

		return post(url, data);
	}

	/**
	 * Uploads the full collection log to the server.
	 * Triggered by the Collection Log Sync button.
	 *
	 * @param data The data to be uploaded.
	 */
	public void uploadFullCollectionLog(@NotNull PlayerDataSubmission data) throws IOException
	{
		final HttpUrl url = new HttpUrl.Builder()
			.scheme(scheme)
			.host(host)
			.addPathSegments("api/collection-log/sync_collection.php")
			.build();

		post(url, data);
	}

	/**
	 * Retrieves player info from the Player Info endpoint
	 *
	 * @param username The username to check
	 * @link <a href="https://templeosrs.com/api_doc.php#Player_Information">Player Info API</a>
	 */
	@NotNull
	public PlayerInfoResponse.Data getPlayerInfo(@NotNull String username) throws IOException, NullPointerException
	{
		final HttpUrl url = new HttpUrl.Builder()
			.scheme(scheme)
			.host(host)
			.addPathSegments("api/player_info.php")
			.addQueryParameter("player", username)
			.addQueryParameter("cloginfo", "1")
			.addQueryParameter("formattedrsn", "1")
			.build();


		String response = get(url);

		PlayerInfoResponse playerInfoResponse = gson.fromJson(response, PlayerInfoResponse.class);
		PlayerInfoResponse.Data data = playerInfoResponse.getData();
		APIError error = playerInfoResponse.getError();

		if (error != null)
		{
			if (error.getCode() == 402)
			{
				throw new NullPointerException("Player has no TempleOSRS profile");
			}

			throw new IOException(String.valueOf(error));
		}

		if (data != null)
		{
			return data;
		}

		throw new IOException("Unexpected response format: " + response);
	}

	/**
	 * Retrieves the given player's full collection log
	 *
	 * @param username The username to query
	 * @return The collection log data
	 * @link <a href="https://templeosrs.com/api_doc.php#Player_Collection_Log">Player Collection Log API</a>
	 */
	public String getPlayerCollectionLog(@NotNull String username)
	{
		final HttpUrl url = new HttpUrl.Builder()
			.scheme(scheme)
			.host(host)
			.addPathSegments("api/collection-log/player_collection_log.php")
			.addQueryParameter("player", username)
			.addQueryParameter("categories", "all")
			.addQueryParameter("includenames", "1")
			.addQueryParameter("onlyitems", "1")
			.build();

		try
		{
			String response = get(url);

			if (response.contains("\"Code\":402") && response.contains("has not synced"))
			{
				return "error:unsynced";
			}

			return response;
		}
		catch (Exception e)
		{
			log.error(" Exception while fetching log for {}: {}", username, e.getMessage());

			return null;
		}
	}
}

package com.templeosrs.util.collections.data;

import java.util.Set;
import lombok.Value;

@Value
public class CollectionLogCategory
{
	String title;
	Set<Integer> items;
}

package com.templeosrs.util.collections.data;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.api.APIError;
import java.util.Set;
import lombok.Value;

@Value
public class CollectionLogResponse
{
	Data data;

	APIError error;

	@Value
	public static class Data
	{
		String player;
		@SerializedName("last_changed")
		String lastChanged;
		Set<ObtainedCollectionItem> items;
	}
}

package com.templeosrs.util.collections.data;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.api.APIError;
import javax.annotation.Nullable;
import lombok.Value;

@Value
public class CollectionLogSyncResponse
{
	@Nullable
	Data data;

	@Nullable
	APIError error;

	@Value
	public static class Data
	{
		@SerializedName("sync_date")
		String syncDate;

		@SerializedName("sync_date_unix")
		int syncDateUnix;

		@SerializedName("last_changed")
		String lastChanged;

		@SerializedName("last_changed_unix")
		int lastChangedUnix;

		String username;

		String message;
	}
}

package com.templeosrs.util.collections.data;

import java.sql.Timestamp;
import lombok.Value;
import lombok.experimental.NonFinal;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@Value
public class ObtainedCollectionItem
{
	int id;

	int count;

	String date;

	@Nullable
	@NonFinal
	String name;

	public ObtainedCollectionItem(int id, int count)
	{
		this.id = id;
		this.count = count;
		this.date = null;
		this.name = null;
	}

	public ObtainedCollectionItem(int id, @NotNull String name, int count)
	{
		this.id = id;
		this.name = name;
		this.count = count;
		this.date = null;
	}

	public ObtainedCollectionItem(int id, @NotNull String name, int count, String date)
	{
		this.id = id;
		this.name = name;
		this.count = count;
		this.date = date;
	}

	public Timestamp getDate()
	{
		if (this.date == null)
		{
			return null;
		}

		return Timestamp.valueOf(this.date);
	}
}

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.data;

import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class PlayerData
{
	public int totalCollectionsAvailable;
	public Set<ObtainedCollectionItem> obtainedItems;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.data;

import lombok.AllArgsConstructor;
import lombok.Value;

@Value
@AllArgsConstructor
public class PlayerDataSubmission
{
	String username;
	String profile;
	long playerHash;
	PlayerData data;
}
package com.templeosrs.util.collections.data;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.api.APIError;
import javax.annotation.Nullable;
import lombok.Value;

@Value
public class PlayerInfoResponse
{
	@Nullable
	Data data;

	@Nullable
	APIError error;

	@Value
	public static class CollectionLog
	{
		@Nullable
		@SerializedName("last_changed")
		String lastChanged;
	}

	@Value
	public static class Data
	{
		@SerializedName("collection_log")
		CollectionLog collectionLog;

		@SerializedName("player_name_with_capitalization")
		String playerNameWithCapitalization;
	}
}

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.data;

import lombok.Value;
import net.runelite.client.config.RuneScapeProfileType;

@Value
public class PlayerProfile
{
	String username;
	RuneScapeProfileType profileType;
}
package com.templeosrs.util.collections.database;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import java.io.File;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;

@Slf4j
@Singleton
public class CollectionDatabase
{
	private static final String DB_URL = "jdbc:h2:file:" + RuneLite.RUNELITE_DIR + "/templeosrs/runelite-collections;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1";

	private static final String COLLECTION_LOG_CACHE_TABLE_NAME = "collection_log_cache";
	private static final String PLAYER_METADATA_TABLE_NAME = "player_metadata";

	static
	{
		File pluginDir = new File(RuneLite.RUNELITE_DIR, "templeosrs");
		if (!pluginDir.exists())
		{
			if (!pluginDir.mkdirs())
			{
				log.warn(" Failed to create plugin directory at {}", pluginDir.getAbsolutePath());
			}
		}
	}

	public static Connection getConnection() throws SQLException
	{
		return DriverManager.getConnection(DB_URL);
	}

	public static void init()
	{
		try
		{
			//  Required for Plugin Hub: explicitly load the H2 JDBC driver
			Class.forName("org.h2.Driver");

			try (Connection conn = getConnection(); Statement stmt = conn.createStatement())
			{
				final String createCollectionLogCacheTableSql = String.format(
					"CREATE TABLE IF NOT EXISTS %s(" +
						"id IDENTITY PRIMARY KEY, " +
						"item_id INT, " +
						"item_name VARCHAR(255), " +
						"item_count INT, " +
						"player_name VARCHAR(255)" +
						")",
					COLLECTION_LOG_CACHE_TABLE_NAME
				);

				final String createPlayerMetadataTableSql = String.format(
					"CREATE TABLE IF NOT EXISTS %s(" +
						"id IDENTITY PRIMARY KEY, " +
						"player_name VARCHAR(255), " +
						"last_changed TIMESTAMP, " +
						"last_accessed TIMESTAMP" +
						")",
					PLAYER_METADATA_TABLE_NAME
				);

				stmt.executeUpdate(createCollectionLogCacheTableSql);
				stmt.executeUpdate(createPlayerMetadataTableSql);
			}
		}
		catch (ClassNotFoundException e)
		{
			log.warn("H2 Driver class not found: {}", e.getMessage());
		}
		catch (SQLException e)
		{
			log.warn("Database initialization failed: {}", e.getMessage());
		}
	}

	private static void addColumnIfNotExists(Connection conn, String table, String column, String type) throws SQLException
	{
		String checkQuery = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ? AND COLUMN_NAME = ?";
		try (PreparedStatement ps = conn.prepareStatement(checkQuery))
		{
			ps.setString(1, table.toUpperCase());
			ps.setString(2, column.toUpperCase());
			try (ResultSet rs = ps.executeQuery())
			{
				if (!rs.next())
				{
					try (Statement stmt = conn.createStatement())
					{
						stmt.executeUpdate("ALTER TABLE " + table + " ADD COLUMN " + column + " " + type);
					}
				}
			}
		}
	}

	public static boolean hasPlayerData(String playerName)
	{
		String sql = String.format("SELECT 1 FROM %s WHERE player_name = ? LIMIT 1", COLLECTION_LOG_CACHE_TABLE_NAME);

		try (Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql))
		{
			ps.setString(1, playerName.toLowerCase());
			ResultSet rs = ps.executeQuery();
			return rs.next();
		}
		catch (SQLException e)
		{
			log.warn("Error checking player data: {}", e.getMessage());
			return false;
		}
	}

	/**
	 * Saves the API response data to the API cache table
	 *
	 * @param playerName The player name associated with the response
	 * @param items      The items to persist to the database
	 */
	public static void upsertItemsBatch(
		@NotNull String playerName,
		@NotNull Set<ObtainedCollectionItem> items,
		Timestamp lastChanged
	)
	{
		try (Connection conn = getConnection())
		{
			conn.setAutoCommit(false);

			try (
				PreparedStatement ps1 = conn.prepareStatement(
					String.format("MERGE INTO %s USING DUAL ", COLLECTION_LOG_CACHE_TABLE_NAME) +
						"ON item_id = ? AND player_name = ? " +
						"WHEN MATCHED THEN UPDATE SET item_count = ? " +
						"WHEN NOT MATCHED THEN INSERT (player_name, item_id, item_count, item_name) VALUES (?, ?, ?, ?)"
				);
				PreparedStatement ps2 = conn.prepareStatement(
					String.format("MERGE INTO %s USING DUAL ", PLAYER_METADATA_TABLE_NAME) +
						"ON player_name = ? " +
						"WHEN MATCHED THEN UPDATE SET last_changed = ?, last_accessed = ? " +
						"WHEN NOT MATCHED THEN INSERT (player_name, last_changed, last_accessed) VALUES (?, ?, ?)"
				)
			)
			{
				final String lowerPlayerName = playerName.toLowerCase();
				final Timestamp lastAccessed = new Timestamp(System.currentTimeMillis());

				for (ObtainedCollectionItem item : items)
				{
					final int itemId = item.getId();
					final int itemCount = item.getCount();

					ps1.setInt(1, itemId);
					ps1.setString(2, lowerPlayerName);
					ps1.setInt(3, itemCount);
					ps1.setString(4, lowerPlayerName);
					ps1.setInt(5, itemId);
					ps1.setInt(6, itemCount);
					ps1.setString(7, item.getName());

					ps1.addBatch();
				}

				ps2.setString(1, lowerPlayerName);
				ps2.setTimestamp(2, lastChanged);
				ps2.setTimestamp(3, lastAccessed);
				ps2.setString(4, lowerPlayerName);
				ps2.setTimestamp(5, lastChanged);
				ps2.setTimestamp(6, lastAccessed);

				ps1.executeBatch();
				ps2.execute();
			}

			conn.commit();
		}
		catch (SQLException e)
		{
			log.warn("Error inserting items to the API cache: {}", e.getMessage());
		}
	}

	public static Multiset<Integer> getCollectionLogDiff(String playerName, Multiset<Integer> collectionLogItems)
	{
		try (Connection conn = getConnection())
		{
			try (PreparedStatement ps = conn.prepareStatement(
				String.format(
					"SELECT item_count, item_id FROM %s WHERE player_name = ? AND item_id = ? LIMIT 1",
					COLLECTION_LOG_CACHE_TABLE_NAME
				)
			))
			{
				final Multiset<Integer> foundItems = HashMultiset.create();

				for (Multiset.Entry<Integer> entry : collectionLogItems.entrySet())
				{
					final int itemId = entry.getElement();

					ps.setString(1, playerName.toLowerCase());
					ps.setInt(2, itemId);

					final ResultSet rs = ps.executeQuery();

					if (rs.next())
					{
						final int rsItemCount = rs.getInt("item_count");
						final int rsItemId = rs.getInt("item_id");

						foundItems.add(rsItemId, rsItemCount);
					}
				}

				return Multisets.difference(collectionLogItems, foundItems);
			}
		}
		catch (SQLException e)
		{
			log.warn("Error comparing collection log: {}", e.getMessage());

			return null;
		}
	}

	public static Timestamp getLatestTimestamp(String playerName)
	{
		String sql = String.format("SELECT last_changed FROM %s WHERE player_name = ?", PLAYER_METADATA_TABLE_NAME);

		try (Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql))
		{
			ps.setString(1, playerName.toLowerCase());
			ResultSet rs = ps.executeQuery();
			if (rs.next())
			{
				return rs.getTimestamp(1);
			}
		}
		catch (SQLException e)
		{
			log.warn("Error fetching latest timestamp: {}", e.getMessage());
		}

		return null;
	}

	public static void clearAll()
	{
		try (Connection conn = getConnection();
			 Statement stmt = conn.createStatement())
		{
			stmt.executeUpdate(String.format("DELETE FROM %s", COLLECTION_LOG_CACHE_TABLE_NAME));
		}
		catch (SQLException e)
		{
			log.warn("Error clearing all items: {}", e.getMessage());
		}
	}

	public static Set<ObtainedCollectionItem> getItemsByCategory(String playerName, Set<Integer> categoryItems)
	{
		Map<Integer, ObtainedCollectionItem> items = new HashMap<>();

		try (Connection conn = getConnection();
			 PreparedStatement ps1 = conn.prepareStatement(
				 String.format(
					 "SELECT item_id, item_name, item_count FROM %s WHERE player_name = ? AND item_id IN (%s)",
					 COLLECTION_LOG_CACHE_TABLE_NAME,
					 StringUtils.repeat("?", ",", categoryItems.size())
				 )
			 );
			 PreparedStatement ps2 = conn.prepareStatement(
				 String.format("UPDATE %s ", PLAYER_METADATA_TABLE_NAME) +
					 "SET last_accessed = ? " +
					 "WHERE player_name = ?"
			 )
		)
		{
			conn.setAutoCommit(false);

			final Timestamp lastAccessed = new Timestamp(System.currentTimeMillis());
			final String lowerPlayerName = playerName.toLowerCase();

			ps1.setString(1, playerName.toLowerCase());

			int paramIndex = 2;
			for (int id : categoryItems)
			{
				ps1.setInt(paramIndex, id);
				paramIndex++;
			}

			try (ResultSet rs = ps1.executeQuery())
			{
				while (rs.next())
				{
					int itemId = rs.getInt("item_id");
					String itemName = rs.getString("item_name");
					int count = rs.getInt("item_count");

					items.put(itemId, new ObtainedCollectionItem(itemId, itemName, count));
				}
			}

			ps2.setTimestamp(1, lastAccessed);
			ps2.setString(2, lowerPlayerName);

			ps2.execute();

			conn.commit();
		}
		catch (SQLException e)
		{
			log.warn("Error fetching items by category: {}", e.getMessage());
		}

		Set<ObtainedCollectionItem> sortedItems = new LinkedHashSet<>();

		// Sorts the database response to match the order found in the log tab
		for (int itemId : categoryItems)
		{
			if (items.containsKey(itemId))
			{
				sortedItems.add(items.get(itemId));
			}
		}

		return sortedItems;
	}

	public static void pruneOldPlayers(String yourUsername, int maxPlayers)
	{
		try (Connection conn = getConnection();
			 PreparedStatement ps1 = conn.prepareStatement(
				 "SELECT player_name, MIN(last_accessed) as oldest " +
					 String.format("FROM %s ", COLLECTION_LOG_CACHE_TABLE_NAME) +
					 "WHERE player_name != ? " +
					 "GROUP BY player_name " +
					 "ORDER BY oldest ASC"
			 );
			 PreparedStatement deleteStmt = conn.prepareStatement(
				 String.format(
					 "DELETE FROM %s AS a INNER JOIN %s AS b WHERE a.player_name = b.player_name AND a.player_name = ?",
					 COLLECTION_LOG_CACHE_TABLE_NAME,
					 PLAYER_METADATA_TABLE_NAME
				 )
			 )
		)
		{
			ps1.setString(1, yourUsername.toLowerCase());
			ResultSet rs = ps1.executeQuery();

			int count = 0;
			List<String> playersToRemove = new ArrayList<>();

			while (rs.next())
			{
				count++;
				if (count > maxPlayers)
				{
					playersToRemove.add(rs.getString("player_name"));
				}
			}

			for (String name : playersToRemove)
			{
				log.debug("\uD83E\uDDF9 Pruning cached player: {}", name);
				deleteStmt.setString(1, name);
				deleteStmt.executeUpdate();
			}
		}
		catch (SQLException e)
		{
			log.warn("Error pruning old players: {}", e.getMessage());
		}
	}
}

package com.templeosrs.util.collections.parser;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.templeosrs.util.api.APIError;
import com.templeosrs.util.collections.data.CollectionLogResponse;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.database.CollectionDatabase;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
public class CollectionParser
{
	@Inject
	private Gson gson;

	/**
	 * Parses the Temple API response to a map of collection log items
	 *
	 * @param rawUsername The username associated with the response
	 * @param json        The raw JSON response from the Player Collection Log endpoint
	 */
	public void parseAndStore(String rawUsername, String json)
	{
		final String username = rawUsername.toLowerCase();

		log.debug(" Starting parse() for user: {}...", username);

		CollectionLogResponse collectionLogResponse;

		// Log the raw JSON for debugging purposes
		log.debug("Raw JSON: {}", json);

		try
		{
			// Directly parse the JSON string using Gson
			collectionLogResponse = gson.fromJson(json, CollectionLogResponse.class);
		}
		catch (JsonSyntaxException e)
		{
			log.error(" Failed to parse JSON for {}: {}", username, e.getMessage());

			return;
		}
		catch (Exception e)
		{
			log.error(" Unexpected error while parsing JSON for {}: {}", username, e.getMessage());

			return;
		}

		CollectionLogResponse.Data data = collectionLogResponse.getData();
		APIError error = collectionLogResponse.getError();

		// Handle error response
		if (error != null)
		{
			String errorMessage = error.getMessage();

			if (errorMessage.contains("Player has not synced"))
			{
				log.warn(" Player {} has not synced their collection log yet.", username);
			}
			else
			{
				log.warn(" API error for {}: {}", username, errorMessage);
			}

			return; // Stop further processing for this player
		}

		// Handle success response
		if (data != null)
		{
			Set<ObtainedCollectionItem> itemList = new HashSet<>();

			for (ObtainedCollectionItem item : data.getItems())
			{
				log.debug(" Queuing: {} x{} @ {}", item.getName(), item.getCount(), item.getDate());
				itemList.add(item);
			}

			log.debug(" Parsed {} items for {}.", itemList.size(), username);

			if (itemList.isEmpty())
			{
				log.warn(" No items found to store for {}", username);

				return;
			}

			log.debug(" Starting store() for user: {}...", username);

			CollectionDatabase.upsertItemsBatch(username, itemList, Timestamp.valueOf(data.getLastChanged()));

			int itemCount = itemList.size();

			log.debug(" Parsed and inserted {} items total for {}.", itemCount, username);

			//  Manually shut down the database after insert
			try (Connection conn = CollectionDatabase.getConnection();
				 Statement stmt = conn.createStatement()
			)
			{
				stmt.execute("SHUTDOWN");
				log.debug(" Manually closed H2 database after sync.");
			}
			catch (SQLException e)
			{
				log.error(" Error while trying to shut down the database", e);
			}
		}
	}
}
package com.templeosrs.util.collections.services;

import com.templeosrs.util.collections.CollectionLogRequestManager;
import com.templeosrs.util.collections.database.CollectionDatabase;
import com.templeosrs.util.collections.parser.CollectionParser;
import com.templeosrs.util.collections.utils.PlayerNameUtils;
import java.sql.Timestamp;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import org.jetbrains.annotations.NotNull;

@Slf4j
public class CollectionLogService
{
	@Inject
	private CollectionLogRequestManager collectionLogRequestManager;

	@Inject
	private ScheduledExecutorService scheduledExecutorService;

	@Inject
	private Client client;

	@Inject
	private CollectionParser collectionParser;

	/**
	 * Compares the timestamp of the latest collection log to the saved data.
	 *
	 * @param username The username to check
	 * @return True if the saved data is the latest available.
	 */
	public boolean isDataFresh(@NotNull String username, @NotNull String lastChanged)
	{
		Timestamp dbTimestamp = CollectionDatabase.getLatestTimestamp(username);
		Timestamp apiTimestamp = Timestamp.valueOf(lastChanged);

		log.debug(" [Compare] {} | DB: {} | API: {}", username, dbTimestamp, apiTimestamp);

		return dbTimestamp != null && !dbTimestamp.before(apiTimestamp);
	}

	/**
	 * Synchronises the player's cached collection log.
	 */
	public void syncCollectionLog()
	{
		scheduledExecutorService.execute(() -> {
			log.debug(" Starting syncCollectionLog()...");

			if (client.getLocalPlayer() == null)
			{
				log.warn(" Local player is null  not logged in yet.");
				return;
			}

			String username = Objects.requireNonNull(client.getLocalPlayer().getName()).toLowerCase();

			log.debug(" Detected username: {}", username);

			String json = collectionLogRequestManager.getPlayerCollectionLog(username);

			log.debug(" Fetched JSON: {} characters", json != null ? json.length() : 0);

			if (json == null || json.isEmpty())
			{
				log.error(" Empty or null response from Temple API");
				return;
			}

			log.debug(" Parsing and storing JSON...");

			collectionParser.parseAndStore(PlayerNameUtils.normalizePlayerName(username), json);

			log.debug(" Parsing complete.");
		});
	}
}

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import static java.lang.Math.round;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.MenuAction;
import net.runelite.api.SpriteID;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class SyncButtonManager
{
	private static final int COLLECTION_LOG_SETUP = 7797;
	private static final int[] SPRITE_IDS_INACTIVE = {
		SpriteID.DIALOG_BACKGROUND,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_LEFT,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_RIGHT,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_LEFT,
		SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_RIGHT,
		SpriteID.WORLD_MAP_BUTTON_EDGE_LEFT,
		SpriteID.WORLD_MAP_BUTTON_EDGE_TOP,
		SpriteID.WORLD_MAP_BUTTON_EDGE_RIGHT,
		SpriteID.WORLD_MAP_BUTTON_EDGE_BOTTOM,
	};

	private static final int[] SPRITE_IDS_ACTIVE = {
		SpriteID.RESIZEABLE_MODE_SIDE_PANEL_BACKGROUND,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED,
		SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED,
	};

	private static final int FONT_COLOUR_INACTIVE = 0xd6d6d6;
	private static final int FONT_COLOUR_ACTIVE = 0xffffff;
	private static final int CLOSE_BUTTON_OFFSET = 28;
	private static final int BUTTON_WIDTH = 60;
	private static final int BUTTON_OFFSET = CLOSE_BUTTON_OFFSET + 5;
	private int lastAttemptedUpdate = -1;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CollectionLogManager collectionLogManager;

	@Getter
	@Setter
	private boolean fullSyncRequested = false;

	public void startUp()
	{
		eventBus.register(this);
		clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
	}

	public void shutDown()
	{
		eventBus.unregister(this);
		clientThread.invokeLater(this::removeButton);
	}

	void tryAddButton(Runnable onClick)
	{
		for (Screen screen : Screen.values())
		{
			addButton(screen, onClick);
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP)
		{
			removeButton();
			addButton(Screen.COLLECTION_LOG, this::onButtonClick);
		}
	}

	void onButtonClick()
	{
		if (lastAttemptedUpdate != -1 && lastAttemptedUpdate + 50 > client.getTickCount())
		{
			client.addChatMessage(ChatMessageType.CONSOLE, "TempleOSRS", "Last update within 30 seconds. You can update again in " + round((lastAttemptedUpdate + 50 - client.getTickCount()) * 0.6) + " seconds.", "TempleOSRS");
			return;
		}

		lastAttemptedUpdate = client.getTickCount();

		setFullSyncRequested(true);

		// Clear the previously obtained item list to avoid duplicating items when counts change
		collectionLogManager.getObtainedCollectionLogItems().clear();

		client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
		client.runScript(2240);
		client.addChatMessage(ChatMessageType.CONSOLE, "TempleOSRS", "Your collection log data is being sent to TempleOSRS...", "TempleOSRS");
	}

	void addButton(Screen screen, Runnable onClick)
	{
		Widget parent = client.getWidget(screen.getParentId());
		Widget searchButton = client.getWidget(screen.getSearchButtonId());
		Widget collectionLogContainer = client.getWidget(screen.getCollectionLogContainer());
		Widget[] containerChildren;
		Widget draggableTopbar;
		if (parent == null || searchButton == null || collectionLogContainer == null ||
			(containerChildren = collectionLogContainer.getChildren()) == null ||
			(draggableTopbar = containerChildren[0]) == null)
		{
			return;
		}

		final int w = BUTTON_WIDTH;
		final int h = searchButton.getOriginalHeight();
		final int x = BUTTON_OFFSET;
		final int y = searchButton.getOriginalY();
		final int cornerDim = 9;

		final Widget[] spriteWidgets = new Widget[10];

		spriteWidgets[0] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[0])
			.setPos(x, y)
			.setSize(w, h)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setYPositionMode(searchButton.getYPositionMode());

		spriteWidgets[1] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[1])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x + (w - cornerDim), y);
		spriteWidgets[2] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[2])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x, y);
		spriteWidgets[3] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[3])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x + (w - cornerDim), y + h - cornerDim);
		spriteWidgets[4] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[4])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(cornerDim, cornerDim)
			.setPos(x, y + h - cornerDim);
		// Left and right edges
		int sideWidth = 9;
		int sideHeight = 4;
		spriteWidgets[5] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[5])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(sideWidth, sideHeight)
			.setPos(x + (w - sideWidth), y + cornerDim);
		spriteWidgets[7] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[7])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(sideWidth, sideHeight)
			.setPos(x, y + cornerDim);

		// Top and bottom edges
		int topWidth = 42;
		int topHeight = 9;
		spriteWidgets[6] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[6])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(topWidth, topHeight)
			.setPos(x + cornerDim, y);
		spriteWidgets[8] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SPRITE_IDS_INACTIVE[8])
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(topWidth, topHeight)
			.setPos(x + cornerDim, y + h - topHeight);
		// Refresh icon
		spriteWidgets[9] = parent.createChild(-1, WidgetType.GRAPHIC)
			.setSpriteId(SpriteID.UNKNOWN_WHITE_REFRESH_ARROWS)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setSize(13, 13)
			.setPos(x + 6, y + 4);


		for (int i = 0; i < 10; i++)
		{
			spriteWidgets[i].revalidate();
		}

		final Widget text = parent.createChild(-1, WidgetType.TEXT)
			.setText("Temple")
			.setTextColor(FONT_COLOUR_INACTIVE)
			.setFontId(FontID.PLAIN_11)
			.setTextShadowed(true)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setXTextAlignment(WidgetTextAlignment.LEFT)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setPos(x - 8, y)
			.setSize(w, h)
			.setYPositionMode(searchButton.getYPositionMode());
		text.revalidate();

		// We'll give the text layer the listeners since it covers the whole area
		text.setHasListener(true);
		text.setOnMouseOverListener((JavaScriptCallback) ev ->
		{
			for (int i = 0; i <= 8; i++)
			{
				spriteWidgets[i].setSpriteId(SPRITE_IDS_ACTIVE[i]);
			}
			text.setTextColor(FONT_COLOUR_ACTIVE);
		});
		text.setOnMouseLeaveListener((JavaScriptCallback) ev ->
		{
			for (int i = 0; i <= 8; i++)
			{
				spriteWidgets[i].setSpriteId(SPRITE_IDS_INACTIVE[i]);
			}
			text.setTextColor(FONT_COLOUR_INACTIVE);
		});

		// Register a click listener
		text.setAction(0, "Sync your collection log with Temple");
		text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());


		// Shrink the top bar to avoid overlapping the new button
		draggableTopbar.setOriginalWidth(draggableTopbar.getOriginalWidth() - (w + (x - CLOSE_BUTTON_OFFSET)));
		draggableTopbar.revalidate();

		// recompute locations / sizes on parent
		parent.revalidate();
	}

	void removeButton()
	{
		for (Screen screen : Screen.values())
		{
			Widget parent = client.getWidget(screen.getParentId());
			if (parent != null)
			{
				parent.deleteAllChildren();
				parent.revalidate();
			}
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum Screen
	{
		// First number is col log container (inner) and second is search button id
		COLLECTION_LOG(40697944, 40697932, ComponentID.COLLECTION_LOG_CONTAINER),
		;

		@Getter(onMethod_ = @Component)
		private final int parentId;

		@Getter(onMethod_ = @Component)
		private final int searchButtonId;

		@Getter(onMethod_ = @Component)
		private final int collectionLogContainer;
	}
}
package com.templeosrs.util.collections.utils;

import java.util.Map;
import java.util.Set;
import lombok.Value;

@Value
public class CollectionLogCacheData
{
	Set<Integer> itemIds;
	Map<Integer, Set<Integer>> categoryItems;
	Map<String, Integer> categoryStructIds;
	Map<Integer, Set<String>> categorySlugs;
}

package com.templeosrs.util.collections.utils;

import com.templeosrs.util.collections.CollectionLogCategorySlug;
import com.templeosrs.util.collections.data.CollectionLogCategory;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import net.runelite.api.gameval.ItemID;

public class CollectionLogCategoryUtils
{
	/**
	 * Category aliases to be used in the !col command. e.g. "!col kree"
	 */
	public static final Map<String, CollectionLogCategorySlug> CATEGORY_ALIASES = Map.<String, CollectionLogCategorySlug>ofEntries(
		// === Bosses ===
		Map.entry("armadyl", CollectionLogCategorySlug.kreearra),
		Map.entry("kree", CollectionLogCategorySlug.kreearra),
		Map.entry("arma", CollectionLogCategorySlug.kreearra),
		Map.entry("archaeologist", CollectionLogCategorySlug.crazy_archaeologist),
		Map.entry("crazy", CollectionLogCategorySlug.crazy_archaeologist),
		Map.entry("barrows", CollectionLogCategorySlug.barrows_chests),
		Map.entry("bryo", CollectionLogCategorySlug.bryophyta),
		Map.entry("bear", CollectionLogCategorySlug.callisto_and_artio),
		Map.entry("artio", CollectionLogCategorySlug.callisto_and_artio),
		Map.entry("callisto", CollectionLogCategorySlug.callisto_and_artio),
		Map.entry("vetion", CollectionLogCategorySlug.vetion_and_calvarion),
		Map.entry("calvarion", CollectionLogCategorySlug.vetion_and_calvarion),
		Map.entry("calv", CollectionLogCategorySlug.vetion_and_calvarion),
		Map.entry("vet", CollectionLogCategorySlug.vetion_and_calvarion),
		Map.entry("cerb", CollectionLogCategorySlug.cerberus),
		Map.entry("corp", CollectionLogCategorySlug.corporeal_beast),
		Map.entry("corporeal", CollectionLogCategorySlug.corporeal_beast),
		Map.entry("deranged", CollectionLogCategorySlug.deranged_archaeologist),
		Map.entry("dagannoth", CollectionLogCategorySlug.dagannoth_kings),
		Map.entry("dk", CollectionLogCategorySlug.dagannoth_kings),
		Map.entry("dks", CollectionLogCategorySlug.dagannoth_kings),
		Map.entry("delve", CollectionLogCategorySlug.doom_of_mokhaiotl),
		Map.entry("doom", CollectionLogCategorySlug.doom_of_mokhaiotl),
		Map.entry("mok", CollectionLogCategorySlug.doom_of_mokhaiotl),
		Map.entry("duke", CollectionLogCategorySlug.duke_sucellus),
		Map.entry("sucellus", CollectionLogCategorySlug.duke_sucellus),
		Map.entry("ele", CollectionLogCategorySlug.chaos_elemental),
		Map.entry("elemental", CollectionLogCategorySlug.chaos_elemental),
		Map.entry("fanatic", CollectionLogCategorySlug.chaos_fanatic),
		Map.entry("graardor", CollectionLogCategorySlug.general_graardor),
		Map.entry("bandos", CollectionLogCategorySlug.general_graardor),
		Map.entry("grotesque", CollectionLogCategorySlug.grotesque_guardians),
		Map.entry("gg", CollectionLogCategorySlug.grotesque_guardians),
		Map.entry("ggs", CollectionLogCategorySlug.grotesque_guardians),
		Map.entry("hydra", CollectionLogCategorySlug.alchemical_hydra),
		Map.entry("alchemical", CollectionLogCategorySlug.alchemical_hydra),
		Map.entry("kbd", CollectionLogCategorySlug.king_black_dragon),
		Map.entry("kalphite", CollectionLogCategorySlug.kalphite_queen),
		Map.entry("kril", CollectionLogCategorySlug.kril_tsutsaroth),
		Map.entry("zammy", CollectionLogCategorySlug.kril_tsutsaroth),
		Map.entry("zamorak", CollectionLogCategorySlug.kril_tsutsaroth),
		Map.entry("leviathan", CollectionLogCategorySlug.the_leviathan),
		Map.entry("levi", CollectionLogCategorySlug.the_leviathan),
		Map.entry("mole", CollectionLogCategorySlug.giant_mole),
		Map.entry("moons", CollectionLogCategorySlug.moons_of_peril),
		Map.entry("muspah", CollectionLogCategorySlug.phantom_muspah),
		Map.entry("nightmare", CollectionLogCategorySlug.the_nightmare),
		Map.entry("phosani", CollectionLogCategorySlug.the_nightmare),
		Map.entry("phn", CollectionLogCategorySlug.the_nightmare),
		Map.entry("sire", CollectionLogCategorySlug.abyssal_sire),
		Map.entry("spider", CollectionLogCategorySlug.venenatis_and_spindel),
		Map.entry("spindel", CollectionLogCategorySlug.venenatis_and_spindel),
		Map.entry("venenatis", CollectionLogCategorySlug.venenatis_and_spindel),
		Map.entry("thermonuclear", CollectionLogCategorySlug.thermonuclear_smoke_devil),
		Map.entry("thermy", CollectionLogCategorySlug.thermonuclear_smoke_devil),
		Map.entry("titans", CollectionLogCategorySlug.royal_titans),
		Map.entry("royal", CollectionLogCategorySlug.royal_titans),
		Map.entry("rt", CollectionLogCategorySlug.royal_titans),
		Map.entry("tormented", CollectionLogCategorySlug.tormented_demons),
		Map.entry("tds", CollectionLogCategorySlug.tormented_demons),
		Map.entry("whisperer", CollectionLogCategorySlug.the_whisperer),
		Map.entry("whisp", CollectionLogCategorySlug.the_whisperer),
		Map.entry("zilyana", CollectionLogCategorySlug.commander_zilyana),
		Map.entry("sara", CollectionLogCategorySlug.commander_zilyana),
		Map.entry("zily", CollectionLogCategorySlug.commander_zilyana),
		Map.entry("saradomin", CollectionLogCategorySlug.commander_zilyana),
		Map.entry("amox", CollectionLogCategorySlug.amoxliatl),
		Map.entry("vork", CollectionLogCategorySlug.vorkath),
		Map.entry("huey", CollectionLogCategorySlug.the_hueycoatl),
		Map.entry("vard", CollectionLogCategorySlug.vardorvis),
		Map.entry("zul", CollectionLogCategorySlug.zulrah),

		// === Clue Scrolls ===
		Map.entry("beginner_clue", CollectionLogCategorySlug.beginner_treasure_trails),
		Map.entry("easy_clue", CollectionLogCategorySlug.easy_treasure_trails),
		Map.entry("elite_clue", CollectionLogCategorySlug.elite_treasure_trails),
		Map.entry("hard_clue", CollectionLogCategorySlug.hard_treasure_trails),
		Map.entry("master_clue", CollectionLogCategorySlug.master_treasure_trails),
		Map.entry("medium_clue", CollectionLogCategorySlug.medium_treasure_trails),
		Map.entry("shared_clue", CollectionLogCategorySlug.shared_treasure_trail_rewards),
		Map.entry("beginner", CollectionLogCategorySlug.beginner_treasure_trails),
		Map.entry("easy", CollectionLogCategorySlug.easy_treasure_trails),
		Map.entry("medium", CollectionLogCategorySlug.medium_treasure_trails),
		Map.entry("hard", CollectionLogCategorySlug.hard_treasure_trails),
		Map.entry("elite", CollectionLogCategorySlug.elite_treasure_trails),
		Map.entry("master", CollectionLogCategorySlug.master_treasure_trails),
		Map.entry("shared", CollectionLogCategorySlug.shared_treasure_trail_rewards),
		Map.entry("cases", CollectionLogCategorySlug.scroll_cases),

		// === Minigames & Activities ===
		Map.entry("aerial", CollectionLogCategorySlug.aerial_fishing),
		Map.entry("champions", CollectionLogCategorySlug.champions_challenge),
		Map.entry("chompy", CollectionLogCategorySlug.chompy_bird_hunting),
		Map.entry("creature", CollectionLogCategorySlug.creature_creation),
		Map.entry("den", CollectionLogCategorySlug.rogues_den),
		Map.entry("druids", CollectionLogCategorySlug.elder_chaos_druids),
		Map.entry("randoms", CollectionLogCategorySlug.random_events),
		Map.entry("events", CollectionLogCategorySlug.random_events),
		Map.entry("experiment", CollectionLogCategorySlug.gloughs_experiments),
		Map.entry("glough", CollectionLogCategorySlug.gloughs_experiments),
		Map.entry("fossil", CollectionLogCategorySlug.fossil_island_notes),
		Map.entry("gotr", CollectionLogCategorySlug.guardians_of_the_rift),
		Map.entry("rift", CollectionLogCategorySlug.guardians_of_the_rift),
		Map.entry("rumours", CollectionLogCategorySlug.hunter_guild),
		Map.entry("hunter", CollectionLogCategorySlug.hunter_guild),
		Map.entry("lms", CollectionLogCategorySlug.last_man_standing),
		Map.entry("mixology", CollectionLogCategorySlug.mastering_mixology),
		Map.entry("mlm", CollectionLogCategorySlug.motherlode_mine),
		Map.entry("monkey", CollectionLogCategorySlug.monkey_backpacks),
		Map.entry("notes", CollectionLogCategorySlug.my_notes),
		Map.entry("pc", CollectionLogCategorySlug.pest_control),
		Map.entry("pest", CollectionLogCategorySlug.pest_control),
		Map.entry("revs", CollectionLogCategorySlug.revenants),
		Map.entry("rev", CollectionLogCategorySlug.revenants),
		Map.entry("rooftop", CollectionLogCategorySlug.rooftop_agility),
		Map.entry("sep", CollectionLogCategorySlug.hallowed_sepulchre),
		Map.entry("sepulchre", CollectionLogCategorySlug.hallowed_sepulchre),
		Map.entry("hs", CollectionLogCategorySlug.hallowed_sepulchre),
		Map.entry("shades", CollectionLogCategorySlug.shades_of_mortton),
		Map.entry("shayzien", CollectionLogCategorySlug.shayzien_armour),
		Map.entry("stars", CollectionLogCategorySlug.shooting_stars),
		Map.entry("trekking", CollectionLogCategorySlug.temple_trekking),
		Map.entry("tithe", CollectionLogCategorySlug.tithe_farm),
		Map.entry("brewing", CollectionLogCategorySlug.trouble_brewing),
		Map.entry("trouble", CollectionLogCategorySlug.trouble_brewing),
		Map.entry("tb", CollectionLogCategorySlug.trouble_brewing),
		Map.entry("volcanic", CollectionLogCategorySlug.volcanic_mine),
		Map.entry("wyrm", CollectionLogCategorySlug.colossal_wyrm_agility),
		Map.entry("ba", CollectionLogCategorySlug.barbarian_assault),
		Map.entry("assault", CollectionLogCategorySlug.barbarian_assault),
		Map.entry("barbarian", CollectionLogCategorySlug.barbarian_assault),
		Map.entry("brimhaven", CollectionLogCategorySlug.brimhaven_agility_arena),
		Map.entry("trawler", CollectionLogCategorySlug.fishing_trawler),
		Map.entry("wars", CollectionLogCategorySlug.castle_wars),
		Map.entry("totems", CollectionLogCategorySlug.vale_totems),
		Map.entry("restaurant", CollectionLogCategorySlug.gnome_restaurant),
		Map.entry("mta", CollectionLogCategorySlug.magic_training_arena),
		Map.entry("foundry", CollectionLogCategorySlug.giants_foundry),
		Map.entry("mh", CollectionLogCategorySlug.mahogany_homes),
		Map.entry("homes", CollectionLogCategorySlug.mahogany_homes),
		Map.entry("mahogany", CollectionLogCategorySlug.mahogany_homes),
		Map.entry("temp", CollectionLogCategorySlug.tempoross),

		// === Miscellaneous ===
		Map.entry("misc", CollectionLogCategorySlug.miscellaneous),
		Map.entry("pets", CollectionLogCategorySlug.all_pets),
		Map.entry("skilling", CollectionLogCategorySlug.skilling_pets),

		// === Raids & Endgame ===
		Map.entry("cg", CollectionLogCategorySlug.the_gauntlet),
		Map.entry("gauntlet", CollectionLogCategorySlug.the_gauntlet),
		Map.entry("colosseum", CollectionLogCategorySlug.fortis_colosseum),
		Map.entry("colo", CollectionLogCategorySlug.fortis_colosseum),
		Map.entry("cox", CollectionLogCategorySlug.chambers_of_xeric),
		Map.entry("chambers", CollectionLogCategorySlug.chambers_of_xeric),
		Map.entry("fightcaves", CollectionLogCategorySlug.the_fight_caves),
		Map.entry("jad", CollectionLogCategorySlug.the_fight_caves),
		Map.entry("inferno", CollectionLogCategorySlug.the_inferno),
		Map.entry("zuk", CollectionLogCategorySlug.the_inferno),
		Map.entry("toa", CollectionLogCategorySlug.tombs_of_amascut),
		Map.entry("tombs", CollectionLogCategorySlug.tombs_of_amascut),
		Map.entry("tob", CollectionLogCategorySlug.theatre_of_blood),
		Map.entry("theatre", CollectionLogCategorySlug.theatre_of_blood)
	);

	/**
	 * Builds a list of alises grouped by their category slug,
	 * e.g. kreearra=[armadyl, kree, arma]
	 * Used to provide a list of aliases when using the help commands
	 */
	public static final Map<String, Set<String>> INVERTED_ALIASES = CATEGORY_ALIASES
		.entrySet()
		.stream()
		.collect(
			Collectors.groupingBy(
				item -> item.getValue().toString(),
				Collectors.mapping(
					Map.Entry::getKey,
					Collectors.toSet()
				)
			)
		);

	public static final Map<String, CollectionLogCategory> CUSTOM_CATEGORIES = Map.ofEntries(
		Map.entry(
			CollectionLogCategorySlug.gilded.name(),
			new CollectionLogCategory(
				"Gilded",
				new LinkedHashSet<>(
					Arrays.asList(
						ItemID.RUNE_FULL_HELM_GOLDPLATE,
						ItemID.RUNE_PLATEBODY_GOLDPLATE,
						ItemID.RUNE_PLATELEGS_GOLDPLATE,
						ItemID.RUNE_PLATESKIRT_GOLDPLATE,
						ItemID.RUNE_KITESHIELD_GOLDPLATE,
						ItemID.RUNE_MED_HELM_GOLD,
						ItemID.RUNE_CHAINBODY_GOLD,
						ItemID.RUNE_SQ_SHIELD_GOLD,
						ItemID.RUNE_2H_SWORD_GOLD,
						ItemID.RUNE_SPEAR_GOLD,
						ItemID.BRUT_RUNE_SPEAR_GOLD,
						ItemID.RUNE_SCIMITAR_GOLD,
						ItemID.RUNE_BOOTS_GOLD,
						ItemID.TRAIL_GILDED_DHIDE_COIF,
						ItemID.TRAIL_GILDED_DHIDE_VAMBRACES,
						ItemID.TRAIL_GILDED_DHIDE_TOP,
						ItemID.TRAIL_GILDED_DHIDE_CHAPS,
						ItemID.TRAIL_GILDED_PICKAXE,
						ItemID.TRAIL_GILDED_AXE,
						ItemID.TRAIL_GILDED_SPADE
					)
				)
			)
		),
		Map.entry(
			CollectionLogCategorySlug.thirdage.name(),
			new CollectionLogCategory(
				"Third age",
				new LinkedHashSet<>(
					Arrays.asList(
						ItemID._3A_PICKAXE,
						ItemID._3A_AXE,
						ItemID._3A_DRUIDIC_TOP,
						ItemID._3A_DRUIDIC_BOTTOMS,
						ItemID._3A_DRUIDIC_STAFF,
						ItemID._3A_DRUIDIC_CLOAK,
						ItemID.TRAIL_FIGHTER_SWORD,
						ItemID.TRAIL_MAGE_WAND,
						ItemID.TRAIL_THIRD_CAPE,
						ItemID.TRAIL_RANGER_BOW,
						ItemID.TRAIL_RANGER_COIF,
						ItemID.TRAIL_RANGER_TORSO,
						ItemID.TRAIL_RANGER_LEGS,
						ItemID.TRAIL_RANGER_VAMBRACES,
						ItemID.TRAIL_MAGE_HAT,
						ItemID.TRAIL_MAGE_TORSO,
						ItemID.TRAIL_MAGE_LEGS,
						ItemID.TRAIL_MAGE_AMULET,
						ItemID.TRAIL_FIGHTER_HELM,
						ItemID.TRAIL_SILVER_PLATE_CHEST,
						ItemID.TRAIL_SILVER_PLATE_LEGS,
						ItemID.TRAIL_SILVER_PLATE_SKIRT,
						ItemID.TRAIL_FIGHTER_SHIELD
					)
				)
			)
		)
	);
}
package com.templeosrs.util.collections.utils;

public class PlayerNameUtils
{
	/**
	 * Normalises the player's name by removing Ironman prefixes and formatting.
	 *
	 * @param playerName The player name to normalise.
	 * @return The normalised player name.
	 */
	public static String normalizePlayerName(String playerName)
	{
		if (playerName == null)
		{
			return "";
		}

		// Replace non-breaking space and other unusual whitespace with normal space
		String normalizedName = playerName.replace('\u00A0', ' ')
			.replaceAll("\\s+", " ")
			.trim();

		// Remove known Ironman prefixes
		String[] ironmanPrefixes = {"Ultimate Ironman", "Hardcore Ironman", "Ironman"};
		for (String prefix : ironmanPrefixes)
		{
			if (normalizedName.startsWith(prefix))
			{
				normalizedName = normalizedName.replaceFirst(prefix, "").trim();
				break;
			}
		}

		// Remove <img=xx> tags
		normalizedName = normalizedName.replaceAll("<img=\\d+>", "").trim();

		// Replace spaces with underscores and lowercase
		normalizedName = normalizedName.replace(' ', '_').toLowerCase();

		return normalizedName;
	}
}
package com.templeosrs.util.comp;

import com.google.gson.Gson;
import java.util.Objects;

public class TempleCompetition
{
	public boolean error = false;

	public TempleCompetitionResponse compOverview;

	public TempleCompetition(String competitionJSON, Gson gson)
	{
		compOverview = gson.fromJson(competitionJSON, TempleCompetitionResponse.class);

		if (Objects.nonNull(compOverview.error))
		{
			error = true;
		}
	}

}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;
import java.util.List;

public class TempleCompetitionData
{
	@SerializedName("info")
	public TempleCompetitionInfo info;

	@SerializedName("participants")
	public List<TempleCompetitionParticipant> participants = null;
}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;

public class TempleCompetitionInfo
{
	@SerializedName("id")
	public Integer id;

	@SerializedName("name")
	public String name;

	@SerializedName("team_competition")
	public Boolean teamCompetition;

	@SerializedName("participant_count")
	public Integer participantCount;

	@SerializedName("skill")
	public String skill;

	@SerializedName("skill_index")
	public Integer skillIndex;

	@SerializedName("start_date")
	public String startDate;

	@SerializedName("end_date")
	public String endDate;

	@SerializedName("status")
	public Integer status;

	@SerializedName("status_text")
	public String statusText;
}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;

public class TempleCompetitionParticipant
{
	@SerializedName("username")
	public String username;

	@SerializedName("xp_gained")
	public Double xpGained;

	@SerializedName("start_xp")
	public Double startXp;

	@SerializedName("end_xp")
	public Double endXp;

	@SerializedName("start_level")
	public Double startLevel;

	@SerializedName("current_level")
	public Double currentLevel;

	@SerializedName("team_name")
	public String teamName;
}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TempleCompetitionResponse
{
	@SerializedName("data")
	public TempleCompetitionData data;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util;

import java.util.HashMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum CurrentTopRanges
{
	Day("Day", "day"),
	Week("Week", "week"),
	Month("Month", "month");

	private static final Map<String, PlayerRanges> lookup = new HashMap<>();

	static
	{
		for (PlayerRanges r : PlayerRanges.values())
		{
			lookup.put(r.getName(), r);
		}
	}

	private final String name;
	private final String range;

	public String getName()
	{
		return this.name;
	}

}

/*
 * Copyright (c) 2018, John Pettenger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.templeosrs.util;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Inject;
import com.templeosrs.TempleOSRSConfig;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;

@Slf4j
@Singleton
public
class NameAutocompleter implements KeyListener
{
	/**
	 * Non-breaking space character.
	 */
	private static final String NBSP = Character.toString((char) 160);

	/**
	 * Character class for characters that cannot be in an RSN.
	 */
	private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

	private static final int MAX_SEARCH_HISTORY = 25;

	private final Client client;
	private final TempleOSRSConfig hiscoreConfig;

	private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

	/**
	 * The name currently being autocompleted.
	 */
	private String autocompleteName;

	/**
	 * Pattern for the name currently being autocompleted.
	 */
	private Pattern autocompleteNamePattern;

	@Inject
	private NameAutocompleter(Client client, TempleOSRSConfig templeOSRSConfig)
	{
		this.client = client;
		this.hiscoreConfig = templeOSRSConfig;
	}

	@Override
	public void keyTyped(KeyEvent e)
	{
		if (!hiscoreConfig.autocomplete())
		{
			return;
		}

		final JTextComponent input = (JTextComponent) e.getSource();
		final String inputText = input.getText();

		// Only autocomplete if the selection end is at the end of the text.
		if (input.getSelectionEnd() != inputText.length())
		{
			return;
		}

		// Character to be inserted at the selection start.
		final String charToInsert = Character.toString(e.getKeyChar());

		// Don't attempt to autocomplete if the name is invalid.
		// This condition is also true when the user presses a key like backspace.
		if (INVALID_CHARS.matcher(charToInsert).find()
			|| INVALID_CHARS.matcher(inputText).find())
		{
			return;
		}

		// Check if we are already autocompleting.
		if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches())
		{
			if (isExpectedNext(input, charToInsert))
			{
				try
				{
					// Insert the character and move the selection.
					final int insertIndex = input.getSelectionStart();
					Document doc = input.getDocument();
					doc.remove(insertIndex, 1);
					doc.insertString(insertIndex, charToInsert, null);
					input.select(insertIndex + 1, input.getSelectionEnd());
				}
				catch (BadLocationException ex)
				{
					log.warn("Could not insert character.", ex);
				}

				// Prevent default behavior.
				e.consume();
			}
			else // Character to insert does not match current autocompletion. Look for another name.
			{
				newAutocomplete(e);
			}
		}
		else // Search for a name to autocomplete
		{
			newAutocomplete(e);
		}
	}

	@Override
	public void keyPressed(KeyEvent e)
	{

	}

	@Override
	public void keyReleased(KeyEvent e)
	{

	}

	private void newAutocomplete(KeyEvent e)
	{
		final JTextComponent input = (JTextComponent) e.getSource();
		final String inputText = input.getText();
		final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

		if (findAutocompleteName(nameStart))
		{
			// Assert this.autocompleteName != null
			final String name = this.autocompleteName;
			SwingUtilities.invokeLater(() ->
			{
				try
				{
					input.getDocument().insertString(
						nameStart.length(),
						name.substring(nameStart.length()),
						null);
					input.select(nameStart.length(), name.length());
				}
				catch (BadLocationException ex)
				{
					log.warn("Could not autocomplete name.", ex);
				}
			});
		}
	}

	private boolean findAutocompleteName(String nameStart)
	{
		final Pattern pattern;
		Optional<String> autocompleteName;

		// Pattern to match names that start with nameStart.
		// Allows spaces to be represented as common whitespaces, underscores,
		// hyphens, or non-breaking spaces.
		// Matching non-breaking spaces is necessary because the API
		// returns non-breaking spaces when a name has whitespace.
		pattern = Pattern.compile(
			"(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

		// Search all previous successful queries
		autocompleteName = searchHistory.stream()
			.filter(n -> pattern.matcher(n).matches())
			.findFirst();

		// Search friends if previous searches weren't matched
		if (!autocompleteName.isPresent())
		{
			NameableContainer<Friend> friendContainer = client.getFriendContainer();
			if (friendContainer != null)
			{
				autocompleteName = Arrays.stream(friendContainer.getMembers())
					.map(Nameable::getName)
					.filter(n -> pattern.matcher(n).matches())
					.findFirst();
			}
		}

		// Search friends chat if a friend wasn't found
		if (!autocompleteName.isPresent())
		{
			final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
			if (friendsChatManager != null)
			{
				autocompleteName = Arrays.stream(friendsChatManager.getMembers())
					.map(Nameable::getName)
					.filter(n -> pattern.matcher(n).matches())
					.findFirst();
			}
		}

		// Search clans
		if (!autocompleteName.isPresent())
		{
			final ClanSettings[] clanSettings = {
				client.getClanSettings(ClanID.CLAN),
				client.getClanSettings(ClanID.GROUP_IRONMAN),
				client.getGuestClanSettings()
			};
			autocompleteName = Arrays.stream(clanSettings)
				.filter(Objects::nonNull)
				.flatMap(cs -> cs.getMembers().stream())
				.map(ClanMember::getName)
				.filter(n -> pattern.matcher(n).matches())
				.findFirst();
		}

		// Search cached players if a friend wasn't found
		if (!autocompleteName.isPresent())
		{
			WorldView wv = client.getTopLevelWorldView();
			autocompleteName = wv.players().stream()
				.filter(Objects::nonNull)
				.map(Player::getName)
				.filter(Objects::nonNull)
				.filter(n -> pattern.matcher(n).matches())
				.findFirst();
		}

		if (autocompleteName.isPresent())
		{
			this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
			this.autocompleteNamePattern = Pattern.compile(
				"(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
		}
		else
		{
			this.autocompleteName = null;
			this.autocompleteNamePattern = null;
		}

		return autocompleteName.isPresent();
	}

	void addToSearchHistory(@NonNull String name)
	{
		if (!searchHistory.contains(name))
		{
			searchHistory.offer(name);
		}
	}

	private boolean isExpectedNext(JTextComponent input, String nextChar)
	{
		String expected;
		if (input.getSelectionStart() < input.getSelectionEnd())
		{
			try
			{
				expected = input.getText(input.getSelectionStart(), 1);
			}
			catch (BadLocationException ex)
			{
				log.warn("Could not get first character from input selection.", ex);
				return false;
			}
		}
		else
		{
			expected = "";
		}
		return nextChar.equalsIgnoreCase(expected);
	}
}
package com.templeosrs.util.player;

import com.google.gson.Gson;
import java.util.Objects;

public class TemplePlayer
{
	public boolean error = false;

	public TemplePlayerResponse playerSkillsOverview;

	public TemplePlayerResponse playerBossesOverview;

	public TemplePlayer(String playerSkillsOverviewJSON, String playerBossingOverviewJSON, Gson gson)
	{
		playerSkillsOverview = gson.fromJson(playerSkillsOverviewJSON, TemplePlayerResponse.class);
		playerBossesOverview = gson.fromJson(playerBossingOverviewJSON, TemplePlayerResponse.class);

		if (Objects.nonNull(playerSkillsOverview.error) || Objects.nonNull(playerBossesOverview.error))
		{
			error = true;
		}
	}
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;
import java.util.Map;

public class TemplePlayerData
{
	@SerializedName("info")
	public TemplePlayerInfo info;

	@SerializedName("table")
	public Map<String, TemplePlayerSkill> table;

	@SerializedName("graph")
	public TemplePlayerGraph graph;
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;
import java.util.List;

public class TemplePlayerGraph
{
	@SerializedName("skill")
	public String skill;

	@SerializedName("skill_index")
	public Integer skillIndex;

	@SerializedName("xp")
	public List<Double> xp = null;

	@SerializedName("rank")
	public List<Double> rank = null;

	@SerializedName("date")
	public List<String> date = null;
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;

public class TemplePlayerInfo
{
	@SerializedName("name")
	public String name;

	@SerializedName("tracking_start")
	public String trackingStart;

	@SerializedName("tracking_end")
	public String trackingEnd;

	@SerializedName("tracking_type")
	public String trackingType;

	@SerializedName("tracking_ehp_index")
	public String trackingEhpIndex;

	@SerializedName("tracking_length_text")
	public String trackingLengthText;

	@SerializedName("last_check")
	public String lastCheck;

	@SerializedName("last_change")
	public String lastChange;

	@SerializedName("last_check_text")
	public String lastCheckText;

	@SerializedName("last_change_text")
	public String lastChangeText;

	@SerializedName("xp_drop")
	public String xpDrop;

	@SerializedName("xp_drop_text")
	public String xpDropText;

	@SerializedName("earliest")
	public String earliest;

	@SerializedName("earliest_text")
	public String earliestText;

	@SerializedName("total_dp_count")
	public String totalDpCount;

	@SerializedName("cooldown")
	public String cooldown;

	@SerializedName("days")
	public String days;

	@SerializedName("hours_played")
	public String hoursPlayed;

	@SerializedName("hours_per_day")
	public String hoursPerDay;

	@SerializedName("xp_gained")
	public String xpGained;

	@SerializedName("xp_per_day")
	public String xpPerDay;

	@SerializedName("avr_xph")
	public String avrXph;

	@SerializedName("top_skill")
	public String topSkill;

	@SerializedName("gp_spent")
	public String gpSpent;
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TemplePlayerResponse
{
	@SerializedName("data")
	public TemplePlayerData data;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;

public class TemplePlayerSkill
{
	@SerializedName("index")
	public Integer index;

	@SerializedName("xp")
	public Double xp;

	@SerializedName("xp_total")
	public Double xpTotal;

	@SerializedName("rank")
	public Double rank;

	@SerializedName("rank_total")
	public Double rankTotal;

	@SerializedName("level")
	public Double level;

	@SerializedName("level_total")
	public Double levelTotal;

	@SerializedName("ehp")
	public Double ehp;

	@SerializedName("ehb")
	public Double ehb;
}


package com.templeosrs.util;

import java.util.HashMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum PlayerRanges
{
	Day("Day", "1day"),
	Week("Week", "1week"),
	Month("Month", "31day"),
	Six_Months("Six Months", "186days"),
	Year("Year", "365days"),
	All_Time("All Time", "alltime");

	private static final Map<String, PlayerRanges> lookup = new HashMap<>();

	static
	{
		for (PlayerRanges r : PlayerRanges.values())
		{
			lookup.put(r.getName(), r);
		}
	}

	private final String name;
	private final String range;

	public static PlayerRanges get(String name)
	{
		return lookup.get(name);
	}

	public String getName()
	{
		return this.name;
	}

}

package com.templeosrs.util.sync;

import com.google.gson.Gson;
import java.util.Objects;

public class TempleSync
{
	public boolean error = false;

	public TempleSyncResponse dataResponse;

	public TempleSync(String response, Gson gson)
	{
		dataResponse = gson.fromJson(response, TempleSyncResponse.class);

		if (Objects.nonNull(dataResponse.error))
		{
			error = true;
		}
	}
}

package com.templeosrs.util.sync;

import com.google.gson.annotations.SerializedName;

public class TempleSyncData
{
	@SerializedName("added_names")
	public Integer addedNames;

	@SerializedName("removed_names")
	public Integer removedNames;

	@SerializedName("old_member_count")
	public Integer oldMemberCount;

	@SerializedName("new_member_count")
	public Integer newMemberCount;
}

package com.templeosrs.util.sync;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TempleSyncResponse
{
	@SerializedName("data")
	public TempleSyncData data;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util;

import com.google.gson.annotations.SerializedName;

public class TempleError
{
	@SerializedName("Code")
	public Integer code;

	@SerializedName("Message")
	public String message;
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.hiscore.HiscoreSkillType;
import static net.runelite.client.hiscore.HiscoreSkillType.ACTIVITY;
import static net.runelite.client.hiscore.HiscoreSkillType.BOSS;
import static net.runelite.client.hiscore.HiscoreSkillType.SKILL;

@AllArgsConstructor
@Getter
public enum TempleHiscoreSkill
{
	OVERALL("Overall", SKILL),
	ATTACK("Attack", SKILL),
	DEFENCE("Defence", SKILL),
	STRENGTH("Strength", SKILL),
	HITPOINTS("Hitpoints", SKILL),
	RANGED("Ranged", SKILL),
	PRAYER("Prayer", SKILL),
	MAGIC("Magic", SKILL),
	COOKING("Cooking", SKILL),
	WOODCUTTING("Woodcutting", SKILL),
	FLETCHING("Fletching", SKILL),
	FISHING("Fishing", SKILL),
	FIREMAKING("Firemaking", SKILL),
	CRAFTING("Crafting", SKILL),
	SMITHING("Smithing", SKILL),
	MINING("Mining", SKILL),
	HERBLORE("Herblore", SKILL),
	AGILITY("Agility", SKILL),
	THIEVING("Thieving", SKILL),
	SLAYER("Slayer", SKILL),
	FARMING("Farming", SKILL),
	RUNECRAFT("Runecraft", SKILL),
	HUNTER("Hunter", SKILL),
	CONSTRUCTION("Construction", SKILL),
	EHP("Ehp", SKILL),
	CLUE_ALL("Clue All", ACTIVITY),
	CLUE_BEGINNER("Clue Beginner", ACTIVITY),
	CLUE_EASY("Clue Easy", ACTIVITY),
	CLUE_MEDIUM("Clue Medium", ACTIVITY),
	CLUE_HARD("Clue Hard", ACTIVITY),
	CLUE_ELITE("Clue Elite", ACTIVITY),
	CLUE_MASTER("Clue Master", ACTIVITY),
	LAST_MAN_STANDING("Last Man Standing", ACTIVITY),
	ABYSSAL_SIRE("Abyssal Sire", BOSS),
	ALCHEMICAL_HYDRA("Alchemical Hydra", BOSS),
	BARROWS_CHESTS("Barrows Chests", BOSS),
	BRYOPHYTA("Bryophyta", BOSS),
	CALLISTO("Callisto", BOSS),
	CERBERUS("Cerberus", BOSS),
	CHAMBERS_OF_XERIC("Chambers of Xeric", BOSS),
	CHAMBERS_OF_XERIC_CHALLENGE_MODE("Chambers of Xeric Challenge Mode", BOSS),
	CHAOS_ELEMENTAL("Chaos Elemental", BOSS),
	CHAOS_FANATIC("Chaos Fanatic", BOSS),
	COMMANDER_ZILYANA("Commander Zilyana", BOSS),
	CORPOREAL_BEAST("Corporeal Beast", BOSS),
	CRAZY_ARCHAEOLOGIST("Crazy Archaeologist", BOSS),
	DAGANNOTH_PRIME("Dagannoth Prime", BOSS),
	DAGANNOTH_REX("Dagannoth Rex", BOSS),
	DAGANNOTH_SUPREME("Dagannoth Supreme", BOSS),
	DERANGED_ARCHAEOLOGIST("Deranged Archaeologist", BOSS),
	GENERAL_GRAARDOR("General Graardor", BOSS),
	GIANT_MOLE("Giant Mole", BOSS),
	GROTESQUE_GUARDIANS("Grotesque Guardians", BOSS),
	HESPORI("Hespori", BOSS),
	KALPHITE_QUEEN("Kalphite Queen", BOSS),
	KING_BLACK_DRAGON("King Black Dragon", BOSS),
	KRAKEN("Kraken", BOSS),
	KREEARRA("KreeArra", BOSS),
	KRIL_TSUTSAROTH("Kril Tsutsaroth", BOSS),
	MIMIC("Mimic", BOSS),
	OBOR("Obor", BOSS),
	SARACHNIS("Sarachnis", BOSS),
	SCORPIA("Scorpia", BOSS),
	SKOTIZO("Skotizo", BOSS),
	THE_GAUNTLET("The Gauntlet", BOSS),
	THE_CORRUPTED_GAUNTLET("The Corrupted Gauntlet", BOSS),
	THEATRE_OF_BLOOD("Theatre of Blood", BOSS),
	THERMONUCLEAR_SMOKE_DEVIL("Thermonuclear Smoke Devil", BOSS),
	TZKAL_ZUK("TzKal-Zuk", BOSS),
	TZTOK_JAD("TzTok-Jad", BOSS),
	VENENATIS("Venenatis", BOSS),
	VETION("Vetion", BOSS),
	VORKATH("Vorkath", BOSS),
	WINTERTODT("Wintertodt", BOSS),
	ZALCANO("Zalcano", BOSS),
	ZULRAH("Zulrah", BOSS),
	EHB("Ehb", BOSS),
	IRON_EHB("Iron Ehb", BOSS),
	EHP_EHB("Ehp + Ehb", BOSS),
	IRON_EHP("Iron Ehp", SKILL),
	F2P_EHP("F2P Ehp", SKILL),
	LVL3_EHP("Lvl-3 Ehp", SKILL),
	THE_NIGHTMARE("The Nightmare", BOSS),
	SOUL_WARS_ZEAL("Soul Wars Zeal", ACTIVITY),
	TEMPOROSS("Tempoross", BOSS),
	THEATRE_OF_BLOOD_CHALLENGE_MODE("Theatre of Blood Challenge Mode", BOSS),
	BOUNTY_HUNTER_HUNTER("Bounty Hunter - Hunter", ACTIVITY),
	BOUNTY_HUNTER_ROGUE("Bounty Hunter - Rogue", ACTIVITY),
	PHOSANIS_NIGHTMARE("Phosanis Nightmare", BOSS),
	NEX("Nex", BOSS),
	RIFTS_CLOSED("Rifts closed", BOSS),
	UIM_EHP("UIM Ehp", SKILL),
	PVP_ARENA("PvP Arena", SKILL),
	TOMBS_OF_AMASCUT("Tombs of Amascut", BOSS),
	TOMBS_OF_AMASCUT_EXPERT("Tombs of Amascut Expert", BOSS),
	PHANTOM_MUSPAH("Phantom Muspah", BOSS),
	ARTIO("Artio", BOSS),
	CALVARION("Calvarion", BOSS),
	SPINDEL("Spindel", BOSS),
	FANTASY_EHP("Fantasy Ehp", SKILL),
	DUKE_SUCELLUS("Duke Sucellus", BOSS),
	THE_LEVIATHAN("The Leviathan", BOSS),
	THE_WHISPERER("The Whisperer", BOSS),
	VARDORVIS("Vardorvis", BOSS),
	SCURRIUS("Scurrius", BOSS),
	LUNAR_CHESTS("Lunar Chests", BOSS),
	SOL_HEREDIT("Sol Heredit", BOSS),
	ARAXXOR("Araxxor", BOSS),
	HUEYCOATL("Hueycoatl", BOSS),
	AMOXLIATL("Amoxliatl", BOSS),
	COLLECTIONS("Collections", BOSS),
	THE_ROYAL_TITANS("The Royal Titans", BOSS);


	private final String name;
	private final HiscoreSkillType type;
}

package com.templeosrs.util;

import com.google.gson.Gson;
import com.templeosrs.util.clan.TempleClan;
import com.templeosrs.util.comp.TempleCompetition;
import com.templeosrs.util.player.TemplePlayer;
import com.templeosrs.util.sync.TempleSync;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import javax.inject.Inject;
import okhttp3.Call;
import okhttp3.FormBody;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class TempleService
{
	@Inject
	private OkHttpClient client;

	@Inject
	private Gson gson;

	private String request(Request request) throws Exception
	{
		String JSON = null;

		Call call = client.newCall(request);
		Response response = call.execute();
		ResponseBody body = response.body();

		if (body != null)
		{
			JSON = body.string();
			response.close();
		}

		return JSON;
	}

	public String requestUserSkillGains(String player, String duration) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("player").addPathSegment("view").addPathSegment("overview_skilling_view.php").addQueryParameter("player", player).addQueryParameter("duration", duration).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestUserBossGains(String player, String duration) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("player").addPathSegment("view").addPathSegment("overview_skilling_view.php").addQueryParameter("player", player).addQueryParameter("duration", duration).addQueryParameter("tracking", "bosses").build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestClanOverview(String id) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("group_info.php").addQueryParameter("id", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestClanAchievements(String id) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("group_achievements.php").addQueryParameter("id", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestCompetitionInfo(String id) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("competition_info.php").addQueryParameter("id", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestClanCurrentTop(String skill, String id, String range) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("current_top").addPathSegment(range + ".php").addQueryParameter("skill", skill).addQueryParameter("group", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public CompletableFuture<TemplePlayer> fetchUserGainsAsync(String player, String duration) throws Exception
	{
		String playerSkillsOverviewJSON = requestUserSkillGains(player, duration);
		String playerBossingOverviewJSON = requestUserBossGains(player, duration);

		CompletableFuture<TemplePlayer> future = new CompletableFuture<>();
		future.complete(new TemplePlayer(playerSkillsOverviewJSON, playerBossingOverviewJSON, gson));
		return future;
	}

	public CompletableFuture<TempleClan> fetchClanAsync(String id, String range) throws Exception
	{
		String clanOverviewJSON = requestClanOverview(id);
		String clanAchievementsJSON = requestClanAchievements(id);
		String clanCurrentTopEhpJSON = requestClanCurrentTop("ehp", id, range);
		String clanCurrentTopEhbJSON = requestClanCurrentTop("ehb", id, range);

		CompletableFuture<TempleClan> future = new CompletableFuture<>();
		future.complete(new TempleClan(clanOverviewJSON, clanAchievementsJSON, clanCurrentTopEhpJSON, clanCurrentTopEhbJSON, gson));
		return future;
	}

	public CompletableFuture<TempleCompetition> fetchCompetitionAsync(String id) throws Exception
	{
		String competitionOverviewJSON = requestCompetitionInfo(id);

		CompletableFuture<TempleCompetition> future = new CompletableFuture<>();
		future.complete(new TempleCompetition(competitionOverviewJSON, gson));
		return future;
	}

	public CompletableFuture<TempleSync> syncClanMembersAsync(String id, String key, List<String> members) throws Exception
	{
		String syncResponseJSON;

		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("edit_group.php").build();

		RequestBody formBody = new FormBody.Builder().add("id", id).add("key", key).add("memberlist", String.valueOf(members)).build();

		Request request = new Request.Builder().url(url).post(formBody).build();

		syncResponseJSON = request(request);

		CompletableFuture<TempleSync> future = new CompletableFuture<>();
		future.complete(new TempleSync(syncResponseJSON, gson));
		return future;
	}

	public CompletableFuture<TempleSync> addClanMembersAsync(String id, String key, List<String> members) throws Exception
	{
		String syncResponseJSON;

		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("add_group_member.php").build();

		RequestBody formBody = new FormBody.Builder().add("id", id).add("key", key).add("players", String.valueOf(members)).build();

		Request request = new Request.Builder().url(url).post(formBody).build();

		syncResponseJSON = request(request);

		CompletableFuture<TempleSync> future = new CompletableFuture<>();
		future.complete(new TempleSync(syncResponseJSON, gson));
		return future;
	}

	public void addDatapointAsync(String username, long accountHash) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("php").addPathSegment("add_datapoint.php").addQueryParameter("player", username).addQueryParameter("accountHash", Long.toString(accountHash)).build();

		Request request = new Request.Builder().url(url).build();

		request(request);
	}
}

package com.templeosrs.collectionlog.autosync;

import java.util.HashSet;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class CollectionLogAutoSyncChatMessageSubscriberTest extends MockedCollectionLogAutoSyncTest
{
	final String newCollectionLogItem = "Twisted bow";
	final String newCollectionLogItemMessage = String.format("New item added to your collection log: %s", newCollectionLogItem);

	@Test
	@DisplayName("Ensure obtained items are not modified for messages that are not ChatMessageType.GAMEMESSAGE")
	void doesNotAddToObtainedItemsForNonGameMessageMessages()
	{
		ChatMessage chatMessage = buildChatMessage(ChatMessageType.CLAN_MESSAGE, newCollectionLogItemMessage);

		eventBus.post(chatMessage);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getObtainedItemNames());
	}

	@Test
	@DisplayName("Ensure obtained items are not modified for messages that do not match the new collection log item pattern")
	void doesNotAddToObtainedItemsForNonMatchingGameMessages()
	{
		ChatMessage chatMessage = buildChatMessage(ChatMessageType.GAMEMESSAGE, "Some message");

		eventBus.post(chatMessage);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getObtainedItemNames());
	}

	@Test
	@DisplayName("Ensure obtained items are modified for game messages that match the new collection log item pattern")
	void addsToObtainedItemsForMatchingGameMessages()
	{
		triggerNewCollectionLogItemChatMessageEvent(newCollectionLogItem);

		HashSet<String> expectedObtainedItems = new HashSet<>();

		expectedObtainedItems.add(newCollectionLogItem);

		assertEquals(expectedObtainedItems, collectionLogAutoSyncManager.getObtainedItemNames());
	}
}

package com.templeosrs.collectionlog.autosync;

import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

public class CollectionLogAutoSyncConfigCheckerTest extends MockedCollectionLogAutoSyncTest
{
	@Test
	@DisplayName("Ensure a warning is not displayed on login when the \"new collection log\" option is enabled")
	void doesNotEmitWarningWhenNewCollectionLogOptionIsEnabled()
	{
		setCollectionLogOptionValue(1);

		logIn();

		verify(chatMessageManager, never()).queue(any(QueuedMessage.class));
	}

	@Test
	@DisplayName("Ensure a warning is displayed on login when the \"new collection log\" option is disabled")
	void emitsWarningWhenNewCollectionLogOptionIsDisabled()
	{
		logIn();
		setCollectionLogOptionValue(0);

		verifyChatMessageHasBeenDisplayedTimes(1);
	}

	@Test
	@DisplayName("Ensure a warning is not displayed if it has already been shown for the current session")
	void doesNotEmitWarningWhenWarningHasBeenShownForCurrentSession()
	{
		logIn();
		setCollectionLogOptionValue(0);

		verifyChatMessageHasBeenDisplayedTimes(1);

		hopWorld();
		verifyChatMessageHasBeenDisplayedTimes(1);
	}

	@Test
	@DisplayName("Ensure a warning is displayed when starting a new login session when the \"new collection log\"  option is disabled")
	void emitsWarningWhenStartingNewSession()
	{
		logIn();
		setCollectionLogOptionValue(0);

		verifyChatMessageHasBeenDisplayedTimes(1);

		logOut();
		logIn();
		setCollectionLogOptionValue(0);
		verifyChatMessageHasBeenDisplayedTimes(2);
	}

	private void verifyChatMessageHasBeenDisplayedTimes(int expectedTimes)
	{
		String highlightedMessage = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append("Please enable \"Collection log - New addition notification\" in your game settings for " +
				"TempleOSRS to automatically sync your collection log!")
			.build();

		final QueuedMessage expectedQueuedMessage = QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(highlightedMessage)
			.build();

		verify(chatMessageManager, times(expectedTimes)).queue(expectedQueuedMessage);
	}
}

package com.templeosrs.collectionlog.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import net.runelite.api.events.GameTick;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.mockito.Mockito.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class CollectionLogAutoSyncGameTickSubscriberTest extends MockedCollectionLogAutoSyncTest
{
	@Test
	@DisplayName("Ensure no request is made if the game tick to sync has not been set")
	void doesNotRequestIfGameTickToSyncIsUnset()
	{
		GameTick gameTick = new GameTick();

		collectionLogAutoSyncManager.getPendingSyncItems().add(
			new ObtainedCollectionItem(1, "Item name", 1)
		);

		eventBus.post(gameTick);

		verify(scheduledExecutorService, never()).execute(any(Runnable.class));
	}

	@Test
	@DisplayName("Ensure no request is made if the pending sync items is empty")
	void doesNotRequestIfPendingSyncItemsIsEmpty()
	{
		GameTick gameTick = new GameTick();

		collectionLogAutoSyncManager.startSyncCountdown();

		eventBus.post(gameTick);

		verify(scheduledExecutorService, never()).execute(any(Runnable.class));
	}

	@Test
	@DisplayName("Ensure a request is made if the game tick to sync is less than or equal to the client game tick, and the pending sync items list is not empty")
	void requestsIfGameTickToSyncHasPassedAndItemsArePendingSync()
	{
		GameTick gameTick = new GameTick();

		collectionLogAutoSyncManager.startSyncCountdown();
		collectionLogAutoSyncManager.getPendingSyncItems().add(
			new ObtainedCollectionItem(1, "Item name", 1)
		);

		final String username = "CousinOfKos";
		final long accountHash = 1234567890;

		when(player.getName()).thenReturn(username);
		when(client.getLocalPlayer()).thenReturn(player);
		when(client.getAccountHash()).thenReturn(accountHash);
		when(client.getTickCount()).thenReturn(100);

		eventBus.post(gameTick);

		verify(scheduledExecutorService, times(1)).execute(any(Runnable.class));
	}
}

package com.templeosrs.collectionlog.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import java.util.HashSet;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

public class CollectionLogAutoSyncItemContainerChangedSubscriberTest extends MockedCollectionLogAutoSyncTest
{
	@BeforeEach
		// In-game, the chat message triggers before the inventory is updated with new items, so emulate this in the tests
	void setupChatMessageEventAndTrigger()
	{
		triggerNewCollectionLogItemChatMessageEvent("Twisted bow");
	}

	@Test
	@DisplayName("Ensure the pending items are not modified when the changed container is not the inventory")
	void doesNotAddToPendingItemsForNonInventoryContainers()
	{
		ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
			InventoryID.DREAM_BANK_INVENTORY,
			new Item[]{}
		);

		eventBus.post(itemContainerChanged);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the pending items are not modified when no inventory items are found in the obtained items list")
	void doesNotAddToPendingItemsWhenNoInventoryItemsMatchObtainedItems()
	{
		final Item[] mockItems = {
			new Item(ItemID.BONES, 1)
		};

		ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
			InventoryID.INV,
			mockItems
		);

		eventBus.post(itemContainerChanged);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the pending items are modified when inventory items are found in the obtained items list")
	void addsToPendingItemsWhenInventoryItemsMatchObtainedItems()
	{
		final Item[] mockItems = {
			new Item(ItemID.TWISTED_BOW, 42)
		};

		ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
			InventoryID.INV,
			mockItems
		);

		when(itemComposition.getName()).thenReturn("Twisted bow");

		eventBus.post(itemContainerChanged);

		HashSet<ObtainedCollectionItem> expectedHashSet = new HashSet<>();
		expectedHashSet.add(new ObtainedCollectionItem(ItemID.TWISTED_BOW, "Twisted bow", 42));

		assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the sync countdown is started when inventory items are found in the obtained items list")
	void startsSyncCountdownWhenInventoryItemsMatchObtainedItems()
	{
		final Item[] mockItems = {
			new Item(ItemID.TWISTED_BOW, 1)
		};

		ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
			InventoryID.INV,
			mockItems
		);

		when(itemComposition.getName()).thenReturn("Twisted bow");
		when(client.getTickCount()).thenReturn(100);

		eventBus.post(itemContainerChanged);

		assertEquals(117, collectionLogAutoSyncManager.getGameTickToSync());
	}

	@Test
	@DisplayName("Ensure any items with duplicate names are assigned to their item ID")
	void duplicateItemNamesAreAssignedToItemId()
	{
		collectionLogAutoSyncManager.getObtainedItemNames().clear();

		triggerNewCollectionLogItemChatMessageEvent("Graceful boots");

		final Item[] mockItems = {new Item(ItemID.GRACEFUL_BOOTS, 1)};
		final HashSet<ObtainedCollectionItem> expectedHashSet = new HashSet<>();

		ItemContainerChanged itemContainerChanged = new ItemContainerChanged(InventoryID.INV, itemContainer);
		when(itemContainer.getItems()).thenReturn(mockItems);

		ItemComposition gracefulBootsItemComposition = spy(ItemComposition.class);
		when(gracefulBootsItemComposition.getName()).thenReturn("Graceful boots");
		when(itemManager.getItemComposition(ItemID.GRACEFUL_BOOTS)).thenReturn(gracefulBootsItemComposition);

		expectedHashSet.add(new ObtainedCollectionItem(ItemID.GRACEFUL_BOOTS, "Graceful boots", 1));

		eventBus.post(itemContainerChanged);

		assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());

		// Trigger another collection log event that has a duplicate name to an existing item in the inventory
		triggerNewCollectionLogItemChatMessageEvent("Graceful boots");

		final Item[] mockItems2 = {
			new Item(ItemID.GRACEFUL_BOOTS_WYRM, 1)
		};

		ItemContainerChanged itemContainerChanged2 = new ItemContainerChanged(InventoryID.INV, itemContainer);

		when(itemContainer.getItems()).thenReturn(mockItems2);

		ItemComposition gracefulBootsWyrmItemComposition = spy(ItemComposition.class);
		when(gracefulBootsWyrmItemComposition.getName()).thenReturn("Graceful boots");
		when(itemManager.getItemComposition(ItemID.GRACEFUL_BOOTS_WYRM)).thenReturn(gracefulBootsWyrmItemComposition);

		expectedHashSet.add(new ObtainedCollectionItem(ItemID.GRACEFUL_BOOTS_WYRM, "Graceful boots", 1));

		eventBus.post(itemContainerChanged2);

		assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());
	}
}

package com.templeosrs.collectionlog.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import java.util.HashSet;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.mockito.Mockito.when;

public class CollectionLogAutoSyncServerNpcLootSubscriberTest extends MockedCollectionLogAutoSyncTest
{
	// In-game, the chat message triggers before the loot is received, so emulate this in the tests
	@BeforeEach
	void setupChatMessageEventAndTrigger()
	{
		triggerNewCollectionLogItemChatMessageEvent("Twisted bow");
	}

	@Test
	@DisplayName("Ensure the pending sync items list is not modified when the obtained items list is empty")
	void doesNotAddToPendingItemsWhenObtainedItemsListIsEmpty()
	{
		collectionLogAutoSyncManager.getObtainedItemNames().clear();

		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{}
		);

		eventBus.post(npcLootReceived);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the sync countdown timer is not started when the obtained items list is empty")
	void doesNotStartSyncCountdownWhenObtainedItemsListIsEmpty()
	{
		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{}
		);

		eventBus.post(npcLootReceived);

		assertNull(collectionLogAutoSyncManager.getGameTickToSync());
	}

	@Test
	@DisplayName("Ensure the pending sync items list is not modified when the loot received is not found in the obtained items list")
	void doesNotAddToPendingItemsWhenLootIsNotInObtainedItemsList()
	{
		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.BONES, 1)
			}
		);

		eventBus.post(npcLootReceived);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the sync countdown timer is not started when the loot received is not found in the obtained items list")
	void doesNotStartSyncCountdownWhenLootIsNotInObtainedItemsList()
	{
		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.BONES, 1)
			}
		);

		eventBus.post(npcLootReceived);

		assertNull(collectionLogAutoSyncManager.getGameTickToSync());
	}

	@Test
	@DisplayName("Ensure the pending sync items list is modified when the loot received is found in the obtained items list")
	void addsToPendingItemsWhenLootIsInObtainedItemsList()
	{
		when(itemComposition.getName()).thenReturn("Twisted bow");

		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.TWISTED_BOW, 42)
			}
		);

		eventBus.post(npcLootReceived);

		final HashSet<ObtainedCollectionItem> expectedHashSet = new HashSet<>();
		expectedHashSet.add(new ObtainedCollectionItem(ItemID.TWISTED_BOW, "Twisted bow", 42));

		assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the sync countdown timer is started when the loot received is found in the obtained items list")
	void startsSyncCountdownTimerWhenLootIsInObtainedItemsList()
	{
		when(itemComposition.getName()).thenReturn("Twisted bow");
		when(client.getTickCount()).thenReturn(100);

		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.TWISTED_BOW, 1)
			}
		);

		eventBus.post(npcLootReceived);

		assertEquals(117, collectionLogAutoSyncManager.getGameTickToSync());
	}
}

package com.templeosrs.collectionlog.autosync;

import com.google.inject.testing.fieldbinder.Bind;
import com.templeosrs.MockedTest;
import com.templeosrs.util.collections.autosync.CollectionLogAutoSyncManager;
import java.util.Arrays;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

public class MockedCollectionLogAutoSyncTest extends MockedTest
{
	@Bind
	protected final CollectionLogAutoSyncManager collectionLogAutoSyncManager = spy(CollectionLogAutoSyncManager.class);

	@BeforeEach
	void enableAutoSyncOption()
	{
		when(templeOSRSConfig.autoSyncClog()).thenReturn(true);
	}

	@BeforeEach
	void registerWithEventBus()
	{
		collectionLogAutoSyncManager.startUp();
	}

	@AfterEach
	void unregisterWithEventBus()
	{
		collectionLogAutoSyncManager.shutDown();
	}

	void triggerNewCollectionLogItemChatMessageEvent(String itemName)
	{
		final ChatMessage chatMessage = buildChatMessage(
			ChatMessageType.GAMEMESSAGE,
			String.format("New item added to your collection log: %s", itemName)
		);

		eventBus.post(chatMessage);
	}

	void logIn()
	{
		when(loggedInState.isLoggedOut()).thenReturn(false);

		final GameStateChanged gameStateChanged = buildGameStateChangedEvent(GameState.LOGGED_IN);

		eventBus.post(gameStateChanged);
	}

	void logOut()
	{
		when(loggedInState.isLoggedOut()).thenReturn(true);

		final GameStateChanged gameStateChanged = buildGameStateChangedEvent(GameState.LOGIN_SCREEN);

		eventBus.post(gameStateChanged);
	}

	void hopWorld()
	{
		final GameStateChanged gameStateChanged = buildGameStateChangedEvent(GameState.HOPPING);

		eventBus.post(gameStateChanged);
	}

	void setCollectionLogOptionValue(int value)
	{
		final VarbitChanged varbitChanged = new VarbitChanged();

		varbitChanged.setVarbitId(VarbitID.OPTION_COLLECTION_NEW_ITEM);
		varbitChanged.setValue(value);

		eventBus.post(varbitChanged);
	}

	NpcLootReceived buildNpcLootReceivedEvent(ItemStack[] itemStacks)
	{
		for (ItemStack value : itemStacks)
		{
			when(itemManager.getItemComposition(value.getId())).thenReturn(itemComposition);
		}

		return new NpcLootReceived(npc, Arrays.asList(itemStacks));
	}

	ChatMessage buildChatMessage(ChatMessageType type, String message)
	{
		return new ChatMessage(null, type, "", message, "", 0);
	}

	ItemContainerChanged buildItemContainerChangedEvent(int inventoryID, Item[] items)
	{
		for (Item value : items)
		{
			when(itemManager.getItemComposition(value.getId())).thenReturn(itemComposition);
		}

		when(itemContainer.getItems()).thenReturn(items);

		return new ItemContainerChanged(inventoryID, itemContainer);
	}

	GameStateChanged buildGameStateChangedEvent(GameState gameState)
	{
		final GameStateChanged gameStateChanged = new GameStateChanged();

		gameStateChanged.setGameState(gameState);

		return gameStateChanged;
	}
}

package com.templeosrs;

import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import com.templeosrs.util.collections.autosync.LoggedInState;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.xpupdater.XpUpdaterConfig;
import net.runelite.client.ui.ClientUI;
import org.junit.jupiter.api.BeforeEach;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

public class MockedTest
{
	@Bind
	protected final Client client = spy(Client.class);

	@Bind
	protected final RuneLiteConfig runeLiteConfig = mock(RuneLiteConfig.class);

	@Bind
	protected final ItemManager itemManager = mock(ItemManager.class);

	@Bind
	protected final ItemContainer itemContainer = mock(ItemContainer.class);

	@Bind
	protected final ItemComposition itemComposition = mock(ItemComposition.class);

	@Bind
	protected final Item item = mock(Item.class);

	@Bind
	protected final TempleOSRSConfig templeOSRSConfig = mock(TempleOSRSConfig.class);

	@Bind
	protected final ScheduledExecutorService scheduledExecutorService = spy(ScheduledExecutorService.class);

	@Bind
	protected final EventBus eventBus = spy(EventBus.class);

	@Bind
	protected final NPC npc = mock(NPC.class);

	@Bind
	protected final Player player = mock(Player.class);

	@Bind
	protected final ConfigManager configManager = mock(ConfigManager.class);

	@Bind
	protected final PluginManager pluginManager = mock(PluginManager.class);

	@Bind
	protected final ClientUI clientUI = mock(ClientUI.class);

	@Bind
	protected final ChatMessageManager chatMessageManager = mock(ChatMessageManager.class);

	@Bind
	protected final XpUpdaterConfig xpUpdaterConfig = mock(XpUpdaterConfig.class);

	@Bind
	protected final GameStateChanged gameStateChanged = mock(GameStateChanged.class);

	@Bind
	protected final LoggedInState loggedInState = spy(LoggedInState.class);

	@BeforeEach
	protected void beforeEach()
	{
		Guice.createInjector(BoundFieldModule.of(this));
	}
}

package com.templeosrs;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TempleOSRSPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TempleOSRSPlugin.class);
		RuneLite.main(args);
	}
}
