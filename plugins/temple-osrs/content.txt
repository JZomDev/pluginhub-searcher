package com.templeosrs.util;

import com.google.gson.Gson;
import com.templeosrs.util.clan.TempleClan;
import com.templeosrs.util.comp.TempleCompetition;
import com.templeosrs.util.player.TemplePlayer;
import com.templeosrs.util.sync.TempleSync;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import javax.inject.Inject;
import okhttp3.Call;
import okhttp3.FormBody;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class TempleService
{
	@Inject
	private OkHttpClient client;

	@Inject
	private Gson gson;

	private String request(Request request) throws Exception
	{
		String JSON = null;

		Call call = client.newCall(request);
		Response response = call.execute();
		ResponseBody body = response.body();

		if (body != null)
		{
			JSON = body.string();
			response.close();
		}

		return JSON;
	}

	public String requestUserSkillGains(String player, String duration) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("player").addPathSegment("view").addPathSegment("overview_skilling_view.php").addQueryParameter("player", player).addQueryParameter("duration", duration).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestUserBossGains(String player, String duration) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("player").addPathSegment("view").addPathSegment("overview_skilling_view.php").addQueryParameter("player", player).addQueryParameter("duration", duration).addQueryParameter("tracking", "bosses").build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestClanOverview(String id) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("group_info.php").addQueryParameter("id", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestClanAchievements(String id) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("group_achievements.php").addQueryParameter("id", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestCompetitionInfo(String id) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("competition_info.php").addQueryParameter("id", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public String requestClanCurrentTop(String skill, String id, String range) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("current_top").addPathSegment(range + ".php").addQueryParameter("skill", skill).addQueryParameter("group", id).build();

		Request request = new Request.Builder().url(url).build();

		return request(request);
	}

	public CompletableFuture<TemplePlayer> fetchUserGainsAsync(String player, String duration) throws Exception
	{
		String playerSkillsOverviewJSON = requestUserSkillGains(player, duration);
		String playerBossingOverviewJSON = requestUserBossGains(player, duration);

		CompletableFuture<TemplePlayer> future = new CompletableFuture<>();
		future.complete(new TemplePlayer(playerSkillsOverviewJSON, playerBossingOverviewJSON, gson));
		return future;
	}

	public CompletableFuture<TempleClan> fetchClanAsync(String id, String range) throws Exception
	{
		String clanOverviewJSON = requestClanOverview(id);
		String clanAchievementsJSON = requestClanAchievements(id);
		String clanCurrentTopEhpJSON = requestClanCurrentTop("ehp", id, range);
		String clanCurrentTopEhbJSON = requestClanCurrentTop("ehb", id, range);

		CompletableFuture<TempleClan> future = new CompletableFuture<>();
		future.complete(new TempleClan(clanOverviewJSON, clanAchievementsJSON, clanCurrentTopEhpJSON, clanCurrentTopEhbJSON, gson));
		return future;
	}

	public CompletableFuture<TempleCompetition> fetchCompetitionAsync(String id) throws Exception
	{
		String competitionOverviewJSON = requestCompetitionInfo(id);

		CompletableFuture<TempleCompetition> future = new CompletableFuture<>();
		future.complete(new TempleCompetition(competitionOverviewJSON, gson));
		return future;
	}

	public CompletableFuture<TempleSync> syncClanMembersAsync(String id, String key, List<String> members) throws Exception
	{
		String syncResponseJSON;

		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("edit_group.php").build();

		RequestBody formBody = new FormBody.Builder().add("id", id).add("key", key).add("memberlist", String.valueOf(members)).build();

		Request request = new Request.Builder().url(url).post(formBody).build();

		syncResponseJSON = request(request);

		CompletableFuture<TempleSync> future = new CompletableFuture<>();
		future.complete(new TempleSync(syncResponseJSON, gson));
		return future;
	}

	public CompletableFuture<TempleSync> addClanMembersAsync(String id, String key, List<String> members) throws Exception
	{
		String syncResponseJSON;

		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("api").addPathSegment("add_group_member.php").build();

		RequestBody formBody = new FormBody.Builder().add("id", id).add("key", key).add("players", String.valueOf(members)).build();

		Request request = new Request.Builder().url(url).post(formBody).build();

		syncResponseJSON = request(request);

		CompletableFuture<TempleSync> future = new CompletableFuture<>();
		future.complete(new TempleSync(syncResponseJSON, gson));
		return future;
	}

	public void addDatapointAsync(String username, long accountHash) throws Exception
	{
		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("php").addPathSegment("add_datapoint.php").addQueryParameter("player", username).addQueryParameter("accountHash", Long.toString(accountHash)).build();

		Request request = new Request.Builder().url(url).build();

		request(request);
	}
}

package com.templeosrs.util.sync;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TempleSyncResponse
{
	@SerializedName("data")
	public TempleSyncData data;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.sync;

import com.google.gson.Gson;
import java.util.Objects;

public class TempleSync
{
	public boolean error = false;

	public TempleSyncResponse dataResponse;

	public TempleSync(String response, Gson gson)
	{
		dataResponse = gson.fromJson(response, TempleSyncResponse.class);

		if (Objects.nonNull(dataResponse.error))
		{
			error = true;
		}
	}
}

package com.templeosrs.util.sync;

import com.google.gson.annotations.SerializedName;

public class TempleSyncData
{
	@SerializedName("added_names")
	public Integer addedNames;

	@SerializedName("removed_names")
	public Integer removedNames;

	@SerializedName("old_member_count")
	public Integer oldMemberCount;

	@SerializedName("new_member_count")
	public Integer newMemberCount;
}

package com.templeosrs.util.api;

import com.google.gson.annotations.SerializedName;
import lombok.Value;

@Value
public class APIError {
    @SerializedName("Code")
    int code;

    @SerializedName("Message")
    String message;

    public String toString() {
        return "HTTP " + code + ": " + message;
    }
}
package com.templeosrs.util.api;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;

import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;

import static net.runelite.http.api.RuneLiteAPI.JSON;

@Slf4j
public class RequestManager {
    @Inject
    OkHttpClient okHttpClient;

    @Inject
    private Gson gson;

    protected final String scheme = "https";

    protected final String host = "templeosrs.com";

    private Request.Builder buildRequest(@NotNull HttpUrl url)
    {
        String PLUGIN_USER_AGENT = "TempleOSRS RuneLite Plugin Collection Log Sync - For any issues/abuse Contact 44mikael on Discord (https://www.templeosrs.com)";

        return new Request.Builder()
            .addHeader("User-Agent", PLUGIN_USER_AGENT)
            .url(url);
    }

    /**
     * Initiates a synchronous request with no timeout.
     * @param request The request to be sent.
     * @return The request data.
     * @throws IOException The request error.
     */
    private String doRequest(Request request) throws IOException {
        try (Response response = okHttpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                throw new IOException(String.format("HTTP error fetching %s: %s", request.url(), response.code()));
            }

            String body = Objects.requireNonNull(response.body()).string();

            if (body.isEmpty()) {
                throw new IOException(String.format("Empty response body was returned from %s", request.url()));
            }

            return body;
        }
    }

    /**
     * Initiates a synchronous GET request.
     * @param url The URL to send the request to.
     */
    protected String get(@NotNull HttpUrl url) throws IOException {
        final Request request = buildRequest(url).get().build();

        return doRequest(request);
    }

    /**
     * Initiates a synchronous POST request with the given data.
     *
     * @param url  The URL to send the request to.
     * @param data The data to be sent in the request body.
     */
    protected String post(@NotNull HttpUrl url, @NotNull Object data) throws IOException {
        final Request request = buildRequest(url)
                .post(RequestBody.create(JSON, gson.toJson(data)))
                .build();

        return doRequest(request);
    }
}

package com.templeosrs.util.api;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class QuadraticBackoffStrategy {
    @Getter
    @Setter
    private boolean submitting = false;

    private int requestAttemptCount = 0;
    private int cycleCount = 0;

    public void reset()
    {
        submitting = false;
        requestAttemptCount = 0;
        cycleCount = 0;
    }

    public void beginNewRequestAttempt()
    {
        requestAttemptCount++;
    }

    public void finishCycle()
    {
        submitting = false;
    }

    public boolean shouldSkipRequest()
    {
        cycleCount++;

        final boolean shouldSkip = Math.pow((int) Math.sqrt(cycleCount), 2) != cycleCount;

        if (shouldSkip) {
            setSubmitting(false);

            log.debug("⚠️ Skipping request due to backoff configuration");
        } else {
            beginNewRequestAttempt();
        }

        return shouldSkip;
    }

    public boolean isRequestLimitReached()
    {
        int maxRetries = 3;
        final boolean isRequestLimitReached = requestAttemptCount >= maxRetries;

        if (isRequestLimitReached) {
            log.error("❌ Maximum number of retries reached; aborting request!");

            reset();
        }

        return isRequestLimitReached;
    }
}

package com.templeosrs.util;

import com.google.gson.annotations.SerializedName;

public class TempleError
{
	@SerializedName("Code")
	public Integer code;

	@SerializedName("Message")
	public String message;
}

/*
 * Copyright (c) 2018, John Pettenger
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.templeosrs.util;

import com.google.common.collect.EvictingQueue;
import com.google.inject.Inject;
import com.templeosrs.TempleOSRSConfig;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;
import javax.swing.text.JTextComponent;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.Nameable;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.WorldView;

@Slf4j
@Singleton
public
class NameAutocompleter implements KeyListener {
    /**
     * Non-breaking space character.
     */
    private static final String NBSP = Character.toString((char) 160);

    /**
     * Character class for characters that cannot be in an RSN.
     */
    private static final Pattern INVALID_CHARS = Pattern.compile("[^a-zA-Z0-9_ -]");

    private static final int MAX_SEARCH_HISTORY = 25;

    private final Client client;
    private final TempleOSRSConfig hiscoreConfig;

    private final EvictingQueue<String> searchHistory = EvictingQueue.create(MAX_SEARCH_HISTORY);

    /**
     * The name currently being autocompleted.
     */
    private String autocompleteName;

    /**
     * Pattern for the name currently being autocompleted.
     */
    private Pattern autocompleteNamePattern;

    @Inject
    private NameAutocompleter(Client client, TempleOSRSConfig templeOSRSConfig) {
        this.client = client;
        this.hiscoreConfig = templeOSRSConfig;
    }

    @Override
    public void keyPressed(KeyEvent e) {

    }

    @Override
    public void keyReleased(KeyEvent e) {

    }

    @Override
    public void keyTyped(KeyEvent e) {
        if (!hiscoreConfig.autocomplete()) {
            return;
        }

        final JTextComponent input = (JTextComponent) e.getSource();
        final String inputText = input.getText();

        // Only autocomplete if the selection end is at the end of the text.
        if (input.getSelectionEnd() != inputText.length()) {
            return;
        }

        // Character to be inserted at the selection start.
        final String charToInsert = Character.toString(e.getKeyChar());

        // Don't attempt to autocomplete if the name is invalid.
        // This condition is also true when the user presses a key like backspace.
        if (INVALID_CHARS.matcher(charToInsert).find()
                || INVALID_CHARS.matcher(inputText).find()) {
            return;
        }

        // Check if we are already autocompleting.
        if (autocompleteName != null && autocompleteNamePattern.matcher(inputText).matches()) {
            if (isExpectedNext(input, charToInsert)) {
                try {
                    // Insert the character and move the selection.
                    final int insertIndex = input.getSelectionStart();
                    Document doc = input.getDocument();
                    doc.remove(insertIndex, 1);
                    doc.insertString(insertIndex, charToInsert, null);
                    input.select(insertIndex + 1, input.getSelectionEnd());
                } catch (BadLocationException ex) {
                    log.warn("Could not insert character.", ex);
                }

                // Prevent default behavior.
                e.consume();
            } else // Character to insert does not match current autocompletion. Look for another name.
            {
                newAutocomplete(e);
            }
        } else // Search for a name to autocomplete
        {
            newAutocomplete(e);
        }
    }

    private void newAutocomplete(KeyEvent e) {
        final JTextComponent input = (JTextComponent) e.getSource();
        final String inputText = input.getText();
        final String nameStart = inputText.substring(0, input.getSelectionStart()) + e.getKeyChar();

        if (findAutocompleteName(nameStart)) {
            // Assert this.autocompleteName != null
            final String name = this.autocompleteName;
            SwingUtilities.invokeLater(() ->
            {
                try {
                    input.getDocument().insertString(
                            nameStart.length(),
                            name.substring(nameStart.length()),
                            null);
                    input.select(nameStart.length(), name.length());
                } catch (BadLocationException ex) {
                    log.warn("Could not autocomplete name.", ex);
                }
            });
        }
    }

    private boolean findAutocompleteName(String nameStart) {
        final Pattern pattern;
        Optional<String> autocompleteName;

        // Pattern to match names that start with nameStart.
        // Allows spaces to be represented as common whitespaces, underscores,
        // hyphens, or non-breaking spaces.
        // Matching non-breaking spaces is necessary because the API
        // returns non-breaking spaces when a name has whitespace.
        pattern = Pattern.compile(
                "(?i)^" + nameStart.replaceAll("[ _-]", "[ _" + NBSP + "-]") + ".+?");

        // Search all previous successful queries
        autocompleteName = searchHistory.stream()
                .filter(n -> pattern.matcher(n).matches())
                .findFirst();

        // Search friends if previous searches weren't matched
        if (!autocompleteName.isPresent()) {
            NameableContainer<Friend> friendContainer = client.getFriendContainer();
            if (friendContainer != null) {
                autocompleteName = Arrays.stream(friendContainer.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search friends chat if a friend wasn't found
        if (!autocompleteName.isPresent()) {
            final FriendsChatManager friendsChatManager = client.getFriendsChatManager();
            if (friendsChatManager != null) {
                autocompleteName = Arrays.stream(friendsChatManager.getMembers())
                        .map(Nameable::getName)
                        .filter(n -> pattern.matcher(n).matches())
                        .findFirst();
            }
        }

        // Search clans
        if (!autocompleteName.isPresent()) {
            final ClanSettings[] clanSettings = {
                    client.getClanSettings(ClanID.CLAN),
                    client.getClanSettings(ClanID.GROUP_IRONMAN),
                    client.getGuestClanSettings()
            };
            autocompleteName = Arrays.stream(clanSettings)
                    .filter(Objects::nonNull)
                    .flatMap(cs -> cs.getMembers().stream())
                    .map(ClanMember::getName)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        // Search cached players if a friend wasn't found
        if (!autocompleteName.isPresent()) {
            WorldView wv = client.getTopLevelWorldView();
            autocompleteName = wv.players().stream()
                    .filter(Objects::nonNull)
                    .map(Player::getName)
                    .filter(Objects::nonNull)
                    .filter(n -> pattern.matcher(n).matches())
                    .findFirst();
        }

        if (autocompleteName.isPresent()) {
            this.autocompleteName = autocompleteName.get().replace(NBSP, " ");
            this.autocompleteNamePattern = Pattern.compile(
                    "(?i)^" + this.autocompleteName.replaceAll("[ _-]", "[ _-]") + "$");
        } else {
            this.autocompleteName = null;
            this.autocompleteNamePattern = null;
        }

        return autocompleteName.isPresent();
    }

    void addToSearchHistory(@NonNull String name) {
        if (!searchHistory.contains(name)) {
            searchHistory.offer(name);
        }
    }

    private boolean isExpectedNext(JTextComponent input, String nextChar) {
        String expected;
        if (input.getSelectionStart() < input.getSelectionEnd()) {
            try {
                expected = input.getText(input.getSelectionStart(), 1);
            } catch (BadLocationException ex) {
                log.warn("Could not get first character from input selection.", ex);
                return false;
            }
        } else {
            expected = "";
        }
        return nextChar.equalsIgnoreCase(expected);
    }
}
package com.templeosrs.util.comp;

import com.google.gson.Gson;
import java.util.Objects;

public class TempleCompetition
{
	public boolean error = false;

	public TempleCompetitionResponse compOverview;

	public TempleCompetition(String competitionJSON, Gson gson)
	{
		compOverview = gson.fromJson(competitionJSON, TempleCompetitionResponse.class);

		if (Objects.nonNull(compOverview.error))
		{
			error = true;
		}
	}

}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TempleCompetitionResponse
{
	@SerializedName("data")
	public TempleCompetitionData data;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;
import java.util.List;

public class TempleCompetitionData
{
	@SerializedName("info")
	public TempleCompetitionInfo info;

	@SerializedName("participants")
	public List<TempleCompetitionParticipant> participants = null;
}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;

public class TempleCompetitionInfo
{
	@SerializedName("id")
	public Integer id;

	@SerializedName("name")
	public String name;

	@SerializedName("team_competition")
	public Boolean teamCompetition;

	@SerializedName("participant_count")
	public Integer participantCount;

	@SerializedName("skill")
	public String skill;

	@SerializedName("skill_index")
	public Integer skillIndex;

	@SerializedName("start_date")
	public String startDate;

	@SerializedName("end_date")
	public String endDate;

	@SerializedName("status")
	public Integer status;

	@SerializedName("status_text")
	public String statusText;
}

package com.templeosrs.util.comp;

import com.google.gson.annotations.SerializedName;

public class TempleCompetitionParticipant
{
	@SerializedName("username")
	public String username;

	@SerializedName("xp_gained")
	public Double xpGained;

	@SerializedName("start_xp")
	public Double startXp;

	@SerializedName("end_xp")
	public Double endXp;

	@SerializedName("start_level")
	public Double startLevel;

	@SerializedName("current_level")
	public Double currentLevel;

	@SerializedName("team_name")
	public String teamName;
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.hiscore.HiscoreSkillType;
import static net.runelite.client.hiscore.HiscoreSkillType.ACTIVITY;
import static net.runelite.client.hiscore.HiscoreSkillType.BOSS;
import static net.runelite.client.hiscore.HiscoreSkillType.SKILL;

@AllArgsConstructor
@Getter
public enum TempleHiscoreSkill
{
	OVERALL("Overall", SKILL),
	ATTACK("Attack", SKILL),
	DEFENCE("Defence", SKILL),
	STRENGTH("Strength", SKILL),
	HITPOINTS("Hitpoints", SKILL),
	RANGED("Ranged", SKILL),
	PRAYER("Prayer", SKILL),
	MAGIC("Magic", SKILL),
	COOKING("Cooking", SKILL),
	WOODCUTTING("Woodcutting", SKILL),
	FLETCHING("Fletching", SKILL),
	FISHING("Fishing", SKILL),
	FIREMAKING("Firemaking", SKILL),
	CRAFTING("Crafting", SKILL),
	SMITHING("Smithing", SKILL),
	MINING("Mining", SKILL),
	HERBLORE("Herblore", SKILL),
	AGILITY("Agility", SKILL),
	THIEVING("Thieving", SKILL),
	SLAYER("Slayer", SKILL),
	FARMING("Farming", SKILL),
	RUNECRAFT("Runecraft", SKILL),
	HUNTER("Hunter", SKILL),
	CONSTRUCTION("Construction", SKILL),
	EHP("Ehp", SKILL),
	CLUE_ALL("Clue All", ACTIVITY),
	CLUE_BEGINNER("Clue Beginner", ACTIVITY),
	CLUE_EASY("Clue Easy", ACTIVITY),
	CLUE_MEDIUM("Clue Medium", ACTIVITY),
	CLUE_HARD("Clue Hard", ACTIVITY),
	CLUE_ELITE("Clue Elite", ACTIVITY),
	CLUE_MASTER("Clue Master", ACTIVITY),
	LAST_MAN_STANDING("Last Man Standing", ACTIVITY),
	ABYSSAL_SIRE("Abyssal Sire", BOSS),
	ALCHEMICAL_HYDRA("Alchemical Hydra", BOSS),
	BARROWS_CHESTS("Barrows Chests", BOSS),
	BRYOPHYTA("Bryophyta", BOSS),
	CALLISTO("Callisto", BOSS),
	CERBERUS("Cerberus", BOSS),
	CHAMBERS_OF_XERIC("Chambers of Xeric", BOSS),
	CHAMBERS_OF_XERIC_CHALLENGE_MODE("Chambers of Xeric Challenge Mode", BOSS),
	CHAOS_ELEMENTAL("Chaos Elemental", BOSS),
	CHAOS_FANATIC("Chaos Fanatic", BOSS),
	COMMANDER_ZILYANA("Commander Zilyana", BOSS),
	CORPOREAL_BEAST("Corporeal Beast", BOSS),
	CRAZY_ARCHAEOLOGIST("Crazy Archaeologist", BOSS),
	DAGANNOTH_PRIME("Dagannoth Prime", BOSS),
	DAGANNOTH_REX("Dagannoth Rex", BOSS),
	DAGANNOTH_SUPREME("Dagannoth Supreme", BOSS),
	DERANGED_ARCHAEOLOGIST("Deranged Archaeologist", BOSS),
	GENERAL_GRAARDOR("General Graardor", BOSS),
	GIANT_MOLE("Giant Mole", BOSS),
	GROTESQUE_GUARDIANS("Grotesque Guardians", BOSS),
	HESPORI("Hespori", BOSS),
	KALPHITE_QUEEN("Kalphite Queen", BOSS),
	KING_BLACK_DRAGON("King Black Dragon", BOSS),
	KRAKEN("Kraken", BOSS),
	KREEARRA("KreeArra", BOSS),
	KRIL_TSUTSAROTH("Kril Tsutsaroth", BOSS),
	MIMIC("Mimic", BOSS),
	OBOR("Obor", BOSS),
	SARACHNIS("Sarachnis", BOSS),
	SCORPIA("Scorpia", BOSS),
	SKOTIZO("Skotizo", BOSS),
	THE_GAUNTLET("The Gauntlet", BOSS),
	THE_CORRUPTED_GAUNTLET("The Corrupted Gauntlet", BOSS),
	THEATRE_OF_BLOOD("Theatre of Blood", BOSS),
	THERMONUCLEAR_SMOKE_DEVIL("Thermonuclear Smoke Devil", BOSS),
	TZKAL_ZUK("TzKal-Zuk", BOSS),
	TZTOK_JAD("TzTok-Jad", BOSS),
	VENENATIS("Venenatis", BOSS),
	VETION("Vetion", BOSS),
	VORKATH("Vorkath", BOSS),
	WINTERTODT("Wintertodt", BOSS),
	ZALCANO("Zalcano", BOSS),
	ZULRAH("Zulrah", BOSS),
	EHB("Ehb", BOSS),
	IRON_EHB("Iron Ehb", BOSS),
	EHP_EHB("Ehp + Ehb", BOSS),
	IRON_EHP("Iron Ehp", SKILL),
	F2P_EHP("F2P Ehp", SKILL),
	LVL3_EHP("Lvl-3 Ehp", SKILL),
	THE_NIGHTMARE("The Nightmare", BOSS),
	SOUL_WARS_ZEAL("Soul Wars Zeal", ACTIVITY),
	TEMPOROSS("Tempoross", BOSS),
	THEATRE_OF_BLOOD_CHALLENGE_MODE("Theatre of Blood Challenge Mode", BOSS),
	BOUNTY_HUNTER_HUNTER("Bounty Hunter - Hunter", ACTIVITY),
	BOUNTY_HUNTER_ROGUE("Bounty Hunter - Rogue", ACTIVITY),
	PHOSANIS_NIGHTMARE("Phosanis Nightmare", BOSS),
	NEX("Nex", BOSS),
	RIFTS_CLOSED("Rifts closed", BOSS),
	UIM_EHP("UIM Ehp", SKILL),
	PVP_ARENA("PvP Arena", SKILL),
	TOMBS_OF_AMASCUT("Tombs of Amascut", BOSS),
	TOMBS_OF_AMASCUT_EXPERT("Tombs of Amascut Expert", BOSS),
	PHANTOM_MUSPAH("Phantom Muspah", BOSS),
	ARTIO("Artio", BOSS),
	CALVARION("Calvarion", BOSS),
	SPINDEL("Spindel", BOSS),
	FANTASY_EHP("Fantasy Ehp", SKILL),
	DUKE_SUCELLUS("Duke Sucellus", BOSS),
	THE_LEVIATHAN("The Leviathan", BOSS),
	THE_WHISPERER("The Whisperer", BOSS),
	VARDORVIS("Vardorvis", BOSS),
	SCURRIUS("Scurrius", BOSS),
	LUNAR_CHESTS("Lunar Chests", BOSS),
	SOL_HEREDIT("Sol Heredit", BOSS),
	ARAXXOR("Araxxor", BOSS),
	HUEYCOATL("Hueycoatl", BOSS),
	AMOXLIATL("Amoxliatl", BOSS),
	COLLECTIONS("Collections", BOSS),
	THE_ROYAL_TITANS("The Royal Titans", BOSS);


	private final String name;
	private final HiscoreSkillType type;
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;
import java.util.List;

public class TemplePlayerGraph
{
	@SerializedName("skill")
	public String skill;

	@SerializedName("skill_index")
	public Integer skillIndex;

	@SerializedName("xp")
	public List<Double> xp = null;

	@SerializedName("rank")
	public List<Double> rank = null;

	@SerializedName("date")
	public List<String> date = null;
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;
import java.util.Map;

public class TemplePlayerData
{
	@SerializedName("info")
	public TemplePlayerInfo info;

	@SerializedName("table")
	public Map<String, TemplePlayerSkill> table;

	@SerializedName("graph")
	public TemplePlayerGraph graph;
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TemplePlayerResponse
{
	@SerializedName("data")
	public TemplePlayerData data;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.player;

import com.google.gson.Gson;
import java.util.Objects;

public class TemplePlayer
{
	public boolean error = false;

	public TemplePlayerResponse playerSkillsOverview;

	public TemplePlayerResponse playerBossesOverview;

	public TemplePlayer(String playerSkillsOverviewJSON, String playerBossingOverviewJSON, Gson gson)
	{
		playerSkillsOverview = gson.fromJson(playerSkillsOverviewJSON, TemplePlayerResponse.class);
		playerBossesOverview = gson.fromJson(playerBossingOverviewJSON, TemplePlayerResponse.class);

		if (Objects.nonNull(playerSkillsOverview.error) || Objects.nonNull(playerBossesOverview.error))
		{
			error = true;
		}
	}
}

package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;

public class TemplePlayerSkill
{
	@SerializedName("index")
	public Integer index;

	@SerializedName("xp")
	public Double xp;

	@SerializedName("xp_total")
	public Double xpTotal;

	@SerializedName("rank")
	public Double rank;

	@SerializedName("rank_total")
	public Double rankTotal;

	@SerializedName("level")
	public Double level;

	@SerializedName("level_total")
	public Double levelTotal;

	@SerializedName("ehp")
	public Double ehp;

	@SerializedName("ehb")
	public Double ehb;
}


package com.templeosrs.util.player;

import com.google.gson.annotations.SerializedName;

public class TemplePlayerInfo
{
	@SerializedName("name")
	public String name;

	@SerializedName("tracking_start")
	public String trackingStart;

	@SerializedName("tracking_end")
	public String trackingEnd;

	@SerializedName("tracking_type")
	public String trackingType;

	@SerializedName("tracking_ehp_index")
	public String trackingEhpIndex;

	@SerializedName("tracking_length_text")
	public String trackingLengthText;

	@SerializedName("last_check")
	public String lastCheck;

	@SerializedName("last_change")
	public String lastChange;

	@SerializedName("last_check_text")
	public String lastCheckText;

	@SerializedName("last_change_text")
	public String lastChangeText;

	@SerializedName("xp_drop")
	public String xpDrop;

	@SerializedName("xp_drop_text")
	public String xpDropText;

	@SerializedName("earliest")
	public String earliest;

	@SerializedName("earliest_text")
	public String earliestText;

	@SerializedName("total_dp_count")
	public String totalDpCount;

	@SerializedName("cooldown")
	public String cooldown;

	@SerializedName("days")
	public String days;

	@SerializedName("hours_played")
	public String hoursPlayed;

	@SerializedName("hours_per_day")
	public String hoursPerDay;

	@SerializedName("xp_gained")
	public String xpGained;

	@SerializedName("xp_per_day")
	public String xpPerDay;

	@SerializedName("avr_xph")
	public String avrXph;

	@SerializedName("top_skill")
	public String topSkill;

	@SerializedName("gp_spent")
	public String gpSpent;
}

package com.templeosrs.util;

import java.util.HashMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum CurrentTopRanges
{
	Day("Day", "day"),
	Week("Week", "week"),
	Month("Month", "month");

	private static final Map<String, PlayerRanges> lookup = new HashMap<>();

	static
	{
		for (PlayerRanges r : PlayerRanges.values())
		{
			lookup.put(r.getName(), r);
		}
	}

	private final String name;
	private final String range;

	public String getName()
	{
		return this.name;
	}

}

package com.templeosrs.util.collections;

import com.google.gson.Gson;
import com.templeosrs.util.api.APIError;
import com.templeosrs.util.api.RequestManager;
import com.templeosrs.util.collections.autosync.PlayerDataSync;
import com.templeosrs.util.collections.data.PlayerDataSubmission;
import com.templeosrs.util.collections.data.PlayerInfoResponse;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;
import java.io.IOException;

@Slf4j
public class CollectionLogRequestManager extends RequestManager {
    @Inject
    private Gson gson;

    /**
     * Uploads newly obtained collection log items to the server.
     * Used by the auto-sync feature to automatically synchronise the collection log.
     *
     * @param data The data to be uploaded.
     * @return The API response data
     */
    public String uploadObtainedCollectionLogItems(@NotNull PlayerDataSync data) throws IOException {
        final HttpUrl url = new HttpUrl.Builder()
                .scheme(scheme)
                .host(host)
                .addPathSegments("api/collection-log/sync_new_collections.php")
                .build();

        return post(url, data);
    }

    /**
     * Uploads the full collection log to the server.
     * Triggered by the Collection Log Sync button.
     *
     * @param data The data to be uploaded.
     */
    public void uploadFullCollectionLog(@NotNull PlayerDataSubmission data) throws IOException {
        final HttpUrl url = new HttpUrl.Builder()
                .scheme(scheme)
                .host(host)
                .addPathSegments("api/collection-log/sync_collection.php")
                .build();

        post(url, data);
    }

    /**
     * Retrieves player info from the Player Info endpoint
     *
     * @param username The username to check
     * @link <a href="https://templeosrs.com/api_doc.php#Player_Information">Player Info API</a>
     */
    @NotNull
    public PlayerInfoResponse.Data getPlayerInfo(@NotNull String username) throws IOException, NullPointerException {
        final HttpUrl url = new HttpUrl.Builder()
                .scheme(scheme)
                .host(host)
                .addPathSegments("api/player_info.php")
                .addQueryParameter("player", username)
                .addQueryParameter("cloginfo", "1")
                .addQueryParameter("formattedrsn", "1")
                .build();


        String response = get(url);

        PlayerInfoResponse playerInfoResponse = gson.fromJson(response, PlayerInfoResponse.class);
        PlayerInfoResponse.Data data = playerInfoResponse.getData();
        APIError error = playerInfoResponse.getError();

        if (error != null) {
            if (error.getCode() == 402) {
                throw new NullPointerException("Player has no TempleOSRS profile");
            }

            throw new IOException(String.valueOf(error));
        }

        if (data != null) {
            return data;
        }

        throw new IOException("Unexpected response format: " + response);
    }

    /**
     * Retrieves the given player's full collection log
     * @param username The username to query
     * @return The collection log data
     * @link <a href="https://templeosrs.com/api_doc.php#Player_Collection_Log">Player Collection Log API</a>
     */
    public String getPlayerCollectionLog(@NotNull String username)
    {
        final HttpUrl url = new HttpUrl.Builder()
                .scheme(scheme)
                .host(host)
                .addPathSegments("api/collection-log/player_collection_log.php")
                .addQueryParameter("player", username)
                .addQueryParameter("categories", "all")
                .addQueryParameter("includenames", "1")
                .addQueryParameter("onlyitems", "1")
                .build();

        try {
            String response = get(url);

            if (response.contains("\"Code\":402") && response.contains("has not synced")) {
                return "error:unsynced";
            }

            return response;
        } catch (Exception e) {
            log.error("❌ Exception while fetching log for {}: {}", username, e.getMessage());

            return null;
        }
    }
}

package com.templeosrs.util.collections.utils;

public class PlayerNameUtils {
    /**
     * Normalises the player's name by removing Ironman prefixes and formatting.
     * @param playerName The player name to normalise.
     * @return The normalised player name.
     */
    public static String normalizePlayerName(String playerName) {
        if (playerName == null) return "";

        // Replace non-breaking space and other unusual whitespace with normal space
        String normalizedName = playerName.replace('\u00A0', ' ')
                .replaceAll("\\s+", " ")
                .trim();

        // Remove known Ironman prefixes
        String[] ironmanPrefixes = {"Ultimate Ironman", "Hardcore Ironman", "Ironman"};
        for (String prefix : ironmanPrefixes) {
            if (normalizedName.startsWith(prefix)) {
                normalizedName = normalizedName.replaceFirst(prefix, "").trim();
                break;
            }
        }

        // Remove <img=xx> tags
        normalizedName = normalizedName.replaceAll("<img=\\d+>", "").trim();

        // Replace spaces with underscores and lowercase
        normalizedName = normalizedName.replace(' ', '_').toLowerCase();

        return normalizedName;
    }
}
package com.templeosrs.util.collections.utils;

import lombok.Value;

import java.util.Map;
import java.util.Set;

@Value
public class CollectionLogCacheData {
    Set<Integer> itemIds;
    Map<Integer, Set<Integer>> categoryItems;
    Map<String, Integer> categoryStructIds;
    Map<Integer, Set<String>> categorySlugs;
}

package com.templeosrs.util.collections.utils;

import com.templeosrs.util.collections.CollectionLogCategorySlug;
import com.templeosrs.util.collections.data.CollectionLogCategory;
import java.util.Arrays;
import java.util.LinkedHashSet;
import net.runelite.api.gameval.ItemID;

import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class CollectionLogCategoryUtils {
    /**
     * Category aliases to be used in the !col command. e.g. "!col kree"
     */
    public static final Map<String, CollectionLogCategorySlug> CATEGORY_ALIASES = Map.<String, CollectionLogCategorySlug>ofEntries(
            // === Bosses ===
            Map.entry("armadyl", CollectionLogCategorySlug.kreearra),
            Map.entry("kree", CollectionLogCategorySlug.kreearra),
            Map.entry("arma", CollectionLogCategorySlug.kreearra),
            Map.entry("archaeologist", CollectionLogCategorySlug.crazy_archaeologist),
            Map.entry("crazy", CollectionLogCategorySlug.crazy_archaeologist),
            Map.entry("barrows", CollectionLogCategorySlug.barrows_chests),
			Map.entry("bryo", CollectionLogCategorySlug.bryophyta),
			Map.entry("bear", CollectionLogCategorySlug.callisto_and_artio),
            Map.entry("artio", CollectionLogCategorySlug.callisto_and_artio),
            Map.entry("callisto", CollectionLogCategorySlug.callisto_and_artio),
            Map.entry("vetion", CollectionLogCategorySlug.vetion_and_calvarion),
            Map.entry("calvarion", CollectionLogCategorySlug.vetion_and_calvarion),
            Map.entry("calv", CollectionLogCategorySlug.vetion_and_calvarion),
            Map.entry("vet", CollectionLogCategorySlug.vetion_and_calvarion),
			Map.entry("cerb", CollectionLogCategorySlug.cerberus),
            Map.entry("corp", CollectionLogCategorySlug.corporeal_beast),
            Map.entry("corporeal", CollectionLogCategorySlug.corporeal_beast),
            Map.entry("deranged", CollectionLogCategorySlug.deranged_archaeologist),
            Map.entry("dagannoth", CollectionLogCategorySlug.dagannoth_kings),
            Map.entry("dk", CollectionLogCategorySlug.dagannoth_kings),
            Map.entry("dks", CollectionLogCategorySlug.dagannoth_kings),
			Map.entry("delve", CollectionLogCategorySlug.doom_of_mokhaiotl),
			Map.entry("doom", CollectionLogCategorySlug.doom_of_mokhaiotl),
			Map.entry("mok", CollectionLogCategorySlug.doom_of_mokhaiotl),
            Map.entry("duke", CollectionLogCategorySlug.duke_sucellus),
            Map.entry("sucellus", CollectionLogCategorySlug.duke_sucellus),
			Map.entry("ele", CollectionLogCategorySlug.chaos_elemental),
            Map.entry("elemental", CollectionLogCategorySlug.chaos_elemental),
            Map.entry("fanatic", CollectionLogCategorySlug.chaos_fanatic),
            Map.entry("graardor", CollectionLogCategorySlug.general_graardor),
            Map.entry("bandos", CollectionLogCategorySlug.general_graardor),
            Map.entry("grotesque", CollectionLogCategorySlug.grotesque_guardians),
            Map.entry("gg", CollectionLogCategorySlug.grotesque_guardians),
            Map.entry("ggs", CollectionLogCategorySlug.grotesque_guardians),
            Map.entry("hydra", CollectionLogCategorySlug.alchemical_hydra),
            Map.entry("alchemical" , CollectionLogCategorySlug.alchemical_hydra),
            Map.entry("kbd", CollectionLogCategorySlug.king_black_dragon),
            Map.entry("kalphite", CollectionLogCategorySlug.kalphite_queen),
            Map.entry("kril", CollectionLogCategorySlug.kril_tsutsaroth),
            Map.entry("zammy", CollectionLogCategorySlug.kril_tsutsaroth),
            Map.entry("zamorak", CollectionLogCategorySlug.kril_tsutsaroth),
            Map.entry("leviathan", CollectionLogCategorySlug.the_leviathan),
            Map.entry("levi", CollectionLogCategorySlug.the_leviathan),
            Map.entry("mole", CollectionLogCategorySlug.giant_mole),
            Map.entry("moons", CollectionLogCategorySlug.moons_of_peril),
            Map.entry("muspah", CollectionLogCategorySlug.phantom_muspah),
            Map.entry("nightmare", CollectionLogCategorySlug.the_nightmare),
            Map.entry("phosani", CollectionLogCategorySlug.the_nightmare),
            Map.entry("phn", CollectionLogCategorySlug.the_nightmare),
            Map.entry("sire", CollectionLogCategorySlug.abyssal_sire),
            Map.entry("spider", CollectionLogCategorySlug.venenatis_and_spindel),
            Map.entry("spindel", CollectionLogCategorySlug.venenatis_and_spindel),
            Map.entry("venenatis", CollectionLogCategorySlug.venenatis_and_spindel),
            Map.entry("thermonuclear", CollectionLogCategorySlug.thermonuclear_smoke_devil),
            Map.entry("thermy", CollectionLogCategorySlug.thermonuclear_smoke_devil),
            Map.entry("titans", CollectionLogCategorySlug.royal_titans),
            Map.entry("royal", CollectionLogCategorySlug.royal_titans),
            Map.entry("rt", CollectionLogCategorySlug.royal_titans),
            Map.entry("tormented", CollectionLogCategorySlug.tormented_demons),
            Map.entry("tds", CollectionLogCategorySlug.tormented_demons),
            Map.entry("whisperer", CollectionLogCategorySlug.the_whisperer),
            Map.entry("whisp", CollectionLogCategorySlug.the_whisperer),
            Map.entry("zilyana", CollectionLogCategorySlug.commander_zilyana),
            Map.entry("sara", CollectionLogCategorySlug.commander_zilyana),
            Map.entry("zily" , CollectionLogCategorySlug.commander_zilyana),
            Map.entry("saradomin" , CollectionLogCategorySlug.commander_zilyana),
            Map.entry("amox", CollectionLogCategorySlug.amoxliatl),
            Map.entry("vork", CollectionLogCategorySlug.vorkath),
            Map.entry("huey", CollectionLogCategorySlug.the_hueycoatl),
            Map.entry("vard", CollectionLogCategorySlug.vardorvis),
            Map.entry("zul", CollectionLogCategorySlug.zulrah),

            // === Clue Scrolls ===
            Map.entry("beginner_clue", CollectionLogCategorySlug.beginner_treasure_trails),
            Map.entry("easy_clue", CollectionLogCategorySlug.easy_treasure_trails),
            Map.entry("elite_clue", CollectionLogCategorySlug.elite_treasure_trails),
            Map.entry("hard_clue", CollectionLogCategorySlug.hard_treasure_trails),
            Map.entry("master_clue", CollectionLogCategorySlug.master_treasure_trails),
            Map.entry("medium_clue", CollectionLogCategorySlug.medium_treasure_trails),
            Map.entry("shared_clue", CollectionLogCategorySlug.shared_treasure_trail_rewards),
            Map.entry("beginner", CollectionLogCategorySlug.beginner_treasure_trails),
            Map.entry("easy", CollectionLogCategorySlug.easy_treasure_trails),
            Map.entry("medium", CollectionLogCategorySlug.medium_treasure_trails),
            Map.entry("hard", CollectionLogCategorySlug.hard_treasure_trails),
            Map.entry("elite", CollectionLogCategorySlug.elite_treasure_trails),
            Map.entry("master", CollectionLogCategorySlug.master_treasure_trails),
            Map.entry("shared", CollectionLogCategorySlug.shared_treasure_trail_rewards),
            Map.entry("cases", CollectionLogCategorySlug.scroll_cases),

            // === Minigames & Activities ===
            Map.entry("aerial", CollectionLogCategorySlug.aerial_fishing),
            Map.entry("champions", CollectionLogCategorySlug.champions_challenge),
            Map.entry("chompy", CollectionLogCategorySlug.chompy_bird_hunting),
            Map.entry("creature", CollectionLogCategorySlug.creature_creation),
            Map.entry("den", CollectionLogCategorySlug.rogues_den),
            Map.entry("druids", CollectionLogCategorySlug.elder_chaos_druids),
			Map.entry("randoms", CollectionLogCategorySlug.random_events),
            Map.entry("events", CollectionLogCategorySlug.random_events),
            Map.entry("experiment", CollectionLogCategorySlug.gloughs_experiments),
            Map.entry("glough", CollectionLogCategorySlug.gloughs_experiments),
            Map.entry("fossil", CollectionLogCategorySlug.fossil_island_notes),
            Map.entry("gotr", CollectionLogCategorySlug.guardians_of_the_rift),
            Map.entry("rift", CollectionLogCategorySlug.guardians_of_the_rift),
			Map.entry("rumours", CollectionLogCategorySlug.hunter_guild),
            Map.entry("hunter", CollectionLogCategorySlug.hunter_guild),
            Map.entry("lms", CollectionLogCategorySlug.last_man_standing),
            Map.entry("mixology", CollectionLogCategorySlug.mastering_mixology),
            Map.entry("mlm", CollectionLogCategorySlug.motherlode_mine),
            Map.entry("monkey", CollectionLogCategorySlug.monkey_backpacks),
            Map.entry("notes", CollectionLogCategorySlug.my_notes),
            Map.entry("pc", CollectionLogCategorySlug.pest_control),
            Map.entry("pest", CollectionLogCategorySlug.pest_control),
            Map.entry("revs", CollectionLogCategorySlug.revenants),
            Map.entry("rev", CollectionLogCategorySlug.revenants),
            Map.entry("rooftop", CollectionLogCategorySlug.rooftop_agility),
            Map.entry("sep", CollectionLogCategorySlug.hallowed_sepulchre),
            Map.entry("sepulchre", CollectionLogCategorySlug.hallowed_sepulchre),
            Map.entry("hs", CollectionLogCategorySlug.hallowed_sepulchre),
            Map.entry("shades", CollectionLogCategorySlug.shades_of_mortton),
            Map.entry("shayzien", CollectionLogCategorySlug.shayzien_armour),
            Map.entry("stars", CollectionLogCategorySlug.shooting_stars),
            Map.entry("trekking", CollectionLogCategorySlug.temple_trekking),
            Map.entry("tithe", CollectionLogCategorySlug.tithe_farm),
            Map.entry("brewing", CollectionLogCategorySlug.trouble_brewing),
            Map.entry("trouble", CollectionLogCategorySlug.trouble_brewing),
            Map.entry("tb", CollectionLogCategorySlug.trouble_brewing),
            Map.entry("volcanic", CollectionLogCategorySlug.volcanic_mine),
            Map.entry("wyrm", CollectionLogCategorySlug.colossal_wyrm_agility),
            Map.entry("ba", CollectionLogCategorySlug.barbarian_assault),
            Map.entry("assault", CollectionLogCategorySlug.barbarian_assault),
            Map.entry("barbarian", CollectionLogCategorySlug.barbarian_assault),
            Map.entry("brimhaven", CollectionLogCategorySlug.brimhaven_agility_arena),
            Map.entry("trawler", CollectionLogCategorySlug.fishing_trawler),
            Map.entry("wars", CollectionLogCategorySlug.castle_wars),
            Map.entry("totems", CollectionLogCategorySlug.vale_totems),
            Map.entry("restaurant", CollectionLogCategorySlug.gnome_restaurant),
            Map.entry("mta", CollectionLogCategorySlug.magic_training_arena),
            Map.entry("foundry", CollectionLogCategorySlug.giants_foundry),
            Map.entry("mh", CollectionLogCategorySlug.mahogany_homes),
            Map.entry("homes", CollectionLogCategorySlug.mahogany_homes),
            Map.entry("mahogany", CollectionLogCategorySlug.mahogany_homes),
			Map.entry("temp", CollectionLogCategorySlug.tempoross),

            // === Miscellaneous ===
            Map.entry("misc", CollectionLogCategorySlug.miscellaneous),
            Map.entry("pets", CollectionLogCategorySlug.all_pets),
            Map.entry("skilling", CollectionLogCategorySlug.skilling_pets),

            // === Raids & Endgame ===
            Map.entry("cg", CollectionLogCategorySlug.the_gauntlet),
            Map.entry("gauntlet", CollectionLogCategorySlug.the_gauntlet),
            Map.entry("colosseum", CollectionLogCategorySlug.fortis_colosseum),
            Map.entry("colo", CollectionLogCategorySlug.fortis_colosseum),
            Map.entry("cox", CollectionLogCategorySlug.chambers_of_xeric),
            Map.entry("chambers", CollectionLogCategorySlug.chambers_of_xeric),
            Map.entry("fightcaves", CollectionLogCategorySlug.the_fight_caves),
            Map.entry("jad", CollectionLogCategorySlug.the_fight_caves),
            Map.entry("inferno", CollectionLogCategorySlug.the_inferno),
            Map.entry("zuk", CollectionLogCategorySlug.the_inferno),
            Map.entry("toa", CollectionLogCategorySlug.tombs_of_amascut),
            Map.entry("tombs", CollectionLogCategorySlug.tombs_of_amascut),
            Map.entry("tob", CollectionLogCategorySlug.theatre_of_blood),
            Map.entry("theatre", CollectionLogCategorySlug.theatre_of_blood)
    );

    /**
     * Builds a list of alises grouped by their category slug,
     * e.g. kreearra=[armadyl, kree, arma]
     * Used to provide a list of aliases when using the help commands
     */
    public static final Map<String, Set<String>> INVERTED_ALIASES = CATEGORY_ALIASES
            .entrySet()
            .stream()
            .collect(
                Collectors.groupingBy(
                    item -> item.getValue().toString(),
                    Collectors.mapping(
                        Map.Entry::getKey,
                        Collectors.toSet()
                    )
                )
            );

    public static final Map<String, CollectionLogCategory> CUSTOM_CATEGORIES = Map.ofEntries(
            Map.entry(
                CollectionLogCategorySlug.gilded.name(),
                new CollectionLogCategory(
                    "Gilded",
					new LinkedHashSet<>(
						Arrays.asList(
							ItemID.RUNE_FULL_HELM_GOLDPLATE,
							ItemID.RUNE_PLATEBODY_GOLDPLATE,
							ItemID.RUNE_PLATELEGS_GOLDPLATE,
							ItemID.RUNE_PLATESKIRT_GOLDPLATE,
							ItemID.RUNE_KITESHIELD_GOLDPLATE,
							ItemID.RUNE_MED_HELM_GOLD,
							ItemID.RUNE_CHAINBODY_GOLD,
							ItemID.RUNE_SQ_SHIELD_GOLD,
							ItemID.RUNE_2H_SWORD_GOLD,
							ItemID.RUNE_SPEAR_GOLD,
							ItemID.BRUT_RUNE_SPEAR_GOLD,
							ItemID.RUNE_SCIMITAR_GOLD,
							ItemID.RUNE_BOOTS_GOLD,
							ItemID.TRAIL_GILDED_DHIDE_COIF,
							ItemID.TRAIL_GILDED_DHIDE_VAMBRACES,
							ItemID.TRAIL_GILDED_DHIDE_TOP,
							ItemID.TRAIL_GILDED_DHIDE_CHAPS,
							ItemID.TRAIL_GILDED_PICKAXE,
							ItemID.TRAIL_GILDED_AXE,
							ItemID.TRAIL_GILDED_SPADE
						)
					)
                )
            ),
            Map.entry(
                CollectionLogCategorySlug.thirdage.name(),
                new CollectionLogCategory(
                    "Third age",
					new LinkedHashSet<>(
						Arrays.asList(
							ItemID._3A_PICKAXE,
							ItemID._3A_AXE,
							ItemID._3A_DRUIDIC_TOP,
							ItemID._3A_DRUIDIC_BOTTOMS,
							ItemID._3A_DRUIDIC_STAFF,
							ItemID._3A_DRUIDIC_CLOAK,
							ItemID.TRAIL_FIGHTER_SWORD,
							ItemID.TRAIL_MAGE_WAND,
							ItemID.TRAIL_THIRD_CAPE,
							ItemID.TRAIL_RANGER_BOW,
							ItemID.TRAIL_RANGER_COIF,
							ItemID.TRAIL_RANGER_TORSO,
							ItemID.TRAIL_RANGER_LEGS,
							ItemID.TRAIL_RANGER_VAMBRACES,
							ItemID.TRAIL_MAGE_HAT,
							ItemID.TRAIL_MAGE_TORSO,
							ItemID.TRAIL_MAGE_LEGS,
							ItemID.TRAIL_MAGE_AMULET,
							ItemID.TRAIL_FIGHTER_HELM,
							ItemID.TRAIL_SILVER_PLATE_CHEST,
							ItemID.TRAIL_SILVER_PLATE_LEGS,
							ItemID.TRAIL_SILVER_PLATE_SKIRT,
							ItemID.TRAIL_FIGHTER_SHIELD
						)
					)
                )
            )
    );
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.annotations.Component;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import static java.lang.Math.round;

@Slf4j
@Singleton
public class SyncButtonManager {
    private static final int COLLECTION_LOG_SETUP = 7797;
    private static final int[] SPRITE_IDS_INACTIVE = {
            SpriteID.DIALOG_BACKGROUND,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_LEFT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_TOP_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_LEFT,
            SpriteID.WORLD_MAP_BUTTON_METAL_CORNER_BOTTOM_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_LEFT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_TOP,
            SpriteID.WORLD_MAP_BUTTON_EDGE_RIGHT,
            SpriteID.WORLD_MAP_BUTTON_EDGE_BOTTOM,
    };

    private static final int[] SPRITE_IDS_ACTIVE = {
            SpriteID.RESIZEABLE_MODE_SIDE_PANEL_BACKGROUND,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_TOP_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_METAL_CORNER_BOTTOM_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_LEFT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_TOP_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_RIGHT_HOVERED,
            SpriteID.EQUIPMENT_BUTTON_EDGE_BOTTOM_HOVERED,
    };

    private static final int FONT_COLOUR_INACTIVE = 0xd6d6d6;
    private static final int FONT_COLOUR_ACTIVE = 0xffffff;
    private static final int CLOSE_BUTTON_OFFSET = 28;
    private static final int BUTTON_WIDTH = 60;
    private static final int BUTTON_OFFSET = CLOSE_BUTTON_OFFSET + 5;
    private int lastAttemptedUpdate = -1;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private EventBus eventBus;

    @Inject
    private CollectionLogManager collectionLogManager;

    @Getter
    @Setter
    private boolean fullSyncRequested = false;

    public void startUp() {
        eventBus.register(this);
        clientThread.invokeLater(() -> tryAddButton(this::onButtonClick));
    }

    public void shutDown() {
        eventBus.unregister(this);
        clientThread.invokeLater(this::removeButton);
    }

    @Getter
    @RequiredArgsConstructor
    enum Screen {
        // First number is col log container (inner) and second is search button id
        COLLECTION_LOG(40697944, 40697932, ComponentID.COLLECTION_LOG_CONTAINER),
        ;

        @Getter(onMethod_ = @Component)
        private final int parentId;

        @Getter(onMethod_ = @Component)
        private final int searchButtonId;

        @Getter(onMethod_ = @Component)
        private final int collectionLogContainer;
    }

    void tryAddButton(Runnable onClick) {
        for (Screen screen : Screen.values()) {
            addButton(screen, onClick);
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
            removeButton();
            addButton(Screen.COLLECTION_LOG, this::onButtonClick);
        }
    }

    void onButtonClick() {
        if (lastAttemptedUpdate != -1 && lastAttemptedUpdate + 50 > client.getTickCount()) {
            client.addChatMessage(ChatMessageType.CONSOLE, "TempleOSRS", "Last update within 30 seconds. You can update again in " + round((lastAttemptedUpdate + 50 - client.getTickCount()) * 0.6) + " seconds.", "TempleOSRS");
            return;
        }

        lastAttemptedUpdate = client.getTickCount();

        setFullSyncRequested(true);

        // Clear the previously obtained item list to avoid duplicating items when counts change
        collectionLogManager.getObtainedCollectionLogItems().clear();

        client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
        client.runScript(2240);
        client.addChatMessage(ChatMessageType.CONSOLE, "TempleOSRS", "Your collection log data is being sent to TempleOSRS...", "TempleOSRS");
    }

    void addButton(Screen screen, Runnable onClick) {
        Widget parent = client.getWidget(screen.getParentId());
        Widget searchButton = client.getWidget(screen.getSearchButtonId());
        Widget collectionLogContainer = client.getWidget(screen.getCollectionLogContainer());
        Widget[] containerChildren;
        Widget draggableTopbar;
        if (parent == null || searchButton == null || collectionLogContainer == null ||
                (containerChildren = collectionLogContainer.getChildren()) == null ||
                (draggableTopbar = containerChildren[0]) == null) {
            return;
        }

        final int w = BUTTON_WIDTH;
        final int h = searchButton.getOriginalHeight();
        final int x = BUTTON_OFFSET;
        final int y = searchButton.getOriginalY();
        final int cornerDim = 9;

        final Widget[] spriteWidgets = new Widget[10];

        spriteWidgets[0] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[0])
                .setPos(x, y)
                .setSize(w, h)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setYPositionMode(searchButton.getYPositionMode());

        spriteWidgets[1] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[1])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y);
        spriteWidgets[2] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[2])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y);
        spriteWidgets[3] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[3])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x + (w - cornerDim), y + h - cornerDim);
        spriteWidgets[4] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[4])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(cornerDim, cornerDim)
                .setPos(x, y + h - cornerDim);
        // Left and right edges
        int sideWidth = 9;
        int sideHeight = 4;
        spriteWidgets[5] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[5])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x + (w - sideWidth), y + cornerDim);
        spriteWidgets[7] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[7])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(sideWidth, sideHeight)
                .setPos(x, y + cornerDim);

        // Top and bottom edges
        int topWidth = 42;
        int topHeight = 9;
        spriteWidgets[6] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[6])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y);
        spriteWidgets[8] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SPRITE_IDS_INACTIVE[8])
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(topWidth, topHeight)
                .setPos(x + cornerDim, y + h - topHeight);
        // Refresh icon
        spriteWidgets[9] = parent.createChild(-1, WidgetType.GRAPHIC)
                .setSpriteId(SpriteID.UNKNOWN_WHITE_REFRESH_ARROWS)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setSize(13, 13)
                .setPos(x + 6, y + 4);


        for (int i = 0; i < 10; i++) {
            spriteWidgets[i].revalidate();
        }

        final Widget text = parent.createChild(-1, WidgetType.TEXT)
                .setText("Temple")
                .setTextColor(FONT_COLOUR_INACTIVE)
                .setFontId(FontID.PLAIN_11)
                .setTextShadowed(true)
                .setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
                .setXTextAlignment(WidgetTextAlignment.LEFT)
                .setYTextAlignment(WidgetTextAlignment.CENTER)
                .setPos(x - 8, y)
                .setSize(w, h)
                .setYPositionMode(searchButton.getYPositionMode());
        text.revalidate();

        // We'll give the text layer the listeners since it covers the whole area
        text.setHasListener(true);
        text.setOnMouseOverListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++) {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_ACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_ACTIVE);
        });
        text.setOnMouseLeaveListener((JavaScriptCallback) ev ->
        {
            for (int i = 0; i <= 8; i++) {
                spriteWidgets[i].setSpriteId(SPRITE_IDS_INACTIVE[i]);
            }
            text.setTextColor(FONT_COLOUR_INACTIVE);
        });

        // Register a click listener
        text.setAction(0, "Sync your collection log with Temple");
        text.setOnOpListener((JavaScriptCallback) ev -> onClick.run());


        // Shrink the top bar to avoid overlapping the new button
        draggableTopbar.setOriginalWidth(draggableTopbar.getOriginalWidth() - (w + (x - CLOSE_BUTTON_OFFSET)));
        draggableTopbar.revalidate();

        // recompute locations / sizes on parent
        parent.revalidate();
    }

    void removeButton() {
        for (Screen screen : Screen.values()) {
            Widget parent = client.getWidget(screen.getParentId());
            if (parent != null) {
                parent.deleteAllChildren();
                parent.revalidate();
            }
        }
    }
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.data;

import lombok.AllArgsConstructor;
import lombok.Value;

@Value
@AllArgsConstructor
public class PlayerDataSubmission
{
    String username;
    String profile;
    long playerHash;
    PlayerData data;
}
package com.templeosrs.util.collections.data;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.api.APIError;
import lombok.Value;

import java.util.Set;

@Value
public class CollectionLogResponse {
    @Value
    public static class Data {
        String player;
        @SerializedName("last_changed") String lastChanged;
        Set<ObtainedCollectionItem> items;
    }

    Data data;
    APIError error;
}

package com.templeosrs.util.collections.data;

import lombok.Value;
import lombok.experimental.NonFinal;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.sql.Timestamp;

@Value
public class ObtainedCollectionItem {
    int id;
    @Nullable @NonFinal String name;
    int count;
    String date;

    public ObtainedCollectionItem(int id, int count) {
        this.id = id;
        this.count = count;
        this.date = null;
        this.name = null;
    }

    public ObtainedCollectionItem(int id, @NotNull String name, int count) {
        this.id = id;
        this.name = name;
        this.count = count;
        this.date = null;
    }

    public ObtainedCollectionItem(int id, @NotNull String name, int count, String date) {
        this.id = id;
        this.name = name;
        this.count = count;
        this.date = date;
    }

    public Timestamp getDate()
    {
        if (this.date == null) {
            return null;
        }

        return Timestamp.valueOf(this.date);
    }
}

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.data;

import lombok.Value;
import net.runelite.client.config.RuneScapeProfileType;

@Value
public class PlayerProfile
{
    String username;
    RuneScapeProfileType profileType;
}
package com.templeosrs.util.collections.data;

import java.util.Set;
import lombok.Value;

@Value
public class CollectionLogCategory {
    String title;
    Set<Integer> items;
}

package com.templeosrs.util.collections.data;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.api.APIError;
import lombok.Value;

import javax.annotation.Nullable;

@Value
public class PlayerInfoResponse {
    @Value
    public static class CollectionLog {
        @Nullable
        @SerializedName("last_changed")
        String lastChanged;
    }

    @Value
    public static class Data {
        @SerializedName("collection_log")
        CollectionLog collectionLog;

        @SerializedName("player_name_with_capitalization")
        String playerNameWithCapitalization;
    }

    @Nullable
    Data data;

    @Nullable
    APIError error;
}

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.data;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.Set;

@Data
@AllArgsConstructor
public class PlayerData
{
    public int totalCollectionsAvailable;
    public Set<ObtainedCollectionItem> obtainedItems;
}
package com.templeosrs.util.collections.data;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.api.APIError;
import lombok.Value;

import javax.annotation.Nullable;

@Value
public class CollectionLogSyncResponse {
    @Value
    public static class Data {
        @SerializedName("sync_date")
        String syncDate;

        @SerializedName("sync_date_unix")
        int syncDateUnix;

        @SerializedName("last_changed")
        String lastChanged;

        @SerializedName("last_changed_unix")
        int lastChangedUnix;

        String username;

        String message;
    }

    @Nullable
    Data data;

    @Nullable
    APIError error;
}

package com.templeosrs.util.collections.parser;

import com.google.gson.*;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.*;

import com.templeosrs.util.api.APIError;
import com.templeosrs.util.collections.data.CollectionLogResponse;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.database.CollectionDatabase;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class CollectionParser {
    @Inject
    private Gson gson;

    /**
     * Parses the Temple API response to a map of collection log items
     * @param rawUsername The username associated with the response
     * @param json The raw JSON response from the Player Collection Log endpoint
     */
    public void parseAndStore(String rawUsername, String json)
    {
        final String username = rawUsername.toLowerCase();

        log.debug("🧹 Starting parse() for user: {}...", username);

        CollectionLogResponse collectionLogResponse;

        // Log the raw JSON for debugging purposes
        log.debug("Raw JSON: {}", json);

        try {
            // Directly parse the JSON string using Gson
            collectionLogResponse = gson.fromJson(json, CollectionLogResponse.class);
        } catch (JsonSyntaxException e) {
            log.error("❌ Failed to parse JSON for {}: {}", username, e.getMessage());

            return;
        } catch (Exception e) {
            log.error("❌ Unexpected error while parsing JSON for {}: {}", username, e.getMessage());

            return;
        }

        CollectionLogResponse.Data data = collectionLogResponse.getData();
        APIError error = collectionLogResponse.getError();

        // Handle error response
        if (error != null) {
            String errorMessage = error.getMessage();

            if (errorMessage.contains("Player has not synced")){
                log.warn("⚠️ Player {} has not synced their collection log yet.", username);
            } else {
                log.warn("⚠️ API error for {}: {}", username, errorMessage);
            }

            return; // Stop further processing for this player
        }

        // Handle success response
        if (data != null) {
            Set<ObtainedCollectionItem> itemList = new HashSet<>();

            for (ObtainedCollectionItem item : data.getItems()) {
                log.debug("➡️ Queuing: {} x{} @ {}", item.getName(), item.getCount(), item.getDate());
                itemList.add(item);
            }

            log.debug("✅ Parsed {} items for {}.", itemList.size(), username);

            if (itemList.isEmpty()) {
                log.warn("⚠️ No items found to store for {}", username);

                return;
            }

            log.debug("🧹 Starting store() for user: {}...", username);

            CollectionDatabase.upsertItemsBatch(username, itemList, Timestamp.valueOf(data.getLastChanged()));

            int itemCount = itemList.size();

            log.debug("✅ Parsed and inserted {} items total for {}.", itemCount, username);

            // ✅ Manually shut down the database after insert
            try (Connection conn = CollectionDatabase.getConnection();
                 Statement stmt = conn.createStatement()
            ) {
                stmt.execute("SHUTDOWN");
                log.debug("🚗 Manually closed H2 database after sync.");
            } catch (SQLException e) {
                log.error("⚠️ Error while trying to shut down the database", e);
            }
        }
    }
}
package com.templeosrs.util.collections.database;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;

import javax.inject.Singleton;
import java.io.File;
import java.sql.*;
import java.util.*;

@Slf4j
@Singleton
public class CollectionDatabase {
    private static final String DB_URL = "jdbc:h2:file:" + RuneLite.RUNELITE_DIR + "/templeosrs/runelite-collections;AUTO_SERVER=TRUE;DB_CLOSE_DELAY=-1";

    private static final String COLLECTION_LOG_CACHE_TABLE_NAME = "collection_log_cache";
    private static final String PLAYER_METADATA_TABLE_NAME = "player_metadata";

    static {
        File pluginDir = new File(RuneLite.RUNELITE_DIR, "templeosrs");
        if (!pluginDir.exists()) {
            if (!pluginDir.mkdirs()) {
                log.warn("⚠️ Failed to create plugin directory at {}", pluginDir.getAbsolutePath());
            }
        }
    }

    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(DB_URL);
    }

    public static void init() {
        try {
            // 🚨 Required for Plugin Hub: explicitly load the H2 JDBC driver
            Class.forName("org.h2.Driver");

            try (Connection conn = getConnection(); Statement stmt = conn.createStatement()) {
                final String createCollectionLogCacheTableSql = String.format(
                        "CREATE TABLE IF NOT EXISTS %s(" +
                                "id IDENTITY PRIMARY KEY, " +
                                "item_id INT, " +
                                "item_name VARCHAR(255), " +
                                "item_count INT, " +
                                "player_name VARCHAR(255)" +
                        ")",
                        COLLECTION_LOG_CACHE_TABLE_NAME
                );

                final String createPlayerMetadataTableSql = String.format(
                        "CREATE TABLE IF NOT EXISTS %s(" +
                                "id IDENTITY PRIMARY KEY, " +
                                "player_name VARCHAR(255), " +
                                "last_changed TIMESTAMP, " +
                                "last_accessed TIMESTAMP" +
                        ")",
                        PLAYER_METADATA_TABLE_NAME
                );

                stmt.executeUpdate(createCollectionLogCacheTableSql);
                stmt.executeUpdate(createPlayerMetadataTableSql);
            }
        } catch (ClassNotFoundException e) {
            log.warn("H2 Driver class not found: {}", e.getMessage());
        } catch (SQLException e) {
            log.warn("Database initialization failed: {}", e.getMessage());
        }
    }

    private static void addColumnIfNotExists(Connection conn, String table, String column, String type) throws SQLException {
        String checkQuery = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ? AND COLUMN_NAME = ?";
        try (PreparedStatement ps = conn.prepareStatement(checkQuery)) {
            ps.setString(1, table.toUpperCase());
            ps.setString(2, column.toUpperCase());
            try (ResultSet rs = ps.executeQuery()) {
                if (!rs.next()) {
                    try (Statement stmt = conn.createStatement()) {
                        stmt.executeUpdate("ALTER TABLE " + table + " ADD COLUMN " + column + " " + type);
                    }
                }
            }
        }
    }

    public static boolean hasPlayerData(String playerName) {
        String sql = String.format("SELECT 1 FROM %s WHERE player_name = ? LIMIT 1", COLLECTION_LOG_CACHE_TABLE_NAME);

        try (Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, playerName.toLowerCase());
            ResultSet rs = ps.executeQuery();
            return rs.next();
        } catch (SQLException e) {
            log.warn("Error checking player data: {}", e.getMessage());
            return false;
        }
    }

    /**
     * Saves the API response data to the API cache table
     * @param playerName The player name associated with the response
     * @param items The items to persist to the database
     */
    public static void upsertItemsBatch(
            @NotNull String playerName,
            @NotNull Set<ObtainedCollectionItem> items,
            Timestamp lastChanged
    ) {
        try (Connection conn = getConnection()) {
            conn.setAutoCommit(false);

            try (
                PreparedStatement ps1 = conn.prepareStatement(
                    String.format("MERGE INTO %s USING DUAL ", COLLECTION_LOG_CACHE_TABLE_NAME) +
                    "ON item_id = ? AND player_name = ? " +
                    "WHEN MATCHED THEN UPDATE SET item_count = ? " +
                    "WHEN NOT MATCHED THEN INSERT (player_name, item_id, item_count, item_name) VALUES (?, ?, ?, ?)"
                );
                PreparedStatement ps2 = conn.prepareStatement(
                    String.format("MERGE INTO %s USING DUAL ", PLAYER_METADATA_TABLE_NAME) +
                    "ON player_name = ? " +
                    "WHEN MATCHED THEN UPDATE SET last_changed = ?, last_accessed = ? " +
                    "WHEN NOT MATCHED THEN INSERT (player_name, last_changed, last_accessed) VALUES (?, ?, ?)"
                )
            )
            {
                final String lowerPlayerName = playerName.toLowerCase();
                final Timestamp lastAccessed = new Timestamp(System.currentTimeMillis());

                for (ObtainedCollectionItem item : items) {
                    final int itemId = item.getId();
                    final int itemCount = item.getCount();

                    ps1.setInt(1, itemId);
                    ps1.setString(2, lowerPlayerName);
                    ps1.setInt(3, itemCount);
                    ps1.setString(4, lowerPlayerName);
                    ps1.setInt(5, itemId);
                    ps1.setInt(6, itemCount);
                    ps1.setString(7, item.getName());

                    ps1.addBatch();
                }

                ps2.setString(1, lowerPlayerName);
                ps2.setTimestamp(2, lastChanged);
                ps2.setTimestamp(3, lastAccessed);
                ps2.setString(4, lowerPlayerName);
                ps2.setTimestamp(5, lastChanged);
                ps2.setTimestamp(6, lastAccessed);

                ps1.executeBatch();
                ps2.execute();
            }

            conn.commit();
        } catch (SQLException e) {
            log.warn("Error inserting items to the API cache: {}", e.getMessage());
        }
    }

    public static Multiset<Integer> getCollectionLogDiff(String playerName, Multiset<Integer> collectionLogItems)
    {
        try (Connection conn = getConnection())
        {
            try (PreparedStatement ps = conn.prepareStatement(
                String.format(
                    "SELECT item_count, item_id FROM %s WHERE player_name = ? AND item_id = ? LIMIT 1",
                        COLLECTION_LOG_CACHE_TABLE_NAME
                )
            ))
            {
                final Multiset<Integer> foundItems = HashMultiset.create();

                for (Multiset.Entry<Integer> entry : collectionLogItems.entrySet())
                {
                    final int itemId = entry.getElement();

                    ps.setString(1, playerName.toLowerCase());
                    ps.setInt(2, itemId);

                    final ResultSet rs = ps.executeQuery();

                    if (rs.next())
                    {
                        final int rsItemCount = rs.getInt("item_count");
                        final int rsItemId = rs.getInt("item_id");

                        foundItems.add(rsItemId, rsItemCount);
                    }
                }

                return Multisets.difference(collectionLogItems, foundItems);
            }
        } catch (SQLException e) {
            log.warn("Error comparing collection log: {}", e.getMessage());

            return null;
        }
    }

    public static Timestamp getLatestTimestamp(String playerName) {
        String sql = String.format("SELECT last_changed FROM %s WHERE player_name = ?", PLAYER_METADATA_TABLE_NAME);

        try (Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, playerName.toLowerCase());
            ResultSet rs = ps.executeQuery();
            if (rs.next()) {
                return rs.getTimestamp(1);
            }
        } catch (SQLException e) {
            log.warn("Error fetching latest timestamp: {}", e.getMessage());
        }

        return null;
    }

    public static void clearAll() {
        try (Connection conn = getConnection();
             Statement stmt = conn.createStatement())
        {
            stmt.executeUpdate(String.format("DELETE FROM %s", COLLECTION_LOG_CACHE_TABLE_NAME));
        } catch (SQLException e) {
            log.warn("Error clearing all items: {}", e.getMessage());
        }
    }

    public static Set<ObtainedCollectionItem> getItemsByCategory(String playerName, Set<Integer> categoryItems) {
        Map<Integer, ObtainedCollectionItem> items = new HashMap<>();

        try (Connection conn = getConnection();
             PreparedStatement ps1 = conn.prepareStatement(
                 String.format(
                     "SELECT item_id, item_name, item_count FROM %s WHERE player_name = ? AND item_id IN (%s)",
                     COLLECTION_LOG_CACHE_TABLE_NAME,
                     StringUtils.repeat("?", ",", categoryItems.size())
                 )
             );
             PreparedStatement ps2 = conn.prepareStatement(
                String.format("UPDATE %s ", PLAYER_METADATA_TABLE_NAME) +
                "SET last_accessed = ? " +
                "WHERE player_name = ?"
             );
        )
        {
            conn.setAutoCommit(false);

            final Timestamp lastAccessed = new Timestamp(System.currentTimeMillis());
            final String lowerPlayerName = playerName.toLowerCase();
            
            ps1.setString(1, playerName.toLowerCase());
                        
            int paramIndex = 2;
            for (int id : categoryItems)
            {
                ps1.setInt(paramIndex, id);
                paramIndex++;
            }

            try (ResultSet rs = ps1.executeQuery()) {
                while (rs.next()) {
                    int itemId = rs.getInt("item_id");
                    String itemName = rs.getString("item_name");
                    int count = rs.getInt("item_count");

                    items.put(itemId, new ObtainedCollectionItem(itemId, itemName, count));
                }
            }

            ps2.setTimestamp(1, lastAccessed);
            ps2.setString(2, lowerPlayerName);

            ps2.execute();

            conn.commit();
        } catch (SQLException e) {
            log.warn("Error fetching items by category: {}", e.getMessage());
        }

        Set<ObtainedCollectionItem> sortedItems = new LinkedHashSet<>();

        // Sorts the database response to match the order found in the log tab
        for (int itemId : categoryItems)
        {
            if (items.containsKey(itemId))
            {
                sortedItems.add(items.get(itemId));
            }
        }

        return sortedItems;
    }

    public static void pruneOldPlayers(String yourUsername, int maxPlayers) {
        try (Connection conn = getConnection();
             PreparedStatement ps1 = conn.prepareStatement(
             "SELECT player_name, MIN(last_accessed) as oldest " +
                 String.format("FROM %s ", COLLECTION_LOG_CACHE_TABLE_NAME) +
                 "WHERE player_name != ? " +
                 "GROUP BY player_name " +
                 "ORDER BY oldest ASC"
             );
             PreparedStatement deleteStmt = conn.prepareStatement(
                 String.format(
                     "DELETE FROM %s AS a INNER JOIN %s AS b WHERE a.player_name = b.player_name AND a.player_name = ?",
                     COLLECTION_LOG_CACHE_TABLE_NAME,
                     PLAYER_METADATA_TABLE_NAME
                 )
             );
        ) {
            ps1.setString(1, yourUsername.toLowerCase());
            ResultSet rs = ps1.executeQuery();

            int count = 0;
            List<String> playersToRemove = new ArrayList<>();

            while (rs.next()) {
                count++;
                if (count > maxPlayers) {
                    playersToRemove.add(rs.getString("player_name"));
                }
            }

            for (String name : playersToRemove) {
                log.debug("\uD83E\uDDF9 Pruning cached player: {}", name);
                deleteStmt.setString(1, name);
                deleteStmt.executeUpdate();
            }
        } catch (SQLException e) {
            log.warn("Error pruning old players: {}", e.getMessage());
        }
    }
}

package com.templeosrs.util.collections.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ServerNpcLoot;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;

@Slf4j
public class CollectionLogAutoSyncServerNpcLootSubscriber
{
	@Inject
	private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

	@Inject
	private ItemManager itemManager;

	/**
	 * This method is called when an NPC loot event is received.
	 * If any items in the loot match the newly obtained collection log item names,
	 * they are added to a list of items awaiting a server sync and the sync countdown is started.
	 */
	@Subscribe
	private void onServerNpcLoot(ServerNpcLoot serverNpcLoot)
	{
		if (collectionLogAutoSyncManager.obtainedItemNames.isEmpty())
		{
			return;
		}

		final int previousPendingSyncItemsCount = collectionLogAutoSyncManager.pendingSyncItems.size();

		serverNpcLoot.getItems().forEach(item ->
		{
			final int itemId = item.getId();
			final int itemCount = item.getQuantity();
			final String itemName = itemManager.getItemComposition(itemId).getName();

			if (collectionLogAutoSyncManager.obtainedItemNames.contains(itemName))
			{
				collectionLogAutoSyncManager.pendingSyncItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
				collectionLogAutoSyncManager.obtainedItemNames.remove(itemName);
			}
		});
		
		if (previousPendingSyncItemsCount < collectionLogAutoSyncManager.pendingSyncItems.size())
		{
			collectionLogAutoSyncManager.startSyncCountdown();
		}
	}
}

package com.templeosrs.util.collections.autosync;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.gson.Gson;
import com.templeosrs.util.api.APIError;
import com.templeosrs.util.api.QuadraticBackoffStrategy;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.CollectionLogRequestManager;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.data.PlayerProfile;
import com.templeosrs.util.collections.database.CollectionDatabase;
import com.templeosrs.util.collections.data.CollectionLogSyncResponse;
import lombok.Getter;
import lombok.Setter;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import org.jetbrains.annotations.Nullable;

import javax.inject.Inject;
import java.io.IOException;
import java.sql.Timestamp;
import java.util.HashSet;
import java.util.Set;

@Slf4j
public class CollectionLogAutoSyncManager
{
	@Inject
	private CollectionLogAutoSyncChatMessageSubscriber collectionLogAutoSyncChatMessageSubscriber;

	@Inject
	private CollectionLogAutoSyncItemContainerChangedSubscriber collectionLogAutoSyncItemContainerChangedSubscriber;

	@Inject
	private CollectionLogAutoSyncServerNpcLootSubscriber collectionLogAutoSyncServerNpcLootSubscriber;

	@Inject
	private CollectionLogAutoSyncGameTickSubscriber collectionLogAutoSyncGameTickSubscriber;

	@Inject
	private CollectionLogAutoSyncConfigChecker collectionLogAutoSyncConfigChecker;

	@Inject
	private LoggedInState loggedInState;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CollectionLogRequestManager requestManager;

	@Inject
	private CollectionLogManager collectionLogManager;

	@Inject
	private Gson gson;

	@Getter
	protected final HashSet<String> obtainedItemNames = new HashSet<>();

	@Getter
	@Nullable
	private Integer gameTickToSync;

	@Getter
	@Setter
	private boolean triggerSyncAllowed;

	@Getter
	@Setter
	private boolean logOpenAutoSync;

	@Getter
	@Setter
	private boolean computingDiff;

	@Getter
	QuadraticBackoffStrategy backoffStrategy = new QuadraticBackoffStrategy();

	/**
	 * Keeps track of what item IDs are pending a server sync
	 */
	@Getter
	protected final HashSet<ObtainedCollectionItem> pendingSyncItems = new HashSet<>();

	public void startUp()
	{
		eventBus.register(this);
		eventBus.register(collectionLogAutoSyncChatMessageSubscriber);
		eventBus.register(collectionLogAutoSyncItemContainerChangedSubscriber);
		eventBus.register(collectionLogAutoSyncServerNpcLootSubscriber);
		eventBus.register(collectionLogAutoSyncGameTickSubscriber);
		eventBus.register(collectionLogAutoSyncConfigChecker);
		eventBus.register(loggedInState);

		collectionLogAutoSyncConfigChecker.startUp();
	}

	public void shutDown()
	{
		eventBus.unregister(this);
		eventBus.unregister(collectionLogAutoSyncChatMessageSubscriber);
		eventBus.unregister(collectionLogAutoSyncItemContainerChangedSubscriber);
		eventBus.unregister(collectionLogAutoSyncServerNpcLootSubscriber);
		eventBus.unregister(collectionLogAutoSyncGameTickSubscriber);
		eventBus.unregister(collectionLogAutoSyncConfigChecker);
		eventBus.unregister(loggedInState);

		collectionLogAutoSyncConfigChecker.shutDown();

		obtainedItemNames.clear();
		clearSyncCountdown();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() == InterfaceID.COLLECTION)
		{
			setLogOpenAutoSync(true);
			setTriggerSyncAllowed(true);

			// Clear the previously obtained item list to avoid duplicating items when counts change
			collectionLogManager.getObtainedCollectionLogItems().clear();
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		if (scriptPostFired.getScriptId() == 7797 && isTriggerSyncAllowed())
		{
			clientThread.invokeLater(() -> {
				client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
				client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Back", null);

				setTriggerSyncAllowed(false);

				gameTickToSync = client.getTickCount() + 3;
			});
		}
	}

	/**
	 * Starts the sync countdown.
	 * This utilises a 17-tick delay (which corresponds to a roughly 10-second wait) as a way to batch requests.
	 * This is useful for when multiple items are obtained in quick succession, such as Chompy Hats.
	 */
	public void startSyncCountdown()
	{
		final int syncDelayInTicks = 17;

		gameTickToSync = client.getTickCount() + syncDelayInTicks;
	}

	/**
	 * Resets the sync countdown.
	 * Used after the request has successfully completed.
	 */
	public void clearSyncCountdown()
	{
		backoffStrategy.reset();
		setLogOpenAutoSync(false);
		gameTickToSync = null;
	}

	public void computeCollectionLogDiff()
	{
		try
		{
			String username = client.getLocalPlayer().getName();

			if (username == null || !CollectionDatabase.hasPlayerData(username))
			{
				log.debug("No saved log items were found, falling back to a full sync for {}", username);

				clearSyncCountdown();

				return;
			}

			log.debug("Computing collection log diff for {}", username);

			Set<ObtainedCollectionItem> obtainedCollectionLogItems = collectionLogManager.getObtainedCollectionLogItems();

			final Multiset<Integer> collectionLogItemIdCountMap = HashMultiset.create();

			for (ObtainedCollectionItem item : obtainedCollectionLogItems)
			{
				final int itemId = item.getId();
				final int itemCount = item.getCount();

				collectionLogItemIdCountMap.add(itemId, itemCount);
			}

			final Multiset<Integer> itemDiff = CollectionDatabase.getCollectionLogDiff(username, collectionLogItemIdCountMap);

			if (itemDiff == null || itemDiff.isEmpty())
			{
				log.debug("No log items have been changed since the last sync for {}", username);

				// No items to sync, stop processing
				clearSyncCountdown();

				return;
			}

			log.debug("Found {} changed log item(s) since the last sync: {}", itemDiff.elementSet().size(), itemDiff);

			// Add the log items found in the diff to the pending sync items set
			obtainedCollectionLogItems
				.stream()
				// Name check isn't technically needed here, but it helps suppress warnings
				.filter(item -> itemDiff.contains(item.getId()) && item.getName() != null)
				.map(item -> new ObtainedCollectionItem(item.getId(), item.getName(), item.getCount()))
				.forEach(pendingSyncItems::add);
		}
		finally
		{
			setComputingDiff(false);
		}
	}

	/**
	 * Uploads the obtained collection log items to the server.
	 * This is called when the sync countdown has completed and there are items pending a sync.
	 */
	@Synchronized
	public void uploadObtainedCollectionLogItems()
	{
		if (backoffStrategy.shouldSkipRequest())
		{
			return;
		}

		String username = client.getLocalPlayer().getName();

		if (username == null)
		{
			return;
		}

		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
		PlayerProfile profileKey = new PlayerProfile(username, profileType);

		PlayerDataSync submission = new PlayerDataSync(
			profileKey.getUsername(),
			profileKey.getProfileType().name(),
			client.getAccountHash(),
			pendingSyncItems
		);

		try
		{
			String response = requestManager.uploadObtainedCollectionLogItems(submission);

			CollectionLogSyncResponse collectionLogSyncResponse = gson.fromJson(response, CollectionLogSyncResponse.class);
			String lastChangedTimestamp = getLastChangedTimestamp(collectionLogSyncResponse, response);

			log.debug("response: {}, lastChanged: {}", response, lastChangedTimestamp);

			// Saves the new/updated items to the API cache to prevent refetching the entire log
			CollectionDatabase.upsertItemsBatch(username, pendingSyncItems, Timestamp.valueOf(lastChangedTimestamp));

			obtainedItemNames.clear();
			pendingSyncItems.clear();

			clearSyncCountdown();

			log.debug("Successfully synchronised new log items for {}", submission.getUsername());
		}
		catch (IOException | NullPointerException e)
		{
			log.error("❌ Failed to upload obtained collection log items: {}", e.getMessage());
		}
		finally
		{
			backoffStrategy.finishCycle();
		}
	}

	private String getLastChangedTimestamp(CollectionLogSyncResponse collectionLogSyncResponse, String response) throws IOException
	{
		APIError error = collectionLogSyncResponse.getError();
		CollectionLogSyncResponse.Data data = collectionLogSyncResponse.getData();

		if (error == null && data == null)
		{
			clearSyncCountdown();

			throw new NullPointerException("Unexpected response format from the collection log sync endpoint: " + response);
		}

		if (error != null)
		{
			clearSyncCountdown();

			throw new IOException(String.valueOf(error));
		}

		return data.getLastChanged();
	}
}

package com.templeosrs.util.collections.autosync;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.tuple.Pair;

import javax.inject.Inject;
import java.util.Arrays;

@Slf4j
public class CollectionLogAutoSyncItemContainerChangedSubscriber
{
    @Inject
    private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

    @Inject
    private ItemManager itemManager;

    private final Multiset<Integer> inventoryItems = HashMultiset.create();

    /**
     * This method is called when the item container changes, specifically when the inventory is updated.
     * If any items in the inventory match the newly obtained collection log item names,
     * they are added to a list of items awaiting a server sync and the sync countdown is started.
     */
    @Subscribe
    private void onItemContainerChanged(ItemContainerChanged itemContainerChanged)
    {
        if (itemContainerChanged.getContainerId() != InventoryID.INV) {
            return;
        }

        final ItemContainer inventory = itemContainerChanged.getItemContainer();
        final Multiset<Integer> currentInventoryItems = HashMultiset.create();

        Arrays.stream(inventory.getItems()).forEach(
                item -> currentInventoryItems.add(item.getId(), item.getQuantity())
        );

        final Multiset<Integer> inventoryDifference = Multisets.difference(currentInventoryItems, inventoryItems);

        final int previousPendingSyncItemsCount = collectionLogAutoSyncManager.pendingSyncItems.size();

        inventoryDifference.entrySet().forEach(item -> {
            String itemName = itemManager.getItemComposition(item.getElement()).getName();
            int itemId = item.getElement();
            int itemCount = item.getCount();

            if (collectionLogAutoSyncManager.obtainedItemNames.contains(itemName)) {
                collectionLogAutoSyncManager.pendingSyncItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
                collectionLogAutoSyncManager.obtainedItemNames.remove(itemName);
            }
        });

        // Overwrite the cached inventory items with the current inventory items
        // to provide a comparator for the next inventory change event
        inventoryItems.clear();
        inventoryItems.addAll(currentInventoryItems);

        if (previousPendingSyncItemsCount < collectionLogAutoSyncManager.pendingSyncItems.size()) {
            collectionLogAutoSyncManager.startSyncCountdown();
        }
    }
}

package com.templeosrs.util.collections.autosync;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class LoggedInState {
    private static final int LOGGED_OUT = -1;

    @Inject
    private Client client;

    private int lastLoggedInTick = LOGGED_OUT;

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        setForCurrentGameState(event.getGameState());
    }

    public void setForCurrentGameState(GameState gameState) {
        if (gameState == GameState.LOGGED_IN) {
            setLastLoginTick(client.getTickCount());
        } else {
            setLoggedOut();
        }
    }

    public boolean isLoggedOut() {
        return this.lastLoggedInTick == LOGGED_OUT;
    }

    public boolean onlyJustLoggedIn(int tickWindow) {
        return client.getTickCount() - this.lastLoggedInTick < tickWindow;
    }

    public void setLoggedOut() {
        this.lastLoggedInTick = LOGGED_OUT;
    }

    public void setLastLoginTick(int lastLoggedInTick) {
        this.lastLoggedInTick = lastLoggedInTick;
    }
}
package com.templeosrs.util.collections.autosync;

import com.templeosrs.util.api.QuadraticBackoffStrategy;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.HashSet;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
public class CollectionLogAutoSyncGameTickSubscriber
{
    @Inject
    private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

    @Inject
    private CollectionLogManager collectionLogManager;

    @Inject
    private Client client;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    /**
     * Listens for game ticks and checks if the sync countdown has completed.
     * Once the countdown is complete, and there are items pending a sync
     * it will upload any newly obtained items to the server.
     */
    @Subscribe
    public void onGameTick(GameTick gameTick)
    {
        QuadraticBackoffStrategy backoffStrategy = collectionLogAutoSyncManager.getBackoffStrategy();

        if (backoffStrategy.isRequestLimitReached()) {
            collectionLogAutoSyncManager.clearSyncCountdown();
            return;
        }

        if (backoffStrategy.isSubmitting() || collectionLogAutoSyncManager.isComputingDiff()) {
            return;
        }

        final Integer gameTickToSync = collectionLogAutoSyncManager.getGameTickToSync();
        final HashSet<ObtainedCollectionItem> pendingSyncItems = collectionLogAutoSyncManager.getPendingSyncItems();

        // Add any diffed items to the pendingSync list when the log has been opened
        if (
            gameTickToSync != null &&
            client.getTickCount() >= gameTickToSync &&
            collectionLogAutoSyncManager.isLogOpenAutoSync() &&
            pendingSyncItems.isEmpty()
        ) {
            collectionLogAutoSyncManager.setComputingDiff(true);
            scheduledExecutorService.execute(collectionLogAutoSyncManager::computeCollectionLogDiff);

            return;
        }

        if (gameTickToSync == null || pendingSyncItems.isEmpty()) {
            return;
        }

        // Sync new collection log items when the game has reached correct tick.
        if (client.getTickCount() >= gameTickToSync) {
            backoffStrategy.setSubmitting(true);
            scheduledExecutorService.execute(collectionLogAutoSyncManager::uploadObtainedCollectionLogItems);
        }
    }
}

package com.templeosrs.util.collections.autosync;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static net.runelite.client.util.Text.removeTags;

@Slf4j
public class CollectionLogAutoSyncChatMessageSubscriber
{
    private final Pattern NEW_COLLECTION_LOG_ITEM_PATTERN = Pattern.compile("New item added to your collection log: (.*)");

    @Inject
    private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

    /**
     * This method watches for in-game chat messages that match the new collection log item pattern.
     * If a matching message is found, it extracts the item name and adds it to the obtainedItemNames set,
     * which is then used by the ItemContainerChanged and NpcLootReceived events to determine if the item should be synced.
     */
    @Subscribe
    private void onChatMessage(ChatMessage chatMessage)
    {
        if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE) {
            return;
        }

        Matcher matcher = NEW_COLLECTION_LOG_ITEM_PATTERN.matcher(chatMessage.getMessage());

        if (matcher.matches()) {
            String itemName = removeTags(matcher.group(1));

            collectionLogAutoSyncManager.obtainedItemNames.add(itemName);
        }
    }
}

/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.util.collections.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.Set;

@Data
@AllArgsConstructor
public class PlayerDataSync
{
    private String username;
    private String profile;
    private long playerHash;
    private Set<ObtainedCollectionItem> items;
}
package com.templeosrs.util.collections.autosync;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.collections.CollectionLogManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.Set;

@Slf4j
public class CollectionLogAutoSyncConfigChecker {
    @Inject
    private Client client;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private TempleOSRSPlugin templeOSRSPlugin;

    @Inject
    private CollectionLogManager collectionLogManager;

    @Inject
    private LoggedInState loggedInState;

    private int lastShownCollectionLogSettingWarningTick = -1;

    /**
     * Potential values are:
     * 0 = no notification
     * 1 = chat notification only
     * 2 = popup notification only
     * 3 = chat and popup
     * <p>
     * We only care about 1 and 3 to indicate chat message notifications are enabled.
     */
    private static final Set<Integer> enabledCollectionLogNotificationSettingValues = Set.of(1, 3);

    void startUp()
    {
        if (client.getGameState() == GameState.LOGGED_IN) {
            collectionLogManager.getClientThread().invoke(() -> {
                checkAndWarnForCollectionLogNotificationSetting(client.getVarbitValue(VarbitID.OPTION_COLLECTION_NEW_ITEM));
            });
        }
    }

    void shutDown()
    {
        lastShownCollectionLogSettingWarningTick = -1;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        GameState gameState = event.getGameState();

        if (gameState == GameState.CONNECTION_LOST || gameState == GameState.HOPPING) {
            lastShownCollectionLogSettingWarningTick = client.getTickCount(); // avoid warning during DC or hopping
        }

        if (gameState == GameState.LOGIN_SCREEN) {
            lastShownCollectionLogSettingWarningTick = -1;
        }
    }

    /**
     * Checks for OPTION_COLLECTION_NEW_ITEM varbit value changes and runs the warning message check.
     * This is also ran when logging in, as the game doesn't load varbits immediately.
     * Don't read varbits during a world hop because they seem to always be 0
     */
    @Subscribe
    private void onVarbitChanged(VarbitChanged varbitChanged) {
        if (varbitChanged.getVarbitId() == VarbitID.OPTION_COLLECTION_NEW_ITEM && client.getGameState() != GameState.HOPPING) {
            checkAndWarnForCollectionLogNotificationSetting(varbitChanged.getValue());
        }
    }

    /**
     * If the auto-sync clog option is enabled, the warning has not been shown recently, and the
     * clog notification option is disabled, shows a warning to the player to tell them to enable the in-game option.
     */
    private void checkAndWarnForCollectionLogNotificationSetting(int collectionLogOptionVarbitValue) {
        if (
                !templeOSRSPlugin.getConfig().autoSyncClog() ||
                loggedInState.isLoggedOut() ||
                (lastShownCollectionLogSettingWarningTick != -1 &&
                        client.getTickCount() - lastShownCollectionLogSettingWarningTick < 16) ||
                enabledCollectionLogNotificationSettingValues.contains(collectionLogOptionVarbitValue)
        ) {
            return;
        }

        lastShownCollectionLogSettingWarningTick = client.getTickCount();
        sendEnableCollectionLogSettingsMessage();
    }

    private void sendEnableCollectionLogSettingsMessage() {
        String highlightedMessage = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append("Please enable \"Collection log - New addition notification\" in your game settings for " +
                        "TempleOSRS to automatically sync your collection log!")
                .build();

        chatMessageManager.queue(QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(highlightedMessage)
                .build());
    }
}

package com.templeosrs.util.collections;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * All available category groups (i.e. tabs) mapped to their in-game struct IDs
 */
@RequiredArgsConstructor
public enum CollectionLogCategoryGroup {
    bosses(471),
    raids(472),
    clues(473),
    minigames(474),
    other(475);

    @Getter
    private final int structId;
}
/*
 * Copyright (c) 2025, andmcadams
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.templeosrs.util.collections;

import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.api.QuadraticBackoffStrategy;
import com.templeosrs.util.collections.autosync.CollectionLogAutoSyncManager;
import com.templeosrs.util.collections.chatcommands.CollectionLogChatCommandChatMessageSubscriber;
import com.templeosrs.util.collections.data.*;
import com.templeosrs.util.collections.database.CollectionDatabase;
import com.templeosrs.util.collections.services.CollectionLogService;
import com.templeosrs.util.collections.utils.CollectionLogCacheData;
import lombok.Getter;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneScapeProfileType;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import org.jetbrains.annotations.Nullable;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class CollectionLogManager
{
	@Inject
	private ItemManager itemManager;

	@Inject
	private SyncButtonManager syncButtonManager;

	@Inject
	private ScheduledExecutorService scheduledExecutorService;

	@Getter
	@Inject
	private Client client;

	@Getter
	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CollectionLogAutoSyncManager collectionLogAutoSyncManager;

	@Inject
	private TempleOSRSPlugin templeOSRSPlugin;

	@Inject
	private CollectionLogRequestManager requestManager;

	@Inject
	private CollectionLogService collectionLogService;

	@Inject
	private CollectionLogChatCommandChatMessageSubscriber collectionLogChatCommandChatMessageSubscriber;

	@Inject
	private CollectionLogRequestManager collectionLogRequestManager;

	@Nullable
	private Integer gameTickToSync;

	/**
	 * List of items found in the collection log, computed by reading the in-game enums/structs.
	 */
	private final Set<Integer> collectionLogItemsFromCache = new HashSet<>();

	/**
	 * Unique list of all obtained collection log items
	 */
	@Getter
	private final Set<ObtainedCollectionItem> obtainedCollectionLogItems = new HashSet<>();

	/**
	 * Maps in-game categories to the list of items they contain. Pulled from the in-game cache, where the key is the
	 * category struct ID (e.g. <a href="https://chisel.weirdgloop.org/structs/index.html?type=structs&id=493">STRUCT #493</a>)
	 * and the value is the contents of the enum found in <a href="https://chisel.weirdgloop.org/structs/index.html?type=params&id=690">PARAM #690</a>.
	 */
	@Getter
	private static final Map<Integer, Set<Integer>> collectionLogCategoryItemMap = new HashMap<>();

	/**
	 * Maps slugified category names (e.g. guardians_of_the_rift) to their in-game struct ID
	 */
	@Getter
	private static final Map<String, Integer> collectionLogCategoryStructIdMap = new HashMap<>();

	/**
	 * Maps top level tabs (e.g. "Bosses") to their containing categories.
	 * Used to list the available categories when using the "!col help ___" commands
	 */
	@Getter
	private static final Map<Integer, Set<String>> collectionLogCategoryTabSlugs = new LinkedHashMap<>();

	@Getter
	private final QuadraticBackoffStrategy backoffStrategy = new QuadraticBackoffStrategy();

	public void startUp()
	{
		eventBus.register(this);

		CollectionDatabase.init();

		if (templeOSRSPlugin.getConfig().enableClogChatCommand())
		{
			collectionLogChatCommandChatMessageSubscriber.startUp();
		}

		if (templeOSRSPlugin.getConfig().autoSyncClog())
		{
			collectionLogAutoSyncManager.startUp();
		}

		clientThread.invoke(() -> {
			if (client.getIndexConfig() == null || client.getGameState().ordinal() < GameState.LOGIN_SCREEN.ordinal())
			{
				return false;
			}

			CollectionLogCacheData collectionLogCacheData = parseCacheForClog();

			collectionLogItemsFromCache.addAll(collectionLogCacheData.getItemIds());
			collectionLogCategoryItemMap.putAll(collectionLogCacheData.getCategoryItems());
			collectionLogCategoryStructIdMap.putAll(collectionLogCacheData.getCategoryStructIds());
			collectionLogCategoryTabSlugs.putAll(collectionLogCacheData.getCategorySlugs());

			return true;
		});
	}

	public void shutDown()
	{
		eventBus.unregister(this);

		if (templeOSRSPlugin.getConfig().enableClogChatCommand())
		{
			collectionLogChatCommandChatMessageSubscriber.shutDown();
		}

		if (templeOSRSPlugin.getConfig().autoSyncClog())
		{
			collectionLogAutoSyncManager.shutDown();
		}

		syncButtonManager.shutDown();

		obtainedCollectionLogItems.clear();
		collectionLogItemsFromCache.clear();
		collectionLogCategoryItemMap.clear();
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(TempleOSRSConfig.TEMPLE_OSRS_CONFIG_GROUP))
		{
			return;
		}

		if (templeOSRSPlugin.getConfig().autoSyncClog())
		{
			collectionLogAutoSyncManager.startUp();
		}
		else
		{
			collectionLogAutoSyncManager.shutDown();
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		if (backoffStrategy.isRequestLimitReached())
		{
			gameTickToSync = null;

			return;
		}

		if (!backoffStrategy.isSubmitting() && gameTickToSync != null && client.getTickCount() >= gameTickToSync)
		{
			backoffStrategy.setSubmitting(true);
			scheduledExecutorService.execute(this::submitTask);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState state = gameStateChanged.getGameState();

		switch (state)
		{
			// When hopping, we need to clear any state related to the player
			case HOPPING:
			case LOGGING_IN:
			case CONNECTION_LOST:
				break;
			case LOGGED_IN:
			{
				// Attempt to synchronise the player's collection log on login
				clientThread.invokeLater(() -> {
					final String username = client.getLocalPlayer().getName();

					// Wait for username to be available
					if (username == null)
					{
						return false;
					}

					try
					{
						String lastChanged = collectionLogRequestManager
							.getPlayerInfo(username)
							.getCollectionLog()
							.getLastChanged();


						// Skip sync if the player's collection log doesn't exist, or has already been saved and is up-to-date
						if (
							lastChanged == null ||
								(collectionLogService.isDataFresh(username, lastChanged) && CollectionDatabase.hasPlayerData(username))
						)
						{
							return true;
						}

						collectionLogService.syncCollectionLog();

						return true;
					}
					catch (NullPointerException | IOException e)
					{
						// If an error occurs then bail early to avoid infinite retries
						return true;
					}
				});
			}
		}
	}

	/**
	 * Handles updating the collection log after the log has opened or the Temple sync button has been pressed.
	 */
	@Subscribe
	public void onScriptPreFired(ScriptPreFired preFired)
	{
		if (preFired.getScriptId() == 4100)
		{
			if (collectionLogItemsFromCache.isEmpty())
			{
				return;
			}

			// Submit the collection log data three ticks after the first script prefires
			// This gives the game time to build the obtained items set and resolves an issue
			// that caused players with large logs to miss items in their sync data
			gameTickToSync = client.getTickCount() + 3;

			Object[] args = preFired.getScriptEvent().getArguments();
			int itemId = (int) args[1];
			int itemCount = (int) args[2];
			String itemName = itemManager.getItemComposition(itemId).getName();

			obtainedCollectionLogItems.add(new ObtainedCollectionItem(itemId, itemName, itemCount));
		}
	}

	@Synchronized
	public void submitTask()
	{
		// TODO: do we want other GameStates?
		if (client.getGameState() != GameState.LOGGED_IN || client.getLocalPlayer().getName() == null)
		{
			log.error("⚠️ Aborting sync as the player is no longer logged in");

			return;
		}

		if (backoffStrategy.shouldSkipRequest())
		{
			return;
		}

		String username = client.getLocalPlayer().getName();

		final boolean hasPlayerData = CollectionDatabase.hasPlayerData(username);

		if (hasPlayerData && !syncButtonManager.isFullSyncRequested())
		{
			backoffStrategy.reset();
			gameTickToSync = null;

			return;
		}

		// If no API player data exists or if the sync button has been pressed, upload the entire log
		submitPlayerData();
	}

	private void submitPlayerData()
	{
		String username = client.getLocalPlayer().getName();

		// Do not send if slot data wasn't generated
		if (obtainedCollectionLogItems.isEmpty())
		{
			log.error("❌ No obtained items have been set for {}", username);

			gameTickToSync = null;
			backoffStrategy.reset();

			return;
		}

		RuneScapeProfileType profileType = RuneScapeProfileType.getCurrent(client);
		PlayerProfile profileKey = new PlayerProfile(username, profileType);

		// Only IDs and counts are useful in the request
		Set<ObtainedCollectionItem> preparedItems = obtainedCollectionLogItems
			.stream()
			.map(item -> new ObtainedCollectionItem(item.getId(), item.getCount()))
			.collect(Collectors.toSet());

		int totalCollectionsAvailable = collectionLogItemsFromCache.size();

		PlayerData playerData = new PlayerData(totalCollectionsAvailable, preparedItems);

		PlayerDataSubmission submission = new PlayerDataSubmission(
			profileKey.getUsername(),
			profileKey.getProfileType().name(),
			client.getAccountHash(),
			playerData
		);

		try
		{
			requestManager.uploadFullCollectionLog(submission);
			syncButtonManager.setFullSyncRequested(false);
			gameTickToSync = null;

			log.debug("Successfully submitted collection log for {}", submission.getUsername());
		}
		catch (IOException e)
		{
			log.error("❌ Failed to upload collection log for {}", submission.getUsername());
		}
		finally
		{
			backoffStrategy.finishCycle();
		}
	}

	/**
	 * Parse the enums and structs in the cache to figure out which item ids exist in the collection log.
	 */
	private CollectionLogCacheData parseCacheForClog()
	{
		Set<Integer> items = new HashSet<>();
		Map<Integer, Set<Integer>> categoryItems = new HashMap<>();
		Map<String, Integer> categoryStructIds = new HashMap<>();
		Map<Integer, Set<String>> categorySlugs = new LinkedHashMap<>();

		final Pattern specialCharacterPattern = Pattern.compile("['()]", Pattern.CASE_INSENSITIVE);

		// Some items with data saved on them have replacements to fix a duping issue (satchels, flamtaer bag)
		// Enum 3721 contains a mapping of the item ids to replace -> ids to replace them with
		EnumComposition replacements = client.getEnum(3721);

		// 2102 - Struct that contains the highest level tabs in the collection log (Bosses, Raids, etc)
		// https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2102
		int[] topLevelTabStructIds = client.getEnum(2102).getIntVals();
		for (int topLevelTabStructIndex : topLevelTabStructIds)
		{
			// The collection log top level tab structs contain a param that points to the enum
			// that contains the pointers to sub tabs.
			// ex: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=471
			StructComposition topLevelTabStruct = client.getStructComposition(topLevelTabStructIndex);

			Set<String> singleCategorySlugSet = new LinkedHashSet<>();

			// Param 683 contains the pointer to the enum that contains the subtabs ids
			// ex: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2103
			int[] subtabStructIndices = client.getEnum(topLevelTabStruct.getIntValue(683)).getIntVals();
			for (int subtabStructIndex : subtabStructIndices)
			{

				// The subtab structs are for subtabs in the collection log (Commander Zilyana, Chambers of Xeric, etc.)
				// and contain a pointer to the enum that contains all the item ids for that tab.
				// ex subtab struct: https://chisel.weirdgloop.org/structs/index.html?type=structs&id=476
				// ex subtab enum: https://chisel.weirdgloop.org/structs/index.html?type=enums&id=2109
				StructComposition subtabStruct = client.getStructComposition(subtabStructIndex);

				int[] clogItems = client.getEnum(subtabStruct.getIntValue(690)).getIntVals();

				// Gets a slugified version of the category title
				// (e.g. Master Treasure Trails (Rare) -> master_treasure_trails_rare)
				String normalizedCategoryName = specialCharacterPattern
					.matcher(
						subtabStruct.getStringValue(689)
							.toLowerCase()
							.replaceAll(" ", "_")
					)
					.replaceAll("");

				Set<Integer> itemSet = new LinkedHashSet<>();

				for (int clogItemId : clogItems)
				{
					final int replacementId = replacements.getIntValue(clogItemId);

					itemSet.add(
						replacementId == -1
							? clogItemId
							: replacementId
					);
				}

				items.addAll(itemSet);
				categoryItems.put(subtabStructIndex, itemSet);
				categoryStructIds.put(normalizedCategoryName, subtabStructIndex);
				singleCategorySlugSet.add(normalizedCategoryName);
			}

			categorySlugs.put(topLevelTabStructIndex, singleCategorySlugSet);
		}

		return new CollectionLogCacheData(items, categoryItems, categoryStructIds, categorySlugs);
	}
}

package com.templeosrs.util.collections;

import lombok.RequiredArgsConstructor;

/**
 * Categories that can be used in the chat command.
 * Note: the command falls back to the input value, so may capture items not in this list if it has not been updated
 *
 * @link <a href="https://templeosrs.com/api/collection-log/category_parameters.php">Full category list</a>
 */
@RequiredArgsConstructor
public enum CollectionLogCategorySlug {
    // Bosses
    abyssal_sire,
    alchemical_hydra,
    amoxliatl,
    araxxor,
    barrows_chests,
    bryophyta,
    callisto_and_artio,
    cerberus,
    chaos_elemental,
    chaos_fanatic,
    commander_zilyana,
    corporeal_beast,
    crazy_archaeologist,
    dagannoth_kings,
    deranged_archaeologist,
    doom_of_mokhaiotl,
    duke_sucellus,
    the_fight_caves,
    fortis_colosseum,
    the_gauntlet,
    general_graardor,
    giant_mole,
    grotesque_guardians,
    hespori,
    the_hueycoatl,
    the_inferno,
    kalphite_queen,
    king_black_dragon,
    kraken,
    kreearra,
    kril_tsutsaroth,
    the_leviathan,
    moons_of_peril,
    nex,
    the_nightmare,
    obor,
    phantom_muspah,
    royal_titans,
    sarachnis,
    scorpia,
    scurrius,
    skotizo,
    tempoross,
    thermonuclear_smoke_devil,
    vardorvis,
    venenatis_and_spindel,
    vetion_and_calvarion,
    vorkath,
    the_whisperer,
    wintertodt,
    yama,
    zalcano,
    zulrah,

    // Raids
    chambers_of_xeric,
    theatre_of_blood,
    tombs_of_amascut,

    // Clues
    beginner_treasure_trails,
    easy_treasure_trails,
    medium_treasure_trails,
    hard_treasure_trails,
    elite_treasure_trails,
    master_treasure_trails,
    hard_treasure_trails_rare,
    elite_treasure_trails_rare,
    master_treasure_trails_rare,
    shared_treasure_trail_rewards,
    scroll_cases,

    // Minigames
    barbarian_assault,
    brimhaven_agility_arena,
    castle_wars,
    fishing_trawler,
    giants_foundry,
    gnome_restaurant,
    guardians_of_the_rift,
    hallowed_sepulchre,
    last_man_standing,
    magic_training_arena,
    mahogany_homes,
    mastering_mixology,
    pest_control,
    rogues_den,
    shades_of_mortton,
    soul_wars,
    temple_trekking,
    tithe_farm,
    trouble_brewing,
    vale_totems,
    volcanic_mine,

    // Other
    aerial_fishing,
    all_pets,
    camdozaal,
    champions_challenge,
    chompy_bird_hunting,
    colossal_wyrm_agility,
    creature_creation,
    cyclopes,
    elder_chaos_druids,
    forestry,
    fossil_island_notes,
    gloughs_experiments,
    hunter_guild,
    monkey_backpacks,
    motherlode_mine,
    my_notes,
    random_events,
    revenants,
    rooftop_agility,
    shayzien_armour,
    shooting_stars,
    skilling_pets,
    slayer,
    tormented_demons,
    tzhaar,
    miscellaneous,

    // Custom
    gilded,
    thirdage,
}
package com.templeosrs.util.collections.chatcommands;

import com.templeosrs.util.collections.chatcommands.commands.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.*;

@Slf4j
public class CollectionLogChatCommandChatMessageSubscriber
{
	@Inject
	private Client client;

	@Inject
	private EventBus eventBus;

	@Inject
	private DisplayPlayerCollectionLogChatCommand displayPlayerCollectionLogChatCommand;

	@Inject
	private ListAllHelpCommandsChatCommand helpCommandsChatCommand;

	@Inject
	private ListAllBossCategoriesChatCommand bossCategoriesChatCommand;

	@Inject
	private ListAllCluesCategoriesChatCommand cluesCategoriesChatCommand;

	@Inject
	private ListAllRaidsCategoriesChatCommand raidsCategoriesChatCommand;

	@Inject
	private ListAllCustomCategoriesChatCommand customCategoriesChatCommand;

	@Inject
	private ListAllMinigamesCategoriesChatCommand minigamesCategoriesChatCommand;

	@Inject
	private ListAllOtherCategoriesChatCommand otherCategoriesChatCommand;

	private final Set<ChatMessageType> allowedMessageTypes = Set.of(
		ChatMessageType.PUBLICCHAT,
		ChatMessageType.FRIENDSCHAT,
		ChatMessageType.PRIVATECHAT,
		ChatMessageType.CLAN_CHAT,
		ChatMessageType.CLAN_GIM_MESSAGE,
		ChatMessageType.CLAN_GUEST_CHAT
	);

	public static Map<String, ChatCommand> chatCommands = new LinkedHashMap<>();

	public void startUp()
	{
		eventBus.register(this);

		chatCommands.put(displayPlayerCollectionLogChatCommand.trigger, displayPlayerCollectionLogChatCommand);
		chatCommands.put(helpCommandsChatCommand.trigger, helpCommandsChatCommand);
		chatCommands.put(bossCategoriesChatCommand.trigger, bossCategoriesChatCommand);
		chatCommands.put(raidsCategoriesChatCommand.trigger, raidsCategoriesChatCommand);
		chatCommands.put(cluesCategoriesChatCommand.trigger, cluesCategoriesChatCommand);
		chatCommands.put(minigamesCategoriesChatCommand.trigger, minigamesCategoriesChatCommand);
		chatCommands.put(otherCategoriesChatCommand.trigger, otherCategoriesChatCommand);
		chatCommands.put(customCategoriesChatCommand.trigger, customCategoriesChatCommand);
	}

	public void shutDown()
	{
		eventBus.unregister(this);

		chatCommands.values().forEach(ChatCommand::shutDown);
		chatCommands.clear();
	}

	@Subscribe(priority = -2) // Run after ChatMessageManager
	public void onChatMessage(ChatMessage event)
	{
		final ChatMessageType type = event.getType();
		final String rawMessage = event.getMessage().trim();

		final String COLLECTION_LOG_CHAT_TRIGGER = "!col ";

		// Only react to public, private, or clan chat messages that begin with "!col "
		if (!allowedMessageTypes.contains(type) || !rawMessage.toLowerCase().startsWith(COLLECTION_LOG_CHAT_TRIGGER))
		{
			return;
		}

		ChatCommand chatCommand = chatCommands.get(rawMessage.toLowerCase());

		if (chatCommand != null)
		{
			chatCommand.execute(event);

			return;
		}

		displayPlayerCollectionLogChatCommand.command(event);
	}

	/**
	 * Prevents the help commands from being rendered to the chat for anyone with the plugin installed
	 */
	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!event.getEventName().equals("chatFilterCheck"))
		{
			return;
		}

		int[] intStack = client.getIntStack();
		int intStackSize = client.getIntStackSize();
		Object[] objectStack = client.getObjectStack();
		int objectStackSize = client.getObjectStackSize();

		final int messageType = intStack[intStackSize - 2];
		String message = (String) objectStack[objectStackSize - 1];
		ChatMessageType chatMessageType = ChatMessageType.of(messageType);

		if (!allowedMessageTypes.contains(chatMessageType))
		{
			return;
		}

		Set<String> hiddenChatCommands = Set.of("!col list", "!col help");

		for (String hiddenChatCommand : hiddenChatCommands)
		{
			if (message.toLowerCase().startsWith(hiddenChatCommand))
			{
				intStack[intStackSize - 3] = 0;

				break;
			}
		}
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.chatcommands.ChatCommand;
import com.templeosrs.util.collections.data.CollectionLogCategory;
import com.templeosrs.util.collections.utils.CollectionLogCategoryUtils;
import java.util.List;
import java.util.stream.Collectors;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;

import java.util.Map;

public class ListAllCustomCategoriesChatCommand extends ChatCommand {
    public ListAllCustomCategoriesChatCommand()
    {
        super("!col list custom", "Lists all available custom categories", true);
    }

    @Override
    public void command(ChatMessage event)
    {
        clientThread.invoke(() -> {
            chatMessageManager.queue(
                QueuedMessage.builder()
                    .type(ChatMessageType.CONSOLE)
                    .runeLiteFormattedMessage(buildAvailableCategoriesMessage("custom"))
                    .build()
            );

			List<Integer> iconItemIds = CollectionLogCategoryUtils.CUSTOM_CATEGORIES
				.values()
				.stream()
				.map(item -> item.getItems().iterator().next())
				.collect(Collectors.toList());

			loadItemIcons(iconItemIds);

			int i = 0;

            for (Map.Entry<String, CollectionLogCategory> customCategory : CollectionLogCategoryUtils.CUSTOM_CATEGORIES.entrySet()) {
				int iconIndex = itemIconIndexes.get(iconItemIds.get(i++));

                chatMessageManager.queue(
                    QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(
                            new ChatMessageBuilder()
                                .append(ChatColorType.NORMAL)
								.img(iconIndex)
                                .append(customCategory.getValue().getTitle())
                                .append(": ")
                                .append(ChatColorType.HIGHLIGHT)
                                .append(customCategory.getKey())
                                .build()
                        )
                        .build()
                );
            }

            client.refreshChat();
        });
    }
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllCluesCategoriesChatCommand extends ChatCommand {
    public ListAllCluesCategoriesChatCommand()
    {
        super("!col list clues", "Lists all available clues categories", true);
    }

    @Override
    public void command(ChatMessage event)
    {
        listAvailableCollectionLogCategories(CollectionLogCategoryGroup.clues);
    }
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.ChatMessage;

@Slf4j
public class ListAllBossCategoriesChatCommand extends ChatCommand {
    public ListAllBossCategoriesChatCommand()
    {
        super("!col list bosses", "Lists all available boss categories", true);
    }

    @Override
    public void command(ChatMessage event)
    {
        listAvailableCollectionLogCategories(CollectionLogCategoryGroup.bosses);
    }
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.chatcommands.ChatCommand;
import com.templeosrs.util.collections.chatcommands.CollectionLogChatCommandChatMessageSubscriber;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.Text;

import java.util.Map;

public class ListAllHelpCommandsChatCommand extends ChatCommand {
    public ListAllHelpCommandsChatCommand()
    {
        super("!col help", "Lists all available help commands", true);
    }

    @Override
    public void command(ChatMessage event)
    {
        clientThread.invoke(() -> {
            chatMessageManager.queue(
                QueuedMessage.builder()
                    .type(ChatMessageType.CONSOLE)
                    .runeLiteFormattedMessage("Available help commands:")
                    .build()
            );

            for (Map.Entry<String, ChatCommand> helpCommandMessage : CollectionLogChatCommandChatMessageSubscriber.chatCommands.entrySet())
            {
                // Output a list of all available help commands, excluding the current one
                // (the player must already know the command to even trigger this)
                if (!helpCommandMessage.getKey().equals(this.trigger)) {
                    chatMessageManager.queue(
                        QueuedMessage.builder()
                            .type(ChatMessageType.CONSOLE)
                            .runeLiteFormattedMessage(
                                    new ChatMessageBuilder()
                                        .append(ChatColorType.HIGHLIGHT)
                                        .append(helpCommandMessage.getKey())
                                        .append(": ")
                                        .append(ChatColorType.NORMAL)
                                        .append(Text.escapeJagex(helpCommandMessage.getValue().description))
                                        .build()
                            )
                            .build()
                    );
                }
            }

            client.refreshChat();
        });
    }
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllRaidsCategoriesChatCommand extends ChatCommand {
    public ListAllRaidsCategoriesChatCommand()
    {
        super("!col list raids", "Lists all available raids categories", true);
    }

    @Override
    public void command(ChatMessage event)
    {
        listAvailableCollectionLogCategories(CollectionLogCategoryGroup.raids);
    }
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllOtherCategoriesChatCommand extends ChatCommand {
    public ListAllOtherCategoriesChatCommand()
    {
        super("!col list other", "Lists all available other categories", true);
    }

    @Override
    public void command(ChatMessage event)
    {
        listAvailableCollectionLogCategories(CollectionLogCategoryGroup.other);
    }
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.collections.CollectionLogCategorySlug;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.CollectionLogRequestManager;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import com.templeosrs.util.collections.data.CollectionLogCategory;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.data.PlayerInfoResponse;
import com.templeosrs.util.collections.database.CollectionDatabase;
import com.templeosrs.util.collections.parser.CollectionParser;
import com.templeosrs.util.collections.services.CollectionLogService;
import com.templeosrs.util.collections.utils.CollectionLogCategoryUtils;
import com.templeosrs.util.collections.utils.PlayerNameUtils;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.StructComposition;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import javax.inject.Inject;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
public class DisplayPlayerCollectionLogChatCommand extends ChatCommand  {
    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private CollectionLogRequestManager collectionLogRequestManager;

    @Inject
    private TempleOSRSPlugin templeOSRSPlugin;

    @Inject
    private CollectionParser collectionParser;

    @Inject
    private CollectionLogService collectionLogService;

    public DisplayPlayerCollectionLogChatCommand()
	{
		super("!col ", "Displays the player's collection log for a given boss. May also be used to display other players' logs, e.g. !col kree CousinOfKos", false);
	}

    @Override
    public void command(ChatMessage event)
	{
        final String rawMessage = event.getMessage().trim();

        String[] parts = rawMessage.substring(5).trim().split(" ", 2);

        if (parts.length == 0) {
            return;
        }

        // Normalize boss name
        String bossInput = parts[0].trim().replace(' ', '_').toLowerCase();
        CollectionLogCategory category = getCategoryFromMessageInput(bossInput);

        // Determine target player (specified or sender)
        String playerName = (parts.length == 2) ? parts[1].trim() : event.getName();
        String normalizedPlayerName = PlayerNameUtils.normalizePlayerName(playerName);  // Normalize the player name for the API call
        String localName = PlayerNameUtils.normalizePlayerName(client.getLocalPlayer().getName());
        boolean isLocalPlayer = normalizedPlayerName.equalsIgnoreCase(localName);

        if (category == null) {
            if (isLocalPlayer) {
                log.warn("❌ No alias or category found for {}", bossInput);

                final String errorMessage = new ChatMessageBuilder()
                    .append(ChatColorType.NORMAL)
                    .append("Use ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append("!col help")
                    .append(ChatColorType.NORMAL)
                    .append(" to help find the correct category.")
                    .build();

                chatMessageManager.queue(
                    QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(errorMessage)
                        .build()
                );
            }

            overwriteMessage(
                new ChatMessageBuilder()
                    .append(ChatColorType.HIGHLIGHT)
                    .append(bossInput)
                    .append(ChatColorType.NORMAL)
                    .append(" is not a valid collection log category or alias.")
                    .build(),
                event.getMessageNode()
            );

            return;
        }

        scheduledExecutorService.execute(() ->
        {
            PlayerInfoResponse.Data playerInfo = getPlayerInfo(normalizedPlayerName, event);

            if (playerInfo == null) {
                // Error messages are handled when getting the player info
                return;
            }

            String prettyPlayerName = playerInfo.getPlayerNameWithCapitalization();

            if (playerInfo.getCollectionLog().getLastChanged() == null) {
                overwriteMessage(
                    new ChatMessageBuilder()
                        .append(ChatColorType.NORMAL)
                        .append("No TempleOSRS collection log found for ")
                        .append(ChatColorType.HIGHLIGHT)
                        .append(prettyPlayerName)
                        .append(".")
                        .build(),
                    event.getMessageNode()
                );

                return;
            }

            String lastChanged = playerInfo.getCollectionLog().getLastChanged();

            final boolean isDataStale = !collectionLogService.isDataFresh(normalizedPlayerName, lastChanged);
            final boolean hasLocalData = CollectionDatabase.hasPlayerData(normalizedPlayerName);
            final boolean shouldUpdate = !hasLocalData || isDataStale;

            if (shouldUpdate)
            {
                log.debug("📭 No local data for '{}', fetching from API...", normalizedPlayerName);
                String json = collectionLogRequestManager.getPlayerCollectionLog(normalizedPlayerName);

                if (json == null) {
                    log.warn("❌ No data fetched for user: {}", normalizedPlayerName);

                    overwriteMessage(
                        new ChatMessageBuilder()
                            .append(ChatColorType.NORMAL)
                            .append("Failed to fetch log for ")
                            .append(ChatColorType.HIGHLIGHT)
                            .append(prettyPlayerName)
                            .append(ChatColorType.NORMAL)
                            .append(".")
                            .build(),
                        event.getMessageNode()
                    );

                    return;
                }

                if (!isLocalPlayer) {
                    CollectionDatabase.pruneOldPlayers(localName, templeOSRSPlugin.getConfig().maxCachedPlayers());
                }

                collectionParser.parseAndStore(PlayerNameUtils.normalizePlayerName(playerName), json);
            }
            else
            {
                log.debug("✔️ Found cached data for '{}'", normalizedPlayerName);
            }

            // Fetch the requested category
            Set<ObtainedCollectionItem> items = CollectionDatabase.getItemsByCategory(
                    normalizedPlayerName,
					new LinkedHashSet<>(category.getItems())
            );

            loadItemIcons(
				items
					.stream()
					.map(ObtainedCollectionItem::getId)
					.collect(Collectors.toList())
			);

            ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder();
            String categoryName = category.getTitle();


			// If sender's name is same as the player being queried, omit the player's name
			if (!event.getName().equalsIgnoreCase(playerName))
			{
				chatMessageBuilder
					.append(ChatColorType.HIGHLIGHT)
					.append(prettyPlayerName + "'s ")
					.append(categoryName)
					.append(ChatColorType.NORMAL);
			}
			else
			{
				chatMessageBuilder.append(categoryName);
			}

			chatMessageBuilder
				.append(getLogProgress(items.size(), category.getItems().size()))
				.append(": ");

            if (items.isEmpty()) {
                chatMessageBuilder.append("No obtained collection log items.");
            } else {
                int i = 0;

                for (ObtainedCollectionItem item : items)
                {
                    Integer iconIndex = itemIconIndexes.get(item.getId());

                    if (iconIndex != null) {
                        chatMessageBuilder.img(iconIndex);
                    }

                    chatMessageBuilder
                            .append("x")
                            .append(String.valueOf(item.getCount()));

                    if (i++ < items.size() - 1) {
                        chatMessageBuilder.append(", ");
                    }
                }
            }

            overwriteMessage(chatMessageBuilder.build(), event.getMessageNode());
        });
    }

    private PlayerInfoResponse.Data getPlayerInfo(String playerName, ChatMessage chatMessage)
    {
        try {
            return collectionLogRequestManager.getPlayerInfo(playerName);
        } catch (NullPointerException e) {
            overwriteMessage(
                new ChatMessageBuilder()
                    .append(ChatColorType.NORMAL)
                    .append("Unable to find ")
                    .append(ChatColorType.HIGHLIGHT)
                    .append(playerName)
                    .append(ChatColorType.NORMAL)
                    .append(" on TempleOSRS.")
                    .build(),
                chatMessage.getMessageNode()
            );
        } catch (IOException e) {
            overwriteMessage(
                new ChatMessageBuilder()
                    .append(ChatColorType.NORMAL)
                    .append("Failed to fetch from TempleOSRS.")
                    .build(),
                chatMessage.getMessageNode()
            );
        }

        return null;
    }

    private String getCategoryKeyFromMessageInput(String bossInput)
    {
        try {
            final CollectionLogCategorySlug categorySlug = Objects.requireNonNullElseGet(
                    CollectionLogCategoryUtils.CATEGORY_ALIASES.get(bossInput),
                    () -> CollectionLogCategorySlug.valueOf(bossInput)
            );

            return categorySlug.toString();
        } catch (IllegalArgumentException e) {
            return bossInput;
        }
    }

    private CollectionLogCategory getCategoryFromMessageInput(String bossInput)
    {
        String categoryKey = getCategoryKeyFromMessageInput(bossInput);
        CollectionLogCategory customCategory = CollectionLogCategoryUtils.CUSTOM_CATEGORIES.get(bossInput);

        if (customCategory != null) {
            return customCategory;
        }

        try {
            int structId = CollectionLogManager.getCollectionLogCategoryStructIdMap().get(categoryKey);

            StructComposition categoryStruct = client.getStructComposition(structId);
            String categoryTitle = categoryStruct.getStringValue(689);
            Set<Integer> categoryItems = CollectionLogManager.getCollectionLogCategoryItemMap().get(categoryStruct.getId());

			return new CollectionLogCategory(categoryTitle, categoryItems);
		}
		catch (NullPointerException e)
		{
			return null;
		}
	}

	private String getLogProgress(int acquiredItemsCount, int totalItemsCount)
	{
		if (acquiredItemsCount == 0)
		{
			return "";
		}

		return " (" + acquiredItemsCount + "/" + totalItemsCount + ")";
	}
}

package com.templeosrs.util.collections.chatcommands.commands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.chatcommands.ChatCommand;
import net.runelite.api.events.ChatMessage;

public class ListAllMinigamesCategoriesChatCommand extends ChatCommand {
    public ListAllMinigamesCategoriesChatCommand()
    {
        super("!col list minigames", "Lists all available minigames categories", true);
    }

    @Override
    public void command(ChatMessage event)
    {
        listAvailableCollectionLogCategories(CollectionLogCategoryGroup.minigames);
    }
}

package com.templeosrs.util.collections.chatcommands;

import com.templeosrs.util.collections.CollectionLogCategoryGroup;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.utils.CollectionLogCategoryUtils;
import com.templeosrs.util.collections.utils.PlayerNameUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.util.Set;

@Slf4j
public abstract class ChatCommand {
    public ChatCommand(String trigger, String description, boolean onlyShowForLocalPlayer)
    {
        this.trigger = trigger;
        this.description = description;
        this.onlyShowForLocalPlayer = onlyShowForLocalPlayer;
    }

    @Inject
    protected Client client;

    @Inject
    protected ClientThread clientThread;

    @Inject
    protected ChatMessageManager chatMessageManager;

    @Inject
    protected ItemManager itemManager;

    /**
     * The chat message that triggers the command, e.g. "!col help"
     */
    public String trigger;

    /**
     * The description given to the command when listed by the "!col help" command
     */
    public String description;

    /**
     * If true, hide the message from all other players except the local player
     */
    private final boolean onlyShowForLocalPlayer;

	/**
	 * Maintain a map of item IDs to their respective index in the icon list
	 */
	protected final Map<Integer, Integer> itemIconIndexes = new HashMap<>();

	/**
	 * Maintain a list of previously seen item icons to avoid loading them twice
	 */
	protected final Set<Integer> loadedItemIds = new HashSet<>();

    /**
     * Checks whether the message sender is the currently logged in player
     * @param event the ChatMessage event
     * @return true if the message sender if the currently logged in player
     */
    public boolean isOtherPlayer(ChatMessage event)
    {
        String localName = PlayerNameUtils.normalizePlayerName(client.getLocalPlayer().getName());
        String senderName = PlayerNameUtils.normalizePlayerName(event.getName());

        return !senderName.equalsIgnoreCase(localName);
    }

    public String buildAvailableCategoriesMessage(String category)
    {
        return new ChatMessageBuilder()
            .append(ChatColorType.NORMAL)
            .append("Available ")
            .append(ChatColorType.HIGHLIGHT)
            .append(category)
            .append(ChatColorType.NORMAL)
            .append(" categories:")
            .build();
    }

    public void overwriteMessage(String newMessage, MessageNode messageNode)
    {
        messageNode.setRuneLiteFormatMessage(newMessage);
        client.refreshChat();
    }

    /**
     * Outputs a list of all available collection log categories.
     * As this is derived from the in-game cache,
     * it will always be up-to-date with the latest changes (unless a new tab is added).
     * @param categoryGroup The category group (i.e. tab) for which to list items
     */
    public void listAvailableCollectionLogCategories(CollectionLogCategoryGroup categoryGroup)
    {
        clientThread.invoke(() -> {
            chatMessageManager.queue(
                QueuedMessage.builder()
                    .type(ChatMessageType.CONSOLE)
                    .runeLiteFormattedMessage(buildAvailableCategoriesMessage(categoryGroup.toString()))
                    .build()
            );

            Set<String> categorySlugs = CollectionLogManager
                    .getCollectionLogCategoryTabSlugs()
                    .get(categoryGroup.getStructId());

			List<Integer> iconItemIds = categorySlugs.stream().map(slug -> {
				int structId = CollectionLogManager.getCollectionLogCategoryStructIdMap().get(slug);
				Set<Integer> categoryItems = CollectionLogManager.getCollectionLogCategoryItemMap().get(structId);

				return new ArrayList<>(categoryItems).get(0);
			}).collect(Collectors.toList());

			loadItemIcons(iconItemIds);

			int i = 0;

            for (String categorySlug : categorySlugs) {
                int structId = CollectionLogManager.getCollectionLogCategoryStructIdMap().get(categorySlug);
                String categoryTitle = client.getStructComposition(structId).getStringValue(689);
				int iconIndex = itemIconIndexes.get(iconItemIds.get(i++));

				ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
                        .append(ChatColorType.NORMAL)
						.img(iconIndex)
                        .append(categoryTitle)
                        .append(": ");

                Set<String> categoryAliases = CollectionLogCategoryUtils.INVERTED_ALIASES.get(categorySlug);

                chatMessageBuilder
                        .append(ChatColorType.HIGHLIGHT)
                        .append(
                            categoryAliases == null
                                ? categorySlug
                                : String.join(", ", categoryAliases)
                        );

                chatMessageManager.queue(
                    QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(chatMessageBuilder.build())
                        .build()
                );
            }

            client.refreshChat();
        });
    }

	/**
	 * Loads the in-game icons for a given item list, ready to be used in the chat message.
	 * @param iconItemIds The item list for which to load item icons.
	 */
	protected void loadItemIcons(List<Integer> iconItemIds)
	{
		// Starting with an empty list, we find which icons haven't previously been seen
		List<Integer> newItems = new ArrayList<>();

		for (int itemId : iconItemIds) {
			if (!loadedItemIds.contains(itemId)) {
				newItems.add(itemId);
				loadedItemIds.add(itemId);
			}
		}

		if (newItems.isEmpty()) {
			return;
		}

		final IndexedSprite[] modIcons = client.getModIcons();

		assert modIcons != null;

		final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + iconItemIds.size());
		final int iconIndex = modIcons.length;

		client.setModIcons(newModIcons);

		int i = 0;

		for (int itemId : iconItemIds) {
			final AsyncBufferedImage img = itemManager.getImage(itemId);
			final int idx = iconIndex + i++;

			itemIconIndexes.put(itemId, idx);

			img.onLoaded(() ->
			{
				final BufferedImage image = ImageUtil.resizeImage(img, 18, 16);
				final IndexedSprite sprite = ImageUtil.getImageIndexedSprite(image, client);
				// modicons array might be replaced in between when we assign it and the callback,
				// so fetch modicons again
				client.getModIcons()[idx] = sprite;
			});
		}
	}

    /**
     * Executes the chat command handler.
     * If it has been configured to only show for the current player, it will not be triggered for anyone else.
     * @param event The chat message event
     */
    public void execute(ChatMessage event)
    {
        if (onlyShowForLocalPlayer && isOtherPlayer(event)) {
            return;
        }

        command(event);
    }

    public void command(ChatMessage event) {}

    public void shutDown() {
		itemIconIndexes.clear();
		loadedItemIds.clear();
	}
}

package com.templeosrs.util.collections.services;

import com.templeosrs.util.collections.CollectionLogRequestManager;
import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import com.templeosrs.util.collections.database.CollectionDatabase;
import com.templeosrs.util.collections.parser.CollectionParser;
import com.templeosrs.util.collections.utils.PlayerNameUtils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import org.jetbrains.annotations.NotNull;

import javax.inject.Inject;
import java.sql.Timestamp;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
public class CollectionLogService {
    @Inject
    private CollectionLogRequestManager collectionLogRequestManager;

    @Inject
    private ScheduledExecutorService scheduledExecutorService;

    @Inject
    private Client client;

    @Inject
    private CollectionParser collectionParser;

    /**
     * Compares the timestamp of the latest collection log to the saved data.
     * @param username The username to check
     * @return True if the saved data is the latest available.
     */
    public boolean isDataFresh(@NotNull String username, @NotNull String lastChanged)
    {
        Timestamp dbTimestamp = CollectionDatabase.getLatestTimestamp(username);
        Timestamp apiTimestamp = Timestamp.valueOf(lastChanged);

        log.debug("🕒 [Compare] {} | DB: {} | API: {}", username, dbTimestamp, apiTimestamp);

        return dbTimestamp != null && !dbTimestamp.before(apiTimestamp);
    }

    /**
     * Synchronises the player's cached collection log.
     */
    public void syncCollectionLog() {
        scheduledExecutorService.execute(() -> {
            log.debug("🔄 Starting syncCollectionLog()...");

            if (client.getLocalPlayer() == null) {
                log.warn("⚠️ Local player is null — not logged in yet.");
                return;
            }

            String username = Objects.requireNonNull(client.getLocalPlayer().getName()).toLowerCase();

            log.debug("👤 Detected username: {}", username);

            String json = collectionLogRequestManager.getPlayerCollectionLog(username);

            log.debug("📥 Fetched JSON: {} characters", json != null ? json.length() : 0);

            if (json == null || json.isEmpty()) {
                log.error("❌ Empty or null response from Temple API");
                return;
            }

            log.debug("🧩 Parsing and storing JSON...");

            collectionParser.parseAndStore(PlayerNameUtils.normalizePlayerName(username), json);

            log.debug("✅ Parsing complete.");
        });
    }
}

package com.templeosrs.util;

import java.util.HashMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum PlayerRanges
{
	Day("Day", "1day"),
	Week("Week", "1week"),
	Month("Month", "31day"),
	Six_Months("Six Months", "186days"),
	Year("Year", "365days"),
	All_Time("All Time", "alltime");

	private static final Map<String, PlayerRanges> lookup = new HashMap<>();

	static
	{
		for (PlayerRanges r : PlayerRanges.values())
		{
			lookup.put(r.getName(), r);
		}
	}

	private final String name;
	private final String range;

	public static PlayerRanges get(String name)
	{
		return lookup.get(name);
	}

	public String getName()
	{
		return this.name;
	}

}

package com.templeosrs.util.clan;

import com.google.gson.Gson;
import java.util.Objects;

public class TempleClan
{
	public boolean error = false;

	public TempleClanOverviewResponse clanOverview;

	public TempleClanAchievementResponse clanAchievements;

	public TempleClanCurrentTopResponse clanCurrentTopEhp;

	public TempleClanCurrentTopResponse clanCurrentTopEhb;

	public TempleClan(String clanOverviewJSON, String clanAchievementsJSON, String clanCurrentTopEhpJSON, String clanCurrentTopEhbJSON, Gson gson)
	{
		clanOverview = gson.fromJson(clanOverviewJSON, TempleClanOverviewResponse.class);

		clanAchievements = gson.fromJson(clanAchievementsJSON, TempleClanAchievementResponse.class);

		clanCurrentTopEhp = gson.fromJson(clanCurrentTopEhpJSON, TempleClanCurrentTopResponse.class);

		clanCurrentTopEhb = gson.fromJson(clanCurrentTopEhbJSON, TempleClanCurrentTopResponse.class);

		if (Objects.nonNull(clanOverview.error))
		{
			error = true;
		}
	}
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanOverviewInfo
{
	@SerializedName("id")
	public Integer id;

	@SerializedName("name")
	public String name;

	@SerializedName("youtube_link")
	public String youtubeLink;

	@SerializedName("twitter_link")
	public String twitterLink;

	@SerializedName("twitch_link")
	public String twitchLink;

	@SerializedName("discord_link")
	public String discordLink;

	@SerializedName("forum_link")
	public String forumLink;

	@SerializedName("total_xp")
	public Long totalXp;

	@SerializedName("average_xp")
	public Long averageXp;

	@SerializedName("total_ehp")
	public Double totalEhp;

	@SerializedName("average_ehp")
	public Double averageEhp;

	@SerializedName("total_ehb")
	public Double totalEhb;

	@SerializedName("average_ehb")
	public Double averageEhb;

	@SerializedName("clan_type")
	public String clanType;

	@SerializedName("member_count")
	public Integer memberCount;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanCurrentTopPlayer
{
	@SerializedName("player")
	public String player;

	@SerializedName("xp")
	public Double xp;

	@SerializedName("rank")
	public Integer rank;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;
import java.util.Map;

public class TempleClanCurrentTopResponse
{
	@SerializedName(value = "Day", alternate = {"Week", "Month"})
	public Map<String, TempleClanCurrentTopPlayer> list;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanOverviewData
{
	@SerializedName("info")
	public TempleClanOverviewInfo info;

	@SerializedName("members")
	public String[] members;

	@SerializedName("leaders")
	public String[] leaders;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;
import java.util.List;

public class TempleClanAchievementResponse
{
	@SerializedName("data")
	public List<TempleClanAchievement> data = null;

	@SerializedName("error")
	public TempleError error;
}

package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;

public class TempleClanAchievement
{
	@SerializedName("Username")
	public String username;

	@SerializedName("Date")
	public String date;

	@SerializedName("Skill")
	public String skill;

	@SerializedName("Type")
	public String type;

	@SerializedName("Xp")
	public Long xp;
}


package com.templeosrs.util.clan;

import com.google.gson.annotations.SerializedName;
import com.templeosrs.util.TempleError;

public class TempleClanOverviewResponse
{
	@SerializedName("data")
	public TempleClanOverviewData data;

	@SerializedName("error")
	public TempleError error;
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs;

import com.google.inject.Provides;
import com.templeosrs.ui.TempleOSRSPanel;
import com.templeosrs.ui.clans.TempleClans;
import com.templeosrs.ui.competitions.TempleCompetitions;
import com.templeosrs.ui.ranks.TempleRanks;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.collections.CollectionLogManager;
import com.templeosrs.util.collections.SyncButtonManager;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.xpupdater.XpUpdaterConfig;
import net.runelite.client.plugins.xpupdater.XpUpdaterPlugin;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Provider;
import javax.swing.*;

@PluginDependency(XpUpdaterPlugin.class)
@PluginDescriptor(name = "TempleOSRS", description = "A RuneLite plugin utilizing the TempleOSRS API.", tags = {"Temple", "ehp", "ehb"})
public class TempleOSRSPlugin extends Plugin {
    private static final String TEMPLE = "Temple";

    private static final int XP_THRESHOLD = 10000;

    private static NavigationButton navButton;

    public TempleRanks ranks;

    public TempleClans clans;

    public TempleCompetitions competitions;

    public TempleOSRSPanel panel;

    private long lastAccount;

    private boolean fetchXp;

    private long lastXp;

    @Inject
    private Client client;

    @Inject
    private Provider<MenuManager> menuManager;

    @Inject
    private PluginManager pluginManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Getter
    @Inject
    private TempleOSRSConfig config;

    @Inject
    private XpUpdaterConfig xpUpdaterConfig;

    @Inject
    private XpUpdaterPlugin xpUpdaterPlugin;

    @Inject
    private TempleService service;

    @Inject
    private SyncButtonManager syncButtonManager;

    @Inject
    private CollectionLogManager clogManager;

    @Override
    protected void startUp() {
        fetchXp = true;

        lastAccount = -1L;

        ranks = injector.getInstance(TempleRanks.class);

        clans = injector.getInstance(TempleClans.class);

        competitions = injector.getInstance(TempleCompetitions.class);

        panel = new TempleOSRSPanel(ranks, clans, competitions);
        navButton = NavigationButton.builder().tooltip("TempleOSRS").icon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "skills/skill_icon_ehp.png")).priority(5).panel(panel).build();

        if (config.showSidebar()) {
            clientToolbar.addNavigation(navButton);
        }

        if (config.playerLookup() && client != null) {
            menuManager.get().addPlayerMenuItem(TEMPLE);
        }

        // Only display clog update button if enabled
        if (config.clogSyncButton()) {
            syncButtonManager.startUp();
        }

        clogManager.startUp();
    }

    @Override
    protected void shutDown() {
        clientToolbar.removeNavigation(navButton);

        if (client != null) {
            menuManager.get().removePlayerMenuItem(TEMPLE);
        }
        ranks.shutdown();
        clogManager.shutDown();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (event.getGroup().equals(TempleOSRSConfig.TEMPLE_OSRS_CONFIG_GROUP)) {
            if (client != null) {
                menuManager.get().removePlayerMenuItem(TEMPLE);
                if (config.playerLookup()) {
                    menuManager.get().addPlayerMenuItem(TEMPLE);
                }

                // Show/Hide plugin icon in sidebar
                if (config.showSidebar()) {
                    clientToolbar.addNavigation(navButton);
                } else {
                    clientToolbar.removeNavigation(navButton);
                }

                if (clans.clanAchievements != null) {
                    clans.remove(clans.clanAchievements);
                    if (config.displayClanAchievements()) {
                        clans.add(clans.clanAchievements);
                    }
                }

                if (clans.clanCurrentTop != null) {
                    clans.remove(clans.clanCurrentTop);
                    if (config.displayClanCurrentTop()) {
                        clans.add(clans.clanCurrentTop);
                    }
                }

                if (clans.clanMembers != null) {
                    clans.remove(clans.clanMembers);
                    if (config.displayClanMembers()) {
                        clans.add(clans.clanMembers);
                    }
                }

                // Collection Log Related
                if (config.clogSyncButton()) {
                    syncButtonManager.startUp();
                } else {
                    syncButtonManager.shutDown();
                }

                clans.repaint();
                clans.revalidate();
            }

            competitions.rebuildWatchlist();
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        if ((event.getType() != MenuAction.CC_OP.getId() && event.getType() != MenuAction.CC_OP_LOW_PRIORITY.getId()) || !config.playerLookup()) {
            return;
        }

        String username = Text.toJagexName(Text.removeTags(event.getTarget()).toLowerCase().trim());

        final String option = event.getOption();
        final int componentId = event.getActionParam1();
        final int groupId = WidgetUtil.componentToInterface(componentId);

        if (groupId == InterfaceID.FRIEND_LIST && option.equals("Delete")
                || groupId == InterfaceID.FRIENDS_CHAT && (option.equals("Add ignore") || option.equals("Remove friend"))
                || groupId == InterfaceID.CHATBOX && (option.equals("Add ignore") || option.equals("Message"))
                || groupId == InterfaceID.IGNORE_LIST && option.equals("Delete")
                || (componentId == ComponentID.CLAN_MEMBERS || componentId == ComponentID.CLAN_GUEST_MEMBERS) && (option.equals("Add ignore") || option.equals("Remove friend"))
                || groupId == InterfaceID.PRIVATE_CHAT && (option.equals("Add ignore") || option.equals("Message"))
                || groupId == InterfaceID.GROUP_IRON && (option.equals("Add friend") || option.equals("Remove friend") || option.equals("Remove ignore"))
        ) {
            client.createMenuEntry(-2).setOption(TEMPLE).setTarget(event.getTarget()).setType(MenuAction.RUNELITE).setIdentifier(event.getIdentifier()).onClick(e -> fetchUser(username));
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals(TEMPLE)) {
            Player player = event.getMenuEntry().getPlayer();
            if (player == null) {
                return;
            }

            String username = player.getName();
            fetchUser(username);
        }
    }

    @Subscribe
    public void onGameTick(GameTick gameTick) {
        if (fetchXp) {
            lastXp = client.getOverallExperience();
            fetchXp = false;
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState state = gameStateChanged.getGameState();
        if (state == GameState.LOGGED_IN) {
            if (lastAccount != client.getAccountHash()) {
                lastAccount = client.getAccountHash();
                fetchXp = true;
            }
        } else if (state == GameState.LOGIN_SCREEN) {
            Player local = client.getLocalPlayer();
            if (local == null) {
                return;
            }

            long totalXp = client.getOverallExperience();
            String username = local.getName();

			/* Don't submit update if xp-threshold has not been reached or username is null
			   or config option for auto-update is disabled */
            if (Math.abs(totalXp - lastXp) > XP_THRESHOLD && username != null && config.autoUpdate()) {
                updateUser(lastAccount, username.replace(" ", "+"));
                lastXp = totalXp;
            }
        }
    }

    @Provides
    TempleOSRSConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TempleOSRSConfig.class);
    }

    public void fetchUser(String username) {
        SwingUtilities.invokeLater(() -> {
            clientToolbar.openPanel(navButton);

            /* select ranks-tab */
            panel.tabGroup.select(panel.ranksTab);
            ranks.fetchUser(username);
        });
    }

    public void updateUser(long accountHash, String username) {
        /* if XpUpdaterPlugin is disabled or XpUpdaterPlugin's config option for templeosrs is disabled */
        if (!pluginManager.isPluginEnabled(xpUpdaterPlugin) || !xpUpdaterConfig.templeosrs()) {
            new Thread(() -> {
                try {
                    service.addDatapointAsync(username, accountHash);
                } catch (Exception ignored) {

                }
            }).start();
        }
    }
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * Copyright (c) 2019, Bram91 <https://github.com/bram91>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.ui;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.ui.clans.TempleClans;
import com.templeosrs.ui.competitions.TempleCompetitions;
import com.templeosrs.ui.ranks.TempleRanks;
import java.awt.BorderLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.time.Instant;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.border.EmptyBorder;
import static net.runelite.client.RuneLite.SCREENSHOT_DIR;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

public class TempleOSRSPanel extends PluginPanel
{
	public static final String DEFAULT = "--";

	private static final String SCREENSHOTS = SCREENSHOT_DIR + File.separator + "Temple-Snapshots" + File.separator;

	public final TempleRanks ranks;

	public final TempleClans groups;

	public final TempleCompetitions competitions;

	public final MaterialTabGroup tabGroup;

	public final MaterialTab ranksTab;

	public final MaterialTab groupsTab;

	public final MaterialTab competitionsTab;

	@Inject
	public TempleOSRSPanel(TempleRanks ranks, TempleClans groups, TempleCompetitions competitions)
	{
		this.ranks = ranks;
		this.groups = groups;
		this.competitions = competitions;

		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		getScrollPane().setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* material-tab-group for each API Endpoint (Players, Groups, Competitions)*/
		JPanel display = new JPanel();
		tabGroup = new MaterialTabGroup(display);

		ranksTab = new MaterialTab("Ranks", tabGroup, ranks);
		groupsTab = new MaterialTab("Clans", tabGroup, groups);
		competitionsTab = new MaterialTab("Competitions", tabGroup, competitions);

		tabGroup.addTab(ranksTab);
		tabGroup.addTab(groupsTab);
		tabGroup.addTab(competitionsTab);

		tabGroup.select(ranksTab);

		layoutPanel.add(tabGroup);
		layoutPanel.add(display);
		layoutPanel.add(buildScreenshots());

		add(layoutPanel);
	}

	/* build screenshots button */
	private JPanel buildScreenshots()
	{
		JPanel saveLayout = new JPanel(new BorderLayout());
		saveLayout.setBorder(new EmptyBorder(5, 5, 5, 5));
		saveLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* create menu and menu-options */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem takeScreenshot = new JMenuItem();
		takeScreenshot.setText("Take Screenshot of current view...");
		takeScreenshot.addActionListener(e -> screenshot(this));
		menu.add(takeScreenshot);

		JMenuItem openFolder = new JMenuItem();
		openFolder.setText("Open screenshot folder...");
		openFolder.addActionListener(e -> {
			if (SCREENSHOT_DIR.exists() || SCREENSHOT_DIR.mkdirs())
			{
				LinkBrowser.open(SCREENSHOT_DIR.getAbsolutePath());
			}
		});
		menu.add(openFolder);

		/* build button and add menu options to take-snapshot/open-snapshots-folder */
		JButton screenshotButton = new JButton();
		screenshotButton.setBorder(new EmptyBorder(5, 5, 5, 5));
		screenshotButton.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "save.png")));
		screenshotButton.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		screenshotButton.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(screenshotButton, e.getX(), e.getY());
			}
		});
		saveLayout.add(screenshotButton, BorderLayout.WEST);

		return saveLayout;
	}

	/* take a perfectly cropped image of the plugin-layout */
	private void screenshot(JPanel panel)
	{
		/* use epoch-time as unique file-name */
		String timestamp = String.valueOf(Instant.now().getEpochSecond());

		/* create directory if not exists,
		 * continue if success */
		File directory = new File(SCREENSHOTS);
		if (directory.exists() || directory.mkdirs())
		{
			/* create image */
			BufferedImage img = new BufferedImage(panel.getSize().width, panel.getSize().height, BufferedImage.TYPE_INT_RGB);
			panel.paint(img.createGraphics());
			File imageFile = new File(SCREENSHOTS + timestamp + ".png");

			/* attempt to save image-file to directory */
			try
			{
				if (imageFile.createNewFile())
				{
					ImageIO.write(img, "png", imageFile);
				}
			}
			catch (Exception ignored)
			{

			}
		}
	}
}

package com.templeosrs.ui.competitions;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.TempleHiscoreSkill;
import com.templeosrs.util.comp.TempleCompetitionInfo;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.FlowLayout;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class TempleCompetitionOverview extends JPanel
{

	TempleCompetitionOverview(TempleCompetitionInfo info, int memberCount)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
		layoutPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		layoutPanel.setOpaque(false);

		/* add competition name to layout */
		String name = info.name;
		JLabel compName = new JLabel(name);
		compName.setFont(FontManager.getRunescapeBoldFont());
		compName.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		compName.setAlignmentX(Component.CENTER_ALIGNMENT);
		compName.setToolTipText(name);
		layoutPanel.add(compName);

		/* add participants-count to layout */
		JPanel fieldLayout = new JPanel();
		fieldLayout.setLayout(new FlowLayout());
		fieldLayout.setOpaque(false);

		JLabel field = new JLabel("Participants:");
		field.setFont(FontManager.getRunescapeSmallFont());
		field.setAlignmentX(Component.CENTER_ALIGNMENT);
		fieldLayout.add(field);

		JLabel count = new JLabel(String.valueOf(memberCount));
		count.setFont(FontManager.getRunescapeSmallFont());
		fieldLayout.add(count);

		JPanel statusLayout = new JPanel();
		statusLayout.setLayout(new FlowLayout());
		statusLayout.setOpaque(false);

		/* add status to layout */
		JLabel statusLabel = new JLabel("Status:");
		statusLabel.setFont(FontManager.getRunescapeSmallFont());
		statusLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		statusLayout.add(statusLabel);

		String statusText = info.statusText;
		JLabel status = new JLabel(statusText);
		status.setFont(FontManager.getRunescapeSmallFont());

		/* add set status-text color */
		if (statusText.equals("Finished"))
		{
			status.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		}
		else if (statusText.equals("In progress"))
		{
			status.setForeground(ColorScheme.PROGRESS_INPROGRESS_COLOR);
		}
		else
		{
			status.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}

		statusLayout.add(status);

		layoutPanel.add(statusLayout);

		layoutPanel.add(fieldLayout);

		/* get HiscoreSkill by index */
		TempleHiscoreSkill skill = TempleHiscoreSkill.values()[info.skillIndex];

		String skillName = skill.getName();
		String formattedName = skillName.replaceAll("[^A-Za-z0-9]", "").toLowerCase();

		/* determine skill's icon-path */
		String iconPath;
		if (skill.getType().equals(HiscoreSkillType.SKILL))
		{
			iconPath = "skills/skill_icon_" + formattedName + ".png";
		}
		else
		{
			iconPath = "bosses/game_icon_" + formattedName + ".png";
		}

		JLabel iconLabel = new JLabel();

		/* add icon to layout */
		ImageIcon icon;
		try
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, iconPath));
		}
		catch (Exception e)
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "bosses/game_icon_null.png"));
		}
		iconLabel.setIcon(icon);
		iconLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		iconLabel.setToolTipText(info.skill);

		layoutPanel.add(iconLabel);

		add(layoutPanel);
	}
}

package com.templeosrs.ui.competitions;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.comp.TempleCompetitionParticipant;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.QuantityFormatter;

public class TempleCompetitionRow extends JPanel
{
	TempleCompetitionRow(TempleOSRSPlugin plugin, TempleCompetitionParticipant player, int i, Color color)
	{
		setLayout(new BorderLayout());

		JPanel row = new JPanel();
		row.setLayout(new GridLayout());
		row.setBackground(color);
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		/* add start-point and current-end-point as tooltip-text */
		row.setToolTipText("<html>Start: <span style='color:#32a0fa'>" + QuantityFormatter.quantityToStackSize(player.startXp.longValue()) + "</span><br>End: <span style='color:#32a0fa'>" + QuantityFormatter.quantityToStackSize(player.endXp.longValue()) + "</span></html>");

		/* add player and ranking */
		JLabel name = new JLabel(i + ". " + player.username);
		name.setBorder(new EmptyBorder(0, 5, 0, 0));
		name.setFont(FontManager.getRunescapeSmallFont());
		row.add(name);

		/* add formatted total */
		JLabel xp = new JLabel(QuantityFormatter.quantityToStackSize(player.xpGained.longValue()));
		xp.setBorder(new EmptyBorder(0, 5, 0, 0));
		xp.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		xp.setFont(FontManager.getRunescapeSmallFont());
		row.add(xp);

		/* add on-click menu to row */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + player.username + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(player.username));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		row.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});

		add(row);
	}
}

package com.templeosrs.ui.competitions;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.comp.TempleCompetition;
import com.templeosrs.util.comp.TempleCompetitionInfo;
import com.templeosrs.util.comp.TempleCompetitionParticipant;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import okhttp3.HttpUrl;

public class TempleCompetitions extends PluginPanel
{
	private static final Pattern isNumeric = Pattern.compile("-?\\d+(\\.\\d+)?");

	public final IconTextField lookup;

	private final Client client;

	private final TempleOSRSPlugin plugin;

	private final TempleOSRSConfig config;

	private final PluginErrorPanel errorPanel = new PluginErrorPanel();

	private final JPanel fetchLayout;

	private final TempleService service;

	private TempleCompetitionWatchlist watchlist;

	@Inject
	public TempleCompetitions(TempleOSRSConfig config, TempleOSRSPlugin plugin, Client client, TempleService templeService)
	{
		this.plugin = plugin;
		this.client = client;
		this.config = config;
		this.service = templeService;

		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		fetchLayout = new JPanel();
		fetchLayout.setLayout(new BoxLayout(fetchLayout, BoxLayout.Y_AXIS));
		fetchLayout.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		fetchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* build and add search-text-field */
		JPanel searchLayout = new JPanel();
		searchLayout.setLayout(new BoxLayout(searchLayout, BoxLayout.X_AXIS));
		searchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lookup = buildTextField();
		searchLayout.add(lookup);

		JLabel actions = new JLabel();
		actions.setBorder(new EmptyBorder(0, 5, 0, 0));
		actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
		actions.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				JPopupMenu menu = new JPopupMenu();
				JMenuItem fetchPlayerMenuItem = new JMenuItem();
				fetchPlayerMenuItem.setText("Search");
				fetchPlayerMenuItem.addActionListener(ev -> fetchCompetition());
				menu.add(fetchPlayerMenuItem);

				JMenuItem openPlayerPageMenuItem = new JMenuItem();
				openPlayerPageMenuItem.setText("Open TempleOSRS");
				openPlayerPageMenuItem.addActionListener(ev -> open());
				menu.add(openPlayerPageMenuItem);

				JMenuItem addItemMenuItem = new JMenuItem();
				addItemMenuItem.setText("Add to Watchlist");
				addItemMenuItem.addActionListener(ev -> watchlist.addWatchlistItem(lookup.getText()));
				menu.add(addItemMenuItem);

				JMenuItem removeItemMenuItem = new JMenuItem();
				removeItemMenuItem.setText("Remove from Watchlist");
				removeItemMenuItem.addActionListener(ev -> watchlist.removeWatchlistItem(lookup.getText()));
				menu.add(removeItemMenuItem);

				actions.add(menu);
				menu.show(actions, e.getX(), e.getY());
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears_light.png")));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
			}
		});

		searchLayout.add(actions);
		fetchLayout.add(searchLayout);

		/* build and add duration selection */
		watchlist = new TempleCompetitionWatchlist(config, this);
		fetchLayout.add(watchlist);

		add(fetchLayout);

		/* add default, error-panel when competition has not been fetched yet */
		errorPanel.setContent("Competitions", "You have not fetched competition information yet.");
		add(errorPanel);

		/* load default competition on start-up */
		if (config.fetchDefaults())
		{
			if (config.getDefaultComp() != 0)
			{
				lookup.setText(Integer.toString(config.getDefaultComp()));
				fetchCompetition();
			}
		}
	}

	private IconTextField buildTextField()
	{
		IconTextField lookup = new IconTextField();

		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
		lookup.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		lookup.setBackground(ColorScheme.SCROLL_TRACK_COLOR);
		/* fetch competition on action */
		lookup.addActionListener(e -> fetchCompetition());
		lookup.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (config.getDefaultComp() != 0 && SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2)
				{
					lookup.setText(Integer.toString(config.getDefaultComp()));
					fetchCompetition();
				}
			}
		});

		/* reset on clear */
		lookup.addClearListener(() -> {
			completed();
			reset();
		});

		return lookup;
	}

	/* fetch competition from search-text-field */
	public void fetchCompetition()
	{
		final String id = lookup.getText();

		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		/* competition-id must be integer */
		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		loading();

		reset();

		/* create separate thread for completing competition-fetch/ panel rebuilds,
		 *  try to fetch competition,
		 *  when fetching completes, rebuild panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				service.fetchCompetitionAsync(id).whenCompleteAsync((result, err) -> response(id, result, err));
			}
			catch (Exception e)
			{
				error();
			}
		}).start();
	}

	private void response(String id, TempleCompetition result, Throwable e)
	{
		remove(errorPanel);

		if (!lookup.getText().equals(id))
		{
			completed();
			return;
		}

		/* result is null, exception thrown, or error response */
		if (Objects.isNull(result) || Objects.nonNull(e) || result.error)
		{
			error();
			return;
		}
		rebuild(result);
	}

	private void rebuild(TempleCompetition result)
	{
		if (client == null)
		{
			return;
		}

		TempleCompetitionInfo info = result.compOverview.data.info;
		List<TempleCompetitionParticipant> participants = result.compOverview.data.participants;

		/* Event-Dispatch-Thread necessary for adding/ removing new components */
		SwingUtilities.invokeLater(() -> {
			/* create and add rankings/ overview */
			TempleCompetitionRankings rankings = new TempleCompetitionRankings(plugin, participants);

			TempleCompetitionOverview compOverview = new TempleCompetitionOverview(info, rankings.i);

			add(compOverview);
			add(rankings);
		});

		completed();

		revalidate();
		repaint();
	}

	public void rebuildWatchlist()
	{
		watchlist = new TempleCompetitionWatchlist(config, this);

		/* watchlist is indexed at position one of fetchLayout */
		fetchLayout.remove(1);
		fetchLayout.add(watchlist);

		fetchLayout.revalidate();
		fetchLayout.repaint();
	}

	private void open()
	{
		String id = lookup.getText();
		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		/* if valid competition-id, open temple competition-page */
		loading();

		HttpUrl url = new HttpUrl.Builder()
			.scheme("https")
			.host("templeosrs.com")
			.addPathSegment("competitions")
			.addPathSegment("standings.php")
			.addQueryParameter("id", id).build();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url.toString()));

		completed();
	}

	/* reset completion tab to default */
	private void reset()
	{
		removeAll();
		add(fetchLayout);
		add(errorPanel);

		repaint();
		revalidate();
	}

	/* set fields for error status */
	private void error()
	{
		lookup.setIcon(IconTextField.Icon.ERROR);
		lookup.setEditable(true);
	}

	/* set fields for loading status */
	private void loading()
	{
		lookup.setIcon(IconTextField.Icon.LOADING);
		lookup.setEditable(false);
	}

	/* set fields for completed status */
	private void completed()
	{
		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
	}
}

package com.templeosrs.ui.competitions;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.comp.TempleCompetitionParticipant;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.List;
import java.util.Objects;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleCompetitionRankings extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	public int i = 0;

	TempleCompetitionRankings(TempleOSRSPlugin plugin, List<TempleCompetitionParticipant> participantList)
	{
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(0, -2, 0, -2));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel compRankings = new JPanel();
		compRankings.setLayout(new GridLayout(0, 1));

		/* create header-bar for competitions (Name, Total) */
		JPanel compHeader = new JPanel();
		compHeader.setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		compHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		compHeader.setPreferredSize(new Dimension(PANEL_WIDTH, 20));
		compHeader.setLayout(new GridLayout(0, 2));

		JLabel label = new JLabel("Name");
		label.setBorder(new EmptyBorder(0, 5, 0, 0));
		label.setFont(FontManager.getRunescapeSmallFont());
		compHeader.add(label);

		JLabel gain = new JLabel("Total");
		gain.setBorder(new EmptyBorder(0, 5, 0, 0));
		gain.setFont(FontManager.getRunescapeSmallFont());
		compHeader.add(gain);

		/* add header to rankings-panel */
		compRankings.add(compHeader);

		/* for each player in participant-list */
		for (TempleCompetitionParticipant player : participantList)
		{
			/* if participant has some skill-gain for competition */
			if (Objects.nonNull(player.xpGained) && player.xpGained > 0)
			{
				/* create and add new row for participant */
				TempleCompetitionRow row = new TempleCompetitionRow(plugin, player, i + 1, COLORS[i % 2]);
				compRankings.add(row);
				i++;
			}
		}

		/* add participant-list to layout */
		layoutPanel.add(compRankings, BorderLayout.SOUTH);

		/* create custom border */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), "Competition Rankings");
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if participant-count is too large -> add scroll-pane and set preferred dimensions */
		if (i > 15)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 425));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs.ui.competitions;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.LinkedHashSet;
import java.util.Set;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.Text;

public class TempleCompetitionWatchlist extends JPanel
{
	public static JComboBox<String> jComboBox;
	private final TempleOSRSConfig config;

	public TempleCompetitionWatchlist(TempleOSRSConfig config, TempleCompetitions panel)
	{
		this.config = config;

		String[] competitions = new String[Text.fromCSV(config.getCompetitionWatchlist()).size()];

		for (int i = 0; i < Text.fromCSV(config.getCompetitionWatchlist()).size(); i++)
		{
			competitions[i] = Text.fromCSV(config.getCompetitionWatchlist()).get(i);
		}

		setLayout(new BorderLayout());
		setOpaque(false);

		setMinimumSize(new Dimension(PANEL_WIDTH, 20));
		setBorder(new EmptyBorder(5, 0, 0, 0));

		jComboBox = new JComboBox<>(competitions);
		jComboBox.addActionListener(e -> {
			panel.lookup.setText((String) jComboBox.getSelectedItem());
			panel.fetchCompetition();
		});
		jComboBox.setSelectedItem(config.getDefaultComp());

		add(jComboBox);
	}

	void addWatchlistItem(String competitionId)
	{
		if (Strings.isNullOrEmpty(competitionId))
		{
			return;
		}

		Set<String> watchlist = new LinkedHashSet<>(Text.fromCSV(config.getCompetitionWatchlist()));
		if (!watchlist.contains(competitionId))
		{
			watchlist.add(competitionId);
			config.setCompetitionWatchlist(Text.toCSV(watchlist));
		}
	}

	void removeWatchlistItem(String competitionId)
	{
		if (Strings.isNullOrEmpty(competitionId))
		{
			return;
		}

		Set<String> watchlist = new LinkedHashSet<>(Text.fromCSV(config.getCompetitionWatchlist()));
		if (watchlist.contains(competitionId))
		{
			watchlist.remove(competitionId);
			config.setCompetitionWatchlist(Text.toCSV(watchlist));
		}
	}
}

package com.templeosrs.ui.ranks;

import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Comparator;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleActivitySortHeader extends JPanel
{
	private final TempleActivitySortFilter name;

	private final TempleActivitySortFilter total;

	private final TempleActivitySortFilter rank;

	private final TempleActivitySortFilter ehp;

	TempleActivitySortHeader(TempleActivity panel, HiscoreSkillType type)
	{
		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
		setPreferredSize(new Dimension(PANEL_WIDTH, 20));

		/* create sorting-filters with unique comparators (Name, Total, Rank, Ehp),
		 * reset all other filters on selection */
		name = new TempleActivitySortFilter("Name");
		name.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(total, rank, ehp);
				Comparator<TempleActivityTableRow> comparator = name.increasing ? Comparator.comparing((TempleActivityTableRow row) -> row.name) : Comparator.comparing((TempleActivityTableRow row) -> row.name).reversed();
				/* resort skills-panel on click */
				panel.sort(comparator);
			}
		});

		total = new TempleActivitySortFilter("Total");
		total.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(name, rank, ehp);
				Comparator<TempleActivityTableRow> comparator = total.increasing ? Comparator.comparingDouble((TempleActivityTableRow row) -> row.total) : Comparator.comparingDouble((TempleActivityTableRow row) -> row.total).reversed();
				panel.sort(comparator);
			}
		});

		rank = new TempleActivitySortFilter("Rank");
		rank.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(total, name, ehp);
				Comparator<TempleActivityTableRow> comparator = rank.increasing ? Comparator.comparingDouble((TempleActivityTableRow row) -> row.rank) : Comparator.comparingDouble((TempleActivityTableRow row) -> row.rank).reversed();
				panel.sort(comparator);
			}
		});

		ehp = new TempleActivitySortFilter(type.equals(HiscoreSkillType.SKILL) ? "EHP" : "EHB");
		ehp.addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				reset(total, name, rank);
				Comparator<TempleActivityTableRow> comparator = ehp.increasing ? Comparator.comparingDouble((TempleActivityTableRow row) -> row.ehp) : Comparator.comparingDouble((TempleActivityTableRow row) -> row.ehp).reversed();
				panel.sort(comparator);
			}
		});

		JPanel display = new JPanel();
		display.setLayout(new GridLayout(1, 4));

		/* add filters to sort-panel */
		display.add(name);
		display.add(total);
		display.add(rank);
		display.add(ehp);

		add(display);
	}

	/* reset a list of filters to default */
	private void reset(TempleActivitySortFilter... types)
	{
		for (TempleActivitySortFilter t : types)
		{
			t.reset();
			t.increasing = false;
		}
	}

	/* reset all filters to default */
	void reset()
	{
		reset(name, total, rank, ehp);
	}
}

package com.templeosrs.ui.ranks;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.ImageUtil;

public class TempleActivityTableRow extends JPanel
{
	final String name;

	private final TempleActivityLabel skillGain;

	private final TempleActivityLabel rankGain;

	private final TempleActivityLabel ehpGain;

	long total;

	long rank;

	double ehp;

	HiscoreSkillType type;

	TempleActivityTableRow(String skillName, String tooltip, Color color, HiscoreSkillType type)
	{
		this.name = skillName;
		this.type = type;

		setLayout(new BorderLayout());
		setBackground(color);

		JPanel row = new JPanel();
		row.setLayout(new GridLayout());
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		row.setOpaque(false);

		JPanel iconPanel = new JPanel();
		iconPanel.setLayout(new BorderLayout());
		iconPanel.setOpaque(false);

		/* determine icon-path by skill type and formatted-name */
		String iconPath;
		if (type.equals(HiscoreSkillType.SKILL))
		{
			iconPath = "skills/skill_icon_" + skillName + ".png";
		}
		else if (type.equals(HiscoreSkillType.BOSS))
		{
			iconPath = "bosses/game_icon_" + skillName + ".png";
		}
		else
		{
			iconPath = "overall.png";
		}

		JLabel iconLabel = new JLabel();
		iconLabel.setBorder(new EmptyBorder(0, 5, 0, 0));

		/* load icon resource from path */
		ImageIcon icon;
		try
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, iconPath));
		}
		catch (Exception e)
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "skills/skill_icon_null.png"));
		}

		iconLabel.setIcon(icon);
		iconLabel.setToolTipText(tooltip);

		/* add icon to row */
		iconPanel.add(iconLabel);
		row.add(iconPanel, BorderLayout.WEST);

		/* create and add labels to row */
		skillGain = new TempleActivityLabel();
		rankGain = new TempleActivityLabel();
		ehpGain = new TempleActivityLabel();

		row.add(skillGain);
		row.add(rankGain);
		row.add(ehpGain);
		add(row);
	}

	/* update activity-row values */
	void update(long gain, long level, long rank, double ehp)
	{
		this.total = gain;
		this.rank = rank;
		this.ehp = ehp;

		/* add levels gained as tooltip-text if SKILL */
		skillGain.update(gain);
		skillGain.setToolTipText(type.equals(HiscoreSkillType.SKILL) ? "<html>Levels Gained: <span style='color:#32a0fa'>" + level + "</span></html>" : "");

		rankGain.update(rank);
		ehpGain.update(ehp);
	}

	/* reset activity-row values to default */
	void reset()
	{
		skillGain.reset();
		rankGain.reset();
		ehpGain.reset();
	}
}

package com.templeosrs.ui.ranks;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public class TempleRanksOverview extends JPanel
{
	public final TempleRanksOverviewSection EXP;

	public final TempleRanksOverviewSection EHP;

	public final TempleRanksOverviewSection EHB;

	public TempleRanksOverview()
	{
		setLayout(new GridLayout(0, 1));
		setBorder(new EmptyBorder(5, -2, 5, -2));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* create custom border for player-overview */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), "Player Overview");
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		layoutPanel.setBorder(custom);

		JPanel playerOverview = new JPanel();
		playerOverview.setBorder(new EmptyBorder(3, 3, 3, 3));
		playerOverview.setLayout(new GridLayout(3, 1));
		playerOverview.setOpaque(false);

		/* create overview sections and add to player-overview panel */
		EHP = new TempleRanksOverviewSection("Ehp", "Efficient Hours Played", ColorScheme.DARK_GRAY_HOVER_COLOR);
		EHB = new TempleRanksOverviewSection("Ehb", "Efficient Hours Bossed", ColorScheme.DARKER_GRAY_COLOR);
		EXP = new TempleRanksOverviewSection("Xp", "Total Experience", ColorScheme.DARK_GRAY_HOVER_COLOR);

		playerOverview.add(EHP);
		playerOverview.add(EHB);
		playerOverview.add(EXP);

		layoutPanel.add(playerOverview, BorderLayout.SOUTH);
		add(layoutPanel);
	}

	/* reset player-overview sections */
	public void reset()
	{
		EHP.reset();
		EHB.reset();
		EXP.reset();
	}
}

package com.templeosrs.ui.ranks;

import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.util.PlayerRanges;
import java.awt.BorderLayout;
import java.awt.Dimension;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleRanksDuration extends JPanel
{
	private static final String[] OPTIONS = new String[PlayerRanges.values().length];
	public static JComboBox<String> jComboBox;

	static
	{
		for (int i = 0; i < PlayerRanges.values().length; i++)
		{
			OPTIONS[i] = PlayerRanges.values()[i].getName();
		}
	}

	public TempleRanksDuration(TempleOSRSConfig config, TempleRanks panel)
	{
		setLayout(new BorderLayout());
		setOpaque(false);

		setMinimumSize(new Dimension(PANEL_WIDTH, 20));
		setBorder(new EmptyBorder(5, 0, 0, 0));

		jComboBox = new JComboBox<>(OPTIONS);
		jComboBox.addActionListener(e -> panel.fetchUser());
		jComboBox.setSelectedItem(config.getDefaultRange().getName());

		add(jComboBox);
	}
}

package com.templeosrs.ui.ranks;

import static com.templeosrs.ui.TempleOSRSPanel.DEFAULT;
import javax.swing.JLabel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;

public class TempleActivityLabel extends JLabel
{
	TempleActivityLabel()
	{
		setText(DEFAULT);
		setFont(FontManager.getRunescapeSmallFont());
		setForeground(ColorScheme.LIGHT_GRAY_COLOR);
	}

	/* update activity-row label (xp, level, rank) */
	void update(long value)
	{
		setText(QuantityFormatter.quantityToStackSize(value));
		if (value == 0)
		{
			setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			setText(DEFAULT);
		}
		else if (value > 0)
		{
			setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}
		else
		{
			setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}
	}

	/* update (double) activity-row label (ehp, ehb) */
	void update(double value)
	{
		setText(String.format("%.2f", value));
		if (value == 0)
		{
			setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			setText(DEFAULT);
		}
		else if (value > 0)
		{
			setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}
		else
		{
			setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}
	}

	/* reset activity-row label to default */
	void reset()
	{
		setText(DEFAULT);
		setForeground(ColorScheme.LIGHT_GRAY_COLOR);
	}
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, dekvall
 * Copyright (c) 2021, Rorro
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.templeosrs.ui.ranks;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.NameAutocompleter;
import com.templeosrs.util.PlayerRanges;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.player.TemplePlayer;
import com.templeosrs.util.player.TemplePlayerData;
import com.templeosrs.util.player.TemplePlayerSkill;
import java.awt.Dimension;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Objects;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.api.Client;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import okhttp3.HttpUrl;

public class TempleRanks extends PluginPanel
{
	public final IconTextField lookup;

	private final Client client;

	private final TempleOSRSConfig config;

	private final NameAutocompleter nameAutocompleter;

	private final TempleActivity skills;

	private final TempleActivity bosses;

	private final TempleRanksOverview overview;

	private final TempleService service;

	@Inject
	public TempleRanks(TempleOSRSConfig config, Client client, TempleService templeService, NameAutocompleter nameAutocompleter)
	{
		this.client = client;
		this.config = config;
		this.nameAutocompleter = nameAutocompleter;
		this.service = templeService;

		skills = new TempleActivity(HiscoreSkillType.SKILL);
		bosses = new TempleActivity(HiscoreSkillType.BOSS);

		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		JPanel fetchLayout = new JPanel();
		fetchLayout.setLayout(new BoxLayout(fetchLayout, BoxLayout.Y_AXIS));
		fetchLayout.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		fetchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* build and add search-text-field */
		JPanel searchLayout = new JPanel();
		searchLayout.setLayout(new BoxLayout(searchLayout, BoxLayout.X_AXIS));
		searchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lookup = buildTextField();
		searchLayout.add(lookup);

		JLabel actions = new JLabel();
		actions.setBorder(new EmptyBorder(0, 5, 0, 0));
		actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
		actions.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				JPopupMenu menu = new JPopupMenu();
				JMenuItem fetchPlayerMenuItem = new JMenuItem();
				fetchPlayerMenuItem.setText("Search");
				fetchPlayerMenuItem.addActionListener(ev -> fetchUser());
				menu.add(fetchPlayerMenuItem);

				JMenuItem openPlayerPageMenuItem = new JMenuItem();
				openPlayerPageMenuItem.setText("Open TempleOSRS");
				openPlayerPageMenuItem.addActionListener(ev -> open());
				menu.add(openPlayerPageMenuItem);

				actions.add(menu);
				menu.show(actions, e.getX(), e.getY());
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears_light.png")));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
			}
		});

		searchLayout.add(actions);
		fetchLayout.add(searchLayout);

		/* build and add duration selection */
		TempleRanksDuration timeSelection = new TempleRanksDuration(config, this);
		fetchLayout.add(timeSelection);

		add(fetchLayout);

		/* build and add player overview */
		overview = new TempleRanksOverview();
		add(overview);

		/* material-tab-group for selecting view of Skills/ Bosses */
		JPanel display = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(display);

		MaterialTab skillsTab = new MaterialTab("Skills", tabGroup, skills);
		MaterialTab bossesTab = new MaterialTab("Bosses", tabGroup, bosses);

		tabGroup.addTab(skillsTab);
		tabGroup.addTab(bossesTab);
		tabGroup.select(skillsTab);
		add(tabGroup);

		add(display);

		/* add key listener for player-search autocomplete */
		addInputKeyListener(this.nameAutocompleter);

		/* load default player on start-up */
		if (config.fetchDefaults())
		{
			if (!Strings.isNullOrEmpty(config.getDefaultPlayer()))
			{
				fetchUser(config.getDefaultPlayer());
			}
		}
	}

	/* remove key listener for player-search autocomplete */
	public void shutdown()
	{
		removeInputKeyListener(this.nameAutocompleter);
	}

	private IconTextField buildTextField()
	{
		IconTextField lookup = new IconTextField();

		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
		lookup.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		lookup.setBackground(ColorScheme.SCROLL_TRACK_COLOR);

		/* add action listeners for fetching user / fetching local player */
		lookup.addActionListener(e -> fetchUser());
		lookup.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				if (SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2)
				{
					String player = config.getDefaultPlayer();

					if (!Strings.isNullOrEmpty(player))
					{
						fetchUser(player);
					}
				}
			}
		});

		/* reset icons and panel on clear */
		lookup.addClearListener(() -> {
			completed();
			reset();
		});

		return lookup;
	}

	/* search-text-field double-click -> fetch local player */
	public void fetchUser(String username)
	{
		lookup.setText(username);
		fetchUser();
	}

	/* fetch player from search-text-field */
	public void fetchUser()
	{
		final String username = format(lookup.getText());

		if (Strings.isNullOrEmpty(username))
		{
			return;
		}

		/* maximum username length */
		if (username.length() > 12)
		{
			error();
			return;
		}

		loading();

		reset();

		String period = PlayerRanges.get(String.valueOf(TempleRanksDuration.jComboBox.getSelectedItem())).getRange();

		/* create separate thread for completing player-fetch/ panel rebuilds,
		 *  try to fetch player gains,
		 *  when fetching completes, rebuild panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				service.fetchUserGainsAsync(username, period).whenCompleteAsync((result, err) -> response(username, result, err));
			}
			catch (Exception e)
			{
				e.printStackTrace();
				error();
			}
		}).start();
	}

	private void response(String username, TemplePlayer result, Throwable e)
	{
		/* search-text-field has changed since start of fetching player data */
		if (!format(lookup.getText()).equals(username))
		{
			completed();
			return;
		}

		/* result is null, error is not null, or error response */
		if (Objects.isNull(result) || Objects.nonNull(e) || result.error)
		{
			error();
			return;
		}
		rebuild(result);
	}

	/* rebuild components */
	private void rebuild(TemplePlayer result)
	{
		skills.update(result);
		bosses.update(result);
		rebuildOverall(result);

		completed();
	}

	private void rebuildOverall(TemplePlayer result)
	{
		/* get player skills and bosses data from result */
		TemplePlayerData bossingData = result.playerBossesOverview.data;
		TemplePlayerData skillsData = result.playerSkillsOverview.data;

		TemplePlayerSkill ehbData = bossingData.table.get("Ehb");
		TemplePlayerSkill ehpData = skillsData.table.get("Ehp");
		TemplePlayerSkill xpData = skillsData.table.get("Overall");

		/* if not null, get overall totals, ranks, and gains for ehp/ehb/xp */
		double ehbRankTotal = Objects.nonNull(ehbData.rankTotal) ? ehbData.rankTotal : 0;
		double ehbTotal = Objects.nonNull(ehbData.xpTotal) ? ehbData.xpTotal : 0;

		double ehbRankGain = Objects.nonNull(ehbData.rank) ? ehbData.rank : 0;
		double ehbGain = Objects.nonNull(ehbData.xp) ? ehbData.xp : 0;

		double ehpRankTotal = Objects.nonNull(ehpData.rankTotal) ? ehpData.rankTotal : 0;
		double ehpTotal = Objects.nonNull(ehpData.xpTotal) ? ehpData.xpTotal : 0;

		double ehpRankGain = Objects.nonNull(ehpData.rank) ? ehpData.rank : 0;
		double ehpGain = Objects.nonNull(ehpData.xp) ? ehpData.xp : 0;

		double xpRankTotal = Objects.nonNull(xpData.rankTotal) ? xpData.rankTotal : 0;
		double xpTotal = Objects.nonNull(xpData.xpTotal) ? xpData.xpTotal : 0;

		/* update player-overview sections */
		overview.EHP.update((long) ehpRankTotal, (long) ehpTotal);
		overview.EHB.update((long) ehbRankTotal, (long) ehbTotal);
		overview.EXP.update((long) xpRankTotal, (long) xpTotal);

		/* update activity overall-row */
		bosses.update((long) ehbRankGain, ehbGain);
		skills.update((long) ehpRankGain, ehpGain);
	}

	private void open()
	{
		String username = format(lookup.getText());
		if (Strings.isNullOrEmpty(username))
		{
			return;
		}

		if (username.length() > 12)
		{
			error();
			return;
		}

		/* if valid username format, open temple player-profile */
		loading();

		HttpUrl url = new HttpUrl.Builder().scheme("https").host("templeosrs.com").addPathSegment("player").addPathSegment("overview.php").addQueryParameter("player", username).build();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url.toString()));

		completed();
	}

	/* reset all panels */
	private void reset()
	{
		skills.reset();
		bosses.reset();
		overview.reset();

		repaint();
		revalidate();
	}

	/* set fields for error status */
	private void error()
	{
		lookup.setIcon(IconTextField.Icon.ERROR);
		lookup.setEditable(true);
	}

	/* set fields for loading status */
	private void loading()
	{
		lookup.setIcon(IconTextField.Icon.LOADING);
		lookup.setEditable(false);
	}

	/* set fields for completed status */
	private void completed()
	{
		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
	}

	private void addInputKeyListener(KeyListener l)
	{
		lookup.addKeyListener(l);
	}

	private void removeInputKeyListener(KeyListener l)
	{
		lookup.removeKeyListener(l);
	}

	/* format username to be accepted by Temple API */
	private String format(String text)
	{
		String formatted = text.replaceAll("\\s+", "+");
		return formatted.replace('\u00A0', '+');
	}
}


package com.templeosrs.ui.ranks;

import com.google.common.collect.ImmutableList;
import com.templeosrs.util.TempleHiscoreSkill;
import static com.templeosrs.util.TempleHiscoreSkill.*;
import com.templeosrs.util.player.TemplePlayer;
import com.templeosrs.util.player.TemplePlayerData;
import com.templeosrs.util.player.TemplePlayerSkill;
import java.awt.Color;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;

public class TempleActivity extends JPanel
{
	public static final List<TempleHiscoreSkill> SKILLS = ImmutableList.of(
		ATTACK, DEFENCE, STRENGTH,
		HITPOINTS, RANGED, PRAYER,
		MAGIC, COOKING, WOODCUTTING,
		FLETCHING, FISHING, FIREMAKING,
		CRAFTING, SMITHING, MINING,
		HERBLORE, AGILITY, THIEVING,
		SLAYER, FARMING, RUNECRAFT,
		HUNTER, CONSTRUCTION
	);

	public static final List<TempleHiscoreSkill> BOSSES = ImmutableList.of(
		ABYSSAL_SIRE, ALCHEMICAL_HYDRA, AMOXLIATL, ARAXXOR, ARTIO, BARROWS_CHESTS,
		BRYOPHYTA, CALLISTO, CALVARION, CERBERUS,
		CHAMBERS_OF_XERIC, CHAMBERS_OF_XERIC_CHALLENGE_MODE, CHAOS_ELEMENTAL,
		CHAOS_FANATIC, COMMANDER_ZILYANA, CORPOREAL_BEAST,
		DAGANNOTH_PRIME, DAGANNOTH_REX, DAGANNOTH_SUPREME,
		CRAZY_ARCHAEOLOGIST, DERANGED_ARCHAEOLOGIST, DUKE_SUCELLUS, GENERAL_GRAARDOR,
		GIANT_MOLE, GROTESQUE_GUARDIANS, HESPORI,
		KALPHITE_QUEEN, KING_BLACK_DRAGON, KRAKEN,
		KREEARRA, KRIL_TSUTSAROTH, LUNAR_CHESTS, MIMIC,
		NEX, THE_NIGHTMARE, PHOSANIS_NIGHTMARE,
		OBOR, PHANTOM_MUSPAH, SARACHNIS, SCORPIA, SCURRIUS,
		SKOTIZO, SOL_HEREDIT, SPINDEL, TEMPOROSS, THE_GAUNTLET,
		THE_CORRUPTED_GAUNTLET, HUEYCOATL, THE_LEVIATHAN, THE_ROYAL_TITANS, THE_WHISPERER, THEATRE_OF_BLOOD, THEATRE_OF_BLOOD_CHALLENGE_MODE,
		THERMONUCLEAR_SMOKE_DEVIL, TOMBS_OF_AMASCUT, TOMBS_OF_AMASCUT_EXPERT, TZKAL_ZUK, TZTOK_JAD, VARDORVIS,
		VENENATIS, VETION, VORKATH,
		WINTERTODT, ZALCANO, ZULRAH, COLLECTIONS
	);

	private static final Color[] COLORS = {ColorScheme.DARKER_GRAY_COLOR, ColorScheme.DARK_GRAY_HOVER_COLOR};

	final Map<String, TempleActivityTableRow> map = new HashMap<>();

	final TempleActivitySortHeader sortPanel;

	final TempleActivityTableRow overall;

	ArrayList<TempleActivityTableRow> rows = new ArrayList<>();

	HiscoreSkillType hiscoreSkillType;

	long total;

	@Inject
	public TempleActivity(HiscoreSkillType type)
	{
		hiscoreSkillType = type;

		setLayout(new GridLayout(0, 1));
		setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		sortPanel = new TempleActivitySortHeader(this, hiscoreSkillType);

		overall = new TempleActivityTableRow("overall", "Overall", COLORS[1], HiscoreSkillType.OVERALL);

		initialize();
	}

	private void initialize()
	{
		/* reset rows */
		rows.clear();

		/* add default panels */
		add(sortPanel);
		add(overall);

		/* get correct list of HiscoreSkills */
		List<TempleHiscoreSkill> list = (hiscoreSkillType.equals(HiscoreSkillType.SKILL) ? SKILLS : BOSSES);

		/* for each skill in list */
		for (int i = 0; i < list.size(); i++)
		{
			TempleHiscoreSkill skill = list.get(i);
			String formattedKey = skill.getName().replaceAll("[^A-Za-z0-9]", "").toLowerCase();

			/* create a skill-row, add <key, row> to map, add row to rows-list */
			TempleActivityTableRow row = new TempleActivityTableRow(formattedKey, skill.getName(), COLORS[i % 2], hiscoreSkillType);
			map.put(formattedKey, row);
			rows.add(row);
			add(row);
		}
	}

	public void update(TemplePlayer result)
	{
		/* determine and get type of json */
		TemplePlayerData playerData = hiscoreSkillType.equals(HiscoreSkillType.SKILL) ? result.playerSkillsOverview.data : result.playerBossesOverview.data;

		/* for each entry in playerData */
		for (Map.Entry<String, TemplePlayerSkill> entry : playerData.table.entrySet())
		{
			/* get the HiscoreSkill of that entry by index */
			TempleHiscoreSkill skill;
			try
			{
				/* If a skill can't be found, continue */
				skill = TempleHiscoreSkill.values()[entry.getValue().index];
			}
			catch (IndexOutOfBoundsException ignored)
			{
				continue;
			}

			String formattedKey = skill.getName().replaceAll("[^A-Za-z0-9]", "").toLowerCase();

			/* if map contains this HighscoreSkill */
			if (map.containsKey(formattedKey))
			{
				/* get the mapped, skill-row */
				TempleActivityTableRow row = map.get(formattedKey);
				TemplePlayerSkill skillData = playerData.table.get(skill.getName());

				long total = Objects.nonNull(skillData.xp) ? skillData.xp.longValue() : 0;
				long levels = Objects.nonNull(skillData.level) ? skillData.level.longValue() : 0;
				long rank = Objects.nonNull(skillData.rank) ? skillData.rank.longValue() : 0;
				double ehp = hiscoreSkillType.equals(HiscoreSkillType.SKILL) ? (Objects.nonNull(skillData.ehp) ? skillData.ehp : 0) : (Objects.nonNull(skillData.ehb) ? skillData.ehb : 0);

				this.total += total;

				/* update skill-row's values */
				row.update(total, levels, rank, ehp);
			}
		}
	}

	/* update overall row */
	public void update(long rank, double ehp)
	{
		overall.update(total, 0, rank, ehp);
	}

	/* reset activity panel to defaults */
	public void reset()
	{
		total = 0;

		overall.reset();
		sortPanel.reset();

		removeAll();

		initialize();
	}

	/* re-build list of skills by sorted row-list */
	private void rebuild()
	{
		int i = 0;
		for (TempleActivityTableRow row : rows)
		{
			String skill = row.name;
			TempleActivityTableRow entry = map.get(skill);
			entry.setBackground(COLORS[i++ % 2]);
			add(entry);
		}

		repaint();
		revalidate();
	}

	/* sort row-list with comparator passed in through sort-filter mouse event */
	void sort(Comparator<TempleActivityTableRow> comparator)
	{
		rows.sort(comparator);
		rebuild();
	}
}

package com.templeosrs.ui.ranks;

import static com.templeosrs.ui.TempleOSRSPanel.DEFAULT;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.QuantityFormatter;

public class TempleRanksOverviewSection extends JPanel
{
	JLabel total;

	JLabel rank;

	TempleRanksOverviewSection(String label, String tooltip, Color color)
	{
		this.total = createNewJLabel(label + " Total");
		this.rank = createNewJLabel(label + " Rank");

		setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		setBorder(new EmptyBorder(0, 10, 0, 0));
		setLayout(new GridLayout(1, 3));
		setBackground(color);

		/* add labels to layout */
		JLabel field = new JLabel(label.toUpperCase(), SwingConstants.LEFT);
		field.setFont(FontManager.getRunescapeSmallFont());
		field.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		field.setToolTipText(tooltip);

		add(field);
		add(total);
		add(rank);
	}

	/* update overview-section (rank, total) pair */
	public void update(long x, long x1)
	{
		rank.setText(x != 0 ? QuantityFormatter.quantityToStackSize(x) : DEFAULT);
		total.setText(x1 != 0 ? QuantityFormatter.quantityToStackSize(x1) : DEFAULT);
	}

	/* reset overview-section (rank, total) pair */
	void reset()
	{
		total.setText(DEFAULT);
		rank.setText(DEFAULT);
	}

	/* creates an overview-section label of similar style */
	private JLabel createNewJLabel(String tooltip)
	{
		JLabel label = new JLabel(DEFAULT);

		label.setFont(FontManager.getRunescapeSmallFont());
		label.setToolTipText(tooltip);

		return label;
	}
}

package com.templeosrs.ui.ranks;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class TempleActivitySortFilter extends JPanel
{
	private final JLabel icon;

	boolean increasing;

	TempleActivitySortFilter(String text)
	{
		icon = new JLabel();

		JLabel label = new JLabel(text);
		label.setFont(FontManager.getRunescapeSmallFont());

		setLayout(new GridLayout(0, 2));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* on mouse-event, flip ascending/ descending icon */
		addMouseListener(new MouseAdapter()
		{
			public void mousePressed(MouseEvent me)
			{
				increasing = !increasing;
				icon.setIcon(new ImageIcon(increasing ? ImageUtil.loadImageResource(TempleOSRSPlugin.class, "sorting/up.png") : ImageUtil.loadImageResource(TempleOSRSPlugin.class, "sorting/down.png")));
			}
		});

		add(label);
		add(icon);
	}

	void reset()
	{
		icon.setIcon(null);
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.CurrentTopRanges;
import com.templeosrs.util.clan.TempleClanCurrentTopPlayer;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.Map;
import java.util.Objects;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanCurrentTopList extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	TempleClanCurrentTopList(TempleOSRSPlugin plugin, Map<String, TempleClanCurrentTopPlayer> skill, CurrentTopRanges range)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel currentTop = new JPanel();
		currentTop.setLayout(new GridLayout(0, 1));

		/* create a list, if map is not null -> add map entries to list */
		ArrayList<TempleClanCurrentTopPlayer> players = new ArrayList<>();
		if (Objects.nonNull(skill))
		{
			players.addAll(skill.values());
		}

		/* for each member in the list of current-top players */
		for (int i = 0; i < players.size(); i++)
		{
			/* create a new member-row and add to current-top list */
			TempleClanCurrentTopPlayer player = players.get(i);
			TempleClanCurrentTopRow user = new TempleClanCurrentTopRow(plugin, i + 1, player.player, String.format("%.2f", player.xp), COLORS[i % 2]);
			currentTop.add(user);
		}

		/* add current-top list to main layout */
		layoutPanel.add(currentTop, BorderLayout.SOUTH);

		/* create custom border, add to (layout or scroll) */

		String title = "Current Top - " + range.getName();
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), title);
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if list is too large -> add scroll-pane and set preferred dimensions */
		if (players.size() > 10)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 275));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.clan.TempleClanAchievement;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanAchievements extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	TempleClanAchievements(TempleOSRSPlugin plugin, List<TempleClanAchievement> clanActivityList)
	{
		if (clanActivityList == null)
		{
			return;
		}

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* layout which holds all achievement-rows */
		JPanel clanActivity = new JPanel();
		clanActivity.setLayout(new GridLayout(0, 1));

		/* for each achievement in activity-list */
		for (int i = 0; i < clanActivityList.size(); i++)
		{
			TempleClanAchievement skill = clanActivityList.get(i);
			HiscoreSkillType type = skill.type.equals("Skill") ? HiscoreSkillType.SKILL : HiscoreSkillType.BOSS;

			/* create a new achievement-row and add to clan-activity layout */
			TempleClanAchievementRow row = new TempleClanAchievementRow(plugin, skill.username, skill.skill, type, skill.xp, COLORS[i % 2]);
			clanActivity.add(row);
		}

		/* add clan-activity list to main layout */
		layoutPanel.add(clanActivity, BorderLayout.SOUTH);

		/* create custom border */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), "Recent Activity");
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if list is too large -> add scroll-pane and set preferred dimensions */
		if (clanActivityList.size() > 10)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 275));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs.ui.clans;

import com.google.common.base.Strings;
import com.templeosrs.TempleOSRSConfig;
import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.TempleService;
import com.templeosrs.util.clan.TempleClan;
import com.templeosrs.util.clan.TempleClanAchievement;
import com.templeosrs.util.clan.TempleClanOverviewInfo;
import com.templeosrs.util.sync.TempleSync;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.api.Client;
import net.runelite.api.clan.ClanMember;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;

public class TempleClans extends PluginPanel
{
	private static final Pattern isNumeric = Pattern.compile("-?\\d+(\\.\\d+)?");

	public final IconTextField lookup;

	private final Client client;

	private final ClientThread thread;

	private final TempleOSRSPlugin plugin;

	private final TempleOSRSConfig config;

	private final PluginErrorPanel errorPanel = new PluginErrorPanel();

	private final JPanel fetchLayout;

	public TempleClanAchievements clanAchievements;

	public TempleClanMembers clanMembers;

	public TempleClanCurrentTop clanCurrentTop;

	public TempleService service;

	@Inject
	public TempleClans(TempleOSRSConfig config, TempleOSRSPlugin plugin, Client client, ClientThread thread, TempleService templeService)
	{
		this.plugin = plugin;
		this.client = client;
		this.thread = thread;
		this.config = config;
		this.service = templeService;

		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		fetchLayout = new JPanel();
		fetchLayout.setLayout(new BoxLayout(fetchLayout, BoxLayout.Y_AXIS));
		fetchLayout.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		fetchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* build and add search-text-field */
		JPanel searchLayout = new JPanel();
		searchLayout.setLayout(new BoxLayout(searchLayout, BoxLayout.X_AXIS));
		searchLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		lookup = buildTextField();
		searchLayout.add(lookup);

		JLabel actions = new JLabel();
		actions.setBorder(new EmptyBorder(0, 5, 0, 0));
		actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
		actions.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (client == null)
				{
					return;
				}

				JPopupMenu menu = new JPopupMenu();
				JMenuItem fetchPlayerMenuItem = new JMenuItem();
				fetchPlayerMenuItem.setText("Search");
				fetchPlayerMenuItem.addActionListener(ev -> fetchClan());
				menu.add(fetchPlayerMenuItem);

				JMenuItem openPlayerPageMenuItem = new JMenuItem();
				openPlayerPageMenuItem.setText("Open TempleOSRS");
				openPlayerPageMenuItem.addActionListener(ev -> open());
				menu.add(openPlayerPageMenuItem);

				JMenuItem syncClanMembersMenuItem = new JMenuItem();
				syncClanMembersMenuItem.setText("Sync Clan Members");
				syncClanMembersMenuItem.addActionListener(ev -> verify());
				menu.add(syncClanMembersMenuItem);

				actions.add(menu);
				menu.show(actions, e.getX(), e.getY());
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears_light.png")));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				actions.setIcon(new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "gears.png")));
			}

		});

		searchLayout.add(actions);
		fetchLayout.add(searchLayout);

		add(fetchLayout);

		/* add default, error-panel when clan has not been fetched yet */
		errorPanel.setContent("Clans", "You have not fetched clan information yet.");
		add(errorPanel);

		/* load default clan on start-up */
		if (config.fetchDefaults())
		{
			if (config.getDefaultClan() != 0)
			{
				lookup.setText(Integer.toString(config.getDefaultClan()));
				fetchClan();
			}
		}
	}

	private IconTextField buildTextField()
	{
		IconTextField lookup = new IconTextField();

		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
		lookup.setPreferredSize(new Dimension(PANEL_WIDTH, 25));
		lookup.setBackground(ColorScheme.SCROLL_TRACK_COLOR);

		/* fetch clan on action */
		lookup.addActionListener(e -> fetchClan());
		lookup.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (config.getDefaultClan() != 0 && SwingUtilities.isLeftMouseButton(e) && e.getClickCount() == 2)
				{
					lookup.setText(Integer.toString(config.getDefaultClan()));
					fetchClan();
				}

				if (SwingUtilities.isRightMouseButton(e))
				{
					JPopupMenu menu = new JPopupMenu();
					JMenuItem fetchPlayerMenuItem = new JMenuItem();
					fetchPlayerMenuItem.setText("Search");
					fetchPlayerMenuItem.addActionListener(ev -> fetchClan());
					menu.add(fetchPlayerMenuItem);

					JMenuItem openPlayerPageMenuItem = new JMenuItem();
					openPlayerPageMenuItem.setText("Open TempleOSRS");
					openPlayerPageMenuItem.addActionListener(ev -> open());
					menu.add(openPlayerPageMenuItem);
					lookup.add(menu);

					JMenuItem syncClanMembersMenuItem = new JMenuItem();
					syncClanMembersMenuItem.setText("Sync Clan Members");
					syncClanMembersMenuItem.addActionListener(ev -> verify());
					menu.add(syncClanMembersMenuItem);
					lookup.add(menu);
					menu.show(lookup, e.getX(), e.getY());
				}
			}
		});

		/* reset on clear */
		lookup.addClearListener(() -> {
			completed();
			reset();
		});

		return lookup;
	}

	/* fetch clan from search-text-field */
	public void fetchClan()
	{
		final String id = lookup.getText();

		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		/* clan-id must be integer */
		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		loading();

		reset();

		/* create separate thread for completing clan-fetch/ panel rebuilds,
		 *  try to fetch clan,
		 *  when fetching completes, rebuild panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				service.fetchClanAsync(id, config.getCurrentTopRange().getRange()).whenCompleteAsync((result, err) -> response(id, result, err));
			}
			catch (Exception e)
			{
				error();
			}
		}).start();
	}

	/* reload fetched clan after syncing member-list */
	private void reload(String id)
	{
		loading();

		reset();

		try
		{
			service.fetchClanAsync(id, config.getCurrentTopRange().getRange()).whenCompleteAsync((result, err) -> response(id, result, err));
		}
		catch (Exception e)
		{
			error();
		}
	}

	private void rebuild(TempleClan result)
	{
		if (client == null)
		{
			return;
		}

		String[] leaders = result.clanOverview.data.leaders;
		String[] members = result.clanOverview.data.members;
		TempleClanOverviewInfo info = result.clanOverview.data.info;
		List<TempleClanAchievement> clanActivity = result.clanAchievements.data;
		/* Event-Dispatch-Thread necessary for adding/ removing new components */
		SwingUtilities.invokeLater(() -> {

			add(new TempleClanOverview(info));

			/* create achievements-component, only add if config option */
			clanAchievements = new TempleClanAchievements(plugin, clanActivity);
			if (config.displayClanAchievements())
			{
				add(clanAchievements);
			}

			/* create current-top-component, only add if config option enabled */
			TempleClanCurrentTopList clanCurrentTopEhp = new TempleClanCurrentTopList(plugin, result.clanCurrentTopEhp.list, config.getCurrentTopRange());
			TempleClanCurrentTopList clanCurrentTopEhb = new TempleClanCurrentTopList(plugin, result.clanCurrentTopEhb.list, config.getCurrentTopRange());

			clanCurrentTop = new TempleClanCurrentTop(clanCurrentTopEhp, clanCurrentTopEhb);
			if (config.displayClanCurrentTop())
			{
				add(clanCurrentTop);
			}

			/* create members-component, only add if config option */
			clanMembers = new TempleClanMembers(new TempleClanMembersList(plugin, "Leaders", leaders), new TempleClanMembersList(plugin, "Members", members));
			if (config.displayClanMembers())
			{
				add(clanMembers);
			}
		});

		completed();

		revalidate();
		repaint();
	}

	private void open()
	{
		String id = lookup.getText();
		if (Strings.isNullOrEmpty(id))
		{
			return;
		}

		if (!isNumeric.matcher(id).matches())
		{
			error();
			return;
		}

		/* if valid clan-id, open temple clan-page */
		loading();

		HttpUrl url = new HttpUrl.Builder()
			.scheme("https")
			.host("templeosrs.com")
			.addPathSegment("groups")
			.addPathSegment("overview.php")
			.addQueryParameter("id", id).build();

		SwingUtilities.invokeLater(() -> LinkBrowser.browse(url.toString()));

		completed();
	}

	private void verify()
	{
		if (client == null)
		{
			return;
		}

		if (Strings.isNullOrEmpty(config.clanKey()))
		{
			return;
		}

		ClanSettings localClan = client.getClanSettings();

		if (localClan == null)
		{
			return;
		}

		/* add confirmation to sync clan-members with fetched clan (requires key) */
		final int confirmation = JOptionPane.showOptionDialog(lookup, "This will sync the fetched clan's TempleOSRS members-list to all members in the current account's clan (Requires Key).",
			"Are you sure?", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE,
			null, new String[]{
				"Yes",
				"No"
			}, "No");

		if (confirmation != JOptionPane.YES_OPTION)
		{
			return;
		}

		/* exclude certain clan ranks from members-sync */
		filter(localClan);
	}

	private void verify(List<String> filteredList)
	{
		loading();

		String id = lookup.getText();
		/* create separate thread for completing clan-post/ panel reload,
		 *  try to post clan members given clan-id, verification, and list,
		 *  when post completes, check response -> reload panel
		 *  if exception, set error status
		 */
		new Thread(() -> {
			try
			{
				if (config.onlyAddMembers())
				{
					service.addClanMembersAsync(id, config.clanKey(), filteredList).whenCompleteAsync((result, err) -> response(id, result, err));
				}
				else
				{
					service.syncClanMembersAsync(id, config.clanKey(), filteredList).whenCompleteAsync((result, err) -> response(id, result, err));
				}
			}
			catch (Exception e)
			{
				error();
			}
		}).start();
	}

	/* filter unwanted ranks for members-sync */
	private void filter(ClanSettings localClan)
	{
		List<String> clanList = new ArrayList<>();
		List<String> ignoredRanks = Text.fromCSV(config.getIgnoredRanks());

		/* ClientThread necessary for method titleForRank */
		thread.invoke(() -> {
			for (ClanMember member : localClan.getMembers())
			{
				ClanRank rank = member.getRank();
				ClanTitle clanTitle = localClan.titleForRank(rank);
				if (clanTitle != null)
				{
					String title = clanTitle.getName();
					if (!ignoredRanks.contains(title))
					{
						/* create a list of clan members retrieved from RuneLite, ignoring excluded ranks */
						clanList.add(format(member.getName()));
					}
				}
			}
			verify(clanList);
		});
	}

	/* Sync members response */
	private void response(String id, TempleSync response, Throwable e)
	{
		/* response is null, exception thrown, or error response */
		if (Objects.isNull(response) || Objects.nonNull(e) || response.error)
		{
			error();
			return;
		}
		reload(id);
	}

	/* Group information response */
	private void response(String id, TempleClan result, Throwable e)
	{
		remove(errorPanel);

		if (!lookup.getText().equals(id))
		{
			completed();
			return;
		}

		/* result is null, exception thrown, or error response */
		if (Objects.isNull(result) || Objects.nonNull(e) || result.error)
		{
			error();
			return;
		}
		rebuild(result);
	}

	/* reset clan tab to default */
	private void reset()
	{
		clanAchievements = null;
		clanMembers = null;

		removeAll();
		add(fetchLayout);
		add(errorPanel);

		repaint();
		revalidate();
	}

	/* set fields for error status */
	private void error()
	{
		lookup.setIcon(IconTextField.Icon.ERROR);
		lookup.setEditable(true);
	}

	/* set fields for loading status */
	private void loading()
	{
		lookup.setIcon(IconTextField.Icon.LOADING);
		lookup.setEditable(false);
	}

	/* set fields for completed status */
	private void completed()
	{
		lookup.setIcon(IconTextField.Icon.SEARCH);
		lookup.setEditable(true);
	}

	/* format username to be accepted by Temple API */
	private String format(String text)
	{
		return text.replace('\u00A0', ' ');
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanCurrentTopRow extends JPanel
{
	TempleClanCurrentTopRow(TempleOSRSPlugin plugin, Integer rank, String name, String xp, Color color)
	{
		setLayout(new BorderLayout());
		setBackground(color);

		JPanel row = new JPanel();
		row.setLayout(new GridLayout(0, 2));
		row.setOpaque(false);
		row.setBorder(new EmptyBorder(2, 5, 2, 0));
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));

		/* add rank and username to row */
		JLabel username = new JLabel(rank + ". " + name);
		username.setFont(FontManager.getRunescapeSmallFont());
		username.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		row.add(username);

		/* add on-click menu to row */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + name + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(name));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		row.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});

		/* add ehp to row */
		JLabel ehp = new JLabel(xp);
		ehp.setFont(FontManager.getRunescapeSmallFont());
		ehp.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);

		row.add(ehp);

		add(row);
	}
}

package com.templeosrs.ui.clans;

import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

public class TempleClanCurrentTop extends PluginPanel
{
	TempleClanCurrentTop(TempleClanCurrentTopList Ehp, TempleClanCurrentTopList Ehb)
	{
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		/* tab group to switch between EHP and EHB */
		JPanel display = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(display);

		MaterialTab leadersTab = new MaterialTab("Hours Played", tabGroup, Ehp);
		MaterialTab membersTab = new MaterialTab("Hours Bossed", tabGroup, Ehb);

		tabGroup.addTab(leadersTab);
		tabGroup.addTab(membersTab);
		tabGroup.select(leadersTab);

		add(tabGroup);
		add(display);
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanMember extends JPanel
{
	TempleClanMember(TempleOSRSPlugin plugin, String name, Color color)
	{
		setLayout(new BorderLayout());
		setBackground(color);

		JPanel row = new JPanel();
		row.setLayout(new GridLayout());
		row.setOpaque(false);
		row.setBorder(new EmptyBorder(2, 5, 2, 0));
		row.setPreferredSize(new Dimension(PANEL_WIDTH, 25));

		/* add username to row */
		JLabel username = new JLabel(name);
		username.setFont(FontManager.getRunescapeSmallFont());
		username.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		row.add(username);

		/* add on-click menu to row */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + name + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(name));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		row.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});

		add(row);
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.border.EmptyBorder;
import net.runelite.client.hiscore.HiscoreSkillType;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;

public class TempleClanAchievementRow extends JPanel
{
	TempleClanAchievementRow(TempleOSRSPlugin plugin, String name, String skill, HiscoreSkillType type, long xp, Color color)
	{
		setLayout(new BorderLayout());

		JPanel row = new JPanel();
		row.setLayout(new GridLayout(1, 3));
		row.setBorder(new EmptyBorder(2, 0, 2, 0));
		row.setPreferredSize(new Dimension(0, 25));
		row.setBackground(color);

		/* format name for file-path */
		String formattedName = skill.replaceAll("[^A-Za-z0-9]", "").toLowerCase();

		/* determine icon-path */
		String iconPath;
		if (type.equals(HiscoreSkillType.SKILL))
		{
			iconPath = "skills/skill_icon_" + formattedName + ".png";
		}
		else
		{
			iconPath = "bosses/game_icon_" + formattedName + ".png";
		}

		ImageIcon icon;
		try
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, iconPath));
		}
		catch (Exception e)
		{
			icon = new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "bosses/game_icon_null.png"));
		}

		/* add username to row */
		JLabel usernameLabel = createNewJLabel(name);
		row.add(usernameLabel);

		/* add achievement-value to row */
		String xpType = QuantityFormatter.quantityToStackSize(xp);
		JLabel xpLabel = createNewJLabel(xpType);

		xpLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		xpLabel.setHorizontalAlignment(JLabel.CENTER);
		row.add(xpLabel);

		/* add achievement-icon to row */
		JLabel iconLabel = new JLabel();
		iconLabel.setBorder(new EmptyBorder(0, 0, 0, 5));
		iconLabel.setIcon(icon);
		iconLabel.setToolTipText(skill);
		iconLabel.setHorizontalAlignment(JLabel.RIGHT);
		row.add(iconLabel);

		add(row);

		/* add on-click menu to username label */
		JPopupMenu menu = new JPopupMenu();

		JMenuItem lookupPlayer = new JMenuItem();
		lookupPlayer.setText("<html>Lookup <span style='color:#6ee16e'>" + name + "</span></html>");
		lookupPlayer.addActionListener(e -> plugin.fetchUser(name));
		menu.add(lookupPlayer);

		/* show lookup player menu option on click mouse-event */
		usernameLabel.addMouseListener(new MouseAdapter()
		{
			public void mouseClicked(MouseEvent e)
			{
				menu.show(row, e.getX(), e.getY());
			}
		});
	}

	/* create a new achievement label of similar style */
	JLabel createNewJLabel(String text)
	{
		JLabel label = new JLabel(text);
		label.setToolTipText(text);
		label.setFont(FontManager.getRunescapeSmallFont());
		label.setBorder(new EmptyBorder(0, 5, 0, 0));
		return label;
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import com.templeosrs.util.clan.TempleClanOverviewInfo;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Objects;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.EtchedBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

public class TempleClanOverview extends JPanel
{

	TempleClanOverview(TempleClanOverviewInfo info)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
		layoutPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), new EmptyBorder(5, 5, 5, 5)));
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* add name to layout */
		JLabel clanName = new JLabel(info.name);
		clanName.setBorder(new EmptyBorder(5, 5, 0, 0));
		clanName.setFont(FontManager.getRunescapeBoldFont());
		clanName.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		clanName.setAlignmentX(Component.CENTER_ALIGNMENT);
		clanName.setToolTipText(
			"<html> <table>" +
				"<tr><th style='text-align: left'>Total Xp: </th><td style='color:#6ee16e'>" + info.totalXp + "</td></tr>" +
				"<tr><th style='text-align: left'>Avg. Ehp: </th><td style='color:#6ee16e'>" + String.format("%.2f", info.averageEhp) + "</td></tr>" +
				"<tr><th style='text-align: left'>Avg. Ehb: </th><td style='color:#6ee16e'>" + String.format("%.2f", info.averageEhb) + "</td></tr>" +
				"</table> </html>");
		layoutPanel.add(clanName);

		JPanel fieldLayout = new JPanel();
		fieldLayout.setLayout(new FlowLayout());
		fieldLayout.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* create and add members-count to layout */
		JLabel field = new JLabel("Members:");
		field.setBorder(new EmptyBorder(5, 5, 0, 0));
		field.setFont(FontManager.getRunescapeSmallFont());
		field.setAlignmentX(Component.CENTER_ALIGNMENT);
		fieldLayout.add(field);

		JLabel count = new JLabel(String.valueOf(info.memberCount));
		count.setBorder(new EmptyBorder(5, 0, 0, 0));
		count.setFont(FontManager.getRunescapeSmallFont());
		fieldLayout.add(count);

		layoutPanel.add(fieldLayout);

		/* create and add socials to layout */
		JPanel clanSocials = new JPanel();
		clanSocials.setPreferredSize(new Dimension(PANEL_WIDTH, 30));
		clanSocials.setLayout(new FlowLayout());
		clanSocials.setAlignmentX(Component.CENTER_ALIGNMENT);
		clanSocials.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		/* if social link exists, create and add button to socials-panel */
		if (Objects.nonNull(info.discordLink))
		{
			JButton social = createSocialsButton("https://discord.com/invite/" + info.discordLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/discord.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.twitterLink))
		{
			JButton social = createSocialsButton("https://twitter.com/" + info.twitterLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/twitter.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.youtubeLink))
		{
			JButton social = createSocialsButton("https://www.youtube.com/channel/" + info.youtubeLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/youtube.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.forumLink))
		{
			JButton social = createSocialsButton("https://secure.runescape.com/m=forum/sl=0/forums?" + info.forumLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/forums.png")));
			clanSocials.add(social);
		}

		if (Objects.nonNull(info.twitchLink))
		{
			JButton social = createSocialsButton("https://www.twitch.tv/" + info.twitchLink, new ImageIcon(ImageUtil.loadImageResource(TempleOSRSPlugin.class, "clans/discord.png")));
			clanSocials.add(social);
		}

		/* if there is at least one social linked, add to layout */
		if (clanSocials.getComponentCount() > 0)
		{
			layoutPanel.add(clanSocials);
		}

		add(layoutPanel);
	}

	private JButton createSocialsButton(String link, ImageIcon icon)
	{
		JButton socialButton = new JButton();
		socialButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		socialButton.setBorder(new EmptyBorder(4, 4, 4, 4));

		JLabel socialLabel = new JLabel();
		socialLabel.setPreferredSize(new Dimension(16, 16));
		socialLabel.setIcon(icon);

		/* on social-icon click mouse-event, open link to social */
		socialButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				String url = link.trim();
				SwingUtilities.invokeLater(() -> LinkBrowser.browse(url));
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				socialButton.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				socialButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		socialButton.add(socialLabel);

		return socialButton;
	}
}

package com.templeosrs.ui.clans;

import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

public class TempleClanMembers extends PluginPanel
{
	public TempleClanMembers(TempleClanMembersList leaders, TempleClanMembersList members)
	{
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(0, 0, 0, 0));

		/* tab group to switch between leaders and members */
		JPanel display = new JPanel();
		MaterialTabGroup tabGroup = new MaterialTabGroup(display);

		MaterialTab leadersTab = new MaterialTab("Leaders", tabGroup, leaders);
		MaterialTab membersTab = new MaterialTab("Members", tabGroup, members);

		tabGroup.addTab(leadersTab);
		tabGroup.addTab(membersTab);
		tabGroup.select(leadersTab);

		add(tabGroup);
		add(display);
	}
}

package com.templeosrs.ui.clans;

import com.templeosrs.TempleOSRSPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import static net.runelite.client.ui.PluginPanel.PANEL_WIDTH;

public class TempleClanMembersList extends JPanel
{
	private static final Color[] COLORS = {ColorScheme.DARK_GRAY_HOVER_COLOR, ColorScheme.DARKER_GRAY_COLOR};

	TempleClanMembersList(TempleOSRSPlugin plugin, String heading, String[] members)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new BorderLayout());
		layoutPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel clanMembers = new JPanel();
		clanMembers.setLayout(new GridLayout(0, 1));

		/* for each member in members-list */
		for (int i = 0; i < members.length; i++)
		{
			/* create a new member-row and add to clan-members list */
			TempleClanMember user = new TempleClanMember(plugin, members[i], COLORS[i % 2]);
			clanMembers.add(user);
		}

		/* add clan-members list to main layout */
		layoutPanel.add(clanMembers, BorderLayout.SOUTH);

		/* create custom border, add to (layout or scroll) */
		TitledBorder custom = BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(EtchedBorder.LOWERED, ColorScheme.DARK_GRAY_COLOR, ColorScheme.SCROLL_TRACK_COLOR), heading);
		custom.setTitleColor(ColorScheme.GRAND_EXCHANGE_LIMIT);
		custom.setTitleJustification(TitledBorder.CENTER);
		custom.setTitleFont(FontManager.getRunescapeSmallFont());

		/* if list is too large -> add scroll-pane and set preferred dimensions */
		if (members.length > 10)
		{
			setPreferredSize(new Dimension(PANEL_WIDTH, 275));

			/* create and add scroll-pane */
			final JScrollPane scroll = new JScrollPane(layoutPanel);
			scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
			scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
			scroll.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			scroll.setBorder(custom);
			add(scroll);
		}
		else
		{
			layoutPanel.setBorder(custom);
			add(layoutPanel);
		}
	}
}

package com.templeosrs;

import com.templeosrs.util.CurrentTopRanges;
import com.templeosrs.util.PlayerRanges;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("TempleOSRS")
public interface TempleOSRSConfig extends Config
{
	String TEMPLE_OSRS_CONFIG_GROUP = "TempleOSRS";

	@ConfigSection(
		name = "General",
		description = "General Options",
		position = 0
	)
	String generalOptions = "generalOptions";

	@ConfigSection(
		name = "Ranks",
		description = "Rank Options",
		position = 10
	)
	String rankOptions = "rankOptions";

	@ConfigSection(
		name = "Clans",
		description = "Clan Options",
		position = 20
	)
	String clanOptions = "clanOptions";

	@ConfigSection(
		name = "Competitions",
		description = "Competition Options",
		position = 30
	)
	String compOptions = "compOptions";

	@ConfigSection(
		name = "Collection Log",
		description = "Collection Log Options",
		position = 40
	)
	String clogOptions = "clogOptions";

	@ConfigItem(
		keyName = "autocomplete",
		name = "Autocomplete",
		description = "Toggle name prediction when typing a name to lookup",
		position = 1,
		section = generalOptions
	)
	default boolean autocomplete()
	{
		return true;
	}

	@ConfigItem(
		keyName = "playerLookup",
		name = "Player Lookup",
		description = "Toggle TempleOSRS lookup option in players' right-click menus",
		position = 2,
		section = generalOptions
	)
	default boolean playerLookup()
	{
		return false;
	}

	@ConfigItem(
		keyName = "fetchDefaults",
		name = "Fetch Defaults",
		description = "Toggle whether or not to fetch defaults on startup",
		position = 3,
		section = generalOptions
	)
	default boolean fetchDefaults()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showSidebar",
		name = "Show sidebar icon",
		description = "Display TempleOSRS plugin in the sidebar.",
		position = 4,
	    section = generalOptions
	)
	default boolean showSidebar() { return true; }

	@ConfigItem(
		keyName = "defaultPlayer",
		name = "Default Player",
		description = "Default player loaded on startup",
		position = 1,
		section = rankOptions
	)
	default String getDefaultPlayer()
	{
		return "";
	}

	@ConfigItem(
		keyName = "defaultRange",
		name = "Default Range",
		description = "Default time-period for player-ranks loaded on startup",
		position = 2,
		section = rankOptions
	)
	default PlayerRanges getDefaultRange()
	{
		return PlayerRanges.Week;
	}

	@ConfigItem(
		keyName = "autoUpdate",
		name = "Auto-Update",
		description = "Toggle whether or not to automatically update the player on TempleOSRS",
		position = 3,
		section = rankOptions
	)
	default boolean autoUpdate()
	{
		return false;
	}

	@ConfigItem(
		keyName = "clanAchievements",
		name = "Clan Achievements",
		description = "Toggle whether or not to display group-achievements when fetching group-information",
		position = 1,
		section = clanOptions
	)
	default boolean displayClanAchievements()
	{
		return true;
	}

	@ConfigItem(
		keyName = "clanMembers",
		name = "Clan Members",
		description = "Toggle whether or not to display group-members when fetching group-information",
		position = 2,
		section = clanOptions
	)
	default boolean displayClanMembers()
	{
		return false;
	}

	@ConfigItem(
		keyName = "clanCurrentTop",
		name = "Current Top Rankings",
		description = "Toggle whether or not to display weekly-top players for ehp and ehb when fetching group-information",
		position = 3,
		section = clanOptions
	)
	default boolean displayClanCurrentTop()
	{
		return true;
	}

	@ConfigItem(
		keyName = "currentTopRange",
		name = "Current Top Range",
		description = "Default time-period for current-top-ranks loaded on clan-fetch",
		position = 4,
		section = clanOptions
	)
	default CurrentTopRanges getCurrentTopRange()
	{
		return CurrentTopRanges.Week;
	}

	@ConfigItem(
		keyName = "defaultClan",
		name = "Default Clan",
		description = "Default clan loaded on startup",
		position = 5,
		section = clanOptions
	)
	default int getDefaultClan()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "clanKey",
		name = "Clan Key",
		description = "Required key to edit group-members using the TempleOSRS API",
		position = 6,
		secret = true,
		section = clanOptions
	)
	default String clanKey()
	{
		return "";
	}

	@ConfigItem(
		keyName = "ignoredRanks",
		name = "Ignored ranks",
		description = "A comma-separated list of excluded ranks from group-members sync (Case Sensitive).",
		position = 7,
		section = clanOptions
	)
	default String getIgnoredRanks()
	{
		return "";
	}

	@ConfigItem(
		keyName = "onlyAddMembers",
		name = "Only Add Members",
		description = "Toggle whether or not to only add members during clan-sync",
		position = 8,
		section = clanOptions
	)
	default boolean onlyAddMembers()
	{
		return false;
	}

	@ConfigItem(
		keyName = "defaultComp",
		name = "Default Competition",
		description = "Default competition loaded on startup",
		position = 1,
		section = compOptions
	)
	default int getDefaultComp()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "competitionWatchlist",
		name = "Competition Watchlist",
		description = "A comma-separated list of saved competition IDs.",
		position = 2,
		section = compOptions
	)
	default String getCompetitionWatchlist()
	{
		return "";
	}

	@ConfigItem(
		keyName = "competitionWatchlist",
		name = "",
		description = ""
	)
	void setCompetitionWatchlist(String key);

	@ConfigItem(
			keyName = "clogsyncbutton",
			name = "Collection Log Update Button",
			description = "Add a button to the collection log interface to update your collection log on TempleOSRS",
			position = 1,
			section = clogOptions
	)
	default boolean clogSyncButton()
	{
		return true;
	}

	@ConfigItem(
			keyName = "autoSyncClog",
			name = "Automatically sync Collection Log",
			description = "When enabled, TempleOSRS will automatically sync your collection log when you receive a new item",
			position = 2,
			section = clogOptions
	)
	default boolean autoSyncClog()
	{
		return false;
	}

	@ConfigItem(
			keyName = "enableClogChatCommand",
			name = "Enable !col chat command",
			description = "When enabled, the plugin will detect any !col chat messages and replace the contents with " +
					"TempleOSRS log data, if available",
			position = 4,
			section = clogOptions
	)
	default boolean enableClogChatCommand() { return true; }

	@Range(min = 50, max = 200)
	@ConfigItem(
			keyName = "maxCachedPlayers",
			name = "Max Cached Players",
			description = "Maximum number of players to keep in the database (excluding yourself)." +
					" The more players the more MB kept on database. " +
					"Default number of players in database is 50",
			position = 3,
			section = clogOptions
	)
	default int maxCachedPlayers() { return 50; }
}

package com.templeosrs;

import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import com.templeosrs.util.collections.autosync.LoggedInState;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.xpupdater.XpUpdaterConfig;
import net.runelite.client.ui.ClientUI;
import org.junit.jupiter.api.BeforeEach;

import java.util.concurrent.ScheduledExecutorService;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

public class MockedTest {
    @Bind
    protected final Client client = spy(Client.class);

    @Bind
    protected final RuneLiteConfig runeLiteConfig = mock(RuneLiteConfig.class);

    @Bind
    protected final ItemManager itemManager = mock(ItemManager.class);

    @Bind
    protected final ItemContainer itemContainer = mock(ItemContainer.class);

    @Bind
    protected final ItemComposition itemComposition = mock(ItemComposition.class);

    @Bind
    protected final Item item = mock(Item.class);

    @Bind
    protected final TempleOSRSConfig templeOSRSConfig = mock(TempleOSRSConfig.class);

    @Bind
    protected final ScheduledExecutorService scheduledExecutorService = spy(ScheduledExecutorService.class);
    
    @Bind
    protected final EventBus eventBus = spy(EventBus.class);

    @Bind
    protected final NPC npc = mock(NPC.class);

    @Bind
    protected final Player player = mock(Player.class);

    @Bind
    protected final ConfigManager configManager = mock(ConfigManager.class);

    @Bind
    protected final PluginManager pluginManager = mock(PluginManager.class);

    @Bind
    protected final ClientUI clientUI = mock(ClientUI.class);

    @Bind
    protected final ChatMessageManager chatMessageManager = mock(ChatMessageManager.class);

    @Bind
    protected final XpUpdaterConfig xpUpdaterConfig = mock(XpUpdaterConfig.class);

    @Bind
    protected final GameStateChanged gameStateChanged = mock(GameStateChanged.class);

    @Bind
    protected final LoggedInState loggedInState = spy(LoggedInState.class);

    @BeforeEach
    protected void beforeEach()
    {
        Guice.createInjector(BoundFieldModule.of(this));
    }
}

package com.templeosrs.collectionlog.autosync;

import com.google.inject.testing.fieldbinder.Bind;
import com.templeosrs.MockedTest;
import com.templeosrs.util.collections.autosync.CollectionLogAutoSyncManager;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;

import java.util.Arrays;

import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

public class MockedCollectionLogAutoSyncTest extends MockedTest {
    @Bind
    protected final CollectionLogAutoSyncManager collectionLogAutoSyncManager = spy(CollectionLogAutoSyncManager.class);

    @BeforeEach
    void enableAutoSyncOption()
    {
        when(templeOSRSConfig.autoSyncClog()).thenReturn(true);
    }

    @BeforeEach
    void registerWithEventBus()
    {
        collectionLogAutoSyncManager.startUp();
    }

    @AfterEach
    void unregisterWithEventBus()
    {
        collectionLogAutoSyncManager.shutDown();
    }

    void triggerNewCollectionLogItemChatMessageEvent(String itemName)
    {
        final ChatMessage chatMessage = buildChatMessage(
                ChatMessageType.GAMEMESSAGE,
                String.format("New item added to your collection log: %s", itemName)
        );

        eventBus.post(chatMessage);
    }

    void logIn()
    {
        when(loggedInState.isLoggedOut()).thenReturn(false);

        final GameStateChanged gameStateChanged = buildGameStateChangedEvent(GameState.LOGGED_IN);

        eventBus.post(gameStateChanged);
    }

    void logOut()
    {
        when(loggedInState.isLoggedOut()).thenReturn(true);

        final GameStateChanged gameStateChanged = buildGameStateChangedEvent(GameState.LOGIN_SCREEN);

        eventBus.post(gameStateChanged);
    }

    void hopWorld()
    {
        final GameStateChanged gameStateChanged = buildGameStateChangedEvent(GameState.HOPPING);

        eventBus.post(gameStateChanged);
    }

    void setCollectionLogOptionValue(int value)
    {
        final VarbitChanged varbitChanged = new VarbitChanged();

        varbitChanged.setVarbitId(VarbitID.OPTION_COLLECTION_NEW_ITEM);
        varbitChanged.setValue(value);

        eventBus.post(varbitChanged);
    }

    NpcLootReceived buildNpcLootReceivedEvent(ItemStack[] itemStacks)
    {
        for (ItemStack value : itemStacks) {
            when(itemManager.getItemComposition(value.getId())).thenReturn(itemComposition);
        }

        return new NpcLootReceived(npc, Arrays.asList(itemStacks));
    }

    ChatMessage buildChatMessage(ChatMessageType type, String message)
    {
        return new ChatMessage(null, type, "", message, "", 0);
    }

    ItemContainerChanged buildItemContainerChangedEvent(int inventoryID, Item[] items)
    {
        for (Item value : items) {
            when(itemManager.getItemComposition(value.getId())).thenReturn(itemComposition);
        }

        when(itemContainer.getItems()).thenReturn(items);

        return new ItemContainerChanged(inventoryID, itemContainer);
    }

    GameStateChanged buildGameStateChangedEvent(GameState gameState)
    {
        final GameStateChanged gameStateChanged = new GameStateChanged();

        gameStateChanged.setGameState(gameState);

        return gameStateChanged;
    }
}

package com.templeosrs.collectionlog.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.HashSet;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.mockito.Mockito.when;

public class CollectionLogAutoSyncServerNpcLootSubscriberTest extends MockedCollectionLogAutoSyncTest
{
	// In-game, the chat message triggers before the loot is received, so emulate this in the tests
	@BeforeEach
	void setupChatMessageEventAndTrigger()
	{
		triggerNewCollectionLogItemChatMessageEvent("Twisted bow");
	}

	@Test
	@DisplayName("Ensure the pending sync items list is not modified when the obtained items list is empty")
	void doesNotAddToPendingItemsWhenObtainedItemsListIsEmpty()
	{
		collectionLogAutoSyncManager.getObtainedItemNames().clear();

		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{}
		);

		eventBus.post(npcLootReceived);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the sync countdown timer is not started when the obtained items list is empty")
	void doesNotStartSyncCountdownWhenObtainedItemsListIsEmpty()
	{
		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{}
		);

		eventBus.post(npcLootReceived);

		assertNull(collectionLogAutoSyncManager.getGameTickToSync());
	}

	@Test
	@DisplayName("Ensure the pending sync items list is not modified when the loot received is not found in the obtained items list")
	void doesNotAddToPendingItemsWhenLootIsNotInObtainedItemsList()
	{
		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.BONES, 1)
			}
		);

		eventBus.post(npcLootReceived);

		assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the sync countdown timer is not started when the loot received is not found in the obtained items list")
	void doesNotStartSyncCountdownWhenLootIsNotInObtainedItemsList()
	{
		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.BONES, 1)
			}
		);

		eventBus.post(npcLootReceived);

		assertNull(collectionLogAutoSyncManager.getGameTickToSync());
	}

	@Test
	@DisplayName("Ensure the pending sync items list is modified when the loot received is found in the obtained items list")
	void addsToPendingItemsWhenLootIsInObtainedItemsList()
	{
		when(itemComposition.getName()).thenReturn("Twisted bow");

		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.TWISTED_BOW, 42)
			}
		);

		eventBus.post(npcLootReceived);

		final HashSet<ObtainedCollectionItem> expectedHashSet = new HashSet<>();
		expectedHashSet.add(new ObtainedCollectionItem(ItemID.TWISTED_BOW, "Twisted bow", 42));

		assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());
	}

	@Test
	@DisplayName("Ensure the sync countdown timer is started when the loot received is found in the obtained items list")
	void startsSyncCountdownTimerWhenLootIsInObtainedItemsList()
	{
		when(itemComposition.getName()).thenReturn("Twisted bow");
		when(client.getTickCount()).thenReturn(100);

		NpcLootReceived npcLootReceived = buildNpcLootReceivedEvent(
			new ItemStack[]{
				new ItemStack(ItemID.TWISTED_BOW, 1)
			}
		);

		eventBus.post(npcLootReceived);

		assertEquals(117, collectionLogAutoSyncManager.getGameTickToSync());
	}
}

package com.templeosrs.collectionlog.autosync;

import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

public class CollectionLogAutoSyncConfigCheckerTest extends MockedCollectionLogAutoSyncTest
{
    @Test
    @DisplayName("Ensure a warning is not displayed on login when the \"new collection log\" option is enabled")
    void doesNotEmitWarningWhenNewCollectionLogOptionIsEnabled()
    {
        setCollectionLogOptionValue(1);

        logIn();

        verify(chatMessageManager, never()).queue(any(QueuedMessage.class));
    }

    @Test
    @DisplayName("Ensure a warning is displayed on login when the \"new collection log\" option is disabled")
    void emitsWarningWhenNewCollectionLogOptionIsDisabled()
    {
        logIn();
        setCollectionLogOptionValue(0);

        verifyChatMessageHasBeenDisplayedTimes(1);
    }

    @Test
    @DisplayName("Ensure a warning is not displayed if it has already been shown for the current session")
    void doesNotEmitWarningWhenWarningHasBeenShownForCurrentSession()
    {
        logIn();
        setCollectionLogOptionValue(0);

        verifyChatMessageHasBeenDisplayedTimes(1);

        hopWorld();
        verifyChatMessageHasBeenDisplayedTimes(1);
    }

    @Test
    @DisplayName("Ensure a warning is displayed when starting a new login session when the \"new collection log\"  option is disabled")
    void emitsWarningWhenStartingNewSession()
    {
        logIn();
        setCollectionLogOptionValue(0);

        verifyChatMessageHasBeenDisplayedTimes(1);

        logOut();
        logIn();
        setCollectionLogOptionValue(0);
        verifyChatMessageHasBeenDisplayedTimes(2);
    }

    private void verifyChatMessageHasBeenDisplayedTimes(int expectedTimes)
    {
        String highlightedMessage = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append("Please enable \"Collection log - New addition notification\" in your game settings for " +
                        "TempleOSRS to automatically sync your collection log!")
                .build();

        final QueuedMessage expectedQueuedMessage = QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(highlightedMessage)
                .build();

        verify(chatMessageManager, times(expectedTimes)).queue(expectedQueuedMessage);
    }
}

package com.templeosrs.collectionlog.autosync;

import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.HashSet;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class CollectionLogAutoSyncChatMessageSubscriberTest extends MockedCollectionLogAutoSyncTest
{
    final String newCollectionLogItem = "Twisted bow";
    final String newCollectionLogItemMessage = String.format("New item added to your collection log: %s", newCollectionLogItem);

    @Test
    @DisplayName("Ensure obtained items are not modified for messages that are not ChatMessageType.GAMEMESSAGE")
    void doesNotAddToObtainedItemsForNonGameMessageMessages()
    {
        ChatMessage chatMessage = buildChatMessage(ChatMessageType.CLAN_MESSAGE, newCollectionLogItemMessage);

        eventBus.post(chatMessage);

        assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getObtainedItemNames());
    }

    @Test
    @DisplayName("Ensure obtained items are not modified for messages that do not match the new collection log item pattern")
    void doesNotAddToObtainedItemsForNonMatchingGameMessages()
    {
        ChatMessage chatMessage = buildChatMessage(ChatMessageType.GAMEMESSAGE, "Some message");

        eventBus.post(chatMessage);

        assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getObtainedItemNames());
    }

    @Test
    @DisplayName("Ensure obtained items are modified for game messages that match the new collection log item pattern")
    void addsToObtainedItemsForMatchingGameMessages()
    {
        triggerNewCollectionLogItemChatMessageEvent(newCollectionLogItem);

        HashSet<String> expectedObtainedItems = new HashSet<>();

        expectedObtainedItems.add(newCollectionLogItem);

        assertEquals(expectedObtainedItems, collectionLogAutoSyncManager.getObtainedItemNames());
    }
}

package com.templeosrs.collectionlog.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import net.runelite.api.events.GameTick;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.mockito.Mockito.*;

public class CollectionLogAutoSyncGameTickSubscriberTest extends MockedCollectionLogAutoSyncTest
{
    @Test
    @DisplayName("Ensure no request is made if the game tick to sync has not been set")
    void doesNotRequestIfGameTickToSyncIsUnset()
    {
        GameTick gameTick = new GameTick();

        collectionLogAutoSyncManager.getPendingSyncItems().add(
            new ObtainedCollectionItem(1, "Item name", 1)
        );

        eventBus.post(gameTick);

        verify(scheduledExecutorService, never()).execute(any(Runnable.class));
    }

    @Test
    @DisplayName("Ensure no request is made if the pending sync items is empty")
    void doesNotRequestIfPendingSyncItemsIsEmpty()
    {
        GameTick gameTick = new GameTick();

        collectionLogAutoSyncManager.startSyncCountdown();

        eventBus.post(gameTick);

        verify(scheduledExecutorService, never()).execute(any(Runnable.class));
    }

    @Test
    @DisplayName("Ensure a request is made if the game tick to sync is less than or equal to the client game tick, and the pending sync items list is not empty")
    void requestsIfGameTickToSyncHasPassedAndItemsArePendingSync()
    {
        GameTick gameTick = new GameTick();

        collectionLogAutoSyncManager.startSyncCountdown();
        collectionLogAutoSyncManager.getPendingSyncItems().add(
            new ObtainedCollectionItem(1, "Item name", 1)
        );

        final String username = "CousinOfKos";
        final long accountHash = 1234567890;

        when(player.getName()).thenReturn(username);
        when(client.getLocalPlayer()).thenReturn(player);
        when(client.getAccountHash()).thenReturn(accountHash);
        when(client.getTickCount()).thenReturn(100);

        eventBus.post(gameTick);

        verify(scheduledExecutorService, times(1)).execute(any(Runnable.class));
    }
}

package com.templeosrs.collectionlog.autosync;

import com.templeosrs.util.collections.data.ObtainedCollectionItem;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.HashSet;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class CollectionLogAutoSyncItemContainerChangedSubscriberTest extends MockedCollectionLogAutoSyncTest
{
    @BeforeEach
    // In-game, the chat message triggers before the inventory is updated with new items, so emulate this in the tests
    void setupChatMessageEventAndTrigger()
    {
        triggerNewCollectionLogItemChatMessageEvent("Twisted bow");
    }
    
    @Test
    @DisplayName("Ensure the pending items are not modified when the changed container is not the inventory")
    void doesNotAddToPendingItemsForNonInventoryContainers()
    {
        ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
                InventoryID.DREAM_BANK_INVENTORY,
                new Item[]{}
        );

        eventBus.post(itemContainerChanged);

        assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
    }

    @Test
    @DisplayName("Ensure the pending items are not modified when no inventory items are found in the obtained items list")
    void doesNotAddToPendingItemsWhenNoInventoryItemsMatchObtainedItems()
    {
        final Item[] mockItems = {
                new Item(ItemID.BONES, 1)
        };

        ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
                InventoryID.INV,
                mockItems
        );

        eventBus.post(itemContainerChanged);

        assertEquals(new HashSet<>(), collectionLogAutoSyncManager.getPendingSyncItems());
    }

    @Test
    @DisplayName("Ensure the pending items are modified when inventory items are found in the obtained items list")
    void addsToPendingItemsWhenInventoryItemsMatchObtainedItems()
    {
        final Item[] mockItems = {
                new Item(ItemID.TWISTED_BOW, 42)
        };

        ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
                InventoryID.INV,
                mockItems
        );

        when(itemComposition.getName()).thenReturn("Twisted bow");

        eventBus.post(itemContainerChanged);

        HashSet<ObtainedCollectionItem> expectedHashSet = new HashSet<>();
        expectedHashSet.add(new ObtainedCollectionItem(ItemID.TWISTED_BOW, "Twisted bow", 42));

        assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());
    }

    @Test
    @DisplayName("Ensure the sync countdown is started when inventory items are found in the obtained items list")
    void startsSyncCountdownWhenInventoryItemsMatchObtainedItems()
    {
        final Item[] mockItems = {
                new Item(ItemID.TWISTED_BOW, 1)
        };
        
        ItemContainerChanged itemContainerChanged = buildItemContainerChangedEvent(
                InventoryID.INV,
                mockItems
        );
        
        when(itemComposition.getName()).thenReturn("Twisted bow");
        when(client.getTickCount()).thenReturn(100);
        
        eventBus.post(itemContainerChanged);
        
        assertEquals(117, collectionLogAutoSyncManager.getGameTickToSync());
    }

    @Test
    @DisplayName("Ensure any items with duplicate names are assigned to their item ID")
    void duplicateItemNamesAreAssignedToItemId()
    {
        collectionLogAutoSyncManager.getObtainedItemNames().clear();

        triggerNewCollectionLogItemChatMessageEvent("Graceful boots");

        final Item[] mockItems = { new Item(ItemID.GRACEFUL_BOOTS, 1) };
        final HashSet<ObtainedCollectionItem> expectedHashSet = new HashSet<>();

        ItemContainerChanged itemContainerChanged = new ItemContainerChanged(InventoryID.INV, itemContainer);
        when(itemContainer.getItems()).thenReturn(mockItems);

        ItemComposition gracefulBootsItemComposition = spy(ItemComposition.class);
        when(gracefulBootsItemComposition.getName()).thenReturn("Graceful boots");
        when(itemManager.getItemComposition(ItemID.GRACEFUL_BOOTS)).thenReturn(gracefulBootsItemComposition);

        expectedHashSet.add(new ObtainedCollectionItem(ItemID.GRACEFUL_BOOTS, "Graceful boots", 1));

        eventBus.post(itemContainerChanged);

        assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());

        // Trigger another collection log event that has a duplicate name to an existing item in the inventory
        triggerNewCollectionLogItemChatMessageEvent("Graceful boots");

        final Item[] mockItems2 = {
                new Item(ItemID.GRACEFUL_BOOTS_WYRM, 1)
        };

        ItemContainerChanged itemContainerChanged2 = new ItemContainerChanged(InventoryID.INV, itemContainer);

        when(itemContainer.getItems()).thenReturn(mockItems2);

        ItemComposition gracefulBootsWyrmItemComposition = spy(ItemComposition.class);
        when(gracefulBootsWyrmItemComposition.getName()).thenReturn("Graceful boots");
        when(itemManager.getItemComposition(ItemID.GRACEFUL_BOOTS_WYRM)).thenReturn(gracefulBootsWyrmItemComposition);

        expectedHashSet.add(new ObtainedCollectionItem(ItemID.GRACEFUL_BOOTS_WYRM, "Graceful boots", 1));

        eventBus.post(itemContainerChanged2);

        assertEquals(expectedHashSet, collectionLogAutoSyncManager.getPendingSyncItems());
    }
}

package com.templeosrs;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TempleOSRSPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TempleOSRSPlugin.class);
		RuneLite.main(args);
	}
}
