package com.github.therealguru.totemfletching;

import com.github.therealguru.totemfletching.listener.PluginEventListener;
import com.github.therealguru.totemfletching.service.OverlayService;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(name = "Totem Fletching")
public class TotemFletchingPlugin extends Plugin {

    @Inject private EventBus eventBus;
    @Inject private PluginEventListener pluginEventListener;
    @Inject private OverlayService overlayService;

    @Override
    protected void startUp() throws Exception {
        eventBus.register(pluginEventListener);
        overlayService.registerOverlays();
    }

    @Override
    protected void shutDown() throws Exception {
        eventBus.unregister(pluginEventListener);
        overlayService.unregisterOverlays();
    }

    @Provides
    TotemFletchingConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TotemFletchingConfig.class);
    }
}

package com.github.therealguru.totemfletching;

import com.github.therealguru.totemfletching.model.TotemHighlightMode;
import java.awt.Color;
import net.runelite.client.config.*;

@ConfigGroup("totem-fletching")
public interface TotemFletchingConfig extends Config {

    Color RED = Color.decode("#E45F5F");
    Color GREEN = Color.decode("#9CF575");
    Color DEFAULT_TEXT_COLOR = Color.decode("#ddc2ff");

    @ConfigSection(
            name = "Overlay Settings",
            description = "Enable or disable individual overlays",
            position = 0)
    String sectionOverlays = "sectionOverlays";

    @ConfigItem(
            keyName = "renderTotemHighlight",
            name = "Show Totem Highlight",
            description = "Draw the highlight over totems",
            section = sectionOverlays,
            position = 0)
    default TotemHighlightMode renderTotemHighlight() {
        return TotemHighlightMode.OUTLINE;
    }

    @ConfigItem(
            keyName = "totemFillAlpha",
            name = "Totem Fill Opacity",
            section = sectionOverlays,
            description = "Opacity of the filled totem highlight (0-255)",
            position = 1)
    default int totemFillAlpha() {
        return 80;
    }

    @ConfigItem(
            keyName = "renderTotemText",
            name = "Show Totem Text",
            description = "Draw the text overlay over totems for animals and decorations",
            section = sectionOverlays,
            position = 2)
    default boolean renderTotemText() {
        return true;
    }

    @ConfigItem(
            keyName = "renderPoints",
            name = "Show Points Text",
            description = "Draw the text overlay over points",
            section = sectionOverlays,
            position = 3)
    default boolean renderPoints() {
        return true;
    }

    @ConfigItem(
            keyName = "renderEntTrails",
            name = "Show Ent Trails",
            description =
                    "Whether to show the ent trails that need to be stepped on for bonus points",
            section = sectionOverlays,
            position = 4)
    default boolean renderEntTrails() {
        return true;
    }

    @ConfigItem(
            keyName = "highlightCorrectCarvingChoice",
            name = "Highlight Correct Carving Choices",
            description = "Highlight which animals to select in the totem carving interface",
            section = sectionOverlays,
            position = 5)
    default boolean highlightCorrectCarvingChoice() {
        return true;
    }

    @ConfigItem(
            keyName = "maskIncorrectCarvingChoice",
            name = "Mask Incorrect Carving Choices",
            description = "Mask the incorrect animals in the totem carving interface",
            section = sectionOverlays,
            position = 6)
    default boolean maskIncorrectCarvingChoice() {
        return true;
    }

    @ConfigItem(
            keyName = "renderPanel",
            name = "Show widget",
            description = "Show a helper widget when doing Totem fletching",
            section = sectionOverlays,
            position = 7)
    default boolean renderPanel() {
        return false;
    }

    @ConfigItem(
            keyName = "showTotemId",
            name = "Show Totem Id's",
            description =
                    "Use this to help you  determine which totem is which for notification settings",
            section = sectionOverlays,
            position = 8)
    default boolean showTotemId() {
        return false;
    }

    @ConfigSection(
            name = "Color Settings",
            description = "Pick colors for each overlay element",
            position = 1)
    String sectionColors = "sectionColors";

    @ConfigItem(
            keyName = "totemCompleteColor",
            name = "Complete Totem",
            description = "Choose the color used for the highlight on complete totems",
            section = sectionColors,
            position = 0)
    default Color totemCompleteColor() {
        return GREEN;
    }

    @ConfigItem(
            keyName = "totemIncompleteColor",
            name = "Incomplete Totem",
            description = "Choose the color used for the highlight on incomplete totems",
            section = sectionColors,
            position = 1)
    default Color totemIncompleteColor() {
        return RED;
    }

    @ConfigItem(
            keyName = "totemTextColor",
            name = "Totem Text",
            description = "Choose the color used for the text on the totem overlays",
            section = sectionColors,
            position = 2)
    default Color totemTextColor() {
        return DEFAULT_TEXT_COLOR;
    }

    @ConfigItem(
            keyName = "pointsTextColor",
            name = "Points Text",
            description = "Choose the color used for the text on the points overlays",
            section = sectionColors,
            position = 3)
    default Color pointsTextColor() {
        return DEFAULT_TEXT_COLOR;
    }

    @ConfigItem(
            keyName = "pointsCappedColor",
            name = "Points Tile at Maximum",
            description =
                    "Choose the color used to highlight the points tile if the maximum point total has been reached",
            section = sectionColors,
            position = 4)
    default Color pointsCappedColor() {
        return RED;
    }

    @ConfigItem(
            keyName = "entTrailColor",
            name = "Ent Trail",
            description = "Choose the color used to draw ent trails",
            section = sectionColors,
            position = 5)
    default Color entTrailColor() {
        return Color.decode("#e4fff6");
    }

    @ConfigItem(
            keyName = "carvingHighlightColor",
            name = "Carving Highlight",
            description =
                    "Choose the color used to highlight the correct choices in the carving interface",
            section = sectionColors,
            position = 6)
    default Color carvingHighlightColor() {
        return Color.decode("#9CF575");
    }

    @ConfigItem(
            keyName = "carvingHighlightBorderWidth",
            name = "Carving Highlight Border Width",
            description = "Select the border width for the correct choices",
            section = sectionColors,
            position = 7)
    @Units(Units.PIXELS)
    @Range(min = 1, max = 10)
    default int carvingHighlightBorderWidth() {
        return 2;
    }

    @ConfigItem(
            keyName = "carvingMaskColor",
            name = "Carving Mask",
            description = "Choose the color to mask the incorrect choices in the carving interface",
            section = sectionColors,
            position = 8)
    @Alpha
    default Color carvingMaskColor() {
        return new Color(64, 64, 64, 204);
    }

    @ConfigSection(
            name = "Additional Settings",
            description = "Customize additional accessibility settings",
            closedByDefault = true,
            position = 2)
    String sectionAdditional = "sectionAdditional";

    @ConfigItem(
            keyName = "keepDecoratedText",
            name = "Keep Fully Decorated Text",
            description = "Show the text on a fully decorated totem",
            section = sectionAdditional,
            position = 0)
    default boolean keepDecoratedText() {
        return false;
    }

    @ConfigItem(
            keyName = "showZeroPoints",
            name = "Show Zero Points",
            description = "Show the points text even if the points are zero",
            section = sectionAdditional,
            position = 1)
    default boolean showZeroPoints() {
        return true;
    }

    @ConfigItem(
            keyName = "unbuiltOffset",
            name = "Unbuilt Totem Offset",
            description = "Choose how high the unbuilt totem text will be from the ground",
            section = sectionAdditional,
            position = 2)
    @Units(Units.PIXELS)
    @Range(max = 800)
    default int unbuiltOffset() {
        return 160;
    }

    @ConfigItem(
            keyName = "builtOffset",
            name = "Built Totem Offset",
            description = "Choose how high the built totem text will be from the ground",
            section = sectionAdditional,
            position = 3)
    @Units(Units.PIXELS)
    @Range(max = 800)
    default int builtOffset() {
        return 160;
    }

    @ConfigItem(
            keyName = "pointsOffset",
            name = "Points Offset",
            description = "Choose how high the points text will be from the ground",
            section = sectionAdditional,
            position = 4)
    @Units(Units.PIXELS)
    @Range(max = 800)
    default int pointsOffset() {
        return 16;
    }

    @ConfigSection(
            name = "Notification Settings",
            description = "Enable/Disable Totem Decay Notifications",
            position = 3)
    String sectionNotifications = "sectionNotifications";

    @ConfigItem(
            keyName = "notificationDecayTotem1",
            name = "Notification for Totem 1 Decay",
            description =
                    "This notification will trigger when totem 1 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 0)
    default Notification notificationDecayTotem1() {
        return Notification.OFF;
    }

    @ConfigItem(
            keyName = "notificationDecayTotem2",
            name = "Notification for Totem 2 Decay",
            description =
                    "This notification will trigger when totem 2 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 1)
    default Notification notificationDecayTotem2() {
        return Notification.OFF;
    }

    @ConfigItem(
            keyName = "notificationDecayTotem3",
            name = "Notification for Totem 3 Decay",
            description =
                    "This notification will trigger when totem 3 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 2)
    default Notification notificationDecayTotem3() {
        return Notification.OFF;
    }

    @ConfigItem(
            keyName = "notificationDecayTotem4",
            name = "Notification for Totem 4 Decay",
            description =
                    "This notification will trigger when totem 4 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 3)
    default Notification notificationDecayTotem4() {
        return Notification.OFF;
    }

    @ConfigItem(
            keyName = "notificationDecayTotem5",
            name = "Notification for Totem 5 Decay",
            description =
                    "This notification will trigger when totem 5 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 4)
    default Notification notificationDecayTotem5() {
        return Notification.OFF;
    }

    @ConfigItem(
            keyName = "notificationDecayTotem6",
            name = "Notification for Totem 6 Decay",
            description =
                    "This notification will trigger when totem 6 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 5)
    default Notification notificationDecayTotem6() {
        return Notification.OFF;
    }

    @ConfigItem(
            keyName = "notificationDecayTotem7",
            name = "Notification for Totem 7 Decay",
            description =
                    "This notification will trigger when totem 7 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 6)
    default Notification notificationDecayTotem7() {
        return Notification.OFF;
    }

    @ConfigItem(
            keyName = "notificationDecayTotem8",
            name = "Notification for Totem 8 Decay",
            description =
                    "This notification will trigger when totem 8 has decayed. Enable totem id's to see which totem this is.",
            section = sectionNotifications,
            position = 7)
    default Notification notificationDecayTotem8() {
        return Notification.OFF;
    }
}

package com.github.therealguru.totemfletching.model;

public enum TotemTier {
    LOW,
    MID,
    TOP
}

package com.github.therealguru.totemfletching.model;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.config.Notification;

@Getter
@Setter
public class Totem {

    private static final int MAXIMUM_POINTS = 15000;

    private int totemId;
    private int totemGameObjectId;
    private int pointsGameObjectId;
    private int startingVarbit;
    private Notification notification;
    private GameObject totemGameObject;
    private GameObject pointsGameObject;
    private boolean carved = false;
    private int decoration = 0;
    private int decay = 0;
    private int base = 0;
    private int[] animals = new int[3];
    private Map<TotemTier, Integer> progress = new HashMap<>();
    private int points = 0;

    public Totem(
            int totemId,
            int totemGameObjectId,
            int pointsGameObjectId,
            int startingVarbit,
            Notification notification) {
        this.totemId = totemId;
        this.totemGameObjectId = totemGameObjectId;
        this.pointsGameObjectId = pointsGameObjectId;
        this.startingVarbit = startingVarbit;
        this.notification = notification;
        this.progress.put(TotemTier.LOW, 0);
        this.progress.put(TotemTier.MID, 0);
        this.progress.put(TotemTier.TOP, 0);
    }

    public boolean hasTotemStarted() {
        return base != 0;
    }

    public boolean isBuildingTotem() {
        return base >= 1 && base <= 6;
    }

    public boolean isDecorated() {
        return decoration == 4;
    }

    private int getValue(TotemTier totemTier) {
        return progress.getOrDefault(totemTier, 0);
    }

    public int getPoints() {
        return points;
    }

    public boolean isBottomComplete() {
        return getValue(TotemTier.LOW) > 4;
    }

    public boolean isMiddleComplete() {
        return getValue(TotemTier.MID) > 4;
    }

    public boolean isTopComplete() {
        return getValue(TotemTier.TOP) > 4;
    }

    public boolean isVarbitRelated(int varbit) {
        return varbit >= startingVarbit && varbit <= (startingVarbit + 17);
    }

    public boolean isRenderable(Client client) {
        return totemGameObject != null
                && pointsGameObject != null
                && TotemRegion.isInsideAuburnvale(client.getLocalPlayer().getWorldLocation());
    }

    public boolean isPointCapped() {
        return points >= MAXIMUM_POINTS;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Totem totem = (Totem) o;
        return totemId == totem.totemId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(totemId);
    }
}

package com.github.therealguru.totemfletching.model;

import java.util.Arrays;

public enum TotemVarbit {
    BASE(0),
    BASE_CARVED(1),
    BASE_MULTILOC(2),
    LOW(3),
    MID(4),
    TOP(5),
    DECORATIONS(6),
    ANIMAL_1(7),
    ANIMAL_2(8),
    ANIMAL_3(9),
    DECAY(10),
    POINTS(11),
    MULTIANIMAL_A_1(12),
    MULTIANIMAL_B_1(13),
    MULTIANIMAL_C_1(14),
    MULTIANIMAL_D_1(15),
    MULTIANIMAL_E_1(16),
    ALL_MULTIANIMALS(17);

    private int relativeVarbit;

    TotemVarbit(int relativeVarbit) {
        this.relativeVarbit = relativeVarbit;
    }

    public int getRealVarbit(Totem totem) {
        return totem.getStartingVarbit() + this.relativeVarbit;
    }

    public static TotemVarbit getVarbit(Totem totem, int varbit) {
        return Arrays.stream(TotemVarbit.values())
                .filter(totemVarbit -> totemVarbit.getRealVarbit(totem) == varbit)
                .findFirst()
                .orElse(null);
    }
}

package com.github.therealguru.totemfletching.model;

public enum TotemHighlightMode {
    NONE,
    OUTLINE,
    FILL
}

package com.github.therealguru.totemfletching.model;

import java.awt.Polygon;
import net.runelite.api.coords.WorldPoint;

public class TotemRegion {
    public static final Polygon AUBURNVALE_POLYGON = new Polygon();

    // Slightly modified Wiki polyline of Auburn Valley
    static {
        AUBURNVALE_POLYGON.addPoint(1344, 3297);
        AUBURNVALE_POLYGON.addPoint(1333, 3312);
        AUBURNVALE_POLYGON.addPoint(1333, 3322);
        AUBURNVALE_POLYGON.addPoint(1325, 3330);
        AUBURNVALE_POLYGON.addPoint(1325, 3333);
        AUBURNVALE_POLYGON.addPoint(1330, 3338);
        AUBURNVALE_POLYGON.addPoint(1330, 3348);
        AUBURNVALE_POLYGON.addPoint(1340, 3348);
        AUBURNVALE_POLYGON.addPoint(1348, 3356);
        AUBURNVALE_POLYGON.addPoint(1348, 3380);
        AUBURNVALE_POLYGON.addPoint(1380, 3400);
        AUBURNVALE_POLYGON.addPoint(1400, 3400);
        AUBURNVALE_POLYGON.addPoint(1418, 3394);
        AUBURNVALE_POLYGON.addPoint(1480, 3364);
        AUBURNVALE_POLYGON.addPoint(1504, 3364);
        AUBURNVALE_POLYGON.addPoint(1504, 3312);
        AUBURNVALE_POLYGON.addPoint(1484, 3312);
        AUBURNVALE_POLYGON.addPoint(1468, 3304);
        AUBURNVALE_POLYGON.addPoint(1460, 3296);
        AUBURNVALE_POLYGON.addPoint(1460, 3292);
        AUBURNVALE_POLYGON.addPoint(1448, 3286);
        AUBURNVALE_POLYGON.addPoint(1421, 3286);
        AUBURNVALE_POLYGON.addPoint(1421, 3275);
        AUBURNVALE_POLYGON.addPoint(1411, 3270);
        AUBURNVALE_POLYGON.addPoint(1402, 3270);
        AUBURNVALE_POLYGON.addPoint(1402, 3268);
        AUBURNVALE_POLYGON.addPoint(1401, 3267);
        AUBURNVALE_POLYGON.addPoint(1401, 3266);
        AUBURNVALE_POLYGON.addPoint(1400, 3266);
        AUBURNVALE_POLYGON.addPoint(1400, 3263);
        AUBURNVALE_POLYGON.addPoint(1399, 3262);
        AUBURNVALE_POLYGON.addPoint(1399, 3259);
        AUBURNVALE_POLYGON.addPoint(1365, 3259);
    }

    public static boolean isInsideAuburnvale(WorldPoint point) {
        return AUBURNVALE_POLYGON.contains(point.getX(), point.getY());
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.TotemFletchingPlugin;
import com.github.therealguru.totemfletching.model.TotemRegion;
import com.github.therealguru.totemfletching.service.ResearchPointService;
import com.github.therealguru.totemfletching.service.TotemService;
import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class PanelOverlay extends OverlayPanel {
    private final Client client;
    private final TotemFletchingConfig config;
    private final ResearchPointService pointService;
    private final TotemService totemService;

    @Inject
    public PanelOverlay(
            TotemFletchingPlugin plugin,
            TotemFletchingConfig config,
            TotemService totemService,
            ResearchPointService pointService,
            Client client) {
        super(plugin);
        this.client = client;
        this.config = config;
        this.pointService = pointService;
        this.totemService = totemService;
        setPosition(OverlayPosition.TOP_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.renderPanel()) return null;

        if (!TotemRegion.isInsideAuburnvale(client.getLocalPlayer().getWorldLocation()))
            return null;

        panelComponent.getChildren().add(TitleComponent.builder().text("Vale Totems").build());

        panelComponent
                .getChildren()
                .add(
                        LineComponent.builder()
                                .left("Unclaimed offerings:")
                                .right(String.valueOf(totemService.getTotalPoints()))
                                .build());

        panelComponent
                .getChildren()
                .add(
                        LineComponent.builder()
                                .left("Research points:")
                                .right(String.valueOf(pointService.getResearchPoints()))
                                .build());

        return super.render(graphics);
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.TotemFletchingPlugin;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemHighlightMode;
import com.github.therealguru.totemfletching.service.TotemService;
import java.awt.*;
import java.util.Map;
import java.util.Optional;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
public class TotemFletchingOverlay extends Overlay {

    private final TotemService totemService;
    private final Client client;
    private final TotemFletchingConfig config;

    @Inject
    public TotemFletchingOverlay(
            TotemFletchingPlugin plugin,
            TotemFletchingConfig config,
            TotemService totemService,
            Client client) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.totemService = totemService;
        this.client = client;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        totemService.getTotems().stream()
                .filter(totem -> totem.isRenderable(client))
                .forEach((totem) -> renderTotem(graphics2D, totem));
        return null;
    }

    void renderTotem(Graphics2D graphics2D, Totem totem) {
        renderTotemHighlight(graphics2D, totem);
        renderPointsOverlay(graphics2D, totem);

        if (config.renderTotemText()) {
            Optional<String> totemText = getTotemText(totem);
            if (totemText.isPresent()) {
                String text = totemText.get();
                Point canvasPoint = getTotemCanvasPoint(graphics2D, totem, text);
                if (canvasPoint != null) {
                    OverlayUtil.renderTextLocation(
                            graphics2D, canvasPoint, text, config.totemTextColor());
                }
            }
        }
    }

    private void renderTotemHighlight(Graphics2D graphics2D, Totem totem) {

        TotemHighlightMode mode = config.renderTotemHighlight();
        if (mode == TotemHighlightMode.NONE) return;

        if (totem.hasTotemStarted()) {
            Shape shape = totem.getTotemGameObject().getClickbox();
            if (shape != null) {
                final Color highlight = getTotemColor(totem);

                if (mode == TotemHighlightMode.FILL) {
                    final int alpha = config.totemFillAlpha();
                    final Color fill =
                            new Color(
                                    highlight.getRed(),
                                    highlight.getGreen(),
                                    highlight.getBlue(),
                                    alpha);

                    graphics2D.setRenderingHint(
                            RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                    final Composite oldComposite = graphics2D.getComposite();
                    final Color oldColor = graphics2D.getColor();

                    graphics2D.setComposite(AlphaComposite.SrcOver);
                    graphics2D.setColor(fill);
                    graphics2D.fill(shape);

                    graphics2D.setColor(oldColor);
                    graphics2D.setComposite(oldComposite);
                }

                OverlayUtil.renderPolygon(graphics2D, shape, highlight);
            }
        } else {
            OverlayUtil.renderTileOverlay(
                    graphics2D, totem.getTotemGameObject(), null, config.totemIncompleteColor());
        }
    }

    Optional<String> getTotemText(Totem totem) {
        if (totem.isCarved() && totem.isDecorated() && !config.keepDecoratedText()) {
            return Optional.empty();
        }

        String baseText = totem.isCarved() ? totem.getDecoration() + " / 4" : getAnimalText(totem);

        return Optional.of(appendTotemId(baseText, totem.getTotemId()));
    }

    private String appendTotemId(String text, int totemId) {
        return config.showTotemId() ? text + " [id: " + totemId + "]" : text;
    }

    private String getAnimalText(final Totem totem) {
        Map<Integer, Boolean> animalData = totemService.getCarvedAnimalsStatus(totem);
        StringBuilder text = new StringBuilder();
        for (Map.Entry<Integer, Boolean> entry : animalData.entrySet()) {
            if (entry.getValue()) continue;

            text.append(entry.getKey()).append(" ");
        }
        return text.toString().trim();
    }

    public Color getTotemColor(Totem totem) {
        return totem.isCarved() && totem.isDecorated()
                ? config.totemCompleteColor()
                : config.totemIncompleteColor();
    }

    void renderPointsOverlay(Graphics2D graphics2D, Totem totem) {
        if (!config.renderPoints() || (totem.getPoints() == 0 && !config.showZeroPoints())) return;

        renderPointsTile(graphics2D, totem);
        renderPointsText(graphics2D, totem);
    }

    void renderPointsText(Graphics2D graphics2D, Totem totem) {
        final GameObject gameObject = totem.getPointsGameObject();
        final LocalPoint localPoint =
                LocalPoint.fromWorld(client.getTopLevelWorldView(), gameObject.getWorldLocation());
        if (localPoint == null) return;

        String text = getPointsText(totem);
        Point canvasPoint =
                gameObject.getCanvasTextLocation(graphics2D, text, config.pointsOffset());
        if (canvasPoint == null) return;

        OverlayUtil.renderTextLocation(graphics2D, canvasPoint, text, config.pointsTextColor());
    }

    void renderPointsTile(Graphics2D graphics2D, Totem totem) {
        if (!totem.isPointCapped()) return;

        OverlayUtil.renderTileOverlay(
                graphics2D, totem.getPointsGameObject(), null, config.pointsCappedColor());
    }

    private String getPointsText(Totem totem) {
        return totem.isPointCapped() ? "MAXIMUM" : Integer.toString(totem.getPoints());
    }

    private Point getTotemCanvasPoint(Graphics2D graphics2D, Totem totem, String text) {
        if (totem.hasTotemStarted()) {
            return totem.getTotemGameObject()
                    .getCanvasTextLocation(graphics2D, text, config.builtOffset());
        } else {
            return totem.getTotemGameObject()
                    .getCanvasTextLocation(graphics2D, text, config.unbuiltOffset());
        }
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.service.TotemService;
import java.awt.*;
import java.util.Map;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
public class CarvingActionOverlay extends Overlay {

    private static final int TOTEM_CARVING_TEXT_WIDGET = InterfaceID.Skillmulti.TITLE;
    private static final int FIRST_CARVING_WIDGET = InterfaceID.Skillmulti.A;
    private static final int ANIMAL_COUNT = 5;
    private static final String ACTION_TEXT = "What animal would you like to carve?";

    private final Client client;
    private final TotemService totemService;
    private final TotemFletchingConfig config;

    @Inject
    public CarvingActionOverlay(TotemService service, TotemFletchingConfig config, Client client) {
        super();
        this.client = client;
        this.totemService = service;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(.6F);
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (!config.highlightCorrectCarvingChoice() && !config.maskIncorrectCarvingChoice())
            return null;

        if (!isCarvingWidget()) return null;

        totemService.getClosestTotem().ifPresent(totem -> renderCarvingChoices(graphics2D, totem));

        return null;
    }

    private void renderCarvingChoices(Graphics2D graphics2D, Totem totem) {
        Map<Integer, Boolean> carvedState = totemService.getCarvedAnimalsStatus(totem);
        for (int i = 0; i < ANIMAL_COUNT; i++) {
            Widget carvingWidget = client.getWidget(FIRST_CARVING_WIDGET + i);
            if (carvingWidget != null && !carvingWidget.isHidden()) {
                // If the choice doesn't exist then we default to true (this just means the animal
                // is an incorrect choice).
                boolean isCarvedOrIncorrectChoice = carvedState.getOrDefault(i + 1, true);
                renderOverlay(graphics2D, carvingWidget, !isCarvedOrIncorrectChoice);
            }
        }
    }

    private void renderOverlay(Graphics2D graphics, Widget carvingWidget, boolean correctChoice) {
        Rectangle bounds = carvingWidget.getBounds();
        if (bounds != null) {
            if (correctChoice && config.highlightCorrectCarvingChoice()) {
                graphics.setColor(config.carvingHighlightColor());
                graphics.setStroke(new BasicStroke(config.carvingHighlightBorderWidth()));
                graphics.draw(bounds);
            } else if (!correctChoice && config.maskIncorrectCarvingChoice()) {
                graphics.setColor(config.carvingMaskColor());
                graphics.fill(bounds);
            }
        }
    }

    private boolean isCarvingWidget() {
        Widget titleWidget = client.getWidget(TOTEM_CARVING_TEXT_WIDGET);
        return titleWidget != null
                && titleWidget.getText() != null
                && titleWidget.getText().equalsIgnoreCase(ACTION_TEXT);
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.TotemFletchingPlugin;
import com.github.therealguru.totemfletching.model.TotemRegion;
import com.github.therealguru.totemfletching.service.EntTrailService;
import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class EntTrailOverlay extends Overlay {
    private final EntTrailService service;
    private final TotemFletchingConfig config;
    private final Client client;

    @Inject
    public EntTrailOverlay(
            TotemFletchingPlugin plugin,
            TotemFletchingConfig config,
            EntTrailService service,
            Client client) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.service = service;
        this.config = config;
        this.client = client;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.renderEntTrails()) {
            return null;
        }

        if (!TotemRegion.isInsideAuburnvale(client.getLocalPlayer().getWorldLocation()))
            return null;

        for (GameObject object : service.getInactiveEntTrails()) {
            if (object == null) continue;
            renderEntTrail(object, graphics);
        }
        return null;
    }

    void renderEntTrail(final GameObject gameObject, Graphics2D graphics2D) {
        OverlayUtil.renderTileOverlay(graphics2D, gameObject, null, config.entTrailColor());
    }
}

package com.github.therealguru.totemfletching.listener;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.service.EntTrailService;
import com.github.therealguru.totemfletching.service.ResearchPointService;
import com.github.therealguru.totemfletching.service.TotemService;
import javax.inject.Inject;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.*;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class PluginEventListener {

    private final Client client;
    private final TotemService totemService;
    private final EntTrailService entTrailService;
    private final ResearchPointService researchPointService;
    private final TotemFletchingConfig config;

    @Subscribe
    public void onVarbitChanged(final VarbitChanged varbitChanged) {
        if (varbitChanged.getVarbitId() == VarPlayerID.ENT_TOTEMS_RESEARCH_POINTS) {
            researchPointService.onVarbitChanged();
        }
        if (varbitChanged.getVarbitId() < VarbitID.ENT_TOTEMS_SITE_1_BASE
                || varbitChanged.getVarbitId() > VarbitID.ENT_TOTEMS_SITE_8_ALL_MULTIANIMALS)
            return;

        totemService.onVarbitChanged(varbitChanged);
    }

    @Subscribe
    public void onGameObjectSpawned(final GameObjectSpawned gameObjectSpawned) {
        totemService.addGameObject(gameObjectSpawned.getGameObject());
        entTrailService.addEntTrail(gameObjectSpawned);
    }

    @Subscribe
    public void onGameObjectDespawned(final GameObjectDespawned gameObjectDespawned) {
        totemService.removeGameObject(gameObjectDespawned.getGameObject());
        entTrailService.removeEntTrail(gameObjectDespawned);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState().equals(GameState.LOADING)) {
            totemService.clearGameObjects();
            entTrailService.clearEntTrails();
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        log.debug("Config has reloaded {}", config.notificationDecayTotem2());
        totemService.onConfigChange(config);
    }

    @Subscribe
    public void onGameTick(final GameTick gameTick) {
        totemService.updateClosestTotem(client.getLocalPlayer());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.events.VarbitChanged;

@RequiredArgsConstructor
public abstract class TotemAction {

    @Getter private final TotemVarbit varbit;

    public abstract void onVarbitChanged(Totem totem, VarbitChanged varbitChanged);
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.Notifier;

@Slf4j
public class BaseAction extends TotemAction {

    private final Notifier notifier;

    public BaseAction(Notifier notifier) {
        super(TotemVarbit.BASE);
        this.notifier = notifier;
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setBase(varbitChanged.getValue());
        if (varbitChanged.getValue() == 0) {
            log.debug("Totem {} has decayed", totem.getTotemId());
            notifier.notify(
                    totem.getNotification(), "Totem " + totem.getTotemId() + " has decayed");
        }
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemTier;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class TotemTierAction extends TotemAction {

    private final TotemTier totemTier;

    public TotemTierAction(TotemTier tier) {
        super(TotemVarbit.valueOf(tier.name()));
        this.totemTier = tier;
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.getProgress().put(totemTier, varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class DecorationsAction extends TotemAction {

    public DecorationsAction() {
        super(TotemVarbit.DECORATIONS);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setDecoration(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class DecayAction extends TotemAction {

    public DecayAction() {
        super(TotemVarbit.DECAY);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setDecay(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class AnimalAction extends TotemAction {

    private final int animal;

    public AnimalAction(int animal) {
        super(TotemVarbit.valueOf("ANIMAL_" + animal));
        this.animal = animal;
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.getAnimals()[animal - 1] = varbitChanged.getValue();
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class BaseCarvedAction extends TotemAction {

    public BaseCarvedAction() {
        super(TotemVarbit.BASE_CARVED);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setCarved(varbitChanged.getValue() == 1);
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class PointsAction extends TotemAction {

    public PointsAction() {
        super(TotemVarbit.POINTS);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setPoints(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;

@Slf4j
@Singleton
public class EntTrailService {

    private static final List<Integer> ENT_TRAIL_GAME_OBJECT_IDS = List.of(57115, 57116);
    private static final List<Integer> ENT_TRAIL_INACTIVE_ANIMATION_IDS = List.of(12344, 12345);
    private static final List<Integer> ENT_TRAIL_ACTIVE_ANIMATION_IDS = List.of(12346);

    private final List<GameObject> entTrails = new ArrayList<>();

    public List<GameObject> getInactiveEntTrails() {
        return entTrails.stream().filter(this::isInactiveEntTrail).collect(Collectors.toList());
    }

    private boolean isInactiveEntTrail(GameObject entTrail) {
        if (!(entTrail.getRenderable() instanceof DynamicObject)) {
            return false;
        }

        DynamicObject dynamicObject = (DynamicObject) entTrail.getRenderable();
        if (dynamicObject.getAnimation() == null) {
            return false;
        }

        return ENT_TRAIL_INACTIVE_ANIMATION_IDS.contains(dynamicObject.getAnimation().getId());
    }

    public void addEntTrail(GameObjectSpawned spawned) {
        if (!isEntTrail(spawned.getGameObject())) return;

        entTrails.add(spawned.getGameObject());
    }

    public void removeEntTrail(GameObjectDespawned despawned) {
        entTrails.remove(despawned.getGameObject());
    }

    private boolean isEntTrail(GameObject gameObject) {
        return ENT_TRAIL_GAME_OBJECT_IDS.contains(gameObject.getId());
    }

    public void clearEntTrails() {
        this.entTrails.clear();
    }
}

package com.github.therealguru.totemfletching.service;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarPlayerID;

public class ResearchPointService {

    private final Client client;
    private final TotemFletchingConfig config;
    private Integer researchPoints;

    @Inject
    public ResearchPointService(TotemFletchingConfig config, Client client) {
        this.client = client;
        this.config = config;
    }

    public void onVarbitChanged() {
        if (!config.renderPanel()) return;
        researchPoints = client.getVarpValue(VarPlayerID.ENT_TOTEMS_RESEARCH_POINTS);
    }

    public int getResearchPoints() {
        if (researchPoints == null) {
            researchPoints = client.getVarpValue(VarPlayerID.ENT_TOTEMS_RESEARCH_POINTS);
        }
        return researchPoints;
    }
}

package com.github.therealguru.totemfletching.service;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.action.*;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemTier;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameObject;
import net.runelite.api.Player;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.Notifier;

@Slf4j
@Singleton
public class TotemService {

    private final Map<TotemVarbit, TotemAction> totemActions;
    @Getter private final List<Totem> totems;
    @Getter private Optional<Totem> closestTotem = Optional.empty();

    @Inject
    public TotemService(TotemFletchingConfig config, Notifier notifier) {
        this.totemActions = initializeTotemActions(notifier);
        this.totems = initializeTotems(config);
    }

    private Map<TotemVarbit, TotemAction> initializeTotemActions(Notifier notifier) {
        Map<TotemVarbit, TotemAction> actions = new HashMap<>();
        actions.put(TotemVarbit.ANIMAL_1, new AnimalAction(1));
        actions.put(TotemVarbit.ANIMAL_2, new AnimalAction(2));
        actions.put(TotemVarbit.ANIMAL_3, new AnimalAction(3));
        actions.put(TotemVarbit.BASE, new BaseAction(notifier));
        actions.put(TotemVarbit.BASE_CARVED, new BaseCarvedAction());
        actions.put(TotemVarbit.DECAY, new DecayAction());
        actions.put(TotemVarbit.DECORATIONS, new DecorationsAction());
        actions.put(TotemVarbit.POINTS, new PointsAction());
        actions.put(TotemVarbit.LOW, new TotemTierAction(TotemTier.LOW));
        actions.put(TotemVarbit.MID, new TotemTierAction(TotemTier.MID));
        actions.put(TotemVarbit.TOP, new TotemTierAction(TotemTier.TOP));
        return actions;
    }

    private List<Totem> initializeTotems(TotemFletchingConfig config) {
        return List.of(
                new Totem(
                        1,
                        ObjectID.ENT_TOTEMS_SITE_1_BASE,
                        ObjectID.ENT_TOTEMS_SITE_1_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_1_BASE,
                        config.notificationDecayTotem1()),
                new Totem(
                        2,
                        ObjectID.ENT_TOTEMS_SITE_2_BASE,
                        ObjectID.ENT_TOTEMS_SITE_2_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_2_BASE,
                        config.notificationDecayTotem2()),
                new Totem(
                        3,
                        ObjectID.ENT_TOTEMS_SITE_3_BASE,
                        ObjectID.ENT_TOTEMS_SITE_3_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_3_BASE,
                        config.notificationDecayTotem3()),
                new Totem(
                        4,
                        ObjectID.ENT_TOTEMS_SITE_4_BASE,
                        ObjectID.ENT_TOTEMS_SITE_4_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_4_BASE,
                        config.notificationDecayTotem4()),
                new Totem(
                        5,
                        ObjectID.ENT_TOTEMS_SITE_5_BASE,
                        ObjectID.ENT_TOTEMS_SITE_5_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_5_BASE,
                        config.notificationDecayTotem5()),
                new Totem(
                        6,
                        ObjectID.ENT_TOTEMS_SITE_6_BASE,
                        ObjectID.ENT_TOTEMS_SITE_6_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_6_BASE,
                        config.notificationDecayTotem6()),
                new Totem(
                        7,
                        ObjectID.ENT_TOTEMS_SITE_7_BASE,
                        ObjectID.ENT_TOTEMS_SITE_7_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_7_BASE,
                        config.notificationDecayTotem7()),
                new Totem(
                        8,
                        ObjectID.ENT_TOTEMS_SITE_8_BASE,
                        ObjectID.ENT_TOTEMS_SITE_8_OFFERINGS,
                        VarbitID.ENT_TOTEMS_SITE_8_BASE,
                        config.notificationDecayTotem8()));
    }

    public void onConfigChange(TotemFletchingConfig config) {
        this.totems.get(0).setNotification(config.notificationDecayTotem1());
        this.totems.get(1).setNotification(config.notificationDecayTotem2());
        this.totems.get(2).setNotification(config.notificationDecayTotem3());
        this.totems.get(3).setNotification(config.notificationDecayTotem4());
        this.totems.get(4).setNotification(config.notificationDecayTotem5());
        this.totems.get(5).setNotification(config.notificationDecayTotem6());
        this.totems.get(6).setNotification(config.notificationDecayTotem7());
        this.totems.get(7).setNotification(config.notificationDecayTotem8());
    }

    public void onVarbitChanged(final VarbitChanged varbitChanged) {
        findTotemByVarbit(varbitChanged.getVarbitId())
                .ifPresent(
                        totem -> {
                            TotemVarbit totemVarbit =
                                    TotemVarbit.getVarbit(totem, varbitChanged.getVarbitId());
                            TotemAction action = totemActions.get(totemVarbit);
                            if (action != null) {
                                action.onVarbitChanged(totem, varbitChanged);
                            }
                        });
    }

    private Optional<Totem> findTotemByVarbit(int varbitId) {
        return totems.stream().filter(t -> t.isVarbitRelated(varbitId)).findFirst();
    }

    public void addGameObject(final GameObject gameObject) {
        for (Totem totem : totems) {
            if (totem.getTotemGameObjectId() == gameObject.getId()) {
                totem.setTotemGameObject(gameObject);
            } else if (totem.getPointsGameObjectId() == gameObject.getId()) {
                totem.setPointsGameObject(gameObject);
            }
        }
    }

    public void removeGameObject(final GameObject gameObject) {
        for (Totem totem : totems) {
            if (totem.getTotemGameObjectId() == gameObject.getId()) {
                totem.setTotemGameObject(null);
            } else if (totem.getPointsGameObjectId() == gameObject.getId()) {
                totem.setPointsGameObject(null);
            }
        }
    }

    public void clearGameObjects() {
        getTotems()
                .forEach(
                        totem -> {
                            totem.setTotemGameObject(null);
                            totem.setPointsGameObject(null);
                        });
    }

    /**
     * Returns the carved status for each animal on the given totem. The map contains animal IDs as
     * keys and whether they have been carved as values. A value of {@code true} means the animal
     * has already been carved on this totem. A value of {@code false} means the animal has not been
     * carved yet.
     *
     * @param totem the totem to check
     * @return a map of animal ID to carved status
     */
    public Map<Integer, Boolean> getCarvedAnimalsStatus(final Totem totem) {
        Map<Integer, Boolean> result = new HashMap<>();

        for (int animal : totem.getAnimals()) {
            int progressKey = animal + 9;
            boolean exists = totem.getProgress().containsValue(progressKey);
            result.put(animal, exists);
        }

        return result;
    }

    public void updateClosestTotem(Player player) {
        closestTotem = findClosestTotem(player);
    }

    private Optional<Totem> findClosestTotem(Player player) {
        return getTotems().stream()
                .filter(totem -> totem.getTotemGameObject() != null)
                .filter(
                        totem ->
                                totem.getTotemGameObject()
                                                .getWorldLocation()
                                                .distanceTo(player.getWorldLocation())
                                        <= 10)
                .findFirst();
    }

    public int getTotalPoints() {
        return getTotems().stream().mapToInt(Totem::getPoints).sum();
    }
}

package com.github.therealguru.totemfletching.service;

import com.github.therealguru.totemfletching.overlay.CarvingActionOverlay;
import com.github.therealguru.totemfletching.overlay.EntTrailOverlay;
import com.github.therealguru.totemfletching.overlay.PanelOverlay;
import com.github.therealguru.totemfletching.overlay.TotemFletchingOverlay;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = @Inject)
public class OverlayService {
    private final OverlayManager overlayManager;
    private final TotemFletchingOverlay gameOverlay;
    private final CarvingActionOverlay carvingOverlay;
    private final EntTrailOverlay entTrailOverlay;
    private final PanelOverlay panelOverlay;

    public void registerOverlays() {
        overlayManager.add(gameOverlay);
        overlayManager.add(carvingOverlay);
        overlayManager.add(entTrailOverlay);
        overlayManager.add(panelOverlay);
    }

    public void unregisterOverlays() {
        overlayManager.remove(gameOverlay);
        overlayManager.remove(carvingOverlay);
        overlayManager.remove(entTrailOverlay);
        overlayManager.remove(panelOverlay);
    }
}

package com.github.therealguru.totemfletching;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TotemFletchingPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(TotemFletchingPlugin.class);
        RuneLite.main(args);
    }
}

