package com.github.therealguru.totemfletching;

import com.github.therealguru.totemfletching.listener.PluginEventListener;
import com.github.therealguru.totemfletching.service.OverlayService;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(name = "Totem Fletching")
public class TotemFletchingPlugin extends Plugin {

    @Inject private EventBus eventBus;
    @Inject private PluginEventListener pluginEventListener;
    @Inject private OverlayService overlayService;

    @Override
    protected void startUp() throws Exception {
        eventBus.register(pluginEventListener);
        overlayService.registerOverlays();
    }

    @Override
    protected void shutDown() throws Exception {
        eventBus.unregister(pluginEventListener);
        overlayService.unregisterOverlays();
    }

    @Provides
    TotemFletchingConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TotemFletchingConfig.class);
    }
}

package com.github.therealguru.totemfletching;

import com.github.therealguru.totemfletching.model.TotemHighlightMode;
import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup("totem-fletching")
public interface TotemFletchingConfig extends Config {

    Color RED = Color.decode("#E45F5F");
    Color GREEN = Color.decode("#9CF575");
    Color DEFAULT_TEXT_COLOR = Color.decode("#ddc2ff");

    @ConfigSection(
            name = "Overlay Settings",
            description = "Enable or disable individual overlays",
            position = 0)
    String sectionOverlays = "sectionOverlays";

    @ConfigItem(
            keyName = "renderTotemHighlight",
            name = "Show Totem Highlight",
            description = "Draw the highlight over totems",
            section = sectionOverlays,
            position = 0)
    default TotemHighlightMode renderTotemHighlight() {
        return TotemHighlightMode.OUTLINE;
    }

    @ConfigItem(
            keyName = "totemFillAlpha",
            name = "Totem Fill Opacity",
            section = sectionOverlays,
            description = "Opacity of the filled totem highlight (0-255)",
            position = 1)
    default int totemFillAlpha() {
        return 80;
    }

    @ConfigItem(
            keyName = "renderTotemText",
            name = "Show Totem Text",
            description = "Draw the text overlay over totems for animals and decorations",
            section = sectionOverlays,
            position = 2)
    default boolean renderTotemText() {
        return true;
    }

    @ConfigItem(
            keyName = "renderPoints",
            name = "Show Points Text",
            description = "Draw the text overlay over points",
            section = sectionOverlays,
            position = 3)
    default boolean renderPoints() {
        return true;
    }

    @ConfigItem(
            keyName = "renderEntTrails",
            name = "Show Ent Trails",
            description =
                    "Whether to show the ent trails that need to be stepped on for bonus points",
            section = sectionOverlays,
            position = 4)
    default boolean renderEntTrails() {
        return true;
    }

    @ConfigItem(
            keyName = "highlightCorrectCarvingChoice",
            name = "Highlight Correct Carving Choices",
            description = "Highlight which animals to select in the totem carving interface",
            section = sectionOverlays,
            position = 5)
    default boolean highlightCorrectCarvingChoice() {
        return true;
    }

    @ConfigItem(
            keyName = "maskIncorrectCarvingChoice",
            name = "Mask Incorrect Carving Choices",
            description = "Mask the incorrect animals in the totem carving interface",
            section = sectionOverlays,
            position = 6)
    default boolean maskIncorrectCarvingChoice() {
        return true;
    }

    @ConfigSection(
            name = "Color Settings",
            description = "Pick colors for each overlay element",
            position = 1)
    String sectionColors = "sectionColors";

    @ConfigItem(
            keyName = "totemCompleteColor",
            name = "Complete Totem",
            description = "Choose the color used for the highlight on complete totems",
            section = sectionColors,
            position = 0)
    default Color totemCompleteColor() {
        return GREEN;
    }

    @ConfigItem(
            keyName = "totemIncompleteColor",
            name = "Incomplete Totem",
            description = "Choose the color used for the highlight on incomplete totems",
            section = sectionColors,
            position = 1)
    default Color totemIncompleteColor() {
        return RED;
    }

    @ConfigItem(
            keyName = "totemTextColor",
            name = "Totem Text",
            description = "Choose the color used for the text on the totem overlays",
            section = sectionColors,
            position = 2)
    default Color totemTextColor() {
        return DEFAULT_TEXT_COLOR;
    }

    @ConfigItem(
            keyName = "pointsTextColor",
            name = "Points Text",
            description = "Choose the color used for the text on the points overlays",
            section = sectionColors,
            position = 3)
    default Color pointsTextColor() {
        return DEFAULT_TEXT_COLOR;
    }

    @ConfigItem(
            keyName = "pointsCappedColor",
            name = "Points Tile at Maximum",
            description =
                    "Choose the color used to highlight the points tile if the maximum point total has been reached",
            section = sectionColors,
            position = 4)
    default Color pointsCappedColor() {
        return RED;
    }

    @ConfigItem(
            keyName = "entTrailColor",
            name = "Ent Trail",
            description = "Choose the color used to draw ent trails",
            section = sectionColors,
            position = 5)
    default Color entTrailColor() {
        return Color.decode("#e4fff6");
    }

    @ConfigItem(
            keyName = "carvingHighlightColor",
            name = "Carving Highlight",
            description =
                    "Choose the color used to highlight the correct choices in the carving interface",
            section = sectionColors,
            position = 6)
    default Color carvingHighlightColor() {
        return Color.decode("#9CF575");
    }

    @ConfigItem(
            keyName = "carvingHighlightBorderWidth",
            name = "Carving Highlight Border Width",
            description = "Select the border width for the correct choices",
            section = sectionColors,
            position = 7)
    @Units(Units.PIXELS)
    @Range(min = 1, max = 10)
    default int carvingHighlightBorderWidth() {
        return 2;
    }

    @ConfigItem(
            keyName = "carvingMaskColor",
            name = "Carving Mask",
            description = "Choose the color to mask the incorrect choices in the carving interface",
            section = sectionColors,
            position = 8)
    @Alpha
    default Color carvingMaskColor() {
        return new Color(64, 64, 64, 204);
    }

    @ConfigSection(
            name = "Additional Settings",
            description = "Customize additional accessibility settings",
            closedByDefault = true,
            position = 2)
    String sectionAdditional = "sectionAdditional";

    @ConfigItem(
            keyName = "keepDecoratedText",
            name = "Keep Fully Decorated Text",
            description = "Show the text on a fully decorated totem",
            section = sectionAdditional,
            position = 0)
    default boolean keepDecoratedText() {
        return false;
    }

    @ConfigItem(
            keyName = "showZeroPoints",
            name = "Show Zero Points",
            description = "Show the points text even if the points are zero",
            section = sectionAdditional,
            position = 1)
    default boolean showZeroPoints() {
        return true;
    }

    @ConfigItem(
            keyName = "unbuiltOffset",
            name = "Unbuilt Totem Offset",
            description = "Choose how high the unbuilt totem text will be from the ground",
            section = sectionAdditional,
            position = 2)
    @Units(Units.PIXELS)
    @Range(max = 800)
    default int unbuiltOffset() {
        return 160;
    }

    @ConfigItem(
            keyName = "builtOffset",
            name = "Built Totem Offset",
            description = "Choose how high the built totem text will be from the ground",
            section = sectionAdditional,
            position = 3)
    @Units(Units.PIXELS)
    @Range(max = 800)
    default int builtOffset() {
        return 160;
    }

    @ConfigItem(
            keyName = "pointsOffset",
            name = "Points Offset",
            description = "Choose how high the points text will be from the ground",
            section = sectionAdditional,
            position = 4)
    @Units(Units.PIXELS)
    @Range(max = 800)
    default int pointsOffset() {
        return 16;
    }

    @ConfigItem(
            keyName = "renderPanel",
            name = "Show widget",
            description = "Show a helper widget when doing Totem fletching",
            section = sectionOverlays,
            position = 7)
    default boolean renderPanel() {
        return false;
    }
}

package com.github.therealguru.totemfletching.model;

public enum TotemTier {
    LOW,
    MID,
    TOP
}

package com.github.therealguru.totemfletching.model;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

public enum TotemRegions {
    NORTH(Constants.Regions.NORTH),
    NORTH_EAST(Constants.Regions.NORTH_EAST),
    NORTH_WEST(Constants.Regions.NORTH_WEST),
    SOUTH(Constants.Regions.SOUTH),
    SOUTH_WEST(Constants.Regions.SOUTH_WEST),
    SOUTH_EAST(Constants.Regions.SOUTH_EAST);

    private final int id;

    TotemRegions(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    private static final Set<Integer> VALID_REGION_IDS =
            Arrays.stream(values()).map(TotemRegions::getId).collect(Collectors.toSet());

    public static boolean isValid(int id) {
        return VALID_REGION_IDS.contains(id);
    }
}

package com.github.therealguru.totemfletching.model;

import java.util.HashMap;
import java.util.Map;
import lombok.Data;
import net.runelite.api.Client;
import net.runelite.api.GameObject;

@Data
public class Totem {

    private static final int MAXIMUM_POINTS = 15000;

    private int totemId;
    private int totemGameObjectId;
    private int pointsGameObjectId;
    private int startingVarbit;
    private GameObject totemGameObject;
    private GameObject pointsGameObject;
    private boolean carved = false;
    private int decoration = 0;
    private int decay = 0;
    private int base = 0;
    private int[] animals = new int[3];
    private Map<TotemTier, Integer> progress = new HashMap<>();
    private int points = 0;

    public Totem(int totemId, int totemGameObjectId, int pointsGameObjectId, int startingVarbit) {
        this.totemId = totemId;
        this.totemGameObjectId = totemGameObjectId;
        this.pointsGameObjectId = pointsGameObjectId;
        this.startingVarbit = startingVarbit;
        this.progress.put(TotemTier.LOW, 0);
        this.progress.put(TotemTier.MID, 0);
        this.progress.put(TotemTier.TOP, 0);
    }

    public boolean hasTotemStarted() {
        return base != 0;
    }

    public boolean isBuildingTotem() {
        return base >= 1 && base <= 6;
    }

    public boolean isDecorated() {
        return decoration == 4;
    }

    private int getValue(TotemTier totemTier) {
        return progress.getOrDefault(totemTier, 0);
    }

    public int getPoints() {
        return points;
    }

    public boolean isBottomComplete() {
        return getValue(TotemTier.LOW) > 4;
    }

    public boolean isMiddleComplete() {
        return getValue(TotemTier.MID) > 4;
    }

    public boolean isTopComplete() {
        return getValue(TotemTier.TOP) > 4;
    }

    public boolean isVarbitRelated(int varbit) {
        return varbit >= startingVarbit && varbit <= (startingVarbit + 17);
    }

    public boolean isRenderable(Client client) {
        return totemGameObject != null
                && pointsGameObject != null
                && totemGameObject
                                .getWorldLocation()
                                .distanceTo(client.getLocalPlayer().getWorldLocation())
                        <= 16;
    }

    public boolean isPointCapped() {
        return points >= MAXIMUM_POINTS;
    }
}

package com.github.therealguru.totemfletching.model;

import java.util.Arrays;

public enum TotemVarbit {
    BASE(0),
    BASE_CARVED(1),
    BASE_MULTILOC(2),
    LOW(3),
    MID(4),
    TOP(5),
    DECORATIONS(6),
    ANIMAL_1(7),
    ANIMAL_2(8),
    ANIMAL_3(9),
    DECAY(10),
    POINTS(11),
    MULTIANIMAL_A_1(12),
    MULTIANIMAL_B_1(13),
    MULTIANIMAL_C_1(14),
    MULTIANIMAL_D_1(15),
    MULTIANIMAL_E_1(16),
    ALL_MULTIANIMALS(17);

    private int relativeVarbit;

    TotemVarbit(int relativeVarbit) {
        this.relativeVarbit = relativeVarbit;
    }

    public int getRealVarbit(Totem totem) {
        return totem.getStartingVarbit() + this.relativeVarbit;
    }

    public static TotemVarbit getVarbit(Totem totem, int varbit) {
        return Arrays.stream(TotemVarbit.values())
                .filter(totemVarbit -> totemVarbit.getRealVarbit(totem) == varbit)
                .findFirst()
                .orElse(null);
    }
}

package com.github.therealguru.totemfletching.model;

public class Constants {

    public static class Regions {
        public static final int NORTH = 5684;
        public static final int NORTH_WEST = 5428;
        public static final int NORTH_EAST = 5940;
        public static final int SOUTH = 5683;
        public static final int SOUTH_WEST = 5427;
        public static final int SOUTH_EAST = 5939;
    }
}

package com.github.therealguru.totemfletching.model;

public enum TotemHighlightMode {
    NONE,
    OUTLINE,
    FILL
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.TotemFletchingPlugin;
import com.github.therealguru.totemfletching.model.TotemRegions;
import com.github.therealguru.totemfletching.service.ResearchPointService;
import com.github.therealguru.totemfletching.service.TotemService;
import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

public class PanelOverlay extends OverlayPanel {
    private final Client client;
    private final TotemFletchingConfig config;
    private final ResearchPointService pointService;
    private final TotemService totemService;

    @Inject
    public PanelOverlay(
            TotemFletchingPlugin plugin,
            TotemFletchingConfig config,
            TotemService totemService,
            ResearchPointService pointService,
            Client client) {
        super(plugin);
        this.client = client;
        this.config = config;
        this.pointService = pointService;
        this.totemService = totemService;
        setPosition(OverlayPosition.TOP_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.renderPanel()) return null;

        boolean isInRegion =
                TotemRegions.isValid(client.getLocalPlayer().getWorldLocation().getRegionID());

        if (!isInRegion) return null;

        panelComponent.getChildren().add(TitleComponent.builder().text("Vale Totems").build());

        panelComponent
                .getChildren()
                .add(
                        LineComponent.builder()
                                .left("Unclaimed offerings:")
                                .right(String.valueOf(totemService.getTotalPoints()))
                                .build());

        panelComponent
                .getChildren()
                .add(
                        LineComponent.builder()
                                .left("Research points:")
                                .right(String.valueOf(pointService.getResearchPoints()))
                                .build());

        return super.render(graphics);
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.TotemFletchingPlugin;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemHighlightMode;
import com.github.therealguru.totemfletching.service.TotemService;
import java.awt.*;
import java.util.Map;
import java.util.Optional;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
public class TotemFletchingOverlay extends Overlay {

    private final TotemService totemService;
    private final Client client;
    private final TotemFletchingConfig config;

    @Inject
    public TotemFletchingOverlay(
            TotemFletchingPlugin plugin,
            TotemFletchingConfig config,
            TotemService totemService,
            Client client) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.totemService = totemService;
        this.client = client;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        totemService.getTotems().stream()
                .filter(totem -> totem.isRenderable(client))
                .forEach((totem) -> renderTotem(graphics2D, totem));
        return null;
    }

    void renderTotem(Graphics2D graphics2D, Totem totem) {
        renderTotemHighlight(graphics2D, totem);
        renderPointsOverlay(graphics2D, totem);

        if (config.renderTotemText()) {
            Optional<String> totemText = getTotemText(totem);
            if (totemText.isPresent()) {
                String text = totemText.get();
                Point canvasPoint = getTotemCanvasPoint(graphics2D, totem, text);
                if (canvasPoint != null) {
                    OverlayUtil.renderTextLocation(
                            graphics2D, canvasPoint, text, config.totemTextColor());
                }
            }
        }
    }

    private void renderTotemHighlight(Graphics2D graphics2D, Totem totem) {

        TotemHighlightMode mode = config.renderTotemHighlight();
        if (mode == TotemHighlightMode.NONE) return;

        if (totem.hasTotemStarted()) {
            Shape shape = totem.getTotemGameObject().getClickbox();
            if (shape != null) {
                final Color highlight = getTotemColor(totem);

                if (mode == TotemHighlightMode.FILL) {
                    final int alpha = config.totemFillAlpha();
                    final Color fill =
                            new Color(
                                    highlight.getRed(),
                                    highlight.getGreen(),
                                    highlight.getBlue(),
                                    alpha);

                    graphics2D.setRenderingHint(
                            RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                    final Composite oldComposite = graphics2D.getComposite();
                    final Color oldColor = graphics2D.getColor();

                    graphics2D.setComposite(AlphaComposite.SrcOver);
                    graphics2D.setColor(fill);
                    graphics2D.fill(shape);

                    graphics2D.setColor(oldColor);
                    graphics2D.setComposite(oldComposite);
                }

                OverlayUtil.renderPolygon(graphics2D, shape, getTotemColor(totem));
            }
        } else {
            OverlayUtil.renderTileOverlay(
                    graphics2D, totem.getTotemGameObject(), null, config.totemIncompleteColor());
        }
    }

    Optional<String> getTotemText(Totem totem) {
        if (!totem.isCarved()) {
            return Optional.of(totem.getTotemId() + " | " + getAnimalText(totem));
        } else if (!totem.isDecorated() || config.keepDecoratedText()) {
            return Optional.of(totem.getDecoration() + " / 4");
        } else {
            return Optional.empty();
        }
    }

    private String getAnimalText(final Totem totem) {
        Map<Integer, Boolean> animalData = totemService.getAnimalsProgress(totem);
        StringBuilder text = new StringBuilder();
        for (Map.Entry<Integer, Boolean> entry : animalData.entrySet()) {
            if (entry.getValue()) continue;

            text.append(entry.getKey()).append(" ");
        }
        return text.toString().trim();
    }

    public Color getTotemColor(Totem totem) {
        return totem.isCarved() && totem.isDecorated()
                ? config.totemCompleteColor()
                : config.totemIncompleteColor();
    }

    void renderPointsOverlay(Graphics2D graphics2D, Totem totem) {
        if (!config.renderPoints() || (totem.getPoints() == 0 && !config.showZeroPoints())) return;

        renderPointsTile(graphics2D, totem);
        renderPointsText(graphics2D, totem);
    }

    void renderPointsText(Graphics2D graphics2D, Totem totem) {
        final GameObject gameObject = totem.getPointsGameObject();
        final LocalPoint localPoint =
                LocalPoint.fromWorld(client.getTopLevelWorldView(), gameObject.getWorldLocation());
        if (localPoint == null) return;

        String text = getPointsText(totem);
        Point canvasPoint =
                gameObject.getCanvasTextLocation(graphics2D, text, config.pointsOffset());
        if (canvasPoint == null) return;

        OverlayUtil.renderTextLocation(graphics2D, canvasPoint, text, config.pointsTextColor());
    }

    void renderPointsTile(Graphics2D graphics2D, Totem totem) {
        if (!totem.isPointCapped()) return;

        OverlayUtil.renderTileOverlay(
                graphics2D, totem.getPointsGameObject(), null, config.pointsCappedColor());
    }

    private String getPointsText(Totem totem) {
        return totem.isPointCapped() ? "MAXIMUM" : Integer.toString(totem.getPoints());
    }

    private Point getTotemCanvasPoint(Graphics2D graphics2D, Totem totem, String text) {
        if (totem.hasTotemStarted()) {
            return totem.getTotemGameObject()
                    .getCanvasTextLocation(graphics2D, text, config.builtOffset());
        } else {
            return totem.getTotemGameObject()
                    .getCanvasTextLocation(graphics2D, text, config.unbuiltOffset());
        }
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.service.TotemService;
import java.awt.*;
import java.util.Map;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
public class CarvingActionOverlay extends Overlay {

    private static final int TOTEM_CARVING_TEXT_WIDGET = InterfaceID.Skillmulti.TITLE;
    private static final int FIRST_CARVING_WIDGET = InterfaceID.Skillmulti.A;
    private static final int ANIMAL_COUNT = 5;
    private static final String ACTION_TEXT = "What animal would you like to carve?";

    private final Client client;
    private final TotemService totemService;
    private final TotemFletchingConfig config;

    @Inject
    public CarvingActionOverlay(TotemService service, TotemFletchingConfig config, Client client) {
        super();
        this.client = client;
        this.totemService = service;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(.6F);
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if (!config.highlightCorrectCarvingChoice() && !config.maskIncorrectCarvingChoice())
            return null;

        Totem totem = totemService.getClosestTotem();
        if (totem == null) return null;

        if (!isCarvingWidget()) return null;

        Map<Integer, Boolean> carvedState = totemService.getAnimalsProgress(totem);
        for (int i = 0; i < ANIMAL_COUNT; i++) {
            Widget carvingWidget = client.getWidget(FIRST_CARVING_WIDGET + i);
            if (carvingWidget != null && !carvingWidget.isHidden()) {
                // If the choice doesn't exist then we default to true (this just means the animal
                // is an incorrect choice).
                boolean isCarvedOrIncorrectChoice = carvedState.getOrDefault(i + 1, true);
                renderOverlay(graphics2D, carvingWidget, !isCarvedOrIncorrectChoice);
            }
        }

        return null;
    }

    private void renderOverlay(Graphics2D graphics, Widget carvingWidget, boolean correctChoice) {
        Rectangle bounds = carvingWidget.getBounds();
        if (bounds != null) {
            if (correctChoice && config.highlightCorrectCarvingChoice()) {
                graphics.setColor(config.carvingHighlightColor());
                graphics.setStroke(new BasicStroke(config.carvingHighlightBorderWidth()));
                graphics.draw(bounds);
            } else if (!correctChoice && config.maskIncorrectCarvingChoice()) {
                graphics.setColor(config.carvingMaskColor());
                graphics.fill(bounds);
            }
        }
    }

    private boolean isCarvingWidget() {
        Widget titleWidget = client.getWidget(TOTEM_CARVING_TEXT_WIDGET);
        return titleWidget != null
                && titleWidget.getText() != null
                && titleWidget.getText().equalsIgnoreCase(ACTION_TEXT);
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.TotemFletchingPlugin;
import com.github.therealguru.totemfletching.service.EntTrailService;
import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class EntTrailOverlay extends Overlay {
    private final EntTrailService service;
    private final TotemFletchingConfig config;

    @Inject
    public EntTrailOverlay(
            TotemFletchingPlugin plugin,
            TotemFletchingConfig config,
            EntTrailService service,
            Client client) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.service = service;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.renderEntTrails()) {
            return null;
        }

        for (GameObject object : service.getInactiveEntTrails()) {
            if (object == null) continue;
            renderEntTrail(object, graphics);
        }
        return null;
    }

    void renderEntTrail(final GameObject gameObject, Graphics2D graphics2D) {
        OverlayUtil.renderTileOverlay(graphics2D, gameObject, null, config.entTrailColor());
    }
}

package com.github.therealguru.totemfletching.listener;

import com.github.therealguru.totemfletching.service.EntTrailService;
import com.github.therealguru.totemfletching.service.ResearchPointService;
import com.github.therealguru.totemfletching.service.TotemService;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.*;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

public class PluginEventListener {

    @Inject private Client client;

    @Inject private TotemService totemService;
    @Inject private EntTrailService entTrailService;
    @Inject private ResearchPointService researchPointService;

    @Subscribe
    public void onVarbitChanged(final VarbitChanged varbitChanged) {
        if (varbitChanged.getVarbitId() == VarPlayerID.ENT_TOTEMS_RESEARCH_POINTS) {
            researchPointService.onVarbitChanged();
        }
        if (varbitChanged.getVarbitId() < VarbitID.ENT_TOTEMS_SITE_1_BASE
                || varbitChanged.getVarbitId() > VarbitID.ENT_TOTEMS_SITE_8_ALL_MULTIANIMALS)
            return;

        totemService.onVarbitChanged(varbitChanged);
    }

    @Subscribe
    public void onGameObjectSpawned(final GameObjectSpawned gameObjectSpawned) {
        totemService.addGameObject(gameObjectSpawned.getGameObject());
        entTrailService.addEntTrail(gameObjectSpawned);
    }

    @Subscribe
    public void onGameObjectDespawned(final GameObjectDespawned gameObjectDespawned) {
        totemService.removeGameObject(gameObjectDespawned.getGameObject());
        entTrailService.removeEntTrail(gameObjectDespawned);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState().equals(GameState.LOADING)) {
            totemService.clearGameObjects();
            entTrailService.clearEntTrails();
        }
    }

    @Subscribe
    public void onGameTick(final GameTick gameTick) {
        totemService.updateClosestTotem(client.getLocalPlayer());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.events.VarbitChanged;

@RequiredArgsConstructor
public abstract class TotemAction {

    @Getter private final TotemVarbit varbit;

    public abstract void onVarbitChanged(Totem totem, VarbitChanged varbitChanged);
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class BaseAction extends TotemAction {

    public BaseAction() {
        super(TotemVarbit.BASE);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setBase(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemTier;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class TotemTierAction extends TotemAction {

    private final TotemTier totemTier;

    public TotemTierAction(TotemTier tier) {
        super(TotemVarbit.valueOf(tier.name()));
        this.totemTier = tier;
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.getProgress().put(totemTier, varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class DecorationsAction extends TotemAction {

    public DecorationsAction() {
        super(TotemVarbit.DECORATIONS);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setDecoration(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class DecayAction extends TotemAction {

    public DecayAction() {
        super(TotemVarbit.DECAY);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setDecay(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class AnimalAction extends TotemAction {

    private final int animal;

    public AnimalAction(int animal) {
        super(TotemVarbit.valueOf("ANIMAL_" + animal));
        this.animal = animal;
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.getAnimals()[animal - 1] = varbitChanged.getValue();
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class BaseCarvedAction extends TotemAction {

    public BaseCarvedAction() {
        super(TotemVarbit.BASE_CARVED);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setCarved(varbitChanged.getValue() == 1);
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class PointsAction extends TotemAction {

    public PointsAction() {
        super(TotemVarbit.POINTS);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setPoints(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;

@Slf4j
@Singleton
public class EntTrailService {

    private static final List<Integer> ENT_TRAIL_GAME_OBJECT_IDS = List.of(57115, 57116);
    private static final List<Integer> ENT_TRAIL_INACTIVE_ANIMATION_IDS = List.of(12344, 12345);
    private static final List<Integer> ENT_TRAIL_ACTIVE_ANIMATION_IDS = List.of(12346);

    private final List<GameObject> entTrails = new ArrayList<>();

    public EntTrailService() {}

    public List<GameObject> getInactiveEntTrails() {
        return entTrails.stream()
                .filter(entTrail -> entTrail.getRenderable() instanceof DynamicObject)
                .filter(
                        entTrail ->
                                ((DynamicObject) entTrail.getRenderable()).getAnimation() != null)
                .filter(
                        entTrail ->
                                ENT_TRAIL_INACTIVE_ANIMATION_IDS.contains(
                                        ((DynamicObject) entTrail.getRenderable())
                                                .getAnimation()
                                                .getId()))
                .collect(Collectors.toList());
    }

    public void addEntTrail(GameObjectSpawned spawned) {
        if (!isEntTrail(spawned.getGameObject())) return;

        entTrails.add(spawned.getGameObject());
    }

    public void removeEntTrail(GameObjectDespawned despawned) {
        entTrails.remove(despawned.getGameObject());
    }

    private boolean isEntTrail(GameObject gameObject) {
        return ENT_TRAIL_GAME_OBJECT_IDS.contains(gameObject.getId());
    }

    public void clearEntTrails() {
        this.entTrails.clear();
    }
}

package com.github.therealguru.totemfletching.service;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarPlayerID;

public class ResearchPointService {

    private final Client client;
    private final TotemFletchingConfig config;
    private Integer researchPoints;

    @Inject
    public ResearchPointService(TotemFletchingConfig config, Client client) {
        this.client = client;
        this.config = config;
    }

    public void onVarbitChanged() {
        if (!config.renderPanel()) return;
        researchPoints = client.getVarpValue(VarPlayerID.ENT_TOTEMS_RESEARCH_POINTS);
    }

    public int getResearchPoints() {
        if (researchPoints == null) {
            researchPoints = client.getVarpValue(VarPlayerID.ENT_TOTEMS_RESEARCH_POINTS);
        }
        return researchPoints;
    }
}

package com.github.therealguru.totemfletching.service;

import com.github.therealguru.totemfletching.action.*;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemTier;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameObject;
import net.runelite.api.Player;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;

@Slf4j
@Singleton
public class TotemService {

    private static final List<Totem> TOTEMS =
            List.of(
                    new Totem(
                            1,
                            ObjectID.ENT_TOTEMS_SITE_1_BASE,
                            ObjectID.ENT_TOTEMS_SITE_1_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_1_BASE),
                    new Totem(
                            2,
                            ObjectID.ENT_TOTEMS_SITE_2_BASE,
                            ObjectID.ENT_TOTEMS_SITE_2_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_2_BASE),
                    new Totem(
                            3,
                            ObjectID.ENT_TOTEMS_SITE_3_BASE,
                            ObjectID.ENT_TOTEMS_SITE_3_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_3_BASE),
                    new Totem(
                            4,
                            ObjectID.ENT_TOTEMS_SITE_4_BASE,
                            ObjectID.ENT_TOTEMS_SITE_4_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_4_BASE),
                    new Totem(
                            5,
                            ObjectID.ENT_TOTEMS_SITE_5_BASE,
                            ObjectID.ENT_TOTEMS_SITE_5_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_5_BASE),
                    new Totem(
                            6,
                            ObjectID.ENT_TOTEMS_SITE_6_BASE,
                            ObjectID.ENT_TOTEMS_SITE_6_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_6_BASE),
                    new Totem(
                            7,
                            ObjectID.ENT_TOTEMS_SITE_7_BASE,
                            ObjectID.ENT_TOTEMS_SITE_7_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_7_BASE),
                    new Totem(
                            8,
                            ObjectID.ENT_TOTEMS_SITE_8_BASE,
                            ObjectID.ENT_TOTEMS_SITE_8_OFFERINGS,
                            VarbitID.ENT_TOTEMS_SITE_8_BASE));

    private static final Map<TotemVarbit, TotemAction> TOTEM_ACTIONS = new HashMap<>();

    static {
        TOTEM_ACTIONS.put(TotemVarbit.ANIMAL_1, new AnimalAction(1));
        TOTEM_ACTIONS.put(TotemVarbit.ANIMAL_2, new AnimalAction(2));
        TOTEM_ACTIONS.put(TotemVarbit.ANIMAL_3, new AnimalAction(3));
        TOTEM_ACTIONS.put(TotemVarbit.BASE, new BaseAction());
        TOTEM_ACTIONS.put(TotemVarbit.BASE_CARVED, new BaseCarvedAction());
        TOTEM_ACTIONS.put(TotemVarbit.DECAY, new DecayAction());
        TOTEM_ACTIONS.put(TotemVarbit.DECORATIONS, new DecorationsAction());
        TOTEM_ACTIONS.put(TotemVarbit.POINTS, new PointsAction());
        TOTEM_ACTIONS.put(TotemVarbit.LOW, new TotemTierAction(TotemTier.LOW));
        TOTEM_ACTIONS.put(TotemVarbit.MID, new TotemTierAction(TotemTier.MID));
        TOTEM_ACTIONS.put(TotemVarbit.TOP, new TotemTierAction(TotemTier.TOP));
    }

    @Getter private Totem closestTotem = null;

    public TotemService() {}

    public void onVarbitChanged(final VarbitChanged varbitChanged) {
        Totem totem =
                TOTEMS.stream()
                        .filter(t -> t.isVarbitRelated(varbitChanged.getVarbitId()))
                        .findFirst()
                        .orElse(null);
        if (totem == null) return;

        TotemVarbit totemVarbit = TotemVarbit.getVarbit(totem, varbitChanged.getVarbitId());
        TotemAction action = TOTEM_ACTIONS.get(totemVarbit);
        if (action != null) {
            action.onVarbitChanged(totem, varbitChanged);
        }
    }

    public void addGameObject(final GameObject gameObject) {
        for (Totem totem : TOTEMS) {
            if (totem.getTotemGameObjectId() == gameObject.getId()) {
                totem.setTotemGameObject(gameObject);
            } else if (totem.getPointsGameObjectId() == gameObject.getId()) {
                totem.setPointsGameObject(gameObject);
            }
        }
    }

    public void removeGameObject(final GameObject gameObject) {
        for (Totem totem : TOTEMS) {
            if (totem.getTotemGameObjectId() == gameObject.getId()) {
                totem.setTotemGameObject(null);
            } else if (totem.getPointsGameObjectId() == gameObject.getId()) {
                totem.setPointsGameObject(null);
            }
        }
    }

    public void clearGameObjects() {
        getTotems()
                .forEach(
                        totem -> {
                            totem.setTotemGameObject(null);
                            totem.setPointsGameObject(null);
                        });
    }

    public Map<Integer, Boolean> getAnimalsProgress(final Totem totem) {
        Map<Integer, Boolean> result = new HashMap<>();

        for (int animal : totem.getAnimals()) {
            int progressKey = animal + 9;
            boolean exists = totem.getProgress().containsValue(progressKey);
            result.put(animal, exists);
        }

        return result;
    }

    public List<Totem> getTotems() {
        return TOTEMS;
    }

    public void updateClosestTotem(Player player) {
        closestTotem =
                getTotems().stream()
                        .filter(totem -> totem.getTotemGameObject() != null)
                        .filter(
                                totem ->
                                        totem.getTotemGameObject()
                                                        .getWorldLocation()
                                                        .distanceTo(player.getWorldLocation())
                                                <= 10)
                        .findFirst()
                        .orElse(null);
    }

    public int getTotalPoints() {
        return getTotems().stream().mapToInt(Totem::getPoints).sum();
    }
}

package com.github.therealguru.totemfletching.service;

import com.github.therealguru.totemfletching.overlay.CarvingActionOverlay;
import com.github.therealguru.totemfletching.overlay.EntTrailOverlay;
import com.github.therealguru.totemfletching.overlay.PanelOverlay;
import com.github.therealguru.totemfletching.overlay.TotemFletchingOverlay;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@Singleton
public class OverlayService {
    @Inject private OverlayManager overlayManager;

    @Inject private TotemFletchingOverlay gameOverlay;
    @Inject private CarvingActionOverlay carvingOverlay;
    @Inject private EntTrailOverlay entTrailOverlay;
    @Inject private PanelOverlay panelOverlay;

    public OverlayService() {}

    public void registerOverlays() {
        overlayManager.add(gameOverlay);
        overlayManager.add(carvingOverlay);
        overlayManager.add(entTrailOverlay);
        overlayManager.add(panelOverlay);
    }

    public void unregisterOverlays() {
        overlayManager.remove(gameOverlay);
        overlayManager.remove(carvingOverlay);
        overlayManager.remove(entTrailOverlay);
        overlayManager.remove(panelOverlay);
    }
}

package com.github.therealguru.totemfletching;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TotemFletchingPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(TotemFletchingPlugin.class);
        RuneLite.main(args);
    }
}

