package com.github.therealguru.totemfletching;

import com.github.therealguru.totemfletching.overlay.CarvingActionOverlay;
import com.github.therealguru.totemfletching.overlay.EntTrailOverlay;
import com.github.therealguru.totemfletching.overlay.TotemFletchingOverlay;
import com.github.therealguru.totemfletching.service.EntTrailService;
import com.github.therealguru.totemfletching.service.TotemService;
import com.google.inject.Provides;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
        name = "Totem Fletching"
)
public class TotemFletchingPlugin extends Plugin {

    @Inject
    private Client client;
    @Inject
    private TotemFletchingConfig config;
    @Inject
    private OverlayManager overlayManager;

    private TotemService totemService;
    private EntTrailService entTrailService;
    private TotemFletchingOverlay gameOverlay;
    private CarvingActionOverlay carvingOverlay;
    private EntTrailOverlay entTrailOverlay;

    @Override
    protected void startUp() throws Exception {
        totemService = new TotemService();
        entTrailService = new EntTrailService();
        gameOverlay = new TotemFletchingOverlay(this, totemService, client);
        carvingOverlay = new CarvingActionOverlay(totemService, config, client);
        entTrailOverlay = new EntTrailOverlay(this, config, entTrailService, client);
        overlayManager.add(gameOverlay);
        overlayManager.add(carvingOverlay);
        overlayManager.add(entTrailOverlay);
    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(gameOverlay);
        overlayManager.remove(carvingOverlay);
        overlayManager.remove(entTrailOverlay);
    }

    @Provides
    TotemFletchingConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(TotemFletchingConfig.class);
    }

    @Subscribe
    public void onVarbitChanged(final VarbitChanged varbitChanged) {
        if (varbitChanged.getVarbitId() < 17611 || varbitChanged.getVarbitId() > 17754) return;

        totemService.onVarbitChanged(varbitChanged);
    }

    @Subscribe
    public void onGameObjectSpawned(final GameObjectSpawned gameObjectSpawned) {
        totemService.addGameObject(gameObjectSpawned.getGameObject());
        entTrailService.addEntTrail(gameObjectSpawned);
    }

    @Subscribe
    public void onGameObjectDespawned(final GameObjectDespawned gameObjectDespawned) {
        totemService.removeGameObject(gameObjectDespawned.getGameObject());
        entTrailService.removeEntTrail(gameObjectDespawned);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState().equals(GameState.LOADING)) {
            totemService.clearGameObjects();
            entTrailService.clearEntTrails();
        }
    }

    @Subscribe
    public void onGameTick(final GameTick gameTick) {
        totemService.updateClosestTotem(client.getLocalPlayer());
    }
}

package com.github.therealguru.totemfletching;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("totem-fletching")
public interface TotemFletchingConfig extends Config {

    @ConfigItem(
            keyName = "renderEntTrails",
            name = "Show Ent Trails",
            description = "Whether to show the ent trails that need to be stepped on for bonus points"
    )
    default boolean renderEntTrails() {
        return true;
    }

    @ConfigItem(
            keyName = "renderCarvingOverlay",
            name = "Highlight Animal Overlay",
            description = "Highlights which animals to select in the UI"
    )
    default boolean renderCarvingOverlay() {
        return true;
    }
}

package com.github.therealguru.totemfletching.model;

public enum TotemTier {

    LOW,
    MID,
    TOP
}

package com.github.therealguru.totemfletching.model;

import lombok.Data;
import net.runelite.api.GameObject;

import java.util.HashMap;
import java.util.Map;


@Data
public class Totem {

    private int totemId;
    private int totemGameObjectId;
    private int pointsGameObjectId;
    private int startingVarbit;
    private GameObject totemGameObject;
    private GameObject pointsGameObject;
    private boolean carved = false;
    private int decoration = 0;
    private int decay = 0;
    private int base = 0;
    private int[] animals = new int[3];
    private Map<TotemTier, Integer> progress = new HashMap<>();
    private int points = 0;

    public Totem(int totemId, int totemGameObjectId, int pointsGameObjectId, int startingVarbit) {
        this.totemId = totemId;
        this.totemGameObjectId = totemGameObjectId;
        this.pointsGameObjectId = pointsGameObjectId;
        this.startingVarbit = startingVarbit;
        this.progress.put(TotemTier.LOW, 0);
        this.progress.put(TotemTier.MID, 0);
        this.progress.put(TotemTier.TOP, 0);
    }

    public boolean hasTotemStarted() {
        return base != 0;
    }

    public boolean isBuildingTotem() {
        return base >= 1 && base <= 6;
    }

    public boolean isDecorated() {
        return decoration == 4;
    }

    private int getValue(TotemTier totemTier) {
        return progress.getOrDefault(totemTier, 0);
    }

    public boolean isBottomComplete() {
        return getValue(TotemTier.LOW) > 4;
    }

    public boolean isMiddleComplete() {
        return getValue(TotemTier.MID) > 4;
    }

    public boolean isTopComplete() {
        return getValue(TotemTier.TOP) > 4;
    }

    public boolean isVarbitRelated(int varbit) {
        return varbit >= startingVarbit && varbit <= (startingVarbit + 17);
    }

    public boolean isRenderable() {
        return totemGameObject != null && pointsGameObject != null;
    }

}

package com.github.therealguru.totemfletching.model;

import java.util.Arrays;

public enum TotemVarbit {

    BASE(0),
    BASE_CARVED(1),
    BASE_MULTILOC(2),
    LOW(3),
    MID(4),
    TOP(5),
    DECORATIONS(6),
    ANIMAL_1(7),
    ANIMAL_2(8),
    ANIMAL_3(9),
    DECAY(10),
    POINTS(11),
    MULTIANIMAL_A_1(12),
    MULTIANIMAL_B_1(13),
    MULTIANIMAL_C_1(14),
    MULTIANIMAL_D_1(15),
    MULTIANIMAL_E_1(16),
    ALL_MULTIANIMALS(17);


    private int relativeVarbit;

    TotemVarbit(int relativeVarbit) {
        this.relativeVarbit = relativeVarbit;
    }

    public int getRealVarbit(Totem totem) {
        return totem.getStartingVarbit() + this.relativeVarbit;
    }

    public static TotemVarbit getVarbit(Totem totem, int varbit) {
        return Arrays.stream(TotemVarbit.values()).filter(totemVarbit -> totemVarbit.getRealVarbit(totem) == varbit).findFirst().orElse(null);
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.service.TotemService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.annotation.Nullable;
import java.awt.*;
import java.util.Map;
import java.util.Optional;

@Slf4j
public class TotemFletchingOverlay extends Overlay {

    private TotemService totemService;
    private Client client;

    public TotemFletchingOverlay(@Nullable Plugin plugin, TotemService totemService, Client client) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.totemService = totemService;
        this.client = client;
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        totemService.getTotems().stream().filter(Totem::isRenderable).forEach((totem) -> renderTotem(graphics2D, totem));
        return null;
    }

    void renderTotem(Graphics2D graphics2D, Totem totem) {
        renderTotemHighlight(graphics2D, totem);
        renderPoints(graphics2D, totem);

        Optional<String> totemText = getTotemText(totem);
        if (totemText.isPresent()) {
            String text = totemText.get();
            Point canvasPoint = totem.getTotemGameObject().getCanvasTextLocation(graphics2D, text, 16);
            if (canvasPoint != null) {
                OverlayUtil.renderTextLocation(graphics2D, canvasPoint, text, Color.GREEN);
            }
        }
    }

    private void renderTotemHighlight(Graphics2D graphics2D, Totem totem) {
        if (totem.hasTotemStarted()) {
            Shape shape = totem.getTotemGameObject().getClickbox();
            if (shape != null) {
                OverlayUtil.renderPolygon(graphics2D, shape, getTotemColor(totem));
            }
        } else {
            OverlayUtil.renderTileOverlay(graphics2D, totem.getTotemGameObject(), null, Color.RED);
        }
    }

    Optional<String> getTotemText(Totem totem) {
        if ((!totem.hasTotemStarted() || totem.isBuildingTotem()) && !totem.isCarved()) {
            return Optional.of(getAnimalText(totem));
        } else if (!totem.isDecorated()) {
            return Optional.of(totem.getDecoration() + " / 4");
        } else {
            return Optional.empty();
        }
    }

    private String getAnimalText(final Totem totem) {
        Map<Integer, Boolean> animalData = totemService.getAnimalsProgress(totem);
        StringBuilder text = new StringBuilder();
        for (Map.Entry<Integer, Boolean> entry : animalData.entrySet()) {
            if (entry.getValue()) continue;

            text.append(entry.getKey()).append(" ");
        }
        return text.toString().trim();
    }

    public Color getTotemColor(Totem totem) {
        return totem.isCarved() && totem.isDecorated() ? Color.GREEN : Color.RED;
    }

    void renderPoints(Graphics2D graphics2D, Totem totem) {
        GameObject gameObject = totem.getPointsGameObject();

        final LocalPoint localPoint = LocalPoint.fromWorld(client.getTopLevelWorldView(), gameObject.getWorldLocation());
        if (localPoint == null) return;

        final String text = totem.getPoints() + "";

        Point canvasPoint = totem.getPointsGameObject().getCanvasTextLocation(graphics2D, text, 16);
        if (canvasPoint == null) return;

        OverlayUtil.renderTextLocation(graphics2D, canvasPoint, text, Color.GREEN);
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.service.TotemService;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.*;
import java.util.Map;

@Slf4j
public class CarvingActionOverlay extends Overlay {

    private static final int TOTEM_CARVING_WIDGET = 270;
    private static final int TOTEM_CARVING_TEXT_WIDGET = 5;
    private static final String ACTION_TEXT = "What animal would you like to carve?";

    private final Client client;
    private final TotemService totemService;
    private final TotemFletchingConfig config;

    public CarvingActionOverlay(TotemService service, TotemFletchingConfig config, Client client) {
        super();
        this.client = client;
        this.totemService = service;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(.6F);
    }

    @Override
    public Dimension render(Graphics2D graphics2D) {
        if(!config.renderCarvingOverlay()) return null;

        Totem totem = totemService.getClosestTotem();
        if (totem == null) return null;

        Widget root = client.getWidget(TOTEM_CARVING_WIDGET, 0);
        if (root == null || root.isHidden()) {
            return null;
        }

        if(!isCarvingWidget()) return null;

        Map<Integer, Boolean> carved = totemService.getAnimalsProgress(totem);

        for (Map.Entry<Integer, Boolean> state : carved.entrySet()) {
            if (state.getValue()) continue;

            Widget childWidget = client.getWidget(TOTEM_CARVING_WIDGET, 13 + state.getKey());
            if (childWidget != null && !childWidget.isHidden()) {
                renderOverlay(graphics2D, childWidget);
            }
            Widget textWidget = client.getWidget(TOTEM_CARVING_WIDGET, InterfaceID.Skillmulti.TEXT);
            if(textWidget != null) {
                log.debug("Text widget is present with text: {}", textWidget.getText());
            }

            Widget tooltipWidget = client.getWidget(TOTEM_CARVING_WIDGET, InterfaceID.Skillmulti.TOOLTIP);
            if(tooltipWidget != null) {
                log.debug("Tooltip widget is present with text: {}", tooltipWidget.getText());
            }
        }
        return null;
    }

    private void renderOverlay(Graphics2D graphics, Widget childWidget) {
        Rectangle bounds = childWidget.getBounds();
        if (bounds != null) {
            graphics.setColor(Color.GREEN);
            graphics.setStroke(new BasicStroke(2));
            graphics.draw(bounds);
        }
    }

    private boolean isCarvingWidget() {
        Widget childWidget = client.getWidget(TOTEM_CARVING_WIDGET, TOTEM_CARVING_TEXT_WIDGET);
        return childWidget != null && childWidget.getText() != null && childWidget.getText().equalsIgnoreCase(ACTION_TEXT);
    }
}

package com.github.therealguru.totemfletching.overlay;

import com.github.therealguru.totemfletching.TotemFletchingConfig;
import com.github.therealguru.totemfletching.TotemFletchingPlugin;
import com.github.therealguru.totemfletching.service.EntTrailService;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;

public class EntTrailOverlay extends Overlay {

    private final EntTrailService service;
    private final TotemFletchingConfig config;

    public EntTrailOverlay(TotemFletchingPlugin plugin, TotemFletchingConfig config, EntTrailService service, Client client) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.service = service;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if(!config.renderEntTrails()) return null;

        for(GameObject object : service.getInactiveEntTrails()) {
            if(object == null) continue;

            renderEntTrail(object, graphics);
        }
        return null;
    }

    void renderEntTrail(final GameObject gameObject, Graphics2D graphics2D) {
        OverlayUtil.renderTileOverlay(graphics2D, gameObject, null, Color.RED);
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.events.VarbitChanged;

@RequiredArgsConstructor
public abstract class TotemAction {

    @Getter
    private final TotemVarbit varbit;

    public abstract void onVarbitChanged(Totem totem, VarbitChanged varbitChanged);
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class BaseAction extends TotemAction {

    public BaseAction() {
        super(TotemVarbit.BASE);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setBase(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemTier;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class TotemTierAction extends TotemAction {

    private final TotemTier totemTier;

    public TotemTierAction(TotemTier tier) {
        super(TotemVarbit.valueOf(tier.name()));
        this.totemTier = tier;
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.getProgress().put(totemTier, varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class DecorationsAction extends TotemAction {

    public DecorationsAction() {
        super(TotemVarbit.DECORATIONS);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setDecoration(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class DecayAction extends TotemAction {

    public DecayAction() {
        super(TotemVarbit.DECAY);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setDecay(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class AnimalAction extends TotemAction {

    private final int animal;

    public AnimalAction(int animal) {
        super(TotemVarbit.valueOf("ANIMAL_" + animal));
        this.animal = animal;
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.getAnimals()[animal - 1] = varbitChanged.getValue();
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class BaseCarvedAction extends TotemAction {

    public BaseCarvedAction() {
        super(TotemVarbit.BASE_CARVED);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setCarved(varbitChanged.getValue() == 1);
    }
}

package com.github.therealguru.totemfletching.action;

import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import net.runelite.api.events.VarbitChanged;

public class PointsAction extends TotemAction {

    public PointsAction() {
        super(TotemVarbit.POINTS);
    }

    @Override
    public void onVarbitChanged(Totem totem, VarbitChanged varbitChanged) {
        totem.setPoints(varbitChanged.getValue());
    }
}

package com.github.therealguru.totemfletching.service;

import lombok.Getter;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.widgets.WidgetID;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class EntTrailService {

    private static final List<Integer> ENT_TRAIL_GAME_OBJECT_IDS = List.of(57115, 57116);
    private static final List<Integer> ENT_TRAIL_INACTIVE_ANIMATION_IDS = List.of(12345);
    private static final List<Integer> ENT_TRAIL_ACTIVE_ANIMATION_IDS = List.of(12346);

    private final List<GameObject> entTrails = new ArrayList<>();

    public List<GameObject> getInactiveEntTrails() {
        return entTrails.stream().filter(entTrail -> entTrail.getRenderable() instanceof DynamicObject)
                .filter(entTrail -> ((DynamicObject) entTrail.getRenderable()).getAnimation() != null)
                .filter(entTrail -> ENT_TRAIL_INACTIVE_ANIMATION_IDS.contains(((DynamicObject) entTrail.getRenderable()).getAnimation().getId()))
                .collect(Collectors.toList());
    }

    public void addEntTrail(GameObjectSpawned spawned) {
        if(!isEntTrail(spawned.getGameObject())) return;

        entTrails.add(spawned.getGameObject());
    }

    public void removeEntTrail(GameObjectDespawned despawned) {
        entTrails.remove(despawned.getGameObject());
    }

    private boolean isEntTrail(GameObject gameObject) {
        return ENT_TRAIL_GAME_OBJECT_IDS.contains(gameObject.getId());
    }

    public void clearEntTrails() {
        this.entTrails.clear();
    }
}

package com.github.therealguru.totemfletching.service;

import com.github.therealguru.totemfletching.action.*;
import com.github.therealguru.totemfletching.model.Totem;
import com.github.therealguru.totemfletching.model.TotemTier;
import com.github.therealguru.totemfletching.model.TotemVarbit;
import lombok.Getter;
import net.runelite.api.GameObject;
import net.runelite.api.Player;
import net.runelite.api.events.VarbitChanged;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class TotemService {

    private static final List<Totem> TOTEMS = List.of(
            new Totem(1, 57016, 57020, 17611),
            new Totem(2, 57022, 57026, 17629),
            new Totem(3, 57028, 57032, 17647),
            new Totem(4, 57034, 57038, 17665),
            new Totem(5, 57040, 57044, 17683),
            new Totem(6, 57046, 57050, 17701),
            new Totem(7, 57052, 57056, 17719),
            new Totem(8, 57058, 57062, 17737)
    );

    private static final Map<TotemVarbit, TotemAction> TOTEM_ACTIONS = new HashMap<>();

    static {
        TOTEM_ACTIONS.put(TotemVarbit.ANIMAL_1, new AnimalAction(1));
        TOTEM_ACTIONS.put(TotemVarbit.ANIMAL_2, new AnimalAction(2));
        TOTEM_ACTIONS.put(TotemVarbit.ANIMAL_3, new AnimalAction(3));
        TOTEM_ACTIONS.put(TotemVarbit.BASE, new BaseAction());
        TOTEM_ACTIONS.put(TotemVarbit.BASE_CARVED, new BaseCarvedAction());
        TOTEM_ACTIONS.put(TotemVarbit.DECAY, new DecayAction());
        TOTEM_ACTIONS.put(TotemVarbit.DECORATIONS, new DecorationsAction());
        TOTEM_ACTIONS.put(TotemVarbit.POINTS, new PointsAction());
        TOTEM_ACTIONS.put(TotemVarbit.LOW, new TotemTierAction(TotemTier.LOW));
        TOTEM_ACTIONS.put(TotemVarbit.MID, new TotemTierAction(TotemTier.MID));
        TOTEM_ACTIONS.put(TotemVarbit.TOP, new TotemTierAction(TotemTier.TOP));
    }

    @Getter
    private Totem closestTotem = null;

    public void onVarbitChanged(final VarbitChanged varbitChanged) {
        Totem totem = TOTEMS.stream().filter(t -> t.isVarbitRelated(varbitChanged.getVarbitId())).findFirst().orElse(null);
        if (totem == null) return;

        TotemVarbit totemVarbit = TotemVarbit.getVarbit(totem, varbitChanged.getVarbitId());
        TotemAction action = TOTEM_ACTIONS.get(totemVarbit);
        if (action != null) {
            action.onVarbitChanged(totem, varbitChanged);
        }
    }

    public void addGameObject(final GameObject gameObject) {
        for (Totem totem : TOTEMS) {
            if (totem.getTotemGameObjectId() == gameObject.getId()) {
                totem.setTotemGameObject(gameObject);
            } else if (totem.getPointsGameObjectId() == gameObject.getId()) {
                totem.setPointsGameObject(gameObject);
            }
        }

    }

    public void removeGameObject(final GameObject gameObject) {
        for (Totem totem : TOTEMS) {
            if (totem.getTotemGameObjectId() == gameObject.getId()) {
                totem.setTotemGameObject(null);
            } else if (totem.getPointsGameObjectId() == gameObject.getId()) {
                totem.setPointsGameObject(null);
            }
        }
    }

    public void clearGameObjects() {
        getTotems().forEach(totem -> {
            totem.setTotemGameObject(null);
            totem.setPointsGameObject(null);
        });
    }

    public Map<Integer, Boolean> getAnimalsProgress(final Totem totem) {
        Map<Integer, Boolean> result = new HashMap<>();

        for (int animal : totem.getAnimals()) {
            int progressKey = animal + 9;
            boolean exists = totem.getProgress().containsValue(progressKey);
            result.put(animal, exists);
        }

        return result;
    }


    public List<Totem> getTotems() {
        return TOTEMS;
    }

    public void updateClosestTotem(Player player) {
        closestTotem = getTotems().stream()
                .filter(totem -> totem.getTotemGameObject() != null)
                .filter(totem -> totem.getTotemGameObject().getWorldLocation().distanceTo(player.getWorldLocation()) <= 10)
                .findFirst()
                .orElse(null);
    }
}

package com.github.therealguru.totemfletching;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TotemFletchingPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TotemFletchingPlugin.class);
		RuneLite.main(args);
	}
}
