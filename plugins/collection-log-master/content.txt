package com.collectionlogmaster.util;

import lombok.NonNull;

public class StringUtils {
    public static @NonNull String kebabCase(@NonNull String snakeCase) {
        return snakeCase.toLowerCase().replace('_', '-');
    }
}

package com.collectionlogmaster.util;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class EnumUtils {
    public static <T extends Enum<T>> T fromString(@NonNull Class<T> enumClass, String name) {
        for (T e : enumClass.getEnumConstants()) {
            if (EnumUtils.toString(e).equals(name)) {
                return e;
            }
        }

        log.warn("No enum const {} for name '{}'", enumClass.getName(), name);
        return null;
    }

    public static <T extends Enum<T>> @NonNull String toString(T enumValue) {
        return StringUtils.kebabCase(enumValue.name());
    }
}

package com.collectionlogmaster.util;

import net.runelite.client.eventbus.EventBus;

import javax.inject.Inject;

public abstract class EventBusSubscriber {
    @Inject
    EventBus eventBus = null;

    public void startUp() {
        eventBus.register(this);
    };

    public void shutDown() {
        eventBus.unregister(this);
    }
}

package com.collectionlogmaster.util;

import com.collectionlogmaster.CollectionLogMasterPlugin;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;

import static com.collectionlogmaster.util.GsonOverride.GSON;

public class FileUtils {
    /**
     * Loads a definition resource from a JSON file
     *
     * @param classType the class into which the data contained in the JSON file will be read into
     * @param resource  the name of the resource (file name)
     * @param <T>       the class type
     * @return the data read from the JSON definition file
     */
    public static <T> T loadDefinitionResource(Class<T> classType, String resource) {
        // Load the resource as a stream and wrap it in a reader
        InputStream resourceStream = classType.getResourceAsStream(resource);
        assert resourceStream != null;
        InputStreamReader definitionReader = new InputStreamReader(resourceStream);

        // Load the objects from the JSON file
        return GSON.fromJson(definitionReader, classType);
    }

    public static <T> T loadResource(String resourcePath, Type clazz) {
        try (InputStream is = CollectionLogMasterPlugin.class.getResourceAsStream(resourcePath)) {
            assert is != null;
            return GSON.fromJson(new InputStreamReader(is), clazz);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

package com.collectionlogmaster.util;

import com.google.inject.Inject;

import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class SimpleDebouncer {
    public interface Callback {
        void call();
    }

    Future<?> future;

    @Inject
    private ScheduledExecutorService executorService;

    private final static int MS_DELAY = 500;

    public synchronized void debounce(Callback cb) {
        if (future != null) {
            future.cancel(false);
            future = null;
        }

        future = executorService.schedule(cb::call, MS_DELAY, TimeUnit.MILLISECONDS);
    }
}

package com.collectionlogmaster.util;

import com.collectionlogmaster.PluginUpdateNotifier;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLiteProperties;
import okhttp3.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

import static com.collectionlogmaster.util.GsonOverride.GSON;

@Slf4j
public class HttpClient {
    private static final MediaType JSON_MEDIA_TYPE = Objects.requireNonNull(MediaType.parse("application/json; charset=utf-8"));

    @Inject
    private OkHttpClient okHttpClient;

    private final String userAgent;

    @Inject
    public HttpClient() {
        String runeliteVersion = RuneLiteProperties.getVersion();
        String pluginVersion = PluginUpdateNotifier.getPluginVersion();
        userAgent = "RuneLite:" + runeliteVersion + "," + "CLogMaster:" + pluginVersion;
    }

    private Request.Builder buildRequest(String url, Consumer<Request.Builder> methodSetter) {
        Request.Builder builder = new Request.Builder()
                .url(url)
                .header("Content-Type", "application/json")
                .header("User-Agent", userAgent);
        methodSetter.accept(builder);
        return builder;
    }

    private CompletableFuture<Response> executeHttpRequestAsync(Request request) {
        log.debug("Sending {} request to {}; data = {}", request.method(), request.url(), request.body());

        CompletableFuture<Response> future = new CompletableFuture<>();
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.warn("Async request failed.", e);
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                future.complete(response);
            }
        });
        return future;
    }

    public <T> CompletableFuture<T> postHttpRequestAsync(String url, String data, @Nullable Class<T> clazz) {
        RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, data);
        Request request = buildRequest(url, builder -> builder.post(body)).build();
        return executeHttpRequestAsync(request)
                .thenApply((response) -> handleResponse(response, clazz));
    }

    public <T> CompletableFuture<T> putHttpRequestAsync(String url, String data, @Nullable Class<T> clazz) {
        RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, data);
        Request request = buildRequest(url, builder -> builder.put(body)).build();
        return executeHttpRequestAsync(request)
                .thenApply((response) -> handleResponse(response, clazz));
    }

    public <T> CompletableFuture<T> getHttpRequestAsync(String url, @Nullable Class<T> clazz) {
        Request request = buildRequest(url, Request.Builder::get)
                .build();
        return executeHttpRequestAsync(request)
                .thenApply((response) -> handleResponse(response, clazz));
    }

    private <T> T handleResponse(Response response, @Nullable Class<T> clazz) {
        try (Response res = response) {
            ResponseBody body = res.body();

            if (body == null) {
                throw new RuntimeException("Response body is null");
            }

            String bodyString = body.string();
            if (!response.isSuccessful()) {
                throw new RuntimeException("Response unsuccessful: " + bodyString);
            }

            if (clazz == null) {
                return null;
            }

            return GSON.fromJson(bodyString, clazz);
        } catch (IOException e) {
            throw new RuntimeException("Error reading response body");
        }
    }
}

package com.collectionlogmaster.util;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.collectionlogmaster.domain.Tag;
import com.collectionlogmaster.domain.adapters.EnumAdapter;
import com.collectionlogmaster.domain.adapters.VerificationAdapter;
import com.collectionlogmaster.domain.verification.Verification;
import com.collectionlogmaster.domain.verification.VerificationMethod;
import com.collectionlogmaster.domain.verification.diary.DiaryDifficulty;
import com.collectionlogmaster.domain.verification.diary.DiaryRegion;
import net.runelite.api.Skill;

import javax.inject.Inject;

public class GsonOverride {
    /**
     * Custom Gson instance capable of parsing additional types.
     */
    public static Gson GSON;

    @Inject
    public GsonOverride(Gson originalGson) {
        GsonBuilder gsonBuilder = originalGson.newBuilder()
                .registerTypeAdapter(Verification.class, new VerificationAdapter())
                .registerTypeAdapter(VerificationMethod.class, new EnumAdapter<>(VerificationMethod.class))
                .registerTypeAdapter(DiaryRegion.class, new EnumAdapter<>(DiaryRegion.class))
                .registerTypeAdapter(DiaryDifficulty.class, new EnumAdapter<>(DiaryDifficulty.class))
                .registerTypeAdapter(Skill.class, new EnumAdapter<>(Skill.class))
                .registerTypeAdapter(Tag.class, new EnumAdapter<>(Tag.class));

        GSON = gsonBuilder.create();
    }
}

package com.collectionlogmaster;

import com.collectionlogmaster.domain.DynamicTaskImages;
import com.collectionlogmaster.domain.TaskTier;
import net.runelite.client.config.*;

import static com.collectionlogmaster.CollectionLogMasterConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface CollectionLogMasterConfig extends Config
{
    String CONFIG_GROUP = "collection-log-master";

    String PLUGIN_VERSION_KEY = "plugin-version";
    String IS_COMMAND_ENABLED_KEY = "isCommandEnabled";

    @Range(
            min = 1000,
            max = 10000
    )
    @Units(Units.MILLISECONDS)
    @ConfigItem(
            keyName = "rollTime",
            name = "Roll Time",
            description = "How long new tasks will take to roll",
            position = 1
    )
    default int rollTime()
    {
        return 5000;
    }

    @ConfigItem(
            keyName = "rollPastCompleted",
            name = "Roll past completed",
            description = "When rolling tasks, include those you've already completed in the roll animation. Helpful when you're getting to the end of a tier!",
            position = 2
    )
    default boolean rollPastCompleted()
    {
        return false;
    }

    @ConfigItem(
            keyName = "hideBelow",
            name = "Hide Tasks Below",
            description = "Disabled the showing up/assigning of tasks at or below the specified tier",
            position = 3
    )
    default TaskTier hideBelow()
    {
        return TaskTier.EASY;
    }

    @ConfigItem(
            keyName = "displayCurrentTaskOverlay",
            name = "Display current task overlay",
            description = "Enable an overlay showing the currently assigned task (when one exists)",
            position = 5
    )
    default boolean displayCurrentTaskOverlay()
    {
        return true;
    }

    @ConfigItem(
            keyName = "dynamicTaskImages",
            name = "Dynamic task images",
            description = "Display dynamic task images based on required/acquired items",
            position = 6
    )
    default DynamicTaskImages dynamicTaskImages()
    {
        return DynamicTaskImages.COMPLETE;
    }

    @ConfigItem(
            keyName = "isLMSEnabled",
            name = "Enable LMS tasks",
            description = "Whether to include LMS tasks in the list.",
            position = 7
    )
    default boolean isLMSEnabled()
    {
        return true;
    }

    @ConfigSection(
            name = "!taskman Command",
            description = "Configuration options for the !taskman command",
            position = 8
    )
    String command = "command";

    @ConfigItem(
            keyName = IS_COMMAND_ENABLED_KEY,
            name = "Enable command",
            description = "When you or others type !taskman in the chat, it will be replaced by your current task status",
            section = command,
            position = 0
    )
    default boolean isCommandEnabled()
    {
        return true;
    }
}

package com.collectionlogmaster.synchronization.diary;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.diary.AchievementDiaryVerification;
import com.collectionlogmaster.domain.verification.diary.DiaryDifficulty;
import com.collectionlogmaster.domain.verification.diary.DiaryRegion;
import com.collectionlogmaster.synchronization.Verifier;
import lombok.NonNull;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class AchievementDiaryVerifier implements Verifier {
    @Inject
    private AchievementDiaryService achievementDiaryService;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof AchievementDiaryVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof AchievementDiaryVerification;
        AchievementDiaryVerification verif = (AchievementDiaryVerification) task.getVerification();

        DiaryRegion diary = verif.getRegion();
        DiaryDifficulty difficulty = verif.getDifficulty();

        return achievementDiaryService.isComplete(diary, difficulty);
    }
}

package com.collectionlogmaster.synchronization.diary;

import com.collectionlogmaster.domain.verification.diary.DiaryDifficulty;
import com.collectionlogmaster.domain.verification.diary.DiaryRegion;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class AchievementDiaryService {
    private static final int DIARY_COMPLETION_SCRIPT = 2200;

    @Inject
    private Client client;

    // Code from: RuneProfile
    // Repository: https://github.com/ReinhardtR/runeprofile-plugin
    // License: BSD 2-Clause License
    public boolean isComplete(@NonNull DiaryRegion diary, @NonNull DiaryDifficulty difficulty) {
        // https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cdiary_completion_info%5D.cs2
        client.runScript(DIARY_COMPLETION_SCRIPT, diary.getId());
        int[] stack = client.getIntStack();

        return stack[difficulty.getStackOffset()] == 1;
    }
}

package com.collectionlogmaster.synchronization.clog;

import com.collectionlogmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton

// Code from: RuneProfile
// Repository: https://github.com/ReinhardtR/runeprofile-plugin
// License: BSD 2-Clause License
public class CollectionLogWidgetSubscriber extends EventBusSubscriber {
    @Inject
    private Client client;

    @Inject
    private CollectionLogService collectionLogService;

    private int tickCollectionLogScriptFired = -1;

    private boolean isAutoClogRetrieval = false;

    public void reset() {
        isAutoClogRetrieval = false;
        tickCollectionLogScriptFired = -1;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.HOPPING && gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onGameTick(GameTick gameTick) {
        int tick = client.getTickCount();
        boolean hasClogScriptFired = tickCollectionLogScriptFired != -1;
        boolean hasBufferPassed = tickCollectionLogScriptFired + 2 < tick;
        if (hasClogScriptFired && hasBufferPassed) {
            tickCollectionLogScriptFired = -1;
            log.debug("Clog items script has fired");
            isAutoClogRetrieval = false;
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();

            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int quantity = (int) args[2];

            if (quantity > 0) {
                collectionLogService.storeItem(itemId);
            }
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        final int COLLECTION_LOG_SETUP = 7797;
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
            if (isAutoClogRetrieval) {
                return;
            }

            // disallow updating from the adventure log, to avoid players updating their profile
            // while viewing other players collection logs using the POH adventure log.
            if (isOpenedFromAdventureLog()) return;

            isAutoClogRetrieval = true;
            client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
            client.runScript(2240);
        }
    }

    private boolean isOpenedFromAdventureLog() {
        return client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
    }
}

package com.collectionlogmaster.synchronization.clog;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.synchronization.Verifier;
import lombok.NonNull;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Singleton
public class CollectionLogVerifier implements Verifier {
    @Inject
    private CollectionLogService collectionLogService;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof CollectionLogVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof CollectionLogVerification;
        CollectionLogVerification verif = (CollectionLogVerification) task.getVerification();

        long totalObtained = Arrays.stream(verif.getItemIds())
                .filter(itemId -> this.collectionLogService.isItemObtained(itemId))
                .count();

        return totalObtained >= verif.getCount();
    }
}

package com.collectionlogmaster.synchronization.clog;

import com.collectionlogmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@Singleton
public class CollectionLogService extends EventBusSubscriber {
	@Inject
	public CollectionLogWidgetSubscriber collectionLogWidgetSubscriber;

    private final Set<Integer> obtainedItems = new HashSet<>();

    public void startUp() {
        super.startUp();
        collectionLogWidgetSubscriber.startUp();

        reset();
    }

    public void shutDown() {
        super.startUp();
        collectionLogWidgetSubscriber.shutDown();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    public boolean isItemObtained(int itemId) {
        return obtainedItems.contains(itemId);
    }

    public void storeItem(int itemId) {
        obtainedItems.add(itemId);
    }

    public void reset() {
        obtainedItems.clear();
    }
}

package com.collectionlogmaster.synchronization;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.synchronization.clog.CollectionLogVerifier;
import com.collectionlogmaster.synchronization.diary.AchievementDiaryVerifier;
import com.collectionlogmaster.synchronization.skill.SkillVerifier;
import com.collectionlogmaster.task.TaskService;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton
public class SyncService {
    @Inject
    private Client client;

    @Inject
    private CollectionLogMasterPlugin plugin;

    @Inject
    private TaskService taskService;

    @Inject
    private SyncService syncService;

    @Inject
    private CollectionLogVerifier collectionLogVerifier;

    @Inject
    private AchievementDiaryVerifier achievementDiaryVerifier;

    @Inject
    private SkillVerifier skillVerifier;

    private @NonNull Verifier[] getVerifiers() {
        return new Verifier[]{
            this.collectionLogVerifier,
            this.achievementDiaryVerifier,
            this.skillVerifier
        };
    }

    private Boolean verify(Task task) {
        for (Verifier verif : this.getVerifiers()) {
            if (verif.supports(task)) {
                return verif.verify(task);
            }
        }

        return null;
    }

    public void sync() {
        int updatedCount = 0;
        for (TaskTier tier : TaskTier.values()) {
            for (Task task : taskService.getTierTasks(tier)) {
                Boolean isVerified = syncService.verify(task);
                if (isVerified == null) {
                    continue;
                }

                boolean taskChanged = isVerified != taskService.isComplete(task.getId());

                if (!taskChanged) {
                    continue;
                }

                plugin.completeTask(task.getId(), false);

                String newStatus = isVerified ? "<col=27ae60>complete</col>" : "<col=c0392b>incomplete</col>";
                String msg = String.format("%s tier task '%s' marked as %s", tier.displayName, task.getName(), newStatus);
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, "");

                updatedCount++;
            }
        }

        String msg = String.format("Task synchronization finalized; %d task updated", updatedCount);
        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
    }
}

package com.collectionlogmaster.synchronization;

import com.collectionlogmaster.domain.Task;
import lombok.NonNull;

public interface Verifier {
    boolean supports(@NonNull Task task);
    boolean verify(@NonNull Task task);
}

package com.collectionlogmaster.synchronization.skill;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.skill.SkillVerification;
import com.collectionlogmaster.synchronization.Verifier;
import lombok.NonNull;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class SkillVerifier implements Verifier {
    @Inject
    private Client client;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof SkillVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof SkillVerification;
        SkillVerification verif = (SkillVerification) task.getVerification();

        long totalAchieved = verif.getExperience().entrySet().stream()
                .filter(entry -> entry.getKey() != null)
                .filter(entry -> client.getSkillExperience(entry.getKey()) > entry.getValue())
                .count();

        return totalAchieved >= verif.getCount();
    }
}

package com.collectionlogmaster;

import com.collectionlogmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

import static com.collectionlogmaster.CollectionLogMasterConfig.CONFIG_GROUP;
import static com.collectionlogmaster.CollectionLogMasterConfig.PLUGIN_VERSION_KEY;

@Slf4j
@Singleton
public class PluginUpdateNotifier extends EventBusSubscriber {
    private static final String[] UPDATE_MESSAGES = {
            "<colHIGHLIGHT>Collection Log Master updated to v" + getPluginVersion(),
            "<colHIGHLIGHT>- Added option to disable LMS tasks",
            "<colHIGHLIGHT>- Removed the command reminder",
            "<colHIGHLIGHT>- Other minor fixes and improvements",
    };

    @Inject
    ConfigManager configManager;

    @Inject
    ChatMessageManager chatMessageManager;

    public static String getPluginVersion() {
        try (InputStream is = CollectionLogMasterPlugin.class.getResourceAsStream("version")) {
            assert is != null;
            return new String(is.readAllBytes(), StandardCharsets.UTF_8)
                    .replace("-SNAPSHOT", "");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState == GameState.LOGGED_IN) {
            checkUpdate();
        }
    }

    private void checkUpdate() {
        boolean isDebug = false;
        String curVersion = getPluginVersion();
        String lastVersion = configManager.getRSProfileConfiguration(CONFIG_GROUP, PLUGIN_VERSION_KEY);

        //noinspection ConstantValue
        if (isDebug || !curVersion.equals(lastVersion)) {
            configManager.setRSProfileConfiguration(CONFIG_GROUP, PLUGIN_VERSION_KEY, curVersion);
            notifyUpdate();
        }
    }

    private void notifyUpdate() {
        //noinspection ConstantConditions
        if (UPDATE_MESSAGES == null) return;

        String replacedMessage = String.join("<br>", UPDATE_MESSAGES);
        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(replacedMessage)
                        .build()
        );
    }
}

package com.collectionlogmaster.ui.generic;

import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a graphic display component, effectively just a game sprite.
 * @author Antipixel
 */
public class UIGraphic extends UIComponent
{
	/**
	 * Constructs a new graphic component
	 * @param widget the underlying widget
	 */
	public UIGraphic(Widget widget)
	{
		super(widget);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param spriteID the sprite ID
	 */
	public void setSprite(int spriteID)
	{
		this.getWidget().setSpriteId(spriteID);
	}

	/**
	 * Sets the sprite to display on the component
	 * @param itemID the item ID
	 */
	public void setItem(int itemID)
	{
		this.getWidget().setItemQuantity(100);
		this.getWidget().setItemQuantityMode(ItemQuantityMode.NEVER);
		this.getWidget().setItemId(itemID);
	}
}

package com.collectionlogmaster.ui.generic;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.FontID;
import net.runelite.api.ScriptEvent;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.*;

import java.util.Set;

public class UINativeButton extends UIComponent {
	public static final int CORNER_SIZE = 9;

	private static final int[] DEFAULT_SPRITES = {
		SpriteID.TRADEBACKING,
		SpriteID.V2StoneButtonOut.A_TOP_LEFT,
		SpriteID.V2StoneButtonOut.A_TOP_RIGHT,
		SpriteID.V2StoneButtonOut.A_BOTTOM_LEFT,
		SpriteID.V2StoneButtonOut.A_BOTTOM_RIGHT,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_LEFT,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_TOP,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_RIGHT,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_BOTTOM,
	};

	private static final int[] HOVER_SPRITES = {
		SpriteID.TRADEBACKING_DARK,
		SpriteID.V2StoneButtonIn.A_TOP_LEFT,
		SpriteID.V2StoneButtonIn.A_TOP_RIGHT,
		SpriteID.V2StoneButtonIn.A_BOTTOM_LEFT,
		SpriteID.V2StoneButtonIn.A_BOTTOM_RIGHT,
		SpriteID.V2StoneButtonIn.A_LEFT,
		SpriteID.V2StoneButtonIn.A_TOP,
		SpriteID.V2StoneButtonIn.A_RIGHT,
		SpriteID.V2StoneButtonIn.A_BOTTOM,
	};

	private static final int[] DISABLED_SPRITES = {
		SpriteID.TRADEBACKING_DARK,
		SpriteID.V2StoneButton.TOP_LEFT,
		SpriteID.V2StoneButton.TOP_RIGHT,
		SpriteID.V2StoneButton.BOTTOM_LEFT,
		SpriteID.V2StoneButton.BOTTOM_RIGHT,
		SpriteID.V2StoneButton.LEFT,
		SpriteID.V2StoneButton.TOP,
		SpriteID.V2StoneButton.RIGHT,
		SpriteID.V2StoneButton.BOTTOM,
	};

	@Getter
	@RequiredArgsConstructor
	public enum State {
		DEFAULT(0xFFFFFF, DEFAULT_SPRITES),
		HOVER(0xFFFFFF, HOVER_SPRITES),
		DISABLED(0x969696, DISABLED_SPRITES);

		private final int textColor;
		private final int[] sprites;
	}

	@Getter
	private State state = State.DEFAULT;

	private final Widget background;
	private final Widget topLeftCorner;
	private final Widget topRightCorner;
	private final Widget bottomLeftCorner;
	private final Widget bottomRightCorner;
	private final Widget leftEdge;
	private final Widget topEdge;
	private final Widget rightEdge;
	private final Widget bottomEdge;
	private final Widget textWidget;

	private final Widget[] allGraphics;

	public UINativeButton(Widget widget) {
		super(widget, Set.of(WidgetType.LAYER));

		background = widget.createChild(WidgetType.GRAPHIC);
		topLeftCorner = widget.createChild(WidgetType.GRAPHIC);
		topRightCorner = widget.createChild(WidgetType.GRAPHIC);
		bottomLeftCorner = widget.createChild(WidgetType.GRAPHIC);
		bottomRightCorner = widget.createChild(WidgetType.GRAPHIC);
		leftEdge = widget.createChild(WidgetType.GRAPHIC);
		topEdge = widget.createChild(WidgetType.GRAPHIC);
		rightEdge = widget.createChild(WidgetType.GRAPHIC);
		bottomEdge = widget.createChild(WidgetType.GRAPHIC);
		allGraphics = new Widget[]{background, topLeftCorner, topRightCorner, bottomLeftCorner, bottomRightCorner, leftEdge, topEdge, rightEdge, bottomEdge};

		textWidget = widget.createChild(WidgetType.TEXT);

		applyStaticStyles();
		applyStatefulStyles();
	}

	public void setState(State state) {
		this.state = state;
		applyStatefulStyles();
	}

	public void setText(String text) {
		textWidget.setText(text);
	}

	@Override
	protected void onActionSelected(ScriptEvent e) {
		if (state == State.DISABLED) return;

		super.onActionSelected(e);
	}

	@Override
	protected void onMouseHover(ScriptEvent e) {
		super.onMouseHover(e);

		if (state == State.DEFAULT) {
			setState(State.HOVER);
		}
	}

	@Override
	protected void onMouseLeave(ScriptEvent e) {
		super.onMouseLeave(e);

		if (state == State.HOVER) {
			setState(State.DEFAULT);
		}
	}

	private void applyStaticStyles() {
		background
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setSpriteTiling(true);

		topLeftCorner
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE);

		topRightCorner
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE);

		bottomLeftCorner
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE);

		bottomRightCorner
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE);

		leftEdge
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE, CORNER_SIZE * 2)
			.setSpriteTiling(true);

		topEdge
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE * 2, CORNER_SIZE)
			.setSpriteTiling(true);

		rightEdge
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE, CORNER_SIZE * 2)
			.setSpriteTiling(true);

		bottomEdge
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE * 2, CORNER_SIZE)
			.setSpriteTiling(true);

		textWidget
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setFontId(FontID.BOLD_12)
			.setTextShadowed(true);

		revalidate();
	}

	private void applyStatefulStyles() {
		int[] sprites = state.getSprites();
		for (int i = 0; i < allGraphics.length; i++) {
			allGraphics[i].setSpriteId(sprites[i]);
		}

		textWidget.setTextColor(state.getTextColor());
	}

	@Override
	public void revalidate() {
		super.revalidate();

		for (Widget g : allGraphics) {
			g.revalidate();
		}

		textWidget.revalidate();
	}
}

package com.collectionlogmaster.ui.generic;

import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

/**
 * A group of UIComponents
 * @author Antipixel
 */
public class UIPage
{
	@Getter
	private boolean visible;
	private List<UIComponent> components;

	/**
	 * Constructs a new UI page
	 */
	public UIPage()
	{
		this.components = new ArrayList<>();
	}

	/**
	 * Sets the visibility for all the components in the page
	 * @param visibility true for visible, false for hidden
	 */
	public void setVisibility(boolean visibility)
	{
		this.visible = visibility;
		// Update the visibility for each of the components
		this.components.forEach(c -> c.setVisibility(visibility));
	}

	/**
	 * Adds a UI component to the page
	 * @param component the component to add
	 */
	public void add(UIComponent component)
	{
		this.components.add(component);
	}

	/**
	 * Removes a UI component from the page
	 * @param component the component to remove
	 */
	public void remove(UIComponent component)
	{
		this.components.remove(component);
	}
}

package com.collectionlogmaster.ui.generic;

/**
 * A listener interface for receiving UI component events
 * @author Antipixel
 */
public interface ComponentEventListener<T extends UIComponent>
{
	/**
	 * Invoked upon a component event
	 * @param src the source component responsible for the event
	 */
	void onComponentEvent(T src);
}


package com.collectionlogmaster.ui.generic;

import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetTextAlignment;

import java.awt.*;

/**
 * This class wraps a game widget and gives it the functionality of
 * a text label component, with basic control over text colour and font.
 * @author Antipixel
 */
public class UILabel extends UIComponent
{
	/**
	 * Constructs a new label component
	 * @param labelWidget the underlying widget
	 */
	public UILabel(Widget labelWidget)
	{
		super(labelWidget);

		// Set default font and text colour
		this.setFont(FontID.PLAIN_11);
		this.setColour(Color.WHITE.getRGB());

		// Set the alignment to centre and enable text shadowing
		labelWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		labelWidget.setTextShadowed(true);
	}

	/**
	 * Sets the display text of the label
	 * @param text the display text
	 */
	public void setText(String text)
	{

		this.getWidget().setText(text);
	}

	/**
	 * Sets the font of the label
	 * @param fontID the font ID, specified in {@link FontID}
	 */
	public void setFont(int fontID)
	{
		this.getWidget().setFontId(fontID);
	}

	/**
	 * Sets the colour of the label text
	 * @param colour the RGB colour
	 */
	public void setColour(int colour)
	{
		this.getWidget().setTextColor(colour);
	}
}

package com.collectionlogmaster.ui.generic;

/**
 * A listener interface for receiving menu actions
 * @author Antipixel
 */
public interface MenuAction
{
	/**
	 * Invoked upon selection of the menu action that is is bound to
	 */
	void onMenuAction();
}

package com.collectionlogmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps two widgets, one a sprite and one text, and gives them the
 * functionality of a checkbox component. A listener can be added to the checkbox
 * which triggers upon the switching of the checkbox state between check and unchecked.
 * @author Antipixel
 */
public class UICheckBox extends UIComponent
{
	private static final int LABEL_COL_DEFAULT = 0xFF981F;
	private static final int LABEL_COL_HOVER = 0xFFFFFF;
	private static final int LABEL_WIDTH = 89;
	private static final int LABEL_HEIGHT = 18;

	private static final int SPRITEID_CHECKBOX_UNCHECKED_STD = 1215;
	private static final int SPRITEID_CHECKBOX_CHECKED_STD = 1217;
	private static final int SPRITEID_CHECKBOX_UNCHECKED_HOV = 1218;
	private static final int SPRITEID_CHECKBOX_CHECKED_HOV = 1220;
	private static final int CHECKBOX_SIZE = 16;

	private static final String OPTION_TOGGLE = "Toggle";

	private UILabel label;
	private UIGraphic checkbox;

	@Getter
	private boolean enabled;
	private boolean hovering;

	@Setter
	private ComponentEventListener<UICheckBox> toggleListener;

	/**
	 * Constructs a new checkbox component
	 * @param boxIcon the checkbox graphic widget
	 * @param labelWidget the checkbox label widget
	 */
	public UICheckBox(Widget boxIcon, Widget labelWidget)
	{
		super(boxIcon);

		this.enabled = false;
		this.hovering = false;

		// Wrap the widget in a label component, set the
		// dimension, colour and attach the listeners
		this.label = new UILabel(labelWidget);
		this.label.setSize(LABEL_WIDTH, LABEL_HEIGHT);
		this.label.setColour(LABEL_COL_DEFAULT);
		this.label.setOnHoverListener(this::onLabelHover);
		this.label.setOnLeaveListener(this::onLabelLeave);
		this.label.addAction(OPTION_TOGGLE, this::onCheckboxToggled);

		this.checkbox = new UIGraphic(boxIcon);
		this.checkbox.addAction(OPTION_TOGGLE, this::onCheckboxToggled);
		this.checkbox.setOnHoverListener(e -> onLabelHover(label));
		this.checkbox.setOnLeaveListener(e -> onLabelLeave(label));

		// Resize and update the sprite for the checkbox widget
		this.updateCheckboxSprite();
		this.setSize(CHECKBOX_SIZE, CHECKBOX_SIZE);
	}

	/**
	 * Called upon the mouse hovering over the label component
	 * @param src the label component
	 */
	private void onLabelHover(UIComponent src)
	{
		// Update the hovering state
		this.hovering = true;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_HOVER);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	/**
	 * Called upon the mouse leaving the label component
	 * @param src the label component
	 */
	private void onLabelLeave(UIComponent src)
	{
		// Update the hovering state
		this.hovering = false;

		// Update the label colour
		UILabel label = (UILabel) src;
		label.setColour(LABEL_COL_DEFAULT);

		// Make sure the checkbox sprite is up to date
		this.updateCheckboxSprite();
	}

	@Override
	public void setX(int x)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setX(x);
		this.label.setX(x);
	}

	@Override
	public void setY(int y)
	{
		// Match the position of the label
		// to that of the checkbox
		super.setY(y);
		this.label.setY(y);
	}

	@Override
	public void setName(String name)
	{
		// Set the name of the label instead
		this.label.setName(name);
	}

	/**
	 * Called upon the toggle menu action being selected on the checkbox component
	 */
	private void onCheckboxToggled()
	{
		// Switch the checked state
		this.setEnabled(!enabled);

		// If there's a toggle listener registered, call it
		if (this.toggleListener != null)
			this.toggleListener.onComponentEvent(this);
	}

	/**
	 * Updates the sprite for the checkbox, depending on whether the checkbox
	 * is enabled or disabled, or if the mouse is hovering over it
	 */
	private void updateCheckboxSprite()
	{
		// Get both standard and hovering sprites for the current enable state
		int stdSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_STD : SPRITEID_CHECKBOX_UNCHECKED_STD;
		int hovSprite = enabled ? SPRITEID_CHECKBOX_CHECKED_HOV : SPRITEID_CHECKBOX_UNCHECKED_HOV;

		// Apply it to the checkbox widget, depending on whether the mouse is hovering
		this.getWidget().setSpriteId(this.hovering ? hovSprite : stdSprite);
	}

	/**
	 * Sets the state of the checkbox, checked or unchecked
	 * @param enabled true for checked, false for unchecked
	 */
	public void setEnabled(boolean enabled)
	{
		// Set the new state
		this.enabled = enabled;

		// Update the sprite
		this.updateCheckboxSprite();
	}

	/**
	 * Sets the text of the checkbox label
	 * @param text the label text
	 */
	public void setText(String text)
	{
		this.label.setText(text);
	}

	// Align checkbox to right hand side of the window near the close button
	public void alignToRightEdge(Widget window, int marginFromEdge, int y)
	{
		int windowWidth = window.getWidth();
		int checkboxX = windowWidth - LABEL_WIDTH - CHECKBOX_SIZE - marginFromEdge;
		this.setPosition(checkboxX, y);
		
		// Force widget position updates
		this.getWidget().setPos(checkboxX, y);
		this.label.getWidget().setPos(checkboxX + CHECKBOX_SIZE + 4, y); // 4px spacing between checkbox and label
		
		// Revalidate widgets
		this.getWidget().revalidate();
		this.label.getWidget().revalidate();
	}
}

package com.collectionlogmaster.ui.generic;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * UI Component classes allow for complex user interface functionality by
 * wrapping the gaming widget and carefully controlling its behaviour
 * @author Antipixel
 */
public abstract class UIComponent
{
	private static final int MAX_OPACITY = 255;
	private static final String BTN_NAME_FORMAT = "<col=ff9040>%s</col>";

	@Getter
	protected Widget widget;

	/* Actions and events */
	protected List<MenuAction> actions;

	@Setter
	private ComponentEventListener<UIComponent> hoverListener;

	@Setter
	private ComponentEventListener<UIComponent> leaveListener;

	@Setter
	private ComponentEventListener<UIComponent> mousePressListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseDragListener;

	@Setter
	private ComponentEventListener<UIComponent> mouseReleaseListener;

	/**
	 * Constructs a new UIComponent
	 * @param widget the underlying game widget
	 */
	public UIComponent(Widget widget)
	{
		this.widget = widget;

		// Assign the event listeners to the widget
		this.widget.setOnOpListener((JavaScriptCallback) this::onActionSelected);
		this.widget.setOnMouseOverListener((JavaScriptCallback) this::onMouseHover);
		this.widget.setOnMouseLeaveListener((JavaScriptCallback) this::onMouseLeave);
		this.widget.setHasListener(true);

		this.actions = new ArrayList<>();
	}

	public UIComponent(Widget widget, Set<Integer> allowedTypes) {
		this(widget);

		if (!allowedTypes.contains(widget.getType())) {
			String msg = String.format("Incompatible widget's type given; %s given, %d expected", allowedTypes, widget.getType());
			throw new RuntimeException(msg);
		}
	}

	/**
	 * Adds an action option to the component's menu
	 * @param action the action name
 	 * @param callback the callback event, which is trigger upon the
	 *                 selection of this menu option
	 */
	public void addAction(String action, MenuAction callback)
	{
		this.widget.setAction(actions.size(), action);
		this.actions.add(callback);
	}

	/**
	 * Triggered upon the selection of menu option
	 * @param e the script event
	 */
	protected void onActionSelected(ScriptEvent e)
	{
		// If there's no actions specified, ignore
		if (this.actions.isEmpty())
			return;

		// Get the action event object for this menu option
		MenuAction actionEvent = this.actions.get(e.getOp() - 1);

		// Call the action listener for this option
		actionEvent.onMenuAction();
	}

	/**
	 * Triggered upon the mouse entering the component
	 * @param e the script event
	 */
	protected void onMouseHover(ScriptEvent e)
	{
		// If a hover event is specified, trigger it
		if (this.hoverListener != null)
			this.hoverListener.onComponentEvent(this);
	}

	/**
	 * Triggered upon the mouse leaving the component
	 * @param e the script event
	 */
	protected void onMouseLeave(ScriptEvent e)
	{
		// If a leave event is specified, trigger it
		if (this.leaveListener != null)
			this.leaveListener.onComponentEvent(this);
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * hovering over the widget
	 * @param listener the listener
	 */
	public void setOnHoverListener(ComponentEventListener<UIComponent> listener)
	{
		this.hoverListener = listener;
	}

	/**
	 * Sets a listener which will be called upon the mouse
	 * exiting from over the widget
	 * @param listener the listener
	 */
	public void setOnLeaveListener(ComponentEventListener<UIComponent> listener)
	{
		this.leaveListener = listener;
	}

	/**
	 * Sets the name of the component widget
	 * @param name the component name
	 */
	public void setName(String name)
	{
		this.widget.setName(String.format(BTN_NAME_FORMAT, name));
	}

	/**
	 * Sets the component size
	 * @param width the component width
	 * @param height the component height
	 */
	public void setSize(int width, int height)
	{
		this.widget.setOriginalWidth(width);
		this.widget.setOriginalHeight(height);
	}

	public void setSizeMode(int widthMode, int heightMode)
	{
		this.widget.setWidthMode(widthMode);
		this.widget.setHeightMode(heightMode);
	}

	/**
	 * Sets the position of the component, relative
	 * to the parent layer widget
	 * @param x the x position
	 * @param y the y position
	 */
	public void setPosition(int x, int y)
	{
		this.setX(x);
		this.setY(y);
	}

	/**
	 * Sets the X position of the component, relative
	 * to the parent layer
	 * @param x the x position
	 */
	public void setX(int x)
	{
		this.widget.setOriginalX(x);
	}

	/**
	 * Sets the Y position of the component, relative
	 * to the parent layer
	 * @param y the x position
	 */
	public void setY(int y)
	{
		this.widget.setOriginalY(y);
	}

	/**
	 * Gets the X position of the component, relative
	 * to the the parent layer
	 * @return the x position
	 */
	public int getX()
	{
		return this.widget.getOriginalX();
	}

	/**
	 * Gets the Y position of the component, relative
	 * to the the parent layer
	 * @return the y position
	 */
	public int getY()
	{
		return this.widget.getOriginalY();
	}


	/**
	 * Sets the visibility of the component
	 * @param visible true for visible, false for hidden
	 */
	public void setVisibility(boolean visible)
	{
		this.widget.setHidden(!visible);
	}

	/**
	 * Sets the opacity of the widget
	 * @param opacity the opacity value. Expects a value
	 *                between 0.0 (transparent) and 1.0 (opaque)
	 */
	public void setOpacity(float opacity)
	{
		// Cap the opacity to 1.0
		if (opacity > 1.0)
			opacity = 1.0f;

		// Invert the percentage
		float percentage = 1.0f - opacity;

		// Convert the percentage value to a 0-255 integer
		this.widget.setOpacity((int)(percentage * MAX_OPACITY));
	}

	/**
	 * Gets the opacity of the widget
	 * @return an opacity value between 0.0 (transparent) and 1.0 (opaque)
	 */
	public float getOpacity()
	{
		// Convert the opacity to a percentage
		float opacity = (float)this.widget.getOpacity() / MAX_OPACITY;

		// Invert the percentage
		return 1.0f - opacity;
	}

	public void clearActions() {
		actions.clear();
		this.widget.clearActions();
	}

	public void revalidate() {
		this.widget.revalidate();
	}
}

package com.collectionlogmaster.ui.generic;

import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.Widget;

/**
 * This class wraps a game widget and gives it the functionality
 * of a button, with the option of a second sprite shown on hover
 * @author Antipixel
 */
public class UIButton extends UIComponent
{
	private int spriteStandard;
	private int spriteHover;

	/**
	 * Constructs a new button component
	 * @param widget the underlying widget
	 */
	public UIButton(Widget widget)
	{
		super(widget);

		// Blank the sprites
		this.spriteStandard = -1;
		this.spriteHover = -1;
	}

	@Override
	protected void onMouseHover(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseHover(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteHover);
	}

	@Override
	protected void onMouseLeave(ScriptEvent e)
	{
		// Call the parent method
		super.onMouseLeave(e);

		// Update the sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the button sprite for both standard and hover
	 * @param standard the standard sprite id
	 * @param hover the sprite to display on hover
	 */
	public void setSprites(int standard, int hover)
	{
		this.spriteStandard = standard;
		this.spriteHover = hover;

		// Update the widgets sprite
		this.getWidget().setSpriteId(this.spriteStandard);
	}

	/**
	 * Sets the sprite for the button, for buttons
	 * without a sprite for hovering state
	 * @param standard the button sprite
	 */
	public void setSprites(int standard)
	{
		this.setSprites(standard, standard);
	}
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.InterfaceManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class TaskOverlay extends Overlay {

    private static final Dimension EMPTY = new Dimension(0, 0);

    private static final int WIDTH_ADDITION = 51;
    private static final int MIN_HEIGHT = 46;

    private static final float OUTER_COLOR_OFFSET = 0.8f;
    private static final float INNER_COLOR_OFFSET = 1.2f;
    private static final float ALPHA_OFFSET = 1.4f;

    private static final int MAX_BYTE = 255;

    @Inject
    private CollectionLogMasterConfig config;

    @Inject
    private RuneLiteConfig runeLiteConfig;

    @Inject
    private ItemManager itemManager;

    @Inject
    private InterfaceManager interfaceManager;

    @Inject
    private TaskService taskService;

    @Override
    public Dimension render(Graphics2D g) {
        try {
            Task activeTask = taskService.getActiveTask();
            if (!config.displayCurrentTaskOverlay() || activeTask == null || interfaceManager.isDashboardOpen()) {
                return EMPTY;
            }

            Image icon = itemManager.getImage(activeTask.getDisplayItemId());
            String task = activeTask.getName();


            FontMetrics fm = g.getFontMetrics();

            int width = fm.stringWidth(task) + WIDTH_ADDITION;
            int height = MIN_HEIGHT;

            Color border = outsideColor(this.runeLiteConfig.overlayBackgroundColor());

            g.setColor(this.runeLiteConfig.overlayBackgroundColor());
            g.fillRect(0, 0, width, height);
            g.setColor(border);
            g.drawRect(0, 0, width, height);

//            int textX = 46;
            int textX = width - fm.stringWidth(task) - 5;
            int textY = 30;

            g.setFont(g.getFont().deriveFont(16f));
            g.setColor(Color.BLACK);
            g.drawString(task, textX + 1, textY + 1);
            g.setColor(Color.WHITE);
            g.drawString(task, textX, textY);

            int iconWidth = icon.getWidth(null);
            int iconHeight = icon.getHeight(null);

            g.drawImage(icon, 5 + 18 - (iconWidth / 2), 5 + 18 - (iconHeight / 2), iconWidth, iconHeight, null);
            return new Dimension(width, height);
        } catch (Throwable t) {
            t.printStackTrace();
            return EMPTY;
        }
    }

    private Color outsideColor(Color base) {
        return new Color(
                Math.round(base.getRed() * OUTER_COLOR_OFFSET),
                Math.round(base.getGreen() * OUTER_COLOR_OFFSET),
                Math.round(base.getBlue() * OUTER_COLOR_OFFSET),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }

    private Color innerColor(Color base) {
        return new Color(
                Math.min(MAX_BYTE, Math.round(base.getRed() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getGreen() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getBlue() * INNER_COLOR_OFFSET)),
                Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
        );
    }
}

package com.collectionlogmaster.ui.component;

import com.google.inject.Inject;
import com.collectionlogmaster.util.EventBusSubscriber;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.eventbus.Subscribe;

import java.util.*;

@Slf4j
public class BurgerMenuManager extends EventBusSubscriber {
    private static final int DRAW_BURGER_MENU_SCRIPT_ID = 7812;
    private static final int COLLECTION_LOG_SETUP_SCRIPT_ID = 7797;
    private static final int COLLECTION_LOG_BURGER_MENU_WIDGET_ID = 40697929;

    private static final int BG_OPACITY = 255;
    private static final int BG_OPACITY_SELECTED = 230;
    private static final int TEXT_OPACITY = 0;
    private static final int TEXT_OPACITY_SELECTED = 200;
    private static final int TEXT_COLOR = 0xFF981F;
    private static final int TEXT_COLOR_SELECTED = 0xC8C8C8;
    private static final int TEXT_COLOR_HOVER = 0xFFFFFF;

    private static final String BUTTON_TEXT = "Tasks";
    private static final String ACTION_TEXT = "View Tasks Dashboard";

    @Inject
    private Client client;

    private Widget menu;
    private Widget ourBackground;
    private Widget ourText;
    private Widget firstBackground;
    private Widget firstText;

    private int baseMenuHeight = -1;

    @Getter
    private boolean selected = false;

    @Setter
    private Runnable onSelectChangedListener = null;

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        int scriptId = event.getScriptId();
        if (scriptId == COLLECTION_LOG_SETUP_SCRIPT_ID) {
            setSelected(false);
            baseMenuHeight = -1;
        }

        if (scriptId != DRAW_BURGER_MENU_SCRIPT_ID) {
            return;
        }

        Object[] args = event.getScriptEvent().getArguments();
        int menuId = (int) args[3];
        if (menuId != COLLECTION_LOG_BURGER_MENU_WIDGET_ID) {
            return;
        }

        try {
            log.debug("Adding task dashboard button to menu with ID: {}", menuId);
            addButton(menuId);
        } catch (Exception e) {
            log.debug("Failed to add task dashboard button to menu: {}", e.getMessage());
        }
    }

    public void setSelected(boolean selected) {
        if (this.selected == selected) return;

        this.selected = selected;
        restyleOptions();

        if (this.onSelectChangedListener != null) {
            this.onSelectChangedListener.run();
        }
    }

    private void restyleOptions() {
        if (ourBackground == null || ourText == null) return;

        Widget selectedBackground = selected ? ourBackground : firstBackground;
        Widget selectedText = selected ? ourText : firstText;
        Widget defaultBackground = selected ? firstBackground : ourBackground;
        Widget defaultText = selected ? firstText : ourText;

        selectedBackground.setOpacity(BG_OPACITY_SELECTED);
        selectedText.setOpacity(TEXT_OPACITY_SELECTED)
            .setTextColor(TEXT_COLOR_SELECTED);

        defaultBackground.setOpacity(BG_OPACITY);
        defaultText.setOpacity(TEXT_OPACITY)
            .setTextColor(TEXT_COLOR);

        selectedBackground.revalidate();
        selectedText.revalidate();
        defaultBackground.revalidate();
        defaultText.revalidate();
    }

    private void addButton(int menuId) throws NullPointerException, NoSuchElementException {
        Widget menu = Objects.requireNonNull(client.getWidget(menuId));
        List<Widget> menuChildren = Arrays.asList(Objects.requireNonNull(menu.getChildren()));
        if (baseMenuHeight == -1) {
            baseMenuHeight = menu.getOriginalHeight();
        }

        setupFirstWidgets(menuChildren);
        List<Widget> reversedMenuChildren = new ArrayList<>(menuChildren);
        Collections.reverse(reversedMenuChildren);
        Widget lastBackground = getFirstWidgetOfType(reversedMenuChildren, WidgetType.RECTANGLE);
        Widget lastText = getFirstWidgetOfType(reversedMenuChildren, WidgetType.TEXT);

        final int buttonHeight = lastBackground.getHeight();
        final int buttonY = lastBackground.getOriginalY() + buttonHeight;

        final boolean existingButton = menuChildren.stream()
                .anyMatch(w -> w.getText().equals(BUTTON_TEXT));

        if (!existingButton) {
            this.menu = menu;

            ourBackground = menu.createChild(WidgetType.RECTANGLE)
                    .setOriginalWidth(lastBackground.getOriginalWidth())
                    .setOriginalHeight(lastBackground.getOriginalHeight())
                    .setOriginalX(lastBackground.getOriginalX())
                    .setOriginalY(buttonY)
                    .setOpacity(lastBackground.getOpacity())
                    .setFilled(lastBackground.isFilled())
                    .setTextColor(lastBackground.getTextColor());
            ourBackground.revalidate();

            ourText = menu.createChild(WidgetType.TEXT)
                    .setText(BUTTON_TEXT)
                    .setTextColor(TEXT_COLOR)
                    .setFontId(lastText.getFontId())
                    .setTextShadowed(lastText.getTextShadowed())
                    .setOriginalWidth(lastText.getOriginalWidth())
                    .setOriginalHeight(lastText.getOriginalHeight())
                    .setOriginalX(lastText.getOriginalX())
                    .setOriginalY(buttonY)
                    .setXTextAlignment(lastText.getXTextAlignment())
                    .setYTextAlignment(lastText.getYTextAlignment());
            ourText.setHasListener(true);
            ourText.setOnMouseOverListener((JavaScriptCallback) ev -> { if (!selected) ourText.setTextColor(TEXT_COLOR_HOVER); });
            ourText.setOnMouseLeaveListener((JavaScriptCallback) ev -> { if (!selected) ourText.setTextColor(TEXT_COLOR); });
            ourText.setAction(0, ACTION_TEXT);
            ourText.setOnOpListener((JavaScriptCallback) ev -> {
                setSelected(true);
                hideMenu();
            });
            ourText.revalidate();
        }

        if (menu.getOriginalHeight() <= baseMenuHeight) {
            menu.setOriginalHeight((menu.getOriginalHeight() + buttonHeight));
        }

        restyleOptions();
        menu.revalidate();
        for (Widget child : menuChildren) {
            child.revalidate();
        }
    }

    private void setupFirstWidgets(List<Widget> menuChildren) {
        firstBackground = getFirstWidgetOfType(menuChildren, WidgetType.RECTANGLE);
        firstText = getFirstWidgetOfType(menuChildren, WidgetType.TEXT);

        firstText.setHasListener(true);
        firstText.setOnMouseOverListener((JavaScriptCallback) ev -> { if (selected) firstText.setTextColor(TEXT_COLOR_HOVER); });
        firstText.setOnMouseLeaveListener((JavaScriptCallback) ev -> { if (selected) firstText.setTextColor(TEXT_COLOR); });
        firstText.setAction(0, firstText.getText());
        firstText.setOnOpListener((JavaScriptCallback) ev -> {
            setSelected(false);
            hideMenu();
        });
    }

    private void hideMenu() {
        if (menu != null) {
            menu.setHidden(true)
                .revalidate();
        }
    }

    private static Widget getFirstWidgetOfType(List<Widget> menuChildren, int widgetType) {
        return menuChildren.stream()
                .filter(w -> w.getType() == widgetType)
                .findFirst()
                .orElseThrow(() -> new NoSuchElementException("No widget of type" + widgetType + " found in menu"));
    }
}
package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.synchronization.SyncService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.generic.UIGraphic;
import com.collectionlogmaster.ui.generic.UILabel;
import com.collectionlogmaster.ui.generic.UINativeButton;
import com.collectionlogmaster.ui.generic.UIPage;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.SoundEffectID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.swing.*;
import java.awt.*;
import java.util.List;
import java.util.Map;

import static com.collectionlogmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_HEIGHT;
import static com.collectionlogmaster.ui.InterfaceConstants.COLLECTION_LOG_WINDOW_WIDTH;

public class TaskDashboard extends UIPage {
    private final static int DEFAULT_BUTTON_WIDTH = 140;
    private final static int DEFAULT_BUTTON_HEIGHT = 30;
    private final static int SMALL_BUTTON_WIDTH = 68;
    private final static int DEFAULT_TASK_DETAILS_WIDTH = 300;
    private final static int DEFAULT_TASK_DETAILS_HEIGHT = 75;
    private final static int TASK_BACKGROUND_SPRITE_ID = -20006;

    @Getter
    private Widget window;
    private CollectionLogMasterPlugin plugin;

    private CollectionLogMasterConfig config;
    private final SyncService syncService;
    private final TaskService taskService;
    private final Client client;
    private final TaskInfo taskInfo;

    private UILabel title;
    private UILabel taskLabel;
    private UILabel percentCompletion;

    private UIGraphic taskImage;
    private UIGraphic taskBg;

    private final UINativeButton completeTaskBtn;
    private final UINativeButton generateTaskBtn;
    private final UINativeButton faqBtn;
    private final UINativeButton syncBtn;

    public TaskDashboard(CollectionLogMasterPlugin plugin, CollectionLogMasterConfig config, Widget window, SyncService syncService, TaskService taskService, Client client, TaskInfo taskInfo) {
        this.window = window;
        this.plugin = plugin;
        this.config = config;
        this.syncService = syncService;
        this.taskService = taskService;
        this.client = client;
        this.taskInfo = taskInfo;

        createTaskDetails();

        Widget titleWidget = window.createChild(-1, WidgetType.TEXT);
        this.title = new UILabel(titleWidget);
        this.title.setFont(FontID.QUILL_CAPS_LARGE);
        this.title.setSize(COLLECTION_LOG_WINDOW_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.title.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), 24);
        this.title.setText("Current Task");

        Widget percentWidget = window.createChild(-1, WidgetType.TEXT);
        this.percentCompletion = new UILabel(percentWidget);
        this.percentCompletion.setFont(FontID.BOLD_12);
        this.percentCompletion.setSize(COLLECTION_LOG_WINDOW_WIDTH, 25);
        this.percentCompletion.setPosition(getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH), COLLECTION_LOG_WINDOW_HEIGHT - 91);
        updatePercentages();

        completeTaskBtn = new UINativeButton(window.createChild(WidgetType.LAYER));
        completeTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        completeTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) + (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        completeTaskBtn.setText("Complete Task");
        completeTaskBtn.addAction("Complete", plugin::completeTask);

        generateTaskBtn = new UINativeButton(window.createChild(WidgetType.LAYER));
        generateTaskBtn.setSize(DEFAULT_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        generateTaskBtn.setPosition(getCenterX(window, DEFAULT_BUTTON_WIDTH) - (DEFAULT_BUTTON_WIDTH / 2 + 15), getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62);
        generateTaskBtn.setText("Generate Task");
        generateTaskBtn.addAction("Generate task", this::generateTask);

        faqBtn = new UINativeButton(window.createChild(WidgetType.LAYER));
        faqBtn.setSize(SMALL_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        faqBtn.setPosition(getCenterX(window, SMALL_BUTTON_WIDTH) + 190, getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112);
        faqBtn.setText("FAQ");
        faqBtn.addAction("Open FAQ", plugin::visitFaq);

        syncBtn = new UINativeButton(window.createChild(WidgetType.LAYER));
        syncBtn.setSize(SMALL_BUTTON_WIDTH, DEFAULT_BUTTON_HEIGHT);
        syncBtn.setPosition(getCenterX(window, SMALL_BUTTON_WIDTH) - 190, getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112);
        syncBtn.setText("Sync");
        syncBtn.addAction("Sync completed tasks", syncService::sync);

        this.add(this.title);
        this.add(this.taskBg);
        this.add(this.taskLabel);
        this.add(this.taskImage);
        this.add(this.percentCompletion);
        this.add(completeTaskBtn);
        this.add(generateTaskBtn);
        this.add(faqBtn);
        this.add(syncBtn);
    }

    @Override
    public void setVisibility(boolean visible) {
        super.setVisibility(visible);
        if (visible) {
            if (taskService.getActiveTask() == null) {
                clearTask();
            } else {
                Task activeTask = taskService.getActiveTask();
                setTask(activeTask, null);
            }
        }
    }

    private void createTaskDetails() {
        final int POS_X = getCenterX(window, DEFAULT_TASK_DETAILS_WIDTH);
        final int POS_Y = getCenterY(window, DEFAULT_TASK_DETAILS_HEIGHT)-3;

        Widget taskBgWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskBg = new UIGraphic(taskBgWidget);
        this.taskBg.setSize(DEFAULT_TASK_DETAILS_WIDTH, DEFAULT_TASK_DETAILS_HEIGHT);
        this.taskBg.setPosition(POS_X, POS_Y);
        this.taskBg.setSprite(TASK_BACKGROUND_SPRITE_ID);

        Widget label = window.createChild(-1, WidgetType.TEXT);
        label.setTextColor(Color.WHITE.getRGB());
        label.setTextShadowed(true);
        label.setName("Task Label");
        this.taskLabel = new UILabel(label);
        this.taskLabel.setFont(496);
        this.taskLabel.setPosition(POS_X+60, POS_Y);
        this.taskLabel.setSize(DEFAULT_TASK_DETAILS_WIDTH-60, DEFAULT_TASK_DETAILS_HEIGHT);

        Widget taskImageWidget = window.createChild(-1, WidgetType.GRAPHIC);
        this.taskImage = new UIGraphic(taskImageWidget);
        this.taskImage.setPosition(POS_X+12, POS_Y+21);
        this.taskImage.setSize(42, 36);
        this.taskImage.getWidget().setBorderType(1);
    }

    public void clearTask() {
        this.taskBg.getWidget().clearActions();
        this.taskBg.clearActions();
        this.taskLabel.setText("No active task.");
        this.taskImage.setItem(7542);
        this.disableCompleteTask();
        this.enableGenerateTask();
    }

    public void setTask(Task task, List<Task> cyclingTasks) {
        this.disableGenerateTask();

        if (cyclingTasks != null) {
            for (int i = 0; i < 250; i++) {
                Task displayTask = cyclingTasks.get((int) Math.floor(Math.random() * cyclingTasks.size()));
                // Seems the most natural timing
                double decay = 450.0 / ((double) config.rollTime());
                int delay = (int) ((config.rollTime() * 0.925) * Math.exp(-decay * i));
                Timer fakeTaskTimer = new Timer(delay, ae -> {
                    this.taskLabel.setText(displayTask.getName());
                    this.taskImage.setItem(displayTask.getDisplayItemId());
                });
                fakeTaskTimer.setRepeats(false);
                fakeTaskTimer.setCoalesce(true);
                fakeTaskTimer.start();
            }
            Timer realTaskTimer = new Timer(config.rollTime(), ae -> {
                setTask(task, null);
            });
            realTaskTimer.setRepeats(false);
            realTaskTimer.setCoalesce(true);
            realTaskTimer.start();
            return;
        }

        this.taskLabel.setText(task.getName());
        this.taskImage.setItem(task.getDisplayItemId());
        this.taskBg.clearActions();
        this.taskBg.addAction("View task info", () -> taskInfo.showTask(task.getId()));
        this.enableCompleteTask();
    }

    private void generateTask() {
		client.playSoundEffect(SoundEffectID.UI_BOOP);
		Task generatedTask = taskService.generate();

		List<Task> rollTaskList = config.rollPastCompleted() ? taskService.getTierTasks() : taskService.getIncompleteTierTasks();
		setTask(generatedTask, rollTaskList);
        disableGenerateTask();
        updatePercentages();
	}

    public void updatePercentages() {
        Map<TaskTier, Float> progress = taskService.getProgress();
        TaskTier currentTier = taskService.getCurrentTier();
        float tierPercentage = progress.get(currentTier);

        String text = String.format(
                "<col=%s>%d%%</col> %s Completed",
                getCompletionColor(tierPercentage),
                (int) tierPercentage,
                currentTier.displayName
        );
        percentCompletion.setText(text);
    }

    private String getCompletionColor(double percent) {
        int max = 255;
        int amount = (int) Math.round(((percent % 50) / 50) * max);

        if(percent == 100) {
            return "00ff00";
        }
        else if(percent > 50) {
            int redValue = max - amount;
            return String.format("%02x", redValue)+"ff00";

        }
        else if(percent == 50) {
            return "ffff00";
        }
        else {
            return "ff"+String.format("%02x", amount)+"00";
        }
    }


    public void disableGenerateTask() {
        generateTaskBtn.setState(UINativeButton.State.DISABLED);
    }

    public void enableGenerateTask() {
        generateTaskBtn.setState(UINativeButton.State.DEFAULT);

        this.disableCompleteTask();
    }

    public void disableCompleteTask() {
        completeTaskBtn.setState(UINativeButton.State.DISABLED);
    }

    public void enableCompleteTask() {
        completeTaskBtn.setState(UINativeButton.State.DEFAULT);
    }

    public void updateBounds() {
        int windowWidth = window.getWidth();

        // Update title position - force widget position update
        int titleX = getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH);
        this.title.setPosition(titleX, 24);
        this.title.getWidget().setPos(titleX, 24);

        // Update task details (background, label, image)
        final int taskPosX = getCenterX(window, DEFAULT_TASK_DETAILS_WIDTH);
        final int taskPosY = getCenterY(window, DEFAULT_TASK_DETAILS_HEIGHT) - 3;
        
        this.taskBg.setPosition(taskPosX, taskPosY);
        this.taskBg.getWidget().setPos(taskPosX, taskPosY);
        
        this.taskLabel.setPosition(taskPosX + 60, taskPosY);
        this.taskLabel.getWidget().setPos(taskPosX + 60, taskPosY);
        
        this.taskImage.setPosition(taskPosX + 12, taskPosY + 21);
        this.taskImage.getWidget().setPos(taskPosX + 12, taskPosY + 21);

        // Update button positions - force widget position updates
        int generateBtnX = getCenterX(window, DEFAULT_BUTTON_WIDTH) - (DEFAULT_BUTTON_WIDTH / 2 + 15);
        int generateBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62;
        generateTaskBtn.setPosition(generateBtnX, generateBtnY);
        
        int completeBtnX = getCenterX(window, DEFAULT_BUTTON_WIDTH) + (DEFAULT_BUTTON_WIDTH / 2 + 15);
        int completeBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 62;
        completeTaskBtn.setPosition(completeBtnX, completeBtnY);
        completeTaskBtn.getWidget().setPos(completeBtnX, completeBtnY);
        
        // Update FAQ button position with boundary checking
        int faqBtnX = getCenterX(window, SMALL_BUTTON_WIDTH) + 238;
        int faqBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112;
        
        // Check if FAQ button would go outside the window and align with edge if needed
        int faqBtnWidth = SMALL_BUTTON_WIDTH;
        if (faqBtnX + faqBtnWidth + 10 > windowWidth) {
            faqBtnX = windowWidth - faqBtnWidth - 10; // 10px margin from edge
        }
        faqBtn.setPosition(faqBtnX, faqBtnY);

        // Update Sync button position with boundary checking
        int syncBtnX = getCenterX(window, SMALL_BUTTON_WIDTH) - 238;
        int syncBtnY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112;
        if (syncBtnX < 10) {
            syncBtnX = 10; // 10px margin from left edge
        }
        syncBtn.setPosition(syncBtnX, syncBtnY);

        // Update percentage completion position - force widget position update
        int percentX = getCenterX(window, COLLECTION_LOG_WINDOW_WIDTH);
        int percentY = getCenterY(window, DEFAULT_BUTTON_HEIGHT) + 112; // Same Y as FAQ button
        this.percentCompletion.setPosition(percentX, percentY);
        this.percentCompletion.getWidget().setPos(percentX, percentY);
        
        // Force revalidation of all widgets
        this.title.getWidget().revalidate();
        this.taskBg.getWidget().revalidate();
        this.taskLabel.getWidget().revalidate();
        this.taskImage.getWidget().revalidate();
        generateTaskBtn.revalidate();
        completeTaskBtn.revalidate();
        faqBtn.revalidate();
        syncBtn.revalidate();
        this.percentCompletion.getWidget().revalidate();
    }

	private int getCenterX(Widget window, int width) {
		return (window.getWidth() / 2) - (width / 2);
	}

	private int getCenterY(Widget window, int height) {
		return (window.getHeight() / 2) - (height / 2);
	}

	private void playFailSound() {
		client.playSoundEffect(2277);
	}
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.ui.generic.UIButton;
import com.collectionlogmaster.ui.generic.UIGraphic;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import java.util.ArrayList;
import java.util.List;

import static com.collectionlogmaster.ui.InterfaceConstants.*;

public class TabManager {
    private final CollectionLogMasterConfig config;
    private final Widget window;
    private final CollectionLogMasterPlugin plugin;
    
    private List<UIButton> tabs;
    private UIButton taskDashboardTab;
    
    private TaskDashboard taskDashboard;
    private TaskList taskList;
    private UIGraphic divider;

    private int TAB_HEIGHT = 21;
    private int TAB_WIDTH = 66;
    private int DASHBOARD_TAB_WIDTH = 95;

    public TabManager(Widget window, CollectionLogMasterConfig config, CollectionLogMasterPlugin plugin) {
        this.window = window;
        this.config = config;
        this.plugin = plugin;
        
        createTabs();
        createDivider();
    }

    public void setComponents(TaskDashboard taskDashboard, TaskList taskList) {
        this.taskDashboard = taskDashboard;
        this.taskList = taskList;
    }

    private void createTabs() {
        // Remove any existing tabs from the window
        if (tabs != null) {
            for (UIButton tab : tabs) {
                if (tab != null && tab.getWidget() != null) {
                    tab.getWidget().setHidden(true);
                }
            }
        }
        tabs = new ArrayList<>();
        // Remove and recreate dashboard tab
        if (taskDashboardTab != null && taskDashboardTab.getWidget() != null) {
            taskDashboardTab.getWidget().setHidden(true);
        }
        Widget dashboardTabWidget = window.createChild(-1, WidgetType.GRAPHIC);
        taskDashboardTab = new UIButton(dashboardTabWidget);
        taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
        taskDashboardTab.setSize(DASHBOARD_TAB_WIDTH, TAB_HEIGHT);
        taskDashboardTab.setPosition(10, 0);
        taskDashboardTab.addAction("View <col=ff9040>Dashboard</col>", this::activateTaskDashboard);
        taskDashboardTab.setVisibility(false);
        // Always create all tabs for all tiers
        for (TaskTier tier : TaskTier.values()) {
            Widget tabWidget = window.createChild(-1, WidgetType.GRAPHIC);
            UIButton tab = new UIButton(tabWidget);
            tab.setSize(TAB_WIDTH, TAB_HEIGHT);
            tab.setVisibility(false);
            tabs.add(tab);
        }
    }

    private void createDivider() {
        Widget dividerWidget = window.createChild(-1, WidgetType.GRAPHIC);
        divider = new UIGraphic(dividerWidget);
        divider.setSprite(DIVIDER_SPRITE_ID);
        divider.setSize(window.getWidth(), 1); // Full width minus margins
        divider.setPosition(0, 20);
        divider.revalidate();
    }

    public void updateBounds() {
        // Update divider width to match window width
        int windowWidth = window.getWidth();
        divider.setSize(windowWidth, 1);
        divider.revalidate();

        // Update tab positions
        updateTabPositions();
    }

    private void updateTabPositions() {
        int windowWidth = window.getWidth();
        int minSpacing = -30; // Allow up to 30px overlap
        // Count only visible tabs
        int visibleTierTabs = 0;
        for (TaskTier tier : TaskTier.values()) {
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                visibleTierTabs++;
            }
        }
        int totalTabsWidth = DASHBOARD_TAB_WIDTH + (visibleTierTabs * TAB_WIDTH);
        int spacing = (windowWidth - totalTabsWidth) / (visibleTierTabs + 2);
        // Allow negative spacing for overlap, but not less than minSpacing
        spacing = Math.max(minSpacing, Math.min(10, spacing));
        int dashboardX = spacing;
        taskDashboardTab.setPosition(dashboardX, 0);
        taskDashboardTab.getWidget().setPos(dashboardX, 0);
        int currentX = dashboardX + DASHBOARD_TAB_WIDTH + spacing;
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            UIButton tab = tabs.get(tabIndex);
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                if (plugin.getSelectedTier() == tier && !this.taskDashboard.isVisible()) {
                    tab.setSprites(tier.tabSpriteHoverId);
                } else {
                    tab.setSprites(tier.tabSpriteId, tier.tabSpriteHoverId);
                }
                tab.setPosition(currentX, 0);
                tab.getWidget().setPos(currentX, 0);
                tab.setVisibility(true);
                tab.getWidget().setHidden(false);
                int finalTabIndex = tabIndex;
                tab.clearActions();
                tab.addAction(String.format("View <col=ff9040>%s Task List</col>", tier.displayName), () -> activateTaskListForTier(tier, finalTabIndex));
                currentX += TAB_WIDTH + spacing;
            } else {
                // Move out of view if not visible
                tab.setPosition(-1000, -1000);
                tab.getWidget().setPos(-1000, -1000);
                tab.setVisibility(false);
                tab.getWidget().setHidden(true);
            }
            tab.revalidate();
            tab.getWidget().revalidate();
            tabIndex++;
        }
        if (!this.taskDashboard.isVisible() && !this.taskList.isVisible()) {
            hideTabs();
        }
    }

    public void updateTabs() {
        hideTabs();
        if (tabs == null) return;
        if (!taskDashboard.isVisible() && !taskList.isVisible()) return;

        updateTabPositions();
        showTabs();
    }

    private void activateTaskListForTier(TaskTier tier, int tabIndex) {
        taskDashboardTab.setSprites(DASHBOARD_TAB_SPRITE_ID, DASHBOARD_TAB_HOVER_SPRITE_ID);
        if (plugin.getSelectedTier() != tier) {
            this.taskList.goToTop();
            plugin.setSelectedTier(tier);
        }
        updateTabs();
        tabs.get(tabIndex).setSprites(tier.tabSpriteHoverId);
        this.taskDashboard.setVisibility(false);
        this.taskList.refreshTasks(0);
        this.taskList.setVisibility(true);
    }

    public void activateTaskDashboard() {
        this.taskDashboardTab.setSprites(DASHBOARD_TAB_HOVER_SPRITE_ID);
        this.taskList.setVisibility(false);
        this.taskDashboard.setVisibility(true);
        updateTabs();
    }

    public void hideTabs() {
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(false);
        }
        if (this.tabs != null) {
            this.tabs.forEach(t -> t.setVisibility(false));
        }
    }

    public void showTabs() {
        // Hide tabs if neither list is visible
        if (!this.taskList.isVisible() && !this.taskDashboard.isVisible()) {
            this.hideTabs();
            return;
        }
        if (this.taskDashboardTab != null) {
            this.taskDashboardTab.setVisibility(true);
        }
        int tabIndex = 0;
        for (TaskTier tier : TaskTier.values()) {
            UIButton tab = this.tabs.get(tabIndex);
            if (tier.ordinal() >= config.hideBelow().ordinal()) {
                tab.setVisibility(true);
            } else {
                // Move out of view before hiding
                tab.setPosition(-1000, 0);
                tab.getWidget().setPos(-1000, 0);
                tab.setVisibility(false);
            }
            tabIndex++;
        }
        updateTabPositions();
    }
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.synchronization.clog.CollectionLogService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.generic.UIGraphic;
import com.collectionlogmaster.ui.generic.UILabel;
import com.collectionlogmaster.ui.generic.UINativeButton;
import com.collectionlogmaster.ui.generic.UIPage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.util.LinkBrowser;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class TaskInfo extends UIPage {
    private final static int OFFSET_X = 0;
    private final static int OFFSET_Y = 21;

    private final Widget window;
    private final CollectionLogMasterPlugin plugin;
    private final CollectionLogService collectionLogService;
    private final TaskService taskService;

    private final static int BUTTON_HEIGHT = 30;
    private final static int BUTTON_WIDTH = 68;
    private final static int LARGE_BUTTON_WIDTH = 140;

    private TaskDashboard taskDashboard;
    private TaskList taskList;
    private TabManager tabManager;
    private UIPage previousVisiblePage = null;
    private Task currentTask = null;

    private Rectangle bounds = new Rectangle();
    private int windowWidth = 480;
    private int windowHeight = 252;
    private int wrapperX = 0;
    private int wrapperY = 0;
    private int wrapperHeight = 231;
    private int windowX = 0;
    private int windowY = 0;

    public TaskInfo(Widget window, CollectionLogMasterPlugin plugin, CollectionLogService collectionLogService, TaskService taskService) {
        this.window = window;
        this.plugin = plugin;
        this.collectionLogService = collectionLogService;
        this.taskService = taskService;

        updateBounds();
    }

    public void setComponents(TaskDashboard taskDashboard, TaskList taskList, TabManager tabManager) {
        this.taskDashboard = taskDashboard;
        this.taskList = taskList;
        this.tabManager = tabManager;
    }

    @Override
    public void setVisibility(boolean visible) {
        super.setVisibility(visible);
        if (visible) {
            this.previousVisiblePage = this.taskDashboard.isVisible() ? this.taskDashboard : this.taskList;
            this.previousVisiblePage.setVisibility(false);
            this.tabManager.hideTabs();
        } else if (this.previousVisiblePage != null) {
            this.previousVisiblePage.setVisibility(true);
            if (this.taskList.isVisible()) {
                this.taskList.updateBounds();
            }
            this.tabManager.showTabs();
            this.tabManager.updateTabs();
            previousVisiblePage = null;
        }
    }

    private UILabel titleLabel;
    private UILabel tipLabel;
    private UINativeButton wikiBtn;
    private UINativeButton closeBtn;
    private UINativeButton completeBtn;
    private UILabel progressLabel;
    private UIGraphic progressBarBg;
    private UIGraphic progressBarFill;
    private List<UIGraphic> taskIcons = new ArrayList<>();
    private UILabel extraItemsLabel;

    public void showTask(String taskId) {
        currentTask = taskService.getTaskById(taskId);

        // Show the task title
        if (titleLabel == null) {
            titleLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
        }
        titleLabel.setFont(FontID.BOLD_12);
        titleLabel.setText(currentTask.getName());
        titleLabel.getWidget().setHidden(false);
        titleLabel.getWidget().setTextColor(Color.WHITE.getRGB());
        titleLabel.getWidget().setTextShadowed(true);
        titleLabel.getWidget().setName(currentTask.getName());
        this.add(titleLabel);

        // Show the task tip
        if (tipLabel == null) {
            tipLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
            this.add(tipLabel);
        }
        tipLabel.setFont(FontID.PLAIN_12);
        tipLabel.setText(currentTask.getTip());
        tipLabel.getWidget().setHidden(false);
        tipLabel.getWidget().setTextColor(Color.WHITE.getRGB());
        tipLabel.getWidget().setTextShadowed(true);
        tipLabel.getWidget().setName(currentTask.getName());

        int itemIndex = 0;
        if (currentTask.getVerification() instanceof CollectionLogVerification) {
            CollectionLogVerification verification = (CollectionLogVerification) currentTask.getVerification();
            int[] itemIds = verification.getItemIds();

            // Create or reuse a UIGraphic for the progress bar background
            if (progressBarBg == null) {
                progressBarBg = new UIGraphic(window.createChild(-1, WidgetType.RECTANGLE));
                this.add(progressBarBg);
            }
            progressBarBg.getWidget().setFilled(true);
            progressBarBg.getWidget().setOpacity(100);
            progressBarBg.getWidget().setTextColor(new Color(40, 40, 40).getRGB()); // dark background
            progressBarBg.getWidget().setBorderType(1);

            // Create or reuse a UIGraphic for the progress bar fill
            if (progressBarFill == null) {
                progressBarFill = new UIGraphic(window.createChild(-1, WidgetType.RECTANGLE));
                this.add(progressBarFill);
            }
            progressBarFill.getWidget().setFilled(true);
            progressBarFill.getWidget().setOpacity(100);
            progressBarFill.getWidget().setTextColor(new Color(60, 180, 75).getRGB()); // green fill
            progressBarFill.getWidget().setBorderType(0);

            // Progress label on top of the bar
            if (progressLabel == null) {
                progressLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
                this.add(progressLabel);
            }
            progressLabel.setFont(FontID.PLAIN_12);
            progressLabel.getWidget().setTextColor(Color.WHITE.getRGB());
            progressLabel.getWidget().setTextShadowed(true);
            progressLabel.getWidget().setName(currentTask.getName());

            if (itemIds != null && itemIds.length > 0) {
                int itemSize = 32;
                for (int itemId : itemIds) {
                    UIGraphic itemImage = itemIndex < taskIcons.size() ? taskIcons.get(itemIndex) : null;
                    if (itemImage == null) {
                        itemImage = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                        taskIcons.add(itemImage);
                        this.add(itemImage);
                    }
                    itemImage.getWidget().setHidden(false);
                    itemImage.getWidget().setBorderType(1);
                    itemImage.setSize(itemSize, itemSize);
                    itemImage.setItem(itemId);
                    boolean isObtained = collectionLogService.isItemObtained(itemId);
                    itemImage.setOpacity(isObtained ? 1 : 0.3f);
                    String itemName = plugin.itemManager.getItemComposition(itemId).getName();
                    itemImage.clearActions();
                    itemImage.addAction(itemName, () -> {});
                    itemIndex++;
                }
            }
        }
        // Extra items label if needed
        if (extraItemsLabel == null) {
            extraItemsLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
            this.add(extraItemsLabel);
        }
        extraItemsLabel.setFont(FontID.PLAIN_11);
        extraItemsLabel.setText("");
        extraItemsLabel.getWidget().setTextColor(Color.WHITE.getRGB());
        extraItemsLabel.getWidget().setTextShadowed(true);
        extraItemsLabel.getWidget().setName(currentTask.getName());

        if (wikiBtn == null) {
            wikiBtn = new UINativeButton(window.createChild(WidgetType.LAYER));
            this.add(wikiBtn);
        }
        wikiBtn.setSize(BUTTON_WIDTH, BUTTON_HEIGHT);
        wikiBtn.setText("Wiki");
        wikiBtn.clearActions();
        wikiBtn.addAction("View Wiki", () -> LinkBrowser.browse(currentTask.getWikiLink()));

        if (closeBtn == null) {
            closeBtn = new UINativeButton(window.createChild(WidgetType.LAYER));
            closeBtn.addAction("Close Task Info", this::closeTask);
            this.add(closeBtn);
        }
        closeBtn.setSize(BUTTON_WIDTH, BUTTON_HEIGHT);
        closeBtn.setText("Back");

        if (completeBtn == null) {
            completeBtn = new UINativeButton(window.createChild(WidgetType.LAYER));
            this.add(completeBtn);
        }
        completeBtn.setSize(LARGE_BUTTON_WIDTH, BUTTON_HEIGHT);
        completeBtn.clearActions();
        if (taskService.isComplete(taskId)) {
            completeBtn.setText("Mark incomplete");
            completeBtn.addAction("Mark as <col=c0392b>incomplete</col>", () -> toggleTask(taskId));
        } else {
            completeBtn.setText("Mark complete");
            completeBtn.addAction("Mark as <col=27ae60>complete</col>", () -> toggleTask(taskId));
        }

        // Hide task list/dashboard/tabs, show task info
        this.setVisibility(true);
        this.setPositions();
    }

    private void toggleTask(String taskId) {
        completeBtn.clearActions();

        if (taskService.isComplete(taskId)) {
            taskService.uncomplete(taskId);
            completeBtn.setText("Mark complete");
            completeBtn.addAction("Mark as <col=27ae60>complete</col>", () -> toggleTask(taskId));
        } else {
            taskService.complete(taskId);
            completeBtn.setText("Mark incomplete");
            completeBtn.addAction("Mark as <col=c0392b>incomplete</col>", () -> toggleTask(taskId));
        }
    }

    private void setPositions() {
        int offset_y = 0;
        titleLabel.setPosition(0, offset_y);
        titleLabel.setSize(windowWidth, 20);
        offset_y += 30;
        tipLabel.setPosition(10, offset_y);
        Dimension descBounds = getTextDimension(tipLabel.getWidget(), tipLabel.getWidget().getText(), windowWidth - 40);
        tipLabel.setSize(windowWidth - 20, descBounds.height);
        offset_y += descBounds.height + 8;
        int progressBarX = 10;
        int progressBarY = offset_y;
        
        int itemIndex = 0;
        if (currentTask.getVerification() instanceof CollectionLogVerification) {
            CollectionLogVerification verification = (CollectionLogVerification) currentTask.getVerification();
            int[] itemIds = verification.getItemIds();

            int obtainedCount = 0;
            int requiredCount = verification.getCount();
            for (int id : itemIds) {
                if (collectionLogService.isItemObtained(id)) {
                    obtainedCount++;
                }
            }
            int progressBarWidth = windowWidth - 20;
            int progressBarHeight = 18;
            int fillWidth = Math.min((int) ((obtainedCount / (float) requiredCount) * progressBarWidth), progressBarWidth);
            
            progressBarBg.setPosition(progressBarX, progressBarY);
            progressBarBg.setSize(progressBarWidth, progressBarHeight);
            progressBarFill.setPosition(progressBarX, progressBarY);
            progressBarFill.setSize(fillWidth, progressBarHeight);
            progressLabel.setPosition(progressBarX, progressBarY);
            progressLabel.setSize(progressBarWidth, progressBarHeight);
            progressLabel.setText("Obtained " + obtainedCount + "/" + requiredCount + " required items");
            offset_y += 18;

            if (itemIds != null && itemIds.length > 0) {
                int itemSize = 32;
                int spacing = 8;
                int itemsPerRow = Math.max(1, (windowWidth - 20) / (itemSize + spacing));
                int numRows = (int) Math.ceil((double) itemIds.length / itemsPerRow);
                int startY = offset_y + 8;
                int y = startY;
                for (int row = 0; row < numRows; row++) {
                    int itemsInThisRow = Math.min(itemsPerRow, itemIds.length - itemIndex);
                    int totalRowWidth = itemsInThisRow * itemSize + (itemsInThisRow - 1) * spacing;
                    int startX = (windowWidth - totalRowWidth) / 2;
                    int x = startX;
                    // Check if this row would be too close to the bottom edge
                    if (y + itemSize > windowHeight - BUTTON_HEIGHT - 20) {
                        break;
                    }
                    for (int col = 0; col < itemsInThisRow; col++) {
                        UIGraphic itemImage = itemIndex < taskIcons.size() ? taskIcons.get(itemIndex) : null;
                        itemImage.setPosition(x, y);
                        x += itemSize + spacing;
                        itemImage.revalidate();
                        itemIndex++;
                    }
                    y += itemSize + spacing;
                }
                offset_y = y;
                if (itemIndex < itemIds.length) {
                    extraItemsLabel.setText((itemIds.length - itemIndex) + " more items...");
                    extraItemsLabel.setPosition(10, offset_y);
                    extraItemsLabel.setSize(windowWidth, 12);
                    extraItemsLabel.revalidate();
                } else {
                    extraItemsLabel.setText("");
                    extraItemsLabel.setPosition(-100, -100);
                }
                for (int i = itemIndex; i < taskIcons.size(); i++) {
                    UIGraphic itemImage = taskIcons.get(i);
                    if (itemImage != null) {
                        itemImage.setPosition(-100, -100);
                        itemImage.revalidate();
                    }
                }
            }
        } else {
            progressBarBg.setPosition(-100, -100);
            progressBarFill.setPosition(-100, -100);
            progressLabel.setPosition(-100, -100);
        }
        offset_y += 16;
        wikiBtn.setPosition(10, windowHeight - 10 - BUTTON_HEIGHT);
        completeBtn.setPosition((windowWidth / 2) - (LARGE_BUTTON_WIDTH / 2), windowHeight - 10 - BUTTON_HEIGHT);
        closeBtn.setPosition(windowWidth - 10 - BUTTON_WIDTH, windowHeight - 10 - BUTTON_HEIGHT);

        titleLabel.revalidate();
        tipLabel.revalidate();
        wikiBtn.revalidate();
        closeBtn.revalidate();
        completeBtn.revalidate();
        progressBarBg.revalidate();
        progressBarFill.revalidate();
        progressLabel.revalidate();
    }

    private Dimension getTextDimension(Widget widget, String text, int maxWidth) {
        if (text == null || text.isEmpty()) {
            return new Dimension(0, 0);
        }
        String[] words = text.split(" ");
        StringBuilder line = new StringBuilder();
        int lineCount = 1;
        int maxLineWidth = 0;
        for (int i = 0; i < words.length; i++) {
            String testLine = line.length() == 0 ? words[i] : line + " " + words[i];
            int testWidth = widget.getFont().getTextWidth(testLine);
            if (line.toString().contains("<br>") || testWidth > maxWidth && line.length() > 0) {
                // Start new line
                maxLineWidth = Math.max(maxLineWidth, widget.getFont().getTextWidth(line.toString()));
                line = new StringBuilder(words[i]);
                lineCount++;
            } else {
                if (line.length() > 0) {
                    line.append(" ");
                }
                line.append(words[i]);
            }
        }
        // Check last line
        if (line.length() > 0) {
            maxLineWidth = Math.max(maxLineWidth, widget.getFont().getTextWidth(line.toString()));
        }
        int lineHeight = widget.getFont().getBaseline();
        return new Dimension(maxLineWidth, lineCount * lineHeight);
    }

    public void closeTask() {
        // TODO: Implement closing the task info
        this.setVisibility(false);
    }

    public void updateBounds()
    {
        Widget wrapper = window.getParent();
        wrapperX = wrapper.getRelativeX();
        wrapperY = wrapper.getRelativeY();
        wrapperHeight = window.getHeight() - OFFSET_Y;
        windowX = window.getRelativeX();
        windowY = window.getRelativeY();
        windowWidth = window.getWidth();
        windowHeight = window.getHeight();

        bounds.setLocation(wrapperX + windowX + OFFSET_X, wrapperY + windowY + OFFSET_Y);
        bounds.setSize(windowWidth - OFFSET_X, wrapperHeight);

        if (!this.isVisible()) {
            return;
        }

        this.setPositions();
    }
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.DynamicTaskImages;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.synchronization.clog.CollectionLogService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.generic.UIButton;
import com.collectionlogmaster.ui.generic.UIGraphic;
import com.collectionlogmaster.ui.generic.UILabel;
import com.collectionlogmaster.ui.generic.UIPage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;

import java.awt.*;
import java.awt.event.MouseWheelEvent;
import java.util.ArrayList;
import java.util.List;

import static com.collectionlogmaster.ui.InterfaceConstants.*;

@Slf4j
public class TaskList extends UIPage {
    private final static int OFFSET_X = 0;
    private final static int OFFSET_Y = 21;
    private final static int TASK_WIDTH = 300;
    private final static int TASK_HEIGHT = 50;
    private final static int COLUMN_SPACING = 24;
    private final static int TASK_ITEM_HEIGHT = 32;
    private final static int TASK_ITEM_WIDTH = 36;
    private final static int PAGE_UP_ARROW_SPRITE_ID = -20029;
    private final static int UP_ARROW_SPRITE_ID = -20014;
    private final static int DOWN_ARROW_SPRITE_ID = -20015;
    private final static int PAGE_DOWN_ARROW_SPRITE_ID = -20030;
    private final static int THUMB_TOP_SPRITE_ID = -20031;
    private final static int THUMB_MIDDLE_SPRITE_ID = -20032;
    private final static int THUMB_BOTTOM_SPRITE_ID = -20033;
    private final static int ARROW_SPRITE_WIDTH = 39;
    private final static int ARROW_SPRITE_HEIGHT = 20;
    private final static int ARROW_Y_OFFSET = 4;
    private final static int SCROLLBAR_WIDTH = 35; // Match arrow width
    private final static int SCROLLBAR_THUMB_MIN_HEIGHT = 8;
    

    private final Widget window;
    private final CollectionLogMasterPlugin plugin;
    private final ClientThread clientThread;
    private final CollectionLogService collectionLogService;
    private final TaskService taskService;
    private final TaskInfo taskInfo;

    private Rectangle bounds = new Rectangle();

    private List<UIGraphic> taskBackgrounds = new ArrayList<>();
    private List<UILabel> taskLabels = new ArrayList<>();
    private List<UIGraphic> taskImages = new ArrayList<>();
    private Widget scrollbarTrackWidget;
    private Widget scrollbarThumbTopWidget;
    private Widget scrollbarThumbMiddleWidget;
    private Widget scrollbarThumbBottomWidget;
    private UIButton pageUpButton;
    private UIButton upArrowButton;
    private UIButton downArrowButton;
    private UIButton pageDownButton;
    private boolean isDraggingThumb = false;
    private int dragStartY = 0;
    private int dragStartTopIndex = 0;
    private int topTaskIndex = 0;
    private int totalTasks = 0;
    // default values, will update when bounds change
    private int windowWidth = 480;
    private int windowHeight = 252;
    private int wrapperX = 0;
    private int wrapperY = 0;
    private int wrapperHeight = 230;
    private int windowX = 0;
    private int windowY = 0;
    private int tasksPerPage = 20;
    private int columns = 1;

    private final CollectionLogMasterConfig config;

    public TaskList(Widget window, CollectionLogMasterPlugin plugin, ClientThread clientThread, CollectionLogMasterConfig config, CollectionLogService collectionLogService, TaskService taskService, TaskInfo taskInfo) {
        this.window = window;
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.config = config;
        this.collectionLogService = collectionLogService;
        this.taskService = taskService;
        this.taskInfo = taskInfo;

        updateBounds();

        createScrollbarComponents();
        this.add(upArrowButton);
        this.add(pageUpButton);
        this.add(downArrowButton);
        this.add(pageDownButton);

        // Refresh the tasks list
        refreshTasks(0);
    }

    private void createScrollbarComponents() {
        Widget pageUpWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageUpButton = new UIButton(pageUpWidget);
        pageUpButton.setSprites(PAGE_UP_ARROW_SPRITE_ID);
        pageUpButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageUpButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        pageUpButton.addAction("Page up", () -> refreshTasks(-tasksPerPage));

        Widget upWidget = window.createChild(-1, WidgetType.GRAPHIC);
        upArrowButton = new UIButton(upWidget);
        upArrowButton.setSprites(UP_ARROW_SPRITE_ID);
        upArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        upArrowButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        upArrowButton.addAction("Scroll up", () -> refreshTasks(-1));

        scrollbarTrackWidget = window.createChild(-1, WidgetType.RECTANGLE);
        scrollbarTrackWidget.setFilled(true);
        scrollbarTrackWidget.setTextColor(0x665948);
        scrollbarTrackWidget.setSize(SCROLLBAR_WIDTH, 200);
        scrollbarTrackWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);
        
        scrollbarThumbTopWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbTopWidget.setSpriteId(THUMB_TOP_SPRITE_ID);
        scrollbarThumbTopWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbTopWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET);

        scrollbarThumbMiddleWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbMiddleWidget.setSpriteId(THUMB_MIDDLE_SPRITE_ID);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, SCROLLBAR_THUMB_MIN_HEIGHT - 4);
        scrollbarThumbMiddleWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + 2);

        scrollbarThumbBottomWidget = window.createChild(-1, WidgetType.GRAPHIC);
        scrollbarThumbBottomWidget.setSpriteId(THUMB_BOTTOM_SPRITE_ID);
        scrollbarThumbBottomWidget.setSize(SCROLLBAR_WIDTH, 2);
        scrollbarThumbBottomWidget.setPos(-ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + SCROLLBAR_THUMB_MIN_HEIGHT - 2);

        Widget downWidget = window.createChild(-1, WidgetType.GRAPHIC);
        downArrowButton = new UIButton(downWidget);
        downArrowButton.setSprites(DOWN_ARROW_SPRITE_ID);
        downArrowButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        downArrowButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        downArrowButton.addAction("Scroll down", () -> refreshTasks(1));

        Widget pageDownWidget = window.createChild(-1, WidgetType.GRAPHIC);
        pageDownButton = new UIButton(pageDownWidget);
        pageDownButton.setSprites(PAGE_DOWN_ARROW_SPRITE_ID);
        pageDownButton.setSize(ARROW_SPRITE_WIDTH, ARROW_SPRITE_HEIGHT);
        pageDownButton.setPosition(-ARROW_SPRITE_WIDTH, 0);
        pageDownButton.addAction("Page down", () -> refreshTasks(tasksPerPage));
    }
    
    public void refreshTasks(int dir) {
        TaskTier relevantTier = plugin.getSelectedTier();
        if (relevantTier == null) {
            relevantTier = TaskTier.MASTER;
        }
        int tasksToShowCount = tasksPerPage * columns;
        totalTasks = taskService.getTierTasks(relevantTier).size();
        if (dir != 0) {
            int newIndex = topTaskIndex + (dir * columns);
            topTaskIndex = Math.min(Math.max(0, totalTasks - tasksToShowCount), Math.max(0, newIndex));
        }
        int rows = tasksPerPage;
        int totalTasksHeight = rows * TASK_HEIGHT;
        int verticalMargin = Math.max(0, (wrapperHeight - totalTasksHeight) / (rows - 1));
        int totalHeightWithMargin = totalTasksHeight + (rows > 1 ? (rows - 1) * verticalMargin : 0);
        int startY = OFFSET_Y + Math.max(0, (wrapperHeight - totalHeightWithMargin) / 2);
        int totalWidth = columns * TASK_WIDTH + (columns - 1) * COLUMN_SPACING;
        int startX = (windowWidth - totalWidth - SCROLLBAR_WIDTH - 10) / 2;
        hideUnusedTaskElements(tasksToShowCount);
        List<Task> tasksToShow = getTasksToShow(relevantTier, topTaskIndex, tasksToShowCount);
        int widgetIndex = 0;
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < columns; col++) {
                int i = row * columns + col;
                if (i >= tasksToShow.size() || i > tasksToShowCount) {
                    break;
                }

                Task task = tasksToShow.get(i);

                int taskY = startY + (row * (TASK_HEIGHT + verticalMargin));
                int taskX = startX + col * (TASK_WIDTH + COLUMN_SPACING);

                UIGraphic taskBg;
                if (taskBackgrounds.size() <= widgetIndex) {
                    // Create a new background if it doesn't exist yet
                    taskBg = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                    taskBackgrounds.add(taskBg);
                    this.add(taskBg);
                } else {
                    taskBg = taskBackgrounds.get(widgetIndex);
                }
                // Ensure it's visible, clear the actions, set size and position
                taskBg.getWidget().setHidden(false);
                taskBg.clearActions();
                taskBg.setSize(TASK_WIDTH, TASK_HEIGHT);
                taskBg.setPosition(taskX, taskY);
                taskBg.getWidget().setPos(taskX, taskY);
                boolean taskCompleted = taskService.isComplete(task.getId());

                Task activeTask = taskService.getActiveTask();
                if (activeTask != null && activeTask.getId().equals(task.getId())) {
                    taskBg.setSprite(TASK_CURRENT_BACKGROUND_SPRITE_ID);
                } else if (taskCompleted) {
                    taskBg.setSprite(TASK_COMPLETE_BACKGROUND_SPRITE_ID);
                } else {
                    taskBg.setSprite(TASK_LIST_BACKGROUND_SPRITE_ID);
                }

                // Create the task label
                UILabel taskLabel;
                if (taskLabels.size() <= widgetIndex) {
                    // Create a new label if it doesn't exist yet
                    taskLabel = new UILabel(window.createChild(-1, WidgetType.TEXT));
                    this.add(taskLabel);
                    taskLabels.add(taskLabel);
                } else {
                    taskLabel = taskLabels.get(widgetIndex);
                }
                taskLabel.getWidget().setHidden(false);
                taskLabel.getWidget().setTextColor(Color.WHITE.getRGB());
                taskLabel.getWidget().setTextShadowed(true);
                taskLabel.getWidget().setName(task.getName());
                taskLabel.setText(task.getName());
                taskLabel.setFont(496);
                taskLabel.setPosition(taskX + 60, taskY);
                taskLabel.setSize(TASK_WIDTH-60, TASK_HEIGHT);

                // Create the task image
                UIGraphic taskImage;
                if (taskImages.size() <= widgetIndex) {
                    // Create a new image if it doesn't exist yet
                    taskImage = new UIGraphic(window.createChild(-1, WidgetType.GRAPHIC));
                    this.add(taskImage);
                    taskImages.add(taskImage);
                } else {
                    taskImage = taskImages.get(widgetIndex);
                }
                taskImage.getWidget().setHidden(false);
                taskImage.setPosition(taskX + 12, taskY + 6);
                taskImage.getWidget().setBorderType(1);
                taskImage.setSize(TASK_ITEM_WIDTH, TASK_ITEM_HEIGHT);
                taskImage.setItem(task.getDisplayItemId());

                // Add our right click actions
                String taskId = task.getId();
                taskBg.addAction("Show task info", () -> taskInfo.showTask(taskId));
                if (taskService.isComplete(taskId)) {
                    taskBg.addAction("Mark incomplete", () -> toggleTask(taskId));
                } else {
                    taskBg.addAction("Mark complete", () -> toggleTask(taskId));
                }

                if (task.getVerification() instanceof CollectionLogVerification) {
                    CollectionLogVerification verif = (CollectionLogVerification) task.getVerification();

                    int[] checkArray = verif.getItemIds();
                    int count = verif.getCount();

                    if (
                        !task.getName().contains("clues")
                        && (config.dynamicTaskImages() == DynamicTaskImages.ALL || (!taskCompleted && config.dynamicTaskImages() == DynamicTaskImages.INCOMPLETE) || (taskCompleted && config.dynamicTaskImages() == DynamicTaskImages.COMPLETE))
                    ) {
                        List<Integer> potentialItems = new ArrayList<>();
                        for (int checkID : checkArray) {
                            if (
                                (taskCompleted && collectionLogService.isItemObtained(checkID)) ||
                                (!taskCompleted && !collectionLogService.isItemObtained(checkID))
                             ) {
                                potentialItems.add(checkID);
                            }
                        }

                        if (!potentialItems.isEmpty()) {
                            taskImage.setItem(potentialItems.get((count - 1) % potentialItems.size()));
                        }
                    }
                }

                taskImage.revalidate();
                taskLabel.revalidate();
                taskBg.revalidate();

                widgetIndex++;
            }
        }
        updateScrollbar();
    }

    private void toggleTask(String taskId) {
        taskService.toggleComplete(taskId);
        refreshTasks(0);
    }

    // Overload getTasksToShow to accept a count
    private List<Task> getTasksToShow(TaskTier relevantTier, int topTaskIndex, int count) {
        List<Task> tasksToShow = new ArrayList<>();
        List<Task> taskList = taskService.getTierTasks(relevantTier);
        for (int i = 0; i < count; i++) {
            if (topTaskIndex + i >= taskList.size()) break;
            tasksToShow.add(taskList.get(topTaskIndex + i));
        }
        return tasksToShow;
    }

    private void hideUnusedTaskElements(int visibleCount) {
        // Only hide widgets beyond visibleCount (which is visibleTasks+1)
        for (int i = visibleCount; i < taskBackgrounds.size(); i++) {
            UIGraphic bg = taskBackgrounds.get(i);
            bg.getWidget().setHidden(true);
            bg.setPosition(-1000, 0);
            bg.getWidget().setPos(-1000, 0);
            bg.setSprite(TRANSPARENT_SPRITE_ID);
        }
        for (int i = visibleCount; i < taskLabels.size(); i++) {
            UILabel label = taskLabels.get(i);
            label.getWidget().setHidden(true);
            label.setPosition(-1000, 0);
            label.getWidget().setPos(-1000, 0);
            label.setText("");
        }
        for (int i = visibleCount; i < taskImages.size(); i++) {
            UIGraphic img = taskImages.get(i);
            img.getWidget().setHidden(true);
            img.setPosition(-1000, 0);
            img.getWidget().setPos(-1000, 0);
            img.setItem(-1);
        }
    }

    public void goToTop() {
        topTaskIndex = 0;
        updateScrollbar();
    }

    public void handleWheel(final MouseWheelEvent event)
    {
        if (!this.isVisible() || !bounds.contains(event.getPoint()))
        {
            return;
        }

        event.consume();

        // Needed otherwise we get laggy updates
        clientThread.invoke(() -> refreshTasks(event.getWheelRotation()));
    }

    public void updateBounds()
    {
        Widget wrapper = window.getParent();
        wrapperX = wrapper.getRelativeX();
        wrapperY = wrapper.getRelativeY();
        wrapperHeight = window.getHeight() - OFFSET_Y;
        windowX = window.getRelativeX();
        windowY = window.getRelativeY();
        windowWidth = window.getWidth();
        windowHeight = window.getHeight();

        bounds.setLocation(wrapperX + windowX + OFFSET_X, wrapperY + windowY + OFFSET_Y);
        bounds.setSize(windowWidth - OFFSET_X, wrapperHeight);
        // Recalculate how many tasks can be displayed
        int newTasksPerPage = Math.max(1, wrapperHeight / TASK_HEIGHT);
        columns = Math.max(1, (windowWidth - SCROLLBAR_WIDTH - 40) / (TASK_WIDTH + COLUMN_SPACING));
        if (newTasksPerPage != tasksPerPage) {
            tasksPerPage = newTasksPerPage;
            // Ensure topTaskIndex is valid for the new page size
            TaskTier relevantTier = plugin.getSelectedTier();
            if (relevantTier == null) {
                relevantTier = TaskTier.MASTER;
            }
            int maxTopIndex = Math.max(0, taskService.getTierTasks(relevantTier).size() - tasksPerPage);
            topTaskIndex = Math.min(topTaskIndex, maxTopIndex);
        }

        if (!this.isVisible()) {
            return;
        }
        updateArrowPositions();
        updateScrollbar();
        refreshTasks(0);
    }

    private void updateArrowPositions() {
        int scrollbarX = windowWidth - ARROW_SPRITE_WIDTH - 5;
        // Position arrows vertically in order: page up, up, down, page down
        int pageUpY = ARROW_SPRITE_HEIGHT + ARROW_Y_OFFSET;
        int upArrowY = ARROW_SPRITE_HEIGHT * 2 + ARROW_Y_OFFSET;
        int downArrowY = windowHeight - ARROW_SPRITE_HEIGHT * 2;
        int pageDownY = windowHeight - ARROW_SPRITE_HEIGHT;
        forceWidgetPositionUpdate(pageUpButton.getWidget(), scrollbarX, pageUpY);
        forceWidgetPositionUpdate(upArrowButton.getWidget(), scrollbarX, upArrowY);
        forceWidgetPositionUpdate(downArrowButton.getWidget(), scrollbarX, downArrowY);
        forceWidgetPositionUpdate(pageDownButton.getWidget(), scrollbarX, pageDownY);
    }

    private void forceWidgetPositionUpdate(Widget button, int x, int y) {
        button.setPos(x, y);
        button.revalidate();
    }

    private void forceWidgetUpdate(Widget widget, int width, int height) {
        widget.setSize(width, height);
        widget.revalidate();
    }

    private void updateScrollbar() {
        if (!this.isVisible()) {
            setScrollbarVisibility(false);
            return;
        }

        // The track should fill between the up and down arrows
        int trackY = ARROW_SPRITE_HEIGHT * 3 + ARROW_Y_OFFSET;
        int scrollbarTrackHeight = windowHeight - trackY - ARROW_SPRITE_HEIGHT * 2;
        int scrollbarX = windowWidth - SCROLLBAR_WIDTH - 9;
        scrollbarTrackWidget.setPos(scrollbarX + 2, trackY);

        // Update position, arrows and thumbs
        forceWidgetUpdate(scrollbarTrackWidget, SCROLLBAR_WIDTH, scrollbarTrackHeight);
        updateArrowPositions();
        setScrollbarVisibility(true);
        updateScrollbarThumb(scrollbarTrackHeight, scrollbarX);
    }

    private void updateScrollbarThumb(int scrollbarTrackHeight, int scrollbarX) {
        int tasksPerPageActual = (columns > 1) ? tasksPerPage * columns : tasksPerPage;
        topTaskIndex = Math.min(topTaskIndex, Math.max(0, totalTasks - tasksPerPageActual));
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPageActual / totalTasks)));
        int maxScrollPosition = Math.max(1, totalTasks - tasksPerPageActual);
        int thumbY = (int)((scrollbarTrackHeight - thumbHeight) * ((double)topTaskIndex / maxScrollPosition));
        int thumbStartY = ARROW_SPRITE_HEIGHT*3 + ARROW_Y_OFFSET + thumbY;
        int thumbX = scrollbarX + 2;
        // Update middle section (variable height)
        int middleHeight = Math.max(0, thumbHeight - 4);
        scrollbarThumbMiddleWidget.setSize(SCROLLBAR_WIDTH, middleHeight);
        // Force redraw all thumb components
        forceWidgetPositionUpdate(scrollbarThumbTopWidget, thumbX, thumbStartY);
        forceWidgetPositionUpdate(scrollbarThumbMiddleWidget, thumbX, thumbStartY + 2);
        forceWidgetPositionUpdate(scrollbarThumbBottomWidget, thumbX, thumbStartY + thumbHeight - 2);
    }

    private int calculateNewScrollPosition(int mouseY, int totalTasks) {
        int tasksPerPageActual = tasksPerPage * columns;
        int scrollbarTrackHeight = wrapperHeight - (ARROW_SPRITE_HEIGHT * 4) - ARROW_Y_OFFSET;
        int thumbHeight = Math.max(SCROLLBAR_THUMB_MIN_HEIGHT, (int)(scrollbarTrackHeight * ((double)tasksPerPageActual / totalTasks)));
        int deltaY = mouseY - dragStartY;
        int maxTopIndex = Math.max(0, totalTasks - tasksPerPageActual);
        double scrollRatio = (scrollbarTrackHeight - thumbHeight) > 0 ? (double)deltaY / (scrollbarTrackHeight - thumbHeight) : 0;
        int newTopIndex = dragStartTopIndex + (int)(scrollRatio * (totalTasks - tasksPerPageActual));
        
        // Round to nearest column boundary
        newTopIndex = (newTopIndex / columns) * columns;
        
        return Math.max(0, Math.min(maxTopIndex, newTopIndex));
    }

    private void setScrollbarVisibility(boolean visible) {
        if (scrollbarTrackWidget != null) scrollbarTrackWidget.setHidden(!visible);
        if (scrollbarThumbTopWidget != null) scrollbarThumbTopWidget.setHidden(!visible);
        if (scrollbarThumbMiddleWidget != null) scrollbarThumbMiddleWidget.setHidden(!visible);
        if (scrollbarThumbBottomWidget != null) scrollbarThumbBottomWidget.setHidden(!visible);
    }

    @Override
    public void setVisibility(boolean visible) {
        super.setVisibility(visible);
        setScrollbarVisibility(visible && this.isVisible());
        if (visible) updateScrollbar();
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if (!this.isVisible()) return;
        
        if (isPointInScrollThumb(mouseX, mouseY)) {
            isDraggingThumb = true;
            dragStartY = mouseY;
            dragStartTopIndex = topTaskIndex;
        }
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if (!isDraggingThumb || !this.isVisible()) return;
        
        if (totalTasks <= tasksPerPage) return;
        
        int newTopIndex = calculateNewScrollPosition(mouseY, totalTasks);
        if (newTopIndex != topTaskIndex) {
            topTaskIndex = newTopIndex;
            // Needed otherwise we get laggy updates
            clientThread.invoke(() -> refreshTasks(0));
        }
    }

    private boolean isPointInScrollThumb(int mouseX, int mouseY) {
        int baseX = wrapperX + windowX;
        int baseY = wrapperY + windowY;
        
        // Check if point is in any of the three thumb components
        int thumbX = baseX + scrollbarThumbTopWidget.getRelativeX();
        int thumbTopY = baseY + scrollbarThumbTopWidget.getRelativeY();
        int thumbBottomY = baseY + scrollbarThumbBottomWidget.getRelativeY() + scrollbarThumbBottomWidget.getHeight();
        int thumbWidth = scrollbarThumbTopWidget.getWidth();
        
        return mouseX >= thumbX && mouseX <= thumbX + thumbWidth &&
            mouseY >= thumbTopY && mouseY <= thumbBottomY;
    }

    public void handleMouseRelease() {
        isDraggingThumb = false;
    }
}

package com.collectionlogmaster.ui;

public class InterfaceConstants {

    public static final String DEF_FILE_SPRITES = "SpriteDef.json";
    public static final int TRANSPARENT_SPRITE_ID = -20099;

    public static final int TASK_LIST_BACKGROUND_SPRITE_ID = -20012;
    public static final int TASK_COMPLETE_BACKGROUND_SPRITE_ID = -20013;
    public static final int TASK_CURRENT_BACKGROUND_SPRITE_ID = -20016;

    public static final int COLLECTION_LOG_WINDOW_WIDTH = 500;
    public static final int COLLECTION_LOG_WINDOW_HEIGHT = 314;

    public static final int DASHBOARD_TAB_SPRITE_ID = -20007;
    public static final int DASHBOARD_TAB_HOVER_SPRITE_ID = -20008;
    public static final int DIVIDER_SPRITE_ID = -20011;

    public static final int TASKLIST_EASY_TAB_SPRITE_ID = -20017;
    public static final int TASKLIST_EASY_TAB_HOVER_SPRITE_ID = -20018;
    public static final int TASKLIST_MEDIUM_TAB_SPRITE_ID = -20019;
    public static final int TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID = -20020;
    public static final int TASKLIST_HARD_TAB_SPRITE_ID = -20021;
    public static final int TASKLIST_HARD_TAB_HOVER_SPRITE_ID = -20022;
    public static final int TASKLIST_ELITE_TAB_SPRITE_ID = -20023;
    public static final int TASKLIST_ELITE_TAB_HOVER_SPRITE_ID = -20024;
    public static final int TASKLIST_MASTER_TAB_SPRITE_ID = -20025;
    public static final int TASKLIST_MASTER_TAB_HOVER_SPRITE_ID = -20026;
}

package com.collectionlogmaster.ui;

import lombok.Getter;
import net.runelite.client.game.SpriteOverride;

@Getter
public class SpriteDefinition implements SpriteOverride
{
    private int spriteId;
    private String fileName;
}

package com.collectionlogmaster.ui;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.command.CommandRequest;
import com.collectionlogmaster.domain.command.CommandResponse;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.util.EventBusSubscriber;
import com.collectionlogmaster.util.HttpClient;
import com.collectionlogmaster.util.SimpleDebouncer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;

import static com.collectionlogmaster.util.GsonOverride.GSON;

@Slf4j
@Singleton
public class TaskmanCommandManager extends EventBusSubscriber {
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatCommandManager chatCommandManager;

    @Inject
    private CollectionLogMasterConfig config;

    @Inject
    private HttpClient httpClient;

    @Inject
    private TaskService taskService;

    @Inject
    private SimpleDebouncer updateDebouncer;

    private final HttpUrl baseApiUrl = new HttpUrl.Builder()
            .scheme("https")
            .host("taskman.up.railway.app")
            .addPathSegment("task")
            .addPathSegment("command")
            .build();

    private final String COLLECTION_LOG_COMMAND = "!taskman";

    public void startUp() {
        super.startUp();

        if (config.isCommandEnabled()) {
            chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeCommand);
        }
    }

    public void shutDown() {
        super.shutDown();

        if (config.isCommandEnabled()) {
            chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(CollectionLogMasterConfig.CONFIG_GROUP)) return;
        if (!event.getKey().equals(CollectionLogMasterConfig.IS_COMMAND_ENABLED_KEY)) return;

        if (config.isCommandEnabled()) {
            chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeCommand);
            updateServerImmediately();
        } else {
            chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged e) {
        if (e.getGameState() != GameState.LOGGED_IN) return;

        clientThread.invokeAtTickEnd(this::updateServer);
    }

    private void executeCommand(ChatMessage chatMessage, String message) {
        log.debug("Executing taskman command: {}", message);

        String senderName = chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT)
                ? client.getLocalPlayer().getName()
                : Text.sanitize(chatMessage.getName());

        if (senderName == null) {
            log.debug("Couldn't identify message sender");
            return;
        }

        HttpUrl url = baseApiUrl.newBuilder().addPathSegment(senderName).build();
        httpClient.getHttpRequestAsync(url.toString(), CommandResponse.class)
            .thenAccept(res ->
                clientThread.invokeLater(() -> replaceChatMessage(chatMessage, res))
            );
    }

    public void updateServer() {
        log.debug("Scheduling command update; {}", Instant.now());
        updateDebouncer.debounce(this::updateServerImmediately);
    }

    public void updateServerImmediately() {
        if (!config.isCommandEnabled()) {
            return;
        }

        log.debug("Executing command update; {}", Instant.now());

        String rsn = client.getLocalPlayer().getName();
        if (rsn == null) return;

        HttpUrl url = baseApiUrl.newBuilder().addPathSegment(rsn).build();

        String taskId = "complete";
        Task currentTask = taskService.getActiveTask();
        if (currentTask != null) {
            taskId = currentTask.getId();
        }

        TaskTier currentTier = taskService.getCurrentTier();
        float currentProgress = taskService.getProgress().get(currentTier);

        CommandRequest data = new CommandRequest(taskId, taskService.getCurrentTier().displayName, (int) currentProgress);
        httpClient.putHttpRequestAsync(url.toString(), GSON.toJson(data), null);
    }

    private void replaceChatMessage(ChatMessage chatMessage, CommandResponse res) {
        if (res == null) return;

        final String msg = new ChatMessageBuilder()
                .append(ChatColorType.NORMAL)
                .append("Progress: ")
                .append(ChatColorType.HIGHLIGHT)
                .append(res.getProgressPercentage() + "% " + res.getTier())
                .append(ChatColorType.NORMAL)
                .append(" Current task: ")
                .append(ChatColorType.HIGHLIGHT)
                .append(res.getTask().getName())
                .build();

        final MessageNode messageNode = chatMessage.getMessageNode();
        messageNode.setRuneLiteFormatMessage(msg);
        client.refreshChat();
    }
}

package com.collectionlogmaster.ui;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.synchronization.SyncService;
import com.collectionlogmaster.synchronization.clog.CollectionLogService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.component.BurgerMenuManager;
import com.collectionlogmaster.ui.component.TabManager;
import com.collectionlogmaster.ui.component.TaskDashboard;
import com.collectionlogmaster.ui.component.TaskInfo;
import com.collectionlogmaster.ui.component.TaskList;
import com.collectionlogmaster.ui.generic.UICheckBox;
import com.collectionlogmaster.util.EventBusSubscriber;
import com.collectionlogmaster.util.FileUtils;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.SoundEffectID;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.input.MouseWheelListener;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.util.List;

import static com.collectionlogmaster.CollectionLogMasterConfig.CONFIG_GROUP;
import static com.collectionlogmaster.ui.InterfaceConstants.DEF_FILE_SPRITES;

@Singleton
public class InterfaceManager extends EventBusSubscriber implements MouseListener, MouseWheelListener {
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private CollectionLogMasterConfig config;

    @Inject
    private CollectionLogMasterPlugin plugin;

	@Inject
	private MouseManager mouseManager;

    @Inject
    private SpriteManager spriteManager;

    @Inject
    private CollectionLogService collectionLogService;

    @Inject
    private SyncService syncService;

    @Inject
    private TaskService taskService;

    @Inject
    private BurgerMenuManager burgerMenuManager;

    public TaskDashboard taskDashboard;
    private TaskList taskList;
    private TabManager tabManager;
    private TaskInfo taskInfo;

    private UICheckBox taskDashboardCheckbox;

    private boolean checkboxDeprecationWarned = false;

    public void startUp() {
        super.startUp();
        mouseManager.registerMouseListener(this);
        mouseManager.registerMouseWheelListener(this);
        burgerMenuManager.startUp();

        burgerMenuManager.setOnSelectChangedListener(this::toggleTaskDashboard);

        SpriteDefinition[] spriteDefinitions = FileUtils.loadDefinitionResource(SpriteDefinition[].class, DEF_FILE_SPRITES);
        this.spriteManager.addSpriteOverrides(spriteDefinitions);
    }

    public void shutDown() {
        super.shutDown();
        mouseManager.unregisterMouseListener(this);
        mouseManager.unregisterMouseWheelListener(this);
        burgerMenuManager.shutDown();
    }

	@Subscribe
	public void onConfigChanged(ConfigChanged e) {
        if (!e.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

        if (!isTaskDashboardEnabled() || this.taskDashboard == null || this.tabManager == null) {
            return;
        }

        taskDashboard.updatePercentages();

        clientThread.invoke(tabManager::updateTabs);

        List<TaskTier> visibleTiers = taskService.getVisibleTiers();
        TaskTier activeTier = plugin.getSelectedTier();
        if (activeTier != null && !visibleTiers.contains(activeTier)) {
            clientThread.invoke(tabManager::activateTaskDashboard);
        }
    }

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e) {
		if (e.getGroupId() != InterfaceID.COLLECTION) {
			return;
		}

        Widget window = client.getWidget(InterfaceID.Collection.CONTENT);

        createTaskInfo(window);
        createTaskDashboard(window);
        createTaskList(window);
        createTabManager(window);
        createTaskCheckbox();
        this.tabManager.setComponents(taskDashboard, taskList);
        this.taskInfo.setComponents(taskDashboard, taskList, tabManager);

        this.tabManager.updateTabs();
        this.taskDashboard.setVisibility(false);
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed e) {
		if (e.getGroupId() != InterfaceID.COLLECTION) {
			return;
		}

        this.taskDashboard.setVisibility(false);
        this.taskList.setVisibility(false);
        tabManager.hideTabs();
	}
    
    Rectangle oldBounds;

	@Subscribe
	public void onGameTick(GameTick e) {
        Widget window = client.getWidget(621, 88);
        if (window == null) {
            oldBounds = null;
            return;
        }
        // Check if the window bounds have changed
        Rectangle newBounds = window.getBounds();
        if (oldBounds != null && oldBounds.equals(newBounds)) {
            return;
        }
        oldBounds = newBounds;

        if (this.taskList != null) {
            taskList.updateBounds();
        }
        if (this.taskDashboard != null) {
            taskDashboard.updateBounds();
        }
        if (this.tabManager != null) {
            tabManager.updateBounds();
        }
        if (this.taskInfo != null) {
            taskInfo.updateBounds();
        }
        if (this.taskDashboardCheckbox != null) {
            taskDashboardCheckbox.alignToRightEdge(window, 35, 10);
        }
	}

    public boolean isDashboardOpen() {
        return this.taskDashboard != null && this.taskDashboard.isVisible();
    }

    public void handleMouseWheel(MouseWheelEvent event) {
        if (this.taskList != null) {
            taskList.handleWheel(event);
        }
    }

    public void handleMousePress(int mouseX, int mouseY) {
        if (this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMousePress(mouseX, mouseY);
        }
    }

    public void handleMouseDrag(int mouseX, int mouseY) {
        if (this.taskList != null && this.taskList.isVisible()) {
            taskList.handleMouseDrag(mouseX, mouseY);
        }
    }

    public void handleMouseRelease() {
        if (this.taskList != null) {
            taskList.handleMouseRelease();
        }
    }

    @Override
    public MouseWheelEvent mouseWheelMoved(MouseWheelEvent event) {
        handleMouseWheel(event);
        return event;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent event) {
        handleMousePress(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent event) {
        handleMouseRelease();
        return event;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent event) {
        handleMouseDrag(event.getX(), event.getY());
        return event;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent event) {
        return event;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent event) {
        return event;
    }

    private void createTabManager(Widget window) {
        this.tabManager = new TabManager(window, config, plugin);
    }

    private void createTaskDashboard(Widget window) {
        this.taskDashboard = new TaskDashboard(plugin, config, window, syncService, taskService, client, taskInfo);
        this.taskDashboard.setVisibility(false);
    }

    private void createTaskList(Widget window) {
        this.taskList = new TaskList(window, plugin, clientThread, config, collectionLogService, taskService, taskInfo);
        this.taskList.setVisibility(false);
    }

    private void createTaskInfo(Widget window) {
        this.taskInfo = new TaskInfo(window, plugin, collectionLogService, taskService);
    }

    private void createTaskCheckbox() {
        Widget window = client.getWidget(621, 88);
        if (window != null) {
            // Create the graphic widget for the checkbox
            Widget toggleWidget = window.createChild(-1, WidgetType.GRAPHIC);
            Widget labelWidget = window.createChild(-1, WidgetType.TEXT);

            // Wrap in checkbox, set size, position, etc.
            taskDashboardCheckbox = new UICheckBox(toggleWidget, labelWidget);
            taskDashboardCheckbox.setPosition(360, 10);
            taskDashboardCheckbox.setName("Task Dashboard");
            taskDashboardCheckbox.setEnabled(false);
            taskDashboardCheckbox.setText("Task Dashboard");
            labelWidget.setPos(375, 10);


            taskDashboardCheckbox.setToggleListener((UICheckBox src) -> {
                if (!checkboxDeprecationWarned) {
                    checkboxDeprecationWarned = true;
                    String msg = "<col=ff392b>Please use the hamburger menu on the top-left corner to open the task dashboard;"
                            + " this checkbox will be removed in the future";
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, "");
                    client.playSoundEffect(2277);
                }

                this.burgerMenuManager.setSelected(taskDashboardCheckbox.isEnabled());
            });
        }
    }

    private void toggleTaskDashboard() {
        if(this.taskDashboard == null) return;

        Task activeTask = taskService.getActiveTask();
        if (activeTask != null) {
            this.taskDashboard.setTask(activeTask, null);
        } else {
            this.taskDashboard.clearTask();
        }

        boolean enabled = isTaskDashboardEnabled();
        
        
        this.taskDashboardCheckbox.setEnabled(enabled);
        Widget contentWidget = client.getWidget(InterfaceID.Collection.CONTENT);
        if (contentWidget != null) {
            for (Widget c : contentWidget.getStaticChildren()) {
                c.setHidden(enabled);
            }
        }
        Widget searchTitleWidget = client.getWidget(InterfaceID.Collection.SEARCH_TITLE);
        if (searchTitleWidget != null) {
            searchTitleWidget.setHidden(enabled);
        }

        if (enabled) {
            this.tabManager.activateTaskDashboard();
        } else {
            this.taskInfo.setVisibility(false);
            this.taskDashboard.setVisibility(false);
            this.taskList.setVisibility(false);
            this.tabManager.hideTabs();
        }

        // *Boop*
        this.client.playSoundEffect(SoundEffectID.UI_BOOP);
    }

    private boolean isTaskDashboardEnabled() {
        return burgerMenuManager.isSelected();
    }

    public void completeTask() {
        boolean wasDashboardVisible = this.taskDashboard.isVisible();
        this.taskDashboard.updatePercentages();
        taskList.refreshTasks(0);
        // Restore previous visibility state
        this.taskDashboard.setVisibility(wasDashboardVisible);
        this.taskList.setVisibility(!wasDashboardVisible);
        this.tabManager.showTabs();
    }
}

package com.collectionlogmaster;

import com.google.inject.Provides;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.synchronization.clog.CollectionLogService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.InterfaceManager;
import com.collectionlogmaster.ui.TaskmanCommandManager;
import com.collectionlogmaster.ui.component.TaskOverlay;
import com.collectionlogmaster.util.GsonOverride;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SoundEffectID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;

@Slf4j
@PluginDescriptor(
		name = "Collection Log Master",
		conflicts = {"[DEPRECATED] Collection Log Master"}
)
public class CollectionLogMasterPlugin extends Plugin {
	@Inject
	@SuppressWarnings("unused")
	private GsonOverride gsonOverride;

	@Inject
	private Client client;

	@Inject
	protected TaskOverlay taskOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private InterfaceManager interfaceManager;

	@Inject
	public ItemManager itemManager;

	@Inject
	public CollectionLogService collectionLogService;

	@Inject
	public PluginUpdateNotifier pluginUpdateNotifier;

	@Inject
	public TaskService taskService;

	@Inject
	public TaskmanCommandManager taskmanCommand;

	@Getter
	@Setter
	// TODO: this is UI state, move it somewhere else
	private TaskTier selectedTier;

	@Override
	protected void startUp() {
		taskService.startUp();
		collectionLogService.startUp();
		pluginUpdateNotifier.startUp();
		interfaceManager.startUp();
		taskmanCommand.startUp();
		this.taskOverlay.setResizable(true);
		this.overlayManager.add(this.taskOverlay);
	}

	@Override
	protected void shutDown() {
		taskService.shutDown();
		collectionLogService.shutDown();
		pluginUpdateNotifier.shutDown();
		interfaceManager.shutDown();
		taskmanCommand.shutDown();
		this.overlayManager.remove(this.taskOverlay);
	}

	@Provides
	CollectionLogMasterConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(CollectionLogMasterConfig.class);
	}

	public void completeTask() {
		Task activeTask = taskService.getActiveTask();
		completeTask(activeTask.getId());
	}

	public void completeTask(String taskId) {
		completeTask(taskId, true);
	}

	public void completeTask(String taskId, boolean playSound) {
		if (playSound) {
			this.client.playSoundEffect(SoundEffectID.UI_BOOP);
		}

		taskService.toggleComplete(taskId);
		if (taskService.getActiveTask() == null) {
			interfaceManager.taskDashboard.clearTask();
		}

		interfaceManager.completeTask();
	}

	public void visitFaq() {
		LinkBrowser.browse("https://docs.google.com/document/d/e/2PACX-1vTHfXHzMQFbt_iYAP-O88uRhhz3wigh1KMiiuomU7ftli-rL_c3bRqfGYmUliE1EHcIr3LfMx2UTf2U/pub");
	}
}

package com.collectionlogmaster.domain;

public enum DynamicTaskImages {
  NONE,
  INCOMPLETE,
  COMPLETE,
  ALL
}

package com.collectionlogmaster.domain;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.Data;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Set;

@Data
public class Task {
    private String id;
    private String name;
    private String tip;
    private String wikiLink;
    private int displayItemId;
    private Set<Tag> tags;

    private @Nullable Verification verification;

    public Set<Tag> getTags() {
        if (tags == null) {
            tags = new HashSet<>();
        }

        return tags;
    }
}

package com.collectionlogmaster.domain;

public enum Tag {
    LMS;
}

package com.collectionlogmaster.domain.command;

import lombok.Data;

@Data
public class CommandResponse {
    private CommandTask task;
    private String tier;
    private int progressPercentage;
}

package com.collectionlogmaster.domain.command;

import lombok.Data;

@Data
public class CommandTask {
    private String name;
    private String imageUrl;
}

package com.collectionlogmaster.domain.command;

import lombok.Data;
import lombok.RequiredArgsConstructor;

@Data
@RequiredArgsConstructor
public class CommandRequest {
    private final String taskId;
    private final String tier;
    private final int progressPercentage;
}

package com.collectionlogmaster.domain.verification.diary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum DiaryRegion {
    KARAMJA(0),
    ARDOUGNE(1),
    FALADOR(2),
    FREMENNIK(3),
    KANDARIN(4),
    DESERT(5),
    LUMBRIDGE_AND_DRAYNOR(6),
    MORYTANIA(7),
    VARROCK(8),
    WILDERNESS(9),
    WESTERN_PROVINCES(10),
    KOUREND_AND_KEBOS(11);

    private final int id;
}

package com.collectionlogmaster.domain.verification.diary;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class AchievementDiaryVerification extends Verification {
    private @NonNull DiaryRegion region;
    private @NonNull DiaryDifficulty difficulty;
}

package com.collectionlogmaster.domain.verification.diary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum DiaryDifficulty {
    EASY(2),
    MEDIUM(5),
    HARD(8),
    ELITE(11);

    private final int stackOffset;
}

package com.collectionlogmaster.domain.verification.clog;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class CollectionLogVerification extends Verification {
    private int @NonNull [] itemIds;
    private int count;
}

package com.collectionlogmaster.domain.verification;

public enum VerificationMethod {
    COLLECTION_LOG,
    ACHIEVEMENT_DIARY,
    SKILL;
}

package com.collectionlogmaster.domain.verification;

import lombok.Getter;

@Getter
public abstract class Verification {
    private VerificationMethod method;
}

package com.collectionlogmaster.domain.verification.skill;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import net.runelite.api.Skill;

import java.util.Map;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class SkillVerification extends Verification {
    private @NonNull Map<Skill, Integer> experience;
    private int count;
}

package com.collectionlogmaster.domain.savedata;

import lombok.Getter;
import lombok.ToString;

import javax.annotation.Nullable;

@ToString
@Getter
public class BaseSaveData {
    protected @Nullable Integer version = null;
}

package com.collectionlogmaster.domain.savedata.v0;

import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V0SaveData extends BaseSaveData {
    public final static Integer VERSION = null;

    public V0SaveData() {
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    private final Map<TaskTier, Set<Integer>> progress;

    @Setter
    private V0TaskPointer activeTaskPointer;

    @Setter
    private TaskTier selectedTier;
}

package com.collectionlogmaster.domain.savedata.v0;

import lombok.Getter;

@Getter
@Deprecated
public class V0Task {
    private int id;
    private String description;
    private int itemID;
}

package com.collectionlogmaster.domain.savedata.v0;

import com.collectionlogmaster.domain.TaskTier;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Deprecated
public class V0TaskPointer {

    private TaskTier taskTier;
    private V0Task task;
}

package com.collectionlogmaster.domain.savedata.v1;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@AllArgsConstructor
@NoArgsConstructor
@Deprecated
public class V1TaskPointer {
    private TaskTier taskTier;
    private Task task;
}

package com.collectionlogmaster.domain.savedata.v1;

import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V1SaveData extends BaseSaveData {
    public final static int VERSION = 1;

    public V1SaveData() {
        this.version = VERSION;
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    private final Map<TaskTier, Set<String>> progress;

    @Setter
    private @Nullable V1TaskPointer activeTaskPointer;
}

package com.collectionlogmaster.domain.savedata;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Set;

@Getter
@ToString
public class SaveData extends BaseSaveData {
    public final static int VERSION = 3;

    public SaveData() {
        this.version = VERSION;
    }

    @Setter
    private @Nullable String activeTaskId = null;

    private final Set<String> completedTasks = new HashSet<>();
}

package com.collectionlogmaster.domain.savedata;

import com.google.gson.reflect.TypeToken;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.v0.V0SaveData;
import com.collectionlogmaster.domain.savedata.v0.V0Task;
import com.collectionlogmaster.domain.savedata.v0.V0TaskPointer;
import com.collectionlogmaster.domain.savedata.v1.V1SaveData;
import com.collectionlogmaster.domain.savedata.v1.V1TaskPointer;
import com.collectionlogmaster.domain.savedata.v2.V2SaveData;
import com.collectionlogmaster.task.SaveDataStorage;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.util.FileUtils;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.collectionlogmaster.util.GsonOverride.GSON;

@Singleton
@Slf4j
@SuppressWarnings("deprecation")
public class SaveDataUpdater {
    @Inject
    private SaveDataStorage saveDataStorage;

    @Inject
    private TaskService taskService;

    public SaveData update(String json) {
        BaseSaveData base = GSON.fromJson(json, BaseSaveData.class);
        if (base == null) {
            return new SaveData();
        }

        if (base.getVersion() == V0SaveData.VERSION) {
            V0SaveData v0Save = GSON.fromJson(json, V0SaveData.class);
            return update(update(update(v0Save)));
        }

        if (base.getVersion() == V1SaveData.VERSION) {
            V1SaveData v1Save = GSON.fromJson(json, V1SaveData.class);
            return update(update(v1Save));
        }

        if (base.getVersion() == V2SaveData.VERSION) {
            V2SaveData v2Save = GSON.fromJson(json, V2SaveData.class);
            return update(v2Save);
        }

        if (base.getVersion() == SaveData.VERSION) {
            return GSON.fromJson(json, SaveData.class);
        }

        log.warn("Could not figure out save data version for json {}", json);
        return new SaveData();
    }

    private SaveData update(V2SaveData v2Save) {
        saveDataStorage.saveBackup(v2Save);
        SaveData newSave = new SaveData();

        newSave.getCompletedTasks().addAll(v2Save.getCompletedTasks());

        Task activeTask = v2Save.getActiveTask();
        if (activeTask != null) {
            newSave.setActiveTaskId(activeTask.getId());
        }

        return newSave;
    }

    private V2SaveData update(V1SaveData v1Save) {
        saveDataStorage.saveBackup(v1Save);
        V2SaveData newSave = new V2SaveData();

        V1TaskPointer v1ActiveTaskPointer = v1Save.getActiveTaskPointer();
        if (v1ActiveTaskPointer != null) {
            newSave.setActiveTask(v1ActiveTaskPointer.getTask());
        }

        Set<String> newCompletedTasks = newSave.getCompletedTasks();
        Set<String> v1CompletedTasks = v1Save.getProgress().entrySet().stream()
                .flatMap(entry -> entry.getValue().stream())
                .collect(Collectors.toSet());

        newCompletedTasks.addAll(v1CompletedTasks);

        return newSave;
    }

    private V1SaveData update(V0SaveData v0Save) {
        saveDataStorage.saveBackup(v0Save);
        V1SaveData newSave = new V1SaveData();

        Type mapType = new TypeToken<Map<TaskTier, Map<Integer, String>>>() {}.getType();
        Map<TaskTier, Map<Integer, String>> v0MigrationData =
                FileUtils.loadResource("domain/savedata/v0-migration.json", mapType);;

        Map<TaskTier, Set<Integer>> v0Progress = v0Save.getProgress();
        Map<TaskTier, Set<String>> newProgress = newSave.getProgress();

        for (TaskTier tier : TaskTier.values()) {
            Set<Integer> v0TierData = v0Progress.get(tier);
            Set<String> newTierData = newProgress.get(tier);
            Map<Integer, String> tierMigrationData = v0MigrationData.get(tier);

            for (Integer v0TaskId : v0TierData) {
                if (tierMigrationData.containsKey(v0TaskId)) {
                    newTierData.add(tierMigrationData.get(v0TaskId));
                }
            }
        }

        V0TaskPointer v0TaskPointer = v0Save.getActiveTaskPointer();
        if (v0TaskPointer != null) {
            V0Task v0Task = v0TaskPointer.getTask();
            String newTaskId = v0MigrationData.get(v0TaskPointer.getTaskTier()).get(v0Task.getId());
            Task newTask = taskService.getTaskById(newTaskId);

            // if we can't find the task, don't set it to avoid problems
            if (newTask != null) {
                newSave.setActiveTaskPointer(new V1TaskPointer(v0TaskPointer.getTaskTier(), newTask));
            }
        }

        return newSave;
    }
}

package com.collectionlogmaster.domain.savedata.v2;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V2SaveData extends BaseSaveData {
    public final static int VERSION = 2;

    public V2SaveData() {
        this.version = VERSION;
    }

    private final Set<String> completedTasks = new HashSet<>();

    @Setter
    private @Nullable Task activeTask = null;
}

package com.collectionlogmaster.domain;

import static com.collectionlogmaster.ui.InterfaceConstants.*;

public enum TaskTier {
    EASY("Easy", TASKLIST_EASY_TAB_SPRITE_ID, TASKLIST_EASY_TAB_HOVER_SPRITE_ID),
    MEDIUM("Medium", TASKLIST_MEDIUM_TAB_SPRITE_ID, TASKLIST_MEDIUM_TAB_HOVER_SPRITE_ID),
    HARD("Hard", TASKLIST_HARD_TAB_SPRITE_ID, TASKLIST_HARD_TAB_HOVER_SPRITE_ID),
    ELITE("Elite", TASKLIST_ELITE_TAB_SPRITE_ID, TASKLIST_ELITE_TAB_HOVER_SPRITE_ID),
    MASTER("Master", TASKLIST_MASTER_TAB_SPRITE_ID, TASKLIST_MASTER_TAB_HOVER_SPRITE_ID);

    public final String displayName;
    public final int tabSpriteId;
    public final int tabSpriteHoverId;

    TaskTier(String displayName, int tabSpriteId, int tabSpriteHoverId) {
        this.displayName = displayName;
        this.tabSpriteId = tabSpriteId;
        this.tabSpriteHoverId = tabSpriteHoverId;
    }
}

package com.collectionlogmaster.domain;

import lombok.Data;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Data
public class TieredTaskList {
    private List<Task> easy = new ArrayList<>();
    private List<Task> medium = new ArrayList<>();
    private List<Task> hard = new ArrayList<>();
    private List<Task> elite = new ArrayList<>();
    private List<Task> master = new ArrayList<>();

    public List<Task> getForTier(TaskTier tier) {
        switch (tier) {
            case EASY: return easy;
            case MEDIUM: return medium;
            case HARD: return hard;
            case ELITE: return elite;
            case MASTER: return master;
            default: return Collections.emptyList();
        }
    }
}

package com.collectionlogmaster.domain.adapters;

import com.google.gson.*;
import com.collectionlogmaster.util.EnumUtils;
import com.collectionlogmaster.util.StringUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
@RequiredArgsConstructor
public class EnumAdapter<T extends Enum<T>> implements JsonDeserializer<T>, JsonSerializer<T> {
    private final Class<T> clazz;

    @Override
    public T deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException {
        return EnumUtils.fromString(clazz, jsonElement.getAsString());
    }

    @Override
    public JsonElement serialize(T t, Type type, JsonSerializationContext context) {
        return context.serialize(StringUtils.kebabCase(t.name()), String.class);
    }
}

package com.collectionlogmaster.domain.adapters;

import com.google.gson.*;
import com.collectionlogmaster.domain.verification.Verification;
import com.collectionlogmaster.domain.verification.VerificationMethod;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.domain.verification.diary.AchievementDiaryVerification;
import com.collectionlogmaster.domain.verification.skill.SkillVerification;
import com.collectionlogmaster.util.EnumUtils;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
public class VerificationAdapter implements JsonDeserializer<Verification> {
    private static final String DISCRIMINATOR_FIELD = "method";

    @Override
    public Verification deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException {
        JsonObject obj = jsonElement.getAsJsonObject();
        if (!obj.has(DISCRIMINATOR_FIELD)) {
            log.error("Verification object has no required discriminator field '{}'", DISCRIMINATOR_FIELD);
            return null;
        }

        String methodStr = obj.get(DISCRIMINATOR_FIELD).getAsString();
        VerificationMethod method = EnumUtils.fromString(VerificationMethod.class, methodStr);
        if (method == null) {
            log.warn("Verification object has unknown method '{}'", methodStr);
            return null;
        }

        switch (method) {
            case COLLECTION_LOG:
                return context.deserialize(jsonElement, CollectionLogVerification.class);

            case ACHIEVEMENT_DIARY:
                return context.deserialize(jsonElement, AchievementDiaryVerification.class);

            case SKILL:
                return context.deserialize(jsonElement, SkillVerification.class);
        }

        log.error("Unhandled verification method '{}'", method);
        return null;
    }
}

package com.collectionlogmaster.task;

import com.collectionlogmaster.domain.TieredTaskList;
import com.collectionlogmaster.util.FileUtils;
import com.collectionlogmaster.util.HttpClient;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.CompletableFuture;


@Slf4j
@Singleton
public class TaskListStorage {
    private static final String LOCAL_TASK_LIST_FILE = "task-list.json";

    private static final String REMOTE_TASK_LIST_URL = "https://raw.githubusercontent.com/OSRS-Taskman/generate-task/refs/heads/main/src/main/resources/com/logmaster/domain/task-list.json";

    private final HttpClient httpClient;

    private @NonNull TieredTaskList taskList = new TieredTaskList();

    @Inject
    public TaskListStorage(HttpClient httpClient) {
        this.httpClient = httpClient;
        loadAsync();
    }

    public @NonNull TieredTaskList get() {
        return taskList;
    }

    private void loadAsync() {
        fetchRemoteAsync()
                .exceptionally(t -> fetchLocal())
                .thenAccept(taskList -> this.taskList = taskList);
    }

    private @NonNull TieredTaskList fetchLocal() {
        return FileUtils.loadDefinitionResource(TieredTaskList.class, LOCAL_TASK_LIST_FILE);
    }

    private CompletableFuture<TieredTaskList> fetchRemoteAsync() {
        return httpClient.getHttpRequestAsync(REMOTE_TASK_LIST_URL, TieredTaskList.class);
    }
}

package com.collectionlogmaster.task;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.domain.Tag;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.SaveData;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.ui.TaskmanCommandManager;
import com.collectionlogmaster.util.EventBusSubscriber;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Singleton
@Slf4j
public class TaskService extends EventBusSubscriber {
    @Inject
    private CollectionLogMasterConfig config;

    @Inject
    private SaveDataStorage saveDataStorage;

    @Inject
    private TaskListStorage taskListStorage;

    @Inject
    private TaskmanCommandManager taskmanCommandManager;

    @Override
    public void startUp() {
        super.startUp();
        saveDataStorage.startUp();
    }

    @Override
    public void shutDown() {
        super.shutDown();
        saveDataStorage.shutDown();
    }

    public Task getActiveTask() {
        String activeTaskId = saveDataStorage.get().getActiveTaskId();

        return activeTaskId == null ? null : getTaskById(activeTaskId);
    }

    // we might want to build a cache map in the future
    public Task getTaskById(String taskId) {
        for (TaskTier t : TaskTier.values()) {
            List<Task> tasks = getTierTasks(t);
            for (Task task : tasks) {
                if (task.getId().equals(taskId)) {
                    return task;
                }
            }
        }

        return null;
    }

    public @NonNull TaskTier getCurrentTier() {
        Map<TaskTier, Float> progress = getProgress();

        return getVisibleTiers().stream()
                .filter(t -> progress.get(t) < 100)
                .findFirst()
                .orElse(TaskTier.MASTER);
    }

    public List<Task> getTierTasks() {
        return getTierTasks(getCurrentTier());
    }

    public List<Task> getTierTasks(TaskTier tier) {
        List<Task> tierTasks = taskListStorage.get().getForTier(tier);

        if (!config.isLMSEnabled()) {
            return filterTag(tierTasks, Tag.LMS);
        }

        return tierTasks;
    }

    public List<Task> getIncompleteTierTasks() {
        return getIncompleteTierTasks(getCurrentTier());
    }

    public List<Task> getIncompleteTierTasks(TaskTier tier) {
        List<Task> tierTasks = getTierTasks(tier);

        return tierTasks.stream()
                .filter(t -> !isComplete(t.getId()))
                .collect(Collectors.toList());
    }

    public List<TaskTier> getVisibleTiers() {
        TaskTier hideBelow = config.hideBelow();

        return Arrays.stream(TaskTier.values())
                .filter(t -> t.ordinal() >= hideBelow.ordinal())
                .collect(Collectors.toList());
    }

    public @NonNull Map<TaskTier, Float> getProgress() {
        SaveData data = saveDataStorage.get();
        Set<String> completedTasks = data.getCompletedTasks();

        Map<TaskTier, Float> completionPercentages = new HashMap<>();
        for (TaskTier tier : TaskTier.values()) {
            Set<String> tierTasks = getTierTasks(tier).stream()
                    .map(Task::getId)
                    .collect(Collectors.toSet());

            int totalTierTasks = tierTasks.size();
            tierTasks.retainAll(completedTasks);

            float tierPercentage = 100f * tierTasks.size() / totalTierTasks;

            completionPercentages.put(tier, tierPercentage);
        }

        return completionPercentages;
    }

    public Task generate() {
        SaveData data = saveDataStorage.get();

        String activeTaskId = data.getActiveTaskId();
        if (activeTaskId != null) {
            log.warn("Tried to generate task when previous one wasn't completed yet");
            return null;
        }

        TaskTier currentTier = getCurrentTier();
        List<Task> incompleteTierTasks = getIncompleteTierTasks(currentTier);
        if (incompleteTierTasks.isEmpty()) {
            log.warn("No tasks left");
            return null;
        }

        Task generatedTask = pickRandomTask(incompleteTierTasks);
        log.debug("New task generated: {}", generatedTask);

        data.setActiveTaskId(generatedTask.getId());
        saveDataStorage.save();
        taskmanCommandManager.updateServer();

        return generatedTask;
    }

    public void complete() {
        Task activeTask = getActiveTask();
        if (activeTask == null) {
            return;
        }

        complete(activeTask.getId());
    }

    public void complete(String taskId) {
        SaveData data = saveDataStorage.get();
        Set<String> completedTasks = data.getCompletedTasks();
        completedTasks.add(taskId);

        if (taskId.equals(data.getActiveTaskId())) {
            data.setActiveTaskId(null);
        }

        saveDataStorage.save();
        taskmanCommandManager.updateServer();
    }

    public void uncomplete(String taskId) {
        Set<String> completedTasks = saveDataStorage.get().getCompletedTasks();
        completedTasks.remove(taskId);

        saveDataStorage.save();
        taskmanCommandManager.updateServer();
    }

    public void toggleComplete(String taskId) {
        if (isComplete(taskId)) {
            uncomplete(taskId);
        } else {
            complete(taskId);
        }
    }

    public boolean isComplete(String taskId) {
        Set<String> completedTasks = saveDataStorage.get().getCompletedTasks();

        return completedTasks.contains(taskId);
    }

    private Task pickRandomTask(List<Task> tasks) {
		int index = (int) Math.floor(Math.random() * tasks.size());
		Task pickedTask = tasks.get(index);

		if (!(pickedTask.getVerification() instanceof CollectionLogVerification)) {
			return pickedTask;
		}

		// get first of similarly named tasks
		String taskName = pickedTask.getName();
		Stream<Task> similarTasks = tasks.stream()
				.filter(t -> taskName.equals(t.getName()))
				.filter(t -> t.getVerification() instanceof CollectionLogVerification);

        //noinspection DataFlowIssue
        return similarTasks.min(Comparator.comparingInt(
			t -> ((CollectionLogVerification) t.getVerification()).getCount()
		)).orElse(pickedTask);
	}

    private List<Task> filterTag(List<Task> list, Tag tag) {
        return list.stream()
                .filter(t -> !t.getTags().contains(tag))
                .collect(Collectors.toList());
    }
}

package com.collectionlogmaster.task;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.google.gson.JsonSyntaxException;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import com.collectionlogmaster.domain.savedata.SaveData;
import com.collectionlogmaster.domain.savedata.SaveDataUpdater;
import com.collectionlogmaster.util.EventBusSubscriber;
import com.collectionlogmaster.util.SimpleDebouncer;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;

import static com.collectionlogmaster.CollectionLogMasterConfig.CONFIG_GROUP;
import static com.collectionlogmaster.util.GsonOverride.GSON;

@Singleton
@Slf4j
public class SaveDataStorage extends EventBusSubscriber {
    public static final String SAVE_DATA_KEY = "save-data";

    public static final String SAVE_DATA_BACKUP_KEY_BASE = "save-data-bk";

    @Inject
    private ConfigManager configManager;

    @Inject
    private SaveDataUpdater saveDataUpdater;

    @Inject
    private SimpleDebouncer saveDebouncer;

    private SaveData data;

    @Override
    public void startUp() {
        super.startUp();
        load();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged e) {
        GameState state = e.getGameState();
        switch (state) {
            case LOGGED_IN:
                load();
                break;

            case LOGIN_SCREEN:
                saveImmediately();
                break;
        }
    }

    public SaveData get() {
        return data;
    }

    public void save() {
        log.debug("Scheduling save; {}", Instant.now());
        saveDebouncer.debounce(this::saveImmediately);
    }

    public void saveImmediately() {
        log.debug("Saving; {}", Instant.now());
        String json = GSON.toJson(data);
        configManager.setRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, json);
    }

    public void saveBackup(BaseSaveData data) {
        String json = GSON.toJson(data);
        configManager.setRSProfileConfiguration(
                CONFIG_GROUP,
                SAVE_DATA_BACKUP_KEY_BASE + data.getVersion(),
                json
        );
    }

    private void load() {
        importOldPluginSave();
        data = read();
    }

    private @NonNull SaveData read() {
        String json = configManager.getRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY);
        if (json == null) {
            return new SaveData();
        }

        try {
            return saveDataUpdater.update(json);
        } catch (JsonSyntaxException e) {
            log.error("Unable to parse save data JSON", e);
        }

        return new SaveData();
    }

	private void importOldPluginSave() {
		Boolean alreadyImported = configManager.getRSProfileConfiguration(
				CollectionLogMasterConfig.CONFIG_GROUP,
				"oldPluginSaveImported",
				Boolean.class
		);

		if (alreadyImported != null && alreadyImported) {
			return;
		}

        log.info("Importing old plugin save for profile {}", configManager.getRSProfileKey());
        String oldSave = configManager.getRSProfileConfiguration("log-master", SAVE_DATA_KEY);
        log.info("Old save: {}", oldSave);

        configManager.setRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, oldSave);
        configManager.setRSProfileConfiguration(CONFIG_GROUP, "oldPluginSaveImported", true);
	}
}

package com.collectionlogmaster;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CollectionLogMasterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CollectionLogMasterPlugin.class);
		RuneLite.main(args);
	}
}
