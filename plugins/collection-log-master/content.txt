package com.collectionlogmaster.input;

import java.awt.event.MouseEvent;

/**
 * Extended {@link net.runelite.client.input.MouseListener} interface to provide a default
 * implementation of all handlers so implementers aren't forced to write boilerplate code for
 * the events it doesn't care about.
 */
public interface MouseListener extends net.runelite.client.input.MouseListener {
	default MouseEvent mouseClicked(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	default MouseEvent mousePressed(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	default MouseEvent mouseReleased(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	default MouseEvent mouseEntered(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	default MouseEvent mouseExited(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	default MouseEvent mouseDragged(MouseEvent mouseEvent) {
		return mouseEvent;
	}

	default MouseEvent mouseMoved(MouseEvent mouseEvent) {
		return mouseEvent;
	}
}

package com.collectionlogmaster.input;

import java.awt.event.InputEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.BiFunction;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.input.MouseWheelListener;

/**
 * We implement our own version of {@link net.runelite.client.input.MouseListener MouseManager}
 * mostly for the three following reasons:
 * <ol>
 * 	<li>It helps us keep track of any lingering listeners registered in our UI classes, allowing
 *   us to more easily identify instances where we forgot to properly unregister. See
 *   {@link #checkMaxListeners} for more details.
 * 	<li>It lets us run listeners in the reverse order they were registered. This is important so
 * 	 that when a new interface is open in front of another, the newest one has priority in its
 * 	 event listeners.
 * 	<li>It makes sure that, in the worst case scenario, listeners are unregistered once the plugin
 * 	 is disabled.
 * 	</li>
 * </ol>
 */
@Slf4j
@Singleton
public class MouseManager implements net.runelite.client.input.MouseListener, MouseWheelListener {
	public static final int MAX_LISTENERS = 3;

	@Inject
	private net.runelite.client.input.MouseManager mouseManager;

	@Inject
	@Named("developerMode")
	private boolean isDeveloperMode;

	private final CopyOnWriteArrayList<MouseListener> mouseListeners = new CopyOnWriteArrayList<>();
	private final CopyOnWriteArrayList<MouseWheelListener> mouseWheelListeners = new CopyOnWriteArrayList<>();

	public void startUp() {
		mouseManager.registerMouseListener(this);
		mouseManager.registerMouseWheelListener(this);
	}

	public void shutDown() {
		mouseManager.unregisterMouseListener(this);
		mouseManager.unregisterMouseWheelListener(this);
	}

	/**
	 * Checks whether the maximum amount of listeners the plugin should register was exceeded. This
	 * amount is defined by the UI hierarchy. When more listeners are registered, it logs a warning.
	 * If in developer mode, it also throws an exception and refuses to register the listener.
	 */
	private void checkMaxListeners(List<?> listeners) {
		if (listeners.size() == MAX_LISTENERS) {
			RuntimeException ex = new RuntimeException("Attempting to register more listeners than expected.");
			if (isDeveloperMode) {
				throw ex;
			}

			log.warn("", ex);
		}
	}

	private <Listener, Event extends InputEvent> Event forwardToListeners(
		List<Listener> listeners,
		Event event,
		BiFunction<Listener, Event, Event> eventMethod
	) {
		// we loop in reverse order so handlers added later take precedence
		var iterator = listeners.listIterator(listeners.size());
		while (iterator.hasPrevious()) {
			Listener listener = iterator.previous();
			event = eventMethod.apply(listener, event);
			if (event.isConsumed()) {
				break;
			}
		}

		return event;
	}

	public void registerMouseListener(MouseListener mouseListener) {
		checkMaxListeners(mouseListeners);
		mouseListeners.addIfAbsent(mouseListener);
	}

	public void unregisterMouseListener(MouseListener mouseListener) {
		mouseListeners.remove(mouseListener);
	}

	public void registerMouseWheelListener(MouseWheelListener mouseWheelListener) {
		checkMaxListeners(mouseWheelListeners);
		mouseWheelListeners.addIfAbsent(mouseWheelListener);
	}

	public void unregisterMouseWheelListener(MouseWheelListener mouseWheelListener) {
		mouseWheelListeners.remove(mouseWheelListener);
	}

	public MouseEvent mousePressed(MouseEvent mouseEvent) {
		return forwardToListeners(mouseListeners, mouseEvent, MouseListener::mousePressed);
	}

	public MouseEvent mouseReleased(MouseEvent mouseEvent) {
		return forwardToListeners(mouseListeners, mouseEvent, MouseListener::mouseReleased);
	}

	public MouseEvent mouseClicked(MouseEvent mouseEvent) {
		return forwardToListeners(mouseListeners, mouseEvent, MouseListener::mouseClicked);
	}

	public MouseEvent mouseEntered(MouseEvent mouseEvent) {
		return forwardToListeners(mouseListeners, mouseEvent, MouseListener::mouseEntered);
	}

	public MouseEvent mouseExited(MouseEvent mouseEvent) {
		return forwardToListeners(mouseListeners, mouseEvent, MouseListener::mouseExited);
	}

	public MouseEvent mouseDragged(MouseEvent mouseEvent) {
		return forwardToListeners(mouseListeners, mouseEvent, MouseListener::mouseDragged);
	}

	public MouseEvent mouseMoved(MouseEvent mouseEvent) {
		return forwardToListeners(mouseListeners, mouseEvent, MouseListener::mouseMoved);
	}

	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent mouseWheelEvent) {
		return forwardToListeners(mouseWheelListeners, mouseWheelEvent, MouseWheelListener::mouseWheelMoved);
	}
}

package com.collectionlogmaster.util;

import lombok.NonNull;

public class StringUtils {
	public static @NonNull String toggleString(@NonNull String curValue, @NonNull String onValue, @NonNull String offValue) {
		return curValue.equals(onValue) ? offValue : onValue;
	}

	public static @NonNull String kebabCase(@NonNull String snakeCase) {
		return snakeCase.toLowerCase().replace('_', '-');
	}
}

package com.collectionlogmaster.util;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class EnumUtils {
    public static <T extends Enum<T>> T fromString(@NonNull Class<T> enumClass, String name) {
        for (T e : enumClass.getEnumConstants()) {
            if (EnumUtils.toString(e).equals(name)) {
                return e;
            }
        }

        log.warn("No enum const {} for name '{}'", enumClass.getName(), name);
        return null;
    }

    public static <T extends Enum<T>> @NonNull String toString(T enumValue) {
        return StringUtils.kebabCase(enumValue.name());
    }
}

package com.collectionlogmaster.util;

import javax.inject.Inject;
import net.runelite.client.eventbus.EventBus;

public abstract class EventBusSubscriber {
	@Inject
	protected EventBus eventBus = null;

	public void startUp() {
		eventBus.register(this);
	};

	public void shutDown() {
		eventBus.unregister(this);
	}
}

package com.collectionlogmaster.util;

import static com.collectionlogmaster.util.GsonOverride.GSON;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;

public class FileUtils {
	public static <T> T loadResource(String resourcePath, Type clazz) {
		try (InputStream is = CollectionLogMasterPlugin.class.getResourceAsStream(resourcePath)) {
			assert is != null;
			return GSON.fromJson(new InputStreamReader(is), clazz);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
}

package com.collectionlogmaster.util;

import com.google.inject.Inject;

import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class SimpleDebouncer {
    public interface Callback {
        void call();
    }

    Future<?> future;

    @Inject
    private ScheduledExecutorService executorService;

    private final static int MS_DELAY = 500;

    public synchronized void debounce(Callback cb) {
        if (future != null) {
            future.cancel(false);
            future = null;
        }

        future = executorService.schedule(cb::call, MS_DELAY, TimeUnit.MILLISECONDS);
    }
}

package com.collectionlogmaster.util;

import com.collectionlogmaster.PluginUpdateNotifier;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLiteProperties;
import okhttp3.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import java.io.IOException;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

import static com.collectionlogmaster.util.GsonOverride.GSON;

@Slf4j
public class HttpClient {
    private static final MediaType JSON_MEDIA_TYPE = Objects.requireNonNull(MediaType.parse("application/json; charset=utf-8"));

    @Inject
    private OkHttpClient okHttpClient;

    private final String userAgent;

    @Inject
    public HttpClient() {
        String runeliteVersion = RuneLiteProperties.getVersion();
        String pluginVersion = PluginUpdateNotifier.getPluginVersion();
        userAgent = "RuneLite:" + runeliteVersion + "," + "CLogMaster:" + pluginVersion;
    }

    private Request.Builder buildRequest(String url, Consumer<Request.Builder> methodSetter) {
        Request.Builder builder = new Request.Builder()
                .url(url)
                .header("Content-Type", "application/json")
                .header("User-Agent", userAgent);
        methodSetter.accept(builder);
        return builder;
    }

    private CompletableFuture<Response> executeHttpRequestAsync(Request request) {
        log.debug("Sending {} request to {}; data = {}", request.method(), request.url(), request.body());

        CompletableFuture<Response> future = new CompletableFuture<>();
        okHttpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NonNull Call call, @NonNull IOException e) {
                log.warn("Async request failed.", e);
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NonNull Call call, @NonNull Response response) {
                future.complete(response);
            }
        });
        return future;
    }

    public <T> CompletableFuture<T> postHttpRequestAsync(String url, String data, @Nullable Class<T> clazz) {
        RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, data);
        Request request = buildRequest(url, builder -> builder.post(body)).build();
        return executeHttpRequestAsync(request)
                .thenApply((response) -> handleResponse(response, clazz));
    }

    public <T> CompletableFuture<T> putHttpRequestAsync(String url, String data, @Nullable Class<T> clazz) {
        RequestBody body = RequestBody.create(JSON_MEDIA_TYPE, data);
        Request request = buildRequest(url, builder -> builder.put(body)).build();
        return executeHttpRequestAsync(request)
                .thenApply((response) -> handleResponse(response, clazz));
    }

    public <T> CompletableFuture<T> getHttpRequestAsync(String url, @Nullable Class<T> clazz) {
        Request request = buildRequest(url, Request.Builder::get)
                .build();
        return executeHttpRequestAsync(request)
                .thenApply((response) -> handleResponse(response, clazz));
    }

    private <T> T handleResponse(Response response, @Nullable Class<T> clazz) {
        try (Response res = response) {
            ResponseBody body = res.body();

            if (body == null) {
                throw new RuntimeException("Response body is null");
            }

            String bodyString = body.string();
            if (!response.isSuccessful()) {
                throw new RuntimeException("Response unsuccessful: " + bodyString);
            }

            if (clazz == null) {
                return null;
            }

            return GSON.fromJson(bodyString, clazz);
        } catch (IOException e) {
            throw new RuntimeException("Error reading response body");
        }
    }
}

package com.collectionlogmaster.util;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.collectionlogmaster.domain.Tag;
import com.collectionlogmaster.domain.adapters.EnumAdapter;
import com.collectionlogmaster.domain.adapters.VerificationAdapter;
import com.collectionlogmaster.domain.verification.Verification;
import com.collectionlogmaster.domain.verification.VerificationMethod;
import com.collectionlogmaster.domain.verification.diary.DiaryDifficulty;
import com.collectionlogmaster.domain.verification.diary.DiaryRegion;
import net.runelite.api.Skill;

import javax.inject.Inject;

public class GsonOverride {
    /**
     * Custom Gson instance capable of parsing additional types.
     */
    public static Gson GSON;

    @Inject
    public GsonOverride(Gson originalGson) {
        GsonBuilder gsonBuilder = originalGson.newBuilder()
                .registerTypeAdapter(Verification.class, new VerificationAdapter())
                .registerTypeAdapter(VerificationMethod.class, new EnumAdapter<>(VerificationMethod.class))
                .registerTypeAdapter(DiaryRegion.class, new EnumAdapter<>(DiaryRegion.class))
                .registerTypeAdapter(DiaryDifficulty.class, new EnumAdapter<>(DiaryDifficulty.class))
                .registerTypeAdapter(Skill.class, new EnumAdapter<>(Skill.class))
                .registerTypeAdapter(Tag.class, new EnumAdapter<>(Tag.class));

        GSON = gsonBuilder.create();
    }
}

package com.collectionlogmaster;

import com.collectionlogmaster.domain.DynamicTaskImages;
import com.collectionlogmaster.domain.TaskTier;
import net.runelite.client.config.*;

import static com.collectionlogmaster.CollectionLogMasterConfig.CONFIG_GROUP;

@ConfigGroup(CONFIG_GROUP)
public interface CollectionLogMasterConfig extends Config
{
    String CONFIG_GROUP = "collection-log-master";

    String PLUGIN_VERSION_KEY = "plugin-version";
    String IS_COMMAND_ENABLED_KEY = "isCommandEnabled";

    @Range(
            min = 1000,
            max = 10000
    )
    @Units(Units.MILLISECONDS)
    @ConfigItem(
            keyName = "rollTime",
            name = "Roll Time",
            description = "How long new tasks will take to roll",
            position = 1
    )
    default int rollTime()
    {
        return 5000;
    }

    @ConfigItem(
            keyName = "rollPastCompleted",
            name = "Roll past completed",
            description = "When rolling tasks, include those you've already completed in the roll animation. Helpful when you're getting to the end of a tier!",
            position = 2
    )
    default boolean rollPastCompleted()
    {
        return false;
    }

    @ConfigItem(
            keyName = "hideBelow",
            name = "Hide Tasks Below",
            description = "Disabled the showing up/assigning of tasks at or below the specified tier",
            position = 3
    )
    default TaskTier hideBelow()
    {
        return TaskTier.EASY;
    }

    @ConfigItem(
            keyName = "displayCurrentTaskOverlay",
            name = "Display current task overlay",
            description = "Enable an overlay showing the currently assigned task (when one exists)",
            position = 5
    )
    default boolean displayCurrentTaskOverlay()
    {
        return true;
    }

    @ConfigItem(
            keyName = "dynamicTaskImages",
            name = "Dynamic task images",
            description = "Display dynamic task images based on required/acquired items",
            position = 6
    )
    default DynamicTaskImages dynamicTaskImages()
    {
        return DynamicTaskImages.COMPLETE;
    }

    @ConfigItem(
            keyName = "isLMSEnabled",
            name = "Enable LMS tasks",
            description = "Whether to include LMS tasks in the list.",
            position = 7
    )
    default boolean isLMSEnabled()
    {
        return true;
    }

    @ConfigSection(
            name = "!taskman Command",
            description = "Configuration options for the !taskman command",
            position = 8
    )
    String command = "command";

    @ConfigItem(
            keyName = IS_COMMAND_ENABLED_KEY,
            name = "Enable command",
            description = "When you or others type !taskman in the chat, it will be replaced by your current task status",
            section = command,
            position = 0
    )
    default boolean isCommandEnabled()
    {
        return true;
    }
}

package com.collectionlogmaster.command;


import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.task.SaveDataStorage;
import com.collectionlogmaster.task.TaskListStorage;
import com.collectionlogmaster.util.EventBusSubscriber;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class DevCommandsManager extends EventBusSubscriber {
	private final String SET_ACTIVE_TASK_COMMAND = "set-active-task";

	@Inject
	private SaveDataStorage saveDataStorage;

	@Inject
	private TaskListStorage taskListStorage;

	@Inject
	@Named("developerMode")
	private boolean isDeveloperMode;

	@Subscribe
	public void onCommandExecuted(CommandExecuted e) {
		if (!isDeveloperMode) return;

		String command = e.getCommand();
		String[] args = e.getArguments();

		log.debug("Command executed: ::{} {}", command, args);
		if (command.equals(SET_ACTIVE_TASK_COMMAND)) {
			executeSecActiveTaskCommand(args);
		}
	}

	private void executeSecActiveTaskCommand(String[] args) {
		if (args.length != 1) return;
		String taskPrefix = args[0];

		for (Task task : taskListStorage.get().all()) {
			String taskId = task.getId();
			if (taskId.startsWith(taskPrefix)) {
				log.debug("Setting active task to {}", taskId);
				saveDataStorage.get().setActiveTaskId(taskId);
				return;
			}
		}

		log.debug("Unable to find task with prefix {}", taskPrefix);
	}
}

package com.collectionlogmaster.command;

import static com.collectionlogmaster.util.GsonOverride.GSON;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.command.CommandRequest;
import com.collectionlogmaster.domain.command.CommandResponse;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.util.EventBusSubscriber;
import com.collectionlogmaster.util.HttpClient;
import com.collectionlogmaster.util.SimpleDebouncer;
import java.time.Instant;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;

@Slf4j
@Singleton
public class TaskmanCommandManager extends EventBusSubscriber {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatCommandManager chatCommandManager;

	@Inject
	private CollectionLogMasterConfig config;

	@Inject
	private HttpClient httpClient;

	@Inject
	private TaskService taskService;

	@Inject
	private SimpleDebouncer updateDebouncer;

	private final HttpUrl baseApiUrl = new HttpUrl.Builder()
			.scheme("https")
			.host("taskman.up.railway.app")
			.addPathSegment("task")
			.addPathSegment("command")
			.build();

	private final String COLLECTION_LOG_COMMAND = "!taskman";

	public void startUp() {
		super.startUp();

		if (config.isCommandEnabled()) {
			chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeCommand);
		}
	}

	public void shutDown() {
		super.shutDown();

		if (config.isCommandEnabled()) {
			chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(CollectionLogMasterConfig.CONFIG_GROUP)) return;
		if (!event.getKey().equals(CollectionLogMasterConfig.IS_COMMAND_ENABLED_KEY)) return;

		if (config.isCommandEnabled()) {
			chatCommandManager.registerCommand(COLLECTION_LOG_COMMAND, this::executeCommand);
			updateServerImmediately();
		} else {
			chatCommandManager.unregisterCommand(COLLECTION_LOG_COMMAND);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e) {
		if (e.getGameState() != GameState.LOGGED_IN) return;

		clientThread.invokeAtTickEnd(this::updateServer);
	}

	private void executeCommand(ChatMessage chatMessage, String message) {
		log.debug("Executing taskman command: {}", message);

		String senderName = chatMessage.getType().equals(ChatMessageType.PRIVATECHATOUT)
				? client.getLocalPlayer().getName()
				: Text.sanitize(chatMessage.getName());

		if (senderName == null) {
			log.debug("Couldn't identify message sender");
			return;
		}

		HttpUrl url = baseApiUrl.newBuilder().addPathSegment(senderName).build();
		httpClient.getHttpRequestAsync(url.toString(), CommandResponse.class)
				.thenAccept(res ->
						clientThread.invokeLater(() -> replaceChatMessage(chatMessage, res))
				);
	}

	public void updateServer() {
		log.debug("Scheduling command update; {}", Instant.now());
		updateDebouncer.debounce(this::updateServerImmediately);
	}

	public void updateServerImmediately() {
		if (!config.isCommandEnabled()) {
			return;
		}

		log.debug("Executing command update; {}", Instant.now());

		String rsn = client.getLocalPlayer().getName();
		if (rsn == null) return;

		HttpUrl url = baseApiUrl.newBuilder().addPathSegment(rsn).build();

		String taskId = "complete";
		Task currentTask = taskService.getActiveTask();
		if (currentTask != null) {
			taskId = currentTask.getId();
		}

		TaskTier currentTier = taskService.getCurrentTier();
		float currentProgress = taskService.getProgress().get(currentTier) * 100;

		CommandRequest data = new CommandRequest(taskId, taskService.getCurrentTier().displayName, (int) currentProgress);
		httpClient.putHttpRequestAsync(url.toString(), GSON.toJson(data), null);
	}

	private void replaceChatMessage(ChatMessage chatMessage, CommandResponse res) {
		if (res == null) return;

		final String msg = new ChatMessageBuilder()
				.append(ChatColorType.NORMAL)
				.append("Progress: ")
				.append(ChatColorType.HIGHLIGHT)
				.append(res.getProgressPercentage() + "% " + res.getTier())
				.append(ChatColorType.NORMAL)
				.append(" Current task: ")
				.append(ChatColorType.HIGHLIGHT)
				.append(res.getTask().getName())
				.build();

		final MessageNode messageNode = chatMessage.getMessageNode();
		messageNode.setRuneLiteFormatMessage(msg);
		client.refreshChat();
	}
}

package com.collectionlogmaster.synchronization.diary;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.diary.AchievementDiaryVerification;
import com.collectionlogmaster.domain.verification.diary.DiaryDifficulty;
import com.collectionlogmaster.domain.verification.diary.DiaryRegion;
import com.collectionlogmaster.synchronization.Verifier;
import lombok.NonNull;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class AchievementDiaryVerifier implements Verifier {
    @Inject
    private AchievementDiaryService achievementDiaryService;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof AchievementDiaryVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof AchievementDiaryVerification;
        AchievementDiaryVerification verif = (AchievementDiaryVerification) task.getVerification();

        DiaryRegion diary = verif.getRegion();
        DiaryDifficulty difficulty = verif.getDifficulty();

        return achievementDiaryService.isComplete(diary, difficulty);
    }
}

package com.collectionlogmaster.synchronization.diary;

import com.collectionlogmaster.domain.verification.diary.DiaryDifficulty;
import com.collectionlogmaster.domain.verification.diary.DiaryRegion;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import org.jetbrains.annotations.NotNull;

@Slf4j
@Singleton
public class AchievementDiaryService {
	private static final int DIARY_COMPLETION_INFO_SCRIPT_ID = 2200;

	private static final int COMPLETE_TASK_COUNT_OFFSET = 0;
	private static final int TOTAL_TASK_COUNT_OFFSET = 1;
	private static final int REWARD_COLLECTED_OFFSET = 2;

	@Inject
	private Client client;

	public boolean isComplete(@NonNull DiaryRegion diary, @NonNull DiaryDifficulty difficulty) {
		int[] stack = runScript(diary);

		return stack[difficulty.getStackOffset() + REWARD_COLLECTED_OFFSET] == 1;
	}

	public int getTotalTaskCount(@NonNull DiaryRegion diary, @NonNull DiaryDifficulty difficulty) {
		int[] stack = runScript(diary);

		return stack[difficulty.getStackOffset() + TOTAL_TASK_COUNT_OFFSET];
	}

	public int getCompleteTaskCount(@NonNull DiaryRegion diary, @NonNull DiaryDifficulty difficulty) {
		int[] stack = runScript(diary);

		return stack[difficulty.getStackOffset() + COMPLETE_TASK_COUNT_OFFSET];
	}

	private int[] runScript(@NotNull DiaryRegion diary) {
		// https://github.com/RuneStar/cs2-scripts/blob/master/scripts/%5Bproc%2Cdiary_completion_info%5D.cs2
		client.runScript(DIARY_COMPLETION_INFO_SCRIPT_ID, diary.getId());
		return client.getIntStack();
	}
}

package com.collectionlogmaster.synchronization.clog;

import com.collectionlogmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;

@Slf4j
@Singleton

// Code from: RuneProfile
// Repository: https://github.com/ReinhardtR/runeprofile-plugin
// License: BSD 2-Clause License
public class CollectionLogWidgetSubscriber extends EventBusSubscriber {
    @Inject
    private Client client;

    @Inject
    private CollectionLogService collectionLogService;

    private int tickCollectionLogScriptFired = -1;

    private boolean isAutoClogRetrieval = false;

    public void reset() {
        isAutoClogRetrieval = false;
        tickCollectionLogScriptFired = -1;
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.HOPPING && gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onGameTick(GameTick gameTick) {
        int tick = client.getTickCount();
        boolean hasClogScriptFired = tickCollectionLogScriptFired != -1;
        boolean hasBufferPassed = tickCollectionLogScriptFired + 2 < tick;
        if (hasClogScriptFired && hasBufferPassed) {
            tickCollectionLogScriptFired = -1;
            log.debug("Clog items script has fired");
            isAutoClogRetrieval = false;
        }
    }

    // Code from: WikiSync
    // Repository: https://github.com/weirdgloop/WikiSync
    // License: BSD 2-Clause License
    @Subscribe
    public void onScriptPreFired(ScriptPreFired preFired) {
        if (preFired.getScriptId() == 4100) {
            tickCollectionLogScriptFired = client.getTickCount();

            Object[] args = preFired.getScriptEvent().getArguments();
            int itemId = (int) args[1];
            int quantity = (int) args[2];

            if (quantity > 0) {
                collectionLogService.storeItem(itemId);
            }
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired scriptPostFired) {
        final int COLLECTION_LOG_SETUP = 7797;
        if (scriptPostFired.getScriptId() == COLLECTION_LOG_SETUP) {
            if (isAutoClogRetrieval) {
                return;
            }

            // disallow updating from the adventure log, to avoid players updating their profile
            // while viewing other players collection logs using the POH adventure log.
            if (isOpenedFromAdventureLog()) return;

            isAutoClogRetrieval = true;
            client.menuAction(-1, 40697932, MenuAction.CC_OP, 1, -1, "Search", null);
            client.runScript(2240);
        }
    }

    private boolean isOpenedFromAdventureLog() {
        return client.getVarbitValue(VarbitID.COLLECTION_POH_HOST_BOOK_OPEN) == 1;
    }
}

package com.collectionlogmaster.synchronization.clog;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.synchronization.Verifier;
import lombok.NonNull;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;

@Singleton
public class CollectionLogVerifier implements Verifier {
    @Inject
    private CollectionLogService collectionLogService;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof CollectionLogVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof CollectionLogVerification;
        CollectionLogVerification verif = (CollectionLogVerification) task.getVerification();

        long totalObtained = Arrays.stream(verif.getItemIds())
                .filter(itemId -> this.collectionLogService.isItemObtained(itemId))
                .count();

        return totalObtained >= verif.getCount();
    }
}

package com.collectionlogmaster.synchronization.clog;

import com.collectionlogmaster.util.EventBusSubscriber;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@Singleton
public class CollectionLogService extends EventBusSubscriber {
	@Inject
	public CollectionLogWidgetSubscriber collectionLogWidgetSubscriber;

    private final Set<Integer> obtainedItems = new HashSet<>();

    public void startUp() {
        super.startUp();
        collectionLogWidgetSubscriber.startUp();

        reset();
    }

    public void shutDown() {
        super.startUp();
        collectionLogWidgetSubscriber.shutDown();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState gameState = gameStateChanged.getGameState();
        if (gameState != GameState.LOGGED_IN) {
            reset();
        }
    }

    public boolean isItemObtained(int itemId) {
        return obtainedItems.contains(itemId);
    }

    public void storeItem(int itemId) {
        obtainedItems.add(itemId);
    }

    public void reset() {
        obtainedItems.clear();
    }
}

package com.collectionlogmaster.synchronization;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.synchronization.clog.CollectionLogVerifier;
import com.collectionlogmaster.synchronization.diary.AchievementDiaryVerifier;
import com.collectionlogmaster.synchronization.skill.SkillVerifier;
import com.collectionlogmaster.task.TaskService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;

@Slf4j
@Singleton
public class SyncService {
	@Inject
	private Client client;

	@Inject
	private CollectionLogMasterPlugin plugin;

	@Inject
	private TaskService taskService;

	@Inject
	private SyncService syncService;

	@Inject
	private CollectionLogVerifier collectionLogVerifier;

	@Inject
	private AchievementDiaryVerifier achievementDiaryVerifier;

	@Inject
	private SkillVerifier skillVerifier;

	private @NonNull Verifier[] getVerifiers() {
		return new Verifier[] {
				this.collectionLogVerifier,
				this.achievementDiaryVerifier,
				this.skillVerifier
		};
	}

	private Boolean verify(Task task) {
		for (Verifier verif : this.getVerifiers()) {
			if (verif.supports(task)) {
				return verif.verify(task);
			}
		}

		return null;
	}

	public void sync() {
		int updatedCount = 0;
		for (TaskTier tier : TaskTier.values()) {
			for (Task task : taskService.getTierTasks(tier)) {
				Boolean isVerified = syncService.verify(task);
				if (isVerified == null) {
					continue;
				}

				boolean taskChanged = isVerified != taskService.isComplete(task.getId());
				if (!taskChanged) {
					continue;
				}

				taskService.toggleComplete(task.getId());

				String newStatus = isVerified ? "<col=27ae60>complete</col>" : "<col=c0392b>incomplete</col>";
				String msg = String.format("%s tier task '%s' marked as %s", tier.displayName, task.getName(), newStatus);
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, "");

				updatedCount++;
			}
		}

		String msg = String.format("Task synchronization finalized; %d tasks updated", updatedCount);
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null);
	}
}

package com.collectionlogmaster.synchronization;

import com.collectionlogmaster.domain.Task;
import lombok.NonNull;

public interface Verifier {
    boolean supports(@NonNull Task task);
    boolean verify(@NonNull Task task);
}

package com.collectionlogmaster.synchronization.skill;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.skill.SkillVerification;
import com.collectionlogmaster.synchronization.Verifier;
import lombok.NonNull;
import net.runelite.api.Client;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class SkillVerifier implements Verifier {
    @Inject
    private Client client;

    public boolean supports(@NonNull Task task) {
        return task.getVerification() instanceof SkillVerification;
    }

    public boolean verify(@NonNull Task task) {
        assert task.getVerification() instanceof SkillVerification;
        SkillVerification verif = (SkillVerification) task.getVerification();

        long totalAchieved = verif.getExperience().entrySet().stream()
                .filter(entry -> entry.getKey() != null)
                .filter(entry -> client.getSkillExperience(entry.getKey()) > entry.getValue())
                .count();

        return totalAchieved >= verif.getCount();
    }
}

package com.collectionlogmaster;

import static com.collectionlogmaster.CollectionLogMasterConfig.CONFIG_GROUP;
import static com.collectionlogmaster.CollectionLogMasterConfig.PLUGIN_VERSION_KEY;

import com.collectionlogmaster.util.EventBusSubscriber;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
@Singleton
public class PluginUpdateNotifier extends EventBusSubscriber {
	private static final String[] UPDATE_MESSAGES = {
			"<colHIGHLIGHT>Collection Log Master updated to v" + getPluginVersion(),
			"<colHIGHLIGHT>- Rewritten entire interface code; now supports resource packs",
	};

	@Inject
	ConfigManager configManager;

	@Inject
	ChatMessageManager chatMessageManager;

	public static String getPluginVersion() {
		try (InputStream is = CollectionLogMasterPlugin.class.getResourceAsStream("version")) {
			assert is != null;
			return new String(is.readAllBytes(), StandardCharsets.UTF_8)
					.replace("-SNAPSHOT", "");
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		GameState gameState = gameStateChanged.getGameState();
		if (gameState == GameState.LOGGED_IN) {
			checkUpdate();
		}
	}

	private void checkUpdate() {
		boolean isDebug = false;
		String curVersion = getPluginVersion();
		String lastVersion = configManager.getRSProfileConfiguration(CONFIG_GROUP, PLUGIN_VERSION_KEY);

		//noinspection ConstantValue
		if (isDebug || !curVersion.equals(lastVersion)) {
			configManager.setRSProfileConfiguration(CONFIG_GROUP, PLUGIN_VERSION_KEY, curVersion);
			notifyUpdate();
		}
	}

	private void notifyUpdate() {
		//noinspection ConstantConditions
		if (UPDATE_MESSAGES == null) return;

		String replacedMessage = String.join("<br>", UPDATE_MESSAGES);
		chatMessageManager.queue(
				QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(replacedMessage)
						.build()
		);
	}
}

package com.collectionlogmaster.ui.generic;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.input.MouseManager;
import com.google.inject.Inject;
import java.awt.event.MouseWheelEvent;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.MouseWheelListener;

@Accessors(chain = true)
public class UIScrollableContainer extends UIComponent<UIScrollableContainer> implements MouseWheelListener {
	private static final int SCROLLBAR_SENSITIVITY_MULTIPLIER = 4;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MouseManager mouseManager;

	@Getter
	private final Widget content;
	private final UIScrollBar scrollBar;

	@Setter
	private int scrollSensitivity = 4;

	/**
	 * Only supported when scrollAxis is VERTICAL
	 */
	@Setter
	private boolean drawScrollbar = false;

	public static UIScrollableContainer createInside(Widget window) {
		return new UIScrollableContainer(window.createChild(WidgetType.LAYER));
	}

	public UIScrollableContainer(Widget widget) {
		super(widget);
		CollectionLogMasterPlugin.getStaticInjector().injectMembers(this);

		mouseManager.registerMouseWheelListener(this);

		content = widget.createChild(WidgetType.LAYER);
		scrollBar = UIScrollBar.createInside(widget, widget, content);

		initializeWidgets();
	}

	public UIScrollableContainer setScrollBuffer(int scrollBuffer) {
		scrollBar.setScrollBuffer(scrollBuffer);
		return this;
	}

	public UIScrollableContainer setScrollAxis(ScrollAxis scrollAxis) {
		scrollBar.setScrollAxis(scrollAxis);
		return this;
	}

	@Override
	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent e) {
		if (e.getScrollType() != MouseWheelEvent.WHEEL_UNIT_SCROLL) {
			return e;
		}
		if (!widget.getBounds().contains(e.getPoint())) {
			return e;
		}

		e.consume();

		// scroll faster when scrolling on top of scrollbar
		int multiplier = scrollBar.getBounds().contains(e.getPoint()) ? SCROLLBAR_SENSITIVITY_MULTIPLIER : 1;
		int scrollDistance = e.getUnitsToScroll() * scrollSensitivity * multiplier;

		clientThread.invoke(() -> {
			scrollBar.scroll(scrollDistance)
				.revalidate();
		});

		return e;
	}

	private void initializeWidgets() {
		widget.revalidate();

		scrollBar.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(UIScrollBar.ARROW_SIZE, 0)
			.revalidate();

		content.setPos(0, 0)
			.revalidate();
	}

	@Override
	public void revalidate() {
		widget.revalidate();

		if (scrollBar.getScrollAxis() == ScrollAxis.VERTICAL) {
			int minusWidth = 0;
			if (drawScrollbar) {
				minusWidth = UIScrollBar.ARROW_SIZE;
			}

			content.setWidthMode(WidgetSizeMode.MINUS)
				.setOriginalWidth(minusWidth)
				.revalidate();

			scrollBar.setHidden(!drawScrollbar)
				.revalidate();
		} else if (scrollBar.getScrollAxis() == ScrollAxis.HORIZONTAL) {
			content.setHeightMode(WidgetSizeMode.MINUS)
				.setOriginalHeight(0)
				.revalidate();

			scrollBar.setHidden(true)
				.revalidate();
		}
	}

	@Override
	public void unregister() {
		mouseManager.unregisterMouseWheelListener(this);
		scrollBar.unregister();
	}
}
package com.collectionlogmaster.ui.generic;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.input.MouseListener;
import com.collectionlogmaster.input.MouseManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import javax.inject.Inject;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import org.jetbrains.annotations.Range;

@Accessors(chain = true)
public class UIScrollBar extends UIComponent<UIScrollBar> implements MouseListener {
	public static final int ARROW_SIZE = 16;
	private static final int THUMB_EDGE_HEIGHT = 5;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MouseManager mouseManager;

	private final Widget tracker;
	private final Widget thumbContainer;
	private final Widget thumbMiddle;
	private final Widget thumbTop;
	private final Widget thumbBottom;
	private final Widget upArrow;
	private final Widget downArrow;

	private final Widget content;
	private final Widget container;

	@Getter
	@Setter
	private ScrollAxis scrollAxis = ScrollAxis.VERTICAL;

	@Setter
	private int scrollBuffer = 0;

	private Point thumbDragLast = null;

	public static UIScrollBar createInside(Widget window, Widget container, Widget content) {
		return new UIScrollBar(window.createChild(WidgetType.LAYER), container, content);
	}

	public UIScrollBar(Widget widget, Widget container, Widget content) {
		super(widget);
		CollectionLogMasterPlugin.getStaticInjector().injectMembers(this);

		mouseManager.registerMouseListener(this);

		tracker = widget.createChild(WidgetType.GRAPHIC);
		thumbContainer = widget.createChild(WidgetType.LAYER);
		thumbMiddle = thumbContainer.createChild(WidgetType.GRAPHIC);
		thumbTop = thumbContainer.createChild(WidgetType.GRAPHIC);
		thumbBottom = thumbContainer.createChild(WidgetType.GRAPHIC);
		upArrow = widget.createChild(WidgetType.GRAPHIC);
		downArrow = widget.createChild(WidgetType.GRAPHIC);
		this.container = container;
		this.content = content;

		initializeWidgets();
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		Point point = e.getPoint();
		if (thumbContainer.getBounds().contains(point)) {
			return e;
		}

		Rectangle trackerBounds = tracker.getBounds();
		if (!trackerBounds.contains(point)) {
			return e;
		}

		e.consume();

		Point boundedPoint = new Point(point.x, point.y);
		boundedPoint.translate(-trackerBounds.x, -trackerBounds.y);

		int thumbPosition = boundedPoint.y - (thumbContainer.getHeight() / 2);
		float scrollPercent = (float) thumbPosition / (tracker.getHeight() - thumbContainer.getHeight());

		clientThread.invoke(() -> {
			scrollToPercent(scrollPercent)
				.revalidate();
		});

		return e;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e) {
		Point point = e.getPoint();
		if (!thumbContainer.getBounds().contains(point)) {
			return e;
		}

		e.consume();
		thumbDragLast = point;

		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e) {
		if (!thumbContainer.getBounds().contains(e.getPoint())) {
			return e;
		}
		if (thumbDragLast == null) {
			return e;
		}

		e.consume();
		thumbDragLast = null;

		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e) {
		Point point = e.getPoint();
		if (thumbDragLast == null) {
			return e;
		}

		e.consume();

		int dragPixels = point.y - thumbDragLast.y;
		if (dragPixels == 0) {
			return e;
		}

		int maxScroll = content.getOriginalHeight() - container.getHeight() + scrollBuffer;
		int maxThumbPosition = tracker.getHeight() - thumbContainer.getHeight();
		int dragOffset = dragPixels * maxScroll / maxThumbPosition;

		clientThread.invoke(() -> {
			scroll(dragOffset)
				.revalidate();
		});

		thumbDragLast = point;

		return e;
	}

	public UIScrollBar scroll(int scrollDistance) {
		if (scrollAxis == ScrollAxis.VERTICAL) {
			int scrollY = content.getScrollY() + scrollDistance;
			scrollTo(scrollY);
		} else if (scrollAxis == ScrollAxis.HORIZONTAL) {
			int scrollX = content.getScrollX() + scrollDistance;
			scrollTo(scrollX);
		}

		return this;
	}

	public UIScrollBar scrollTo(@Range(from = 0, to = Integer.MAX_VALUE) int scrollOffset) {
		if (scrollAxis == ScrollAxis.VERTICAL) {
			int maxScroll = content.getOriginalHeight() - container.getHeight() + scrollBuffer;
			int scrollY = Math.max(0, Math.min(maxScroll, scrollOffset));
			content.setScrollY(scrollY);
		} else if (scrollAxis == ScrollAxis.HORIZONTAL) {
			int maxScroll = content.getOriginalWidth() - container.getWidth() + scrollBuffer;
			int scrollX = Math.max(0, Math.min(maxScroll, scrollOffset));
			content.setScrollX(scrollX);
		}

		return this;
	}

	public UIScrollBar scrollToPercent(@Range(from = 0, to = 1) float scrollPercent) {
		if (scrollAxis == ScrollAxis.VERTICAL) {
			int maxScroll = content.getOriginalHeight() - container.getHeight() + scrollBuffer;
			scrollTo((int) (maxScroll * scrollPercent));
		} else if (scrollAxis == ScrollAxis.HORIZONTAL) {
			int maxScroll = content.getOriginalWidth() - container.getWidth() + scrollBuffer;
			scrollTo((int) (maxScroll * scrollPercent));
		}

		return this;
	}

	private void initializeWidgets() {
		widget.setOriginalWidth(ARROW_SIZE)
			.revalidate();

		tracker.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, ARROW_SIZE)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, ARROW_SIZE * 2)
			.setSpriteTiling(true)
			.setSpriteId(SpriteID.ScrollbarDraggerV2.TRACK)
			.revalidate();

		thumbContainer.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, ARROW_SIZE)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setOriginalWidth(0)
			.revalidate();

		thumbMiddle.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, THUMB_EDGE_HEIGHT * 2)
			.setSpriteTiling(true)
			.setSpriteId(SpriteID.ScrollbarDraggerV2.MIDDLE)
			.revalidate();

		thumbTop.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, THUMB_EDGE_HEIGHT)
			.setSpriteId(SpriteID.ScrollbarDraggerV2.TOP)
			.revalidate();

		thumbBottom.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, THUMB_EDGE_HEIGHT)
			.setSpriteId(SpriteID.ScrollbarDraggerV2.BOTTOM)
			.revalidate();

		upArrow.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, ARROW_SIZE)
			.setSpriteId(SpriteID.ScrollbarV2.ARROW_UP)
			.revalidate();

		downArrow.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, ARROW_SIZE)
			.setSpriteId(SpriteID.ScrollbarV2.ARROW_DOWN)
			.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();

		content.revalidate();
		container.revalidate();
		tracker.revalidate();

		// TODO: handle horizontal scrollbar
		if (scrollAxis == ScrollAxis.VERTICAL) {
			float scrollRatio = Math.max(1, (float) content.getOriginalHeight() / widget.getHeight());
			int thumbHeight = Math.round(Math.max(THUMB_EDGE_HEIGHT * 2, tracker.getHeight() / scrollRatio));
			int maxScroll = content.getOriginalHeight() - container.getHeight() + scrollBuffer;
			float scrollPercent = (float) content.getScrollY() / maxScroll;
			int thumbPosition = Math.round((tracker.getHeight() - thumbHeight) * scrollPercent);
			thumbContainer.setOriginalY(thumbPosition + ARROW_SIZE)
				.setOriginalHeight(thumbHeight)
				.revalidate();
		}

		thumbMiddle.revalidate();
		thumbTop.revalidate();
		thumbBottom.revalidate();
		upArrow.revalidate();
		downArrow.revalidate();
	}

	public void unregister() {
		mouseManager.unregisterMouseListener(this);
	}
}

package com.collectionlogmaster.ui.generic;

import lombok.Getter;

@Getter
public enum ScrollAxis {
	VERTICAL,
	HORIZONTAL;
}

package com.collectionlogmaster.ui.generic;

import java.awt.Color;
import java.util.Arrays;
import lombok.NonNull;
import net.runelite.api.FontTypeFace;
import net.runelite.api.widgets.Widget;
import net.runelite.client.util.LinkBrowser;
import org.jetbrains.annotations.Range;

public class UIUtil {
	private static final String WIDGET_NAME_FORMAT = "<col=ff9040>%s</col>";
	private static final String BASE_OSRS_WIKI_URL = "https://oldschool.runescape.wiki/w/%s";
	public static final String FAQ_URL =
		"https://docs.google.com/document/d/e/2PACX-1vTHfXHzMQFbt_iYAP-O88uRhhz3wigh1KMiiuomU7ftli-rL_c3bRqfGYmUliE1EHcIr3LfMx2UTf2U/pub";

	public static void openWikiLink(String itemName) {
		String wikiUrl = String.format(BASE_OSRS_WIKI_URL, itemName.replace(" ", "_"));
		LinkBrowser.browse(wikiUrl);
	}

	public static void openFAQ() {
		LinkBrowser.browse(FAQ_URL);
	}

	public static String formatName(String name) {
		return String.format(WIDGET_NAME_FORMAT, name);
	}

	public static int getTextHeight(@NonNull String text, @NonNull FontTypeFace font, int lineHeight, int maxWidth) {
		return lineHeight * getTextLineCount(text, font, maxWidth);
	}

	public static int getTextHeight(@NonNull String text, @NonNull FontTypeFace font, int maxWidth) {
		return getTextHeight(text, font, font.getBaseline(), maxWidth);
	}

	public static int getTextHeight(@NonNull String text, @NonNull Widget widget) {
		return getTextHeight(text, widget.getFont(), widget.getWidth());
	}

	public static int getTextLineCount(@NonNull String text, @NonNull FontTypeFace font, int maxWidth) {
		int spaceWidth = font.getTextWidth(" ");
		int[] wordWidths = Arrays.stream(text.split(" "))
			.mapToInt(font::getTextWidth)
			.toArray();

		int lineCount = 1;
		// account for first word not having a space before it
		int lineWidth = -spaceWidth;
		for (int wordWidth : wordWidths) {
			lineWidth += wordWidth + spaceWidth;

			if (lineWidth > maxWidth) {
				lineCount++;
				// include overflow word into next line
				lineWidth = wordWidth;
			}
		}

		return lineCount;
	}

	public static int getCompletionColor(@Range(from = 0, to = 1) float percent) {
		return Color.HSBtoRGB(percent / 3, 1, 1) & 0xFFFFFF;
	}

	public static int roundCompletionPercent(@Range(from = 0, to = 1) float percent) {
		int roundedPercent = (int) (percent * 100);

		// prevent showing 0% unless it's really 0
		if (roundedPercent == 0 && percent > 0) {
			return 1;
		}

		return roundedPercent;
	}
}

package com.collectionlogmaster.ui.generic;

import net.runelite.api.FontID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import org.jetbrains.annotations.Range;

public class UIProgressBar extends UIComponent<UIProgressBar> {
	private final Widget border;
	private final Widget background;
	private final Widget barFill;
	private final Widget textWidget;

	public static UIProgressBar createInside(Widget window) {
		return new UIProgressBar(window.createChild(WidgetType.LAYER));
	}

	public UIProgressBar(Widget widget) {
		super(widget, WidgetType.LAYER);

		border = widget.createChild(WidgetType.RECTANGLE);
		background = widget.createChild(WidgetType.GRAPHIC);
		barFill = widget.createChild(WidgetType.GRAPHIC);
		textWidget = widget.createChild(WidgetType.TEXT);

		initializeWidgets();
	}

	public UIProgressBar setPercent(@Range(from = 0, to = 1) float percent) {
		// we can easily set the width to the given percent by using WidgetSizeMode.ABSOLUTE_16384THS
		barFill.setOriginalWidth(Math.round((1 << 14) * percent))
				.revalidate();

		return this;
	}

	public UIProgressBar setText(String text) {
		textWidget.setText(text);
		return this;
	}

	private void initializeWidgets() {
		widget.revalidate();

		border.setPos(0, 0)
				.setWidthMode(WidgetSizeMode.MINUS)
				.setHeightMode(WidgetSizeMode.MINUS)
				.setSize(0, 0)
				.setTextColor(0x242020)
				.revalidate();

		background.setPos(1, 1)
				.setWidthMode(WidgetSizeMode.MINUS)
				.setHeightMode(WidgetSizeMode.MINUS)
				.setSize(2, 2)
				.setSpriteTiling(true)
				.setSpriteId(SpriteID.CaProgressBar._1)
				.revalidate();

		barFill.setPos(1, 1)
				.setHeightMode(WidgetSizeMode.MINUS)
				.setWidthMode(WidgetSizeMode.ABSOLUTE_16384THS)
				.setOriginalHeight(2)
				.setSpriteTiling(true)
				.setSpriteId(SpriteID.CaProgressBar._0)
				.revalidate();

		// it just looks better if we put 2px lower
		textWidget.setPos(0, 2)
				.setWidthMode(WidgetSizeMode.MINUS)
				.setHeightMode(WidgetSizeMode.MINUS)
				.setSize(0, 2)
				.setXTextAlignment(WidgetTextAlignment.CENTER)
				.setYTextAlignment(WidgetTextAlignment.CENTER)
				.setFontId(FontID.PLAIN_12)
				.setTextColor(0xFFFFFF)
				.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();

		border.revalidate();
		background.revalidate();
		barFill.revalidate();
		textWidget.revalidate();
	}
}

package com.collectionlogmaster.ui.generic;

import com.collectionlogmaster.ui.sprites.SpriteOverride;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.SpriteID;

@Getter
@RequiredArgsConstructor
public enum BorderTheme {
	NULL(0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1),
	ETCHED(
		8,
		4,
		SpriteID.SettingsTabs._16,
		SpriteID.TabsEtchedCorner._0,
		SpriteID.TabsEtchedCorner._1,
		SpriteID.TabsEtchedCorner._2,
		SpriteID.TabsEtchedCorner._3,
		SpriteID.SettingsTabs._14,
		SpriteID.SettingsTabs._12,
		SpriteID.SettingsTabs._15,
		SpriteID.SettingsTabs._13
	),
	ETCHED_GREEN_DYED(
		8,
		4,
		SpriteOverride.SETTINGS_TAB_BACKGROUND_GREEN_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_TOP_LEFT_CORNER_GREEN_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_TOP_RIGHT_CORNER_GREEN_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_BOTTOM_LEFT_CORNER_GREEN_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_BOTTOM_RIGHT_CORNER_GREEN_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_LEFT_EDGE_GREEN_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_TOP_EDGE_GREEN_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_RIGHT_EDGE_GREEN_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_BOTTOM_EDGE_GREEN_DYED.getSpriteId()
	),
	ETCHED_GOLD_DYED(
		8,
		4,
		SpriteOverride.SETTINGS_TAB_BACKGROUND_GOLD_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_TOP_LEFT_CORNER_GOLD_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_TOP_RIGHT_CORNER_GOLD_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_BOTTOM_LEFT_CORNER_GOLD_DYED.getSpriteId(),
		SpriteOverride.TABS_ETCHED_BOTTOM_RIGHT_CORNER_GOLD_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_LEFT_EDGE_GOLD_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_TOP_EDGE_GOLD_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_RIGHT_EDGE_GOLD_DYED.getSpriteId(),
		SpriteOverride.SETTINGS_TAB_BOTTOM_EDGE_GOLD_DYED.getSpriteId()
	);

	private final int cornerSize;
	private final int edgeSize;
	private final int background;
	private final int topLeftCorner;
	private final int topRightCorner;
	private final int bottomLeftCorner;
	private final int bottomRightCorner;
	private final int leftEdge;
	private final int topEdge;
	private final int rightEdge;
	private final int bottomEdge;
}

package com.collectionlogmaster.ui.generic;

import lombok.Getter;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import org.intellij.lang.annotations.MagicConstant;

// TODO: implement UIMultiSpriteButton using UIBorderContainer + UIButton
public class UIBorderedContainer extends UIComponent<UIBorderedContainer> {
	private final Widget background;
	private final Widget topLeftCorner;
	private final Widget topRightCorner;
	private final Widget bottomLeftCorner;
	private final Widget bottomRightCorner;
	private final Widget leftEdge;
	private final Widget topEdge;
	private final Widget rightEdge;
	private final Widget bottomEdge;

	@Getter
	private final Widget content;

	private BorderTheme theme = BorderTheme.NULL;

	public static UIBorderedContainer createInside(Widget window) {
		return new UIBorderedContainer(window.createChild(WidgetType.LAYER), WidgetType.LAYER);
	}

	public static UIBorderedContainer createInside(
		Widget window,
		@MagicConstant(valuesFromClass = WidgetType.class) int contentType
	) {
		return new UIBorderedContainer(window.createChild(WidgetType.LAYER), contentType);
	}

	public UIBorderedContainer(Widget widget, @MagicConstant(valuesFromClass = WidgetType.class) int contentType) {
		super(widget, WidgetType.LAYER);

		background = widget.createChild(WidgetType.GRAPHIC);
		topLeftCorner = widget.createChild(WidgetType.GRAPHIC);
		topRightCorner = widget.createChild(WidgetType.GRAPHIC);
		bottomLeftCorner = widget.createChild(WidgetType.GRAPHIC);
		bottomRightCorner = widget.createChild(WidgetType.GRAPHIC);
		leftEdge = widget.createChild(WidgetType.GRAPHIC);
		topEdge = widget.createChild(WidgetType.GRAPHIC);
		rightEdge = widget.createChild(WidgetType.GRAPHIC);
		bottomEdge = widget.createChild(WidgetType.GRAPHIC);
		content = widget.createChild(contentType);

		initializeWidgets();
	}

	public UIBorderedContainer setTheme(BorderTheme theme) {
		this.theme = theme;
		return this;
	}

	private void initializeWidgets() {
		background.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSpriteTiling(true)
			.revalidate();

		topLeftCorner.setPos(0, 0)
			.revalidate();

		topRightCorner.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.revalidate();

		bottomLeftCorner.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.revalidate();

		bottomRightCorner.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.revalidate();

		leftEdge.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSpriteTiling(true)
			.revalidate();

		topEdge.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSpriteTiling(true)
			.revalidate();

		rightEdge.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSpriteTiling(true)
			.revalidate();

		bottomEdge.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSpriteTiling(true)
			.revalidate();
	}

	@Override
	public void revalidate() {
		int cornerSize = theme.getCornerSize();
		int edgeSize = theme.getEdgeSize();

		widget.revalidate();

		background.setPos(edgeSize, edgeSize)
			.setSize(edgeSize * 2, edgeSize * 2)
			.setSpriteId(theme.getBackground())
			.revalidate();

		topLeftCorner.setSize(cornerSize, cornerSize)
			.setSpriteId(theme.getTopLeftCorner())
			.revalidate();

		topRightCorner.setSize(cornerSize, cornerSize)
			.setSpriteId(theme.getTopRightCorner())
			.revalidate();

		bottomLeftCorner.setSize(cornerSize, cornerSize)
			.setSpriteId(theme.getBottomLeftCorner())
			.revalidate();

		bottomRightCorner.setSize(cornerSize, cornerSize)
			.setSpriteId(theme.getBottomRightCorner())
			.revalidate();

		leftEdge.setSize(edgeSize, cornerSize * 2)
			.setSpriteId(theme.getLeftEdge())
			.revalidate();

		topEdge.setSize(cornerSize * 2, edgeSize)
			.setSpriteId(theme.getTopEdge())
			.revalidate();

		rightEdge.setSize(edgeSize, cornerSize * 2)
			.setSpriteId(theme.getRightEdge())
			.revalidate();

		bottomEdge.setSize(cornerSize * 2, edgeSize)
			.setSpriteId(theme.getBottomEdge())
			.revalidate();

		content.revalidate();
	}
}
package com.collectionlogmaster.ui.generic;

import static java.util.Map.entry;

import com.collectionlogmaster.ui.generic.button.UIButton;
import com.collectionlogmaster.ui.sprites.SpriteOverride;
import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.FontID;
import net.runelite.api.ScriptEvent;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;

public class UITab extends UIButton<UITab> {
	public static final int TAB_HEIGHT = 20;
	public static final int CORNER_SIZE = 20;
	public static final int PADDING_X = 15;
	public static final int TEXT_Y_OFFSET = 2;

	private static final int[] DEFAULT_SPRITES = {
		SpriteID.TabsTall._2,
		SpriteID.TabsTall._3,
		SpriteOverride.TALL_TABS_CORNER_VFLIP.getSpriteId()
	};

	private static final int[] HOVER_SPRITES = {
		SpriteID.TabsTall._0,
		SpriteID.TabsTall._1,
		SpriteOverride.TALL_TABS_CORNER_HOVER_VFLIP.getSpriteId()
	};

	private static final int[] DISABLED_SPRITES = HOVER_SPRITES;

	@Getter
	@RequiredArgsConstructor
	public enum StateTheme {
		DEFAULT(0xFFA82F, DEFAULT_SPRITES),
		HOVER(0xFFA82F, HOVER_SPRITES),
		DISABLED(0xFFA82F, DISABLED_SPRITES);

		private final int textColor;
		private final int[] sprites;
	}

	private static final Map<State, StateTheme> THEME_MAP = Map.ofEntries(
		entry(State.DEFAULT, StateTheme.DEFAULT),
		entry(State.HOVER, StateTheme.HOVER),
		entry(State.DISABLED, StateTheme.DISABLED)
	);

	private final Widget leftCorner;
	private final Widget middle;
	private final Widget rightCorner;
	private final Widget textWidget;

	public static UITab createInside(Widget window) {
		return new UITab(window.createChild(WidgetType.LAYER));
	}

	protected UITab(Widget widget) {
		super(widget);

		leftCorner = widget.createChild(WidgetType.GRAPHIC);
		middle = widget.createChild(WidgetType.GRAPHIC);
		rightCorner = widget.createChild(WidgetType.GRAPHIC);
		textWidget = widget.createChild(WidgetType.TEXT);

		initializeWidgets();
	}

	@Override
	protected void onActionSelected(ScriptEvent e) {
		super.onActionSelected(e);

		setState(State.DISABLED)
			.revalidate();
	}

	public UITab setText(String text) {
		textWidget.setText(text);
		return this;
	}

	protected StateTheme getTheme() {
		return THEME_MAP.get(getState());
	}

	protected void initializeWidgets() {
		widget.setOriginalHeight(CORNER_SIZE)
			.revalidate();

		leftCorner.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE)
			.revalidate();

		middle.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE * 2, 0)
			.setSpriteTiling(true)
			.revalidate();

		rightCorner.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE)
			.revalidate();

		textWidget.setPos(0, TEXT_Y_OFFSET)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setFontId(FontID.PLAIN_12)
			.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();

		int textWidth = textWidget.getFont().getTextWidth(textWidget.getText());
		widget.setOriginalWidth(textWidth + (PADDING_X * 2))
			.revalidate();

		StateTheme theme = getTheme();
		int[] themeSprites = theme.getSprites();
		leftCorner.setSpriteId(themeSprites[0])
			.revalidate();

		middle.setSpriteId(themeSprites[1])
			.revalidate();

		rightCorner.setSpriteId(themeSprites[2])
			.revalidate();

		textWidget.setTextColor(theme.getTextColor())
			.revalidate();
	}
}

package com.collectionlogmaster.ui.generic;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import org.intellij.lang.annotations.MagicConstant;

public class UIGridContainer extends UIComponent<UIGridContainer> {
	/**
	 * Initial distance between grid items. Final gap will
	 * be increased to accommodate for remaining space.
	 */
	private static final int BASE_GAP = 2;

	private final List<Widget> items = new ArrayList<>();

	public static UIGridContainer createInside(Widget window) {
		return new UIGridContainer(window.createChild(WidgetType.LAYER));
	}

	public UIGridContainer(Widget widget) {
		super(widget, WidgetType.LAYER);
	}

	public List<Widget> getItems() {
		return Collections.unmodifiableList(items);
	}

	public Widget createItem(@MagicConstant(valuesFromClass = WidgetType.class) int widgetType) {
		Widget newItem = widget.createChild(widgetType);
		items.add(newItem);
		return newItem;
	}

	private void repositionItems() {
		// we assume all items are same size
		Widget anyItem = items.iterator().next();
		int itemGap = BASE_GAP;
		int itemWidth = anyItem.getWidth() + itemGap;
		int itemHeight = anyItem.getHeight() + itemGap;
		int widthAvailable = widget.getWidth() - (BASE_GAP * 2);

		// redistribute remaining space first equally between items
		int spaceRemaining = widthAvailable % itemWidth;
		int maxItemsPerLine = widthAvailable / itemWidth;
		itemGap += spaceRemaining / maxItemsPerLine;
		itemWidth = anyItem.getWidth() + itemGap;

		// redistribute rest of remaining space as "padding" on the grid itself
		spaceRemaining = widthAvailable % itemWidth;
		int gridOffset = BASE_GAP + (spaceRemaining / 2) + (itemGap / 2);

		// the last line needs to be offset to remain centered
		int lastLineIndex = ((items.size() - 1) / maxItemsPerLine);
		int lastLineXOffset = Math.floorMod(-items.size(), maxItemsPerLine) * itemWidth / 2;

		int i = 0;
		for (Widget item : items) {
			int x = i % maxItemsPerLine;
			int y = i / maxItemsPerLine;
			int extraXOffset = y == lastLineIndex ? lastLineXOffset : 0;

			int posX = x * itemWidth + gridOffset + extraXOffset;
			int posY = y * itemHeight + BASE_GAP;

			item.setPos(posX, posY)
				.revalidate();

			i++;
		}
	}

	@Override
	public void revalidate() {
		widget.revalidate();

		if (items.isEmpty()) {
			return;
		}

		repositionItems();

		Widget lastItem = items.get(items.size() - 1);
		widget.setOriginalHeight(lastItem.getRelativeY() + lastItem.getHeight() + BASE_GAP);
	}
}

package com.collectionlogmaster.ui.generic.button;

import static java.util.Map.entry;

import java.util.Map;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;

public abstract class UIMultiSpriteButton<This extends UIMultiSpriteButton<This>> extends UIButton<This> {
	public static final int CORNER_SIZE = 9;

	private static final int[] DEFAULT_SPRITES = {
		SpriteID.TRADEBACKING,
		SpriteID.V2StoneButtonOut.A_TOP_LEFT,
		SpriteID.V2StoneButtonOut.A_TOP_RIGHT,
		SpriteID.V2StoneButtonOut.A_BOTTOM_LEFT,
		SpriteID.V2StoneButtonOut.A_BOTTOM_RIGHT,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_LEFT,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_TOP,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_RIGHT,
		SpriteID.V2StoneButtonOut.A_MAP_EDGE_BOTTOM,
	};

	private static final int[] HOVER_SPRITES = {
		SpriteID.TRADEBACKING_DARK,
		SpriteID.V2StoneButtonIn.A_TOP_LEFT,
		SpriteID.V2StoneButtonIn.A_TOP_RIGHT,
		SpriteID.V2StoneButtonIn.A_BOTTOM_LEFT,
		SpriteID.V2StoneButtonIn.A_BOTTOM_RIGHT,
		SpriteID.V2StoneButtonIn.A_LEFT,
		SpriteID.V2StoneButtonIn.A_TOP,
		SpriteID.V2StoneButtonIn.A_RIGHT,
		SpriteID.V2StoneButtonIn.A_BOTTOM,
	};

	private static final int[] DISABLED_SPRITES = {
		SpriteID.TRADEBACKING_DARK,
		SpriteID.V2StoneButton.TOP_LEFT,
		SpriteID.V2StoneButton.TOP_RIGHT,
		SpriteID.V2StoneButton.BOTTOM_LEFT,
		SpriteID.V2StoneButton.BOTTOM_RIGHT,
		SpriteID.V2StoneButton.LEFT,
		SpriteID.V2StoneButton.TOP,
		SpriteID.V2StoneButton.RIGHT,
		SpriteID.V2StoneButton.BOTTOM,
	};

	@Getter
	@RequiredArgsConstructor
	public enum StateTheme {
		DEFAULT(0xFFFFFF, DEFAULT_SPRITES),
		HOVER(0xFFFFFF, HOVER_SPRITES),
		DISABLED(0x969696, DISABLED_SPRITES);

		private final int textColor;
		private final int[] sprites;
	}

	private static final Map<State, StateTheme> THEME_MAP = Map.ofEntries(
		entry(State.DEFAULT, StateTheme.DEFAULT),
		entry(State.HOVER, StateTheme.HOVER),
		entry(State.DISABLED, StateTheme.DISABLED)
	);

	private final Widget background;
	private final Widget topLeftCorner;
	private final Widget topRightCorner;
	private final Widget bottomLeftCorner;
	private final Widget bottomRightCorner;
	private final Widget leftEdge;
	private final Widget topEdge;
	private final Widget rightEdge;
	private final Widget bottomEdge;
	protected Widget content;

	private final Widget[] allGraphics;

	protected UIMultiSpriteButton(Widget widget) {
		super(widget);

		background = widget.createChild(WidgetType.GRAPHIC);
		topLeftCorner = widget.createChild(WidgetType.GRAPHIC);
		topRightCorner = widget.createChild(WidgetType.GRAPHIC);
		bottomLeftCorner = widget.createChild(WidgetType.GRAPHIC);
		bottomRightCorner = widget.createChild(WidgetType.GRAPHIC);
		leftEdge = widget.createChild(WidgetType.GRAPHIC);
		topEdge = widget.createChild(WidgetType.GRAPHIC);
		rightEdge = widget.createChild(WidgetType.GRAPHIC);
		bottomEdge = widget.createChild(WidgetType.GRAPHIC);
		allGraphics = new Widget[] {
			background,
			topLeftCorner, topRightCorner, bottomLeftCorner, bottomRightCorner,
			leftEdge, topEdge, rightEdge, bottomEdge
		};

		createContent(widget);

		initializeWidgets();
	}

	protected abstract void createContent(Widget widget);

	protected StateTheme getTheme() {
		return THEME_MAP.get(getState());
	}

	protected void initializeWidgets() {
		widget.revalidate();

		background.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setSpriteTiling(true)
			.revalidate();

		topLeftCorner.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE)
			.revalidate();

		topRightCorner.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE)
			.revalidate();

		bottomLeftCorner.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE)
			.revalidate();

		bottomRightCorner.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, 0)
			.setSize(CORNER_SIZE, CORNER_SIZE)
			.revalidate();

		leftEdge.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE, CORNER_SIZE * 2)
			.setSpriteTiling(true)
			.revalidate();

		topEdge.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE * 2, CORNER_SIZE)
			.setSpriteTiling(true)
			.revalidate();

		rightEdge.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE, CORNER_SIZE * 2)
			.setSpriteTiling(true)
			.revalidate();

		bottomEdge.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(CORNER_SIZE * 2, CORNER_SIZE)
			.setSpriteTiling(true)
			.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();

		int[] sprites = getTheme().getSprites();
		for (int i = 0; i < allGraphics.length; i++) {
			allGraphics[i].setSpriteId(sprites[i])
				.revalidate();
		}

		content.revalidate();
	}
}

package com.collectionlogmaster.ui.generic.button;

import static java.util.Map.entry;

import java.util.Map;
import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import org.intellij.lang.annotations.MagicConstant;

public class UISimpleButton extends UIButton<UISimpleButton> {
	private static final int BASE_GAP = 4;

	private Map<State, Integer> textColorTheme = Map.ofEntries(
		entry(State.DEFAULT, 0xCCCCCC),
		entry(State.HOVER, 0xFFFFFF),
		entry(State.DISABLED, 0x969696)
	);

	private Map<State, Integer> iconSpriteTheme = Map.ofEntries(
		entry(State.DEFAULT, -1),
		entry(State.HOVER, -1),
		entry(State.DISABLED, -1)
	);

	private final Widget icon;
	private final Widget text;

	public static UISimpleButton createInside(Widget window) {
		return new UISimpleButton(window.createChild(WidgetType.LAYER));
	}

	protected UISimpleButton(Widget widget) {
		super(widget);

		icon = widget.createChild(WidgetType.GRAPHIC);
		text = widget.createChild(WidgetType.TEXT);

		initializeWidgets();
	}

	protected int getTextColor() {
		return textColorTheme.getOrDefault(getState(), 0xFFFFFF);
	}

	protected int getIconSprite() {
		return iconSpriteTheme.getOrDefault(getState(), -1);
	}

	public UISimpleButton setFontId(@MagicConstant(valuesFromClass = FontID.class) int font) {
		text.setFontId(font);
		return this;
	}

	public UISimpleButton setText(String textContent) {
		text.setText(textContent);
		return this;
	}

	public UISimpleButton setTextShadowed(boolean shadowed) {
		text.setTextShadowed(shadowed);
		return this;
	}

	public UISimpleButton setIconSpriteTheme(int defaultSprite, int hoverSprite, int disabledSprite) {
		iconSpriteTheme = Map.ofEntries(
			entry(State.DEFAULT, defaultSprite),
			entry(State.HOVER, hoverSprite),
			entry(State.DISABLED, disabledSprite)
		);

		return this;
	}

	public UISimpleButton setTextColorTheme(int defaultColor, int hoverColor, int disabledColor) {
		textColorTheme = Map.ofEntries(
			entry(State.DEFAULT, defaultColor),
			entry(State.HOVER, hoverColor),
			entry(State.DISABLED, disabledColor)
		);

		return this;
	}

	public UISimpleButton setIconSize(int width, int height) {
		icon.setSize(width, height);
		return this;
	}

	protected void initializeWidgets() {
		widget.revalidate();

		icon.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setOriginalY(0);

		text.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setOriginalY(1)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setFontId(FontID.PLAIN_12)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();

		// remove gap when one of the widgets is not used
		int effectiveGap = text.getText().isBlank() || getIconSprite() == -1 ? 0 : BASE_GAP;

		text.setOriginalWidth(text.getFont().getTextWidth(text.getText()))
			.setOriginalX((icon.getOriginalWidth() + effectiveGap) / 2)
			.setTextColor(getTextColor())
			.revalidate();

		icon.setOriginalX((text.getOriginalWidth() + effectiveGap) / -2)
			.setSpriteId(getIconSprite())
			.revalidate();
	}
}

package com.collectionlogmaster.ui.generic.button;

import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import org.intellij.lang.annotations.MagicConstant;

public class UITextButton extends UIMultiSpriteButton<UITextButton> {
	public static UITextButton createInside(Widget window) {
		return new UITextButton(window.createChild(WidgetType.LAYER));
	}

	public UITextButton(Widget widget) {
		super(widget);
	}

	@Override
	protected void createContent(Widget widget) {
		content = widget.createChild(WidgetType.TEXT);
	}

	@Override
	protected void initializeWidgets() {
		super.initializeWidgets();

		content.setPos(0, 0)
				.setWidthMode(WidgetSizeMode.MINUS)
				.setHeightMode(WidgetSizeMode.MINUS)
				.setSize(0, 0)
				.setXTextAlignment(WidgetTextAlignment.CENTER)
				.setYTextAlignment(WidgetTextAlignment.CENTER)
				.setFontId(FontID.BOLD_12)
				.setTextShadowed(true)
				.revalidate();
	}

	public UITextButton setFont(@MagicConstant(valuesFromClass = FontID.class) int font) {
		content.setFontId(font);
		return this;
	}

	public UITextButton setText(String text) {
		content.setText(text);
		return this;
	}

	@Override
	public void revalidate() {
		content.setTextColor(getTheme().getTextColor());

		super.revalidate();
	}
}

package com.collectionlogmaster.ui.generic.button;

import com.collectionlogmaster.ui.generic.UIComponent;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import net.runelite.api.ScriptEvent;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

@Accessors(chain = true)
public abstract class UIButton<This extends UIButton<This>> extends UIComponent<This> {
	public enum State {
		DEFAULT,
		HOVER,
		DISABLED;
	}

	@Getter
	@Setter
	private State state = State.DEFAULT;

	@Getter
	protected Runnable action = null;

	protected UIButton(Widget widget) {
		super(widget, WidgetType.LAYER);

		widget.setOnOpListener((JavaScriptCallback) this::onActionSelected);
		widget.setOnMouseOverListener((JavaScriptCallback) this::onMouseHover);
		widget.setOnMouseLeaveListener((JavaScriptCallback) this::onMouseLeave);
		widget.setHasListener(true);
	}

	protected void onActionSelected(ScriptEvent e) {
		if (state == State.DISABLED) {
			return;
		}

		if (action != null) {
			action.run();
		}
	}

	protected void onMouseHover(ScriptEvent e) {
		if (state == State.DEFAULT) {
			setState(State.HOVER)
				.revalidate();
		}
	}

	protected void onMouseLeave(ScriptEvent e) {
		if (state == State.HOVER) {
			setState(State.DEFAULT)
				.revalidate();
		}
	}

	public This setName(String name) {
		widget.setName(name);
		return castThis();
	}

	public This setAction(String label, Runnable action) {
		widget.setAction(0, label);
		this.action = action;

		return castThis();
	}

	public void triggerAction() {
		onActionSelected(null);
	}
}

package com.collectionlogmaster.ui.generic;

import java.awt.Rectangle;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import org.intellij.lang.annotations.MagicConstant;

/**
 * Wraps a given Widget into a class we can control and extend from, exposing most common Widget
 * methods. This should be used as the base for more advanced components, usually having a LAYER
 * widget as the base and more children widgets for extended functionality.
 *
 * @param <This> The class that is extending UIComponent; this
 *               is required for the chaining to work properly
 */
@Slf4j
public abstract class UIComponent<This extends UIComponent<This>> {
	@Getter
	protected Widget widget;

	protected UIComponent(Widget widget) {
		this(widget, WidgetType.LAYER);
	}

	protected UIComponent(Widget widget, @MagicConstant(valuesFromClass = WidgetType.class) int allowedType) {
		if (allowedType != widget.getType()) {
			String msg = String.format("Incompatible widget; %d given, %d expected", allowedType, widget.getType());
			throw new RuntimeException(msg);
		}

		this.widget = widget;
	}

	public This setOriginalX(int originalX) {
		widget.setOriginalX(originalX);
		return castThis();
	}

	public int getOriginalX() {
		return widget.getOriginalX();
	}

	public This setOriginalY(int originalY) {
		widget.setOriginalY(originalY);
		return castThis();
	}

	public int getOriginalY() {
		return widget.getOriginalY();
	}

	public int getRelativeX() {
		return widget.getRelativeX();
	}

	public int getRelativeY() {
		return widget.getRelativeY();
	}

	public This setPos(int x, int y) {
		widget.setPos(x, y);
		return castThis();
	}

	public This setOriginalWidth(int originalWidth) {
		widget.setOriginalWidth(originalWidth);
		return castThis();
	}

	public int getOriginalWidth() {
		return widget.getOriginalWidth();
	}

	public This setOriginalHeight(int originalHeight) {
		widget.setOriginalHeight(originalHeight);
		return castThis();
	}

	public int getOriginalHeight() {
		return widget.getOriginalHeight();
	}

	public int getWidth() {
		return widget.getWidth();
	}

	public int getHeight() {
		return widget.getHeight();
	}

	public This setSize(int width, int height) {
		widget.setSize(width, height);
		return castThis();
	}

	public This setXPositionMode(@MagicConstant(valuesFromClass = WidgetPositionMode.class) int xpm) {
		widget.setXPositionMode(xpm);
		return castThis();
	}

	public This setYPositionMode(@MagicConstant(valuesFromClass = WidgetPositionMode.class) int ypm) {
		widget.setYPositionMode(ypm);
		return castThis();
	}

	public This setWidthMode(@MagicConstant(valuesFromClass = WidgetSizeMode.class) int widthMode) {
		widget.setWidthMode(widthMode);
		return castThis();
	}

	public This setHeightMode(@MagicConstant(valuesFromClass = WidgetSizeMode.class) int heightMode) {
		widget.setHeightMode(heightMode);
		return castThis();
	}

	public This setHidden(boolean hidden) {
		widget.setHidden(hidden);
		return castThis();
	}

	public Rectangle getBounds() {
		return widget.getBounds();
	}

	public boolean isHidden() {
		return widget.isHidden();
	}

	/**
	 * Cast this to the generic type given so that chaining methods preserve
	 * the child class type and its methods can still be called in the chain.
	 */
	@SuppressWarnings("unchecked")
	protected This castThis() {
		return (This) this;
	}

	/**
	 * Unlike Widget::revalidate, this method is also responsible
	 * for applying many stateful style changes.
	 */
	public void revalidate() {
		widget.revalidate();
	}

	public void unregister() {

	}
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.InterfaceManager;
import com.collectionlogmaster.ui.generic.BorderTheme;
import com.collectionlogmaster.ui.generic.UIBorderedContainer;
import com.collectionlogmaster.ui.generic.UIComponent;
import com.collectionlogmaster.ui.generic.UIUtil;
import javax.inject.Inject;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.Accessors;
import net.runelite.api.FontID;
import net.runelite.api.ScriptEvent;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import org.jetbrains.annotations.Range;

@Accessors(chain = true)
public class TaskComponent extends UIComponent<TaskComponent> {
	private final UIBorderedContainer outerContainer;
	private final UIBorderedContainer imageContainer;
	private final Widget image;
	private final Widget name;

	@Getter
	@Setter
	private Task task = null;

	@Setter
	private int paddingSize = 10;

	@Inject
	private InterfaceManager interfaceManager;

	@Inject
	private TaskService taskService;

	public static TaskComponent createInside(Widget window) {
		return new TaskComponent(window.createChild(WidgetType.LAYER));
	}

	protected TaskComponent(Widget widget) {
		super(widget, WidgetType.LAYER);
		CollectionLogMasterPlugin.getStaticInjector().injectMembers(this);

		outerContainer = UIBorderedContainer.createInside(widget);
		imageContainer = new UIBorderedContainer(outerContainer.getContent(), WidgetType.GRAPHIC);
		image = imageContainer.getContent();
		name = widget.createChild(WidgetType.TEXT);

		initializeWidgets();
	}

	public TaskComponent setOpacity(@Range(from = 0, to = 255) int transparency) {
		image.setOpacity(transparency);
		name.setOpacity(transparency);
		return this;
	}

	public TaskComponent setTheme(BorderTheme theme) {
		outerContainer.setTheme(theme);
		imageContainer.setTheme(theme);
		return this;
	}

	private void onActionSelected(ScriptEvent e) {
		int actionIndex = e.getOp();
		switch (actionIndex) {
			case 1:
				interfaceManager.openTaskInfo(task);
				return;

			case 2:
				boolean isComplete = taskService.toggleComplete(task.getId());
				setOpacity(isComplete ? 0 : 175)
					.setTheme(isComplete ? BorderTheme.ETCHED_GREEN_DYED : BorderTheme.ETCHED)
					.revalidate();
				return;
		}
	}

	private void initializeWidgets() {
		widget.setHasListener(true)
			.revalidate();

		widget.setOnOpListener((JavaScriptCallback) this::onActionSelected);

		outerContainer.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setTheme(BorderTheme.ETCHED)
			.revalidate();

		imageContainer.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setTheme(BorderTheme.ETCHED)
			.revalidate();

		image.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setBorderType(1);

		image.revalidate();

		name.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setFontId(FontID.BOLD_12)
			.setTextColor(0xFFFFFF)
			.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();

		if (task != null) {
			widget.setName(UIUtil.formatName(task.getName()));
			widget.setAction(0, "View");
			if (taskService.isComplete(task.getId())) {
				widget.setAction(1, "Uncomplete");
			} else {
				widget.setAction(1, "Complete");
			}
		} else {
			widget.setAction(0, null);
			widget.setAction(1, null);
		}

		outerContainer.revalidate();

		imageContainer.setPos(paddingSize, 0)
			.setSize(outerContainer.getHeight() - (paddingSize * 2), paddingSize * 2)
			.revalidate();

		int itemId = ItemID._100GUIDE_GUIDECAKE;
		String taskName = "No active task";
		if (task != null) {
			itemId = task.getDisplayItemId();
			taskName = task.getName();
		}

		image.setSize(paddingSize, paddingSize)
			.setItemId(itemId)
			.revalidate();

		name.setSize(outerContainer.getHeight() + paddingSize, 0)
			.setPos((outerContainer.getHeight() - paddingSize) / 2, 0)
			.setText(taskName)
			.revalidate();
	}
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.synchronization.SyncService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.generic.UIComponent;
import com.collectionlogmaster.ui.generic.UIUtil;
import com.collectionlogmaster.ui.generic.button.UIButton.State;
import com.collectionlogmaster.ui.generic.button.UITextButton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import net.runelite.api.FontID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.NotNull;

public class TaskDashboard extends UIComponent<TaskDashboard> {
	public static final int BASE_GAP = 16;
	public static final int TITLE_HEIGHT = 50;
	public static final int BUTTON_HEIGHT = 30;
	public static final int BUTTON_WIDTH = 140;
	public static final int TASK_COMPONENT_WIDTH = 300;
	public static final int TASK_COMPONENT_HEIGHT = 70;
	public static final int MAX_ROLLING_STEPS = 65;

	@Inject
	private ScheduledExecutorService executorService;

	@Inject
	private ClientThread clientThread;

	@Inject
	private CollectionLogMasterConfig config;

	@Inject
	private TaskService taskService;

	@Inject
	private SyncService syncService;

	private final Widget title;
	private final TaskComponent taskComponent;
	private final UITextButton completeButton;
	private final UITextButton generateButton;
	private final UITextButton faqButton;
	private final UITextButton syncButton;
	private final Widget progress;

	public static TaskDashboard createInside(Widget window) {
		return new TaskDashboard(window.createChild(WidgetType.LAYER));
	}

	protected TaskDashboard(Widget widget) {
		super(widget, WidgetType.LAYER);
		CollectionLogMasterPlugin.getStaticInjector().injectMembers(this);

		title = widget.createChild(WidgetType.TEXT);
		taskComponent = TaskComponent.createInside(widget);
		completeButton = UITextButton.createInside(widget);
		generateButton = UITextButton.createInside(widget);
		faqButton = UITextButton.createInside(widget);
		syncButton = UITextButton.createInside(widget);
		progress = widget.createChild(WidgetType.TEXT);

		initializeWidgets();
	}

	private void initializeWidgets() {
		widget.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.revalidate();

		title.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, BASE_GAP)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, TITLE_HEIGHT)
			.setFontId(FontID.QUILL_CAPS_LARGE)
			.setTextColor(0xFFFFFF)
			.setTextShadowed(true)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setText("Current Task")
			.revalidate();

		taskComponent.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, title.getRelativeY() + title.getHeight() + BASE_GAP)
			.setSize(TASK_COMPONENT_WIDTH, TASK_COMPONENT_HEIGHT)
			.revalidate();

		int actionButtonsY = taskComponent.getRelativeY() + taskComponent.getHeight() + BASE_GAP;
		completeButton.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(-((BUTTON_WIDTH / 2) + BASE_GAP), actionButtonsY)
			.setSize(BUTTON_WIDTH, BUTTON_HEIGHT)
			.setText("Complete Task")
			.revalidate();

		generateButton.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos((BUTTON_WIDTH / 2) + BASE_GAP, actionButtonsY)
			.setSize(BUTTON_WIDTH, BUTTON_HEIGHT)
			.setText("Generate Task")
			.revalidate();

		progress.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, generateButton.getRelativeY() + generateButton.getHeight() + BASE_GAP)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize((BUTTON_WIDTH + BASE_GAP) * 2, BUTTON_HEIGHT)
			.setFontId(FontID.BOLD_12)
			.setTextColor(0xFFFFFF)
			.setTextShadowed(true)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.revalidate();

		syncButton.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(BASE_GAP / 2, BASE_GAP / 2)
			.setSize(BUTTON_WIDTH / 2, BUTTON_HEIGHT)
			.setText("Sync")
			.setName(UIUtil.formatName("Sync"))
			.setAction("Visit", () -> {
				syncService.sync();
				revalidate();
			})
			.revalidate();

		faqButton.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(BASE_GAP / 2, BASE_GAP / 2)
			.setSize(BUTTON_WIDTH / 2, BUTTON_HEIGHT)
			.setText("FAQ")
			.setName(UIUtil.formatName("FAQ"))
			.setAction("Check", UIUtil::openFAQ)
			.revalidate();
	}

	private @NotNull String getProgressText() {
		TaskTier tier = taskService.getCurrentTier();
		float percent = taskService.getProgress().get(tier);

		return String.format(
			"<col=%x>%d%%</col> %s Completed",
			UIUtil.getCompletionColor(percent),
			UIUtil.roundCompletionPercent(percent),
			tier.displayName
		);
	}

	private void generateTask() {
		Task generatedTask = taskService.generate();
		List<Task> rollTasks = getRollTasks();

		Stack<Pair<Task, Integer>> stepStack = new Stack<>();
		stepStack.push(Pair.of(generatedTask, 0));

		int timeLeft = config.rollTime();
		while (timeLeft > 0) {
			int stepDelay = calculateStepDelay(stepStack.size() - 1);

			stepStack.push(Pair.of(
				rollTasks.get(stepStack.size()),
				stepDelay
			));

			timeLeft -= stepDelay;
		}

		executeRollStep(stepStack);

		generateButton.setState(State.DISABLED)
			.revalidate();
	}

	/**
	 * Calculates the delay between the current step and the next one, in milliseconds. Uses an
	 * exponential function as to start very start and quickly slow down, trying to emulate a
	 * spinning prize wheel slowly decelerating.
	 */
	private int calculateStepDelay(int stepCount) {
		// a magic constant used to fine tune the total duration of all
		// steps, in order for it to match the configured roll time
		final double K = 250;

		// a magic constant used to fine tune how quickly the "wheel decelerates"
		final double Q = 36;

		// just the roll time divided by 1000
		final double R = config.rollTime() / 1000d;

		// (K * cbrt(R)) * e^(-s / sqrt(Q * R))
		return (int) ((K * Math.cbrt(R)) * Math.exp(-stepCount / Math.sqrt(Q * R)));
	}

	private void executeRollStep(Stack<Pair<Task, Integer>> stepStack) {
		Pair<Task, Integer> step = stepStack.pop();
		Task task = step.getLeft();
		int nextStepDelay = step.getRight();

		clientThread.invoke(() -> {
			taskComponent.setTask(task)
				.revalidate();
		});

		if (stepStack.empty()) {
			clientThread.invoke(this::revalidate);
			return;
		}

		executorService.schedule(() -> executeRollStep(stepStack), nextStepDelay, TimeUnit.MILLISECONDS);
	}

	private @NotNull List<Task> getRollTasks() {
		List<Task> candidateTasks = taskService.getIncompleteTierTasks();
		if (candidateTasks.size() < MAX_ROLLING_STEPS && config.rollPastCompleted()) {
			candidateTasks = taskService.getTierTasks();
		}

		while (candidateTasks.size() < MAX_ROLLING_STEPS) {
			candidateTasks.addAll(new ArrayList<>(candidateTasks));
		}

		Collections.shuffle(candidateTasks);

		return candidateTasks.subList(0, MAX_ROLLING_STEPS);
	}

	@Override
	public void revalidate() {
		super.revalidate();

		title.revalidate();

		Task activeTask = taskService.getActiveTask();
		taskComponent.setTask(activeTask)
			.revalidate();

		if (activeTask != null) {
			completeButton.setState(State.DEFAULT)
				.setName(UIUtil.formatName(activeTask.getName()))
				.setAction("Complete", () -> {
					taskService.complete();
					revalidate();
				})
				.revalidate();

			generateButton.setState(State.DISABLED)
				.setAction(null, null)
				.revalidate();
		} else {
			completeButton.setState(State.DISABLED)
				.setAction(null, null)
				.revalidate();

			generateButton.setState(State.DEFAULT)
				.setName(UIUtil.formatName("new task"))
				.setAction("Generate", this::generateTask)
				.revalidate();
		}

		String progressText = getProgressText();
		progress.setText(progressText)
			.revalidate();

		syncButton.revalidate();
		faqButton.revalidate();
	}
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.generic.ScrollAxis;
import com.collectionlogmaster.ui.generic.UIComponent;
import com.collectionlogmaster.ui.generic.UIScrollableContainer;
import com.collectionlogmaster.ui.generic.UITab;
import com.collectionlogmaster.ui.generic.UIUtil;
import com.collectionlogmaster.ui.generic.button.UIButton;
import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;

// TODO: maybe extract into reusable component, if we ever need tabs elsewhere
public class MainTabbedContainer extends UIComponent<MainTabbedContainer> {
	public static final int TAB_GAP = 2;

	@Inject
	private ClientThread clientThread;

	@Inject
	private TaskService taskService;

	private final UIScrollableContainer scrollableContainer;
	private final Widget tabsContainer;
	private final Widget divider;
	private final Widget contentContainer;
	private UIComponent<?> contentComponent = null;

	private final List<UITab> tabs = new ArrayList<>();

	public static MainTabbedContainer createInside(Widget window) {
		return new MainTabbedContainer(window.createChild(WidgetType.LAYER));
	}

	protected MainTabbedContainer(Widget widget) {
		super(widget, WidgetType.LAYER);
		CollectionLogMasterPlugin.getStaticInjector().injectMembers(this);

		scrollableContainer = UIScrollableContainer.createInside(widget);
		tabsContainer = scrollableContainer.getContent();
		divider = tabsContainer.createChild(WidgetType.RECTANGLE);
		contentContainer = widget.createChild(WidgetType.LAYER);

		initializeWidgets();
	}

	private void addTab(String label, Function<Widget, UIComponent<?>> renderer) {
		UITab tab = UITab.createInside(tabsContainer)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setOriginalY(0)
			.setText(label)
			.setName(UIUtil.formatName(label))
			.setAction("View", () -> activateTab(renderer));

		tabs.add(tab);
	}

	private void activateTab(Function<Widget, UIComponent<?>> renderer) {
		for (UITab tab : tabs) {
			tab.setState(UIButton.State.DEFAULT)
				.revalidate();
		}

		for (Widget tabContent : contentContainer.getDynamicChildren()) {
			// ideally we should delete those widgets, but I couldn't figure out how
			tabContent.setHidden(true);
		}

		clientThread.invoke(() -> {
			if (contentComponent != null) {
				contentComponent.unregister();
			}

			contentComponent = renderer.apply(contentContainer);
		});
	}

	private void initializeWidgets() {
		widget.setPos(0, 0)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.revalidate();

		scrollableContainer.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, UITab.TAB_HEIGHT + 1)
			.setScrollAxis(ScrollAxis.HORIZONTAL)
			.setScrollSensitivity(2)
			.revalidate();

		addTab("Dashboard", container -> {
			TaskDashboard dashboard = TaskDashboard.createInside(container);
			dashboard.revalidate();
			return dashboard;
		});

		for (TaskTier tier : taskService.getVisibleTiers()) {
			addTab(tier.displayName, (Widget container) -> {
				TaskList taskList = TaskList.createInside(container, taskService.getTierTasks(tier));
				taskList.revalidate();
				return taskList;
			});
		}

		divider.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, UITab.TAB_HEIGHT)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, 1)
			.setTextColor(0x606060)
			.revalidate();

		contentContainer.setPos(0, UITab.TAB_HEIGHT + 1)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, UITab.TAB_HEIGHT + 1);

		// activate first tab
		tabs.get(0).triggerAction();
	}

	@Override
	public void revalidate() {
		super.revalidate();

		scrollableContainer.revalidate();

		int previousTabX = TAB_GAP;
		for (UITab tab : tabs) {
			tab.setOriginalX(previousTabX)
				.revalidate();

			previousTabX += tab.getWidth() + TAB_GAP;
		}

		int tabsWidth = Math.max(previousTabX, scrollableContainer.getWidth());
		tabsContainer.setOriginalWidth(tabsWidth)
			.revalidate();

		divider.revalidate();

		contentContainer.revalidate();

		if (contentComponent != null) {
			contentComponent.revalidate();
		}
	}

	@Override
	public void unregister() {
		scrollableContainer.unregister();

		if (contentComponent != null) {
			contentComponent.unregister();
		}
	}
}

package com.collectionlogmaster.ui.component;

import static com.collectionlogmaster.ui.InterfaceManager.COLLECTION_LOG_SETUP_SCRIPT_ID;

import com.collectionlogmaster.ui.InterfaceManager;
import com.collectionlogmaster.ui.state.StateChanged;
import com.collectionlogmaster.ui.state.StateStore;
import com.collectionlogmaster.util.EventBusSubscriber;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.eventbus.Subscribe;
import org.intellij.lang.annotations.MagicConstant;

/**
 * Responsible for handling the interaction with the hamburger menu in the top-left corner of the
 * collection log window. Heavily inspired by <a href="https://github.com/ReinhardtR/runeprofile-plugin/blob/master/src/main/java/com/runeprofile/ui/ManualUpdateButtonManager.java">RuneProfile's implementation</a>
 */
@Slf4j
@Singleton
public class MenuManager extends EventBusSubscriber {
	private static final int DRAW_BURGER_MENU_SCRIPT_ID = 7812;
	private static final int COLLECTION_LOG_BURGER_MENU_WIDGET_ID = 40697929;

	private static final int BG_OPACITY = 255;
	private static final int BG_OPACITY_SELECTED = 230;
	private static final int TEXT_OPACITY = 0;
	private static final int TEXT_OPACITY_SELECTED = 200;
	private static final int TEXT_COLOR = 0xFF981F;
	private static final int TEXT_COLOR_SELECTED = 0xC8C8C8;
	private static final int TEXT_COLOR_HOVER = 0xFFFFFF;

	private static final String BUTTON_TEXT = "Tasks";
	private static final String ACTION_TEXT = "View Tasks Dashboard";

	@Inject
	private Client client;

	@Inject
	private StateStore stateStore;

	@Inject
	private InterfaceManager interfaceManager;

	private Widget menu;
	private Widget ourBackground;
	private Widget ourText;
	private Widget firstBackground;
	private Widget firstText;

	private int baseMenuHeight = -1;

	@Subscribe
	public void onStateChanged(StateChanged ev) {
		restyleOptions();
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event) {
		int scriptId = event.getScriptId();
		if (scriptId == COLLECTION_LOG_SETUP_SCRIPT_ID) {
			stateStore.setDashboardEnabled(false);
			interfaceManager.close();
			baseMenuHeight = -1;
			return;
		}

		if (scriptId != DRAW_BURGER_MENU_SCRIPT_ID) {
			return;
		}

		Object[] args = event.getScriptEvent().getArguments();
		int menuId = (int) args[3];
		if (menuId != COLLECTION_LOG_BURGER_MENU_WIDGET_ID) {
			return;
		}

		try {
			addButton(menuId);
		} catch (Exception e) {
			log.warn("Failed to add task dashboard button to menu: {}", e.getMessage());
		}
	}

	private void restyleOptions() {
		if (ourBackground == null || ourText == null) {
			return;
		}

		boolean selected = stateStore.isDashboardEnabled();
		Widget selectedBackground = selected ? ourBackground : firstBackground;
		Widget selectedText = selected ? ourText : firstText;
		Widget defaultBackground = selected ? firstBackground : ourBackground;
		Widget defaultText = selected ? firstText : ourText;

		selectedBackground.setOpacity(BG_OPACITY_SELECTED);
		selectedText.setOpacity(TEXT_OPACITY_SELECTED)
			.setTextColor(TEXT_COLOR_SELECTED);

		defaultBackground.setOpacity(BG_OPACITY);
		defaultText.setOpacity(TEXT_OPACITY)
			.setTextColor(TEXT_COLOR);

		selectedBackground.revalidate();
		selectedText.revalidate();
		defaultBackground.revalidate();
		defaultText.revalidate();
	}

	private void addButton(int menuId) throws NullPointerException, NoSuchElementException {
		Widget menu = Objects.requireNonNull(client.getWidget(menuId));
		List<Widget> menuChildren = Arrays.asList(Objects.requireNonNull(menu.getChildren()));
		if (baseMenuHeight == -1) {
			baseMenuHeight = menu.getOriginalHeight();
		}

		setupFirstWidgets(menuChildren);
		List<Widget> reversedMenuChildren = new ArrayList<>(menuChildren);
		Collections.reverse(reversedMenuChildren);
		Widget lastBackground = getFirstWidgetOfType(reversedMenuChildren, WidgetType.RECTANGLE);
		Widget lastText = getFirstWidgetOfType(reversedMenuChildren, WidgetType.TEXT);

		final int buttonHeight = lastBackground.getHeight();
		final int buttonY = lastBackground.getOriginalY() + buttonHeight;

		final boolean existingButton = menuChildren.stream()
			.anyMatch(w -> w.getText().equals(BUTTON_TEXT));

		if (!existingButton) {
			this.menu = menu;

			ourBackground = menu.createChild(WidgetType.RECTANGLE)
				.setOriginalWidth(lastBackground.getOriginalWidth())
				.setOriginalHeight(lastBackground.getOriginalHeight())
				.setOriginalX(lastBackground.getOriginalX())
				.setOriginalY(buttonY)
				.setOpacity(lastBackground.getOpacity())
				.setFilled(lastBackground.isFilled())
				.setTextColor(lastBackground.getTextColor());
			ourBackground.revalidate();

			ourText = menu.createChild(WidgetType.TEXT)
				.setText(BUTTON_TEXT)
				.setTextColor(TEXT_COLOR)
				.setFontId(lastText.getFontId())
				.setTextShadowed(lastText.getTextShadowed())
				.setOriginalWidth(lastText.getOriginalWidth())
				.setOriginalHeight(lastText.getOriginalHeight())
				.setOriginalX(lastText.getOriginalX())
				.setOriginalY(buttonY)
				.setXTextAlignment(lastText.getXTextAlignment())
				.setYTextAlignment(lastText.getYTextAlignment());
			ourText.setHasListener(true);
			ourText.setOnMouseOverListener((JavaScriptCallback) ev -> {
				if (!stateStore.isDashboardEnabled()) {
					ourText.setTextColor(TEXT_COLOR_HOVER);
				}
			});
			ourText.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
				if (!stateStore.isDashboardEnabled()) {
					ourText.setTextColor(TEXT_COLOR);
				}
			});
			ourText.setAction(0, ACTION_TEXT);
			ourText.setOnOpListener((JavaScriptCallback) ev -> {
				stateStore.setDashboardEnabled(true);
				interfaceManager.openMainContainer();
				hideMenu();
			});
			ourText.revalidate();
		}

		if (menu.getOriginalHeight() <= baseMenuHeight) {
			menu.setOriginalHeight((menu.getOriginalHeight() + buttonHeight));
		}

		restyleOptions();
		menu.revalidate();
		for (Widget child : menuChildren) {
			child.revalidate();
		}
	}

	private void setupFirstWidgets(List<Widget> menuChildren) {
		firstBackground = getFirstWidgetOfType(menuChildren, WidgetType.RECTANGLE);
		firstText = getFirstWidgetOfType(menuChildren, WidgetType.TEXT);

		firstText.setHasListener(true);
		firstText.setOnMouseOverListener((JavaScriptCallback) ev -> {
			if (stateStore.isDashboardEnabled()) {
				firstText.setTextColor(TEXT_COLOR_HOVER);
			}
		});
		firstText.setOnMouseLeaveListener((JavaScriptCallback) ev -> {
			if (stateStore.isDashboardEnabled()) {
				firstText.setTextColor(TEXT_COLOR);
			}
		});
		firstText.setAction(0, firstText.getText());
		firstText.setOnOpListener((JavaScriptCallback) ev -> {
			stateStore.setDashboardEnabled(false);
			interfaceManager.close();
			hideMenu();
		});
	}

	private void hideMenu() {
		if (menu != null) {
			menu.setHidden(true)
				.revalidate();
		}

		Widget burgerMenuOverlay = client.getWidget(40697874);
		if (burgerMenuOverlay != null) {
			burgerMenuOverlay.setHidden(true)
				.revalidate();
		}
	}

	private static Widget getFirstWidgetOfType(
		List<Widget> menuChildren,
		@MagicConstant(valuesFromClass = WidgetType.class) int widgetType
	) {
		return menuChildren.stream()
			.filter(w -> w.getType() == widgetType)
			.findFirst()
			.orElseThrow(() -> new NoSuchElementException("No widget of type" + widgetType + " found in menu"));
	}
}
package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.verification.Verification;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.domain.verification.diary.AchievementDiaryVerification;
import com.collectionlogmaster.domain.verification.diary.DiaryDifficulty;
import com.collectionlogmaster.domain.verification.diary.DiaryRegion;
import com.collectionlogmaster.domain.verification.skill.SkillVerification;
import com.collectionlogmaster.synchronization.clog.CollectionLogService;
import com.collectionlogmaster.synchronization.diary.AchievementDiaryService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.generic.UIComponent;
import com.collectionlogmaster.ui.generic.UIGridContainer;
import com.collectionlogmaster.ui.generic.UIProgressBar;
import com.collectionlogmaster.ui.generic.UIScrollableContainer;
import com.collectionlogmaster.ui.generic.UIUtil;
import com.collectionlogmaster.ui.generic.button.UISimpleButton;
import com.collectionlogmaster.ui.generic.button.UITextButton;
import com.google.inject.Inject;
import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.FontID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.ItemQuantityMode;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.LinkBrowser;
import org.apache.commons.lang3.tuple.Pair;

@Slf4j
public class TaskInfo extends UIComponent<TaskInfo> {
	private static final int TITLE_HEIGHT = 24;
	private static final int BASE_GAP = 4;
	public static final int PROGRESS_BAR_HEIGHT = 24;
	public static final int BUTTON_HEIGHT = 30;
	public static final int BUTTON_WIDTH = 140;

	private final Widget background;
	private final Widget titleText;
	private final UISimpleButton backButton;
	private final UISimpleButton wikiButton;
	private final Widget divider;
	private final Widget tipText;
	private final UIProgressBar progressBar;
	private final UIScrollableContainer scrollableContainer;
	private final UIGridContainer itemGrid;
	private final UITextButton markButton;

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	@Inject
	private TaskService taskService;

	@Inject
	private CollectionLogService collectionLogService;

	@Inject
	private AchievementDiaryService achievementDiaryService;

	private final @NonNull Task task;

	@Getter
	private final CompletableFuture<Void> closeFuture;

	public static TaskInfo openInside(Widget window, @NonNull Task task) {
		return new TaskInfo(window.createChild(WidgetType.LAYER), task);
	}

	private TaskInfo(Widget widget, @NonNull Task task) {
		super(widget, WidgetType.LAYER);
		CollectionLogMasterPlugin.getStaticInjector().injectMembers(this);

		closeFuture = new CompletableFuture<>();
		this.task = task;

		background = widget.createChild(WidgetType.GRAPHIC);
		titleText = widget.createChild(WidgetType.TEXT);
		backButton = UISimpleButton.createInside(widget);
		wikiButton = UISimpleButton.createInside(widget);
		divider = widget.createChild(WidgetType.RECTANGLE);
		tipText = widget.createChild(WidgetType.TEXT);
		progressBar = UIProgressBar.createInside(widget);
		scrollableContainer = UIScrollableContainer.createInside(widget);
		itemGrid = new UIGridContainer(scrollableContainer.getContent());
		markButton = UITextButton.createInside(widget);

		initializeWidgets();
	}

	public void close() {
		// we're only "leaking" the parent LAYER widget
		widget.setHidden(true)
			.deleteAllChildren();

		unregister();

		closeFuture.complete(null);
	}

	private Pair<@NonNull Float, @NonNull String> getProgressData(Verification verif) {
		if (verif == null) {
			return null;
		}

		if (verif.isCollectionLog()) {
			return getProgressData(verif.asCollectionLog());
		}

		if (verif.isAchievementDiary()) {
			return getProgressData(verif.asAchievementDiary());
		}

		if (verif.isSkill()) {
			return getProgressData(verif.asSkill());
		}

		return null;
	}

	private Pair<@NonNull Float, @NonNull String> getProgressData(CollectionLogVerification verif) {
		int totalCount = verif.getCount();
		long obtainedCount = Arrays.stream(verif.getItemIds())
			.filter(itemId -> collectionLogService.isItemObtained(itemId))
			.count();

		return Pair.of(
			Math.min(1, (float) obtainedCount / totalCount),
			String.format("Obtained %d/%d required items", obtainedCount, totalCount)
		);
	}

	private Pair<@NonNull Float, @NonNull String> getProgressData(AchievementDiaryVerification verif) {
		DiaryRegion region = verif.getRegion();
		DiaryDifficulty difficulty = verif.getDifficulty();
		int totalCount = achievementDiaryService.getTotalTaskCount(region, difficulty);
		int completedCount = achievementDiaryService.getCompleteTaskCount(region, difficulty);

		return Pair.of(
			(float) completedCount / totalCount,
			String.format("Completed %d/%d required tasks", completedCount, totalCount)
		);
	}

	private Pair<@NonNull Float, @NonNull String> getProgressData(SkillVerification verif) {
		int totalCount = verif.getCount();
		long achievedCount = verif.getExperience().entrySet().stream()
			.filter(entry -> entry.getKey() != null)
			.filter(entry -> client.getSkillExperience(entry.getKey()) > entry.getValue())
			.count();

		return Pair.of(
			(float) achievedCount / totalCount,
			String.format("Achieved in %d/%d required skills", achievedCount, totalCount)
		);
	}


	private void initializeWidgets() {
		widget.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.revalidate();

		background.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setSpriteId(SpriteID.TRADEBACKING)
			.setSpriteTiling(true)
			.revalidate();

		titleText.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(0, TITLE_HEIGHT)
			.setLineHeight(TITLE_HEIGHT)
			.setXTextAlignment(WidgetTextAlignment.CENTER)
			.setYTextAlignment(WidgetTextAlignment.CENTER)
			.setFontId(FontID.BOLD_12)
			.setTextShadowed(true)
			.setTextColor(0xFFFFFF)
			.setText(task.getName())
			.revalidate();

		backButton.setPos(BASE_GAP / 2, BASE_GAP / 2)
			.setSize(40, titleText.getHeight() - BASE_GAP)
			.setIconSpriteTheme(SpriteID.CloseArrows._0, SpriteID.CloseArrows._1, SpriteID.CloseArrows._0)
			.setIconSize(13, 11)
			.setFontId(FontID.PLAIN_11)
			.setText("Back")
			.setAction("Go back", this::close)
			.revalidate();

		wikiButton
			.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT)
			.setPos(BASE_GAP / 2, BASE_GAP / 2)
			.setSize(40, titleText.getHeight() - BASE_GAP)
			.setIconSpriteTheme(SpriteID.WikiIcon.DESELECTED, SpriteID.WikiIcon.SELECTED, SpriteID.WikiIcon.DESELECTED)
			.setIconSize(40, 14)
			.setFontId(FontID.PLAIN_11)
			.setText("")
			.setAction("Wiki", () -> LinkBrowser.browse(task.getWikiLink()))
			.revalidate();

		divider.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, titleText.getRelativeY() + titleText.getHeight())
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(BASE_GAP * 2, 1)
			.setTextColor(0x606060)
			.revalidate();

		String tip = task.getTip();
		if (tip == null || tip.isBlank()) {
			tipText.setHidden(true)
				.revalidate();
		} else {
			tipText.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
				.setPos(0, divider.getRelativeY() + divider.getHeight() + BASE_GAP)
				.setWidthMode(WidgetSizeMode.MINUS)
				.setOriginalWidth(BASE_GAP * 2)
				.setXTextAlignment(WidgetTextAlignment.CENTER)
				.setYTextAlignment(WidgetTextAlignment.CENTER)
				.setFontId(FontID.PLAIN_11)
				.setTextColor(0xFFFFFF)
				.setText(tip)
				.revalidate();

			// we need to revalidate before setting the height because
			// we require the widget's width to be up to date
			tipText.setOriginalHeight(UIUtil.getTextHeight(tip, tipText))
				.revalidate();
		}

		Widget prev = tipText.isHidden() ? divider : tipText;
		progressBar.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, prev.getOriginalY() + prev.getHeight() + BASE_GAP)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setSize(BASE_GAP, PROGRESS_BAR_HEIGHT)
			.revalidate();

		int gridOriginalY = progressBar.getOriginalY() + progressBar.getHeight() + BASE_GAP;
		scrollableContainer.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setPos(0, gridOriginalY)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(BASE_GAP, gridOriginalY + BASE_GAP)
			.setScrollBuffer(BUTTON_HEIGHT + (BASE_GAP * 2))
			.setDrawScrollbar(true)
			.revalidate();

		Pair<Float, String> progressData = getProgressData(task.getVerification());
		if (progressData == null) {
			progressBar.setHidden(true)
				.revalidate();
		} else {
			progressBar.setPercent(progressData.getLeft())
				.setText(progressData.getRight())
				.revalidate();
		}

		initializeItems();

		itemGrid.setPos(0, 0)
			.revalidate();

		scrollableContainer.revalidate();

		markButton.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER)
			.setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)
			.setPos(0, BASE_GAP)
			.setSize(BUTTON_WIDTH, BUTTON_HEIGHT)
			.setFont(FontID.BOLD_12)
			.setText("Mark Complete")
			.setAction("Mark", () -> {
				taskService.toggleComplete(task.getId());
				revalidate();
			})
			.revalidate();
	}

	private void initializeItems() {
		// TODO: handle diary by listing individual tasks and skill by listing skills
		if (!(task.getVerification() instanceof CollectionLogVerification)) {
			return;
		}

		CollectionLogVerification verif = task.getVerification().asCollectionLog();
		for (int itemId : verif.getItemIds()) {
			String itemName = itemManager.getItemComposition(itemId).getMembersName();
			boolean itemObtained = collectionLogService.isItemObtained(itemId);

			Widget w = itemGrid.createItem(WidgetType.GRAPHIC)
				.setName(UIUtil.formatName(itemName))
				.setSize(36, 36)
				.setOpacity(itemObtained ? 0 : 175)
				.setItemQuantityMode(ItemQuantityMode.NEVER)
				.setItemQuantity(1000)
				.setItemId(itemId);

			w.setHasListener(true);
			w.setOnOpListener((JavaScriptCallback) e -> UIUtil.openWikiLink(itemName));
			w.setAction(0, "Wiki");
			w.setBorderType(1);
			w.revalidate();
		}

		itemGrid.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();
		titleText.revalidate();
		backButton.revalidate();
		wikiButton.revalidate();
		tipText.revalidate();
		progressBar.revalidate();
		scrollableContainer.revalidate();
		itemGrid.revalidate();

		if (taskService.isComplete(task.getId())) {
			markButton.setText("Mark Incomplete")
				.revalidate();
		} else {
			markButton.setText("Mark Complete")
				.revalidate();
		}
	}

	@Override
	public void unregister() {
		scrollableContainer.unregister();
	}
}

package com.collectionlogmaster.ui.component;

import com.collectionlogmaster.CollectionLogMasterPlugin;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.generic.BorderTheme;
import com.collectionlogmaster.ui.generic.UIComponent;
import com.collectionlogmaster.ui.generic.UIGridContainer;
import com.collectionlogmaster.ui.generic.UIScrollableContainer;
import com.google.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetType;


@Slf4j
public class TaskList extends UIComponent<TaskList> {
	public static final int TASK_COMPONENT_WIDTH = 300;
	public static final int TASK_COMPONENT_HEIGHT = 50;
	public static final int TASK_COMPONENT_PADDING = 5;

	@Inject
	private TaskService taskService;

	private final Widget background;
	private final UIScrollableContainer scrollableContainer;
	private final UIGridContainer taskGrid;

	private final List<@NonNull Task> tasks;

	private final List<TaskComponent> taskComponents = new ArrayList<>();

	public static TaskList createInside(Widget window, List<@NonNull Task> tasks) {
		return new TaskList(window.createChild(WidgetType.LAYER), tasks);
	}

	private TaskList(Widget widget, List<@NonNull Task> tasks) {
		super(widget, WidgetType.LAYER);
		CollectionLogMasterPlugin.getStaticInjector().injectMembers(this);

		this.tasks = tasks;

		background = widget.createChild(WidgetType.GRAPHIC);
		scrollableContainer = UIScrollableContainer.createInside(widget);
		taskGrid = new UIGridContainer(scrollableContainer.getContent());

		initializeWidgets();
	}

	private void initializeWidgets() {
		widget.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.revalidate();

		background.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setSpriteId(SpriteID.TRADEBACKING)
			.setSpriteTiling(true)
			.revalidate();

		scrollableContainer.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setHeightMode(WidgetSizeMode.MINUS)
			.setSize(0, 0)
			.setDrawScrollbar(true)
			.revalidate();

		taskGrid.setPos(0, 0)
			.setWidthMode(WidgetSizeMode.MINUS)
			.setOriginalWidth(0)
			.revalidate();

		for (Task task : tasks) {
			TaskComponent taskComponent = new TaskComponent(taskGrid.createItem(WidgetType.LAYER))
				.setPaddingSize(TASK_COMPONENT_PADDING)
				.setSize(TASK_COMPONENT_WIDTH, TASK_COMPONENT_HEIGHT)
				.setTask(task);

			taskComponent.revalidate();
			taskComponents.add(taskComponent);
		}

		taskGrid.revalidate();
	}

	@Override
	public void revalidate() {
		super.revalidate();
		scrollableContainer.revalidate();
		taskGrid.revalidate();

		Task activeTask = taskService.getActiveTask();
		for (TaskComponent taskComponent : taskComponents) {
			Task task = taskComponent.getTask();

			boolean isActive = task.equals(activeTask);
			if (isActive) {
				taskComponent.setOpacity(0)
					.setTheme(BorderTheme.ETCHED_GOLD_DYED)
					.revalidate();

				continue;
			}

			boolean isComplete = taskService.isComplete(task.getId());
			if (isComplete) {
				taskComponent.setOpacity(0)
					.setTheme(BorderTheme.ETCHED_GREEN_DYED)
					.revalidate();

				continue;
			}

			taskComponent.setOpacity(125)
				.setTheme(BorderTheme.ETCHED)
				.revalidate();
		}
	}

	@Override
	public void unregister() {
		scrollableContainer.unregister();
	}
}

package com.collectionlogmaster.ui.sprites;

import com.collectionlogmaster.util.EventBusSubscriber;
import java.awt.Color;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SpritePixels;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

@Slf4j
@Singleton
public class SpriteManager extends EventBusSubscriber {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private net.runelite.client.game.SpriteManager spriteManager;

	public void startUp() {
		this.spriteManager.addSpriteOverrides(SpriteOverride.values());
		clientThread.invokeAtTickEnd(this::overrideTransformedSprites);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e) {
		String configGroup = e.getGroup();
		if (configGroup.equals("resourcepacks")) {
			clientThread.invokeAtTickEnd(this::overrideTransformedSprites);
		}
	}

	private void overrideTransformedSprites() {
		for (SpriteOverride spriteOverride : SpriteOverride.values()) {
			if (spriteOverride.getOriginalSpriteId() == null) {
				continue;
			}

			if (spriteOverride.getTransform() == SpriteOverride.Transform.VFLIP) {
				addSpriteOverride(
					spriteOverride.getSpriteId(),
					getVFlippedSpritePixels(spriteOverride.getOriginalSpriteId())
				);

				continue;
			}

			if (spriteOverride.getDye() != null) {
				addSpriteOverride(
					spriteOverride.getSpriteId(),
					getDyedSpritePixels(spriteOverride.getOriginalSpriteId(), spriteOverride.getDye())
				);
			}
		}
	}

	private void addSpriteOverride(int spriteId, SpritePixels spritePixels) {
		// we can't use SpriteManager because it only accepts resource paths as input
		client.getSpriteOverrides().put(spriteId, spritePixels);
	}

	public SpritePixels getDyedSpritePixels(int spriteId, Color dye) {
		SpritePixels sp = getSpritePixels(spriteId);
		if (sp == null) {
			return null;
		}

		float dyeAlpha = dye.getAlpha() / 255f;
		int dyeRed = (int) (dye.getRed() * dyeAlpha);
		int dyeGreen = (int) (dye.getGreen() * dyeAlpha);
		int dyeBlue = (int) (dye.getBlue() * dyeAlpha);

		int[] originalPixels = sp.getPixels();
		int[] dyedPixels = new int[originalPixels.length];
		for (int i = 0; i < originalPixels.length; i++) {
			int originalPixel = originalPixels[i];

			// skip transparent pixels
			if (originalPixel == 0) {
				dyedPixels[i] = 0;
				continue;
			}

			Color originalColor = new Color(originalPixel);
			int finalRed = dyeRed + (int) (originalColor.getRed() * (1 - dyeAlpha));
			int finalGreen = dyeGreen + (int) (originalColor.getGreen() * (1 - dyeAlpha));
			int finalBlue = dyeBlue + (int) (originalColor.getBlue() * (1 - dyeAlpha));

			dyedPixels[i] = new Color(finalRed, finalGreen, finalBlue, 255 - originalColor.getAlpha()).getRGB();
		}

		return client.createSpritePixels(dyedPixels, sp.getWidth(), sp.getHeight());
	}

	public SpritePixels getVFlippedSpritePixels(int spriteId) {
		SpritePixels sp = getSpritePixels(spriteId);
		if (sp == null) {
			return null;
		}

		int[] originalPixels = sp.getPixels();
		int[] flippedPixels = new int[originalPixels.length];
		for (int i = 0; i < sp.getHeight(); i++) {
			int baseOffset = i * sp.getWidth();
			for (int j = 0; j < sp.getWidth(); j++) {
				flippedPixels[baseOffset + j] = originalPixels[baseOffset + sp.getWidth() - j - 1];
			}
		}

		return client.createSpritePixels(flippedPixels, sp.getWidth(), sp.getHeight());
	}

	private @Nullable SpritePixels getSpritePixels(int spriteId) {
		// we check overrides first so that in case another plugin (such as
		// resource packs) has overridden the sprite we still get the correct one
		SpritePixels sp = client.getSpriteOverrides().get(spriteId);
		if (sp != null) {
			return sp;
		}

		SpritePixels[] allSp = client.getSprites(client.getIndexSprites(), spriteId, 0);
		if (allSp == null || allSp.length < 1 || allSp[0] == null) {
			log.warn("Unable to find sprite for id {}", spriteId);
			return null;
		}

		return allSp[0];
	}
}

package com.collectionlogmaster.ui.sprites;

import java.awt.Color;
import javax.annotation.Nullable;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.gameval.SpriteID;

@Getter
public enum SpriteOverride implements net.runelite.client.game.SpriteOverride {
	// we'll override these later by processing the original sprite on the fly
	TALL_TABS_CORNER_VFLIP(SpriteID.TabsTall._2, Transform.VFLIP),
	TALL_TABS_CORNER_HOVER_VFLIP(SpriteID.TabsTall._0, Transform.VFLIP),

	SETTINGS_TAB_BACKGROUND_GREEN_DYED(SpriteID.SettingsTabs._16, Dyes.GREEN),
	TABS_ETCHED_TOP_LEFT_CORNER_GREEN_DYED(SpriteID.TabsEtchedCorner._0, Dyes.GREEN),
	TABS_ETCHED_TOP_RIGHT_CORNER_GREEN_DYED(SpriteID.TabsEtchedCorner._1, Dyes.GREEN),
	TABS_ETCHED_BOTTOM_LEFT_CORNER_GREEN_DYED(SpriteID.TabsEtchedCorner._2, Dyes.GREEN),
	TABS_ETCHED_BOTTOM_RIGHT_CORNER_GREEN_DYED(SpriteID.TabsEtchedCorner._3, Dyes.GREEN),
	SETTINGS_TAB_LEFT_EDGE_GREEN_DYED(SpriteID.SettingsTabs._14, Dyes.GREEN),
	SETTINGS_TAB_TOP_EDGE_GREEN_DYED(SpriteID.SettingsTabs._12, Dyes.GREEN),
	SETTINGS_TAB_RIGHT_EDGE_GREEN_DYED(SpriteID.SettingsTabs._15, Dyes.GREEN),
	SETTINGS_TAB_BOTTOM_EDGE_GREEN_DYED(SpriteID.SettingsTabs._13, Dyes.GREEN),

	SETTINGS_TAB_BACKGROUND_GOLD_DYED(SpriteID.SettingsTabs._16, Dyes.GOLD),
	TABS_ETCHED_TOP_LEFT_CORNER_GOLD_DYED(SpriteID.TabsEtchedCorner._0, Dyes.GOLD),
	TABS_ETCHED_TOP_RIGHT_CORNER_GOLD_DYED(SpriteID.TabsEtchedCorner._1, Dyes.GOLD),
	TABS_ETCHED_BOTTOM_LEFT_CORNER_GOLD_DYED(SpriteID.TabsEtchedCorner._2, Dyes.GOLD),
	TABS_ETCHED_BOTTOM_RIGHT_CORNER_GOLD_DYED(SpriteID.TabsEtchedCorner._3, Dyes.GOLD),
	SETTINGS_TAB_LEFT_EDGE_GOLD_DYED(SpriteID.SettingsTabs._14, Dyes.GOLD),
	SETTINGS_TAB_TOP_EDGE_GOLD_DYED(SpriteID.SettingsTabs._12, Dyes.GOLD),
	SETTINGS_TAB_RIGHT_EDGE_GOLD_DYED(SpriteID.SettingsTabs._15, Dyes.GOLD),
	SETTINGS_TAB_BOTTOM_EDGE_GOLD_DYED(SpriteID.SettingsTabs._13, Dyes.GOLD);

	// we put `lastSpriteId` into a nested static class to force the
	// JVM into initializing it before calling the enum constructor
	private static class Memory {
		private static int lastSpriteId = -20000;
	}

	private static class Dyes {
		public static final Color GREEN = new Color(0, 255, 0, 25);
		public static final Color GOLD = new Color(255, 215, 0, 25);
	}

	public enum Transform {
		VFLIP;
	}

	private final int spriteId;

	private String fileName;

	private @Nullable Integer originalSpriteId = null;

	private @Nullable Color dye = null;
	private @Nullable Transform transform = null;

	SpriteOverride() {
		// we don't really care what the ID is, as long as it's
		// not repeated and we can reference it from the enum
		this.spriteId = --Memory.lastSpriteId;
		this.fileName = "transparent.png";
	}

	SpriteOverride(String fileName) {
		this();
		this.fileName = fileName;
	}

	SpriteOverride(int originalSpriteId, @NonNull Color dye) {
		this();
		this.originalSpriteId = originalSpriteId;
		this.dye = dye;
	}

	SpriteOverride(int originalSpriteId, @NonNull Transform transform) {
		this();
		this.originalSpriteId = originalSpriteId;
		this.transform = transform;
	}
}

package com.collectionlogmaster.ui;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.state.StateStore;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Image;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;

@Singleton
@Slf4j
public class TaskOverlay extends Overlay {
	private static final Dimension EMPTY = new Dimension(0, 0);

	private static final int WIDTH_ADDITION = 51;
	private static final int MIN_HEIGHT = 46;

	private static final float OUTER_COLOR_OFFSET = 0.8f;
	private static final float INNER_COLOR_OFFSET = 1.2f;
	private static final float ALPHA_OFFSET = 1.4f;

	private static final int MAX_BYTE = 255;

	@Inject
	private CollectionLogMasterConfig config;

	@Inject
	private RuneLiteConfig runeLiteConfig;

	@Inject
	private ItemManager itemManager;

	@Inject
	private StateStore stateStore;

	@Inject
	private TaskService taskService;

	@Override
	public Dimension render(Graphics2D g) {
		try {
			Task activeTask = taskService.getActiveTask();
			if (!config.displayCurrentTaskOverlay() || activeTask == null || stateStore.isDashboardEnabled()) {
				return EMPTY;
			}

			Image icon = itemManager.getImage(activeTask.getDisplayItemId());
			String task = activeTask.getName();


			FontMetrics fm = g.getFontMetrics();

			int width = fm.stringWidth(task) + WIDTH_ADDITION;
			int height = MIN_HEIGHT;

			Color border = outsideColor(this.runeLiteConfig.overlayBackgroundColor());

			g.setColor(this.runeLiteConfig.overlayBackgroundColor());
			g.fillRect(0, 0, width, height);
			g.setColor(border);
			g.drawRect(0, 0, width, height);

//            int textX = 46;
			int textX = width - fm.stringWidth(task) - 5;
			int textY = 30;

			g.setFont(g.getFont().deriveFont(16f));
			g.setColor(Color.BLACK);
			g.drawString(task, textX + 1, textY + 1);
			g.setColor(Color.WHITE);
			g.drawString(task, textX, textY);

			int iconWidth = icon.getWidth(null);
			int iconHeight = icon.getHeight(null);

			g.drawImage(icon, 5 + 18 - (iconWidth / 2), 5 + 18 - (iconHeight / 2), iconWidth, iconHeight, null);
			return new Dimension(width, height);
		} catch (Throwable t) {
			log.warn("", new RuntimeException("Failed to render overlay"));
			return EMPTY;
		}
	}

	private Color outsideColor(Color base) {
		return new Color(
				Math.round(base.getRed() * OUTER_COLOR_OFFSET),
				Math.round(base.getGreen() * OUTER_COLOR_OFFSET),
				Math.round(base.getBlue() * OUTER_COLOR_OFFSET),
				Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
		);
	}

	private Color innerColor(Color base) {
		return new Color(
				Math.min(MAX_BYTE, Math.round(base.getRed() * INNER_COLOR_OFFSET)),
				Math.min(MAX_BYTE, Math.round(base.getGreen() * INNER_COLOR_OFFSET)),
				Math.min(MAX_BYTE, Math.round(base.getBlue() * INNER_COLOR_OFFSET)),
				Math.min(MAX_BYTE, Math.round(base.getAlpha() * ALPHA_OFFSET))
		);
	}
}

package com.collectionlogmaster.ui.state;

import lombok.Value;

@Value
public class StateChanged {
}

package com.collectionlogmaster.ui.state;

import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import net.runelite.client.eventbus.EventBus;

@Singleton
public class StateStore {
	@Inject
	private EventBus eventBus;

	@Getter
	private boolean dashboardEnabled = false;

	// TODO: maybe add some sort of key to event so subscribers
	//  can more selectively decide how/when to react
	private void postEvent() {
		eventBus.post(new StateChanged());
	}

	public void setDashboardEnabled(boolean enabled) {
		dashboardEnabled = enabled;
		postEvent();
	}
}

package com.collectionlogmaster.ui;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.ui.component.MainTabbedContainer;
import com.collectionlogmaster.ui.component.MenuManager;
import com.collectionlogmaster.ui.component.TaskInfo;
import com.collectionlogmaster.ui.sprites.SpriteManager;
import com.collectionlogmaster.util.EventBusSubscriber;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.Subscribe;
import org.jetbrains.annotations.Nullable;

@Slf4j
@Singleton
public class InterfaceManager extends EventBusSubscriber {
	public static final int COLLECTION_LOG_SETUP_SCRIPT_ID = 7797;
	public static final int COLLECTION_LOG_OVERVIEW_SCRIPT_ID = 2388;

	@Inject
	private Client client;

	@Inject
	private SpriteManager spriteManager;

	@Inject
	private MenuManager menuManager;

	private MainTabbedContainer container = null;

	private TaskInfo taskInfo = null;

	public void startUp() {
		super.startUp();
		menuManager.startUp();
		spriteManager.startUp();
	}

	public void shutDown() {
		super.shutDown();
		menuManager.shutDown();
		spriteManager.shutDown();
	}

	@Subscribe
	public void onScriptPreFired(ScriptPreFired event) {
		int scriptId = event.getScriptId();
		if (scriptId != COLLECTION_LOG_SETUP_SCRIPT_ID && scriptId != COLLECTION_LOG_OVERVIEW_SCRIPT_ID) {
			return;
		}

		close();
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded e) {
		if (e.getGroupId() != InterfaceID.COLLECTION) {
			return;
		}

		close();
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed e) {
		if (e.getGroupId() != InterfaceID.COLLECTION) {
			return;
		}

		close();
	}

	public void hideCollectionLogContent(boolean hidden) {
		Widget window = getContentWidget();
		if (window == null) {
			return;
		}

		for (Widget w : window.getStaticChildren()) {
			if (w.getId() == InterfaceID.Collection.BURGER_MENU_OVERLAY) {
				continue;
			}

			w.setHidden(hidden)
				.revalidate();
		}
	}

	public void openMainContainer() {
		Widget content = getContentWidget();
		if (content == null) {
			return;
		}

		hideCollectionLogContent(true);

		if (container != null) {
			container.unregister();
		}

		container = MainTabbedContainer.createInside(content);
		container.revalidate();
	}

	public void openTaskInfo(Task task) {
		Widget content = getContentWidget();
		if (content == null) {
			return;
		}

		container.setHidden(true)
			.revalidate();

		taskInfo = TaskInfo.openInside(content, task);
		taskInfo.revalidate();
		taskInfo.getCloseFuture()
			.thenAccept((r) -> {
				taskInfo = null;
				container.setHidden(false)
					.revalidate();
			});
	}

	private @Nullable Widget getContentWidget() {
		return client.getWidget(InterfaceID.Collection.CONTENT);
	}

	public void close() {
		hideCollectionLogContent(false);

		if (container != null) {
			container.setHidden(true)
				.revalidate();
			container.unregister();
		}
		container = null;

		if (taskInfo != null) {
			taskInfo.close();
		}
		taskInfo = null;
	}
}

package com.collectionlogmaster;

import com.collectionlogmaster.command.DevCommandsManager;
import com.collectionlogmaster.command.TaskmanCommandManager;
import com.collectionlogmaster.input.MouseManager;
import com.collectionlogmaster.synchronization.clog.CollectionLogService;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.ui.InterfaceManager;
import com.collectionlogmaster.ui.TaskOverlay;
import com.collectionlogmaster.util.GsonOverride;
import com.google.inject.Injector;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
		name = "Collection Log Master",
		conflicts = {"[DEPRECATED] Collection Log Master"})
public class CollectionLogMasterPlugin extends Plugin {
	@Inject
	@SuppressWarnings("unused")
	private GsonOverride gsonOverride;

	@Getter
	private static Injector staticInjector;

	@Inject
	protected TaskOverlay taskOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private InterfaceManager interfaceManager;

	@Inject
	public CollectionLogService collectionLogService;

	@Inject
	public PluginUpdateNotifier pluginUpdateNotifier;

	@Inject
	public TaskService taskService;

	@Inject
	public TaskmanCommandManager taskmanCommand;

	@Inject
	public DevCommandsManager devCommands;

	@Override
	protected void startUp() {
		CollectionLogMasterPlugin.staticInjector = getInjector();

		mouseManager.startUp();
		taskService.startUp();
		collectionLogService.startUp();
		pluginUpdateNotifier.startUp();
		interfaceManager.startUp();
		taskmanCommand.startUp();
		devCommands.startUp();
		this.taskOverlay.setResizable(true);
		this.overlayManager.add(this.taskOverlay);
	}

	@Override
	protected void shutDown() {
		mouseManager.shutDown();
		taskService.shutDown();
		collectionLogService.shutDown();
		pluginUpdateNotifier.shutDown();
		interfaceManager.shutDown();
		taskmanCommand.shutDown();
		devCommands.shutDown();
		this.overlayManager.remove(this.taskOverlay);
	}

	@Provides
	CollectionLogMasterConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(CollectionLogMasterConfig.class);
	}
}

package com.collectionlogmaster.domain;

public enum DynamicTaskImages {
  NONE,
  INCOMPLETE,
  COMPLETE,
  ALL
}

package com.collectionlogmaster.domain;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.Data;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Set;

@Data
public class Task {
    private String id;
    private String name;
    private String tip;
    private String wikiLink;
    private int displayItemId;
    private Set<Tag> tags;

    private @Nullable Verification verification;

    public Set<Tag> getTags() {
        if (tags == null) {
            tags = new HashSet<>();
        }

        return tags;
    }
}

package com.collectionlogmaster.domain;

public enum Tag {
    LMS;
}

package com.collectionlogmaster.domain.command;

import lombok.Data;

@Data
public class CommandResponse {
    private CommandTask task;
    private String tier;
    private int progressPercentage;
}

package com.collectionlogmaster.domain.command;

import lombok.Data;

@Data
public class CommandTask {
    private String name;
    private String imageUrl;
}

package com.collectionlogmaster.domain.command;

import lombok.Data;
import lombok.RequiredArgsConstructor;

@Data
@RequiredArgsConstructor
public class CommandRequest {
    private final String taskId;
    private final String tier;
    private final int progressPercentage;
}

package com.collectionlogmaster.domain.verification.diary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum DiaryRegion {
    KARAMJA(0),
    ARDOUGNE(1),
    FALADOR(2),
    FREMENNIK(3),
    KANDARIN(4),
    DESERT(5),
    LUMBRIDGE_AND_DRAYNOR(6),
    MORYTANIA(7),
    VARROCK(8),
    WILDERNESS(9),
    WESTERN_PROVINCES(10),
    KOUREND_AND_KEBOS(11);

    private final int id;
}

package com.collectionlogmaster.domain.verification.diary;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class AchievementDiaryVerification extends Verification {
    private @NonNull DiaryRegion region;
    private @NonNull DiaryDifficulty difficulty;
}

package com.collectionlogmaster.domain.verification.diary;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Getter
@RequiredArgsConstructor
public enum DiaryDifficulty {
	EASY(0),
	MEDIUM(3),
	HARD(6),
	ELITE(9);

	private final int stackOffset;
}

package com.collectionlogmaster.domain.verification.clog;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class CollectionLogVerification extends Verification {
    private int @NonNull [] itemIds;
    private int count;
}

package com.collectionlogmaster.domain.verification;

public enum VerificationMethod {
    COLLECTION_LOG,
    ACHIEVEMENT_DIARY,
    SKILL;
}

package com.collectionlogmaster.domain.verification;

import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.domain.verification.diary.AchievementDiaryVerification;
import com.collectionlogmaster.domain.verification.skill.SkillVerification;
import lombok.Getter;

@Getter
public abstract class Verification {
	private VerificationMethod method;

	public boolean isCollectionLog() {
		return this instanceof CollectionLogVerification;
	}

	public boolean isAchievementDiary() {
		return this instanceof AchievementDiaryVerification;
	}

	public boolean isSkill() {
		return this instanceof SkillVerification;
	}

	public CollectionLogVerification asCollectionLog() {
		return (CollectionLogVerification) this;
	}

	public AchievementDiaryVerification asAchievementDiary() {
		return (AchievementDiaryVerification) this;
	}

	public SkillVerification asSkill() {
		return (SkillVerification) this;
	}
}

package com.collectionlogmaster.domain.verification.skill;

import com.collectionlogmaster.domain.verification.Verification;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import net.runelite.api.Skill;

import java.util.Map;

@Getter
@AllArgsConstructor
@NoArgsConstructor
public class SkillVerification extends Verification {
    private @NonNull Map<Skill, Integer> experience;
    private int count;
}

package com.collectionlogmaster.domain.savedata;

import lombok.Getter;
import lombok.ToString;

import javax.annotation.Nullable;

@ToString
@Getter
public class BaseSaveData {
    protected @Nullable Integer version = null;
}

package com.collectionlogmaster.domain.savedata.v0;

import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V0SaveData extends BaseSaveData {
    public final static Integer VERSION = null;

    public V0SaveData() {
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    private final Map<TaskTier, Set<Integer>> progress;

    @Setter
    private V0TaskPointer activeTaskPointer;

    @Setter
    private TaskTier selectedTier;
}

package com.collectionlogmaster.domain.savedata.v0;

import lombok.Getter;

@Getter
@Deprecated
public class V0Task {
    private int id;
    private String description;
    private int itemID;
}

package com.collectionlogmaster.domain.savedata.v0;

import com.collectionlogmaster.domain.TaskTier;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@Deprecated
public class V0TaskPointer {

    private TaskTier taskTier;
    private V0Task task;
}

package com.collectionlogmaster.domain.savedata.v1;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Getter
@AllArgsConstructor
@NoArgsConstructor
@Deprecated
public class V1TaskPointer {
    private TaskTier taskTier;
    private Task task;
}

package com.collectionlogmaster.domain.savedata.v1;

import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V1SaveData extends BaseSaveData {
    public final static int VERSION = 1;

    public V1SaveData() {
        this.version = VERSION;
        this.progress = new HashMap<>();

        for (TaskTier tier : TaskTier.values()) {
            this.progress.put(tier, new HashSet<>());
        }
    }

    private final Map<TaskTier, Set<String>> progress;

    @Setter
    private @Nullable V1TaskPointer activeTaskPointer;
}

package com.collectionlogmaster.domain.savedata;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Set;

@Getter
@ToString
public class SaveData extends BaseSaveData {
    public final static int VERSION = 3;

    public SaveData() {
        this.version = VERSION;
    }

    @Setter
    private @Nullable String activeTaskId = null;

    private final Set<String> completedTasks = new HashSet<>();
}

package com.collectionlogmaster.domain.savedata;

import com.google.gson.reflect.TypeToken;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.v0.V0SaveData;
import com.collectionlogmaster.domain.savedata.v0.V0Task;
import com.collectionlogmaster.domain.savedata.v0.V0TaskPointer;
import com.collectionlogmaster.domain.savedata.v1.V1SaveData;
import com.collectionlogmaster.domain.savedata.v1.V1TaskPointer;
import com.collectionlogmaster.domain.savedata.v2.V2SaveData;
import com.collectionlogmaster.task.SaveDataStorage;
import com.collectionlogmaster.task.TaskService;
import com.collectionlogmaster.util.FileUtils;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import static com.collectionlogmaster.util.GsonOverride.GSON;

@Singleton
@Slf4j
@SuppressWarnings("deprecation")
public class SaveDataUpdater {
    @Inject
    private SaveDataStorage saveDataStorage;

    @Inject
    private TaskService taskService;

    public SaveData update(String json) {
        BaseSaveData base = GSON.fromJson(json, BaseSaveData.class);
        if (base == null) {
            return new SaveData();
        }

        if (base.getVersion() == V0SaveData.VERSION) {
            V0SaveData v0Save = GSON.fromJson(json, V0SaveData.class);
            return update(update(update(v0Save)));
        }

        if (base.getVersion() == V1SaveData.VERSION) {
            V1SaveData v1Save = GSON.fromJson(json, V1SaveData.class);
            return update(update(v1Save));
        }

        if (base.getVersion() == V2SaveData.VERSION) {
            V2SaveData v2Save = GSON.fromJson(json, V2SaveData.class);
            return update(v2Save);
        }

        if (base.getVersion() == SaveData.VERSION) {
            return GSON.fromJson(json, SaveData.class);
        }

        log.warn("Could not figure out save data version for json {}", json);
        return new SaveData();
    }

    private SaveData update(V2SaveData v2Save) {
        saveDataStorage.saveBackup(v2Save);
        SaveData newSave = new SaveData();

        newSave.getCompletedTasks().addAll(v2Save.getCompletedTasks());

        Task activeTask = v2Save.getActiveTask();
        if (activeTask != null) {
            newSave.setActiveTaskId(activeTask.getId());
        }

        return newSave;
    }

    private V2SaveData update(V1SaveData v1Save) {
        saveDataStorage.saveBackup(v1Save);
        V2SaveData newSave = new V2SaveData();

        V1TaskPointer v1ActiveTaskPointer = v1Save.getActiveTaskPointer();
        if (v1ActiveTaskPointer != null) {
            newSave.setActiveTask(v1ActiveTaskPointer.getTask());
        }

        Set<String> newCompletedTasks = newSave.getCompletedTasks();
        Set<String> v1CompletedTasks = v1Save.getProgress().entrySet().stream()
                .flatMap(entry -> entry.getValue().stream())
                .collect(Collectors.toSet());

        newCompletedTasks.addAll(v1CompletedTasks);

        return newSave;
    }

    private V1SaveData update(V0SaveData v0Save) {
        saveDataStorage.saveBackup(v0Save);
        V1SaveData newSave = new V1SaveData();

        Type mapType = new TypeToken<Map<TaskTier, Map<Integer, String>>>() {}.getType();
        Map<TaskTier, Map<Integer, String>> v0MigrationData =
                FileUtils.loadResource("domain/savedata/v0-migration.json", mapType);;

        Map<TaskTier, Set<Integer>> v0Progress = v0Save.getProgress();
        Map<TaskTier, Set<String>> newProgress = newSave.getProgress();

        for (TaskTier tier : TaskTier.values()) {
            Set<Integer> v0TierData = v0Progress.get(tier);
            Set<String> newTierData = newProgress.get(tier);
            Map<Integer, String> tierMigrationData = v0MigrationData.get(tier);

            for (Integer v0TaskId : v0TierData) {
                if (tierMigrationData.containsKey(v0TaskId)) {
                    newTierData.add(tierMigrationData.get(v0TaskId));
                }
            }
        }

        V0TaskPointer v0TaskPointer = v0Save.getActiveTaskPointer();
        if (v0TaskPointer != null) {
            V0Task v0Task = v0TaskPointer.getTask();
            String newTaskId = v0MigrationData.get(v0TaskPointer.getTaskTier()).get(v0Task.getId());
            Task newTask = taskService.getTaskById(newTaskId);

            // if we can't find the task, don't set it to avoid problems
            if (newTask != null) {
                newSave.setActiveTaskPointer(new V1TaskPointer(v0TaskPointer.getTaskTier(), newTask));
            }
        }

        return newSave;
    }
}

package com.collectionlogmaster.domain.savedata.v2;

import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import javax.annotation.Nullable;
import java.util.HashSet;
import java.util.Set;

@Getter
@ToString
@Deprecated
public class V2SaveData extends BaseSaveData {
    public final static int VERSION = 2;

    public V2SaveData() {
        this.version = VERSION;
    }

    private final Set<String> completedTasks = new HashSet<>();

    @Setter
    private @Nullable Task activeTask = null;
}

package com.collectionlogmaster.domain;


public enum TaskTier {
	EASY("Easy"),
	MEDIUM("Medium"),
	HARD("Hard"),
	ELITE("Elite"),
	MASTER("Master");

	public final String displayName;

	TaskTier(String displayName) {
		this.displayName = displayName;
	}
}

package com.collectionlogmaster.domain;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.Data;

@Data
public class TieredTaskList {
	private List<Task> easy = new ArrayList<>();
	private List<Task> medium = new ArrayList<>();
	private List<Task> hard = new ArrayList<>();
	private List<Task> elite = new ArrayList<>();
	private List<Task> master = new ArrayList<>();

	public List<Task> all() {
		return Stream.of(easy, medium, hard, elite, master)
				.flatMap(Collection::stream)
				.collect(Collectors.toList());
	}

	public List<Task> getForTier(TaskTier tier) {
		switch (tier) {
			case EASY: return easy;
			case MEDIUM: return medium;
			case HARD: return hard;
			case ELITE: return elite;
			case MASTER: return master;
			default: return Collections.emptyList();
		}
	}
}

package com.collectionlogmaster.domain.adapters;

import com.google.gson.*;
import com.collectionlogmaster.util.EnumUtils;
import com.collectionlogmaster.util.StringUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
@RequiredArgsConstructor
public class EnumAdapter<T extends Enum<T>> implements JsonDeserializer<T>, JsonSerializer<T> {
    private final Class<T> clazz;

    @Override
    public T deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException {
        return EnumUtils.fromString(clazz, jsonElement.getAsString());
    }

    @Override
    public JsonElement serialize(T t, Type type, JsonSerializationContext context) {
        return context.serialize(StringUtils.kebabCase(t.name()), String.class);
    }
}

package com.collectionlogmaster.domain.adapters;

import com.google.gson.*;
import com.collectionlogmaster.domain.verification.Verification;
import com.collectionlogmaster.domain.verification.VerificationMethod;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.domain.verification.diary.AchievementDiaryVerification;
import com.collectionlogmaster.domain.verification.skill.SkillVerification;
import com.collectionlogmaster.util.EnumUtils;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Type;

@Slf4j
public class VerificationAdapter implements JsonDeserializer<Verification> {
    private static final String DISCRIMINATOR_FIELD = "method";

    @Override
    public Verification deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext context) throws JsonParseException {
        JsonObject obj = jsonElement.getAsJsonObject();
        if (!obj.has(DISCRIMINATOR_FIELD)) {
            log.error("Verification object has no required discriminator field '{}'", DISCRIMINATOR_FIELD);
            return null;
        }

        String methodStr = obj.get(DISCRIMINATOR_FIELD).getAsString();
        VerificationMethod method = EnumUtils.fromString(VerificationMethod.class, methodStr);
        if (method == null) {
            log.warn("Verification object has unknown method '{}'", methodStr);
            return null;
        }

        switch (method) {
            case COLLECTION_LOG:
                return context.deserialize(jsonElement, CollectionLogVerification.class);

            case ACHIEVEMENT_DIARY:
                return context.deserialize(jsonElement, AchievementDiaryVerification.class);

            case SKILL:
                return context.deserialize(jsonElement, SkillVerification.class);
        }

        log.error("Unhandled verification method '{}'", method);
        return null;
    }
}

package com.collectionlogmaster.task;

import com.collectionlogmaster.domain.TieredTaskList;
import com.collectionlogmaster.util.FileUtils;
import com.collectionlogmaster.util.HttpClient;
import java.util.concurrent.CompletableFuture;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;


@Slf4j
@Singleton
public class TaskListStorage {
	private static final String LOCAL_TASK_LIST_FILE = "task-list.json";

	private static final String REMOTE_TASK_LIST_URL = "https://raw.githubusercontent.com/OSRS-Taskman/collection-log-master/refs/heads/main/src/main/resources/com/collectionlogmaster/task-list.json";

	private final HttpClient httpClient;

	private @NonNull TieredTaskList taskList = new TieredTaskList();

	@Inject
	public TaskListStorage(HttpClient httpClient) {
		this.httpClient = httpClient;
		loadAsync();
	}

	public @NonNull TieredTaskList get() {
		return taskList;
	}

	private void loadAsync() {
		fetchRemoteAsync()
				.exceptionally(t -> fetchLocal())
				.thenAccept(taskList -> this.taskList = taskList);
	}

	private @NonNull TieredTaskList fetchLocal() {
		return FileUtils.loadResource(LOCAL_TASK_LIST_FILE, TieredTaskList.class);
	}

	private CompletableFuture<TieredTaskList> fetchRemoteAsync() {
		return httpClient.getHttpRequestAsync(REMOTE_TASK_LIST_URL, TieredTaskList.class);
	}
}

package com.collectionlogmaster.task;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.collectionlogmaster.command.TaskmanCommandManager;
import com.collectionlogmaster.domain.Tag;
import com.collectionlogmaster.domain.Task;
import com.collectionlogmaster.domain.TaskTier;
import com.collectionlogmaster.domain.savedata.SaveData;
import com.collectionlogmaster.domain.verification.clog.CollectionLogVerification;
import com.collectionlogmaster.util.EventBusSubscriber;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.Range;

@Singleton
@Slf4j
public class TaskService extends EventBusSubscriber {
	@Inject
	private CollectionLogMasterConfig config;

	@Inject
	private SaveDataStorage saveDataStorage;

	@Inject
	private TaskListStorage taskListStorage;

	@Inject
	private TaskmanCommandManager taskmanCommandManager;

	@Override
	public void startUp() {
		super.startUp();
		saveDataStorage.startUp();
	}

	@Override
	public void shutDown() {
		super.shutDown();
		saveDataStorage.shutDown();
	}

	public Task getActiveTask() {
		String activeTaskId = saveDataStorage.get().getActiveTaskId();

		return activeTaskId == null ? null : getTaskById(activeTaskId);
	}

	// we might want to build a cache map in the future
	public Task getTaskById(String taskId) {
		for (TaskTier t : TaskTier.values()) {
			List<Task> tasks = getTierTasks(t);
			for (Task task : tasks) {
				if (task.getId().equals(taskId)) {
					return task;
				}
			}
		}

		return null;
	}

	public @NonNull TaskTier getCurrentTier() {
		Map<TaskTier, Float> progress = getProgress();

		return getVisibleTiers().stream()
				.filter(t -> progress.get(t) < 1)
				.findFirst()
				.orElse(TaskTier.MASTER);
	}

	public List<Task> getTierTasks() {
		return getTierTasks(getCurrentTier());
	}

	public List<Task> getTierTasks(TaskTier tier) {
		List<Task> tierTasks = taskListStorage.get().getForTier(tier);

		if (!config.isLMSEnabled()) {
			return filterTag(tierTasks, Tag.LMS);
		}

		return tierTasks;
	}

	public List<Task> getIncompleteTierTasks() {
		return getIncompleteTierTasks(getCurrentTier());
	}

	public List<Task> getIncompleteTierTasks(TaskTier tier) {
		List<Task> tierTasks = getTierTasks(tier);

		return tierTasks.stream()
				.filter(t -> !isComplete(t.getId()))
				.collect(Collectors.toList());
	}

	public List<TaskTier> getVisibleTiers() {
		TaskTier hideBelow = config.hideBelow();

		return Arrays.stream(TaskTier.values())
				.filter(t -> t.ordinal() >= hideBelow.ordinal())
				.collect(Collectors.toList());
	}

	public @NonNull Map<TaskTier, @Range(from = 0, to = 1) Float> getProgress() {
		SaveData data = saveDataStorage.get();
		Set<String> completedTasks = data.getCompletedTasks();

		Map<TaskTier, @Range(from = 0, to = 1) Float> completionPercentages = new HashMap<>();
		for (TaskTier tier : TaskTier.values()) {
			Set<String> tierTasks = getTierTasks(tier).stream()
					.map(Task::getId)
					.collect(Collectors.toSet());

			float totalTierTasks = tierTasks.size();
			tierTasks.retainAll(completedTasks);

			float tierPercentage = tierTasks.size() / totalTierTasks;

			completionPercentages.put(tier, tierPercentage);
		}

		return completionPercentages;
	}

	public Task generate() {
		SaveData data = saveDataStorage.get();

		String activeTaskId = data.getActiveTaskId();
		if (activeTaskId != null) {
			log.warn("Tried to generate task when previous one wasn't completed yet");
			return null;
		}

		List<Task> incompleteTierTasks = getIncompleteTierTasks();
		if (incompleteTierTasks.isEmpty()) {
			log.warn("No tasks left");
			return null;
		}

		Task generatedTask = pickRandomTask(incompleteTierTasks);
		log.debug("New task generated: {}", generatedTask);

		data.setActiveTaskId(generatedTask.getId());
		saveDataStorage.save();
		taskmanCommandManager.updateServer();

		return generatedTask;
	}

	public void complete() {
		Task activeTask = getActiveTask();
		if (activeTask == null) {
			return;
		}

		complete(activeTask.getId());
	}

	public void complete(String taskId) {
		SaveData data = saveDataStorage.get();
		Set<String> completedTasks = data.getCompletedTasks();
		completedTasks.add(taskId);

		if (taskId.equals(data.getActiveTaskId())) {
			data.setActiveTaskId(null);
		}

		saveDataStorage.save();
		taskmanCommandManager.updateServer();
	}

	public void uncomplete(String taskId) {
		Set<String> completedTasks = saveDataStorage.get().getCompletedTasks();
		completedTasks.remove(taskId);

		saveDataStorage.save();
		taskmanCommandManager.updateServer();
	}

	public boolean toggleComplete(String taskId) {
		if (isComplete(taskId)) {
			uncomplete(taskId);
			return false;
		} else {
			complete(taskId);
			return true;
		}
	}

	public boolean isComplete(String taskId) {
		Set<String> completedTasks = saveDataStorage.get().getCompletedTasks();

		return completedTasks.contains(taskId);
	}

	private Task pickRandomTask(List<Task> tasks) {
		int index = (int) Math.floor(Math.random() * tasks.size());
		Task pickedTask = tasks.get(index);

		if (!(pickedTask.getVerification() instanceof CollectionLogVerification)) {
			return pickedTask;
		}

		// get first of similarly named tasks
		String taskName = pickedTask.getName();
		Stream<Task> similarTasks = tasks.stream()
				.filter(t -> taskName.equals(t.getName()))
				.filter(t -> t.getVerification() instanceof CollectionLogVerification);

		//noinspection DataFlowIssue
		return similarTasks.min(Comparator.comparingInt(
				t -> ((CollectionLogVerification) t.getVerification()).getCount()
		)).orElse(pickedTask);
	}

	private List<Task> filterTag(List<Task> list, Tag tag) {
		return list.stream()
				.filter(t -> !t.getTags().contains(tag))
				.collect(Collectors.toList());
	}
}

package com.collectionlogmaster.task;

import com.collectionlogmaster.CollectionLogMasterConfig;
import com.google.gson.JsonSyntaxException;
import com.collectionlogmaster.domain.savedata.BaseSaveData;
import com.collectionlogmaster.domain.savedata.SaveData;
import com.collectionlogmaster.domain.savedata.SaveDataUpdater;
import com.collectionlogmaster.util.EventBusSubscriber;
import com.collectionlogmaster.util.SimpleDebouncer;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Instant;

import static com.collectionlogmaster.CollectionLogMasterConfig.CONFIG_GROUP;
import static com.collectionlogmaster.util.GsonOverride.GSON;

@Singleton
@Slf4j
public class SaveDataStorage extends EventBusSubscriber {
    public static final String SAVE_DATA_KEY = "save-data";

    public static final String SAVE_DATA_BACKUP_KEY_BASE = "save-data-bk";

    @Inject
    private ConfigManager configManager;

    @Inject
    private SaveDataUpdater saveDataUpdater;

    @Inject
    private SimpleDebouncer saveDebouncer;

    private SaveData data;

    @Override
    public void startUp() {
        super.startUp();
        load();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged e) {
        GameState state = e.getGameState();
        switch (state) {
            case LOGGED_IN:
                load();
                break;

            case LOGIN_SCREEN:
                saveImmediately();
                break;
        }
    }

    public SaveData get() {
        return data;
    }

    public void save() {
        log.debug("Scheduling save; {}", Instant.now());
        saveDebouncer.debounce(this::saveImmediately);
    }

    public void saveImmediately() {
        log.debug("Saving; {}", Instant.now());
        String json = GSON.toJson(data);
        configManager.setRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, json);
    }

    public void saveBackup(BaseSaveData data) {
        String json = GSON.toJson(data);
        configManager.setRSProfileConfiguration(
                CONFIG_GROUP,
                SAVE_DATA_BACKUP_KEY_BASE + data.getVersion(),
                json
        );
    }

    private void load() {
        importOldPluginSave();
        data = read();
    }

    private @NonNull SaveData read() {
        String json = configManager.getRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY);
        if (json == null) {
            return new SaveData();
        }

        try {
            return saveDataUpdater.update(json);
        } catch (JsonSyntaxException e) {
            log.error("Unable to parse save data JSON", e);
        }

        return new SaveData();
    }

	private void importOldPluginSave() {
		Boolean alreadyImported = configManager.getRSProfileConfiguration(
				CollectionLogMasterConfig.CONFIG_GROUP,
				"oldPluginSaveImported",
				Boolean.class
		);

		if (alreadyImported != null && alreadyImported) {
			return;
		}

        log.info("Importing old plugin save for profile {}", configManager.getRSProfileKey());
        String oldSave = configManager.getRSProfileConfiguration("log-master", SAVE_DATA_KEY);
        log.info("Old save: {}", oldSave);

        if (oldSave != null) {
            configManager.setRSProfileConfiguration(CONFIG_GROUP, SAVE_DATA_KEY, oldSave);
        }

        configManager.setRSProfileConfiguration(CONFIG_GROUP, "oldPluginSaveImported", true);
	}
}

package com.collectionlogmaster;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CollectionLogMasterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CollectionLogMasterPlugin.class);
		RuneLite.main(args);
	}
}
