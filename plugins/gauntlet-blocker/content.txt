package com.gauntletBlocker;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import javax.inject.Inject;
import net.runelite.api.GameObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class GauntletBlockerOverlay extends Overlay
{
    private final GauntletBlockerPlugin plugin;
    private final GauntletBlockerConfig config;
    private final ModelOutlineRenderer outlineRenderer;

    private static final int GAUNTLET_PORTAL_OBJECT_ID = 36081;

    @Inject
    public GauntletBlockerOverlay(
            GauntletBlockerPlugin plugin,
            GauntletBlockerConfig config,
            ModelOutlineRenderer outlineRenderer
    )
    {
        this.plugin = plugin;
        this.config = config;
        this.outlineRenderer = outlineRenderer;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.overlayEnabled())
        {
            return null;
        }

        GameObject portal = plugin.getPortalObject();
        if (portal == null)
        {
            return null;
        }

        Color base = config.overlayColor();
        if (base == null)
        {
            return null;
        }

        // Feathered “shadow” pass (this is the feather look)
        final int softWidth = 20;
        final int softFeather = 20;
        outlineRenderer.drawOutline(portal, softWidth, base, softFeather);

        // Subtle fill (optional vibe)

        Shape clickbox = portal.getClickbox();
        if (clickbox != null)
        {
            int fillAlpha = Math.min(255, Math.max(0, (int) (base.getAlpha()* 0.9)) );
            Color fill = new Color(base.getRed(), base.getGreen(), base.getBlue(), fillAlpha);
            graphics.setColor(fill);
            graphics.fill(clickbox);
        }
        return null;
    }
}

package com.gauntletBlocker;

import com.google.inject.Provides;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.MenuEntry;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

@PluginDescriptor(
		name = "Gauntlet Blocker",
		description = "Blocks Gauntlet portal entry, customizable overlay and customizes examine text.",
		tags = {"gauntlet", "hider", "cg", "blocker", "portal"}
)
public class GauntletBlockerPlugin extends Plugin
{
	private static final int GAUNTLET_PORTAL_OBJECT_ID = 36081;

	private static final String PORTAL_NAME = "gauntlet portal";
	private static final String OPTION_ENTER = "enter";
	private static final String OPTION_EXAMINE = "examine";

	@Inject
	private Client client;

	@Inject
	private GauntletBlockerConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private GauntletBlockerOverlay overlay;

	private boolean pendingPortalExamine;
	private long pendingPortalExamineUntilMs;

	private GameObject portalObject;

	@Provides
	GauntletBlockerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GauntletBlockerConfig.class);
	}

	@Override
	protected void startUp()
	{
		overlayManager.add(overlay);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(overlay);
		portalObject = null;
		pendingPortalExamine = false;
	}

	public GameObject getPortalObject()
	{
		return portalObject;
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		portalObject = findPortalObjectById(GAUNTLET_PORTAL_OBJECT_ID);
	}

	private GameObject findPortalObjectById(int objectId)
	{
		var tiles = client.getScene().getTiles();
		if (tiles == null)
		{
			return null;
		}

		int plane = client.getPlane();
		if (plane < 0 || plane >= tiles.length)
		{
			return null;
		}

		var planeTiles = tiles[plane];
		if (planeTiles == null)
		{
			return null;
		}

		for (int x = 0; x < planeTiles.length; x++)
		{
			var col = planeTiles[x];
			if (col == null)
			{
				continue;
			}

			for (int y = 0; y < col.length; y++)
			{
				var tile = col[y];
				if (tile == null)
				{
					continue;
				}

				GameObject[] objs = tile.getGameObjects();
				if (objs == null)
				{
					continue;
				}

				for (GameObject obj : objs)
				{
					if (obj != null && obj.getId() == objectId)
					{
						return obj;
					}
				}
			}
		}
		return null;
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		String option = clean(event.getOption());
		String target = clean(event.getTarget());

		if (!target.equals(PORTAL_NAME) || !option.equals(OPTION_ENTER))
		{
			return;
		}

		MenuEntry[] entries = client.getMenuEntries();
		if (entries == null || entries.length == 0)
		{
			return;
		}

		List<MenuEntry> newEntries = new ArrayList<>(entries.length);

		for (MenuEntry e : entries)
		{
			String eOpt = clean(e.getOption());
			String eTgt = clean(e.getTarget());

			if (eTgt.equals(PORTAL_NAME) && eOpt.equals(OPTION_ENTER))
			{
				continue;
			}

			newEntries.add(e);
		}

		client.setMenuEntries(newEntries.toArray(new MenuEntry[0]));
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		String option = clean(event.getMenuOption());
		String target = clean(event.getMenuTarget());

		if (target.equals(PORTAL_NAME) && option.equals(OPTION_ENTER))
		{
			event.consume(); // or event.setConsumed(true) on older mappings
			return;
		}

		if (target.equals(PORTAL_NAME) && option.equals(OPTION_EXAMINE))
		{
			String replacement = safeTrim(config.customExamineText());
			if (replacement.isEmpty())
			{
				return;
			}

			pendingPortalExamine = true;
			pendingPortalExamineUntilMs = System.currentTimeMillis() + 1500;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!pendingPortalExamine)
		{
			return;
		}

		if (System.currentTimeMillis() > pendingPortalExamineUntilMs)
		{
			pendingPortalExamine = false;
			return;
		}

		if (event.getType() != ChatMessageType.OBJECT_EXAMINE)
		{
			return;
		}

		String replacement = safeTrim(config.customExamineText());
		if (replacement.isEmpty())
		{
			pendingPortalExamine = false;
			return;
		}

		MessageNode node = event.getMessageNode();
		node.setValue(replacement);
		client.refreshChat();

		pendingPortalExamine = false;
	}

	private static String clean(String s)
	{
		return s == null ? "" : Text.standardize(s);
	}

	private static String safeTrim(String s)
	{
		return s == null ? "" : s.trim();
	}
}

package com.gauntletBlocker;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(GauntletBlockerConfig.GROUP)
public interface GauntletBlockerConfig extends Config
{
	String GROUP = "gauntletblocker";

	@ConfigItem(
			keyName = "overlayEnabled",
			name = "Enable overlay",
			description = "Draw an overlay on the Gauntlet portal."
	)
	default boolean overlayEnabled()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
			keyName = "overlayColor",
			name = "Overlay color",
			description = "Color used for the portal overlay (alpha supported)."
	)
	default Color overlayColor()
	{
		return new Color(0, 0, 0, 180);
	}

	@ConfigItem(
			keyName = "customExamineText",
			name = "Portal examine text",
			description = "Leave blank to use the default examine text."
	)
	default String customExamineText()
	{
		return "The portal has been sealed shut.";
	}
}

package com.gauntletBlocker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GauntletBlockerPlugin.class);
		RuneLite.main(args);
	}
}
