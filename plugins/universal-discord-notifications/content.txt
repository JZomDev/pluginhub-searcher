package universalDiscord;

import javax.inject.Inject;

public class BaseNotifier {
    protected final UniversalDiscordPlugin plugin;

    @Inject
    public BaseNotifier(UniversalDiscordPlugin plugin) {
        this.plugin = plugin;
    }

    public void handleNotify() {
        plugin.messageHandler.createMessage("This is a base notification", false, null);
    }
}

package universalDiscord;

import net.runelite.api.ItemComposition;
import net.runelite.client.util.QuantityFormatter;

import javax.annotation.Nullable;
import java.util.HashMap;

public class ClueNotifier extends BaseNotifier{
    public HashMap<Integer, Integer> clueItems = new HashMap<Integer, Integer>();

    private DiscordMessageBody messageBody;

    public ClueNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    public void handleNotify(String numberCompleted, String clueType) {
        messageBody = new DiscordMessageBody();
        StringBuilder lootMessage = new StringBuilder();
        long totalPrice = 0;

        for(Integer itemId : clueItems.keySet()) {
            if(lootMessage.length() > 0) {
                lootMessage.append("\n");
            }
            int quantity = clueItems.get(itemId);
            int price = plugin.itemManager.getItemPrice(itemId);
            totalPrice += (long) price * quantity;
            lootMessage.append(getItem(itemId, clueItems.get(itemId)));
        }

        if(totalPrice < plugin.config.clueMinValue()) {
            return;
        }

        String notifyMessage = plugin.config.clueNotifyMessage()
                .replaceAll("%USERNAME%", Utils.getPlayerName())
                .replaceAll("%CLUE%", clueType)
                .replaceAll("%COUNT%", numberCompleted)
                .replaceAll("%LOOT%", lootMessage.toString());
        plugin.messageHandler.createMessage(notifyMessage, plugin.config.clueSendImage(), null);
    }

    public String getItem(int itemId, int quantity) {
        int price = plugin.itemManager.getItemPrice(itemId);
        long totalPrice = (long) price * quantity;
        ItemComposition itemComposition = plugin.itemManager.getItemComposition(itemId);

        if(plugin.config.clueShowItems()) {
            messageBody.getEmbeds().add(new DiscordMessageBody.Embed(new DiscordMessageBody.UrlEmbed(Utils.getItemImageUrl(itemId))));
        }
        return String.format("%s x %s (%s)", quantity, itemComposition.getName(), QuantityFormatter.quantityToStackSize(totalPrice));
    }
}

package universalDiscord;

import javax.inject.Inject;

public class CollectionNotifier extends BaseNotifier {

    @Inject
    public CollectionNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    public void handleNotify(String itemName) {
        String notifyMessage = plugin.config.collectionNotifyMessage()
                .replaceAll("%USERNAME%", Utils.getPlayerName())
                .replaceAll("%ITEM%", itemName);
        plugin.messageHandler.createMessage(notifyMessage, plugin.config.collectionSendImage(), null);
    }
}

package universalDiscord;

import javax.inject.Inject;

public class DeathNotifier extends BaseNotifier {

    @Inject
    public DeathNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    @Override
    public void handleNotify() {
        String notifyMessage = plugin.config.deathNotifyMessage()
                .replaceAll("%USERNAME%", Utils.getPlayerName());
        plugin.messageHandler.createMessage(notifyMessage, plugin.config.deathSendImage(), null);
    }
}

package universalDiscord;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class DiscordMessageBody {
    private String content;
    private List<Embed> embeds = new ArrayList<>();

    @Data
    static class Embed {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed {
        final String url;
    }
}

package universalDiscord;

import static net.runelite.http.api.RuneLiteAPI.GSON;
import com.google.common.base.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.DrawManager;
import okhttp3.*;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Objects;

@Slf4j
public class DiscordMessageHandler {
    private UniversalDiscordPlugin plugin;

    @Inject
    public DiscordMessageHandler(UniversalDiscordPlugin plugin) {
        this.plugin = plugin;
    }

    public void createMessage(String message, boolean sendImage, DiscordMessageBody mBody) {
        DiscordMessageBody messageBody = new DiscordMessageBody();
        if(mBody != null) {
            messageBody = mBody;
        }

        messageBody.setContent(message);
        String webhookUrl = plugin.config.discordWebhook();
        if(Strings.isNullOrEmpty(webhookUrl)) {
            return;
        }
        ArrayList<HttpUrl> urlList = new ArrayList<>();
        String[] strList = webhookUrl.split("\n");
        for (String urlString: strList) {
            if(Objects.equals(urlString, "")) {
                continue;
            }
            urlList.add(HttpUrl.parse(urlString));
        }

        MultipartBody.Builder reqBodyBuilder = new MultipartBody.Builder()
            .setType(MultipartBody.FORM)
            .addFormDataPart("payload_json", GSON.toJson(messageBody));

        if (sendImage) {
            plugin.drawManager.requestNextFrameListener(image -> {
                BufferedImage bufferedImage = (BufferedImage) image;
                byte[] imageBytes;
                try {
                    imageBytes = Utils.convertImageToByteArray(bufferedImage);
                } catch (IOException e) {
                    log.warn("There was an error creating bytes from captured image", e);
                    // Still send the message even if the image cannot be created
                    sendToMultiple(urlList, reqBodyBuilder);
                    return;
                }

                reqBodyBuilder.addFormDataPart("file", "collectionImage.png",
                        RequestBody.create(MediaType.parse("image/png"), imageBytes));
                sendToMultiple(urlList, reqBodyBuilder);
            });
            return;
        }

        sendToMultiple(urlList, reqBodyBuilder);
    }

    private void sendToMultiple(ArrayList<HttpUrl> urls, MultipartBody.Builder requestBody) {
        for (HttpUrl url: urls) {
            sendMessage(url, requestBody);
        }
    }

    private void sendMessage(HttpUrl url, MultipartBody.Builder requestBody) {
        RequestBody body = requestBody.build();
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();
        plugin.httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                log.warn("There was an error sending the webhook message", e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                response.close();
            }
        });
    }
}

package universalDiscord;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Hashtable;

@Slf4j
public class LevelNotifier extends BaseNotifier {

    private ArrayList<String> levelledSkills = new ArrayList<String>();
    private Hashtable<String, Integer> currentLevels = new Hashtable<String, Integer>();
    private boolean sendMessage = false;
    private int ticksWaited = 0;

    @Inject
    public LevelNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    public void reset() {
        currentLevels.clear();
        levelledSkills.clear();
    }

    private boolean checkLevelInterval(int level) {
        return plugin.config.levelInterval() <= 1
                || level == 99
                || level % plugin.config.levelInterval() == 0;
    }

    public void onTick() {
        if(!sendMessage) {
            return;
        }

        ticksWaited++;
        // We wait a couple extra ticks so we can ensure that we process all the levels of the previous tick
        if (ticksWaited > 2) {
            ticksWaited = 0;
            attemptNotify();
        }
    }

    public void attemptNotify() {
        sendMessage = false;
        StringBuilder skillMessage = new StringBuilder();
        int index = 0;

        for (String skill : levelledSkills) {
            if(index == levelledSkills.size()) {
                skillMessage.append(" and ");
            } else if (index > 0) {
                skillMessage.append(", ");
            }
            skillMessage.append(String.format("%s to %s", skill, currentLevels.get(skill)));
            index++;
        }

        String skillString = skillMessage.toString();
        levelledSkills.clear();
        String fullNotification = plugin.config.levelNotifyMessage()
                .replaceAll("%USERNAME%", Utils.getPlayerName())
                .replaceAll("%SKILL%", skillString);
        plugin.messageHandler.createMessage(fullNotification, plugin.config.levelSendImage(), null);
    }

    public void handleLevelUp(String skill, int level) {
        if(checkLevelInterval(level) && currentLevels.get(skill) != null) {
            if(level == currentLevels.get(skill)) {
                return;
            }
            levelledSkills.add(skill);
            sendMessage = true;
        }
        currentLevels.put(skill, level);
    }
}

package universalDiscord;

import net.runelite.api.ItemComposition;
import net.runelite.api.NPC;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.util.QuantityFormatter;

import javax.inject.Inject;
import java.util.Collection;


public class LootNotifier extends BaseNotifier {
    private boolean sendMessage = false;

    @Inject
    public LootNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    public void handleNotify(Collection<ItemStack> items, String dropper) {
        DiscordMessageBody messageBody = new DiscordMessageBody();
        StringBuilder lootMessage = new StringBuilder();
        int minValue = plugin.config.minLootValue();
        long totalStackValue = 0;

        for (ItemStack item : Utils.reduceItemStack(items)) {
            int itemId = item.getId();
            int quantity = item.getQuantity();
            int price = plugin.itemManager.getItemPrice(itemId);
            long totalPrice = (long) price * quantity;

            if (totalPrice >= minValue) {
                if(totalStackValue != 0) {
                    lootMessage.append("\n");
                }
                sendMessage = true;
                ItemComposition itemComposition = plugin.itemManager.getItemComposition(itemId);
                lootMessage.append(String.format("%s x %s (%s)", quantity, itemComposition.getName(), QuantityFormatter.quantityToStackSize(totalPrice)));
                if(plugin.config.lootIcons()) {
                    messageBody.getEmbeds().add(new DiscordMessageBody.Embed(new DiscordMessageBody.UrlEmbed(Utils.getItemImageUrl(itemId))));
                }
            }

            totalStackValue += totalPrice;
        }

        if (sendMessage) {
            sendMessage = false;
            String lootString = lootMessage.toString();
            String notifyMessage = plugin.config.lootNotifyMessage()
                    .replaceAll("%USERNAME%", Utils.getPlayerName())
                    .replaceAll("%LOOT%", lootString)
                    .replaceAll("%SOURCE%", dropper);
            plugin.messageHandler.createMessage(notifyMessage, plugin.config.lootSendImage(), messageBody);
        }
    }
}

package universalDiscord;

import javax.inject.Inject;

public class PetNotifier extends BaseNotifier {

    @Inject
    public PetNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    @Override
    public void handleNotify() {
        String notifyMessage = plugin.config.petNotifyMessage()
                .replaceAll("%USERNAME%", Utils.getPlayerName());
        plugin.messageHandler.createMessage(notifyMessage, plugin.config.petSendImage(), null);
    }
}

package universalDiscord;

import com.google.common.collect.ImmutableList;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class QuestNotifier extends BaseNotifier{
    public QuestNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    public void handleNotify(String questText) {
        String notifyMessage = plugin.config.questNotifyMessage()
                .replaceAll("%USERNAME%", Utils.getPlayerName())
                .replaceAll("%QUEST%", parseQuestWidget(questText));
        plugin.messageHandler.createMessage(notifyMessage, plugin.config.questSendImage(), null);
    }

    // Credit to: https://github.com/oliverpatrick/Enhanced-Discord-Notifications/blob/master/src/main/java/com/enhanceddiscordnotifications/EnhancedDiscordNotificationsPlugin.java
    // This method existed and seemed fairly solid.

    private static final Pattern QUEST_PATTERN_1 = Pattern.compile(".+?ve\\.*? (?<verb>been|rebuilt|.+?ed)? ?(?:the )?'?(?<quest>.+?)'?(?: [Qq]uest)?[!.]?$");
    private static final Pattern QUEST_PATTERN_2 = Pattern.compile("'?(?<quest>.+?)'?(?: [Qq]uest)? (?<verb>[a-z]\\w+?ed)?(?: f.*?)?[!.]?$");
    private static final ImmutableList<String> RFD_TAGS = ImmutableList.of("Another Cook", "freed", "defeated", "saved");
    private static final ImmutableList<String> WORD_QUEST_IN_NAME_TAGS = ImmutableList.of("Another Cook", "Doric", "Heroes", "Legends", "Observatory", "Olaf", "Waterfall");

    private String parseQuestWidget(final String text) {
        // "You have completed The Corsair Curse!"
        final Matcher questMatch1 = QUEST_PATTERN_1.matcher(text);
        // "'One Small Favour' completed!"
        final Matcher questMatch2 = QUEST_PATTERN_2.matcher(text);
        final Matcher questMatchFinal = questMatch1.matches() ? questMatch1 : questMatch2;
        if (!questMatchFinal.matches()) {
            return "Unable to find quest name!";
        }

        String quest = questMatchFinal.group("quest");
        String verb = questMatchFinal.group("verb") != null ? questMatchFinal.group("verb") : "";

        if (verb.contains("kind of")) {
            quest += " partial completion";
        }
        else if (verb.contains("completely")) {
            quest += " II";
        }

        if (RFD_TAGS.stream().anyMatch((quest + verb)::contains)) {
            quest = "Recipe for Disaster - " + quest;
        }

        if (WORD_QUEST_IN_NAME_TAGS.stream().anyMatch(quest::contains)) {
            quest += " Quest";
        }

        return quest;
    }
}

package universalDiscord;

import javax.inject.Inject;
import java.util.Objects;

public class SlayerNotifier extends BaseNotifier {
    public String slayerTask = "";
    public String slayerPoints = "";
    public String slayerCompleted = "";

    @Inject
    public SlayerNotifier(UniversalDiscordPlugin plugin) {
        super(plugin);
    }

    @Override
    public void handleNotify() {
        // Little jank, but it's a bit cleaner than having bools and checking in the main plugin class
        if (Objects.equals(slayerPoints, "")
            || Objects.equals(slayerTask, "")
            || Objects.equals(slayerCompleted, "")) {
            return;
        }

        String notifyMessage = plugin.config.slayerNotifyMessage()
                .replaceAll("%USERNAME%", Utils.getPlayerName())
                .replaceAll("%TASK%", slayerTask)
                .replaceAll("%TASKCOUNT%", slayerCompleted)
                .replaceAll("%POINTS%", slayerPoints);
        plugin.messageHandler.createMessage(notifyMessage, plugin.config.slayerSendImage(), null);

        slayerTask = "";
        slayerPoints = "";
        slayerCompleted = "";
    }
}

package universalDiscord;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("universalDiscord")
public interface UniversalDiscordConfig extends Config {
    @ConfigSection(
            name = "Collection Log",
            description = "Settings for notifying about collection log",
            position = 1
    )
    String collectionSection = "Collection Log";

    @ConfigSection(
            name = "Pet",
            description = "Settings for notifying when obtaining a pet",
            position = 4
    )
    String petSection = "Pet";

    @ConfigSection(
            name = "Levels",
            description = "Settings for notifying when levelling a skill",
            position = 7
    )
    String levelSection = "Levels";

    @ConfigSection(
            name = "Loot",
            description = "Settings for notifying when loot is dropped",
            position = 11
    )
    String lootSection = "Loot";

    @ConfigSection(
            name = "Death",
            description = "Settings for notifying when you die",
            position = 16
    )
    String deathSection = "Death";

    @ConfigSection(
            name = "Slayer",
            description = "Settings for notifying when you complete a slayer task",
            position = 19
    )
    String slayerSection = "Slayer";

    @ConfigSection(
            name = "Quests",
            description = "Settings for notifying when you complete a quest",
            position = 22
    )
    String questSection = "Quests";

    @ConfigSection(
            name = "Clue Scrolls",
            description = "Settings for notifying when you complete a clue scroll",
            position = 25
    )
    String clueSection = "Clue Scrolls";

    @ConfigItem(
            keyName = "discordWebhook",
            name = "Discord Webhook",
            description = "The Webhook URL for the discord channel",
            position = 0
    )
    default String discordWebhook() {
        return "";
    }

    @ConfigItem(
            keyName = "collectionLogEnabled",
            name = "Enable collection log",
            description = "Enable notifications for collection log",
            position = 1,
            section = collectionSection
    )
    default boolean notifyCollectionLog() {
        return false;
    }

    @ConfigItem(
            keyName = "collectionNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username and %ITEM% for the item",
            position = 2,
            section = collectionSection
    )
    default String collectionNotifyMessage() {
        return "%USERNAME% has added %ITEM% to their collection";
    }

    @ConfigItem(
            keyName = "collectionSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 3,
            section = collectionSection
    )
    default boolean collectionSendImage() {
        return true;
    }

    @ConfigItem(
            keyName = "petEnabled",
            name = "Enable pets",
            description = "Enable notifications for obtaining pets",
            position = 4,
            section = petSection
    )
    default boolean notifyPet() {
        return false;
    }

    @ConfigItem(
            keyName = "petNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username",
            position = 5,
            section = petSection
    )
    default String petNotifyMessage() {
        return "%USERNAME% has a funny feeling they are being followed";
    }

    @ConfigItem(
            keyName = "petSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 6,
            section = petSection
    )
    default boolean petSendImage() {
        return true;
    }


    @ConfigItem(
            keyName = "levelEnabled",
            name = "Enable level",
            description = "Enable notifications for gaining levels",
            position = 7,
            section = levelSection
    )
    default boolean notifyLevel() {
        return false;
    }

    @ConfigItem(
            keyName = "levelInterval",
            name = "Notify Interval",
            description = "Interval between when a notification should be sent",
            position = 8,
            section = levelSection
    )
    default int levelInterval() {
        return 1;
    }

    @ConfigItem(
            keyName = "levelNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username and %SKILL% to insert the levelled skill(s)",
            position = 9,
            section = levelSection
    )
    default String levelNotifyMessage() {
        return "%USERNAME% has levelled %SKILL%";
    }

    @ConfigItem(
            keyName = "levelSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 10,
            section = levelSection
    )
    default boolean levelSendImage() {
        return true;
    }

    @ConfigItem(
            keyName = "lootEnabled",
            name = "Enable loot",
            description = "Enable notifications for gaining loot",
            position = 11,
            section = lootSection
    )
    default boolean notifyLoot() {
        return false;
    }

    @ConfigItem(
            keyName = "lootIcons",
            name = "Show loot icons",
            description = "Show icons for the loot obtained",
            position = 12,
            section = lootSection
    )
    default boolean lootIcons() {
        return false;
    }

    @ConfigItem(
            keyName = "minLootValue",
            name = "Min Loot value",
            description = "Minimum value of the loot to notify",
            position = 13,
            section = lootSection
    )
    default int minLootValue() {
        return 0;
    }

    @ConfigItem(
            keyName = "lootNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username, %LOOT% to insert the loot and %SOURCE% to show the source of the loot",
            position = 14,
            section = lootSection
    )
    default String lootNotifyMessage() {
        return "%USERNAME% has looted: \n\n%LOOT%\nFrom: %SOURCE%";
    }

    @ConfigItem(
            keyName = "lootSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 15,
            section = lootSection
    )
    default boolean lootSendImage() {
        return true;
    }

    @ConfigItem(
            keyName = "deathEnabled",
            name = "Enable Death",
            description = "Enable notifications for when you die",
            position = 16,
            section = deathSection
    )
    default boolean notifyDeath() {
        return false;
    }

    @ConfigItem(
            keyName = "deathSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 17,
            section = deathSection
    )
    default boolean deathSendImage() {
        return false;
    }

    @ConfigItem(
            keyName = "deathNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username",
            position = 18,
            section = deathSection
    )
    default String deathNotifyMessage() {
        return "%USERNAME% has died...";
    }

    @ConfigItem(
            keyName = "slayerEnabled",
            name = "Enable Slayer",
            description = "Enable notifications for when you complete a slayer task",
            position = 19,
            section = slayerSection
    )
    default boolean notifySlayer() {
        return false;
    }

    @ConfigItem(
            keyName = "slayerSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 20,
            section = slayerSection
    )
    default boolean slayerSendImage() {
        return false;
    }

    @ConfigItem(
            keyName = "slayerNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username, %TASK% to insert your task, %POINTS% to show how many points you obtained and %TASKCOUNT% to show how many tasks you have completed.",
            position = 21,
            section = slayerSection
    )
    default String slayerNotifyMessage() {
        return "%USERNAME% has completed a slayer task: %TASK%, getting %POINTS% points and making that %TASKCOUNT% tasks completed";
    }

    @ConfigItem(
            keyName = "questEnabled",
            name = "Enable Quest",
            description = "Enable notifications for when you complete a quest",
            position = 22,
            section = questSection
    )
    default boolean notifyQuest() {
        return false;
    }

    @ConfigItem(
            keyName = "questSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 23,
            section = questSection
    )
    default boolean questSendImage() {
        return false;
    }

    @ConfigItem(
            keyName = "questNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username and %QUEST% to insert the quest that you completed",
            position = 24,
            section = questSection
    )
    default String questNotifyMessage() {
        return "%USERNAME% has completed a quest: %QUEST%";
    }

    @ConfigItem(
            keyName = "clueEnabled",
            name = "Enable Clue Scrolls",
            description = "Enable notifications for when you complete a clue scroll",
            position = 25,
            section = clueSection
    )
    default boolean notifyClue() {
        return false;
    }

    @ConfigItem(
            keyName = "clueSendImage",
            name = "Send Image",
            description = "Send image with the notification",
            position = 26,
            section = clueSection
    )
    default boolean clueSendImage() {
        return false;
    }
    @ConfigItem(
            keyName = "clueShowItems",
            name = "Show Item Icons",
            description = "Show item icons gained from the clue",
            position = 27,
            section = clueSection
    )
    default boolean clueShowItems() {
        return false;
    }

    @ConfigItem(
            keyName = "clueMinValue",
            name = "Min Value",
            description = "The minimum value of the items to be shown",
            position = 28,
            section = clueSection
    )
    default int clueMinValue() {
        return 0;
    }

    @ConfigItem(
            keyName = "clueNotifMessage",
            name = "Notification Message",
            description = "The message to be sent through the webhook. Use %USERNAME% to insert your username, %CLUE% to insert the clue type, %LOOT% to show the loot obtained and %COUNT% to insert how many of those clue types you have completed",
            position = 29,
            section = clueSection
    )
    default String clueNotifyMessage() {
        return "%USERNAME% has completed a %CLUE% clue, they have completed %COUNT%.\nThey obtained:\n\n%LOOT%";
    }

}

package universalDiscord;

import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.events.NotificationFired;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;
import okhttp3.OkHttpClient;

import java.util.Collection;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static net.runelite.api.widgets.WidgetID.QUEST_COMPLETED_GROUP_ID;


@Slf4j
@PluginDescriptor(
    name = "Universal Discord"
)
public class UniversalDiscordPlugin extends Plugin {
    @Inject
    private Client client;
    @Inject
    public OkHttpClient httpClient;

    @Inject
    public DrawManager drawManager;
    @Inject
    public UniversalDiscordConfig config;

    @Inject
    public ItemManager itemManager;

    public final DiscordMessageHandler messageHandler = new DiscordMessageHandler(this);
    private final CollectionNotifier collectionNotifier = new CollectionNotifier(this);
    private final PetNotifier petNotifier = new PetNotifier(this);
    private final LevelNotifier levelNotifier = new LevelNotifier(this);
    private final LootNotifier lootNotifier = new LootNotifier(this);
    private final DeathNotifier deathNotifier = new DeathNotifier(this);
    private final SlayerNotifier slayerNotifier = new SlayerNotifier(this);
    private final QuestNotifier questNotifier = new QuestNotifier(this);
    private final ClueNotifier clueNotifier = new ClueNotifier(this);

    private static final Pattern CLUE_SCROLL_REGEX = Pattern.compile("You have completed (?<scrollCount>\\d+) (?<scrollType>\\w+) Treasure Trails\\.");
    private static final Pattern SLAYER_TASK_REGEX = Pattern.compile("You have completed your task! You killed (?<task>[\\d,]+ [\\w,]+)\\..*");
    private static final Pattern SLAYER_COMPLETE_REGEX = Pattern.compile("You've completed (?:at least )?(?<taskCount>[\\d,]+) (?:Wilderness )?tasks?(?: and received \\d+ points, giving you a total of (?<points>[\\d,]+)|\\.You'll be eligible to earn reward points if you complete tasks from a more advanced Slayer Master\\.| and reached the maximum amount of Slayer points \\((?<points2>[\\d,]+)\\))?");

    private static final Pattern COLLECTION_LOG_REGEX = Pattern.compile("New item added to your collection log: (?<itemName>[\\w,\\s-.]+)");
    private static final Pattern PET_REGEX = Pattern.compile("You have a funny feeling like you.*");

    private String slayerTask = "";
    private String slayerTasksCompleted = "";
    private String slayerPoints = "";

    private boolean questCompleted = false;
    private boolean clueCompleted = false;
    private String clueCount = "";
    private String clueType = "";

    @Override
    protected void startUp() throws Exception {
        Utils.client = client;
        log.info("Started up Universal Discord");
    }

    @Override
    protected void shutDown() throws Exception {
        log.info("Shutting down Universal Discord");
    }

    @Provides
    UniversalDiscordConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(UniversalDiscordConfig.class);
    }

    @Subscribe
    public void onNotificationFired(NotificationFired notif) {

    }

    @Subscribe
    public void onUsernameChanged(UsernameChanged usernameChanged) {
        levelNotifier.reset();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState().equals(GameState.LOGIN_SCREEN)) {
            levelNotifier.reset();
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChange) {
        levelNotifier.handleLevelUp(statChange.getSkill().getName(), statChange.getLevel());
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        levelNotifier.onTick();
    }

    @Subscribe
    public void onChatMessage(ChatMessage message) {
        ChatMessageType msgType = message.getType();
        String chatMessage = Text.removeTags(message.getMessage());

        if (msgType.equals(ChatMessageType.GAMEMESSAGE)) {
            Matcher collectionMatcher = COLLECTION_LOG_REGEX.matcher(chatMessage);
            if(config.notifyCollectionLog() && collectionMatcher.find()) {
                collectionNotifier.handleNotify(collectionMatcher.group("itemName"));
                return;
            }

            if(config.notifyPet() && PET_REGEX.matcher(chatMessage).matches()) {
                petNotifier.handleNotify();
                return;
            }

            if(config.notifySlayer()
                && (chatMessage.contains("Slayer master")
                    || chatMessage.contains("Slayer Master")
                    || chatMessage.contains("completed your task!")
                )) {
                Matcher taskMatcher = SLAYER_TASK_REGEX.matcher(chatMessage);
                Matcher pointsMatcher = SLAYER_COMPLETE_REGEX.matcher(chatMessage);

                if(taskMatcher.find()) {
                    slayerTask = taskMatcher.group("task");
                    slayerNotifier.slayerTask = slayerTask;
                    slayerNotifier.handleNotify();
                }

                if(pointsMatcher.find()) {
                    slayerPoints = pointsMatcher.group("points");
                    slayerTasksCompleted = pointsMatcher.group("taskCount");

                    if(slayerPoints == null) {
                        slayerPoints = pointsMatcher.group("points2");
                    }

                    // 3 different cases of seeing points, so in our worst case it's 0
                    if(slayerPoints == null) {
                        slayerPoints = "0";
                    }
                    slayerNotifier.slayerPoints = slayerPoints;
                    slayerNotifier.slayerCompleted = slayerTasksCompleted;

                    slayerNotifier.handleNotify();
                }
            }

            if(config.notifyClue()) {
                Matcher clueMatcher = CLUE_SCROLL_REGEX.matcher(chatMessage);
                if(clueMatcher.find()) {
                    String numberCompleted = clueMatcher.group("scrollCount");
                    String scrollType = clueMatcher.group("scrollType");

                    if(clueCompleted) {
                        clueNotifier.handleNotify(numberCompleted, scrollType);
                        clueCompleted = false;
                    } else {
                        clueType = scrollType;
                        clueCount = numberCompleted;
                        clueCompleted = true;
                    }
                }
            }
        }
    }

    @Subscribe
    public void onActorDeath(ActorDeath actor) {
        if(config.notifyDeath() && Objects.equals(actor.getActor().getName(), Utils.getPlayerName())) {
            deathNotifier.handleNotify();
        }
    }

    @Subscribe
    public void onNpcLootReceived(NpcLootReceived npcLootReceived) {
        if(!config.notifyLoot()) {
            return;
        }

        NPC npc = npcLootReceived.getNpc();
        Collection<ItemStack> items = npcLootReceived.getItems();

        lootNotifier.handleNotify(items, npc.getName());
    }

    @Subscribe
    public void onPlayerLootReceived(PlayerLootReceived playerLootReceived) {
        Collection<ItemStack> items = playerLootReceived.getItems();
        lootNotifier.handleNotify(items, playerLootReceived.getPlayer().getName());
    }

    @Subscribe
    public void onLootReceived(LootReceived lootReceived) {
        if (lootReceived.getType() != LootRecordType.EVENT && lootReceived.getType() != LootRecordType.PICKPOCKET) {
            return;
        }

        lootNotifier.handleNotify(lootReceived.getItems(), lootReceived.getName());
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        int groupId = event.getGroupId();

        if (groupId == QUEST_COMPLETED_GROUP_ID) {

            if(config.notifyQuest()) {
                Widget quest = client.getWidget(WidgetInfo.QUEST_COMPLETED_NAME_TEXT);

                if(quest != null) {
                    String questWidget = quest.getText();
                    questNotifier.handleNotify(questWidget);
                }
            }
        }

        if (groupId == WidgetID.CLUE_SCROLL_REWARD_GROUP_ID) {
            Widget clue = client.getWidget(WidgetInfo.CLUE_SCROLL_REWARD_ITEM_CONTAINER);
            if(clue != null) {
                clueNotifier.clueItems.clear();
                Widget[] children = clue.getChildren();

                if(children == null) {
                    return;
                }

                for (Widget child : children) {
                    if(child == null) {
                        continue;
                    }

                    int quantity = child.getItemQuantity();
                    int itemId = child.getItemId();

                    if (itemId > -1 && quantity > 0) {
                        clueNotifier.clueItems.put(itemId, quantity);
                    }
                }

                if(clueCompleted) {
                    clueNotifier.handleNotify(clueCount, clueType);
                    clueCompleted = false;
                } else {
                    clueCompleted = true;
                }
            }
        }
    }
}

package universalDiscord;

import net.runelite.api.Client;
import net.runelite.client.game.ItemStack;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class Utils {
    public static Client client;
    public static String getPlayerName() {
        return client.getLocalPlayer().getName();
    }

    public static byte[] convertImageToByteArray(BufferedImage bufferedImage) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "png", byteArrayOutputStream);
        return byteArrayOutputStream.toByteArray();
    }

    public static Collection<ItemStack> reduceItemStack(Collection<ItemStack> items) {
        final List<ItemStack> list = new ArrayList<>();

        for (final ItemStack item : items) {
            int quantity = 0;
            for (final ItemStack i : list) {
                if (i.getId() == item.getId()) {
                    quantity = i.getQuantity();
                    list.remove(i);
                    break;
                }
            }

            if (quantity > 0) {
                list.add(new ItemStack(item.getId(), item.getQuantity() + quantity, item.getLocation()));
            } else {
                list.add(item);
            }
        }

        return list;
    }

    public static String getItemImageUrl(int itemId) {
        return "https://static.runelite.net/cache/item/icon/" + itemId + ".png";
    }
}

package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import universalDiscord.UniversalDiscordPlugin;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(UniversalDiscordPlugin.class);
		RuneLite.main(args);
	}
}
