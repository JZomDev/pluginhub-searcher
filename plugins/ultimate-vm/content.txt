package com.ultimatevm;

import java.util.HashSet;

public class CapCounter {
    private final int CAP_POINT_GAIN = 50;
    private HashSet<Integer> seenChambers = new HashSet<>();
    private HashSet<Integer> possibleCapPositions = new HashSet<>();
    private int timesCapped;
    private int currentScore;

    CapCounter() {
        initialize();
    }
    public void initialize() {
        seenChambers.clear();
        possibleCapPositions.clear();
        currentScore = timesCapped = 0;
    }
    public void addCappingPositions(int chamberX, int chamberY) {
        int positionCode = (chamberX << 16) | chamberY;
        if(seenChambers.contains(positionCode)) return;
        seenChambers.add(positionCode);

        possibleCapPositions.add(((chamberX+1) << 16) | (chamberY-1));
        possibleCapPositions.add((chamberX << 16) | (chamberY-1));
        possibleCapPositions.add(((chamberX+2) << 16) | chamberY);
        possibleCapPositions.add(((chamberX+2) << 16) | (chamberY+1));
        possibleCapPositions.add(((chamberX+1) << 16) | (chamberY+2));
        possibleCapPositions.add((chamberX << 16) | (chamberY+2));
        possibleCapPositions.add(((chamberX-1) << 16) | (chamberY+1));
        possibleCapPositions.add(((chamberX-1) << 16) | chamberY);
    }
    public boolean updateScore(int newScore, int playerX, int playerY) {
        int scoreDiff = newScore - currentScore;
        currentScore = newScore;
        //Player has to be in specific positions in order to cap
        if(!possibleCapPositions.contains((playerX << 16) | playerY))
            return false;

        if(scoreDiff == CAP_POINT_GAIN) ++timesCapped;
        return (scoreDiff == CAP_POINT_GAIN);
    }
    public int getTimesCapped() {
        return timesCapped;
    }
}

package com.ultimatevm;

import java.awt.Color;

import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.util.ImageUtil;

public class CapCounterInfoBox extends InfoBox {
    private CapCounter capCounter;
    public CapCounterInfoBox(CapCounter capCounter, UltimateVolcanicMinePlugin plugin) {
        super(ImageUtil.getResourceStreamFromClass(UltimateVolcanicMinePlugin.class, "/chamber.png"), plugin);
        this.capCounter = capCounter;
    }

    public String getText() {
        return String.valueOf(capCounter.getTimesCapped());
    }

    public Color getTextColor() {
        return Color.WHITE;
    }

    public String getTooltip() {
        return "You have capped  " + capCounter.getTimesCapped() + " times.";
    }
}

package com.ultimatevm;

import java.awt.Color;
import net.runelite.api.coords.WorldPoint;

public class CappingRock extends TimedObject {
    private final double TICK_RESPAWN_TIME = 25;

    CappingRock(WorldPoint worldLocation) {
        super(worldLocation, ObjectType.ROCK);
    }

    @Override
    public Color getStateColor() {
        double ratio = ticksPassed / TICK_RESPAWN_TIME;
        if(ratio < 0.4) return new Color(255, 50, 0);
        else if(ratio < 0.8) return new Color(255, 187, 0);
        return new Color(0, 217, 0);
    }

    @Override
    public double getTimeLeft() { return TICK_RESPAWN_TIME - ticksPassed; }
    @Override
    public double getTimeRemaining()  {
        return Math.min(1, ticksPassed / TICK_RESPAWN_TIME);
    }
    @Override
    public boolean isTimeExpired() { return ticksPassed >= TICK_RESPAWN_TIME; }
}

package com.ultimatevm;

import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.HashSet;

import static net.runelite.api.ItemID.*;

public class PickaxeProtector {
    public static int INVENTORY_SIZE = 28;
    static HashSet<Integer> protectedPickaxeTypes;
    private final Client client;
    HashSet<Integer> startingPickaxes;
    private int numTicksPickaxeDropped;
    @Inject
    PickaxeProtector(Client client) {
        this.client = client;
        startingPickaxes = new HashSet<>();
        resetStartingPickaxes();
        if(protectedPickaxeTypes != null) return;
        protectedPickaxeTypes = new HashSet<>(Arrays.asList(_3RD_AGE_PICKAXE, DRAGON_PICKAXE,
                DRAGON_PICKAXE_12797, DRAGON_PICKAXE_OR, DRAGON_PICKAXE_OR_25376, CRYSTAL_PICKAXE,
                CRYSTAL_PICKAXE_23863, CRYSTAL_PICKAXE_INACTIVE, CORRUPTED_PICKAXE, INFERNAL_PICKAXE,
                INFERNAL_PICKAXE_OR, INFERNAL_PICKAXE_UNCHARGED, INFERNAL_PICKAXE_UNCHARGED_25369,
                RUNE_PICKAXE));
    }

    void getStartingPickaxes() {
        if(!startingPickaxes.isEmpty()) return;
        final ItemContainer itemContainer = client.getItemContainer(InventoryID.INVENTORY);
        if (itemContainer == null) return;
        final Item[] items = itemContainer.getItems();
        for (int i = 0; i < INVENTORY_SIZE; i++) {
            if (i < items.length) {
                final Item item = items[i];
                if(!protectedPickaxeTypes.contains(item.getId())) continue;
                if (item.getQuantity() > 0) startingPickaxes.add(item.getId());
            }
        }
    }
    void resetStartingPickaxes() {
        startingPickaxes.clear();
        resetTicksDropped();
    }
    boolean isPickaxeDropped() {
        final ItemContainer itemContainer = client.getItemContainer(InventoryID.INVENTORY);
        if (itemContainer == null) return false;
        HashSet<Integer> droppedPickaxes = new HashSet<>(startingPickaxes);
        final Item[] items = itemContainer.getItems();
        for (int i = 0; i < INVENTORY_SIZE; i++) {
            if (i < items.length) {
                final Item item = items[i];
                if (item.getQuantity() > 0) {
                    //remove potential dropped since its in the inventory
                    droppedPickaxes.remove(item.getId());
                }
            }
        }
        return !droppedPickaxes.isEmpty();
    }
    void incrementTicksDropped() { ++numTicksPickaxeDropped; }
    void resetTicksDropped() { numTicksPickaxeDropped = 0; }
    int getNumTicksPickaxeDropped() { return numTicksPickaxeDropped; }
}

package com.ultimatevm;

import net.runelite.api.coords.WorldPoint;
import java.awt.Color;

public class PlayerPlatform extends TimedObject {
    private final double TICK_DESPAWN_TIME = 150;

    PlayerPlatform(WorldPoint worldLocation) {
        super(worldLocation, ObjectType.PLATFORM);
    }

    @Override
    public Color getStateColor() {
        double ticksLeft = getTimeLeft();
        if(ticksLeft < 10) return new Color(255, 50, 0);
        else if(ticksLeft < 75) return new Color(255, 187, 0);
        return new Color(0, 217, 0);
    }

    @Override
    public double getTimeLeft() { return TICK_DESPAWN_TIME - ticksPassed; }
    @Override
    public double getTimeRemaining()  {
        return Math.min(1, 1 - ticksPassed / TICK_DESPAWN_TIME);
    }
    @Override
    public boolean isTimeExpired() { return ticksPassed >= TICK_DESPAWN_TIME; }
}

package com.ultimatevm;

import java.util.LinkedList;
import java.util.Iterator;

public class StabilityTracker {

    //Constants
    public static final int STARTING_STABILITY = 50;
    private static final int MAX_STABILITY = 100;
    private static final int MAX_STABILITY_UPDATES = 3;
    private static final int MIN_STABILITY_CHANGE = -28;
    private static final int MAX_STABILITY_CHANGE = 24;

    private boolean hasResetHistory = false;
    private int currentStability;
    private int numDisplay;
    private LinkedList<Integer> stabilityHistory = new LinkedList<>();

    public StabilityTracker() {
        initialize();
        numDisplay = 3;
    }

    public void initialize() {
        currentStability = STARTING_STABILITY;
        stabilityHistory.clear();
        hasResetHistory = false;
    }

    public void resetStabilityHistory() {
        if(hasResetHistory) return;
        stabilityHistory.clear();
        hasResetHistory = true;
    }

    public boolean updateStability(int newStability) {
        if(currentStability == newStability) return false;
        int change = newStability - currentStability;
        if(change > MAX_STABILITY_CHANGE || change < MIN_STABILITY_CHANGE) return false;

        currentStability = newStability;

        addChange(change);
        //If stability is max highly likely the change was truncated so this update is invalid
        return currentStability != MAX_STABILITY;
    }

    private int calcTrend() {
        if(stabilityHistory.size() < 2) return 0;
        int currentTrend = 0, nextChange = Integer.MIN_VALUE;
        Iterator<Integer> it = stabilityHistory.iterator();
        while(it.hasNext()) {
            int change = (Integer)it.next();
            if(nextChange != Integer.MIN_VALUE) {
                currentTrend += (nextChange - change);
            }
            nextChange = change;
        }
        return currentTrend / (MAX_STABILITY_UPDATES - 1);
    }

    public boolean isFutureStabilityBad(int stabilityThreshold) {
        int trend = 0;
//        int trend = calcTrend();
//        if(trend >= 0) return false;
        return getCurrentChange() + trend <= stabilityThreshold;
    }
    public String getStabilityText() {
        if(stabilityHistory.isEmpty()) return "";

        StringBuilder builder = new StringBuilder();
        Iterator<Integer> it = stabilityHistory.iterator();
        int numIterations = 0;
        while(it.hasNext()) {
            if(numIterations == numDisplay)
                return " (" + builder.toString() + ")";

            if(++numIterations > 1) builder.append(",");

            int change = (Integer)it.next();
            if (change >= 0) {
                builder.append("<col=00ff00>").append(change).append("</col>");
            } else {
                builder.append("<col=ff0000>").append(Math.abs(change)).append("</col>");
            }
        }
        return " (" + builder.toString() + ")";
    }
    public int getCurrentStability() { return currentStability; }
    public int getCurrentChange() {
        if(stabilityHistory.isEmpty()) return 0;
        return stabilityHistory.getFirst();
    }
    public void addChange(int change) {
        stabilityHistory.addFirst(change);
        while(stabilityHistory.size() > MAX_STABILITY_UPDATES) stabilityHistory.removeLast();
    }
    public void setDisplayCount(int count) { numDisplay = count;}
}

package com.ultimatevm;

public class StabilityUpdateInfo {
    static private int numPlayers = 1;
    static public void resetPlayers() { numPlayers = 1;}
    static public int getNumPlayers() { return numPlayers; }
    static public boolean isSolo() { return numPlayers == 1;}
    static public void setNumPlayers(int players) {
        numPlayers = Math.max(numPlayers, players);
    }
    static public int getMinRNGVariation() {
        return -numPlayers / 3;
    }
    static public int getMaxRNGPossibleSize() { return (numPlayers / 3) + 2;}

    static public StatusState getPredictionState(StabilityUpdateInfo initialStabUpdate, VentStatusTimeline timeline) {
        if(initialStabUpdate == null) return timeline.getTimelinePredictionState();
        StatusState predictionState = new StatusState();
        //Iterate until we get a valid uncut range prediction
        int startingRNGMod = initialStabUpdate.RNGUpdateMod;
        for(int i = getMaxRNGPossibleSize() - 1; i >= 0; --i) {
            //Start with more common mods first
            initialStabUpdate.RNGUpdateMod = 1 - i;
            initialStabUpdate.calcStabilityChange();
            //Run a prediction with this new mod to see if we get a valid result
            predictionState = timeline.getTimelinePredictionState();
            if(predictionState.areRangesDefined()) break;
        }
        initialStabUpdate.RNGUpdateMod = startingRNGMod;
        initialStabUpdate.calcStabilityChange();
        return predictionState;
    }
    //Stability updates have a max rng mod of +1
    //and a min mod of -numPlayers / 3 for team sizes less than 6
    //team sizes 6 and up I am unsure
    private byte possibleRNGMods;
    private StatusState stabilityUpdateState;
    private int RNGUpdateMod;
    private final int tickTimeStamp, initialChange;
    private boolean isVerified;
    StabilityUpdateInfo(StatusState stabilityUpdate, int currentTick, int change) {
        possibleRNGMods = 0;
        tickTimeStamp = currentTick;
        isVerified = false;
        for(int i = 0; i < getMaxRNGPossibleSize(); ++i)
            possibleRNGMods |= (1 << i);

        //By default we assume the most common rng mod
        this.stabilityUpdateState = new StatusState(stabilityUpdate);
        this.initialChange = change;
        this.RNGUpdateMod = getMinRNGVariation();
        verifyByInvalidPoints();
        calcStabilityChange();
    }

    public void verifyByInvalidPoints() {
        if(!isValid()) return;
        if(isVerified()) return;

        for(int i = 0; i < getMaxRNGPossibleSize(); ++i) {
            int currentRNGMod = 1 - i;
            //check if this mod is possible
            if(!stabilityUpdateState.calcPredictedVentValues(initialChange - currentRNGMod)) {
                possibleRNGMods &= ~(1 << i);
            }
        }
        checkVerification();
    }
    public void verifyByBreakpointShift(StabilityUpdateInfo futureStabState, int movementAmount) {
        if(!isValid()) return;
        if(isVerified() && futureStabState.isVerified()) return;
        //Ensure all possible predicted numbers are on the same breakpoint
        if((Math.abs(movementAmount) % 3) != 0) return;
        //This will only work for one missing vent
        int[] missingVentIndices = futureStabState.getStabilityUpdateState().getUnidentifiedVentIndices();
        if(missingVentIndices.length != 1) return;

        int shift = movementAmount / 3;
        StatusState testState = new StatusState(stabilityUpdateState);
        //If there is no overlap mod is the same
        testState.setOverlappingRangesWith(futureStabState.getStabilityUpdateState());
        //Otherwise the mod is based off the difference between the two ranges
    }

    public void calcStabilityChange() {
        stabilityUpdateState.calcPredictedVentValues(initialChange - RNGUpdateMod);
    }
    public void updateVentValues(StatusState updatedState) {
        stabilityUpdateState.setVentsEqualTo(updatedState);
        verifyByInvalidPoints();
        calcStabilityChange();
    }
    public void updatePredictedState(StatusState predictedState, StabilityUpdateInfo prevStabInfo, int initalRNGMod) {
        if(predictedState.getVents()[0].isFreezeClipAccurate()) updateVentValues(predictedState);
        if(prevStabInfo == null || stabilityUpdateState.getNumIdentifiedVents() == prevStabInfo.getStabilityUpdateState().getNumIdentifiedVents()) {
            predictedState.setOverlappingRangesWith(getAllPossiblePredictedValuesState());
            trimDoubleVentRanges(predictedState);
        }
        else predictedState.setOverlappingRangesWith(getPossiblePredictedValuesState(initalRNGMod));
    }
    public StatusState getAllPossiblePredictedValuesState() {
        StatusState mergedPossiblities = new StatusState(stabilityUpdateState);
        for(int i = 0; i < getMaxRNGPossibleSize(); ++i) {
            StatusState testState = getPossiblePredictedValuesState(1 - i);
            mergedPossiblities.mergePredictedRangesWith(testState);
        }
        return mergedPossiblities;
    }
    public StatusState getPossiblePredictedValuesState(int rngMod) {
        StatusState possibleState = new StatusState(stabilityUpdateState);
        possibleState.calcPredictedVentValues(initialChange - rngMod);
        return possibleState;
    }

    private void checkVerification() {
        int numBitsOn = 0;
        for(int i = 0; i < getMaxRNGPossibleSize(); ++i) {
            int currentRNGMod = 1 - i;
            //set our rngMod to the lowest possible value (since it would be more common)
            if((possibleRNGMods & (1 << i)) != 0) {
                RNGUpdateMod = currentRNGMod;
                ++numBitsOn;
            }
        }
        if(numBitsOn == 1) {
            isVerified = true;
        }
    }
    private void trimDoubleVentRanges(StatusState predictedState) {
        if(predictedState.getNumKnownVents() != 1) return;
        StatusState mergedTrimmings = new StatusState();
        mergedTrimmings.clearAllRanges();
        for(int i = 0; i < getMaxRNGPossibleSize(); ++i) {
            StatusState testState = new StatusState(predictedState);
            testState.trimDoubleVentRanges(initialChange - (1 - i));
            mergedTrimmings.mergePredictedRangesWith(testState);
        }
        predictedState.setOverlappingRangesWith(mergedTrimmings);
    }

    //Accessors
    public final StatusState getStabilityUpdateState() { return stabilityUpdateState; }
    public boolean isValid() {
        if(stabilityUpdateState.isAllVentsIdentified()) return false;
        return stabilityUpdateState.isEnoughVentsIdentified();
    }
    public boolean isVerified() { return isVerified; }
    public int getTickTimeStamp() { return tickTimeStamp; }
    public int getRNGUpdateMod() { return RNGUpdateMod; }
    public int getInitialChange() { return initialChange; }
}

package com.ultimatevm;

import java.util.ArrayList;

import static com.ultimatevm.VentStatus.*;

public class StatusState {
    private static final char[] VENT_TAGS = {'A', 'B', 'C'};
    public static final int NUM_VENTS = 3;
    public static final int STABILITY_CHANGE_CONSTANT = -25;

    public static final int TRUNCATION_POSSIBILITIES = NUM_VENTS;

    private VentStatus[] vents = new VentStatus[NUM_VENTS];
    private int numIdentifiedVents;
    private int stabilityChange;
    private boolean hasReset;

    public static int getTotalVentUpdate(int change) {
        return (change - STABILITY_CHANGE_CONSTANT);
    }
    public static int calcStabilityChange(StatusState state) {
        return calcStabilityChange(state.getIdentifiedVentTotalValue());
    }
    public static int calcStabilityChange(int totalVentInfluence) {
        return STABILITY_CHANGE_CONSTANT + totalVentInfluence;
    }
    public static int makeMoveBitState(StatusState curr, StatusState prev) {
        boolean isAMoveValid = curr.getVents()[0].isIdentified() && prev.getVents()[0].isIdentified();
        boolean isBMoveValid = curr.getVents()[1].isIdentified() && prev.getVents()[1].isIdentified();
        boolean isCMoveValid = curr.getVents()[2].isIdentified() && prev.getVents()[2].isIdentified();

        int aMove = 3, bMove = 3, cMove = 3;
        if(isAMoveValid) aMove = Math.min(3, Math.abs(curr.getVents()[0].getActualValue() - prev.getVents()[0].getActualValue()));
        if(isBMoveValid) bMove = Math.min(3, Math.abs(curr.getVents()[1].getActualValue() - prev.getVents()[1].getActualValue()));
        if(isCMoveValid) cMove = Math.min(3, Math.abs(curr.getVents()[2].getActualValue() - prev.getVents()[2].getActualValue()));
        int bitState = aMove | (bMove << 2) | (cMove << 4);
        return bitState << 6;
    }

    public StatusState() {
        hasReset = false;
        numIdentifiedVents = 0;
        for(int i = 0; i < vents.length; ++i) {
            vents[i] = new VentStatus(VENT_TAGS[i]);
        }
    }
    public StatusState(StatusState state) {
        for(int i = 0; i < vents.length; ++i) {
            vents[i] = new VentStatus(VENT_TAGS[i]);
        }
        setEqualTo(state);
    }
    public void setVentEqualTo(StatusState state, int ventIndex) {
        //Update number of vents we have identified
        if(vents[ventIndex].isIdentified() && !state.vents[ventIndex].isIdentified())
            --numIdentifiedVents;
        if(!vents[ventIndex].isIdentified() && state.vents[ventIndex].isIdentified())
            ++numIdentifiedVents;

        vents[ventIndex].setEqualTo(state.vents[ventIndex]);
    }
    public void setVentsEqualTo(StatusState state) {
        for(int i = 0; i < vents.length; ++i) {
            setVentEqualTo(state, i);
        }
    }
    public void setEqualTo(StatusState state) {
        this.hasReset = state.hasReset;
        this.stabilityChange = state.stabilityChange;
        setVentsEqualTo(state);
    }
    public void clearAllRanges() {
        for(int i = 0; i < vents.length; ++i) {
            if(vents[i].isIdentified()) continue;
            vents[i].clearRanges();
        }
    }

    public int[] updateVentStatus(int[] ventStatus, int chambers) {
        numIdentifiedVents = 0;
        int[] changeStates = new int[NUM_VENTS];
        for(int i = 0; i < ventStatus.length; ++i) {
            changeStates[i] = vents[i].update(ventStatus[i], getDirectionFromChambers(i, chambers));
            if(vents[i].isIdentified()) ++numIdentifiedVents;
        }
        return changeStates;
    }
    public void updateVentMovement() {
        int[] currentVentInfluence = new int[]{0, 0};
        int[] previousVentInfluence = new int[]{0, 0};
        for(int i = 0; i < vents.length; ++i) {
            //keep track of influence before vent movement
            previousVentInfluence[0] = currentVentInfluence[0];
            previousVentInfluence[1] = currentVentInfluence[1];
            //The vent values BEFORE movement influences other vents below it
            vents[i].updateEstimatedMovementInfluence(currentVentInfluence);
            vents[i].updateMovement(previousVentInfluence);
        }
    }
    public boolean reverseMovement(int bitMoveState) {
        if(!isEnoughVentsKnown()) return false;
        int currentVentInfluence = 0, numReverseFailures = 0;
        for(int i = 0; i < vents.length; ++i) {
            int curMove = bitMoveState & (3 << (i * 2));
            curMove = (curMove >> (i * 2));
            boolean isKnownVent = vents[i].isIdentified() || vents[i].isFreezeClipAccurate();

            //Attempt to reverse the value if its move is unknown
            if(curMove == 3) {
                //If there was a previous failure we cannot reverse this
                int inf = STARTING_VENT_VALUE;
                if(numReverseFailures == 0) inf = vents[i].getReversedInfluence(currentVentInfluence);

                //Check if the value cannot be reversed
                if (inf == STARTING_VENT_VALUE) {
                    ++numReverseFailures;
                    //If this is a vent we care about reversing exit
                    if(isKnownVent) return false;
                    continue;
                }
                currentVentInfluence += inf;
                vents[i].doReversedMovement(currentVentInfluence);
            }
            else {
                //Set to its previous state
                vents[i].update(vents[i].getActualValue() - (curMove * vents[i].getDirection()), vents[i].getDirection());
                currentVentInfluence += VentStatus.getMovementInfluenceOfValue(vents[i].getActualValue());
            }
        }
        return true;
    }
    public void mergePredictedRangesWith(StatusState state) {
        for(int i = 0; i < NUM_VENTS; ++i) {
            if(vents[i].isIdentified()) continue;
            if(!state.vents[i].isRangeDefined()) continue;
            mergeVentWith(i, state.vents[i]);
        }
    }
    public void setOverlappingRangesWith(StatusState state) {
        for(int i = 0; i < NUM_VENTS; ++i) {
            if(vents[i].isIdentified()) continue;
            if(!vents[i].isRangeDefined()) continue;
            overlapVentWith(i, state.vents[i]);
        }
    }
    public boolean doFreezeClipping(int moveBitState) {
        int clippedValueState = 0;
        for(int i = 0; i < NUM_VENTS; ++i) {
            int curMove = moveBitState & (3 << (i * 2));
            curMove = (curMove >> (i * 2));
            switch(vents[i].getName()) {
                case 'A':
                    //Cant freeze clip based on A's movement
                    break;
                case 'B':
                    //Skip if not identified movement wont be accurate
                    if(!vents[i].isIdentified()) continue;
                    //Skip if A does not have defined ranges
                    if(!vents[0].isRangeDefined()) continue;
                    if(curMove == 0) {
                        //Skip if bounded
                        if(vents[i].isBounded()) continue;
                        //B cannot freeze unless A is 41-59
                        vents[0].doInnerBoundsClipping(41, 59);
                    } else if(curMove == 1) {
                        //Skip if B could be bounded
                        int actualValue = vents[i].getActualValue();
                        if(actualValue == 1 || actualValue == 99) continue;
                        //If B is 41-59 A must be outside of 41-59
                        if(vents[i].isWithinRange(41, 59)) vents[0].doOuterBoundsClipping(41, 59);
                        //Otherwise A must be 41-59 to slow B's movement
                        else vents[0].doInnerBoundsClipping(41, 59);
                    } else if(curMove == 2) {
                        //B cannot have full movement unless A is not 41-59
                        vents[0].doOuterBoundsClipping(41, 59);
                    }
                    //If A no longer has a valid range that means it was clipped
                    if(!vents[0].isRangeDefined()) clippedValueState |= 1;
                    break;
                case 'C':
                    //Skip if not identified movement wont be accurate
                    if(!vents[i].isIdentified()) continue;
                    //Skip if neither A or B have defined ranges
                    boolean isADefined = vents[0].isRangeDefined();
                    boolean isBDefined = vents[1].isRangeDefined();
                    if(!isADefined && !isBDefined) continue;
                    boolean canAFreeze = vents[0].isWithinRange(41, 59);
                    boolean canBFreeze = vents[1].isWithinRange(41, 59);
                    if(curMove == 0) {
                        //Skip if bounded
                        if(vents[i].isBounded()) continue;
                        //If C is outside 41-59 then both A and B must be 41-59
                        if(!vents[i].isWithinRange(41, 59)) {
                            vents[0].doInnerBoundsClipping(41, 59);
                            vents[1].doInnerBoundsClipping(41, 59);
                        }
                        //Otherwise at least either A or B must be 41-59
                        else {
                            if(!canAFreeze) vents[1].doInnerBoundsClipping(41, 59);
                            if(!canBFreeze) vents[0].doInnerBoundsClipping(41, 59);
                        }
                    }
                    else if(curMove == 1) {
                        //Skip if C could be bounded
                        int actualValue = vents[i].getActualValue();
                        if(actualValue == 1 || actualValue == 99) continue;

                        if(vents[i].isWithinRange(41, 59)) {
                            //C cannot have full movement unless A and B arent 41-59
                            vents[0].doOuterBoundsClipping(41, 59);
                            vents[1].doOuterBoundsClipping(41, 59);
                        }
                        //Otherwise at least either A or B must be 41-59
                        else {
                            if(!canAFreeze) vents[1].doInnerBoundsClipping(41, 59);
                            if(!canBFreeze) vents[0].doInnerBoundsClipping(41, 59);
                        }
                    }
                    else if(curMove == 2) {
                        //C cannot have full movement unless A and B arent 41-59
                        vents[0].doOuterBoundsClipping(41, 59);
                        vents[1].doOuterBoundsClipping(41, 59);
                    }
                    //If A no longer has a valid range that means it was clipped
                    if(isADefined && !vents[0].isRangeDefined()) clippedValueState |= 1;
                    //If B no longer has a valid range that means it was clipped
                    if(isBDefined && !vents[1].isRangeDefined()) clippedValueState |= 2;
                    break;
            }
        }
        //Make freeze clip accurate A
        vents[0].makeFreezeClipAccurate();

        return clippedValueState != 0;
    }
    public void forceReset() {
        numIdentifiedVents = 0;
        for(int i = 0; i < vents.length; ++i) {
            vents[i].doVMReset();
        }
    }
    public void doVMReset() {
        if(hasReset) return;
        forceReset();
        hasReset = true;
    }
    public void doHalfSpaceClipping(int ventsToClip, int clipInfo) {
        for(int i = 0; i < NUM_VENTS; ++i) {
            if(vents[i].isIdentified()) continue;
            if((ventsToClip & (1 << i)) == 0) continue;

            int ventDirection = vents[i].getDirection();
            //0 - up, 1 - down
            boolean downwardClip = ((clipInfo & (1 << i)) != 0);

            //Vent percent is moving down
            if(ventDirection < 0) {
                if(downwardClip) vents[i].doInnerBoundsClipping(0, 53);
                else vents[i].doInnerBoundsClipping(47, 100);
            }
            //Vent percent is moving up
            else if(ventDirection > 0) {
                if(downwardClip) vents[i].doInnerBoundsClipping(47, 100);
                else vents[i].doInnerBoundsClipping(0, 53);
            }
        }
    }
    public int[] getUnidentifiedVentIndices() {
        int curIndex = 0;
        int[] indices = new int[NUM_VENTS - numIdentifiedVents];
        for(int i = 0; i < vents.length; ++i) {
            if(this.vents[i].isIdentified()) continue;
            indices[curIndex++] = i;
        }
        return indices;
    }
    public int[] getUnknownVentIndices() {
        int curIndex = 0;
        int[] indices = new int[NUM_VENTS - getNumKnownVents()];
        for(int i = 0; i < vents.length; ++i) {
            if(this.vents[i].isIdentified()) continue;
            if(this.vents[i].isFreezeClipAccurate()) continue;
            indices[curIndex++] = i;
        }
        return indices;
    }
    public boolean calcPredictedVentValues(int change) {
        stabilityChange = change;
        if(isAllVentsKnown()) return false;
        if(!isEnoughVentsKnown()) return false;
        int[] indices = getUnknownVentIndices();
        if(getNumKnownVents() == 1) return calcDoubleVentValue(new VentStatus[]{vents[indices[0]], vents[indices[1]]}, change);
        return calcSingleVentValue(vents[indices[0]], change);
    }
    public void alignPredictedRangesWith(StatusState state) {
        for(int i = 0; i < NUM_VENTS; ++i) {
            if(vents[i].isIdentified()) continue;
            if(!state.vents[i].isRangeDefined()) continue;

            if(!vents[i].isRangeDefined()) mergeVentWith(i, state.vents[i]);
            else overlapVentWith(i, state.vents[i]);
        }
    }
    public void trimDoubleVentRanges(int change) {
        if(getNumKnownVents() != 1) return;
        int[] ventIndices = getUnknownVentIndices();
        int pointsNeeded = getTotalVentUpdate(change) - getIdentifiedVentTotalValue();
        trimRangesBasedOn(pointsNeeded, vents[ventIndices[1]], vents[ventIndices[0]]);
        trimRangesBasedOn(pointsNeeded, vents[ventIndices[0]], vents[ventIndices[1]]);
    }
    public void clipPredictedStabilityMismatch(int stabilityAmount) {
        if(numIdentifiedVents != 2) return;
        int ventIndex = getUnidentifiedVentIndices()[0];
        if(!vents[ventIndex].isTwoSeperateValues()) return;
        int partialVentUpdate = getIdentifiedVentTotalValue();

        //Exit if both changes are equal the stability amount or are equal
        int lowerBoundStart = vents[ventIndex].getLowerBoundStart();
        int lowerBoundStability = calcStabilityChange(partialVentUpdate + getStabilityInfluence(lowerBoundStart));
        int upperBoundEnd = vents[ventIndex].getUpperBoundEnd();
        int upperBoundStability = calcStabilityChange(partialVentUpdate + getStabilityInfluence(upperBoundEnd));
        if(lowerBoundStability >= stabilityAmount && upperBoundStability >= stabilityAmount) return;
        if(lowerBoundStability == upperBoundStability) return;

        //Check and clip the range with the lowest stability value
        boolean clipLowerBound = lowerBoundStability < upperBoundStability;
        int boundStart, boundEnd;
        if(clipLowerBound) {
            boundStart = lowerBoundStart;
            boundEnd = vents[ventIndex].getLowerBoundEnd();
            for(; boundStart <= boundEnd; ++boundStart) {
                int change = calcStabilityChange(partialVentUpdate + getStabilityInfluence(boundStart));
                if(change >= stabilityAmount) break;
            }
            if(boundStart > boundEnd) {
                int upperBoundStart = vents[ventIndex].getUpperBoundStart();
                vents[ventIndex].clearRanges();
                vents[ventIndex].setLowerBoundRange(upperBoundStart, upperBoundEnd);
                vents[ventIndex].setUpperBoundRange(upperBoundStart, upperBoundEnd);
            }
            else vents[ventIndex].setLowerBoundRange(boundStart, boundEnd);
        } else {
            boundStart = vents[ventIndex].getUpperBoundStart();
            boundEnd = upperBoundEnd;
            for(; boundStart <= boundEnd; --boundEnd) {
                int change = calcStabilityChange(partialVentUpdate + getStabilityInfluence(boundEnd));
                if(change >= stabilityAmount) break;
            }
            if(boundStart > boundEnd) {
                int lowerBoundEnd = vents[ventIndex].getLowerBoundEnd();
                vents[ventIndex].clearRanges();
                vents[ventIndex].setLowerBoundRange(lowerBoundStart, lowerBoundEnd);
                vents[ventIndex].setUpperBoundRange(lowerBoundStart, lowerBoundEnd);
            }
            else vents[ventIndex].setUpperBoundRange(boundStart, boundEnd);
        }
    }
    public int getFutureStabilityChange(UltimateVolcanicMineConfig.PredictionScenario scenario) {
        //Check if our estimates are precise enough for predicted stability changes
        if(!isEnoughVentsIdentified()) return STARTING_VENT_VALUE;
        int[] unknownIndices = getUnknownVentIndices();
        int numDoubleRanges = 0, rangeLengthThreshold = 6;
        for(int i = 0; i < unknownIndices.length; ++i) {
            if(!vents[unknownIndices[i]].isRangeDefined())
                return STARTING_VENT_VALUE;
            if(vents[unknownIndices[i]].isTwoSeperateValues())
                ++numDoubleRanges;

            int lowerLength = vents[unknownIndices[i]].getLowerBoundEnd();
            lowerLength -= vents[unknownIndices[i]].getLowerBoundStart();
            if(lowerLength > rangeLengthThreshold) return STARTING_VENT_VALUE;

            int upperLength = vents[unknownIndices[i]].getUpperBoundEnd();
            upperLength -= vents[unknownIndices[i]].getUpperBoundStart();
            if(upperLength > rangeLengthThreshold) return STARTING_VENT_VALUE;
        }
        if(numDoubleRanges > 1) return STARTING_VENT_VALUE;

        //If all is good calculate the predicted stability change
        int totalVentValue = 0;
        ArrayList<VentStatus> estimatedVents = new ArrayList<>();
        for(int i = 0; i < NUM_VENTS; ++i) {
            if(vents[i].isIdentified() || vents[i].isFreezeClipAccurate())
                totalVentValue += vents[i].getStabilityInfluence();
            else
                estimatedVents.add(vents[i]);
        }

        int estimatedVentValue = Integer.MAX_VALUE;
        for(int i = 0; i < estimatedVents.size(); ++i) {
            VentStatus vent = estimatedVents.get(i);
            int avgLower = (vent.getLowerBoundEnd() + vent.getLowerBoundStart()) / 2;
            int avgUpper = (vent.getUpperBoundStart() + vent.getUpperBoundEnd()) / 2;
            int ventUpdate = 0;

            switch(scenario) {
                case WORST_CASE:
                    ventUpdate = Math.min(getStabilityInfluence(avgLower), getStabilityInfluence(avgUpper));
                    break;
                case BEST_CASE:
                    ventUpdate = Math.max(getStabilityInfluence(avgLower), getStabilityInfluence(avgUpper));
                    break;
                default:
                    //Average-case (crap)
                    ventUpdate = (getStabilityInfluence(avgLower) + getStabilityInfluence(avgUpper)) / 2;
                    break;
            }

            if(estimatedVentValue == Integer.MAX_VALUE) estimatedVentValue = ventUpdate;
            else estimatedVentValue += ventUpdate;
        }

        if(estimatedVentValue != Integer.MAX_VALUE)
            totalVentValue += estimatedVentValue;
        return calcStabilityChange(totalVentValue) + StabilityUpdateInfo.getMinRNGVariation();
    }

    //Helpers
    private boolean calcSingleVentValue(VentStatus vent, int change) {
        int partialVentUpdate = getIdentifiedVentTotalValue();
        int pointsNeeded = getTotalVentUpdate(change) - partialVentUpdate;
        //Exit if the value we need is out of range - stability change is invalid
        if(pointsNeeded < 0 || pointsNeeded > (int)VENT_STABILITY_WEIGHT) return false;

        float missingInversePercent = 1.0f - (pointsNeeded / VENT_STABILITY_WEIGHT);
        int missingVentUpdate = (int)Math.ceil(PERFECT_VENT_VALUE * missingInversePercent);

        int lowerBoundStart = (PERFECT_VENT_VALUE - TRUNCATION_POSSIBILITIES) - missingVentUpdate;
        int lowerBoundEnd = (PERFECT_VENT_VALUE + TRUNCATION_POSSIBILITIES) - missingVentUpdate;
        int upperBoundStart = (PERFECT_VENT_VALUE - TRUNCATION_POSSIBILITIES) + missingVentUpdate;
        int upperBoundEnd = (PERFECT_VENT_VALUE + TRUNCATION_POSSIBILITIES) + missingVentUpdate;
        while(lowerBoundStart < lowerBoundEnd) {
            int newChange1 = calcStabilityChange(partialVentUpdate + getStabilityInfluence(lowerBoundStart));
            int newChange2 = calcStabilityChange(partialVentUpdate + getStabilityInfluence(lowerBoundEnd));
            if(newChange1 == change && newChange2 == change) break;

            if(newChange1 != change) {
                ++lowerBoundStart; --upperBoundEnd;
            }
            if(newChange2 != change) {
                --lowerBoundEnd; ++upperBoundStart;
            }
        }

        vent.clearRanges();
        vent.setLowerBoundRange(lowerBoundStart, lowerBoundEnd);
        vent.setUpperBoundRange(upperBoundStart, upperBoundEnd);
        return true;
    }
    private boolean calcDoubleVentValue(VentStatus[] vents, int change) {
        int partialVentUpdate = getIdentifiedVentTotalValue();
        int pointsNeeded = getTotalVentUpdate(change) - partialVentUpdate;
        //Exit if the value we need is out of range - stability change is invalid
        if(pointsNeeded < 0 || pointsNeeded > (int)VENT_STABILITY_WEIGHT * 2) return false;

        int totalLowerBoundStart = STARTING_VENT_VALUE;
        int totalLowerBoundEnd = STARTING_VENT_VALUE;
        int totalUpperBoundStart = STARTING_VENT_VALUE;
        int totalUpperBoundEnd = STARTING_VENT_VALUE;

        //Try all of the possible double vent combos
        for(int takenPoints = 0; takenPoints <= (int)VENT_STABILITY_WEIGHT; ++takenPoints) {
            int remainingPoints = pointsNeeded - takenPoints;
            if(remainingPoints < 0 || remainingPoints > (int)VENT_STABILITY_WEIGHT) continue;
            float missingInversePercent = 1.0f - (takenPoints / VENT_STABILITY_WEIGHT);
            int missingVentUpdate = (int)Math.ceil(PERFECT_VENT_VALUE * missingInversePercent);

            int maxDistance = Math.min(MAX_VENT_VALUE - PERFECT_VENT_VALUE, missingVentUpdate);
            int minDistance = Math.max(0, missingVentUpdate - PERFECT_VENT_VALUE);

            int lowerBoundStart = (PERFECT_VENT_VALUE - TRUNCATION_POSSIBILITIES) - maxDistance;
            int lowerBoundEnd = (PERFECT_VENT_VALUE + TRUNCATION_POSSIBILITIES) - minDistance;
            int upperBoundStart = (PERFECT_VENT_VALUE - TRUNCATION_POSSIBILITIES) + minDistance;
            int upperBoundEnd = (PERFECT_VENT_VALUE + TRUNCATION_POSSIBILITIES) + maxDistance;

            //Get full possible range values
            while(lowerBoundStart < lowerBoundEnd) {
                int newChange1 = calcStabilityChange(partialVentUpdate + remainingPoints + getStabilityInfluence(lowerBoundStart));
                int newChange2 = calcStabilityChange(partialVentUpdate + remainingPoints + getStabilityInfluence(lowerBoundEnd));
                if(newChange1 == change && newChange2 == change) break;

                if(newChange1 != change) {
                    ++lowerBoundStart; --upperBoundEnd;
                }
                if(newChange2 != change) {
                    --lowerBoundEnd; ++upperBoundStart;
                }
            }

            //Update our total bounds
            if(totalLowerBoundStart == STARTING_VENT_VALUE) totalLowerBoundStart = lowerBoundStart;
            else totalLowerBoundStart = Math.min(totalLowerBoundStart, lowerBoundStart);

            if(totalLowerBoundEnd == STARTING_VENT_VALUE) totalLowerBoundEnd = lowerBoundEnd;
            else totalLowerBoundEnd = Math.max(totalLowerBoundEnd, lowerBoundEnd);

            if(totalUpperBoundStart == STARTING_VENT_VALUE) totalUpperBoundStart = upperBoundStart;
            else totalUpperBoundStart = Math.min(totalUpperBoundStart, upperBoundStart);

            if(totalUpperBoundEnd == STARTING_VENT_VALUE) totalUpperBoundEnd = upperBoundEnd;
            else totalUpperBoundEnd = Math.max(totalUpperBoundEnd, upperBoundEnd);
        }

        //Set both vents accordingly
        for(int i = 0; i < vents.length; ++i) {
            vents[i].clearRanges();
            vents[i].setLowerBoundRange(totalLowerBoundStart, totalLowerBoundEnd);
            vents[i].setUpperBoundRange(totalUpperBoundStart, totalUpperBoundEnd);
        }
        return true;
    }
    private int getDirectionFromChambers(int index, int chambers) { return (chambers & (1 << index)) != 0 ? 1 : -1;}
    private int getIdentifiedVentTotalValue() {
        int totalVentUpdate = 0;
        for(int i = 0; i < NUM_VENTS; ++i) {
            totalVentUpdate += vents[i].getStabilityInfluence();
        }
        return totalVentUpdate;
    }
    private void mergeVentWith(int index, VentStatus toMergeWith) {
        if(vents[index].isRangeDefined()) {
            vents[index].mergeLowerBoundRanges(toMergeWith.getLowerBoundStart(),
                    toMergeWith.getLowerBoundEnd());
            vents[index].mergeUpperBoundRanges(toMergeWith.getUpperBoundStart(),
                    toMergeWith.getUpperBoundEnd());
            //Merge ranges if they are both overlap
            if(vents[index].isUpperBoundWithinRange(vents[index].getLowerBoundStart(), vents[index].getLowerBoundEnd())) {
                vents[index].mergeUpperBoundRanges(vents[index].getLowerBoundStart(), vents[index].getLowerBoundEnd());
                vents[index].mergeLowerBoundRanges(vents[index].getUpperBoundStart(), vents[index].getUpperBoundEnd());
            }
        } else {
            vents[index].setLowerBoundRange(toMergeWith.getLowerBoundStart(), toMergeWith.getLowerBoundEnd());
            vents[index].setUpperBoundRange(toMergeWith.getUpperBoundStart(), toMergeWith.getUpperBoundEnd());
        }
    }
    private void overlapVentWith(int index, VentStatus toOverlapWith) {
        //Get all possible range combinations
        int[] lowerLower = vents[index].getOverlappedLowerBoundRange(toOverlapWith.getLowerBoundStart(),
                toOverlapWith.getLowerBoundEnd());
        int[] lowerUpper = vents[index].getOverlappedLowerBoundRange(toOverlapWith.getUpperBoundStart(),
                toOverlapWith.getUpperBoundEnd());
        int[] upperUpper = vents[index].getOverlappedUpperBoundRange(toOverlapWith.getUpperBoundStart(),
                toOverlapWith.getUpperBoundEnd());
        int[] upperLower = vents[index].getOverlappedUpperBoundRange(toOverlapWith.getLowerBoundStart(),
                toOverlapWith.getLowerBoundEnd());
        boolean isLowerLowerValid = !(lowerLower[0] == -1 && lowerLower[1] == -1);
        boolean isLowerUpperValid = !(lowerUpper[0] == -1 && lowerUpper[1] == -1);
        boolean isUpperUpperValid = !(upperUpper[0] == -1 && upperUpper[1] == -1);
        boolean isUpperLowerValid = !(upperLower[0] == -1 && upperLower[1] == -1);
        boolean isLowerValid = isLowerLowerValid || isLowerUpperValid;
        boolean isUpperValid = isUpperLowerValid || isUpperUpperValid;

        //Exit if neither range has any overlap
        vents[index].clearRanges();
        if(!isLowerValid && !isUpperValid) return;

        //All overlaps are valid edge case
        boolean isBothLowerValid = isLowerUpperValid && isLowerLowerValid;
        boolean isBothUpperValid = isUpperLowerValid && isUpperUpperValid;
        if(isBothLowerValid && isBothUpperValid) {
            vents[index].setLowerBoundRange(lowerLower[0], lowerLower[1]);
            vents[index].setUpperBoundRange(upperUpper[0], upperUpper[1]);
            return;
        }

        //Lower bound range overlaps with another range
        if(isLowerValid) {
            if(isBothLowerValid) {
                vents[index].setLowerBoundRange(lowerLower[0], lowerUpper[1]);
            } else {
                if (isLowerLowerValid) vents[index].setLowerBoundRange(lowerLower[0], lowerLower[1]);
                else vents[index].setLowerBoundRange(lowerUpper[0], lowerUpper[1]);
            }
            //If only lower bound is valid set upper bound range as well
            if(!isUpperValid) vents[index].setUpperBoundRange(vents[index].getLowerBoundStart(), vents[index].getLowerBoundEnd());
        }
        //Upper bound range overlaps with another range
        if(isUpperValid) {
            if(isBothUpperValid) {
                vents[index].setUpperBoundRange(upperLower[0], upperUpper[1]);
            } else {
                if (isUpperUpperValid) vents[index].setUpperBoundRange(upperUpper[0], upperUpper[1]);
                else vents[index].setUpperBoundRange(upperLower[0], upperLower[1]);
            }
            //If only upper bound is valid set lower bound range as well
            if(!isLowerValid) vents[index].setLowerBoundRange(vents[index].getUpperBoundStart(), vents[index].getUpperBoundEnd());
        }
    }

    //Double Vent range trimming
    private void trimRangesBasedOn(int pointsNeeded, VentStatus toTrim, VentStatus trimSource) {
        if(!toTrim.isRangeDefined()) return;
        if(toTrim.isTwoSeperateValues()) {
            int[] lowerResult = trimSingleSeperateRange(pointsNeeded, trimSource,
                    new int[]{toTrim.getLowerBoundStart(), toTrim.getLowerBoundEnd()});
            boolean isLowerResultValid = (lowerResult[0] != -1 && lowerResult[1] != -1);
            int[] upperResult = trimSingleSeperateRange(pointsNeeded, trimSource,
                    new int[]{toTrim.getUpperBoundStart(), toTrim.getUpperBoundEnd()});
            boolean isUpperResultValid = (upperResult[0] != -1 && upperResult[1] != -1);

            toTrim.clearRanges();
            if(!isLowerResultValid && !isUpperResultValid) return;

            if(isLowerResultValid && isUpperResultValid) {
                toTrim.setLowerBoundRange(lowerResult[0], lowerResult[1]);
                toTrim.setUpperBoundRange(upperResult[0], upperResult[1]);
            } else if(isLowerResultValid) {
                toTrim.setLowerBoundRange(lowerResult[0], lowerResult[1]);
                toTrim.setUpperBoundRange(lowerResult[0], lowerResult[1]);
            } else {
                toTrim.setLowerBoundRange(upperResult[0], upperResult[1]);
                toTrim.setUpperBoundRange(upperResult[0], upperResult[1]);
            }
        } else {
            int boundStart = toTrim.getLowerBoundStart();
            int boundEnd = toTrim.getLowerBoundEnd();
            int lowerBoundStart = Integer.MAX_VALUE, upperBoundEnd = Integer.MIN_VALUE;
            int lowerBoundEnd = MIN_VENT_VALUE, upperBoundStart = MAX_VENT_VALUE;
            //Iterate through all possibilities considering that the range couls
            //break in two
            while (boundStart <= boundEnd) {
                int missingPoints = pointsNeeded - getStabilityInfluence(boundStart);
                boolean isBoundStartValid = doesVentSourceHaveRange(trimSource, missingPoints);

                if(isBoundStartValid) {
                    //Smallest valid bound start is our new lowerBoundStart
                    lowerBoundStart = Math.min(boundStart, lowerBoundStart);
                    //Largest valid bound start is our new lowerBoundEnd
                    lowerBoundEnd = Math.max(boundStart, lowerBoundEnd);
                }

                missingPoints = pointsNeeded - getStabilityInfluence(boundEnd);
                boolean isBoundEndValid = doesVentSourceHaveRange(trimSource, missingPoints);

                if(isBoundEndValid) {
                    //Largest valid bound end is our new upperBoundEnd
                    upperBoundEnd = Math.max(boundEnd, upperBoundEnd);
                    //Smallest valid bound end is our new upperBoundStart
                    upperBoundStart = Math.min(boundEnd, upperBoundStart);
                }

                ++boundStart; --boundEnd;
            }

            toTrim.clearRanges();
            if(lowerBoundStart == Integer.MAX_VALUE && upperBoundEnd == Integer.MIN_VALUE)
                return;

            if(lowerBoundStart == Integer.MAX_VALUE) {
                toTrim.setLowerBoundRange(upperBoundStart, upperBoundEnd);
                toTrim.setUpperBoundRange(upperBoundStart, upperBoundEnd);
            }
            else if(upperBoundEnd == Integer.MIN_VALUE) {
                toTrim.setLowerBoundRange(lowerBoundStart, lowerBoundEnd);
                toTrim.setUpperBoundRange(lowerBoundStart, lowerBoundEnd);
            }
            else {
                toTrim.setLowerBoundRange(lowerBoundStart, lowerBoundEnd);
                toTrim.setUpperBoundRange(upperBoundStart, upperBoundEnd);
            }
        }
    }
    private int[] trimSingleSeperateRange(int pointsNeeded, VentStatus trimSource, int[] rangeBounds) {
        int boundStart = rangeBounds[0];
        int boundEnd = rangeBounds[1];
        while (boundStart <= boundEnd) {
            int missingPoints = pointsNeeded - getStabilityInfluence(boundStart);
            boolean isBoundStartValid = doesVentSourceHaveRange(trimSource, missingPoints);
            if(!isBoundStartValid) ++boundStart;

            missingPoints = pointsNeeded - getStabilityInfluence(boundEnd);
            boolean isBoundEndValid = doesVentSourceHaveRange(trimSource, missingPoints);
            if(!isBoundEndValid) --boundEnd;

            if(isBoundStartValid && isBoundEndValid) break;
        }
        if(boundStart > boundEnd) return new int[]{-1, -1};
        return new int[]{boundStart, boundEnd};
    }
    private boolean doesVentSourceHaveRange(VentStatus trimSource, int missingPoints) {
        int[] lowerRange = VentStatus.pointsToLowerRange(missingPoints);
        int[] upperRange = VentStatus.pointsToUpperRange(missingPoints);
        boolean isLowerValid = trimSource.isWithinRange(lowerRange[0], lowerRange[1]);
        boolean isUpperValid = trimSource.isWithinRange(upperRange[0], upperRange[1]);
        return (isLowerValid || isUpperValid);
    }

    //Accessors
    public boolean hasDoneVMReset() { return hasReset; }
    public boolean isEnoughVentsIdentified() { return numIdentifiedVents > 0; }
    public boolean isEnoughVentsKnown() { return getNumKnownVents() > 0; }
    public boolean isAllVentsIdentified() { return numIdentifiedVents == NUM_VENTS; }
    public boolean isAllVentsKnown() { return getNumKnownVents() == NUM_VENTS; }
    public final VentStatus[] getVents() { return vents; }
    public int getStabilityChange() { return stabilityChange; }
    public int getNumIdentifiedVents() { return numIdentifiedVents; }
    public int getNumKnownVents() {
        int knownCount = vents[0].isFreezeClipAccurate() ? 1 : 0;
        return knownCount + numIdentifiedVents;
    }
    public boolean areRangesDefined() {
        //All ranges must be defined for this
        int[] missingVentIndices = getUnidentifiedVentIndices();
        for(int i = 0; i < missingVentIndices.length; ++i) {
            if(!vents[missingVentIndices[i]].isRangeDefined()) return false;
        }
        return true;
    }
}

package com.ultimatevm;

import java.awt.Color;
import net.runelite.api.coords.WorldPoint;

public abstract class TimedObject {
    public enum ObjectType {
        ROCK,
        PLATFORM
    }

    protected double ticksPassed;
    private final WorldPoint worldLocation;
    private final ObjectType type;

    TimedObject(WorldPoint worldLocation, ObjectType type) {
        this.worldLocation = worldLocation;
        this.type = type;
    }

    public Color getStateColor() {
        return new Color(0, 0, 0);
    }
    public void updateTimeRemaining() {
        ++ticksPassed;
    }

    public double getTimeLeft() { return ticksPassed; }
    public double getTimeRemaining()  {
        return ticksPassed;
    }
    public WorldPoint getWorldLocation() { return worldLocation; }
    public ObjectType getObjectType() { return type; }
    public boolean isTimeExpired() { return true; }
}

package com.ultimatevm;

import java.awt.*;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.ColorUtil;

public class TimedObjectOverlay extends Overlay {
    private final Client client;
    private final UltimateVolcanicMineConfig config;
    private TimedObjectTracker objTracker;

    @Inject
    TimedObjectOverlay(Client client, UltimateVolcanicMineConfig config)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.config = config;
    }

    public void setRockTracker(TimedObjectTracker rockTracker) {
        this.objTracker = rockTracker;
    }

    private void renderProgressPie(Graphics2D graphics, final Point canvasLocation, final TimedObject obj) {
        final ProgressPieComponent progressPieComponent = new ProgressPieComponent();
        progressPieComponent.setPosition(canvasLocation);
        progressPieComponent.setProgress(obj.getTimeRemaining());
        Color stateColor = obj.getStateColor();

        progressPieComponent.setBorderColor(stateColor);
        progressPieComponent.setFill(ColorUtil.colorWithAlpha(stateColor, (int) (stateColor.getAlpha() / 2.5)));
        progressPieComponent.render(graphics);
    }
    private void renderNumber(Graphics2D graphics, final Point canvasLocation, final TimedObject obj) {
        int currentTicks = (int)obj.getTimeLeft();
        if(currentTicks > config.numberThreshold()) return;
        final TextComponent textComponent = new TextComponent();
        textComponent.setText(Integer.toString(currentTicks));
        textComponent.setFont(new Font("Arial Bold", Font.BOLD, 16));
        textComponent.setPosition(new java.awt.Point(canvasLocation.getX()-10, canvasLocation.getY()));
        textComponent.setColor(obj.getStateColor());
        textComponent.render(graphics);
    }
    private void renderBasedOnMode(UltimateVolcanicMineConfig.TimingRenderMode mode, Graphics2D graphics, final Point canvasLocation, final TimedObject obj) {
        switch(mode) {
            case PROGRESS_PIE:
                renderProgressPie(graphics, canvasLocation, obj);
                break;

            case NUMBER:
                renderNumber(graphics, canvasLocation, obj);
                break;
        }
    }
    @Override
    public Dimension render(Graphics2D graphics)
    {
        for (TimedObject obj : objTracker.getObjects()) {
            final LocalPoint localLocation = LocalPoint.fromWorld(client, obj.getWorldLocation());
            if (localLocation == null) continue;

            final Point canvasLocation = Perspective.localToCanvas(client, localLocation, client.getPlane());
            if (canvasLocation == null) continue;

            switch(obj.getObjectType()) {
                case ROCK:
                    if(!config.rockTimer()) continue;
                    renderBasedOnMode(config.rockRenderMode(), graphics, canvasLocation, obj);
                    break;

                case PLATFORM:
                    if(!config.platformTimer()) continue;
                    renderBasedOnMode(config.platformRenderMode(), graphics, canvasLocation, obj);
                    break;
            }
        }
        return null;
    }
}

package com.ultimatevm;

import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import net.runelite.api.coords.WorldPoint;

public class TimedObjectTracker {
    HashSet<Integer> positionCodes;
    LinkedList<TimedObject> timedObjects;
    public TimedObjectTracker() {
        timedObjects = new LinkedList<>();
        positionCodes = new HashSet<>();
    }

    public void addObject(WorldPoint worldLocation, TimedObject.ObjectType type) {
        int positionCode = (worldLocation.getX() << 16) | worldLocation.getY();
        if(positionCodes.contains(positionCode)) return;
        positionCodes.add(positionCode);
        switch(type) {
            case ROCK:
                timedObjects.addLast(new CappingRock(worldLocation));
                break;

            case PLATFORM:
                timedObjects.addLast(new PlayerPlatform(worldLocation));
                break;
        }
    }
    public void clearRocks() {
        timedObjects.clear();
        positionCodes.clear();
    }
    public void updateRockTimers() {
        for (TimedObject obj : timedObjects) {
            obj.updateTimeRemaining();
        }
        removeExpiredRocks();
    }
    private void removeExpiredRocks() {
        Iterator<TimedObject> it = timedObjects.iterator();
        while(it.hasNext()) {
            TimedObject obj = it.next();
            if(!obj.isTimeExpired()) continue;
            int positionCode = (obj.getWorldLocation().getX() << 16) | obj.getWorldLocation().getY();
            positionCodes.remove(positionCode);
            it.remove();
        }
    }

    public final LinkedList<TimedObject> getObjects() { return timedObjects; }
}

package com.ultimatevm;

import java.util.LinkedList;

public class TimelineCache {
    public LinkedList<StatusState> possibleStates;
    public StabilityUpdateInfo prevStabInfo;
    public StatusState predictedState;
    public int startingTick, i;
    public int previousMovementTick, numTicksNegativePredictedStability;
    public int mostRecentIdentifyTick;

    TimelineCache() {

    }
    void initalize(StatusState initialState, int startTick) {
        possibleStates = new LinkedList<>();
        prevStabInfo = null;
        predictedState = new StatusState(initialState);
        i = startingTick = previousMovementTick = startTick;
        mostRecentIdentifyTick = startTick;
        numTicksNegativePredictedStability = 0;
        possibleStates.push(predictedState);
    }
}

package com.ultimatevm;

import net.runelite.client.config.Config;
import net.runelite.client.config.*;

@ConfigGroup("ultimate-volcanic-mine")
public interface UltimateVolcanicMineConfig extends Config
{
	enum PredictionScenario
	{
		WORST_CASE,
		BEST_CASE
	}

	enum TimingRenderMode {
		PROGRESS_PIE,
		NUMBER
	}

	@ConfigSection(
			name = "Display",
			description = "All the options for how your interface to look",
			position = 0,
			closedByDefault = false
	)
	String display = "display";
	@ConfigItem(
			position = 1,
			keyName = "capCounter",
			name = "Cap counter",
			description = "Displays an infobox with the total vents capped",
			section = display
	)
	default boolean capCounter()
	{
		return true;
	}
	@ConfigItem(
			keyName = "stabilityUpdateHistoryCount",
			name = "Stability Update History",
			description = "The number of stability updates to track",
			position = 2,
			section = display
	)
	@Range(
			max = 3,
			min = 0
	)
	default int stabilityUpdateHistoryCount()
	{
		return 3;
	}
	@ConfigItem(
			keyName = "predictedStabilityChangeHistoryCount",
			name = "Predicted Stability Change History",
			description = "The number of predicted stability changes to track",
			position = 3,
			section = display
	)
	@Range(
			max = 3,
			min = 0
	)
	default int predictedStabilityChangeHistoryCount()
	{
		return 1;
	}
	@ConfigItem(
			position = 4,
			keyName = "ventStatusUpdateHistory",
			name = "Vent Status Update History",
			description = "Sends a chat message with the vent status for each stability update",
			section = display
	)
	default boolean ventStatusUpdateHistory()
	{
		return false;
	}
	@ConfigItem(
			position = 5,
			keyName = "ventStatusPrediction",
			name = "Vent Status Prediction",
			description = "Displays estimates for missing vents",
			section = display
	)
	default boolean ventStatusPrediction()
	{
		return true;
	}

	@ConfigSection(
			name = "Timing",
			description = "Options on how to display timed objects",
			position = 1,
			closedByDefault = false
	)
	String timing = "timing";
	@ConfigItem(
			position = 0,
			keyName = "rockTimer",
			name = "Rock Timer",
			description = "Shows a respawn timer when a rock is taken",
			section = timing
	)
	default boolean rockTimer()
	{
		return true;
	}
	@ConfigItem(
			keyName = "rockRenderMode",
			name = "Rock Render Mode",
			description = "How the rock respawn timer is rendered",
			position = 1,
			section = timing
	)
	default TimingRenderMode rockRenderMode() {
		return TimingRenderMode.PROGRESS_PIE;
	}
	@ConfigItem(
			position = 2,
			keyName = "platformTimer",
			name = "Platform Timer",
			description = "Shows a despawn timer when a platform is made",
			section = timing
	)
	default boolean platformTimer()
	{
		return false;
	}
	@ConfigItem(
			keyName = "platformRenderMode",
			name = "Platform Render Mode",
			description = "How the platform despawn timer is rendered",
			position = 3,
			section = timing
	)
	default TimingRenderMode platformRenderMode() {
		return TimingRenderMode.NUMBER;
	}
	@ConfigItem(
			keyName = "numberThreshold",
			name = "Platform Number Threshold",
			description = "Maximum number to display when a platform is up",
			position = 4,
			section = timing
	)
	@Range(
			max = 150,
			min = 0
	)
	default int numberThreshold() {
		return 25;
	}

	@ConfigSection(
			name = "Notifications",
			description = "All the options for how you want to customize your notifications",
			position = 2,
			closedByDefault = false
	)
	String notifications = "notifications";
	@ConfigItem(
			keyName = "ventWarning",
			name = "Vent Shift Notification",
			description = "Show warning in advance of vents resetting 5 minutes into game",
			position = 0,
			section = notifications
	)
	default boolean showVentWarning()
	{
		return true;
	}
	@ConfigItem(
			keyName = "ventWarningTime",
			name = "Vent Shift Warning Time",
			description = "Number of seconds before the vents reset",
			position = 1,
			section = notifications
	)
	@Range(
			max = 60,
			min = 1
	)
	@Units(Units.SECONDS)
	default int ventWarningTime()
	{
		return 25;
	}
	@ConfigItem(
			keyName = "eruptionWarning",
			name = "Eruption Notification",
			description = "Show warning in advance of the volcano erupting",
			position = 2,
			section = notifications
	)
	default boolean showEruptionWarning()
	{
		return true;
	}
	@ConfigItem(
			keyName = "eruptionWarningTime",
			name = "Eruption Warning Time",
			description = "Number of seconds before the volcano erupts",
			position = 3,
			section = notifications
	)
	@Range(
			max = 60,
			min = 30
	)
	@Units(Units.SECONDS)
	default int eruptionWarningTime()
	{
		return 40;
	}
	@ConfigItem(
			keyName = "platformWarning",
			name = "Platform Despawn Notification",
			description = "Show warning for when platform below you is about to disappear",
			position = 4,
			section = notifications
	)
	default boolean showPlatformWarning()
	{
		return true;
	}
	@ConfigItem(
			keyName = "boulderMovement",
			name = "Boulder Movement Notification",
			description = "Notify when current boulder stage is complete",
			position = 5,
			section = notifications
	)
	default boolean showBoulderWarning()
	{
		return true;
	}
	@ConfigItem(
			position = 6,
			keyName = "ventFixNotifier",
			name = "Vent Fix notifier",
			description = "Notifies on stability change 6 mins or prior for A role and B/C role",
			section = notifications
	)
	default boolean ventFixNotifier()
	{
		return true;
	}
	@ConfigItem(
			position = 7,
			keyName = "postResetVentFixNotifier",
			name = "Post Reset Vent Fix notifier",
			description = "Notifies on dangerous stability change 3 mins or prior after the reset",
			section = notifications
	)
	default boolean postResetVentFixNotifier()
	{
		return false;
	}

	@ConfigSection(
			name = "Predicted Pre Reset Fix",
			description = "Options for customizing your predicted vent fix",
			position = 3,
			closedByDefault = false
	)
	String preresetfix = "predicted pre reset fix";
	@ConfigItem(
			position = 0,
			keyName = "predictedVentFixNotifier",
			name = "Predicted Vent Fix notifier",
			description = "Notifies when predicted stability change drops below a specific amount",
			section = preresetfix
	)
	default boolean predictedVentFixNotifier()
	{
		return false;
	}
	@ConfigItem(
			keyName = "predictedVentFixScenario",
			name = "Prediction Scenario",
			description = "Uses best or worst case scenario when predicting fixes or stability changes",
			position = 1,
			section = preresetfix
	)
	default PredictionScenario predictedVentFixScenario() {
		return PredictionScenario.WORST_CASE;
	}
	@ConfigItem(
			keyName = "predictedStabilityChange",
			name = "Stability Change",
			description = "The estimated change before a recommended vent fix",
			position = 2,
			section = preresetfix
	)
	@Range(
			max = 13,
			min = 1
	)
	default int predictedStabilityChange()
	{
		return 12;
	}
	@ConfigItem(
			keyName = "predictedventWarningStartTime",
			name = "Warning Start Time",
			description = "Number of seconds after 9:00 to suggest a vent fix",
			position = 3,
			section = preresetfix
	)
	@Range(
			max = 60,
			min = 1
	)
	@Units(Units.SECONDS)
	default int predictedventWarningStartTime()
	{
		return 15;
	}
	@ConfigItem(
			keyName = "predictedventWarningEndTime",
			name = "Warning End Time",
			description = "Number of seconds before 6:00 to suggest a vent fix",
			position = 4,
			section = preresetfix
	)
	@Range(
			max = 60,
			min = 1
	)
	@Units(Units.SECONDS)
	default int predictedventWarningEndTime()
	{
		return 30;

	}

	@ConfigSection(
			name = "Pickaxe Protection",
			description = "Options for customizing your predicted vent fix",
			position = 4,
			closedByDefault = true
	)
	String pickaxeprotection = "pickaxe protection";
	@ConfigItem(
			position = 0,
			keyName = "pickaxeDespawnProtection",
			name = "Pickaxe Despawn notifier",
			description = "Notifies when your pickaxe is about to despawn soon",
			section = pickaxeprotection
	)
	default boolean pickaxeDespawnProtection()
	{
		return true;
	}
	@ConfigItem(
			keyName = "pickaxeDespawnProtectionStartTime",
			name = "Pickaxe Despawn Start Time",
			description = "Notifies x seconds after you drop your pickaxe",
			position = 1,
			section = pickaxeprotection
	)
	@Range(
			max = 100,
			min = 1
	)
	@Units(Units.SECONDS)
	default int pickaxeDespawnProtectionStartTime()
	{
		return 75;
	}
	@ConfigItem(
			position = 2,
			keyName = "boulderFinishPickaxeLeaveProtection",
			name = "Boulder Finish Pickaxe Leave notifier",
			description = "Notifies if your pickaxe is still on the ground after finishing the boulder",
			section = pickaxeprotection
	)
	default boolean boulderFinishPickaxeLeaveProtection()
	{
		return true;
	}
	@ConfigItem(
			position = 3,
			keyName = "lowStabilityPickaxeLeaveProtection",
			name = "Low Stability Pickaxe Leave notifier",
			description = "Notifies if your pickaxe is still on the ground if stability gets low",
			section = pickaxeprotection
	)
	default boolean lowStabilityPickaxeLeaveProtection()
	{
		return true;
	}
	@ConfigItem(
			keyName = "pickaxeLeaveStabilityAmount",
			name = "Pickaxe Leave Stability Amount",
			description = "Notifies once stability is x amount or lower if pick is on the floor",
			position = 4,
			section = pickaxeprotection
	)
	@Range(
			max = 100,
			min = 1
	)
	default int pickaxeLeaveStabilityAmount()
	{
		return 35;
	}

	@ConfigSection(
			name = "Team Size Manager",
			description = "Notifications for any unexpected team size changes",
			position = 5,
			closedByDefault = true
	)
	String teamSize = "team size";
	@ConfigItem(
			keyName = "playerLeaveNotifier",
			name = "Player Leave Notifier",
			description = "Notifies when a player dies or exits the mine",
			position = 0,
			section = teamSize
	)
	default boolean playerLeaveNotifier()
	{
		return true;
	}
	@ConfigItem(
			keyName = "extraPlayerNotifier",
			name = "Extra Player Notifier",
			description = "Notifies when an unexpected player enters the mine",
			position = 1,
			section = teamSize
	)
	default boolean extraPlayerNotifier()
	{
		return false;
	}
	@ConfigItem(
			keyName = "expectedTeamSize",
			name = "Expected Team Size",
			description = "Set to the number of players in your current team",
			position = 2,
			section = teamSize
	)
	@Range(
			max = 50,
			min = 1
	)
	default int expectedTeamSize()
	{
		return 1;
	}
}

package com.ultimatevm;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import net.runelite.api.widgets.Widget;

import java.util.HashMap;

@Slf4j
@PluginDescriptor(
	name = "Ultimate Volcanic Mine"
)
public class UltimateVolcanicMinePlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private Notifier notifier;

	@Inject
	private UltimateVolcanicMineConfig config;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private TimedObjectOverlay timedObjectOverlay;

	//Constants
	private static final int PROC_VOLCANIC_MINE_SET_OTHERINFO = 2022;
	private static final int VARBIT_STABILITY = 5938;
	private static final int VARBIT_GAME_STATE = 5941;
	private static final int VARBIT_TIME_REMAINING = 5944;
	private static final int VARBIT_VENT_STATUS_A = 5939;
	private static final int VARBIT_VENT_STATUS_B = 5940;
	private static final int VARBIT_VENT_STATUS_C = 5942;
	private static final int VARBIT_CHAMBER_STATUS = 5936;
	private static final int VARBIT_POINTS = 5934;
	private static final int VARBIT_PLAYER_COUNT = 5937;
	private static final int HUD_STABILITY_COMPONENT = 11;
	private static final int HUD_VENT_A_PERCENTAGE = 17;
	private static final int HUD_VENT_B_PERCENTAGE = 18;
	private static final int HUD_VENT_C_PERCENTAGE = 19;
	private static final int VM_GAME_STATE_NONE = 0;
	private static final int VM_GAME_STATE_IN_LOBBY = 1;
	private static final int VM_GAME_STATE_IN_GAME = 2;
	private static final int VM_REGION_NORTH = 15263;
	private static final int VM_REGION_SOUTH = 15262;
	private static final int GAME_OBJ_CHAMBER_BLOCKED = 31044;
	private static final int GAME_OBJ_CHAMBER_UNBLOCKED = 31043;
	private static final int GAME_OBJ_TAKEN_ROCK = 31046;
	private static final int GAME_OBJ_ROCK = 31045;
	private static final int VM_EXIT_TIME = 50;
	private static final int VM_LOBBY_TIME = 50;

	private static final float SECONDS_TO_TICKS = 1.666f;


	private VentStatusPredicter ventStatusPredicter = new VentStatusPredicter();
	private StabilityTracker stabilityTracker = new StabilityTracker();
	private StabilityTracker futureStabilityTracker = new StabilityTracker();
	private VMNotifier VM_notifier;
	private CapCounter capCounter = new CapCounter();
	private TimedObjectTracker timedObjectTracker = new TimedObjectTracker();
	private CapCounterInfoBox capInfoBox;
    private PickaxeProtector pickaxeProtector;
	private HashMap<Integer, Tile> rockTiles = new HashMap<>();
	private int vmGameState = VM_GAME_STATE_NONE;
	private int timeRemainingFromServer, estimatedTimeRemaining;
	private int eruptionTime, ventWarningTime;
	private int maxPlayerCount, ticksSinceLobbyStart;


	@Provides
	UltimateVolcanicMineConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(UltimateVolcanicMineConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		eruptionTime = (int) (config.eruptionWarningTime() * SECONDS_TO_TICKS);
		ventWarningTime = (int) (config.ventWarningTime() * SECONDS_TO_TICKS);

		stabilityTracker.setDisplayCount(config.stabilityUpdateHistoryCount());
		futureStabilityTracker.setDisplayCount(config.predictedStabilityChangeHistoryCount());

		infoBoxManager.removeInfoBox(capInfoBox);
		if(config.capCounter() && capCounter.getTimesCapped() >= 1) infoBoxManager.addInfoBox(capInfoBox);

		overlayManager.remove(timedObjectOverlay);
		if(config.rockTimer() || config.platformTimer()) overlayManager.add(timedObjectOverlay);
	}

	@Override
	protected void startUp() throws Exception {
		VM_notifier = new VMNotifier(config);
        pickaxeProtector = new PickaxeProtector(client);
		stabilityTracker.setDisplayCount(config.stabilityUpdateHistoryCount());
		futureStabilityTracker.setDisplayCount(config.predictedStabilityChangeHistoryCount());
		capInfoBox = new CapCounterInfoBox(capCounter, this);
		timedObjectOverlay.setRockTracker(timedObjectTracker);
		overlayManager.add(timedObjectOverlay);
		eruptionTime = (int) (config.eruptionWarningTime() * SECONDS_TO_TICKS);
		ventWarningTime = (int) (config.ventWarningTime() * SECONDS_TO_TICKS);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(timedObjectOverlay);
		infoBoxManager.removeInfoBox(capInfoBox);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if(!isInVM()) return;
		vmGameState = client.getVarbitValue(VARBIT_GAME_STATE);
		if (vmGameState == VM_GAME_STATE_IN_LOBBY) {
			stabilityTracker.initialize();
			ventStatusPredicter.initialize();
			futureStabilityTracker.initialize();
			stabilityTracker.setDisplayCount(config.stabilityUpdateHistoryCount());
			futureStabilityTracker.setDisplayCount(config.predictedStabilityChangeHistoryCount());
			resetGameVariables();
		}
	}

	@Subscribe
	public void onGameTick(GameTick tick) {
		if(!isInVM()) {
			vmGameState = VM_GAME_STATE_NONE;
			StabilityUpdateInfo.resetPlayers();
			infoBoxManager.removeInfoBox(capInfoBox);
			resetGameVariables();
			return;
		}

		if(maxPlayerCount > config.expectedTeamSize())
			VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_EXTRA_PLAYER, ventStatusPredicter.getCurrentTick());

		int newTimeRemaining = client.getVarbitValue(VARBIT_TIME_REMAINING);
		if(newTimeRemaining != timeRemainingFromServer) {
			estimatedTimeRemaining = timeRemainingFromServer = newTimeRemaining;
		} else --estimatedTimeRemaining;

        pickaxeProtector.getStartingPickaxes();
        if(pickaxeProtector.isPickaxeDropped()) pickaxeProtector.incrementTicksDropped();
		else pickaxeProtector.resetTicksDropped();
		if(config.pickaxeDespawnProtection()) {
			int requiredDroppedTicks = (int)(config.pickaxeDespawnProtectionStartTime() * SECONDS_TO_TICKS);
			if(requiredDroppedTicks <= pickaxeProtector.getNumTicksPickaxeDropped())
				VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_PICKAXE_DESPAWN, ticksSinceLobbyStart);
		}
		++ticksSinceLobbyStart;

        if(!hasGameStarted()) return;

		StabilityUpdateInfo.setNumPlayers(client.getVarbitValue(VARBIT_PLAYER_COUNT));
		timedObjectTracker.updateRockTimers();

		updateVentStatus(client.getVarbitValue(VARBIT_VENT_STATUS_A),
				client.getVarbitValue(VARBIT_VENT_STATUS_B),
				client.getVarbitValue(VARBIT_VENT_STATUS_C),
				client.getVarbitValue(VARBIT_CHAMBER_STATUS));
		//Update our predicted stability change on the same exact tick the vent status changes
		if(ventStatusPredicter.isMovementUpdateTick()) {
			//Check if we have to fix vents in the future
			int futureChange = ventStatusPredicter.getFutureStabilityChange(config.predictedVentFixScenario());
			if(futureChange != VentStatus.STARTING_VENT_VALUE) {
				futureStabilityTracker.addChange(futureChange);
				if (futureStabilityTracker.isFutureStabilityBad(config.predictedStabilityChange())) {
					int startTime = 900 - (int)(config.predictedventWarningStartTime() * SECONDS_TO_TICKS);
					int endTime = 600 + (int)(config.predictedventWarningEndTime() * SECONDS_TO_TICKS);
					if(estimatedTimeRemaining < startTime && estimatedTimeRemaining > endTime)
						VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_PREDICTED_VENT_FIX, ventStatusPredicter.getCurrentTick());
				}
			}
		}

		int currentStability = client.getVarbitValue(VARBIT_STABILITY);
		if(updateStability(currentStability)) {
			if(config.ventStatusUpdateHistory()) {
				Widget widget = client.getWidget(ComponentID.VOLCANIC_MINE_VENT_A_PERCENTAGE+1);
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "CyanWarrior4: ", ventStatusPredicter.getVentStatusText(0, widget.getText()), null);
				widget = client.getWidget(ComponentID.VOLCANIC_MINE_VENT_B_PERCENTAGE+1);
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "CyanWarrior4: ", ventStatusPredicter.getVentStatusText(1, widget.getText()), null);
				widget = client.getWidget(ComponentID.VOLCANIC_MINE_VENT_C_PERCENTAGE+1);
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "CyanWarrior4: ", ventStatusPredicter.getVentStatusText(2, widget.getText()), null);
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "CyanWarrior4: ", "Stability Update: " + stabilityTracker.getCurrentChange(), null);
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "CyanWarrior4: ", "Time: " + estimatedTimeRemaining, null);
			}

			//Check if we have to fix vents now
			if(stabilityTracker.getCurrentChange() < 0 && estimatedTimeRemaining > 595)
				VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_PRE_RESET_VENT_FIX, ventStatusPredicter.getCurrentTick());

			//Check if we should have all 3 vents fixed (post-reset)
			boolean isPostResetTime = (estimatedTimeRemaining <= (VentStatusTimeline.VM_GAME_RESET_TIME-15) && estimatedTimeRemaining > 305);
			if(currentStability + (stabilityTracker.getCurrentChange() * 4) <= 0 && isPostResetTime)
				VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_POST_RESET_VENT_FIX, ventStatusPredicter.getCurrentTick());
		}

		//Ensure reset will not happen at the very start before the server sends the new game time
		//Reset around 5:00 when the server sends new unidentified vent
		if(ventStatusPredicter.getCurrentTick() > VMNotifier.NOTIFICATION_START_COOLDOWN_TICKS &&
				timeRemainingFromServer <= VentStatusTimeline.VM_GAME_RESET_TIME) {
			stabilityTracker.resetStabilityHistory();
			futureStabilityTracker.resetStabilityHistory();
		}

		int currentTick = ventStatusPredicter.getCurrentTick();
		if (estimatedTimeRemaining <= (VentStatusTimeline.VM_GAME_RESET_TIME + ventWarningTime))
			VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_RESET, currentTick);

		if (estimatedTimeRemaining <= eruptionTime) {
			VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_ERUPTION, currentTick);
		}

		ventStatusPredicter.updateDisplayState();
		if(config.ventStatusPrediction()) {
//			Widget widget = client.getWidget(WidgetID.VOLCANIC_MINE_GROUP_ID, HUD_VENT_A_PERCENTAGE);
//			if (widget != null) widget.setText(ventStatusPredicter.getVentStatusText(0, widget.getText()));
//			widget = client.getWidget(WidgetID.VOLCANIC_MINE_GROUP_ID, HUD_VENT_B_PERCENTAGE);
//			if (widget != null) widget.setText(ventStatusPredicter.getVentStatusText(1, widget.getText()));
//			widget = client.getWidget(WidgetID.VOLCANIC_MINE_GROUP_ID, HUD_VENT_C_PERCENTAGE);
//			if (widget != null) widget.setText(ventStatusPredicter.getVentStatusText(2, widget.getText()));
		}

		ventStatusPredicter.getTimeline().updateTick();
		if(ventStatusPredicter.getCurrentTick() > VentStatusTimeline.VM_GAME_RESET_TIME) {
			ventStatusPredicter.reset();
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
			return;

		// Remove colour and line breaks
		String chatMsg = Text.removeTags(event.getMessage());

		// Mark when an earthquake occurs
		if (chatMsg.equals("A sudden earthquake strikes the cavern!")) {
			ventStatusPredicter.markEarthquakeEvent();
		}
	}
	//Helper functions for testing
	public boolean updateStability(int newStability) {
		if(config.lowStabilityPickaxeLeaveProtection()) {
			if (newStability <= config.pickaxeLeaveStabilityAmount() && pickaxeProtector.isPickaxeDropped())
				VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_PICKAXE_LOW_STABILITY, ventStatusPredicter.getCurrentTick());
		}

		if(stabilityTracker.updateStability(newStability)) {
			ventStatusPredicter.makeStatusState(stabilityTracker.getCurrentChange());
			return true;
		}
		return false;
	}
	public void updateVentStatus(int ventA, int ventB, int ventC, int chamberStatus) {
		ventStatusPredicter.updateVentStatus(new int[]{ventA, ventB, ventC}, chamberStatus);
	}
	public final VentStatusPredicter getVentStatusPredicter() { return ventStatusPredicter; }

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		if(!isInVM()) return;

		//Set our starting player count
		if(event.getVarbitId() == VARBIT_PLAYER_COUNT) {
			maxPlayerCount = Math.max(maxPlayerCount, client.getVarbitValue(VARBIT_PLAYER_COUNT));
		}

		if(!hasGameStarted()) return;

		//Check if a player leaves/dies - player count can only move down in game
		if(event.getVarbitId() == VARBIT_PLAYER_COUNT) {
			//Skip this check if its time to exit the mine
			if (estimatedTimeRemaining <= VM_EXIT_TIME) return;
			VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_PLAYER_LEAVE, ventStatusPredicter.getCurrentTick());
		}

		//Keep track of points for our cap counter
		if(event.getVarbitId() == VARBIT_POINTS) {
			int playerX = client.getLocalPlayer().getWorldLocation().getX();
			int playerY = client.getLocalPlayer().getWorldLocation().getY();
			if(capCounter.updateScore(client.getVarbitValue(VARBIT_POINTS), playerX, playerY)) {
				//Only add the info box once the player caps for the first time
				if (capCounter.getTimesCapped() == 1) infoBoxManager.addInfoBox(capInfoBox);
			}
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event) {
		if (event.getScriptId() != PROC_VOLCANIC_MINE_SET_OTHERINFO) {
			return;
		}

		//Stability Trackers
		Widget widget = client.getWidget(InterfaceID.VOLCANIC_MINE, HUD_STABILITY_COMPONENT);
		if(config.stabilityUpdateHistoryCount() > 0 && widget != null)
			widget.setText(widget.getText() + stabilityTracker.getStabilityText());

		widget = client.getWidget(InterfaceID.VOLCANIC_MINE, HUD_STABILITY_COMPONENT-1);
		if(widget != null) {
			if (config.predictedStabilityChangeHistoryCount() > 0)
				widget.setText("Stab." + futureStabilityTracker.getStabilityText());
			else
				widget.setText("Stability");
		}

		//Vent Status
		if(config.ventStatusPrediction()) {
			widget = client.getWidget(ComponentID.VOLCANIC_MINE_VENT_A_PERCENTAGE+1);
			if (widget != null) widget.setText(ventStatusPredicter.getVentStatusText(0, widget.getText()));
			widget = client.getWidget(ComponentID.VOLCANIC_MINE_VENT_B_PERCENTAGE+1);
			if (widget != null) widget.setText(ventStatusPredicter.getVentStatusText(1, widget.getText()));
			widget = client.getWidget(ComponentID.VOLCANIC_MINE_VENT_C_PERCENTAGE+1);
			if (widget != null) widget.setText(ventStatusPredicter.getVentStatusText(2, widget.getText()));
		}
	}

	@Subscribe
	void onGameObjectDespawned(GameObjectDespawned event) {
		int gameObjectId = event.getGameObject().getId();
		if(gameObjectId == GAME_OBJ_ROCK) {
			timedObjectTracker.addObject(event.getGameObject().getWorldLocation(), TimedObject.ObjectType.ROCK);
		}
	}

	private void resetGameVariables() {
		VM_notifier.reset();
		capCounter.initialize();
		timedObjectTracker.clearRocks();
        pickaxeProtector.resetStartingPickaxes();
		estimatedTimeRemaining = timeRemainingFromServer = 0;
		ticksSinceLobbyStart = maxPlayerCount = 0;
	}
	private boolean hasGameStarted() {
		if(vmGameState >= VM_GAME_STATE_IN_GAME) return true;
		//Both Lobby and exit time are 30 seconds
		return estimatedTimeRemaining > VM_LOBBY_TIME;
	}


	//Function(s) taken from Hipipis Plugin hub VMPlugin
	private static final String PLATFORM_WARNING_MESSAGE = "The platform beneath you will disappear soon!";
	private static final String BOULDER_WARNING_MESSAGE = "The current boulder stage is complete.";
	// Constants
	private static final int PLATFORM_STAGE_3_ID = 31000;
	private static final int PLATFORM_STAGE_1_ID = 30998;
	private static final int BOULDER_BREAK_STAGE_1_ID = 7807;
	private static final int BOULDER_BREAK_STAGE_2_ID = 7809;
	private static final int BOULDER_BREAK_STAGE_3_ID = 7811;
	private static final int BOULDER_BREAK_STAGE_4_ID = 7813;
	private static final int BOULDER_BREAK_STAGE_5_ID = 7815;
	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event) {
		if (!isInVM()) return;

		int gameObjectId = event.getGameObject().getId();
		int playerX = client.getLocalPlayer().getWorldLocation().getX();
		int playerY = client.getLocalPlayer().getWorldLocation().getY();
		int objectX = event.getGameObject().getWorldLocation().getX();
		int objectY = event.getGameObject().getWorldLocation().getY();

		//Get initial positions the player must be on to cap
		if(gameObjectId == GAME_OBJ_CHAMBER_BLOCKED || gameObjectId == GAME_OBJ_CHAMBER_UNBLOCKED) {
			objectX = event.getGameObject().getWorldLocation().getX();
			objectY = event.getGameObject().getWorldLocation().getY();
			capCounter.addCappingPositions(objectX, objectY);
		}

		if(gameObjectId == PLATFORM_STAGE_1_ID) {
			timedObjectTracker.addObject(event.getGameObject().getWorldLocation(), TimedObject.ObjectType.PLATFORM);
		}

		// If warning is enabled and game object spawned is a stage 3 platform
		if (gameObjectId == PLATFORM_STAGE_3_ID)
		{
			if(!config.showPlatformWarning()) return;
			// Notify player if the stage 3 platform is beneath them
			if (playerX == objectX && playerY == objectY)
			{
				notifier.notify(PLATFORM_WARNING_MESSAGE);
			}
		}
	}
	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		// Return if not in VM
		if (!isInVM())
		{
			return;
		}

		// If warning is enabled and npc spawned is a boulder that is breaking
		NPC npc = npcSpawned.getNpc();
		switch(npc.getId())
		{
			case BOULDER_BREAK_STAGE_5_ID:
				if(config.boulderFinishPickaxeLeaveProtection() && pickaxeProtector.isPickaxeDropped())
					VM_notifier.notify(notifier, VMNotifier.NotificationEvents.VM_PICKAXE_BOULDER_COMPLETE, ventStatusPredicter.getCurrentTick());
				//If we finish the game early dont trigger player leave event
				VM_notifier.removeEvent(VMNotifier.NotificationEvents.VM_PLAYER_LEAVE);
			case BOULDER_BREAK_STAGE_1_ID:
			case BOULDER_BREAK_STAGE_2_ID:
			case BOULDER_BREAK_STAGE_3_ID:
			case BOULDER_BREAK_STAGE_4_ID:
				if (config.showBoulderWarning()) notifier.notify(BOULDER_WARNING_MESSAGE);
				break;
			default:
				break;
		}

	}
	private boolean isInVM()
	{
		Player player = client.getLocalPlayer();
		if(player == null) return false;
		LocalPoint localPoint = player.getLocalLocation();
		if(localPoint == null) return false;
		WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
		if(worldPoint == null) return false;
		int currentRegionID = worldPoint.getRegionID();
		return  currentRegionID == VM_REGION_NORTH || currentRegionID == VM_REGION_SOUTH;
	}
}

package com.ultimatevm;

public class VentStatus {
    public static final int STARTING_VENT_VALUE = 127;
    public static final int MIN_VENT_VALUE = 0;
    public static final int PERFECT_VENT_VALUE = 50;
    public static final int MAX_VENT_VALUE = 100;
    public static final int MIN_STARTING_VENT_VALUE = 30;
    public static final int MAX_STARTING_VENT_VALUE = 70;
    public static final int MAX_RESET_SOLO_VENT_VALUE = 75;
    public static final int MIN_RESET_SOLO_VENT_VALUE = 25;
    public static final float VENT_STABILITY_WEIGHT = 16.0f;
    public static int BASE_MOVE_RATE = 2;
    public static int[][] pointsToLowerRanges = null, pointsToUpperRanges = null;


    public enum VentChangeStateFlag {
        IDENTIFIED (1),
        NO_CHANGE (2),
        ONE_CHANGE (4),
        TWO_CHANGE (8),
        DIRECTION_CHANGE (16),
        RESET(32);
        private final int bitFlag;

        VentChangeStateFlag(int bitFlag) {
            this.bitFlag = bitFlag;
        }
        int bitFlag() {return bitFlag;}
    }
    private char ventName;
    private int actualValue;
    private int movementDirection;

    //Estimated Bounds
    private boolean isFreezeClipAccurate;
    private int lowerBoundStart, lowerBoundEnd;
    private int upperBoundStart, upperBoundEnd;
    private int totalBoundStart, totalBoundEnd;

    private static void makePointsToRangeTable() {
        if(pointsToLowerRanges != null && pointsToUpperRanges != null) return;
        pointsToLowerRanges = new int[(int)VENT_STABILITY_WEIGHT+1][2];
        pointsToUpperRanges = new int[(int)VENT_STABILITY_WEIGHT+1][2];

        //Mid values
        pointsToLowerRanges[16][0] = pointsToUpperRanges[16][0] = 47;
        pointsToLowerRanges[16][1] = pointsToUpperRanges[16][1] = 53;
        //Lower values
        pointsToLowerRanges[15][0] = 44; pointsToLowerRanges[15][1] = 46;
        pointsToLowerRanges[14][0] = 41; pointsToLowerRanges[14][1] = 43;
        pointsToLowerRanges[13][0] = 38; pointsToLowerRanges[13][1] = 40;
        pointsToLowerRanges[12][0] = 35; pointsToLowerRanges[12][1] = 37;
        pointsToLowerRanges[11][0] = 32; pointsToLowerRanges[11][1] = 34;
        pointsToLowerRanges[10][0] = 29; pointsToLowerRanges[10][1] = 31;
        pointsToLowerRanges[9][0] = 26; pointsToLowerRanges[9][1] = 28;
        pointsToLowerRanges[8][0] = 22; pointsToLowerRanges[8][1] = 25;
        pointsToLowerRanges[7][0] = 19; pointsToLowerRanges[7][1] = 21;
        pointsToLowerRanges[6][0] = 16; pointsToLowerRanges[6][1] = 18;
        pointsToLowerRanges[5][0] = 13; pointsToLowerRanges[5][1] = 15;
        pointsToLowerRanges[4][0] = 10; pointsToLowerRanges[4][1] = 12;
        pointsToLowerRanges[3][0] = 7; pointsToLowerRanges[3][1] = 9;
        pointsToLowerRanges[2][0] = 4; pointsToLowerRanges[2][1] = 6;
        pointsToLowerRanges[1][0] = 1; pointsToLowerRanges[1][1] = 3;
        pointsToLowerRanges[0][0] = pointsToLowerRanges[0][1] = 0;
        //Upper values
        pointsToUpperRanges[15][0] = 54; pointsToLowerRanges[15][1] = 56;
        pointsToUpperRanges[14][0] = 57; pointsToLowerRanges[14][1] = 59;
        pointsToUpperRanges[13][0] = 60; pointsToLowerRanges[13][1] = 62;
        pointsToUpperRanges[12][0] = 63; pointsToLowerRanges[12][1] = 65;
        pointsToUpperRanges[11][0] = 66; pointsToLowerRanges[11][1] = 68;
        pointsToUpperRanges[10][0] = 69; pointsToUpperRanges[10][1] = 71;
        pointsToUpperRanges[9][0] = 72; pointsToUpperRanges[9][1] = 74;
        pointsToUpperRanges[8][0] = 75; pointsToUpperRanges[8][1] = 78;
        pointsToUpperRanges[7][0] = 79; pointsToUpperRanges[7][1] = 81;
        pointsToUpperRanges[6][0] = 82; pointsToUpperRanges[6][1] = 84;
        pointsToUpperRanges[5][0] = 85; pointsToUpperRanges[5][1] = 87;
        pointsToUpperRanges[4][0] = 88; pointsToUpperRanges[4][1] = 90;
        pointsToUpperRanges[3][0] = 91; pointsToUpperRanges[3][1] = 93;
        pointsToUpperRanges[2][0] = 94; pointsToUpperRanges[2][1] = 96;
        pointsToUpperRanges[1][0] = 97; pointsToUpperRanges[1][1] = 99;
        pointsToUpperRanges[0][0] = pointsToUpperRanges[0][1] = 100;
    }
    public static int getStabilityInfluence(int ventValue) {
        float percentValue = PERFECT_VENT_VALUE - Math.abs(PERFECT_VENT_VALUE - ventValue);
        percentValue = (percentValue / 50.0f) * VENT_STABILITY_WEIGHT;
        return (int) Math.ceil(percentValue);
    }
    public static int getMovementInfluenceOfValue(int value) {
        if(value > 40 && value < 60) return -1;
        return 0;
    }
    public static int[] pointsToLowerRange(int points) {
        if(pointsToLowerRanges == null) return new int[]{-1, -1};
        if(points < 0 || points > (int)VENT_STABILITY_WEIGHT) return new int[]{-1, -1};
        return pointsToLowerRanges[points];
    }
    public static int[] pointsToUpperRange(int points) {
        if(pointsToUpperRanges == null) return new int[]{-1, -1};
        if(points < 0 || points > (int)VENT_STABILITY_WEIGHT) return new int[]{-1, -1};
        return pointsToUpperRanges[points];
    }

    public VentStatus(char name) {
        makePointsToRangeTable();
        ventName = name;
        this.movementDirection = 0;
        actualValue = STARTING_VENT_VALUE;
        totalBoundStart = MIN_STARTING_VENT_VALUE;
        totalBoundEnd = MAX_STARTING_VENT_VALUE;
        setStartingRanges();
    }
    public VentStatus(VentStatus vent) {
        setEqualTo(vent);
    }

    public void doVMReset() {
        //Direction state will remain the same as before
        actualValue = STARTING_VENT_VALUE;
        totalBoundStart = MIN_VENT_VALUE;
        totalBoundEnd = MAX_VENT_VALUE;
        if(StabilityUpdateInfo.isSolo()) {
            totalBoundStart = MIN_RESET_SOLO_VENT_VALUE;
            totalBoundEnd = MAX_RESET_SOLO_VENT_VALUE;
        }
        setStartingRanges();
    }
    public void setEqualTo(VentStatus vent) {
        this.ventName = vent.ventName;
        this.actualValue = vent.actualValue;
        this.movementDirection = vent.movementDirection;
        //Bounds
        this.lowerBoundStart = vent.lowerBoundStart;
        this.lowerBoundEnd = vent.lowerBoundEnd;
        this.upperBoundStart = vent.upperBoundStart;
        this.upperBoundEnd = vent.upperBoundEnd;
        this.totalBoundStart = vent.totalBoundStart;
        this.totalBoundEnd = vent.totalBoundEnd;
        this.isFreezeClipAccurate = vent.isFreezeClipAccurate;
    }
    public int update(int actualValue, int direction) {
        int bitState = 0;
        int prevValue = this.actualValue;
        this.actualValue = actualValue;
        if(!isIdentified() && prevValue != STARTING_VENT_VALUE)
            bitState |= VentChangeStateFlag.RESET.bitFlag;
        if(this.movementDirection != 0 && this.movementDirection != direction)
            bitState |= VentChangeStateFlag.DIRECTION_CHANGE.bitFlag;
        this.movementDirection = direction;

        if(isIdentified() || (bitState & VentChangeStateFlag.RESET.bitFlag) != 0) {
            lowerBoundStart = lowerBoundEnd = actualValue;
            upperBoundStart = upperBoundEnd = actualValue;
            isFreezeClipAccurate = false;
        }
        if(!isIdentified()) return bitState;

        int diff = Math.abs(this.actualValue - prevValue);
        if(diff == 1) return bitState | VentChangeStateFlag.ONE_CHANGE.bitFlag;
        else if(diff == 2) return bitState |  VentChangeStateFlag.TWO_CHANGE.bitFlag;
        else if(diff > 2) return bitState | VentChangeStateFlag.IDENTIFIED.bitFlag;

        if(this.actualValue == MIN_VENT_VALUE && this.movementDirection == -1)
            return bitState;

        if(this.actualValue == MAX_VENT_VALUE && this.movementDirection == 1)
            return bitState;

        return bitState | VentChangeStateFlag.NO_CHANGE.bitFlag;
    }
    public void updateMovement(int[] outsideVentInfluence) {
        if(isIdentified()) return;
        //Get our possible movement amounts
        int currentMinMoveRate = BASE_MOVE_RATE + outsideVentInfluence[0];
        int currentMaxMoveRate = BASE_MOVE_RATE + outsideVentInfluence[1];

        //Consider all movement possibilities when moving ranges
        int startRangeMoveRate, endRangeMoveRate;
        if(getDirection() > 0) {
            //upward movement
            endRangeMoveRate = currentMaxMoveRate;
            startRangeMoveRate = currentMinMoveRate;
        } else {
            //downward movement
            startRangeMoveRate = currentMaxMoveRate;
            endRangeMoveRate = currentMinMoveRate;
        }
        //Update total bounds even if range is not defined
        int totalBoundStartMove = Math.max(0, (startRangeMoveRate + getMovementInfluenceOfValue(totalBoundStart))) * movementDirection;
        totalBoundStart = capVentValue(totalBoundStart + totalBoundStartMove);

        int totalBoundEndMove = Math.max(0, (endRangeMoveRate + getMovementInfluenceOfValue(totalBoundEnd))) * movementDirection;
        totalBoundEnd = capVentValue(totalBoundEnd + totalBoundEndMove);

        if(!isRangeDefined()) return;
        //Update our current ranges
        int lowerStart = getLowerBoundStart();
        int lowerStartMove = Math.max(0, (startRangeMoveRate + getMovementInfluenceOfValue(lowerStart))) * movementDirection;

        int upperEnd = getUpperBoundEnd();
        int upperEndMove = Math.max(0, (endRangeMoveRate + getMovementInfluenceOfValue(upperEnd))) * movementDirection;

        int lowerEnd = getLowerBoundEnd();
        int lowerEndMove = Math.max(0, (endRangeMoveRate + getMovementInfluenceOfValue(lowerEnd))) * movementDirection;

        int upperStart = getUpperBoundStart();
        int upperStartMove = Math.max(0, (startRangeMoveRate + getMovementInfluenceOfValue(upperStart))) * movementDirection;

        clearRanges();
        setLowerBoundRange(lowerStart + lowerStartMove, lowerEnd + lowerEndMove);
        setUpperBoundRange(upperStart + upperStartMove, upperEnd + upperEndMove);
    }
    public void clearRanges() {
        lowerBoundStart = lowerBoundEnd = STARTING_VENT_VALUE;
        upperBoundStart = upperBoundEnd = STARTING_VENT_VALUE;
    }
    public boolean canLowerBoundMergeWith(int start, int end) {
        return isLowerBoundWithinRange(start-1, end+1);
    }
    public boolean canUpperBoundMergeWith(int start, int end) {
        return isUpperBoundWithinRange(start-1, end+1);
    }
    public void mergeLowerBoundRanges(int start, int end) {
        lowerBoundStart = Math.min(lowerBoundStart, capVentValue(start));
        lowerBoundEnd = Math.max(lowerBoundEnd, capVentValue(end));
    }
    public void mergeUpperBoundRanges(int start, int end) {
        upperBoundStart = Math.min(upperBoundStart, capVentValue(start));
        upperBoundEnd = Math.max(upperBoundEnd, capVentValue(end));
    }
    public void setLowerBoundRange(int start, int end) {
        lowerBoundStart = capVentValue(start);
        lowerBoundEnd = capVentValue(end);
        //Merge ranges if they are both within bounds
        if(canUpperBoundMergeWith(lowerBoundStart, lowerBoundEnd)) {
            mergeUpperBoundRanges(lowerBoundStart, lowerBoundEnd);
            mergeLowerBoundRanges(upperBoundStart, upperBoundEnd);
        }
    }
    public void setUpperBoundRange(int start, int end) {
        upperBoundStart = capVentValue(start);
        upperBoundEnd = capVentValue(end);
        //Merge ranges if they are both within bounds
        if(canLowerBoundMergeWith(upperBoundStart, upperBoundEnd)) {
            mergeUpperBoundRanges(lowerBoundStart, lowerBoundEnd);
            mergeLowerBoundRanges(upperBoundStart, upperBoundEnd);
        }
    }
    public void doInnerBoundsClipping(int start, int end) {
        if(isIdentified()) return;
        if(!isRangeDefined()) return;
        int[] lower = getOverlappedLowerBoundRange(start, end);
        int[] upper = getOverlappedUpperBoundRange(start, end);
        boolean isLowerBoundClipped = (lower[0] == -1 && lower[1] == -1);
        boolean isUpperBoundClipped = (upper[0] == -1 && upper[1] == -1);
        clearRanges();
        if(isLowerBoundClipped && isUpperBoundClipped) return;

        if(isLowerBoundClipped) {
            //Lower bound doesnt fit use upper bound instead
            setUpperBoundRange(upper[0], upper[1]);
            setLowerBoundRange(upper[0], upper[1]);
        }
        else if(isUpperBoundClipped) {
            //Upper bound doesnt fit use lower bound instead
            setUpperBoundRange(lower[0], lower[1]);
            setLowerBoundRange(lower[0], lower[1]);
        } else {
            setUpperBoundRange(upper[0], upper[1]);
            setLowerBoundRange(lower[0], lower[1]);
        }
    }
    public void doOuterBoundsClipping(int start, int end) {
        if(isIdentified()) return;
        if(!isRangeDefined()) return;
        if(doOuterBoundsSingleRangeClipping(start, end)) return;

        int[] lower = getOutsideLowerBoundRange(start, end);
        int[] upper = getOutsideUpperBoundRange(start, end);
        boolean isLowerBoundClipped = (lower[0] == -1 && lower[1] == -1);
        boolean isUpperBoundClipped = (upper[0] == -1 && upper[1] == -1);
        clearRanges();
        if(isLowerBoundClipped && isUpperBoundClipped) return;

        if(isLowerBoundClipped) {
            //Lower bound doesnt fit use upper bound instead
            setUpperBoundRange(upper[0], upper[1]);
            setLowerBoundRange(upper[0], upper[1]);
        }
        else if(isUpperBoundClipped) {
            //Upper bound doesnt fit use lower bound instead
            setUpperBoundRange(lower[0], lower[1]);
            setLowerBoundRange(lower[0], lower[1]);
        } else {
            setUpperBoundRange(upper[0], upper[1]);
            setLowerBoundRange(lower[0], lower[1]);
        }
    }
    private boolean doOuterBoundsSingleRangeClipping(int start, int end) {
        if(isTwoSeperateValues()) return false;

        //Range to clip is out of our bounds
        int upperBoundEnd = getUpperBoundEnd();
        int lowerBoundStart = getLowerBoundStart();
        if(start > upperBoundEnd) return false;
        if(end < lowerBoundStart) return false;

        //Our current range fits inside of our range to clip
        clearRanges();
        if(start <= lowerBoundStart && end >= upperBoundEnd)
            return true;

        //Range to clip doesnt break the single range
        int maxStart = Math.max(start-1, lowerBoundStart);
        int minEnd = Math.min(end+1, upperBoundEnd);
        if(start <= lowerBoundStart || end >= upperBoundEnd) {
            //Lower end of our range is clipped
            if(start <= lowerBoundStart) {
                setUpperBoundRange(minEnd, upperBoundEnd);
                setLowerBoundRange(minEnd, upperBoundEnd);
            }
            //Upper end of our range is clipped
            if(end >= upperBoundEnd) {
                setUpperBoundRange(lowerBoundStart, maxStart);
                setLowerBoundRange(lowerBoundStart, maxStart);
            }
        }
        //Range to clip is inside of our current range
        else {
            setUpperBoundRange(minEnd, upperBoundEnd);
            setLowerBoundRange(lowerBoundStart, maxStart);
        }
        return true;
    }
    public void flipDirection() {
        movementDirection *= -1;
    }

    public boolean isIdentified() { return actualValue != STARTING_VENT_VALUE; }
    public boolean isRangeDefined() {
        if(lowerBoundStart == STARTING_VENT_VALUE || lowerBoundEnd == STARTING_VENT_VALUE) return false;
        if(upperBoundStart == STARTING_VENT_VALUE || upperBoundEnd == STARTING_VENT_VALUE) return false;
        return true;
    }
    public boolean isTwoSeperateValues() { return !(lowerBoundStart == upperBoundStart && lowerBoundEnd == upperBoundEnd); }
    public boolean isLowerBoundSingleValue() { return (lowerBoundStart == lowerBoundEnd); }
    public boolean isUpperBoundSingleValue() { return (upperBoundStart == upperBoundEnd); }
    public boolean isLowerBoundWithinRange(int start, int end) {
        return !(start > lowerBoundEnd || end < lowerBoundStart);
    }
    public boolean isUpperBoundWithinRange(int start, int end) {
        return !(start > upperBoundEnd || end < upperBoundStart);
    }
    public boolean isWithinRange(int start, int end) {
        if(isLowerBoundWithinRange(start, end)) return true;
        if(isTwoSeperateValues()) {
            return isUpperBoundWithinRange(start, end);
        }
        return false;
    }
    public int[] getOverlappedLowerBoundRange(int start, int end) {
        if(!isLowerBoundWithinRange(start, end)) return new int[]{-1, -1};
        int maxStart = Math.max(getLowerBoundStart(), start);
        int minEnd = Math.min(getLowerBoundEnd(), end);
        return new int[]{maxStart, minEnd};
    }
    public int[] getOutsideLowerBoundRange(int start, int end) {
        int newStart = lowerBoundStart, newEnd = lowerBoundEnd;
        if(!isLowerBoundWithinRange(start, end)) return new int[]{newStart, newEnd};
        //Check if start is within the passed bounds
        if(lowerBoundStart >= start && lowerBoundStart <= end) newStart = end+1;
        //Check if end is within the passed bounds
        if(lowerBoundEnd >= start && lowerBoundEnd <= end) newEnd = start-1;
        //return invalid range if both are within the passed bounds
        if(newStart > newEnd) return new int[]{-1, -1};
        return new int[]{newStart, newEnd};
    }
    public int[] getOverlappedUpperBoundRange(int start, int end) {
        if(!isUpperBoundWithinRange(start, end)) return new int[]{-1, -1};
        int maxStart = Math.max(getUpperBoundStart(), start);
        int minEnd = Math.min(getUpperBoundEnd(), end);
        return new int[]{maxStart, minEnd};
    }
    public int[] getOutsideUpperBoundRange(int start, int end) {
        int newStart = upperBoundStart, newEnd = upperBoundEnd;
        if(!isUpperBoundWithinRange(start, end)) return new int[]{newStart, newEnd};
        //Check if start is within the passed bounds
        if(upperBoundStart >= start && upperBoundStart <= end) newStart = end+1;
        //Check if end is within the passed bounds
        if(upperBoundEnd >= start && upperBoundEnd <= end) newEnd = start-1;
        //return invalid range if both are within the passed bounds
        if(newStart > newEnd) return new int[]{-1, -1};
        return new int[]{newStart, newEnd};
    }
    public void updateEstimatedMovementInfluence(int[] currentInf) {
        int minInf, maxInf;
        if(!isRangeDefined()) {
            //Assume 0-100 which means both -1 and 0 influence
            minInf = -1; maxInf = 0;
        } else {
            boolean canInfluence = isWithinRange(41,59);
            boolean canNotInfluence = isWithinRange(0, 40) || isWithinRange(60, 100);
            if(canInfluence && canNotInfluence) {
                //This vent has the possibility to both slow and not slow movement
                minInf = -1; maxInf = 0;
            }
            else if(canInfluence) {
                //This vent only has the possibility to slow movement
                minInf = maxInf = -1;
            }
            else if(canNotInfluence) {
                //This vent cannot influence movement
                minInf = maxInf = 0;
            }
            else {
                //Somehow invalid range - should be impossible
                //Assume 0-100 which means both -1 and 0 influence
                minInf = -1; maxInf = 0;
            }
        }
        currentInf[0] += minInf;
        currentInf[1] += maxInf;
    }

    public int getReversedInfluence(int outsideVentInfluence) {
        //We know the value is the same as before so we can exit safely
        if(outsideVentInfluence < -1)
            return isIdentified() ? getMovementInfluenceOfValue(capVentValue(actualValue)) : 0;
        //Cannot reverse a blank value
        if(!isRangeDefined()) return STARTING_VENT_VALUE;

        if(!isIdentified() && !isFreezeClipAccurate()) {
            //Our ranges are estimated
            if(!isTwoSeperateValues()) {
                //Exit on huge single ranges that border on freeze non-freeze
                if(lowerBoundStart < 41 && lowerBoundEnd > 59) return STARTING_VENT_VALUE;

                int lowerStartInf = determineReversedInfluence(outsideVentInfluence, lowerBoundStart);
                if(lowerStartInf == STARTING_VENT_VALUE) return STARTING_VENT_VALUE;
                //Can simply exit since this is a single estimated value
                if(isLowerBoundSingleValue()) return lowerStartInf;

                int lowerEndInf = determineReversedInfluence(outsideVentInfluence, lowerBoundEnd);
                if(lowerEndInf == STARTING_VENT_VALUE) return STARTING_VENT_VALUE;
                //Exit on influence mismatch
                if(lowerStartInf != lowerEndInf) return STARTING_VENT_VALUE;
                return lowerStartInf;
            }

            //We have two seperate estimated ranges
            int lowerStartInf = determineReversedInfluence(outsideVentInfluence, lowerBoundStart);
            if(lowerStartInf == STARTING_VENT_VALUE) return STARTING_VENT_VALUE;

            if(!isLowerBoundSingleValue()) {
                int lowerEndInf = determineReversedInfluence(outsideVentInfluence, lowerBoundEnd);
                if(lowerEndInf == STARTING_VENT_VALUE) return STARTING_VENT_VALUE;
                //Exit on influence mismatch
                if(lowerStartInf != lowerEndInf) return STARTING_VENT_VALUE;
            }

            int upperStartInf = determineReversedInfluence(outsideVentInfluence, upperBoundStart);
            if(upperStartInf == STARTING_VENT_VALUE) return STARTING_VENT_VALUE;
            //Exit on influence mismatch
            if(lowerStartInf != upperStartInf) return STARTING_VENT_VALUE;

            if(!isUpperBoundSingleValue()) {
                int upperEndInf = determineReversedInfluence(outsideVentInfluence, upperBoundEnd);
                if(upperEndInf == STARTING_VENT_VALUE) return STARTING_VENT_VALUE;
                //Exit on influence mismatch
                if(upperStartInf != upperEndInf) return STARTING_VENT_VALUE;
            }
            return lowerStartInf;
        }

        //We are dealing with a known single value
        //We cannot reverse bounded values; dont know how long they been bounded
        if(isBounded()) return STARTING_VENT_VALUE;
        //Attempt to reverse this value and determine influence
        int value = isFreezeClipAccurate() ? getLowerBoundStart() : actualValue;
        return determineReversedInfluence(outsideVentInfluence, value);
    }
    public void doReversedMovement(int outsideVentInfluence) {
        if(!isRangeDefined()) return;
        int currentMoveRate = Math.max(0, BASE_MOVE_RATE + outsideVentInfluence) * movementDirection;
        if(!isIdentified() && !isFreezeClipAccurate()) {
            if(!isBounded(lowerBoundStart)) lowerBoundStart = capVentValue(getLowerBoundStart() - currentMoveRate);
            if(!isBounded(lowerBoundEnd)) lowerBoundEnd = capVentValue(getLowerBoundEnd() - currentMoveRate);
            if(!isBounded(upperBoundStart)) upperBoundStart = capVentValue(getUpperBoundStart() - currentMoveRate);
            if(!isBounded(upperBoundEnd)) upperBoundEnd = capVentValue(getUpperBoundEnd() - currentMoveRate);
            return;
        }
        if(isIdentified()) actualValue = capVentValue(actualValue - currentMoveRate);
        int value = isFreezeClipAccurate() ? capVentValue(getLowerBoundStart() - currentMoveRate) : actualValue;
        lowerBoundStart = lowerBoundEnd = value;
        upperBoundStart = upperBoundEnd = value;
    }

    public int getStabilityInfluence() {
        if(isFreezeClipAccurate()) return getStabilityInfluence(lowerBoundStart);
        if(!isIdentified()) return 0;
        return getStabilityInfluence(actualValue);
    }
    public boolean isBounded() {
        return isBounded(actualValue);
    }
    public void makeFreezeClipAccurate() {
        if(ventName != 'A') return;
        if(getLowerBoundStart() != 40 && getLowerBoundStart() != 60) return;
        if(!canBeFreezeClipAccurate()) return;
        isFreezeClipAccurate = true;
    }

    //Helpers
    private int capVentValue(int value) { return Math.min(MAX_VENT_VALUE, Math.max(MIN_VENT_VALUE, value));}
    private void setStartingRanges() {
        isFreezeClipAccurate = false;
        clearRanges();
        setLowerBoundRange(totalBoundStart, totalBoundEnd);
        setUpperBoundRange(totalBoundStart, totalBoundEnd);
    }
    private boolean isBounded(int value) {
        return value == 100 || value == 0;
    }
    private int determineReversedInfluence(int outsideVentInfluence, int value) {
        int[] infPossibilities = new int[BASE_MOVE_RATE];
        for(int i = 0; i < BASE_MOVE_RATE; ++i) {
            int move = (outsideVentInfluence + (BASE_MOVE_RATE - i)) * movementDirection;
            infPossibilities[i] = getMovementInfluenceOfValue(capVentValue(value - move));
        }
        //Exit on freeze, non-freeze mismatch cannot reverse reliably
        //eg blocked 41 or unblocked 59
        if(infPossibilities[0] != infPossibilities[1]) return STARTING_VENT_VALUE;
        int move = Math.max(0, (outsideVentInfluence + BASE_MOVE_RATE)) * movementDirection;
        return getMovementInfluenceOfValue(capVentValue(value - move));
    }


    //Getters
    public char getName() { return ventName; }
    public int getActualValue() { return actualValue; }
    public int getDirection() { return movementDirection; }
    public int getLowerBoundStart() { return lowerBoundStart; }
    public int getLowerBoundEnd() { return lowerBoundEnd; }
    public int getUpperBoundStart() { return upperBoundStart; }
    public int getUpperBoundEnd() { return upperBoundEnd; }
    public int getTotalBoundStart() { return totalBoundStart; }
    public int getTotalBoundEnd() { return totalBoundEnd; }
    public boolean canBeFreezeClipAccurate() {
        if(isIdentified()) return false;
        if(isTwoSeperateValues()) return false;
        return (isLowerBoundSingleValue() || isUpperBoundSingleValue());
    }
    public boolean isFreezeClipAccurate() {
        if(!canBeFreezeClipAccurate()) return false;
        return isFreezeClipAccurate;
    }
}

package com.ultimatevm;

import static com.ultimatevm.StatusState.*;
import static com.ultimatevm.VentStatus.*;

public class VentStatusPredicter {
    public static final int SLOWEST_VENT_UPDATE_TICK = VentStatusTimeline.VENT_MOVE_TICK_TIME-1;
    public static final int HIGHEST_STABLE_RNG_PLAYER_COUNT = 8;

    private VentStatusTimeline timeline;
    private StatusState displayState;
    private int numTicksNoMove;


    public VentStatusPredicter() {
        initialize();
    }
    public void initialize() {
        timeline = new VentStatusTimeline();
        displayState = new StatusState();
    }
    public void reset() {
        if(!timeline.isHasReset()) displayState.forceReset();
        timeline.reset();
    }
    public void updateVentStatus(int[] ventStatus, int chambers) {
        processVentChangeState(displayState.updateVentStatus(ventStatus, chambers));
    }
    public void makeStatusState(int change) {
        timeline.addStabilityUpdateTick(displayState, change);
    }
    public String getVentStatusText(int index, String startingText) {
        VentStatus[] vents = displayState.getVents();
        if(vents[index].isIdentified() || !vents[index].isRangeDefined()) return startingText;
        return startingText.substring(0, 3) +
                "<col=00ffff>" +
                getVentPercentText(vents[index]) +
                "</col>";
    }
    public void markEarthquakeEvent() {
        timeline.addEarthquakeEventTick();
    }

    //Helpers
    private String getVentPercentText(VentStatus vent) {
        StringBuilder builder = new StringBuilder();
        if(vent.isTwoSeperateValues()) {
            if(vent.isLowerBoundSingleValue())
                builder.append(vent.getLowerBoundStart()).append("%");
            else {
                builder.append(vent.getLowerBoundStart()).append("-");
                builder.append(vent.getLowerBoundEnd());
            }
            builder.append(" ");
            if(vent.isUpperBoundSingleValue())
                builder.append(vent.getUpperBoundStart()).append("%");
            else {
                builder.append(vent.getUpperBoundStart()).append("-");
                builder.append(vent.getUpperBoundEnd());
            }
        } else {
            if(vent.isLowerBoundSingleValue())
                builder.append(vent.getLowerBoundStart()).append("%");
            else {
                builder.append(vent.getLowerBoundStart()).append("-");
                builder.append(vent.getLowerBoundEnd()).append("%");
            }
        }
        return builder.toString();
    }
    private void processVentChangeState(int[] changeStates) {
        int bitState = 0, movementBitState = 0;
        for(int i = 0; i < changeStates.length; ++i) {
            if((changeStates[i] & VentChangeStateFlag.IDENTIFIED.bitFlag()) != 0) {
                bitState |= (1 << i);
                movementBitState |= (3 << (i * 2));
            }
            if((changeStates[i] & VentChangeStateFlag.DIRECTION_CHANGE.bitFlag()) != 0) {
                bitState |= (1 << (i+3));
            }

            if((changeStates[i] & VentChangeStateFlag.NO_CHANGE.bitFlag()) != 0) {
                //TODO: Record how many ticks a specific vent has no change
                bitState |= 64;
            }

            if((changeStates[i] & VentChangeStateFlag.ONE_CHANGE.bitFlag()) != 0) {
                bitState |= 128;
                movementBitState |= (1 << (i * 2));
            }

            if((changeStates[i] & VentChangeStateFlag.TWO_CHANGE.bitFlag()) != 0) {
                bitState |= 128;
                movementBitState |= (2 << (i * 2));
            }

            if((changeStates[i] & VentChangeStateFlag.RESET.bitFlag()) != 0){
                bitState |= 512;
            }

            //By default set movement state to 3(dont know move) if the vent is unknown
            if(!displayState.getVents()[i].isIdentified())
                movementBitState |= (3 << (i * 2));
        }

        //Reset when all vents are set to unidentified
        if((bitState & 512) != 0) {
            displayState.doVMReset();
        }
        timeline.addInitialState(displayState);

        if((bitState & VentStatusTimeline.DIRECTION_CHANGED_BIT_MASK) != 0) timeline.addDirectionChangeTick(bitState);

        //Do an estimated move if a movement update was skips for whatever reason
        if((bitState & 128) == 0) {
            if(++numTicksNoMove == VentStatusTimeline.VENT_MOVE_TICK_TIME) {
                timeline.addEstimatedMovementTick();
                numTicksNoMove = 0;
            }
        }
        if((bitState & 128) != 0) {
            timeline.addMovementTick(displayState, (movementBitState << 6));
            numTicksNoMove = 0;
        }
        if((bitState & VentStatusTimeline.IDENTIFIED_BIT_MASK) != 0) {
            timeline.addIdentifiedVentTick(displayState, bitState);
        }
    }
    public void updateDisplayState() {
        if(StabilityUpdateInfo.getNumPlayers() > HIGHEST_STABLE_RNG_PLAYER_COUNT) return;
        if(displayState.isAllVentsIdentified()) return;
        StatusState predictedState = timeline.getCurrentPredictionState();
        if(predictedState == null) return;
        for(int i = 0; i < NUM_VENTS; ++i) {
            VentStatus vent = displayState.getVents()[i];
            if(vent.isIdentified()) continue;
            vent.setEqualTo(predictedState.getVents()[i]);
        }
    }

    public int getFutureStabilityChange(UltimateVolcanicMineConfig.PredictionScenario scenario) {
        return displayState.getFutureStabilityChange(scenario);
    }
    public final StatusState getDisplayState() { return displayState; }
    public final VentStatusTimeline getTimeline() { return timeline; }
    public final int getCurrentTick() { return timeline.getCurrentTick(); }
    public boolean isMovementUpdateTick() { return getCurrentTick() % VentStatusTimeline.VENT_MOVE_TICK_TIME == SLOWEST_VENT_UPDATE_TICK;}
}

package com.ultimatevm;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;

public class VentStatusTimeline {
    //Constants
    public static final int VENT_MOVE_TICK_TIME = 10;
    public static final int STABILITY_UPDATE_TICK_TIME = 25;
    public static final int VM_GAME_FULL_TIME = 1000;
    public static final int VM_GAME_RESET_TIME = 500;

    //Flags
    public static final int DIRECTION_CHANGED_FLAG = 16;
    public static final int IDENTIFIED_VENT_FLAG = DIRECTION_CHANGED_FLAG+1;
    public static final int MOVEMENT_UPDATE_FLAG = IDENTIFIED_VENT_FLAG+1;
    public static final int STABILITY_UPDATE_FLAG = MOVEMENT_UPDATE_FLAG+1;
    public static final int EARTHQUAKE_EVENT_FLAG = STABILITY_UPDATE_FLAG+1;
    public static final int ESTIMATED_MOVEMENT_FLAG = EARTHQUAKE_EVENT_FLAG+1;
    public static final int HALF_SPACE_COMPLETED_FLAG = ESTIMATED_MOVEMENT_FLAG+1;


    //Masks
    public static final int IDENTIFIED_BIT_MASK = 7;
    public static final int DIRECTION_CHANGED_BIT_MASK = 7 << 3;
    public static final int MOVEMENT_BIT_MASK = 63 << 6;
    //       |   move    | dir |  id |
    //0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

    public static final int HALF_SPACE_VENTS_BIT_MASK = 7 << HALF_SPACE_COMPLETED_FLAG+1;
    public static final int HALF_SPACE_CLIP_BIT_MASK = 7 << HALF_SPACE_COMPLETED_FLAG+4;
    //clip |vents| space completed?
    //0 0 0 0 0 0  0

    private int currentTick, startingTick;
    private int currentMovementTick, firstStabilityUpdateTick;
    private int[] timeline;
    private int[] identifiedVentTick;
    private StatusState[] identifiedVentStates;
    private TimelineCache[] timelineCaches;
    private int numIdentifiedVents;
    private boolean hasReset = false;
    StatusState initialState;
    StabilityUpdateInfo initialStabInfo;
    HashMap<Integer, StatusState> tickToMovementVentState;
    HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState;

    public VentStatusTimeline() {
        initialize();
    }
    public void initialize() {
        currentTick = 0;
        timeline = new int[VM_GAME_FULL_TIME];
        tickToMovementVentState = new HashMap<>();
        tickToStabilityUpdateState = new HashMap<>();
        reset();
        hasReset = false;
    }
    public void reset() {
        if(hasReset) return;
        hasReset = true;
        firstStabilityUpdateTick = Integer.MAX_VALUE;
        currentMovementTick = startingTick = currentTick;
        numIdentifiedVents = 0;
        initialState = null;
        initialStabInfo = null;
        clearCache();
        identifiedVentTick = new int[StatusState.NUM_VENTS+1];
        identifiedVentStates = new StatusState[StatusState.NUM_VENTS+1];
        for(int i = 0; i < StatusState.NUM_VENTS+1; ++i) {
            identifiedVentTick[i] = -1;
            identifiedVentStates[i] = null;
        }
    }
    public void clearCache() {
        timelineCaches = new TimelineCache[StabilityUpdateInfo.getMaxRNGPossibleSize()];
        for(int i = 0; i < timelineCaches.length; ++i)
            timelineCaches[i] = new TimelineCache();
    }
    public void initalizeCache() {
        for(int i = 0; i < timelineCaches.length; ++i)
            timelineCaches[i].initalize(initialState, startingTick);
    }
    public boolean addInitialState(StatusState startingState) {
        //Only add initial state once for pre reset and post reset
        if(initialState != null) return false;
        initialState = new StatusState(startingState);
        initalizeCache();
        return true;
    }
    public void addIdentifiedVentTick(StatusState currentState, int bitState) {
        int ventIndex = -1;
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            if(identifiedVentTick[i] != -1) continue;
            if ((bitState & (1 << i)) != 0) {
                timeline[currentTick] |= (1 << IDENTIFIED_VENT_FLAG);
                timeline[currentTick] |= bitState & IDENTIFIED_BIT_MASK;
                ++numIdentifiedVents;
                identifiedVentStates[i] = new StatusState(currentState);
                identifiedVentTick[i] = currentTick;
                ventIndex = i;
            }
        }

        if(numIdentifiedVents == 3 || ventIndex == -1) return;
        //Backtrack and fill out missing vent values
        updatePreviousVentValues(identifiedVentStates[ventIndex], currentTick);
    }
    private void backtrackFreezeClipAccurateA(StatusState currentState) {
        //Exit if we already reversed this value
        if(identifiedVentTick[3] != -1) return;
        identifiedVentStates[3] = new StatusState(currentState);
        identifiedVentTick[3] = currentTick;
        //Don't backtrack if the other two vents are already identified
        if(numIdentifiedVents+1 >= 3) return;
        updatePreviousVentValues(identifiedVentStates[3], currentTick);
    }
    private void updatePreviousVentValues(StatusState startingState, int tick) {
        clearCache();
        StatusState curState = new StatusState(startingState);
        LinkedList<Integer> stabilityUpdateTicks = new LinkedList<>();
        int numTicksNoMovement = 0, futureMovementTick = Integer.MAX_VALUE;
        for(int i = tick; i > startingTick; --i) {
            //Exit when there is a chain of missing movement updates
            if(numTicksNoMovement > (VENT_MOVE_TICK_TIME * 2)) break;

            if((timeline[i] & (1 << STABILITY_UPDATE_FLAG)) != 0) {
                //If future movement occured within 10 ticks we can process this now
                if(futureMovementTick - i <= VENT_MOVE_TICK_TIME) {
                    StabilityUpdateInfo stabilityInfo = tickToStabilityUpdateState.get(i);
                    stabilityInfo.updateVentValues(curState);
                    setInitialStabilityUpdateInfo(stabilityInfo);
                }
                //otherwise we have to process this during the previous movement update
                else stabilityUpdateTicks.addLast(i);
            }

            if((timeline[i] & (1 << MOVEMENT_UPDATE_FLAG)) != 0) {
                numTicksNoMovement = 0;
                futureMovementTick = i;
                //update the future stability state
                if(!stabilityUpdateTicks.isEmpty()) {
                    StabilityUpdateInfo stabilityInfo = tickToStabilityUpdateState.get(stabilityUpdateTicks.getFirst());
                    stabilityInfo.updateVentValues(curState);
                    setInitialStabilityUpdateInfo(stabilityInfo);
                    stabilityUpdateTicks.removeFirst();
                }
                //update the movement state
                StatusState movementState = tickToMovementVentState.get(i);
                movementState.setVentsEqualTo(curState);
                //exit if we can longer reverse the movement
                int bitMoveState = (timeline[i] & MOVEMENT_BIT_MASK) >> 6;
                if(!curState.reverseMovement(bitMoveState)) break;
                //update the movement bit info
                bitMoveState = StatusState.makeMoveBitState(movementState, curState);
                timeline[i] &= ~(MOVEMENT_BIT_MASK);
                timeline[i] |= bitMoveState;
            } else ++numTicksNoMovement;

            if(isEarthquakeDelayMovement(i)) numTicksNoMovement = 0;

            if((timeline[i] & (1 << DIRECTION_CHANGED_FLAG)) != 0) {
                //Change our direction if it occured this tick
                changeStateDirection(curState, i);
            }
        }
        initalizeCache();
    }
    private void clearMoveSkipEstimatedMove() {
        int minTick = Math.max(startingTick, currentTick - (int)(VENT_MOVE_TICK_TIME * 2.5f));
        int prevEstMoveTick = Integer.MIN_VALUE, prevMoveTick = Integer.MIN_VALUE;
        for(int i = currentTick-1; i >= minTick; --i) {
            if((timeline[i] & (1 << ESTIMATED_MOVEMENT_FLAG)) != 0) {
                //exit if consecutive estimated movement (means no skip)
                if(prevEstMoveTick != Integer.MIN_VALUE) return;
                prevEstMoveTick = i;
            }
            if((timeline[i] & (1 << MOVEMENT_UPDATE_FLAG)) != 0) {
                //exit if consecutive movement (means no skip)
                if(prevMoveTick != Integer.MIN_VALUE) return;
                prevMoveTick = i;
            }
        }
        //Exit if either estimated or actual movement tick are not found
        if(prevEstMoveTick == Integer.MIN_VALUE || prevMoveTick == Integer.MIN_VALUE) return;
        //Exit if the previous movement tick is after the estimated one
        if(prevMoveTick > prevEstMoveTick) return;
        //remove estimated movement tick was added since a movement tick was skipped
        timeline[prevEstMoveTick] &= ~(1 << ESTIMATED_MOVEMENT_FLAG);
    }
    private void fixPreviousEstimatedMoves() {
        clearCache();
        int updateTick = currentTick % VENT_MOVE_TICK_TIME;
        for(int i = currentTick-1; i >= currentMovementTick; --i) {
            //Clear estimated movement flag
            timeline[i] &= ~(1 << ESTIMATED_MOVEMENT_FLAG);
            if(i % VENT_MOVE_TICK_TIME == updateTick)
                addEstimatedMovementTick(i);
        }
        initalizeCache();
    }

    public void addDirectionChangeTick(int bitState) {
        timeline[currentTick] |= (bitState & DIRECTION_CHANGED_BIT_MASK);
        timeline[currentTick] |= (1 << DIRECTION_CHANGED_FLAG);
    }
    public void addEarthquakeEventTick() {
        timeline[currentTick] |= (1 << EARTHQUAKE_EVENT_FLAG);
        //Clear estimated movement flag
        timeline[currentTick] &= ~(1 << ESTIMATED_MOVEMENT_FLAG);
    }
    public void addMovementTick(StatusState currentState, int movementBitState) {
        //A movement tick cannot occur on or before a starting tick
        if(currentTick <= startingTick) return;
        addNewMovementTickState(currentTick, currentState, movementBitState);
        clearMoveSkipEstimatedMove();
        //Update previous values on the very first movement update (likely after a vent check)
        if(currentMovementTick == startingTick) {
            fixPreviousEstimatedMoves();
            updatePreviousVentValues(currentState, currentTick);
        }
        currentMovementTick = currentTick;
    }
    public void addStabilityUpdateTick(StatusState currentState, int change) {
        addNewStabilityUpdateTickState(currentTick, currentState, change);
    }
    public boolean addEstimatedMovementTick() {
        return addEstimatedMovementTick(currentTick);
    }
    private boolean addEstimatedMovementTick(int tick) {
        //A movement tick cannot occur on or before a starting tick
        if(tick <= startingTick) return false;
        //Estimated movements cannot occur same tick as an earthquake
        if((timeline[tick] & (1 << EARTHQUAKE_EVENT_FLAG)) != 0)
            return false;
        timeline[tick] |= (1 << ESTIMATED_MOVEMENT_FLAG);
        return true;
    }
    private void checkHalfSpace(int tick) {
        if(!tickToStabilityUpdateState.containsKey(tick)) return;
        //Do this only if one vent is known
        int numKnownVents = tickToStabilityUpdateState.get(tick).getStabilityUpdateState().getNumIdentifiedVents();
        if(numKnownVents != 1) return;

        //Find a valid previous change
        int currentChange = tickToStabilityUpdateState.get(tick).getInitialChange();
        int endingTick = Math.max(tick - (STABILITY_UPDATE_TICK_TIME*2),startingTick);
        for(int i = tick - STABILITY_UPDATE_TICK_TIME; i >= endingTick; i -= STABILITY_UPDATE_TICK_TIME) {
            if(!tickToStabilityUpdateState.containsKey(i)) continue;

            int change = tickToStabilityUpdateState.get(i).getInitialChange();
            int prevKnownVents = tickToStabilityUpdateState.get(i).getStabilityUpdateState().getNumIdentifiedVents();

            //Ensure these two updates have the same number of known vents
            if(numKnownVents != prevKnownVents)
                continue;

            //Determine each vents contribution and direction changes
            int[] pointChange = new int[StatusState.NUM_VENTS];
            int[] moveChange = new int[StatusState.NUM_VENTS+1];
            if(!getPointContribution(i, tick, pointChange, moveChange))
                break;

            int timeframeSize = (tick - i) / STABILITY_UPDATE_TICK_TIME;
            if(completeHalfSpace(tick, timeframeSize,currentChange - change, pointChange, moveChange))
                break;
        }
    }
    public StatusState getTimelinePredictionState() {
        //Get the current cache to use
        TimelineCache cache;
        if(initialStabInfo == null) {
            cache = timelineCaches[(-StabilityUpdateInfo.getMinRNGVariation())+1];
        }
        else cache = timelineCaches[(-initialStabInfo.getRNGUpdateMod())+1];

        for(; cache.i <= currentTick; ++cache.i) {
            if((timeline[cache.i] & (1 << IDENTIFIED_VENT_FLAG)) != 0) {
                int idFlags = timeline[cache.i] & IDENTIFIED_BIT_MASK;
                Iterator<StatusState> iterator = cache.possibleStates.descendingIterator();
                cache.mostRecentIdentifyTick = cache.i;
                while (iterator.hasNext()) {
                    StatusState curState = iterator.next();
                    if ((idFlags & 1) != 0) {
                        curState.setVentEqualTo(identifiedVentStates[0], 0);
                    }
                    if ((idFlags & 2) != 0) {
                        curState.setVentEqualTo(identifiedVentStates[1], 1);
                    }
                    if ((idFlags & 4) != 0) {
                        curState.setVentEqualTo(identifiedVentStates[2], 2);
                    }
                }
            }
            if((timeline[cache.i] & (1 << ESTIMATED_MOVEMENT_FLAG)) != 0) {
                int mostRecentEvent = Math.max(cache.mostRecentIdentifyTick, cache.previousMovementTick);
                boolean isValueClipped = false, isConsecMoveSkip = (cache.i - mostRecentEvent > VENT_MOVE_TICK_TIME);
                StatusState newPossibility = new StatusState(cache.possibleStates.getLast());

                //Don't do any freeze clipping unless two movements were skipped
                if(isConsecMoveSkip) isValueClipped = newPossibility.doFreezeClipping(0);

                //Only set if value wasnt freeze clipped
                if(!isValueClipped) {
                    handleSameTickDirectionChangeMovement(newPossibility, cache.i);
                    cache.possibleStates.addLast(newPossibility);
                }
                //Set predicted state to the new up to date possibility
                //If two consecutive movements are skipped just update the predicted state
                if(isConsecMoveSkip) cache.predictedState = cache.possibleStates.getLast();
            }
            if((timeline[cache.i] & (1 << MOVEMENT_UPDATE_FLAG)) != 0) {
                cache.previousMovementTick = cache.i;
                int moveBitState = timeline[cache.i] & MOVEMENT_BIT_MASK;
                moveBitState >>= 6;
                Iterator<StatusState> iterator = cache.possibleStates.descendingIterator();
                while (iterator.hasNext()) {
                    StatusState curState = iterator.next();
                    //Remove possibility if a value was clipped
                    boolean isValueClipped = curState.doFreezeClipping(moveBitState);
                    if(cache.possibleStates.size() > 1 && isValueClipped) {
                        iterator.remove();
                        continue;
                    }

                    //Update our estimated vent values
                    handleSameTickDirectionChangeMovement(curState, cache.i);
                    syncWithMovementState(curState, cache.i);
                }
                cache.predictedState = cache.possibleStates.getLast();
            }
            if((timeline[cache.i] & (1 << STABILITY_UPDATE_FLAG)) != 0) {
                Iterator<StatusState> iterator = cache.possibleStates.descendingIterator();
                StabilityUpdateInfo stabilityInfo = tickToStabilityUpdateState.get(cache.i);
                int initalRNGMod = initialStabInfo == null ?
                        StabilityUpdateInfo.getMinRNGVariation()
                        : initialStabInfo.getRNGUpdateMod();
                while (iterator.hasNext()) {
                    StatusState curState = iterator.next();
                    if(stabilityInfo.isValid()) {
                        //Use stability updates to set/narrow our possible values
                        if (stabilityInfo == initialStabInfo) {
                            if(curState.getVents()[0].isFreezeClipAccurate()) initialStabInfo.updateVentValues(curState);
                            curState.alignPredictedRangesWith(initialStabInfo.getStabilityUpdateState());
                        } else stabilityInfo.updatePredictedState(curState, cache.prevStabInfo, initalRNGMod);
                    }

                    if((timeline[cache.i] & (1 << HALF_SPACE_COMPLETED_FLAG)) != 0) {
                        int ventsToClip = (timeline[cache.i] & HALF_SPACE_VENTS_BIT_MASK) >> (HALF_SPACE_COMPLETED_FLAG+1);
                        int clipInfo = (timeline[cache.i] & HALF_SPACE_CLIP_BIT_MASK) >> (HALF_SPACE_COMPLETED_FLAG+4);
                        curState.doHalfSpaceClipping(ventsToClip, clipInfo);
                    }
                }

                removeInvalidPossibilities(cache.possibleStates);
                cache.predictedState = cache.possibleStates.getLast();
                cache.prevStabInfo = stabilityInfo;
                cache.numTicksNegativePredictedStability = 0;
            }
            if((timeline[cache.i] & (1 << DIRECTION_CHANGED_FLAG)) != 0) {
                //Change our direction if it occured this tick
                Iterator<StatusState> iterator = cache.possibleStates.descendingIterator();
                while (iterator.hasNext()) {
                    changeStateDirection(iterator.next(), cache.i);
                }
            }

            int predictedChange = cache.predictedState.getFutureStabilityChange(UltimateVolcanicMineConfig.PredictionScenario.WORST_CASE);
            if(predictedChange < StabilityUpdateInfo.getMinRNGVariation()-1)
                ++cache.numTicksNegativePredictedStability;
            else cache.numTicksNegativePredictedStability = 0;

            //Attempt to clip invalid predicted ranges
            //This scenario occurs when stability stays 100% for extended time
            if(cache.prevStabInfo != null) {
                if (cache.numTicksNegativePredictedStability < STABILITY_UPDATE_TICK_TIME * 2) continue;

                int ticksSinceLastUpdate = cache.i - cache.prevStabInfo.getTickTimeStamp();
                if (ticksSinceLastUpdate < STABILITY_UPDATE_TICK_TIME * 2) continue;

                //Check and see if we meet requirements to display
                //a predicted stability change
                Iterator<StatusState> iterator = cache.possibleStates.descendingIterator();
                while (iterator.hasNext()) {
                    StatusState curState = iterator.next();
                    curState.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation() - 1);
                }
            }
        }
        if(cache.predictedState.getVents()[0].isFreezeClipAccurate())
            backtrackFreezeClipAccurateA(cache.predictedState);
        return cache.predictedState;
    }
    public StatusState getCurrentPredictionState() {
        return StabilityUpdateInfo.getPredictionState(initialStabInfo, this);
    }

    //Helpers
    private void addNewMovementTickState(int tick, StatusState currentState, int moveState) {
        StatusState newState = new StatusState(currentState);
        tickToMovementVentState.put(tick, newState);
        timeline[tick] |= (1 << MOVEMENT_UPDATE_FLAG);
        timeline[tick] |= moveState;
    }
    private void addNewStabilityUpdateTickState(int tick, StatusState currentState, int change) {
        StabilityUpdateInfo newInfo = new StabilityUpdateInfo(currentState, tick, change);
        tickToStabilityUpdateState.put(currentTick, newInfo);
        timeline[tick] |= (1 << STABILITY_UPDATE_FLAG);
        setInitialStabilityUpdateInfo(newInfo);
//        checkHalfSpace(currentTick);
    }
    private void setInitialStabilityUpdateInfo(StabilityUpdateInfo info) {
        firstStabilityUpdateTick = Math.min(firstStabilityUpdateTick, currentTick);
        //Skip if no identified vents
        int infoIdentifiedVentCount = info.getStabilityUpdateState().getNumIdentifiedVents();
        if(infoIdentifiedVentCount == 0) return;
        if(initialStabInfo == null) initialStabInfo = info;
        else if (initialStabInfo.getTickTimeStamp() > info.getTickTimeStamp())
            initialStabInfo = info;
    }
    private void changeStateDirection(StatusState state, int tick) {
        int directionFlags = timeline[tick] & DIRECTION_CHANGED_BIT_MASK;
        directionFlags >>= 3;
        if((directionFlags & 1) != 0) state.getVents()[0].flipDirection();
        if((directionFlags & 2) != 0) state.getVents()[1].flipDirection();
        if((directionFlags & 4) != 0) state.getVents()[2].flipDirection();
    }
    private void handleSameTickDirectionChangeMovement(StatusState curState, int tick) {
        if((timeline[tick] & (1 << DIRECTION_CHANGED_FLAG)) != 0) {
            //It's possible for the directional change to occur both
            //before and after this movement update; assume both possibilities
            StatusState newDirState = new StatusState(curState);
            changeStateDirection(newDirState, tick);
            newDirState.updateVentMovement();
            curState.updateVentMovement();
            curState.mergePredictedRangesWith(newDirState);
        }
        else curState.updateVentMovement();
    }
    private void syncWithMovementState(StatusState state, int tick) {
        StatusState moveState = tickToMovementVentState.get(tick);
        //Check and see if we can sync with an accurate freeze clipped value
        boolean accurateFreezeClipSync = (identifiedVentTick[3] != -1 && identifiedVentTick[3] >= tick);
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            if(!moveState.getVents()[i].isFreezeClipAccurate()) {
                if (!moveState.getVents()[i].isIdentified()) continue;
            } else if(!accurateFreezeClipSync) continue;

            state.setVentEqualTo(moveState, i);
        }
    }
    private boolean isEarthquakeDelayMovement(int tick) {
        if((timeline[tick] & (1 << EARTHQUAKE_EVENT_FLAG)) == 0) return false;

        //Check if next 10 ticks was a movement update
        if(tick + VENT_MOVE_TICK_TIME <= VM_GAME_FULL_TIME) {
            if ((timeline[tick + VENT_MOVE_TICK_TIME] & (1 << MOVEMENT_UPDATE_FLAG)) != 0)
                return true;
        }
        //Check if previous 10 ticks was a movement update
        if(tick - VENT_MOVE_TICK_TIME >= startingTick) {
            return (timeline[tick - VENT_MOVE_TICK_TIME] & (1 << MOVEMENT_UPDATE_FLAG)) != 0;
        }
        return false;
    }
    private void removeInvalidPossibilities(LinkedList<StatusState> possibleStates) {
        //Remove all invalid possibilities - always keep 1 state even if invalid
        Iterator<StatusState> iterator = possibleStates.descendingIterator();
        while (iterator.hasNext()) {
            if(possibleStates.size() == 1) break;
            StatusState curState = iterator.next();
            if(!curState.areRangesDefined()) iterator.remove();
        }
    }
    private boolean getPointContribution(int startTick, int endTick, int[] pointChange, int[] moveChange) {
        //Exit if starting stability update doesnt exist
        if(!tickToStabilityUpdateState.containsKey(startTick)) return false;

        //Get our starting points
        StatusState startState = tickToStabilityUpdateState.get(startTick).getStabilityUpdateState();
        int[] startingPoints = new int[StatusState.NUM_VENTS], endingPoints = new int[StatusState.NUM_VENTS];
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            if(!startState.getVents()[i].isIdentified())
                endingPoints[i] = startingPoints[i] = Integer.MAX_VALUE;
            else endingPoints[i] = startingPoints[i] = VentStatus.getStabilityInfluence(startState.getVents()[i].getActualValue());
        }

        int directionState = 0, numMovementUpdates = 0;
        for(int i = startTick; i <= endTick; ++i) {
            //Keep track of directional state to ensure proper half space clipping
            if((timeline[i] & (1 << DIRECTION_CHANGED_FLAG)) != 0) {
                int directionFlags = timeline[i] & DIRECTION_CHANGED_BIT_MASK;
                directionFlags >>= 3;
                if((directionFlags & 1) != 0) directionState |= 1;
                if((directionFlags & 2) != 0) directionState |= 2;
                if((directionFlags & 4) != 0) directionState |= 4;
            }

            //Update ending points
            if((timeline[i] & (1 << MOVEMENT_UPDATE_FLAG)) != 0) {
                StatusState moveState = tickToMovementVentState.get(i);
                for(int j = 0; j < StatusState.NUM_VENTS; ++j) {
                    if(!moveState.getVents()[j].isIdentified())
                        endingPoints[j] = Integer.MAX_VALUE;
                    else endingPoints[j] = VentStatus.getStabilityInfluence(moveState.getVents()[j].getActualValue());
                }
                //Keep track of how long each vent have been facing a specific direction
                moveChange[0] = ++numMovementUpdates;
            }
        }

        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            if(startingPoints[i] == Integer.MAX_VALUE)
                pointChange[i] = Integer.MAX_VALUE;
            else {
                pointChange[i] = endingPoints[i] - startingPoints[i];
                directionState &= ~(1 << i);
            }
        }
        return directionState == 0;
    }
    private boolean completeHalfSpace(int tick, int timeframeSize, int changeDiff, int[] pointChange, int[] moveChange) {
        //Make sure change cannot be influenced by rng
        if(Math.abs(changeDiff) < StabilityUpdateInfo.getMaxRNGPossibleSize())
            return false;

        //Get influence of the two missing vents
        int knownVentIndex = 0;
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            if(pointChange[i] == Integer.MAX_VALUE) {
                continue;
            }
            changeDiff -= pointChange[i];
            knownVentIndex = i;
        }
        int missingVentFlag = 7 & ~(1 << knownVentIndex);

        //No movement check
        if(moveChange[0] == 0) {
            //For B this is only possible if A is 41-59; just clip A
            if(knownVentIndex == 1) {
                if(changeDiff < 0) {
                    //1 placed for downward clipping trend
                    timeline[tick] |= (1 << HALF_SPACE_COMPLETED_FLAG+4);
                }
                //0s placed for clipping for upward trend
                timeline[tick] |= (1 << HALF_SPACE_COMPLETED_FLAG+1);
                timeline[tick] |= (1 << HALF_SPACE_COMPLETED_FLAG);
                return true;
            }
            //No movement is unacceptable for A
            //For C Either A or B are 41-59 dont know which so cant clip
            return false;
        } else {
            //Both missing vents must have increased or decreased change
            if(Math.abs(changeDiff) <= timeframeSize) return false;

            if(changeDiff < 0) {
                //1 placed for downward clipping trend
                timeline[tick] |= (missingVentFlag << HALF_SPACE_COMPLETED_FLAG+4);
            }
            //0s placed for clipping for upward trend
            timeline[tick] |= (missingVentFlag << HALF_SPACE_COMPLETED_FLAG+1);
            timeline[tick] |= (1 << HALF_SPACE_COMPLETED_FLAG);
        }
        return true;
    }

    //Accessors
    public boolean isHasReset() { return hasReset; }
    public int getCurrentTick() { return currentTick; }
    public int getCurrentStartingTick() {return startingTick;}
    public int getNumIdentifiedVents() { return numIdentifiedVents; }
    public boolean hasEventOccuredThisTick() { return timeline[currentTick] != 0; }
    public final int[] getTimeline() { return timeline; }
    public final int[] getIdentifiedVentTicks() { return identifiedVentTick; }
    public final StatusState[] getIdentifiedVentStates() { return identifiedVentStates; }
    public final StatusState getInitialState() { return initialState; }
    public final HashMap<Integer, StatusState> getMovementVentStates() { return tickToMovementVentState; }
    public final HashMap<Integer, StabilityUpdateInfo> getStabilityUpdateStates() { return tickToStabilityUpdateState; }

    //Modifiers
    public void updateTick() { ++currentTick; }
}

package com.ultimatevm;

import java.util.HashMap;
import java.util.HashSet;
import net.runelite.client.Notifier;

import javax.inject.Inject;


public class VMNotifier {
    public enum NotificationEvents {
        VM_PLAYER_LEAVE,
        VM_EXTRA_PLAYER,
        VM_RESET,
        VM_ERUPTION,
        VM_PRE_RESET_VENT_FIX,
        VM_POST_RESET_VENT_FIX,
        VM_PREDICTED_VENT_FIX,
        VM_PICKAXE_DESPAWN,
        VM_PICKAXE_LOW_STABILITY,
        VM_PICKAXE_BOULDER_COMPLETE;
    }
    public static final int NOTIFICATION_START_COOLDOWN_TICKS = 10;
    @Inject
    private UltimateVolcanicMineConfig config;
    private HashSet<NotificationEvents> oneTimeEvents = new HashSet<>();
    private HashMap<NotificationEvents, Integer> continousEvents = new HashMap<>();
    @Inject
    VMNotifier(UltimateVolcanicMineConfig config) {
        this.config = config;
        reset();
    }
    private void setOneTimeEvents() {
        oneTimeEvents.add(NotificationEvents.VM_PLAYER_LEAVE);
        oneTimeEvents.add(NotificationEvents.VM_EXTRA_PLAYER);
        oneTimeEvents.add(NotificationEvents.VM_RESET);
        oneTimeEvents.add(NotificationEvents.VM_ERUPTION);
        oneTimeEvents.add(NotificationEvents.VM_PRE_RESET_VENT_FIX);
        oneTimeEvents.add(NotificationEvents.VM_POST_RESET_VENT_FIX);
        oneTimeEvents.add(NotificationEvents.VM_PREDICTED_VENT_FIX);
        oneTimeEvents.add(NotificationEvents.VM_PICKAXE_DESPAWN);
        oneTimeEvents.add(NotificationEvents.VM_PICKAXE_LOW_STABILITY);
        oneTimeEvents.add(NotificationEvents.VM_PICKAXE_BOULDER_COMPLETE);
    }
    private void setContinousEvents() {
        continousEvents.put(NotificationEvents.VM_PICKAXE_DESPAWN, 0);
    }
    public void reset() {
        setOneTimeEvents();
        setContinousEvents();
    }
    public void removeEvent(NotificationEvents event) {
        oneTimeEvents.remove(event);
    }
    public void notify(Notifier notifier, NotificationEvents event, int ticksPassed) {
        if(!oneTimeEvents.contains(event)) return;
        //Special case for extra player since we want notif to go off asap
        if(event == NotificationEvents.VM_EXTRA_PLAYER) {
            if(!config.extraPlayerNotifier()) return;
            notifier.notify("An extra player has joined your team!");
            oneTimeEvents.remove(event);
        }

        if(ticksPassed <= NOTIFICATION_START_COOLDOWN_TICKS) return;

        switch (event) {
            case VM_PLAYER_LEAVE:
                oneTimeEvents.remove(event);
                if(!config.playerLeaveNotifier()) return;
                notifier.notify("A player has left the mine!");
                break;

            case VM_RESET:
                oneTimeEvents.remove(event);
                if(!config.showVentWarning()) return;
                notifier.notify("The vents will shift in " + config.ventWarningTime() + " seconds!");
                break;

            case VM_ERUPTION:
                oneTimeEvents.remove(event);
                if(!config.showEruptionWarning()) return;
                notifier.notify("The volcano will erupt in " + config.eruptionWarningTime() + " seconds!");
                break;

            case VM_PRE_RESET_VENT_FIX:
                oneTimeEvents.remove(event);
                if(!config.ventFixNotifier()) return;
                notifier.notify("Fix your vent!");
                break;

            case VM_POST_RESET_VENT_FIX:
                oneTimeEvents.remove(event);
                if(!config.postResetVentFixNotifier()) return;
                notifier.notify("Consider fixing all 3 vents; the mine can collapse with bad RNG!");
                break;

            case VM_PREDICTED_VENT_FIX:
                oneTimeEvents.remove(event);
                if(!config.predictedVentFixNotifier()) return;
                notifier.notify("Be alert you might have to fix your vent soon!");
                break;

            case VM_PICKAXE_DESPAWN:
                int lastEventTime = continousEvents.get(NotificationEvents.VM_PICKAXE_DESPAWN);
                if(lastEventTime + NOTIFICATION_START_COOLDOWN_TICKS < ticksPassed) {
                    notifier.notify("Be careful your pickaxe will despawn soon!");
                    continousEvents.put(NotificationEvents.VM_PICKAXE_DESPAWN, ticksPassed);
                }
                break;

            case VM_PICKAXE_LOW_STABILITY:
                oneTimeEvents.remove(event);
                notifier.notify("Mine Stability is low don't forget your pickaxe!");
                break;

            case VM_PICKAXE_BOULDER_COMPLETE:
                oneTimeEvents.remove(event);
                notifier.notify("You finished the boulder, pick up your pickaxe!");
                break;

            default:
                break;
        }
    }
}

package com.ultimatevm;

import org.junit.Assert;
import org.testng.annotations.Test;
@Test()
public class SimulationTests {
    VentStatusPredicter predicter;
    int[] ventValues, ventDirection;
    int u = VentStatus.STARTING_VENT_VALUE;
    int directionBitState, currentTick;

    //Helpers
    private void createPredicter(int dir, int tick, int size) {
        StabilityUpdateInfo.setNumPlayers(size);
        predicter = new VentStatusPredicter();
        ventValues = new int[]{u,u,u};
        ventDirection = new int[]{0,0,0};
        currentTick = tick+1;
        updateVentDirection(dir);
        predicter.updateVentStatus(ventValues, directionBitState);
        predicter.getTimeline().updateTick();
    }
    private int getDirectionFromChambers(int index, int chambers) { return (chambers & (1 << index)) != 0 ? 1 : -1;}
    private void updateVentDirection(int dir) {
        directionBitState = dir;
        for(int i = 0; i < StatusState.NUM_VENTS; ++i)
            ventDirection[i] = getDirectionFromChambers(i, directionBitState);
    }
    private void advanceTicks(int nextTick) {
        int advTicks = nextTick - currentTick;
        for(int i = 0; i < advTicks; ++i) {
            predicter.updateVentStatus(ventValues, directionBitState);
            predicter.getTimeline().updateTick();
        }
        currentTick = nextTick;
    }
    private void identifyVent(int A, int B, int C) {
        if(A != u) ventValues[0] = A;
        if(B != u) ventValues[1] = B;
        if(C != u) ventValues[2] = C;
    }

    //Events
    private void doIdentifyVent(int tick, int A, int B, int C) {
        advanceTicks(tick-1);
        identifyVent(A, B, C);
        predicter.updateVentStatus(ventValues, directionBitState);
        predicter.updateDisplayState();
        predicter.getTimeline().updateTick();
        ++currentTick;
    }
    private void doDirectionChange(int tick, int newDir) {
        advanceTicks(tick-1);
        updateVentDirection(newDir);
        predicter.updateVentStatus(ventValues, directionBitState);
        predicter.updateDisplayState();
        predicter.getTimeline().updateTick();
        ++currentTick;
    }
    private void doStabilityUpdate(int tick, int change) {
        advanceTicks(tick-1);
        predicter.updateVentStatus(ventValues, directionBitState);
        predicter.makeStatusState(change);
        predicter.updateDisplayState();
        predicter.getTimeline().updateTick();
        ++currentTick;
    }
    private void doMovementUpdateByValue(int tick, int A, int B, int C) {
        advanceTicks(tick-1);
        identifyVent(A, B, C);
        predicter.updateVentStatus(ventValues, directionBitState);
        predicter.updateDisplayState();
        predicter.getTimeline().updateTick();
        ++currentTick;
    }
    private void doSameTickMovementStabilityUpdate(int tick, int A, int B, int C, int change) {
        advanceTicks(tick-1);
        identifyVent(A, B, C);
        predicter.updateVentStatus(ventValues, directionBitState);
        predicter.makeStatusState(change);
        predicter.updateDisplayState();
        predicter.getTimeline().updateTick();
        ++currentTick;
    }
    private void doSameTickMovementDirectionUpdate(int tick, int A, int B, int C, int newDir) {
        advanceTicks(tick-1);
        identifyVent(A, B, C);
        updateVentDirection(newDir);
        predicter.updateVentStatus(ventValues, directionBitState);
        predicter.getTimeline().updateTick();
        ++currentTick;
    }
    private void doEarthquake(int tick) {
        advanceTicks(tick-1);
        predicter.markEarthquakeEvent();
        predicter.updateDisplayState();
    }
    private void doReset() {
        predicter.reset();
        predicter.updateVentStatus(new int[]{u,u,u}, directionBitState);
        predicter.getTimeline().updateTick();
        ++currentTick;
    }

    public void simulateFreezeClipAFreezeThresholdCross() {
        createPredicter(1, 500, 1);
        doEarthquake(505);
        doIdentifyVent(523, u, 66, u);
        doMovementUpdateByValue(530, u, 64, u);
        doIdentifyVent(537, u, 64, 29);
        doMovementUpdateByValue(540, u, 62, 27);
        doMovementUpdateByValue(550, u, 60, 25);
        doMovementUpdateByValue(560, u, 58, 23);
        doMovementUpdateByValue(570, u, 57, 22);
        doMovementUpdateByValue(580, u, 56, 21);
        doMovementUpdateByValue(590, u, 55, 20);
        doDirectionChange(595, 3);
        doDirectionChange(599, 1);
        doSameTickMovementDirectionUpdate(600, u, 56, 19, 3);
        doDirectionChange(603, 1);
        doMovementUpdateByValue(610, u, 55, 18);
        doMovementUpdateByValue(620, u, 54, 17);
        doMovementUpdateByValue(630, u, 53, 16);
        doEarthquake(640);
        doMovementUpdateByValue(650, u, 52, 15);
        doEarthquake(655);
        doMovementUpdateByValue(660, u, 51, 14);
        doMovementUpdateByValue(680, u, 50, 13);
        doMovementUpdateByValue(690, u, 49, 12);
        doSameTickMovementStabilityUpdate(700, u, 48, 11, -3);
        doMovementUpdateByValue(710, u, 47, 10);
        doMovementUpdateByValue(720, u, 46, 9);
        doStabilityUpdate(725, -6);
        doMovementUpdateByValue(730, u, 45, 8);
        doMovementUpdateByValue(740, u, 44, 7);
        doSameTickMovementStabilityUpdate(750, u, 43, 6, -9);
        doMovementUpdateByValue(760, u, 42, 5);
        doDirectionChange(764, 5);
        doMovementUpdateByValue(770, u, 41, 6);
        doStabilityUpdate(775, -9);
        doMovementUpdateByValue(780, u, 40, 7);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertTrue(predictedState.getVents()[0].isRangeDefined());
    }

    public void simulateFreezeClipABoundThresholdCross() {
        createPredicter(0, 500, 1);
        doIdentifyVent(500, u, u, 33);
        doMovementUpdateByValue(509, u, u, 31);
        identifyVent(u, 3, u);
        doMovementUpdateByValue(519, u, 3, 29);
        doStabilityUpdate(524, -4);
        doMovementUpdateByValue(529, u, 1, 27);
        doSameTickMovementDirectionUpdate(539, u, 0, 25, 2);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertTrue(predictedState.getVents()[0].isRangeDefined());
    }

    public void simulateEstimatedMoveRemoved() {
        createPredicter(4, 500, 1);
        doIdentifyVent(501, u, u, 41);
        doMovementUpdateByValue(509, u, u, 42);
        doMovementUpdateByValue(519, u, u, 43);
        doIdentifyVent(520, u, 72, u);
        doStabilityUpdate(524, 9);
        doMovementUpdateByValue(529, u, 70, 44);
        doMovementUpdateByValue(539, u, 68, 45);
        doSameTickMovementStabilityUpdate(549, u, 66, 46, 14);
        doMovementUpdateByValue(559, u, 64, 47);
        doMovementUpdateByValue(569, u, 63, 47);
        doStabilityUpdate(574, 17);
        doMovementUpdateByValue(579, u, 62, 47);
        doMovementUpdateByValue(589, u, 61, 47);
        doMovementUpdateByValue(599, u, 60, 47);
        doMovementUpdateByValue(609, u, 59, 47);
        doDirectionChange(615, 6);
        doDirectionChange(624, 4);
        doDirectionChange(626, 6);
        doDirectionChange(629, 4);
        doMovementUpdateByValue(749, u, 58, 47);
        doMovementUpdateByValue(759, u, 57, 47);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertTrue(predictedState.getVents()[0].isRangeDefined());
    }

    public void simulateFlickeringA() {
        createPredicter(6, 0, 1);
        doStabilityUpdate(24, 15);
        doIdentifyVent(43, u, 60, u);
        doSameTickMovementStabilityUpdate(49, u, 62, u, 12);
        doMovementUpdateByValue(59, u, 64, u);
        doIdentifyVent(60, u, u, 53);
        doMovementUpdateByValue(69, u, 66, 54);
        doDirectionChange(73, 2);
        doStabilityUpdate(74, 7);
        doMovementUpdateByValue(79, u, 68, 53);
        doMovementUpdateByValue(89, u, 70, 52);
        doDirectionChange(91, 0);
        doEarthquake(99);
        doMovementUpdateByValue(109, u, 68, 51);
        doMovementUpdateByValue(119, u, 66, 50);
        doStabilityUpdate(124, 6);
        advanceTicks(129);
//        doMovementUpdateByValue(139, u, 64, 49);
//        doSameTickMovementStabilityUpdate(149, u, 62, 48, 6);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertTrue(predictedState.getVents()[0].isRangeDefined());
    }

    public void simulateCBSoloStart() {
        createPredicter(3, 0, 1);
        doEarthquake(24);
        doIdentifyVent(44, u, u, 57);
        doStabilityUpdate(49, 15);
        doIdentifyVent(69, u, 37, u);
        doStabilityUpdate(74, 14);

        StatusState predictedState = predicter.getDisplayState();
        //Ensure freeze setting + stability clipping works properly
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 60);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 62);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 60);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 62);
    }

    public void simulateAFreezeRangeNoStabilityUpdate() {
        createPredicter(3, 500, 1);
        doIdentifyVent(506, u, u, 17);
        doMovementUpdateByValue(509, u, u, 15);
        doMovementUpdateByValue(519, u, u, 14);
        doIdentifyVent(524, u, 42, u);
        doMovementUpdateByValue(529, u, 43, 13);
        doMovementUpdateByValue(539, u, 44, 12);
        doMovementUpdateByValue(549, u, 45, 11);
        doMovementUpdateByValue(559, u, 46, 10);
        doEarthquake(669);
        doEarthquake(699);
        doMovementUpdateByValue(779, u, 47, 9);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 62);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 62);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 62);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 62);
    }

    public void simulateIncorrectFreezeRangeA() {
        createPredicter(2, 500, 1);
        doIdentifyVent(501, u, u, 57);
        doMovementUpdateByValue(509, u, u, 56);
        doIdentifyVent(517, u, 42, u);
        doMovementUpdateByValue(519, u, 43, 56);
        doStabilityUpdate(524, 16);
        doMovementUpdateByValue(529, u, 44, 56);
        doMovementUpdateByValue(539, u, 45, 56);
        doMovementUpdateByValue(549, u, 46, 56);
        doEarthquake(579);
        doEarthquake(654);
        doEarthquake(669);
        doMovementUpdateByValue(779, u, 47, 56);
        doMovementUpdateByValue(789, u, 48, 56);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 36);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 36);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 36);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 36);
    }

    public void simulateIncorrectMovementOrderBug() {
        createPredicter(3, 0, 1);
        doEarthquake(24);
        doIdentifyVent(33, 49, u, u);
        doMovementUpdateByValue(39, 50, u, u);
        doSameTickMovementStabilityUpdate(49, 51, u, u, 19);
        doIdentifyVent(54, u, 41, u);
        doMovementUpdateByValue(59, 52, 41, u);
        doMovementUpdateByValue(69, 53, 41, u);
        doStabilityUpdate(74, 19);
        doMovementUpdateByValue(79, 54, 41, u);
        doMovementUpdateByValue(89, 55, 41, u);
        doMovementUpdateByValue(99, 56, 41, u);
        doMovementUpdateByValue(109, 57, 41, u);
        doMovementUpdateByValue(119, 58, 41, u);
        doMovementUpdateByValue(129, 59, 41, u);
        doMovementUpdateByValue(139, 60, 41, u);
        doMovementUpdateByValue(149, 62, 42, u);
        doMovementUpdateByValue(159, 64, 43, u);
        doMovementUpdateByValue(169, 66, 44, u);
        doMovementUpdateByValue(179, 68, 45, u);
        doMovementUpdateByValue(189, 70, 46, u);
        doMovementUpdateByValue(199, 72, 47, u);
        doMovementUpdateByValue(209, 74, 48, u);
        doMovementUpdateByValue(229, 76, 49, u);
        doMovementUpdateByValue(239, 78, 50, u);
        doMovementUpdateByValue(249, 80, 51, u);
        doMovementUpdateByValue(259, 82, 52, u);
        doMovementUpdateByValue(269, 84, 53, u);
        doMovementUpdateByValue(279, 86, 54, u);
        doMovementUpdateByValue(289, 88, 55, u);
        doMovementUpdateByValue(299, 90, 56, u);
        doMovementUpdateByValue(309, 92, 57, u);
        doMovementUpdateByValue(319, 94, 58, u);
        doMovementUpdateByValue(329, 96, 59, u);
        doMovementUpdateByValue(339, 98, 60, u);
        doMovementUpdateByValue(349, 100, 62, u);
        doDirectionChange(351, 2);
        doMovementUpdateByValue(359, 98, 64, u);
        doMovementUpdateByValue(369, 96, 66, u);
        doMovementUpdateByValue(379, 94, 68, u);
        doMovementUpdateByValue(389, 92, 70, u);
        doMovementUpdateByValue(409, 90, 72, u);
        doMovementUpdateByValue(419, 88, 74, u);
        doStabilityUpdate(424, -1);
        doMovementUpdateByValue(429, 86, 76, u);
        doMovementUpdateByValue(439, 84, 78, u);
        doSameTickMovementStabilityUpdate(449, 82, 80, u, -2);

        //C is 26 - only possible answer
        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 26);
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 26);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 26);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 26);
    }

    public void simulateMovementSkipNonFreezeRangeA() {
        createPredicter(2, 0, 2);
        StatusState predictedState = predicter.getDisplayState();
        doReset();
        doIdentifyVent(25, u, 48, u);
        doMovementUpdateByValue(28, u, 49, u);
        doMovementUpdateByValue(38, u, 50, u);
        doIdentifyVent(39, u, u, 33);
        doMovementUpdateByValue(48, u, 51, 32);
        doMovementUpdateByValue(58, u, 52, 31);
        doDirectionChange(65, 0);
        doMovementUpdateByValue(68, u, 51, 30);
        doMovementUpdateByValue(78, u, 50, 29);
        doMovementUpdateByValue(88, u, 49, 28);
        doMovementUpdateByValue(98, u, 48, 27);
        doDirectionChange(108, 0);
//        doMovementUpdateByValue(118, u, 47, 26);

        //A should not be in freeze range just yet - only 1 moveskip
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 0);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 24);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 58);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 80);
    }

    public void simulateIncorrectPredictedStability() {
        createPredicter(7, 0, 1);
        doStabilityUpdate(23, 18);
        doIdentifyVent(36, 62, u, u);
        doSameTickMovementStabilityUpdate(48, 64, u, u, 15);
        doDirectionChange(53, 6);
        doMovementUpdateByValue(58, 62, u, u);
        doMovementUpdateByValue(68, 60, u, u);
        doStabilityUpdate(73, 16);
        doMovementUpdateByValue(78, 58, u, u);
        doIdentifyVent(82, u, 58, u);
        doMovementUpdateByValue(88, 57, 58, u);
        doMovementUpdateByValue(98, 56, 58, u);
        doMovementUpdateByValue(108, 55, 58, u);
        doMovementUpdateByValue(118, 54, 58, u);
        doMovementUpdateByValue(128, 53, 58, u);
        doMovementUpdateByValue(138, 52, 58, u);
        doMovementUpdateByValue(148, 51, 58, u);
        doEarthquake(158);
        doMovementUpdateByValue(168, 50, 58, u);
        doMovementUpdateByValue(178, 49, 58, u);
        doMovementUpdateByValue(188, 48, 58, u);
        doMovementUpdateByValue(198, 47, 58, u);
        doMovementUpdateByValue(208, 46, 58, u);
        doMovementUpdateByValue(218, 45, 58, u);
        doMovementUpdateByValue(228, 44, 58, u);
        doMovementUpdateByValue(238, 43, 58, u);
        doMovementUpdateByValue(248, 42, 58, u);
        doMovementUpdateByValue(258, 41, 58, u);
        doMovementUpdateByValue(268, 40, 58, u);
        doMovementUpdateByValue(278, 38, 59, u);
        doMovementUpdateByValue(288, 36, 60, u);
        doMovementUpdateByValue(298, 34, 62, u);
        doMovementUpdateByValue(308, 32, 64, u);
        doMovementUpdateByValue(318, 30, 66, u);
        doMovementUpdateByValue(328, 28, 68, u);
        doMovementUpdateByValue(338, 26, 70, u);
        doMovementUpdateByValue(348, 24, 72, u);
        doMovementUpdateByValue(358, 22, 74, u);
        doDirectionChange(360, 7);
        doEarthquake(368);
        //Negative Updates start here
        doMovementUpdateByValue(378, 24, 76, u);
        doMovementUpdateByValue(388, 26, 78, u);
        doMovementUpdateByValue(398, 28, 80, u);
        doMovementUpdateByValue(408, 30, 82, u);
        doMovementUpdateByValue(418, 32, 84, u);
        doMovementUpdateByValue(428, 34, 86, u);

        int predictedUpdate = predicter.getFutureStabilityChange(UltimateVolcanicMineConfig.PredictionScenario.WORST_CASE);
        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 54);
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 54);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 54);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 54);
    }

    public void simulateSize3_5() {
//        createPredicter(0, 0, 5);
//        doStabilityUpdate(24, 14);
//        doIdentifyVent(33, u, 37, u);
//        updateVentDirection(2);
//        doMovementUpdateByValue(39, u, 36, u);
//        doSameTickMovementStabilityUpdate(49, u, 37, u, 9);
//        doIdentifyVent(53, 42, u, u);
//        doEarthquake(54);
//        doMovementUpdateByValue(59, 41, 38, u);
//        doMovementUpdateByValue(69, 40, 39, u);
//        doStabilityUpdate(74, 8);
//        doDirectionChange(78, 3);
//        doMovementUpdateByValue(79, 42, 41, u);
//
//        StatusState predictedState = predicter.getDisplayState();
    }

    public void simulateA4159NotAppear() {
        createPredicter(0, 0, 2);
        doReset();
        doIdentifyVent(15, u, 65, u);
        doMovementUpdateByValue(20, u, 63, u);
        doMovementUpdateByValue(30, u, 61, u);
        doMovementUpdateByValue(40, u, 59, u);
        doMovementUpdateByValue(50, u, 58, u);
        doMovementUpdateByValue(60, u, 57, u);
        doMovementUpdateByValue(70, u, 56, u);
        doDirectionChange(88, 2);
        doMovementUpdateByValue(90, u, 57, u);
        doDirectionChange(93, 0);
        doMovementUpdateByValue(100, u, 56, u);
        doEarthquake(110);
        doMovementUpdateByValue(120, u, 55, u);
        doMovementUpdateByValue(130, u, 54, u);
        doEarthquake(140);
        doMovementUpdateByValue(150, u, 53, u);
        doDirectionChange(186, 2);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 55);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 57);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 55);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 57);
    }

    public void simulateMovementIdentifySameTickNoPredictionBug() {
        createPredicter(3, 0, 1);
        doIdentifyVent(1, u, u, 83);
        doMovementUpdateByValue(7, u, u, 82);
        doMovementUpdateByValue(17, u, 51, 81);
        doStabilityUpdate(22, 9);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertTrue(predictedState.getVents()[0].isRangeDefined());
    }

    public void simulateDoubleToSingleVentPrediction() {
        createPredicter(1, 0, 1);
        doStabilityUpdate(24, 16);
        doIdentifyVent(34, 46, u, u);
        doMovementUpdateByValue(39, 47, u, u);
        doSameTickMovementStabilityUpdate(49, 48, u, u, 17);
        doMovementUpdateByValue(59, 49, u, u);
        doIdentifyVent(65, u, 59, u);
        doMovementUpdateByValue(69, 50, 59, u);
        doStabilityUpdate(74, 17);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 35);
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 37);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 63);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 65);
    }

    public void simulateOverwrittenADoubleVent() {
        createPredicter(6, 0, 1);
        StatusState predictedState = predicter.getDisplayState();

        doMovementUpdateByValue(8, u, 84, u);
        doDirectionChange(9, 4);
        doMovementUpdateByValue(18, u, 83, u);
        doMovementUpdateByValue(28, u, 82, u);
        doMovementUpdateByValue(38, u, 81, u);
        doMovementUpdateByValue(48, u, 79, u);
        doMovementUpdateByValue(58, u, 77, u);
        doMovementUpdateByValue(68, u, 75, u);
        doMovementUpdateByValue(78, u, 73, u);
        doMovementUpdateByValue(88, u, 71, u);
        doMovementUpdateByValue(98, u, 69, u);
        doMovementUpdateByValue(108, u, 67, u);
        doMovementUpdateByValue(118, u, 65, u);
        doDirectionChange(126, 6);
        doMovementUpdateByValue(128, u, 67, u);
        doMovementUpdateByValue(138, u, 69, u);
        doDirectionChange(141, 4);
        doSameTickMovementStabilityUpdate(148, u, 67, u, -5);

        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 18);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 18);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 18);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 18);

    }

    public void simulateDoubleVentCorrectAClipped() {
        //proof we cannot rely on estimated moves!
        createPredicter(6, 0, 2);
        doReset();
        doIdentifyVent(7, u, 59, u);
        doMovementUpdateByValue(9, u, 60, u);
        doMovementUpdateByValue(19, u, 62, u);
        doStabilityUpdate(24, -1);
        doDirectionChange(25, 4);
        doMovementUpdateByValue(29, u, 60, u);
        doMovementUpdateByValue(39, u, 58, u);
        doSameTickMovementStabilityUpdate(49, u, 57, u, 3);
        doMovementUpdateByValue(59, u, 56, u);
        doMovementUpdateByValue(69, u, 55, u);
        doStabilityUpdate(74, 6);
        doMovementUpdateByValue(79, u, 54, u);
        doMovementUpdateByValue(89, u, 53, u);
        doMovementUpdateByValue(99, u, 52, u);
        doMovementUpdateByValue(109, u, 51, u);
        doMovementUpdateByValue(119, u, 50, u);
        doMovementUpdateByValue(129, u, 49, u);
        doDirectionChange(176, 6);
        doMovementUpdateByValue(339, u, 48, u);

        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 38);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 38);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 38);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 38);
    }

    public void simulateDoubleVentTrim() {
        createPredicter(1, 0, 2);
        doReset();
        StatusState predictedState = predicter.getDisplayState();
        doIdentifyVent(2, 75, u, u);
        doMovementUpdateByValue(10, 77, u, u);
        doDirectionChange(6, 0);
        doMovementUpdateByValue(20, 75, u, u);
        doStabilityUpdate(25, -3);
        doMovementUpdateByValue(30, 73, u, u);
        doMovementUpdateByValue(40, 71, u, u);
        doSameTickMovementStabilityUpdate(50, 69, u, u, -5);
        doMovementUpdateByValue(60, 67, u, u);
        doMovementUpdateByValue(70, 65, u, u);
        doStabilityUpdate(74, -6);
        doMovementUpdateByValue(79, 63, u, u);
        doDirectionChange(83, 2);
        doMovementUpdateByValue(89, 61, u, u);
        doSameTickMovementStabilityUpdate(99, 59, u, u, -5);
        //With trimming C was distinguished here - bounds clip as well
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 0);
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 12);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 0);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 12);

        doMovementUpdateByValue(109, 58, u, u);
        doMovementUpdateByValue(119, 57, u, u);
        doStabilityUpdate(124, -5);
        doMovementUpdateByValue(129, 56, u, u);
        doMovementUpdateByValue(139, 55, u, u);
        doSameTickMovementStabilityUpdate(149, 54, u, u, -4);
        doMovementUpdateByValue(159, 53, u, u);
        doMovementUpdateByValue(169, 52, u, u);
        doStabilityUpdate(174, -4);
        //Without trimming C was distinguished here
        doMovementUpdateByValue(179, 51, u, u);
        doMovementUpdateByValue(189, 50, u, u);
        doEarthquake(199);
        doMovementUpdateByValue(209, 49, u, u);
        doMovementUpdateByValue(219, 48, u, u);
        doStabilityUpdate(224, -3);
        //With trimming B was distinguished here - bounds clip as well
        //Without trimming B is never distinguished
        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundStart(), 15);
        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundEnd(), 18);
        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundStart(), 15);
        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundEnd(), 18);
    }

    public void simulateSameTickMoveDirectionChangeBug() {
        createPredicter(1, 0, 2);
        doReset();
        doIdentifyVent(14, u, 48, u);
        doMovementUpdateByValue(20, u, 47, u);
        doDirectionChange(22, 3);
        doMovementUpdateByValue(30, u, 48, u);
        doMovementUpdateByValue(40, u, 49, u);
        doEarthquake(50);
        doMovementUpdateByValue(60, u, 50, u);
        doMovementUpdateByValue(70, u, 51, u);
        doEarthquake(80);
        doDirectionChange(82, 1);
        doMovementUpdateByValue(90, u, 50, u);
        doMovementUpdateByValue(100, u, 49, u);
        doMovementUpdateByValue(110, u, 48, u);
        doDirectionChange(114, 3);
        doMovementUpdateByValue(120, u, 49, u);
        doStabilityUpdate(125, -3);
        doMovementUpdateByValue(130, u, 50, u);
        doMovementUpdateByValue(140, u, 51, u);
        doSameTickMovementStabilityUpdate(150, u, 52, u, -5);
        //same tick direction swap and movement - bug is caused here
        doSameTickMovementDirectionUpdate(160, u, 53, u, 7);
        doMovementUpdateByValue(170, u, 54, u);
        doStabilityUpdate(175, -6);
        doMovementUpdateByValue(180, u, 55, u);
        doMovementUpdateByValue(190, u, 56, u);
        doDirectionChange(196, 5);
        doSameTickMovementStabilityUpdate(200, u, 55, u, -7);
        doDirectionChange(203, 7);
        doMovementUpdateByValue(210, u, 56, u);
        doDirectionChange(211, 5);
        doEarthquake(215);
        doMovementUpdateByValue(220, u, 55, u);
        doStabilityUpdate(225, -8);
        doMovementUpdateByValue(230, u, 54, u);
        doMovementUpdateByValue(240, u, 53, u);
        doSameTickMovementStabilityUpdate(250, u, 52, u, -6);

        //Answer is precisely 9
        StatusState predictedState = predicter.getDisplayState();
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 9);
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 9);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 9);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 9);
    }

    public void simulateIncorrectPostResetDoubleVentC() {
        createPredicter(1, 0, 2);
        doReset();
        StatusState predictedState = predicter.getDisplayState();
        doIdentifyVent(6, u, u, 30);
        doMovementUpdateByValue(10, u, u, 28);
        doDirectionChange(16, 5);
        doMovementUpdateByValue(20, u, u, 30);
        doStabilityUpdate(25, 3);
        doMovementUpdateByValue(30, u, u, 32);
        doMovementUpdateByValue(40, u, u, 34);
        doSameTickMovementStabilityUpdate(50, u, u, 36, 4);
        doMovementUpdateByValue(60, u, u, 38);
        doMovementUpdateByValue(70, u, u, 39);
        doStabilityUpdate(75, 5);
        doEarthquake(80);
        doMovementUpdateByValue(90, u, u, 40);
        doSameTickMovementStabilityUpdate(100, u, u, 41, 5);
        doStabilityUpdate(125, 4);
        doStabilityUpdate(150, 5);
        doStabilityUpdate(175, 5);
        //Incorrect clipping here for some reason
        doStabilityUpdate(200, 4);
        doStabilityUpdate(225, 4);
        doDirectionChange(226, 7);
        //Bug could be here
        doEarthquake(230);
        doDirectionChange(231, 5);
        doStabilityUpdate(250, 3);
        doStabilityUpdate(275, 2);
        doMovementUpdateByValue(280, u, u, 42);

        //B was in fact 38% (identified last minute)
        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundStart(), 0);
        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundEnd(), 4);
        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundStart(), 38);
        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundEnd(), 38);
    }

    public void simulate2ndIncorrectPostResetDoubleVentC() {
        createPredicter(1, 0, 2);
        doReset();
        StatusState predictedState = predicter.getDisplayState();
        doIdentifyVent(2, u, u, 11);
        doMovementUpdateByValue(9, u, u, 9);
        doDirectionChange(13, 5);
        doMovementUpdateByValue(19, u, u, 11);
        doStabilityUpdate(24, -9);
        doMovementUpdateByValue(29, u, u, 13);
        doMovementUpdateByValue(39, u, u, 15);
        doSameTickMovementStabilityUpdate(49, u, u, 17, -11);
        doMovementUpdateByValue(59, u, u, 19);
        doDirectionChange(67, 7);
        doMovementUpdateByValue(69, u, u, 21);
        doStabilityUpdate(74, -10);
        doMovementUpdateByValue(79, u, u, 23);
        doMovementUpdateByValue(89, u, u, 25);
        doEarthquake(94);
        doSameTickMovementStabilityUpdate(99, u, u, 27, -9);
        doMovementUpdateByValue(109, u, u, 29);
        doMovementUpdateByValue(119, u, u, 31);
        doStabilityUpdate(124, -8);
        doMovementUpdateByValue(129, u, u, 33);
        doMovementUpdateByValue(139, u, u, 35);
        doSameTickMovementStabilityUpdate(149, u, u, 37, -4);
        doMovementUpdateByValue(159, u, u, 39);
        doMovementUpdateByValue(169, u, u, 41);
        doStabilityUpdate(174, -1);
        doMovementUpdateByValue(179, u, u, 42);
        doMovementUpdateByValue(189, u, u, 43);
        doSameTickMovementStabilityUpdate(199, u, u, 44, 2);
        doMovementUpdateByValue(209, u, u, 45);
        doMovementUpdateByValue(219, u, u, 46);
        doStabilityUpdate(224, 4);
        doStabilityUpdate(249, 5);
        doStabilityUpdate(274, 5);
        doStabilityUpdate(299, 6);
        doStabilityUpdate(324, 6);
        doStabilityUpdate(349, 6);
        doStabilityUpdate(374, 5);
        doStabilityUpdate(399, 4);
        doStabilityUpdate(424, 3);
        doMovementUpdateByValue(429, u, u, 47);

        //B is in fact 62%
        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundStart(), 62);
        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundEnd(), 62);
        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundStart(), 62);
        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundEnd(), 62);
    }

    public void simulateLostRangesAtGameStart() {
        createPredicter(3, 0, 1);
        doStabilityUpdate(23, 14);
        doIdentifyVent(42, u, u, 29);

        //Ranges shouldn't be cleared due to a blank stability update
        StatusState predictedState = predicter.getDisplayState();
        Assert.assertTrue(predictedState.getVents()[0].isRangeDefined());
        Assert.assertTrue(predictedState.getVents()[1].isRangeDefined());
        Assert.assertTrue(predictedState.getVents()[2].isRangeDefined());

        doSameTickMovementStabilityUpdate(48, u, u, 28, 9);
        doMovementUpdateByValue(58, u, u, 27);
        doDirectionChange(65, 7);
        doMovementUpdateByValue(68, u, u, 29);
        doStabilityUpdate(73, 8);
        doMovementUpdateByValue(78, u, u, 31);
        doMovementUpdateByValue(88, u, u, 33);
    }

    public void simulatePrematureAFreezeClipPostReset() {
        createPredicter(6, 0, 1);
        doReset();
        StatusState predictedState = predicter.getDisplayState();
        doEarthquake(4);
        doIdentifyVent(9, u, 32, u);
        doMovementUpdateByValue(19, u, 34, u);
        doMovementUpdateByValue(29, u, 36, u);
        doMovementUpdateByValue(39, u, 38, u);
        doMovementUpdateByValue(49, u, 40, u);
        doMovementUpdateByValue(59, u, 42, u);
        doMovementUpdateByValue(69, u, 43, u);
        doMovementUpdateByValue(259, u, 44, u);

        //A is in fact 38%
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 38);
        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 38);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 38);
        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 38);
    }

    public void simulateIncorrectEstimatedMoveFreezeClip() {
        createPredicter(0, 0, 1);
        doReset();
        StatusState predictedState = predicter.getDisplayState();

        doIdentifyVent(1, u, u, 56);
        doIdentifyVent(14, u, 42, 56);
        doMovementUpdateByValue(29, u, 41, 56);

        //Value should not get freeze clipped here
        Assert.assertFalse(predictedState.getVents()[0].isFreezeClipAccurate());

        doDirectionChange(33, 2);
        doMovementUpdateByValue(39, u, 42, 56);
        doMovementUpdateByValue(49, u, 43, 56);
        doMovementUpdateByValue(59, u, 44, 56);
        doMovementUpdateByValue(69, u, 45, 56);
        doMovementUpdateByValue(89, u, 46, 56);
        doEarthquake(114);
        doMovementUpdateByValue(279, u, 47, 56);

        //Value should get freeze clipped here
        Assert.assertTrue(predictedState.getVents()[0].isFreezeClipAccurate());
    }


    //Abandoned half-space tests
    public void simulateIncorrectHalfSpaceClipping() {
        createPredicter(5, 0, 1);
        doIdentifyVent(3, 63, u, u);
        doMovementUpdateByValue(9, 65, u, u);
        doDirectionChange(18,4);
        doStabilityUpdate(24, -9);
        doMovementUpdateByValue(29, 63, u, u);
        doMovementUpdateByValue(39, 61, u, u);
        doSameTickMovementStabilityUpdate(49, 59, u, u, -6);
        doMovementUpdateByValue(59, 58, u, u);
        doMovementUpdateByValue(69, 57, u, u);
        doStabilityUpdate(74, -5);

//        //Half space clipping should not occur here
        StatusState predictedState = predicter.getDisplayState();
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundEnd(), 4);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundStart(), 83);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundEnd(), 92);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 8);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 17);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 96);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 100);
    }

    public void simulate0ToNegativeHalfSpace() {
//        createPredicter(1, 0, 1);
//        doStabilityUpdate(24, 19);
//        doIdentifyVent(34, 46, u, u);
//        doMovementUpdateByValue(39, 47, u, u);
//        doSameTickMovementStabilityUpdate(49, 48, u, u, 19);
//        doIdentifyVent(55, u, 43, u);
//        doMovementUpdateByValue(59, 49, 43, u);
//
//        //Post reset
//        doReset();
//        doIdentifyVent(502, 64, u, u);
//        doMovementUpdateByValue(506, 62, u, u);
//        doMovementUpdateByValue(516, 60, u, u);
//        doMovementUpdateByValue(526, 58, u, u);
//        doMovementUpdateByValue(536, 57, u, u);
//        doMovementUpdateByValue(546, 56, u, u);
//        doMovementUpdateByValue(556, 55, u, u);
//        doMovementUpdateByValue(566, 54, u, u);
//        doStabilityUpdate(571, -2);
//        doEarthquake(576);
//        doMovementUpdateByValue(586, 53, u, u);
//        doMovementUpdateByValue(596, 52, u, u);
//
//        StatusState predictedState = predicter.getDisplayState();
    }
}

package com.ultimatevm;

import org.testng.annotations.Test;
import org.testng.Assert;

@Test()
public class StabilityUpdateInfoTest {

    public void constructorTest() {
        StatusState state = new StatusState();
        int u = VentStatus.STARTING_VENT_VALUE;
        state.updateVentStatus(new int[]{50, 50, u}, 20);
        StabilityUpdateInfo stabInfo = new StabilityUpdateInfo(state, 0, 20);

        Assert.assertFalse(stabInfo.isVerified());
        Assert.assertNotEquals(stabInfo.getStabilityUpdateState(), state);
        Assert.assertEquals(stabInfo.getRNGUpdateMod(), 0);
        Assert.assertEquals(stabInfo.getTickTimeStamp(), 0);
        Assert.assertEquals(stabInfo.getInitialChange(), 20);
        //State should have a calculated stability
        Assert.assertTrue(stabInfo.getStabilityUpdateState().getVents()[2].isRangeDefined());
    }

    public void verifyByInvalidPointsTest() {
        StatusState state = new StatusState();
        int u = VentStatus.STARTING_VENT_VALUE;
        state.updateVentStatus(new int[]{50, 50, u}, 0);
        StabilityUpdateInfo stabInfo = new StabilityUpdateInfo(state, 0, 24);
        stabInfo.verifyByInvalidPoints();

        Assert.assertEquals(stabInfo.getRNGUpdateMod(), 1);
        Assert.assertTrue(stabInfo.isVerified());
    }

    public void getAllPossiblePredictedValuesStateTest() {
        StatusState state = new StatusState();
        int u = VentStatus.STARTING_VENT_VALUE;
        state.updateVentStatus(new int[]{50, 50, u}, 0);

        //One huge range should be set here
        StabilityUpdateInfo stabInfo = new StabilityUpdateInfo(state, 0, 23);
        StatusState possibleValues = stabInfo.getAllPossiblePredictedValuesState();

        Assert.assertEquals(possibleValues.getVents()[2].getLowerBoundStart(), 44);
        Assert.assertEquals(possibleValues.getVents()[2].getUpperBoundStart(), 44);
        Assert.assertEquals(possibleValues.getVents()[2].getLowerBoundEnd(), 56);
        Assert.assertEquals(possibleValues.getVents()[2].getUpperBoundEnd(), 56);


        //Two huge ranges should be set here
        stabInfo = new StabilityUpdateInfo(state, 0, 22);
        possibleValues = stabInfo.getAllPossiblePredictedValuesState();

        Assert.assertEquals(possibleValues.getVents()[2].getLowerBoundStart(), 41);
        Assert.assertEquals(possibleValues.getVents()[2].getLowerBoundEnd(), 46);
        Assert.assertEquals(possibleValues.getVents()[2].getUpperBoundStart(), 54);
        Assert.assertEquals(possibleValues.getVents()[2].getUpperBoundEnd(), 59);
    }
}

package com.ultimatevm;

import org.testng.annotations.Test;
import org.testng.Assert;

@Test()
public class StatusStateTest {
    private final int u = VentStatus.STARTING_VENT_VALUE;
    private int makeMoveBitState(int aMove, int bMove, int cMove) {
        return aMove | (bMove << 2) | (cMove << 4);
    }

    public void constructorTest() {
        StatusState state = new StatusState();
        for(int i = 0; i < StatusState.NUM_VENTS; ++i)
            Assert.assertNotNull(state.getVents()[i]);
        Assert.assertEquals(state.getNumIdentifiedVents(), 0);
        Assert.assertFalse(state.isAllVentsIdentified());
        Assert.assertFalse(state.isEnoughVentsIdentified());
        Assert.assertFalse(state.hasDoneVMReset());
    }

    public void copyConstructorTest() {
        StatusState originalState = new StatusState();
        originalState.doVMReset();
        originalState.updateVentStatus(new int[]{0,0,0},0);
        StatusState state = new StatusState(originalState);

        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertNotNull(state.getVents()[i]);
            Assert.assertEquals(state.getVents()[i].getActualValue(), 0);
        }
        Assert.assertEquals(state.getNumIdentifiedVents(), 3);
        Assert.assertTrue(state.isAllVentsIdentified());
        Assert.assertTrue(state.isEnoughVentsIdentified());
        Assert.assertTrue(state.hasDoneVMReset());
    }

    public void setVentsEqualToTest() {
        StatusState originalState = new StatusState();
        originalState.updateVentStatus(new int[]{0,0,0},0);
        StatusState state = new StatusState();
        state.setVentsEqualTo(originalState);
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertEquals(state.getVents()[i].getActualValue(), 0);
        }
        Assert.assertEquals(state.getNumIdentifiedVents(), 3);
        Assert.assertTrue(state.isAllVentsIdentified());
        Assert.assertTrue(state.isEnoughVentsIdentified());
    }

    public void setEqualToTest() {
        StatusState state = new StatusState();
        StatusState originalState = new StatusState();
        originalState.doVMReset();
        originalState.updateVentStatus(new int[]{0,0,0},0);
        state.setEqualTo(originalState);

        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertNotNull(state.getVents()[i]);
            Assert.assertEquals(state.getVents()[i].getActualValue(), 0);
        }
        Assert.assertEquals(state.getNumIdentifiedVents(), 3);
        Assert.assertTrue(state.isAllVentsIdentified());
        Assert.assertTrue(state.isEnoughVentsIdentified());
        Assert.assertTrue(state.hasDoneVMReset());
    }

    public void updateVentStatusTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();
        //Ensure our vents are set properly
        int[] changeStates = state.updateVentStatus(new int[]{50,50,50}, 7);
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertEquals(vents[i].getActualValue(), 50);
            Assert.assertEquals(vents[i].getDirection(), 1);
            Assert.assertEquals(changeStates[i], VentStatus.VentChangeStateFlag.IDENTIFIED.bitFlag());
        }
        changeStates = state.updateVentStatus(new int[]{49,49,49}, 0);
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertEquals(vents[i].getActualValue(), 49);
            Assert.assertEquals(vents[i].getDirection(), -1);
            Assert.assertEquals(changeStates[i],
                    VentStatus.VentChangeStateFlag.ONE_CHANGE.bitFlag() + VentStatus.VentChangeStateFlag.DIRECTION_CHANGE.bitFlag());
        }
    }

    public void updateVentMovementTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();
        state.updateVentStatus(new int[]{u, u, u}, 7);

        vents[0].clearRanges();
        vents[0].setUpperBoundRange(50, 50);
        vents[0].setLowerBoundRange(50, 50);

        state.updateVentMovement();
        Assert.assertEquals(vents[0].getLowerBoundStart(), 51);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 51);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 51);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 51);
    }

    public void updateVentMovementAInfluenceTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();
        state.updateVentStatus(new int[]{u, 50, 50}, 7);

        //A never freezes
        //Movement by 1 since 41-59% range
        vents[0].clearRanges();
        vents[0].setLowerBoundRange(41, 59);
        vents[0].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[0].getLowerBoundStart(), 42);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 42);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 60);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 60);

        //Movement by 2 since outside of 41-59% range
        vents[0].clearRanges();
        vents[0].setLowerBoundRange(0, 40);
        vents[0].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[0].getLowerBoundStart(), 2);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 42);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 62);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 100);
    }

    public void updateVentMovementBInfluenceTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();

        //B is only influenced by A
        //Unidentified A influence (possible 0, -1 movement inf)
        state.updateVentStatus(new int[]{u, u, 50}, 7);
        //Movement by 0 and 1 since A is unknown and B is 41-59% range
        vents[1].clearRanges();
        vents[1].setLowerBoundRange(41, 59);
        vents[1].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[1].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 60);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 60);

        //Movement by 1 and 2 since A is unknown and B is outside of 41-59% range
        vents[1].clearRanges();
        vents[1].setLowerBoundRange(0, 40);
        vents[1].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[1].getLowerBoundStart(), 1);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 42);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 61);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 100);


        //A 41-59% range influence (possible -1 movement inf)
        state.updateVentStatus(new int[]{50, u, 50}, 7);
        //Movement by 0 since A and B are 41-59% range
        vents[1].clearRanges();
        vents[1].setLowerBoundRange(41, 59);
        vents[1].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[1].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 59);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 59);

        //Movement by 1 since A is 41-59% and B is outside of 41-59% range
        vents[1].clearRanges();
        vents[1].setLowerBoundRange(0, 40);
        vents[1].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[1].getLowerBoundStart(), 1);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 41);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 61);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 100);


        //Zero A influence (outside 41-59%) (possible 0 movement inf)
        state.updateVentStatus(new int[]{0, u, 50}, 7);
        //Movement by 1 since A is not 41-59% but B is 41-59% range
        vents[1].clearRanges();
        vents[1].setLowerBoundRange(41, 59);
        vents[1].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[1].getLowerBoundStart(), 42);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 42);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 60);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 60);

        //Movement by 2 since A and B are outside of 41-59% range
        vents[1].clearRanges();
        vents[1].setLowerBoundRange(0, 40);
        vents[1].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[1].getLowerBoundStart(), 2);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 42);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 62);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 100);
    }

    public void updateVentMovementCInfluenceTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();

        //C is influenced by both A and B
        //Unidentified A and B influence (possible 0, -2 movement inf)
        state.updateVentStatus(new int[]{u, u, u}, 7);

        //Movement by 0 and 1 since A and B are unknown
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 60);

        //Movement by 0 and 2 since A and B are unknown;
        //C is also outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 98);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 42);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);


        //Unidentified A and 41-59% B influence (possible -1, -2 movement inf)
        state.updateVentStatus(new int[]{u, 50, u}, 7);

        //Movement by 0 since A is unknown and B is 41-59%
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 59);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 59);

        //Movement by 0 and 1 since A is unknown and B is 41-59%;
        //doesnt matter C is outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);


        //Unidentified A and outside 41-59% B influence (possible 0, -1 movement inf)
        state.updateVentStatus(new int[]{u, 0, u}, 7);

        //Movement by 0 and 1 since A is unknown and C is 41-59%;
        //B is outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 60);

        //Movement by 1 and 2 since A is unknown;
        //B and C are outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 98);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 1);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 42);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 61);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);




        //41-59% A and unidentified B influence (possible -1, -2 movement inf)
        state.updateVentStatus(new int[]{50, u, u}, 7);
        vents[1].clearRanges();

        //Movement by 0 since A is 41-59% and B is unknown
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 59);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 59);

        //Movement by 0 and 1 since A and B are unknown;
        //C is outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);


        //41-59% A and B influence (possible -2 movement inf)
        state.updateVentStatus(new int[]{50, 50, u}, 7);

        //Movement by 0 since A and B are 41-59%
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 59);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 59);

        //Movement by 0 since A and B are 41-59%;
        //doesnt matter C is outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 40);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 99);


        //41-59% A and outside 41-59% B influence (possible -1 movement inf)
        state.updateVentStatus(new int[]{50, 0, u}, 7);

        //Movement by 0 since A and C are 41-59%;
        //doesnt matter B is outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 59);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 59);

        //Movement by 1 since B and C are outside of 41-59% range;
        //because A is 41-59%
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 1);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 61);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);




        //Outside 41-59% A and unidentified B influence (possible 0, -1 movement inf)
        state.updateVentStatus(new int[]{0, u, u}, 7);
        vents[1].clearRanges();

        //Movement by 0 and 1 since B is unknown and C is 41-59%
        //even though A is outside of 41-59%
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 60);

        //Movement by 1 and 2  since B is unknown;
        //both A and C are outside of 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 98);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 1);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 42);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 61);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);


        //Outside 41-59% A and 41-59% B influence (possible -1 movement inf)
        state.updateVentStatus(new int[]{0, 50, u}, 7);

        //Movement by 0 since B and C are 41-59%
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 41);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 59);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 59);

        //Movement by 1 since A and C are outside 41-59%;
        //B is 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 1);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 41);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 61);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);


        //41-59% A and outside 41-59% B influence (possible 0 movement inf)
        state.updateVentStatus(new int[]{0, 0, u}, 7);

        //Movement by 1 since A and B are outside 41-59%;
        //C is 41-59% range
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(41, 59);
        vents[2].setUpperBoundRange(41, 59);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 42);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 42);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 60);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 60);

        //Movement by 2 since all vents are outside of 41-59% range;
        vents[2].clearRanges();
        vents[2].setLowerBoundRange(0, 40);
        vents[2].setUpperBoundRange(60, 99);
        state.updateVentMovement();
        Assert.assertEquals(vents[2].getLowerBoundStart(), 2);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 42);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 62);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);
    }

    public void doVMResetTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();
        state.updateVentStatus(new int[]{0,0,0}, 7);
        state.doVMReset();
        //All values should be clear
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertEquals(vents[i].getActualValue(), VentStatus.STARTING_VENT_VALUE);
        }
        Assert.assertTrue(state.hasDoneVMReset());
        //Should fail if called a second time
        state.updateVentStatus(new int[]{0,0,0}, 7);
        state.doVMReset();
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertEquals(vents[i].getActualValue(), 0);
        }
        Assert.assertTrue(state.hasDoneVMReset());
    }

    public void getUnidentifiedVentIndicesTest() {
        StatusState state = new StatusState();
        //All
        state.updateVentStatus(new int[]{u,u,u}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{0,1,2});
        //Two
        state.updateVentStatus(new int[]{0,u,u}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{1,2});
        state.updateVentStatus(new int[]{u,0,u}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{0,2});
        state.updateVentStatus(new int[]{u,u,0}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{0,1});
        //One
        state.updateVentStatus(new int[]{u,0,0}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{0});
        state.updateVentStatus(new int[]{0,u,0}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{1});
        state.updateVentStatus(new int[]{0,0,u}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{2});
        //None
        state.updateVentStatus(new int[]{0,0,0}, 7);
        Assert.assertEquals(state.getUnidentifiedVentIndices(), new int[]{});
    }

    public void calcPredictedVentValuesTest() {
        StatusState state = new StatusState();
        //All vents are identifed should only update stability change
        state.updateVentStatus(new int[]{0, 51, 51}, 7);
        state.calcPredictedVentValues(25);
        Assert.assertEquals(state.getStabilityChange(), 25);
        final VentStatus[] vents = state.getVents();
        Assert.assertTrue(vents[0].isRangeDefined());
        Assert.assertEquals(vents[0].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 0);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 0);

        //No vents are identifed should only update stability change
        state = new StatusState();
        state.updateVentStatus(new int[]{u, u, u}, 7);
        state.calcPredictedVentValues(25);
        Assert.assertEquals(state.getStabilityChange(), 25);
        final VentStatus[] vents2 = state.getVents();
        for(int i = 0; i < vents2.length; ++i) {
            Assert.assertEquals(vents2[i].getLowerBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
            Assert.assertEquals(vents2[i].getLowerBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);
            Assert.assertEquals(vents2[i].getUpperBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
            Assert.assertEquals(vents2[i].getUpperBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);
        }
    }

    public void calcSingleVentValueTest() {
        //Max calc test
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 50, 50}, 7);
        Assert.assertTrue(state.calcPredictedVentValues(23));
        Assert.assertEquals(state.getStabilityChange(), 23);
        final VentStatus[] vents = state.getVents();
        Assert.assertTrue(vents[0].isRangeDefined());
        Assert.assertEquals(vents[0].getLowerBoundStart(), 47);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 53);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 47);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 53);

        //Normal calc test
        Assert.assertTrue(state.calcPredictedVentValues(22));
        Assert.assertEquals(state.getStabilityChange(), 22);
        Assert.assertEquals(vents[0].getLowerBoundStart(), 44);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 46);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 54);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 56);

        //Min calc test
        Assert.assertTrue(state.calcPredictedVentValues(7));
        Assert.assertEquals(state.getStabilityChange(), 7);
        Assert.assertEquals(vents[0].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 0);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 100);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 100);
    }

    public void calcSingleVentValueInvalidTest() {
        //Max calc test
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u, 50, 50}, 7);
        state.clearAllRanges();
        Assert.assertFalse(state.calcPredictedVentValues(24));
        final VentStatus[] vents = state.getVents();
        Assert.assertEquals(vents[0].getLowerBoundStart(), u);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), u);
        Assert.assertEquals(vents[0].getUpperBoundStart(), u);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), u);

        //Min calc test
        state.updateVentStatus(new int[]{u, 0, 0}, 7);
        state.clearAllRanges();
        Assert.assertFalse(state.calcPredictedVentValues(-27));
        Assert.assertEquals(vents[0].getLowerBoundStart(), u);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), u);
        Assert.assertEquals(vents[0].getUpperBoundStart(), u);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), u);
    }

    public void calcDoubleVentValueTest() {
        //Max calc test
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u, 50, u}, 7);
        final VentStatus[] vents = state.getVents();
        Assert.assertTrue(state.calcPredictedVentValues(23));
        Assert.assertEquals(state.getStabilityChange(), 23);
        Assert.assertEquals(vents[0].getLowerBoundStart(), 47);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 53);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 47);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 53);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 47);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 53);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 47);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 53);

        //Max calc test - increased range size
        state.updateVentStatus(new int[]{u, 50, u}, 7);
        final VentStatus[] vents2 = state.getVents();
        Assert.assertTrue(state.calcPredictedVentValues(22));
        Assert.assertEquals(state.getStabilityChange(), 22);
        Assert.assertEquals(vents2[0].getLowerBoundStart(), 44);
        Assert.assertEquals(vents2[0].getLowerBoundEnd(), 56);
        Assert.assertEquals(vents2[0].getUpperBoundStart(), 44);
        Assert.assertEquals(vents2[0].getUpperBoundEnd(), 56);
        Assert.assertEquals(vents2[2].getLowerBoundStart(), 44);
        Assert.assertEquals(vents2[2].getLowerBoundEnd(), 56);
        Assert.assertEquals(vents2[2].getUpperBoundStart(), 44);
        Assert.assertEquals(vents2[2].getUpperBoundEnd(), 56);

        //Double range test
        state.updateVentStatus(new int[]{u, 50, u}, 7);
        final VentStatus[] vents3 = state.getVents();
        Assert.assertTrue(state.calcPredictedVentValues(6));
        Assert.assertEquals(state.getStabilityChange(), 6);
        Assert.assertEquals(vents3[0].getLowerBoundStart(), 0);
        Assert.assertEquals(vents3[0].getLowerBoundEnd(), 46);
        Assert.assertEquals(vents3[0].getUpperBoundStart(), 54);
        Assert.assertEquals(vents3[0].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents3[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents3[2].getLowerBoundEnd(), 46);
        Assert.assertEquals(vents3[2].getUpperBoundStart(), 54);
        Assert.assertEquals(vents3[2].getUpperBoundEnd(), 100);

        //Min calc test
        state.updateVentStatus(new int[]{u, 50, u}, 7);
        final VentStatus[] vents4 = state.getVents();
        Assert.assertTrue(state.calcPredictedVentValues(-9));
        Assert.assertEquals(state.getStabilityChange(), -9);
        Assert.assertEquals(vents4[0].getLowerBoundStart(), 0);
        Assert.assertEquals(vents4[0].getLowerBoundEnd(), 0);
        Assert.assertEquals(vents4[0].getUpperBoundStart(), 100);
        Assert.assertEquals(vents4[0].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents4[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents4[2].getLowerBoundEnd(), 0);
        Assert.assertEquals(vents4[2].getUpperBoundStart(), 100);
        Assert.assertEquals(vents4[2].getUpperBoundEnd(), 100);
    }

    public void calcDoubleVentValueInvalidTest() {
        //Max calc test
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u, 50, u}, 7);
        final VentStatus[] vents = state.getVents();
        state.clearAllRanges();
        Assert.assertFalse(state.calcPredictedVentValues(24));
        Assert.assertEquals(vents[0].getLowerBoundStart(), u);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), u);
        Assert.assertEquals(vents[0].getUpperBoundStart(), u);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), u);
        Assert.assertEquals(vents[2].getLowerBoundStart(), u);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), u);
        Assert.assertEquals(vents[2].getUpperBoundStart(), u);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), u);

        //Min calc test
        state.updateVentStatus(new int[]{u, 0, u}, 7);
        final VentStatus[] vents2 = state.getVents();
        state.clearAllRanges();
        Assert.assertFalse(state.calcPredictedVentValues(-27));
        Assert.assertEquals(vents2[0].getLowerBoundStart(), u);
        Assert.assertEquals(vents2[0].getLowerBoundEnd(), u);
        Assert.assertEquals(vents2[0].getUpperBoundStart(), u);
        Assert.assertEquals(vents2[0].getUpperBoundEnd(), u);
        Assert.assertEquals(vents2[2].getLowerBoundStart(), u);
        Assert.assertEquals(vents2[2].getLowerBoundEnd(), u);
        Assert.assertEquals(vents2[2].getUpperBoundStart(), u);
        Assert.assertEquals(vents2[2].getUpperBoundEnd(), u);
    }

    public void mergePredictedRangesWithTest() {
        StatusState state = new StatusState();
        StatusState toMerge = new StatusState();
        toMerge.updateVentStatus(new int[]{50, 50, u}, 7);
        toMerge.getVents()[2].clearRanges();
        toMerge.getVents()[2].setLowerBoundRange(41, 59);
        toMerge.getVents()[2].setUpperBoundRange(41, 59);

        //When we have no range defined to take the other states range
        state.updateVentStatus(new int[]{50, 50, u}, 7);
        state.getVents()[2].clearRanges();
        state.mergePredictedRangesWith(toMerge);
        Assert.assertEquals(state.getVents()[2].getLowerBoundStart(), 41);
        Assert.assertEquals(state.getVents()[2].getLowerBoundEnd(), 59);
        Assert.assertEquals(state.getVents()[2].getUpperBoundStart(), 41);
        Assert.assertEquals(state.getVents()[2].getUpperBoundEnd(), 59);

        //Ensure ranges merge correctly
        state.updateVentStatus(new int[]{50, 50, u}, 7);
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(30, 40);
        state.getVents()[2].setUpperBoundRange(60, 70);
        state.mergePredictedRangesWith(toMerge);
        Assert.assertEquals(state.getVents()[2].getLowerBoundStart(), 30);
        Assert.assertEquals(state.getVents()[2].getLowerBoundEnd(), 70);
        Assert.assertEquals(state.getVents()[2].getUpperBoundStart(), 30);
        Assert.assertEquals(state.getVents()[2].getUpperBoundEnd(), 70);
    }

    public void mergePredictedRangesWithInvalidTest() {
        StatusState state = new StatusState();
        StatusState toMerge = new StatusState();
        toMerge.updateVentStatus(new int[]{50, 50, u}, 7);
        toMerge.getVents()[2].setLowerBoundRange(41, 59);
        toMerge.getVents()[2].setUpperBoundRange(41, 59);

        //All vents identified nothing to merge
        state.updateVentStatus(new int[]{50, 50, 50}, 7);
        state.mergePredictedRangesWith(toMerge);
        Assert.assertEquals(state.getVents()[2].getLowerBoundStart(), 50);
        Assert.assertEquals(state.getVents()[2].getLowerBoundEnd(), 50);
        Assert.assertEquals(state.getVents()[2].getUpperBoundStart(), 50);
        Assert.assertEquals(state.getVents()[2].getUpperBoundEnd(), 50);

        //Undefined ranges to merge means nothing to merge
        state.updateVentStatus(new int[]{50, 50, u}, 7);
        state.getVents()[2].setLowerBoundRange(47, 53);
        state.getVents()[2].setUpperBoundRange(47, 53);
        toMerge.getVents()[2].clearRanges();
        state.mergePredictedRangesWith(toMerge);
        Assert.assertEquals(state.getVents()[2].getLowerBoundStart(), 47);
        Assert.assertEquals(state.getVents()[2].getLowerBoundEnd(), 53);
        Assert.assertEquals(state.getVents()[2].getUpperBoundStart(), 47);
        Assert.assertEquals(state.getVents()[2].getUpperBoundEnd(), 53);
    }

    public void setOverlappingRangesWithTest() {
        StatusState state = new StatusState();
        final VentStatus vent = state.getVents()[2];
        StatusState toOverlap = new StatusState();
        toOverlap.updateVentStatus(new int[]{50, 50, u}, 7);
        toOverlap.getVents()[2].clearRanges();
        toOverlap.getVents()[2].setLowerBoundRange(41, 46);
        toOverlap.getVents()[2].setUpperBoundRange(54, 59);

        //Both ranges overlap
        vent.clearRanges();
        vent.setLowerBoundRange(38, 44);
        vent.setUpperBoundRange(56, 62);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundStart(), 56);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);

        //Only lower bound overlaps
        vent.setLowerBoundRange(38, 44);
        vent.setUpperBoundRange(62, 65);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundStart(), 41);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Only upper bound overlaps
        vent.setLowerBoundRange(35, 38);
        vent.setUpperBoundRange(56, 62);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 56);
        Assert.assertEquals(vent.getLowerBoundEnd(), 59);
        Assert.assertEquals(vent.getUpperBoundStart(), 56);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);

        //Neither range overlap
        vent.setLowerBoundRange(35, 38);
        vent.setUpperBoundRange(62, 65);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), u);
        Assert.assertEquals(vent.getLowerBoundEnd(), u);
        Assert.assertEquals(vent.getUpperBoundStart(), u);
        Assert.assertEquals(vent.getUpperBoundEnd(), u);

    }

    public void setOverlappingRangesWithInvalidTest() {
        StatusState state = new StatusState();
        StatusState toOverlap = new StatusState();
        toOverlap.updateVentStatus(new int[]{50, 50, u}, 7);
        toOverlap.getVents()[2].setLowerBoundRange(41, 59);
        toOverlap.getVents()[2].setUpperBoundRange(41, 59);

        //All vents identified no overlapping should be done
        state.updateVentStatus(new int[]{50, 50, 50}, 7);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(state.getVents()[2].getLowerBoundStart(), 50);
        Assert.assertEquals(state.getVents()[2].getLowerBoundEnd(), 50);
        Assert.assertEquals(state.getVents()[2].getUpperBoundStart(), 50);
        Assert.assertEquals(state.getVents()[2].getUpperBoundEnd(), 50);

        //When we have no range defined to take the other states range
        state.updateVentStatus(new int[]{50, 50, u}, 7);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(state.getVents()[2].getLowerBoundStart(), u);
        Assert.assertEquals(state.getVents()[2].getLowerBoundEnd(), u);
        Assert.assertEquals(state.getVents()[2].getUpperBoundStart(), u);
        Assert.assertEquals(state.getVents()[2].getUpperBoundEnd(), u);

        //Undefined ranges to merge means our range gets cleared
        state.updateVentStatus(new int[]{50, 50, u}, 7);
        state.getVents()[2].setLowerBoundRange(47, 53);
        state.getVents()[2].setUpperBoundRange(47, 53);
        toOverlap.getVents()[2].clearRanges();
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(state.getVents()[2].getLowerBoundStart(), u);
        Assert.assertEquals(state.getVents()[2].getLowerBoundEnd(), u);
        Assert.assertEquals(state.getVents()[2].getUpperBoundStart(), u);
        Assert.assertEquals(state.getVents()[2].getUpperBoundEnd(), u);
    }

    public void setOverlappingRangesWithRangeMismatchTest() {
        StatusState state = new StatusState();
        final VentStatus vent = state.getVents()[2];
        StatusState toOverlap = new StatusState();
        toOverlap.updateVentStatus(new int[]{46, 0, u}, 7);
        toOverlap.getVents()[2].setLowerBoundRange(22, 28);
        toOverlap.getVents()[2].setUpperBoundRange(72, 78);

        //Lower upper range overlap
        vent.setLowerBoundRange(59, 75);
        vent.setUpperBoundRange(91, 95);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 72);
        Assert.assertEquals(vent.getLowerBoundEnd(), 75);
        Assert.assertEquals(vent.getUpperBoundStart(), 72);
        Assert.assertEquals(vent.getUpperBoundEnd(), 75);

        //Lower both range overlap
        toOverlap.getVents()[2].clearRanges();
        toOverlap.getVents()[2].setLowerBoundRange(72, 78);
        toOverlap.getVents()[2].setUpperBoundRange(72, 78);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 72);
        Assert.assertEquals(vent.getLowerBoundEnd(), 75);
        Assert.assertEquals(vent.getUpperBoundStart(), 72);
        Assert.assertEquals(vent.getUpperBoundEnd(), 75);

        //Upper lower range overlap
        toOverlap.getVents()[2].clearRanges();
        toOverlap.getVents()[2].setLowerBoundRange(52, 58);
        toOverlap.getVents()[2].setUpperBoundRange(100, 100);
        vent.clearRanges();
        vent.setLowerBoundRange(9, 25);
        vent.setUpperBoundRange(51, 55);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 52);
        Assert.assertEquals(vent.getLowerBoundEnd(), 55);
        Assert.assertEquals(vent.getUpperBoundStart(), 52);
        Assert.assertEquals(vent.getUpperBoundEnd(), 55);

        //Upper both range overlap
        toOverlap.getVents()[2].clearRanges();
        toOverlap.getVents()[2].setLowerBoundRange(52, 58);
        toOverlap.getVents()[2].setUpperBoundRange(52, 58);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 52);
        Assert.assertEquals(vent.getLowerBoundEnd(), 55);
        Assert.assertEquals(vent.getUpperBoundStart(), 52);
        Assert.assertEquals(vent.getUpperBoundEnd(), 55);
    }

    public void setOverlappingRangesLowerUpperBothMatchTest() {
        StatusState state = new StatusState();
        final VentStatus vent = state.getVents()[2];
        StatusState toOverlap = new StatusState();
        toOverlap.updateVentStatus(new int[]{50, 50, u}, 7);
        toOverlap.getVents()[2].clearRanges();
        toOverlap.getVents()[2].setLowerBoundRange(0, 46);
        toOverlap.getVents()[2].setUpperBoundRange(54, 100);

        //Upper range values match both lower and upper overlap
        vent.clearRanges();
        vent.setLowerBoundRange(0, 9);
        vent.setUpperBoundRange(46, 59);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 0);
        Assert.assertEquals(vent.getLowerBoundEnd(), 9);
        Assert.assertEquals(vent.getUpperBoundStart(), 46);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);

        //Lower range values match both lower and upper overlap
        vent.clearRanges();
        vent.setLowerBoundRange(41, 54);
        vent.setUpperBoundRange(91, 100);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 54);
        Assert.assertEquals(vent.getUpperBoundStart(), 91);
        Assert.assertEquals(vent.getUpperBoundEnd(), 100);

        //Both range values match both lower and upper overlap
        //Our vent has a huge single range
        vent.clearRanges();
        vent.setLowerBoundRange(41, 54);
        vent.setUpperBoundRange(46, 59);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 46);
        Assert.assertEquals(vent.getUpperBoundStart(), 54);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);

        //Other vent has a huge single range
        toOverlap.getVents()[2].setLowerBoundRange(0, 54);
        toOverlap.getVents()[2].setUpperBoundRange(46, 100);
        state.setOverlappingRangesWith(toOverlap);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 46);
        Assert.assertEquals(vent.getUpperBoundStart(), 54);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);
    }

    public void doFreezeClippingBTest() {
        StatusState state = new StatusState();
        final VentStatus vent = state.getVents()[0];
        state.updateVentStatus(new int[]{u, 50, 50}, 0);

        //B is frozen with 0 move
        vent.clearRanges();
        vent.setLowerBoundRange(30, 33);
        vent.setUpperBoundRange(42, 44);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(1, 0, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);
        Assert.assertFalse(vent.isFreezeClipAccurate());

        //B is 41-59 with 1 move
        vent.clearRanges();
        vent.setLowerBoundRange(30, 33);
        vent.setUpperBoundRange(42, 44);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(2, 1, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 30);
        Assert.assertEquals(vent.getLowerBoundEnd(), 33);
        Assert.assertEquals(vent.getUpperBoundStart(), 30);
        Assert.assertEquals(vent.getUpperBoundEnd(), 33);
        Assert.assertFalse(vent.isFreezeClipAccurate());

        //B is outside 41-59 with 1 move
        state.updateVentStatus(new int[]{u, 60, 50}, 0);
        vent.clearRanges();
        vent.setLowerBoundRange(30, 33);
        vent.setUpperBoundRange(42, 44);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(2, 1, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);
        Assert.assertFalse(vent.isFreezeClipAccurate());

        //B is bounded with 1 move edge case - dont clip anything
        state.updateVentStatus(new int[]{u, 1, u}, 0);
        vent.clearRanges();
        vent.setLowerBoundRange(30, 33);
        vent.setUpperBoundRange(42, 44);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(2, 1, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 30);
        Assert.assertEquals(vent.getLowerBoundEnd(), 33);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);
        Assert.assertFalse(vent.isFreezeClipAccurate());

        //B is outside 41-59 with 2 move
        vent.clearRanges();
        vent.setLowerBoundRange(30, 33);
        vent.setUpperBoundRange(42, 44);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(2, 2, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 30);
        Assert.assertEquals(vent.getLowerBoundEnd(), 33);
        Assert.assertEquals(vent.getUpperBoundStart(), 30);
        Assert.assertEquals(vent.getUpperBoundEnd(), 33);
        Assert.assertFalse(vent.isFreezeClipAccurate());

        //B is bounded with 0 move - don't clip anything
        state.updateVentStatus(new int[]{u, 0, u}, 0);
        vent.clearRanges();
        vent.setLowerBoundRange(30, 33);
        vent.setUpperBoundRange(42, 44);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(2, 0, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 30);
        Assert.assertEquals(vent.getLowerBoundEnd(), 33);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);
        Assert.assertFalse(vent.isFreezeClipAccurate());
    }

    public void doFreezeClippingBClippedATest() {
        StatusState state = new StatusState();
        final VentStatus vent = state.getVents()[0];
        state.updateVentStatus(new int[]{u, 50, 50}, 0);

        //B is outside 41-59 with 2 move - ensure A gets clipped
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        Assert.assertTrue(state.doFreezeClipping(makeMoveBitState(0, 2, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), u);
        Assert.assertEquals(vent.getLowerBoundEnd(), u);
        Assert.assertEquals(vent.getUpperBoundStart(), u);
        Assert.assertEquals(vent.getUpperBoundEnd(), u);
        Assert.assertFalse(vent.isFreezeClipAccurate());
    }

    public void doFreezeClippingCTest() {
        StatusState state = new StatusState();
        final VentStatus ventA = state.getVents()[0];
        final VentStatus ventB = state.getVents()[1];

        //0 move tests
        //C is outside 41-59 with 0 move - both A B 41-59
        state.updateVentStatus(new int[]{u, u, 60}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(1, 0, 0));
        Assert.assertEquals(ventA.getLowerBoundStart(), 42);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 44);
        Assert.assertEquals(ventA.getUpperBoundStart(), 42);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 44);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 42);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 44);
        Assert.assertEquals(ventB.getUpperBoundStart(), 42);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 44);

        //C is 41-59 with 0 move (possible both AB are 41-59) - do nothing
        state.updateVentStatus(new int[]{u, u, 50}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(1, 0, 0));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 42);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 44);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 42);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 44);

        //C is 41-59 with 0 move (only possible A is 41-59) - clip A
        state.updateVentStatus(new int[]{u, u, 50}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(30, 33);
        state.doFreezeClipping(makeMoveBitState(1, 0, 0));
        Assert.assertEquals(ventA.getLowerBoundStart(), 42);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 44);
        Assert.assertEquals(ventA.getUpperBoundStart(), 42);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 44);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 30);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 33);

        //C is 41-59 with 0 move (only possible B is 41-59) - clip B
        state.updateVentStatus(new int[]{u, u, 50}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(30, 33);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(1, 0, 0));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 30);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 33);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 42);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 44);
        Assert.assertEquals(ventB.getUpperBoundStart(), 42);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 44);

        //C is bounded with 0 move (possible both AB are 41-59) - do nothing
        state.updateVentStatus(new int[]{u, u, 0}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(1, 0, 0));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 42);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 44);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 42);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 44);


        //1 move tests
        //C is outside 41-59 with 1 move - either A or B 41-59
        state.updateVentStatus(new int[]{u, u, 60}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(1, 1, 1));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 42);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 44);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 42);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 44);

        //C is outside 41-59 with 1 move (only possible A is 41-59) - clip A
        state.updateVentStatus(new int[]{u, u, 60}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(30, 33);
        state.doFreezeClipping(makeMoveBitState(1, 1, 1));
        Assert.assertEquals(ventA.getLowerBoundStart(), 42);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 44);
        Assert.assertEquals(ventA.getUpperBoundStart(), 42);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 44);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 30);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 33);

        //C is outside 41-59 with 1 move (only possible B is 41-59) - clip B
        state.updateVentStatus(new int[]{u, u, 60}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(30, 33);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(1, 1, 1));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 30);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 33);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 42);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 44);
        Assert.assertEquals(ventB.getUpperBoundStart(), 42);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 44);

        //C is bounded with 1 move (only possible B is 41-59) - do nothing
        state.updateVentStatus(new int[]{u, u, 1}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(30, 33);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(1, 1, 1));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 30);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 33);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 42);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 44);

        //C is 41-59 with 1 move - both A B outside 41-59
        state.updateVentStatus(new int[]{u, u, 50}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(2, 2, 1));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 30);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 33);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 30);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 33);


        //2 move tests
        //C is outside 41-59 with 2 move - both A B outside 41-59
        state.updateVentStatus(new int[]{u, u, 60}, 0);
        ventA.clearRanges();
        ventA.setLowerBoundRange(30, 33);
        ventA.setUpperBoundRange(42, 44);
        ventB.clearRanges();
        ventB.setLowerBoundRange(30, 33);
        ventB.setUpperBoundRange(42, 44);
        state.doFreezeClipping(makeMoveBitState(2, 2, 2));
        Assert.assertEquals(ventA.getLowerBoundStart(), 30);
        Assert.assertEquals(ventA.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventA.getUpperBoundStart(), 30);
        Assert.assertEquals(ventA.getUpperBoundEnd(), 33);
        Assert.assertFalse(ventA.isFreezeClipAccurate());
        Assert.assertEquals(ventB.getLowerBoundStart(), 30);
        Assert.assertEquals(ventB.getLowerBoundEnd(), 33);
        Assert.assertEquals(ventB.getUpperBoundStart(), 30);
        Assert.assertEquals(ventB.getUpperBoundEnd(), 33);
    }

    public void makeFreezeClipAccurateTest() {
        StatusState state = new StatusState();
        VentStatus vent = state.getVents()[0];
        state.updateVentStatus(new int[]{u, 75, u}, 0);

        //B is outside 41-59 with 2 move
        vent.clearRanges();
        vent.setLowerBoundRange(40, 42);
        vent.setUpperBoundRange(40, 42);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(1, 2, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 40);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 40);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);
        Assert.assertTrue(vent.isFreezeClipAccurate());

        state = new StatusState();
        vent = state.getVents()[0];
        state.updateVentStatus(new int[]{u, 75, u}, 0);

        vent.clearRanges();
        vent.setLowerBoundRange(58, 60);
        vent.setUpperBoundRange(58, 60);
        Assert.assertFalse(state.doFreezeClipping(makeMoveBitState(1, 2, 0)));
        Assert.assertEquals(vent.getLowerBoundStart(), 60);
        Assert.assertEquals(vent.getLowerBoundEnd(), 60);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 60);
        Assert.assertTrue(vent.isFreezeClipAccurate());
    }

    public void clipPredictedStabilityMismatchInvalidTest() {
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{24, 76, u}, 6);
        final VentStatus ventC = state.getVents()[2];

        //Single value range do nothing
        ventC.setUpperBoundRange(79, 79);
        ventC.setLowerBoundRange(79, 79);
        state.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation()-1);
        Assert.assertEquals(ventC.getLowerBoundStart(), 79);
        Assert.assertEquals(ventC.getLowerBoundEnd(), 79);
        Assert.assertEquals(ventC.getUpperBoundStart(), 79);
        Assert.assertEquals(ventC.getUpperBoundEnd(), 79);

        //Both changes are above stability amount do nothing
        ventC.setUpperBoundRange(53, 53);
        ventC.setLowerBoundRange(47, 47);
        state.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation()-1);
        Assert.assertEquals(ventC.getLowerBoundStart(), 47);
        Assert.assertEquals(ventC.getLowerBoundEnd(), 47);
        Assert.assertEquals(ventC.getUpperBoundStart(), 53);
        Assert.assertEquals(ventC.getUpperBoundEnd(), 53);

        //Both changes are negative but match no clipping
        ventC.setUpperBoundRange(79, 79);
        ventC.setLowerBoundRange(21, 21);
        state.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation()-1);
        Assert.assertEquals(ventC.getLowerBoundStart(), 21);
        Assert.assertEquals(ventC.getLowerBoundEnd(), 21);
        Assert.assertEquals(ventC.getUpperBoundStart(), 79);
        Assert.assertEquals(ventC.getUpperBoundEnd(), 79);
    }

    public void clipPredictedStabilityMismatchTest() {
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{24, 76, u}, 6);
        final VentStatus ventC = state.getVents()[2];

        //Upper bound partial clipping
        ventC.setUpperBoundRange(77, 79);
        ventC.setLowerBoundRange(47, 49);
        state.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation()-1);
        Assert.assertEquals(ventC.getLowerBoundStart(), 47);
        Assert.assertEquals(ventC.getLowerBoundEnd(), 49);
        Assert.assertEquals(ventC.getUpperBoundStart(), 77);
        Assert.assertEquals(ventC.getUpperBoundEnd(), 78);

        //Upper bound full clipping
        ventC.setUpperBoundRange(79, 79);
        ventC.setLowerBoundRange(47, 49);
        state.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation()-1);
        Assert.assertEquals(ventC.getLowerBoundStart(), 47);
        Assert.assertEquals(ventC.getLowerBoundEnd(), 49);
        Assert.assertEquals(ventC.getUpperBoundStart(), 47);
        Assert.assertEquals(ventC.getUpperBoundEnd(), 49);

        //Lower bound partial clipping
        ventC.setUpperBoundRange(51, 53);
        ventC.setLowerBoundRange(21, 23);
        state.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation()-1);
        Assert.assertEquals(ventC.getLowerBoundStart(), 22);
        Assert.assertEquals(ventC.getLowerBoundEnd(), 23);
        Assert.assertEquals(ventC.getUpperBoundStart(), 51);
        Assert.assertEquals(ventC.getUpperBoundEnd(), 53);

        //Lower bound full clipping
        ventC.setUpperBoundRange(51, 53);
        ventC.setLowerBoundRange(21, 21);
        state.clipPredictedStabilityMismatch(StabilityUpdateInfo.getMinRNGVariation()-1);
        Assert.assertEquals(ventC.getLowerBoundStart(), 51);
        Assert.assertEquals(ventC.getLowerBoundEnd(), 53);
        Assert.assertEquals(ventC.getUpperBoundStart(), 51);
        Assert.assertEquals(ventC.getUpperBoundEnd(), 53);
    }

    public void doHalfSpaceClippingChangeTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();
        vents[0].setLowerBoundRange(0, 100);
        vents[0].setUpperBoundRange(0, 100);
        vents[1].setLowerBoundRange(0, 100);
        vents[1].setUpperBoundRange(0, 100);
        vents[2].setLowerBoundRange(0, 100);
        vents[2].setUpperBoundRange(0, 100);

        //A Clipping test - moving upward
        vents[0].update(u, 1);
        //Only clip A - negative point contribution
        state.doHalfSpaceClipping(1, 1);
        Assert.assertEquals(vents[0].getLowerBoundStart(), 47);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 47);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents[1].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);

        //Only clip A - positive point contribution
        vents[0].setLowerBoundRange(0, 100);
        vents[0].setUpperBoundRange(0, 100);
        state.doHalfSpaceClipping(1, 0);
        Assert.assertEquals(vents[0].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 53);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 53);
        Assert.assertEquals(vents[1].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);

        //A Clipping test - moving downward
        vents[0].update(u, -1);
        vents[0].setLowerBoundRange(0, 100);
        vents[0].setUpperBoundRange(0, 100);
        //Only clip A - negative point contribution
        state.doHalfSpaceClipping(1, 1);
        Assert.assertEquals(vents[0].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 53);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 53);
        Assert.assertEquals(vents[1].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);

        vents[0].setLowerBoundRange(0, 100);
        vents[0].setUpperBoundRange(0, 100);
        //Only clip A - positive point contribution
        state.doHalfSpaceClipping(1, 0);
        Assert.assertEquals(vents[0].getLowerBoundStart(), 47);
        Assert.assertEquals(vents[0].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[0].getUpperBoundStart(), 47);
        Assert.assertEquals(vents[0].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents[1].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[1].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[1].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[1].getUpperBoundEnd(), 100);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);
    }

    public void reverseMovementSingleKnownVentTest() {
        int unknownMovement = 63;
        int AMovement = 2, BMovement = 2 << 2, CMovement = 2 << 4;
        int UnknownA = 3, UnknownB = 3 << 2, UnknownC = 3 << 4;

        //No vents known test
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u, u, u}, 0);
        Assert.assertFalse(state.reverseMovement(unknownMovement));


        //A vent known tests
        //Unknown movement - should still be able to reverse
        StatusState stateA = new StatusState();
        stateA.updateVentStatus(new int[]{70, u, u}, 0);
        Assert.assertTrue(stateA.reverseMovement(unknownMovement));
        Assert.assertEquals(stateA.getVents()[0].getActualValue(), 72);

        //Movement by 2 - should be able to reverse
        stateA.updateVentStatus(new int[]{70, u, u}, 0);
        Assert.assertTrue(stateA.reverseMovement(AMovement | UnknownB | UnknownC));
        Assert.assertEquals(stateA.getVents()[0].getActualValue(), 72);


        //B vent known tests
        //Unknown movement - should fail to reverse
        StatusState stateB = new StatusState();
        stateB.updateVentStatus(new int[]{u, 70, u}, 0);
        Assert.assertFalse(stateB.reverseMovement(unknownMovement));
        Assert.assertEquals(stateB.getVents()[1].getActualValue(), 70);

        //Movement by 2 - should be able to reverse
        stateB.updateVentStatus(new int[]{u, 70, u}, 0);
        Assert.assertTrue(stateB.reverseMovement(UnknownA | BMovement | UnknownC));
        Assert.assertEquals(stateB.getVents()[1].getActualValue(), 72);

        //Unknown movement but good estimates - should be able to reverse by 2
        stateB.updateVentStatus(new int[]{u, 70, u}, 0);
        stateB.getVents()[0].clearRanges();
        stateB.getVents()[0].setLowerBoundRange(70, 70);
        stateB.getVents()[0].setUpperBoundRange(70, 70);
        Assert.assertTrue(stateB.reverseMovement(unknownMovement));
        Assert.assertEquals(stateB.getVents()[1].getActualValue(), 72);

        //Unknown movement but good estimates - should be able to reverse by 1
        stateB.updateVentStatus(new int[]{u, 70, u}, 0);
        stateB.getVents()[0].clearRanges();
        stateB.getVents()[0].setLowerBoundRange(50, 50);
        stateB.getVents()[0].setUpperBoundRange(50, 50);
        Assert.assertTrue(stateB.reverseMovement(unknownMovement));
        Assert.assertEquals(stateB.getVents()[1].getActualValue(), 71);


        //C vent known tests
        //Unknown movement - should fail to reverse
        StatusState stateC = new StatusState();
        stateC.updateVentStatus(new int[]{u, u, 70}, 0);
        Assert.assertFalse(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 70);

        //Movement by 2 - should be able to reverse
        stateC.updateVentStatus(new int[]{u, u, 70}, 0);
        Assert.assertTrue(stateC.reverseMovement(UnknownA | UnknownB | CMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 72);

        //Unknown movement but bad B estimates - should fail to reverse by 2
        stateC.updateVentStatus(new int[]{u, u, 70}, 0);
        stateC.getVents()[0].clearRanges();
        stateC.getVents()[0].setLowerBoundRange(70, 70);
        stateC.getVents()[0].setUpperBoundRange(70, 70);
        Assert.assertFalse(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 70);
        //Unknown movement but good estimates - should be able to reverse by 2
        stateC.getVents()[1].clearRanges();
        stateC.getVents()[1].setLowerBoundRange(70, 70);
        stateC.getVents()[1].setUpperBoundRange(70, 70);
        Assert.assertTrue(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 72);

        //Unknown movement but bad B estimates - should fail to reverse by 1
        stateC = new StatusState();
        stateC.updateVentStatus(new int[]{u, u, 70}, 0);
        stateC.getVents()[0].clearRanges();
        stateC.getVents()[0].setLowerBoundRange(50, 50);
        stateC.getVents()[0].setUpperBoundRange(50, 50);
        Assert.assertFalse(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 70);
        //Unknown movement but good estimates - should be able to reverse by 1
        stateC.getVents()[1].clearRanges();
        stateC.getVents()[1].setLowerBoundRange(70, 70);
        stateC.getVents()[1].setUpperBoundRange(70, 70);
        Assert.assertTrue(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 71);

        //Unknown movement but bad B estimates - should fail to reverse by 1
        stateC = new StatusState();
        stateC.updateVentStatus(new int[]{u, u, 70}, 0);
        stateC.getVents()[0].clearRanges();
        stateC.getVents()[0].setLowerBoundRange(70, 70);
        stateC.getVents()[0].setUpperBoundRange(70, 70);
        Assert.assertFalse(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 70);
        //Unknown movement but good estimates - should be able to reverse by 1
        stateC.getVents()[1].clearRanges();
        stateC.getVents()[1].setLowerBoundRange(50, 50);
        stateC.getVents()[1].setUpperBoundRange(50, 50);
        Assert.assertTrue(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 71);

        //Unknown movement but bad B estimates - should fail to reverse by 0
        stateC = new StatusState();
        stateC.updateVentStatus(new int[]{u, u, 70}, 0);
        stateC.getVents()[0].clearRanges();
        stateC.getVents()[0].setLowerBoundRange(50, 50);
        stateC.getVents()[0].setUpperBoundRange(50, 50);
        Assert.assertFalse(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 70);
        //Unknown movement but good estimates - should be able to reverse by 0
        stateC.getVents()[1].clearRanges();
        stateC.getVents()[1].setLowerBoundRange(50, 50);
        stateC.getVents()[1].setUpperBoundRange(50, 50);
        Assert.assertTrue(stateC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateC.getVents()[2].getActualValue(), 70);
    }

    public void reverseMovementDoubleKnownVentTest() {
        int unknownMovement = 63;
        int AMovement = 2, BMovement = 2 << 2, CMovement = 2 << 4;
        int UnknownA = 3, UnknownB = 3 << 2, UnknownC = 3 << 4;

        //AB vent known tests
        //Unknown movement - should still be able to reverse
        StatusState stateAB = new StatusState();
        stateAB.updateVentStatus(new int[]{70, 70, u}, 0);
        Assert.assertTrue(stateAB.reverseMovement(unknownMovement));
        Assert.assertEquals(stateAB.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAB.getVents()[1].getActualValue(), 72);

        //Unknown B but known A - should still be able to reverse
        stateAB.updateVentStatus(new int[]{70, 70, u}, 0);
        Assert.assertTrue(stateAB.reverseMovement(AMovement | UnknownB | UnknownC));
        Assert.assertEquals(stateAB.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAB.getVents()[1].getActualValue(), 72);

        //Unknown A but known B - should still be able to reverse
        stateAB.updateVentStatus(new int[]{70, 70, u}, 0);
        Assert.assertTrue(stateAB.reverseMovement(UnknownA | BMovement | UnknownC));
        Assert.assertEquals(stateAB.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAB.getVents()[1].getActualValue(), 72);

        //Movement by 2 - should be able to reverse
        stateAB.updateVentStatus(new int[]{70, 70, u}, 0);
        Assert.assertTrue(stateAB.reverseMovement(AMovement | BMovement | UnknownC));
        Assert.assertEquals(stateAB.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAB.getVents()[1].getActualValue(), 72);


        //AC vent known tests
        //Unknown movement - should fail to reverse
        StatusState stateAC = new StatusState();
        stateAC.updateVentStatus(new int[]{70, u, 70}, 0);
        Assert.assertFalse(stateAC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateAC.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAC.getVents()[2].getActualValue(), 70);

        //Unknown C but known A - should still fail to reverse
        stateAC.updateVentStatus(new int[]{70, u, 70}, 0);
        Assert.assertFalse(stateAC.reverseMovement(AMovement | UnknownB | UnknownC));
        Assert.assertEquals(stateAC.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAC.getVents()[2].getActualValue(), 70);

        //Unknown A but known C - should be able to reverse
        stateAC.updateVentStatus(new int[]{70, u, 70}, 0);
        Assert.assertTrue(stateAC.reverseMovement(UnknownA | UnknownB | CMovement));
        Assert.assertEquals(stateAC.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAC.getVents()[2].getActualValue(), 72);

        //Movement by 2 - should be able to reverse
        stateAC.updateVentStatus(new int[]{70, u, 70}, 0);
        Assert.assertTrue(stateAC.reverseMovement(AMovement | UnknownB | CMovement));
        Assert.assertEquals(stateAC.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAC.getVents()[2].getActualValue(), 72);

        //Unknown movement but good estimates - should be able to reverse by 2
        stateAC = new StatusState();
        stateAC.updateVentStatus(new int[]{70, u, 70}, 0);
        stateAC.getVents()[1].clearRanges();
        stateAC.getVents()[1].setLowerBoundRange(70, 70);
        stateAC.getVents()[1].setUpperBoundRange(70, 70);
        Assert.assertTrue(stateAC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateAC.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAC.getVents()[2].getActualValue(), 72);

        //Unknown movement but good estimates - should be able to reverse by 1
        stateAC = new StatusState();
        stateAC.updateVentStatus(new int[]{70, u, 70}, 0);
        stateAC.getVents()[1].clearRanges();
        stateAC.getVents()[1].setLowerBoundRange(50, 50);
        stateAC.getVents()[1].setUpperBoundRange(50, 50);
        Assert.assertTrue(stateAC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateAC.getVents()[0].getActualValue(), 72);
        Assert.assertEquals(stateAC.getVents()[2].getActualValue(), 71);


        //BC vent known tests
        //Unknown movement - should fail to reverse
        StatusState stateBC = new StatusState();
        stateBC.updateVentStatus(new int[]{u, 70, 70}, 0);
        Assert.assertFalse(stateBC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateBC.getVents()[1].getActualValue(), 70);
        Assert.assertEquals(stateBC.getVents()[2].getActualValue(), 70);

        //Unknown C but known B - should still fail to reverse
        stateBC.updateVentStatus(new int[]{u, 70, 70}, 0);
        Assert.assertFalse(stateBC.reverseMovement(UnknownA | BMovement | UnknownC));
        Assert.assertEquals(stateBC.getVents()[1].getActualValue(), 72);
        Assert.assertEquals(stateBC.getVents()[2].getActualValue(), 70);

        //Unknown B but known C - should still fail to reverse
        stateBC.updateVentStatus(new int[]{u, 70, 70}, 0);
        Assert.assertFalse(stateBC.reverseMovement(UnknownA | UnknownB | CMovement));
        Assert.assertEquals(stateBC.getVents()[1].getActualValue(), 70);
        Assert.assertEquals(stateBC.getVents()[2].getActualValue(), 70);

        //Movement by 2 - should be able to reverse
        stateBC.updateVentStatus(new int[]{u, 70, 70}, 0);
        Assert.assertTrue(stateBC.reverseMovement(UnknownA | BMovement | CMovement));
        Assert.assertEquals(stateBC.getVents()[1].getActualValue(), 72);
        Assert.assertEquals(stateBC.getVents()[2].getActualValue(), 72);

        //Unknown movement but good estimates - should be able to reverse by 2
        stateBC = new StatusState();
        stateBC.updateVentStatus(new int[]{u, 70, 70}, 0);
        stateBC.getVents()[0].clearRanges();
        stateBC.getVents()[0].setLowerBoundRange(70, 70);
        stateBC.getVents()[0].setUpperBoundRange(70, 70);
        Assert.assertTrue(stateBC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateBC.getVents()[1].getActualValue(), 72);
        Assert.assertEquals(stateBC.getVents()[2].getActualValue(), 72);

        //Unknown movement but good estimates - should be able to reverse by 1
        stateBC = new StatusState();
        stateBC.updateVentStatus(new int[]{u, 70, 70}, 0);
        stateBC.getVents()[0].clearRanges();
        stateBC.getVents()[0].setLowerBoundRange(50, 50);
        stateBC.getVents()[0].setUpperBoundRange(50, 50);
        Assert.assertTrue(stateBC.reverseMovement(unknownMovement));
        Assert.assertEquals(stateBC.getVents()[1].getActualValue(), 71);
        Assert.assertEquals(stateBC.getVents()[2].getActualValue(), 71);
    }

    public void reverseMovementFreezeClippedATest() {
        int unknownMovement = 63;
        int CMovement = 1 << 4;
        int UnknownA = 3, UnknownB = 3 << 2, UnknownC = 3 << 4;

        //Accurate Freeze Clip A vent tests
        //Unknown movement - should still be able to reverse
        StatusState stateFreezeA = new StatusState();
        stateFreezeA.updateVentStatus(new int[]{u, u, u}, 0);
        stateFreezeA.getVents()[0].clearRanges();
        stateFreezeA.getVents()[0].setLowerBoundRange(40, 40);
        stateFreezeA.getVents()[0].setUpperBoundRange(40, 40);
        stateFreezeA.getVents()[0].makeFreezeClipAccurate();
        Assert.assertTrue(stateFreezeA.reverseMovement(unknownMovement));
        Assert.assertEquals(stateFreezeA.getVents()[0].getLowerBoundStart(), 41);
        Assert.assertEquals(stateFreezeA.getVents()[0].getLowerBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA.getVents()[0].getUpperBoundStart(), 41);
        Assert.assertEquals(stateFreezeA.getVents()[0].getUpperBoundEnd(), 41);

        //Unknown movement AB - should still be able to reverse
        StatusState stateFreezeA_B = new StatusState();
        stateFreezeA_B.updateVentStatus(new int[]{u, 70, u}, 0);
        stateFreezeA_B.getVents()[0].clearRanges();
        stateFreezeA_B.getVents()[0].setLowerBoundRange(40, 40);
        stateFreezeA_B.getVents()[0].setUpperBoundRange(40, 40);
        stateFreezeA_B.getVents()[0].makeFreezeClipAccurate();
        Assert.assertTrue(stateFreezeA_B.reverseMovement(unknownMovement));
        Assert.assertEquals(stateFreezeA_B.getVents()[0].getLowerBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_B.getVents()[0].getLowerBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_B.getVents()[0].getUpperBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_B.getVents()[0].getUpperBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_B.getVents()[1].getActualValue(), 71);

        //Unknown movement AC - should fail to reverse
        StatusState stateFreezeA_C = new StatusState();
        stateFreezeA_C.updateVentStatus(new int[]{u, u, 70}, 0);
        stateFreezeA_C.getVents()[0].clearRanges();
        stateFreezeA_C.getVents()[0].setLowerBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].setUpperBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].makeFreezeClipAccurate();
        Assert.assertFalse(stateFreezeA_C.reverseMovement(unknownMovement));
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[2].getActualValue(), 70);

        //Unknown movement AC but good estimates - should be able to reverse by 1
        stateFreezeA_C = new StatusState();
        stateFreezeA_C.updateVentStatus(new int[]{u, u, 70}, 0);
        stateFreezeA_C.getVents()[0].clearRanges();
        stateFreezeA_C.getVents()[0].setLowerBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].setUpperBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].makeFreezeClipAccurate();
        stateFreezeA_C.getVents()[1].clearRanges();
        stateFreezeA_C.getVents()[1].setLowerBoundRange(70, 70);
        stateFreezeA_C.getVents()[1].setUpperBoundRange(70, 70);
        Assert.assertTrue(stateFreezeA_C.reverseMovement(unknownMovement));
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[2].getActualValue(), 71);

        //Unknown movement AC but good estimates - should be able to reverse by 0
        stateFreezeA_C = new StatusState();
        stateFreezeA_C.updateVentStatus(new int[]{u, u, 70}, 0);
        stateFreezeA_C.getVents()[0].clearRanges();
        stateFreezeA_C.getVents()[0].setLowerBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].setUpperBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].makeFreezeClipAccurate();
        stateFreezeA_C.getVents()[1].clearRanges();
        stateFreezeA_C.getVents()[1].setLowerBoundRange(50, 50);
        stateFreezeA_C.getVents()[1].setUpperBoundRange(50, 50);
        Assert.assertTrue(stateFreezeA_C.reverseMovement(unknownMovement));
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[2].getActualValue(), 70);

        //Movement by 1 - should be able to reverse
        stateFreezeA_C = new StatusState();
        stateFreezeA_C.updateVentStatus(new int[]{u, u, 70}, 0);
        stateFreezeA_C.getVents()[0].clearRanges();
        stateFreezeA_C.getVents()[0].setLowerBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].setUpperBoundRange(40, 40);
        stateFreezeA_C.getVents()[0].makeFreezeClipAccurate();
        Assert.assertTrue(stateFreezeA_C.reverseMovement(UnknownA | UnknownB | CMovement));
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getLowerBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundStart(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[0].getUpperBoundEnd(), 41);
        Assert.assertEquals(stateFreezeA_C.getVents()[2].getActualValue(), 71);
    }

    public void trimDoubleVentSeperateRangesTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();
        state.updateVentStatus(new int[]{54, u, u}, 2);

        //Upper bound range C should be clipped
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(0, 11);
        vents[2].setUpperBoundRange(80, 83);
        state.trimDoubleVentRanges(-5);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 9);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 9);

        //Lower bound range C should be clipped
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(17, 20);
        vents[2].setUpperBoundRange(89, 100);
        state.trimDoubleVentRanges(-5);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 91);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 91);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);

        //Both ranges C should be trimmed
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(0, 11);
        vents[2].setUpperBoundRange(89, 100);
        state.trimDoubleVentRanges(-5);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 9);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 91);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);

        //Both ranges C should be clipped
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(17, 20);
        vents[2].setUpperBoundRange(80, 83);
        state.trimDoubleVentRanges(-5);
        Assert.assertFalse(vents[2].isRangeDefined());
    }

    public void trimDoubleVentSingleRangeTest() {
        StatusState state = new StatusState();
        final VentStatus[] vents = state.getVents();
        state.updateVentStatus(new int[]{54, u, u}, 2);

        //No valid upperbound ranges will be found
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(0, 31);
        vents[2].setUpperBoundRange(0, 31);
        state.trimDoubleVentRanges(-5);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 9);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 9);

        //No valid lowerbound ranges will be found
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(69, 100);
        vents[2].setUpperBoundRange(69, 100);
        state.trimDoubleVentRanges(-5);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 91);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 91);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 100);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);

        //No valid ranges will be found
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(47, 53);
        vents[2].setUpperBoundRange(47, 53);
        state.trimDoubleVentRanges(-5);
        Assert.assertFalse(vents[2].isRangeDefined());

        //Valid ranges will be found for both - large range will split
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(0, 100);
        vents[2].setUpperBoundRange(0, 100);
        state.trimDoubleVentRanges(-5);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 91);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 9);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 100);

        //Edge cases - range merge testing
        vents[1].setLowerBoundRange(8, 20);
        vents[1].setUpperBoundRange(86, 96);
        vents[2].setLowerBoundRange(0, 9);
        vents[2].setUpperBoundRange(0, 9);
        state.trimDoubleVentRanges(-5);
        Assert.assertEquals(vents[2].getLowerBoundStart(), 0);
        Assert.assertEquals(vents[2].getUpperBoundStart(), 0);
        Assert.assertEquals(vents[2].getLowerBoundEnd(), 9);
        Assert.assertEquals(vents[2].getUpperBoundEnd(), 9);

    }

    public void getFutureStabilityChangeTest() {
        UltimateVolcanicMineConfig.PredictionScenario worstCase = UltimateVolcanicMineConfig.PredictionScenario.WORST_CASE;
        UltimateVolcanicMineConfig.PredictionScenario bestCase = UltimateVolcanicMineConfig.PredictionScenario.BEST_CASE;
        StatusState state = new StatusState();

        //No vents known shouldnt have a change
        state.updateVentStatus(new int[]{u, u, u}, 0);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);


        //1 vent tests
        //should fail due to undefined ranges
        state.updateVentStatus(new int[]{u, 50, u}, 0);
        state.clearAllRanges();
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.getVents()[0].setLowerBoundRange(50, 50);
        state.getVents()[0].setUpperBoundRange(50, 50);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.clearAllRanges();
        state.getVents()[2].setLowerBoundRange(50, 50);
        state.getVents()[2].setUpperBoundRange(50, 50);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //should fail due to huge single range
        state.getVents()[0].setLowerBoundRange(40, 60);
        state.getVents()[0].setUpperBoundRange(40, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.clearAllRanges();
        state.getVents()[0].setLowerBoundRange(50, 50);
        state.getVents()[0].setUpperBoundRange(50, 50);
        state.getVents()[2].setLowerBoundRange(40, 60);
        state.getVents()[2].setUpperBoundRange(40, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //should fail due to huge double range
        state.clearAllRanges();
        state.getVents()[2].setLowerBoundRange(50, 50);
        state.getVents()[2].setUpperBoundRange(50, 50);
        state.getVents()[0].setLowerBoundRange(40, 40);
        state.getVents()[0].setUpperBoundRange(50, 57);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.getVents()[0].clearRanges();
        state.getVents()[0].setLowerBoundRange(43, 50);
        state.getVents()[0].setUpperBoundRange(60, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.clearAllRanges();
        state.getVents()[0].setLowerBoundRange(50, 50);
        state.getVents()[0].setUpperBoundRange(50, 50);
        state.getVents()[2].setLowerBoundRange(40, 40);
        state.getVents()[2].setUpperBoundRange(50, 57);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(43, 50);
        state.getVents()[2].setUpperBoundRange(60, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //should fail due to two double ranges
        state.clearAllRanges();
        state.getVents()[2].setLowerBoundRange(40, 40);
        state.getVents()[2].setUpperBoundRange(60, 60);
        state.getVents()[0].setLowerBoundRange(40, 40);
        state.getVents()[0].setUpperBoundRange(60, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //will pass with a single range and one small double range
        state.clearAllRanges();
        state.getVents()[0].setLowerBoundRange(47, 53);
        state.getVents()[0].setUpperBoundRange(47, 53);
        state.getVents()[2].setLowerBoundRange(38, 40);
        state.getVents()[2].setUpperBoundRange(57, 59);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 20);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 21);
        state.clearAllRanges();
        state.getVents()[2].setLowerBoundRange(47, 53);
        state.getVents()[2].setUpperBoundRange(47, 53);
        state.getVents()[0].setLowerBoundRange(38, 40);
        state.getVents()[0].setUpperBoundRange(57, 59);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 20);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 21);

        //will pass with two single ranges
        state.clearAllRanges();
        state.getVents()[2].setLowerBoundRange(47, 53);
        state.getVents()[2].setUpperBoundRange(47, 53);
        state.getVents()[0].setLowerBoundRange(47, 53);
        state.getVents()[0].setUpperBoundRange(47, 53);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 23);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 23);


        //1 vent + freeze clip accurate tests
        //should fail due to undefined ranges
        state.clearAllRanges();
        state.getVents()[0].setLowerBoundRange(40, 40);
        state.getVents()[0].setUpperBoundRange(40, 40);
        state.getVents()[0].makeFreezeClipAccurate();
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //should fail due to huge single range
        state.getVents()[2].setLowerBoundRange(40, 60);
        state.getVents()[2].setUpperBoundRange(40, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //should fail due to huge double range
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(40, 40);
        state.getVents()[2].setUpperBoundRange(50, 57);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(43, 50);
        state.getVents()[2].setUpperBoundRange(60, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //will pass with one small double range
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(38, 40);
        state.getVents()[2].setUpperBoundRange(57, 59);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 17);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 18);

        //will pass with one larger single range
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(47, 53);
        state.getVents()[2].setUpperBoundRange(47, 53);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 20);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 20);


        //2 vents tests
        //should fail due to undefined ranges
        state.clearAllRanges();
        state.updateVentStatus(new int[]{50, 50, u}, 0);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //should fail due to huge single range
        state.getVents()[2].setLowerBoundRange(40, 60);
        state.getVents()[2].setUpperBoundRange(40, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //should fail due to huge double range
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(40, 40);
        state.getVents()[2].setUpperBoundRange(50, 57);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(43, 50);
        state.getVents()[2].setUpperBoundRange(60, 60);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), u);

        //will pass with one small double range
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(38, 40);
        state.getVents()[2].setUpperBoundRange(57, 59);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 20);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 21);

        //will pass with one larger single range
        state.getVents()[2].clearRanges();
        state.getVents()[2].setLowerBoundRange(47, 53);
        state.getVents()[2].setUpperBoundRange(47, 53);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 23);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 23);


        //3 vents tests
        //will always pass
        state.updateVentStatus(new int[]{50, 50, 50}, 0);
        Assert.assertEquals(state.getFutureStabilityChange(worstCase), 23);
        Assert.assertEquals(state.getFutureStabilityChange(bestCase), 23);
    }

    public float getPercent(int value) {
        float percentValue = 50 - Math.abs(50 - value);
        return percentValue / 50.0f;
    }
    public int calcStabReverse(int A, int B, int C) {
        float weight = 16;
        float valA = (getPercent(A) * weight);
        float valB = (getPercent(B) * weight);
        float valC = (getPercent(C) * weight);
        int infA = (int)Math.ceil(valA);
        int infB = (int)Math.ceil(valB);
        int infC = (int)Math.ceil(valC);
        int total = infA + infB + infC;
        return -25 + total;
    }
    public int calcStabReverseRound(int A, int B, int C) {
        float weight = 49 / 3f;
        float valA = (getPercent(A) * weight);
        float valB = (getPercent(B) * weight);
        float valC = (getPercent(C) * weight);
        int infA = (int)Math.round(valA);
        int infB = (int)Math.round(valB);
        int infC = (int)Math.round(valC);
        int total = infA + infB + infC;
        return -25 + total;
    }
    public void sandbox() {
        int u = VentStatus.STARTING_VENT_VALUE;
        StatusState testState = new StatusState();
        testState.updateVentStatus(new int[]{23, 42, u}, 4);
        testState.calcPredictedVentValues(11);
        //50-53 all gave the same value
        //Vents all have equal weight

        int A = 41, B = 52, C = 58;
        int stab = calcStabReverse(A, B, C);
        int stab2 = calcStabReverseRound(A, B, C);
    }

}

package com.ultimatevm;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class UltimateVolcanicMinePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(UltimateVolcanicMinePlugin.class);
		RuneLite.main(args);
	}
}
package com.ultimatevm;

import net.runelite.client.util.Text;
import org.testng.annotations.Test;
import org.testng.Assert;

@Test()
public class VentStatusPredicterTest {

    int u = VentStatus.STARTING_VENT_VALUE;

    public void constructorTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        Assert.assertNotNull(predicter.getDisplayState());
        Assert.assertNotNull(predicter.getTimeline());
    }

    public void initializeTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        predicter.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 40, 50}, 7);
        predicter.makeStatusState(10);
        final StatusState prevState = predicter.getDisplayState();
        final VentStatusTimeline prevTimeline = predicter.getTimeline();
        predicter.initialize();

        Assert.assertNotEquals(predicter.getDisplayState(), prevState);
        Assert.assertNotEquals(predicter.getTimeline(), prevTimeline);
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertFalse(predicter.getDisplayState().getVents()[i].isIdentified());
            Assert.assertEquals(predicter.getDisplayState().getVents()[i].getDirection(), 0);
        }

    }

    public void resetTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        predicter.updateVentStatus(new int[]{50, 50, 50}, 7);

        //Ensure reset is done properly
        predicter.reset();
        Assert.assertEquals(predicter.getTimeline().getNumIdentifiedVents(), 0);

        //Reset should not work the second time
        predicter.updateVentStatus(new int[]{u, u, u}, 7);
        predicter.updateVentStatus(new int[]{50, 50, 50}, 7);
        predicter.reset();
        Assert.assertEquals(predicter.getTimeline().getNumIdentifiedVents(), 3);
    }

    public void updateVentStatusTest() {
        int u = VentStatus.STARTING_VENT_VALUE;
        VentStatusPredicter predicter = new VentStatusPredicter();
        //Make sure values are set
        int[] values = {u, 96, u};
        predicter.updateVentStatus(values, 7);
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertEquals(predicter.getDisplayState().getVents()[i].getActualValue(), values[i]);
            Assert.assertEquals(predicter.getDisplayState().getVents()[i].getDirection(), 1);
        }
    }

    public void makeStatusStateTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        int u = VentStatus.STARTING_VENT_VALUE;
        //Right amount of vents are known a range should be made!
        predicter.updateVentStatus(new int[]{u, 40, 50}, 7);
        predicter.getTimeline().updateTick();
        predicter.makeStatusState(15);
        Assert.assertFalse(predicter.getDisplayState().getVents()[0].isIdentified());
        Assert.assertTrue(predicter.getDisplayState().getVents()[0].isRangeDefined());
    }

    public void updateVentStatusMovementTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        int u = VentStatus.STARTING_VENT_VALUE;
        predicter.updateVentStatus(new int[]{u, 50, 50}, 7);
        predicter.getTimeline().updateTick();
        predicter.makeStatusState(23);
        predicter.updateDisplayState();
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getLowerBoundStart(), 47);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getLowerBoundEnd(), 53);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getUpperBoundStart(), 47);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getUpperBoundEnd(), 53);

        //Movement should be updated here
        for(int i = 0; i < VentStatusTimeline.VENT_MOVE_TICK_TIME*2; ++i) {
            predicter.updateVentStatus(new int[]{u, 50, 50}, 7);
            predicter.updateDisplayState();
            predicter.getTimeline().updateTick();
        }
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getLowerBoundStart(), 49);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getLowerBoundEnd(), 55);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getUpperBoundStart(), 49);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getUpperBoundEnd(), 55);

        //Movement should not update and values remain the same
        for(int i = 0; i < 5; ++i) {
            predicter.updateVentStatus(new int[]{u, 50, 50}, 7);
            predicter.updateDisplayState();
            predicter.getTimeline().updateTick();
        }
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getLowerBoundStart(), 49);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getLowerBoundEnd(), 55);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getUpperBoundStart(), 49);
        Assert.assertEquals(predicter.getDisplayState().getVents()[0].getUpperBoundEnd(), 55);
    }

    public void processVentChangeStateIdentifyTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        final VentStatusTimeline timeline = predicter.getTimeline();
        int u = VentStatus.STARTING_VENT_VALUE;

        //Ensure timeline identified vent event was called
        predicter.updateVentStatus(new int[]{u, u, u}, 7);
        predicter.getTimeline().updateTick();
        predicter.updateVentStatus(new int[]{50, 50, 50}, 7);
        Assert.assertNotNull(predicter.getTimeline().getIdentifiedVentStates()[0]);
        Assert.assertNotNull(predicter.getTimeline().getIdentifiedVentStates()[1]);
        Assert.assertNotNull(predicter.getTimeline().getIdentifiedVentStates()[2]);
    }

    public void processVentChangeStateDirectionTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        final VentStatusTimeline timeline = predicter.getTimeline();
        int u = VentStatus.STARTING_VENT_VALUE;

        //Ensure timeline direction change event was called
        predicter.updateVentStatus(new int[]{u, u, u}, 7);
        predicter.getTimeline().updateTick();
        predicter.updateVentStatus(new int[]{u, u, u}, 0);
        Assert.assertNotEquals(timeline.getTimeline()[1] & (1 << VentStatusTimeline.DIRECTION_CHANGED_FLAG), 0);
    }

    public void processVentChangeStateMovementTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        final VentStatusTimeline timeline = predicter.getTimeline();
        int u = VentStatus.STARTING_VENT_VALUE;

        //Ensure timeline direction change event was called
        predicter.updateVentStatus(new int[]{50, u, u}, 7);
        //Movement by 1
        predicter.getTimeline().updateTick();
        predicter.updateVentStatus(new int[]{51, u, u}, 7);
        Assert.assertNotEquals(timeline.getTimeline()[1] & (1 << VentStatusTimeline.MOVEMENT_UPDATE_FLAG), 0);
        //Movement by 2
        predicter.getTimeline().updateTick();
        predicter.updateVentStatus(new int[]{53, u, u}, 7);
        Assert.assertNotEquals(timeline.getTimeline()[2] & (1 << VentStatusTimeline.MOVEMENT_UPDATE_FLAG), 0);
    }

    public void processVentChangeStateResetTest() {
        VentStatusPredicter predicter = new VentStatusPredicter();
        final VentStatusTimeline timeline = predicter.getTimeline();
        int u = VentStatus.STARTING_VENT_VALUE;

        //Ensure reset event occurs
        predicter.updateVentStatus(new int[]{50, 50, 50}, 7);
        predicter.updateVentStatus(new int[]{u, u, u}, 7);
        Assert.assertTrue(predicter.getDisplayState().hasDoneVMReset());
        Assert.assertEquals(predicter.getDisplayState().getNumIdentifiedVents(), 0);
        //Timeline should remain unaffected
        Assert.assertEquals(predicter.getTimeline().getNumIdentifiedVents(), 3);
    }

    public void getVentStatusTextTest() {
        //Undefined range vents return the default text
        VentStatusPredicter predicter = new VentStatusPredicter();
        predicter.getDisplayState().getVents()[0].clearRanges();
        Assert.assertEquals(predicter.getVentStatusText(0, ""), "");

        //Identified vents return the default text
        predicter.initialize();
        predicter.updateVentStatus(new int[]{0, 50, 50}, 7);
        Assert.assertEquals(predicter.getVentStatusText(0, ""), "");

        //Only a single value should be displayed
        predicter.initialize();
        predicter.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 51, 51}, 7);
        predicter.getDisplayState().getVents()[0].clearRanges();
        predicter.getDisplayState().getVents()[0].setLowerBoundRange(50, 50);
        predicter.getDisplayState().getVents()[0].setUpperBoundRange(50, 50);
        String result = predicter.getVentStatusText(0, "A: ");
        result = Text.removeTags(result);
        Assert.assertEquals(result, "A: 50%");

        //Only a single range should be displayed
        predicter.initialize();
        predicter.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 50, 51}, 7);
        predicter.getDisplayState().getVents()[0].clearRanges();
        predicter.getDisplayState().getVents()[0].setLowerBoundRange(49, 51);
        predicter.getDisplayState().getVents()[0].setUpperBoundRange(49, 51);
        result = Text.removeTags(predicter.getVentStatusText(0, "A: "));
        Assert.assertEquals(result, "A: 49-51%");

        //Two values should be displayed
        predicter.initialize();
        predicter.reset();
        predicter.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 50, 50}, 7);
        predicter.getDisplayState().getVents()[0].clearRanges();
        predicter.getDisplayState().getVents()[0].setLowerBoundRange(0, 0);
        predicter.getDisplayState().getVents()[0].setUpperBoundRange(100, 100);
        result = Text.removeTags(predicter.getVentStatusText(0, "A: "));
        Assert.assertEquals(result, "A: 0% 100%");

        //Two ranges should be displayed
        predicter.initialize();
        predicter.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 50, 50}, 7);
        predicter.getDisplayState().getVents()[0].clearRanges();
        predicter.getDisplayState().getVents()[0].setLowerBoundRange(45, 47);
        predicter.getDisplayState().getVents()[0].setUpperBoundRange(53, 55);
        result = Text.removeTags(predicter.getVentStatusText(0, "A: "));
        Assert.assertEquals(result, "A: 45-47 53-55");

        //One value one range should be displayed
        predicter.initialize();
        predicter.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 50, 50}, 7);
        predicter.getDisplayState().getVents()[0].clearRanges();
        predicter.getDisplayState().getVents()[0].setLowerBoundRange(45, 45);
        predicter.getDisplayState().getVents()[0].setUpperBoundRange(53, 55);
        result = Text.removeTags(predicter.getVentStatusText(0, "A: "));
        Assert.assertEquals(result, "A: 45% 53-55");

        predicter.initialize();
        predicter.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE, 50, 50}, 7);
        predicter.getDisplayState().getVents()[0].clearRanges();
        predicter.getDisplayState().getVents()[0].setLowerBoundRange(45, 47);
        predicter.getDisplayState().getVents()[0].setUpperBoundRange(55, 55);
        result = Text.removeTags(predicter.getVentStatusText(0, "A: "));
        Assert.assertEquals(result, "A: 45-47 55%");
    }

}

package com.ultimatevm;

import org.testng.annotations.Test;
import org.testng.Assert;

@Test()
public class VentStatusTest {
    int u = VentStatus.STARTING_VENT_VALUE;
    @Test()
    public void constructorTest() {
        VentStatus vent = new VentStatus('A');
        Assert.assertEquals(vent.getName(), 'A');
        Assert.assertEquals(vent.getDirection(), 0);
        Assert.assertEquals(vent.getActualValue(), VentStatus.STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);
        Assert.assertFalse(vent.isFreezeClipAccurate());
    }

    public void copyConstructorTest() {
        StabilityUpdateInfo.resetPlayers();
        VentStatus vent = new VentStatus('A');
        vent.doVMReset();
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(60, 60);
        vent.setUpperBoundRange(60, 60);
        vent.makeFreezeClipAccurate();
        vent.updateMovement(new int[]{0, 0});


        VentStatus newVent = new VentStatus(vent);
        Assert.assertEquals(newVent.getName(), 'A');
        Assert.assertEquals(newVent.getDirection(), 1);
        Assert.assertEquals(newVent.getActualValue(), VentStatus.STARTING_VENT_VALUE);
        Assert.assertEquals(newVent.getLowerBoundStart(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(newVent.getLowerBoundEnd(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(newVent.getUpperBoundStart(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(newVent.getUpperBoundEnd(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertTrue(newVent.isFreezeClipAccurate());
        //For solo reset total bounds are 25-75%
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_RESET_SOLO_VENT_VALUE+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_RESET_SOLO_VENT_VALUE+VentStatus.BASE_MOVE_RATE);
        StabilityUpdateInfo.setNumPlayers(2);
    }

    public void setEqualToTest() {
        StabilityUpdateInfo.resetPlayers();
        VentStatus vent = new VentStatus('A');
        vent.doVMReset();
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(60, 60);
        vent.setUpperBoundRange(60, 60);
        vent.makeFreezeClipAccurate();
        vent.updateMovement(new int[]{0, 0});

        VentStatus newVent = new VentStatus('A');
        newVent.setEqualTo(vent);
        Assert.assertEquals(newVent.getName(), 'A');
        Assert.assertEquals(newVent.getDirection(), 1);
        Assert.assertEquals(newVent.getActualValue(), VentStatus.STARTING_VENT_VALUE);
        Assert.assertEquals(newVent.getLowerBoundStart(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(newVent.getLowerBoundEnd(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(newVent.getUpperBoundStart(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(newVent.getUpperBoundEnd(), 60+VentStatus.BASE_MOVE_RATE);
        Assert.assertTrue(newVent.isFreezeClipAccurate());
        //For solo reset total bounds are 25-75%
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_RESET_SOLO_VENT_VALUE+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_RESET_SOLO_VENT_VALUE+VentStatus.BASE_MOVE_RATE);
        StabilityUpdateInfo.setNumPlayers(2);
    }

    public void doVMResetTest() {
        StabilityUpdateInfo.setNumPlayers(2);
        VentStatus vent = new VentStatus('A');
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);
        vent.update(VentStatus.PERFECT_VENT_VALUE, 1);
        vent.updateMovement(new int[]{0, 0});

        vent.doVMReset();
        Assert.assertEquals(vent.getName(), 'A');
        Assert.assertEquals(vent.getDirection(), 1);
        Assert.assertEquals(vent.getActualValue(), VentStatus.STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), VentStatus.MAX_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_VENT_VALUE);
        //For reset total bounds are 0-100%
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE);
    }

    public void doVMSoloResetTest() {
        StabilityUpdateInfo.resetPlayers();
        VentStatus vent = new VentStatus('A');
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);
        vent.update(VentStatus.PERFECT_VENT_VALUE, 1);
        vent.updateMovement(new int[]{0, 0});

        vent.doVMReset();
        Assert.assertEquals(vent.getName(), 'A');
        Assert.assertEquals(vent.getDirection(), 1);
        Assert.assertEquals(vent.getActualValue(), VentStatus.STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_RESET_SOLO_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), VentStatus.MAX_RESET_SOLO_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundStart(), VentStatus.MIN_RESET_SOLO_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_RESET_SOLO_VENT_VALUE);
        //For solo reset total bounds are 25-75%
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_RESET_SOLO_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_RESET_SOLO_VENT_VALUE);
        StabilityUpdateInfo.setNumPlayers(2);
    }

    public void doVMResetFreezeClipAccurateTest() {
        VentStatus vent = new VentStatus('A');
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(60, 60);
        vent.setUpperBoundRange(60, 60);
        vent.makeFreezeClipAccurate();

        Assert.assertTrue(vent.isFreezeClipAccurate());
        vent.doVMReset();
        Assert.assertFalse(vent.isFreezeClipAccurate());
    }

    public void isIdentifiedTest() {
        VentStatus vent = new VentStatus('A');
        Assert.assertFalse(vent.isIdentified());
        vent.update(20, 1);
        Assert.assertTrue(vent.isIdentified());
    }

    public void setLowerBoundRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setLowerBoundRange(49,51);
        Assert.assertEquals(vent.getLowerBoundStart(), 49);
        Assert.assertEquals(vent.getLowerBoundEnd(), 51);
    }

    public void setLowerBoundRangeCapTest() {
        VentStatus vent = new VentStatus('A');
        vent.setLowerBoundRange(VentStatus.MIN_VENT_VALUE-1, VentStatus.MAX_VENT_VALUE+1);
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), VentStatus.MAX_VENT_VALUE);
    }

    public void setUpperBoundRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setUpperBoundRange(49,51);
        Assert.assertEquals(vent.getUpperBoundStart(), 49);
        Assert.assertEquals(vent.getUpperBoundEnd(), 51);
    }

    public void setUpperBoundRangeCapTest() {
        VentStatus vent = new VentStatus('A');
        vent.setUpperBoundRange(VentStatus.MIN_VENT_VALUE-1, VentStatus.MAX_VENT_VALUE+1);
        Assert.assertEquals(vent.getUpperBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_VENT_VALUE);
    }

    public void isLowerBoundWithinRange() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setLowerBoundRange(35,50);
        //Actually out of range
        Assert.assertFalse(vent.isLowerBoundWithinRange(10, 34));
        Assert.assertFalse(vent.isLowerBoundWithinRange(51, 76));
        //Partially in range
        Assert.assertTrue(vent.isLowerBoundWithinRange(10, 35));
        Assert.assertTrue(vent.isLowerBoundWithinRange(50, 76));
        //Within the range
        Assert.assertTrue(vent.isLowerBoundWithinRange(40, 45));
        Assert.assertTrue(vent.isLowerBoundWithinRange(20, 55));
    }

    public void isUpperBoundWithinRange() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setUpperBoundRange(35,50);
        //Actually out of range
        Assert.assertFalse(vent.isUpperBoundWithinRange(10, 34));
        Assert.assertFalse(vent.isUpperBoundWithinRange(51, 76));
        //Partially in range
        Assert.assertTrue(vent.isUpperBoundWithinRange(10, 35));
        Assert.assertTrue(vent.isUpperBoundWithinRange(50, 76));
        //Within the range
        Assert.assertTrue(vent.isUpperBoundWithinRange(40, 45));
        Assert.assertTrue(vent.isUpperBoundWithinRange(20, 55));
    }

    public void setLowerBoundRangeMergeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setUpperBoundRange(50,65);
        vent.setLowerBoundRange(35,50);
        Assert.assertEquals(vent.getLowerBoundStart(), 35);
        Assert.assertEquals(vent.getLowerBoundEnd(), 65);
        Assert.assertEquals(vent.getUpperBoundStart(), 35);
        Assert.assertEquals(vent.getUpperBoundEnd(), 65);
    }

    public void setUpperBoundRangeMergeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setLowerBoundRange(35,50);
        vent.setUpperBoundRange(50,65);
        Assert.assertEquals(vent.getLowerBoundStart(), 35);
        Assert.assertEquals(vent.getLowerBoundEnd(), 65);
        Assert.assertEquals(vent.getUpperBoundStart(), 35);
        Assert.assertEquals(vent.getUpperBoundEnd(), 65);
    }

    public void updateTest() {
        VentStatus vent = new VentStatus('A');

        //Predicted ranges should be unchanged when vent isnt identified
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(60, 60);
        vent.setUpperBoundRange(60, 60);
        vent.makeFreezeClipAccurate();
        Assert.assertFalse(vent.isIdentified());
        Assert.assertEquals(vent.getActualValue(), VentStatus.STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getDirection(), 1);
        Assert.assertEquals(vent.getLowerBoundStart(), 60);
        Assert.assertEquals(vent.getLowerBoundEnd(), 60);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 60);
        Assert.assertTrue(vent.isFreezeClipAccurate());

        //Otherwise will change
        vent.update(60, 1);
        Assert.assertTrue(vent.isIdentified());
        Assert.assertEquals(vent.getActualValue(), 60);
        Assert.assertEquals(vent.getDirection(), 1);
        Assert.assertEquals(vent.getLowerBoundStart(), 60);
        Assert.assertEquals(vent.getLowerBoundEnd(), 60);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 60);
        Assert.assertFalse(vent.isFreezeClipAccurate());
    }

    public void updateDifferenceTest() {
        VentStatus vent = new VentStatus('A');
        //Unidentified Tests
        //No change state returned for the very first update
        Assert.assertEquals(vent.update(VentStatus.STARTING_VENT_VALUE, 1), 0);
        //Nothing changed from the previous update
        Assert.assertEquals(vent.update(VentStatus.STARTING_VENT_VALUE, 1), 0);
        //Direction was changed here
        Assert.assertEquals(vent.update(VentStatus.STARTING_VENT_VALUE, -1), VentStatus.VentChangeStateFlag.DIRECTION_CHANGE.bitFlag());

        //Identified tests
        //Vent was just identified
        Assert.assertEquals(vent.update(100, -1), VentStatus.VentChangeStateFlag.IDENTIFIED.bitFlag());
        //Vent was unidentified (reset)
        Assert.assertEquals(vent.update(VentStatus.STARTING_VENT_VALUE, -1), VentStatus.VentChangeStateFlag.RESET.bitFlag());
        //Vent was just identified and direction changed
        Assert.assertEquals(vent.update(100, 1),
                VentStatus.VentChangeStateFlag.IDENTIFIED.bitFlag() + VentStatus.VentChangeStateFlag.DIRECTION_CHANGE.bitFlag());

        //Bounded tests
        //Vent must be bounded so no change state
        Assert.assertEquals(vent.update(100, 1), 0);
        //Direction has changed and vent cannot be bounded
        Assert.assertEquals(vent.update(100, -1),
                VentStatus.VentChangeStateFlag.NO_CHANGE.bitFlag() + VentStatus.VentChangeStateFlag.DIRECTION_CHANGE.bitFlag());
        vent.update(0, -1);
        //Vent must be bounded so no change state
        Assert.assertEquals(vent.update(0, -1), 0);
        //Direction has changed and vent cannot be bounded
        Assert.assertEquals(vent.update(0, 1),
                VentStatus.VentChangeStateFlag.NO_CHANGE.bitFlag() + VentStatus.VentChangeStateFlag.DIRECTION_CHANGE.bitFlag());
        vent.update(0, 1);

        //Increase of 1
        Assert.assertEquals(vent.update(1, 1), VentStatus.VentChangeStateFlag.ONE_CHANGE.bitFlag());
        //Decrease of 1
        Assert.assertEquals(vent.update(0, 1), VentStatus.VentChangeStateFlag.ONE_CHANGE.bitFlag());
        //Increase of 2
        Assert.assertEquals(vent.update(2, 1), VentStatus.VentChangeStateFlag.TWO_CHANGE.bitFlag());
        //Decrease of 2
        Assert.assertEquals(vent.update(0, 1), VentStatus.VentChangeStateFlag.TWO_CHANGE.bitFlag());

        //No change
        vent.update(50, 1);
        Assert.assertEquals(vent.update(50, 1), VentStatus.VentChangeStateFlag.NO_CHANGE.bitFlag());
        //Vent became unidentified and direction changed
        Assert.assertEquals(vent.update(VentStatus.STARTING_VENT_VALUE, -1),
                VentStatus.VentChangeStateFlag.RESET.bitFlag() | VentStatus.VentChangeStateFlag.DIRECTION_CHANGE.bitFlag());
    }

    public void updateMovementInvalidTest() {
        VentStatus vent = new VentStatus('A');
        //Nothing should change if the vent is identified
        vent.update(VentStatus.PERFECT_VENT_VALUE, 1);
        vent.updateMovement(new int[]{0, 0});
        //Ranges
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.PERFECT_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), VentStatus.PERFECT_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundStart(), VentStatus.PERFECT_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.PERFECT_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE);

        //Nothing should change if range is undefined
        vent.clearRanges();
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.updateMovement(new int[]{0, 0});
        //Ranges
        Assert.assertFalse(vent.isRangeDefined());
        //Total bounds should always update
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_STARTING_VENT_VALUE+VentStatus.BASE_MOVE_RATE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_STARTING_VENT_VALUE+VentStatus.BASE_MOVE_RATE);
    }

    public void updateMovementRangeTest() {
        //Ranges should be updated and capped at 100%
        VentStatus vent = new VentStatus('A');
        vent.doVMReset();
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(VentStatus.MIN_VENT_VALUE, 3);
        vent.setUpperBoundRange(97, VentStatus.MAX_VENT_VALUE);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_VENT_VALUE+1);
        Assert.assertEquals(vent.getLowerBoundEnd(), 4);
        Assert.assertEquals(vent.getUpperBoundStart(), 98);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE+1);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE);

        //Ranges should be updated and capped at 0%
        vent.doVMReset();
        vent.update(VentStatus.STARTING_VENT_VALUE, -1);
        vent.clearRanges();
        vent.setLowerBoundRange(VentStatus.MIN_VENT_VALUE, 3);
        vent.setUpperBoundRange(97, VentStatus.MAX_VENT_VALUE);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), 2);
        Assert.assertEquals(vent.getUpperBoundStart(), 96);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_VENT_VALUE-1);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE-1);

        //Ranges should merge and move properly
        vent.doVMReset();
        vent.clearRanges();
        vent.setLowerBoundRange(47, VentStatus.PERFECT_VENT_VALUE);
        vent.setUpperBoundRange(VentStatus.PERFECT_VENT_VALUE, 53);
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 46);
        Assert.assertEquals(vent.getLowerBoundEnd(), 52);
        Assert.assertEquals(vent.getUpperBoundStart(), 46);
        Assert.assertEquals(vent.getUpperBoundEnd(), 52);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE-VentStatus.BASE_MOVE_RATE);

        //Ranges should merge and move properly even max ranges
        vent.doVMReset();
        vent.clearRanges();
        vent.setLowerBoundRange(VentStatus.MIN_VENT_VALUE, VentStatus.PERFECT_VENT_VALUE);
        vent.setUpperBoundRange(VentStatus.PERFECT_VENT_VALUE, VentStatus.MAX_VENT_VALUE);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), VentStatus.MAX_VENT_VALUE-1);
        Assert.assertEquals(vent.getUpperBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_VENT_VALUE-1);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE-1);
    }

    public void updateMovementRangeFrozenTest() {
        //Ranges should not be updated if frozen
        VentStatus vent = new VentStatus('C');
        vent.doVMReset();
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(VentStatus.MIN_VENT_VALUE, 3);
        vent.setUpperBoundRange(97, VentStatus.MAX_VENT_VALUE);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getLowerBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getLowerBoundEnd(), 3);
        Assert.assertEquals(vent.getUpperBoundStart(), 97);
        Assert.assertEquals(vent.getUpperBoundEnd(), VentStatus.MAX_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE);

        //Since ranges are within 41-59% there is an additional influence
        //making this -2
        vent.doVMReset();
        vent.clearRanges();
        vent.setLowerBoundRange(41, 45);
        vent.setUpperBoundRange(55, 59);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 45);
        Assert.assertEquals(vent.getUpperBoundStart(), 55);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE+1);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE);

        //Test for -3 influence it should still be 0 movement
        vent.doVMReset();
        vent.clearRanges();
        vent.setLowerBoundRange(41, 45);
        vent.setUpperBoundRange(55, 59);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 45);
        Assert.assertEquals(vent.getUpperBoundStart(), 55);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);
        Assert.assertEquals(vent.getTotalBoundStart(), VentStatus.MIN_VENT_VALUE);
        Assert.assertEquals(vent.getTotalBoundEnd(), VentStatus.MAX_VENT_VALUE);
    }

    public void updateMovementRangeDifferentMoveTest() {
        VentStatus vent = new VentStatus('C');
        //Lower bound start + upper bound end are out of freeze range
        vent.update(VentStatus.STARTING_VENT_VALUE, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(40, 45);
        vent.setUpperBoundRange(55, 60);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 45);
        Assert.assertEquals(vent.getUpperBoundStart(), 55);
        Assert.assertEquals(vent.getUpperBoundEnd(), 61);

        //Upper bound start and end are out of freeze range
        vent.clearRanges();
        vent.setLowerBoundRange(41, 45);
        vent.setUpperBoundRange(60, 62);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 45);
        Assert.assertEquals(vent.getUpperBoundStart(), 61);
        Assert.assertEquals(vent.getUpperBoundEnd(), 63);

        //Lower bound start and end are out of freeze range
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(55, 59);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 39);
        Assert.assertEquals(vent.getLowerBoundEnd(), 41);
        Assert.assertEquals(vent.getUpperBoundStart(), 55);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);
    }

    public void updateEstimatedMovementInfluenceTest() {
        VentStatus vent = new VentStatus('C');

        //Undefined range case
        int[] influenceAmount = new int[]{0, 0};
        vent.updateEstimatedMovementInfluence(influenceAmount);
        Assert.assertEquals(influenceAmount[0], -1);
        Assert.assertEquals(influenceAmount[1], 0);

        //Impossible case - defaults to 0
        influenceAmount = new int[]{0, 0};
        vent.setLowerBoundRange(-10, -1);
        vent.setUpperBoundRange(-10, -1);
        vent.updateEstimatedMovementInfluence(influenceAmount);
        Assert.assertEquals(influenceAmount[0], 0);
        Assert.assertEquals(influenceAmount[1], 0);

        //No influence case
        influenceAmount = new int[]{0, 0};
        vent.setLowerBoundRange(0, 20);
        vent.setUpperBoundRange(0, 20);
        vent.updateEstimatedMovementInfluence(influenceAmount);
        Assert.assertEquals(influenceAmount[0], 0);
        Assert.assertEquals(influenceAmount[1], 0);

        //Only influence case
        influenceAmount = new int[]{0, 0};
        vent.setLowerBoundRange(43, 45);
        vent.setUpperBoundRange(43, 45);
        vent.updateEstimatedMovementInfluence(influenceAmount);
        Assert.assertEquals(influenceAmount[0], -1);
        Assert.assertEquals(influenceAmount[1], -1);

        //Both influence case
        influenceAmount = new int[]{0, 0};
        vent.setLowerBoundRange(38, 45);
        vent.setUpperBoundRange(38, 45);
        vent.updateEstimatedMovementInfluence(influenceAmount);
        Assert.assertEquals(influenceAmount[0], -1);
        Assert.assertEquals(influenceAmount[1], 0);
    }

    public void updateMovementPossibilitiesTest() {
        VentStatus vent = new VentStatus('C');

        //0 Min influence tests
        //Upward movement
        vent.update(u, 1);

        //Vents should move up by 1
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 43);
        Assert.assertEquals(vent.getUpperBoundStart(), 43);
        Assert.assertEquals(vent.getLowerBoundEnd(), 45);
        Assert.assertEquals(vent.getUpperBoundEnd(), 45);

        //Vents should move up by 2
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 40);
        Assert.assertEquals(vent.getLowerBoundEnd(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 42);

        //Downward movement
        vent.update(u, -1);

        //Vents should move down by 1
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getUpperBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 43);
        Assert.assertEquals(vent.getUpperBoundEnd(), 43);

        //Vents should move down by 2
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 36);
        Assert.assertEquals(vent.getUpperBoundStart(), 36);
        Assert.assertEquals(vent.getLowerBoundEnd(), 38);
        Assert.assertEquals(vent.getUpperBoundEnd(), 38);



        //-1 Min influence tests
        //Upward movement
        vent.update(u, 1);

        //Vents should move up by 0
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move up by 1
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 39);
        Assert.assertEquals(vent.getUpperBoundStart(), 39);
        Assert.assertEquals(vent.getLowerBoundEnd(), 41);
        Assert.assertEquals(vent.getUpperBoundEnd(), 41);

        //Vents should move up by 0 and 1
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-1, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 45);
        Assert.assertEquals(vent.getUpperBoundEnd(), 45);

        //Vents should move up by 1 and 2
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-1, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 39);
        Assert.assertEquals(vent.getUpperBoundStart(), 39);
        Assert.assertEquals(vent.getLowerBoundEnd(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 42);

        //Downward movement
        vent.update(u, -1);

        //Vents should move down by 0
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move down by 1
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 37);
        Assert.assertEquals(vent.getUpperBoundStart(), 37);
        Assert.assertEquals(vent.getLowerBoundEnd(), 39);
        Assert.assertEquals(vent.getUpperBoundEnd(), 39);

        //Vents should move down by 0 and 1
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-1, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getUpperBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move down by 1 and 2
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-1, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 36);
        Assert.assertEquals(vent.getUpperBoundStart(), 36);
        Assert.assertEquals(vent.getLowerBoundEnd(), 39);
        Assert.assertEquals(vent.getUpperBoundEnd(), 39);



        //-2 Min influence tests
        //Upward movement
        vent.update(u, 1);

        //Vents should move up by 0
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move up by 0
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getUpperBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);

        //Vents should move up by 0
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-2, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move up by 0 and 1
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-2, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getUpperBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 41);
        Assert.assertEquals(vent.getUpperBoundEnd(), 41);

        //Vents should move up by 0 and 1
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-2, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 45);
        Assert.assertEquals(vent.getUpperBoundEnd(), 45);

        //Vents should move up by 0 and 2
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-2, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getUpperBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 42);

        //Downward movement
        vent.update(u, -1);

        //Vents should move down by 0
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move down by 0
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getUpperBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);

        //Vents should move down by 0
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-2, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move down by 0 and 1
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-2, -1});
        Assert.assertEquals(vent.getLowerBoundStart(), 37);
        Assert.assertEquals(vent.getUpperBoundStart(), 37);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);

        //Vents should move down by 0 and 1
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(42, 44);
        vent.updateMovement(new int[]{-2, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getUpperBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);

        //Vents should move down by 0 and 2
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.updateMovement(new int[]{-2, 0});
        Assert.assertEquals(vent.getLowerBoundStart(), 36);
        Assert.assertEquals(vent.getUpperBoundStart(), 36);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);
    }

    public void updateMovementTotalBoundPossibilitiesTest() {
        //18-58
        VentStatus downwardVent = new VentStatus('C');
        downwardVent.update(u, -1);
        for(int i = 0; i < 6; ++i) downwardVent.updateMovement(new int[]{0, 0});

        //42-82
        VentStatus upwardVent = new VentStatus('C');
        upwardVent.update(u, 1);
        for(int i = 0; i < 6; ++i) upwardVent.updateMovement(new int[]{0, 0});

        //0 Min influence tests
        //Upward movement

        //boundStart should move by 1
        //boundEnd should move by 2
        VentStatus vent = new VentStatus(upwardVent);
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getTotalBoundStart(), 43);
        Assert.assertEquals(vent.getTotalBoundEnd(), 84);

        //Downward movement

        //boundStart should move by 2
        //boundEnd should move by 1
        vent = new VentStatus(downwardVent);
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getTotalBoundStart(), 16);
        Assert.assertEquals(vent.getTotalBoundEnd(), 57);


        //-1 Min influence tests
        //Upward movement

        //boundStart should move by 0
        //boundEnd should move by 1
        vent = new VentStatus(upwardVent);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getTotalBoundStart(), 42);
        Assert.assertEquals(vent.getTotalBoundEnd(), 83);

        //boundStart should move by 0
        //boundEnd should move by 2
        vent = new VentStatus(upwardVent);
        vent.updateMovement(new int[]{-1, 0});
        Assert.assertEquals(vent.getTotalBoundStart(), 42);
        Assert.assertEquals(vent.getTotalBoundEnd(), 84);

        //Downward movement

        //boundStart should move by 1
        //boundEnd should move by 0
        vent = new VentStatus(downwardVent);
        vent.updateMovement(new int[]{-1, -1});
        Assert.assertEquals(vent.getTotalBoundStart(), 17);
        Assert.assertEquals(vent.getTotalBoundEnd(), 58);

        //boundStart should move by 2
        //boundEnd should move by 0
        vent = new VentStatus(downwardVent);
        vent.updateMovement(new int[]{-1, 0});
        Assert.assertEquals(vent.getTotalBoundStart(), 16);
        Assert.assertEquals(vent.getTotalBoundEnd(), 58);


        //-2 Min influence tests
        //Upward movement

        //boundStart should move by 0
        //boundEnd should move by 0
        vent = new VentStatus(upwardVent);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getTotalBoundStart(), 42);
        Assert.assertEquals(vent.getTotalBoundEnd(), 82);

        //boundStart should move by 0
        //boundEnd should move by 1
        vent = new VentStatus(upwardVent);
        vent.updateMovement(new int[]{-2, -1});
        Assert.assertEquals(vent.getTotalBoundStart(), 42);
        Assert.assertEquals(vent.getTotalBoundEnd(), 83);

        //boundStart should move by 0
        //boundEnd should move by 2
        vent = new VentStatus(upwardVent);
        vent.updateMovement(new int[]{-2, 0});
        Assert.assertEquals(vent.getTotalBoundStart(), 42);
        Assert.assertEquals(vent.getTotalBoundEnd(), 84);

        //Downward movement

        //boundStart should move by 0
        //boundEnd should move by 0
        vent = new VentStatus(downwardVent);
        vent.updateMovement(new int[]{-2, -2});
        Assert.assertEquals(vent.getTotalBoundStart(), 18);
        Assert.assertEquals(vent.getTotalBoundEnd(), 58);

        //boundStart should move by 1
        //boundEnd should move by 0
        vent = new VentStatus(downwardVent);
        vent.updateMovement(new int[]{-2, -1});
        Assert.assertEquals(vent.getTotalBoundStart(), 17);
        Assert.assertEquals(vent.getTotalBoundEnd(), 58);

        //boundStart should move by 2
        //boundEnd should move by 0
        vent = new VentStatus(downwardVent);
        vent.updateMovement(new int[]{-2, 0});
        Assert.assertEquals(vent.getTotalBoundStart(), 16);
        Assert.assertEquals(vent.getTotalBoundEnd(), 58);
    }

    public void isRangeDefinedTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        Assert.assertFalse(vent.isRangeDefined());
        vent.setLowerBoundRange(40, 45);
        Assert.assertFalse(vent.isRangeDefined());
        vent.setUpperBoundRange(55, 60);
        Assert.assertTrue(vent.isRangeDefined());
    }

    public void clearRangesTest() {
        VentStatus vent = new VentStatus('A');
        vent.setLowerBoundRange(40, 45);
        vent.setUpperBoundRange(40, 45);
        Assert.assertTrue(vent.isRangeDefined());
        vent.clearRanges();
        Assert.assertFalse(vent.isRangeDefined());
    }

    public void isTwoSeperateValuesTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        Assert.assertFalse(vent.isTwoSeperateValues());
        vent.setLowerBoundRange(40, 45);
        Assert.assertTrue(vent.isTwoSeperateValues());
        vent.setUpperBoundRange(40, 45);
        Assert.assertFalse(vent.isTwoSeperateValues());
    }

    public void isLowerBoundSingleValueTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        Assert.assertTrue(vent.isLowerBoundSingleValue());
        vent.setLowerBoundRange(40, 45);
        Assert.assertFalse(vent.isLowerBoundSingleValue());
        vent.setLowerBoundRange(45, 45);
        Assert.assertTrue(vent.isLowerBoundSingleValue());
    }

    public void isUpperBoundSingleValueTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        Assert.assertTrue(vent.isUpperBoundSingleValue());
        vent.setUpperBoundRange(50, 55);
        Assert.assertFalse(vent.isUpperBoundSingleValue());
        vent.setUpperBoundRange(55, 55);
        Assert.assertTrue(vent.isUpperBoundSingleValue());
    }

    public void isWithinRangeLowerTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setLowerBoundRange(35,50);
        //Actually out of range
        Assert.assertFalse(vent.isWithinRange(10, 34));
        Assert.assertFalse(vent.isWithinRange(51, 76));
        //Partially in range
        Assert.assertTrue(vent.isWithinRange(10, 35));
        Assert.assertTrue(vent.isWithinRange(50, 76));
        //Within the range
        Assert.assertTrue(vent.isWithinRange(40, 45));
        Assert.assertTrue(vent.isWithinRange(20, 55));
    }

    public void isWithinRangeUpperTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setUpperBoundRange(35,50);
        //Actually out of range
        Assert.assertFalse(vent.isWithinRange(10, 34));
        Assert.assertFalse(vent.isWithinRange(51, 76));
        //Partially in range
        Assert.assertTrue(vent.isWithinRange(10, 35));
        Assert.assertTrue(vent.isWithinRange(50, 76));
        //Within the range
        Assert.assertTrue(vent.isWithinRange(40, 45));
        Assert.assertTrue(vent.isWithinRange(20, 55));
    }

    public void isWithinRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setLowerBoundRange(35,45);
        vent.setUpperBoundRange(55,60);
        //Out of range
        Assert.assertFalse(vent.isWithinRange(10, 34));
        Assert.assertFalse(vent.isWithinRange(61, 90));
        //Inbetween both ranges
        Assert.assertFalse(vent.isWithinRange(46, 54));
        //Within one but not the other
        Assert.assertTrue(vent.isWithinRange(10, 35));
        Assert.assertTrue(vent.isWithinRange(59, 90));
        //Within both
        Assert.assertTrue(vent.isWithinRange(45, 55));
        Assert.assertTrue(vent.isWithinRange(VentStatus.MIN_VENT_VALUE - 1, VentStatus.MAX_VENT_VALUE + 1));
    }

    public void getOverlappedLowerBoundRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setLowerBoundRange(35,45);
        //Start is lower
        int[] ans = vent.getOverlappedLowerBoundRange(30, 45);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //End is higher
        ans = vent.getOverlappedLowerBoundRange(35, 50);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Range is greater
        ans = vent.getOverlappedLowerBoundRange(30, 50);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Start is higher
        ans = vent.getOverlappedLowerBoundRange(40, 45);
        Assert.assertEquals(ans[0], 40);
        Assert.assertEquals(ans[1], 45);
        //End is lower
        ans = vent.getOverlappedLowerBoundRange(35, 40);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 40);
        //Both are within bounds
        ans = vent.getOverlappedLowerBoundRange(40, 40);
        Assert.assertEquals(ans[0], 40);
        Assert.assertEquals(ans[1], 40);
        //Out of bounds
        ans = vent.getOverlappedLowerBoundRange(25, 30);
        Assert.assertEquals(ans[0], -1);
        Assert.assertEquals(ans[1], -1);
    }

    public void getOverlappedUpperBoundRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setUpperBoundRange(35,45);
        //Start is lower
        int[] ans = vent.getOverlappedUpperBoundRange(30, 45);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //End is higher
        ans = vent.getOverlappedUpperBoundRange(35, 50);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Range is greater
        ans = vent.getOverlappedUpperBoundRange(30, 50);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Start is higher
        ans = vent.getOverlappedUpperBoundRange(40, 45);
        Assert.assertEquals(ans[0], 40);
        Assert.assertEquals(ans[1], 45);
        //End is lower
        ans = vent.getOverlappedUpperBoundRange(35, 40);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 40);
        //Both are within bounds
        ans = vent.getOverlappedUpperBoundRange(40, 40);
        Assert.assertEquals(ans[0], 40);
        Assert.assertEquals(ans[1], 40);
        //Out of bounds
        ans = vent.getOverlappedUpperBoundRange(25, 30);
        Assert.assertEquals(ans[0], -1);
        Assert.assertEquals(ans[1], -1);
    }

    public void getOutsideLowerBoundRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setLowerBoundRange(35,45);
        //Start is lower
        int[] ans = vent.getOutsideLowerBoundRange(40, 45);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 39);
        //End is higher
        ans = vent.getOutsideLowerBoundRange(35, 40);
        Assert.assertEquals(ans[0], 41);
        Assert.assertEquals(ans[1], 45);
        //Range completely overlaps
        ans = vent.getOutsideLowerBoundRange(35, 45);
        Assert.assertEquals(ans[0], -1);
        Assert.assertEquals(ans[1], -1);
        //Out of bounds - Start is higher
        ans = vent.getOutsideLowerBoundRange(25, 30);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Out of bounds - End is lower
        ans = vent.getOutsideLowerBoundRange(50, 55);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Range is within bounds
        ans = vent.getOutsideLowerBoundRange(38, 42);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
    }

    public void getOutsideUpperBoundRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.setUpperBoundRange(35,45);
        //Start is lower
        int[] ans = vent.getOutsideUpperBoundRange(40, 45);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 39);
        //End is higher
        ans = vent.getOutsideUpperBoundRange(35, 40);
        Assert.assertEquals(ans[0], 41);
        Assert.assertEquals(ans[1], 45);
        //Range completely overlaps
        ans = vent.getOutsideUpperBoundRange(35, 45);
        Assert.assertEquals(ans[0], -1);
        Assert.assertEquals(ans[1], -1);
        //Out of bounds - Start is higher
        ans = vent.getOutsideUpperBoundRange(25, 30);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Out of bounds - End is lower
        ans = vent.getOutsideUpperBoundRange(50, 55);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
        //Range is within bounds
        ans = vent.getOutsideUpperBoundRange(38, 42);
        Assert.assertEquals(ans[0], 35);
        Assert.assertEquals(ans[1], 45);
    }

    public void doInnerBoundsClippingTest() {
        //Only test case is 41-59
        VentStatus vent = new VentStatus('A');

        //Both are out of bounds
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(60, 62);
        vent.doInnerBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), u);
        Assert.assertEquals(vent.getLowerBoundEnd(), u);
        Assert.assertEquals(vent.getUpperBoundStart(), u);
        Assert.assertEquals(vent.getUpperBoundEnd(), u);

        //Only lower bound is in bounds
        vent.clearRanges();
        vent.setLowerBoundRange(41, 43);
        vent.setUpperBoundRange(63, 65);
        vent.doInnerBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 43);
        Assert.assertEquals(vent.getUpperBoundStart(), 41);
        Assert.assertEquals(vent.getUpperBoundEnd(), 43);

        //Only upper bound is in bounds
        vent.clearRanges();
        vent.setLowerBoundRange(35, 37);
        vent.setUpperBoundRange(57, 59);
        vent.doInnerBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 57);
        Assert.assertEquals(vent.getLowerBoundEnd(), 59);
        Assert.assertEquals(vent.getUpperBoundStart(), 57);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);

        //Both are in bounds
        vent.clearRanges();
        vent.setLowerBoundRange(41, 43);
        vent.setUpperBoundRange(57, 59);
        vent.doInnerBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 43);
        Assert.assertEquals(vent.getUpperBoundStart(), 57);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);
    }

    public void doOuterBoundsClippingTest() {
        //Only test case is 41-59
        VentStatus vent = new VentStatus('A');

        //Both are out of bounds
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(60, 62);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 62);

        //Only lower bound is in bounds
        vent.clearRanges();
        vent.setLowerBoundRange(41, 43);
        vent.setUpperBoundRange(63, 65);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 63);
        Assert.assertEquals(vent.getLowerBoundEnd(), 65);
        Assert.assertEquals(vent.getUpperBoundStart(), 63);
        Assert.assertEquals(vent.getUpperBoundEnd(), 65);

        //Only upper bound is in bounds
        vent.clearRanges();
        vent.setLowerBoundRange(35, 37);
        vent.setUpperBoundRange(57, 59);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 35);
        Assert.assertEquals(vent.getLowerBoundEnd(), 37);
        Assert.assertEquals(vent.getUpperBoundStart(), 35);
        Assert.assertEquals(vent.getUpperBoundEnd(), 37);

        //Both are in bounds
        vent.clearRanges();
        vent.setLowerBoundRange(41, 43);
        vent.setUpperBoundRange(57, 59);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), u);
        Assert.assertEquals(vent.getLowerBoundEnd(), u);
        Assert.assertEquals(vent.getUpperBoundStart(), u);
        Assert.assertEquals(vent.getUpperBoundEnd(), u);
    }

    public void doOuterBoundsSingleRangeClippingTest() {
        //Only test case is 41-59
        VentStatus vent = new VentStatus('A');

        //Range is lower than our clipping
        vent.clearRanges();
        vent.setLowerBoundRange(38, 40);
        vent.setUpperBoundRange(38, 40);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 38);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);

        //Range is higher than our clipping
        vent.clearRanges();
        vent.setLowerBoundRange(60, 62);
        vent.setUpperBoundRange(60, 62);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 60);
        Assert.assertEquals(vent.getLowerBoundEnd(), 62);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 62);

        //Range is inside of clipping
        vent.clearRanges();
        vent.setLowerBoundRange(41, 59);
        vent.setUpperBoundRange(41, 59);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), u);
        Assert.assertEquals(vent.getLowerBoundEnd(), u);
        Assert.assertEquals(vent.getUpperBoundStart(), u);
        Assert.assertEquals(vent.getUpperBoundEnd(), u);

        //Lower end range clipping - single value
        vent.clearRanges();
        vent.setLowerBoundRange(41, 60);
        vent.setUpperBoundRange(41, 60);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 60);
        Assert.assertEquals(vent.getLowerBoundEnd(), 60);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 60);

        //Lower end range clipping - range
        vent.clearRanges();
        vent.setLowerBoundRange(41, 62);
        vent.setUpperBoundRange(41, 62);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 60);
        Assert.assertEquals(vent.getLowerBoundEnd(), 62);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 62);

        //Upper end range clipping - single value
        vent.clearRanges();
        vent.setLowerBoundRange(40, 59);
        vent.setUpperBoundRange(40, 59);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 40);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 40);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);

        //Upper end range clipping - range
        vent.setLowerBoundRange(38, 59);
        vent.setUpperBoundRange(38, 59);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 38);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);

        //Breaking single range
        vent.setLowerBoundRange(38, 62);
        vent.setUpperBoundRange(38, 62);
        vent.doOuterBoundsClipping(41, 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 38);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 62);
    }

    public void getReversedInfluenceATest() {
        VentStatus vent = new VentStatus('A');

        //Unidentified vent
        vent.clearRanges();
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);

        //Cannot reverse bounded values
        vent.update(0, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);
        vent.update(0, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);
        vent.update(100, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);
        vent.update(100, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);

        //Non Freeze range A
        vent.update(60, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);
        vent.update(40, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);

        //Freeze range A
        vent.update(40, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);
        vent.update(41, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);
        vent.update(59, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);
        vent.update(60, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);

        //Freeze - non-freeze mismatch A
        //only 39 -> 41 is possible; 40 -> 42
        vent.update(41, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);
        //40 -> 42 or 41 -> 42 is possible
        vent.update(42, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);
        //60 -> 58 or 59 -> 58 is possible
        vent.update(58, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);
        //only 61 -> 59 is possible; 60 -> 58
        vent.update(59, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);

        //Impossible reverses
        //60 -> 62 and 59 -> 60; blocked 61 is impossible to reverse
        vent.update(61, 1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);
        //40 -> 38 and 41 -> 40; unblocked 39 is impossible to reverse
        vent.update(39, -1);
        Assert.assertEquals(vent.getReversedInfluence(0), VentStatus.STARTING_VENT_VALUE);
    }

    public void getReversedInfluenceBTest() {
        VentStatus vent = new VentStatus('B');

        //We will assume A is in freeze range otherwise same result as above test(s)
        //Unidentified vent
        vent.clearRanges();
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);

        //Cannot reverse bounded values
        vent.update(0, -1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);
        vent.update(0, 1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);
        vent.update(100, -1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);
        vent.update(100, 1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);

        //Non Freeze range B
        vent.update(60, -1);
        Assert.assertEquals(vent.getReversedInfluence(-1), 0);
        vent.update(40, 1);
        Assert.assertEquals(vent.getReversedInfluence(-1), 0);

        //Freeze range B
        vent.update(41, -1);
        Assert.assertEquals(vent.getReversedInfluence(-1), -1);
        vent.update(59, 1);
        Assert.assertEquals(vent.getReversedInfluence(-1), -1);

        //Impossible reverses
        //40 -> 41 and 41 -> 41; blocked 41 is impossible to reverse
        vent.update(41, 1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);
        //60 -> 59 and 59 -> 59; unblocked 59 is impossible to reverse
        vent.update(59, -1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);
        //59 -> 59; blocked 60 cannot come from anywhere
        vent.update(60, 1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);
        //41 -> 41; unblocked 40 cannot come from anywhere
        vent.update(40, -1);
        Assert.assertEquals(vent.getReversedInfluence(-1), VentStatus.STARTING_VENT_VALUE);
    }

    public void getReversedInfluenceCTest() {
        VentStatus vent = new VentStatus('C');

        //We will assume A and B are in freeze range otherwise same result as above test(s)
        //Unidentified vent
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);

        //In this case we know bounded values stay the same
        vent.update(0, -1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);
        vent.update(0, 1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);
        vent.update(100, -1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);
        vent.update(100, 1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);

        //Non Freeze range C
        vent.update(60, -1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);
        vent.update(60, 1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);
        vent.update(40, 1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);
        vent.update(40, -1);
        Assert.assertEquals(vent.getReversedInfluence(-2), 0);

        //Freeze range C
        vent.update(41, -1);
        Assert.assertEquals(vent.getReversedInfluence(-2), -1);
        vent.update(41, 1);
        Assert.assertEquals(vent.getReversedInfluence(-2), -1);
        vent.update(59, 1);
        Assert.assertEquals(vent.getReversedInfluence(-2), -1);
        vent.update(59, -1);
        Assert.assertEquals(vent.getReversedInfluence(-2), -1);
    }

    public void getReversedInfluenceFreezeClipAccurateTest() {
        VentStatus vent = new VentStatus('A');

        //Downward accurate freeze clipped value
        vent.update(u, -1);
        vent.clearRanges();
        vent.setUpperBoundRange(40, 40);
        vent.setLowerBoundRange(40, 40);
        vent.makeFreezeClipAccurate();
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getReversedInfluence(0), 0);

        //Upward accurate freeze clipped value
        vent.update(u, 1);
        vent.clearRanges();
        vent.setUpperBoundRange(60, 60);
        vent.setLowerBoundRange(60, 60);
        vent.makeFreezeClipAccurate();
        vent.updateMovement(new int[]{0, 0});
        Assert.assertEquals(vent.getReversedInfluence(0), 0);
    }

    public void getReversedInfluenceSingleEstimatedRangeTest() {
        VentStatus vent = new VentStatus('A');
        vent.update(u, 1);

        //Huge single range test - both outside freeze range
        vent.clearRanges();
        vent.setLowerBoundRange(40, 60);
        vent.setUpperBoundRange(40, 60);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //Range influence mismatch tests
        vent.clearRanges();
        vent.setLowerBoundRange(41, 60);
        vent.setUpperBoundRange(41, 60);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        vent.clearRanges();
        vent.setLowerBoundRange(40, 59);
        vent.setUpperBoundRange(40, 59);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        vent.clearRanges();
        vent.setLowerBoundRange(41, 59);
        vent.setUpperBoundRange(41, 59);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //Single value tests - should always pass
        vent.clearRanges();
        vent.setLowerBoundRange(40, 40);
        vent.setUpperBoundRange(40, 40);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);

        vent.clearRanges();
        vent.setLowerBoundRange(60, 60);
        vent.setUpperBoundRange(60, 60);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);

        //Borderline lowerBoundStart test
        vent.clearRanges();
        vent.setLowerBoundRange(42, 45);
        vent.setUpperBoundRange(42, 45);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //Borderline lowerBoundEnd test
        vent.clearRanges();
        vent.setLowerBoundRange(57, 61);
        vent.setUpperBoundRange(57, 61);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //Valid range tests - should pass
        vent.clearRanges();
        vent.setLowerBoundRange(47, 53);
        vent.setUpperBoundRange(47, 53);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);

        vent.clearRanges();
        vent.setLowerBoundRange(65, 70);
        vent.setUpperBoundRange(65, 70);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);

        vent.clearRanges();
        vent.setLowerBoundRange(30, 35);
        vent.setUpperBoundRange(30, 35);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);
    }

    public void getReversedInfluenceTwoEstimatedRangesTest() {
        VentStatus vent = new VentStatus('A');
        vent.update(u, 1);

        //LowerBoundStart - frozen non-frozen mismatch test
        vent.clearRanges();
        vent.setLowerBoundRange(42, 44);
        vent.setUpperBoundRange(62, 66);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //LowerBoundEnd - frozen non-frozen mismatch test
        vent.clearRanges();
        vent.setLowerBoundRange(41, 42);
        vent.setUpperBoundRange(62, 66);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //LowerBound - influence mismatch test
        vent.clearRanges();
        vent.setLowerBoundRange(38, 43);
        vent.setUpperBoundRange(62, 66);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //UpperBoundStart - frozen non-frozen mismatch test
        vent.clearRanges();
        vent.setLowerBoundRange(43, 43);
        vent.setUpperBoundRange(61, 66);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //UpperBound and LowerBound - influence mismatch test
        vent.clearRanges();
        vent.setLowerBoundRange(43, 43);
        vent.setUpperBoundRange(62, 66);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //UpperBoundEnd - frozen non-frozen mismatch test
        vent.clearRanges();
        vent.setLowerBoundRange(43, 43);
        vent.setUpperBoundRange(57, 61);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //UpperBound - influence mismatch test
        vent.clearRanges();
        vent.setLowerBoundRange(43, 43);
        vent.setUpperBoundRange(57, 63);
        Assert.assertEquals(vent.getReversedInfluence(0), u);

        //0 influence match test
        vent.clearRanges();
        vent.setLowerBoundRange(38, 38);
        vent.setUpperBoundRange(62, 62);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);

        vent.setLowerBoundRange(36, 38);
        vent.setUpperBoundRange(62, 64);
        Assert.assertEquals(vent.getReversedInfluence(0), 0);

        //-1 influence match test
        vent.clearRanges();
        vent.setLowerBoundRange(43, 43);
        vent.setUpperBoundRange(57, 57);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);

        vent.setLowerBoundRange(43, 45);
        vent.setUpperBoundRange(55, 57);
        Assert.assertEquals(vent.getReversedInfluence(0), -1);
    }

    public void doReversedMovementInvalidTest() {
        VentStatus vent = new VentStatus('A');
        vent.clearRanges();
        vent.doReversedMovement(0);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), u);
        Assert.assertEquals(vent.getUpperBoundStart(), u);
        Assert.assertEquals(vent.getLowerBoundEnd(), u);
        Assert.assertEquals(vent.getUpperBoundEnd(), u);
    }

    public void doReversedMovementUnidentifiedTest() {
        VentStatus vent = new VentStatus('A');

        vent.update(u, -1);
        vent.doReversedMovement(0);
        Assert.assertEquals(vent.getLowerBoundStart(), 32);
        Assert.assertEquals(vent.getUpperBoundStart(), 32);
        Assert.assertEquals(vent.getLowerBoundEnd(), 72);
        Assert.assertEquals(vent.getUpperBoundEnd(), 72);

        vent.doReversedMovement(-1);
        Assert.assertEquals(vent.getLowerBoundStart(), 33);
        Assert.assertEquals(vent.getUpperBoundStart(), 33);
        Assert.assertEquals(vent.getLowerBoundEnd(), 73);
        Assert.assertEquals(vent.getUpperBoundEnd(), 73);

        vent.doReversedMovement(-2);
        Assert.assertEquals(vent.getLowerBoundStart(), 33);
        Assert.assertEquals(vent.getUpperBoundStart(), 33);
        Assert.assertEquals(vent.getLowerBoundEnd(), 73);
        Assert.assertEquals(vent.getUpperBoundEnd(), 73);
    }

    public void doReversedMovementBoundedTest() {
        StabilityUpdateInfo.setNumPlayers(2);
        VentStatus vent = new VentStatus('A');
        vent.doVMReset();
        vent.doReversedMovement(0);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), 0);
        Assert.assertEquals(vent.getUpperBoundStart(), 0);
        Assert.assertEquals(vent.getLowerBoundEnd(), 100);
        Assert.assertEquals(vent.getUpperBoundEnd(), 100);
        StabilityUpdateInfo.resetPlayers();
    }

    public void doReversedMovementIdentifiedTest() {
        VentStatus vent = new VentStatus('A');

        //Reverse upward
        vent.update(59, 1);
        vent.doReversedMovement(-2);
        Assert.assertEquals(vent.getActualValue(), 59);
        Assert.assertEquals(vent.getLowerBoundStart(), 59);
        Assert.assertEquals(vent.getUpperBoundStart(), 59);
        Assert.assertEquals(vent.getLowerBoundEnd(), 59);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);

        vent.doReversedMovement(-1);
        Assert.assertEquals(vent.getActualValue(), 58);
        Assert.assertEquals(vent.getLowerBoundStart(), 58);
        Assert.assertEquals(vent.getUpperBoundStart(), 58);
        Assert.assertEquals(vent.getLowerBoundEnd(), 58);
        Assert.assertEquals(vent.getUpperBoundEnd(), 58);

        vent.doReversedMovement(0);
        Assert.assertEquals(vent.getActualValue(), 56);
        Assert.assertEquals(vent.getLowerBoundStart(), 56);
        Assert.assertEquals(vent.getUpperBoundStart(), 56);
        Assert.assertEquals(vent.getLowerBoundEnd(), 56);
        Assert.assertEquals(vent.getUpperBoundEnd(), 56);


        //Reverse downward
        vent.update(41, -1);
        vent.doReversedMovement(-2);
        Assert.assertEquals(vent.getActualValue(), 41);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getUpperBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 41);
        Assert.assertEquals(vent.getUpperBoundEnd(), 41);

        vent.doReversedMovement(-1);
        Assert.assertEquals(vent.getActualValue(), 42);
        Assert.assertEquals(vent.getLowerBoundStart(), 42);
        Assert.assertEquals(vent.getUpperBoundStart(), 42);
        Assert.assertEquals(vent.getLowerBoundEnd(), 42);
        Assert.assertEquals(vent.getUpperBoundEnd(), 42);

        vent.doReversedMovement(0);
        Assert.assertEquals(vent.getActualValue(), 44);
        Assert.assertEquals(vent.getLowerBoundStart(), 44);
        Assert.assertEquals(vent.getUpperBoundStart(), 44);
        Assert.assertEquals(vent.getLowerBoundEnd(), 44);
        Assert.assertEquals(vent.getUpperBoundEnd(), 44);
    }

    public void doReversedMovementFreezeClipAccurateTest() {
        VentStatus vent = new VentStatus('A');

        //Reverse upward
        vent.update(u, 1);
        vent.clearRanges();
        vent.setLowerBoundRange(60, 60);
        vent.setUpperBoundRange(60, 60);
        vent.makeFreezeClipAccurate();

        vent.doReversedMovement(-2);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), 60);
        Assert.assertEquals(vent.getUpperBoundStart(), 60);
        Assert.assertEquals(vent.getLowerBoundEnd(), 60);
        Assert.assertEquals(vent.getUpperBoundEnd(), 60);

        vent.doReversedMovement(-1);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), 59);
        Assert.assertEquals(vent.getUpperBoundStart(), 59);
        Assert.assertEquals(vent.getLowerBoundEnd(), 59);
        Assert.assertEquals(vent.getUpperBoundEnd(), 59);

        vent.doReversedMovement(0);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), 57);
        Assert.assertEquals(vent.getUpperBoundStart(), 57);
        Assert.assertEquals(vent.getLowerBoundEnd(), 57);
        Assert.assertEquals(vent.getUpperBoundEnd(), 57);


        //Reverse downward
        vent.update(u, -1);
        vent.clearRanges();
        vent.setLowerBoundRange(40, 40);
        vent.setUpperBoundRange(40, 40);
        vent.makeFreezeClipAccurate();

        vent.doReversedMovement(-2);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), 40);
        Assert.assertEquals(vent.getUpperBoundStart(), 40);
        Assert.assertEquals(vent.getLowerBoundEnd(), 40);
        Assert.assertEquals(vent.getUpperBoundEnd(), 40);

        vent.doReversedMovement(-1);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), 41);
        Assert.assertEquals(vent.getUpperBoundStart(), 41);
        Assert.assertEquals(vent.getLowerBoundEnd(), 41);
        Assert.assertEquals(vent.getUpperBoundEnd(), 41);

        vent.doReversedMovement(0);
        Assert.assertEquals(vent.getActualValue(), u);
        Assert.assertEquals(vent.getLowerBoundStart(), 43);
        Assert.assertEquals(vent.getUpperBoundStart(), 43);
        Assert.assertEquals(vent.getLowerBoundEnd(), 43);
        Assert.assertEquals(vent.getUpperBoundEnd(), 43);
    }
}

package com.ultimatevm;

import org.testng.Assert;
import org.testng.annotations.Test;

import java.util.HashMap;

@Test()
public class VentStatusTimelineTest {
    int u = VentStatus.STARTING_VENT_VALUE;

    private void advanceTicks(VentStatusTimeline timeline, int numTicks) {
        for(int i = 0; i < numTicks; ++i) timeline.updateTick();
    }
    private int makeMoveBitState(int aMove, int bMove, int cMove) {
        int bitState = aMove | (bMove << 2) | (cMove << 4);
        return bitState << 6;
    }
    public void constructorTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        Assert.assertEquals(timeline.getCurrentTick(), 0);
        Assert.assertEquals(timeline.getCurrentStartingTick(), 0);
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 0);
        Assert.assertNotNull(timeline.getTimeline());
        Assert.assertNotNull(timeline.getMovementVentStates());
        Assert.assertNotNull(timeline.getStabilityUpdateStates());
        Assert.assertNotNull(timeline.getIdentifiedVentTicks());
        Assert.assertNotNull(timeline.getIdentifiedVentStates());
        Assert.assertNull(timeline.getInitialState());
        for(int i = 0; i < StatusState.NUM_VENTS+1; ++i) {
            Assert.assertEquals(timeline.getIdentifiedVentTicks()[i], -1);
            Assert.assertNull(timeline.getIdentifiedVentStates()[i]);
        }
    }

    public void initializeTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();

        timeline.addInitialState(new StatusState());
        timeline.addIdentifiedVentTick(new StatusState(), 1);
        timeline.addStabilityUpdateTick(new StatusState(), 23);
        timeline.updateTick();
        timeline.addMovementTick(new StatusState(), makeMoveBitState(0,0,0));

        //Everything should be reset back to starting values
        timeline.initialize();
        Assert.assertEquals(timeline.getCurrentTick(), 0);
        Assert.assertEquals(timeline.getCurrentStartingTick(), 0);
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 0);
        Assert.assertNull(timeline.getInitialState());
        Assert.assertNotEquals(timelineEvents, timeline.getTimeline());
        Assert.assertNotEquals(tickToMovementVentState, timeline.getMovementVentStates());
        Assert.assertNotEquals(tickToStabilityUpdateState, timeline.getStabilityUpdateStates());
        for(int i = 0; i < StatusState.NUM_VENTS+1; ++i) {
            Assert.assertEquals(timeline.getIdentifiedVentTicks()[i], -1);
            Assert.assertNull(timeline.getIdentifiedVentStates()[i]);
        }
    }

    public void resetTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();

        timeline.addInitialState(new StatusState());
        timeline.addIdentifiedVentTick(new StatusState(), 1);
        timeline.addMovementTick(new StatusState(), makeMoveBitState(0,0,0));
        timeline.updateTick();

        //Stored states, events and ticks should remain the same
        Assert.assertFalse(timeline.isHasReset());
        timeline.reset();
        Assert.assertTrue(timeline.isHasReset());
        Assert.assertEquals(timeline.getCurrentTick(), 1);
        Assert.assertEquals(timeline.getCurrentStartingTick(), 1);
        Assert.assertNull(timeline.getInitialState());
        Assert.assertEquals(timelineEvents, timeline.getTimeline());
        Assert.assertEquals(tickToMovementVentState, timeline.getMovementVentStates());
        Assert.assertEquals(tickToStabilityUpdateState, timeline.getStabilityUpdateStates());
        //Identified vents and states should be cleared
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 0);
        for(int i = 0; i < StatusState.NUM_VENTS+1; ++i) {
            Assert.assertEquals(timeline.getIdentifiedVentTicks()[i], -1);
            Assert.assertNull(timeline.getIdentifiedVentStates()[i]);
        }
    }

    public void addInitialStateTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state1 = new StatusState();

        //Should successfully be added
        Assert.assertTrue(timeline.addInitialState(state1));
        StatusState addedState = timeline.getInitialState();
        Assert.assertNotNull(addedState);
        //New copied instance should be added
        Assert.assertNotEquals(addedState, state1);
        //Should fail if a second initial state is added since one exists
        Assert.assertFalse(timeline.addInitialState(state1));
    }

    public void addIdentifiedVentTickTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        timeline.addInitialState(new StatusState());
        int[] timelineEvents = timeline.getTimeline();
        int[] identifiedVentTicks = timeline.getIdentifiedVentTicks();
        StatusState[] identifiedVentStates = timeline.getIdentifiedVentStates();
        StatusState state1 = new StatusState();
        int onFlag = (1 << VentStatusTimeline.IDENTIFIED_VENT_FLAG);
        int garbageValue = 64;

        timeline.addIdentifiedVentTick(state1, 1 | garbageValue);
        Assert.assertEquals(timelineEvents[0], 1 | onFlag);
        Assert.assertEquals(identifiedVentTicks[0], 0);
        Assert.assertNotNull(identifiedVentStates[0]);
        Assert.assertNotEquals(identifiedVentStates[0], state1);
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 1);

        timeline.addIdentifiedVentTick(state1, 2 | garbageValue);
        Assert.assertEquals(timelineEvents[0], 3 | onFlag);
        Assert.assertEquals(identifiedVentTicks[1], 0);
        Assert.assertNotNull(identifiedVentStates[1]);
        Assert.assertNotEquals(identifiedVentStates[1], state1);
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 2);

        timeline.addIdentifiedVentTick(state1, 4 | garbageValue);
        Assert.assertEquals(timelineEvents[0], 7 | onFlag);
        Assert.assertEquals(identifiedVentTicks[2], 0);
        Assert.assertNotNull(identifiedVentStates[2]);
        Assert.assertNotEquals(identifiedVentStates[2], state1);
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 3);
    }

    public void addIdentifiedVentTickInvalidTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        int[] identifiedVentTicks = timeline.getIdentifiedVentTicks();
        StatusState[] identifiedVentStates = timeline.getIdentifiedVentStates();
        StatusState state1 = new StatusState();

        timeline.addIdentifiedVentTick(state1, 64);
        Assert.assertEquals(timelineEvents[0], 0);
        for(int i = 0; i < StatusState.NUM_VENTS; ++i) {
            Assert.assertEquals(identifiedVentTicks[0], -1);
            Assert.assertNull(identifiedVentStates[0]);
        }
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 0);
    }

    public void addIdentifiedVentTickReassignTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        timeline.addInitialState(new StatusState());
        int[] timelineEvents = timeline.getTimeline();
        int[] identifiedVentTicks = timeline.getIdentifiedVentTicks();
        StatusState[] identifiedVentStates = timeline.getIdentifiedVentStates();


        timeline.addIdentifiedVentTick(new StatusState(), 1);
        StatusState state = identifiedVentStates[0];
        timeline.updateTick();
        timeline.addIdentifiedVentTick(state, 1);

        //Values should be unchanged from last assignment
        Assert.assertEquals(timelineEvents[1], 0);
        Assert.assertEquals(identifiedVentTicks[0], 0);
        Assert.assertEquals(identifiedVentStates[0], state);
        Assert.assertEquals(timeline.getNumIdentifiedVents(), 1);
    }

    public void addDirectionChangeTickTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        int onFlag = (1 << VentStatusTimeline.DIRECTION_CHANGED_FLAG);

        timeline.addDirectionChangeTick((1 << 3) | 1);
        Assert.assertEquals(timelineEvents[0], (1 << 3) | onFlag);
        timeline.updateTick();
        timeline.addDirectionChangeTick((1 << 3) | 1);
        Assert.assertEquals(timelineEvents[1], (1 << 3) | onFlag);
    }

    public void addMovementTickTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        timeline.addInitialState(new StatusState());
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        StatusState state1 = new StatusState();
        int onFlag = (1 << VentStatusTimeline.MOVEMENT_UPDATE_FLAG);

        //This should fail to be added since 0 tick move is impossible
        timeline.addMovementTick(state1, makeMoveBitState(3,3,3));
        StatusState addedState = tickToMovementVentState.get(0);
        Assert.assertNull(addedState);

        //Should successfully be added
        advanceTicks(timeline, 10);
        int moveBitState = makeMoveBitState(3,3,3);
        timeline.addMovementTick(state1, moveBitState);
        addedState = tickToMovementVentState.get(10);
        Assert.assertNotNull(addedState);
        Assert.assertEquals(timelineEvents[10], onFlag | moveBitState);
        //New copied instance should be added
        Assert.assertNotEquals(addedState, state1);

        //Make sure movement bit state is added
        advanceTicks(timeline, 10);
        moveBitState = makeMoveBitState(2,2,2);
        timeline.addMovementTick(state1, moveBitState);
        Assert.assertEquals(timelineEvents[20], onFlag | moveBitState);
    }

    public void addStabilityUpdateTickTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        StatusState state1 = new StatusState();
        int onFlag = (1 << VentStatusTimeline.STABILITY_UPDATE_FLAG);

        timeline.addStabilityUpdateTick(state1, 0);
        //Should successfully be added
        StabilityUpdateInfo addedInfo = tickToStabilityUpdateState.get(0);
        Assert.assertNotNull(addedInfo);
        Assert.assertEquals(timelineEvents[0], onFlag);
        //New copied instance should be added
        Assert.assertNotEquals(addedInfo.getStabilityUpdateState(), state1);
    }

    public void addStabilityUpdateTickCalcTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        StatusState state1 = new StatusState();
        state1.updateVentStatus(new int[]{VentStatus.STARTING_VENT_VALUE,50, 50}, 0);
        timeline.addStabilityUpdateTick(state1, 10);

        //The added state should have a calculated estimated value
        StabilityUpdateInfo addedInfo = tickToStabilityUpdateState.get(0);
        StatusState addedState = addedInfo.getStabilityUpdateState();
        Assert.assertTrue(addedState.getVents()[0].isRangeDefined());
    }

    public void addEarthquakeEventTickTest() {
        //Earthquake event should be added and remove est move
        VentStatusTimeline MoveStartTimeline = new VentStatusTimeline();
        MoveStartTimeline.addInitialState(new StatusState());
        advanceTicks(MoveStartTimeline, 10);
        MoveStartTimeline.addMovementTick(new StatusState(), 0);
        advanceTicks(MoveStartTimeline, 10);
        Assert.assertTrue(MoveStartTimeline.addEstimatedMovementTick());
        MoveStartTimeline.addEarthquakeEventTick();
        Assert.assertEquals(MoveStartTimeline.getTimeline()[20], (1 << VentStatusTimeline.EARTHQUAKE_EVENT_FLAG));
    }

    public void addEstimatedMovementTickTest() {
        VentStatusTimeline MoveStartTimeline = new VentStatusTimeline();
        MoveStartTimeline.addInitialState(new StatusState());
        int addedEstMoveFlag = (1 << VentStatusTimeline.ESTIMATED_MOVEMENT_FLAG);

        //Should fail since estimated movements cannot occur on the starting tick
        Assert.assertFalse(MoveStartTimeline.addEstimatedMovementTick());

        //Should pass even though neither a movement or stability update has occured
        advanceTicks(MoveStartTimeline, 10);
        Assert.assertTrue(MoveStartTimeline.addEstimatedMovementTick());
        Assert.assertEquals(MoveStartTimeline.getTimeline()[10], addedEstMoveFlag);

        //Should pass even though no stability update
        advanceTicks(MoveStartTimeline, 10);
        MoveStartTimeline.addMovementTick(new StatusState(), 0);
        advanceTicks(MoveStartTimeline, 10);
        Assert.assertTrue(MoveStartTimeline.addEstimatedMovementTick());
        Assert.assertEquals(MoveStartTimeline.getTimeline()[30], addedEstMoveFlag);

        //Should pass even though no movement update
        VentStatusTimeline StabStartTimeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u, 50, 50}, 0);
        advanceTicks(StabStartTimeline, 10);
        StabStartTimeline.addStabilityUpdateTick(state, 20);
        Assert.assertTrue(StabStartTimeline.addEstimatedMovementTick());
        Assert.assertEquals(StabStartTimeline.getTimeline()[10], (1 << VentStatusTimeline.STABILITY_UPDATE_FLAG) | addedEstMoveFlag);

        //Should fail since an earthquake occured on the same tick
        advanceTicks(MoveStartTimeline, 10);
        MoveStartTimeline.addEarthquakeEventTick();
        Assert.assertFalse(MoveStartTimeline.addEstimatedMovementTick());
        Assert.assertEquals(MoveStartTimeline.getTimeline()[40], (1 << VentStatusTimeline.EARTHQUAKE_EVENT_FLAG));
    }

    public void clearMoveSkipEstimatedMoveTest() {
        int addedEstMoveFlag = (1 << VentStatusTimeline.ESTIMATED_MOVEMENT_FLAG);

        //Movement was skipped here remove the est move
        VentStatusTimeline MoveStartTimeline1 = new VentStatusTimeline();
        MoveStartTimeline1.addInitialState(new StatusState());
        advanceTicks(MoveStartTimeline1, 10);
        MoveStartTimeline1.addMovementTick(new StatusState(), 0);
        advanceTicks(MoveStartTimeline1, 10);
        Assert.assertTrue(MoveStartTimeline1.addEstimatedMovementTick());
        Assert.assertEquals(MoveStartTimeline1.getTimeline()[20], addedEstMoveFlag);
        advanceTicks(MoveStartTimeline1, 10);
        MoveStartTimeline1.addMovementTick(new StatusState(), 0);
        Assert.assertEquals(MoveStartTimeline1.getTimeline()[20], 0);

        //Movement was not skipped keep all est moves
        VentStatusTimeline MoveStartTimeline2 = new VentStatusTimeline();
        MoveStartTimeline2.addInitialState(new StatusState());
        advanceTicks(MoveStartTimeline2, 10);
        MoveStartTimeline2.addMovementTick(new StatusState(), 0);
        for(int i = 0; i < 4; ++i) {
            advanceTicks(MoveStartTimeline2, 10);
            Assert.assertTrue(MoveStartTimeline2.addEstimatedMovementTick());
        }
        advanceTicks(MoveStartTimeline2, 10);
        MoveStartTimeline2.addMovementTick(new StatusState(), 0);

        int tick = 10;
        for(int i = 0; i < 4; ++i) {
            tick += 10;
            Assert.assertEquals(MoveStartTimeline2.getTimeline()[tick], addedEstMoveFlag);
        }


        //Consec movement edge case; est move should be kept
        advanceTicks(MoveStartTimeline2, 10);
        MoveStartTimeline2.addMovementTick(new StatusState(), 0);

        tick = 10;
        for(int i = 0; i < 4; ++i) {
            tick += 10;
            Assert.assertEquals(MoveStartTimeline2.getTimeline()[tick], addedEstMoveFlag);
        }
    }

    public void fixPreviousEstimatedMovesTest() {
        int addedEstMoveFlag = (1 << VentStatusTimeline.ESTIMATED_MOVEMENT_FLAG);

        //Positioning of the est moves should be corrected
        VentStatusTimeline StabStartTimeline = new VentStatusTimeline();
        StabStartTimeline.addInitialState(new StatusState());
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u, 50, 50}, 0);
        advanceTicks(StabStartTimeline, 22);
        StabStartTimeline.addStabilityUpdateTick(state, 20);
        for(int i = 0; i < 3; ++i) {
            advanceTicks(StabStartTimeline, 10);
            Assert.assertTrue(StabStartTimeline.addEstimatedMovementTick());
        }
        advanceTicks(StabStartTimeline, 5);
        StabStartTimeline.addMovementTick(new StatusState(), 0);
        int oldTick = 22, newTick = 27;
        for(int i = 0; i < 3; ++i) {
            oldTick += 10;
            Assert.assertEquals(StabStartTimeline.getTimeline()[oldTick], 0);
            Assert.assertEquals(StabStartTimeline.getTimeline()[newTick], addedEstMoveFlag);
            newTick += 10;
        }
    }

    public void getTimelinePredictionStateIdentifyTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //Vent B is identified
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,50,u}, 0);
        timeline.addIdentifiedVentTick(state, 2);

        StatusState resultState = timeline.getTimelinePredictionState();
        Assert.assertEquals(resultState.getVents()[0].getActualValue(), u);
        Assert.assertEquals(resultState.getVents()[1].getActualValue(), 50);
        Assert.assertEquals(resultState.getVents()[2].getActualValue(), u);

        //Vent A is identified
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{50,50,u}, 0);
        timeline.addIdentifiedVentTick(state, 1);

        resultState = timeline.getTimelinePredictionState();
        Assert.assertEquals(resultState.getVents()[0].getActualValue(), 50);
        Assert.assertEquals(resultState.getVents()[1].getActualValue(), 50);
        Assert.assertEquals(resultState.getVents()[2].getActualValue(), u);

        //Vent C is identified
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{50,50,50}, 0);
        timeline.addIdentifiedVentTick(state, 4);

        resultState = timeline.getTimelinePredictionState();
        Assert.assertEquals(resultState.getVents()[0].getActualValue(), 50);
        Assert.assertEquals(resultState.getVents()[1].getActualValue(), 50);
        Assert.assertEquals(resultState.getVents()[2].getActualValue(), 50);
    }

    public void getTimelinePredictionStateDirectionTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        advanceTicks(timeline, 5);
        timeline.addDirectionChangeTick(1 << 3);

        StatusState resultState = timeline.getTimelinePredictionState();
        Assert.assertEquals(resultState.getVents()[0].getDirection(), 1);
        Assert.assertEquals(resultState.getVents()[1].getDirection(), -1);
        Assert.assertEquals(resultState.getVents()[2].getDirection(), -1);

        advanceTicks(timeline, 5);
        timeline.addDirectionChangeTick(2 << 3);

        resultState = timeline.getTimelinePredictionState();
        Assert.assertEquals(resultState.getVents()[0].getDirection(), 1);
        Assert.assertEquals(resultState.getVents()[1].getDirection(), 1);
        Assert.assertEquals(resultState.getVents()[2].getDirection(), -1);

        advanceTicks(timeline, 5);
        timeline.addDirectionChangeTick(4 << 3);

        resultState = timeline.getTimelinePredictionState();
        Assert.assertEquals(resultState.getVents()[0].getDirection(), 1);
        Assert.assertEquals(resultState.getVents()[1].getDirection(), 1);
        Assert.assertEquals(resultState.getVents()[2].getDirection(), 1);

        advanceTicks(timeline, 5);
        timeline.addDirectionChangeTick(7 << 3);

        resultState = timeline.getTimelinePredictionState();
        Assert.assertEquals(resultState.getVents()[0].getDirection(), -1);
        Assert.assertEquals(resultState.getVents()[1].getDirection(), -1);
        Assert.assertEquals(resultState.getVents()[2].getDirection(), -1);
    }

    public void getTimelinePredictionStateMovementTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{50,u,u}, 0);
        timeline.addInitialState(state);

        for(int i = 0; i < 5; ++i) {
            advanceTicks(timeline, 10);
            state.updateVentStatus(new int[]{50-(i+1),u,u}, 0);
            timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));

            StatusState result = timeline.getTimelinePredictionState();
            Assert.assertEquals(result.getVents()[0].getActualValue(), 50-(i+1));
            Assert.assertEquals(result.getVents()[1].getActualValue(), u);
            Assert.assertEquals(result.getVents()[2].getActualValue(), u);
        }
    }

    public void getTimelinePredictionStateStabilityTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,75,75}, 0);
        timeline.addInitialState(state);

        advanceTicks(timeline, 25);
        timeline.addStabilityUpdateTick(state, 3);

        //Ensure we get a calculated value
        StatusState result = timeline.getTimelinePredictionState();
        VentStatus predictedVent = result.getVents()[0];
        Assert.assertEquals(predictedVent.getLowerBoundStart(), 35);
        Assert.assertEquals(predictedVent.getLowerBoundEnd(), 37);
        Assert.assertEquals(predictedVent.getUpperBoundStart(), 63);
        Assert.assertEquals(predictedVent.getUpperBoundEnd(), 65);
    }

    public void updatePreviousVentValuesTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //Early Stability update
        advanceTicks(timeline, 20);
        timeline.addStabilityUpdateTick(state, 16);
        //Vent B is identified
        advanceTicks(timeline, 20);
        state.updateVentStatus(new int[]{u,75,u}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        //A's direction was changed
        advanceTicks(timeline, 1);
        timeline.addDirectionChangeTick(1 << 3);
        //Do movement ticks
        for(int i = 0; i < 2; ++i) {
            state.updateVentStatus(new int[]{u,74-i,u}, 1);
            timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));
            //Do same tick stability update
            if(i == 0) timeline.addStabilityUpdateTick(state, 16);
            advanceTicks(timeline, 10);
        }
        //Set earthquake and movement skip
        timeline.addEarthquakeEventTick();
        advanceTicks(timeline, 10);
        //A's direction was changed
        advanceTicks(timeline, 1);
        timeline.addDirectionChangeTick(1 << 3);
        //Vent A is identified
        advanceTicks(timeline, 2);
        state.updateVentStatus(new int[]{50,73,u}, 0);
        timeline.addIdentifiedVentTick(state, 1);

        //Verify results
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        //Early Stability update should remain unchanged
        StatusState tick20StabState = tickToStabilityUpdateState.get(20).getStabilityUpdateState();
        Assert.assertEquals(tick20StabState.getVents()[0].getActualValue(), u);
        //Movement ticks should have the correct values
        int validMovementBit = makeMoveBitState(1, 1, 3);
        Assert.assertEquals(tickToMovementVentState.get(41).getVents()[0].getActualValue(), 49);
        Assert.assertEquals(timelineEvents[41] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(51).getVents()[0].getActualValue(), 50);
        Assert.assertEquals(timelineEvents[51] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        //Second stability update will have a value
        StatusState tick41StabState = tickToStabilityUpdateState.get(41).getStabilityUpdateState();
        Assert.assertEquals(tick41StabState.getVents()[0].getActualValue(), 49);
        //it should also have a new estimated value
        Assert.assertTrue(tick41StabState.getVents()[2].isRangeDefined());
    }

    public void updatePreviousVentValuesOnMovementTickTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //Stability update
        advanceTicks(timeline, 20);
        timeline.addStabilityUpdateTick(state, 23);
        //Vents A B is identified
        advanceTicks(timeline, 1);
        state.updateVentStatus(new int[]{50,50,u}, 0);
        timeline.addIdentifiedVentTick(state, 3);

        //Stability update will not update since there are no movement ticks
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        StatusState tick20StabState = tickToStabilityUpdateState.get(20).getStabilityUpdateState();
        Assert.assertEquals(tick20StabState.getVents()[0].getActualValue(), u);
        Assert.assertEquals(tick20StabState.getVents()[1].getActualValue(), u);
        Assert.assertEquals(tick20StabState.getVents()[2].getActualValue(), u);

        //Do movement tick
        advanceTicks(timeline, 1);
        state.updateVentStatus(new int[]{49,50,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));

        //Stability update will be updated with new values
        Assert.assertEquals(tick20StabState.getVents()[0].getActualValue(), 50);
        Assert.assertEquals(tick20StabState.getVents()[1].getActualValue(), 50);
        Assert.assertEquals(tick20StabState.getVents()[2].getActualValue(), u);
    }

    public void updatePreviousVentValuesMissingMovementTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //1st Stability update
        advanceTicks(timeline, 20);
        timeline.addStabilityUpdateTick(state, 19);
        //Vents B is identified
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,60,u}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        //Do movement tick
        advanceTicks(timeline, 4);
        state.updateVentStatus(new int[]{u,59,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));

        //1st Stability update should be changed
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        StatusState tick20StabState = tickToStabilityUpdateState.get(20).getStabilityUpdateState();
        Assert.assertEquals(tick20StabState.getVents()[0].getActualValue(), u);
        Assert.assertEquals(tick20StabState.getVents()[1].getActualValue(), 60);
        Assert.assertEquals(tick20StabState.getVents()[2].getActualValue(), u);

        //Skipped movement updates due to a freeze
        advanceTicks(timeline, 30);
        state.updateVentStatus(new int[]{u,58,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));
        //Reachable Stability update
        advanceTicks(timeline, 10);
        timeline.addStabilityUpdateTick(state, 18);
        //Vent A is identified
        advanceTicks(timeline, 2);
        state.updateVentStatus(new int[]{55,58,u}, 0);
        timeline.addIdentifiedVentTick(state, 1);

        //1st Stability update should be the same as before - skipped movement updates
        Assert.assertEquals(tick20StabState.getVents()[0].getActualValue(), u);
        Assert.assertEquals(tick20StabState.getVents()[1].getActualValue(), 60);
        Assert.assertEquals(tick20StabState.getVents()[2].getActualValue(), u);
        //2nd Stability update should be changed
        StatusState tick69StabState = tickToStabilityUpdateState.get(69).getStabilityUpdateState();
        Assert.assertEquals(tick69StabState.getVents()[0].getActualValue(), 55);
        Assert.assertEquals(tick69StabState.getVents()[1].getActualValue(), 58);
        Assert.assertEquals(tick69StabState.getVents()[2].getActualValue(), u);
        Assert.assertTrue(tick69StabState.getVents()[2].isRangeDefined());
    }

    public void updatePreviousVentValuesReverseFailTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 7);
        timeline.addInitialState(state);
        int validMoveBitState = makeMoveBitState(1, 3, 3);

        //Vent A is identified
        advanceTicks(timeline, 38);
        state.updateVentStatus(new int[]{53,u,u}, 7);
        timeline.addIdentifiedVentTick(state, 1);
        //Do movement tick
        advanceTicks(timeline, 2);
        state.updateVentStatus(new int[]{54,u,u}, 7);
        timeline.addMovementTick(state, validMoveBitState);
        //Do movement tick + stability update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{55,u,u}, 7);
        timeline.addMovementTick(state, validMoveBitState);
        timeline.addStabilityUpdateTick(state, 18);
        //Identification + movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{56,41,u}, 7);
        timeline.addMovementTick(state, validMoveBitState);
        timeline.addIdentifiedVentTick(state, 2);


        //1st Stability update should remain the same due to reverse move fail
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        StatusState tick50StabState = tickToStabilityUpdateState.get(50).getStabilityUpdateState();
        Assert.assertEquals(tick50StabState.getVents()[0].getActualValue(), 55);
        Assert.assertEquals(tick50StabState.getVents()[1].getActualValue(), u);
        Assert.assertEquals(tick50StabState.getVents()[2].getActualValue(), u);
        //Movement ticks should also remain the same
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        Assert.assertEquals(tickToMovementVentState.get(40).getVents()[1].getActualValue(), u);
        Assert.assertEquals(timelineEvents[40] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMoveBitState);
        Assert.assertEquals(tickToMovementVentState.get(50).getVents()[1].getActualValue(), u);
        Assert.assertEquals(timelineEvents[50] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMoveBitState);
        Assert.assertEquals(tickToMovementVentState.get(60).getVents()[1].getActualValue(), 41);
        Assert.assertEquals(timelineEvents[60] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMoveBitState);
    }

    public void getCurrentPredictionStateTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);


        //C range was lost
        //22: Early Stability update of 18
        advanceTicks(timeline, 22);
        timeline.addStabilityUpdateTick(state, 18);
        //34: A Vent was identified to be 58
        advanceTicks(timeline, 12);
        state.updateVentStatus(new int[]{58,u,u}, 0);
        timeline.addIdentifiedVentTick(state, 1);
        //37: Movement update
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{57,u,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //47: Same tick movement and stability update of 19
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{56,u,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        timeline.addStabilityUpdateTick(state, 19);
        //57: Same tick B Vent was identified to be 43 and movement
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{55,43,u}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //67: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{54,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //77: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{53,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //87: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{52,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //97: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{51,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //107: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{50,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //117: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{49,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //127: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{48,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //137: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{47,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //147: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{46,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //157: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{45,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //167: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{44,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //177: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{43,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //187: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{42,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //197: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{41,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //207: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{40,43,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 0));
        //217: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{38,42,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 0));
        //227: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{36,41,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 0));
        //237: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{34,40,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 0));
        //247: Earthquake and movement skip
        advanceTicks(timeline, 10);
        timeline.addEarthquakeEventTick();
        //257: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{32,38,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //267: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{30,36,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //277: Earthquake and movement skip
        advanceTicks(timeline, 10);
        timeline.addEarthquakeEventTick();
        //287: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{28,34,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //292: Earthquake event
        advanceTicks(timeline, 5);
        timeline.addEarthquakeEventTick();
        //297: Movement update
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{26,32,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //307: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{24,30,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //308: Vent A direction change
        advanceTicks(timeline, 1);
        timeline.addDirectionChangeTick(1 << 3);
        //317: Movement update
        advanceTicks(timeline, 9);
        state.updateVentStatus(new int[]{26,28,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //327: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{28,26,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //337: Earthquake and movement skip
        advanceTicks(timeline, 10);
        timeline.addEarthquakeEventTick();
        //347: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{30,24,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //357: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{32,22,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //367: Earthquake and movement skip
        advanceTicks(timeline, 10);
        timeline.addEarthquakeEventTick();
        //377: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{34,20,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //387: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{36,18,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //397: Earthquake and movement skip
        advanceTicks(timeline, 10);
        timeline.addEarthquakeEventTick();
        //407: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{38,16,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //417: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{40,14,u}, 1);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 0));
        //422: Stability update of -1
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, -1);

        //Verify Results - C should have an defined range
        StatusState predictedState = timeline.getCurrentPredictionState();
        Assert.assertTrue(predictedState.getVents()[2].isRangeDefined());
    }

    public void freezeClippingTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //12: C Vent was identified to be 58
        advanceTicks(timeline, 12);
        state.updateVentStatus(new int[]{u,u,58}, 0);
        timeline.addIdentifiedVentTick(state, 4);
        //28: B Vent was identified to be 53
        advanceTicks(timeline, 16);
        state.updateVentStatus(new int[]{u,53,58}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        //40: Stability update of 19 (+1)
        advanceTicks(timeline, 12);
        timeline.addStabilityUpdateTick(state, 19);
        //43: Movement update
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{u,52,58}, 0);
        timeline.addMovementTick(state, makeMoveBitState(0, 1, 0));

        //Should be freeze clipped here
        StatusState predictedState = timeline.getTimelinePredictionState();
        Assert.assertFalse(predictedState.getVents()[0].isRangeDefined());

        //Should not be freeze clipped here
        predictedState = timeline.getCurrentPredictionState();
        Assert.assertTrue(predictedState.getVents()[0].isRangeDefined());
    }

    //Safe - reverse movement tests
    public void reverseMovementATest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        StatusState state = new StatusState();
        state.doVMReset();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //Tick 5: Identify C Vent
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,u,70}, 0);
        timeline.addIdentifiedVentTick(state, 4);
        state = timeline.getTimelinePredictionState();
        //Tick 8: Movement tick
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{u,u,68}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 18: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,u,66}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 23: Stability update
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, -1);
        state = timeline.getTimelinePredictionState();
        //Tick 28: Movement tick
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,u,64}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 38: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,u,62}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 48: Same tick movement stability update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,u,60}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        timeline.addStabilityUpdateTick(state, -3);
        state = timeline.getTimelinePredictionState();
        //Tick 53: Identify A Vent
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{14,u,60}, 0);
        timeline.addIdentifiedVentTick(state, 1);
        state = timeline.getTimelinePredictionState();

        //Ensure we get an accurate estimate for B
        Assert.assertEquals(state.getVents()[1].getLowerBoundStart(), 10);
        Assert.assertEquals(state.getVents()[1].getLowerBoundEnd(), 12);
        Assert.assertEquals(state.getVents()[1].getUpperBoundStart(), 10);
        Assert.assertEquals(state.getVents()[1].getUpperBoundEnd(), 12);
        //Check that all values reversed to movement states correctly
        int validMovementBit = makeMoveBitState(2, 3, 2);
        Assert.assertEquals(tickToMovementVentState.get(8).getVents()[0].getActualValue(), 22);
        Assert.assertEquals(timelineEvents[8] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(18).getVents()[0].getActualValue(), 20);
        Assert.assertEquals(timelineEvents[18] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(28).getVents()[0].getActualValue(), 18);
        Assert.assertEquals(timelineEvents[28] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(38).getVents()[0].getActualValue(), 16);
        Assert.assertEquals(timelineEvents[38] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(48).getVents()[0].getActualValue(), 14);
        Assert.assertEquals(timelineEvents[48] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        //Check that all values revered to stability update states correctly
        Assert.assertEquals(tickToStabilityUpdateState.get(23).getStabilityUpdateState().getVents()[0].getActualValue(), 20);
        Assert.assertEquals(tickToStabilityUpdateState.get(48).getStabilityUpdateState().getVents()[0].getActualValue(), 14);
    }

    public void reverseMovementBTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        StatusState state = new StatusState();
        state.doVMReset();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //Tick 5: Identify C Vent
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,u,70}, 0);
        timeline.addIdentifiedVentTick(state, 4);
        state = timeline.getTimelinePredictionState();
        //Tick 8: Movement tick
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{u,u,68}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 18: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,u,66}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 23: Stability update
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, -1);
        state = timeline.getTimelinePredictionState();
        //Tick 28: Movement tick
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,u,64}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 38: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,u,62}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        state = timeline.getTimelinePredictionState();
        //Tick 48: Same tick movement stability update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,u,60}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 3, 2));
        timeline.addStabilityUpdateTick(state, -3);
        state = timeline.getTimelinePredictionState();
        //Tick 53: Identify B Vent
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,14,60}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        state = timeline.getTimelinePredictionState();

        //Ensure we get an accurate estimate for A
        Assert.assertEquals(state.getVents()[0].getLowerBoundStart(), 10);
        Assert.assertEquals(state.getVents()[0].getLowerBoundEnd(), 12);
        Assert.assertEquals(state.getVents()[0].getUpperBoundStart(), 10);
        Assert.assertEquals(state.getVents()[0].getUpperBoundEnd(), 12);
        //Check that all values reversed to movement states correctly
        int validMovementBit = makeMoveBitState(3, 2, 2);
        Assert.assertEquals(tickToMovementVentState.get(8).getVents()[1].getActualValue(), 22);
        Assert.assertEquals(timelineEvents[8] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(18).getVents()[1].getActualValue(), 20);
        Assert.assertEquals(timelineEvents[18] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(28).getVents()[1].getActualValue(), 18);
        Assert.assertEquals(timelineEvents[28] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(38).getVents()[1].getActualValue(), 16);
        Assert.assertEquals(timelineEvents[38] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(48).getVents()[1].getActualValue(), 14);
        Assert.assertEquals(timelineEvents[48] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        //Check that all values revered to stability update states correctly
        Assert.assertEquals(tickToStabilityUpdateState.get(23).getStabilityUpdateState().getVents()[1].getActualValue(), 20);
        Assert.assertEquals(tickToStabilityUpdateState.get(48).getStabilityUpdateState().getVents()[1].getActualValue(), 14);
    }

    public void reverseMovementCTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        StatusState state = new StatusState();
        state.doVMReset();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //Tick 5: Identify B Vent
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,70,u}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        state = timeline.getTimelinePredictionState();
        //Tick 8: Movement tick
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{u,68,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 2, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 18: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,66,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 2, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 23: Stability update
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, -1);
        state = timeline.getTimelinePredictionState();
        //Tick 28: Movement tick
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,64,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 2, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 38: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,62,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 2, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 48: Same tick movement stability update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,60,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 2, 3));
        timeline.addStabilityUpdateTick(state, -3);
        state = timeline.getTimelinePredictionState();
        //Tick 53: Identify C Vent
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,60,14}, 0);
        timeline.addIdentifiedVentTick(state, 4);
        state = timeline.getTimelinePredictionState();

        //Ensure we get an accurate estimate for A
        Assert.assertEquals(state.getVents()[0].getLowerBoundStart(), 10);
        Assert.assertEquals(state.getVents()[0].getLowerBoundEnd(), 12);
        Assert.assertEquals(state.getVents()[0].getUpperBoundStart(), 10);
        Assert.assertEquals(state.getVents()[0].getUpperBoundEnd(), 12);
        //Check that all values reversed to movement states correctly
        int validMovementBit = makeMoveBitState(3, 2, 2);
        Assert.assertEquals(tickToMovementVentState.get(8).getVents()[2].getActualValue(), 22);
        Assert.assertEquals(timelineEvents[8] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(18).getVents()[2].getActualValue(), 20);
        Assert.assertEquals(timelineEvents[18] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(28).getVents()[2].getActualValue(), 18);
        Assert.assertEquals(timelineEvents[28] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(38).getVents()[2].getActualValue(), 16);
        Assert.assertEquals(timelineEvents[38] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertEquals(tickToMovementVentState.get(48).getVents()[2].getActualValue(), 14);
        Assert.assertEquals(timelineEvents[48] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        //Check that all values revered to stability update states correctly
        Assert.assertEquals(tickToStabilityUpdateState.get(23).getStabilityUpdateState().getVents()[2].getActualValue(), 20);
        Assert.assertEquals(tickToStabilityUpdateState.get(48).getStabilityUpdateState().getVents()[2].getActualValue(), 14);
    }

    public void reverseMovementFreezeClipAccurateATest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        int[] timelineEvents = timeline.getTimeline();
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        StatusState state = new StatusState();
        state.doVMReset();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);

        //Tick 5: Identify B Vent
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,70,u}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        state = timeline.getTimelinePredictionState();
        //Tick 8: Movement tick
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{u,69,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 18: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,68,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 23: Stability update
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, 4);
        state = timeline.getTimelinePredictionState();
        //Tick 28: Movement tick
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{u,67,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 38: Movement tick
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,66,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));
        state = timeline.getTimelinePredictionState();
        //Tick 48: Same tick movement stability update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,65,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 1, 3));
        timeline.addStabilityUpdateTick(state, 2);
        state = timeline.getTimelinePredictionState();
        //Tick 58: Movement tick - freeze clipped A found here
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{u,63,u}, 0);
        timeline.addMovementTick(state, makeMoveBitState(3, 2, 3));
        state = timeline.getTimelinePredictionState();

        //We should have a freeze clipped accurate A
        Assert.assertTrue(state.getVents()[0].isFreezeClipAccurate());
        //Ensure data is set properly
        Assert.assertNotNull(timeline.getIdentifiedVentStates()[3]);
        Assert.assertEquals(timeline.getIdentifiedVentTicks()[3], 58);
        //Ensure data isnt set a second time + we only reverse once
        StatusState freezeClipAState = timeline.getIdentifiedVentStates()[3];
        advanceTicks(timeline, 1);
        state = timeline.getTimelinePredictionState();
        Assert.assertEquals(timeline.getIdentifiedVentStates()[3], freezeClipAState);
        Assert.assertEquals(timeline.getIdentifiedVentTicks()[3], 58);

        //Check that all values reversed to movement states correctly
        int validMovementBit = makeMoveBitState(3, 1, 3);
        Assert.assertTrue(tickToMovementVentState.get(8).getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToMovementVentState.get(8).getVents()[0].getLowerBoundStart(), 44);
        Assert.assertEquals(timelineEvents[8] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertTrue(tickToMovementVentState.get(18).getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToMovementVentState.get(18).getVents()[0].getLowerBoundStart(), 43);
        Assert.assertEquals(timelineEvents[18] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertTrue(tickToMovementVentState.get(28).getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToMovementVentState.get(28).getVents()[0].getLowerBoundStart(), 42);
        Assert.assertEquals(timelineEvents[28] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertTrue(tickToMovementVentState.get(38).getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToMovementVentState.get(38).getVents()[0].getLowerBoundStart(), 41);
        Assert.assertEquals(timelineEvents[38] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertTrue(tickToMovementVentState.get(48).getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToMovementVentState.get(48).getVents()[0].getLowerBoundStart(), 40);
        Assert.assertEquals(timelineEvents[48] & VentStatusTimeline.MOVEMENT_BIT_MASK, validMovementBit);
        Assert.assertTrue(tickToMovementVentState.get(58).getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToMovementVentState.get(58).getVents()[0].getLowerBoundStart(), 38);
        Assert.assertEquals(timelineEvents[58] & VentStatusTimeline.MOVEMENT_BIT_MASK, makeMoveBitState(3, 2, 3));
        //Check that all values reversed to stability update states correctly
        Assert.assertTrue(tickToStabilityUpdateState.get(23).getStabilityUpdateState().getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToStabilityUpdateState.get(23).getStabilityUpdateState().getVents()[0].getLowerBoundStart(), 43);
        Assert.assertTrue(tickToStabilityUpdateState.get(48).getStabilityUpdateState().getVents()[0].isFreezeClipAccurate());
        Assert.assertEquals(tickToStabilityUpdateState.get(48).getStabilityUpdateState().getVents()[0].getLowerBoundStart(), 40);
    }

    public void checkHalfSpaceInvalidKnownVentsTest() {
        //1-0 known vents mismatch - Half space should not be done
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 0);
        timeline.addInitialState(state);
        advanceTicks(timeline, 25);
        timeline.addStabilityUpdateTick(state, 21);
        advanceTicks(timeline, 12);
        state.updateVentStatus(new int[]{u,52,u}, 0);
        timeline.addIdentifiedVentTick(state, 2);
        advanceTicks(timeline, 13);
        timeline.addStabilityUpdateTick(state, 23);

        final int[] timelineEvents = timeline.getTimeline();
        Assert.assertEquals((timelineEvents[50] & (1 << VentStatusTimeline.HALF_SPACE_COMPLETED_FLAG)), 0);
    }

    public void getPointContributionInvalidDirectionChangeTest() {
        //A direction check
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,51,u}, 0);
        timeline.addInitialState(state);
        advanceTicks(timeline, 25);
        timeline.addStabilityUpdateTick(state, 21);
        //A's direction was changed
        advanceTicks(timeline, 8);
        timeline.addDirectionChangeTick(1 << 3);
        advanceTicks(timeline, 17);
        timeline.addStabilityUpdateTick(state, 23);

        //Should fail since a direction change occured!
        final int[] timelineEvents = timeline.getTimeline();
        Assert.assertEquals((timelineEvents[50] & (1 << VentStatusTimeline.HALF_SPACE_COMPLETED_FLAG)), 0);


        //C direction test
        VentStatusTimeline timeline2 = new VentStatusTimeline();
        timeline2.addInitialState(state);
        advanceTicks(timeline2, 25);
        timeline2.addStabilityUpdateTick(state, 21);
        //C's direction was changed
        advanceTicks(timeline2, 8);
        timeline2.addDirectionChangeTick(4 << 3);
        advanceTicks(timeline2, 17);
        timeline2.addStabilityUpdateTick(state, 23);

        //Should fail since a direction change occured!
        final int[] timelineEvents2 = timeline2.getTimeline();
        Assert.assertEquals((timelineEvents2[50] & (1 << VentStatusTimeline.HALF_SPACE_COMPLETED_FLAG)), 0);
    }

    public void completeHalfSpaceInvalidStabilityChangeDiffTest() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,51,u}, 0);
        timeline.addInitialState(state);
        advanceTicks(timeline, 25);
        timeline.addStabilityUpdateTick(state, 21);
        advanceTicks(timeline, 25);
        timeline.addStabilityUpdateTick(state, 22);

        //Should fail since stability hasnt changed enough!
        final int[] timelineEvents = timeline.getTimeline();
        Assert.assertEquals((timelineEvents[50] & (1 << VentStatusTimeline.HALF_SPACE_COMPLETED_FLAG)), 0);
    }

    public void completeHalfSpaceTest() {
//        VentStatusTimeline timeline = new VentStatusTimeline();
//        StatusState state = new StatusState();
//        state.updateVentStatus(new int[]{u,51,u}, 0);
//        timeline.addInitialState(state);
//        advanceTicks(timeline, 25);
//        timeline.addStabilityUpdateTick(state, 21);
//        advanceTicks(timeline, 25);
//        timeline.addStabilityUpdateTick(state, 22);
//        //B's direction was changed
//        advanceTicks(timeline, 8);
//        timeline.addDirectionChangeTick(2 << 3);
//        advanceTicks(timeline, 17);
//        timeline.addStabilityUpdateTick(state, 23);
//
//        //Half space should succeed here
//        final int[] timelineEvents = timeline.getTimeline();
//        Assert.assertTrue((timelineEvents[75] & (1 << VentStatusTimeline.HALF_SPACE_COMPLETED_FLAG)) != 0);
//        //A vent should be clipped properly
//        StatusState predictedState = timeline.getCurrentPredictionState();
//        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundStart(), 47);
//        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundStart(), 47);
//        Assert.assertEquals(predictedState.getVents()[0].getLowerBoundEnd(), 56);
//        Assert.assertEquals(predictedState.getVents()[0].getUpperBoundEnd(), 56);
    }

    public void halfSpaceClippingTest() {
//        VentStatusTimeline timeline = new VentStatusTimeline();
//        StatusState startingState = new StatusState();
//        startingState.updateVentStatus(new int[]{0,u,u}, 1);
//
//        //Assume both B and C are 25%
//        //Both B and C are fixed
//        timeline.initialize();
//        StatusState state = new StatusState(startingState);
//        timeline.addInitialState(state);
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{2,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{4,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 5);
//        timeline.addStabilityUpdateTick(state, -7);
//        advanceTicks(timeline, 5);
//        state.updateVentStatus(new int[]{6,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{8,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{10,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        timeline.addStabilityUpdateTick(state, -1);
//
//        StatusState predictedState = timeline.getCurrentPredictionState();
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundStart(), 47);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundStart(), 47);
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundEnd(), 93);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundEnd(), 93);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 47);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 47);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 93);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 93);
//
//
//        //Both B and C are not fixed
//        timeline.initialize();
//        state = new StatusState(startingState);
//        timeline.addInitialState(state);
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{2,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{4,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 5);
//        timeline.addStabilityUpdateTick(state, -7);
//        advanceTicks(timeline, 5);
//        state.updateVentStatus(new int[]{6,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{8,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{10,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        timeline.addStabilityUpdateTick(state, -9);
//
//        predictedState = timeline.getCurrentPredictionState();
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundEnd(), 37);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundEnd(), 37);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 37);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 37);
//
//
//        //Either B or C are fixed the other one isnt
//        timeline.initialize();
//        state = new StatusState(startingState);
//        timeline.addInitialState(state);
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{2,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{4,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 5);
//        timeline.addStabilityUpdateTick(state, -7);
//        advanceTicks(timeline, 5);
//        state.updateVentStatus(new int[]{6,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{8,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        advanceTicks(timeline, 10);
//        state.updateVentStatus(new int[]{10,u,u}, 1);
//        timeline.addMovementTick(state, makeMoveBitState(2, 0, 0));
//        timeline.addStabilityUpdateTick(state, -5);
//
//        predictedState = timeline.getCurrentPredictionState();
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[1].getLowerBoundEnd(), 94);
//        Assert.assertEquals(predictedState.getVents()[1].getUpperBoundEnd(), 94);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 0);
//        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 97);
//        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 97);
    }


    public void sandbox() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 3);
        timeline.addInitialState(state);

        //Incorrect C was picked
        //24: Early Stability update
        advanceTicks(timeline, 24);
        timeline.addStabilityUpdateTick(state, 14);
        //33: A Vent was identified to be 66
        advanceTicks(timeline, 9);
        state.updateVentStatus(new int[]{66,u,u}, 3);
        timeline.addIdentifiedVentTick(state, 1);
        //39: Earthquake and movement skip
        advanceTicks(timeline, 6);
        timeline.addEarthquakeEventTick();
        //47: A's direction was changed
        advanceTicks(timeline, 8);
        timeline.addDirectionChangeTick(1 << 3);
        //49: Same tick movement and stability update of 11
        advanceTicks(timeline, 2);
        state.updateVentStatus(new int[]{64,u,u}, 2);
        timeline.addMovementTick(state, makeMoveBitState(2, 3, 3));
        timeline.addStabilityUpdateTick(state, 11);
        //59: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{62,u,u}, 2);
        timeline.addMovementTick(state, makeMoveBitState(2, 3, 3));
        //69: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{60,u,u}, 2);
        timeline.addMovementTick(state, makeMoveBitState(2, 3, 3));
        //74: Stability update of 10
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, 10);
        //79: Movement update
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{58,u,u}, 2);
        timeline.addMovementTick(state, makeMoveBitState(2, 3, 3));
        //80: B Vent was identified to be 77
        advanceTicks(timeline, 1);
        state.updateVentStatus(new int[]{58,77,u}, 2);
        timeline.addIdentifiedVentTick(state, 2);

        //Verify results - lowerbound 30s was right answer
        HashMap<Integer, StabilityUpdateInfo> tickToStabilityUpdateState = timeline.getStabilityUpdateStates();
        HashMap<Integer, StatusState> tickToMovementVentState = timeline.getMovementVentStates();
        StatusState tick74StabState = tickToStabilityUpdateState.get(74).getStabilityUpdateState();
        StatusState predictedState = timeline.getCurrentPredictionState();

        //89: Movement update
        advanceTicks(timeline, 9);
        state.updateVentStatus(new int[]{57,78,u}, 2);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //99: Same tick movement and stability update of 10
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{56,79,u}, 2);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        timeline.addStabilityUpdateTick(state, 10);

        predictedState = timeline.getCurrentPredictionState();
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundStart(), 35);
        Assert.assertEquals(predictedState.getVents()[2].getLowerBoundEnd(), 38);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundStart(), 35);
        Assert.assertEquals(predictedState.getVents()[2].getUpperBoundEnd(), 38);
    }

    public void sandbox2() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 4);
        timeline.addInitialState(state);

        //Initial Stability Update is a +1 mod!
        //22: Early Stability update of 17
        advanceTicks(timeline, 22);
        timeline.addStabilityUpdateTick(state, 17);
        //34: A Vent was identified to be 44
        advanceTicks(timeline, 12);
        state.updateVentStatus(new int[]{44,u,u}, 4);
        timeline.addIdentifiedVentTick(state, 1);
        //37: Movement update
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{43,u,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        //47: Same tick movement and stability update of 16
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{42,u,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        timeline.addStabilityUpdateTick(state, 16);
        //50: A's direction was changed
        advanceTicks(timeline, 3);
        timeline.addDirectionChangeTick(1 << 3);
        //57: Movement update
        advanceTicks(timeline, 7);
        state.updateVentStatus(new int[]{43,u,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        //67: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{44,u,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        //72: Stability update of 16
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, 16);
        //77: Movement update
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{45,u,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        //80: B Vent was identified to be 47
        advanceTicks(timeline, 3);
        state.updateVentStatus(new int[]{45,47,u}, 5);
        timeline.addIdentifiedVentTick(state, 2);
        //87: Movement update
        advanceTicks(timeline, 7);
        state.updateVentStatus(new int[]{46,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //97: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{47,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //107: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{48,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //117: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{49,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //127: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{50,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //137: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{51,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //147: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{52,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //157: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{53,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //167: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{54,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //177: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{55,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //187: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{56,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //197: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{57,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //207: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{58,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //217: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{59,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //227: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{60,47,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //237: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{62,46,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //247: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{64,45,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //257: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{66,44,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //267: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{68,43,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //275: A's direction was changed
        advanceTicks(timeline, 8);
        timeline.addDirectionChangeTick(1 << 3);
        //277: Movement update
        advanceTicks(timeline, 2);
        state.updateVentStatus(new int[]{66,42,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //287: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{64,41,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //297: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{62,40,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //307: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{60,38,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //317: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{58,36,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //327: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{57,35,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //337: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{56,34,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //347: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{55,33,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //357: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{54,32,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //367: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{53,31,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //377: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{52,30,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //387: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{51,29,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //397: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{50,28,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //407: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{49,27,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //417: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{48,26,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //427: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{47,25,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //437: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{46,24,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //447: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{45,23,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //457: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{44,22,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //467: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{43,21,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //472: Stability update of -2
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, -2);

        //Verify Results - C is a single range
        StatusState predictedState = timeline.getCurrentPredictionState();
        Assert.assertTrue(predictedState.getVents()[2].isRangeDefined());
        Assert.assertFalse(predictedState.getVents()[2].isTwoSeperateValues());
    }

    public void sandbox3() {
        VentStatusTimeline timeline = new VentStatusTimeline();
        StatusState state = new StatusState();
        state.updateVentStatus(new int[]{u,u,u}, 5);
        timeline.addInitialState(state);


        //C range was lost
        //24: Early Stability update of 22
        advanceTicks(timeline, 24);
        timeline.addStabilityUpdateTick(state, 22);
        //34: A Vent was identified to be 52
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{52,u,u}, 5);
        timeline.addIdentifiedVentTick(state, 1);
        //39: Movement update
        advanceTicks(timeline, 5);
        state.updateVentStatus(new int[]{53,u,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        //49: Same tick movement and stability update of 20
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{54,u,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        timeline.addStabilityUpdateTick(state, 20);
        //59: Same tick B Vent was identified to be 46 and movement
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{55,46,u}, 5);
        timeline.addIdentifiedVentTick(state, 2);
        timeline.addMovementTick(state, makeMoveBitState(1, 3, 3));
        //69: Earthquake and movement skip
        advanceTicks(timeline, 10);
        timeline.addEarthquakeEventTick();
        //79: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{56,46,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //89: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{57,46,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //109: Movement update
        advanceTicks(timeline, 20);
        state.updateVentStatus(new int[]{58,46,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //119: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{59,46,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //129: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{60,46,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //139: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{62,45,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //149: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{64,44,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //159: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{66,43,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //169: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{68,42,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //179: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{70,41,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //189: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{72,40,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 1, 3));
        //199: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{74,38,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //209: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{76,36,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //219: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{78,34,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //229: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{80,32,u}, 5);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //231: Vent A direction change
        advanceTicks(timeline, 2);
        timeline.addDirectionChangeTick(1 << 3);
        //239: Movement update
        advanceTicks(timeline, 8);
        state.updateVentStatus(new int[]{78,30,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //249: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{76,28,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //259: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{74,26,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //269: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{72,24,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //279: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{70,22,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //289: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{68,20,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //299: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{66,18,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //309: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{64,16,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //319: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{62,14,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //329: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{60,12,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //339: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{58,10,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(2, 2, 3));
        //349: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{57,9,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //359: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{56,8,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //369: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{55,7,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //379: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{54,6,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //389: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{53,5,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //409: Movement update
        advanceTicks(timeline, 20);
        state.updateVentStatus(new int[]{52,4,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //419: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{51,3,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //429: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{50,2,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //439: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{49,1,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 1, 3));
        //449: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{48,0,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //459: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{47,0,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //469: Movement update
        advanceTicks(timeline, 10);
        state.updateVentStatus(new int[]{46,0,u}, 4);
        timeline.addMovementTick(state, makeMoveBitState(1, 0, 3));
        //474: Stability update of -1
        advanceTicks(timeline, 5);
        timeline.addStabilityUpdateTick(state, -1);

        //Verify Results - C should have an defined range
        StatusState predictedState = timeline.getCurrentPredictionState();
        Assert.assertTrue(predictedState.getVents()[2].isRangeDefined());
    }

}

