package com.poisonednpcs.util;

import junit.framework.TestCase;

import java.util.HashSet;
import java.util.Set;

/** Tests for {@link ArrayUtils}. */
public class ArrayUtilsTest extends TestCase {

    public void testConcat() {
        int[] one = new int[] {1, 2, 3};
        int[] two = new int[] {4, 5, 6};

        int[] concatenated = ArrayUtils.concat(one, two);
        for (int i = 0; i < concatenated.length; i++) {
            assertEquals(i + 1, concatenated[i]);
        }
    }

    public void testFilter() {
        String[] original = new String[] { "", "_", "__", "___", "____"};
        Iterable<String> filtered = ArrayUtils.filter(original, s -> (s.length() % 2) == 1);

        Set<String> setified = new HashSet<>();
        filtered.forEach(setified::add);
        assertEquals(2, setified.size());
        assertEquals(true, setified.contains("_"));
        assertEquals(true, setified.contains("___"));
    }

}
package com.poisonednpcs.util;

import com.google.common.collect.ImmutableMap;
import junit.framework.TestCase;

import java.util.Map;

/** Tests for {@link MapUtils}. */
public class MapUtilsTest extends TestCase {

    public void testTransformValues() {
        Map<Integer, Integer> original = ImmutableMap.of(
                0, 0,
                1, 1,
                2, 2);

        Map<Integer, String> transformed = MapUtils.transformValues(original, (k, i) -> i + "");
        transformed.forEach((key, value) -> assertEquals(key + "", value));
    }

}
package com.poisonednpcs.util;

import junit.framework.TestCase;

import java.time.Duration;

/** Tests for {@link DurationUtils}. */
public class DurationUtilsTest extends TestCase {

    public void testToSecondsString() {
        Duration duration1 = Duration.ofSeconds(5);
        assertEquals("5.0s", DurationUtils.durationToSecondsString(duration1));

        Duration duration2 = Duration.ofMillis(6497);
        assertEquals("6.4s", DurationUtils.durationToSecondsString(duration2));
    }

    public void testToSecondsStringZeroDuration() {
        assertEquals("", DurationUtils.durationToSecondsString(Duration.ZERO));
    }

}
package com.poisonednpcs.health;

import com.poisonednpcs.combat.HealthStatus;
import com.poisonednpcs.combat.HitTracker;
import com.poisonednpcs.mocks.MockNPC;
import com.poisonednpcs.npcs.Opponent;
import com.poisonednpcs.npcs.OpponentCuller;
import junit.framework.TestCase;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import org.mockito.Mockito;

import java.awt.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;

public class PoisonWatchTimerTest extends TestCase {

    public void testGetTextColor() {
        final int id = 1;

        MockNPC mockNPC = MockNPC.newSetup().getIndexFn(() -> id).get();
        HealthStatus mockStatus = Mockito.mock(HealthStatus.class);
        Mockito.when(mockStatus.isPoisoned()).thenReturn(true).thenReturn(false);
        Opponent mockOpponent = Mockito.mock(Opponent.class);
        Mockito.when(mockOpponent.getNPC()).thenReturn(mockNPC);
        Mockito.when(mockOpponent.getHealthStatus()).thenReturn(mockStatus);

        PoisonWatchTimer timer = new PoisonWatchTimer(mockOpponent, null, null);

        assertEquals(Color.GREEN, timer.getTextColor());
        assertEquals(Color.YELLOW, timer.getTextColor());
    }

    public void testCull() {
        AtomicBoolean isDead = new AtomicBoolean(false);

        MockNPC mockNPC = MockNPC.newSetup().setIsDeadFn(isDead::get).get();
        HealthStatus mockStatus = Mockito.mock(HealthStatus.class);
        Mockito.when(mockStatus.isActive())
                .thenReturn(true)
                .thenReturn(false)
                .thenReturn(true)
                .thenReturn(false);

        Opponent mockOpponent = Mockito.mock(Opponent.class);
        Mockito.when(mockOpponent.getNPC()).thenReturn(mockNPC);
        Mockito.when(mockOpponent.getHealthStatus()).thenReturn(mockStatus);

        PoisonWatchTimer timer = new PoisonWatchTimer(mockOpponent, null, null);

        assertFalse(timer.cull());
        assertTrue(timer.cull());
        isDead.set(true);
        assertTrue(timer.cull());
        assertTrue(timer.cull());
    }

    public void testUpdateTooltip() {
        final int id1 = 1;
        final int id2 = 2;

        MockNPC mockNPC1 = MockNPC.newSetup().getIndexFn(() -> id1).get();
        MockNPC mockNPC2 = MockNPC.newSetup().getIndexFn(() -> id2).get();

        HitTracker tracker = Mockito.mock(HitTracker.class);
        Mockito.when(tracker.getNumHits()).thenReturn(1);

        HealthStatus status = Mockito.mock(HealthStatus.class);
        Mockito.when(status.isActive()).thenReturn(true);
        Mockito.when(status.getHitTracker()).thenReturn(tracker);

        Opponent opponent1 = Mockito.mock(Opponent.class);
        Mockito.when(opponent1.getNPC()).thenReturn(mockNPC1);
        Mockito.when(opponent1.getHealthStatus()).thenReturn(status);
        Opponent opponent2 = Mockito.mock(Opponent.class);
        Mockito.when(opponent2.getNPC()).thenReturn(mockNPC2);
        Mockito.when(opponent2.getHealthStatus()).thenReturn(status);

        Predicate<InfoBox> updateTooltip = PoisonWatchTimer.updateTooltip(opponent1);

        PoisonWatchTimer timer1 = new PoisonWatchTimer(opponent1, null, null);
        String tooltip1 = timer1.getTooltip();
        PoisonWatchTimer timer2 = new PoisonWatchTimer(opponent2, null, null);
        String tooltip2 = timer2.getTooltip();

        assertFalse(updateTooltip.test(timer1));
        assertFalse(updateTooltip.test(timer2));
        assertNotSame(tooltip1, timer1.getTooltip());
        assertSame(tooltip2, timer2.getTooltip());
    }

    public void testCullOpponents() {
        final int id1 = 1;
        final int id2 = 2;

        MockNPC mockNPC1 = MockNPC.newSetup().getIndexFn(() -> id1).get();
        MockNPC mockNPC2 = MockNPC.newSetup().getIndexFn(() -> id2).get();

        HealthStatus status = Mockito.mock(HealthStatus.class);
        Mockito.when(status.isActive()).thenReturn(true);

        Opponent opponent1 = Mockito.mock(Opponent.class);
        Mockito.when(opponent1.getNPC()).thenReturn(mockNPC1);
        Mockito.when(opponent1.getHealthStatus()).thenReturn(status);
        Opponent opponent2 = Mockito.mock(Opponent.class);
        Mockito.when(opponent2.getNPC()).thenReturn(mockNPC2);
        Mockito.when(opponent2.getHealthStatus()).thenReturn(status);

        Predicate<InfoBox> updateTooltip = PoisonWatchTimer.cullOpponents(OpponentCuller.newBuilder()
                .add(opponent -> opponent.getNPC().getIndex() == id1)
                .build());

        PoisonWatchTimer timer1 = new PoisonWatchTimer(opponent1, null, null);
        PoisonWatchTimer timer2 = new PoisonWatchTimer(opponent2, null, null);

        assertTrue(updateTooltip.test(timer1));
        assertFalse(updateTooltip.test(timer2));
    }
}
package com.poisonednpcs.poison;

import com.google.common.collect.ImmutableList;
import junit.framework.TestCase;

import java.util.List;

/** Tests for {@link PoisonType}. */
public class PoisonTypeTest extends TestCase {

    public void testPoisonRegexMatches() {
        List<String> expectedMatches = ImmutableList.of(
                "Iron dagger(p)",
                "Rune dagger(p)",
                "Iron arrow(p)",
                "Dragon arrow(p)");

        for (String expectedMatch : expectedMatches) {
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.MELEE.getWeaponRegex().matcher(expectedMatch).find());
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.RANGED.getWeaponRegex().matcher(expectedMatch).find());
        }

        List<String> expectedMisses = ImmutableList.of(
                "Iron dagger(p)e",
                "Iron dagger(p",
                "Iron dagger(p+)",
                "Rune dagger(p++)",
                "Iron arrow(p++)",
                "Bronze kiteshield",
                "Dragon arrow");

        for (String expectedMiss : expectedMisses) {
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.MELEE.getWeaponRegex().matcher(expectedMiss).find());
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.RANGED.getWeaponRegex().matcher(expectedMiss).find());
        }
    }

    public void testPoisonPlusRegexMatches() {
        List<String> expectedMatches = ImmutableList.of(
                "Iron dagger(p+)",
                "Rune dagger(p+)",
                "Iron arrow(p+)",
                "Dragon arrow(p+)");

        for (String expectedMatch : expectedMatches) {
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.MELEE_PLUS.getWeaponRegex().matcher(expectedMatch).find());
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.RANGED_PLUS.getWeaponRegex().matcher(expectedMatch).find());
        }

        List<String> expectedMisses = ImmutableList.of(
                "Iron dagger(p)e",
                "Iron dagger(p",
                "Iron dagger(p)",
                "Rune dagger(p++)",
                "Iron arrow(p++)",
                "Bronze kiteshield",
                "Dragon arrow");

        for (String expectedMiss : expectedMisses) {
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.MELEE_PLUS.getWeaponRegex().matcher(expectedMiss).find());
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.RANGED_PLUS.getWeaponRegex().matcher(expectedMiss).find());
        }
    }

    public void testPoisonPlusPlusRegexMatches() {
        List<String> expectedMatches = ImmutableList.of(
                "Iron dagger(p++)",
                "Rune dagger(p++)",
                "Iron arrow(p++)",
                "Dragon arrow(p++)");

        for (String expectedMatch : expectedMatches) {
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.MELEE_PLUS_PLUS.getWeaponRegex().matcher(expectedMatch).find());
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.RANGED_PLUS_PLUS.getWeaponRegex().matcher(expectedMatch).find());
        }

        List<String> expectedMisses = ImmutableList.of(
                "Iron dagger(p)e",
                "Iron dagger(p",
                "Iron dagger(p)",
                "Rune dagger(p+)",
                "Iron arrow(p+)",
                "Bronze kiteshield",
                "Dragon arrow");

        for (String expectedMiss : expectedMisses) {
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.MELEE_PLUS_PLUS.getWeaponRegex().matcher(expectedMiss).find());
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.RANGED_PLUS_PLUS.getWeaponRegex().matcher(expectedMiss).find());
        }
    }

    public void testKarambwanRegexMatches() {
        List<String> expectedMatches = ImmutableList.of(
                "Bronze spear(kp)",
                "Rune spear(kp)",
                "Rune hasta(kp)",
                "Dragon hasta(kp)");

        for (String expectedMatch : expectedMatches) {
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.KARAMBWAN.getWeaponRegex().matcher(expectedMatch).find());
        }

        List<String> expectedMisses = ImmutableList.of(
                "Bronze spear",
                "Bronze spear(p)",
                "Iron dagger(p)",
                "Rune dagger(p+)",
                "Iron arrow(p++)",
                "Rune spear",
                "Dragon hasta");

        for (String expectedMiss : expectedMisses) {
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.KARAMBWAN.getWeaponRegex().matcher(expectedMiss).find());
        }
    }

    public void testEmeraldBoltsERegexMatches() {
        List<String> expectedMatches = ImmutableList.of(
                "Emerald bolts (e)");


        for (String expectedMatch : expectedMatches) {
            assertTrue(String.format("expected match on %s", expectedMatch),
                    PoisonType.EMERALD_BOLTS_E.getWeaponRegex().matcher(expectedMatch).find());
        }

        List<String> expectedMisses = ImmutableList.of(
                "Bronze bolts (e)",
                "Emerald bolts(e)",
                "Emerald bolts (e",
                "Emerald bolts e)",
                "Ruby bolts (e)",
                "Diamond bolts (e)",
                "ahhhhhhhhhhhhhh");

        for (String expectedMiss : expectedMisses) {
            assertFalse(String.format("expected miss on %s", expectedMiss),
                    PoisonType.EMERALD_BOLTS_E.getWeaponRegex().matcher(expectedMiss).find());
        }
    }

}
package com.poisonednpcs.npcs;

import junit.framework.TestCase;

/** Tests for {@link OpponentCuller}. */
public class OpponentCullerTest extends TestCase {

    public void testNoConditionsMatching() {
        Opponent opponent = new Opponent(null, 1);

        OpponentCuller culler = OpponentCuller.newBuilder()
                .add(o -> o.getNPC() != null)
                .add(o -> o.getMaxHealth() == 3)
                .build();

        assertEquals(false, culler.test(opponent));
    }

    public void testAnyConditionMatches() {
        Opponent opponent = new Opponent(null, 1);

        OpponentCuller culler = OpponentCuller.newBuilder()
                .add(o -> o.getNPC() != null)
                .add(o -> o.getMaxHealth() == 1)
                .build();

        assertEquals(true, culler.test(opponent));
    }

    public void testAllConditionsMatching() {
        Opponent opponent = new Opponent(null, 1);

        OpponentCuller culler = OpponentCuller.newBuilder()
                .add(o -> o.getNPC() == null)
                .add(o -> o.getMaxHealth() == 3)
                .build();

        assertEquals(true, culler.test(opponent));
    }

}
package com.poisonednpcs.mocks;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.function.Supplier;

// Do not generally do this. Much better to mock. Not entirely certain I can bring in my own libraries, though, so not
// risking it.
public class MockNPC implements NPC {

    private Supplier<Integer> getIndexFn;
    private Supplier<Boolean> isDeadFn;

    private MockNPC() {}

    @Override
    public int getId() {
        return 0;
    }

    @Override
    public String getName() {
        return null;
    }

    @Override
    public boolean isInteracting() {
        return false;
    }

    @Override
    public Actor getInteracting() {
        return null;
    }

    @Override
    public int getHealthRatio() {
        return 0;
    }

    @Override
    public int getHealthScale() {
        return 0;
    }

    @Override
    public WorldPoint getWorldLocation() {
        return null;
    }

    @Override
    public LocalPoint getLocalLocation() {
        return null;
    }

    @Override
    public int getOrientation() {
        return 0;
    }

    @Override
    public int getCurrentOrientation() {
        return 0;
    }

    @Override
    public int getAnimation() {
        return 0;
    }

    @Override
    public int getPoseAnimation() {
        return 0;
    }

    @Override
    public void setPoseAnimation(int i) {

    }

    @Override
    public int getPoseAnimationFrame() {
        return 0;
    }

    @Override
    public void setPoseAnimationFrame(int i) {

    }

    @Override
    public int getIdlePoseAnimation() {
        return 0;
    }

    @Override
    public void setIdlePoseAnimation(int i) {

    }

    @Override
    public int getIdleRotateLeft() {
        return 0;
    }

    @Override
    public void setIdleRotateLeft(int i) {

    }

    @Override
    public int getIdleRotateRight() {
        return 0;
    }

    @Override
    public void setIdleRotateRight(int i) {

    }

    @Override
    public int getWalkAnimation() {
        return 0;
    }

    @Override
    public void setWalkAnimation(int i) {

    }

    @Override
    public int getWalkRotateLeft() {
        return 0;
    }

    @Override
    public void setWalkRotateLeft(int i) {

    }

    @Override
    public int getWalkRotateRight() {
        return 0;
    }

    @Override
    public void setWalkRotateRight(int i) {

    }

    @Override
    public int getWalkRotate180() {
        return 0;
    }

    @Override
    public void setWalkRotate180(int i) {

    }

    @Override
    public int getRunAnimation() {
        return 0;
    }

    @Override
    public void setRunAnimation(int i) {

    }

    @Override
    public void setAnimation(int i) {

    }

    @Override
    public int getAnimationFrame() {
        return 0;
    }

    @Override
    public void setActionFrame(int i) {

    }

    @Override
    public void setAnimationFrame(int i) {

    }

    @Override
    public IterableHashTable<ActorSpotAnim> getSpotAnims() {
        return null;
    }

    @Override
    public boolean hasSpotAnim(int i) {
        return false;
    }

    @Override
    public void createSpotAnim(int i, int i1, int i2, int i3) {

    }

    @Override
    public void removeSpotAnim(int i) {

    }

    @Override
    public void clearSpotAnims() {

    }

    @Override
    public int getGraphic() {
        return 0;
    }

    @Override
    public void setGraphic(int i) {

    }

    @Override
    public int getGraphicHeight() {
        return 0;
    }

    @Override
    public void setGraphicHeight(int i) {

    }

    @Override
    public int getSpotAnimFrame() {
        return 0;
    }

    @Override
    public void setSpotAnimFrame(int i) {

    }

    @Override
    public Polygon getCanvasTilePoly() {
        return null;
    }

    @Nullable
    @Override
    public Point getCanvasTextLocation(Graphics2D graphics2D, String s, int i) {
        return null;
    }

    @Override
    public Point getCanvasImageLocation(BufferedImage bufferedImage, int i) {
        return null;
    }

    @Override
    public Point getCanvasSpriteLocation(SpritePixels spritePixels, int i) {
        return null;
    }

    @Override
    public Point getMinimapLocation() {
        return null;
    }

    @Override
    public int getLogicalHeight() {
        return 0;
    }

    @Override
    public Shape getConvexHull() {
        return null;
    }

    @Override
    public WorldArea getWorldArea() {
        return null;
    }

    @Override
    public String getOverheadText() {
        return null;
    }

    @Override
    public void setOverheadText(String s) {

    }

    @Override
    public int getOverheadCycle() {
        return 0;
    }

    @Override
    public void setOverheadCycle(int i) {

    }

    @Override
    public boolean isDead() {
        return isDeadFn != null && isDeadFn.get();
    }

    @Override
    public void setDead(boolean b) {

    }

    @Override
    public WorldView getWorldView() {
        return null;
    }

    @Override
    public int getCombatLevel() {
        return 0;
    }

    @Override
    public int getIndex() {
        return getIndexFn == null ? 0 : getIndexFn.get();
    }

    @Override
    public NPCComposition getComposition() {
        return null;
    }

    @Nullable
    @Override
    public NPCComposition getTransformedComposition() {
        return null;
    }

    @Nullable
    @Override
    public NpcOverrides getModelOverrides() {
        return null;
    }

    @Nullable
    @Override
    public NpcOverrides getChatheadOverrides() {
        return null;
    }

    @Override
    public Model getModel() {
        return null;
    }

    @Override
    public int getModelHeight() {
        return 0;
    }

    @Override
    public void setModelHeight(int i) {

    }

    @Override
    public Node getNext() {
        return null;
    }

    @Override
    public Node getPrevious() {
        return null;
    }

    @Override
    public long getHash() {
        return 0;
    }

    public static Setup newSetup() {
        return new Setup();
    }

    public static class Setup {

        private final MockNPC mockNPC = new MockNPC();

        private Setup() {}

        public Setup getIndexFn(Supplier<Integer> getIndexFn) {
            this.mockNPC.getIndexFn = getIndexFn;
            return this;
        }

        public Setup setIsDeadFn(Supplier<Boolean> isDeadFn) {
            this.mockNPC.isDeadFn = isDeadFn;
            return this;
        }

        public MockNPC get() {
            return this.mockNPC;
        }
    }
}

package com.poisonednpcs;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PoisonedNPCsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PoisonedNPCsPlugin.class);
		RuneLite.main(args);
	}

	// -ea --add-opens=java.desktop/com.apple.eawt=ALL-UNNAMED --add-opens=java.desktop/sun.awt=ALL-UNNAMED 
}
package com.poisonednpcs.combat;

import com.poisonednpcs.poison.PoisonType;
import junit.framework.TestCase;
import net.runelite.api.Hitsplat;

import java.time.Duration;
import java.time.Instant;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Integration tests for {@link HitTracker} and {@link PoisonTracker} tied together through {@link HealthStatus}.
 */
public class HealthStatusTest extends TestCase {

    public void testHitAndPoisonTrackersTiedTogether() throws InterruptedException {
        final Duration testDelay = Duration.ofMillis(5);
        final PoisonType poisonType = PoisonType.MELEE_PLUS_PLUS;
        HealthStatus.HIT_TO_POISON_DELAY = testDelay;

        AtomicBoolean isAlive = new AtomicBoolean(true);
        HealthStatus status = new HealthStatus(new HitTracker(isAlive::get));
        assertFalse(status.isPoisoned());
        assertFalse(status.isActive());

        status.getHitTracker().trackHit(new Hit(
                Optional.of(new Weapon(0, Optional.of(poisonType))),
                new Hitsplat(0, 1, 0)));
        assertFalse(status.isPoisoned());
        assertTrue(status.isActive());

        Thread.sleep(testDelay.multipliedBy(2).toMillis());
        assertFalse(status.getHitTracker().getOldestHitAfter(Instant.now().minus(testDelay)).isPresent());

        // The hit that will cause poison, now
        status.getHitTracker().trackHit(new Hit(
                Optional.of(new Weapon(0, Optional.of(poisonType))),
                new Hitsplat(0, 1, 0)));
        assertFalse(status.isPoisoned());
        assertTrue(status.isActive());

        for (int i = 0; i < poisonType.getProgression().length - 1; i++) {
            Thread.sleep(testDelay.toMillis());
            status.getPoisonTracker().registerPoisonSplat(new Hit(
                    Optional.empty(),
                    new Hitsplat(65, poisonType.getProgression()[i], 0)));
            assertTrue(status.isPoisoned());
            assertTrue(status.isActive());
        }

        // The last hit, which will register the kill and halt the poison
        Thread.sleep(testDelay.toMillis());
        status.getPoisonTracker().registerPoisonSplat(new Hit(
                Optional.empty(),
                new Hitsplat(65, poisonType.getProgression()[poisonType.getProgression().length - 1], 0)));
        assertFalse(status.isPoisoned());
        isAlive.set(false);
        assertFalse(status.isActive());
    }

}
package com.poisonednpcs.combat;

import com.poisonednpcs.poison.PoisonType;
import junit.framework.TestCase;
import net.runelite.api.Hitsplat;

import java.time.Duration;
import java.time.Instant;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;

/** Tests for {@link HitTracker}. */
public class HitTrackerTest extends TestCase {

    public void testIgnoreNonPoisonHit() {
        final int amount = 5;

        Instant starting = Instant.now();

        HitTracker tracker = new HitTracker(() -> true);
        assertFalse(tracker.hasHits());

        Hit hit = new Hit(Optional.of(new Weapon(0, Optional.empty())), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit);
        assertFalse(tracker.hasHits());

        Optional<Hit> retrieved = tracker.getOldestHitAfter(starting);
        assertFalse(retrieved.isPresent());
    }

    public void testTrackPoisonHit() {
        final int amount = 5;

        Instant starting = Instant.now();

        HitTracker tracker = new HitTracker(() -> true);
        assertFalse(tracker.hasHits());

        Hit hit = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit);
        assertTrue(tracker.hasHits());

        Optional<Hit> retrieved = tracker.getOldestHitAfter(starting);
        assertTrue(retrieved.isPresent());
        assertEquals(hit, retrieved.get());
    }

    public void testHasHitsViaIsActive() {
        final int value = 0;
        final int amount = 5;

        AtomicInteger test = new AtomicInteger(value);

        HitTracker tracker = new HitTracker(() -> test.get() == value);
        assertFalse(tracker.hasHits());

        Hit hit = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit);
        assertTrue(tracker.hasHits());

        test.set(value + 1);
        assertFalse(tracker.hasHits());
    }

    public void testGetOldestHitAfter() {
        final int amount = 5;

        HitTracker tracker = new HitTracker(() -> true);
        assertFalse(tracker.hasHits());

        Hit hit1 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount - 1, 500));
        tracker.trackHit(hit1);
        assertTrue(tracker.hasHits());

        Instant starting = Instant.now();

        Hit hit2 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit2);
        assertTrue(tracker.hasHits());
        Hit hit3 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount + 2, 1500));
        tracker.trackHit(hit3);
        assertTrue(tracker.hasHits());

        Optional<Hit> retrieved = tracker.getOldestHitAfter(starting);
        assertTrue(retrieved.isPresent());
        assertEquals(hit2, retrieved.get());
    }

    public void testGetClosestTrackedHitToOccurredAfter() throws InterruptedException {
        final int amount = 5;
        HitTracker tracker = new HitTracker(() -> true);

        Hit hit1 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount - 1, 500));
        tracker.trackHit(hit1);
        assertTrue(tracker.hasHits());
        Thread.sleep(30);

        Instant pullTime = Instant.now();
        Thread.sleep(20);

        Hit hit2 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit2);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        Hit hit3 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount + 2, 1500));
        tracker.trackHit(hit3);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        tracker.getOldestHitAfter(pullTime);

        Optional<Hit> closest = tracker.getClosestTrackedHitTo(pullTime, Duration.ofMillis(50));
        assertTrue(closest.isPresent());
        assertEquals(hit2, closest.get());
    }

    public void testGetClosestTrackedHitToOccurredBefore() throws InterruptedException {
        final int amount = 5;
        HitTracker tracker = new HitTracker(() -> true);

        Hit hit1 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount - 1, 500));
        tracker.trackHit(hit1);
        assertTrue(tracker.hasHits());
        Thread.sleep(20);

        Instant pullTime = Instant.now();
        Thread.sleep(30);

        Hit hit2 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit2);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        Hit hit3 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount + 2, 1500));
        tracker.trackHit(hit3);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        tracker.getOldestHitAfter(pullTime);

        Optional<Hit> closest = tracker.getClosestTrackedHitTo(pullTime, Duration.ofMillis(50));
        assertTrue(closest.isPresent());
        assertEquals(hit1, closest.get());
    }

    public void testGetClosestTrackedHitToNoPreviousHit() throws InterruptedException {
        final int amount = 5;
        HitTracker tracker = new HitTracker(() -> true);

        Instant pullTime = Instant.now();
        Thread.sleep(30);

        Hit hit2 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit2);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        Hit hit3 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount + 2, 1500));
        tracker.trackHit(hit3);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        tracker.getOldestHitAfter(pullTime);

        Optional<Hit> closest = tracker.getClosestTrackedHitTo(pullTime, Duration.ofMillis(50));
        assertTrue(closest.isPresent());
        assertEquals(hit2, closest.get());
    }

    public void testGetClosestTrackedHitToNoAfterHit() throws InterruptedException {
        final int amount = 5;
        HitTracker tracker = new HitTracker(() -> true);

        Hit hit2 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit2);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        Hit hit3 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount + 2, 1500));
        tracker.trackHit(hit3);
        assertTrue(tracker.hasHits());
        Thread.sleep(20);

        Instant pullTime = Instant.now();

        tracker.getOldestHitAfter(pullTime);

        Optional<Hit> closest = tracker.getClosestTrackedHitTo(pullTime, Duration.ofMillis(50));
        assertTrue(closest.isPresent());
        assertEquals(hit3, closest.get());
    }

    public void testGetClosestTrackedHitToOutsideGracePeriod() throws InterruptedException {
        final int amount = 5;
        HitTracker tracker = new HitTracker(() -> true);

        Hit hit1 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount - 1, 500));
        tracker.trackHit(hit1);
        assertTrue(tracker.hasHits());
        Thread.sleep(20);

        Instant pullTime = Instant.now();
        Thread.sleep(30);

        Hit hit2 = new Hit(Optional.of(new Weapon(0, Optional.of(PoisonType.MELEE))), new Hitsplat(0, amount, 1000));
        tracker.trackHit(hit2);
        assertTrue(tracker.hasHits());
        Thread.sleep(50);

        tracker.getOldestHitAfter(pullTime);

        // narrow grace period!
        Optional<Hit> closest = tracker.getClosestTrackedHitTo(pullTime, Duration.ofMillis(10));
        assertFalse(closest.isPresent());
    }

}
package com.poisonednpcs.combat;

import com.poisonednpcs.poison.PoisonType;
import junit.framework.TestCase;

import java.time.Instant;
import java.util.Arrays;

/** Tests for {@link PoisonState}. */
public class PoisonStateTest extends TestCase {

    public void testMarkAmbiguous() {
        PoisonState state = new PoisonState(PoisonType.MELEE);
        assertFalse(state.isAmbiguous());
        state.markAmbiguous();
        assertTrue(state.isAmbiguous());
    }

    public void testNextStep() {
        final PoisonType type = PoisonType.MELEE;

        PoisonState state = new PoisonState(type);
        assertFalse(state.isFinished());
        assertNull(state.getLastSplat());

        int next = state.nextExpectedDamage();
        assertEquals(type.getProgression()[0], next);

        int damageRemaining = state.getDamageRemaining();
        int expectedDamageRemaining = Arrays.stream(type.getProgression()).sum();
        assertEquals(expectedDamageRemaining, damageRemaining);

        state.nextStep();
        assertEquals(damageRemaining - next, state.getDamageRemaining());
    }

    public void testNextStepClearsAmbiguity() {
        final PoisonType type = PoisonType.MELEE;

        PoisonState state = new PoisonState(type);
        assertFalse(state.isAmbiguous());

        state.markAmbiguous();
        assertTrue(state.isAmbiguous());

        state.nextStep();
        assertFalse(state.isAmbiguous());
    }

    public void testFullProgression() {
        final PoisonType type = PoisonType.MELEE;

        PoisonState state = new PoisonState(type);
        assertFalse(state.isFinished());
        assertNull(state.getLastSplat());

        int expectedDamageRemaining = Arrays.stream(type.getProgression()).sum();

        int[] progression = type.getProgression();
        for (int next : progression) {
            assertFalse(state.isFinished());
            int actualDamageRemaining = state.getDamageRemaining();
            assertEquals(expectedDamageRemaining, actualDamageRemaining);
            int nextExpected = state.nextExpectedDamage();
            assertEquals(next, nextExpected);

            state.nextStep();
            expectedDamageRemaining -= nextExpected;
        }
        assertTrue(state.isFinished());
        assertEquals(0, state.nextExpectedDamage());
        assertEquals(0, expectedDamageRemaining);
    }

    public void testSplat() throws InterruptedException {
        final PoisonType type = PoisonType.MELEE;
        PoisonState state = new PoisonState(type);
        assertNull(state.getLastSplat());
        Instant before = Instant.now();
        Thread.sleep(5L);
        state.splat();
        Thread.sleep(5L);
        Instant after = Instant.now();

        Instant lastSplat = state.getLastSplat();
        assertNotNull(lastSplat);
        assertTrue(before.isBefore(lastSplat));
        assertTrue(after.isAfter(lastSplat));
    }
}
package com.poisonednpcs.combat;

import com.poisonednpcs.poison.PoisonType;
import junit.framework.TestCase;
import net.runelite.api.Hitsplat;
import org.junit.Assert;

import java.util.Optional;

public class PoisonTrackerTest extends TestCase {

    public void testRegisterBadSplat() {
        PoisonTracker tracker = new PoisonTracker(poisonHit -> Optional.empty());

        try {
            tracker.registerPoisonSplat(new Hit(Optional.empty(), new Hitsplat(1, 1, 0)));
            Assert.fail("no exception was thrown on bad hitsplat");
        } catch (RuntimeException ex) {}
    }

    public void testRegisterGoodSplat() {
        final PoisonType type = PoisonType.MELEE;
        PoisonTracker tracker = new PoisonTracker(poisonHit -> Optional.empty());

        assertFalse(tracker.getPoisonStatus().isPresent());
        assertFalse(tracker.isPoisoned());

        Hit poisonHit = new Hit(Optional.empty(), new Hitsplat(65, type.getProgression()[0], 0));

        // Java frowns on this but if we're only doing it in testing, let it be so.
        PoisonTracker.getPoisonTypeFromHits = (culpritHit, _poisonHit) -> {
            assertEquals(poisonHit, _poisonHit);
            return type;
        };

        tracker.registerPoisonSplat(poisonHit);
        assertTrue(tracker.getPoisonStatus().isPresent());
        assertFalse(tracker.getPoisonStatus().get().isAmbiguous());
        assertTrue(tracker.isPoisoned());
        assertNotNull(tracker.getPoisonStatus().get().getLastSplat());
    }

    public void testRegisterRestartSplat() {
        final PoisonType type = PoisonType.MELEE;
        PoisonTracker tracker = new PoisonTracker(poisonHit -> Optional.empty());

        assertFalse(tracker.getPoisonStatus().isPresent());
        assertFalse(tracker.isPoisoned());

        Hit poisonHit = new Hit(Optional.empty(), new Hitsplat(65, type.getProgression()[0], 0));

        PoisonTracker.getPoisonTypeFromHits = (culpritHit, _poisonHit) -> type;

        for (int i = 0; type.getProgression()[i] >= type.getProgression()[0] - 1; i++) {
            tracker.registerPoisonSplat(new Hit(Optional.empty(), new Hitsplat(65, type.getProgression()[i], 0)));
            assertFalse(tracker.getPoisonStatus().get().isAmbiguous());
        }

        tracker.registerPoisonSplat(poisonHit);
        assertTrue(tracker.getPoisonStatus().isPresent());
        assertFalse(tracker.getPoisonStatus().get().isAmbiguous());
        assertTrue(tracker.isPoisoned());

        // Ensure that a sequence which is reset is properly configured to handle the next splat. This just means that
        // once a sequence is reset, the next splat should function properly. A previous bug resulted in the timestamp
        // of the resetting splat not being marked in the new sequence, which threw NPEs.
        assertNotNull(tracker.getPoisonStatus().get().getLastSplat());
    }

    public void testRegisterAmbiguousSplat() {
        final PoisonType type = PoisonType.MELEE;
        PoisonTracker tracker = new PoisonTracker(poisonHit -> Optional.empty());

        assertFalse(tracker.getPoisonStatus().isPresent());
        assertFalse(tracker.isPoisoned());

        Hit poisonHit = new Hit(Optional.empty(), new Hitsplat(65, type.getProgression()[0], 0));

        PoisonTracker.getPoisonTypeFromHits = (culpritHit, _poisonHit) -> type;

        for (int i = 0; type.getProgression()[i] == type.getProgression()[0]; i++) {
            tracker.registerPoisonSplat(poisonHit);
            assertFalse(tracker.getPoisonStatus().get().isAmbiguous());
        }

        tracker.registerPoisonSplat(poisonHit);
        assertTrue(tracker.getPoisonStatus().isPresent());
        assertTrue(tracker.getPoisonStatus().get().isAmbiguous());
        assertTrue(tracker.isPoisoned());
        assertNotNull(tracker.getPoisonStatus().get().getLastSplat());
    }

    public void testRegisterFullSequence() {
        final PoisonType type = PoisonType.MELEE;
        PoisonTracker tracker = new PoisonTracker(poisonHit -> Optional.empty());

        assertFalse(tracker.getPoisonStatus().isPresent());
        assertFalse(tracker.isPoisoned());

        PoisonTracker.getPoisonTypeFromHits = (culpritHit, _poisonHit) -> type;

        for (int i = 0; i < type.getProgression().length - 1; i++) {
            tracker.registerPoisonSplat(new Hit(Optional.empty(), new Hitsplat(65, type.getProgression()[i], 0)));
            assertFalse(tracker.getPoisonStatus().get().isAmbiguous());
        }

        tracker.registerPoisonSplat(new Hit(Optional.empty(), new Hitsplat(65, type.getProgression()[type.getProgression().length - 1], 0)));
        assertFalse(tracker.getPoisonStatus().isPresent());
        assertFalse(tracker.isPoisoned());
    }

    public void testGetPoisonTypeFromWeapon() {
        final PoisonType expectedType = PoisonType.RANGED_PLUS;
        PoisonType determinedType = PoisonTracker.getPoisonType(
                Optional.of(new Hit(Optional.of(new Weapon(0, Optional.of(expectedType))), null)),
                new Hit(Optional.empty(), new Hitsplat(0, 3, 0)));
        assertEquals(expectedType, determinedType);
    }

    public void testGetPoisonTypeByMaxHit() {
        final PoisonType expectedType = PoisonType.MELEE_PLUS;
        final int maxDamage = PoisonType.MELEE_PLUS.maxHit();
        PoisonType determinedType = PoisonTracker.getPoisonType(
                Optional.of(new Hit(Optional.of(new Weapon(0, Optional.empty())), null)),
                new Hit(Optional.empty(), new Hitsplat(0, maxDamage, 0)));
        assertEquals(expectedType, determinedType);
    }

    public void testGetDefaultPoisonType() {
        PoisonType determinedType = PoisonTracker.getPoisonType(
                Optional.of(new Hit(Optional.of(new Weapon(0, Optional.empty())), null)),
                new Hit(Optional.empty(), new Hitsplat(0, 3, 0)));
        assertEquals(PoisonType.MELEE, determinedType);
    }
}
package com.poisonednpcs;

import com.poisonednpcs.combat.HealthStatus;
import com.poisonednpcs.combat.PoisonTracker;
import com.poisonednpcs.health.Tracking;
import com.poisonednpcs.npcs.NPCTrackingService;
import com.poisonednpcs.npcs.Opponent;
import com.poisonednpcs.util.DurationUtils;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

public class PoisonedNPCsOverlay extends Overlay {

    private final NPCTrackingService npcTrackingService;
    private final PoisonedNPCsConfig config;

    @Inject
    private PoisonedNPCsOverlay(NPCTrackingService npcTrackingService, PoisonedNPCsConfig config) {
        this.npcTrackingService = npcTrackingService;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (config.displayNPCPoisonOverlay()) {
            // Create a new renderer to do all overlays within this cycle
            PoisonOverlayRenderer overlayRenderer = new PoisonOverlayRenderer(config, graphics);
            // We only render overlays for NPCs with which we are in combat
            npcTrackingService.forEachCombat(overlayRenderer::render);
        }
        return null;
    }

    // TODO: could be an OverlayRenderer interface?
    // TODO: make visible to test? Seems prudent, if I can mock everything I need
    private static class PoisonOverlayRenderer {

        /**
         * The offset to add to a text position's Y value to separate it from other values located at the same
         * position. The value can be thought of as "the height of the text" + "a reasonable vertical margin between
         * texts being displayed".
         */
        private static final int STACKED_OVERLAYS_OFFSET = 15;

        private final PoisonedNPCsConfig config;
        private final Graphics2D graphics;
        private final Map<WorldPoint, Integer> worldPointCounters = new HashMap<>();

        PoisonOverlayRenderer(PoisonedNPCsConfig config, Graphics2D graphics) {
            this.config = config;
            this.graphics = graphics;
        }

        void render(Opponent opponent) {
            WorldPoint worldLocation = opponent.getNPC().getWorldLocation();
            // Increment the number of NPCs we see at this world location. We'll use this to determine the physical
            // Y value (virtual Z value) of the poison overlay.
            int occupantCount = worldPointCounters.merge(worldLocation, 1, Integer::sum);

            boolean isPoisoned = opponent.getHealthStatus().isPoisoned();

            Color color = isPoisoned ? Color.GREEN : Color.YELLOW;
            Optional<String> overlayText = Optional.empty();
            if (!isPoisoned) {
                Duration untilPossiblePoison = Tracking.timeUntilPossiblePoison(opponent.getHealthStatus().getHitTracker());
                if (untilPossiblePoison != Duration.ZERO) {
                    overlayText = Optional.of(DurationUtils.durationToSecondsString(untilPossiblePoison));
                }
            } else {
                overlayText = getPoisonNotificationString(opponent.getHealthStatus());
            }

            overlayText.ifPresent(text -> {
                int zOffset = opponent.getNPC().getLogicalHeight() + 40;
                Point location = opponent.getNPC().getCanvasTextLocation(graphics, "", zOffset);
                if (location != null && location.getX() > 0 && location.getY() > 0) {
                    location = new Point(
                        // adjust the x coordinate by the width of the string
                        location.getX() - graphics.getFontMetrics().stringWidth(text) / 2,
                        // We want the text to appear overhead, but we also need to separate the overlays for NPCs which are
                        // occupying the same tile. So stack them (using the occupantCount) as we cycle over them.
                        location.getY() - STACKED_OVERLAYS_OFFSET * (occupantCount - 1));
                    OverlayUtil.renderTextLocation(graphics, location, text, color);
                }
            });
        }

        private Optional<String> getPoisonNotificationString(HealthStatus status) {
            PoisonTracker poisonTracker = status.getPoisonTracker();
            return poisonTracker.getPoisonStatus()
                    .map(poisonStatus -> {
                        Duration untilNextSplat = Tracking.timeUntilPoisonSplat(poisonStatus);
                        boolean isAmbiguous = poisonStatus.isAmbiguous();

                        StringBuilder output = new StringBuilder(DurationUtils.durationToSecondsString(untilNextSplat));
                        if (config.displayNPCOverlayNextDamage()) {
                            int expectedDamage = poisonStatus.nextExpectedDamage();
                            output.append(" ").append(String.format("(%d%s)", expectedDamage, isAmbiguous ? "+" : ""));
                        }
                        if (config.displayNPCOverlayTotalDamage()) {
                            int damageRemaining = poisonStatus.getDamageRemaining();
                            output.append(" ").append(String.format("[%s%d]", isAmbiguous ? ">=" : "", damageRemaining));
                        }
                        return output.toString();
                    });
        }
    }
}

package com.poisonednpcs;

import com.google.common.base.Predicates;
import com.google.inject.Provides;
import com.poisonednpcs.combat.Hit;
import com.poisonednpcs.combat.Weapon;
import com.poisonednpcs.health.HitsplatType;
import com.poisonednpcs.health.PoisonWatchTimer;
import com.poisonednpcs.npcs.NPCTrackingService;
import com.poisonednpcs.npcs.NPCUtils;
import com.poisonednpcs.npcs.Opponent;
import com.poisonednpcs.npcs.OpponentCuller;
import com.poisonednpcs.poison.PoisonType;
import com.poisonednpcs.util.ArrayUtils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.kit.KitType;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;

import javax.inject.Inject;
import java.util.Optional;

/**
 * Displays the poison status of NPCs which are interacting with the client's player. If the player has hit an NPC with
 * a poisoned weapon, the plugin will display via an info box the time until the next possible moment at which poison
 * may begin to splat. In the event that the NPC is confirmed to be poisoned (by observing a poison splat), the plugin
 * will instead track the time until the next poison splat, the damage that splat will occur, and the total amount of
 * remaining damage that sequence of poison will cause.
 *
 * Because the application of poison is not indicated by the client or the game, the plugin can only guess and confirm
 * when poison splats will occur. Only by eventually observing those poison splats can applied poison be confirmed.
 *
 * The plugin also includes an optional overlay, hidden by default, which will display the time until the next possible
 * poison or the next poison splat directly over the relevant NPC's head. Other configurable parameters, hidden by
 * default, allow the next poison splat damage and total poison damage remaining to be included in the overlay.
 */
@Slf4j
@PluginDescriptor(
	name = "Poisoned NPCs"
)
public class PoisonedNPCsPlugin extends Plugin {

	/**
	 * The maximum distance to an NPC, in discrete local coordinates, at which the plugin should still observe that NPC.
	 */
	private static final int MAX_RENDER_DISTANCE = 1700;

	@Inject
	private Client client;

	// TODO: try to remove this and see if it will works
	@Inject
	private PoisonedNPCsConfig config;

	@Inject
	private PoisonedNPCsOverlay poisonedNPCsOverlay;

	@Inject
	private NPCTrackingService npcTrackingService;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private ItemManager itemManager;

	@Override
	protected void startUp() {
		overlayManager.add(poisonedNPCsOverlay);
	}

	@Override
	protected void shutDown() {
		overlayManager.remove(poisonedNPCsOverlay);
		infoBoxManager.removeIf(t -> t instanceof PoisonWatchTimer);
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
		Actor actor = hitsplatApplied.getActor();
		if (!(actor instanceof NPC)) {
			log.trace(String.format("seeing hitsplat on a non-npc: %s", actor.getName()));
			return;
		}

		NPC npc = (NPC) actor;
		npcTrackingService.enterCombat(npc);

		Opponent opponent = npcTrackingService.getOpponent(NPCUtils.getIdentifier(npc));
		if (opponent == null) {
			log.error(String.format("no registered combat with opponent: %s", npc.getName()));
			return;
		}

		Hitsplat hitsplat = hitsplatApplied.getHitsplat();

		// we pull this value prior to recording the hit in case of concurrency concerns with the box renderer
		// TODO: wonder if we could accomplish the same thing by making this synchronized
		// TODO: should we actually be checking if the opponent was already in combat prior to this hit?
		boolean isActiveTimer = opponent.getHealthStatus().isActive();

		HitsplatType hitsplatType = HitsplatType.of(hitsplat.getHitsplatType());
		switch (hitsplatType) { // TODO: replace with mapping(?)
			case OPPONENT_DAMAGED_BY_ME:
				opponent.getHealthStatus().getHitTracker().trackHit(new Hit(Optional.of(getWieldedWeapon()), hitsplat));
				break;
			case OPPONENT_DAMAGED_BY_POISON:
				opponent.getHealthStatus().getPoisonTracker().registerPoisonSplat(new Hit(Optional.empty(), hitsplat));
				break;
			default:
				// Otherwise we don't care about this hitsplat
				return;
		}

		// if a timer wasn't active before but should be now, set one up now that we're interested
		if (!isActiveTimer && opponent.getHealthStatus().isActive()) {
			PoisonWatchTimer poisonWatchTimer = new PoisonWatchTimer(opponent, itemManager.getImage(ItemID.POISON), this);
			infoBoxManager.addInfoBox(poisonWatchTimer);
		}
		// Hacky way to update the timer tooltip to be informative only on updated hits. This predicate will always
		// return false. It is designed to find the correct timer amid all info boxes and update its tooltip only. The
		// alternative to this is to keep references to timers mapped to opponents, which would interfere with culling
		// timers by the timers' own judgment at the correct times (since garbage collection wouldn't sweep up).
		infoBoxManager.removeIf(PoisonWatchTimer.updateTooltip(opponent));
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		// On every game tick, we cull from our combat tracker any NPC's which have become irrelevant.

		final LocalPoint playerLocation = client.getLocalPlayer().getLocalLocation();

		OpponentCuller culler = OpponentCuller.newBuilder()
			.add(opponent -> opponent.getNPC().isDead())
			// cull any opponents that are not loaded in the current scene
			.add(opponent -> !opponent.getNPC().getLocalLocation().isInScene())
			// cull any opponents that are too far away on the screen (we wouldn't see their hitsplats anyway)
			// TODO: this last condition isn't perfect; we can still have issues; can't tell when the hitsplats are visible
			.add(opponent -> playerLocation.distanceTo(opponent.getNPC().getLocalLocation()) > MAX_RENDER_DISTANCE)
			// poison wears off the instant the NPC stops interacting with the player
			.add(opponent -> !client.getLocalPlayer().equals(opponent.getNPC().getInteracting()))
			.build();

		// cull from both the overlay (through the tracking service) and from the info boxes
		npcTrackingService.cullIf(culler);
		infoBoxManager.removeIf(PoisonWatchTimer.cullOpponents(culler));
	}

	@Provides
	PoisonedNPCsConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(PoisonedNPCsConfig.class);
	}

	/** Retrieves a {@link Weapon} representation of the weapon currently wielded by the client's local player. */
	private Weapon getWieldedWeapon() {
		int weaponId = client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.WEAPON);
		ItemComposition weaponComposition = itemManager.getItemComposition(weaponId);

		// Both here and below, we determine the poison level of the weapon by regex'ing against the weapon's name
		for (PoisonType type : ArrayUtils.filter(PoisonType.values(), PoisonType::isMelee)) {
			if (type.getWeaponRegex().matcher(weaponComposition.getName()).find()) {
				return new Weapon(weaponId, Optional.of(type));
			}
		}

		ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
		Item[] items = itemContainer != null ? itemContainer.getItems() : new Item[0];

		if (items.length > EquipmentInventorySlot.AMMO.getSlotIdx()) {
			final Item ammo = items[EquipmentInventorySlot.AMMO.getSlotIdx()];
			final ItemComposition ammoComposition = itemManager.getItemComposition(ammo.getId());
			for (PoisonType type : ArrayUtils.filter(PoisonType.values(), Predicates.not(PoisonType::isMelee))) {
				if (type.getWeaponRegex().matcher(ammoComposition.getName()).find()) {
					return new Weapon(weaponId, Optional.of(type));
				}
			}
		}

		// We didn't find poison, so treat the weapon as unpoisoned
		return new Weapon(weaponId, Optional.empty());
	}
}

package com.poisonednpcs;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("poisonedNPCs")
public interface PoisonedNPCsConfig extends Config
{

	@ConfigItem(
			keyName = "displayNPCPoisonOverlay",
			name = "Display NPC poison overlay",
			description = "Display a detailed poison overlay with poison status on individual NPCs"
	)
	default boolean displayNPCPoisonOverlay() {
		return false;
	}

	@ConfigItem(
			keyName = "displayNPCOverlayNextDamage",
			name = "Display next poison damage",
			description = "Display what the next poison splat damage within parentheses in the overlay"
	)
	default boolean displayNPCOverlayNextDamage() {
		return false;
	}

	@ConfigItem(
			keyName = "displayNPCOverlayTotalDamage",
			name = "Display poison damage remaining",
			description = "Display the remaining damage the inflicted poison will cause in the overlay"
	)
	default boolean displayNPCOverlayTotalDamage() {
		return false;
	}

	/*@ConfigItem(
			keyName = "testValue",
			name = "Test Value",
			description = "A test value"
	)
	default int testValue() {
		return 40;
	}*/
}

package com.poisonednpcs.util;

import java.util.function.Supplier;

public class Multiline {
    private final StringBuilder builder;

    public Multiline() {
        this.builder = new StringBuilder();
    }

    public Multiline append(String s) {
        builder.append(s).append("</br>");
        return this;
    }

    public Multiline appendIf(boolean condition, Supplier<String> s) {
        if (condition) {
            append(s.get());
        }
        return this;
    }

    @Override
    public String toString() {
        return builder.toString();
    }
}

package com.poisonednpcs.util;

import com.google.common.collect.ImmutableList;

import java.util.*;
import java.util.function.Predicate;

/**
 * Utilities to help with operations affected on arrays. There are libraries which do similar things, but these are
 * defined simplistically to complete necessary operations without concerning ourselves with operational overhead.
 */
public class ArrayUtils {

    public static int[] arrayOf(int... nums) {
        return nums;
    }

    /**
     * Concatenates an arbitrary number of integer arrays, in the order in which they are specified.
     */
    public static int[] concat(int[]... arrs) {
        int sum = 0;
        for (int[] arr : arrs) {
            sum += arr.length;
        }
        int[] result = new int[sum];
        Iterator<int[]> arr = Arrays.stream(arrs).iterator();
        int i = 0;
        while (arr.hasNext()) {
            int[] next = arr.next();
            for (int num : next) {
                result[i++] = num;
            }
        }
        return result;
    }

    /**
     * Filters values from an array based on the specified predicate. Values passing true on the predicate are retained.
     */
    public static <K> Iterable<K> filter(K[] values, Predicate<K> filter) {
        ImmutableList.Builder<K> result = ImmutableList.builder();
        for (K k : values) {
            if (filter.test(k)) {
                result.add(k);
            }
        }
        return result.build();
    }
}

package com.poisonednpcs.util;

import java.time.Duration;

/**
 * Utilities which assist in certain operations affected on {@link Duration}s.
 */
public class DurationUtils {

    public static String durationToSecondsString(Duration duration) {
        if (duration.compareTo(Duration.ZERO) <= 0) {
            return "";
        }
        // TODO: there already exist ways to do this
        long seconds = duration.getSeconds();
        int millis = duration.getNano() / 100000000;
        return String.format("%d.%ds", seconds, millis);
    }

}

package com.poisonednpcs.util;

import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;

public class MapUtils {

    public static <K, V1, V2> Map<K, V2> transformValues(Map<K, V1> original, BiFunction<K, V1, V2> transformer) {
        Map<K, V2> transformed = new HashMap<>();
        original.forEach((k, v1) -> transformed.put(k, transformer.apply(k, v1)));
        return transformed;
    }
}

package com.poisonednpcs.health;

import com.poisonednpcs.combat.HitTracker;
import com.poisonednpcs.combat.PoisonState;
import com.poisonednpcs.npcs.NPCUtils;
import com.poisonednpcs.npcs.Opponent;
import com.poisonednpcs.npcs.OpponentCuller;
import com.poisonednpcs.util.DurationUtils;
import com.poisonednpcs.util.Multiline;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.util.function.Predicate;

/**
 * Defines an info box which displays relevant information about ongoing possibly-poisoned combat with a single NPC.
 * The live timer value will either indicate:
 *  a) the next possible time at which poison could begin to occur, if the NPC is not already poisoned
 *  b) the next time at which poison will splat on the NPC, iff the NPC is poisoned
 *
 * All information regarding poison is retrieved from the opponent specified to this timer at construction time.
 */
public class PoisonWatchTimer extends InfoBox {

    private final Opponent opponent;

    public PoisonWatchTimer(Opponent opponent, BufferedImage image, Plugin plugin) {
        super(image, plugin);
        this.opponent = opponent;
    }

    @Override
    public String getText() {
        Duration toShow;
        if (opponent.getHealthStatus().isPoisoned()) {
            toShow = opponent.getHealthStatus().getPoisonTracker().getPoisonStatus()
                    .map(Tracking::timeUntilPoisonSplat).orElse(Duration.ZERO);
        } else {
            toShow = Tracking.timeUntilPossiblePoison(opponent.getHealthStatus().getHitTracker());
        }
        return DurationUtils.durationToSecondsString(toShow);
    }

    @Override
    public Color getTextColor() {
        return opponent.getHealthStatus().isPoisoned() ? Color.GREEN : Color.YELLOW;
    }

    @Override
    public boolean cull() {
        return !opponent.getHealthStatus().isActive() || opponent.getNPC().isDead();
    }

    /**
     * @return true iff the specified opponent equals the opponent belonging to the timer
     */
    public boolean isForOpponent(Opponent opponent) {
        return NPCUtils.getIdentifier(this.opponent.getNPC()) == NPCUtils.getIdentifier(opponent.getNPC());
    }

    /**
     * Defines a dead predicate which will always return false but will also update any tooltips for
     * {@link PoisonWatchTimer}s whose opponents match the specified opponent. We do this like so in order to avoid
     * needing to maintain outside references to timers which need later tooltip updates; maintain those references
     * would interfere with garbage collection after they have been removed from the info box management.
     *
     * @return a predicate which returns false under all circumstances and updates the tooltip for any timers for this opponent
     */
    public static Predicate<InfoBox> updateTooltip(Opponent opponent) {
        return infoBox -> {
            updateTooltip(infoBox, opponent);
            // THIS MUST ALWAYS BE FALSE! We are intentionally preventing the info box from being removed through here.
            return false;
        };
    }

    private static void updateTooltip(InfoBox infoBox, Opponent opponent) {
        if (!(infoBox instanceof PoisonWatchTimer)) {
            // Not a thing we need to update, leave early
            return;
        }
        PoisonWatchTimer poisonWatchTimer = (PoisonWatchTimer) infoBox;
        if (!poisonWatchTimer.isForOpponent(opponent)) {
            // We don't care about this timer, as it's not for the correct opponent, skip anything else
            return;
        }

        if (opponent.getHealthStatus().isPoisoned()) {
            PoisonState poisonState = opponent.getHealthStatus().getPoisonTracker().getPoisonStatus().get();
            int remainingHealth = opponent.getRemainingHealth();

            poisonWatchTimer.setTooltip(new Multiline()
                .append(String.format("%s is poisoned", opponent.getNPC().getName()))
                .append(String.format("Next poison damage: %d", poisonState.nextExpectedDamage()))
                .append(String.format("Remaining poison damage: %d", poisonState.getDamageRemaining()))
                .append(String.format("Remaining opponent health: %s", remainingHealth < 0 ? "??" : String.format("~%d", remainingHealth)))
                .toString());
        } else if (opponent.getHealthStatus().isActive()) {
            HitTracker hitTracker = opponent.getHealthStatus().getHitTracker();
            int numHits = hitTracker.getNumHits();

            // This means we're getting hit but not poisoned, show the next poison opportunity
            poisonWatchTimer.setTooltip(new Multiline()
                .append(String.format("Next opportunity for %s to be poisoned.", opponent.getNPC().getName()))
                .appendIf(numHits > 0, () -> String.format("%d hit(s) on %s are pending.", numHits, opponent.getNPC().getName()))
                .toString());
        }
    }

    public static Predicate<InfoBox> cullOpponents(OpponentCuller opponentCuller) {
        return infoBox -> {
            if (!(infoBox instanceof PoisonWatchTimer)) {
                // Not a thing we need to update, leave early
                return false;
            }
            PoisonWatchTimer poisonWatchTimer = (PoisonWatchTimer) infoBox;
            return opponentCuller.test(poisonWatchTimer.opponent);
        };
    }
}

package com.poisonednpcs.health;

import com.poisonednpcs.combat.Hit;
import com.poisonednpcs.combat.HitTracker;
import com.poisonednpcs.combat.PoisonState;
import com.poisonednpcs.combat.PoisonTracker;
import com.poisonednpcs.poison.Poison;

import java.time.Duration;
import java.time.Instant;
import java.util.Optional;

/**
 * Utilities regarding tracking delays between hits, poison splats, and expected damage.
 */
public class Tracking {

    /**
     * Based on {@link Hit} information from the {@link HitTracker}, calculates and returns the duration until the
     * next possible time at which poison can occur.
     */
    public static Duration timeUntilPossiblePoison(HitTracker tracker) {
        Optional<Hit> oldestHit = tracker.getOldestHitAfter(Instant.now().minus(Poison.POISON_DELAY));
        if (oldestHit.isEmpty()) {
            return Duration.ZERO;
        }
        return Duration.between(Instant.now(), oldestHit.get().getOccurredAt()).plus(Poison.POISON_DELAY);
    }

    /**
     * Based on the {@link PoisonState}, determines when the next poison splat will occur.
     */
    public static Duration timeUntilPoisonSplat(PoisonState poisonState) {
        return Duration.between(Instant.now(), PoisonTracker.getNextExpectedSplat(poisonState));
    }
}

package com.poisonednpcs.health;

import java.util.HashMap;
import java.util.Map;

public enum HitsplatType {
    OPPONENT_SPLASHED_BY_ME(12),
    OPPONENT_SPLASHED_BY_OTHER(13), // TODO: are by-NPC and by-other-player the same?
    OPPONENT_DAMAGED_BY_ME(16),
    OPPONENT_DAMAGED_BY_OTHER(17), // TODO: are by-NPC and by-other-player the same?
    OPPONENT_DAMAGED_BY_POISON(65), // TODO: distinction between poison from a certain source?
    ;

    private final int _enum;

    HitsplatType(int _enum) {
        this._enum = _enum;
    }

    public static HitsplatType of(int _enum) {
        return VALUES.get(_enum);
    }

    private static Map<Integer, HitsplatType> assembleValues() {
        Map<Integer, HitsplatType> values = new HashMap<>();
        for (HitsplatType value : HitsplatType.values()) {
            values.put(value._enum, value);
        }
        return values;
    }

    public static final Map<Integer, HitsplatType> VALUES = assembleValues();
}

package com.poisonednpcs.poison;

import com.google.common.collect.Iterables;
import lombok.Getter;

import java.util.Arrays;
import java.util.regex.Pattern;

import static com.poisonednpcs.poison.Poison.*;

public enum PoisonType {
    // TODO: avoid double-declaring the regular expressions

    RANGED(false, RANGED_POISON_PROGRESSION, Pattern.compile("\\(p\\)$")),
    RANGED_PLUS(false, RANGED_POISON_PLUS_PROGRESSION, Pattern.compile("\\(p\\+\\)$")),
    RANGED_PLUS_PLUS(false, RANGED_POISON_PLUS_PLUS_PROGRESSION, Pattern.compile("\\(p\\+\\+\\)$")),
    MELEE(true, MELEE_POISON_PROGRESSION, Pattern.compile("\\(p\\)$")),
    MELEE_PLUS(true, MELEE_POISON_PLUS_PROGRESSION, Pattern.compile("\\(p\\+\\)$")),
    MELEE_PLUS_PLUS(true, MELEE_POISON_PLUS_PLUS_PROGRESSION, Pattern.compile("\\(p\\+\\+\\)$")),
    KARAMBWAN(true, MELEE_POISON_PLUS_PLUS_PROGRESSION, Pattern.compile("\\(kp\\)$")),
    // Despite being ranged, enchanted emerald bolts use a progression equivalent to melee poison+ w/an initial 5
    EMERALD_BOLTS_E(false, MELEE_POISON_PLUS_PROGRESSION, Pattern.compile("Emerald bolts \\(e\\)"))
    ;

    private final boolean isMelee;
    @Getter
    private final int[] progression;
    @Getter
    private final Pattern weaponRegex;

    PoisonType(boolean isMelee, int[] progression, Pattern weaponRegex) {
        this.isMelee = isMelee;
        this.progression = progression;
        this.weaponRegex = weaponRegex;
    }

    public boolean isMelee() {
        return isMelee;
    }

    public int maxHit() {
        return Arrays.stream(progression).max().orElse(0);
    }

    // This could be done statically.
    public static Iterable<PoisonType> onlyMelee() {
        return Iterables.filter(Arrays.asList(PoisonType.values()), PoisonType::isMelee);
    }
}

package com.poisonednpcs.poison;

import java.time.Duration;

import static com.poisonednpcs.util.ArrayUtils.arrayOf;
import static com.poisonednpcs.util.ArrayUtils.concat;

public class Poison {

    // TODO: there's probably a library somewhere that has this value
    /** Length of time for one game tick, equal to 600ms. */
    public static final Duration GAME_TICK = Duration.ofMillis(600);
    /** The number of ticks it takes for poison to first splat, assuming it was applied. */
    private static final int POISON_DELAY_IN_TICKS = 30;

    public static final Duration POISON_DELAY = GAME_TICK.multipliedBy(POISON_DELAY_IN_TICKS); // 18 seconds

    static final int[] MELEE_POISON_PROGRESSION =
            arrayOf(4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1);
    static final int[] MELEE_POISON_PLUS_PROGRESSION =
            concat(arrayOf(5, 5, 5, 5, 5), MELEE_POISON_PROGRESSION);
    static final int[] MELEE_POISON_PLUS_PLUS_PROGRESSION =
            concat(arrayOf(6, 6, 6, 6, 6), MELEE_POISON_PLUS_PROGRESSION);

    static final int[] RANGED_POISON_PROGRESSION =
            arrayOf(2, 1, 1, 1, 1, 1);
    static final int[] RANGED_POISON_PLUS_PROGRESSION =
            concat(arrayOf(3, 2, 2, 2, 2), RANGED_POISON_PROGRESSION);
    static final int[] RANGED_POISON_PLUS_PLUS_PROGRESSION =
            concat(arrayOf(4, 3, 3, 3, 3), RANGED_POISON_PLUS_PROGRESSION);
}

package com.poisonednpcs.npcs;

import lombok.Getter;
import net.runelite.api.NPC;
import net.runelite.client.game.NPCManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Predicate;

/**
 * Tracks which NPCs are currently considered to be in combat with the client's player.
 */
@Singleton
public class NPCTrackingService {

    private final Map<Integer, Opponent> inCombat = new HashMap<>();

    @Getter
    private NPCManager manager;

    @Inject
    private NPCTrackingService(NPCManager manager) {
        this.manager = manager;
    }

    public void enterCombat(NPC npc) {
        if (inCombat.containsKey(NPCUtils.getIdentifier(npc))) {
            // nothing to do
            return;
        }
        inCombat.put(NPCUtils.getIdentifier(npc), new Opponent(npc, manager.getHealth(npc.getId())));
    }

    public Opponent getOpponent(int npcId) {
        Opponent opponent = inCombat.get(npcId);
        if (opponent == null) {
            // TODO: make this a specific exception type?
            throw new RuntimeException(String.format("not in combat with opponent: %d", npcId));
        }
        return opponent;
    }

    public void cullIf(Predicate<Opponent> condition) {
        // copy out the list of ids and force to materialize to avoid concurrency issues when we modify the map
        List<Integer> ids = new ArrayList<>(inCombat.keySet());
        for (int id : ids) {
            if (condition.test(inCombat.get(id))) {
                inCombat.remove(id);
            }
        }
    }

    public void forEachCombat(Consumer<Opponent> forEach) {
        inCombat.forEach((id, opponent) -> forEach.accept(opponent));
    }
}

package com.poisonednpcs.npcs;

import com.poisonednpcs.combat.HealthStatus;
import com.poisonednpcs.combat.HitTracker;
import lombok.Getter;
import net.runelite.api.NPC;

public class Opponent {

    private final NPC npc;
    @Getter
    private final int maxHealth;
    @Getter
    private final HealthStatus healthStatus;

    Opponent(NPC npc, Integer maxHealth) {
        this.npc = npc;
        this.maxHealth = maxHealth == null ? -1 : maxHealth;
        this.healthStatus = new HealthStatus(new HitTracker(() -> !npc.isDead()));
    }

    public NPC getNPC() {
        return npc;
    }

    public int getRemainingHealth() {
        int healthRatio = npc.getHealthRatio();
        int healthScale = npc.getHealthScale();

        if (healthRatio < 0 || healthScale < 0) {
            return -1;
        } else if (healthScale == 0) {
            // protecting against divide-by-zero
            return -1;
        }

        return (int)(((double)healthRatio / (double)healthScale) * maxHealth);
    }

}

package com.poisonednpcs.npcs;

import net.runelite.api.NPC;

public class NPCUtils {

    /** Common function to retrieve an identifier for an NPC from the NPC. */
    public static int getIdentifier(NPC npc) {
        // the index is the identifier in the cache; we use this instead of the id because the id refers to NPC's of
        // the same model, and we could be attacking multiple NPC's with the same model.
        return npc.getIndex();
    }
}

package com.poisonednpcs.npcs;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;

import java.util.function.Predicate;

/**
 * Allows many different {@link Predicate}s on an {@link Opponent} to be grouped together as a single predicate, where
 * FULFILLING ANY SINGLE PREDICATE within the grouping will count as passing the aggregated predicate.
 */
public class OpponentCuller implements Predicate<Opponent> {

    private final ImmutableList<Predicate<Opponent>> predicates;

    private OpponentCuller(ImmutableList<Predicate<Opponent>> predicates) {
        this.predicates = predicates;
    }

    @Override
    public boolean test(Opponent opponent) {
        // ANY predicate passing passes the whole thing
        return Iterables.any(predicates, p -> p.test(opponent));
    }

    public static Builder newBuilder() {
        return new Builder();
    }

    public static class Builder {
        private final ImmutableList.Builder<Predicate<Opponent>> predicates = ImmutableList.builder();

        private Builder() {}

        public Builder add(Predicate<Opponent> predicate) {
            predicates.add(predicate);
            return this;
        }

        public OpponentCuller build() {
            return new OpponentCuller(predicates.build());
        }
    }
}

package com.poisonednpcs.combat;

import com.poisonednpcs.poison.PoisonType;
import lombok.Getter;

import java.util.Optional;

public class Weapon {

    private final int id;
    @Getter
    private final Optional<PoisonType> poisonType;

    public Weapon(int id, Optional<PoisonType> poisonType) {
        this.id = id;
        this.poisonType = poisonType;
    }
}

package com.poisonednpcs.combat;

import lombok.Getter;
import net.runelite.api.Hitsplat;

import java.time.Instant;
import java.util.Optional;

@Getter
public class Hit {

    private final Optional<Weapon> weapon;
    private final Hitsplat hitsplat;
    private final Instant occurredAt;

    public Hit(Optional<Weapon> weapon, Hitsplat hitsplat) {
        this.weapon = weapon;
        this.hitsplat = hitsplat;
        // TODO: a little sus to just assume that a created hit occurred at the time this object was instantiated
        this.occurredAt = Instant.now();
    }
}

package com.poisonednpcs.combat;

import com.google.common.annotations.VisibleForTesting;
import com.poisonednpcs.poison.Poison;
import lombok.Getter;

import java.time.Duration;

@Getter
public class HealthStatus {

    @VisibleForTesting
    static Duration HIT_TO_POISON_DELAY = Poison.POISON_DELAY;

    /** Grace period that we allow when examining if hits occurred at certain times, here defined as a game tick. */
    private static final Duration HIT_TRACKING_GRACE_PERIOD = Poison.GAME_TICK;

    private final PoisonTracker poisonTracker;
    private final HitTracker hitTracker;

    // TODO: do we really need to pass the HitTracker in?
    public HealthStatus(HitTracker hitTracker) {
        this.hitTracker = hitTracker;
        this.poisonTracker = new PoisonTracker(poisonHit -> hitTracker.getClosestTrackedHitTo(
                poisonHit.getOccurredAt().minus(HIT_TO_POISON_DELAY),
                HIT_TRACKING_GRACE_PERIOD));
    }

    public boolean isActive() {
        return hitTracker.hasHits() || isPoisoned();
    }

    public boolean isPoisoned() {
        return poisonTracker.isPoisoned();
    }
}

package com.poisonednpcs.combat;

import com.google.common.annotations.VisibleForTesting;
import com.poisonednpcs.health.HitsplatType;
import com.poisonednpcs.poison.Poison;
import com.poisonednpcs.poison.PoisonType;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;

/**
 * Tracks and controls the progression of a poison sequence. Supports a "refresh" of the poison sequence in which
 * re-poisoning occurred at an undetermined point. Will continue to maintain the sequence and manage information
 * until the ambiguity removes itself, at which time it will resume the progression.
 */
@Slf4j
public class PoisonTracker {

    @VisibleForTesting
    static BiFunction<Optional<Hit>, Hit, PoisonType> getPoisonTypeFromHits = PoisonTracker::getPoisonType;

    private final Function<Hit, Optional<Hit>> getPoisoningHitFn;

    private Optional<PoisonState> current;

    /**
     * @param getPoisoningHitFn function which takes the first poison hit of the sequence and attempts to return the
     *                          hit which applied the poison.
     */
    public PoisonTracker(Function<Hit, Optional<Hit>> getPoisoningHitFn) {
        this.getPoisoningHitFn = getPoisoningHitFn;
        this.current = Optional.empty();
    }

    public void registerPoisonSplat(Hit hit) {
        if (HitsplatType.of(hit.getHitsplat().getHitsplatType()) != HitsplatType.OPPONENT_DAMAGED_BY_POISON) {
            throw new RuntimeException(String.format("hit is not a poisoning hit: %d", hit.getHitsplat().getHitsplatType()));
        }

        if (current.isEmpty()) {
            // new poison sequence, build a brand new status based on the amount of damage
            current = Optional.of(newPoisonSequence(hit));
        }

        int amount = hit.getHitsplat().getAmount();
        int expectedNextDamage = current.get().nextExpectedDamage();
        // TODO: any way to do this sequence without if statements?
        if (amount == current.get().nextExpectedDamage()) {
            // everything matches expectations, proceed as normal
            current.get().nextStep();
        } else if (expectedNextDamage < amount - 1) {
            // This means the poison's max hit occurred, i.e., we restarted the sequence
            current = Optional.of(newPoisonSequence(hit));
            current.get().nextStep();
        } else if (expectedNextDamage < amount) {
            // we re-applied the poison but we don't know when! Hold position and introduce uncertainty
            current.get().markAmbiguous();
        } else {
            // This implies that the expected damage was GREATER than the amount that we saw, meaning our calculations
            // are off. Optimistically step and mark ambiguity, but this could indicate greater issues.
            current.get().nextStep();
            current.get().markAmbiguous();
        }

        // Register that the poison splat happened. We do this AFTER the above sequence checks to make sure that
        // any reset sequence is properly splatted as well.
        current.get().splat();

        // if we just applied our last piece of poison damage, kill the sequence altogether
        if (current.get().isFinished()) {
            current = Optional.empty();
        }
    }

    public Optional<PoisonState> getPoisonStatus() {
        return current;
    }

    public boolean isPoisoned() {
        return current.isPresent();
    }

    public static Instant getNextExpectedSplat(PoisonState poisonState) {
        return poisonState.getLastSplat().plus(Poison.POISON_DELAY);
    }

    private PoisonState newPoisonSequence(Hit poisonHit) {
        Optional<Hit> hitWhichCausedPoisoning = getPoisoningHitFn.apply(poisonHit);
        PoisonType poisonType = getPoisonTypeFromHits.apply(hitWhichCausedPoisoning, poisonHit);
        return new PoisonState(poisonType);
    }

    @VisibleForTesting
    static PoisonType getPoisonType(Optional<Hit> culpritHit, Hit poisonHit) {
        // defined here so that we can change as necessary during writing/debugging
        final Consumer<String> logFn = log::debug;

        logFn.accept(String.format("Culprit hit presence: %b", culpritHit.isPresent()));
        if (culpritHit.isPresent()) {
            Optional<Weapon> weapon = culpritHit.get().getWeapon();
            if (weapon.map(w -> w.getPoisonType().isPresent()).orElse(false)) {
                logFn.accept(String.format("Poison type detected from weapon: %s", weapon.get().getPoisonType()));
                return weapon.get().getPoisonType().get();
            }
        }

        // else we don't know the weapon that caused the poison, and we have to guess
        // RIGHT NOW, WE ALWAYS GUESS MELEE
        for (PoisonType poisonType : PoisonType.onlyMelee()) {
            // TODO: there's a danger here that we could mis-identify the poison type because (p++) and (kp) have the
            //  same progression; as is, that won't hurt anything, but if the poison type is displayed, it will be wrong
            if (poisonHit.getHitsplat().getAmount() == poisonType.maxHit()) {
                logFn.accept(String.format("Poison type detected from max hit: %s", poisonType));
                return poisonType;
            }
        }
        // when all else fails, we're not exactly hurting the situation by a conservativeish guess
        logFn.accept("Poison type defaulted");
        return PoisonType.MELEE;
    }
}

package com.poisonednpcs.combat;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Optional;
import java.util.function.Supplier;

public class HitTracker {

    private final Deque<Hit> hits = new ArrayDeque<>();
    private final Supplier<Boolean> isActive;

    private Hit pastHit = null;

    public HitTracker(Supplier<Boolean> isActive) {
        this.isActive = isActive;
    }

    public void trackHit(Hit hit) {
        // TODO: this seems like a good opportunity to use an interface to make this a special case thing.
        if (!hit.getWeapon().map(weapon -> weapon.getPoisonType().isPresent()).orElse(false)) {
            // The weapon isn't poisoned, so don't even bother tracking the hit.
            return;
        }
        hits.add(hit);
    }

    public Optional<Hit> getOldestHitAfter(Instant time) {
        while (!hits.isEmpty() && hits.peek().getOccurredAt().isBefore(time)) {
            pastHit = hits.poll();
        }
        return hasHits() ? Optional.of(hits.peek()) : Optional.empty();
    }

    public boolean hasHits() {
        return isActive.get() && !hits.isEmpty();
    }

    public int getNumHits() {
        return hits.size();
    }

    synchronized Optional<Hit> getClosestTrackedHitTo(Instant instant, Duration within) {
        Optional<Hit> past = Optional.ofNullable(pastHit);
        Optional<Hit> next = hits.isEmpty() ? Optional.empty() : Optional.of(hits.peek());

        Optional<Duration> pastDifference = past.map(ph -> Duration.between(instant, ph.getOccurredAt()).abs());
        Optional<Duration> nextDifference = next.map(nh -> Duration.between(instant, nh.getOccurredAt()).abs());

        if (pastDifference.isPresent() && nextDifference.isPresent()) {
            int cmp = pastDifference.get().compareTo(nextDifference.get());
            if (cmp < 0 && pastDifference.get().compareTo(within) < 0) {
                return past;
            } else if (nextDifference.get().compareTo(within) < 0) {
                return next;
            }
        } else if (pastDifference.map(pd -> pd.compareTo(within) < 0).orElse(false)) {
            return past;
        } else if (nextDifference.map(nd -> nd.compareTo(within) < 0).orElse(false)) {
            return next;
        }

        return Optional.empty();
    }
}

package com.poisonednpcs.combat;

import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;
import com.poisonednpcs.poison.PoisonType;
import lombok.Getter;

import java.time.Instant;
import java.util.Arrays;

/**
 * Records and controls the state of a poison progression, including the poison damage which has yet to occur within
 * the progression, the next expected poison splat, and the time at which the last poison splat occurred.
 */
public class PoisonState {

    private final PeekingIterator<Integer> progression;

    @Getter
    private int damageRemaining;
    private boolean isInAmbiguousState = false;
    private Instant lastSplat;

    PoisonState(PoisonType poisonType) {
        this.progression = Iterators.peekingIterator(Arrays.stream(poisonType.getProgression()).iterator());
        this.damageRemaining = Arrays.stream(poisonType.getProgression()).sum();
    }

    public boolean isAmbiguous() {
        return isInAmbiguousState;
    }

    public int nextExpectedDamage() {
        return isFinished() ? 0 : progression.peek();
    }

    int nextStep() {
        damageRemaining -= progression.peek();
        // once we step, we have a definitive place in the poison progression again and are no longer ambiguous
        isInAmbiguousState = false;
        return isFinished() ? 0 : progression.next();
    }

    boolean isFinished() {
        return !progression.hasNext();
    }

    void splat() {
        lastSplat = Instant.now();
    }

    Instant getLastSplat() {
        return lastSplat;
    }

    void markAmbiguous() {
        isInAmbiguousState = true;
    }
}

