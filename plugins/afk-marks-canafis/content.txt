package com.marksofgracecooldown;

import com.google.common.collect.ImmutableMap;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import java.util.Map;
import java.util.function.Predicate;

/**
 * Enum representing Marks of Grace courses with their last obstacle IDs,
 * region IDs, and course end world points.
 */
enum Courses {
    // Rooftop courses
    DRAYNOR(new int[]{11632}, 12338, 44, new WorldPoint(3103, 3261, 0)),
    AL_KHARID(new int[]{14399}, 13105, 65, new WorldPoint(3299, 3194, 0)),
    VARROCK(new int[]{14841}, 12853, 66, new WorldPoint(3236, 3417, 0)),
    CANIFIS(new int[]{14897}, 13878, 44, new WorldPoint(3510, 3485, 0)),
    FALADOR(new int[]{14925}, 12084, 59, new WorldPoint(3029, 3332, 0), new WorldPoint(3029, 3333, 0), new WorldPoint(3029, 3334, 0), new WorldPoint(3029, 3335, 0)),
    // SEERS: default optimal time 44, but if the useSeersTeleport toggle is enabled use 38
    SEERS(new int[]{14931}, 10806, 44, ImmutableMap.of("useSeersTeleport", 38), new WorldPoint(2704, 3464, 0)),
    POLLNIVNEACH(new int[]{14945}, 13358, 61, new WorldPoint(3363, 2998, 0)),
    RELLEKA(new int[]{14994}, 10553, 51, new WorldPoint(2653, 3676, 0)),
    ARDOUGNE(new int[]{15612}, 10547, 46, new WorldPoint(2668, 3297, 0)),
    // Other courses
    GNOME(new int[]{23138, 23139}, 9781, 34, new WorldPoint(2484, 3437, 0), new WorldPoint(2487, 3437, 0)), // Gnome course has 2 last obstacles
    SHAYZIEN_BASIC(new int[]{42216}, 6200, 53, new WorldPoint(1554, 3640, 0)),
    BARBARIAN(new int[]{1948}, 10039, 32, new WorldPoint(2543, 3553, 0)),
    SHAYZIEN_ADVANCED(new int[]{42221}, 5944, 49, new WorldPoint(1522, 3625, 0)),
    APE_ATOLL(new int[]{16062}, 11050, 39, new WorldPoint(2770, 2747, 0)),
    WEREWOLF(new int[]{11644, 11645, 11646}, 14234, 38, new WorldPoint(3528, 9873, 0));


    private static final Map<Integer, Courses> coursesByRegion;
    @Getter
    private final int[] lastObstacleIds;
    @Getter
    private final int regionId;
    @Getter
    private final int optimalTimeSeconds;
    @Getter
    private final WorldPoint[] courseEndWorldPoints;

    // Map of conditional toggle key -> alternative optimal time
    private final Map<String, Integer> conditionalOptimalTimes;

    // Primary constructor with conditional map
    Courses(int[] lastObstacleIds, int regionId, int optimalTimeSeconds, Map<String, Integer> conditionalOptimalTimes, WorldPoint... courseEndWorldPoints) {
        // Defensive copy to avoid external mutation
        this.lastObstacleIds = lastObstacleIds == null ? new int[0] : lastObstacleIds.clone();
        this.optimalTimeSeconds = optimalTimeSeconds;
        this.regionId = regionId;
        this.courseEndWorldPoints = courseEndWorldPoints;
        this.conditionalOptimalTimes = conditionalOptimalTimes == null ? ImmutableMap.of() : conditionalOptimalTimes;
    }

    // Convenience constructor when there are no conditionals
    Courses(int[] lastObstacleIds, int regionId, int optimalTimeSeconds, WorldPoint... courseEndWorldPoints) {
        this(lastObstacleIds, regionId, optimalTimeSeconds, ImmutableMap.of(), courseEndWorldPoints);
    }

    static Courses getCourse(int regionId) {
        return coursesByRegion.get(regionId);
    }

    /**
     * Returns the effective optimal time, checking conditionalOptimalTimes in insertion order
     * and returning the first match where toggleEnabled.test(key) is true. If none match,
     * returns the default optimalTimeSeconds.
     */
    int getOptimalTime(Predicate<String> toggleEnabled) {
        for (Map.Entry<String, Integer> e : conditionalOptimalTimes.entrySet()) {
            if (toggleEnabled.test(e.getKey())) {
                return e.getValue();
            }
        }
        return optimalTimeSeconds;
    }

    /**
     * Returns true if the provided obstacle id matches any of this course's last-obstacle IDs.
     */
    boolean containsLastObstacle(int id) {
        for (int o : lastObstacleIds) {
            if (o == id) return true;
        }
        return false;
    }

    /**
     * Checks if this course is enabled in the config.
     */
    boolean isEnabled(MarksOfGraceCDConfig config) {
        switch (this) {
            case DRAYNOR: return config.enableDraynor();
            case AL_KHARID: return config.enableAlKharid();
            case VARROCK: return config.enableVarrock();
            case CANIFIS: return config.enableCanifis();
            case FALADOR: return config.enableFalador();
            case SEERS: return config.enableSeers();
            case POLLNIVNEACH: return config.enablePollnivneach();
            case RELLEKA: return config.enableRelleka();
            case ARDOUGNE: return config.enableArdougne();
            case GNOME: return config.enableGnome();
            case SHAYZIEN_BASIC: return config.enableShayzienBasic();
            case BARBARIAN: return config.enableBarbarian();
            case SHAYZIEN_ADVANCED: return config.enableShayzienAdvanced();
            case APE_ATOLL: return config.enableApeAtoll();
            case WEREWOLF: return config.enableWerewolf();
            default: return true;
        }
    }

    static {
        ImmutableMap.Builder<Integer, Courses> builder = new ImmutableMap.Builder<>();

        for (Courses course : values()) {
            builder.put(course.regionId, course);
        }

        coursesByRegion = builder.build();
    }
}

package com.marksofgracecooldown;

import net.runelite.client.config.*;

@ConfigGroup("AfkMarksCanafis")  // Old name from when it was canifis only
public interface MarksOfGraceCDConfig extends Config {
    @ConfigItem(
            keyName = "cooldownNotifier",
            name = "Cooldown notification",
            description = "Send a notification when the cooldown expires<br>and you can collect a new mark.",
            position = 0
    )
    default Notification notifyMarksOfGraceCD() {
        return Notification.ON;
    }

    @ConfigItem(
            keyName = "lapTimeBuffer",
            name = "Lap time buffer",
            description =
                    "Extra seconds added to the optimal lap time to<br>" +
                    "give you more room for slower or imperfect laps.<br>" +
                    "Recommended: 2-4 seconds.",
            position = 1
    )
    @Units(Units.SECONDS)
    default int lapTimeBuffer() { return 2; }

    // Replaced the previous boolean setting `swapLeftClickOnWait` with an enum dropdown
    // to allow three modes: OFF, SWAP_WHEN_CANNOT_COMPLETE_LAP (previous behaviour),
    // and SWAP_WHEN_NOT_EXPIRED (always swap while cooldown active).
    enum SwapLeftClickMode {
        OFF("Off"),
        WHEN_CANNOT_COMPLETE_LAP("Near end"),
        WHEN_NOT_EXPIRED("Always");

        private final String label;

        SwapLeftClickMode(String label) {
            this.label = label;
        }

        @Override
        public String toString() {
            return label;
        }
    }

    @ConfigItem(
            keyName = "swapLeftClickMode",
            name = "Swap mode",
            description =
                    "Deprioritize left-click on the final obstacle to<br>" +
                    "help prevent accidentally finishing a lap too early.<br>" +
                    "Off: never deprioritize.<br>" +
                    "Near end: only when the overlay shows 'Wait'.<br>" +
                    "Always: whenever the cooldown is active.",
            position = 2
    )
    default SwapLeftClickMode swapLeftClickMode() {
        return SwapLeftClickMode.OFF; // keep previous default (disabled)
    }

    @ConfigItem(
            keyName = "useCustomLapTime",
            name = "Use custom lap time",
            description =
                    "Replace the built-in optimal lap time with your<br>" +
                    "own custom value. Leave disabled to use the<br>" +
                    "course-specific lap times (recommended).",
            position = 3
    )
    default boolean useCustomLapTime() { return false; }

    @ConfigItem(
            keyName = "customLapTimeSeconds",
            name = "Custom lap time",
            description =
                    "Your custom lap time in seconds.<br>" +
                    "Only used when 'Use custom lap time' is enabled.",
            position = 4
    )
    @Units(Units.SECONDS)
    default int customLapTimeSeconds() {
        return 180;
    }

    @ConfigItem(
            keyName = "useShortArdougneTimer",
            name = "Use short Ardougne timer",
            description =
                    "With the Ardougne Elite Diary, the cooldown has a<br>" +
                    "50% chance to be reduced to 2 minutes. Enable this<br>" +
                    "to use the shorter timer instead of the full 3 minutes.",
            position = 5
    )
    default boolean useShortArdougneTimer() {
        return false;
    }

    @ConfigItem(
            keyName = "useSeersTeleport",
            name = "Use Seers bank teleport",
            description =
                    "Enable if you use the Camelot teleport to bank<br>" +
                    "after each lap. This shortens the optimal lap time.<br>" +
                    "Requires the Hard Kandarin Diary.",
            position = 6
    )
    default boolean useSeersTeleport() {return false;}

    @ConfigSection(
            name = "Per-course",
            description = "Choose which courses the plugin is active on.",
            position = 7,
            closedByDefault = true
    )
    String perCourse = "perCourse";

    @ConfigItem(
            keyName = "enableDraynor",
            name = "Draynor Rooftop",
            description = "Enable plugin on the Draynor rooftop course.",
            position = 8,
            section = perCourse
    )
    default boolean enableDraynor() { return true; }

    @ConfigItem(
            keyName = "enableAlKharid",
            name = "Al Kharid Rooftop",
            description = "Enable plugin on the Al Kharid rooftop course.",
            position = 9,
            section = perCourse
    )
    default boolean enableAlKharid() { return true; }

    @ConfigItem(
            keyName = "enableVarrock",
            name = "Varrock Rooftop",
            description = "Enable plugin on the Varrock rooftop course.",
            position = 10,
            section = perCourse
    )
    default boolean enableVarrock() { return true; }

    @ConfigItem(
            keyName = "enableCanifis",
            name = "Canifis Rooftop",
            description = "Enable plugin on the Canifis rooftop course.",
            position = 11,
            section = perCourse
    )
    default boolean enableCanifis() { return true; }

    @ConfigItem(
            keyName = "enableFalador",
            name = "Falador Rooftop",
            description = "Enable plugin on the Falador rooftop course.",
            position = 12,
            section = perCourse
    )
    default boolean enableFalador() { return true; }

    @ConfigItem(
            keyName = "enableSeers",
            name = "Seers Rooftop",
            description = "Enable plugin on the Seers' Village rooftop course.",
            position = 13,
            section = perCourse
    )
    default boolean enableSeers() { return true; }

    @ConfigItem(
            keyName = "enablePollnivneach",
            name = "Pollnivneach Rooftop",
            description = "Enable plugin on the Pollnivneach rooftop course.",
            position = 14,
            section = perCourse
    )
    default boolean enablePollnivneach() { return true; }

    @ConfigItem(
            keyName = "enableRelleka",
            name = "Rellekka Rooftop",
            description = "Enable plugin on the Rellekka rooftop course.",
            position = 15,
            section = perCourse
    )
    default boolean enableRelleka() { return true; }

    @ConfigItem(
            keyName = "enableArdougne",
            name = "Ardougne Rooftop",
            description = "Enable plugin on the Ardougne rooftop course.",
            position = 16,
            section = perCourse
    )
    default boolean enableArdougne() { return true; }

    @ConfigItem(
            keyName = "enableGnome",
            name = "Gnome Course",
            description = "Enable plugin on the Gnome agility course.",
            position = 17,
            section = perCourse
    )
    default boolean enableGnome() { return true; }

    @ConfigItem(
            keyName = "enableShayzienBasic",
            name = "Shayzien (Basic)",
            description = "Enable plugin on the Shayzien basic course.",
            position = 18,
            section = perCourse
    )
    default boolean enableShayzienBasic() { return true; }

    @ConfigItem(
            keyName = "enableBarbarian",
            name = "Barbarian Outpost",
            description = "Enable plugin on the Barbarian Outpost course.",
            position = 19,
            section = perCourse
    )
    default boolean enableBarbarian() { return true; }

    @ConfigItem(
            keyName = "enableShayzienAdvanced",
            name = "Shayzien (Advanced)",
            description = "Enable plugin on the Shayzien advanced course.",
            position = 20,
            section = perCourse
    )
    default boolean enableShayzienAdvanced() { return true; }

    @ConfigItem(
            keyName = "enableApeAtoll",
            name = "Ape Atoll",
            description = "Enable plugin on the Ape Atoll course.",
            position = 21,
            section = perCourse
    )
    default boolean enableApeAtoll() { return true; }

    @ConfigItem(
            keyName = "enableWerewolf",
            name = "Werewolf Agility",
            description = "Enable plugin on the Werewolf agility course.",
            position = 22,
            section = perCourse
    )
    default boolean enableWerewolf() { return true; }


    @ConfigSection(
            name = "Advanced",
            description =
                    "Fine-tuning options. Most users can leave<br>" +
                    "these at their default values.",
            position = 23,
            closedByDefault = true
    )
    String advanced = "advanced";

    @ConfigItem(
            keyName = "assumeHardKandarinDiary",
            name = "Assume Hard Kandarin diary",
            description =
                    "Force the plugin to treat you as having the Hard<br>" +
                    "Kandarin Diary. Only enable this if you have the<br>" +
                    "diary but automatic detection isn't working.",
            position = 24,
            section = advanced
    )
    default boolean assumeHardKandarinDiary() { return false; }

    @ConfigItem(
            keyName = "enableNtpSync",
            name = "Enable NTP time sync",
            description =
                    "Sync with an internet time server to correct for<br>" +
                    "system clock drift. Recommended if your computer's<br>" +
                    "clock is not accurate.",
            position = 25,
            section = advanced
    )
    default boolean enableNtpSync() {
        return true;
    }

    @ConfigItem(
            keyName = "enableWorldPing",
            name = "Enable world ping",
            description =
                    "Measure your connection latency and use it to<br>" +
                    "improve timer accuracy. Disable if you don't want<br>" +
                    "the plugin making network requests.",
            position = 26,
            section = advanced
    )
    default boolean enableWorldPing() {
        return true;
    }

    @ConfigItem(
            keyName = "pingRefreshInterval",
            name = "Ping refresh interval",
            description =
                    "How often to re-measure your connection latency.<br>" +
                    "Higher values reduce network activity.",
            position = 27,
            section = advanced
    )
    @Units(Units.SECONDS)
    default int pingRefreshInterval() {
        return 15;
    }

    @ConfigItem(
            keyName = "timerBufferSeconds",
            name = "Timer buffer",
            description =
                    "Extra seconds added to the cooldown timer. Increase<br>" +
                    "this (try 1-3) if the overlay says 'Run' but marks<br>" +
                    "don't spawn yet.",
            position = 28,
            section = advanced
    )
    @Units(Units.SECONDS)
    default int timerBufferSeconds() {
        return 0;
    }

    @ConfigItem(
            keyName = "showDebugValues",
            name = "Show debug values",
            description =
                    "Display extra information in the overlay such as<br>" +
                    "lap times, NTP sync status, and connection latency.<br>" +
                    "Useful for troubleshooting timing issues.",
            position = 29,
            section = advanced
    )
    default boolean showDebugValues() {
        return false;
    }

}

package com.marksofgracecooldown;

import com.marksofgracecooldown.ntp.NtpClient;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;

class MarksOfGraceCDOverlay extends OverlayPanel {
    private static final int TIMEOUT_MINUTES = 5;
    private static final long TIMEOUT_MILLIS = TIMEOUT_MINUTES * MarksOfGraceCDPlugin.MILLIS_PER_MINUTE;

    private final MarksOfGraceCDPlugin plugin;

    @Inject
    private MarksOfGraceCDConfig config;

    @Inject
    public MarksOfGraceCDOverlay(MarksOfGraceCDPlugin plugin) {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        this.plugin = plugin;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (plugin.lastCompleteMarkTimeMillis == 0) {
            return null;
        }

        if (plugin.currentCourse != null && !plugin.isCourseEnabled(plugin.currentCourse)) {
            return null;
        }

        long currentMillis = Instant.now().toEpochMilli();

        if (currentMillis - plugin.lastCompleteTimeMillis > TIMEOUT_MILLIS) {
            resetPluginState();
            return null;
        }

        long cooldownTimestamp = plugin.getCooldownTimestamp(false);
        long secondsLeft = getSecondsLeft(cooldownTimestamp, currentMillis);

        renderStatusTitle(secondsLeft);
        addLine("Time until run:", formatTime(secondsLeft));

        if (plugin.hasReducedCooldown) {
            addLine("Reduced time:", formatTime(Math.max(secondsLeft - 60, 0)));
        }

        if (config.showDebugValues() && plugin.currentCourse != null) {
            renderDebugInfo();
        }

        return super.render(graphics);
    }

    private void resetPluginState() {
        plugin.lastCompleteMarkTimeMillis = 0;
        plugin.lastCompleteTimeMillis = 0;
        plugin.currentCourse = null;
    }

    private long getSecondsLeft(long cooldownTimestamp, long currentMillis) {
        long millisLeft = Math.max(cooldownTimestamp - currentMillis, 0);
        return (long) Math.ceil((double) millisLeft / 1000);
    }

    private void renderStatusTitle(long secondsLeft) {
        if (!plugin.isOnCooldown) {
            addTitle("Run", Color.GREEN);
            return;
        }

        int thresholdSeconds = plugin.currentCourse != null
                ? plugin.getLapThresholdSeconds(plugin.currentCourse) : 0;

        if (secondsLeft >= thresholdSeconds) {
            addTitle("XP", Color.ORANGE);
        } else {
            addTitle("Wait", Color.RED);
        }
    }

    private void renderDebugInfo() {
        int baseOptimal = plugin.currentCourse.getOptimalTime(key ->
                "useSeersTeleport".equals(key) && config.useSeersTeleport() &&
                        (config.assumeHardKandarinDiary() || plugin.hasHardKandarinDiary()));
        int combined = Math.max(0, baseOptimal + config.lapTimeBuffer());

        addLine("Base lap time:", formatTime(baseOptimal));
        addLine("Combined lap time:", formatTime(combined));

        int ping = plugin.getLastWorldPing();
        addLine("World ping:", ping >= 0 ? ping + "ms" : "N/A");

        if (config.enableNtpSync()) {
            addLine("NTP status:", NtpClient.getSyncState().toString());
            long offset = NtpClient.getSyncedOffsetMillis();
            addLine("Clock offset:", (offset >= 0 ? "+" : "") + offset + "ms");
        }
    }

    private void addTitle(String text, Color color) {
        panelComponent.getChildren().add(TitleComponent.builder()
                .text(text)
                .color(color)
                .build());
    }

    private void addLine(String left, String right) {
        panelComponent.getChildren().add(LineComponent.builder()
                .left(left)
                .right(right)
                .build());
    }

    private String formatTime(long totalSeconds) {
        return String.format("%d:%02d", (totalSeconds % 3600) / 60, totalSeconds % 60);
    }
}

package com.marksofgracecooldown;

import com.google.inject.Provides;
import com.marksofgracecooldown.ntp.NtpClient;
import com.marksofgracecooldown.ntp.NtpSyncState;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.TileItem;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemSpawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.WorldChanged;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.Notifier;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.worldhopper.ping.Ping;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;

import javax.inject.Inject;
import java.time.Instant;
import java.util.Arrays;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import static net.runelite.api.Skill.AGILITY;

@Slf4j
@PluginDescriptor(
        name = "Marks of Grace Cooldown",
        description = "Tracks the cooldown for Marks of Grace on Agility Courses, allowing you to time your laps, AFK or do other activities",
        tags = {"mark", "of", "grace", "afk", "cooldown", "tracker", "canifis", "agility"},
        configName = "AfkMarksCanafisPlugin" // Old name from when it was canifis only
)
public class MarksOfGraceCDPlugin extends Plugin {
    public static final long MILLIS_PER_MINUTE = 60_000;
    private static final int MARK_COOLDOWN_MINUTES = 3;
    public long lastCompleteMarkTimeMillis;
    public long lastCompleteTimeMillis;
    public boolean isOnCooldown = false;
    public boolean hasReducedCooldown = false;
    Courses currentCourse;
    @Inject
    private Client client;
    @Inject
    private MarksOfGraceCDConfig config;
    @Inject
    private Notifier notifier;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private MarksOfGraceCDOverlay marksCooldownOverlay;
    @Inject
    private WorldService worldService;
    @Inject
    private ConfigManager configManager;
    private ScheduledExecutorService pingExecutor;
    // last measured ping to the current RS world in ms; -1 == unknown
    @Setter
    @Getter
    private volatile int lastWorldPing = -1;

    // track whether we've updated the kandarin detection config for this login session
    private volatile boolean kandarinDetectionConfigUpdated = false;

    @Provides
    MarksOfGraceCDConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(MarksOfGraceCDConfig.class);
    }

    // Package-private setter used by tests to inject a fake config without reflection
    void setConfig(MarksOfGraceCDConfig config) {
        this.config = config;
    }

    @Override
    protected void startUp() {
        overlayManager.add(marksCooldownOverlay);
        kandarinDetectionConfigUpdated = false;
        // Attempt to update kandarin detection status (will only take effect if logged in)
        updateKandarinDetectedConfigIfNeeded();

        // Start NTP sync if enabled to correct for system clock drift
        if (config.enableNtpSync()) {
            NtpClient.startSync();
        }

        // Start background executor to periodically refresh the ping to the current world if enabled
        if (config.enableWorldPing()) {
            pingExecutor = Executors.newSingleThreadScheduledExecutor(r -> new Thread(r, "mogcd-world-ping"));
            int interval = Math.max(1, config.pingRefreshInterval());
            pingExecutor.scheduleWithFixedDelay(this::refreshWorldPing, 5, interval, TimeUnit.SECONDS);
        } else {
            pingExecutor = null;
            lastWorldPing = -1;
        }
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(marksCooldownOverlay);
        if (pingExecutor != null) {
            pingExecutor.shutdownNow();
            pingExecutor = null;
        }
        lastWorldPing = -1;
        // reset the kandarin detection flag so we update next login
        kandarinDetectionConfigUpdated = false;
        // clear detection flag in config UI
        configManager.setConfiguration("AfkMarksCanafis", "kandarinDiaryDetected", false);
    }

    private void refreshWorldPing() {
        WorldResult worldResult = worldService.getWorlds();
        // There is no reason to ping the current world if not logged in, as the overlay doesn't draw
        if (worldResult == null || client.getGameState() != GameState.LOGGED_IN) return;
        final World currentWorld = worldResult.findWorld(client.getWorld());
        if (currentWorld == null) return;

        try {
            // Ping.ping is a blocking call; run in this background thread
            int ping = Ping.ping(currentWorld);
            if (ping >= 0) {
                lastWorldPing = ping;
            } else {
                lastWorldPing = -1;
            }
        } catch (Throwable t) {
            log.debug("Failed to refresh world ping: {}", t.toString());
            lastWorldPing = -1;
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        if (statChanged.getSkill() != AGILITY)
            return;

        Courses course = Courses.getCourse(this.client.getLocalPlayer().getWorldLocation().getRegionID());

        if (course != null && Arrays.stream(course.getCourseEndWorldPoints()).anyMatch((wp) ->
                wp.equals(this.client.getLocalPlayer().getWorldLocation()))) {
            currentCourse = course;
            lastCompleteTimeMillis = Instant.now().toEpochMilli();

            // Ensure NTP is synced when user starts agility training
            checkNtpSync();

            hasReducedCooldown = currentCourse == Courses.ARDOUGNE &&
                    client.getVarbitValue(VarbitID.ARDOUGNE_DIARY_ELITE_COMPLETE) == 1;
        }
    }

    @Subscribe
    public void onWorldChanged(WorldChanged event) {
        // Reset ping when changing worlds to avoid using stale latency data
        lastWorldPing = -1;
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (!kandarinDetectionConfigUpdated) {
            updateKandarinDetectedConfigIfNeeded();
        }

        if (isOnCooldown) {
            if (lastCompleteMarkTimeMillis == 0) {
                isOnCooldown = false;
                return;
            }

            long cooldownTimestamp = getCooldownTimestamp(true);

            if (Instant.now().toEpochMilli() >= cooldownTimestamp) {
                isOnCooldown = false;
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Marks of grace cooldown has finished, run until you find your next mark.", null);

                notifier.notify(config.notifyMarksOfGraceCD(), "Marks of grace cooldown has finished.");
            }
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned itemSpawned) {
        if (currentCourse == null)
            return;

        // Respect per-course toggle
        if (!isCourseEnabled(currentCourse)) return;

        final TileItem item = itemSpawned.getItem();

        if (item.getId() == ItemID.GRACE) {
            lastCompleteMarkTimeMillis = lastCompleteTimeMillis;
            isOnCooldown = true;
        }
    }

    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded e) {
        if (!isOnCooldown || currentCourse == null)
            return;

        // Respect per-course toggle
        if (!isCourseEnabled(currentCourse)) return;

        // Determine configured behaviour
        MarksOfGraceCDConfig.SwapLeftClickMode mode = config.swapLeftClickMode();

        if (mode == MarksOfGraceCDConfig.SwapLeftClickMode.OFF) return;

        if (!currentCourse.containsLastObstacle(e.getIdentifier())) return;

        long millisLeft = getCooldownTimestamp(true) - Instant.now().toEpochMilli();
        if (millisLeft <= 0) {
            return;
        }

        if (mode == MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_NOT_EXPIRED) {
            e.getMenuEntry().setDeprioritized(true);
            return;
        }

        // WHEN_CANNOT_COMPLETE_LAP (previous behaviour)
        int thresholdSeconds = getLapThresholdSeconds(currentCourse);
        if (millisLeft / 1000 < thresholdSeconds) {
            e.getMenuEntry().setDeprioritized(true);
        }
    }

    // Package-private helper to determine whether a menu entry for a given obstacle id should be deprioritized.
    // This mirrors the logic in onMenuEntryAdded, but accepts an obstacle id and is easier to unit-test.
    boolean shouldDeprioritizeMenuEntry(int obstacleId) {
        if (!isOnCooldown || currentCourse == null) return false;

        // Respect per-course toggle
        if (!isCourseEnabled(currentCourse)) return false;

        MarksOfGraceCDConfig.SwapLeftClickMode mode = config.swapLeftClickMode();
        if (mode == MarksOfGraceCDConfig.SwapLeftClickMode.OFF) return false;

        if (!currentCourse.containsLastObstacle(obstacleId)) return false;

        long millisLeft = getCooldownTimestamp(true) - Instant.now().toEpochMilli();
        if (millisLeft <= 0) return false;

        if (mode == MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_NOT_EXPIRED) return true;

        int thresholdSeconds = getLapThresholdSeconds(currentCourse);
        return (millisLeft / 1000) < thresholdSeconds;
    }

    /**
     * Helper to check whether the plugin is enabled for a given course based on config toggles.
     */
    boolean isCourseEnabled(Courses course) {
        return course == null || course.isEnabled(config);
    }

    /**
     * Compute the lap-time threshold in seconds used for swapping/deprioritizing the last obstacle.
     * If the user enabled the custom-lap-time override, return the configured custom seconds.
     * Otherwise, compute the course optimal time (considering course-specific toggles) and add the
     * user's optimalTimeBufferSeconds to allow forgiving timing.
     */
    int getLapThresholdSeconds(Courses course) {
        if (config.useCustomLapTime()) {
            return Math.max(0, config.customLapTimeSeconds());
        }

        int baseOptimal = course.getOptimalTime(key ->
                ("useSeersTeleport".equals(key) && config.useSeersTeleport() &&
                        (config.assumeHardKandarinDiary() || hasHardKandarinDiary()))
        );

        int combined = baseOptimal + config.lapTimeBuffer();
        return Math.max(0, combined);
    }

    public long getCooldownTimestamp(boolean checkForReduced) {
        if (lastCompleteMarkTimeMillis == 0)
            return lastCompleteMarkTimeMillis;

        // Apply NTP offset to get the correct server time for minute-truncation
        // This corrects for users whose system clocks are out of sync
        long ntpOffset = config.enableNtpSync() ? NtpClient.getSyncedOffsetMillis() : 0;
        long serverTimeMillis = lastCompleteMarkTimeMillis + ntpOffset;

        // Minute-truncate using server time to match OSRS game tick timing
        long minuteTruncatedMillis = serverTimeMillis - (serverTimeMillis % MILLIS_PER_MINUTE);
        long serverCooldownMillis = minuteTruncatedMillis + (MARK_COOLDOWN_MINUTES * MILLIS_PER_MINUTE);

        // Add user-configured buffer for safety margin
        long leewayAdjusted = serverCooldownMillis + ((long) config.timerBufferSeconds() * 1000);

        // Apply Ardougne elite diary reduced cooldown only when user opted into using the short Ardougne timer
        if (checkForReduced && hasReducedCooldown && config.useShortArdougneTimer())
            leewayAdjusted -= MILLIS_PER_MINUTE;

        // Convert back to local time by removing the NTP offset
        long localCooldownMillis = leewayAdjusted - ntpOffset;

        // If we have a recent ping to the world, approximate one-way delay and subtract it
        int ping = lastWorldPing;
        if (ping > 0) {
            long oneWay = ping / 2L;
            localCooldownMillis -= oneWay;
        }

        // Safety: don't return a timestamp earlier than the recorded completion time
        if (localCooldownMillis < lastCompleteMarkTimeMillis) {
            localCooldownMillis = lastCompleteMarkTimeMillis;
        }

        return localCooldownMillis;
    }

    /**
     * Detect whether the player has completed the Hard Kandarin diary using a direct VarbitID lookup.
     */
    public boolean hasHardKandarinDiary() {
        if (client == null) {
            return false;
        }
        return client.getVarbitValue(VarbitID.KANDARIN_DIARY_HARD_COMPLETE) == 1;
    }

    private void updateKandarinDetectedConfigIfNeeded() {
        if (kandarinDetectionConfigUpdated) return;
        if (client == null || client.getGameState() != GameState.LOGGED_IN) return;

        boolean detected = hasHardKandarinDiary();
        // Respect the override - don't change the UI value if user manually set override true
        // We still want the UI to show true when detected or when user has assume override
        if (config.assumeHardKandarinDiary()) {
            // if user has set the assume override, show detected as true in UI as well
            configManager.setConfiguration("AfkMarksCanafis", "kandarinDiaryDetected", true);
        } else {
            configManager.setConfiguration("AfkMarksCanafis", "kandarinDiaryDetected", detected);
        }

        kandarinDetectionConfigUpdated = true;
    }

    /**
     * Starts NTP sync if enabled and not already synced.
     */
    private void checkNtpSync() {
        if (config.enableNtpSync() && NtpClient.getSyncState() == NtpSyncState.NOT_SYNCED) {
            NtpClient.startSync();
        }
    }
}

package com.marksofgracecooldown.ntp;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.time.Instant;
import java.util.concurrent.atomic.AtomicReference;

/**
 * NTP client for synchronizing time with an NTP server.
 * Corrects for users whose system clocks are out of sync,
 * ensuring accurate cooldown calculations.
 */
@Slf4j
public class NtpClient {
    private static final String[] NTP_HOSTS = {"pool.ntp.org", "time.google.com", "time.cloudflare.com"};
    private static final int NTP_PORT = 123;
    private static final int SOCKET_TIMEOUT_MS = 5000;
    private static final int SYNC_ATTEMPTS = 3;
    private static final int RETRY_DELAY_MS = 2000;

    private static final long MILLIS_PER_SECOND = 1000L;
    private static final long UNIX_OFFSET_SECONDS = 2208988800L;
    private static final long NTP_CYCLE_MILLIS = (Integer.toUnsignedLong(0xffffffff) + 1) * MILLIS_PER_SECOND;

    @Getter
    private static volatile long syncedOffsetMillis = 0;

    @Getter
    private static volatile NtpSyncState syncState = NtpSyncState.NOT_SYNCED;

    private static final AtomicReference<Thread> syncThread = new AtomicReference<>(null);

    /**
     * Starts an asynchronous NTP time sync if not already syncing.
     */
    public static void startSync() {
        if (syncState == NtpSyncState.SYNCING) {
            return;
        }

        Thread newThread = new Thread(NtpClient::syncTime, "NtpClient-Sync");
        newThread.setDaemon(true);

        if (syncThread.compareAndSet(null, newThread)) {
            newThread.start();
        }
    }

    /**
     * Resets the sync state to allow a fresh sync attempt.
     */
    public static void resetSync() {
        if (syncState != NtpSyncState.SYNCING) {
            syncState = NtpSyncState.NOT_SYNCED;
            syncedOffsetMillis = 0;
        }
    }

    private static void syncTime() {
        syncState = NtpSyncState.SYNCING;

        try {
            for (String host : NTP_HOSTS) {
                if (trySyncWithHost(host)) {
                    return;
                }
            }
            log.warn("NTP sync failed after trying all servers");
            syncState = NtpSyncState.FAILED;
        } finally {
            syncThread.set(null);
        }
    }

    private static boolean trySyncWithHost(String host) {
        for (int attempt = 0; attempt < SYNC_ATTEMPTS; attempt++) {
            try {
                syncedOffsetMillis = queryNtpServer(host);
                syncState = NtpSyncState.SYNCED;
                log.debug("NTP sync successful with {}: offset = {}ms", host, syncedOffsetMillis);
                return true;
            } catch (Exception e) {
                log.debug("NTP sync attempt {} with {} failed: {}", attempt + 1, host, e.getMessage());
                sleepBeforeRetry(attempt);
            }
        }
        return false;
    }

    private static void sleepBeforeRetry(int attempt) {
        if (attempt < SYNC_ATTEMPTS - 1) {
            try {
                Thread.sleep(RETRY_DELAY_MS);
            } catch (InterruptedException ie) {
                Thread.currentThread().interrupt();
            }
        }
    }

    private static long queryNtpServer(String host) throws Exception {
        try (DatagramSocket socket = new DatagramSocket()) {
            socket.setSoTimeout(SOCKET_TIMEOUT_MS);

            byte[] ntpData = new byte[48];
            ntpData[0] = 0x1B; // NTP client request

            DatagramPacket request = new DatagramPacket(ntpData, ntpData.length,
                    InetAddress.getByName(host), NTP_PORT);

            long sendTime = System.currentTimeMillis();
            socket.send(request);
            socket.receive(new DatagramPacket(ntpData, ntpData.length));
            long receiveTime = System.currentTimeMillis();

            long serverNtpMillis = parseNtpTimestamp(ntpData, 40);
            long localNtpMillis = Instant.now().plusSeconds(UNIX_OFFSET_SECONDS).toEpochMilli();

            long offset = calculateOffset(serverNtpMillis, localNtpMillis);
            long networkDelay = (receiveTime - sendTime) / 2;

            return offset - networkDelay;
        }
    }

    private static long parseNtpTimestamp(byte[] data, int offset) {
        long seconds = readUnsignedInt(data, offset);
        long fraction = readUnsignedInt(data, offset + 4);
        return seconds * MILLIS_PER_SECOND + (fraction * MILLIS_PER_SECOND >> 32);
    }

    private static long readUnsignedInt(byte[] data, int offset) {
        return Byte.toUnsignedLong(data[offset]) << 24 |
               Byte.toUnsignedLong(data[offset + 1]) << 16 |
               Byte.toUnsignedLong(data[offset + 2]) << 8 |
               Byte.toUnsignedLong(data[offset + 3]);
    }

    private static long calculateOffset(long serverMillis, long localMillis) {
        long difference = serverMillis - localMillis;
        // Handle NTP timestamp rollover (year 2036)
        if (Math.abs(difference) > NTP_CYCLE_MILLIS / 2) {
            return difference < 0 ? difference + NTP_CYCLE_MILLIS : difference - NTP_CYCLE_MILLIS;
        }
        return difference;
    }
}


package com.marksofgracecooldown.ntp;

/**
 * Represents the current state of NTP time synchronization.
 */
public enum NtpSyncState {
    /** NTP sync has not been attempted yet */
    NOT_SYNCED("Not synced"),
    /** NTP sync is currently in progress */
    SYNCING("Syncing..."),
    /** NTP sync completed successfully */
    SYNCED("Synced"),
    /** NTP sync failed after all retry attempts */
    FAILED("Failed");

    private final String displayName;

    NtpSyncState(String displayName) {
        this.displayName = displayName;
    }

    @Override
    public String toString() {
        return displayName;
    }
}


package com.marksofgracecooldown;

import org.junit.Test;

import static org.junit.Assert.*;

public class CoursesTest {

    @Test
    public void testSeersConditionalTime() {
        // Default should be 44
        assertEquals(44, Courses.SEERS.getOptimalTime(key -> false));

        // When useSeersTeleport toggle is enabled, expect 38
        assertEquals(38, Courses.SEERS.getOptimalTime("useSeersTeleport"::equals));
    }

    @Test
    public void testGetCourseByRegionId() {
        // Test a few known region IDs
        assertEquals(Courses.CANIFIS, Courses.getCourse(13878));
        assertEquals(Courses.DRAYNOR, Courses.getCourse(12338));
        assertEquals(Courses.ARDOUGNE, Courses.getCourse(10547));
        assertEquals(Courses.GNOME, Courses.getCourse(9781));
        assertEquals(Courses.WEREWOLF, Courses.getCourse(14234));

        // Unknown region should return null
        assertNull(Courses.getCourse(99999));
    }

    @Test
    public void testContainsLastObstacle_singleObstacle() {
        // Canifis has one last obstacle: 14897
        assertTrue(Courses.CANIFIS.containsLastObstacle(14897));
        assertFalse(Courses.CANIFIS.containsLastObstacle(14898));
        assertFalse(Courses.CANIFIS.containsLastObstacle(0));
    }

    @Test
    public void testContainsLastObstacle_multipleObstacles_gnome() {
        // Gnome has 2 last obstacles: 23138, 23139
        assertTrue(Courses.GNOME.containsLastObstacle(23138));
        assertTrue(Courses.GNOME.containsLastObstacle(23139));
        assertFalse(Courses.GNOME.containsLastObstacle(23140));
    }

    @Test
    public void testContainsLastObstacle_multipleObstacles_werewolf() {
        // Werewolf has 3 last obstacles: 11644, 11645, 11646
        assertTrue(Courses.WEREWOLF.containsLastObstacle(11644));
        assertTrue(Courses.WEREWOLF.containsLastObstacle(11645));
        assertTrue(Courses.WEREWOLF.containsLastObstacle(11646));
        assertFalse(Courses.WEREWOLF.containsLastObstacle(11647));
    }

    @Test
    public void testOptimalTimeForNonConditionalCourse() {
        // Canifis has no conditionals, should always return 44
        assertEquals(44, Courses.CANIFIS.getOptimalTime(key -> false));
        assertEquals(44, Courses.CANIFIS.getOptimalTime(key -> true));
        assertEquals(44, Courses.CANIFIS.getOptimalTime("useSeersTeleport"::equals));
    }

    @Test
    public void testAllCoursesHaveValidData() {
        for (Courses course : Courses.values()) {
            // Each course should have at least one last obstacle
            assertTrue(course.name() + " should have at least one last obstacle",
                    course.getLastObstacleIds().length > 0);

            // Each course should have a positive optimal time
            assertTrue(course.name() + " should have positive optimal time",
                    course.getOptimalTimeSeconds() > 0);

            // Each course should have a valid region ID
            assertTrue(course.name() + " should have positive region ID",
                    course.getRegionId() > 0);

            // Each course should have at least one end world point
            assertTrue(course.name() + " should have at least one end world point",
                    course.getCourseEndWorldPoints().length > 0);

            // Course lookup by region should return the same course
            assertEquals(course.name() + " region lookup should match",
                    course, Courses.getCourse(course.getRegionId()));
        }
    }
}

package com.marksofgracecooldown;

import net.runelite.client.config.Notification;
import org.junit.Before;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class LapThresholdTest {
    private MarksOfGraceCDPlugin plugin;

    @Before
    public void setUp() throws Exception {
        plugin = new MarksOfGraceCDPlugin();

        // Minimal config: defaults
        MarksOfGraceCDConfig cfg = new MarksOfGraceCDConfig() {
            @Override public int customLapTimeSeconds() { return 200; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 2; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
            // Unused defaults
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean showDebugValues() { return false; }
        };

        // Inject the test config without reflection
        plugin.setConfig(cfg);
    }

    private int callLapThreshold(Courses course) {
        return plugin.getLapThresholdSeconds(course);
    }

    @Test
    public void testAutomaticSeersThreshold() {
        // SEERS default optimal 44 + buffer 2 = 46
        int t = callLapThreshold(Courses.SEERS);
        assertEquals(46, t);
    }

    @Test
    public void testCustomOverride() throws Exception {
        // Replace with a config that returns useCustomLapTime = true
        MarksOfGraceCDConfig cfg2 = new MarksOfGraceCDConfig() {
            @Override public int customLapTimeSeconds() { return 123; }
            @Override public boolean useCustomLapTime() { return true; }
            @Override public int lapTimeBuffer() { return 0; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean showDebugValues() { return false; }
        };

        // Inject the test config without reflection
        plugin.setConfig(cfg2);

        int t = callLapThreshold(Courses.SEERS);
        assertEquals(123, t);
    }

    @Test
    public void testSeersWithTeleportEnabled() {
        // When useSeersTeleport is enabled and user has diary, Seers uses 38 instead of 44
        MarksOfGraceCDConfig cfg = new MarksOfGraceCDConfig() {
            @Override public int customLapTimeSeconds() { return 200; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 2; }
            @Override public boolean useSeersTeleport() { return true; }
            @Override public boolean assumeHardKandarinDiary() { return true; } // Assume diary for test
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean showDebugValues() { return false; }
        };

        plugin.setConfig(cfg);

        // SEERS with teleport: 38 + buffer 2 = 40
        int t = callLapThreshold(Courses.SEERS);
        assertEquals(40, t);
    }

    @Test
    public void testSeersWithTeleportEnabledButNoDiary() {
        // When useSeersTeleport is enabled but no diary, should use default 44
        MarksOfGraceCDConfig cfg = new MarksOfGraceCDConfig() {
            @Override public int customLapTimeSeconds() { return 200; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 2; }
            @Override public boolean useSeersTeleport() { return true; }
            @Override public boolean assumeHardKandarinDiary() { return false; } // No diary
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean showDebugValues() { return false; }
        };

        plugin.setConfig(cfg);

        // Without diary, hasHardKandarinDiary() returns false (no client), so uses default 44 + 2 = 46
        int t = callLapThreshold(Courses.SEERS);
        assertEquals(46, t);
    }

    @Test
    public void testZeroBuffer() {
        MarksOfGraceCDConfig cfg = new MarksOfGraceCDConfig() {
            @Override public int customLapTimeSeconds() { return 200; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 0; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean showDebugValues() { return false; }
        };

        plugin.setConfig(cfg);

        // CANIFIS optimal 44 + buffer 0 = 44
        int t = callLapThreshold(Courses.CANIFIS);
        assertEquals(44, t);
    }

    @Test
    public void testLargeBuffer() {
        MarksOfGraceCDConfig cfg = new MarksOfGraceCDConfig() {
            @Override public int customLapTimeSeconds() { return 200; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 30; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean showDebugValues() { return false; }
        };

        plugin.setConfig(cfg);

        // BARBARIAN optimal 32 + buffer 30 = 62
        int t = callLapThreshold(Courses.BARBARIAN);
        assertEquals(62, t);
    }

    @Test
    public void testCustomLapTimeIgnoresBuffer() {
        // When custom lap time is used, it should return that value directly (buffer not added)
        MarksOfGraceCDConfig cfg = new MarksOfGraceCDConfig() {
            @Override public int customLapTimeSeconds() { return 50; }
            @Override public boolean useCustomLapTime() { return true; }
            @Override public int lapTimeBuffer() { return 10; } // This should be ignored
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean showDebugValues() { return false; }
        };

        plugin.setConfig(cfg);

        // Custom time 50 (buffer should not be added)
        int t = callLapThreshold(Courses.CANIFIS);
        assertEquals(50, t);
    }
}

package com.marksofgracecooldown;

import com.marksofgracecooldown.ntp.NtpClient;
import net.runelite.client.config.Notification;
import org.junit.Before;
import org.junit.Test;

import java.time.Instant;

import static org.junit.Assert.*;

public class MarksOfGraceCDPluginTest {
    private MarksOfGraceCDPlugin plugin;

    @Before
    public void setUp() throws Exception {
        // Reset NTP state to ensure consistent test behavior
        NtpClient.resetSync();

        plugin = new MarksOfGraceCDPlugin();

        // Provide a minimal config implementation (use defaults for unused methods)
        // Per-course toggles default to true in the real config; tests can override as needed
        MarksOfGraceCDConfig defaultConfig = new MarksOfGraceCDConfig() {
            @Override
            public Notification notifyMarksOfGraceCD() {
                return Notification.OFF;
            }

            @Override
            public SwapLeftClickMode swapLeftClickMode() {
                return SwapLeftClickMode.OFF;
            }

            @Override
            public int customLapTimeSeconds() {
                return 180;
            }

            @Override
            public int timerBufferSeconds() {
                return 0;
            }

            @Override
            public boolean useShortArdougneTimer() {
                return true;
            }

            @Override
            public boolean useSeersTeleport() {
                return false;
            }

            @Override
            public boolean enableWorldPing() {
                return false;
            }

            @Override
            public int pingRefreshInterval() {
                return 15;
            }

            @Override
            public boolean showDebugValues() {
                return false;
            }

            @Override
            public boolean enableNtpSync() {
                return false; // Disable NTP in tests for predictable behavior
            }

            // Per-course toggles default to true in the real config; tests can override as needed
            @Override
            public boolean enableDraynor() {
                return true;
            }

            @Override
            public boolean enableAlKharid() {
                return true;
            }

            @Override
            public boolean enableVarrock() {
                return true;
            }

            @Override
            public boolean enableCanifis() {
                return true;
            }

            @Override
            public boolean enableFalador() {
                return true;
            }

            @Override
            public boolean enableSeers() {
                return true;
            }

            @Override
            public boolean enablePollnivneach() {
                return true;
            }

            @Override
            public boolean enableRelleka() {
                return true;
            }

            @Override
            public boolean enableArdougne() {
                return true;
            }

            @Override
            public boolean enableGnome() {
                return true;
            }

            @Override
            public boolean enableShayzienBasic() {
                return true;
            }

            @Override
            public boolean enableBarbarian() {
                return true;
            }

            @Override
            public boolean enableShayzienAdvanced() {
                return true;
            }

            @Override
            public boolean enableApeAtoll() {
                return true;
            }

            @Override
            public boolean enableWerewolf() {
                return true;
            }
        };

        // Inject the test config without reflection
        plugin.setConfig(defaultConfig);

        // default values
        plugin.hasReducedCooldown = false;
        plugin.lastCompleteMarkTimeMillis = 0;
        plugin.lastCompleteTimeMillis = 0;
        plugin.isOnCooldown = false;
    }

    // ========== Cooldown Timestamp Tests ==========

    @Test
    public void testCooldownTimestamp_noPing_noBuffer() {
        long base = Instant.parse("2020-09-13T12:34:56Z").toEpochMilli();
        plugin.lastCompleteMarkTimeMillis = base;

        // No ping, buffer 0
        plugin.setLastWorldPing(-1);

        long minuteTruncated = base - (base % MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        long expected = minuteTruncated + (3 * MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);

        long ts = plugin.getCooldownTimestamp(false);
        assertEquals(expected, ts);
    }

    @Test
    public void testCooldownTimestamp_withPing_andClamp() {
        long base = Instant.parse("2020-09-13T12:59:10Z").toEpochMilli();
        plugin.lastCompleteMarkTimeMillis = base;

        // Simulate large RTT (120s) -> one-way 60s
        plugin.setLastWorldPing(120_000);

        long minuteTruncated = base - (base % MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        long expected = minuteTruncated + (3 * MarksOfGraceCDPlugin.MILLIS_PER_MINUTE) - (plugin.getLastWorldPing() / 2L);
        // clamp: cannot be earlier than lastCompleteMarkTimeMillis
        if (expected < plugin.lastCompleteMarkTimeMillis) expected = plugin.lastCompleteMarkTimeMillis;

        long ts = plugin.getCooldownTimestamp(false);
        assertEquals(expected, ts);
    }

    @Test
    public void testCooldownTimestamp_reducedArdougne() {
        long base = Instant.parse("2020-09-13T12:00:30Z").toEpochMilli();
        plugin.lastCompleteMarkTimeMillis = base;
        plugin.hasReducedCooldown = true;

        // No ping
        plugin.setLastWorldPing(-1);

        long minuteTruncated = base - (base % MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        long expected = minuteTruncated + (3 * MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        // reduced cooldown subtract one minute
        expected -= MarksOfGraceCDPlugin.MILLIS_PER_MINUTE;

        long ts = plugin.getCooldownTimestamp(true);
        assertEquals(expected, ts);
    }

    @Test
    public void testCooldownTimestamp_withTimerBuffer() {
        // Test with a timer buffer configured
        MarksOfGraceCDConfig cfgWithBuffer = new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 5; } // 5 second buffer
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
        };

        plugin.setConfig(cfgWithBuffer);

        long base = Instant.parse("2020-09-13T12:00:00Z").toEpochMilli();
        plugin.lastCompleteMarkTimeMillis = base;
        plugin.setLastWorldPing(-1);

        long minuteTruncated = base - (base % MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        long expected = minuteTruncated + (3 * MarksOfGraceCDPlugin.MILLIS_PER_MINUTE) + (5 * 1000); // + 5 seconds buffer

        long ts = plugin.getCooldownTimestamp(false);
        assertEquals(expected, ts);
    }

    @Test
    public void testCooldownTimestamp_reducedNotAppliedWhenNotChecked() {
        long base = Instant.parse("2020-09-13T12:00:30Z").toEpochMilli();
        plugin.lastCompleteMarkTimeMillis = base;
        plugin.hasReducedCooldown = true;

        plugin.setLastWorldPing(-1);

        long minuteTruncated = base - (base % MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        long expected = minuteTruncated + (3 * MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        // checkForReduced = false, so no reduction applied

        long ts = plugin.getCooldownTimestamp(false);
        assertEquals(expected, ts);
    }

    @Test
    public void testCooldownTimestamp_zeroReturnsZero() {
        plugin.lastCompleteMarkTimeMillis = 0;
        assertEquals(0, plugin.getCooldownTimestamp(false));
        assertEquals(0, plugin.getCooldownTimestamp(true));
    }

    @Test
    public void testCooldownTimestamp_withSmallPing() {
        long base = Instant.parse("2020-09-13T12:00:00Z").toEpochMilli();
        plugin.lastCompleteMarkTimeMillis = base;

        // 100ms ping -> 50ms one-way
        plugin.setLastWorldPing(100);

        long minuteTruncated = base - (base % MarksOfGraceCDPlugin.MILLIS_PER_MINUTE);
        long expected = minuteTruncated + (3 * MarksOfGraceCDPlugin.MILLIS_PER_MINUTE) - 50;

        long ts = plugin.getCooldownTimestamp(false);
        assertEquals(expected, ts);
    }

    // ========== Course Enabled Tests ==========

    @Test
    public void testIsCourseEnabled_allEnabledByDefault() {
        for (Courses course : Courses.values()) {
            assertTrue(course.name() + " should be enabled by default",
                    plugin.isCourseEnabled(course));
        }
    }

    @Test
    public void testIsCourseEnabled_nullReturnsTrue() {
        assertTrue(plugin.isCourseEnabled(null));
    }

    // ========== Swap Mode Tests ==========

    @Test
    public void testDeprioritize_swapModeOff_neverDeprioritizes() {
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 1000; // 1s left
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.OFF; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableCanifis() { return true; }
        });

        p.currentCourse = Courses.CANIFIS;
        p.isOnCooldown = true;

        // Even with cooldown and correct obstacle, OFF mode should never deprioritize
        assertFalse(p.shouldDeprioritizeMenuEntry(14897));
    }

    @Test
    public void testDeprioritize_swapModeAlways_deprioritizesWhenOnCooldown() {
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 60000; // 60s left
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_NOT_EXPIRED; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableCanifis() { return true; }
        });

        p.currentCourse = Courses.CANIFIS;
        p.isOnCooldown = true;

        // WHEN_NOT_EXPIRED mode should deprioritize as long as cooldown is active
        assertTrue(p.shouldDeprioritizeMenuEntry(14897));
    }

    @Test
    public void testDeprioritize_swapModeNearEnd_deprioritizesOnlyWhenBelowThreshold() {
        // Test WHEN_CANNOT_COMPLETE_LAP mode - should only deprioritize when time < threshold
        MarksOfGraceCDPlugin pLongTime = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 120000; // 120s left
            }
        };

        pLongTime.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_CANNOT_COMPLETE_LAP; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableCanifis() { return true; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 0; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
        });

        pLongTime.currentCourse = Courses.CANIFIS;
        pLongTime.isOnCooldown = true;

        // 120s > 44s threshold, should NOT deprioritize
        assertFalse(pLongTime.shouldDeprioritizeMenuEntry(14897));

        // Now test with short time left
        MarksOfGraceCDPlugin pShortTime = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 10000; // 10s left
            }
        };

        pShortTime.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_CANNOT_COMPLETE_LAP; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableCanifis() { return true; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 0; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
        });

        pShortTime.currentCourse = Courses.CANIFIS;
        pShortTime.isOnCooldown = true;

        // 10s < 44s threshold, SHOULD deprioritize
        assertTrue(pShortTime.shouldDeprioritizeMenuEntry(14897));
    }

    @Test
    public void testDeprioritize_wrongObstacle_neverDeprioritizes() {
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 1000;
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_NOT_EXPIRED; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableCanifis() { return true; }
        });

        p.currentCourse = Courses.CANIFIS;
        p.isOnCooldown = true;

        // Wrong obstacle ID - should not deprioritize
        assertFalse(p.shouldDeprioritizeMenuEntry(99999));
    }

    @Test
    public void testDeprioritize_notOnCooldown_neverDeprioritizes() {
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 1000;
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_NOT_EXPIRED; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableCanifis() { return true; }
        });

        p.currentCourse = Courses.CANIFIS;
        p.isOnCooldown = false; // Not on cooldown

        // Not on cooldown - should not deprioritize
        assertFalse(p.shouldDeprioritizeMenuEntry(14897));
    }

    @Test
    public void testDeprioritize_cooldownExpired_neverDeprioritizes() {
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() - 1000; // Expired 1s ago
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_NOT_EXPIRED; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableCanifis() { return true; }
        });

        p.currentCourse = Courses.CANIFIS;
        p.isOnCooldown = true;

        // Cooldown timestamp in the past - should not deprioritize
        assertFalse(p.shouldDeprioritizeMenuEntry(14897));
    }

    // ========== Per-Course Toggle Deprioritization Tests ==========

    @Test
    public void testDeprioritizeAllFinalObstacles_gnome() {
        // Create plugin that simulates a short time-left by overriding getCooldownTimestamp
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 1000; // 1s left
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public net.runelite.client.config.Notification notifyMarksOfGraceCD() { return net.runelite.client.config.Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_CANNOT_COMPLETE_LAP; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return true; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            // explicitly disable GNOME for this test
            @Override public boolean enableGnome() { return false; }
        });

        p.currentCourse = Courses.GNOME;
        p.isOnCooldown = true;

        // Because we disabled GNOME in config, deprioritization should be suppressed
        assertFalse(p.shouldDeprioritizeMenuEntry(23138));
        assertFalse(p.shouldDeprioritizeMenuEntry(23139));
    }

    @Test
    public void testDeprioritizeAllFinalObstacles_werewolf() {
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 1000; // 1s left
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public net.runelite.client.config.Notification notifyMarksOfGraceCD() { return net.runelite.client.config.Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_CANNOT_COMPLETE_LAP; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return true; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            // explicitly disable WEREWOLF for this test
            @Override public boolean enableWerewolf() { return false; }
        });

        p.currentCourse = Courses.WEREWOLF;
        p.isOnCooldown = true;

        // Because we disabled Werewolf in config, deprioritization should be suppressed
        assertFalse(p.shouldDeprioritizeMenuEntry(11644));
        assertFalse(p.shouldDeprioritizeMenuEntry(11645));
        assertFalse(p.shouldDeprioritizeMenuEntry(11646));
    }

    @Test
    public void testDeprioritize_gnomeEnabled_deprioritizesAllObstacles() {
        MarksOfGraceCDPlugin p = new MarksOfGraceCDPlugin() {
            @Override
            public long getCooldownTimestamp(boolean checkForReduced) {
                return Instant.now().toEpochMilli() + 1000; // 1s left
            }
        };

        p.setConfig(new MarksOfGraceCDConfig() {
            @Override public Notification notifyMarksOfGraceCD() { return Notification.OFF; }
            @Override public MarksOfGraceCDConfig.SwapLeftClickMode swapLeftClickMode() { return MarksOfGraceCDConfig.SwapLeftClickMode.WHEN_CANNOT_COMPLETE_LAP; }
            @Override public int customLapTimeSeconds() { return 180; }
            @Override public int timerBufferSeconds() { return 0; }
            @Override public boolean useShortArdougneTimer() { return false; }
            @Override public boolean useSeersTeleport() { return false; }
            @Override public boolean enableWorldPing() { return false; }
            @Override public int pingRefreshInterval() { return 15; }
            @Override public boolean showDebugValues() { return false; }
            @Override public boolean enableGnome() { return true; }
            @Override public boolean useCustomLapTime() { return false; }
            @Override public int lapTimeBuffer() { return 0; }
            @Override public boolean assumeHardKandarinDiary() { return false; }
        });

        p.currentCourse = Courses.GNOME;
        p.isOnCooldown = true;

        // Gnome is enabled and time left (1s) < threshold (34s), should deprioritize both obstacles
        assertTrue(p.shouldDeprioritizeMenuEntry(23138));
        assertTrue(p.shouldDeprioritizeMenuEntry(23139));
    }
}

package com.marksofgracecooldown;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MarksOfGraceCDTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MarksOfGraceCDPlugin.class);
		RuneLite.main(args);
	}
}
package com.marksofgracecooldown.ntp;

import org.junit.BeforeClass;
import org.junit.Test;

import static org.junit.Assert.*;

public class NtpClientTest {

    @BeforeClass
    public static void setUpClass() {
        // Reset NTP state before running tests to ensure clean state
        // Wait for any in-progress sync to complete
        try { Thread.sleep(200); } catch (InterruptedException ignored) {}
        NtpClient.resetSync();
    }

    @Test
    public void testInitialState() {
        NtpSyncState state = NtpClient.getSyncState();
        assertNotNull(state);
    }

    @Test
    public void testSyncStateEnum() {
        assertEquals("Not synced", NtpSyncState.NOT_SYNCED.toString());
        assertEquals("Syncing...", NtpSyncState.SYNCING.toString());
        assertEquals("Synced", NtpSyncState.SYNCED.toString());
        assertEquals("Failed", NtpSyncState.FAILED.toString());
    }

    @Test
    public void testStartSyncDoesNotBlock() {
        long startTime = System.currentTimeMillis();
        NtpClient.startSync();
        long elapsed = System.currentTimeMillis() - startTime;

        assertTrue("startSync should be non-blocking", elapsed < 100);
    }

    @Test
    public void testMultipleStartSyncCalls() {
        NtpClient.startSync();
        NtpClient.startSync();
        NtpClient.startSync();

        NtpSyncState state = NtpClient.getSyncState();
        assertNotNull(state);
    }
}


