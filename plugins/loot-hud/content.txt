package com.LootHUD;

import com.google.inject.Provides;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CopyOnWriteArrayList;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;

@Slf4j
@PluginDescriptor(
		name = "Loot HUD",
		description = "Displays loot notifications in an in-game overlay",
		tags = {"loot", "tracker", "overlay", "hud"}
)
public class LootHudPlugin extends Plugin
{
	@Inject
	private ItemManager itemManager;

	@Inject
	private LootHudConfig config;

	@Inject
	private LootHudOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private KeyManager keyManager;

	@Inject
	private EventBus eventBus;

	private final List<LootHudEntry> allEntries = new CopyOnWriteArrayList<>();
	private final Map<String, RunningTotal> runningTotals = new HashMap<>();
	private final Map<String, List<IndividualKill>> individualKills = new HashMap<>();
	private final Set<String> rareItemNamesCache = new HashSet<>();
	private final Set<String> ignoredItemNamesCache = new HashSet<>();
	private final Set<String> ignoredSourcesCache = new HashSet<>();

	private boolean overlayVisible = true;
	private String lastProcessedEventHash = "";
	private long lastProcessedEventTime = 0;

	@Provides
	LootHudConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LootHudConfig.class);
	}

	@Override
	protected void startUp()
	{
		log.info("Loot HUD started!");
		overlayManager.add(overlay);
		keyManager.registerKeyListener(hotkeyListener);
		eventBus.register(this);
		updateRareItemNamesCache();
		updateIgnoredItemNamesCache();
		updateIgnoredSourcesCache();
	}

	@Override
	protected void shutDown()
	{
		log.info("Loot HUD stopped!");
		overlayManager.remove(overlay);
		keyManager.unregisterKeyListener(hotkeyListener);
		eventBus.unregister(this);
		allEntries.clear();
		runningTotals.clear();
		individualKills.clear();
		rareItemNamesCache.clear();
		ignoredItemNamesCache.clear();
		ignoredSourcesCache.clear();
	}

	private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.toggleKeybind())
	{
		@Override
		public void hotkeyPressed()
		{
			overlayVisible = !overlayVisible;
		}
	};

	@Subscribe
	public void onLootReceived(LootReceived event)
	{
		log.info("Loot received from: {} (Type: {}, Amount: {}) - Items: {}",
				event.getName(), event.getType(), event.getAmount(), event.getItems());

		if (!shouldShowLoot(event.getType())) {
			return;
		}

		if (isSourceIgnored(event.getName())) {
			log.debug("Skipping loot from ignored source: {}", event.getName());
			return;
		}

		List<ItemStack> filteredItems = filterIgnoredItems(new ArrayList<>(event.getItems()));

		if (filteredItems.isEmpty()) {
			log.debug("All items from {} were ignored, skipping display", event.getName());
			return;
		}

		long totalValue = 0;
		boolean hasRareItem = false;
		List<ItemStack> sortedItems = new ArrayList<>(filteredItems);

		if (config.sortItemsByValue()) {
			sortedItems.sort((a, b) -> {
				int priceA = itemManager.getItemPrice(a.getId());
				int priceB = itemManager.getItemPrice(b.getId());
				return Integer.compare(priceB, priceA);
			});
		}

		for (ItemStack item : sortedItems)
		{
			int price = itemManager.getItemPrice(item.getId());
			if (price > 0) {
				totalValue += (long) price * item.getQuantity();
			}

			if (!hasRareItem && !rareItemNamesCache.isEmpty()) {
				try {
					ItemComposition comp = itemManager.getItemComposition(item.getId());
					String itemName = comp.getName().toLowerCase().trim();

					for (String rarePattern : rareItemNamesCache) {
						if (WildcardMatcher.matches(rarePattern, itemName)) {
							hasRareItem = true;
							log.debug("Rare item detected: {} (matches pattern: {})", comp.getName(), rarePattern);
							break;
						}
					}
				} catch (Exception e) {
					log.warn("Error checking item name for ID: {}", item.getId(), e);
				}
			}
		}

		if (config.minValueToShow() > 0 && totalValue < config.minValueToShow()) {
			log.debug("Skipping loot from {}: value {} below minimum {}",
					event.getName(), totalValue, config.minValueToShow());
			return;
		}

		boolean exceedsRareValue = config.rareValueThreshold() > 0 && totalValue >= config.rareValueThreshold();
		boolean isRare = hasRareItem || exceedsRareValue;

		if (isRare) {
			log.info("RARE LOOT DETECTED from {}: {} gp (Has rare item: {}, Exceeds threshold: {})",
					event.getName(), totalValue, hasRareItem, exceedsRareValue);
		}

		Instant expirationTime;
		if (config.alwaysShowOverlay()) {
			expirationTime = Instant.MAX;
		} else {
			expirationTime = Instant.now().plusSeconds(config.displayDuration());
		}

		processLoot(event, sortedItems, totalValue, expirationTime, isRare);
	}

	private List<ItemStack> filterIgnoredItems(List<ItemStack> items) {
		if (ignoredItemNamesCache.isEmpty()) {
			return new ArrayList<>(items);
		}

		List<ItemStack> filtered = new ArrayList<>();
		for (ItemStack item : items) {
			try {
				ItemComposition comp = itemManager.getItemComposition(item.getId());
				String itemName = comp.getName().toLowerCase().trim();
				boolean ignore = false;

				for (String ignoredPattern : ignoredItemNamesCache) {
					if (WildcardMatcher.matches(ignoredPattern, itemName)) {
						ignore = true;
						log.debug("Ignoring item: {} (matches pattern: {})", comp.getName(), ignoredPattern);
						break;
					}
				}

				if (!ignore) {
					filtered.add(item);
				}
			} catch (Exception e) {
				log.warn("Error checking item name for ID: {}", item.getId(), e);
				filtered.add(item);
			}
		}

		return filtered;
	}

	private void processLoot(LootReceived event, List<ItemStack> sortedItems, long totalValue, Instant expirationTime, boolean isRare)
	{
		String eventHash = createEventHash(event, sortedItems, totalValue);
		long currentTime = System.currentTimeMillis();

		if (eventHash.equals(lastProcessedEventHash) && (currentTime - lastProcessedEventTime) < 1000) {
			log.debug("Skipping duplicate event for {}", event.getName());
			return;
		}

		lastProcessedEventHash = eventHash;
		lastProcessedEventTime = currentTime;

		String monsterKey = event.getName() + "|" + event.getType();

		storeIndividualKill(event, sortedItems, totalValue, expirationTime, isRare, monsterKey);
		updateRunningTotal(event, sortedItems, totalValue, expirationTime, isRare, monsterKey);

		if (config.groupLoot()) {
			updateGroupedDisplay(event, monsterKey, expirationTime);
		} else {
			updateIndividualDisplay(event, monsterKey, expirationTime);
		}

		while (allEntries.size() > config.maxNotifications() * 2) {
			allEntries.remove(allEntries.size() - 1);
		}

		cleanupExpiredData();
	}

	private void storeIndividualKill(LootReceived event, List<ItemStack> sortedItems, long totalValue,
									 Instant expirationTime, boolean isRare, String monsterKey) {
		IndividualKill kill = new IndividualKill(
				event.getName(),
				event.getType(),
				new ArrayList<>(sortedItems),
				event.getAmount(),
				totalValue,
				isRare,
				expirationTime
		);

		List<IndividualKill> kills = individualKills.computeIfAbsent(monsterKey, k -> new ArrayList<>());
		kills.add(0, kill);

		while (kills.size() > config.maxNotifications() * 3) {
			kills.remove(kills.size() - 1);
		}
	}

	private void updateRunningTotal(LootReceived event, List<ItemStack> sortedItems, long totalValue,
									Instant expirationTime, boolean isRare, String monsterKey) {
		RunningTotal runningTotal = runningTotals.get(monsterKey);
		if (runningTotal == null) {
			runningTotal = new RunningTotal(
					event.getName(),
					event.getType(),
					new ArrayList<>(sortedItems),
					event.getAmount(),
					totalValue,
					isRare,
					expirationTime
			);
			runningTotals.put(monsterKey, runningTotal);
		} else {
			runningTotal.addKill(sortedItems, event.getAmount(), totalValue, isRare, expirationTime);
		}
	}

	private void updateGroupedDisplay(LootReceived event, String monsterKey, Instant expirationTime) {
		RunningTotal runningTotal = runningTotals.get(monsterKey);
		if (runningTotal == null) {
			log.warn("No running total found for {} when in grouped mode", monsterKey);
			return;
		}

		allEntries.removeIf(entry ->
				entry.getSourceName().equals(event.getName()) &&
						entry.getType() == event.getType() &&
						!entry.isGrouped()
		);

		allEntries.removeIf(entry ->
				entry.getSourceName().equals(event.getName()) &&
						entry.getType() == event.getType() &&
						entry.isGrouped()
		);

		LootHudEntry groupedEntry = new LootHudEntry(
				event.getName(),
				runningTotal.getItems(),
				runningTotal.getKillCount(),
				expirationTime,
				runningTotal.getTotalValue(),
				event.getType(),
				runningTotal.isRare(),
				true
		);

		allEntries.add(0, groupedEntry);
	}

	private void updateIndividualDisplay(LootReceived event, String monsterKey, Instant expirationTime) {
		List<IndividualKill> allKills = new ArrayList<>();

		for (Map.Entry<String, List<IndividualKill>> entry : individualKills.entrySet()) {
			List<IndividualKill> monsterKills = entry.getValue();

			for (IndividualKill kill : monsterKills) {
				if (!config.alwaysShowOverlay() && Instant.now().isAfter(kill.getExpirationTime())) {
					continue;
				}

				allKills.add(kill);
			}
		}

		allKills.sort((a, b) -> b.getExpirationTime().compareTo(a.getExpirationTime()));

		allEntries.removeIf(entry -> entry.isGrouped());
		allEntries.clear();

		for (IndividualKill kill : allKills) {
			LootHudEntry individualEntry = new LootHudEntry(
					kill.getSourceName(),
					kill.getItems(),
					kill.getKillCount(),
					kill.getExpirationTime(),
					kill.getTotalValue(),
					kill.getType(),
					kill.isRare(),
					false
			);

			allEntries.add(individualEntry);
		}

		while (allEntries.size() > config.maxNotifications() * 2) {
			allEntries.remove(allEntries.size() - 1);
		}
	}

	private String createEventHash(LootReceived event, List<ItemStack> items, long totalValue) {
		StringBuilder hash = new StringBuilder();
		hash.append(event.getName()).append("|");
		hash.append(event.getType()).append("|");
		hash.append(event.getAmount()).append("|");
		hash.append(totalValue).append("|");

		for (ItemStack item : items) {
			hash.append(item.getId()).append(":").append(item.getQuantity()).append(";");
		}

		return hash.toString();
	}

	private void cleanupExpiredData() {
		Instant now = Instant.now();

		if (!config.alwaysShowOverlay()) {
			for (List<IndividualKill> kills : individualKills.values()) {
				kills.removeIf(kill -> now.isAfter(kill.getExpirationTime()));
			}

			individualKills.entrySet().removeIf(entry -> entry.getValue().isEmpty());
			runningTotals.entrySet().removeIf(entry -> now.isAfter(entry.getValue().getExpirationTime()));
		}
	}

	private void updateRareItemNamesCache()
	{
		rareItemNamesCache.clear();
		String rareItemNames = config.rareItemNames();
		if (rareItemNames != null && !rareItemNames.trim().isEmpty()) {
			String[] names = rareItemNames.split(",");
			for (String name : names) {
				name = name.trim().toLowerCase();
				if (!name.isEmpty()) {
					rareItemNamesCache.add(name);
					log.debug("Added rare item pattern: {}", name);
				}
			}
		}
		log.info("Loaded {} rare item patterns from config", rareItemNamesCache.size());
	}

	private void updateIgnoredItemNamesCache()
	{
		ignoredItemNamesCache.clear();
		String ignoredItemNames = config.ignoredItemNames();
		if (ignoredItemNames != null && !ignoredItemNames.trim().isEmpty()) {
			String[] names = ignoredItemNames.split(",");
			for (String name : names) {
				name = name.trim().toLowerCase();
				if (!name.isEmpty()) {
					ignoredItemNamesCache.add(name);
					log.debug("Added ignored item pattern: {}", name);
				}
			}
		}
		log.info("Loaded {} ignored item patterns from config", ignoredItemNamesCache.size());
	}

	private void updateIgnoredSourcesCache()
	{
		ignoredSourcesCache.clear();
		String ignoredSources = config.ignoredSources();
		if (ignoredSources != null && !ignoredSources.trim().isEmpty()) {
			String[] names = ignoredSources.split(",");
			for (String name : names) {
				name = name.trim().toLowerCase();
				if (!name.isEmpty()) {
					ignoredSourcesCache.add(name);
					log.debug("Added ignored source pattern: {}", name);
				}
			}
		}
		log.info("Loaded {} ignored source patterns from config", ignoredSourcesCache.size());
	}

	@Subscribe
	private void onConfigChanged(net.runelite.client.events.ConfigChanged event)
	{
		if (!event.getGroup().equals("loothud")) {
			return;
		}

		switch (event.getKey()) {
			case "rareItemNames":
				updateRareItemNamesCache();
				break;
			case "ignoredItemNames":
				updateIgnoredItemNamesCache();
				rebuildAllEntriesWithFilter();
				break;
			case "ignoredSources":
				updateIgnoredSourcesCache();
				cleanupEntriesFromIgnoredSources();
				break;
			case "resetGroupOnLogout":
				if (config.resetGroupOnLogout()) {
					runningTotals.clear();
					individualKills.clear();
					log.info("Cleared all loot data due to config change");
				}
				break;
			case "groupLoot":
				rebuildDisplay();
				break;
		}
	}

	private void cleanupEntriesFromIgnoredSources()
	{
		if (ignoredSourcesCache.isEmpty()) {
			return;
		}

		allEntries.removeIf(entry -> isSourceIgnored(entry.getSourceName()));

		for (Iterator<Map.Entry<String, List<IndividualKill>>> it = individualKills.entrySet().iterator(); it.hasNext();) {
			Map.Entry<String, List<IndividualKill>> entry = it.next();
			String sourceName = entry.getKey().split("\\|")[0];
			if (isSourceIgnored(sourceName)) {
				it.remove();
			}
		}

		for (Iterator<Map.Entry<String, RunningTotal>> it = runningTotals.entrySet().iterator(); it.hasNext();) {
			Map.Entry<String, RunningTotal> entry = it.next();
			String sourceName = entry.getKey().split("\\|")[0];
			if (isSourceIgnored(sourceName)) {
				it.remove();
			}
		}

		log.info("Cleaned up entries from ignored sources");
	}

	private void rebuildAllEntriesWithFilter() {
		allEntries.clear();
		runningTotals.clear();

		Map<String, List<IndividualKill>> newIndividualKills = new HashMap<>();

		for (Map.Entry<String, List<IndividualKill>> entry : individualKills.entrySet()) {
			String monsterKey = entry.getKey();
			List<IndividualKill> oldKills = entry.getValue();
			List<IndividualKill> newKills = new ArrayList<>();

			for (IndividualKill oldKill : oldKills) {
				List<ItemStack> filteredItems = filterIgnoredItems(oldKill.getItems());

				if (filteredItems.isEmpty()) {
					continue;
				}

				long filteredTotalValue = 0;
				boolean filteredIsRare = false;

				for (ItemStack item : filteredItems) {
					int price = itemManager.getItemPrice(item.getId());
					if (price > 0) {
						filteredTotalValue += (long) price * item.getQuantity();
					}

					if (!filteredIsRare) {
						try {
							ItemComposition comp = itemManager.getItemComposition(item.getId());
							String itemName = comp.getName().toLowerCase().trim();
							for (String rarePattern : rareItemNamesCache) {
								if (WildcardMatcher.matches(rarePattern, itemName)) {
									filteredIsRare = true;
									break;
								}
							}
						} catch (Exception e) {
							log.warn("Error re-checking rare status for item ID: {}", item.getId(), e);
						}
					}
				}

				boolean exceedsRareValue = config.rareValueThreshold() > 0 && filteredTotalValue >= config.rareValueThreshold();
				filteredIsRare = filteredIsRare || exceedsRareValue;

				IndividualKill newKill = new IndividualKill(
						oldKill.getSourceName(),
						oldKill.getType(),
						filteredItems,
						oldKill.getKillCount(),
						filteredTotalValue,
						filteredIsRare,
						oldKill.getExpirationTime()
				);

				newKills.add(newKill);
			}

			if (!newKills.isEmpty()) {
				newIndividualKills.put(monsterKey, newKills);
			}
		}

		individualKills.clear();
		individualKills.putAll(newIndividualKills);

		rebuildDisplay();
	}

	private void rebuildDisplay()
	{
		allEntries.clear();

		if (config.groupLoot()) {
			List<RunningTotal> sortedTotals = new ArrayList<>(runningTotals.values());
			sortedTotals.sort((a, b) -> b.getExpirationTime().compareTo(a.getExpirationTime()));

			for (RunningTotal total : sortedTotals) {
				if (!config.alwaysShowOverlay() && Instant.now().isAfter(total.getExpirationTime())) {
					continue;
				}

				LootHudEntry groupedEntry = new LootHudEntry(
						total.getSourceName(),
						total.getItems(),
						total.getKillCount(),
						total.getExpirationTime(),
						total.getTotalValue(),
						total.getType(),
						total.isRare(),
						true
				);

				allEntries.add(groupedEntry);
			}
		} else {
			List<IndividualKill> allKills = new ArrayList<>();

			for (Map.Entry<String, List<IndividualKill>> entry : individualKills.entrySet()) {
				List<IndividualKill> kills = entry.getValue();

				for (IndividualKill kill : kills) {
					if (!config.alwaysShowOverlay() && Instant.now().isAfter(kill.getExpirationTime())) {
						continue;
					}

					allKills.add(kill);
				}
			}

			allKills.sort((a, b) -> b.getExpirationTime().compareTo(a.getExpirationTime()));

			for (IndividualKill kill : allKills) {
				LootHudEntry individualEntry = new LootHudEntry(
						kill.getSourceName(),
						kill.getItems(),
						kill.getKillCount(),
						kill.getExpirationTime(),
						kill.getTotalValue(),
						kill.getType(),
						kill.isRare(),
						false
				);

				allEntries.add(individualEntry);
			}

			log.info("Switched to ungrouped mode - showing {} individual kills", allEntries.size());
		}
	}

	private boolean shouldShowLoot(net.runelite.http.api.loottracker.LootRecordType type)
	{
		switch (type)
		{
			case NPC:
				return config.includeNPCKills();
			case PLAYER:
				return config.includePlayerKills();
			case PICKPOCKET:
				return config.includePickpocket();
			case EVENT:
				return config.includeEvents();
			default:
				return true;
		}
	}

	private boolean isSourceIgnored(String sourceName)
	{
		if (ignoredSourcesCache.isEmpty()) {
			return false;
		}

		return WildcardMatcher.anyMatches(ignoredSourcesCache, sourceName);
	}

	List<LootHudEntry> getRecentLoot()
	{
		List<LootHudEntry> visibleEntries = new ArrayList<>();

		for (LootHudEntry entry : allEntries) {
			if (!config.alwaysShowOverlay() && entry.isExpired()) {
				continue;
			}

			if (config.minValueToShow() > 0 && entry.getTotalValue() < config.minValueToShow()) {
				continue;
			}

			// Update fade-out animation if enabled
			if (config.fadeOutAnimation() && !config.alwaysShowOverlay()) {
				long fadeDurationMillis = config.fadeOutDuration() * 1000L;
				entry.updateFadeAnimation(fadeDurationMillis);
			}

			visibleEntries.add(entry);
		}

		// Sort by expiration time (newest first)
		visibleEntries.sort((a, b) -> b.getExpirationTime().compareTo(a.getExpirationTime()));

		// Limit to max notifications
		int limit = Math.min(config.maxNotifications(), visibleEntries.size());
		return visibleEntries.subList(0, limit);
	}

	boolean isOverlayVisible()
	{
		return overlayVisible;
	}

	/**
	 * Gets the color for an item based on its value and configured thresholds.
	 * @param itemValue The value of the item
	 * @return The appropriate color for this item value
	 */
	java.awt.Color getItemValueColor(long itemValue)
	{
		if (itemValue >= config.valueThreshold5()) {
			return config.valueColor5();
		} else if (itemValue >= config.valueThreshold4()) {
			return config.valueColor4();
		} else if (itemValue >= config.valueThreshold3()) {
			return config.valueColor3();
		} else if (itemValue >= config.valueThreshold2()) {
			return config.valueColor2();
		} else if (itemValue >= config.valueThreshold1()) {
			return config.valueColor1();
		}
		return config.itemNameColor();
	}

	/**
	 * Gets the overlay color based on total value and configured thresholds.
	 * @param totalValue The total value of the loot entry
	 * @return The appropriate overlay color for this total value
	 */
	java.awt.Color getOverlayValueColor(long totalValue)
	{
		if (totalValue >= config.valueThreshold5()) {
			return config.overlayColor5();
		} else if (totalValue >= config.valueThreshold4()) {
			return config.overlayColor4();
		} else if (totalValue >= config.valueThreshold3()) {
			return config.overlayColor3();
		} else if (totalValue >= config.valueThreshold2()) {
			return config.overlayColor2();
		} else if (totalValue >= config.valueThreshold1()) {
			return config.overlayColor1();
		}
		return config.backgroundColor();
	}

	/**
	 * Gets the header overlay color based on total value and configured thresholds.
	 * @param totalValue The total value of the loot entry
	 * @return The appropriate header overlay color for this total value
	 */
	java.awt.Color getHeaderValueColor(long totalValue)
	{
		// For header, use a slightly darker version of the overlay color
		java.awt.Color baseColor = getOverlayValueColor(totalValue);
		if (baseColor.equals(config.backgroundColor())) {
			return config.headerBackgroundColor();
		}

		// Darken the color by reducing RGB values
		return new java.awt.Color(
				Math.max(0, baseColor.getRed() - 40),
				Math.max(0, baseColor.getGreen() - 40),
				Math.max(0, baseColor.getBlue() - 40),
				baseColor.getAlpha()
		);
	}

	// Add this getter method to expose the cache to the overlay
	Set<String> getRareItemNamesCache()
	{
		return rareItemNamesCache;
	}

	private static class RunningTotal {
		private final String sourceName;
		private final net.runelite.http.api.loottracker.LootRecordType type;
		private List<ItemStack> items;
		private int killCount;
		private long totalValue;
		private boolean isRare;
		private Instant expirationTime;

		public RunningTotal(String sourceName, net.runelite.http.api.loottracker.LootRecordType type,
							List<ItemStack> items, int killCount, long totalValue,
							boolean isRare, Instant expirationTime) {
			this.sourceName = sourceName;
			this.type = type;
			this.items = new ArrayList<>(items);
			this.killCount = killCount;
			this.totalValue = totalValue;
			this.isRare = isRare;
			this.expirationTime = expirationTime;
		}

		public void addKill(List<ItemStack> newItems, int newKillCount, long newTotalValue,
							boolean newIsRare, Instant newExpirationTime) {
			Map<Integer, ItemStack> itemMap = new HashMap<>();

			for (ItemStack item : this.items) {
				itemMap.put(item.getId(), new ItemStack(item.getId(), item.getQuantity()));
			}

			for (ItemStack newItem : newItems) {
				int itemId = newItem.getId();
				ItemStack existing = itemMap.get(itemId);
				if (existing != null) {
					itemMap.put(itemId, new ItemStack(itemId, existing.getQuantity() + newItem.getQuantity()));
				} else {
					itemMap.put(itemId, new ItemStack(itemId, newItem.getQuantity()));
				}
			}

			this.items = new ArrayList<>(itemMap.values());
			this.killCount += newKillCount;
			this.totalValue += newTotalValue;
			this.isRare = this.isRare || newIsRare;

			if (newExpirationTime.isAfter(this.expirationTime)) {
				this.expirationTime = newExpirationTime;
			}
		}

		public String getSourceName() { return sourceName; }
		public net.runelite.http.api.loottracker.LootRecordType getType() { return type; }
		public List<ItemStack> getItems() { return new ArrayList<>(items); }
		public int getKillCount() { return killCount; }
		public long getTotalValue() { return totalValue; }
		public boolean isRare() { return isRare; }
		public Instant getExpirationTime() { return expirationTime; }
	}

	private static class IndividualKill {
		private final String sourceName;
		private final net.runelite.http.api.loottracker.LootRecordType type;
		private final List<ItemStack> items;
		private final int killCount;
		private final long totalValue;
		private final boolean isRare;
		private final Instant expirationTime;

		public IndividualKill(String sourceName, net.runelite.http.api.loottracker.LootRecordType type,
							  List<ItemStack> items, int killCount, long totalValue,
							  boolean isRare, Instant expirationTime) {
			this.sourceName = sourceName;
			this.type = type;
			this.items = new ArrayList<>(items);
			this.killCount = killCount;
			this.totalValue = totalValue;
			this.isRare = isRare;
			this.expirationTime = expirationTime;
		}

		public String getSourceName() { return sourceName; }
		public net.runelite.http.api.loottracker.LootRecordType getType() { return type; }
		public List<ItemStack> getItems() { return new ArrayList<>(items); }
		public int getKillCount() { return killCount; }
		public long getTotalValue() { return totalValue; }
		public boolean isRare() { return isRare; }
		public Instant getExpirationTime() { return expirationTime; }
	}
}
package com.LootHUD;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Dimension;
import java.awt.GradientPaint;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.List;
import javax.inject.Inject;
import net.runelite.api.Constants;
import net.runelite.api.Point;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.loottracker.LootRecordType;

class LootHudOverlay extends Overlay
{
    private final LootHudPlugin plugin;
    private final LootHudConfig config;
    private final ItemManager itemManager;

    private static final int PADDING = 4;
    private static final int ITEM_GAP = 2;
    private static final int HEADER_HEIGHT = 20;
    private static final int ITEM_SIZE = Constants.ITEM_SPRITE_WIDTH;
    private static final int TYPE_ICON_SIZE = 12;
    private static final int ITEM_NAME_PADDING = 4;

    private long animationStartTime = System.currentTimeMillis();

    @Inject
    private LootHudOverlay(LootHudPlugin plugin, LootHudConfig config, ItemManager itemManager)
    {
        this.plugin = plugin;
        this.config = config;
        this.itemManager = itemManager;

        // Make overlay movable and dynamic
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGH);
        setMovable(true);
        setResizable(config.allowResizing());
        setSnappable(true);
        setPreferredSize(null);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!plugin.isOverlayVisible())
        {
            return null;
        }

        List<LootHudEntry> entries = plugin.getRecentLoot();
        if (entries.isEmpty())
        {
            return null;
        }

        // Calculate total size needed for all entries
        int totalHeight = 0;
        int maxWidth = 0;
        int entriesCounted = 0;

        for (LootHudEntry entry : entries)
        {
            if (config.minValueToShow() > 0 && entry.getTotalValue() < config.minValueToShow()) {
                continue;
            }

            int entryWidth = calculateEntryWidth(graphics, entry);
            int entryHeight = calculateEntryHeight(entry);

            maxWidth = Math.max(maxWidth, entryWidth);
            totalHeight += entryHeight + 2;
            entriesCounted++;
        }

        // If no entries after filtering, don't render
        if (maxWidth == 0) {
            return null;
        }

        // Check if we should use fixed size or dynamic size
        Dimension preferredSize = null;
        if (config.allowResizing() && getPreferredSize() != null) {
            // Use user's preferred size if resizing is allowed and set
            preferredSize = getPreferredSize();

            // Ensure minimum size
            if (preferredSize.width < maxWidth) {
                preferredSize.width = maxWidth;
            }
            if (preferredSize.height < totalHeight) {
                preferredSize.height = totalHeight;
            }
        } else {
            // Use calculated size
            preferredSize = new Dimension(maxWidth, totalHeight);
        }

        // Update resizable property based on config
        setResizable(config.allowResizing());

        // Draw each entry
        int yOffset = 0;
        int entriesDrawn = 0;

        for (int i = 0; i < entries.size(); i++)
        {
            LootHudEntry entry = entries.get(i);

            if (config.minValueToShow() > 0 && entry.getTotalValue() < config.minValueToShow()) {
                continue;
            }

            // Apply fade effect if enabled and there are multiple entries
            Composite originalComposite = null;
            if (config.fadeOlderEntries() && entries.size() > 1) {
                originalComposite = graphics.getComposite();
                float alpha = calculateAlphaForPosition(i, entries.size());
                graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
            }

            // Apply fade-out animation if enabled
            float currentAlpha = entry.getCurrentAlpha();
            if (config.fadeOutAnimation() && currentAlpha < 1.0f) {
                if (originalComposite == null) {
                    originalComposite = graphics.getComposite();
                }
                graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, currentAlpha));
            }

            yOffset += drawEntry(graphics, entry, yOffset, maxWidth, i);

            // Restore original composite if we changed it
            if (originalComposite != null) {
                graphics.setComposite(originalComposite);
            }

            entriesDrawn++;

            if (entriesDrawn >= config.maxNotifications()) {
                break;
            }
        }

        return preferredSize;
    }

    private int calculateEntryWidth(Graphics2D graphics, LootHudEntry entry)
    {
        if (config.showItemNames() && !entry.getItems().isEmpty()) {
            int maxItemWidth = 0;
            int numItemsToShow = Math.min(entry.getItems().size(), config.maxIconsPerEntry());

            for (int i = 0; i < numItemsToShow; i++) {
                ItemStack item = entry.getItems().get(i);
                int itemWidth = ITEM_SIZE;

                if (config.showItemNames()) {
                    try {
                        ItemComposition comp = itemManager.getItemComposition(item.getId());
                        String itemName = formatItemName(comp.getName(), item.getQuantity());
                        int textWidth = graphics.getFontMetrics().stringWidth(itemName);

                        if (config.itemNamePosition() == LootHudConfig.ItemNamePosition.LEFT ||
                                config.itemNamePosition() == LootHudConfig.ItemNamePosition.RIGHT) {
                            itemWidth += textWidth + ITEM_NAME_PADDING;
                        }
                    } catch (Exception e) {
                        // Ignore
                    }
                }

                maxItemWidth = Math.max(maxItemWidth, itemWidth);
            }

            return maxItemWidth + (PADDING * 2);
        } else {
            int iconsPerRow = Math.min(config.iconsPerRow(), 8);
            return (iconsPerRow * (ITEM_SIZE + ITEM_GAP)) - ITEM_GAP + (PADDING * 2);
        }
    }

    private int calculateEntryHeight(LootHudEntry entry)
    {
        if (config.showItemNames() && !entry.getItems().isEmpty()) {
            // Items in a vertical list
            int numItemsToShow = Math.min(entry.getItems().size(), config.maxIconsPerEntry());
            return HEADER_HEIGHT + (numItemsToShow * (ITEM_SIZE + ITEM_GAP)) - ITEM_GAP + (PADDING * 2);
        } else {
            int iconsPerRow = Math.min(config.iconsPerRow(), 8);
            int numIconsToShow = Math.min(entry.getItems().size(), config.maxIconsPerEntry());
            int rows = (int) Math.ceil((double) numIconsToShow / iconsPerRow);
            return HEADER_HEIGHT + (rows * (ITEM_SIZE + ITEM_GAP)) - ITEM_GAP + (PADDING * 2);
        }
    }

    private String formatItemName(String name, int quantity)
    {
        if (quantity > 1) {
            return name + " (" + quantity + ")";
        }
        return name;
    }

    private float calculateAlphaForPosition(int position, int totalEntries)
    {
        float minAlpha = 0.4f;
        float maxAlpha = 1.0f;

        if (totalEntries <= 1) {
            return maxAlpha;
        }

        float t = (float) position / (totalEntries - 1);
        return maxAlpha - t * (maxAlpha - minAlpha);
    }

    private int drawEntry(Graphics2D graphics, LootHudEntry entry, int yOffset, int maxWidth, int position)
    {
        int entryHeight = calculateEntryHeight(entry);

        // Get border width
        int borderWidth = Math.max(0, Math.min(10, config.borderWidth()));

        // Determine base colors
        Color backgroundColor = config.backgroundColor();
        Color headerBackgroundColor = config.headerBackgroundColor();
        Color gradientEndColor = config.gradientEndColor();

        // Apply value-based overlay colors if enabled and not a rare entry
        if (config.valueBasedOverlay() && !entry.isRare()) {
            backgroundColor = plugin.getOverlayValueColor(entry.getTotalValue());
            headerBackgroundColor = plugin.getHeaderValueColor(entry.getTotalValue());

            // For gradient end color with value-based overlay, create a slightly darker version
            gradientEndColor = new Color(
                    Math.max(0, backgroundColor.getRed() - 30),
                    Math.max(0, backgroundColor.getGreen() - 30),
                    Math.max(0, backgroundColor.getBlue() - 30),
                    backgroundColor.getAlpha()
            );
        } else {
            // Use the configured gradient end color when value-based overlay is disabled or entry is rare
            gradientEndColor = config.gradientEndColor();
        }

        // Draw header background
        graphics.setColor(headerBackgroundColor);
        graphics.fillRect(0, yOffset, maxWidth, HEADER_HEIGHT);

        // Draw main background
        if (config.useGradient()) {
            GradientPaint gradient = new GradientPaint(
                    0, yOffset + HEADER_HEIGHT, backgroundColor,
                    0, yOffset + entryHeight, gradientEndColor
            );
            graphics.setPaint(gradient);
            graphics.fillRect(0, yOffset + HEADER_HEIGHT, maxWidth, entryHeight - HEADER_HEIGHT);
        } else {
            graphics.setColor(backgroundColor);
            graphics.fillRect(0, yOffset + HEADER_HEIGHT, maxWidth, entryHeight - HEADER_HEIGHT);
        }

        // Check if this is a rare entry and which highlight mode is active
        boolean isRare = entry.isRare();
        LootHudConfig.RareItemHighlight highlightMode = config.rareItemHighlight();

        // Only apply highlight to individual (non-grouped) entries
        boolean shouldHighlight = isRare &&
                highlightMode != LootHudConfig.RareItemHighlight.OFF &&
                !entry.isGrouped();

        // Apply highlight if rare and highlight mode is not OFF and entry is not grouped
        Color headerHighlightColor = null;
        Color bodyHighlightColor = null;

        if (shouldHighlight) {
            if (highlightMode == LootHudConfig.RareItemHighlight.RAINBOW) {
                // Create animated rainbow effect
                Color rainbowColor = getRainbowColor(position);
                headerHighlightColor = new Color(
                        rainbowColor.getRed(),
                        rainbowColor.getGreen(),
                        rainbowColor.getBlue(),
                        config.rainbowAlpha()
                );
                bodyHighlightColor = new Color(
                        rainbowColor.getRed(),
                        rainbowColor.getGreen(),
                        rainbowColor.getBlue(),
                        config.rainbowAlpha() - 30
                );

                // Apply to header
                graphics.setColor(headerHighlightColor);
                graphics.fillRect(0, yOffset, maxWidth, HEADER_HEIGHT);
            } else if (highlightMode == LootHudConfig.RareItemHighlight.STATIC) {
                // Use static highlight color (with alpha already included)
                Color highlightColor = config.staticHighlightColor();
                headerHighlightColor = highlightColor;
                bodyHighlightColor = new Color(
                        highlightColor.getRed(),
                        highlightColor.getGreen(),
                        highlightColor.getBlue(),
                        Math.max(0, highlightColor.getAlpha() - 50)
                );

                graphics.setColor(headerHighlightColor);
                graphics.fillRect(0, yOffset, maxWidth, HEADER_HEIGHT);
            } else if (highlightMode == LootHudConfig.RareItemHighlight.PULSE) {
                // New pulse effect
                Color highlightColor = config.staticHighlightColor();

                // Calculate pulsing alpha
                int pulseAlpha = getPulseAlpha(highlightColor.getAlpha(), config.pulseAlphaRange(), position);
                headerHighlightColor = new Color(
                        highlightColor.getRed(),
                        highlightColor.getGreen(),
                        highlightColor.getBlue(),
                        pulseAlpha
                );
                bodyHighlightColor = new Color(
                        highlightColor.getRed(),
                        highlightColor.getGreen(),
                        highlightColor.getBlue(),
                        Math.max(0, pulseAlpha - 50)
                );

                graphics.setColor(headerHighlightColor);
                graphics.fillRect(0, yOffset, maxWidth, HEADER_HEIGHT);
            }
        }

        // Draw border with configurable width
        if (borderWidth > 0) {
            Color borderColor = config.borderColor();
            if (shouldHighlight && highlightMode != LootHudConfig.RareItemHighlight.OFF) {
                if (highlightMode == LootHudConfig.RareItemHighlight.RAINBOW) {
                    Color rainbowBorder = getRainbowColor(position + 2);
                    borderColor = new Color(
                            rainbowBorder.getRed(),
                            rainbowBorder.getGreen(),
                            rainbowBorder.getBlue(),
                            config.rainbowAlpha()
                    );
                } else if (highlightMode == LootHudConfig.RareItemHighlight.PULSE) {
                    int pulseAlpha = getPulseAlpha(config.staticHighlightColor().getAlpha(),
                            config.pulseAlphaRange(), position);
                    borderColor = new Color(
                            config.staticHighlightColor().getRed(),
                            config.staticHighlightColor().getGreen(),
                            config.staticHighlightColor().getBlue(),
                            pulseAlpha
                    );
                }
            }

            graphics.setColor(borderColor);
            graphics.setStroke(new BasicStroke(borderWidth));
            graphics.drawRect(
                    borderWidth / 2,
                    yOffset + borderWidth / 2,
                    maxWidth - borderWidth,
                    entryHeight - borderWidth
            );
            graphics.setStroke(new BasicStroke(1));
        }

        // Draw loot type icon if enabled
        int textXOffset = PADDING;
        if (config.showLootTypeIcon()) {
            Color typeColor = getColorForLootType(entry.getType());
            graphics.setColor(typeColor);
            graphics.fillRect(PADDING, yOffset + PADDING, TYPE_ICON_SIZE, TYPE_ICON_SIZE);
            textXOffset += TYPE_ICON_SIZE + 4;
        }

        // Draw header text (monster name + value)
        int textY = yOffset + PADDING + 14;

        // Format kill count text
        String killText = "";
        if (entry.isGrouped()) {
            killText = " (x" + entry.getKillCount() + ")";
        } else if (config.groupLoot() && entry.getKillCount() > config.groupKillThreshold()) {
            killText = " (x" + entry.getKillCount() + ")";
        } else if (!config.groupLoot() && entry.getKillCount() > 1) {
            killText = " (x" + entry.getKillCount() + ")";
        }

        String displayName = entry.getSourceName();

        // Truncate if too long
        int availableWidth = maxWidth - (PADDING * 2) - textXOffset;
        if (config.showTotalValue()) {
            // Reserve space for value text
            availableWidth -= 80; // Approximate width for value text
        }

        if (graphics.getFontMetrics().stringWidth(displayName + killText) > availableWidth) {
            // Truncate with ellipsis
            while (displayName.length() > 3 &&
                    graphics.getFontMetrics().stringWidth(displayName + "..." + killText) > availableWidth) {
                displayName = displayName.substring(0, displayName.length() - 1);
            }
            displayName = displayName + "...";
        }

        Color textColor = shouldHighlight ? Color.WHITE : config.sourceNameColor();

        // If pulse mode, also pulse the text color slightly
        if (shouldHighlight && highlightMode == LootHudConfig.RareItemHighlight.PULSE) {
            int pulseAlpha = getPulseAlpha(255, config.pulseAlphaRange() / 2, position);
            textColor = new Color(textColor.getRed(), textColor.getGreen(), textColor.getBlue(), pulseAlpha);
        }

        OverlayUtil.renderTextLocation(graphics,
                new Point(textXOffset, textY),
                displayName + killText,
                textColor);

        // Draw value on right if enabled
        if (config.showTotalValue() && entry.getTotalValue() > 0) {
            String valueText = QuantityFormatter.quantityToStackSize(entry.getTotalValue()) + " gp";
            int textWidth = graphics.getFontMetrics().stringWidth(valueText);

            Color valueColor = shouldHighlight ? Color.WHITE : config.valueTextColor();

            if (shouldHighlight && highlightMode == LootHudConfig.RareItemHighlight.PULSE) {
                int pulseAlpha = getPulseAlpha(255, config.pulseAlphaRange() / 2, position);
                valueColor = new Color(valueColor.getRed(), valueColor.getGreen(), valueColor.getBlue(), pulseAlpha);
            }

            OverlayUtil.renderTextLocation(graphics,
                    new Point(maxWidth - PADDING - textWidth, textY),
                    valueText,
                    valueColor);
        }

        // Draw item icons and names
        if (config.showItemIcons() && !entry.getItems().isEmpty()) {
            if (config.showItemNames()) {
                drawItemsWithNames(graphics, entry, yOffset, maxWidth);
            } else {
                drawItemsInGrid(graphics, entry, yOffset, maxWidth);
            }
        }

        return entryHeight + 2;
    }

    private void drawItemsWithNames(Graphics2D graphics, LootHudEntry entry, int yOffset, int maxWidth)
    {
        int numItemsToShow = Math.min(entry.getItems().size(), config.maxIconsPerEntry());
        int startY = yOffset + HEADER_HEIGHT + PADDING;

        for (int i = 0; i < numItemsToShow; i++)
        {
            ItemStack item = entry.getItems().get(i);
            int x = PADDING;
            int y = startY + (i * (ITEM_SIZE + ITEM_GAP));

            try
            {
                ItemComposition comp = itemManager.getItemComposition(item.getId());
                String itemName = formatItemName(comp.getName(), item.getQuantity());
                int itemValue = itemManager.getItemPrice(item.getId()) * item.getQuantity();

                // Determine item color based on value thresholds
                Color itemColor = plugin.getItemValueColor(itemValue);

                // Check if this item is rare
                boolean isItemRare = false;
                String itemNameLower = comp.getName().toLowerCase().trim();
                for (String rarePattern : plugin.getRareItemNamesCache()) {
                    if (WildcardMatcher.matches(rarePattern, itemNameLower)) {
                        isItemRare = true;
                        break;
                    }
                }

                // Use highlighted color if item is rare
                if (isItemRare) {
                    itemColor = config.highlightedItemNameColor();
                }

                // Draw icon
                BufferedImage itemImage = getItemImage(item);
                if (itemImage != null)
                {
                    if (config.itemNamePosition() == LootHudConfig.ItemNamePosition.LEFT)
                    {
                        // Draw name on left, icon on right
                        int textWidth = graphics.getFontMetrics().stringWidth(itemName);
                        OverlayUtil.renderTextLocation(graphics,
                                new Point(x, y + ITEM_SIZE / 2 + 6),
                                itemName,
                                itemColor);
                        graphics.drawImage(itemImage, x + textWidth + ITEM_NAME_PADDING, y, null);
                    }
                    else if (config.itemNamePosition() == LootHudConfig.ItemNamePosition.RIGHT)
                    {
                        // Draw icon on left, name on right
                        graphics.drawImage(itemImage, x, y, null);
                        OverlayUtil.renderTextLocation(graphics,
                                new Point(x + ITEM_SIZE + ITEM_NAME_PADDING, y + ITEM_SIZE / 2 + 6),
                                itemName,
                                itemColor);
                    }
                }
            }
            catch (Exception e)
            {
                // Ignore errors and just draw the icon
                BufferedImage itemImage = getItemImage(item);
                if (itemImage != null)
                {
                    graphics.drawImage(itemImage, x, y, null);
                }
            }
        }
    }

    private void drawItemsInGrid(Graphics2D graphics, LootHudEntry entry, int yOffset, int maxWidth)
    {
        int iconsPerRow = Math.min(config.iconsPerRow(), 8);
        int numIconsToShow = Math.min(entry.getItems().size(), config.maxIconsPerEntry());
        int rows = (int) Math.ceil((double) numIconsToShow / iconsPerRow);

        int iconIndex = 0;

        for (ItemStack item : entry.getItems())
        {
            if (iconIndex >= config.maxIconsPerEntry()) {
                break;
            }

            int row = iconIndex / iconsPerRow;
            int col = iconIndex % iconsPerRow;

            int x = PADDING + col * (ITEM_SIZE + ITEM_GAP);
            int y = yOffset + HEADER_HEIGHT + PADDING + row * (ITEM_SIZE + ITEM_GAP);

            BufferedImage itemImage = getItemImage(item);
            if (itemImage != null) {
                graphics.drawImage(itemImage, x, y, null);
            }

            iconIndex++;
        }

        // Draw "+X" indicator if there are more items than we can show
        if (entry.getItems().size() > config.maxIconsPerEntry()) {
            int remaining = entry.getItems().size() - config.maxIconsPerEntry();
            int lastRow = (int) Math.ceil((double) Math.min(entry.getItems().size(), config.maxIconsPerEntry()) / iconsPerRow) - 1;
            int lastCol = Math.min(entry.getItems().size(), config.maxIconsPerEntry()) % iconsPerRow;
            if (lastCol == 0) lastCol = iconsPerRow;

            int x = PADDING + (lastCol) * (ITEM_SIZE + ITEM_GAP);
            int y = yOffset + HEADER_HEIGHT + PADDING + lastRow * (ITEM_SIZE + ITEM_GAP);

            graphics.setColor(new Color(60, 60, 60, 200));
            graphics.fillRect(x, y, ITEM_SIZE, ITEM_SIZE);

            graphics.setColor(Color.LIGHT_GRAY);
            String plusText = "+" + remaining;
            int textWidth = graphics.getFontMetrics().stringWidth(plusText);
            OverlayUtil.renderTextLocation(graphics,
                    new Point(x + (ITEM_SIZE - textWidth) / 2, y + 18),
                    plusText,
                    Color.LIGHT_GRAY);
        }
    }

    private Color getRainbowColor(int positionOffset)
    {
        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - animationStartTime;

        float speed = config.rainbowAnimationSpeed() / 10.0f;
        float hue = ((elapsedTime * 0.001f * speed) + (positionOffset * 0.2f)) % 1.0f;

        float saturation = 0.8f;
        float brightness = 0.9f;

        int rgb = Color.HSBtoRGB(hue, saturation, brightness);
        return new Color(rgb);
    }

    private int getPulseAlpha(int baseAlpha, int alphaRange, int positionOffset)
    {
        long currentTime = System.currentTimeMillis();
        long elapsedTime = currentTime - animationStartTime;

        float speedFactor = config.pulseAnimationSpeed() / 10.0f;
        long pulsePeriod = (long) (2000 / speedFactor);

        float cyclePosition = (elapsedTime % pulsePeriod) / (float) pulsePeriod;
        float sinePulse = (float) Math.sin(cyclePosition * Math.PI * 2);

        int pulseAlpha = (int) (baseAlpha + (sinePulse * alphaRange / 2));
        return Math.max(0, Math.min(255, pulseAlpha));
    }

    private Color getColorForLootType(LootRecordType type)
    {
        switch (type)
        {
            case NPC:
                return new Color(255, 100, 100, 200);
            case PLAYER:
                return new Color(100, 100, 255, 200);
            case PICKPOCKET:
                return new Color(255, 200, 100, 200);
            case EVENT:
                return new Color(100, 255, 100, 200);
            default:
                return new Color(200, 200, 200, 200);
        }
    }

    private BufferedImage getItemImage(ItemStack item)
    {
        try
        {
            ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
            boolean showQuantity = itemComposition.isStackable() || item.getQuantity() > 1;
            return itemManager.getImage(item.getId(), item.getQuantity(), showQuantity);
        }
        catch (Exception e)
        {
            return null;
        }
    }
}
package com.LootHUD;

import java.util.Set;

/**
 * Simple wildcard matcher for item/source name matching.
 * Supports '*' as wildcard character.
 */
class WildcardMatcher
{
    /**
     * Checks if a string matches a wildcard pattern.
     * @param pattern Pattern with '*' as wildcard
     * @param text Text to match against pattern
     * @return true if text matches pattern
     */
    public static boolean matches(String pattern, String text)
    {
        if (pattern == null || text == null)
        {
            return false;
        }

        // Remove leading/trailing spaces and convert to lowercase
        pattern = pattern.trim().toLowerCase();
        text = text.trim().toLowerCase();

        // If pattern is empty, it matches everything
        if (pattern.isEmpty())
        {
            return true;
        }

        // Handle exact match
        if (!pattern.contains("*"))
        {
            return text.equals(pattern);
        }

        // Handle wildcard matching
        String[] parts = pattern.split("\\*", -1); // -1 to keep empty parts

        // Empty pattern means "*" which matches everything
        if (parts.length == 0)
        {
            return true;
        }

        // Check if text starts with first part
        if (!parts[0].isEmpty() && !text.startsWith(parts[0]))
        {
            return false;
        }

        // Check if text ends with last part
        if (parts.length > 1 && !parts[parts.length - 1].isEmpty() &&
                !text.endsWith(parts[parts.length - 1]))
        {
            return false;
        }

        // Check middle parts
        int currentIndex = 0;
        for (int i = 0; i < parts.length; i++)
        {
            String part = parts[i];
            if (part.isEmpty())
            {
                continue;
            }

            int foundIndex = text.indexOf(part, currentIndex);
            if (foundIndex == -1)
            {
                return false;
            }
            currentIndex = foundIndex + part.length();
        }

        return true;
    }

    /**
     * Checks if text matches any pattern in the set.
     * @param patterns Set of wildcard patterns
     * @param text Text to match
     * @return true if text matches any pattern
     */
    public static boolean anyMatches(Set<String> patterns, String text)
    {
        if (patterns == null || patterns.isEmpty() || text == null)
        {
            return false;
        }

        for (String pattern : patterns)
        {
            if (matches(pattern, text))
            {
                return true;
            }
        }
        return false;
    }
}
package com.LootHUD;

import java.time.Instant;
import java.util.List;
import lombok.Data;
import net.runelite.client.game.ItemStack;
import net.runelite.http.api.loottracker.LootRecordType;

@Data
class LootHudEntry
{
    private final String sourceName;
    private final List<ItemStack> items;
    private final int killCount;
    private final Instant expirationTime;
    private final long totalValue;
    private final LootRecordType type;
    private final boolean isRare;
    private final boolean isGrouped;

    // Animation state
    private float currentAlpha = 1.0f;

    public LootHudEntry(String sourceName, List<ItemStack> items, int killCount, Instant expirationTime, long totalValue, LootRecordType type, boolean isRare, boolean isGrouped)
    {
        this.sourceName = sourceName;
        this.items = items;
        this.killCount = killCount;
        this.expirationTime = expirationTime;
        this.totalValue = totalValue;
        this.type = type;
        this.isRare = isRare;
        this.isGrouped = isGrouped;
    }

    /**
     * Checks if this loot entry has expired.
     * @return true if the current time is after the expiration time, false otherwise
     */
    public boolean isExpired()
    {
        return Instant.now().isAfter(expirationTime);
    }

    /**
     * Gets the remaining display time in milliseconds.
     * @return milliseconds remaining before expiration
     */
    public long getRemainingMillis()
    {
        Instant now = Instant.now();
        if (now.isAfter(expirationTime)) {
            return 0;
        }
        return expirationTime.toEpochMilli() - now.toEpochMilli();
    }

    /**
     * Updates fade-out animation based on current time.
     * @param fadeDurationMillis how long the fade-out animation should last (milliseconds)
     * @return current alpha value (1.0 = fully opaque, 0.0 = fully transparent)
     */
    public float updateFadeAnimation(long fadeDurationMillis)
    {
        if (fadeDurationMillis <= 0)
        {
            currentAlpha = 1.0f;
            return currentAlpha;
        }

        long remaining = getRemainingMillis();

        // If we have more time than the fade duration, stay fully opaque
        if (remaining > fadeDurationMillis)
        {
            currentAlpha = 1.0f;
            return currentAlpha;
        }

        // If we're already expired
        if (remaining <= 0)
        {
            currentAlpha = 0.0f;
            return currentAlpha;
        }

        // We're in the fade-out period
        // Calculate what percentage of the fade duration remains
        float fadeProgress = remaining / (float) fadeDurationMillis;

        // Use this directly for alpha (1.0 at start of fade, 0.0 at end)
        currentAlpha = fadeProgress;
        return currentAlpha;
    }

    /**
     * Gets the current alpha for rendering (updated by updateFadeAnimation).
     * @return current alpha value (1.0 = fully opaque, 0.0 = fully transparent)
     */
    public float getCurrentAlpha()
    {
        return currentAlpha;
    }
}
package com.LootHUD;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;
import net.runelite.client.config.Alpha;

@ConfigGroup("loothud")
public interface LootHudConfig extends Config
{
	// ========== SECTION DEFINITIONS ==========
	@ConfigSection(
			name = "General",
			description = "Basic overlay settings",
			position = 0
	)
	String generalSection = "general";

	@ConfigSection(
			name = "Appearance",
			description = "Colors, transparency, and borders",
			position = 1
	)
	String appearanceSection = "appearance";

	@ConfigSection(
			name = "Display",
			description = "How loot entries are displayed",
			position = 2
	)
	String displaySection = "display";

	@ConfigSection(
			name = "Icons",
			description = "Item icon display settings",
			position = 3
	)
	String iconsSection = "icons";

	@ConfigSection(
			name = "Highlight Effects",
			description = "Rare item highlight settings",
			position = 4
	)
	String highlightSection = "highlight";

	@ConfigSection(
			name = "Filtering",
			description = "Filter what loot is shown",
			position = 5
	)
	String filterSection = "filters";

	@ConfigSection(
			name = "Grouping",
			description = "Group multiple kills from same source",
			position = 6
	)
	String groupingSection = "grouping";

	@ConfigSection(
			name = "Text Colors",
			description = "Text color settings",
			position = 7
	)
	String textColorsSection = "textColors";

	@ConfigSection(
			name = "Value Thresholds",
			description = "Item value-based highlighting",
			position = 8
	)
	String valueThresholdsSection = "valueThresholds";

	// ========== GENERAL SECTION ==========
	@ConfigItem(
			keyName = "toggleKeybind",
			name = "Toggle keybind",
			description = "Key to show/hide the loot overlay",
			position = 0,
			section = generalSection
	)
	default Keybind toggleKeybind()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "allowResizing",
			name = "Allow resizing",
			description = "Allow dragging edges to resize overlay",
			position = 1,
			section = generalSection
	)
	default boolean allowResizing()
	{
		return true;
	}

	// ========== APPEARANCE SECTION ==========
	@Alpha
	@ConfigItem(
			keyName = "backgroundColor",
			name = "Background color",
			description = "Color for loot entry backgrounds (includes transparency)",
			position = 0,
			section = appearanceSection
	)
	default java.awt.Color backgroundColor()
	{
		return new java.awt.Color(0, 0, 0, 180);
	}

	@Alpha
	@ConfigItem(
			keyName = "headerBackgroundColor",
			name = "Header background color",
			description = "Separate background color for source name header",
			position = 1,
			section = appearanceSection
	)
	default java.awt.Color headerBackgroundColor()
	{
		return new java.awt.Color(40, 40, 40, 200);
	}

	@Alpha
	@ConfigItem(
			keyName = "borderColor",
			name = "Border color",
			description = "Color for loot entry borders (includes transparency)",
			position = 2,
			section = appearanceSection
	)
	default java.awt.Color borderColor()
	{
		return new java.awt.Color(100, 100, 100, 150);
	}

	@ConfigItem(
			keyName = "borderWidth",
			name = "Border width",
			description = "Width of the loot entry borders",
			position = 3,
			section = appearanceSection
	)
	@Range(min = 0, max = 10)
	default int borderWidth()
	{
		return 1;
	}

	@ConfigItem(
			keyName = "useGradient",
			name = "Use gradient background",
			description = "Use gradient instead of solid color",
			position = 4,
			section = appearanceSection
	)
	default boolean useGradient()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
			keyName = "gradientEndColor",
			name = "Gradient end color",
			description = "End color for gradient background",
			position = 5,
			section = appearanceSection
	)
	default java.awt.Color gradientEndColor()
	{
		return new java.awt.Color(50, 50, 50, 180);
	}

	// ========== DISPLAY SECTION ==========
	@ConfigItem(
			keyName = "displayDuration",
			name = "Display time",
			description = "How long each loot notification stays visible (seconds)",
			position = 0,
			section = displaySection
	)
	@Range(min = 1, max = 60)
	default int displayDuration()
	{
		return 10;
	}

	@ConfigItem(
			keyName = "alwaysShowOverlay",
			name = "Always show overlay",
			description = "Keep overlay visible even when no new loot is received",
			position = 1,
			section = displaySection
	)
	default boolean alwaysShowOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "maxNotifications",
			name = "Max entries",
			description = "Maximum number of loot entries to show at once",
			position = 2,
			section = displaySection
	)
	@Range(min = 1, max = 10)
	default int maxNotifications()
	{
		return 3;
	}

	@ConfigItem(
			keyName = "fadeOlderEntries",
			name = "Fade older entries",
			description = "Gradually fade older entries for smooth transitions",
			position = 3,
			section = displaySection
	)
	default boolean fadeOlderEntries()
	{
		return false;
	}

	@ConfigItem(
			keyName = "fadeOutAnimation",
			name = "Fade out animation",
			description = "Gradually fade out entries when they expire",
			position = 4,
			section = displaySection
	)
	default boolean fadeOutAnimation()
	{
		return true;
	}

	@ConfigItem(
			keyName = "fadeOutDuration",
			name = "Fade out duration",
			description = "How long the fade out animation lasts (seconds)",
			position = 5,
			section = displaySection
	)
	@Range(min = 1, max = 10)
	default int fadeOutDuration()
	{
		return 3;
	}

	@ConfigItem(
			keyName = "showTotalValue",
			name = "Show total value",
			description = "Display total GE value of each loot pile",
			position = 6,
			section = displaySection
	)
	default boolean showTotalValue()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showLootTypeIcon",
			name = "Show source type icon",
			description = "Show small icon for loot source (NPC, player, etc.)",
			position = 7,
			section = displaySection
	)
	default boolean showLootTypeIcon()
	{
		return false;
	}

	@ConfigItem(
			keyName = "showItemNames",
			name = "Show item names",
			description = "Display item names next to icons",
			position = 8,
			section = displaySection
	)
	default boolean showItemNames()
	{
		return false;
	}

	@ConfigItem(
			keyName = "itemNamePosition",
			name = "Item name position",
			description = "Where to show item names relative to icons",
			position = 9,
			section = displaySection
	)
	default ItemNamePosition itemNamePosition()
	{
		return ItemNamePosition.RIGHT;
	}

	@ConfigItem(
			keyName = "tooltipOnHover",
			name = "Tooltip on hover",
			description = "Show item name tooltip when hovering over icons",
			position = 10,
			section = displaySection
	)
	default boolean tooltipOnHover()
	{
		return true;
	}

	// ========== ICONS SECTION ==========
	@ConfigItem(
			keyName = "showItemIcons",
			name = "Show item icons",
			description = "Display item icons in loot entries",
			position = 0,
			section = iconsSection
	)
	default boolean showItemIcons()
	{
		return true;
	}

	@ConfigItem(
			keyName = "maxIconsPerEntry",
			name = "Max icons per entry",
			description = "Maximum number of item icons to show per loot entry",
			position = 1,
			section = iconsSection
	)
	@Range(min = 1, max = 28)
	default int maxIconsPerEntry()
	{
		return 12;
	}

	@ConfigItem(
			keyName = "iconsPerRow",
			name = "Icons per row",
			description = "Number of item icons per row",
			position = 2,
			section = iconsSection
	)
	@Range(min = 1, max = 8)
	default int iconsPerRow()
	{
		return 4;
	}

	@ConfigItem(
			keyName = "sortItemsByValue",
			name = "Sort by value",
			description = "Show most valuable items first",
			position = 3,
			section = iconsSection
	)
	default boolean sortItemsByValue()
	{
		return true;
	}

	// ========== HIGHLIGHT EFFECTS SECTION ==========
	@ConfigItem(
			keyName = "rareItemHighlight",
			name = "Highlight style",
			description = "How to highlight rare item drops",
			position = 0,
			section = highlightSection
	)
	default RareItemHighlight rareItemHighlight()
	{
		return RareItemHighlight.OFF;
	}

	@ConfigItem(
			keyName = "rareItemNames",
			name = "Rare item list",
			description = "Comma-separated list of item names to highlight<br>Supports wildcards: *bow, dragon *<br>Example: Twisted bow, Scythe of vitur, Tumeken's shadow, dragon *, *fire cape",
			position = 1,
			section = highlightSection
	)
	default String rareItemNames()
	{
		return "Twisted bow, Scythe of vitur, Tumeken's shadow, Torva full helm, Masori body";
	}

	@ConfigItem(
			keyName = "rareValueThreshold",
			name = "Value threshold",
			description = "Minimum loot value to trigger highlight (GP)",
			position = 2,
			section = highlightSection
	)
	@Range(min = 0, max = 100000000)
	default int rareValueThreshold()
	{
		return 1000000;
	}

	@Alpha
	@ConfigItem(
			keyName = "staticHighlightColor",
			name = "Highlight color",
			description = "Color for highlighting rare items (includes transparency)",
			position = 3,
			section = highlightSection
	)
	default java.awt.Color staticHighlightColor()
	{
		return new java.awt.Color(255, 215, 0, 220);
	}

	@ConfigItem(
			keyName = "rainbowAnimationSpeed",
			name = "Rainbow speed",
			description = "Speed of rainbow color cycling",
			position = 4,
			section = highlightSection
	)
	@Range(min = 1, max = 10)
	default int rainbowAnimationSpeed()
	{
		return 5;
	}

	@ConfigItem(
			keyName = "rainbowAlpha",
			name = "Rainbow transparency",
			description = "Transparency for rainbow effect (0-255)",
			position = 5,
			section = highlightSection
	)
	@Range(min = 0, max = 255)
	default int rainbowAlpha()
	{
		return 200;
	}

	@ConfigItem(
			keyName = "pulseAnimationSpeed",
			name = "Pulse speed",
			description = "Speed of pulsing animation",
			position = 6,
			section = highlightSection
	)
	@Range(min = 1, max = 10)
	default int pulseAnimationSpeed()
	{
		return 5;
	}

	@ConfigItem(
			keyName = "pulseAlphaRange",
			name = "Pulse intensity",
			description = "How much transparency changes during pulse",
			position = 7,
			section = highlightSection
	)
	@Range(min = 0, max = 255)
	default int pulseAlphaRange()
	{
		return 80;
	}

	// ========== FILTERING SECTION ==========
	@ConfigItem(
			keyName = "includeNPCKills",
			name = "NPC kills",
			description = "Show loot from killing NPCs",
			position = 0,
			section = filterSection
	)
	default boolean includeNPCKills()
	{
		return true;
	}

	@ConfigItem(
			keyName = "includePlayerKills",
			name = "Player kills",
			description = "Show loot from killing players",
			position = 1,
			section = filterSection
	)
	default boolean includePlayerKills()
	{
		return true;
	}

	@ConfigItem(
			keyName = "includePickpocket",
			name = "Pickpocketing",
			description = "Show loot from pickpocketing",
			position = 2,
			section = filterSection
	)
	default boolean includePickpocket()
	{
		return true;
	}

	@ConfigItem(
			keyName = "includeEvents",
			name = "Events/minigames",
			description = "Show loot from events, chests, and minigames",
			position = 3,
			section = filterSection
	)
	default boolean includeEvents()
	{
		return true;
	}

	@ConfigItem(
			keyName = "minValueToShow",
			name = "Minimum value",
			description = "Only show loot worth more than this amount",
			position = 4,
			section = filterSection
	)
	@Range(min = 0, max = 10000000)
	default int minValueToShow()
	{
		return 0;
	}

	@ConfigItem(
			keyName = "ignoredItemNames",
			name = "Ignored items",
			description = "Comma-separated list of item names to hide from display<br>Supports wildcards: *gloves, bones*, *of the gods<br>Example: Bones, *gloves, Hammer, Coins",
			position = 5,
			section = filterSection
	)
	default String ignoredItemNames()
	{
		return "";
	}

	@ConfigItem(
			keyName = "ignoredSources",
			name = "Ignored sources",
			description = "Comma-separated list of NPC/player names to hide loot from<br>Supports wildcards: *goblin, Bandit*, Lizardman*<br>Example: Man, *goblin, Cow",
			position = 6,
			section = filterSection
	)
	default String ignoredSources()
	{
		return "";
	}

	// ========== GROUPING SECTION ==========
	@ConfigItem(
			keyName = "groupLoot",
			name = "Group kills",
			description = "Combine multiple kills from same source into one entry",
			position = 0,
			section = groupingSection
	)
	default boolean groupLoot()
	{
		return false;
	}

	@ConfigItem(
			keyName = "groupKillThreshold",
			name = "Show kill count after",
			description = "Minimum kills before showing kill count (0 = always show)",
			position = 1,
			section = groupingSection
	)
	@Range(min = 0, max = 100)
	default int groupKillThreshold()
	{
		return 1;
	}

	@ConfigItem(
			keyName = "resetGroupOnLogout",
			name = "Reset on logout",
			description = "Clear grouped loot when logging out",
			position = 2,
			section = groupingSection
	)
	default boolean resetGroupOnLogout()
	{
		return true;
	}

	// ========== TEXT COLORS SECTION ==========
	@Alpha
	@ConfigItem(
			keyName = "sourceNameColor",
			name = "Source name color",
			description = "Color for source name text",
			position = 0,
			section = textColorsSection
	)
	default java.awt.Color sourceNameColor()
	{
		return new java.awt.Color(255, 255, 0, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "itemNameColor",
			name = "Item name color",
			description = "Color for regular item names",
			position = 1,
			section = textColorsSection
	)
	default java.awt.Color itemNameColor()
	{
		return new java.awt.Color(255, 255, 255, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "highlightedItemNameColor",
			name = "Highlighted item name color",
			description = "Color for highlighted/rare item names",
			position = 2,
			section = textColorsSection
	)
	default java.awt.Color highlightedItemNameColor()
	{
		return new java.awt.Color(255, 215, 0, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "valueTextColor",
			name = "Value text color",
			description = "Color for total value text",
			position = 3,
			section = textColorsSection
	)
	default java.awt.Color valueTextColor()
	{
		return new java.awt.Color(0, 255, 0, 255);
	}

	// ========== VALUE THRESHOLDS SECTION ==========
	@ConfigItem(
			keyName = "valueThreshold1",
			name = "Low value items",
			description = "First value threshold for item highlighting",
			position = 0,
			section = valueThresholdsSection
	)
	@Range(min = 0, max = 100000000)
	default int valueThreshold1()
	{
		return 1000;
	}

	@Alpha
	@ConfigItem(
			keyName = "valueColor1",
			name = "Text Color: Low",
			description = "Text color for items above threshold 1",
			position = 1,
			section = valueThresholdsSection
	)
	default java.awt.Color valueColor1()
	{
		return new java.awt.Color(255, 255, 255, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "overlayColor1",
			name = "Overlay Color: Low",
			description = "Overlay color for total value above threshold 1",
			position = 2,
			section = valueThresholdsSection
	)
	default java.awt.Color overlayColor1()
	{
		return new java.awt.Color(0, 0, 0, 180);
	}

	@ConfigItem(
			keyName = "valueThreshold2",
			name = "Medium value items",
			description = "Second value threshold for item highlighting",
			position = 3,
			section = valueThresholdsSection
	)
	@Range(min = 0, max = 100000000)
	default int valueThreshold2()
	{
		return 10000;
	}

	@Alpha
	@ConfigItem(
			keyName = "valueColor2",
			name = "Text Color: Medium",
			description = "Text color for items above threshold 2",
			position = 4,
			section = valueThresholdsSection
	)
	default java.awt.Color valueColor2()
	{
		return new java.awt.Color(0, 255, 0, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "overlayColor2",
			name = "Overlay Color: Medium",
			description = "Overlay color for total value above threshold 2",
			position = 5,
			section = valueThresholdsSection
	)
	default java.awt.Color overlayColor2()
	{
		return new java.awt.Color(0, 40, 0, 180);
	}

	@ConfigItem(
			keyName = "valueThreshold3",
			name = "High value items",
			description = "Third value threshold for item highlighting",
			position = 6,
			section = valueThresholdsSection
	)
	@Range(min = 0, max = 100000000)
	default int valueThreshold3()
	{
		return 50000;
	}

	@Alpha
	@ConfigItem(
			keyName = "valueColor3",
			name = "Text Color: High",
			description = "Text color for items above threshold 3",
			position = 7,
			section = valueThresholdsSection
	)
	default java.awt.Color valueColor3()
	{
		return new java.awt.Color(0, 200, 255, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "overlayColor3",
			name = "Overlay Color: High",
			description = "Overlay color for total value above threshold 3",
			position = 8,
			section = valueThresholdsSection
	)
	default java.awt.Color overlayColor3()
	{
		return new java.awt.Color(0, 20, 40, 180);
	}

	@ConfigItem(
			keyName = "valueThreshold4",
			name = "Insane value items",
			description = "Fourth value threshold for item highlighting",
			position = 9,
			section = valueThresholdsSection
	)
	@Range(min = 0, max = 100000000)
	default int valueThreshold4()
	{
		return 250000;
	}

	@Alpha
	@ConfigItem(
			keyName = "valueColor4",
			name = "Text Color: Insane",
			description = "Text color for items above threshold 4",
			position = 10,
			section = valueThresholdsSection
	)
	default java.awt.Color valueColor4()
	{
		return new java.awt.Color(255, 165, 0, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "overlayColor4",
			name = "Overlay Color: Insane",
			description = "Overlay color for total value above threshold 4",
			position = 11,
			section = valueThresholdsSection
	)
	default java.awt.Color overlayColor4()
	{
		return new java.awt.Color(40, 20, 0, 180);
	}

	@ConfigItem(
			keyName = "valueThreshold5",
			name = "Legendary value items",
			description = "Fifth value threshold for item highlighting",
			position = 12,
			section = valueThresholdsSection
	)
	@Range(min = 0, max = 100000000)
	default int valueThreshold5()
	{
		return 1000000;
	}

	@Alpha
	@ConfigItem(
			keyName = "valueColor5",
			name = "Text Color: Legendary",
			description = "Text color for items above threshold 5",
			position = 13,
			section = valueThresholdsSection
	)
	default java.awt.Color valueColor5()
	{
		return new java.awt.Color(255, 0, 0, 255);
	}

	@Alpha
	@ConfigItem(
			keyName = "overlayColor5",
			name = "Overlay Color: Legendary",
			description = "Overlay color for total value above threshold 5",
			position = 14,
			section = valueThresholdsSection
	)
	default java.awt.Color overlayColor5()
	{
		return new java.awt.Color(40, 0, 0, 180);
	}

	@ConfigItem(
			keyName = "valueBasedOverlay",
			name = "Enable value-based overlay",
			description = "Change overlay background color based on total value",
			position = 15,
			section = valueThresholdsSection
	)
	default boolean valueBasedOverlay()
	{
		return true;
	}

	// ========== ENUM DEFINITIONS ==========
	enum RareItemHighlight
	{
		OFF("Off"),
		STATIC("Static Color"),
		PULSE("Pulse"),
		RAINBOW("Rainbow");

		private final String name;

		RareItemHighlight(String name)
		{
			this.name = name;
		}

		@Override
		public String toString()
		{
			return name;
		}
	}

	enum ItemNamePosition
	{
		LEFT("Left"),
		RIGHT("Right");

		private final String name;

		ItemNamePosition(String name)
		{
			this.name = name;
		}

		@Override
		public String toString()
		{
			return name;
		}
	}
}
package com.LootHUD;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LootHudPlugin.class);
		RuneLite.main(args);
	}
}
