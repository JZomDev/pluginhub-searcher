package com.demoniclarvatracker;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.RenderingHints;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

@Singleton
class SceneOverlay extends Overlay
{
	private final Client client;
	private final DemonicLarvaTrackerPlugin plugin;
	private final DemonicLarvaTrackerConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	SceneOverlay(
		final Client client,
		final DemonicLarvaTrackerPlugin plugin,
		final DemonicLarvaTrackerConfig config,
		final ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(final Graphics2D graphics)
	{
		if (!config.highlightOutline() &&
			!config.highlightTileOutline() &&
			!config.highlightTileFill() &&
			!config.highlightHullOutline() &&
			!config.highlightHullFill() &&
			!config.highlightClickBoxOutline() &&
			!config.highlightClickBoxFill() &&
			!config.highlightNameLabel())
		{
			return null;
		}

		final var larvae = plugin.getLarvae();
		if (larvae.isEmpty())
		{
			return null;
		}

		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAliasing() ?
			RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);

		graphics.setFont(FontManager.getRunescapeFont());

		for (final var entry : larvae.entrySet())
		{
			final var npc = entry.getKey();

			if (config.hideHighlightOnDeath() && (npc.isDead() || (config.hideDeadLarva() && entry.getValue().isDead())))
			{
				continue;
			}

			if (config.highlightOutline())
			{
				renderOutline(npc);
			}

			if (config.highlightTileOutline() || config.highlightTileFill())
			{
				renderTile(graphics, npc);
			}

			if (config.highlightHullOutline() || config.highlightHullFill())
			{
				renderHull(graphics, npc);
			}

			if (config.highlightClickBoxOutline() || config.highlightClickBoxFill())
			{
				renderClickBox(graphics, npc);
			}

			if (config.highlightNameLabel())
			{
				renderNameLabel(graphics, npc);
			}
		}

		return null;
	}

	private void renderOutline(final NPC npc)
	{
		final Color color;

		switch (npc.getId())
		{
			case NpcID.DOM_DEMONIC_ENERGY:
				color = config.colorOutlineBase();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_RANGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
				color = config.colorOutlineRange();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MAGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
				color = config.colorOutlineMagic();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MELEE:
				color = config.colorOutlineMelee();
				break;
			default:
				return;
		}

		modelOutlineRenderer.drawOutline(npc, config.highlightOutlineWidth(), color, config.highlightOutlineFeather());
	}

	private void renderTile(final Graphics2D graphics, final NPC npc)
	{
		final Color outlineColor;
		final Color fillColor;

		switch (npc.getId())
		{
			case NpcID.DOM_DEMONIC_ENERGY:
				outlineColor = config.colorTileOutlineBase();
				fillColor = config.colorTileFillBase();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_RANGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
				outlineColor = config.colorTileOutlineRange();
				fillColor = config.colorTileFillRange();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MAGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
				outlineColor = config.colorTileOutlineMagic();
				fillColor = config.colorTileFillMagic();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MELEE:
				outlineColor = config.colorTileOutlineMelee();
				fillColor = config.colorTileFillMelee();
				break;
			default:
				return;
		}

		final Polygon polygon;

		switch (config.highlightTileMode())
		{
			case TILE:
				polygon = npc.getCanvasTilePoly();
				break;
			case TRUE_TILE:
				final var lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), npc.getWorldLocation());
				if (lp == null)
				{
					return;
				}
				polygon = Perspective.getCanvasTilePoly(client, lp);
				break;
			default:
				return;
		}

		if (config.highlightTileOutline())
		{
			graphics.setColor(outlineColor);
			graphics.setStroke(new BasicStroke((float) config.highlightTileOutlineWidth()));
			graphics.draw(polygon);
		}

		if (config.highlightTileFill())
		{
			graphics.setColor(fillColor);
			graphics.fill(polygon);
		}
	}

	private void renderHull(final Graphics2D graphics, final NPC npc)
	{
		final Color outlineColor;
		final Color fillColor;

		switch (npc.getId())
		{
			case NpcID.DOM_DEMONIC_ENERGY:
				outlineColor = config.colorHullOutlineBase();
				fillColor = config.colorHullFillBase();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_RANGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
				outlineColor = config.colorHullOutlineRange();
				fillColor = config.colorHullFillRange();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MAGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
				outlineColor = config.colorHullOutlineMagic();
				fillColor = config.colorHullFillMagic();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MELEE:
				outlineColor = config.colorHullOutlineMelee();
				fillColor = config.colorHullFillMelee();
				break;
			default:
				return;
		}

		final var shape = npc.getConvexHull();

		if (config.highlightHullOutline())
		{
			graphics.setColor(outlineColor);
			graphics.setStroke(new BasicStroke((float) config.highlightHullWidth()));
			graphics.draw(shape);
		}

		if (config.highlightHullFill())
		{
			graphics.setColor(fillColor);
			graphics.fill(shape);
		}
	}

	private void renderClickBox(final Graphics2D graphics, final NPC npc)
	{
		final var lp = npc.getLocalLocation();
		if (lp == null)
		{
			return;
		}

		final var shape = Perspective.getClickbox(client, npc.getModel(), npc.getCurrentOrientation(), lp.getX(), lp.getY(),
			Perspective.getTileHeight(client, lp, npc.getWorldView().getPlane()));
		if (shape == null)
		{
			return;
		}

		Color outlineColor;
		Color fillColor;

		switch (npc.getId())
		{
			case NpcID.DOM_DEMONIC_ENERGY:
				outlineColor = config.colorClickBoxOutlineBase();
				fillColor = config.colorClickBoxFillBase();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_RANGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
				outlineColor = config.colorClickBoxOutlineRange();
				fillColor = config.colorClickBoxFillRange();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MAGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
				outlineColor = config.colorClickBoxOutlineMagic();
				fillColor = config.colorClickBoxFillMagic();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MELEE:
				outlineColor = config.colorClickBoxOutlineMelee();
				fillColor = config.colorClickBoxFillMelee();
				break;
			default:
				return;
		}

		boolean mouseover = false;

		if (config.highlightClickboxMouseover())
		{
			final var point = client.getMouseCanvasPosition();
			mouseover = shape.contains(point.getX(), point.getY());
		}

		if (config.highlightClickBoxOutline())
		{
			if (mouseover)
			{
				outlineColor = darken(outlineColor, 0.7);
			}

			graphics.setColor(outlineColor);

			graphics.setStroke(new BasicStroke((float) config.highlightClickBoxWidth()));
			graphics.draw(shape);
		}

		if (config.highlightClickBoxFill())
		{
			if (mouseover)
			{
				fillColor = darken(fillColor, 0.5);
			}

			graphics.setColor(fillColor);

			graphics.fill(shape);
		}
	}

	private void renderNameLabel(final Graphics2D graphics, final NPC npc)
	{
		final String label;
		final Color color;

		switch (npc.getId())
		{
			case NpcID.DOM_DEMONIC_ENERGY_MELEE:
				label = config.nameLabelMelee();
				color = config.colorMenuMelee();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_RANGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
				label = config.nameLabelRange();
				color = config.colorMenuRange();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MAGE:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
				label = config.nameLabelMagic();
				color = config.colorMenuMagic();
				break;
			default:
				return;
		}

		if (label.isBlank())
		{
			return;
		}

		final var point = npc.getCanvasTextLocation(graphics, label, npc.getLogicalHeight() + 40);
		if (point == null)
		{
			return;
		}

		final int x = point.getX();
		final int y = point.getY();

		graphics.setColor(Color.BLACK);
		graphics.drawString(label, x + 1, y + 1);
		graphics.drawString(label, x + 2, y + 2);

		graphics.setColor(color);
		graphics.drawString(label, x, y);
	}

	private static Color darken(final Color color, final double factor)
	{
		return new Color(
			Math.max((int) (color.getRed() * factor), 0),
			Math.max((int) (color.getGreen() * factor), 0),
			Math.max((int) (color.getBlue() * factor), 0),
			color.getAlpha()
		);
	}
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.demoniclarvatracker;

enum AttackStyle
{
	ACCURATE,
	AGGRESSIVE,
	DEFENSIVE,
	CONTROLLED,
	RANGING,
	LONGRANGE,
	CASTING,
	DEFENSIVE_CASTING,
	OTHER;
}

/*
 * Copyright (c) 2025, marknewan <http://github.com/marknewan>
 * Copyright (c) 2023, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.demoniclarvatracker;

import com.google.inject.Provides;
import java.awt.Color;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.EnumID;
import net.runelite.api.GameState;
import net.runelite.api.Hitsplat;
import net.runelite.api.NPC;
import net.runelite.api.ParamID;
import net.runelite.api.Renderable;
import net.runelite.api.Skill;
import net.runelite.api.StructComposition;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.FakeXpDrop;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.AnimationID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.Counter;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;

@Slf4j
@Singleton
@PluginDescriptor(
	name = "Demonic Larva Tracker",
	description = "Tracks demonic larva at Doom of Mokhaiotl.",
	tags = {"doom", "mokhaiotl", "demonic", "larva", "grub", "tracker"}
)
public class DemonicLarvaTrackerPlugin extends Plugin
{
	private static final Set<Integer> REGION_IDS = Set.of(5269, 13668, 14180);
	private static final AttackStyle[] ATTACK_STYLES_POWERED_STAVE = new AttackStyle[]{
		AttackStyle.CASTING, AttackStyle.CASTING, null, AttackStyle.DEFENSIVE, null, null
	};

	// TODO: replace with gamevals when updated
	static final int NPC_ID_GIANT_DEMONIC_RANGE_LARVA = 14788;
	static final int NPC_ID_GIANT_DEMONIC_MAGIC_LARVA = 14789;

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private Hooks hooks;
	@Inject
	private DemonicLarvaTrackerConfig config;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private SceneOverlay sceneOverlay;
	@Inject
	private WidgetOverlay widgetOverlay;
	@Inject
	private InfoBoxManager infoBoxManager;
	@Inject
	private SpriteManager spriteManager;

	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	@Getter(AccessLevel.PACKAGE)
	private final Map<NPC, Larva> larvae = new HashMap<>();

	private final Map<Larva, Hitsplat> larvaHitsplats = new HashMap<>();
	private final Map<Skill, Integer> realXpDrops = new EnumMap<>(Skill.class);
	private final Map<Skill, Integer> fakeXpDrops = new EnumMap<>(Skill.class);

	private final int[] previousSkillXp = new int[Skill.values().length];

	@Nullable
	private NPC interactingNpc;
	@Nullable
	private AttackStyle attackStyle;
	@Nullable
	private Counter counter;

	private long lastTickNano;

	private boolean enabled;

	@Override
	protected void startUp()
	{
		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN && inRegion())
			{
				init();
			}
		});
	}

	private void init()
	{
		assert client.isClientThread();

		enabled = true;

		hooks.registerRenderableDrawListener(drawListener);

		overlayManager.add(sceneOverlay);
		overlayManager.add(widgetOverlay);

		setCounter();

		initAttackStyles();
		System.arraycopy(client.getSkillExperiences(), 0, previousSkillXp, 0, previousSkillXp.length);
	}

	@Override
	protected void shutDown()
	{
		enabled = false;

		hooks.unregisterRenderableDrawListener(drawListener);

		overlayManager.remove(sceneOverlay);
		overlayManager.remove(widgetOverlay);

		infoBoxManager.removeInfoBox(counter);

		larvae.clear();
		larvaHitsplats.clear();
		realXpDrops.clear();
		fakeXpDrops.clear();

		Arrays.fill(previousSkillXp, 0);

		interactingNpc = null;
		attackStyle = null;
		counter = null;

		lastTickNano = 0;
	}

	@Provides
	DemonicLarvaTrackerConfig provideConfig(final ConfigManager configManager)
	{
		return configManager.getConfig(DemonicLarvaTrackerConfig.class);
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event)
	{
		switch (event.getGameState())
		{
			case LOGGED_IN:
				if (inRegion())
				{
					if (!enabled)
					{
						init();
					}
				}
				else
				{
					if (enabled)
					{
						shutDown();
					}
				}
				break;
			case HOPPING:
			case LOGIN_SCREEN:
				if (enabled)
				{
					shutDown();
				}
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onGraphicChanged(final GraphicChanged event)
	{
		if (!enabled || !config.removeSpawnAnimation())
		{
			return;
		}

		final var actor = event.getActor();
		if (!(actor instanceof NPC))
		{
			return;
		}

		final var npc = (NPC) actor;
		if (!isLarva(npc))
		{
			return;
		}

		npc.clearSpotAnims();
	}

	@Subscribe
	public void onNpcSpawned(final NpcSpawned event)
	{
		if (!enabled)
		{
			return;
		}

		final var npc = event.getNpc();

		if (!isLarva(npc))
		{
			return;
		}

		larvae.put(npc, new Larva(npc));
		if (config.removeSpawnAnimation())
		{
			npc.clearSpotAnims();
			npc.setAnimation(AnimationID.NPC_DEMONIC_GRUB_WALK);
			npc.setAnimationFrame(0);
		}

		log.debug("{} - onNpcSpawned: {} ({})", client.getTickCount(), npc.getName(), npc.getIndex());
	}

	@Subscribe
	public void onNpcDespawned(final NpcDespawned event)
	{
		if (!enabled)
		{
			return;
		}

		final var npc = event.getNpc();
		final int id = npc.getId();

		if (isLarva(npc))
		{
			larvae.remove(npc);

			log.debug("{} - onNpcDespawned: {} ({})", client.getTickCount(), npc.getName(), npc.getIndex());
		}
		else if (id >= NpcID.DOM_BOSS && id <= NpcID.DOM_BOSS_BURROWED)
		{
			larvae.clear();
		}
	}

	@Subscribe
	public void onActorDeath(final ActorDeath event)
	{
		if (!enabled)
		{
			return;
		}

		final var actor = event.getActor();
		if (!(actor instanceof NPC))
		{
			return;
		}

		final var npc = (NPC) actor;

		final var larva = larvae.get(npc);
		if (larva == null)
		{
			return;
		}

		larva.kill(client.getTickCount());

		log.debug("{} - onActorDeath: {} ({})", client.getTickCount(), npc.getName(), npc.getIndex());
	}

	@Subscribe()
	private void onInteractingChanged(final InteractingChanged event)
	{
		if (!enabled || event.getSource() != client.getLocalPlayer())
		{
			return;
		}

		interactingNpc = null;

		final var actor = event.getTarget();
		if (!(actor instanceof NPC))
		{
			return;
		}

		final var npc = (NPC) actor;
		if (!isLarva(npc))
		{
			return;
		}

		this.interactingNpc = npc;

		log.debug("{} - onInteractingChanged: {} ({})", client.getTickCount(), npc.getName(), npc.getIndex());
	}

	@Subscribe
	public void onFakeXpDrop(final FakeXpDrop event)
	{
		if (!enabled)
		{
			return;
		}

		final var skill = event.getSkill();
		final var xp = event.getXp();

		switch (skill)
		{
			case ATTACK:
			case STRENGTH:
			case DEFENCE:
			case RANGED:
			case HITPOINTS:
				fakeXpDrops.merge(skill, xp, Integer::sum);

				log.debug("{} - onFakeXpDrop: {} {}", client.getTickCount(), skill, xp);
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onStatChanged(final StatChanged event)
	{
		if (!enabled)
		{
			return;
		}

		final var skill = event.getSkill();
		final var xp = event.getXp();

		final int idx = skill.ordinal();
		final int prevXp = previousSkillXp[idx];
		previousSkillXp[idx] = xp;
		if (prevXp == 0)
		{
			return;
		}

		final int xpDiff = xp - prevXp;
		if (xpDiff <= 0)
		{
			return;
		}

		switch (skill)
		{
			case ATTACK:
			case STRENGTH:
			case DEFENCE:
			case RANGED:
			case HITPOINTS:
				realXpDrops.merge(skill, xpDiff, Integer::sum);

				log.debug("{} - onStatChanged: skill={} xp={}", client.getTickCount(), skill, xpDiff);
				break;
			default:
				break;
		}
	}

	@Subscribe
	private void onHitsplatApplied(final HitsplatApplied event)
	{
		if (!enabled)
		{
			return;
		}

		final var hitsplat = event.getHitsplat();
		final int damage = hitsplat.getAmount();
		if (damage == 0)
		{
			return;
		}

		final var actor = event.getActor();
		if (!(actor instanceof NPC))
		{
			return;
		}

		final var npc = (NPC) actor;

		final var larva = larvae.get(npc);
		if (larva == null)
		{
			return;
		}

		larvaHitsplats.put(larva, hitsplat);

		log.debug("{} - onHitsplatApplied: {} ({}) damage={}", client.getTickCount(), npc.getName(), npc.getIndex(), damage);
	}

	@Subscribe
	public void onMenuEntryAdded(final MenuEntryAdded event)
	{
		if (!enabled || !config.recolorLarvaMenuEntries())
		{
			return;
		}

		final var entry = event.getMenuEntry();

		final var npc = entry.getNpc();
		if (npc == null)
		{
			return;
		}

		final Color color;

		switch (npc.getId())
		{
			case NpcID.DOM_DEMONIC_ENERGY:
				color = config.colorMenuBase();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_RANGE:
			case NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
				color = config.colorMenuRange();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MAGE:
			case NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
				color = config.colorMenuMagic();
				break;
			case NpcID.DOM_DEMONIC_ENERGY_MELEE:
				color = config.colorMenuMelee();
				break;
			default:
				return;
		}

		entry.setTarget(ColorUtil.colorTag(color) + npc.getName());
	}

	@Subscribe
	private void onVarbitChanged(final VarbitChanged event)
	{
		if (!enabled)
		{
			return;
		}

		if (event.getVarpId() == VarPlayerID.COM_MODE ||
			event.getVarbitId() == VarbitID.COMBAT_WEAPON_CATEGORY ||
			event.getVarbitId() == VarbitID.AUTOCAST_DEFMODE)
		{
			initAttackStyles();
		}
		else if (event.getVarbitId() == VarbitID.DOM_MISSED_ORBS)
		{
			if (counter != null)
			{
				counter.setCount(event.getValue());
			}
		}
	}

	@Subscribe
	public void onGameTick(final GameTick event)
	{
		if (!enabled || processLag())
		{
			return;
		}

		larvae.values().forEach(larva -> larva.setXpProcessed(false));

		processHitSplats();
		larvaHitsplats.clear();

		processXpDrops(realXpDrops);
		realXpDrops.clear();

		processXpDrops(fakeXpDrops);
		fakeXpDrops.clear();

		reviveLarvae();

		log.debug("---- END GAME TICK {} ----", client.getTickCount());
	}

	private void setCounter()
	{
		counter = new Counter(spriteManager.getSprite(SpriteID.IconBoss25x25.DOOM_OF_MOKHAIOTL, 0), this, client.getVarbitValue(VarbitID.DOM_MISSED_ORBS))
		{
			@Override
			public boolean render()
			{
				return getCount() > 0 && config.infoboxLarvaCounter();
			}
		};

		counter.setTooltip("Demonic Charge");

		infoBoxManager.addInfoBox(counter);
	}

	private boolean inRegion()
	{
		final var wv = client.getTopLevelWorldView();
		return wv.isInstance() && Arrays.stream(wv.getMapRegions()).anyMatch(REGION_IDS::contains);
	}

	private boolean shouldDraw(final Renderable renderable, final boolean overheads)
	{
		if (renderable instanceof NPC)
		{
			final var npc = (NPC) renderable;
			final var larva = larvae.get(npc);
			if (larva != null)
			{
				if (config.hideDeadLarva() && (npc.isDead() || larva.isDead()))
				{
					return false;
				}

				if (npc.getId() != NpcID.DOM_DEMONIC_ENERGY)
				{
					return !(overheads && config.hideLarvaOverheads());
				}
			}
		}

		return true;
	}

	private boolean processLag()
	{
		if (lastTickNano == 0)
		{
			lastTickNano = System.nanoTime();
			return false;
		}

		final long time = System.nanoTime();
		final int lastTickMillis = (int) ((time - lastTickNano) / 1_000_000L);
		lastTickNano = time;

		if (lastTickMillis < config.lagProtectionThreshold())
		{
			return false;
		}

		if (config.printLagMessages())
		{
			client.addChatMessage(
				ChatMessageType.GAMEMESSAGE,
				"DemonicLarvaTracker",
				String.format("[<col=FF0000>D<col=00FF00>L<col=0000FF>T</col>] <col=FFFF00>Warning</col>: Tick %d was <col=FFA500>%d ms</col>.",
					client.getTickCount(), lastTickMillis),
				null
			);
		}

		larvae.values().forEach(Larva::revive);
		larvaHitsplats.clear();
		realXpDrops.clear();
		fakeXpDrops.clear();

		return true;
	}

	private void processHitSplats()
	{
		if (larvaHitsplats.isEmpty())
		{
			return;
		}

		larvaHitsplats.keySet().removeIf(l -> !larvae.containsValue(l));

		for (final var entry : larvaHitsplats.entrySet())
		{
			final var larva = entry.getKey();
			final var npc = larva.getNpc();

			final int damage = entry.getValue().getAmount();

			log.debug("{} - processHitSplats (damage): {} ({}) queuedDamage={} damage={}",
				client.getTickCount(), npc.getName(), npc.getIndex(), larva.getQueuedDamage(), damage);

			larva.dequeueDamage(damage);
			if (larva.hasQueuedDamage())
			{
				continue;
			}

			larva.recalcHp();

			log.debug("{} - processHitSplats (hp): {} ({}) healthRatio={} healthScale={} hp={}",
				client.getTickCount(), npc.getName(), npc.getIndex(), npc.getHealthRatio(), npc.getHealthScale(), larva.getHp());

			if (larva.isDead())
			{
				larva.kill(client.getTickCount());

				log.debug("{} - processHitSplats (kill): {} ({}) hp={} deathTick={}",
					client.getTickCount(), npc.getName(), npc.getIndex(), larva.getHp(), larva.getDeathTick());
			}
			else
			{
				larva.resetDeathTick();

				log.debug("{} - processHitSplats (alive): {} ({}) hp={} deathTick={}",
					client.getTickCount(), npc.getName(), npc.getIndex(), larva.getHp(), larva.getDeathTick());
			}
		}
	}

	private void processXpDrops(final Map<Skill, Integer> xpDrops)
	{
		if (xpDrops.isEmpty())
		{
			return;
		}

		if (interactingNpc == null || attackStyle == null)
		{
			log.debug("{} - processXpDrops (skipping): interactingNpc={} attackStyle={}",
				client.getTickCount(), interactingNpc, attackStyle);
			return;
		}

		final var larva = larvae.get(interactingNpc);
		if (larva == null || larva.isDead() || larva.isXpProcessed())
		{
			log.debug("{} - processXpDrops (skipping): larva null/dead/processed", client.getTickCount());
			return;
		}

		final var npc = larva.getNpc();

		for (final var entry : xpDrops.entrySet())
		{
			var skill = entry.getKey();
			final var xp = entry.getValue();

			if (skill == Skill.ATTACK || skill == Skill.STRENGTH || skill == Skill.DEFENCE || skill == Skill.RANGED)
			{
				if (attackStyle == AttackStyle.LONGRANGE)
				{
					skill = Skill.RANGED;
				}
			}
			else if (skill == Skill.HITPOINTS && attackStyle != AttackStyle.CASTING)
			{
				log.debug("{} - processXpDrops (skipping): skill={} attackStyle={} != CASTING", client.getTickCount(), skill, attackStyle);
				continue;
			}

			larva.setXpProcessed(true);

			final int damage = calcDamageFromXpDrop(skill, xp);
			larva.damage(damage);

			if (larva.isDead())
			{
				larva.kill(client.getTickCount());

				log.debug("{} - processXpDrops (killed): {} ({}) damage={} queuedDamage={} hp={} deathTick={}",
					client.getTickCount(), npc.getName(), npc.getIndex(), damage, larva.getQueuedDamage(), larva.getHp(), larva.getDeathTick());
			}
			else
			{
				larva.resetDeathTick();

				log.debug("{} - processXpDrops (alive): {} ({}) damage={} queuedDamage={} hp={} deathTick={}",
					client.getTickCount(), npc.getName(), npc.getIndex(), damage, larva.getQueuedDamage(), larva.getHp(), larva.getDeathTick());
			}
		}
	}

	private void reviveLarvae()
	{
		if (larvae.isEmpty())
		{
			return;
		}

		for (final var entry : larvae.entrySet())
		{
			final var npc = entry.getKey();
			final var larva = entry.getValue();

			if (!larva.isTimedOut(client.getTickCount(), config.deathTickTimeout()))
			{
				continue;
			}

			final int deathTick = larva.getDeathTick();

			larva.revive();

			log.debug("{} - reviveLarvae: {} ({}) hp={} queuedDamage={} deathTick={}",
				client.getTickCount(), npc.getName(), npc.getIndex(), larva.getHp(), larva.getQueuedDamage(), deathTick);
		}
	}

	private void initAttackStyles()
	{
		final int equippedWeaponTypeVarbit = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);
		final int attackStyleVarbit = client.getVarpValue(VarPlayerID.COM_MODE);
		final int castingModeVarbit = client.getVarbitValue(VarbitID.AUTOCAST_DEFMODE);

		updateAttackStyle(equippedWeaponTypeVarbit, attackStyleVarbit, castingModeVarbit);
	}

	private void updateAttackStyle(final int equippedWeaponType, int attackStyleIndex, final int castingMode)
	{
		final AttackStyle[] attackStyles = getWeaponTypeStyles(equippedWeaponType);

		if (attackStyleIndex < attackStyles.length)
		{
			if (attackStyleIndex == 4)
			{
				attackStyleIndex += castingMode;
			}

			attackStyle = attackStyles[attackStyleIndex];

			if (attackStyle == AttackStyle.DEFENSIVE)
			{
				if (Arrays.equals(attackStyles, ATTACK_STYLES_POWERED_STAVE))
				{
					attackStyle = AttackStyle.DEFENSIVE_CASTING;
				}
			}
			else if (attackStyle == null)
			{
				attackStyle = AttackStyle.OTHER;
			}

			log.debug("{} - updateAttackStyle: attackStyle={}", client.getTickCount(), attackStyle);
		}
	}

	private AttackStyle[] getWeaponTypeStyles(final int weaponType)
	{
		final int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);
		if (weaponStyleEnum == -1)
		{
			if (weaponType == 22)
			{
				return new AttackStyle[]{
					AttackStyle.ACCURATE,
					AttackStyle.AGGRESSIVE,
					null,
					AttackStyle.DEFENSIVE,
					AttackStyle.CASTING,
					AttackStyle.DEFENSIVE_CASTING
				};
			}

			if (weaponType == 30)
			{
				return new AttackStyle[]{
					AttackStyle.ACCURATE, AttackStyle.AGGRESSIVE, AttackStyle.AGGRESSIVE, AttackStyle.DEFENSIVE
				};
			}
			return new AttackStyle[0];
		}
		final int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

		final AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
		int i = 0;
		for (final int style : weaponStyleStructs)
		{
			final StructComposition attackStyleStruct = client.getStructComposition(style);
			final String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);

			AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
			if (attackStyle == AttackStyle.OTHER)
			{
				++i;
				continue;
			}

			if (i == 5 && attackStyle == AttackStyle.DEFENSIVE)
			{
				attackStyle = AttackStyle.DEFENSIVE_CASTING;
			}

			styles[i++] = attackStyle;
		}
		return styles;
	}

	private int calcDamageFromXpDrop(final Skill skill, final int xp)
	{
		if (attackStyle == null)
		{
			return 0;
		}

		double damage = 0;

		switch (skill)
		{
			case ATTACK:
			case STRENGTH:
			case DEFENCE:
				switch (attackStyle)
				{
					case ACCURATE:
					case AGGRESSIVE:
					case DEFENSIVE:
						damage = xp / 4.0D;
						break;
					case CONTROLLED:
						damage = xp / 1.33D;
						break;
					case DEFENSIVE_CASTING:
						damage = xp;
						break;
					default:
						break;
				}
				break;
			case HITPOINTS:
				if (attackStyle == AttackStyle.CASTING)
				{
					damage = xp / 1.33D;
				}
				break;
			case RANGED:
				switch (attackStyle)
				{
					case RANGING:
						damage = xp / 4.0D;
						break;
					case LONGRANGE:
						damage = xp / 2.0D;
						break;
					default:
						break;
				}
				break;
			default:
				break;
		}

		return (int) Math.round(damage);
	}

	private static boolean isLarva(final NPC npc)
	{
		if (npc == null)
		{
			return false;
		}

		final int id = npc.getId();

		return id == NpcID.DOM_DEMONIC_ENERGY || id == NpcID.DOM_DEMONIC_ENERGY_RANGE ||
			id == NpcID.DOM_DEMONIC_ENERGY_MAGE || id == NpcID.DOM_DEMONIC_ENERGY_MELEE ||
			id == NPC_ID_GIANT_DEMONIC_RANGE_LARVA || id == NPC_ID_GIANT_DEMONIC_MAGIC_LARVA;
	}
}

package com.demoniclarvatracker;

import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.ToString;
import net.runelite.api.NPC;
import net.runelite.api.gameval.NpcID;

@ToString
@Getter(AccessLevel.PACKAGE)
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
class Larva
{
	@EqualsAndHashCode.Include
	private final NPC npc;

	private final int maxHp;
	private int hp;

	private int queuedDamage;

	private int deathTick;

	@Setter(AccessLevel.PACKAGE)
	private boolean xpProcessed;

	Larva(final @NonNull NPC npc)
	{
		this.npc = npc;

		switch (npc.getId())
		{
			case NpcID.DOM_DEMONIC_ENERGY:
			case NpcID.DOM_DEMONIC_ENERGY_RANGE:
			case NpcID.DOM_DEMONIC_ENERGY_MAGE:
			case NpcID.DOM_DEMONIC_ENERGY_MELEE:
				maxHp = 2;
				break;
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
			case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
				maxHp = 4;
				break;
			default:
				throw new IllegalArgumentException("Not a larva: " + npc.getName());
		}

		this.hp = maxHp;
	}

	boolean isDead()
	{
		return hp == 0;
	}

	void damage(final int amount)
	{
		queuedDamage = Math.min(maxHp, queuedDamage + amount);
		hp = Math.max(0, hp - amount);
	}

	void kill(final int tick)
	{
		hp = 0;
		deathTick = tick;
	}

	void resetDeathTick()
	{
		deathTick = 0;
	}

	void revive()
	{
		recalcHp();
		queuedDamage = 0;
		deathTick = 0;
	}

	void recalcHp()
	{
		final int ratio = npc.getHealthRatio();
		final int scale = npc.getHealthScale();

		if (ratio == -1 || scale == -1)
		{
			return;
		}

		hp = (int) (maxHp * ((double) ratio / scale));
	}

	boolean isTimedOut(final int tick, final int timeout)
	{
		return deathTick != 0 && tick > (deathTick + timeout);
	}

	void dequeueDamage(final int amount)
	{
		queuedDamage = Math.max(0, queuedDamage - amount);
	}

	boolean hasQueuedDamage()
	{
		return queuedDamage > 0;
	}
}

package com.demoniclarvatracker;

public enum TileMode
{
	TILE,
	TRUE_TILE
}

package com.demoniclarvatracker;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;
import net.runelite.client.util.ColorUtil;

@ConfigGroup(DemonicLarvaTrackerConfig.CONFIG_GROUP)
public interface DemonicLarvaTrackerConfig extends Config
{
	String CONFIG_GROUP = "demoniclarvatracker";

	@ConfigSection(
		name = "General",
		description = "",
		position = 0,
		closedByDefault = true
	)
	String SECTION_GENERAL = "general";

	@ConfigSection(
		name = "Highlights",
		description = "",
		position = 1,
		closedByDefault = true
	)
	String SECTION_HIGHLIGHTS = "highlights";

	@ConfigSection(
		name = "Base Larva",
		description = "",
		position = 2,
		closedByDefault = true
	)
	String SECTION_BASE_LARVA = "baseLarva";

	@ConfigSection(
		name = "Melee Larva",
		description = "",
		position = 3,
		closedByDefault = true
	)
	String SECTION_MELEE_LARVA = "meleeLarva";

	@ConfigSection(
		name = "Range Larva",
		description = "",
		position = 4,
		closedByDefault = true
	)
	String SECTION_RANGE_LARVA = "rangeLarva";

	@ConfigSection(
		name = "Magic Larva",
		description = "",
		position = 5,
		closedByDefault = true
	)
	String SECTION_MAGIC_LARVA = "magicLarva";

	@ConfigSection(
		name = "Advanced",
		description = "",
		position = 6,
		closedByDefault = true
	)
	String SECTION_ADVANCED = "advanced";

	// General

	@ConfigItem(
		name = "Death Prediction",
		description = "Hide larva predicted to die.",
		position = 0,
		keyName = "hideDeadLarva",
		section = SECTION_GENERAL
	)
	default boolean hideDeadLarva()
	{
		return true;
	}

	@Units(value = "ms")
	@ConfigItem(
		name = "Death Lag Protection",
		description = "Unhide larva after a lag spike.",
		position = 1,
		keyName = "lagProtectionThreshold",
		section = SECTION_GENERAL
	)
	default int lagProtectionThreshold()
	{
		return 1000;
	}

	@ConfigItem(
		name = "Print Lag Messages",
		description = "Print to chat when a lag spike is encountered." +
			"<br>Increase the lag protection if you see these messages a lot.",
		position = 2,
		keyName = "printLagMessages",
		section = SECTION_GENERAL
	)
	default boolean printLagMessages()
	{
		return false;
	}

	@ConfigItem(
		name = "Hide Larva Overheads",
		description = "Hide larva overheads." +
			"<br>Only applies to range, melee, and magic larvae.",
		position = 3,
		keyName = "hideLarvaOverheads",
		section = SECTION_GENERAL
	)
	default boolean hideLarvaOverheads()
	{
		return true;
	}

	@ConfigItem(
		name = "Recolor Larva Menu Entries",
		description = "Recolor menu entries for larva npcs.",
		position = 4,
		keyName = "recolorLarvaMenuEntries",
		section = SECTION_GENERAL
	)
	default boolean recolorLarvaMenuEntries()
	{
		return true;
	}

	@ConfigItem(
		name = "Remove Spawn Animation",
		description = "Remove the spawn animation from larvas.",
		position = 5,
		keyName = "removeSpawnAnimation",
		section = SECTION_GENERAL
	)
	default boolean removeSpawnAnimation()
	{
		return true;
	}

	@ConfigItem(
		name = "Infobox Larva Counter",
		description = "Displays a counter of how many larva have been absorbed." +
			"<br>Only displayed when there is at least 1 demonic charge.",
		position = 6,
		keyName = "infoboxLarvaCounter",
		section = SECTION_GENERAL
	)
	default boolean infoboxLarvaCounter()
	{
		return true;
	}

	// Highlights

	// Highlight Outline

	@ConfigItem(
		name = "Highlight Outline",
		description = "Highlight outline of larva npcs.",
		position = 0,
		keyName = "highlightOutline",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightOutline()
	{
		return false;
	}

	@Range(max = 50)
	@ConfigItem(
		name = "Width",
		description = "Width of highlight outline.",
		position = 1,
		keyName = "highlightOutlineWidth",
		section = SECTION_HIGHLIGHTS
	)
	default int highlightOutlineWidth()
	{
		return 1;
	}

	@Range(max = 4)
	@ConfigItem(
		name = "Feather",
		description = "Feather of highlight outline.",
		position = 2,
		keyName = "highlightOutlineFeather",
		section = SECTION_HIGHLIGHTS
	)
	default int highlightOutlineFeather()
	{
		return 1;
	}

	// Highlight Tile

	@ConfigItem(
		name = "Highlight Tile Outline",
		description = "Highlight tile outline of larva npcs.",
		position = 3,
		keyName = "highlightTileOutline",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightTileOutline()
	{
		return false;
	}

	@Range(max = 5)
	@ConfigItem(
		name = "Width",
		description = "Width of highlight tile outline.",
		position = 4,
		keyName = "highlightTileOutlineWidth",
		section = SECTION_HIGHLIGHTS
	)
	default double highlightTileOutlineWidth()
	{
		return 1;
	}

	@ConfigItem(
		name = "Highlight Tile Fill",
		description = "Highlight tile fill of larva npcs.",
		position = 5,
		keyName = "highlightTileFill",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightTileFill()
	{
		return false;
	}

	@ConfigItem(
		name = "Tile Mode",
		description = "Highlight tile mode of larva npcs.",
		position = 6,
		keyName = "highlightTileMode",
		section = SECTION_HIGHLIGHTS
	)
	default TileMode highlightTileMode()
	{
		return TileMode.TRUE_TILE;
	}

	// Highlight Hull

	@ConfigItem(
		name = "Highlight Hull Outline",
		description = "Highlight hull outline of larva npcs.",
		position = 7,
		keyName = "highlightHullOutline",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightHullOutline()
	{
		return false;
	}

	@Range(max = 50)
	@ConfigItem(
		name = "Width",
		description = "Width of highlight hull outline.",
		position = 8,
		keyName = "highlightHullWidth",
		section = SECTION_HIGHLIGHTS
	)
	default double highlightHullWidth()
	{
		return 1;
	}

	@ConfigItem(
		name = "Highlight Hull Fill",
		description = "Highlight hull fill of larva npcs.",
		position = 9,
		keyName = "highlightHullFill",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightHullFill()
	{
		return false;
	}

	// Highlight Clickbox

	@ConfigItem(
		name = "Highlight Clickbox Outline",
		description = "Highlight clickbox outline of larva npcs.",
		position = 10,
		keyName = "highlightClickBoxOutline",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightClickBoxOutline()
	{
		return false;
	}

	@Range(max = 50)
	@ConfigItem(
		name = "Width",
		description = "Width of highlight clickbox outline.",
		position = 11,
		keyName = "highlightClickBoxWidth",
		section = SECTION_HIGHLIGHTS
	)
	default double highlightClickBoxWidth()
	{
		return 1;
	}

	@ConfigItem(
		name = "Highlight Clickbox Fill",
		description = "Highlight clickbox fill of larva npcs.",
		position = 12,
		keyName = "highlightClickBoxFill",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightClickBoxFill()
	{
		return false;
	}

	@ConfigItem(
		name = "Clickbox Mouseover",
		description = "Darken color of the clickbox on mouseover.",
		position = 13,
		keyName = "highlightClickboxMouseover",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightClickboxMouseover()
	{
		return false;
	}

	// Highlight Minimap

	@ConfigItem(
		name = "Highlight Minimap",
		description = "Highlight minimap location of larva npcs.",
		position = 14,
		keyName = "highlightMinimap",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightMinimap()
	{
		return false;
	}

	@ConfigItem(
		name = "Name Labels",
		description = "Draw names above larva npcs." +
			"<br>Only applies to range, melee, and magic larvae.",
		position = 15,
		keyName = "highlightNameLabel",
		section = SECTION_HIGHLIGHTS
	)
	default boolean highlightNameLabel()
	{
		return false;
	}

	@ConfigItem(
		name = "Anti-aliasing",
		description = "Smooths out edges of outlines." +
			"<br>Reduces 'jagged' or 'stair-step' appearance that can occur.",
		position = 16,
		keyName = "antiAliasing",
		section = SECTION_HIGHLIGHTS
	)
	default boolean antiAliasing()
	{
		return false;
	}

	@ConfigItem(
		name = "Hide Highlights On Death",
		description = "Hides the highlighting of dead npcs.",
		position = 17,
		keyName = "hideHighlightOnDeath",
		section = SECTION_HIGHLIGHTS
	)
	default boolean hideHighlightOnDeath()
	{
		return true;
	}

	// Colors

	// Base Colors

	@Alpha
	@ConfigItem(
		name = "Outline",
		description = "",
		position = 0,
		keyName = "colorOutlineBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorOutlineBase()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Outline",
		description = "",
		position = 1,
		keyName = "colorTileOutlineBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorTileOutlineBase()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Fill",
		description = "",
		position = 2,
		keyName = "colorTileFillBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorTileFillBase()
	{
		return ColorUtil.colorWithAlpha(Color.WHITE, 32);
	}

	@Alpha
	@ConfigItem(
		name = "Hull Outline",
		description = "",
		position = 3,
		keyName = "colorHullOutlineBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorHullOutlineBase()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		name = "Hull Fill",
		description = "",
		position = 4,
		keyName = "colorHullFillBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorHullFillBase()
	{
		return ColorUtil.colorWithAlpha(Color.WHITE, 16);
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Outline",
		description = "",
		position = 5,
		keyName = "colorClickBoxOutlineBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorClickBoxOutlineBase()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Fill",
		description = "",
		position = 6,
		keyName = "colorClickBoxFillBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorClickBoxFillBase()
	{
		return ColorUtil.colorWithAlpha(Color.WHITE, 16);
	}

	@ConfigItem(
		name = "Menu Entry",
		description = "",
		position = 7,
		keyName = "colorMenuBase",
		section = SECTION_BASE_LARVA
	)
	default Color colorMenuBase()
	{
		return Color.WHITE;
	}

	// Melee Colors

	@Alpha
	@ConfigItem(
		name = "Outline",
		description = "",
		position = 0,
		keyName = "colorOutlineMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorOutlineMelee()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Outline",
		description = "",
		position = 1,
		keyName = "colorTileOutlineMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorTileOutlineMelee()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Fill",
		description = "",
		position = 2,
		keyName = "colorTileFillMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorTileFillMelee()
	{
		return ColorUtil.colorWithAlpha(Color.RED, 32);
	}

	@Alpha
	@ConfigItem(
		name = "Hull Outline",
		description = "",
		position = 3,
		keyName = "colorHullOutlineMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorHullOutlineMelee()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		name = "Hull Fill",
		description = "",
		position = 4,
		keyName = "colorHullFillMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorHullFillMelee()
	{
		return ColorUtil.colorWithAlpha(Color.RED, 16);
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Outline",
		description = "",
		position = 5,
		keyName = "colorClickBoxOutlineMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorClickBoxOutlineMelee()
	{
		return Color.RED;
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Fill",
		description = "",
		position = 6,
		keyName = "colorClickBoxFillMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorClickBoxFillMelee()
	{
		return ColorUtil.colorWithAlpha(Color.RED, 16);
	}

	@ConfigItem(
		name = "Menu Entry",
		description = "",
		position = 7,
		keyName = "colorMenuMelee",
		section = SECTION_MELEE_LARVA
	)
	default Color colorMenuMelee()
	{
		return Color.RED;
	}

	@ConfigItem(
		name = "Name Label",
		description = "",
		position = 8,
		keyName = "nameLabelMelee",
		section = SECTION_MELEE_LARVA
	)
	default String nameLabelMelee()
	{
		return "Melee";
	}

	// Range Colors

	@Alpha
	@ConfigItem(
		name = "Outline",
		description = "",
		position = 0,
		keyName = "colorOutlineRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorOutlineRange()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Outline",
		description = "",
		position = 1,
		keyName = "colorTileOutlineRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorTileOutlineRange()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Fill",
		description = "",
		position = 2,
		keyName = "colorTileFillRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorTileFillRange()
	{
		return ColorUtil.colorWithAlpha(Color.GREEN, 32);
	}

	@Alpha
	@ConfigItem(
		name = "Hull Outline",
		description = "",
		position = 3,
		keyName = "colorHullOutlineRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorHullOutlineRange()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		name = "Hull Fill",
		description = "",
		position = 4,
		keyName = "colorHullFillRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorHullFillRange()
	{
		return ColorUtil.colorWithAlpha(Color.GREEN, 16);
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Outline",
		description = "",
		position = 5,
		keyName = "colorClickBoxOutlineRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorClickBoxOutlineRange()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Fill",
		description = "",
		position = 6,
		keyName = "colorClickBoxFillRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorClickBoxFillRange()
	{
		return ColorUtil.colorWithAlpha(Color.GREEN, 16);
	}

	@ConfigItem(
		name = "Menu Entry",
		description = "",
		position = 7,
		keyName = "colorMenuRange",
		section = SECTION_RANGE_LARVA
	)
	default Color colorMenuRange()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		name = "Name Label",
		description = "",
		position = 8,
		keyName = "nameLabelRange",
		section = SECTION_RANGE_LARVA
	)
	default String nameLabelRange()
	{
		return "Range";
	}

	// Magic Colors

	@Alpha
	@ConfigItem(
		name = "Outline",
		description = "",
		position = 0,
		keyName = "colorOutlineMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorOutlineMagic()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Outline",
		description = "",
		position = 1,
		keyName = "colorTileOutlineMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorTileOutlineMagic()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		name = "Tile Fill",
		description = "",
		position = 2,
		keyName = "colorTileFillMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorTileFillMagic()
	{
		return ColorUtil.colorWithAlpha(Color.BLUE, 32);
	}

	@Alpha
	@ConfigItem(
		name = "Hull Outline",
		description = "",
		position = 3,
		keyName = "colorHullOutlineMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorHullOutlineMagic()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		name = "Hull Fill",
		description = "",
		position = 4,
		keyName = "colorHullFillMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorHullFillMagic()
	{
		return ColorUtil.colorWithAlpha(Color.BLUE, 16);
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Outline",
		description = "",
		position = 5,
		keyName = "colorClickBoxOutlineMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorClickBoxOutlineMagic()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		name = "Clickbox Fill",
		description = "",
		position = 6,
		keyName = "colorClickBoxFillMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorClickBoxFillMagic()
	{
		return ColorUtil.colorWithAlpha(Color.BLUE, 16);
	}

	@ConfigItem(
		name = "Menu Entry",
		description = "",
		position = 7,
		keyName = "colorMenuMagic",
		section = SECTION_MAGIC_LARVA
	)
	default Color colorMenuMagic()
	{
		return Color.BLUE;
	}

	@ConfigItem(
		name = "Name Label",
		description = "",
		position = 8,
		keyName = "nameLabelMagic",
		section = SECTION_MAGIC_LARVA
	)
	default String nameLabelMagic()
	{
		return "Mage";
	}

	// Advanced

	@Range(min = 2, max = 10)
	@ConfigItem(
		name = "Death Tick-timeout",
		description = "Failsafe timeout that unhides npcs after a # of ticks." +
			"<br>Default value = 2." +
			"<br>A sufficiently high value effectively disables the failsafe.",
		position = 0,
		keyName = "deathTickTimeout",
		section = SECTION_ADVANCED
	)
	default int deathTickTimeout()
	{
		return 2;
	}
}

package com.demoniclarvatracker;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

@Singleton
class WidgetOverlay extends Overlay
{
	private static final int MINIMAP_DOT_RADIUS = 4;

	private final DemonicLarvaTrackerPlugin plugin;
	private final DemonicLarvaTrackerConfig config;

	@Inject
	public WidgetOverlay(final DemonicLarvaTrackerPlugin plugin, final DemonicLarvaTrackerConfig config)
	{
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		if (!config.highlightMinimap())
		{
			return null;
		}

		final var larvae = plugin.getLarvae();
		if (larvae.isEmpty())
		{
			return null;
		}

		for (final var entry : larvae.entrySet())
		{
			final var npc = entry.getKey();

			if (npc.isDead() || (config.hideDeadLarva() && entry.getValue().isDead()))
			{
				continue;
			}

			final var point = npc.getMinimapLocation();
			if (point == null)
			{
				continue;
			}

			final Color color;

			switch (npc.getId())
			{
				case NpcID.DOM_DEMONIC_ENERGY:
					color = config.colorMenuBase();
					break;
				case NpcID.DOM_DEMONIC_ENERGY_RANGE:
				case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_RANGE_LARVA:
					color = config.colorMenuRange();
					break;
				case NpcID.DOM_DEMONIC_ENERGY_MAGE:
				case DemonicLarvaTrackerPlugin.NPC_ID_GIANT_DEMONIC_MAGIC_LARVA:
					color = config.colorMenuMagic();
					break;
				case NpcID.DOM_DEMONIC_ENERGY_MELEE:
					color = config.colorMenuMelee();
					break;
				default:
					continue;
			}

			graphics2D.setColor(Color.BLACK);
			graphics2D.fillOval(point.getX() - MINIMAP_DOT_RADIUS / 2, point.getY() - MINIMAP_DOT_RADIUS / 2 + 1, MINIMAP_DOT_RADIUS, MINIMAP_DOT_RADIUS);
			graphics2D.setColor(color);
			graphics2D.fillOval(point.getX() - MINIMAP_DOT_RADIUS / 2, point.getY() - MINIMAP_DOT_RADIUS / 2, MINIMAP_DOT_RADIUS, MINIMAP_DOT_RADIUS);
		}

		return null;
	}
}
package com.demoniclarvatracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DemonicLarvaTrackerPlugin.class);
		RuneLite.main(args);
	}
}
