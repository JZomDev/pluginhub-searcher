package com.regionlockenforcer;

import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.event.MouseAdapter;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.function.Supplier;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.JCheckBox;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

/**
 * Custom config component for managing regions.
 * Shows sections for Border and Teleports, with create/import buttons.
 */
@Slf4j
public class RegionConfigComponent extends JPanel
{
    private final RegionLockEnforcerPlugin plugin;
    private final TeleportRegistry teleportRegistry;
    private final JPanel borderListPanel;
    private final JPanel teleportsPanel;
    private final JPanel regionListPanel;
    private final JButton createButton;
    private final JButton importButton;
    private final JButton exportRegionButton;
    private final ImageIcon editIcon;
    private final ImageIcon resetIcon;
    private final ImageIcon deleteIcon;

    public RegionConfigComponent(RegionLockEnforcerPlugin plugin, @SuppressWarnings("unused") ConfigManager configManager, TeleportRegistry teleportRegistry)
    {
        super();
        this.plugin = plugin;
        this.teleportRegistry = teleportRegistry;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));
        setOpaque(true);
        this.editIcon = loadIcon("/edit_icon.png", this::createFallbackEditIcon);
        this.resetIcon = loadIcon("/reset_icon.png", this::createFallbackRefreshIcon);
        this.deleteIcon = loadIcon("/delete_icon.png", this::createFallbackDeleteIcon);

        // Top buttons panel - Create New Region, Import Region, Export Region (stacked vertically)
        JPanel topButtonPanel = new JPanel();
        topButtonPanel.setLayout(new BoxLayout(topButtonPanel, BoxLayout.Y_AXIS));
        topButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        topButtonPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 15, 0));
        
        // Create buttons with consistent styling
        Dimension buttonSize = new Dimension(180, 30);
        createButton = createStyledButton("Create New Region", buttonSize, e -> createNewRegion());
        importButton = createStyledButton("Import Region", buttonSize, e -> importRegion());
        exportRegionButton = createStyledButton("Export Region", buttonSize, e -> exportCurrentRegion());
        
        // Center buttons horizontally
        JPanel createButtonPanel = new JPanel();
        createButtonPanel.setLayout(new BoxLayout(createButtonPanel, BoxLayout.X_AXIS));
        createButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        createButtonPanel.add(Box.createHorizontalGlue());
        createButtonPanel.add(createButton);
        createButtonPanel.add(Box.createHorizontalGlue());
        topButtonPanel.add(createButtonPanel);
        
        topButtonPanel.add(Box.createVerticalStrut(5));
        
        JPanel importButtonPanel = new JPanel();
        importButtonPanel.setLayout(new BoxLayout(importButtonPanel, BoxLayout.X_AXIS));
        importButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        importButtonPanel.add(Box.createHorizontalGlue());
        importButtonPanel.add(importButton);
        importButtonPanel.add(Box.createHorizontalGlue());
        topButtonPanel.add(importButtonPanel);
        
        topButtonPanel.add(Box.createVerticalStrut(5));
        
        JPanel exportButtonPanel = new JPanel();
        exportButtonPanel.setLayout(new BoxLayout(exportButtonPanel, BoxLayout.X_AXIS));
        exportButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        exportButtonPanel.add(Box.createHorizontalGlue());
        exportButtonPanel.add(exportRegionButton);
        exportButtonPanel.add(Box.createHorizontalGlue());
        topButtonPanel.add(exportButtonPanel);
        
        add(topButtonPanel);
        
        // Region selection list
        JPanel regionLabelPanel = new JPanel();
        regionLabelPanel.setLayout(new BoxLayout(regionLabelPanel, BoxLayout.X_AXIS));
        regionLabelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        regionLabelPanel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
            BorderFactory.createEmptyBorder(12, 15, 12, 15)
        ));
        JLabel regionListLabel = new JLabel("Select Region");
        regionListLabel.setForeground(ColorScheme.BRAND_ORANGE);
        regionListLabel.setFont(regionListLabel.getFont().deriveFont(java.awt.Font.BOLD, 14f));
        regionListLabel.setAlignmentX(CENTER_ALIGNMENT);
        regionLabelPanel.add(Box.createHorizontalGlue());
        regionLabelPanel.add(regionListLabel);
        regionLabelPanel.add(Box.createHorizontalGlue());
        add(regionLabelPanel);
        
        regionListPanel = new JPanel();
        regionListPanel.setLayout(new BoxLayout(regionListPanel, BoxLayout.Y_AXIS));
        regionListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        regionListPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 15, 0));
        add(regionListPanel);

        // Configure Region section header
        JPanel configureRegionLabelPanel = new JPanel();
        configureRegionLabelPanel.setLayout(new BoxLayout(configureRegionLabelPanel, BoxLayout.X_AXIS));
        configureRegionLabelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        configureRegionLabelPanel.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
            BorderFactory.createEmptyBorder(12, 15, 12, 15)
        ));
        JLabel configureRegionLabel = new JLabel("Configure Region");
        configureRegionLabel.setForeground(ColorScheme.BRAND_ORANGE);
        configureRegionLabel.setFont(configureRegionLabel.getFont().deriveFont(java.awt.Font.BOLD, 14f));
        configureRegionLabel.setAlignmentX(CENTER_ALIGNMENT);
        configureRegionLabelPanel.add(Box.createHorizontalGlue());
        configureRegionLabelPanel.add(configureRegionLabel);
        configureRegionLabelPanel.add(Box.createHorizontalGlue());
        add(configureRegionLabelPanel);

        // Border Section
        JPanel borderLabelPanel = new JPanel();
        borderLabelPanel.setLayout(new BoxLayout(borderLabelPanel, BoxLayout.X_AXIS));
        borderLabelPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        borderLabelPanel.setBorder(BorderFactory.createEmptyBorder(15, 0, 5, 0));
        JLabel borderSectionLabel = new JLabel("Draw Border");
        borderSectionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        borderSectionLabel.setFont(borderSectionLabel.getFont().deriveFont(java.awt.Font.BOLD, 13f));
        borderSectionLabel.setAlignmentX(CENTER_ALIGNMENT);
        borderLabelPanel.add(Box.createHorizontalGlue());
        borderLabelPanel.add(borderSectionLabel);
        borderLabelPanel.add(Box.createHorizontalGlue());
        add(borderLabelPanel);
        
        // Dividing line below Draw Border heading
        JPanel borderDividerPanel = new JPanel();
        borderDividerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        borderDividerPanel.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR));
        borderDividerPanel.setPreferredSize(new Dimension(Integer.MAX_VALUE, 1));
        borderDividerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 1));
        add(borderDividerPanel);
        
        borderListPanel = new JPanel();
        borderListPanel.setLayout(new BoxLayout(borderListPanel, BoxLayout.Y_AXIS));
        borderListPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        borderListPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 15, 0));
        add(borderListPanel);

        // Teleports Section
        JPanel teleportsLabelPanel = new JPanel();
        teleportsLabelPanel.setLayout(new BoxLayout(teleportsLabelPanel, BoxLayout.X_AXIS));
        teleportsLabelPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        teleportsLabelPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 5, 0));
        JLabel teleportsSectionLabel = new JLabel("Teleports Whitelist");
        teleportsSectionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        teleportsSectionLabel.setFont(teleportsSectionLabel.getFont().deriveFont(java.awt.Font.BOLD, 13f));
        teleportsSectionLabel.setAlignmentX(CENTER_ALIGNMENT);
        teleportsLabelPanel.add(Box.createHorizontalGlue());
        teleportsLabelPanel.add(teleportsSectionLabel);
        teleportsLabelPanel.add(Box.createHorizontalGlue());
        add(teleportsLabelPanel);
        
        teleportsPanel = new JPanel();
        teleportsPanel.setLayout(new BoxLayout(teleportsPanel, BoxLayout.Y_AXIS));
        teleportsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        teleportsPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 15, 0));
        add(teleportsPanel);

        refreshRegionList();
        refreshBorderList();
    }

    /**
     * Create a styled button with consistent appearance.
     */
    private JButton createStyledButton(String text, Dimension size, java.awt.event.ActionListener action)
    {
        JButton button = new JButton(text);
        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        button.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        button.setFocusPainted(false);
        button.setPreferredSize(size);
        button.setMaximumSize(size);
        button.setMinimumSize(size);
        button.addActionListener(action);
        return button;
    }

    private String ellipsize(String text, int maxLength)
    {
        if (text == null)
        {
            return "";
        }
        if (maxLength < 4 || text.length() <= maxLength)
        {
            return text;
        }
        return text.substring(0, maxLength - 3) + "...";
    }

    private void createNewRegion()
    {
        String name = JOptionPane.showInputDialog(
            this,
            "Enter a name for the new region:",
            "Create New Region",
            JOptionPane.PLAIN_MESSAGE
        );

        if (name != null && !name.trim().isEmpty())
        {
            String trimmedName = name.trim();
            // Check if profile with this name already exists
            boolean exists = plugin.getRegions().stream()
                    .anyMatch(p -> p.getName().equals(trimmedName));
            
            if (!exists)
            {
                Region newProfile = plugin.createRegion(trimmedName);
                // Automatically enable editing mode for the new profile
                if (newProfile != null)
                {
                    plugin.setEditing(true);
                }
                refreshRegionList();
                refreshBorderList();
            }
            else
            {
                JOptionPane.showMessageDialog(
                    this,
                    "A region with that name already exists.",
                    "Error",
                    JOptionPane.ERROR_MESSAGE
                );
            }
        }
    }

    private void importRegion()
    {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Import Region");
        fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files (*.json)", "json"));
        
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION)
        {
            java.io.File file = fileChooser.getSelectedFile();
            plugin.importRegionFromFile(file.getAbsolutePath());
            refreshRegionList();
            refreshBorderList();
            refreshTeleportsList();
        }
    }
    
    private void exportCurrentRegion()
    {
        Region currentProfile = plugin.getCurrentRegion();
        if (currentProfile == null)
        {
            JOptionPane.showMessageDialog(
                this,
                "No region selected. Please select a region to export.",
                "No Region Selected",
                JOptionPane.WARNING_MESSAGE
            );
            return;
        }
        
        exportRegion(currentProfile);
    }
    
    private void exportRegion(Region profile)
    {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Export Region");
        fileChooser.setFileFilter(new FileNameExtensionFilter("JSON Files (*.json)", "json"));
        fileChooser.setSelectedFile(new java.io.File(profile.getName() + ".json"));
        
        int result = fileChooser.showSaveDialog(this);
        if (result == JFileChooser.APPROVE_OPTION)
        {
            java.io.File file = fileChooser.getSelectedFile();
            String filePath = file.getAbsolutePath();
            if (!filePath.toLowerCase().endsWith(".json"))
            {
                filePath += ".json";
            }
            
            if (plugin.exportRegion(profile, filePath))
            {
                JOptionPane.showMessageDialog(
                    this,
                    "Region exported successfully to:\n" + filePath,
                    "Export Successful",
                    JOptionPane.INFORMATION_MESSAGE
                );
            }
            else
            {
                JOptionPane.showMessageDialog(
                    this,
                    "Failed to export region.",
                    "Export Error",
                    JOptionPane.ERROR_MESSAGE
                );
            }
        }
    }


    private void deleteRegion(String regionName)
    {
        int result = JOptionPane.showConfirmDialog(
            this,
            "Delete the region '" + regionName + "'?\n" +
            "This will only remove it from RuneLite. The JSON file remains untouched.",
            "Delete Region",
            JOptionPane.YES_NO_OPTION,
            JOptionPane.WARNING_MESSAGE
        );

        if (result == JOptionPane.YES_OPTION)
        {
            plugin.deleteRegion(regionName);
            refreshRegionList();
            refreshBorderList();
        }
    }
    
    private void resetBorder(Region profile)
    {
        int result = JOptionPane.showConfirmDialog(
            this,
            "Are you sure you want to reset the border? This will remove all marked tiles.",
            "Reset Border",
            JOptionPane.YES_NO_OPTION,
            JOptionPane.WARNING_MESSAGE
        );

        if (result == JOptionPane.YES_OPTION)
        {
            // Clear all boundary tiles and inner tiles
            profile.getBoundaryTiles().clear();
            profile.getInnerTiles().clear();
            plugin.saveRegions();
            plugin.notifyRegionsChanged();
            // Automatically enable editing mode after reset
            plugin.setEditing(true);
            refreshRegionList();
            refreshBorderList();
        }
    }


    private void finishBorderFromList(Region profile)
    {
        if (profile.getBoundaryTiles().isEmpty())
        {
            JOptionPane.showMessageDialog(
                this,
                "No tiles marked. Please mark some tiles to define the border.",
                "Error",
                JOptionPane.ERROR_MESSAGE
            );
            return;
        }
        
        // Compute inner tiles
        boolean success = plugin.computeInnerTiles(profile);
        
        if (!success)
        {
            // Shape cannot be processed - show error and keep in edit mode
            JOptionPane.showMessageDialog(
                this,
                "Border must be fully enclosed before it can be finished.\n\n" +
                "Close every gap so the outline surrounds a complete area,\n" +
                "then click Finish again.",
                "Border Is Not Fully Bounded",
                JOptionPane.WARNING_MESSAGE
            );
            // Keep editing mode enabled (inner tiles are already cleared by computeInnerTiles)
            plugin.saveRegions();
            plugin.notifyRegionsChanged();
            refreshBorderList();
            return;
        }
        
        // Success - turn off editing toggle when finishing
        plugin.setEditing(false);
        plugin.saveRegions();
        plugin.notifyRegionsChanged();
        refreshRegionList();
        refreshBorderList();
    }


    private void editBorder(Region profile)
    {
        // Re-enable editing mode: clear inner tiles and enable editor
        plugin.enableEditingMode(profile);
        refreshRegionList();
        refreshBorderList();
    }

    private ImageIcon loadIcon(String resourcePath, Supplier<ImageIcon> fallback)
    {
        try
        {
            BufferedImage image = ImageUtil.loadImageResource(RegionConfigComponent.class, resourcePath);
            if (image != null)
            {
                return new ImageIcon(image);
            }
        }
        catch (Exception ex)
        {
            log.warn("Failed to load icon resource {}", resourcePath, ex);
        }
        return fallback.get();
    }

    /**
     * Fallback edit/pencil icon used if sprite is missing.
     */
    private ImageIcon createFallbackEditIcon()
    {
        BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = icon.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Set color to light gray (same as button foreground)
        g.setColor(ColorScheme.LIGHT_GRAY_COLOR);
        g.setStroke(new BasicStroke(1.5f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
        
        // Draw a clean pencil icon: simple angled pencil
        // Main pencil body (diagonal line)
        g.drawLine(4, 4, 12, 12);
        
        // Pencil tip (pointed triangle at bottom-right)
        java.awt.Polygon tip = new java.awt.Polygon();
        tip.addPoint(12, 12);
        tip.addPoint(10, 14);
        tip.addPoint(12, 14);
        g.fillPolygon(tip);
        
        // Pencil eraser (small filled square at top-left)
        g.fillRect(3, 3, 2, 2);
        
        g.dispose();
        return new ImageIcon(icon);
    }
    
    /**
     * Fallback refresh icon used if sprite is missing.
     */
    private ImageIcon createFallbackRefreshIcon()
    {
        BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = icon.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Set color to light gray (same as button foreground)
        g.setColor(ColorScheme.LIGHT_GRAY_COLOR);
        g.setStroke(new BasicStroke(1.5f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
        
        // Draw a circular arrow (refresh icon)
        // Center point
        int centerX = 8;
        int centerY = 8;
        int radius = 5;
        
        // Draw circular arc (about 270 degrees, starting from top-right)
        // Using drawArc: x, y, width, height, startAngle, arcAngle
        g.drawArc(centerX - radius, centerY - radius, radius * 2, radius * 2, 45, 270);
        
        // Draw arrow head at the end of the arc (pointing clockwise)
        // The arc ends at approximately 315 degrees (45 + 270)
        // Convert to radians: 315 degrees = 5.5 radians
        double endAngle = Math.toRadians(315);
        double arrowX = centerX + radius * Math.cos(endAngle);
        double arrowY = centerY + radius * Math.sin(endAngle);
        
        // Draw arrow head (small triangle pointing in the direction of rotation)
        java.awt.Polygon arrowHead = new java.awt.Polygon();
        // Arrow point
        arrowHead.addPoint((int)(arrowX), (int)(arrowY));
        // Arrow base point 1 (perpendicular to the arc)
        double perpAngle = endAngle + Math.PI / 2;
        arrowHead.addPoint((int)(arrowX - 2 * Math.cos(perpAngle)), (int)(arrowY - 2 * Math.sin(perpAngle)));
        // Arrow base point 2 (opposite side)
        arrowHead.addPoint((int)(arrowX - 2 * Math.cos(endAngle)), (int)(arrowY - 2 * Math.sin(endAngle)));
        g.fillPolygon(arrowHead);
        
        g.dispose();
        return new ImageIcon(icon);
    }

    /**
     * Fallback delete icon (simple X) used if sprite missing.
     */
    private ImageIcon createFallbackDeleteIcon()
    {
        BufferedImage icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g = icon.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setColor(ColorScheme.LIGHT_GRAY_COLOR);
        g.setStroke(new BasicStroke(2f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
        g.drawLine(4, 4, 12, 12);
        g.drawLine(12, 4, 4, 12);
        g.dispose();
        return new ImageIcon(icon);
    }

    public void refreshBorderList()
    {
        SwingUtilities.invokeLater(() -> {
            borderListPanel.removeAll();

            Region currentProfile = plugin.getCurrentRegion();
            
            if (currentProfile == null)
            {
                JPanel emptyPanel = new JPanel(new BorderLayout());
                emptyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                JLabel emptyLabel = new JLabel("No region selected");
                emptyLabel.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
                emptyLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));
                emptyPanel.add(emptyLabel, BorderLayout.WEST);
                borderListPanel.add(emptyPanel);
            }
            else
            {
                // Show current region's border section
                JPanel borderItemPanel = new JPanel(new BorderLayout());
                borderItemPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                borderItemPanel.setBorder(BorderFactory.createCompoundBorder(
                    BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
                    BorderFactory.createEmptyBorder(5, 10, 5, 10)
                ));

                // Border name label (show region name, not border name)
                String regionName = currentProfile.getName();
                boolean hasInnerTiles = !currentProfile.getInnerTiles().isEmpty();
                int maxChars = hasInnerTiles ? 26 : 20; // fewer chars when buttons occupy more space
                JLabel nameLabel = new JLabel(ellipsize(regionName, maxChars));
                nameLabel.setToolTipText(regionName);
                nameLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                borderItemPanel.add(nameLabel, BorderLayout.WEST);

                // Button panel for actions
                JPanel buttonPanel = new JPanel();
                buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.X_AXIS));
                buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                buttonPanel.setOpaque(false);
                
                if (hasInnerTiles)
                {
                    // Finished border: show edit and reset buttons
                    // Edit button with pencil icon
                    JButton editButton = new JButton();
                    editButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    editButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                    editButton.setFocusPainted(false);
                    editButton.setPreferredSize(new Dimension(25, 25));
                    editButton.setMaximumSize(new Dimension(25, 25));
                    editButton.setMinimumSize(new Dimension(25, 25));
                    editButton.setToolTipText("Edit");
                    editButton.setIcon(editIcon);
                    editButton.addActionListener(e -> editBorder(currentProfile));
                    buttonPanel.add(editButton);
                    
                    buttonPanel.add(Box.createHorizontalStrut(5));
                    
                    // Reset button with refresh icon
                    JButton resetButton = new JButton();
                    resetButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    resetButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                    resetButton.setFocusPainted(false);
                    resetButton.setPreferredSize(new Dimension(25, 25));
                    resetButton.setMaximumSize(new Dimension(25, 25));
                    resetButton.setMinimumSize(new Dimension(25, 25));
                    resetButton.setToolTipText("Reset Border");
                    resetButton.setIcon(resetIcon);
                    resetButton.addActionListener(e -> resetBorder(currentProfile));
                    buttonPanel.add(resetButton);
                }
                else
                {
                    // Unfinished border: show Finish button
                    JButton finishButton = new JButton("Finish");
                    finishButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    finishButton.setForeground(ColorScheme.BRAND_ORANGE);
                    finishButton.setBorder(BorderFactory.createLineBorder(ColorScheme.BRAND_ORANGE, 1));
                    finishButton.setFocusPainted(false);
                    finishButton.setPreferredSize(new Dimension(80, 25));
                    finishButton.setMaximumSize(new Dimension(80, 25));
                    finishButton.setMinimumSize(new Dimension(80, 25));
                    finishButton.setToolTipText("Draw Border Around Tiles");
                    finishButton.addActionListener(e -> finishBorderFromList(currentProfile));
                    buttonPanel.add(finishButton);
                }
                
                borderItemPanel.add(buttonPanel, BorderLayout.EAST);
                borderListPanel.add(borderItemPanel);
            }

            borderListPanel.revalidate();
            borderListPanel.repaint();
        });
    }
    
    public void refreshRegionList()
    {
        SwingUtilities.invokeLater(() -> {
            if (regionListPanel == null) return;
            
            regionListPanel.removeAll();
            
            java.util.List<Region> profiles = plugin.getRegions();
            Region currentProfile = plugin.getCurrentRegion();
            
            if (profiles.isEmpty())
            {
                JPanel emptyPanel = new JPanel(new BorderLayout());
                emptyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                JLabel emptyLabel = new JLabel("No regions created yet");
                emptyLabel.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
                emptyLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));
                emptyPanel.add(emptyLabel, BorderLayout.WEST);
                regionListPanel.add(emptyPanel);
            }
            else
            {
                for (Region profile : profiles)
                {
                    // Panel for each region item
                    JPanel regionItemPanel = new JPanel(new BorderLayout());
                    regionItemPanel.setBackground(
                        profile == currentProfile 
                            ? ColorScheme.DARKER_GRAY_HOVER_COLOR 
                            : ColorScheme.DARK_GRAY_COLOR
                    );
                    regionItemPanel.setBorder(BorderFactory.createCompoundBorder(
                        BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
                        BorderFactory.createEmptyBorder(5, 10, 5, 10)
                    ));

                    // Region name label (clickable to select)
                    String regionName = profile.getName();
                JLabel nameLabel = new JLabel(ellipsize(regionName, 32));
                    nameLabel.setToolTipText(regionName);
                    nameLabel.setForeground(
                        profile == currentProfile 
                            ? ColorScheme.BRAND_ORANGE 
                            : ColorScheme.LIGHT_GRAY_COLOR
                    );
                    nameLabel.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
                    
                    nameLabel.addMouseListener(new java.awt.event.MouseAdapter() {
                        @Override
                        public void mouseClicked(java.awt.event.MouseEvent e) {
                            plugin.selectRegion(profile.getName());
                            refreshRegionList();
                            refreshBorderList();
                        }
                        @Override
                        public void mouseEntered(java.awt.event.MouseEvent e) {
                            regionItemPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                        }
                        @Override
                        public void mouseExited(java.awt.event.MouseEvent e) {
                            regionItemPanel.setBackground(
                                profile == plugin.getCurrentRegion()
                                    ? ColorScheme.DARKER_GRAY_HOVER_COLOR
                                    : ColorScheme.DARK_GRAY_COLOR
                            );
                        }
                    });
                    regionItemPanel.add(nameLabel, BorderLayout.WEST);
                    
                    // Delete button
                    JButton deleteButton = new JButton();
                    deleteButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    deleteButton.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                    deleteButton.setFocusPainted(false);
                    deleteButton.setPreferredSize(new Dimension(25, 25));
                    deleteButton.setMaximumSize(new Dimension(25, 25));
                    deleteButton.setMinimumSize(new Dimension(25, 25));
                    deleteButton.setToolTipText("Delete Region");
                    deleteButton.setIcon(deleteIcon);
                    deleteButton.addActionListener(e -> deleteRegion(profile.getName()));
                    regionItemPanel.add(deleteButton, BorderLayout.EAST);
                    
                    regionListPanel.add(regionItemPanel);
                }
            }

            regionListPanel.revalidate();
            regionListPanel.repaint();
        });
    }
    
    public void refreshTeleportsList()
    {
        SwingUtilities.invokeLater(() -> {
            if (teleportsPanel == null || teleportRegistry == null) return;
            
            teleportsPanel.removeAll();
            
            Region currentProfile = plugin.getCurrentRegion();
            if (currentProfile == null)
            {
                JPanel emptyPanel = new JPanel(new BorderLayout());
                emptyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                JLabel emptyLabel = new JLabel("No region selected");
                emptyLabel.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
                emptyLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));
                emptyPanel.add(emptyLabel, BorderLayout.WEST);
                teleportsPanel.add(emptyPanel);
            }
            else
            {
                // Ensure whitelist exists
                if (currentProfile.getTeleportWhitelist() == null)
                {
                    currentProfile.setTeleportWhitelist(new java.util.HashSet<>());
                }
                
                // Get categories grouped by type
                java.util.Map<String, List<String>> categoriesByGroup = teleportRegistry.getCategoriesByGroup();
                
                // Display groups in order: Spellbooks, Jewellery, Miscellaneous
                String[] groupOrder = {"Spellbooks", "Jewellery", "Miscellaneous"};
                
                for (String groupName : groupOrder)
                {
                    List<String> categories = categoriesByGroup.get(groupName);
                    if (categories == null || categories.isEmpty())
                    {
                        continue;
                    }
                    
                    // Group header panel - make it stand out more
                    JPanel groupHeaderPanel = new JPanel(new BorderLayout());
                    groupHeaderPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                    groupHeaderPanel.setBorder(BorderFactory.createCompoundBorder(
                        BorderFactory.createMatteBorder(2, 0, 2, 0, ColorScheme.MEDIUM_GRAY_COLOR),
                        BorderFactory.createEmptyBorder(6, 15, 6, 15)
                    ));
                    
                    JLabel groupLabel = new JLabel(groupName);
                    groupLabel.setForeground(ColorScheme.BRAND_ORANGE);
                    groupLabel.setFont(groupLabel.getFont().deriveFont(java.awt.Font.BOLD, 15f));
                    groupHeaderPanel.add(groupLabel, BorderLayout.WEST);
                    teleportsPanel.add(groupHeaderPanel);
                    
                    // Sort categories alphabetically within this group
                    java.util.Collections.sort(categories);
                    
                    // Categories in this group
                    for (String category : categories)
                {
                    // Container panel for header + content - no padding on outer panel so header spans full width
                    JPanel categoryPanel = new JPanel(new BorderLayout());
                    categoryPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                    categoryPanel.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR));
                    
                    // Category header (clickable) - no padding, darkened background fills full width
                    JPanel categoryHeader = new JPanel(new BorderLayout());
                    categoryHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    categoryHeader.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10)); // Padding for label text only
                    categoryHeader.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
                    
                    JLabel categoryLabel = new JLabel(category);
                    categoryLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                    categoryLabel.setFont(categoryLabel.getFont().deriveFont(java.awt.Font.BOLD));
                    categoryHeader.add(categoryLabel, BorderLayout.WEST);
                    
                    // Panel to hold teleports in this category (collapsible body)
                    JPanel categoryContentPanel = new JPanel();
                    categoryContentPanel.setLayout(new BoxLayout(categoryContentPanel, BoxLayout.Y_AXIS));
                    categoryContentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                    categoryContentPanel.setBorder(BorderFactory.createEmptyBorder(0, 10, 0, 10)); // Left/right padding for content alignment
                    categoryContentPanel.setVisible(false); // collapsed by default
                    
                    // Add header and content to categoryPanel - use NORTH/CENTER for vertical stacking
                    // Structure: header at top, content below (when visible)
                    categoryPanel.add(categoryHeader, BorderLayout.NORTH);
                    categoryPanel.add(categoryContentPanel, BorderLayout.CENTER);
                    
                    // Toggle handler
                    MouseAdapter headerClickListener = new MouseAdapter() {
                        @Override
                        public void mouseClicked(java.awt.event.MouseEvent e) {
                            if (e.getSource() != categoryHeader && e.getSource() != categoryLabel)
                            {
                                return;
                            }
                            
                            boolean newState = !categoryContentPanel.isVisible();
                            categoryContentPanel.setVisible(newState);
                            
                            categoryContentPanel.revalidate();
                            categoryPanel.revalidate();
                            teleportsPanel.revalidate();
                            
                            categoryContentPanel.repaint();
                            categoryPanel.repaint();
                            teleportsPanel.repaint();
                        }
                    };
                    categoryHeader.addMouseListener(headerClickListener);
                    categoryLabel.addMouseListener(headerClickListener);
                    
                    // Add category panel - BoxLayout with Y_AXIS will left-align by default when alignmentX is 0.0f
                    // Remove any explicit alignment settings and let it match regionItemPanel behavior
                    teleportsPanel.add(categoryPanel);
                    
                    // Teleports in this category
                    List<TeleportDefinition> teleports = teleportRegistry.getTeleportsByCategory(category);
                    for (TeleportDefinition teleport : teleports)
                    {
                        final String teleportId = teleport.getId();
                        
                        // Skip Tele Group spells - they should be hidden and controlled via single teleports
                        if (teleportId.startsWith("spell_lunar_tele_group"))
                        {
                            continue;
                        }
                        
                        JPanel teleportItemPanel = new JPanel(new BorderLayout());
                        teleportItemPanel.setAlignmentX(0.0f);
                        teleportItemPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
                        teleportItemPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
                        // Left padding matches categoryPanel (10px), plus extra for checkbox (10px more)
                        teleportItemPanel.setBorder(BorderFactory.createCompoundBorder(
                            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
                            BorderFactory.createEmptyBorder(3, 10, 3, 10) // Same left padding as categoryPanel
                        ));
                        JCheckBox teleportCheckBox = new JCheckBox(teleport.getName());
                        teleportCheckBox.setBackground(ColorScheme.DARK_GRAY_COLOR);
                        teleportCheckBox.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                        teleportCheckBox.setSelected(currentProfile.getTeleportWhitelist().contains(teleportId));
                        teleportCheckBox.setFocusPainted(false);
                        
                        teleportCheckBox.addActionListener(e -> {
                            boolean isSelected = teleportCheckBox.isSelected();
                            
                            if (isSelected)
                            {
                                currentProfile.getTeleportWhitelist().add(teleportId);
                            }
                            else
                            {
                                currentProfile.getTeleportWhitelist().remove(teleportId);
                            }
                            
                            // Auto-toggle corresponding Tele Group
                            String teleGroupId = teleportRegistry.getTeleGroupIdForSingleTeleport(teleportId);
                            if (teleGroupId != null)
                            {
                                // This is a single teleport, toggle its Tele Group
                                if (isSelected)
                                {
                                    currentProfile.getTeleportWhitelist().add(teleGroupId);
                                }
                                else
                                {
                                    currentProfile.getTeleportWhitelist().remove(teleGroupId);
                                }
                            }
                            
                            plugin.saveRegions();
                            // Redraw spellbook to apply changes immediately
                            plugin.redrawSpellbook();
                        });
                        
                        teleportItemPanel.add(teleportCheckBox, BorderLayout.WEST);
                        categoryContentPanel.add(teleportItemPanel);
                    }
                }
                } // End of group loop
            }
            
            teleportsPanel.revalidate();
            teleportsPanel.repaint();
        });
    }
}


package com.regionlockenforcer;

/**
 * Types of teleports in the game.
 */
public enum TeleportType
{
    ITEM,           // Teleport from an item (e.g., Ring of Duelling, Amulet of Glory)
    SPELL,          // Teleport spell in spellbook
    OBJECT,         // Teleport from a game object (e.g., Portal, Obelisk)
    NPC_DIALOG      // Teleport from NPC dialog option
}


package com.regionlockenforcer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Singleton;
import lombok.Getter;

/**
 * Registry of all teleports in the game, organized by category.
 * This will be populated with all teleport definitions.
 */
@Singleton
@Getter
public class TeleportRegistry
{
    private final Map<String, List<TeleportDefinition>> teleportsByCategory = new HashMap<>();
    private final Map<String, TeleportDefinition> teleportsById = new HashMap<>();
    
    public TeleportRegistry()
    {
        initializeTeleports();
    }
    
    /**
     * Initialize all teleport definitions.
     * This will be expanded with all teleports in the game.
     */
    private void initializeTeleports()
    {
        // Ring of dueling teleports
        addTeleportCategory("Ring of dueling", createRingOfDuelingTeleports());
        
        // Games necklace teleports
        addTeleportCategory("Games necklace", createGamesNecklaceTeleports());
        
        // Pendant of ates teleports
        addTeleportCategory("Pendant of ates", createPendantOfAtesTeleports());
        
        // Standard spellbook teleports
        addTeleportCategory("Standard Spellbook", createStandardSpellbookTeleports());
        
        // Ancient Magicks spellbook teleports
        addTeleportCategory("Ancient Magicks", createAncientMagicksTeleports());
        
        // Lunar spellbook teleports
        addTeleportCategory("Lunar Spellbook", createLunarSpellbookTeleports());
        
        // Arceuus spellbook teleports
        addTeleportCategory("Arceuus Spellbook", createArceuusSpellbookTeleports());
        
        // Combat bracelet teleports
        addTeleportCategory("Combat bracelet", createCombatBraceletTeleports());
        
        // Skills necklace teleports
        addTeleportCategory("Skills necklace", createSkillsNecklaceTeleports());
        
        // Amulet of glory teleports (applies to both Amulet of glory and Amulet of eternal glory)
        addTeleportCategory("Amulet of glory", createAmuletOfGloryTeleports());
        
        // Ring of wealth teleports
        addTeleportCategory("Ring of wealth", createRingOfWealthTeleports());
        
        // Slayer ring teleports (applies to both Slayer ring and Slayer ring (eternal))
        addTeleportCategory("Slayer ring", createSlayerRingTeleports());
        
        // Digsite pendant teleports
        addTeleportCategory("Digsite pendant", createDigsitePendantTeleports());
        
        // Necklace of passage teleports
        addTeleportCategory("Necklace of passage", createNecklaceOfPassageTeleports());
        
        // Burning amulet teleports
        addTeleportCategory("Burning amulet", createBurningAmuletTeleports());
        
        // Ring of returning teleports
        addTeleportCategory("Ring of returning", createRingOfReturningTeleports());
        
        // Treasure Trail Scrolls teleports
        addTeleportCategory("Treasure Trail Scrolls", createTreasureTrailScrollsTeleports());
        
        // Chronicle teleports
        addTeleportCategory("Chronicle", createChronicleTeleports());
        
        // Giantsoul amulet teleports
        addTeleportCategory("Giantsoul amulet", createGiantsoulAmuletTeleports());
        
        // Xeric's talisman teleports
        addTeleportCategory("Xeric's talisman", createXericsTalismanTeleports());
        
        // Primio teleports
        addTeleportCategory("Primio", createPrimioTeleports());
        
        // Ring of the elements teleports
        addTeleportCategory("Ring of the elements", createRingOfElementsTeleports());
        
        // Charter Ships teleports
        addTeleportCategory("Charter Ships", createCharterShipsTeleports());
    }
    
    /**
     * Add a category of teleports.
     */
    private void addTeleportCategory(String categoryName, List<TeleportDefinition> teleports)
    {
        teleportsByCategory.put(categoryName, teleports);
        for (TeleportDefinition teleport : teleports)
        {
            teleportsById.put(teleport.getId(), teleport);
        }
    }
    
    /**
     * Create Ring of Dueling teleport definitions.
     */
    private List<TeleportDefinition> createRingOfDuelingTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Ring of dueling teleports
        teleports.add(createTeleport("ring_dueling_emirs_arena", "Emir's Arena", "Ring of dueling", 
            TeleportType.ITEM, "Rub", "Ring of dueling", null, null, null, null));
        teleports.add(createTeleport("ring_dueling_ferox_enclave", "Ferox Enclave", "Ring of dueling", 
            TeleportType.ITEM, "Rub", "Ring of dueling", null, null, null, null));
        teleports.add(createTeleport("ring_dueling_castle_wars", "Castle Wars", "Ring of dueling", 
            TeleportType.ITEM, "Rub", "Ring of dueling", null, null, null, null));
        teleports.add(createTeleport("ring_dueling_fortis_colosseum", "Fortis Colosseum", "Ring of dueling", 
            TeleportType.ITEM, "Rub", "Ring of dueling", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Games Necklace teleport definitions.
     */
    private List<TeleportDefinition> createGamesNecklaceTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Games necklace teleports
        teleports.add(createTeleport("games_necklace_barbarian_assault", "Barbarian Assault", "Games necklace", 
            TeleportType.ITEM, "Rub", "Games necklace", null, null, null, null));
        teleports.add(createTeleport("games_necklace_burthorpe", "Burthorpe Games Room", "Games necklace", 
            TeleportType.ITEM, "Rub", "Games necklace", null, null, null, null));
        teleports.add(createTeleport("games_necklace_tears_of_guthix", "Tears of Guthix", "Games necklace", 
            TeleportType.ITEM, "Rub", "Games necklace", null, null, null, null));
        teleports.add(createTeleport("games_necklace_corporeal_beast", "Corporeal Beast", "Games necklace", 
            TeleportType.ITEM, "Rub", "Games necklace", null, null, null, null));
        teleports.add(createTeleport("games_necklace_wintertodt", "Wintertodt Camp", "Games necklace", 
            TeleportType.ITEM, "Rub", "Games necklace", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Pendant of ates teleport definitions.
     */
    private List<TeleportDefinition> createPendantOfAtesTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Pendant of ates teleports
        teleports.add(createTeleport("pendant_ates_darkfrost", "Darkfrost", "Pendant of ates", 
            TeleportType.ITEM, "Teleport", "Pendant of ates", null, null, null, null));
        teleports.add(createTeleport("pendant_ates_twilight_temple", "Twilight Temple", "Pendant of ates", 
            TeleportType.ITEM, "Teleport", "Pendant of ates", null, null, null, null));
        teleports.add(createTeleport("pendant_ates_ralos_rise", "Ralos' Rise", "Pendant of ates", 
            TeleportType.ITEM, "Teleport", "Pendant of ates", null, null, null, null));
        teleports.add(createTeleport("pendant_ates_north_aldarin", "North Aldarin", "Pendant of ates", 
            TeleportType.ITEM, "Teleport", "Pendant of ates", null, null, null, null));
        teleports.add(createTeleport("pendant_ates_kastori", "Kastori", "Pendant of ates", 
            TeleportType.ITEM, "Teleport", "Pendant of ates", null, null, null, null));
        teleports.add(createTeleport("pendant_ates_nemus_retreat", "Nemus Retreat", "Pendant of ates", 
            TeleportType.ITEM, "Teleport", "Pendant of ates", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Standard Spellbook teleport definitions.
     */
    private List<TeleportDefinition> createStandardSpellbookTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Standard spellbook teleports in the order they appear in the spellbook
        teleports.add(createTeleport("spell_lumbridge_home", "Lumbridge Home Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Lumbridge Home Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_varrock", "Varrock Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Varrock Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lumbridge", "Lumbridge Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Lumbridge Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_falador", "Falador Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Falador Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_teleport_to_house", "Teleport to House", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Teleport to House", null, null, null, null));
        teleports.add(createTeleport("spell_camelot", "Camelot Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Camelot Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_kourend_castle", "Kourend Castle Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Kourend Castle Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ardougne", "Ardougne Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Ardougne Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_civitas_illa_fortis", "Civitas illa Fortis Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Civitas illa Fortis Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_watchtower", "Watchtower Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Watchtower Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_trollheim", "Trollheim Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Trollheim Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ape_atoll", "Ape Atoll Teleport", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Ape Atoll Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_teleport_me_to_boat", "Teleport me to Boat", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Teleport me to Boat", null, null, null, null));
        teleports.add(createTeleport("spell_teleport_to_target", "Teleport to Target", "Standard Spellbook", 
            TeleportType.SPELL, "Cast", "Teleport to Target", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Ancient Magicks spellbook teleport definitions.
     */
    private List<TeleportDefinition> createAncientMagicksTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Ancient Magicks spellbook teleports in the order they appear in the spellbook
        teleports.add(createTeleport("spell_ancient_edgeville_home", "Edgeville Home Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Edgeville Home Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_paddewwa", "Paddewwa Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Paddewwa Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_senntisten", "Senntisten Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Senntisten Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_kharyrll", "Kharyrll Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Kharyrll Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_lassar", "Lassar Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Lassar Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_dareeyak", "Dareeyak Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Dareeyak Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_carrallanger", "Carrallanger Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Carrallanger Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_annakarl", "Annakarl Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Annakarl Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_ancient_ghorrock", "Ghorrock Teleport", "Ancient Magicks", 
            TeleportType.SPELL, "Cast", "Ghorrock Teleport", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Lunar spellbook teleport definitions.
     */
    private List<TeleportDefinition> createLunarSpellbookTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Lunar spellbook teleports in the order they appear in the spellbook
        teleports.add(createTeleport("spell_lunar_home", "Lunar Home Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Lunar Home Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_moonclan", "Moonclan Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Moonclan Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_ourania", "Ourania Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Ourania Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_waterbirth", "Waterbirth Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Waterbirth Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_barbarian", "Barbarian Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Barbarian Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_khazard", "Khazard Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Khazard Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_fishing_guild", "Fishing Guild Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Fishing Guild Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_catherby", "Catherby Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Catherby Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_ice_plateau", "Ice Plateau Teleport", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Ice Plateau Teleport", null, null, null, null));
        
        // Tele Group spells
        teleports.add(createTeleport("spell_lunar_tele_group_moonclan", "Tele Group Moonclan", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Tele Group Moonclan", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_tele_group_waterbirth", "Tele Group Waterbirth", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Tele Group Waterbirth", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_tele_group_barbarian", "Tele Group Barbarian", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Tele Group Barbarian", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_tele_group_khazard", "Tele Group Khazard", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Tele Group Khazard", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_tele_group_fishing_guild", "Tele Group Fishing Guild", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Tele Group Fishing Guild", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_tele_group_catherby", "Tele Group Catherby", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Tele Group Catherby", null, null, null, null));
        teleports.add(createTeleport("spell_lunar_tele_group_ice_plateau", "Tele Group Ice Plateau", "Lunar Spellbook", 
            TeleportType.SPELL, "Cast", "Tele Group Ice Plateau", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Get the Tele Group spell ID for a given single teleport spell ID.
     * Returns null if there is no corresponding Tele Group spell.
     */
    public String getTeleGroupIdForSingleTeleport(String singleTeleportId)
    {
        // Map single teleport IDs to their Tele Group equivalents
        java.util.Map<String, String> singleToGroup = new java.util.HashMap<>();
        singleToGroup.put("spell_lunar_moonclan", "spell_lunar_tele_group_moonclan");
        singleToGroup.put("spell_lunar_waterbirth", "spell_lunar_tele_group_waterbirth");
        singleToGroup.put("spell_lunar_barbarian", "spell_lunar_tele_group_barbarian");
        singleToGroup.put("spell_lunar_khazard", "spell_lunar_tele_group_khazard");
        singleToGroup.put("spell_lunar_fishing_guild", "spell_lunar_tele_group_fishing_guild");
        singleToGroup.put("spell_lunar_catherby", "spell_lunar_tele_group_catherby");
        singleToGroup.put("spell_lunar_ice_plateau", "spell_lunar_tele_group_ice_plateau");
        
        return singleToGroup.get(singleTeleportId);
    }
    
    /**
     * Get the single teleport spell ID for a given Tele Group spell ID.
     * Returns null if there is no corresponding single teleport.
     */
    public String getSingleTeleportIdForTeleGroup(String teleGroupId)
    {
        // Map Tele Group IDs to their single teleport equivalents
        java.util.Map<String, String> groupToSingle = new java.util.HashMap<>();
        groupToSingle.put("spell_lunar_tele_group_moonclan", "spell_lunar_moonclan");
        groupToSingle.put("spell_lunar_tele_group_waterbirth", "spell_lunar_waterbirth");
        groupToSingle.put("spell_lunar_tele_group_barbarian", "spell_lunar_barbarian");
        groupToSingle.put("spell_lunar_tele_group_khazard", "spell_lunar_khazard");
        groupToSingle.put("spell_lunar_tele_group_fishing_guild", "spell_lunar_fishing_guild");
        groupToSingle.put("spell_lunar_tele_group_catherby", "spell_lunar_catherby");
        groupToSingle.put("spell_lunar_tele_group_ice_plateau", "spell_lunar_ice_plateau");
        
        return groupToSingle.get(teleGroupId);
    }
    
    /**
     * Get the spell teleport ID for a given tablet name.
     * Returns null if there is no corresponding spell teleport.
     * Used to hide "Break" option on tablets when the spell is not whitelisted.
     */
    public String getSpellTeleportIdForTablet(String tabletName)
    {
        // Map tablet names to their corresponding spell teleport IDs
        java.util.Map<String, String> tabletToSpell = new java.util.HashMap<>();
        
        // Standard spellbook tablets
        tabletToSpell.put("varrock tablet", "spell_varrock");
        tabletToSpell.put("falador tablet", "spell_falador");
        tabletToSpell.put("lumbridge tablet", "spell_lumbridge");
        tabletToSpell.put("camelot tablet", "spell_camelot");
        tabletToSpell.put("ardougne tablet", "spell_ardougne");
        tabletToSpell.put("civitas illa fortis tablet", "spell_civitas_illa_fortis");
        tabletToSpell.put("watchtower tablet", "spell_watchtower");
        tabletToSpell.put("house tablet", "spell_teleport_to_house");
        tabletToSpell.put("kourend castle tablet", "spell_kourend_castle");
        tabletToSpell.put("target teleport", "spell_teleport_to_target");
        
        // Ancient Magicks tablets
        tabletToSpell.put("paddewwa teleport tablet", "spell_ancient_paddewwa");
        tabletToSpell.put("senntisten teleport tablet", "spell_ancient_senntisten");
        tabletToSpell.put("kharyrll teleport tablet", "spell_ancient_kharyrll");
        tabletToSpell.put("lassar teleport tablet", "spell_ancient_lassar");
        tabletToSpell.put("dareeyak teleport tablet", "spell_ancient_dareeyak");
        tabletToSpell.put("carrallanger teleport tablet", "spell_ancient_carrallanger");
        tabletToSpell.put("annakarl teleport tablet", "spell_ancient_annakarl");
        tabletToSpell.put("ghorrock teleport tablet", "spell_ancient_ghorrock");
        
        // Lunar Spellbook tablets
        tabletToSpell.put("moonclan teleport tablet", "spell_lunar_moonclan");
        tabletToSpell.put("ourania teleport tablet", "spell_lunar_ourania");
        tabletToSpell.put("waterbirth teleport tablet", "spell_lunar_waterbirth");
        tabletToSpell.put("barbarian teleport tablet", "spell_lunar_barbarian");
        tabletToSpell.put("khazard teleport tablet", "spell_lunar_khazard");
        tabletToSpell.put("fishing guild teleport tablet", "spell_lunar_fishing_guild");
        tabletToSpell.put("catherby teleport tablet", "spell_lunar_catherby");
        tabletToSpell.put("ice plateau teleport tablet", "spell_lunar_ice_plateau");
        
        // Arceuus Spellbook tablets
        tabletToSpell.put("arceuus library tablet", "spell_arceuus_library");
        tabletToSpell.put("draynor manor tablet", "spell_arceuus_draynor_manor");
        tabletToSpell.put("battlefront tablet", "spell_arceuus_battlefront");
        tabletToSpell.put("mind altar tablet", "spell_arceuus_mind_altar");
        tabletToSpell.put("salve graveyard tablet", "spell_arceuus_salve_graveyard");
        tabletToSpell.put("fenkenstrain's castle tablet", "spell_arceuus_fenkenstrain");
        tabletToSpell.put("west ardougne tablet", "spell_arceuus_west_ardougne");
        tabletToSpell.put("harmony island tablet", "spell_arceuus_harmony_island");
        tabletToSpell.put("cemetery tablet", "spell_arceuus_cemetery");
        tabletToSpell.put("barrows tablet", "spell_arceuus_barrows");
        tabletToSpell.put("ape atoll tablet", "spell_arceuus_ape_atoll"); // Maps to Arceuus spellbook, not standard
        
        // Normalize tablet name (lowercase, remove extra spaces)
        String normalizedTablet = tabletName != null ? tabletName.toLowerCase().trim() : "";
        return tabletToSpell.get(normalizedTablet);
    }
    
    /**
     * Create Arceuus spellbook teleport definitions.
     */
    private List<TeleportDefinition> createArceuusSpellbookTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Arceuus spellbook teleports in the order they appear in the spellbook
        teleports.add(createTeleport("spell_arceuus_home", "Arceuus Home Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Arceuus Home Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_library", "Arceuus Library Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Arceuus Library Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_draynor_manor", "Draynor Manor Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Draynor Manor Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_battlefront", "Battlefront Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Battlefront Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_mind_altar", "Mind Altar Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Mind Altar Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_respawn", "Respawn Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Respawn Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_salve_graveyard", "Salve Graveyard Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Salve Graveyard Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_fenkenstrain", "Fenkenstrain's Castle Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Fenkenstrain's Castle Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_west_ardougne", "West Ardougne Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "West Ardougne Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_harmony_island", "Harmony Island Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Harmony Island Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_cemetery", "Cemetery Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Cemetery Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_barrows", "Barrows Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Barrows Teleport", null, null, null, null));
        teleports.add(createTeleport("spell_arceuus_ape_atoll", "Ape Atoll Teleport", "Arceuus Spellbook", 
            TeleportType.SPELL, "Cast", "Ape Atoll Teleport", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Combat Bracelet teleport definitions.
     */
    private List<TeleportDefinition> createCombatBraceletTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Combat bracelet teleports
        teleports.add(createTeleport("combat_bracelet_warriors_guild", "Warriors' Guild", "Combat bracelet", 
            TeleportType.ITEM, "Rub", "Combat bracelet", null, null, null, null));
        teleports.add(createTeleport("combat_bracelet_champions_guild", "Champions' Guild", "Combat bracelet", 
            TeleportType.ITEM, "Rub", "Combat bracelet", null, null, null, null));
        teleports.add(createTeleport("combat_bracelet_edgeville_monastery", "Edgeville Monastery", "Combat bracelet", 
            TeleportType.ITEM, "Rub", "Combat bracelet", null, null, null, null));
        teleports.add(createTeleport("combat_bracelet_ranging_guild", "Ranging Guild", "Combat bracelet", 
            TeleportType.ITEM, "Rub", "Combat bracelet", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Skills Necklace teleport definitions.
     */
    private List<TeleportDefinition> createSkillsNecklaceTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Skills necklace teleports
        teleports.add(createTeleport("skills_necklace_fishing_guild", "Fishing Guild", "Skills necklace", 
            TeleportType.ITEM, "Rub", "Skills necklace", null, null, null, null));
        teleports.add(createTeleport("skills_necklace_mining_guild", "Mining Guild", "Skills necklace", 
            TeleportType.ITEM, "Rub", "Skills necklace", null, null, null, null));
        teleports.add(createTeleport("skills_necklace_crafting_guild", "Crafting Guild", "Skills necklace", 
            TeleportType.ITEM, "Rub", "Skills necklace", null, null, null, null));
        teleports.add(createTeleport("skills_necklace_cooks_guild", "Cooks' Guild", "Skills necklace", 
            TeleportType.ITEM, "Rub", "Skills necklace", null, null, null, null));
        teleports.add(createTeleport("skills_necklace_woodcutting_guild", "Woodcutting Guild", "Skills necklace", 
            TeleportType.ITEM, "Rub", "Skills necklace", null, null, null, null));
        teleports.add(createTeleport("skills_necklace_farming_guild", "Farming Guild", "Skills necklace", 
            TeleportType.ITEM, "Rub", "Skills necklace", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Amulet of Glory teleport definitions.
     * Note: These teleports apply to both "Amulet of glory" and "Amulet of eternal glory".
     */
    private List<TeleportDefinition> createAmuletOfGloryTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Amulet of glory teleports (works for both regular and eternal)
        teleports.add(createTeleport("amulet_glory_edgeville", "Edgeville", "Amulet of glory", 
            TeleportType.ITEM, "Rub", "Amulet of glory", null, null, null, null));
        teleports.add(createTeleport("amulet_glory_karamja", "Karamja", "Amulet of glory", 
            TeleportType.ITEM, "Rub", "Amulet of glory", null, null, null, null));
        teleports.add(createTeleport("amulet_glory_draynor", "Draynor Village", "Amulet of glory", 
            TeleportType.ITEM, "Rub", "Amulet of glory", null, null, null, null));
        teleports.add(createTeleport("amulet_glory_al_kharid", "Al Kharid", "Amulet of glory", 
            TeleportType.ITEM, "Rub", "Amulet of glory", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Ring of Wealth teleport definitions.
     */
    private List<TeleportDefinition> createRingOfWealthTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Ring of wealth teleports
        teleports.add(createTeleport("ring_wealth_miscellania", "Miscellania", "Ring of wealth", 
            TeleportType.ITEM, "Rub", "Ring of wealth", null, null, null, null));
        teleports.add(createTeleport("ring_wealth_grand_exchange", "Grand Exchange", "Ring of wealth", 
            TeleportType.ITEM, "Rub", "Ring of wealth", null, null, null, null));
        teleports.add(createTeleport("ring_wealth_falador_park", "Falador Park", "Ring of wealth", 
            TeleportType.ITEM, "Rub", "Ring of wealth", null, null, null, null));
        teleports.add(createTeleport("ring_wealth_dondakan", "Dondakan", "Ring of wealth", 
            TeleportType.ITEM, "Rub", "Ring of wealth", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Slayer Ring teleport definitions.
     * Note: These teleports apply to both "Slayer ring" and "Slayer ring (eternal)".
     */
    private List<TeleportDefinition> createSlayerRingTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Slayer ring teleports (works for both regular and eternal)
        teleports.add(createTeleport("slayer_ring_slayer_tower", "Slayer Tower", "Slayer ring", 
            TeleportType.ITEM, "Rub", "Slayer ring", null, null, null, null));
        teleports.add(createTeleport("slayer_ring_fremennik_slayer_dungeon", "Fremennik Slayer Dungeon", "Slayer ring", 
            TeleportType.ITEM, "Rub", "Slayer ring", null, null, null, null));
        teleports.add(createTeleport("slayer_ring_tarns_lair", "Tarn's Lair", "Slayer ring", 
            TeleportType.ITEM, "Rub", "Slayer ring", null, null, null, null));
        teleports.add(createTeleport("slayer_ring_stronghold_slayer_cave", "Stronghold Slayer Cave", "Slayer ring", 
            TeleportType.ITEM, "Rub", "Slayer ring", null, null, null, null));
        teleports.add(createTeleport("slayer_ring_dark_beasts", "Dark Beasts", "Slayer ring", 
            TeleportType.ITEM, "Rub", "Slayer ring", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Digsite Pendant teleport definitions.
     */
    private List<TeleportDefinition> createDigsitePendantTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Digsite pendant teleports
        teleports.add(createTeleport("digsite_pendant_digsite", "Digsite", "Digsite pendant", 
            TeleportType.ITEM, "Rub", "Digsite pendant", null, null, null, null));
        teleports.add(createTeleport("digsite_pendant_fossil_island", "Fossil Island", "Digsite pendant", 
            TeleportType.ITEM, "Rub", "Digsite pendant", null, null, null, null));
        teleports.add(createTeleport("digsite_pendant_lithkren", "Lithkren", "Digsite pendant", 
            TeleportType.ITEM, "Rub", "Digsite pendant", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Necklace of Passage teleport definitions.
     */
    private List<TeleportDefinition> createNecklaceOfPassageTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Necklace of passage teleports
        teleports.add(createTeleport("necklace_passage_wizards_tower", "Wizards' Tower", "Necklace of passage", 
            TeleportType.ITEM, "Rub", "Necklace of passage", null, null, null, null));
        teleports.add(createTeleport("necklace_passage_jorrals_outpost", "Jorral's Outpost", "Necklace of passage", 
            TeleportType.ITEM, "Rub", "Necklace of passage", null, null, null, null));
        teleports.add(createTeleport("necklace_passage_desert_eagle", "Desert eagle station", "Necklace of passage", 
            TeleportType.ITEM, "Rub", "Necklace of passage", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Burning Amulet teleport definitions.
     */
    private List<TeleportDefinition> createBurningAmuletTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Burning amulet teleports (wilderness level text not included)
        teleports.add(createTeleport("burning_amulet_chaos_temple", "Chaos Temple", "Burning amulet", 
            TeleportType.ITEM, "Rub", "Burning amulet", null, null, null, null));
        teleports.add(createTeleport("burning_amulet_bandit_camp", "Bandit Camp", "Burning amulet", 
            TeleportType.ITEM, "Rub", "Burning amulet", null, null, null, null));
        teleports.add(createTeleport("burning_amulet_lava_maze", "Lava Maze", "Burning amulet", 
            TeleportType.ITEM, "Rub", "Burning amulet", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Ring of Returning teleport definitions.
     */
    private List<TeleportDefinition> createRingOfReturningTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Ring of returning teleports (just one: Respawn point)
        teleports.add(createTeleport("ring_returning_respawn", "Respawn", "Ring of returning", 
            TeleportType.ITEM, "Rub", "Ring of returning", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Treasure Trail Scrolls teleport definitions.
     */
    private List<TeleportDefinition> createTreasureTrailScrollsTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Treasure Trail Scrolls teleports
        teleports.add(createTeleport("scroll_nardah", "Nardah teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Nardah teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_digsite", "Digsite teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Digsite teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_feldip_hills", "Feldip hills teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Feldip hills teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_lunar_isle", "Lunar isle teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Lunar isle teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_mortton", "Mort'ton teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Mort'ton teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_pest_control", "Pest control teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Pest control teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_piscatoris", "Piscatoris teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Piscatoris teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_tai_bwo_wannai", "Tai bwo wannai teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Tai bwo wannai teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_iorwerth_camp", "Iorwerth camp teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Iorwerth camp teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_mos_leharmless", "Mos le'harmless teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Mos le'harmless teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_lumberyard", "Lumberyard teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Lumberyard teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_zulandra", "Zul-andra teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Zul-andra teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_key_master", "Key master teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Key master teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_revenant_cave", "Revenant cave teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Revenant cave teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_watson", "Watson teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Watson teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_guthixian_temple", "Guthixian temple teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Guthixian temple teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_spider_cave", "Spider cave teleport", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Spider cave teleport", null, null, null, null));
        teleports.add(createTeleport("scroll_colossal_wyrm", "Colossal wyrm teleport scroll", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Colossal wyrm teleport scroll", null, null, null, null));
        teleports.add(createTeleport("scroll_chasm", "Chasm teleport scroll", "Treasure Trail Scrolls", 
            TeleportType.ITEM, "Teleport", "Chasm teleport scroll", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Chronicle teleport definitions.
     */
    private List<TeleportDefinition> createChronicleTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Chronicle teleports (teleports to Champion's Guild)
        teleports.add(createTeleport("chronicle_champions_guild", "Champion's Guild", "Chronicle", 
            TeleportType.ITEM, "Teleport", "Chronicle", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Giantsoul amulet teleport definitions.
     */
    private List<TeleportDefinition> createGiantsoulAmuletTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Giantsoul amulet teleports (Rub option opens submenu with these destinations)
        teleports.add(createTeleport("giantsoul_bryophyta", "Bryophyta", "Giantsoul amulet", 
            TeleportType.ITEM, "Rub", "Giantsoul amulet", null, null, null, null));
        teleports.add(createTeleport("giantsoul_obor", "Obor", "Giantsoul amulet", 
            TeleportType.ITEM, "Rub", "Giantsoul amulet", null, null, null, null));
        teleports.add(createTeleport("giantsoul_branda_eldric", "Branda and Eldric", "Giantsoul amulet", 
            TeleportType.ITEM, "Rub", "Giantsoul amulet", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Xeric's talisman teleport definitions.
     */
    private List<TeleportDefinition> createXericsTalismanTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        
        // Xeric's talisman teleports (Rub option opens submenu with these destinations)
        teleports.add(createTeleport("xerics_lookout", "Xeric's Lookout", "Xeric's talisman", 
            TeleportType.ITEM, "Rub", "Xeric's talisman", null, null, null, null));
        teleports.add(createTeleport("xerics_glade", "Xeric's Glade", "Xeric's talisman", 
            TeleportType.ITEM, "Rub", "Xeric's talisman", null, null, null, null));
        teleports.add(createTeleport("xerics_inferno", "Xeric's Inferno", "Xeric's talisman", 
            TeleportType.ITEM, "Rub", "Xeric's talisman", null, null, null, null));
        teleports.add(createTeleport("xerics_heart", "Xeric's Heart", "Xeric's talisman", 
            TeleportType.ITEM, "Rub", "Xeric's talisman", null, null, null, null));
        teleports.add(createTeleport("xerics_honour", "Xeric's Honour", "Xeric's talisman", 
            TeleportType.ITEM, "Rub", "Xeric's talisman", null, null, null, null));
        
        return teleports;
    }
    
    /**
     * Create Primio teleport definitions.
     */
    private List<TeleportDefinition> createPrimioTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        // Primio teleports (Travel option on Primio NPC)
        teleports.add(createTeleport("primio_varrock_quetzal", "Varrock Quetzal", "Primio",
            TeleportType.OBJECT, "Travel", "Primio", null, null, null, null));
        return teleports;
    }
    
    /**
     * Create Ring of the elements teleport definitions.
     */
    private List<TeleportDefinition> createRingOfElementsTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        // Ring of the elements teleports (Rub option opens submenu with these destinations)
        teleports.add(createTeleport("ring_elements_air_altar", "Air Altar", "Ring of the elements",
            TeleportType.ITEM, "Rub", "Ring of the elements", null, null, null, null));
        teleports.add(createTeleport("ring_elements_water_altar", "Water Altar", "Ring of the elements",
            TeleportType.ITEM, "Rub", "Ring of the elements", null, null, null, null));
        teleports.add(createTeleport("ring_elements_earth_altar", "Earth Altar", "Ring of the elements",
            TeleportType.ITEM, "Rub", "Ring of the elements", null, null, null, null));
        teleports.add(createTeleport("ring_elements_fire_altar", "Fire Altar", "Ring of the elements",
            TeleportType.ITEM, "Rub", "Ring of the elements", null, null, null, null));
        return teleports;
    }
    
    /**
     * Create Charter Ships teleport definitions.
     */
    private List<TeleportDefinition> createCharterShipsTeleports()
    {
        List<TeleportDefinition> teleports = new ArrayList<>();
        // Charter Ships destinations
        teleports.add(createTeleport("charter_port_sarim", "Port Sarim", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_brimhaven", "Brimhaven", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_catherby", "Catherby", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_musa_point", "Musa Point", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_port_khazard", "Port Khazard", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_corsair_cove", "Corsair Cove", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_port_piscarilius", "Port Piscarilius", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_lands_end", "Land's End", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_aldarin", "Aldarin", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_sunset_coast", "Sunset Coast", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        teleports.add(createTeleport("charter_civitas_illa_fortis", "Civitas illa Fortis", "Charter Ships",
            TeleportType.OBJECT, null, null, null, null, null, null));
        return teleports;
    }
    
    /**
     * Helper to create a teleport definition.
     */
    private TeleportDefinition createTeleport(String id, String name, String category, TeleportType type,
        String menuOption, String menuTarget, Integer itemId, Integer spellId, Integer objectId, Integer npcId)
    {
        TeleportDefinition teleport = new TeleportDefinition(id, name, category, type);
        teleport.setMenuOption(menuOption);
        teleport.setMenuTarget(menuTarget);
        teleport.setItemId(itemId);
        teleport.setSpellId(spellId);
        teleport.setObjectId(objectId);
        teleport.setNpcId(npcId);
        return teleport;
    }
    
    /**
     * Get all teleport categories.
     */
    public List<String> getCategories()
    {
        return new ArrayList<>(teleportsByCategory.keySet());
    }
    
    /**
     * Get all teleports in a category.
     */
    public List<TeleportDefinition> getTeleportsByCategory(String category)
    {
        return teleportsByCategory.getOrDefault(category, new ArrayList<>());
    }
    
    /**
     * Get a teleport by ID.
     */
    public TeleportDefinition getTeleportById(String id)
    {
        return teleportsById.get(id);
    }
    
    /**
     * Get all teleport definitions.
     */
    public List<TeleportDefinition> getAllTeleports()
    {
        return new ArrayList<>(teleportsById.values());
    }
    
    /**
     * Get the group for a teleport category.
     * Groups: "Spellbooks", "Jewellery", "Miscellaneous"
     */
    public String getGroupForCategory(String category)
    {
        // Spellbooks
        if (category.equals("Standard Spellbook") || 
            category.equals("Ancient Magicks") || 
            category.equals("Lunar Spellbook") || 
            category.equals("Arceuus Spellbook"))
        {
            return "Spellbooks";
        }
        
        // Jewellery (rings, amulets, pendants, necklaces, bracelets, talismans)
        if (category.equals("Ring of dueling") ||
            category.equals("Games necklace") ||
            category.equals("Combat bracelet") ||
            category.equals("Skills necklace") ||
            category.equals("Amulet of glory") ||
            category.equals("Ring of wealth") ||
            category.equals("Slayer ring") ||
            category.equals("Digsite pendant") ||
            category.equals("Necklace of passage") ||
            category.equals("Burning amulet") ||
            category.equals("Ring of returning") ||
            category.equals("Giantsoul amulet") ||
            category.equals("Xeric's talisman") ||
            category.equals("Ring of the elements") ||
            category.equals("Pendant of ates"))
        {
            return "Jewellery";
        }
        
        // Miscellaneous (everything else)
        return "Miscellaneous";
    }
    
    /**
     * Get all categories grouped by their group type.
     * Returns a map of group name -> list of categories in that group.
     */
    public java.util.Map<String, List<String>> getCategoriesByGroup()
    {
        java.util.Map<String, List<String>> grouped = new java.util.HashMap<>();
        grouped.put("Spellbooks", new java.util.ArrayList<>());
        grouped.put("Jewellery", new java.util.ArrayList<>());
        grouped.put("Miscellaneous", new java.util.ArrayList<>());
        
        for (String category : getCategories())
        {
            String group = getGroupForCategory(category);
            grouped.get(group).add(category);
        }
        
        return grouped;
    }
}


package com.regionlockenforcer;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.PluginPanel;

/**
 * Side panel for managing regions.
 */
@Singleton
public class RegionLockEnforcerPanel extends PluginPanel
{
    private final RegionConfigComponent borderComponent;

    @Inject
    public RegionLockEnforcerPanel(RegionLockEnforcerPlugin plugin, ConfigManager configManager, TeleportRegistry teleportRegistry)
    {
        super();
        // Remove all borders from the panel
        setBorder(null);
        // Set background to match RuneLite's dark theme
        setBackground(net.runelite.client.ui.ColorScheme.DARK_GRAY_COLOR);
        // Ensure no default borders are applied
        setOpaque(true);
        this.borderComponent = new RegionConfigComponent(plugin, configManager, teleportRegistry);
        add(borderComponent);
    }

    public RegionConfigComponent getBorderComponent()
    {
        return borderComponent;
    }
}

package com.regionlockenforcer;

import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import net.runelite.api.coords.WorldPoint;

@Data
public class LockProfile
{
    private boolean enabled = true;
    private List<WorldPoint> border = new ArrayList<>();
    private List<MenuBlockRule> menuRules = new ArrayList<>();
}

package com.regionlockenforcer;

import java.awt.Color;
import java.awt.event.KeyEvent;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;

@ConfigGroup(RegionLockEnforcerConfig.GROUP)
public interface RegionLockEnforcerConfig extends Config
{
    String GROUP = "regionlockenforcer";

    @ConfigItem(
            keyName = "disableTeleportFiltering",
            name = "Disable Teleport Filtering",
            description = "Disable all teleport filtering regardless of region config",
            position = 1
    )
    default boolean disableTeleportFiltering() { return false; }

    @ConfigItem(
            keyName = "disableBorder",
            name = "Disable Border",
            description = "Disable border drawing and tile click restrictions",
            position = 2
    )
    default boolean disableBorder() { return false; }

    @ConfigItem(
            keyName = "displayBorderOnWorldMap",
            name = "Display Border on World Map",
            description = "Show the border on the world map overlay",
            position = 3
    )
    default boolean displayBorderOnWorldMap() { return true; }

    @ConfigItem(
            keyName = "toggleEditor",
            name = "Toggle Editor Hotkey",
            description = "Enter/exit edit mode; shift-click to mark tiles",
            position = 4
    )
    default Keybind toggleEditor() { return new Keybind(KeyEvent.VK_TAB, 0); }

    @Alpha
    @ConfigItem(
            keyName = "borderColor",
            name = "Border Colour",
            description = "Colour of the border lines around marked tiles",
            position = 5
    )
    default Color borderColor() { return new Color(255, 255, 0, 220); }

    @Alpha
    @ConfigItem(
            keyName = "editingColor",
            name = "Editing Colour",
            description = "Colour of marked tiles when in editing mode",
            position = 6
    )
    default Color editingColor() { return new Color(255, 0, 0, 120); }

    @Range(
            min = 1,
            max = 64
    )
    @ConfigItem(
            keyName = "worldMapGridSize",
            name = "World Map Grid Size",
            description = "Tile width/height for the world map selection grid",
            position = 7
    )
    default int worldMapGridSize() { return 4; }
}

package com.regionlockenforcer;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

@Singleton
public class RegionLockOverlay extends Overlay
{
    private final Client client;
    private final RegionLockEnforcerConfig config;
    RegionLockEnforcerPlugin plugin; // set by plugin.startUp()

    @Inject
    public RegionLockOverlay(Client client, RegionLockEnforcerConfig config)
    {
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGHEST); // deprecation warning is OK
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    public void setPlugin(RegionLockEnforcerPlugin p) { this.plugin = p; }

    @Override
    public Dimension render(Graphics2D g)
    {
        if (config.disableBorder() || plugin == null) return null;
        if (client.getGameState() != GameState.LOGGED_IN || client.getLocalPlayer() == null) return null;

        Set<WorldPoint> markedTiles = plugin.getCurrentRegion() != null 
            ? new HashSet<>(plugin.getCurrentRegion().getBoundaryTiles()) 
            : new HashSet<>();
        com.regionlockenforcer.Region currentProfile = plugin.getCurrentRegion();
        boolean hasInnerTiles = currentProfile != null && !currentProfile.getInnerTiles().isEmpty();
        
        if (hasInnerTiles)
        {
            // Draw border lines along inner edges when inner tiles are computed
            if (!markedTiles.isEmpty())
            {
                drawBorderLines(g, markedTiles);
            }
        }
        else
        {
            // Show marked tiles with editing color when inner tiles are not computed (edit mode)
            for (WorldPoint wp : markedTiles)
            {
                // Convert the world tile to local/canvas
                LocalPoint lp = LocalPoint.fromWorld(client, wp);
                if (lp == null) continue;

                // Fill the tile with editing color
                Polygon tilePoly = Perspective.getCanvasTilePoly(client, lp);
                if (tilePoly != null)
                {
                    Composite old = g.getComposite();
                    g.setComposite(AlphaComposite.SrcOver.derive(0.7f));
                    g.setColor(config.editingColor());
                    g.fill(tilePoly);
                    g.setComposite(old);
                }
            }
        }

        // Show editing mode indicator - above player's head
        if (plugin.isEditing())
        {
            net.runelite.api.Player localPlayer = client.getLocalPlayer();
            if (localPlayer != null)
            {
                LocalPoint playerLocalPoint = localPlayer.getLocalLocation();
                if (playerLocalPoint != null)
                {
                    // Get the plane from the player's world point
                    net.runelite.api.coords.WorldPoint playerWorldPoint = localPlayer.getWorldLocation();
                    int plane = playerWorldPoint != null ? playerWorldPoint.getPlane() : 0;
                    
                    // Get the canvas position of the player
                    net.runelite.api.Point playerPoint = Perspective.localToCanvas(client, playerLocalPoint, 
                        plane, localPlayer.getLogicalHeight() + 20); // Offset above head
                    
                    if (playerPoint != null)
                    {
                        // Use larger font
                        java.awt.Font oldFont = g.getFont();
                        g.setFont(oldFont);
                        
                        FontMetrics fm = g.getFontMetrics();
                        String toggleKey = plugin.getToggleEditorKeybindString();
                        String text = "Press " + toggleKey + " to Toggle Editing";
                        int textWidth = fm.stringWidth(text);
                        
                        // Center text horizontally above player's head
                        int textX = playerPoint.getX() - (textWidth / 2);
                        int textY = playerPoint.getY() - 10; // Offset above head
                        
                        // Draw text with shadow for better visibility
                        g.setColor(Color.BLACK);
                        g.drawString(text, textX + 1, textY + 1); // Shadow
                        g.setColor(Color.WHITE);
                        g.drawString(text, textX, textY); // Main text
                        
                        g.setFont(oldFont);
                    }
                }
            }
        }

        return null;
    }

    /**
     * Draw lines along the outer edges of boundary tiles.
     * An edge is "outer" if:
     * 1. It belongs to a boundary tile (in markedTiles)
     * 2. The neighbor tile across that edge is outside (not in boundaryTiles AND not in innerTiles)
     */
    private void drawBorderLines(Graphics2D g, Set<WorldPoint> markedTiles)
    {
        if (markedTiles.isEmpty()) return;

        // Get the inner tiles from the current profile
        com.regionlockenforcer.Region currentProfile = plugin.getCurrentRegion();
        if (currentProfile == null) return;
        
        Set<WorldPoint> innerTiles = currentProfile.getInnerTiles();
        if (innerTiles == null || innerTiles.isEmpty()) 
        {
            // If inner tiles are empty, we can't determine which edges are outer
            // This shouldn't happen if computeInnerTiles was called, but handle gracefully
            return;
        }

        // Get plane from first marked tile
        int plane = -1;
        for (WorldPoint wp : markedTiles)
        {
            plane = wp.getPlane();
            break;
        }
        if (plane == -1) return;

        Stroke oldStroke = g.getStroke();
        g.setStroke(new BasicStroke(2.0f));
        g.setColor(config.borderColor()); // Configurable border color

        for (WorldPoint wp : markedTiles)
        {
            LocalPoint lp = LocalPoint.fromWorld(client, wp);
            if (lp == null) continue;

            int x = wp.getX();
            int y = wp.getY();

            // Check each of the 4 directions (N, S, E, W)
            // An edge is "outer" if the neighbor across that edge is outside
            // (not in boundaryTiles AND not in innerTiles)
            
            // North edge
            WorldPoint northNeighbor = new WorldPoint(x, y + 1, plane);
            if (isOutsideTile(northNeighbor, markedTiles, innerTiles))
            {
                drawEdgeLine(g, wp, "north");
            }

            // South edge
            WorldPoint southNeighbor = new WorldPoint(x, y - 1, plane);
            if (isOutsideTile(southNeighbor, markedTiles, innerTiles))
            {
                drawEdgeLine(g, wp, "south");
            }

            // East edge
            WorldPoint eastNeighbor = new WorldPoint(x + 1, y, plane);
            if (isOutsideTile(eastNeighbor, markedTiles, innerTiles))
            {
                drawEdgeLine(g, wp, "east");
            }

            // West edge
            WorldPoint westNeighbor = new WorldPoint(x - 1, y, plane);
            if (isOutsideTile(westNeighbor, markedTiles, innerTiles))
            {
                drawEdgeLine(g, wp, "west");
            }
        }

        g.setStroke(oldStroke);
    }

    /**
     * Check if a tile is outside the region.
     * A tile is outside if it's neither a boundary tile nor an inner tile.
     */
    private boolean isOutsideTile(WorldPoint tile, Set<WorldPoint> boundaryTiles, Set<WorldPoint> innerTiles)
    {
        return !boundaryTiles.contains(tile) && !innerTiles.contains(tile);
    }

    /**
     * Draw a line along a specific edge of a tile.
     * Uses world coordinates to prevent rotation with camera.
     * Similar to the west edge drawing approach that doesn't rotate.
     */
    private void drawEdgeLine(Graphics2D g, WorldPoint wp, String direction)
    {
        LocalPoint lp = LocalPoint.fromWorld(client, wp);
        if (lp == null) return;

        final int half = 64; // half tile in local units (tile size = 128)
        int plane = wp.getPlane();
        
        // Calculate corner LocalPoints using offsets from center (same approach as west edge)
        // These offsets are in world space and won't rotate with camera
        LocalPoint swLocal = new LocalPoint((int)(lp.getX() - half), (int)(lp.getY() - half));
        LocalPoint seLocal = new LocalPoint((int)(lp.getX() + half), (int)(lp.getY() - half));
        LocalPoint neLocal = new LocalPoint((int)(lp.getX() + half), (int)(lp.getY() + half));
        LocalPoint nwLocal = new LocalPoint((int)(lp.getX() - half), (int)(lp.getY() + half));

        net.runelite.api.Point p1 = null;
        net.runelite.api.Point p2 = null;

        switch (direction.toLowerCase())
        {
            case "north":
                // North edge: from NE corner to NW corner
                p1 = Perspective.localToCanvas(client, neLocal, plane);
                p2 = Perspective.localToCanvas(client, nwLocal, plane);
                break;
            case "south":
                // South edge: from SE corner to SW corner
                p1 = Perspective.localToCanvas(client, seLocal, plane);
                p2 = Perspective.localToCanvas(client, swLocal, plane);
                break;
            case "east":
                // East edge: from NE corner to SE corner
                p1 = Perspective.localToCanvas(client, neLocal, plane);
                p2 = Perspective.localToCanvas(client, seLocal, plane);
                break;
            case "west":
                // West edge: from NW corner to SW corner
                p1 = Perspective.localToCanvas(client, nwLocal, plane);
                p2 = Perspective.localToCanvas(client, swLocal, plane);
                break;
        }

        if (p1 != null && p2 != null)
        {
            // Only draw if both points are valid (on-screen)
            // If either point is null, the edge is off-screen and we skip it
            g.drawLine(p1.getX(), p1.getY(), p2.getX(), p2.getY());
        }
        // Note: If p1 or p2 is null, the edge is off-screen and we skip drawing it
        // This is expected behavior - we only draw visible edges
    }
}

package com.regionlockenforcer;

import lombok.Data;

/**
 * Represents a single teleport option in the game.
 * This can be a menu option on an item, object, NPC dialog, or a spell.
 */
@Data
public class TeleportDefinition
{
    private String id; // Unique identifier for this teleport
    private String name; // Display name (e.g., "Edgeville", "Varrock")
    private String category; // Category this teleport belongs to (e.g., "Ring of Duelling")
    private TeleportType type; // Type of teleport (ITEM, SPELL, OBJECT, NPC_DIALOG)
    private String menuOption; // Menu option text (e.g., "Edgeville", "Teleport")
    private String menuTarget; // Menu target text (e.g., "Ring of duelling", "Varrock Teleport")
    private Integer itemId; // Item ID if this is an item teleport (null otherwise)
    private Integer spellId; // Spell ID if this is a spell teleport (null otherwise)
    private Integer objectId; // Object ID if this is an object teleport (null otherwise)
    private Integer npcId; // NPC ID if this is an NPC dialog teleport (null otherwise)
    
    public TeleportDefinition()
    {
    }
    
    public TeleportDefinition(String id, String name, String category, TeleportType type)
    {
        this.id = id;
        this.name = name;
        this.category = category;
        this.type = type;
    }
    
    /**
     * Check if this teleport matches a menu entry.
     * Based on logs: Target is like "<col=ff9040>Pendant of ates</col>" (item name with HTML tags)
     * Option is "Teleport" for all entries, so destination must be identified another way.
     * For now, we'll match based on: option matches menuOption AND target contains item name.
     * The specific destination will need to be identified via identifier or item ID.
     */
    public boolean matchesMenuEntry(String option, String target)
    {
        // First check if option matches
        if (menuOption != null && !menuOption.equalsIgnoreCase(option))
        {
            return false;
        }
        
        // Strip HTML color tags from target for comparison
        if (menuTarget != null && target != null)
        {
            String targetClean = target.replaceAll("<col=[^>]*>", "").replaceAll("</col>", "");
            String targetLower = targetClean.toLowerCase();
            String menuTargetLower = menuTarget.toLowerCase();
            
            // Target must contain the item name (after stripping HTML)
            if (!targetLower.contains(menuTargetLower))
            {
                return false;
            }
        }
        
        // If we get here, option matches and target contains item name
        // But we can't distinguish which specific destination this is from option/target alone
        // We'll need to use identifier or item ID - for now return true if basic match
        return true;
    }
    
    /**
     * Check if this teleport matches a menu entry with identifier.
     * The identifier might encode which specific destination this menu entry represents.
     * For items with multiple teleport options, the identifier might be an index or encoded value.
     */
    public boolean matchesMenuEntry(String option, String target, int identifier)
    {
        // Basic match first (option and item name in target)
        if (!matchesMenuEntry(option, target))
        {
            return false;
        }
        
        // If we have an itemId, check if identifier matches
        // Note: identifier might be the item ID for the teleport item itself, not the destination
        if (itemId != null && identifier == itemId)
        {
            return true;
        }
        
        // The problem: we can't distinguish which specific destination this is
        // All "Pendant of ates" teleports will match because they all have:
        // - Option: "Teleport"
        // - Target: "<col=ff9040>Pendant of ates</col>"
        // 
        // We need to find another way to identify the destination.
        // Possible approaches:
        // 1. Menu entry order/index (but this is fragile)
        // 2. Identifier encoding (need to decode it)
        // 3. Different menu structure than we're assuming
        
        // For now, return true if basic match passes
        // This means ALL teleports for the same item will match, which is wrong
        // We need more information to fix this properly
        return true;
    }
}


package com.regionlockenforcer;

import java.util.ArrayList;
import java.util.List;
import lombok.Data;

@Data
public class MenuBlockRule
{
    private boolean enabled = true;
    private List<Integer> opcodes = new ArrayList<>(); // MenuAction ids (optional)
    private String optionRegex;                        // e.g. (?i).*teleport.*|.*travel.*|.*charter.*|.*quetzal.*
    private String targetRegex;                        // e.g. (?i).*Varrock.*|.*Ardougne.*

    boolean matches(int type, String option, String target)
    {
        if (!opcodes.isEmpty() && !opcodes.contains(type)) return false;
        if (optionRegex != null && option != null)
        {
            try { if (!option.matches(optionRegex)) return false; } catch (Exception ignored) { return false; }
        }
        if (targetRegex != null && target != null)
        {
            try { if (!target.matches(targetRegex)) return false; } catch (Exception ignored) { return false; }
        }
        return true;
    }
}

package com.regionlockenforcer;

import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.KeyCode;
import net.runelite.api.MenuAction;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.EnumComposition;
import net.runelite.api.ItemComposition;
import net.runelite.api.ParamID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseAdapter;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
        name = "Region Lock Enforcer",
        description = "Editor marks tiles (darken + west edge) and blocks clicks on them."
)
@Singleton
public class RegionLockEnforcerPlugin extends Plugin
{
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private RegionLockEnforcerConfig config;
    @Inject private ConfigManager configManager;
    @Inject private OverlayManager overlayManager;
    @Inject private RegionLockOverlay overlay;
    @Inject private RegionLockWorldMapOverlay worldMapOverlay;
    @Inject private MouseManager mouseManager;
    @Inject private KeyManager keyManager;
    @Inject private ClientToolbar clientToolbar;
    @Inject private RegionLockEnforcerPanel panel;
    @Inject private TeleportRegistry teleportRegistry;
    @Inject private Gson gson;

    private NavigationButton navButton;

    // Region management
    @Getter private final List<Region> regions = new ArrayList<>();
    @Getter private Region currentRegion = null;

    // Current lock profile (contains menu rules, quest filters, etc.)
    @Getter private LockProfile currentProfile = new LockProfile();

    final EditorInput editor = new EditorInput();
    
    // Charter ship interface caching
    private int lastCharterShipWidgetId = -1; // Cache the widget ID once found
    private int charterShipSearchCooldown = 0; // Throttle widget searches
    
    // World map mouse listener reference for cleanup
    private java.awt.event.MouseListener worldMapMouseListener;

    @Override protected void startUp()
    {
        overlay.setPlugin(this);
        worldMapOverlay.setPlugin(this);
        overlayManager.add(overlay);
        overlayManager.add(worldMapOverlay);
        mouseManager.registerMouseListener(editor);
        // Register world map mouse listener on the client canvas
        clientThread.invokeLater(() ->
        {
            java.awt.Canvas canvas = client.getCanvas();
            if (canvas != null)
            {
                worldMapMouseListener = new java.awt.event.MouseAdapter()
                {
                    @Override
                    public void mousePressed(java.awt.event.MouseEvent e)
                    {
                        if (worldMapOverlay.handleWorldMapClick(e))
                        {
                            e.consume(); // Consume the event if handled
                        }
                    }
                };
                canvas.addMouseListener(worldMapMouseListener);
            }
        });
        keyManager.registerKeyListener(editor.toggleEditHotkey);
        loadRegions();
        
        // Create and add side panel navigation button
        BufferedImage icon = loadPanelIcon();
        if (icon == null)
        {
            icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
        }
        navButton = NavigationButton.builder()
                .tooltip("Region Lock Enforcer")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();
        clientToolbar.addNavigation(navButton);
        
        // Refresh the region, border, and teleports lists in the panel
        if (panel.getBorderComponent() != null)
        {
            panel.getBorderComponent().refreshRegionList();
            panel.getBorderComponent().refreshBorderList();
            panel.getBorderComponent().refreshTeleportsList();
        }
        
        // Redraw spellbook to re-apply filtering when plugin is enabled
        redrawSpellbook();
        
        // Region Lock Enforcer started
    }

    @Override protected void shutDown()
    {
        saveRegions();
        overlayManager.remove(overlay);
        overlayManager.remove(worldMapOverlay);
        // Unregister world map mouse listener
        if (worldMapMouseListener != null)
        {
            clientThread.invokeLater(() ->
            {
                java.awt.Canvas canvas = client.getCanvas();
                if (canvas != null)
                {
                    canvas.removeMouseListener(worldMapMouseListener);
                }
            });
        }
        mouseManager.unregisterMouseListener(editor);
        keyManager.unregisterKeyListener(editor.toggleEditHotkey);
        clientToolbar.removeNavigation(navButton);
        
        // Redraw spellbook to restore all spells when plugin is disabled
        redrawSpellbook();
        
        // Region Lock Enforcer stopped
    }

    private BufferedImage loadPanelIcon()
    {
        try
        {
            return ImageUtil.loadImageResource(RegionLockEnforcerPlugin.class, "/panel_icon.png");
        }
        catch (Exception ex)
        {
            log.warn("Failed to load panel icon resource", ex);
            return null;
        }
    }

    @Provides
    RegionLockEnforcerConfig provideConfig(ConfigManager mgr) { return mgr.getConfig(RegionLockEnforcerConfig.class); }

    /**
     * Get the teleport whitelist from the current region, or null if not available.
     * @return The whitelist Set, or null if filtering is disabled, no region is selected, or whitelist is null
     */
    private Set<String> getTeleportWhitelist()
    {
        if (config.disableTeleportFiltering() || currentRegion == null)
        {
            return null;
        }
        return currentRegion.getTeleportWhitelist();
    }

    /**
     * Remove HTML color tags from a string.
     */
    private String cleanTarget(String target)
            {
        return target != null ? target.replaceAll("<col=[^>]*>", "").replaceAll("</col>", "") : null;
    }

    /**
     * Check if a category is a jewellery box category.
     */
    private boolean isJewelleryBoxCategory(String category)
    {
        return category.equals("Ring of dueling") ||
                        category.equals("Games necklace") ||
                        category.equals("Combat bracelet") ||
                        category.equals("Skills necklace") ||
                        category.equals("Amulet of glory") ||
               category.equals("Ring of wealth");
    }

    /**
     * Find a teleport definition that matches the given option and target.
     * @return The matching teleport, or null if no match found
     */
    private TeleportDefinition findMatchingTeleport(String option, String targetClean)
    {
        if (option == null) return null;
        
        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
        {
            if (option.equalsIgnoreCase(teleport.getName()) && targetMatchesSimple(targetClean, teleport))
        {
                return teleport;
            }
        }
        return null;
    }

    /**
     * Check if a menu entry is a parent teleport entry (e.g., "Teleport" or "Rub" -> "Item name").
     */
    private boolean isParentTeleportEntry(String option, String targetClean)
    {
        if (option == null || targetClean == null) return false;
        if (!option.equalsIgnoreCase("Teleport") && !option.equalsIgnoreCase("Rub")) return false;
        
                    for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
                    {
            if (teleport.getMenuTarget() != null)
                            {
                                String targetLower = targetClean.toLowerCase();
                                String menuTargetLower = teleport.getMenuTarget().toLowerCase();
                if (targetLower.contains(menuTargetLower))
                {
                    return true;
                            }
            }
        }
        return false;
    }

    /**
     * Check if any teleport for the given target item is whitelisted.
     */
    private boolean hasAnyWhitelistedTeleport(String targetClean, Set<String> whitelist)
                            {
        if (targetClean == null) return false;
        
        String targetLower = targetClean.toLowerCase();
        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
        {
            if (teleport.getMenuTarget() != null)
            {
                String menuTargetLower = teleport.getMenuTarget().toLowerCase();
                if (targetLower.contains(menuTargetLower) && whitelist.contains(teleport.getId()))
                            {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Find a submenu destination teleport that matches the option and target.
     */
    private TeleportDefinition findSubmenuTeleport(String option, String targetClean)
    {
        if (option == null) return null;
                
        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
                {
            if (option.equalsIgnoreCase(teleport.getName()) && targetMatchesSubmenu(targetClean, teleport))
            {
                return teleport;
            }
        }
        return null;
    }

    @Subscribe
    public void onClientTick(ClientTick t)
    {
        if (client.getGameState() != GameState.LOGGED_IN) return;
                    
        // Filter jewellery box widgets if interface is open
        Set<String> whitelist = getTeleportWhitelist();
        if (whitelist != null)
        {
            net.runelite.api.widgets.Widget jewelleryBoxWidget = client.getWidget(590, 0);
            if (jewelleryBoxWidget != null && !jewelleryBoxWidget.isHidden())
            {
                // Build map of teleport names to IDs for jewellery box items
                java.util.Map<String, String> teleportNameToId = new java.util.HashMap<>();
                        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
                        {
                    if (isJewelleryBoxCategory(teleport.getCategory()))
                    {
                        teleportNameToId.put(Text.standardize(teleport.getName()), teleport.getId());
                    }
                }
                
                // Filter widgets - hide non-whitelisted teleports
                filterJewelleryBoxWidgetsRecursive(jewelleryBoxWidget, teleportNameToId, whitelist, 0);
            }
        }
        
        // Filter charter ship interface if open
        if (whitelist != null)
                                {
            filterCharterShipInterface();
        }
        
        // Filter teleport entries (both minimenu and direct menu options) on every tick as a fallback
        if (whitelist != null)
        {
            final var entries = client.getMenuEntries();
            final List<net.runelite.api.MenuEntry> keep = new ArrayList<>(entries.length);
            
            for (var me : entries)
            {
                String option = me.getOption();
                String targetClean = cleanTarget(me.getTarget());
                TeleportDefinition matchedTeleport = findMatchingTeleport(option, targetClean);
                    
                    // Keep if it's whitelisted or not a teleport destination entry
                if (matchedTeleport == null || whitelist.contains(matchedTeleport.getId()))
                    {
                        keep.add(me);
                    }
                }
                
                if (keep.size() != entries.length)
                {
                    client.setMenuEntries(keep.toArray(new net.runelite.api.MenuEntry[0]));
            }
        }
    }

    // ForwardsMenuIterator pattern from Custom Menu Swaps to handle submenus
    // This iterator automatically traverses submenus: when it finds a main menu entry with a submenu,
    // it iterates through ALL submenu entries before moving to the next main menu entry.
    private static class MenuIterator
    {
        net.runelite.api.Menu submenu = null;
        int index = -1;  // Current main menu entry index
        int submenuIndex = -1;  // Current submenu entry index (-1 if not in submenu)
        int nextIndex = 0;  // Next main menu entry to process
        int nextSubmenuIndex = -1;  // Next submenu entry to process (-1 if not in submenu)
        net.runelite.api.MenuEntry[] menuEntries;
        
        MenuIterator(net.runelite.api.MenuEntry[] menuEntries)
        {
            this.menuEntries = menuEntries;
        }
        
        boolean hasNext()
        {
            return nextIndex < menuEntries.length;
        }
        
        net.runelite.api.MenuEntry next()
        {
            // Save current position
            index = nextIndex;
            submenuIndex = nextSubmenuIndex;
            
            // Get the entry: from submenu if we're in one, otherwise from main menu
            net.runelite.api.MenuEntry entry = submenuIndex != -1 
                ? submenu.getMenuEntries()[submenuIndex] 
                : menuEntries[index];
            
            // If we're on a main menu entry, check if it has a submenu
            if (submenuIndex == -1)
            {
                submenu = entry.getSubMenu();
            }
            
            // Update next position:
            // 1. If we're in a submenu and there are more submenu entries, continue in submenu
            if (submenu != null && submenuIndex + 1 < submenu.getMenuEntries().length)
            {
                nextSubmenuIndex++;
            }
            // 2. If we just discovered a submenu (we're on main entry that has submenu), start submenu
            else if (submenu != null && submenuIndex == -1 && submenu.getMenuEntries().length > 0)
            {
                nextSubmenuIndex = 0;
            }
            // 3. Otherwise, move to next main menu entry and reset submenu
            else
            {
                nextIndex++;
                nextSubmenuIndex = -1;
            }
            
            return entry;
        }
        
        boolean inSubmenu()
        {
            return submenu != null && submenuIndex != -1;
        }
    }

    @Subscribe(priority = -1) // Run after other plugins to catch minimenu entries, same as Custom Menu Swaps
    public void onMenuOpened(MenuOpened e)
    {
        boolean shiftDown = client.isKeyPressed(KeyCode.KC_SHIFT);

        // If in editing mode and shift is held, disable all interact clicks (except Cancel)
        if (editor.editing && shiftDown)
        {
            final var entries = client.getMenuEntries();
            List<net.runelite.api.MenuEntry> filtered = new ArrayList<>();
            
            for (net.runelite.api.MenuEntry entry : entries)
            {
                String option = entry.getOption();
                // Only keep "Cancel" option, remove all other interactions
                if (option != null && option.equalsIgnoreCase("Cancel"))
                {
                    filtered.add(entry);
                }
            }
            
            if (filtered.size() != entries.length)
            {
                client.setMenuEntries(filtered.toArray(new net.runelite.api.MenuEntry[0]));
            }
            return; // Don't process teleport filtering when shift-editing
        }
        
        // Filter teleport entries using the exact same approach as Custom Menu Swaps custom hides
        // This uses ForwardsMenuIterator pattern to handle submenus correctly
        Set<String> whitelist = getTeleportWhitelist();
        if (whitelist == null)
        {
            return;
        }
        final var entries = client.getMenuEntries();
        
        // Use the same pattern as Custom Menu Swaps: separate lists for main menu and submenu
        List<net.runelite.api.MenuEntry> filtered = new ArrayList<>();
        List<net.runelite.api.MenuEntry> submenuFiltered = new ArrayList<>();
        MenuIterator menuIterator = new MenuIterator(entries);
        
        while (menuIterator.hasNext())
        {
            // If we've moved to a new submenu, set the filtered entries on the previous submenu
            if (menuIterator.submenu != null && menuIterator.nextIndex != menuIterator.index)
            {
                menuIterator.submenu.setMenuEntries(submenuFiltered.toArray(new net.runelite.api.MenuEntry[0]));
                submenuFiltered.clear();
            }
            
            net.runelite.api.MenuEntry entry = menuIterator.next();
            boolean isSubmenu = menuIterator.inSubmenu();
            var entryList = isSubmenu ? submenuFiltered : filtered;
            
            // Use Text.standardize() exactly like Custom Menu Swaps does
            String option = Text.standardize(entry.getOption());
            String target = Text.standardize(entry.getTarget());
            
            // For submenu entries, get the parent entry's target to identify the item
            String effectiveTarget = target;
            if (isSubmenu && menuIterator.index >= 0 && menuIterator.index < menuIterator.menuEntries.length)
            {
                net.runelite.api.MenuEntry parentEntry = menuIterator.menuEntries[menuIterator.index];
                effectiveTarget = Text.standardize(parentEntry.getTarget());
            }
            
            // Check if this matches any teleport destination (not whitelisted = hide it)
            boolean shouldHide = false;
            
            // Check if this is a jewellery box interface teleport (widget group 590)
            // These have the teleport name as the option and empty target
            if (option != null && !option.isEmpty() && (target == null || target.isEmpty()))
            {
                // Match option against jewellery box teleport names
                String standardizedOption = Text.standardize(option);
                for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
                {
                    if (isJewelleryBoxCategory(teleport.getCategory()) &&
                        Text.standardize(teleport.getName()).equals(standardizedOption))
                    {
                        // This is a jewellery box teleport - check if whitelisted
                        if (!whitelist.contains(teleport.getId()))
                        {
                            shouldHide = true;
                        }
                        break;
                    }
                }
            }
            
            // Check if this is a "Break" option on a teleport tablet
            if (option != null && option.equals("break") && effectiveTarget != null)
            {
                String spellTeleportId = teleportRegistry.getSpellTeleportIdForTablet(effectiveTarget);
                if (spellTeleportId != null)
                {
                    // This is a tablet break option - hide it if the corresponding spell is not whitelisted
                    if (!whitelist.contains(spellTeleportId))
                    {
                        shouldHide = true;
                    }
                }
            }
            
            if (!shouldHide && option != null)
            {
                for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
                {
                    // For OBJECT and NPC_DIALOG teleports, match on menu option and target directly
                    // (e.g., "Travel" option on "Primio" target)
                    if (teleport.getType() == TeleportType.OBJECT || teleport.getType() == TeleportType.NPC_DIALOG)
                    {
                        String teleportOption = Text.standardize(teleport.getMenuOption() != null ? teleport.getMenuOption() : "");
                        String teleportTarget = teleport.getMenuTarget() != null ? Text.standardize(teleport.getMenuTarget()) : "";
                        
                        // Match option and target directly (e.g., "Travel" -> "Primio")
                        boolean optionMatches = option.equals(teleportOption);
                        boolean targetMatches = teleportTarget.isEmpty() || (effectiveTarget != null && effectiveTarget.equals(teleportTarget));
                        
                        if (optionMatches && targetMatches)
                        {
                            // Found matching teleport - check if whitelisted
                            if (!whitelist.contains(teleport.getId()))
                            {
                                shouldHide = true;
                            }
                            break;
                        }
                        continue; // Skip the spell/item matching logic below
                    }
                    
                    // Standardize teleport definition values exactly like CustomSwap does
                    String teleportOption = Text.standardize(teleport.getName());
                    String teleportTarget = teleport.getMenuTarget() != null ? Text.standardize(teleport.getMenuTarget()) : "";
                    
                    // Exact matching like CustomSwap.matches() does (EQUALS match type)
                    // For submenu entries, use parent target; for main entries, use entry target
                    // option is guaranteed to be non-null here (checked at line 524)
                    boolean optionMatches = option.equals(teleportOption);
                    boolean targetMatches = targetMatchesWithSpecialCases(effectiveTarget, teleportTarget);
                    
                    if (optionMatches && targetMatches)
                    {
                        // This is a teleport destination entry
                        // Hide it if it's NOT whitelisted (same logic as custom hides)
                        if (!whitelist.contains(teleport.getId()))
                        {
                            shouldHide = true;
                            break;
                        }
                    }
                }
            }
            
            // Keep entry if we shouldn't hide it (same as Custom Menu Swaps filterEntries logic)
            if (!shouldHide)
            {
                entryList.add(entry);
            }
        }
        
        // Set filtered entries on the last submenu if it exists
        if (menuIterator.submenu != null && menuIterator.nextIndex != menuIterator.index)
        {
            menuIterator.submenu.setMenuEntries(submenuFiltered.toArray(new net.runelite.api.MenuEntry[0]));
        }
        
        // Set filtered main menu entries
        if (filtered.size() != entries.length)
        {
            client.setMenuEntries(filtered.toArray(new net.runelite.api.MenuEntry[0]));
        }
    }

    /**
     * Detect when charter ship interface is loaded.
     */
    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        int groupId = event.getGroupId();
        
        net.runelite.api.widgets.Widget widget = client.getWidget(groupId, 0);
        if (widget != null)
        {
            // Build map of charter ship destination names
            java.util.Map<String, String> destinationNameToId = new java.util.HashMap<>();
            for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
            {
                if (teleport.getCategory().equals("Charter Ships"))
                {
                    String destinationName = Text.standardize(teleport.getName());
                    destinationNameToId.put(destinationName, teleport.getId());
                }
            }
            
            // Check if this widget contains charter destinations
            // Widget groups 72 and 885 are both relevant (one is the map, one is the interface)
            if (checkWidgetTreeForCharterDestinations(widget, destinationNameToId, 0, 10))
            {
                lastCharterShipWidgetId = groupId; // Cache it
            }
            else if (groupId == 72 || groupId == 885)
            {
                // These are known charter ship widget groups
                lastCharterShipWidgetId = groupId; // Cache it
            }
        }
    }
    
    /**
     * Filter spellbook teleports using the same approach as RuneLite's SpellbookPlugin.
     * This intercepts the spellbookSort script callback and filters the spell array
     * to remove non-whitelisted teleport spells, preventing gaps in the spellbook.
     */
    @Subscribe
    public void onScriptCallbackEvent(ScriptCallbackEvent event)
    {
        // Handle spellbook filtering
        if ("spellbookSort".equals(event.getEventName()))
        {
            handleSpellbookFiltering();
        }
    }
    
    /**
     * Filter jewellery box and charter ship teleports using the same approach as Better Teleport Menu plugin.
     * This intercepts script callbacks which are called when teleport buttons are added to interfaces.
     */
    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        int scriptId = event.getScriptId();
        
        // Script ID 1688 = POH_JEWELLERY_BOX_ADDBUTTON (from Better Teleport Menu)
        if (scriptId == 1688)
        {
            handleJewelleryBoxFiltering();
            return;
        }
        
        // Script ID 7336 = Charter ship destination button (similar to jewellery box)
        if (scriptId == 7336)
        {
            handleCharterShipFiltering();
        }
    }
    
    /**
     * Handle charter ship filtering (same approach as jewellery box).
     */
    private void handleCharterShipFiltering()
    {
        Set<String> whitelist = getTeleportWhitelist();
        if (whitelist == null)
        {
            return;
        }
        
        // Get the text widget for this destination option (same as jewellery box)
        net.runelite.api.widgets.Widget textWidget = client.getScriptActiveWidget();
        if (textWidget == null)
        {
            return;
        }
        
        // Get the text from the widget and extract the destination name
        String widgetText = textWidget.getText();
        if (widgetText == null || widgetText.isEmpty())
        {
            return;
        }
        
        // Parse destination name: remove HTML tags and key prefix (e.g., "0: Port Sarim")
        String destinationName = cleanTarget(widgetText);
        if (destinationName != null)
        {
            destinationName = destinationName.replaceAll("^[0-9A-Za-z]\\s*:\\s*", "").trim();
        }
        
        // Check if this destination is whitelisted
        boolean isWhitelisted = false;
        if (destinationName != null && !destinationName.isEmpty())
        {
            String standardizedName = Text.standardize(destinationName);
        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
        {
                if (teleport.getCategory().equals("Charter Ships") &&
                    Text.standardize(teleport.getName()).equals(standardizedName) &&
                    whitelist.contains(teleport.getId()))
                    {
                        isWhitelisted = true;
                    break;
                }
            }
        }
        
        textWidget.setHidden(!isWhitelisted);
    }
    
    /**
     * Handle jewellery box filtering.
     */
    private void handleJewelleryBoxFiltering()
    {
        Set<String> whitelist = getTeleportWhitelist();
        if (whitelist == null)
        {
            return;
        }
        
        // Get the text widget for this teleport option (same as Better Teleport Menu)
        net.runelite.api.widgets.Widget textWidget = client.getScriptActiveWidget();
        if (textWidget == null)
        {
            return;
        }
        
        // Get the text from the widget and extract the teleport name
        String widgetText = textWidget.getText();
        if (widgetText == null || widgetText.isEmpty())
        {
            return;
        }
        
        // Parse the teleport name from the widget text
        // Format is typically: "<col=735a28>X</col>: Teleport Name" or just "Teleport Name"
        String teleportName = parseTeleportNameFromWidget(widgetText);
        
        // Match against jewellery box teleport names
        String standardizedName = Text.standardize(teleportName);
        boolean isWhitelisted = false;
        
        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
        {
            if (isJewelleryBoxCategory(teleport.getCategory()) &&
                Text.standardize(teleport.getName()).equals(standardizedName))
            {
                // Found matching teleport - check if whitelisted
                isWhitelisted = whitelist.contains(teleport.getId());
                break;
            }
        }
        
        // Hide the widget if not whitelisted (same approach as Better Teleport Menu)
        if (!isWhitelisted)
        {
            textWidget.setHidden(true);
            // Adjust the stack to account for hidden widget (same as Better Teleport Menu)
            int[] stack = client.getIntStack();
            int size = client.getIntStackSize();
            if (size > 0)
            {
                stack[size - 1] -= textWidget.getOriginalHeight();
            }
        }
    }
    
    /**
     * Filter charter ship destinations from the interface.
     * This runs on ClientTick to continuously filter the destination list and map markers.
     */
    private void filterCharterShipInterface()
    {
        Set<String> whitelist = getTeleportWhitelist();
        if (whitelist == null)
        {
            lastCharterShipWidgetId = -1; // Reset if conditions not met
            return;
        }
        
        // Build map of charter ship destination names to IDs
        java.util.Map<String, String> destinationNameToId = new java.util.HashMap<>();
        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
        {
            if (teleport.getCategory().equals("Charter Ships"))
            {
                String destinationName = Text.standardize(teleport.getName());
                destinationNameToId.put(destinationName, teleport.getId());
            }
        }
        
        // First, try using cached widget ID
        if (lastCharterShipWidgetId != -1)
        {
            net.runelite.api.widgets.Widget cachedWidget = client.getWidget(lastCharterShipWidgetId, 0);
            if (cachedWidget != null && !cachedWidget.isHidden())
            {
                // Verify it still contains charter destinations
                if (checkWidgetTreeForCharterDestinations(cachedWidget, destinationNameToId, 0, 3))
                {
                    filterCharterShipWidgetsRecursive(cachedWidget, destinationNameToId, whitelist, 0);
                    return;
                }
                else
                {
                    // Widget changed, reset cache
                    lastCharterShipWidgetId = -1;
                }
            }
            else
            {
                // Widget closed, reset cache
                lastCharterShipWidgetId = -1;
            }
        }
        
        // If not cached, search for the interface (throttled to avoid spam)
        charterShipSearchCooldown--;
        if (charterShipSearchCooldown > 0)
        {
            return; // Skip search this tick
        }
        charterShipSearchCooldown = 1; // Search every tick (0.6s)
        
        // Search for charter ship interface - look for widgets containing destination names
        for (int widgetGroup = 1; widgetGroup <= 300; widgetGroup++)
        {
            net.runelite.api.widgets.Widget testWidget = client.getWidget(widgetGroup, 0);
            if (testWidget != null && !testWidget.isHidden())
            {
                // Check if this widget tree contains charter destinations
                if (checkWidgetTreeForCharterDestinations(testWidget, destinationNameToId, 0, 5))
                {
                    log.debug("Found charter ship interface - Widget Group: {}", widgetGroup);
                    lastCharterShipWidgetId = widgetGroup; // Cache it
                    filterCharterShipWidgetsRecursive(testWidget, destinationNameToId, whitelist, 0);
                    return;
                }
            }
        }
    }
    
    /**
     * Generic widget tree traversal method.
     * @param widget The widget to start traversal from
     * @param matcher Function that returns true if widget matches (stops traversal), false to continue
     * @param depth Current depth
     * @param maxDepth Maximum depth to traverse
     * @return true if a match was found, false otherwise
     */
    private boolean traverseWidgetTree(net.runelite.api.widgets.Widget widget,
                                     java.util.function.Function<net.runelite.api.widgets.Widget, Boolean> matcher,
                                                         int depth,
                                                         int maxDepth)
    {
        if (widget == null || depth > maxDepth)
        {
            return false;
        }
        
        Boolean match = matcher.apply(widget);
        if (match != null && match)
            {
                return true;
            }
            
        // Recursively check children
        net.runelite.api.widgets.Widget[] children = widget.getChildren();
        if (children != null)
        {
            for (net.runelite.api.widgets.Widget child : children)
            {
                if (traverseWidgetTree(child, matcher, depth + 1, maxDepth))
                {
                    return true;
                }
            }
        }
        
        // Check dynamic children
        net.runelite.api.widgets.Widget[] dynamicChildren = widget.getDynamicChildren();
        if (dynamicChildren != null)
        {
            for (net.runelite.api.widgets.Widget child : dynamicChildren)
            {
                if (traverseWidgetTree(child, matcher, depth + 1, maxDepth))
                {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Generic widget tree traversal method for filtering (modifies widgets).
     * @param widget The widget to start traversal from
     * @param matcher Function that returns true if widget matches (stops traversal), false to continue
     * @param depth Current depth
     * @param maxDepth Maximum depth to traverse
     */
    private void traverseWidgetTreeForFiltering(net.runelite.api.widgets.Widget widget,
                                               java.util.function.Function<net.runelite.api.widgets.Widget, Boolean> matcher,
                                               int depth,
                                               int maxDepth)
    {
        if (widget == null || depth > maxDepth)
        {
            return;
        }
        
        Boolean match = matcher.apply(widget);
        if (match != null && match)
        {
            return; // Found a match, no need to recurse further
        }
        
        // Recursively check children
        net.runelite.api.widgets.Widget[] children = widget.getChildren();
        if (children != null)
        {
            for (net.runelite.api.widgets.Widget child : children)
            {
                traverseWidgetTreeForFiltering(child, matcher, depth + 1, maxDepth);
            }
        }
        
        // Check dynamic children
        net.runelite.api.widgets.Widget[] dynamicChildren = widget.getDynamicChildren();
        if (dynamicChildren != null)
        {
            for (net.runelite.api.widgets.Widget child : dynamicChildren)
            {
                traverseWidgetTreeForFiltering(child, matcher, depth + 1, maxDepth);
            }
        }
        
        // Check nested children
        net.runelite.api.widgets.Widget[] nestedChildren = widget.getNestedChildren();
        if (nestedChildren != null)
                {
            for (net.runelite.api.widgets.Widget child : nestedChildren)
            {
                traverseWidgetTreeForFiltering(child, matcher, depth + 1, maxDepth);
            }
        }
    }
    
    /**
     * Quick check to see if a widget tree contains charter ship destinations (without full filtering).
     */
    private boolean checkWidgetTreeForCharterDestinations(net.runelite.api.widgets.Widget widget,
                                                         java.util.Map<String, String> destinationNameToId,
                                                         int depth,
                                                         int maxDepth)
    {
        return traverseWidgetTree(widget, w -> {
            String widgetText = w.getText();
        if (widgetText != null && !widgetText.isEmpty())
        {
                // Check for "Destination" title
                if (widgetText.contains("Destination"))
                {
                    return true;
                }
                
                // Parse destination name from text (format: "0: Port Sarim", "1: Brimhaven", etc.)
                String destinationName = widgetText;
                // Remove number/letter prefix (e.g., "0: ", "1: ", "B: ", etc.)
                destinationName = destinationName.replaceAll("^[0-9A-Za-z]:\\s*", "");
                destinationName = destinationName.trim();
                
                String standardizedText = Text.standardize(destinationName);
                return destinationNameToId.keySet().stream()
                    .anyMatch(key -> standardizedText.equals(key));
                }
        return false;
        }, depth, maxDepth);
    }
    
    /**
     * Recursively filter charter ship widgets by hiding non-whitelisted destinations.
     */
    private void filterCharterShipWidgetsRecursive(net.runelite.api.widgets.Widget widget,
                                                  java.util.Map<String, String> destinationNameToId,
                                                  Set<String> whitelist,
                                                  int depth)
    {
        traverseWidgetTreeForFiltering(widget, w -> {
            String widgetText = w.getText();
        if (widgetText != null && !widgetText.isEmpty())
        {
            // Parse destination name from text (format: "0: Port Sarim", "1: Brimhaven", etc.)
            String destinationName = widgetText;
            // Remove number prefix (e.g., "0: ", "1: ", "B: ", etc.)
            destinationName = destinationName.replaceAll("^[0-9A-Za-z]:\\s*", "");
            destinationName = destinationName.trim();
            
            String standardizedName = Text.standardize(destinationName);
            String destinationId = destinationNameToId.get(standardizedName);
            
            if (destinationId != null)
            {
                // Found a charter ship destination - hide if not whitelisted
                    w.setHidden(!whitelist.contains(destinationId));
                    return true; // Found a match, stop traversal
                }
            }
            return false;
        }, depth, 20);
    }
    
    /**
     * Handle spellbook filtering via script callback.
     */
    private void handleSpellbookFiltering()
    {

        // Get spell array from script stack (same as SpellbookPlugin)
        int[] stack = client.getIntStack();
        int size = client.getIntStackSize();

        int spellbookEnumId = stack[size - 3];
        int spellArrayId = stack[size - 2];
        int numSpells = stack[size - 1];

        EnumComposition spellbookEnum = client.getEnum(spellbookEnumId);
        int[] spells = client.getArray(spellArrayId); // enum indices

        // If teleport filtering is disabled or no profile, ensure all spells are visible and don't filter
        Set<String> whitelist = getTeleportWhitelist();
        if (whitelist == null)
        {
            // Unhide all spell widgets
            for (int i = 0; i < numSpells; ++i)
            {
                ItemComposition spellObj = client.getItemDefinition(spellbookEnum.getIntValue(spells[i]));
                net.runelite.api.widgets.Widget spellWidget = client.getWidget(spellObj.getIntValue(ParamID.SPELL_BUTTON));
                if (spellWidget != null)
                {
                    spellWidget.setHidden(false);
                }
            }
            // Don't modify the spell array - let it pass through unchanged
            return;
        }

        // Build a map of spell names to teleport IDs for faster lookup
        java.util.Map<String, String> spellNameToTeleportId = new java.util.HashMap<>();
        for (TeleportDefinition teleport : teleportRegistry.getAllTeleports())
        {
            if (teleport.getType() == TeleportType.SPELL && teleport.getMenuTarget() != null)
            {
                spellNameToTeleportId.put(teleport.getMenuTarget().toLowerCase(), teleport.getId());
            }
        }
        int[] newSpells = new int[numSpells];
        int numNewSpells = 0;

        for (int i = 0; i < numSpells; ++i)
        {
            ItemComposition spellObj = client.getItemDefinition(spellbookEnum.getIntValue(spells[i]));
            String spellName = spellObj.getStringValue(ParamID.SPELL_NAME);
            
            // Get the widget for this spell
            net.runelite.api.widgets.Widget spellWidget = client.getWidget(spellObj.getIntValue(ParamID.SPELL_BUTTON));
            
            if (spellName == null || spellName.isEmpty())
            {
                // Keep non-teleport spells and ensure widget is visible
                if (spellWidget != null)
                {
                    spellWidget.setHidden(false);
                }
                newSpells[numNewSpells++] = spells[i];
                continue;
            }

            // Check if this spell matches any teleport definition (fast lookup)
            String spellLower = spellName.toLowerCase();
            String teleportId = spellNameToTeleportId.get(spellLower);
            boolean isTeleportSpell = teleportId != null;
            boolean isWhitelisted = isTeleportSpell && whitelist.contains(teleportId);

            // If it's a teleport spell, hide/show the widget based on whitelist
            if (isTeleportSpell && spellWidget != null)
            {
                spellWidget.setHidden(!isWhitelisted);
            }
            else if (spellWidget != null)
            {
                // Not a teleport spell, ensure it's visible
                spellWidget.setHidden(false);
            }

            // Only add spell to new array if it's not a teleport spell, or if it's whitelisted
            if (!isTeleportSpell || isWhitelisted)
            {
                newSpells[numNewSpells++] = spells[i];
            }
        }

        // Copy filtered spells back to original array (removes gaps)
        System.arraycopy(newSpells, 0, spells, 0, numNewSpells);
        stack[size - 1] = numNewSpells;
    }

    /**
     * Recursively filter jewellery box widgets by hiding those that match non-whitelisted teleports.
     */
    private void filterJewelleryBoxWidgetsRecursive(net.runelite.api.widgets.Widget widget,
                                                    java.util.Map<String, String> teleportNameToId,
                                                    Set<String> whitelist,
                                                    int depth)
    {
        traverseWidgetTreeForFiltering(widget, w -> {
            // Check widget text
            String widgetText = w.getText();
        if (widgetText != null && !widgetText.isEmpty())
        {
            String standardizedText = Text.standardize(widgetText);
            String teleportId = teleportNameToId.get(standardizedText);
            if (teleportId != null)
            {
                    w.setHidden(!whitelist.contains(teleportId));
                    return true; // Found a match, stop traversal
            }
        }
        
            // Check widget name
            String widgetName = w.getName();
        if (widgetName != null && !widgetName.isEmpty())
        {
            String standardizedName = Text.standardize(widgetName);
            String teleportId = teleportNameToId.get(standardizedName);
            if (teleportId != null)
            {
                    w.setHidden(!whitelist.contains(teleportId));
                    return true; // Found a match, stop traversal
            }
        }
        
            return false;
        }, depth, 20);
    }

    /**
     * Redraw the spellbook to apply filtering changes.
     * This triggers the spellbook to redraw, which will call the spellbookSort script callback.
     * Uses the same approach as RuneLite's SpellbookPlugin.
     * This method must be called on the client thread, so it uses invokeLater internally.
     */
    public void redrawSpellbook()
    {
        // Invoke on client thread to avoid "must be called on client thread" errors
        clientThread.invokeLater(() ->
        {
            // Only redraw if client is logged in and ready
            if (client.getGameState() != GameState.LOGGED_IN)
            {
                return;
            }
            
            // Use the spellbook UNIVERSE widget (same as SpellbookPlugin)
            // Widget ID 218 is the spellbook interface, widget 0 is the UNIVERSE container
            net.runelite.api.widgets.Widget spellbookWidget = client.getWidget(218, 0);
            if (spellbookWidget != null && spellbookWidget.getOnInvTransmitListener() != null)
            {
                client.createScriptEvent(spellbookWidget.getOnInvTransmitListener())
                    .setSource(spellbookWidget)
                    .run();
            }
        });
    }


    // Consume the action when clicking a marked tile (and record marks in editor mode)
    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked e)
    {
        if (config.disableBorder()) return;

        final int typeId = e.getMenuAction().getId();
        Tile hovered = client.getSelectedSceneTile();
        WorldPoint wp = hovered != null ? hovered.getWorldLocation() : null;
        
        // TODO: Handle world map chunk clicks when in editing mode
        // Note: RuneLite's MouseAdapter has a different signature than standard Java MouseAdapter,
        // so direct mouse event handling isn't straightforward. World map clicks may need to be
        // detected through widget script events or a custom overlay approach.
        // The chunk methods (addChunk, removeChunk, isChunkFullyContained) are implemented
        // and ready to use once world map click detection is working.

        boolean shiftDown = client.isKeyPressed(KeyCode.KC_SHIFT);

        // Editor: shift-click toggles tile marking (mark if unmarked, unmark if marked)
        if (editor.editing && shiftDown && wp != null && currentRegion != null
                && (typeId == MenuAction.WALK.getId()
                || typeId == MenuAction.GAME_OBJECT_FIRST_OPTION.getId()
                || typeId == MenuAction.GROUND_ITEM_FIRST_OPTION.getId()
                || typeId == MenuAction.NPC_FIRST_OPTION.getId()))
        {
            e.consume();
            // Toggle: if marked, unmark it; if unmarked, mark it
            if (currentRegion.getBoundaryTiles().contains(wp))
            {
                currentRegion.removeTile(wp);
            }
            else
            {
                currentRegion.addTile(wp);
            }
                // Clear inner tiles when boundary changes
            currentRegion.getInnerTiles().clear();
            saveRegions(); // Save immediately on change
            notifyRegionsChanged();
            return;
        }


        // Check menu block rules first
        if (currentProfile != null && currentProfile.getMenuRules() != null)
        {
            String menuOption = e.getMenuOption();
            String menuTarget = e.getMenuTarget();
            for (MenuBlockRule rule : currentProfile.getMenuRules())
            {
                if (rule.isEnabled() && rule.matches(typeId, menuOption, menuTarget))
                {
                        // Blocked menu action
                    e.consume();
                    return;
                }
            }
        }

        // Block ALL clicks outside the bordered region (only when inner tiles are computed)
        // Only block within normal surface map bounds (excludes underground, instances, upper/lower floors)
        // Only block game world actions (WALK, GAME_OBJECT, GROUND_ITEM, NPC, etc.), not UI actions, player interactions, or "Walk here" on players
        if (wp != null && currentRegion != null && !currentRegion.getInnerTiles().isEmpty())
        {
            // Only apply click blocking within normal surface map bounds
            if (isWithinSurfaceBounds(wp))
            {
                // Allow "Walk here" if it's on a player, block it otherwise
                if (typeId == MenuAction.WALK.getId())
                {
                    // Check if there are player actions in the menu (indicates we clicked on a player)
                    final var entries = client.getMenuEntries();
                    boolean isOnPlayer = false;
                    for (var me : entries)
                    {
                        if (isPlayerAction(me.getType()))
                        {
                            isOnPlayer = true;
                            break;
                        }
                    }
                    // If not on a player, block "Walk here"
                    if (!isOnPlayer)
                {
                        Set<WorldPoint> clickableTiles = currentRegion.getAllClickableTiles();
                    if (!clickableTiles.contains(wp))
                    {
            e.consume();
                    }
                }
            }
                // Block other game world actions
                else if (isGameWorldAction(typeId))
                {
                    Set<WorldPoint> clickableTiles = currentRegion.getAllClickableTiles();
                    if (!clickableTiles.contains(wp))
                    {
                        e.consume();
                    }
                }
            }
        }
        // If wp is null or not a game world action, this is a UI click, player interaction, etc. - don't block it
    }

    // Also hide walk/interact entries in the menu for marked tiles (clean UX)
    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded e)
    {
        if (config.disableBorder()) return;

        Tile hovered = client.getSelectedSceneTile();
        WorldPoint hoveredWp = hovered != null ? hovered.getWorldLocation() : null;
        
        // Filter teleports based on whitelist (if region has teleport whitelist configured)
        // We need to filter on EVERY MenuEntryAdded event to catch submenu entries as they're added
        Set<String> whitelist = getTeleportWhitelist();
        if (whitelist != null)
        {
            final var entries = client.getMenuEntries();
            final List<net.runelite.api.MenuEntry> keep = new ArrayList<>(entries.length);
            
            for (var me : entries)
            {
                String option = me.getOption();
                String targetClean = cleanTarget(me.getTarget());
                
                // Check if this is a submenu destination entry first
                TeleportDefinition matchedTeleport = findSubmenuTeleport(option, targetClean);
                
                if (matchedTeleport != null)
                        {
                    // Submenu destination entry - keep if whitelisted
                    if (whitelist.contains(matchedTeleport.getId()))
                    {
                        keep.add(me);
                    }
                }
                else if (isParentTeleportEntry(option, targetClean))
                {
                    // Parent teleport entry - keep if any teleport for this item is whitelisted
                    if (hasAnyWhitelistedTeleport(targetClean, whitelist))
                    {
                        keep.add(me);
                    }
                }
                else
                {
                    // Not a teleport entry, keep it
                    keep.add(me);
                }
            }
            
            if (keep.size() != entries.length)
            {
                client.setMenuEntries(keep.toArray(new net.runelite.api.MenuEntry[0]));
            }
        }

        // Check menu block rules to filter menu entries
        if (currentProfile != null && currentProfile.getMenuRules() != null)
        {
            final var entries = client.getMenuEntries();
            final List<net.runelite.api.MenuEntry> keep = new ArrayList<>(entries.length);
            
            for (var me : entries)
            {
                boolean shouldBlock = false;
                
                // Check against menu block rules
                for (MenuBlockRule rule : currentProfile.getMenuRules())
                {
                    if (rule.isEnabled() && rule.matches(me.getType().getId(), me.getOption(), me.getTarget()))
                    {
                        shouldBlock = true;
                        break;
                    }
                }
                
                if (!shouldBlock)
                {
                keep.add(me);
                }
            }
            
            if (keep.size() != entries.length)
            {
                client.setMenuEntries(keep.toArray(new net.runelite.api.MenuEntry[0]));
            }
        }

        // Remove ALL menu entries for tiles outside the border (only when inner tiles are computed)
        // Only filter within normal surface map bounds (excludes underground, instances, upper/lower floors)
        // Whitelist approach: filter everything, then explicitly allow only UI actions, player interactions, and "Walk here" on players
        if (hoveredWp != null && !editor.editing && currentRegion != null && !currentRegion.getInnerTiles().isEmpty())
        {
            // Only apply menu filtering within normal surface map bounds
            if (isWithinSurfaceBounds(hoveredWp))
            {
                Set<WorldPoint> clickableTiles = currentRegion.getAllClickableTiles();
                if (!clickableTiles.contains(hoveredWp))
                {
                    // Check if we're hovering over a player (do this once before filtering)
                    boolean hoveringOverPlayer = isHoveringOverPlayer(hoveredWp);
                    
                    // Filter ALL menu entries, then explicitly allow only UI actions, player interactions, and "Walk here" on players
                    final var entries = client.getMenuEntries();
                    final List<net.runelite.api.MenuEntry> keep = new ArrayList<>(entries.length);
                    
                    for (var me : entries)
                    {
                        MenuAction actionType = me.getType();
                        // Allow UI actions and player interactions
                        if (isUIAction(actionType) || isPlayerAction(actionType))
                        {
                            keep.add(me);
                        }
                        // Allow "Walk here" only if it's targeting a player
                        else if (actionType == MenuAction.WALK && hoveringOverPlayer)
                        {
                            keep.add(me);
                        }
                    }
                    
                    // Update menu entries (even if empty, to remove all game world options)
                    client.setMenuEntries(keep.toArray(new net.runelite.api.MenuEntry[0]));
                }
            }
        }
        // If hoveredWp is null, this is a UI hover (inventory, chat, etc.) - don't filter menu entries
    }

    // Minimal editor: hotkey toggles edit mode; left-click toggles tile marking
    class EditorInput extends MouseAdapter
    {
        @Getter boolean editing = false;

        final HotkeyListener toggleEditHotkey = new HotkeyListener(() -> config.toggleEditor())
        {
            @Override public void hotkeyPressed() 
            { 
                // Only allow toggle if current profile is in edit mode (has no inner tiles)
                // If profile is finished (has inner tiles), don't allow toggle
                if (currentRegion != null && currentRegion.getInnerTiles().isEmpty())
                {
                    editing = !editing;
                }
                // If no region exists, create one and enable editing
                else if (currentRegion == null)
                {
                    createRegion(null); // Will auto-generate name
                    editing = true;
                }
            }
        };

    }

    /**
     * Check if a tile has at least one outer edge (neighbor not in hull).
     */
    private boolean hasOuterEdge(WorldPoint tile, Set<WorldPoint> hullTiles, int plane)
    {
        int x = tile.getX();
        int y = tile.getY();
        
        WorldPoint northNeighbor = new WorldPoint(x, y + 1, plane);
        WorldPoint southNeighbor = new WorldPoint(x, y - 1, plane);
        WorldPoint eastNeighbor = new WorldPoint(x + 1, y, plane);
        WorldPoint westNeighbor = new WorldPoint(x - 1, y, plane);
        
        return !hullTiles.contains(northNeighbor) || 
               !hullTiles.contains(southNeighbor) || 
               !hullTiles.contains(eastNeighbor) || 
               !hullTiles.contains(westNeighbor);
    }

    /**
     * Check if a MenuAction is a UI-related action (widget, inventory, etc.).
     */
    private boolean isUIAction(MenuAction actionType)
    {
        return actionType == MenuAction.CC_OP ||
               actionType == MenuAction.WIDGET_TARGET ||
               actionType == MenuAction.WIDGET_TYPE_1 ||
               actionType == MenuAction.WIDGET_TYPE_4 ||
               actionType == MenuAction.WIDGET_TYPE_5 ||
               actionType == MenuAction.CANCEL ||
               actionType.name().contains("WIDGET") ||
               actionType.name().contains("ITEM_USE");
    }

    /**
     * Check if a MenuAction is a player interaction (follow, trade, attack, etc.).
     */
    private boolean isPlayerAction(MenuAction actionType)
    {
        return actionType == MenuAction.PLAYER_FIRST_OPTION ||
               actionType == MenuAction.PLAYER_SECOND_OPTION ||
               actionType == MenuAction.PLAYER_THIRD_OPTION ||
               actionType == MenuAction.PLAYER_FOURTH_OPTION ||
               actionType == MenuAction.PLAYER_FIFTH_OPTION ||
               actionType == MenuAction.PLAYER_SIXTH_OPTION ||
               actionType == MenuAction.PLAYER_SEVENTH_OPTION ||
               actionType == MenuAction.PLAYER_EIGHTH_OPTION ||
               actionType.name().contains("PLAYER");
    }

    /**
     * Check if there's a player near the hovered tile location (within 3x3 area).
     * When you right-click a player, "Walk here" appears in the menu, and we want to allow it.
     * Returns true if hovering within 1 tile of a player (3x3 area).
     */
    private boolean isHoveringOverPlayer(WorldPoint hoveredWp)
    {
        if (hoveredWp == null) return false;
        
        // Check the scene for players within 1 tile (3x3 area)
        try
        {
            if (client.getPlayers() != null)
            {
                for (net.runelite.api.Player player : client.getPlayers())
                {
                    if (player != null && player.getWorldLocation() != null)
    {
                        WorldPoint playerWp = player.getWorldLocation();
                        // Check if player is within 1 tile (3x3 area)
                        if (playerWp.getPlane() == hoveredWp.getPlane() &&
                            Math.abs(playerWp.getX() - hoveredWp.getX()) <= 1 &&
                            Math.abs(playerWp.getY() - hoveredWp.getY()) <= 1)
                        {
                            return true;
                        }
                    }
                }
            }
        }
        catch (Exception e)
        {
            // getPlayers() might throw exceptions in some cases, ignore them
        }
        
        return false;
    }

    /**
     * Check if a menu action type is a game world action (walk, interact with objects/NPCs/items).
     * Note: Player interactions (PLAYER_*, FOLLOW, TRADE, etc.) are explicitly excluded and will not be blocked.
     */
    private boolean isGameWorldAction(int typeId)
    {
        return typeId == MenuAction.WALK.getId() ||
               typeId == MenuAction.GAME_OBJECT_FIRST_OPTION.getId() ||
               typeId == MenuAction.GAME_OBJECT_SECOND_OPTION.getId() ||
               typeId == MenuAction.GAME_OBJECT_THIRD_OPTION.getId() ||
               typeId == MenuAction.GAME_OBJECT_FOURTH_OPTION.getId() ||
               typeId == MenuAction.GAME_OBJECT_FIFTH_OPTION.getId() ||
               typeId == MenuAction.GROUND_ITEM_FIRST_OPTION.getId() ||
               typeId == MenuAction.GROUND_ITEM_SECOND_OPTION.getId() ||
               typeId == MenuAction.GROUND_ITEM_THIRD_OPTION.getId() ||
               typeId == MenuAction.GROUND_ITEM_FOURTH_OPTION.getId() ||
               typeId == MenuAction.GROUND_ITEM_FIFTH_OPTION.getId() ||
               typeId == MenuAction.NPC_FIRST_OPTION.getId() ||
               typeId == MenuAction.NPC_SECOND_OPTION.getId() ||
               typeId == MenuAction.NPC_THIRD_OPTION.getId() ||
               typeId == MenuAction.NPC_FOURTH_OPTION.getId() ||
               typeId == MenuAction.NPC_FIFTH_OPTION.getId();
        // Player actions (PLAYER_*, FOLLOW, TRADE, etc.) are NOT included here, so they won't be blocked
    }

    /**
     * Parse teleport name from widget text by removing HTML tags and key prefixes.
     */
    private String parseTeleportNameFromWidget(String widgetText)
    {
        String teleportName = widgetText;
            
        // Remove HTML color tags and key prefix (e.g., "<col=735a28>X</col>: " or "<col=735a28>: ")
        teleportName = teleportName.replaceAll("<col=[^>]*>", "");
        teleportName = teleportName.replaceAll("</col>", "");
        teleportName = teleportName.replaceAll("^[A-Za-z0-9]:\\s*", ""); // Remove "X: " prefix
        teleportName = teleportName.replaceAll("^:\\s*", ""); // Remove ": " prefix if no key
        teleportName = teleportName.trim();
        
        return teleportName;
    }

    /**
     * Check if target matches teleport menu target (simple contains check).
     * Returns true if target is empty (for direct menu options).
     */
    private boolean targetMatchesSimple(String targetClean, TeleportDefinition teleport)
    {
        if (targetClean != null && teleport.getMenuTarget() != null)
        {
            String targetLower = targetClean.toLowerCase();
            String menuTargetLower = teleport.getMenuTarget().toLowerCase();
            return targetLower.contains(menuTargetLower);
        }
        else if (targetClean == null || targetClean.isEmpty())
        {
            // Target is empty - still match if option matches (for direct menu options)
            return true;
        }
        return false;
    }

    /**
     * Check if target matches teleport with special cases for amulet of glory and slayer ring.
     */
    private boolean targetMatchesWithSpecialCases(String effectiveTarget, String teleportTarget)
    {
        boolean targetMatches = teleportTarget.isEmpty() || (effectiveTarget != null && effectiveTarget.equals(teleportTarget));
            
        // Special case: Amulet of glory teleports also match "Amulet of eternal glory"
        if (!targetMatches && teleportTarget.equals("amulet of glory") && effectiveTarget != null)
        {
            targetMatches = effectiveTarget.equals("amulet of eternal glory");
        }
        if (!targetMatches && teleportTarget.equals("amulet of eternal glory") && effectiveTarget != null)
        {
            targetMatches = effectiveTarget.equals("amulet of glory");
        }
        
        // Special case: Slayer ring teleports also match "Slayer ring (eternal)"
        if (!targetMatches && teleportTarget.equals("slayer ring") && effectiveTarget != null)
        {
            targetMatches = effectiveTarget.equals("slayer ring (eternal)");
        }
        if (!targetMatches && teleportTarget.equals("slayer ring (eternal)") && effectiveTarget != null)
        {
            targetMatches = effectiveTarget.equals("slayer ring");
        }
        
        return targetMatches;
    }

    /**
     * Check if target matches teleport for submenu entries (target contains item name OR matches destination name).
     */
    private boolean targetMatchesSubmenu(String targetClean, TeleportDefinition teleport)
        {
        if (targetClean == null || targetClean.isEmpty())
        {
            // Target is empty - this could be a submenu entry
            return true;
        }
        else if (teleport.getMenuTarget() != null)
        {
            String targetLower = targetClean.toLowerCase();
            String menuTargetLower = teleport.getMenuTarget().toLowerCase();
            String nameLower = teleport.getName().toLowerCase();
            
            // Target contains item name OR target matches destination name
            return targetLower.contains(menuTargetLower) || targetLower.equals(nameLower);
        }
        return false;
    }

    /**
     * Import a region from a file (called from sidebar).
     */
    public void importRegionFromFile(String filePath)
    {
        Region imported = importRegion(filePath);
        
        if (imported != null)
        {
            // Check if profile with same name exists
            boolean exists = regions.stream()
                    .anyMatch(p -> p.getName().equals(imported.getName()));
            
            if (exists)
            {
                // Append number to name
                int counter = 1;
                String baseName = imported.getName();
                String newName;
                while (true)
                {
                    newName = baseName + " (" + counter + ")";
                    final String checkName = newName;
                    if (!regions.stream().anyMatch(p -> p.getName().equals(checkName)))
                    {
                        break;
                    }
                    counter++;
                }
                imported.setName(newName);
            }
            
            regions.add(imported);
            currentRegion = imported;
            saveRegions();
            notifyRegionsChanged();
            
            javax.swing.JOptionPane.showMessageDialog(
                null,
                "Region imported successfully: " + imported.getName(),
                "Import Successful",
                javax.swing.JOptionPane.INFORMATION_MESSAGE
            );
        }
        else
        {
            javax.swing.JOptionPane.showMessageDialog(
                null,
                "Failed to import region. Please check the file format.",
                "Import Error",
                javax.swing.JOptionPane.ERROR_MESSAGE
            );
        }
    }


    /**
     * Load regions from config.
     */
    private void loadRegions()
    {
        String profilesStr = configManager.getConfiguration(RegionLockEnforcerConfig.GROUP, "regions");
        regions.clear();
        if (profilesStr != null && !profilesStr.isEmpty())
        {
            List<Region> loaded = RegionSerializer.deserializeRegions(profilesStr);
            // Cache is already pre-computed in deserializeRegion
            regions.addAll(loaded);
        }
        
        // Load selected region
        String selectedName = configManager.getConfiguration(RegionLockEnforcerConfig.GROUP, "selectedRegion");
        if (selectedName != null && !selectedName.isEmpty())
        {
            currentRegion = regions.stream()
                    .filter(p -> p.getName().equals(selectedName))
                    .findFirst()
                    .orElse(null);
        }
        
        // If no region selected but we have regions, select the first one
        if (currentRegion == null && !regions.isEmpty())
        {
            currentRegion = regions.get(0);
        }
    }

    /**
     * Save regions to config.
     */
    public void saveRegions()
    {
        String profilesStr = RegionSerializer.serializeRegions(regions);
        configManager.setConfiguration(RegionLockEnforcerConfig.GROUP, "regions", profilesStr);
        
        if (currentRegion != null)
        {
            configManager.setConfiguration(RegionLockEnforcerConfig.GROUP, "selectedRegion", currentRegion.getName());
        }
    }

    /**
     * Create a new region with the given name.
     */
    public Region createRegion(String name)
    {
        if (name == null || name.trim().isEmpty())
        {
            name = "Region " + (regions.size() + 1);
        }
        Region profile = new Region(name.trim());
        regions.add(profile);
        currentRegion = profile;
        saveRegions();
        notifyRegionsChanged();
        return profile;
    }

    /**
     * Notify that regions have changed (for UI refresh).
     */
    public void notifyRegionsChanged()
    {
        if (panel != null && panel.getBorderComponent() != null)
        {
            panel.getBorderComponent().refreshRegionList();
            panel.getBorderComponent().refreshBorderList();
            panel.getBorderComponent().refreshTeleportsList();
        }
    }

    /**
     * Check if the editor is currently in editing mode.
     */
    public boolean isEditing()
    {
        return editor.editing;
    }

    /**
     * Set the editing mode state.
     */
    public void setEditing(boolean editing)
    {
        editor.editing = editing;
    }
    
    /**
     * Get the toggle editor keybind as a display string.
     * Returns "Tab" if not set (default).
     */
    public String getToggleEditorKeybindString()
    {
        net.runelite.client.config.Keybind keybind = config.toggleEditor();
        if (keybind == null)
        {
            return "Tab";
        }
        
        int keyCode = keybind.getKeyCode();
        int notSetKeyCode = net.runelite.client.config.Keybind.NOT_SET.getKeyCode();
        
        if (keyCode == notSetKeyCode)
        {
            return "Tab";
        }
        
        // Build modifier string
        StringBuilder result = new StringBuilder();
        int modifiers = keybind.getModifiers();
        
        if ((modifiers & java.awt.event.InputEvent.CTRL_DOWN_MASK) != 0)
        {
            result.append("Ctrl+");
        }
        if ((modifiers & java.awt.event.InputEvent.ALT_DOWN_MASK) != 0)
        {
            result.append("Alt+");
        }
        if ((modifiers & java.awt.event.InputEvent.SHIFT_DOWN_MASK) != 0)
        {
            result.append("Shift+");
        }
        
        // Convert key code to readable text string
        result.append(keyCodeToText(keyCode));
        
        return result.toString();
    }
    
    /**
     * Convert a key code to a readable text string.
     */
    private String keyCodeToText(int keyCode)
    {
        // Function keys
        if (keyCode >= java.awt.event.KeyEvent.VK_F1 && keyCode <= java.awt.event.KeyEvent.VK_F12)
        {
            int fNumber = keyCode - java.awt.event.KeyEvent.VK_F1 + 1;
            return "F" + fNumber;
        }
        
        // Special keys
        switch (keyCode)
        {
            case java.awt.event.KeyEvent.VK_TAB:
                return "Tab";
            case java.awt.event.KeyEvent.VK_ENTER:
                return "Enter";
            case java.awt.event.KeyEvent.VK_SPACE:
                return "Space";
            case java.awt.event.KeyEvent.VK_SHIFT:
                return "Shift";
            case java.awt.event.KeyEvent.VK_CONTROL:
                return "Ctrl";
            case java.awt.event.KeyEvent.VK_ALT:
                return "Alt";
            case java.awt.event.KeyEvent.VK_ESCAPE:
                return "Esc";
            case java.awt.event.KeyEvent.VK_BACK_SPACE:
                return "Backspace";
            case java.awt.event.KeyEvent.VK_DELETE:
                return "Delete";
            case java.awt.event.KeyEvent.VK_INSERT:
                return "Insert";
            case java.awt.event.KeyEvent.VK_HOME:
                return "Home";
            case java.awt.event.KeyEvent.VK_END:
                return "End";
            case java.awt.event.KeyEvent.VK_PAGE_UP:
                return "Page Up";
            case java.awt.event.KeyEvent.VK_PAGE_DOWN:
                return "Page Down";
            case java.awt.event.KeyEvent.VK_UP:
                return "Up";
            case java.awt.event.KeyEvent.VK_DOWN:
                return "Down";
            case java.awt.event.KeyEvent.VK_LEFT:
                return "Left";
            case java.awt.event.KeyEvent.VK_RIGHT:
                return "Right";
            default:
                // For regular keys, try to get the character
                if (keyCode >= java.awt.event.KeyEvent.VK_A && keyCode <= java.awt.event.KeyEvent.VK_Z)
                {
                    return String.valueOf((char)('A' + (keyCode - java.awt.event.KeyEvent.VK_A)));
                }
                if (keyCode >= java.awt.event.KeyEvent.VK_0 && keyCode <= java.awt.event.KeyEvent.VK_9)
                {
                    return String.valueOf((char)('0' + (keyCode - java.awt.event.KeyEvent.VK_0)));
                }
                // Fallback: use KeyEvent key name
                // getKeyText() never returns null
                return java.awt.event.KeyEvent.getKeyText(keyCode);
        }
    }

    /**
     * Re-enable editing mode for a border profile by clearing inner tiles.
     * This returns the border to the state before "Finish" was clicked.
     */
    public void enableEditingMode(Region profile)
    {
        if (profile == null) return;
        
        // Clear inner tiles to return to darkened tile mode
        profile.setInnerTiles(new HashSet<>());
        
        // Enable editing mode AND toggle editing on
        editor.editing = true;
        
        // Select this profile if not already selected
        if (currentRegion != profile)
        {
            currentRegion = profile;
        }
        
        saveRegions();
        notifyRegionsChanged();
    }

    /**
     * Select a region by name.
     */
    public void selectRegion(String name)
    {
        if (name == null) return;
        currentRegion = regions.stream()
                .filter(p -> p.getName().equals(name))
                .findFirst()
                .orElse(null);
        if (currentRegion != null)
        {
            saveRegions();
            notifyRegionsChanged();
        }
    }

    /**
     * Delete a region by name.
     */
    public void deleteRegion(String name)
    {
        if (name == null) return;
        boolean removed = regions.removeIf(p -> p.getName().equals(name));
        if (removed)
        {
            // If we deleted the current profile, select another one or null
            if (currentRegion != null && currentRegion.getName().equals(name))
            {
                currentRegion = regions.isEmpty() ? null : regions.get(0);
            }
            saveRegions();
            notifyRegionsChanged();
        }
    }

    /**
     * Check if a WorldPoint is within normal surface map bounds.
     * This excludes underground areas (far north), instances, and upper/lower floors.
     * 
     * Map dimensions: 47 chunks  64 = 3008 tiles wide, 33 chunks  64 = 2112 tiles tall
     * Left edge X = 960, Bottom edge Y = 1984
     * 
     * @param wp The WorldPoint to check
     * @return true if the point is within normal surface map bounds
     */
    private boolean isWithinSurfaceBounds(WorldPoint wp)
    {
        if (wp == null)
        {
            return false;
        }

        // Only block clicks on the main surface plane (plane 0).
        // Upstairs floors (plane > 0) and underground/instance floors (plane != 0) are exempt.
        if (wp.getPlane() != 0)
        {
            return false;
        }

        // Instanced regions (raids, dungeons, POH, etc.) should never be blocked.
        if (client.isInInstancedRegion())
        {
            return false;
        }
        
        // Normal OSRS surface map bounds
        // Map is 3008 tiles wide (47 chunks  64) and 2112 tiles tall (33 chunks  64)
        // Left edge X = 960, Bottom edge Y = 1984
        // Underground areas are placed far north (outside these bounds)
        // Instances and other special areas are outside these bounds
        final int MIN_X = 960;
        final int MAX_X = 960 + 3008 - 1; // 3967
        final int MIN_Y = 1984;
        final int MAX_Y = 1984 + 2112 - 1; // 4095
        
        int x = wp.getX();
        int y = wp.getY();
        
        return x >= MIN_X && x <= MAX_X && y >= MIN_Y && y <= MAX_Y;
    }


    /**
     * Compute all inner tiles (tiles inside the boundary) using an exterior flood fill.
     * This enforces that the user draws a fully bounded shape.
     *
     * @param profile The region to compute inner tiles for
     * @return true if computation was successful, false if the border is not fully enclosed
     */
    public boolean computeInnerTiles(Region profile)
    {
        if (profile == null)
        {
            return false;
        }

        Set<WorldPoint> boundaryTiles = profile.getBoundaryTiles();
        if (boundaryTiles.isEmpty())
        {
            profile.setInnerTiles(new HashSet<>());
            return false;
        }

        int plane = boundaryTiles.iterator().next().getPlane();
        Set<WorldPoint> samePlaneBoundary = boundaryTiles.stream()
            .filter(tile -> tile.getPlane() == plane)
            .collect(java.util.stream.Collectors.toSet());

        if (samePlaneBoundary.isEmpty())
        {
            profile.setInnerTiles(new HashSet<>());
            return false;
        }

        Set<WorldPoint> innerTiles = computeInteriorTiles(samePlaneBoundary, plane);
        if (innerTiles.isEmpty())
        {
            profile.setInnerTiles(new HashSet<>());
            return false;
        }

        profile.setInnerTiles(innerTiles);

        Set<WorldPoint> solidTiles = new HashSet<>(innerTiles);
        solidTiles.addAll(samePlaneBoundary);

        Set<WorldPoint> borderTiles = new HashSet<>();
        for (WorldPoint tile : samePlaneBoundary)
        {
            if (hasOuterEdge(tile, solidTiles, plane))
            {
                borderTiles.add(tile);
            }
        }

        profile.getBoundaryTiles().clear();
        profile.getBoundaryTiles().addAll(borderTiles);

        return true;
    }

    private Set<WorldPoint> computeInteriorTiles(Set<WorldPoint> boundaryTiles, int plane)
    {
        if (boundaryTiles.isEmpty())
        {
            return java.util.Collections.emptySet();
        }

        int minX = boundaryTiles.stream().mapToInt(WorldPoint::getX).min().orElse(0);
        int maxX = boundaryTiles.stream().mapToInt(WorldPoint::getX).max().orElse(0);
        int minY = boundaryTiles.stream().mapToInt(WorldPoint::getY).min().orElse(0);
        int maxY = boundaryTiles.stream().mapToInt(WorldPoint::getY).max().orElse(0);

        int padMinX = minX - 1;
        int padMaxX = maxX + 1;
        int padMinY = minY - 1;
        int padMaxY = maxY + 1;

        int width = padMaxX - padMinX + 1;
        int height = padMaxY - padMinY + 1;

        if (width <= 2 || height <= 2)
        {
            return java.util.Collections.emptySet();
        }

        Set<Long> boundaryKeys = boundaryTiles.stream()
            .map(tile -> tileKey(tile.getX(), tile.getY()))
            .collect(java.util.stream.Collectors.toSet());

        boolean[][] outside = new boolean[width][height];
        java.util.ArrayDeque<int[]> queue = new java.util.ArrayDeque<>();

        for (int x = 0; x < width; x++)
        {
            tryQueueOutside(queue, outside, boundaryKeys, padMinX, padMinY, x, 0);
            tryQueueOutside(queue, outside, boundaryKeys, padMinX, padMinY, x, height - 1);
        }
        for (int y = 1; y < height - 1; y++)
        {
            tryQueueOutside(queue, outside, boundaryKeys, padMinX, padMinY, 0, y);
            tryQueueOutside(queue, outside, boundaryKeys, padMinX, padMinY, width - 1, y);
        }

        final int[][] directions = new int[][]{
            {1, 0},
            {-1, 0},
            {0, 1},
            {0, -1}
        };

        while (!queue.isEmpty())
        {
            int[] cell = queue.removeFirst();
            for (int[] dir : directions)
            {
                int nx = cell[0] + dir[0];
                int ny = cell[1] + dir[1];

                if (nx < 0 || ny < 0 || nx >= width || ny >= height)
                {
                    continue;
                }

                if (outside[nx][ny])
                {
                    continue;
                }

                int worldX = padMinX + nx;
                int worldY = padMinY + ny;

                if (boundaryKeys.contains(tileKey(worldX, worldY)))
                {
                    continue;
                }

                outside[nx][ny] = true;
                queue.addLast(new int[]{nx, ny});
            }
        }

        Set<WorldPoint> innerTiles = new HashSet<>();
        for (int worldX = padMinX + 1; worldX <= padMaxX - 1; worldX++)
        {
            for (int worldY = padMinY + 1; worldY <= padMaxY - 1; worldY++)
            {
                int offsetX = worldX - padMinX;
                int offsetY = worldY - padMinY;
                if (outside[offsetX][offsetY])
                {
                    continue;
                }

                long key = tileKey(worldX, worldY);
                if (boundaryKeys.contains(key))
                {
                    continue;
                }

                innerTiles.add(new WorldPoint(worldX, worldY, plane));
            }
        }

        return innerTiles;
    }

    private void tryQueueOutside(java.util.ArrayDeque<int[]> queue, boolean[][] outside, Set<Long> boundaryKeys,
                                 int baseX, int baseY, int idxX, int idxY)
    {
        if (idxX < 0 || idxY < 0 || idxX >= outside.length || idxY >= outside[0].length)
        {
            return;
        }

        if (outside[idxX][idxY])
        {
            return;
        }

        int worldX = baseX + idxX;
        int worldY = baseY + idxY;

        if (boundaryKeys.contains(tileKey(worldX, worldY)))
        {
            return;
        }

        outside[idxX][idxY] = true;
        queue.addLast(new int[]{idxX, idxY});
    }

    private long tileKey(int x, int y)
    {
        long keyX = ((long)x & 0xFFFFFFFFL) << 32;
        long keyY = ((long)y & 0xFFFFFFFFL);
        return keyX | keyY;
    }

    /**
     * Export a region to a JSON file.
     * 
     * @param profile The region to export
     * @param filePath The file path to save to
     * @return true if export was successful, false otherwise
     */
    public boolean exportRegion(Region profile, String filePath)
    {
        if (profile == null || filePath == null || filePath.isEmpty())
        {
            return false;
        }

        String derivedName = deriveRegionNameFromPath(filePath);
        String exportName = derivedName != null ? derivedName : profile.getName();

        try (java.io.FileWriter writer = new java.io.FileWriter(filePath))
        {
            Gson prettyGson = gson.newBuilder().setPrettyPrinting().create();
            
            // Create a serializable version of the profile
            RegionExport exportData = new RegionExport();
            exportData.name = exportName;
            exportData.boundaryTiles = profile.getBoundaryTiles().stream()
                .map(wp -> new TileData(wp.getX(), wp.getY(), wp.getPlane()))
                .collect(java.util.stream.Collectors.toList());
            exportData.innerTiles = profile.getInnerTiles().stream()
                .map(wp -> new TileData(wp.getX(), wp.getY(), wp.getPlane()))
                .collect(java.util.stream.Collectors.toList());
            exportData.teleportWhitelist = new java.util.ArrayList<>(
                profile.getTeleportWhitelist() != null ? profile.getTeleportWhitelist() : java.util.Collections.emptySet());
            
            prettyGson.toJson(exportData, writer);
        }
        catch (Exception e)
        {
            log.error("Failed to export region", e);
            return false;
        }

        if (derivedName != null && !derivedName.equals(profile.getName()))
        {
            profile.setName(derivedName);
            saveRegions();
            notifyRegionsChanged();
        }

        return true;
    }

    /**
     * Import a region from a JSON file.
     * 
     * @param filePath The file path to load from
     * @return The imported Region, or null if import failed
     */
    public Region importRegion(String filePath)
    {
        if (filePath == null || filePath.isEmpty())
        {
            return null;
        }

        try (java.io.FileReader reader = new java.io.FileReader(filePath))
        {
            RegionExport exportData = gson.fromJson(reader, RegionExport.class);
            
            if (exportData == null)
            {
                return null;
            }

            String derivedName = deriveRegionNameFromPath(filePath);
            String regionName = derivedName != null ? derivedName : exportData.name;
            if (regionName == null || regionName.trim().isEmpty())
            {
                regionName = "Imported Region";
            }
            
            Region profile = new Region(regionName);
            
            // Convert tile data back to WorldPoints
            Set<WorldPoint> boundaryTiles = exportData.boundaryTiles != null
                ? exportData.boundaryTiles.stream()
                    .map(td -> new WorldPoint(td.x, td.y, td.plane))
                    .collect(java.util.stream.Collectors.toSet())
                : new HashSet<>();
            profile.setBoundaryTiles(boundaryTiles);
            
            Set<WorldPoint> innerTiles = exportData.innerTiles != null
                ? exportData.innerTiles.stream()
                    .map(td -> new WorldPoint(td.x, td.y, td.plane))
                    .collect(java.util.stream.Collectors.toSet())
                : new HashSet<>();
            profile.setInnerTiles(innerTiles);
            
            profile.setTeleportWhitelist(exportData.teleportWhitelist != null
                ? new HashSet<>(exportData.teleportWhitelist)
                : new HashSet<>());
            
            return profile;
        }
        catch (Exception e)
        {
            log.error("Failed to import region", e);
            return null;
        }
    }

    private String deriveRegionNameFromPath(String filePath)
    {
        try
        {
            java.nio.file.Path path = java.nio.file.Paths.get(filePath);
            java.nio.file.Path fileName = path.getFileName();
            if (fileName == null)
            {
                return null;
            }

            String baseName = fileName.toString();
            int dotIndex = baseName.lastIndexOf('.');
            if (dotIndex > 0)
            {
                baseName = baseName.substring(0, dotIndex);
            }

            baseName = baseName.trim();
            return baseName.isEmpty() ? null : baseName;
        }
        catch (Exception e)
        {
            log.debug("Failed to derive region name from path {}", filePath, e);
            return null;
        }
    }

    /**
     * Helper classes for JSON export/import
     */
    private static class RegionExport
    {
        String name;
        List<TileData> boundaryTiles;
        List<TileData> innerTiles;
        List<String> teleportWhitelist;
    }

    private static class TileData
    {
        int x;
        int y;
        int plane;
        
        TileData() {} // Default constructor for Gson
        
        TileData(int x, int y, int plane)
        {
            this.x = x;
            this.y = y;
            this.plane = plane;
        }
    }
}



package com.regionlockenforcer;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Stroke;
import java.awt.event.MouseEvent;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

/**
 * World map overlay for drawing chunk grid and handling chunk selection.
 * Based on approach used in region-locker plugin.
 * Uses WorldMap API directly for proper coordinate conversion.
 */
@Singleton
public class RegionLockWorldMapOverlay extends Overlay
{
    private static final int DEFAULT_GRID_SIZE = 64;

    private final Client client;
    private final ClientThread clientThread;
    private final RegionLockEnforcerConfig config;
    private RegionLockEnforcerPlugin plugin;

    @Inject
    private RegionLockWorldMapOverlay(Client client, ClientThread clientThread, RegionLockEnforcerConfig config)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGHEST);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    public void setPlugin(RegionLockEnforcerPlugin plugin)
    {
        this.plugin = plugin;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (plugin == null)
        {
            return null;
        }

        Region currentProfile = plugin.getCurrentRegion();
        if (currentProfile == null)
        {
            return null;
        }

        if (config.disableBorder())
        {
            return null;
        }

        boolean editing = plugin.isEditing();
        int gridSize = getGridSize();
        boolean hasInnerTiles = !currentProfile.getInnerTiles().isEmpty();

        if (editing)
        {
            drawChunkGrid(graphics, gridSize);
            drawBorderTiles(graphics);
            return null;
        }

        if (hasInnerTiles && config.displayBorderOnWorldMap())
        {
            drawBorderTiles(graphics);
        }

        return null;
    }

    /**
     * Draw a grid showing 64x64 chunks on the world map.
     * Based on region-locker plugin implementation.
     * Uses WorldMap API directly for proper coordinate conversion.
     */
    private void drawChunkGrid(Graphics2D graphics, int gridSize)
    {
        WorldMapRenderContext context = buildWorldMapRenderContext();
        if (context == null)
        {
            return;
        }

        Rectangle worldMapRect = context.getMapBounds();
        float pixelsPerTile = context.getPixelsPerTile();
        net.runelite.api.Point worldMapPosition = context.getWorldMapPosition();

        graphics.setClip(worldMapRect);

        int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
        int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

        // Offset in tiles from anchor sides
        int yTileMin = worldMapPosition.getY() - heightInTiles / 2;
        int xRegionMin = floorToMultiple((int)worldMapPosition.getX() - widthInTiles / 2, gridSize);
        int xRegionMax = floorToMultiple((int)worldMapPosition.getX() + widthInTiles / 2, gridSize) + gridSize;
        int yRegionMin = floorToMultiple(yTileMin, gridSize);
        int yRegionMax = floorToMultiple((int)worldMapPosition.getY() + heightInTiles / 2, gridSize) + gridSize;
        int regionPixelSize = (int) Math.ceil(gridSize * pixelsPerTile);

        Stroke oldStroke = graphics.getStroke();
        graphics.setStroke(new BasicStroke(1.0f));
        graphics.setColor(Color.BLACK);

        // Get current border profile to check for selected chunks
        Region currentProfile = plugin.getCurrentRegion();
        boolean hasSelectedAreas = currentProfile != null && !currentProfile.getBoundaryTiles().isEmpty();

        // Draw chunk grid lines and fill selected chunks
        for (int x = xRegionMin; x < xRegionMax; x += gridSize)
        {
            for (int y = yRegionMin; y < yRegionMax; y += gridSize)
            {
                int yTileOffset = -(yTileMin - y);
                int xTileOffset = x + widthInTiles / 2 - (int)worldMapPosition.getX();

                int xPos = ((int) (xTileOffset * pixelsPerTile)) + (int) worldMapRect.getX();
                int yPos = (worldMapRect.height - (int) (yTileOffset * pixelsPerTile)) + (int) worldMapRect.getY();
                // Offset y-position by a single region to correct for drawRect starting from the top
                yPos -= regionPixelSize;

                // Check if this chunk is fully selected
                if (hasSelectedAreas)
                {
                    if (currentProfile.isAreaFullyContained(x, y, 0, gridSize))
                    {
                        // Fill with semi-transparent dark grey/black
                        graphics.setColor(new Color(20, 20, 20, 140));
                        graphics.fillRect(xPos, yPos, regionPixelSize, regionPixelSize);
                    }
                }

                // Draw chunk border
                graphics.setColor(Color.BLACK);
                graphics.drawRect(xPos, yPos, regionPixelSize, regionPixelSize);
            }
        }
        graphics.setStroke(oldStroke);
    }

    /**
     * Draw individual border tiles on the world map.
     * Shows finished border (innerTiles) or marked tiles when in edit mode.
     */
    private void drawBorderTiles(Graphics2D graphics)
    {
        WorldMapRenderContext context = buildWorldMapRenderContext();
        if (context == null)
        {
            return;
        }

        Rectangle worldMapRect = context.getMapBounds();
        float pixelsPerTile = context.getPixelsPerTile();
        net.runelite.api.Point worldMapPosition = context.getWorldMapPosition();

        graphics.setClip(worldMapRect);

        Region currentProfile = plugin.getCurrentRegion();
        if (currentProfile == null) return;

        // Determine which tiles to show and what color to use
        Set<WorldPoint> tilesToShow;
        Color tileColor;
        boolean isEditing = plugin.isEditing();
        boolean hasInnerTiles = !currentProfile.getInnerTiles().isEmpty();
        
        if (isEditing)
        {
            // In edit mode: show marked boundary tiles in editing color
            tilesToShow = currentProfile.getBoundaryTiles();
            tileColor = config.editingColor();
        }
        else if (hasInnerTiles)
        {
            // Finished border: show boundary tiles in config color
            tilesToShow = currentProfile.getBoundaryTiles();
            tileColor = config.borderColor();
        }
        else
        {
            // No tiles to show
            return;
        }

        Set<WorldPoint> tilesToDraw = new HashSet<>(tilesToShow);
        if (tilesToDraw.isEmpty()) return;

        int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
        int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);
        
        int yTileMin = worldMapPosition.getY() - heightInTiles / 2;
        int xTileMin = worldMapPosition.getX() - widthInTiles / 2;
        int xTileMax = worldMapPosition.getX() + widthInTiles / 2;
        int yTileMax = worldMapPosition.getY() + heightInTiles / 2;

        // Draw each tile
        graphics.setColor(tileColor);
        int tilePixelSize = Math.max(1, (int) pixelsPerTile); // At least 1 pixel per tile
        
        for (WorldPoint tile : tilesToDraw)
        {
            // Only draw tiles on plane 0 (surface) for now
            if (tile.getPlane() != 0) continue;
            
            int tileX = tile.getX();
            int tileY = tile.getY();
            
            // Check if tile is visible in current view
            if (tileX < xTileMin || tileX > xTileMax || tileY < yTileMin || tileY > yTileMax)
            {
                continue;
            }
            
            // Calculate position on map using same approach as chunk grid
            int yTileOffset = -(yTileMin - tileY);
            int xTileOffset = tileX + widthInTiles / 2 - (int)worldMapPosition.getX();
            
            int xPos = ((int) (xTileOffset * pixelsPerTile)) + (int) worldMapRect.getX();
            int yPos = (worldMapRect.height - (int) (yTileOffset * pixelsPerTile)) + (int) worldMapRect.getY();
            // Adjust Y position to match chunk grid coordinate system
            yPos -= (int) pixelsPerTile;
            
            // Draw tile as a small rectangle
            graphics.fillRect(xPos, yPos, tilePixelSize, tilePixelSize);
        }
    }

    /**
     * Handle mouse clicks on the world map.
     * Called from the plugin when a click is detected.
     * Must handle widget access on client thread.
     */
    public boolean handleWorldMapClick(MouseEvent e)
    {
        // Only handle left clicks with Shift key when in editing mode
        if (e.getButton() != MouseEvent.BUTTON1)
        {
            return false;
        }
        
        // Require Shift key to be pressed
        if ((e.getModifiersEx() & MouseEvent.SHIFT_DOWN_MASK) == 0)
        {
            return false;
        }

        if (plugin == null || !plugin.isEditing() || plugin.getCurrentRegion() == null)
        {
            return false;
        }

        final int tileGroupSize = getGridSize();

        // Store mouse point for use on client thread
        Point mousePoint = e.getPoint();
        final Point finalMousePoint = new Point(mousePoint);

        // All widget access must be on client thread
        // Use a wrapper to capture the result from invoke()
        final boolean[] shouldHandle = {false};

        clientThread.invoke(() ->
        {
            WorldMapRenderContext context = buildWorldMapRenderContext();
            if (context == null)
            {
                return;
            }

            Rectangle mapBounds = context.getMapBounds();
            if (mapBounds == null || !mapBounds.contains(finalMousePoint))
            {
                return;
            }

            WorldPoint worldPoint = screenToWorldPoint(finalMousePoint, context);
            if (worldPoint == null)
            {
                return;
            }

            // Convert to chunk coordinates
            int baseX = floorToMultiple(worldPoint.getX(), tileGroupSize);
            int baseY = floorToMultiple(worldPoint.getY(), tileGroupSize);
            int plane = worldPoint.getPlane();

            Region currentProfile = plugin.getCurrentRegion();
            if (currentProfile == null)
            {
                return;
            }

            boolean areaHasTiles = currentProfile.hasAnyTileInArea(baseX, baseY, plane, tileGroupSize);

            if (areaHasTiles)
            {
                currentProfile.removeArea(baseX, baseY, plane, tileGroupSize);
            }
            else
            {
                currentProfile.addArea(baseX, baseY, plane, tileGroupSize);
            }

            plugin.saveRegions();
            plugin.notifyRegionsChanged();

            shouldHandle[0] = true;
        });

        return shouldHandle[0];
    }

    private WorldMapRenderContext buildWorldMapRenderContext()
    {
        Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map == null)
        {
            return null;
        }

        if (map.isHidden())
        {
            return null;
        }

        Rectangle mapBounds = map.getBounds();
        if (mapBounds == null)
        {
            return null;
        }

        WorldMap worldMap = client.getWorldMap();
        if (worldMap == null)
        {
            return null;
        }

        net.runelite.api.Point worldMapPosition = worldMap.getWorldMapPosition();
        if (worldMapPosition == null)
        {
            return null;
        }

        float pixelsPerTile = worldMap.getWorldMapZoom();
        if (pixelsPerTile <= 0)
        {
            return null;
        }

        return new WorldMapRenderContext(mapBounds, pixelsPerTile, worldMapPosition);
    }

    private WorldPoint screenToWorldPoint(Point screenPoint, WorldMapRenderContext context)
    {
        Rectangle mapBounds = context.getMapBounds();
        float pixelsPerTile = context.getPixelsPerTile();
        net.runelite.api.Point worldMapPosition = context.getWorldMapPosition();

        if (pixelsPerTile <= 0 || mapBounds == null || worldMapPosition == null)
        {
            return null;
        }

        int widthInTiles = (int)Math.ceil(mapBounds.getWidth() / pixelsPerTile);
        int heightInTiles = (int)Math.ceil(mapBounds.getHeight() / pixelsPerTile);

        double xTileOffset = (screenPoint.x - mapBounds.getX()) / pixelsPerTile;
        double yTileOffsetFromTop = (mapBounds.getHeight() - 1 - (screenPoint.y - mapBounds.getY())) / pixelsPerTile;

        int xIndex = clamp((int)Math.floor(xTileOffset), 0, Math.max(0, widthInTiles - 1));
        int yIndex = clamp((int)Math.floor(yTileOffsetFromTop), 0, Math.max(0, heightInTiles - 1));

        int xTileMin = (int)worldMapPosition.getX() - widthInTiles / 2;
        int yTileMin = worldMapPosition.getY() - heightInTiles / 2;

        int worldX = xTileMin + xIndex;
        int worldY = yTileMin + yIndex;

        return new WorldPoint(worldX, worldY, 0);
    }

    private int clamp(int value, int min, int max)
    {
        if (value < min)
        {
            return min;
        }
        if (value > max)
        {
            return max;
        }
        return value;
    }

    private int getGridSize()
    {
        int size = config.worldMapGridSize();
        if (size < 1)
        {
            return 1;
        }
        if (size > 64)
        {
            return DEFAULT_GRID_SIZE;
        }
        return size;
    }

    private int floorToMultiple(int value, int multiple)
    {
        if (multiple <= 0)
        {
            return value;
        }

        return Math.floorDiv(value, multiple) * multiple;
    }

    private static final class WorldMapRenderContext
    {
        private final Rectangle mapBounds;
        private final float pixelsPerTile;
        private final net.runelite.api.Point worldMapPosition;

        private WorldMapRenderContext(Rectangle mapBounds, float pixelsPerTile, net.runelite.api.Point worldMapPosition)
        {
            this.mapBounds = mapBounds;
            this.pixelsPerTile = pixelsPerTile;
            this.worldMapPosition = worldMapPosition;
        }

        private Rectangle getMapBounds()
        {
            return mapBounds;
        }

        private float getPixelsPerTile()
        {
            return pixelsPerTile;
        }

        private net.runelite.api.Point getWorldMapPosition()
        {
            return worldMapPosition;
        }
    }
}


package com.regionlockenforcer;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import lombok.Data;
import net.runelite.api.coords.WorldPoint;

/**
 * Represents a named region containing boundary tiles and inner tiles, and a teleport whitelist.
 * Boundary tiles define the border shape and are used for drawing borders.
 * Inner tiles are all tiles inside the boundary and are used for click blocking.
 */
@Data
public class Region
{
    private String name;
    private Set<WorldPoint> boundaryTiles = ConcurrentHashMap.newKeySet(); // Tiles that define the border
    private Set<WorldPoint> innerTiles = ConcurrentHashMap.newKeySet(); // All tiles inside the boundary (for click blocking)
    private Set<String> teleportWhitelist = ConcurrentHashMap.newKeySet(); // IDs of whitelisted teleports
    
    // Cached clickable tiles set - computed once and reused for performance
    // Null when cache is invalid, non-null when valid
    private transient Set<WorldPoint> cachedClickableTiles = null;

    public Region()
    {
        this.name = "Untitled Region";
    }

    public Region(String name)
    {
        this.name = name != null ? name : "Untitled Region";
    }

    public Set<WorldPoint> getBoundaryTiles()
    {
        if (boundaryTiles == null)
        {
            boundaryTiles = ConcurrentHashMap.newKeySet();
        }
        return boundaryTiles;
    }

    public Set<WorldPoint> getInnerTiles()
    {
        if (innerTiles == null)
        {
            innerTiles = ConcurrentHashMap.newKeySet();
        }
        return innerTiles;
    }

    public Set<String> getTeleportWhitelist()
    {
        if (teleportWhitelist == null)
        {
            teleportWhitelist = ConcurrentHashMap.newKeySet();
        }
        return teleportWhitelist;
    }

    /**
     * Add a boundary tile to this region.
     * @return true if the tile was added (wasn't already present)
     */
    public boolean addTile(WorldPoint tile)
    {
        boolean added = boundaryTiles.add(tile);
        if (added)
        {
            invalidateClickableTilesCache();
        }
        return added;
    }

    /**
     * Remove a boundary tile from this region.
     * @return true if the tile was removed (was present)
     */
    public boolean removeTile(WorldPoint tile)
    {
        boolean removed = boundaryTiles.remove(tile);
        if (removed)
        {
            invalidateClickableTilesCache();
        }
        return removed;
    }

    /**
     * Toggle a boundary tile in this region (add if absent, remove if present).
     * @return true if the tile is now present after toggle
     */
    public boolean toggleTile(WorldPoint tile)
    {
        if (boundaryTiles.contains(tile))
        {
            boundaryTiles.remove(tile);
            invalidateClickableTilesCache();
            return false;
        }
        else
        {
            boundaryTiles.add(tile);
            invalidateClickableTilesCache();
            return true;
        }
    }

    /**
     * Get all clickable tiles (boundary + inner tiles).
     * Used for determining click blocking.
     * This is cached for performance - the cache is invalidated when tiles change.
     */
    public Set<WorldPoint> getAllClickableTiles()
    {
        // Return cached version if available
        if (cachedClickableTiles != null)
        {
            return cachedClickableTiles;
        }
        
        // Compute and cache
        Set<WorldPoint> all = new HashSet<>(boundaryTiles);
        all.addAll(innerTiles);
        cachedClickableTiles = all;
        return all;
    }
    
    /**
     * Invalidate the cached clickable tiles set.
     * Should be called whenever boundaryTiles or innerTiles are modified.
     */
    private void invalidateClickableTilesCache()
    {
        cachedClickableTiles = null;
    }
    
    /**
     * Pre-compute the clickable tiles cache if it's not already computed.
     * This should be called after deserialization/import to ensure the cache is ready immediately.
     */
    public void ensureCacheComputed()
    {
        if (cachedClickableTiles == null)
        {
            getAllClickableTiles(); // This will compute and cache
        }
    }
    
    /**
     * Set boundary tiles and invalidate cache.
     * Overrides Lombok-generated setter to ensure cache invalidation.
     */
    public void setBoundaryTiles(Set<WorldPoint> boundaryTiles)
    {
        Set<WorldPoint> newSet = ConcurrentHashMap.newKeySet();
        if (boundaryTiles != null)
        {
            newSet.addAll(boundaryTiles);
        }
        this.boundaryTiles = newSet;
        invalidateClickableTilesCache();
    }
    
    /**
     * Set inner tiles and invalidate cache.
     * Overrides Lombok-generated setter to ensure cache invalidation.
     */
    public void setInnerTiles(Set<WorldPoint> innerTiles)
    {
        Set<WorldPoint> newSet = ConcurrentHashMap.newKeySet();
        if (innerTiles != null)
        {
            newSet.addAll(innerTiles);
        }
        this.innerTiles = newSet;
        invalidateClickableTilesCache();
    }

    public void setTeleportWhitelist(Set<String> teleportWhitelist)
    {
        Set<String> newSet = ConcurrentHashMap.newKeySet();
        if (teleportWhitelist != null)
        {
            newSet.addAll(teleportWhitelist);
        }
        this.teleportWhitelist = newSet;
    }

    /**
     * Add all tiles in a square area to the border.
     *
     * @param startX the lower-left tile X coordinate
     * @param startY the lower-left tile Y coordinate
     * @param plane the plane
     * @param size the width/height of the square in tiles
     * @return number of tiles added
     */
    public int addArea(int startX, int startY, int plane, int size)
    {
        if (size <= 0)
        {
            return 0;
        }

        int added = 0;
        
        for (int x = 0; x < size; x++)
        {
            for (int y = 0; y < size; y++)
            {
                WorldPoint tile = new WorldPoint(startX + x, startY + y, plane);
                if (boundaryTiles.add(tile))
                {
                    added++;
                }
            }
        }
        
        // Clear inner tiles when boundary changes
        innerTiles.clear();
        invalidateClickableTilesCache();
        return added;
    }

    /**
     * Add all tiles in a 64x64 chunk to the border.
     * A chunk is defined by its base coordinates (chunkX, chunkY) where
     * chunkX = worldX / 64 and chunkY = worldY / 64.
     */
    public int addChunk(int chunkX, int chunkY, int plane)
    {
        return addArea(chunkX * 64, chunkY * 64, plane, 64);
    }

    /**
     * Remove all tiles in a 64x64 chunk from the border.
     * 
     * @param chunkX The chunk X coordinate (worldX / 64)
     * @param chunkY The chunk Y coordinate (worldY / 64)
     * @param plane The plane (0 = surface, 1 = underground, etc.)
     * @return The number of tiles removed
     */
    public int removeArea(int startX, int startY, int plane, int size)
    {
        if (size <= 0)
        {
            return 0;
        }

        int removed = 0;
        
        for (int x = 0; x < size; x++)
        {
            for (int y = 0; y < size; y++)
            {
                WorldPoint tile = new WorldPoint(startX + x, startY + y, plane);
                if (boundaryTiles.remove(tile))
                {
                    removed++;
                }
            }
        }
        
        // Clear inner tiles when boundary changes
        innerTiles.clear();
        invalidateClickableTilesCache();
        return removed;
    }

    public int removeChunk(int chunkX, int chunkY, int plane)
    {
        return removeArea(chunkX * 64, chunkY * 64, plane, 64);
    }

    /**
     * Check if a chunk is fully contained in the border (all 64x64 tiles are present).
     * 
     * @param chunkX The chunk X coordinate (worldX / 64)
     * @param chunkY The chunk Y coordinate (worldY / 64)
     * @param plane The plane (0 = surface, 1 = underground, etc.)
     * @return true if all tiles in the chunk are in the border
     */
    public boolean isAreaFullyContained(int startX, int startY, int plane, int size)
    {
        if (size <= 0)
        {
            return false;
        }
        
        for (int x = 0; x < size; x++)
        {
            for (int y = 0; y < size; y++)
            {
                WorldPoint tile = new WorldPoint(startX + x, startY + y, plane);
                if (!boundaryTiles.contains(tile))
                {
                    return false;
                }
            }
        }
        
        return true;
    }

    public boolean isChunkFullyContained(int chunkX, int chunkY, int plane)
    {
        return isAreaFullyContained(chunkX * 64, chunkY * 64, plane, 64);
    }

    /**
     * Check if any boundary tile exists within the specified square area.
     *
     * @param startX lower-left tile X coordinate
     * @param startY lower-left tile Y coordinate
     * @param plane plane to inspect
     * @param size width/height of the square
     * @return true if at least one marked tile exists in the area
     */
    public boolean hasAnyTileInArea(int startX, int startY, int plane, int size)
    {
        if (size <= 0)
        {
            return false;
        }

        for (int x = 0; x < size; x++)
        {
            for (int y = 0; y < size; y++)
            {
                WorldPoint tile = new WorldPoint(startX + x, startY + y, plane);
                if (boundaryTiles.contains(tile))
                {
                    return true;
                }
            }
        }
        return false;
    }
}


package com.regionlockenforcer;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.coords.WorldPoint;

/**
 * Utility class for serializing/deserializing Region objects to/from strings.
 * Uses a simple format: "name|tile1;tile2;tile3" where tiles are "x,y,plane"
 */
@Slf4j
public class RegionSerializer
{

    /**
     * Serialize a WorldPoint to a string format: "x,y,plane"
     */
    public static String worldPointToString(WorldPoint wp)
    {
        if (wp == null) return null;
        return wp.getX() + "," + wp.getY() + "," + wp.getPlane();
    }

    /**
     * Deserialize a WorldPoint from a string format: "x,y,plane"
     */
    public static WorldPoint stringToWorldPoint(String str)
    {
        if (str == null || str.isEmpty()) return null;
        try
        {
            String[] parts = str.split(",");
            if (parts.length != 3) return null;
            int x = Integer.parseInt(parts[0].trim());
            int y = Integer.parseInt(parts[1].trim());
            int plane = Integer.parseInt(parts[2].trim());
            return new WorldPoint(x, y, plane);
        }
        catch (Exception e)
        {
            log.warn("Failed to parse WorldPoint from string: {}", str, e);
            return null;
        }
    }

    /**
     * Serialize a set of WorldPoints to a semicolon-separated string.
     */
    public static String serializeTiles(Set<WorldPoint> tiles)
    {
        if (tiles == null || tiles.isEmpty()) return "";
        return tiles.stream()
                .map(RegionSerializer::worldPointToString)
                .filter(s -> s != null)
                .collect(Collectors.joining(";"));
    }

    /**
     * Deserialize a set of WorldPoints from a semicolon-separated string.
     */
    public static Set<WorldPoint> deserializeTiles(String str)
    {
        Set<WorldPoint> tiles = new HashSet<>();
        if (str == null || str.isEmpty()) return tiles;
        try
        {
            String[] parts = str.split(";");
            for (String part : parts)
            {
                if (part.isEmpty()) continue;
                WorldPoint wp = stringToWorldPoint(part);
                if (wp != null) tiles.add(wp);
            }
        }
        catch (Exception e)
        {
            log.warn("Failed to deserialize tiles from string: {}", str, e);
        }
        return tiles;
    }

    /**
     * Serialize a set of strings to a semicolon-separated string.
     */
    public static String serializeStrings(Set<String> strings)
    {
        if (strings == null || strings.isEmpty()) return "";
        return String.join(";", strings);
    }
    
    /**
     * Deserialize a set of strings from a semicolon-separated string.
     */
    public static Set<String> deserializeStrings(String str)
    {
        Set<String> strings = new HashSet<>();
        if (str == null || str.isEmpty()) return strings;
        try
        {
            String[] parts = str.split(";");
            for (String part : parts)
            {
                if (!part.isEmpty()) strings.add(part);
            }
        }
        catch (Exception e)
        {
            log.warn("Failed to deserialize strings from string: {}", str, e);
        }
        return strings;
    }

    /**
     * Serialize a Region to string format: "name|boundaryTiles|innerTiles|teleportWhitelist"
     * Format: "name|tile1;tile2;tile3|tile4;tile5;tile6|teleport1;teleport2"
     * Special characters in name are escaped: | becomes ||, ; becomes |;
     */
    public static String serializeRegion(Region region)
    {
        if (region == null) return "";
        try
        {
            String name = region.getName() != null ? region.getName() : "Untitled Region";
            // Escape special characters: | -> ||, ; -> |;
            name = name.replace("|", "||").replace(";", "|;");
            String boundaryTiles = serializeTiles(region.getBoundaryTiles());
            String innerTiles = serializeTiles(region.getInnerTiles());
            String teleportWhitelist = serializeStrings(region.getTeleportWhitelist());
            return name + "|" + boundaryTiles + "|" + innerTiles + "|" + teleportWhitelist;
        }
        catch (Exception e)
        {
            log.warn("Failed to serialize Region", e);
            return "";
        }
    }

    /**
     * Deserialize a Region from string format.
     * Supports old formats for backward compatibility:
     * - Old format 1: "name|tiles" (just boundary tiles)
     * - Old format 2: "name|boundaryTiles|innerTiles" (no teleport whitelist)
     * - New format: "name|boundaryTiles|innerTiles|teleportWhitelist"
     */
    public static Region deserializeRegion(String str)
    {
        if (str == null || str.isEmpty()) return new Region();
        try
        {
            int firstPipeIndex = str.indexOf('|');
            if (firstPipeIndex == -1) return new Region();
            
            String name = str.substring(0, firstPipeIndex);
            // Unescape special characters: || -> |, |; -> ;
            name = name.replace("|;", ";").replace("||", "|");
            
            String rest = str.substring(firstPipeIndex + 1);
            Region region = new Region(name);
            
            // Split by | to get all parts
            String[] parts = rest.split("\\|", -1); // -1 to keep trailing empty strings
            
            if (parts.length >= 3)
            {
                // New format: boundaryTiles|innerTiles|teleportWhitelist
                region.setBoundaryTiles(deserializeTiles(parts[0]));
                region.setInnerTiles(deserializeTiles(parts[1]));
                if (!parts[2].isEmpty())
                {
                    region.setTeleportWhitelist(deserializeStrings(parts[2]));
                }
                else
                {
                    region.setTeleportWhitelist(new HashSet<>());
                }
            }
            else if (parts.length == 2)
            {
                // Old format 2: boundaryTiles|innerTiles (no teleport whitelist)
                region.setBoundaryTiles(deserializeTiles(parts[0]));
                region.setInnerTiles(deserializeTiles(parts[1]));
                region.setTeleportWhitelist(new HashSet<>());
            }
            else
            {
                // Old format 1: just tiles (treat as boundary tiles for backward compatibility)
                region.setBoundaryTiles(deserializeTiles(rest));
                region.setInnerTiles(new HashSet<>());
                region.setTeleportWhitelist(new HashSet<>());
            }
            
            // Pre-compute the cache so it's ready immediately (no lag on first access)
            region.ensureCacheComputed();
            
            return region;
        }
        catch (Exception e)
        {
            log.warn("Failed to deserialize Region from string: {}", str, e);
            return new Region();
        }
    }

    /**
     * Serialize a list of Regions to string format.
     * Regions are separated by newlines.
     */
    public static String serializeRegions(List<Region> regions)
    {
        if (regions == null || regions.isEmpty()) return "";
        return regions.stream()
                .map(RegionSerializer::serializeRegion)
                .filter(s -> !s.isEmpty())
                .collect(Collectors.joining("\n"));
    }

    /**
     * Deserialize a list of Regions from string format.
     * Regions are separated by newlines.
     */
    public static List<Region> deserializeRegions(String str)
    {
        List<Region> regions = new ArrayList<>();
        if (str == null || str.isEmpty()) return regions;
        try
        {
            String[] lines = str.split("\n");
            for (String line : lines)
            {
                if (line.isEmpty()) continue;
                Region region = deserializeRegion(line);
                if (region != null)
                {
                    // Cache is already pre-computed in deserializeRegion
                    regions.add(region);
                }
            }
        }
        catch (Exception e)
        {
            log.warn("Failed to deserialize regions from string: {}", str, e);
        }
        return regions;
    }
}


package com.regionlockenforcer;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginLauncher
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RegionLockEnforcerPlugin.class);
		RuneLite.main(args);
	}
}
