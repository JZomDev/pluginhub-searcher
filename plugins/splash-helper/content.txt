package xyz.peppie.splashhelper.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum OverallStatField
{
	TOTAL_CASTS("Total Casts"),
	TOTAL_XP("Total XP"),
	TOTAL_COST("Total Cost"),
	REMAINING_CASTS("Remaining"),
	HOURS_REMAINING("Hours Remaining"),
	POTENTIAL_XP("Potential XP"),
	GP_PER_HOUR("GP/Hour"),
	CURRENT_PLAYERS("Current Players"),
	HIGHEST_PLAYERS("Highest Players");

	private final String displayName;

	@Override
	public String toString()
	{
		return displayName;
	}
}

package xyz.peppie.splashhelper.model;

import java.time.Instant;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Server-ready session data structure for persistence.
 * Includes UUID and timestamps for server synchronization.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PersistedSession
{
	/**
	 * Unique identifier for this session (for server sync)
	 */
	private String sessionId;

	/**
	 * When this session was created (for server ordering)
	 */
	private long createdTimestamp;

	/**
	 * When this session was finalized
	 */
	private long finalizedTimestamp;

	/**
	 * Whether this session has been synced to server
	 */
	private boolean syncedToServer;

	/**
	 * The actual session data
	 */
	private SplashSession session;

	/**
	 * Create a new persisted session from a SplashSession
	 */
	public static PersistedSession fromSession(SplashSession session)
	{
		return PersistedSession.builder()
			.sessionId(UUID.randomUUID().toString())
			.createdTimestamp(session.getStartTime().toEpochMilli())
			.finalizedTimestamp(session.getEndTime() != null ? session.getEndTime().toEpochMilli() : Instant.now().toEpochMilli())
			.syncedToServer(false)
			.session(session)
			.build();
	}
}

package xyz.peppie.splashhelper.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SessionStatField
{
	SPELL("Spell"),
	CASTS("Casts"),
	XP_GAINED("XP Gained"),
	XP_PER_HOUR("XP/Hour"),
	RUNE_COST("Rune Cost"),
	NEARBY_PLAYERS("Nearby Players"),
	HIGHEST_PLAYERS("Highest Players");

	private final String displayName;

	@Override
	public String toString()
	{
		return displayName;
	}
}

package xyz.peppie.splashhelper.model;

import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import lombok.Getter;
import lombok.Setter;

@Getter
public class SplashSession
{
	// Static fields (set once at session start)
	private final String playerName;
	private SplashSpell spell;
	private int runeCostPerCast;
	private final Instant startTime;
	private final Instant logoutTime;
	private final int world;
	private final boolean stickyKnight;

	// Dynamic fields (updated during session)
	@Setter
	private int spellsCast = 0;
	@Setter
	private int startMagicXp;
	@Setter
	private int currentMagicXp;
	@Setter
	private int knightMovements = 0;
	@Setter
	private Instant endTime = null;

	// Player tracking (transient - not persisted)
	private transient final Set<String> pickpocketers = new HashSet<>();
	private transient final List<Integer> playerCountSamples = new ArrayList<>();
	@Setter
	private int highestPlayerCount = 0;
	
	// Derived statistics for persistence
	@Setter
	private int averagePlayerCount = 0;
	@Setter
	private int pickpocketerCount = 0;

	// Rune tracking
	@Setter
	private int startingRuneCount = 0;
	@Setter
	private int currentRuneCount = 0;
	private final Map<Integer, Integer> runeUsageMap = new HashMap<>();  // ItemId -> Total amount used
	@Setter
	private long runeCostGp = 0;  // Total GP cost of runes used

	public SplashSession(String playerName, SplashSpell spell, Instant logoutTime, int world, boolean stickyKnight, int startMagicXp)
	{
		this.playerName = playerName;
		this.spell = spell;
		this.runeCostPerCast = spell != null ? spell.getTotalRuneCost() : 0;
		this.startTime = Instant.now();
		this.logoutTime = logoutTime;
		this.world = world;
		this.stickyKnight = stickyKnight;
		this.startMagicXp = startMagicXp;
		this.currentMagicXp = startMagicXp;
	}

	public void setSpell(SplashSpell newSpell)
	{
		this.spell = newSpell;
		this.runeCostPerCast = newSpell != null ? newSpell.getTotalRuneCost() : 0;
	}

	public long getSessionDurationSeconds()
	{
		Instant end = endTime != null ? endTime : Instant.now();
		return java.time.Duration.between(startTime, end).getSeconds();
	}

	public int getMagicXpGained()
	{
		return currentMagicXp - startMagicXp;
	}

	public double getXpPerHour()
	{
		long seconds = getSessionDurationSeconds();
		if (seconds <= 0)
		{
			return 0;
		}
		return (getMagicXpGained() * 3600.0) / seconds;
	}

	public int getRunesUsed()
	{
		return startingRuneCount - currentRuneCount;
	}

	public int getRemainingCasts()
	{
		// currentRuneCount is already the number of possible casts (from countLimitingRunes)
		return currentRuneCount;
	}

	public void addPickpocketer(String playerName)
	{
		if (playerName != null && !playerName.isEmpty())
		{
			pickpocketers.add(playerName);
			pickpocketerCount = pickpocketers.size();
		}
	}

	public int getPickpocketerCount()
	{
		return pickpocketerCount;
	}

	public void addPlayerCountSample(int count, int maxSamples)
	{
		playerCountSamples.add(count);
		if (count > highestPlayerCount)
		{
			highestPlayerCount = count;
		}
		
		// Enforce maximum sample limit to prevent memory issues
		while (playerCountSamples.size() > maxSamples)
		{
			playerCountSamples.remove(0); // Remove oldest sample
		}
		
		// Update average for persistence
		averagePlayerCount = (int) Math.round(playerCountSamples.stream().mapToInt(Integer::intValue).average().orElse(0));
	}

	public double getAveragePlayerCount()
	{
		return averagePlayerCount;
	}

	public void incrementSpellsCast()
	{
		spellsCast++;
	}

	public void incrementKnightMovements()
	{
		knightMovements++;
	}

	/**
	 * Add rune usage for a single cast to the accumulated total.
	 * This allows tracking mixed spell usage without recalculating.
	 * @param runesUsedThisCast List of [itemId, amount] pairs for this cast
	 * @param costGp GP cost of runes used in this cast
	 */
	public void addRuneUsageForCast(List<int[]> runesUsedThisCast, long costGp)
	{
		if (runesUsedThisCast == null || runesUsedThisCast.isEmpty())
		{
			return;
		}

		// Accumulate rune usage using Map (no reference issues)
		for (int[] runeUsage : runesUsedThisCast)
		{
			int itemId = runeUsage[0];
			int amount = runeUsage[1];
			
			// Simply add to the map - Map.put handles both new and existing entries
			runeUsageMap.put(itemId, runeUsageMap.getOrDefault(itemId, 0) + amount);
		}

		// Accumulate cost
		runeCostGp += costGp;
	}

	/**
	 * Get actual rune usage as List<int[]> for compatibility with existing code.
	 * @return List of [itemId, totalAmount] pairs
	 */
	public List<int[]> getActualRuneUsage()
	{
		List<int[]> result = new ArrayList<>();
		for (Map.Entry<Integer, Integer> entry : runeUsageMap.entrySet())
		{
			result.add(new int[]{entry.getKey(), entry.getValue()});
		}
		return result;
	}

	public void finalizeSession()
	{
		this.endTime = Instant.now();
	}

	public boolean isActive()
	{
		return endTime == null;
	}
}

package xyz.peppie.splashhelper.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
public enum SplashSpell
{
	// Standard spellbook - Strike spells
	WIND_STRIKE("Wind Strike", 711, 5.5, new RuneCost(ItemID.AIR_RUNE, 1), new RuneCost(ItemID.MIND_RUNE, 1)),
	WATER_STRIKE("Water Strike", 711, 7.5, new RuneCost(ItemID.AIR_RUNE, 1), new RuneCost(ItemID.MIND_RUNE, 1), new RuneCost(ItemID.WATER_RUNE, 1)),
	EARTH_STRIKE("Earth Strike", 711, 9.5, new RuneCost(ItemID.AIR_RUNE, 1), new RuneCost(ItemID.MIND_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 2)),
	FIRE_STRIKE("Fire Strike", 711, 11.5, new RuneCost(ItemID.AIR_RUNE, 2), new RuneCost(ItemID.MIND_RUNE, 1), new RuneCost(ItemID.FIRE_RUNE, 3)),

	// Standard spellbook - Bolt spells
	WIND_BOLT("Wind Bolt", 711, 13.5, new RuneCost(ItemID.AIR_RUNE, 2), new RuneCost(ItemID.CHAOS_RUNE, 1)),
	WATER_BOLT("Water Bolt", 711, 16.5, new RuneCost(ItemID.AIR_RUNE, 2), new RuneCost(ItemID.CHAOS_RUNE, 1), new RuneCost(ItemID.WATER_RUNE, 2)),
	EARTH_BOLT("Earth Bolt", 711, 19.5, new RuneCost(ItemID.AIR_RUNE, 2), new RuneCost(ItemID.CHAOS_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 3)),
	FIRE_BOLT("Fire Bolt", 711, 22.5, new RuneCost(ItemID.AIR_RUNE, 3), new RuneCost(ItemID.CHAOS_RUNE, 1), new RuneCost(ItemID.FIRE_RUNE, 4)),

	// Standard spellbook - Blast spells
	WIND_BLAST("Wind Blast", 711, 25.5, new RuneCost(ItemID.AIR_RUNE, 3), new RuneCost(ItemID.DEATH_RUNE, 1)),
	WATER_BLAST("Water Blast", 711, 28.5, new RuneCost(ItemID.AIR_RUNE, 3), new RuneCost(ItemID.DEATH_RUNE, 1), new RuneCost(ItemID.WATER_RUNE, 3)),
	EARTH_BLAST("Earth Blast", 711, 31.5, new RuneCost(ItemID.AIR_RUNE, 3), new RuneCost(ItemID.DEATH_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 4)),
	FIRE_BLAST("Fire Blast", 711, 34.5, new RuneCost(ItemID.AIR_RUNE, 4), new RuneCost(ItemID.DEATH_RUNE, 1), new RuneCost(ItemID.FIRE_RUNE, 5)),

	// Standard spellbook - Wave spells
	WIND_WAVE("Wind Wave", 711, 36.0, new RuneCost(ItemID.AIR_RUNE, 5), new RuneCost(ItemID.BLOOD_RUNE, 1)),
	WATER_WAVE("Water Wave", 711, 37.5, new RuneCost(ItemID.AIR_RUNE, 5), new RuneCost(ItemID.BLOOD_RUNE, 1), new RuneCost(ItemID.WATER_RUNE, 7)),
	EARTH_WAVE("Earth Wave", 711, 40.0, new RuneCost(ItemID.AIR_RUNE, 5), new RuneCost(ItemID.BLOOD_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 7)),
	FIRE_WAVE("Fire Wave", 711, 42.5, new RuneCost(ItemID.AIR_RUNE, 5), new RuneCost(ItemID.BLOOD_RUNE, 1), new RuneCost(ItemID.FIRE_RUNE, 7)),

	// Standard spellbook - Surge spells
	WIND_SURGE("Wind Surge", 711, 44.5, new RuneCost(ItemID.AIR_RUNE, 7), new RuneCost(ItemID.WRATH_RUNE, 1)),
	WATER_SURGE("Water Surge", 711, 46.5, new RuneCost(ItemID.AIR_RUNE, 7), new RuneCost(ItemID.WRATH_RUNE, 1), new RuneCost(ItemID.WATER_RUNE, 10)),
	EARTH_SURGE("Earth Surge", 711, 48.5, new RuneCost(ItemID.AIR_RUNE, 7), new RuneCost(ItemID.WRATH_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 10)),
	FIRE_SURGE("Fire Surge", 711, 50.5, new RuneCost(ItemID.AIR_RUNE, 7), new RuneCost(ItemID.WRATH_RUNE, 1), new RuneCost(ItemID.FIRE_RUNE, 10)),

	// Curses (commonly used for splashing)
	CURSE("Curse", 710, 29.0, new RuneCost(ItemID.BODY_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 3), new RuneCost(ItemID.WATER_RUNE, 2)),
	WEAKEN("Weaken", 716, 21.0, new RuneCost(ItemID.BODY_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 2), new RuneCost(ItemID.WATER_RUNE, 3)),
	CONFUSE("Confuse", 716, 13.0, new RuneCost(ItemID.BODY_RUNE, 1), new RuneCost(ItemID.EARTH_RUNE, 2), new RuneCost(ItemID.WATER_RUNE, 3));

	private final String name;
	private final int animationId;
	private final double baseXp;
	private final RuneCost[] runeCosts;

	SplashSpell(String name, int animationId, double baseXp, RuneCost... runeCosts)
	{
		this.name = name;
		this.animationId = animationId;
		this.baseXp = baseXp;
		this.runeCosts = runeCosts;
	}

	public int getTotalRuneCost()
	{
		int total = 0;
		for (RuneCost cost : runeCosts)
		{
			total += cost.getAmount();
		}
		return total;
	}

	public int getRuneCount(int itemId)
	{
		for (RuneCost cost : runeCosts)
		{
			if (cost.getItemId() == itemId)
			{
				return cost.getAmount();
			}
		}
		return 0;
	}

	@Override
	public String toString()
	{
		return name;
	}

	public static SplashSpell fromAnimationId(int animationId)
	{
		for (SplashSpell spell : values())
		{
			if (spell.getAnimationId() == animationId)
			{
				return spell;
			}
		}
		return null;
	}

	/**
	 * Detect the spell from the XP gained.
	 * Each spell has a unique base XP value, so we can identify it from the XP drop.
	 */
	public static SplashSpell fromXpDrop(int xpGained)
	{
		for (SplashSpell spell : values())
		{
			// XP is stored as integer, baseXp is double (e.g., 5.5 -> 5 or 6 XP)
			int expectedXp = (int) spell.getBaseXp();
			int expectedXpRounded = (int) Math.round(spell.getBaseXp());
			
			if (xpGained == expectedXp || xpGained == expectedXpRounded)
			{
				return spell;
			}
		}
		return null;
	}

	@Getter
	@RequiredArgsConstructor
	public static class RuneCost
	{
		private final int itemId;
		private final int amount;
	}

	// Item IDs for runes (from RuneLite's ItemID)
	public static class ItemID
	{
		public static final int AIR_RUNE = 556;
		public static final int WATER_RUNE = 555;
		public static final int EARTH_RUNE = 557;
		public static final int FIRE_RUNE = 554;
		public static final int MIND_RUNE = 558;
		public static final int BODY_RUNE = 559;
		public static final int CHAOS_RUNE = 562;
		public static final int DEATH_RUNE = 560;
		public static final int BLOOD_RUNE = 565;
		public static final int WRATH_RUNE = 21880;
	}
}

package xyz.peppie.splashhelper.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TargetNpc
{
	KNIGHT_OF_ARDOUGNE("Knight of Ardougne"),
	RAT("Rat"),
	GUARD("Guard");

	private final String npcName;

	@Override
	public String toString()
	{
		return npcName;
	}
}

package xyz.peppie.splashhelper.overlays;

import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import xyz.peppie.splashhelper.SplashHelperConfig;
import xyz.peppie.splashhelper.service.TileManager;

public class BoundaryTileOverlay extends Overlay
{
	private final Client client;
	private final SplashHelperConfig config;
	private final TileManager tileManager;

	@Inject
	private BoundaryTileOverlay(Client client, SplashHelperConfig config, TileManager tileManager)
	{
		this.client = client;
		this.config = config;
		this.tileManager = tileManager;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Stroke originalStroke = graphics.getStroke();

		// Render boundary tile
		if (tileManager.getBoundaryTile() != null)
		{
			renderTile(graphics, tileManager.getBoundaryTile(), config.boundaryTileColor(), originalStroke);
		}

		// Render Knight Tile 1
		if (tileManager.getKnightTile1() != null)
		{
			renderTile(graphics, tileManager.getKnightTile1(), config.knightTile1Color(), originalStroke);
		}

		// Render Knight Tile 2
		if (tileManager.getKnightTile2() != null)
		{
			renderTile(graphics, tileManager.getKnightTile2(), config.knightTile2Color(), originalStroke);
		}

		return null;
	}

	private void renderTile(Graphics2D graphics, WorldPoint worldPoint, java.awt.Color color, Stroke originalStroke)
	{
		// Client is guaranteed to be non-null by dependency injection in RuneLite plugins
		final Client safeClient = client;
		if (safeClient == null) {
			return;
		}

		LocalPoint localPoint = LocalPoint.fromWorld(safeClient.getTopLevelWorldView(), worldPoint);

		if (localPoint == null)
		{
			return;
		}

		// Get the tile polygon
		Polygon tilePoly = Perspective.getCanvasTilePoly(safeClient, localPoint);

		if (tilePoly == null)
		{
			return;
		}

		// Fill with transparent dark gray
		graphics.setColor(new java.awt.Color(0, 0, 0, 100));
		graphics.fillPolygon(tilePoly);

		// Draw colored border
		graphics.setStroke(new BasicStroke(2));
		graphics.setColor(color);
		graphics.drawPolygon(tilePoly);
		graphics.setStroke(originalStroke);
	}
}

package xyz.peppie.splashhelper.overlays;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import xyz.peppie.splashhelper.SplashHelperConfig;

/**
 * Overlay to warn players about grief-prone settings.
 * Shows a red warning in the top-left corner if Accept Aid is on or Private Chat is set to All.
 */
public class GriefPreventionOverlay extends Overlay
{
	private static final int ACCEPT_AID_VARP = 427;
	private static final int PRIVATE_CHAT_VARP = 287;
	
	// Private chat values: 0 = Off, 1 = Friends, 2 = On (All)
	private static final int PRIVATE_CHAT_ON = 2;
	
	private final Client client;
	private final SplashHelperConfig config;
	private final PanelComponent panelComponent = new PanelComponent();

	@Inject
	public GriefPreventionOverlay(Client client, SplashHelperConfig config)
	{
		setPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		this.client = client;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// Only show if grief prevention is enabled in config
		if (!config.enableGriefPrevention())
		{
			return null;
		}

		boolean acceptAidOn = client.getVarpValue(ACCEPT_AID_VARP) == 1;
		int privateChatSetting = client.getVarpValue(PRIVATE_CHAT_VARP);
		// Private chat: 0 = Off, 1 = Friends, 2 = On (All)
		boolean privateChatAll = privateChatSetting == PRIVATE_CHAT_ON;

		// Only show overlay if either setting is problematic
		if (!acceptAidOn && !privateChatAll)
		{
			return null;
		}

		panelComponent.getChildren().clear();
		
		// Title
		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Grief Prevention")
			.color(Color.RED)
			.build());

		// Warning messages
		if (acceptAidOn)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("⚠ Accept Aid: ON")
				.leftColor(Color.RED)
				.build());
			panelComponent.getChildren().add(LineComponent.builder()
				.left("  Turn it OFF")
				.leftColor(Color.ORANGE)
				.build());
		}

		if (privateChatAll)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("⚠ Private Chat: All")
				.leftColor(Color.RED)
				.build());
			panelComponent.getChildren().add(LineComponent.builder()
				.left("  Set to Friends/Off")
				.leftColor(Color.ORANGE)
				.build());
		}

		panelComponent.setBackgroundColor(new Color(70, 0, 0, 200));
		panelComponent.setPreferredSize(new Dimension(200, 0));

		return panelComponent.render(graphics);
	}
}

package xyz.peppie.splashhelper.overlays;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import xyz.peppie.splashhelper.SplashHelperPlugin;

public class MagicBonusWarningOverlay extends Overlay
{
	private final SplashHelperPlugin plugin;
	private final PanelComponent panelComponent = new PanelComponent();

	@Inject
	public MagicBonusWarningOverlay(SplashHelperPlugin plugin)
	{
		this.plugin = plugin;
		setPosition(OverlayPosition.TOP_CENTER);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.isHasBadMagicBonus())
		{
			return null;
		}

		panelComponent.getChildren().clear();

		panelComponent.getChildren().add(TitleComponent.builder()
			.text("MAGIC BONUS WARNING")
			.color(Color.RED)
			.build());

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Your magic attack bonus is too high!")
			.leftColor(Color.ORANGE)
			.build());

		panelComponent.getChildren().add(LineComponent.builder()
			.left("You will NOT splash reliably")
			.leftColor(Color.ORANGE)
			.build());

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Required: -64 or lower")
			.leftColor(Color.YELLOW)
			.build());

		panelComponent.setPreferredSize(new Dimension(250, 0));

		return panelComponent.render(graphics);
	}
}

package xyz.peppie.splashhelper.overlays;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.PanelComponent;
import xyz.peppie.splashhelper.SplashHelperPlugin;

/**
 * Overlay that displays safety mode status in the top-left corner.
 * Shows red when safety mode is disabled, green when enabled.
 */
public class SafetyModeOverlay extends Overlay
{
	private final SplashHelperPlugin plugin;
	private final PanelComponent panelComponent = new PanelComponent();

	@Inject
	public SafetyModeOverlay(SplashHelperPlugin plugin)
	{
		super(plugin);
		setPosition(OverlayPosition.TOP_LEFT);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		this.plugin = plugin;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		panelComponent.getChildren().clear();

		// More toned down colors
		Color backgroundColor = plugin.isSafetyModeEnabled() ? new Color(100, 150, 100) : new Color(150, 100, 100);
		Color textColor = new Color(220, 220, 220);

		String status = plugin.isSafetyModeEnabled() ? "Enabled" : "Disabled";

		panelComponent.getChildren().add(
			net.runelite.client.ui.overlay.components.LineComponent.builder()
				.left("Safety Mode: " + status)
				.leftColor(textColor)
				.build()
		);

		panelComponent.setBackgroundColor(backgroundColor);
		panelComponent.setPreferredSize(new Dimension(140, 0));

		return panelComponent.render(graphics);
	}
}

package xyz.peppie.splashhelper.overlays;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.time.Duration;
import java.time.Instant;
import javax.inject.Inject;

import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import xyz.peppie.splashhelper.SplashHelperPlugin;
import xyz.peppie.splashhelper.service.TileManager;

public class SplashHelperOverlay extends Overlay
{
	private SplashHelperPlugin plugin;
	private TileManager tileManager;
	private final PanelComponent panelComponent = new PanelComponent();

	@Inject
	private SplashHelperOverlay()
	{
		setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
	}

	public void setPlugin(SplashHelperPlugin plugin, TileManager tileManager)
	{
		this.plugin = plugin;
		this.tileManager = tileManager;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		panelComponent.getChildren().clear();
		String overlayTitle = "Splash Timer";

		// Add title
		panelComponent.getChildren().add(TitleComponent.builder()
			.text(overlayTitle)
			.color(Color.CYAN)
			.build());

		panelComponent.setPreferredSize(new Dimension(
            graphics.getFontMetrics().stringWidth(overlayTitle) + 90,
            0));

		// Check if plugin is initialized
		if (plugin == null)
		{
			return null;
		}
		
		// Show boundary tile status
		if (tileManager.getBoundaryTile() != null)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Boundary:")
				.right("SET")
				.rightColor(Color.GREEN)
				.build());
		}
		
		// Show movement tracking stats
		if (tileManager.getKnightTile1() != null && tileManager.getKnightTile2() != null)
		{
			double movementsPerMin = tileManager.getMovementsPerMinute();
			String movementText = String.format("%.1f/min", movementsPerMin);
			
			Color movementColor = Color.CYAN;
			if (movementsPerMin > 0)
			{
				movementColor = Color.GREEN;
			}
			
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Movements:")
				.right(movementText)
				.rightColor(movementColor)
				.build());
		}
		
		// Check if timer is initialized
		if (plugin.getTimerEnd() == null)
		{
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Timer:")
				.right("Not started")
				.rightColor(Color.GRAY)
				.build());
			return panelComponent.render(graphics);
		}

		// Calculate remaining time
		Duration remaining = Duration.between(Instant.now(), plugin.getTimerEnd());
		
		if (remaining.isNegative() || remaining.isZero())
		{
			// Timer expired
			panelComponent.getChildren().add(LineComponent.builder()
				.left("Time:")
				.right("EXPIRED")
				.rightColor(Color.RED)
				.build());
		}
		else
		{
			// Format time as MM:SS
			long totalSeconds = remaining.getSeconds();
			long minutes = totalSeconds / 60;
			long seconds = totalSeconds % 60;
			String timeString = String.format("%02d:%02d", minutes, seconds);

			Color timeColor = Color.GREEN;
			if (minutes < 1)
			{
				timeColor = Color.YELLOW;
			}
			if (seconds < 30 && minutes == 0)
			{
				timeColor = Color.RED;
			}

			panelComponent.getChildren().add(LineComponent.builder()
				.left("Time Remaining:")
				.right(timeString)
				.rightColor(timeColor)
				.build());
		}

		return panelComponent.render(graphics);
	}
}

package xyz.peppie.splashhelper.overlays;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import xyz.peppie.splashhelper.SplashHelperConfig;
import xyz.peppie.splashhelper.SplashHelperPlugin;

/**
 * Full-screen visual notification overlay.
 * Fills the entire game canvas with a translucent color when triggered.
 */
public class VisualNotificationOverlay extends Overlay
{
	private final Client client;
	private final SplashHelperPlugin plugin;
	private final SplashHelperConfig config;

	@Inject
	public VisualNotificationOverlay(Client client, SplashHelperPlugin plugin, SplashHelperConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isShowVisualNotification())
		{
			Color originalColor = graphics.getColor();
			
			// Use configured color with some transparency
			Color notificationColor = config.visualNotificationColor();
			Color transparentColor = new Color(
				notificationColor.getRed(),
				notificationColor.getGreen(),
				notificationColor.getBlue(),
				100  // Alpha for transparency
			);
			
			graphics.setColor(transparentColor);
			graphics.fill(new Rectangle(client.getCanvas().getSize()));
			graphics.setColor(originalColor);
		}
		return null;
	}
}

package xyz.peppie.splashhelper.service;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import xyz.peppie.splashhelper.util.Constants;

/**
 * Service responsible for detecting and analyzing the Knight of Ardougne NPC.
 * Handles sticky knight detection based on NPC IDs.
 */
@Singleton
public class KnightDetector
{
	@Inject
	public KnightDetector()
	{
	}

	/**
	 * Check if the given actor is a "sticky" knight (female variant).
	 * Sticky knights have a smaller clickbox and are preferred for splashing.
	 * Detection is based on NPC ID.
	 */
	public boolean isStickyKnight(Actor target)
	{
		if (target == null || !(target instanceof NPC))
		{
			return false;
		}

		NPC knight = (NPC) target;
		int npcId = knight.getId();

		return npcId == Constants.FEMALE_KNIGHT_NPC_ID;
	}

	/**
	 * Check if splashing conditions are met for the given knight and tiles.
	 */
	public boolean isSplashingConditionsMet(Actor target, WorldPoint knightTile1, WorldPoint knightTile2)
	{
		if (target == null)
		{
			return false;
		}

		if (knightTile1 == null || knightTile2 == null)
		{
			return false;
		}

		WorldPoint knightPos = target.getWorldLocation();
		if (knightPos == null)
		{
			return false;
		}

		return knightPos.equals(knightTile1) || knightPos.equals(knightTile2);
	}

	/**
	 * Check if knight has moved from its previous position.
	 */
	public boolean hasKnightMoved(Actor target, WorldPoint lastPosition)
	{
		if (target == null || lastPosition == null)
		{
			return false;
		}

		WorldPoint currentPosition = target.getWorldLocation();
		return currentPosition != null && !currentPosition.equals(lastPosition);
	}

	/**
	 * Check if knight is on one of the valid splash tiles.
	 */
	public boolean isOnValidTile(Actor target, WorldPoint tile1, WorldPoint tile2)
	{
		if (target == null)
		{
			return false;
		}

		WorldPoint knightPos = target.getWorldLocation();
		if (knightPos == null)
		{
			return false;
		}

		boolean onTile1 = tile1 != null && knightPos.equals(tile1);
		boolean onTile2 = tile2 != null && knightPos.equals(tile2);

		return onTile1 || onTile2;
	}
}

package xyz.peppie.splashhelper.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.Notifier;
import net.runelite.client.config.FlashNotification;
import net.runelite.client.config.Notification;
import net.runelite.client.config.NotificationSound;
import net.runelite.client.config.RequestFocusType;
import xyz.peppie.splashhelper.SplashHelperConfig;

import java.awt.Color;
import java.awt.TrayIcon;

/**
 * Service for handling all notification logic.
 */
@Slf4j
@Singleton
public class NotificationService
{
	@Inject
	private Client client;

	@Inject
	private Notifier notifier;

	@Inject
	private SplashHelperConfig config;

	private boolean notificationsMuted = false;
	private VisualNotificationCallback visualNotificationCallback;

	public interface VisualNotificationCallback
	{
		void triggerVisualNotification();
	}

	public void setVisualNotificationCallback(VisualNotificationCallback callback)
	{
		this.visualNotificationCallback = callback;
	}

	/**
	 * Send a timer notification.
	 */
	public void sendTimerNotification(String message)
	{
		if (!config.enableTimerNotification())
		{
			return;
		}
		if (notificationsMuted)
		{
			return;
		}
		sendNotificationInternal(message);
	}

	/**
	 * Send a boundary notification.
	 */
	public void sendBoundaryNotification(String message)
	{
		if (!config.enableBoundaryNotification())
		{
			return;
		}
		if (notificationsMuted)
		{
			return;
		}
		sendNotificationInternal(message);
	}

	/**
	 * Send an HP notification.
	 */
	public void sendHpNotification(String message)
	{
		if (!config.enableHpNotification())
		{
			return;
		}
		if (notificationsMuted)
		{
			return;
		}
		sendNotificationInternal(message);
	}

	/**
	 * Send a generic notification.
	 */
	public void sendNotification(String message)
	{
		sendNotificationInternal(message);
	}

	/**
	 * Mute all notifications.
	 */
	public void muteNotifications()
	{
		notificationsMuted = true;
	}

	/**
	 * Unmute all notifications.
	 */
	public void unmuteNotifications()
	{
		notificationsMuted = false;
	}

	/**
	 * Check if notifications are muted.
	 */
	public boolean areNotificationsMuted()
	{
		return notificationsMuted;
	}

	/**
	 * Internal method to send notification.
	 */
	private void sendNotificationInternal(String message)
	{
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "Splash Helper", message, null);
		
		if (config.useVisualNotification())
		{
			// Trigger visual notification overlay in main plugin
			if (visualNotificationCallback != null)
			{
				visualNotificationCallback.triggerVisualNotification();
			}
			log.debug("Visual notification triggered: {}", message);
		}
		else
		{
			// Send system notification with auto-dismiss enabled
			Notification notification = new Notification(
				true,
				true,
				true,  // Enable auto-dismiss
				false,
				TrayIcon.MessageType.WARNING,
				RequestFocusType.OFF,
				NotificationSound.CUSTOM,
				null,
				client.getMusicVolume(),
				1,
				true,
				FlashNotification.DISABLED,
				Color.GREEN,
				false
			);
			notifier.notify(notification, message);
		}
	}
}

package xyz.peppie.splashhelper.service;

import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import xyz.peppie.splashhelper.util.Constants;

/**
 * Service responsible for tracking players near the knight,
 * particularly pickpocketers who may affect splashing.
 */
@Singleton
public class PlayerTracker
{
	private final Client client;
	private final Set<String> pickpocketers = new HashSet<>();

	@Getter
	private int currentPickpocketerCount = 0;

	@Inject
	public PlayerTracker(Client client)
	{
		this.client = client;
	}

	/**
	 * Reset all tracking data.
	 */
	public void reset()
	{
		pickpocketers.clear();
		currentPickpocketerCount = 0;
	}

	/**
	 * Add a player to the pickpocketer set.
	 * @return true if this is a new pickpocketer
	 */
	public boolean addPickpocketer(String playerName)
	{
		if (playerName == null || playerName.isEmpty())
		{
			return false;
		}
		return pickpocketers.add(playerName);
	}

	/**
	 * Get all tracked pickpocketers.
	 */
	public Set<String> getPickpocketers()
	{
		return new HashSet<>(pickpocketers);
	}

	/**
	 * Check if a player is performing the pickpocket animation.
	 */
	public boolean isPickpocketing(Player player)
	{
		if (player == null)
		{
			return false;
		}
		return player.getAnimation() == Constants.ANIMATION_PICKPOCKET;
	}

	/**
	 * Count players within a radius of a location.
	 */
	public int countPlayersInRadius(WorldPoint center, int radius)
	{
		if (center == null)
		{
			return 0;
		}

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return 0;
		}

		int count = 0;

		for (Player player : client.getTopLevelWorldView().players())
		{
			if (player == null || player == localPlayer)
			{
				continue;
			}

			WorldPoint otherLocation = player.getWorldLocation();
			if (otherLocation != null && center.distanceTo(otherLocation) <= radius)
			{
				count++;
			}
		}

		return count;
	}

	/**
	 * Update pickpocketer count for players near an actor.
	 */
	public void updatePickpocketerCount(Actor target, int radius)
	{
		if (target == null)
		{
			currentPickpocketerCount = 0;
			return;
		}

		WorldPoint targetLocation = target.getWorldLocation();
		currentPickpocketerCount = countPlayersInRadius(targetLocation, radius);
	}

	/**
	 * Check if a player is near the target and performing pickpocket animation.
	 * If so, add them to the pickpocketer set.
	 */
	public void checkAndTrackPickpocketer(Player player, Actor target, int radius)
	{
		if (player == null || target == null)
		{
			return;
		}

		if (!isPickpocketing(player))
		{
			return;
		}

		WorldPoint playerLocation = player.getWorldLocation();
		WorldPoint targetLocation = target.getWorldLocation();

		if (playerLocation != null && targetLocation != null &&
			playerLocation.distanceTo(targetLocation) <= radius)
		{
			String playerName = player.getName();
			if (playerName != null)
			{
				addPickpocketer(playerName);
			}
		}
	}
}

package xyz.peppie.splashhelper.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InventoryID;
import xyz.peppie.splashhelper.model.SplashSpell;
import xyz.peppie.splashhelper.util.Constants;

/**
 * Service responsible for all rune-related calculations including:
 * - Counting runes in inventory and rune pouch
 * - Detecting combination runes
 * - Detecting infinite runes from equipped staves
 * - Calculating remaining spell casts
 */
@Singleton
public class RuneCalculator
{
	private final Client client;

	@Inject
	public RuneCalculator(Client client)
	{
		this.client = client;
	}

	/**
	 * Calculate remaining casts for a spell, accounting for combo runes, pouch, and staves.
	 */
	public int getRemainingCasts(SplashSpell spell)
	{
		if (spell == null)
		{
			return 0;
		}

		ItemContainer inventory = client.getItemContainer(InventoryID.INV);
		if (inventory == null)
		{
			return 0;
		}

		Set<Integer> infiniteRunes = getInfiniteRunesFromEquipment();
		Map<Integer, Integer> runeCounts = buildRuneCountMap(inventory);

		int minCasts = Integer.MAX_VALUE;

		for (SplashSpell.RuneCost cost : spell.getRuneCosts())
		{
			if (infiniteRunes.contains(cost.getItemId()))
			{
				continue;
			}

			int runeCount = runeCounts.getOrDefault(cost.getItemId(), 0);
			int castsWithThisRune = runeCount / cost.getAmount();
			minCasts = Math.min(minCasts, castsWithThisRune);
		}

		return minCasts == Integer.MAX_VALUE ? 0 : minCasts;
	}

	/**
	 * Get the actual runes being consumed for a spell.
	 * Detects combination runes in inventory and excludes infinite runes from staves.
	 * @return List of int[2] arrays: [itemId, amountPerCast]
	 */
	public List<int[]> getActualRuneUsage(SplashSpell spell)
	{
		List<int[]> result = new ArrayList<>();

		if (spell == null)
		{
			return result;
		}

		ItemContainer inventory = client.getItemContainer(InventoryID.INV);
		if (inventory == null)
		{
			return result;
		}

		Set<Integer> infiniteRunes = getInfiniteRunesFromEquipment();
		Map<Integer, Integer> comboRunesInInventory = findCombinationRunes(inventory);

		for (SplashSpell.RuneCost cost : spell.getRuneCosts())
		{
			int requiredRuneId = cost.getItemId();

			if (infiniteRunes.contains(requiredRuneId))
			{
				continue;
			}

			int comboRuneId = findCombinationRuneFor(requiredRuneId, comboRunesInInventory.keySet());
			if (comboRuneId > 0)
			{
				result.add(new int[]{comboRuneId, cost.getAmount()});
			}
			else
			{
				result.add(new int[]{requiredRuneId, cost.getAmount()});
			}
		}

		return deduplicateRuneUsage(result);
	}

	/**
	 * Get set of rune IDs that are provided infinitely by equipped staves.
	 */
	public Set<Integer> getInfiniteRunesFromEquipment()
	{
		Set<Integer> infiniteRunes = new HashSet<>();

		ItemContainer equipment = client.getItemContainer(InventoryID.WORN);
		if (equipment == null)
		{
			return infiniteRunes;
		}

		for (Item item : equipment.getItems())
		{
			int id = item.getId();

			// Air staves
			if (id == Constants.STAFF_OF_AIR || id == Constants.AIR_BATTLESTAFF || id == Constants.MYSTIC_AIR_STAFF ||
				id == Constants.SMOKE_BATTLESTAFF || id == Constants.MYSTIC_SMOKE_STAFF ||
				id == Constants.DUST_BATTLESTAFF || id == Constants.MYSTIC_DUST_STAFF ||
				id == Constants.MIST_BATTLESTAFF || id == Constants.MYSTIC_MIST_STAFF)
			{
				infiniteRunes.add(Constants.AIR_RUNE);
			}

			// Water staves
			if (id == Constants.STAFF_OF_WATER || id == Constants.WATER_BATTLESTAFF || id == Constants.MYSTIC_WATER_STAFF ||
				id == Constants.STEAM_BATTLESTAFF || id == Constants.MYSTIC_STEAM_STAFF ||
				id == Constants.MIST_BATTLESTAFF || id == Constants.MYSTIC_MIST_STAFF ||
				id == Constants.MUD_BATTLESTAFF || id == Constants.MYSTIC_MUD_STAFF)
			{
				infiniteRunes.add(Constants.WATER_RUNE);
			}

			// Earth staves
			if (id == Constants.STAFF_OF_EARTH || id == Constants.EARTH_BATTLESTAFF || id == Constants.MYSTIC_EARTH_STAFF ||
				id == Constants.DUST_BATTLESTAFF || id == Constants.MYSTIC_DUST_STAFF ||
				id == Constants.MUD_BATTLESTAFF || id == Constants.MYSTIC_MUD_STAFF ||
				id == Constants.LAVA_BATTLESTAFF || id == Constants.MYSTIC_LAVA_STAFF)
			{
				infiniteRunes.add(Constants.EARTH_RUNE);
			}

			// Fire staves
			if (id == Constants.STAFF_OF_FIRE || id == Constants.FIRE_BATTLESTAFF || id == Constants.MYSTIC_FIRE_STAFF ||
				id == Constants.SMOKE_BATTLESTAFF || id == Constants.MYSTIC_SMOKE_STAFF ||
				id == Constants.STEAM_BATTLESTAFF || id == Constants.MYSTIC_STEAM_STAFF ||
				id == Constants.LAVA_BATTLESTAFF || id == Constants.MYSTIC_LAVA_STAFF)
			{
				infiniteRunes.add(Constants.FIRE_RUNE);
			}
		}

		return infiniteRunes;
	}

	/**
	 * Build a map of rune type -> count (including combo runes and pouch).
	 */
	private Map<Integer, Integer> buildRuneCountMap(ItemContainer inventory)
	{
		Map<Integer, Integer> runeCounts = new HashMap<>();

		for (Item item : inventory.getItems())
		{
			int id = item.getId();
			int qty = item.getQuantity();

			if (Constants.isBasicRune(id))
			{
				runeCounts.merge(id, qty, (existing, newValue) -> existing == null ? newValue : existing + newValue);
			}

			addCombinationRuneCounts(runeCounts, id, qty);

			if (id == Constants.RUNE_POUCH || id == Constants.RUNE_POUCH_DIVINE)
			{
				addRunePouchCounts(runeCounts);
			}
		}

		return runeCounts;
	}

	/**
	 * Find combination runes in inventory and rune pouch.
	 */
	private Map<Integer, Integer> findCombinationRunes(ItemContainer inventory)
	{
		Map<Integer, Integer> comboRunes = new HashMap<>();

		for (Item item : inventory.getItems())
		{
			int id = item.getId();
			if (Constants.isCombinationRune(id))
			{
				comboRunes.put(id, item.getQuantity());
			}
		}

		// Check rune pouch for combo runes
		for (int i = 0; i < 3; i++)
		{
			int runeId = runeIdFromVarbit(client.getVarbitValue(Constants.RUNE_POUCH_RUNE_VARBITS[i]));
			int amount = client.getVarbitValue(Constants.RUNE_POUCH_AMOUNT_VARBITS[i]);
			if (runeId > 0 && amount > 0 && Constants.isCombinationRune(runeId))
			{
				comboRunes.merge(runeId, amount, (existing, newValue) -> existing == null ? newValue : existing + newValue);
			}
		}

		return comboRunes;
	}

	/**
	 * Add combination rune counts to the rune map (both element types).
	 */
	private void addCombinationRuneCounts(Map<Integer, Integer> runeCounts, int itemId, int quantity)
	{
		switch (itemId)
		{
			case Constants.MIST_RUNE:
				runeCounts.merge(
					Constants.AIR_RUNE, quantity,
					(existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				runeCounts.merge(
					Constants.WATER_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				break;
			case Constants.DUST_RUNE:
				runeCounts.merge(
					Constants.AIR_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				runeCounts.merge(
					Constants.EARTH_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				break;
			case Constants.MUD_RUNE:
				runeCounts.merge(
					Constants.WATER_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				runeCounts.merge(
					Constants.EARTH_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				break;
			case Constants.SMOKE_RUNE:
				runeCounts.merge(
					Constants.AIR_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				runeCounts.merge(
					Constants.FIRE_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				break;
			case Constants.STEAM_RUNE:
				runeCounts.merge(
					Constants.WATER_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				runeCounts.merge(
					Constants.FIRE_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				break;
			case Constants.LAVA_RUNE:
				runeCounts.merge(
					Constants.EARTH_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				runeCounts.merge(
					Constants.FIRE_RUNE,
					quantity, (existing, newValue) -> existing == null ? newValue : existing + newValue
				);
				break;
		}
	}

	/**
	 * Add rune counts from rune pouch to the map.
	 */
	private void addRunePouchCounts(Map<Integer, Integer> runeCounts)
	{
		for (int i = 0; i < 3; i++)
		{
			int runeId = runeIdFromVarbit(client.getVarbitValue(Constants.RUNE_POUCH_RUNE_VARBITS[i]));
			int amount = client.getVarbitValue(Constants.RUNE_POUCH_AMOUNT_VARBITS[i]);

			if (runeId > 0 && amount > 0)
			{
				runeCounts.merge(runeId, amount, (existing, newValue) -> existing == null ? newValue : existing + newValue);
				addCombinationRuneCounts(runeCounts, runeId, amount);
			}
		}
	}

	/**
	 * Convert varbit value to rune item ID.
	 */
	private int runeIdFromVarbit(int varbitValue)
	{
		switch (varbitValue)
		{
			case 1: return Constants.AIR_RUNE;
			case 2: return Constants.WATER_RUNE;
			case 3: return Constants.EARTH_RUNE;
			case 4: return Constants.FIRE_RUNE;
			case 5: return Constants.MIND_RUNE;
			case 6: return Constants.BODY_RUNE;
			case 7: return Constants.DEATH_RUNE;
			case 8: return 561; // Nature rune
			case 9: return Constants.CHAOS_RUNE;
			case 10: return 563; // Law rune
			case 11: return 564; // Cosmic rune
			case 12: return Constants.BLOOD_RUNE;
			case 13: return 566; // Soul rune
			case 14: return 9075; // Astral rune
			case 15: return Constants.MIST_RUNE;
			case 16: return Constants.MUD_RUNE;
			case 17: return Constants.DUST_RUNE;
			case 18: return Constants.LAVA_RUNE;
			case 19: return Constants.STEAM_RUNE;
			case 20: return Constants.SMOKE_RUNE;
			case 21: return Constants.WRATH_RUNE;
			default: return -1;
		}
	}

	/**
	 * Find a combination rune that provides the required element.
	 */
	private int findCombinationRuneFor(int elementRuneId, Set<Integer> availableComboRunes)
	{
		for (int comboId : availableComboRunes)
		{
			if (combinationRuneProvides(comboId, elementRuneId))
			{
				return comboId;
			}
		}
		return -1;
	}

	/**
	 * Check if a combination rune provides a specific element.
	 */
	private boolean combinationRuneProvides(int comboRuneId, int elementRuneId)
	{
		switch (comboRuneId)
		{
			case Constants.MIST_RUNE:
				return elementRuneId == Constants.AIR_RUNE || elementRuneId == Constants.WATER_RUNE;
			case Constants.DUST_RUNE:
				return elementRuneId == Constants.AIR_RUNE || elementRuneId == Constants.EARTH_RUNE;
			case Constants.MUD_RUNE:
				return elementRuneId == Constants.WATER_RUNE || elementRuneId == Constants.EARTH_RUNE;
			case Constants.SMOKE_RUNE:
				return elementRuneId == Constants.AIR_RUNE || elementRuneId == Constants.FIRE_RUNE;
			case Constants.STEAM_RUNE:
				return elementRuneId == Constants.WATER_RUNE || elementRuneId == Constants.FIRE_RUNE;
			case Constants.LAVA_RUNE:
				return elementRuneId == Constants.EARTH_RUNE || elementRuneId == Constants.FIRE_RUNE;
			default:
				return false;
		}
	}

	/**
	 * Deduplicate rune usage list (combo runes providing multiple elements).
	 */
	private List<int[]> deduplicateRuneUsage(List<int[]> runeUsage)
	{
		Map<Integer, Integer> seen = new LinkedHashMap<>();
		for (int[] entry : runeUsage)
		{
			int itemId = entry[0];
			int amount = entry[1];
			if (!seen.containsKey(itemId))
			{
				seen.put(itemId, amount);
			}
		}

		List<int[]> result = new ArrayList<>();
		for (Map.Entry<Integer, Integer> entry : seen.entrySet())
		{
			result.add(new int[]{entry.getKey(), entry.getValue()});
		}
		return result;
	}
}

package xyz.peppie.splashhelper.service;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.reflect.TypeToken;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import xyz.peppie.splashhelper.SplashHelperConfig;
import xyz.peppie.splashhelper.model.PersistedSession;
import xyz.peppie.splashhelper.model.SplashSession;
import xyz.peppie.splashhelper.model.SplashSpell;
import xyz.peppie.splashhelper.util.Constants;

/**
 * Service responsible for managing splash session lifecycle.
 * Handles session creation, updates, finalization, and history.
 */
@Slf4j
@Singleton
public class SessionManager
{
	private final Client client;
	private final RuneCalculator runeCalculator;
	private final ItemManager itemManager;
	private final ConfigManager configManager;
	private final SplashHelperConfig config;
	private final Gson gson;

	@Getter
	private SplashSession currentSession = null;

	@Getter
	private SplashSession lastFinalizedSession = null;

	@Getter
	private final List<SplashSession> sessionHistory = new ArrayList<>();

	private int lastCastTick = -1;
	private int lastMagicXp = -1;

	private static final String SESSION_HISTORY_KEY = "splashhelper_session_history";

	@Inject
	public SessionManager(Client client, RuneCalculator runeCalculator, ItemManager itemManager, ConfigManager configManager, SplashHelperConfig config, Gson gson)
	{
		this.client = client;
		this.runeCalculator = runeCalculator;
		this.itemManager = itemManager;
		this.configManager = configManager;
		this.config = config;
		this.gson = gson.newBuilder()
			.setPrettyPrinting()
			.registerTypeAdapter(Instant.class, new InstantSerializer())
			.registerTypeAdapter(Instant.class, new InstantDeserializer())
			.create();
		
		// Load persisted session history on startup
		loadSessionHistory();
	}

	/**
	 * Start a new splash session.
	 */
	public void startSession(String playerName, SplashSpell spell, Instant logoutTime,
							 int world, boolean stickyKnight)
	{
		int startXp = client.getSkillExperience(Skill.MAGIC);
		lastMagicXp = startXp;
		lastCastTick = client.getTickCount();

		currentSession = new SplashSession(
			playerName,
			spell,
			logoutTime,
			world,
			stickyKnight,
			startXp
		);

		currentSession.setStartingRuneCount(runeCalculator.getRemainingCasts(spell));
		currentSession.setCurrentRuneCount(currentSession.getStartingRuneCount());

		log.debug("Started splash session for {} with spell {}", playerName,
			spell != null ? spell.getName() : "unknown");
	}

	/**
	 * Finalize the current session and add it to history.
	 * Uses rune data already stored in the session (updated continuously while active).
	 */
	public void finalizeSession()
	{
		if (currentSession != null && currentSession.isActive())
		{
			currentSession.setEndTime(Instant.now());
			
			// Finalize derived statistics for persistence
			finalizeDerivedStatistics(currentSession);
			
			sessionHistory.add(currentSession);
			lastFinalizedSession = currentSession;
			
			// Persist session history to storage
			saveSessionHistory();
			
			log.debug("Finalized session: {} casts, {} XP gained, {} gp cost",
				currentSession.getSpellsCast(), currentSession.getMagicXpGained(), currentSession.getRuneCostGp());
		}
		currentSession = null;
		lastMagicXp = -1;
		lastCastTick = -1;
	}

	/**
	 * Check if session should timeout due to inactivity.
	 * @return true if session was timed out
	 */
	public boolean checkSessionTimeout()
	{
		if (currentSession == null || !currentSession.isActive())
		{
			return false;
		}

		if (lastCastTick < 0)
		{
			return false;
		}

		int currentTick = client.getTickCount();
		int ticksSinceLastCast = currentTick - lastCastTick;
		if (ticksSinceLastCast >= Constants.SESSION_TIMEOUT_TICKS)
		{
			log.debug("Session timeout - no cast in {} ticks", ticksSinceLastCast);
			finalizeSession();
			return true;
		}

		return false;
	}

	/**
	 * Record a spell cast based on XP gain.
	 * @param currentXp Current magic XP
	 * @param spell The spell being cast
	 * @return XP gained from this cast, or 0 if no cast detected
	 */
	public int recordCast(int currentXp, SplashSpell spell)
	{
		if (lastMagicXp < 0)
		{
			lastMagicXp = currentXp;
			return 0;
		}

		int xpGained = currentXp - lastMagicXp;
		lastMagicXp = currentXp;

		if (xpGained > 0 && currentSession != null && currentSession.isActive())
		{
			currentSession.incrementSpellsCast();
			currentSession.setCurrentMagicXp(currentXp);

			if (spell != null)
			{
				currentSession.setCurrentRuneCount(runeCalculator.getRemainingCasts(spell));
				
				// Track rune usage for this specific cast
				java.util.List<int[]> runesUsedThisCast = runeCalculator.getActualRuneUsage(spell);
				
				// Create a deep copy to avoid reference issues
				java.util.List<int[]> runesCopy = new java.util.ArrayList<>();
				for (int[] rune : runesUsedThisCast)
				{
					runesCopy.add(new int[]{rune[0], rune[1]});
				}
				
				long costThisCast = calculateRuneCostForUsage(runesCopy);
				currentSession.addRuneUsageForCast(runesCopy, costThisCast);
			}

			lastCastTick = client.getTickCount();
			return xpGained;
		}

		return 0;
	}

	/**
	 * Calculate GP cost for a list of rune usage.
	 */
	private long calculateRuneCostForUsage(java.util.List<int[]> runeUsage)
	{
		if (runeUsage == null || runeUsage.isEmpty())
		{
			return 0;
		}

		long totalCost = 0;
		for (int[] usage : runeUsage)
		{
			int itemId = usage[0];
			int amount = usage[1];
			int price = itemManager.getItemPrice(itemId);
			totalCost += (long) price * amount;
		}
		return totalCost;
	}

	/**
	 * Update session spell if different.
	 */
	public void updateSpell(SplashSpell spell)
	{
		if (currentSession != null && spell != null && currentSession.getSpell() != spell)
		{
			currentSession.setSpell(spell);
		}
	}

	/**
	 * Check if there's an active session.
	 */
	public boolean hasActiveSession()
	{
		return currentSession != null && currentSession.isActive();
	}

	/**
	 * Get the session to display in UI - current if active, otherwise last finalized.
	 */
	public SplashSession getDisplayableSession()
	{
		if (currentSession != null)
		{
			return currentSession;
		}
		return lastFinalizedSession;
	}

	/**
	 * Record a knight movement in the current session.
	 */
	public void recordKnightMovement()
	{
		if (currentSession != null)
		{
			currentSession.setKnightMovements(currentSession.getKnightMovements() + 1);
		}
	}

	/**
	 * Add a pickpocketer to the current session.
	 */
	public void addPickpocketer(String playerName)
	{
		if (currentSession != null && playerName != null)
		{
			currentSession.addPickpocketer(playerName);
		}
	}

	/**
	 * Record a player count sample for the current session.
	 */
	public void recordPlayerCountSample(int count)
	{
		if (currentSession != null)
		{
			currentSession.addPlayerCountSample(count, config.maxPlayerCountSamples());
		}
	}

	/**
	 * Reset all session data.
	 */
	public void reset()
	{
		if (currentSession != null && currentSession.isActive())
		{
			finalizeSession();
		}
		currentSession = null;
		sessionHistory.clear();
		lastMagicXp = -1;
		lastCastTick = -1;
	}

	/**
	 * Get total statistics across all sessions.
	 */
	public SessionStats getTotalStats()
	{
		int totalSessions = sessionHistory.size();
		long totalSeconds = 0;
		int totalCasts = 0;
		int totalXp = 0;

		for (SplashSession session : sessionHistory)
		{
			totalSeconds += session.getSessionDurationSeconds();
			totalCasts += session.getSpellsCast();
			totalXp += session.getMagicXpGained();
		}

		if (currentSession != null && currentSession.isActive())
		{
			totalSessions++;
			totalSeconds += currentSession.getSessionDurationSeconds();
			totalCasts += currentSession.getSpellsCast();
			totalXp += currentSession.getMagicXpGained();
		}

		return new SessionStats(totalSessions, totalSeconds, totalCasts, totalXp);
	}

	/**
	 * Finalize derived statistics for persistence.
	 * Ensures average player count and pickpocketer count are calculated before saving.
	 */
	private void finalizeDerivedStatistics(SplashSession session)
	{
		// The derived statistics are already maintained during the session
		// This method ensures they're finalized if any calculations were missed
		// (they're updated in real-time in the add methods)
		log.debug("Finalized derived statistics for session persistence");
	}

	/**
	 * Save session history to persistent storage.
	 */
	private void saveSessionHistory()
	{
		try
		{
			// Convert sessions to persisted format
			List<PersistedSession> persistedSessions = new ArrayList<>();
			for (SplashSession session : sessionHistory)
			{
				persistedSessions.add(PersistedSession.fromSession(session));
			}

			// Serialize to JSON and save to config
			String json = gson.toJson(persistedSessions);
			configManager.setConfiguration("splashhelper", SESSION_HISTORY_KEY, json);
			
			log.debug("Saved {} sessions to persistent storage", sessionHistory.size());
		}
		catch (Exception e)
		{
			log.error("Failed to save session history", e);
		}
	}

	/**
	 * Load session history from persistent storage.
	 */
	private void loadSessionHistory()
	{
		try
		{
			String json = configManager.getConfiguration("splashhelper", SESSION_HISTORY_KEY);
			if (json == null || json.trim().isEmpty())
			{
				log.debug("No persisted session history found");
				return;
			}

			// Deserialize from JSON
			java.lang.reflect.Type type = new TypeToken<List<PersistedSession>>(){}.getType();
			List<PersistedSession> persistedSessions = gson.fromJson(json, type);

			if (persistedSessions != null)
			{
				// Convert back to regular sessions
				sessionHistory.clear();
				for (PersistedSession persisted : persistedSessions)
				{
					if (persisted.getSession() != null)
					{
						sessionHistory.add(persisted.getSession());
					}
				}

				log.debug("Loaded {} sessions from persistent storage", sessionHistory.size());
			}
		}
		catch (Exception e)
		{
			log.error("Failed to load session history", e);
		}
	}

	/**
	 * Clear all persisted session history.
	 */
	public void clearPersistedHistory()
	{
		sessionHistory.clear();
		configManager.unsetConfiguration("splashhelper", SESSION_HISTORY_KEY);
		log.debug("Cleared persisted session history");
	}

	/**
	 * Delete a specific session from history.
	 */
	public void deleteSession(SplashSession session)
	{
		if (session != null && sessionHistory.remove(session))
		{
			saveSessionHistory();
			log.debug("Deleted session from history: {}", session.getPlayerName());
		}
	}

	/**
	 * Custom serializer for Instant to avoid Java module access issues.
	 */
	private static class InstantSerializer implements JsonSerializer<Instant>
	{
		@Override
		public JsonElement serialize(Instant src, java.lang.reflect.Type typeOfSrc, JsonSerializationContext context)
		{
			return new JsonPrimitive(src.toString());
		}
	}

	/**
	 * Custom deserializer for Instant to avoid Java module access issues.
	 */
	private static class InstantDeserializer implements JsonDeserializer<Instant>
	{
		@Override
		public Instant deserialize(JsonElement json, java.lang.reflect.Type typeOfT, JsonDeserializationContext context)
		{
			return Instant.parse(json.getAsString());
		}
	}

	/**
	 * Simple data class for aggregated session statistics.
	 */
	public static class SessionStats
	{
		public final int sessions;
		public final long totalSeconds;
		public final int totalCasts;
		public final int totalXp;

		public SessionStats(int sessions, long totalSeconds, int totalCasts, int totalXp)
		{
			this.sessions = sessions;
			this.totalSeconds = totalSeconds;
			this.totalCasts = totalCasts;
			this.totalXp = totalXp;
		}
	}
}
package xyz.peppie.splashhelper.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import xyz.peppie.splashhelper.SplashHelperConfig;
import net.runelite.api.coords.WorldPoint;

import java.time.Instant;

/**
 * Service for managing tile-related functionality including boundary tiles, knight tiles, and movement tracking.
 */
@Slf4j
@Singleton
public class TileManager
{
	@Inject
	private SplashHelperConfig config;

	@Inject
	private SessionManager sessionManager;

	@Getter
	private WorldPoint boundaryTile = null;

	@Getter
	private WorldPoint knightTile1 = null;

	@Getter
	private WorldPoint knightTile2 = null;

	// Movement tracking
	private WorldPoint lastNpcPosition = null;
	private int movementCount = 0;
	private Instant trackingStartTime = null;
	@Getter
	private double movementsPerMinute = 0.0;

	// hasEscaped state machine
	@Getter
	private boolean hasEscaped = false;
	private int boundaryTickCounter = 0;
	private static final int BOUNDARY_DEBOUNCE_TICKS = 5;
	private boolean boundaryNotified = false;

	// Current target
	@Getter
	private Actor currentTarget = null;

	/**
	 * Set the boundary tile.
	 */
	public void setBoundaryTile(WorldPoint tile)
	{
		this.boundaryTile = tile;
		boundaryNotified = false;
		log.debug("✓ Boundary tile successfully set to: {}", tile);
	}

	/**
	 * Unset the boundary tile.
	 */
	public void unsetBoundaryTile()
	{
		boundaryTile = null;
		boundaryNotified = false;
		log.debug("✓ Boundary tile unset");
	}

	/**
	 * Set knight tile 1.
	 */
	public void setKnightTile1(WorldPoint tile)
	{
		this.knightTile1 = tile;
		log.debug("✓ Knight Tile 1 successfully set to: {}", tile);
		
		// Initialize tracking if both tiles are set
		if (knightTile1 != null && knightTile2 != null)
		{
			resetMovementTracking();
		}
	}

	/**
	 * Unset knight tile 1.
	 */
	public void unsetKnightTile1()
	{
		knightTile1 = null;
		resetMovementTracking();
		log.debug("✓ Knight Tile 1 unset");
	}

	/**
	 * Set knight tile 2.
	 */
	public void setKnightTile2(WorldPoint tile)
	{
		this.knightTile2 = tile;
		log.debug("✓ Knight Tile 2 successfully set to: {}", tile);
		
		// Initialize tracking if both tiles are set
		if (knightTile1 != null && knightTile2 != null)
		{
			resetMovementTracking();
		}
	}

	/**
	 * Unset knight tile 2.
	 */
	public void unsetKnightTile2()
	{
		knightTile2 = null;
		resetMovementTracking();
		log.debug("✓ Knight Tile 2 unset");
	}

	/**
	 * Set the current target.
	 */
	public void setCurrentTarget(Actor target)
	{
		this.currentTarget = target;
	}

	/**
	 * Reset movement tracking.
	 */
	public void resetMovementTracking()
	{
		lastNpcPosition = null;
		movementCount = 0;
		trackingStartTime = null;
		movementsPerMinute = 0.0;
	}

	/**
	 * Track NPC movement between Knight Tile 1 and Knight Tile 2.
	 */
	public void trackKnightMovement()
	{
		if (knightTile1 != null && knightTile2 != null && currentTarget != null)
		{
			WorldPoint currentPosition = currentTarget.getWorldLocation();
			
			if (currentPosition != null)
			{
				// Check if NPC is on either Knight Tile
				boolean onTile1 = currentPosition.equals(knightTile1);
				boolean onTile2 = currentPosition.equals(knightTile2);
				
				if (onTile1 || onTile2)
				{
					// Initialize tracking on first detection
					if (trackingStartTime == null)
					{
						trackingStartTime = Instant.now();
						lastNpcPosition = currentPosition;
					}
					// Check if NPC moved between tiles
					else if (lastNpcPosition != null && !currentPosition.equals(lastNpcPosition))
					{
						// Only count movements between the two tiles
						boolean wasOnTile1 = lastNpcPosition.equals(knightTile1);
						boolean wasOnTile2 = lastNpcPosition.equals(knightTile2);
						
						if ((wasOnTile1 && onTile2) || (wasOnTile2 && onTile1))
						{
							movementCount++;
							sessionManager.recordKnightMovement();
						}
						
						lastNpcPosition = currentPosition;
					}
					
					// Calculate movements per minute
					if (trackingStartTime != null)
					{
						java.time.Duration trackingDuration = java.time.Duration.between(trackingStartTime, Instant.now());
						double minutes = trackingDuration.toMillis() / 60000.0;
						
						if (minutes > 0)
						{
							movementsPerMinute = movementCount / minutes;
						}
					}
				}
				// Update last position if NPC is on either tile
				if (onTile1 || onTile2)
				{
					lastNpcPosition = currentPosition;
				}
			}
		}
	}

	/**
	 * Update knight position tracking and boundary notifications.
	 * Returns true if boundary notification should be sent.
	 */
	public boolean updateKnightPositionTracking()
	{
		boolean shouldNotifyBoundary = false;
		
		if (currentTarget != null && currentTarget instanceof NPC)
		{
			NPC knight = (NPC) currentTarget;
			WorldPoint knightPos = knight.getWorldLocation();
			
			if (knightPos != null)
			{
				boolean onKnightTile = (knightTile1 != null && knightPos.equals(knightTile1)) ||
									   (knightTile2 != null && knightPos.equals(knightTile2));
				boolean onBoundary = boundaryTile != null && knightPos.equals(boundaryTile);
				
				// hasEscaped state machine
				if (onBoundary)
				{
					if (!hasEscaped)
					{
						hasEscaped = true;
						boundaryTickCounter = 0;
						
						// Send notification only once when entering boundary
						if (!boundaryNotified && config.enableBoundaryNotification())
						{
							shouldNotifyBoundary = true;
							boundaryNotified = true;
						}
					}
					else
					{
						boundaryTickCounter++;
					}
				}
				else if (onKnightTile)
				{
					// Knight returned to original tile
					if (hasEscaped)
					{
						hasEscaped = false;
						boundaryNotified = false;
						boundaryTickCounter = 0;
					}
				}
				else
				{
					// Knight is on some other tile (not boundary, not knight tiles)
					if (hasEscaped)
					{
						boundaryTickCounter++;
						// After 5 ticks on a non-valid tile, allow re-notification
						if (boundaryTickCounter >= BOUNDARY_DEBOUNCE_TICKS)
						{
							boundaryNotified = false;
						}
					}
				}
			}
		}
		
		return shouldNotifyBoundary;
	}

	/**
	 * Reset the hasEscaped state.
	 */
	public void resetEscapedState()
	{
		hasEscaped = false;
		boundaryNotified = false;
		boundaryTickCounter = 0;
	}

	/**
	 * Reset all tile and tracking state.
	 */
	public void reset()
	{
		boundaryTile = null;
		knightTile1 = null;
		knightTile2 = null;
		currentTarget = null;
		boundaryNotified = false;
		lastNpcPosition = null;
		movementCount = 0;
		trackingStartTime = null;
		movementsPerMinute = 0.0;
		hasEscaped = false;
		boundaryTickCounter = 0;
	}
}

package xyz.peppie.splashhelper;

import xyz.peppie.splashhelper.model.TargetNpc;
import xyz.peppie.splashhelper.model.SplashSpell;
import xyz.peppie.splashhelper.model.OverallStatField;
import xyz.peppie.splashhelper.model.SessionStatField;
import java.awt.Color;
import java.awt.event.KeyEvent;
import java.util.EnumSet;
import java.util.Set;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.ModifierlessKeybind;
import net.runelite.client.config.Range;

@ConfigGroup("splashhelper")
public interface SplashHelperConfig extends Config
{
	@ConfigItem(
		keyName = "enableWelcomeMessage",
		name = "Enable Welcome Message",
		description = "Display a welcome message when logging in"
	)
	default boolean enableWelcomeMessage()
	{
		return true;
	}

	@ConfigItem(
		keyName = "targetNpc",
		name = "Target NPC",
		description = "Select the NPC to track for splashing"
	)
	default TargetNpc targetNpc()
	{
		return TargetNpc.KNIGHT_OF_ARDOUGNE;
	}

	@ConfigItem(
		keyName = "timerDuration",
		name = "Timer Duration (minutes)",
		description = "How many minutes the timer should count down"
	)
	default int timerDuration()
	{
		return 15;
	}

	@ConfigItem(
		keyName = "showOverlay",
		name = "Show Timer Overlay",
		description = "Display the timer overlay on screen"
	)
	default boolean showOverlay()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "boundaryTileColor",
		name = "Boundary Tile Color",
		description = "Color of the boundary tile marker"
	)
	default Color boundaryTileColor()
	{
		return new Color(255, 0, 0, 100); // Semi-transparent red
	}

	@Alpha
	@ConfigItem(
		keyName = "knightTile1Color",
		name = "Knight Tile 1 Color",
		description = "Color of the Knight Tile 1 marker"
	)
	default Color knightTile1Color()
	{
		return new Color(0, 255, 0, 255); // Green
	}

	@Alpha
	@ConfigItem(
		keyName = "knightTile2Color",
		name = "Knight Tile 2 Color",
		description = "Color of the Knight Tile 2 marker"
	)
	default Color knightTile2Color()
	{
		return new Color(0, 0, 255, 255); // Blue
	}

	// ==================== Notification Settings ====================

	@ConfigSection(
		name = "Notifications",
		description = "Configure notification behavior",
		position = 10
	)
	String notificationSection = "notifications";

	@ConfigItem(
		keyName = "enableBoundaryNotification",
		name = "Boundary Notification",
		description = "Notify when knight reaches boundary tile",
		section = notificationSection
	)
	default boolean enableBoundaryNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableTimerNotification",
		name = "Timer Notification",
		description = "Notify when splash timer expires",
		section = notificationSection
	)
	default boolean enableTimerNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableHpNotification",
		name = "HP Threshold Notification",
		description = "Notify when HP drops below threshold (only when knight can attack)",
		section = notificationSection
	)
	default boolean enableHpNotification()
	{
		return true;
	}

	@Range(min = 1, max = 99)
	@ConfigItem(
		keyName = "hpThreshold",
		name = "HP Threshold",
		description = "HP level at which to notify (when knight can attack)",
		section = notificationSection
	)
	default int hpThreshold()
	{
		return 10;
	}

	@ConfigItem(
		keyName = "useVisualNotification",
		name = "Visual Notification",
		description = "Use screen tint instead of sound for notifications",
		section = notificationSection
	)
	default boolean useVisualNotification()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "visualNotificationColor",
		name = "Visual Notification Color",
		description = "Color of the screen tint for visual notifications",
		section = notificationSection
	)
	default Color visualNotificationColor()
	{
		return new Color(255, 0, 0, 80); // Semi-transparent red
	}

	@Range(min = 1, max = 30)
	@ConfigItem(
		keyName = "notificationDuration",
		name = "Notification Duration",
		description = "How long notifications are displayed (in seconds)",
		section = notificationSection
	)
	default int notificationDuration()
	{
		return 5;
	}

	// ==================== Statistics Settings ====================

	@ConfigSection(
		name = "Statistics",
		description = "Configure statistics tracking",
		position = 20
	)
	String statisticsSection = "statistics";

	@ConfigItem(
		keyName = "enableStatistics",
		name = "Enable Statistics",
		description = "Track splashing session statistics",
		section = statisticsSection
	)
	default boolean enableStatistics()
	{
		return true;
	}

	@Range(min = 1, max = 60)
	@ConfigItem(
		keyName = "statisticsInterval",
		name = "Tracking Interval (seconds)",
		description = "How often to sample statistics data",
		section = statisticsSection
	)
	default int statisticsInterval()
	{
		return 3;
	}

	@Range(min = 1, max = 20)
	@ConfigItem(
		keyName = "playerCountRadius",
		name = "Player Count Radius",
		description = "Tile radius for counting nearby players",
		section = statisticsSection
	)
	default int playerCountRadius()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "enableGriefPrevention",
		name = "Enable Grief Prevention",
		description = "Show warning overlay if Accept Aid is on or Private Chat is set to All",
		section = statisticsSection
	)
	default boolean enableGriefPrevention()
	{
		return true;
	}

	@ConfigItem(
		keyName = "autoDetectSpell",
		name = "Auto-detect Spell",
		description = "Automatically detect the spell being cast based on XP gained. Disable to use manual selection below.",
		section = statisticsSection,
		position = 10
	)
	default boolean autoDetectSpell()
	{
		return true;
	}

	@ConfigItem(
		keyName = "selectedSpell",
		name = "Splash Spell",
		description = "Select the spell you are using for splashing (only used when auto-detect is disabled)",
		section = statisticsSection,
		position = 11
	)
	default SplashSpell selectedSpell()
	{
		return SplashSpell.FIRE_STRIKE;
	}

	// ==================== Overall Statistics Panel ====================

	@ConfigSection(
		name = "Overall Statistics Panel",
		description = "Configure which fields to show in the overall statistics panel",
		position = 30,
		closedByDefault = true
	)
	String overallStatsSection = "overallStats";

	@ConfigItem(
		keyName = "showOverallStats",
		name = "Show Overall Statistics",
		description = "Enable the overall statistics panel",
		section = overallStatsSection,
		position = 0
	)
	default boolean showOverallStats()
	{
		return true;
	}

	@ConfigItem(
		keyName = "overallStatFields",
		name = "Visible Fields",
		description = "Select which fields to display in the overall statistics panel",
		section = overallStatsSection,
		position = 1
	)
	default Set<OverallStatField> overallStatFields()
	{
		return EnumSet.allOf(OverallStatField.class);
	}

	// ==================== Current Session Panel ====================

	@ConfigSection(
		name = "Current Session Panel",
		description = "Configure which fields to show in the current session panel",
		position = 31,
		closedByDefault = true
	)
	String currentSessionSection = "currentSession";

	@ConfigItem(
		keyName = "showCurrentSession",
		name = "Show Current Session",
		description = "Enable the current session panel",
		section = currentSessionSection,
		position = 0
	)
	default boolean showCurrentSession()
	{
		return true;
	}

	@ConfigItem(
		keyName = "currentSessionFields",
		name = "Visible Fields",
		description = "Select which fields to display in the current session panel",
		section = currentSessionSection,
		position = 1
	)
	default Set<SessionStatField> currentSessionFields()
	{
		return EnumSet.allOf(SessionStatField.class);
	}

	// ==================== Session History Panel ====================

	@ConfigSection(
		name = "Session History Panel",
		description = "Configure which fields to show in the session history panel",
		position = 32,
		closedByDefault = true
	)
	String sessionHistorySection = "sessionHistory";

	@ConfigItem(
		keyName = "showSessionHistory",
		name = "Show Session History",
		description = "Enable the session history panel",
		section = sessionHistorySection,
		position = 0
	)
	default boolean showSessionHistory()
	{
		return true;
	}

	@ConfigItem(
		keyName = "sessionHistoryFields",
		name = "Visible Fields",
		description = "Select which fields to display in the session history panel",
		section = sessionHistorySection,
		position = 1
	)
	default Set<SessionStatField> sessionHistoryFields()
	{
		return EnumSet.allOf(SessionStatField.class);
	}

	@ConfigItem(
		keyName = "maxPlayerCountSamples",
		name = "Max Player Count Samples",
		description = "Maximum number of player count samples to store (prevents memory issues)"
	)
	@Range(
		min = 10,
		max = 1000
	)
	default int maxPlayerCountSamples()
	{
		return 100;
	}

	@ConfigItem(
		keyName = "safetyModeEnabled",
		name = "Safety Mode",
		description = "Enable safety mode to prevent actions that lose knight aggro"
	)
	default boolean safetyModeEnabled()
	{
		return false;
	}

	@ConfigItem(
		keyName = "safetyModeHotkey",
		name = "Safety Mode Hotkey",
		description = "Hotkey to toggle safety mode (default: Numlock *)"
	)
	default ModifierlessKeybind safetyModeHotkey()
	{
		return new ModifierlessKeybind(KeyEvent.VK_MULTIPLY, 0);
	}
}

package xyz.peppie.splashhelper;

import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.List;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.Tile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.StatChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemStats;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.config.ModifierlessKeybind;
import java.awt.event.KeyEvent;

import xyz.peppie.splashhelper.overlays.BoundaryTileOverlay;
import xyz.peppie.splashhelper.overlays.GriefPreventionOverlay;
import xyz.peppie.splashhelper.overlays.MagicBonusWarningOverlay;
import xyz.peppie.splashhelper.overlays.SafetyModeOverlay;
import xyz.peppie.splashhelper.overlays.SplashHelperOverlay;
import xyz.peppie.splashhelper.overlays.VisualNotificationOverlay;
import xyz.peppie.splashhelper.model.SplashSession;
import xyz.peppie.splashhelper.model.SplashSpell;
import xyz.peppie.splashhelper.service.KnightDetector;
import xyz.peppie.splashhelper.service.NotificationService;
import xyz.peppie.splashhelper.service.PlayerTracker;
import xyz.peppie.splashhelper.service.RuneCalculator;
import xyz.peppie.splashhelper.service.SessionManager;
import xyz.peppie.splashhelper.service.TileManager;
import xyz.peppie.splashhelper.ui.SplashStatisticsPanel;
import xyz.peppie.splashhelper.util.Constants;

@Slf4j
@PluginDescriptor(
	name = "Splash Helper",
	description = "A helper plugin for splashing in Old School RuneScape",
	tags = {"combat", "magic", "splashing"}
)
public class SplashHelperPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private SplashHelperConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private SplashHelperOverlay overlay;

	@Inject
	private BoundaryTileOverlay boundaryOverlay;

	@Inject
	private VisualNotificationOverlay visualNotificationOverlay;

	@Inject
	private SafetyModeOverlay safetyModeOverlay;

	@Inject
	private GriefPreventionOverlay griefPreventionOverlay;

	@Inject
	private MagicBonusWarningOverlay magicBonusWarningOverlay;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ItemManager itemManager;

	// Services
	@Inject
	private RuneCalculator runeCalculator;

	@Inject
	private SessionManager sessionManager;

	@Inject
	private KnightDetector knightDetector;

	@Inject
	private PlayerTracker playerTracker;

	@Inject
	private NotificationService notificationService;

	@Inject
	private TileManager tileManager;

	@Inject
	private KeyManager keyManager;
	
	@Inject
	private ClientThread clientThread;

	// Statistics panel
	private SplashStatisticsPanel statisticsPanel;
	private NavigationButton navButton;

	@Getter
	private Instant timerEnd;

	@Getter
	private boolean safetyModeEnabled = false;

	private boolean hasNotified = false;
	
	// Track previous game state for welcome message
	private GameState previousGameState = null;

	// Session tracking delegated to SessionManager service
	private Instant lastStatsSample = null;
	
	// Magic attack bonus tracking
	@Getter
	private boolean hasBadMagicBonus = false;
	private Instant lastBonusWarning = null;

	// Session delegation methods
	public SplashSession getCurrentSession()
	{
		return sessionManager.getCurrentSession();
	}

	/**
	 * Get the session to display in UI - current if active, otherwise last finalized.
	 */
	public SplashSession getDisplayableSession()
	{
		return sessionManager.getDisplayableSession();
	}

	public List<SplashSession> getSessionHistory()
	{
		return sessionManager.getSessionHistory();
	}

	// Tile delegation methods - forward to TileManager
	public WorldPoint getBoundaryTile()
	{
		return tileManager.getBoundaryTile();
	}

	public WorldPoint getKnightTile1()
	{
		return tileManager.getKnightTile1();
	}

	public WorldPoint getKnightTile2()
	{
		return tileManager.getKnightTile2();
	}

	public boolean isHasEscaped()
	{
		return tileManager.isHasEscaped();
	}

	public double getMovementsPerMinute()
	{
		return tileManager.getMovementsPerMinute();
	}

	public Actor getCurrentTarget()
	{
		return tileManager.getCurrentTarget();
	}

	/**
	 * Trigger visual notification overlay.
	 * Called by NotificationService when visual notifications are enabled.
	 */
	public void triggerVisualNotification()
	{
		if (config != null)
		{
			showVisualNotification = true;
			visualNotificationEnd = Instant.now().plusSeconds(config.notificationDuration());
		}
	}

	// Cached values for UI (updated on client thread)
	@Getter
	private volatile int cachedRemainingCasts = 0;
	@Getter
	private volatile java.util.Set<Integer> cachedInfiniteRunes = new java.util.HashSet<>();
	@Getter
	private volatile java.util.List<int[]> cachedActualRuneUsage = new java.util.ArrayList<>();
	@Getter
	private volatile long cachedRuneCost = 0;

	// Player tracking delegated to PlayerTracker service
	public int getCurrentPickpocketerCount()
	{
		SplashSession session = sessionManager.getCurrentSession();
		return session != null ? session.getPickpocketerCount() : 0;
	}

	// Visual notification state
	@Getter
	private boolean showVisualNotification = false;
	private Instant visualNotificationEnd = null;

	@Provides
	SplashHelperConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SplashHelperConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		log.debug("Splash Helper started!");
		overlay.setPlugin(this, tileManager);
		overlayManager.add(overlay);
		
		// Set up visual notification callback
		notificationService.setVisualNotificationCallback(this::triggerVisualNotification);
		overlayManager.add(boundaryOverlay);
		overlayManager.add(visualNotificationOverlay);
		overlayManager.add(griefPreventionOverlay);
		overlayManager.add(magicBonusWarningOverlay);
		overlayManager.add(safetyModeOverlay);

		// Register key listener for safety mode
		keyManager.registerKeyListener(safetyModeKeyListener);
		
		// Load safety mode state from config
		safetyModeEnabled = config.safetyModeEnabled();

		// Create statistics panel
		statisticsPanel = new SplashStatisticsPanel(this, config, itemManager, sessionManager);
		
		final BufferedImage icon = ImageUtil.loadImageResource(SplashHelperPlugin.class, "icon.png");
		
		navButton = NavigationButton.builder()
			.tooltip("Splash Statistics")
			.icon(icon)
			.priority(10)
			.panel(statisticsPanel)
			.build();
		
		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.debug("Splash Helper stopped!");
		overlayManager.remove(overlay);
		overlayManager.remove(boundaryOverlay);
		overlayManager.remove(visualNotificationOverlay);
		overlayManager.remove(griefPreventionOverlay);
		overlayManager.remove(magicBonusWarningOverlay);
		overlayManager.remove(safetyModeOverlay);

		// Unregister key listener
		keyManager.unregisterKeyListener(safetyModeKeyListener);
		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
		}
		
		// Finalize any active session
		sessionManager.finalizeSession();
		
		timerEnd = null;
		hasNotified = false;
		tileManager.reset();
		lastStatsSample = null;
		playerTracker.reset();
		showVisualNotification = false;
		visualNotificationEnd = null;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState currentState = gameStateChanged.getGameState();
		
		// Only show welcome message when actually logging in or hopping worlds
		// (not when teleporting, which also triggers LOGGED_IN)
		if (currentState == GameState.LOGGED_IN)
		{
			if (config.enableWelcomeMessage() && 
				(previousGameState == GameState.LOGIN_SCREEN || 
				 previousGameState == GameState.HOPPING ||
				 previousGameState == GameState.LOGGING_IN))
			{
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Splash Helper is active!", null);
			}
		}
		
		previousGameState = currentState;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("splashhelper"))
		{
			return;
		}

		// Rebuild statistics panel when any statistics panel config changes
		if (event.getKey().startsWith("overallStatFields") ||
			event.getKey().startsWith("currentSessionFields") ||
			event.getKey().startsWith("sessionHistoryFields") ||
			event.getKey().equals("showOverallStats") ||
			event.getKey().equals("showCurrentSession") ||
			event.getKey().equals("showSessionHistory"))
		{
			if (statisticsPanel != null)
			{
				statisticsPanel.rebuildPanels();
				log.debug("Statistics panel rebuilt due to config change: {}", event.getKey());
			}
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		if (event.getSkill() != Skill.MAGIC)
		{
			return;
		}

		if (!sessionManager.hasActiveSession())
		{
			return;
		}

		int currentXp = event.getXp();
		SplashSession session = sessionManager.getCurrentSession();
		
		// Detect or use configured spell
		SplashSpell spell = null;
		if (config.autoDetectSpell())
		{
			// Try to detect from XP - need to calculate gain
			int lastXp = session.getCurrentMagicXp();
			if (lastXp > 0)
			{
				int xpGained = currentXp - lastXp;
				if (xpGained > 0)
				{
					spell = SplashSpell.fromXpDrop(xpGained);
					if (spell != null)
					{
						sessionManager.updateSpell(spell);
						log.debug("Auto-detected spell: {} from {} XP", spell.getName(), xpGained);
					}
				}
			}
			if (spell == null)
			{
				spell = session.getSpell();
			}
		}
		else
		{
			spell = config.selectedSpell();
			sessionManager.updateSpell(spell);
		}

		// Record the cast via SessionManager
		int xpGained = sessionManager.recordCast(currentXp, spell);
		
		if (xpGained > 0)
		{
			// Update panel
			if (statisticsPanel != null)
			{
				statisticsPanel.updatePanel();
			}
			
			log.debug("Spell cast detected: +{} XP, total casts: {}", xpGained, session.getSpellsCast());
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		updateVisualNotificationState();
		checkTimerExpiration();
		checkHpThreshold();

		if (client.getTopLevelWorldView() == null)
		{
			return;
		}

		// Check magic attack bonus
		hasBadMagicBonus = hasBadMagicAttackBonus();

		if (tileManager.updateKnightPositionTracking())
		{
			notificationService.sendBoundaryNotification("Knight reached boundary tile!");
		}
		tileManager.trackKnightMovement();

		updateSessionStatistics();
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		if (event.getTarget() != null && event.getTarget().getName() != null) 
		{
			String sourceName = event.getSource().getName();
			String playerName = client.getLocalPlayer().getName();
			if (sourceName != null && sourceName.equalsIgnoreCase(playerName)) {
				// Session start moved to onAnimationChanged to detect actual spell casting
				// This works for both normal combat and safe-spotting scenarios
			}
		}
	}

	@Subscribe
	public void onActorDeath(ActorDeath event)
	{
		if (event.getActor() == tileManager.getCurrentTarget())
		{
			notificationService.sendNotification("Actor died, resetting timer");
			tileManager.setCurrentTarget(null);
			timerEnd = null;
			hasNotified = false;
		}
	}

	@Subscribe
	@SuppressWarnings("deprecation")
	public void onMenuOpened(MenuOpened event)
	{
		MenuEntry[] entries = event.getMenuEntries();
		
		// Remove "Attack" option from knights if magic bonus is too high
		if (hasBadMagicBonus)
		{
			String configuredNpc = config.targetNpc().getNpcName();
			java.util.List<MenuEntry> filteredEntries = new java.util.ArrayList<>();
			
			for (MenuEntry entry : entries)
			{
				boolean shouldRemove = false;
				
				if (entry.getOption() != null && entry.getOption().equalsIgnoreCase("Attack"))
				{
					String targetName = cleanNpcName(entry.getTarget());
					if (configuredNpc != null && !configuredNpc.isEmpty() && 
						isAllowedNpc(targetName) && targetName.equalsIgnoreCase(configuredNpc))
					{
						shouldRemove = true;
					}
				}
				
				if (!shouldRemove)
				{
					filteredEntries.add(entry);
				}
			}
			
			// Update menu entries if we removed any
			if (filteredEntries.size() < entries.length)
			{
				client.setMenuEntries(filteredEntries.toArray(new MenuEntry[0]));
				entries = client.getMenuEntries();
			}
		}
		
		// Add "Knight Boundary" submenu to tile right-click menu
		
		// Find the first Walk menu entry to get tile coordinates
		for (MenuEntry entry : entries)
		{
			if (entry.getType() == MenuAction.WALK)
			{
				// Create main "Knight Boundary" menu entry
				MenuEntry boundaryMenu = client.createMenuEntry(1)
					.setOption("Knight Boundary")
					.setTarget("")
					.setType(MenuAction.RUNELITE);
				
				// Create submenu
				Menu submenu = boundaryMenu.createSubMenu();
				
				// Add Set/Unset option to submenu
				if (tileManager.getBoundaryTile() == null)
				{
					submenu.createMenuEntry(-1)
						.setOption("Set")
						.setType(MenuAction.RUNELITE)
						.setParam0(entry.getParam0())
						.setParam1(entry.getParam1())
						.onClick(this::onBoundarySetClick);
				}
				else
				{
					submenu.createMenuEntry(-1)
						.setOption("Unset")
						.setType(MenuAction.RUNELITE)
						.setParam0(entry.getParam0())
						.setParam1(entry.getParam1())
						.onClick(this::onBoundaryUnsetClick);
				}
				
				// Add Color option to submenu
				submenu.createMenuEntry(-1)
					.setOption("Color")
					.setType(MenuAction.RUNELITE)
					.setParam0(entry.getParam0())
					.setParam1(entry.getParam1())
					.onClick(this::onBoundaryColorClick);
				
				// Create main "Knight Tile 1" menu entry
				MenuEntry tile1Menu = client.createMenuEntry(2)
					.setOption("Knight Tile 1")
					.setTarget("")
					.setType(MenuAction.RUNELITE);
				
				// Create submenu for Knight Tile 1
				Menu submenu1 = tile1Menu.createSubMenu();
				
				// Add Set/Unset option to submenu
				if (tileManager.getKnightTile1() == null)
				{
					submenu1.createMenuEntry(-1)
						.setOption("Set")
						.setType(MenuAction.RUNELITE)
						.setParam0(entry.getParam0())
						.setParam1(entry.getParam1())
						.onClick(this::onKnightTile1SetClick);
				}
				else
				{
					submenu1.createMenuEntry(-1)
						.setOption("Unset")
						.setType(MenuAction.RUNELITE)
						.setParam0(entry.getParam0())
						.setParam1(entry.getParam1())
						.onClick(this::onKnightTile1UnsetClick);
				}
				
				// Add Color option to submenu
				submenu1.createMenuEntry(-1)
					.setOption("Color")
					.setType(MenuAction.RUNELITE)
					.setParam0(entry.getParam0())
					.setParam1(entry.getParam1())
					.onClick(this::onKnightTile1ColorClick);
				
				// Create main "Knight Tile 2" menu entry
				MenuEntry tile2Menu = client.createMenuEntry(3)
					.setOption("Knight Tile 2")
					.setTarget("")
					.setType(MenuAction.RUNELITE);
				
				// Create submenu for Knight Tile 2
				Menu submenu2 = tile2Menu.createSubMenu();
				
				// Add Set/Unset option to submenu
				if (tileManager.getKnightTile2() == null)
				{
					submenu2.createMenuEntry(-1)
						.setOption("Set")
						.setType(MenuAction.RUNELITE)
						.setParam0(entry.getParam0())
						.setParam1(entry.getParam1())
						.onClick(this::onKnightTile2SetClick);
				}
				else
				{
					submenu2.createMenuEntry(-1)
						.setOption("Unset")
						.setType(MenuAction.RUNELITE)
						.setParam0(entry.getParam0())
						.setParam1(entry.getParam1())
						.onClick(this::onKnightTile2UnsetClick);
				}
				
				// Add Color option to submenu
				submenu2.createMenuEntry(-1)
					.setOption("Color")
					.setType(MenuAction.RUNELITE)
					.setParam0(entry.getParam0())
					.setParam1(entry.getParam1())
					.onClick(this::onKnightTile2ColorClick);
				
				// Only add it once
				break;
			}
		}
	}

	private void onBoundarySetClick(MenuEntry entry)
	{
		if (client.getTopLevelWorldView() == null)
		{
			log.warn("TopLevelWorldView is null, cannot set boundary");
			return;
		}
		
		Tile tile = client.getTopLevelWorldView().getSelectedSceneTile();
		
		if (tile != null)
		{
			WorldPoint location = tile.getWorldLocation();
			tileManager.setBoundaryTile(location);
			log.debug("✓ Boundary tile successfully set to: {}", location);
			notificationService.sendNotification("Boundary tile set at: " + location.getX() + ", " + location.getY());
		}
	}

	private void onBoundaryUnsetClick(MenuEntry entry)
	{
		tileManager.unsetBoundaryTile();
		log.debug("✓ Boundary tile unset");
		notificationService.sendNotification("Boundary tile unset");
	}

	private void onBoundaryColorClick(MenuEntry entry)
	{
		// The color picker is automatically shown by RuneLite's config system
		// when the user changes the boundaryTileColor config item
		notificationService.sendNotification("Change boundary color in the plugin settings");
	}

	private void onKnightTile1SetClick(MenuEntry entry)
	{
		if (client.getTopLevelWorldView() == null)
		{
			log.warn("TopLevelWorldView is null, cannot set Knight Tile 1");
			return;
		}
		
		Tile tile = client.getTopLevelWorldView().getSelectedSceneTile();
		
		if (tile != null)
		{
			WorldPoint location = tile.getWorldLocation();
			tileManager.setKnightTile1(location);
			log.debug("✓ Knight Tile 1 successfully set to: {}", location);
			notificationService.sendNotification("Knight Tile 1 set at: " + location.getX() + ", " + location.getY());
		}
	}

	private void onKnightTile1UnsetClick(MenuEntry entry)
	{
		tileManager.unsetKnightTile1();
		log.debug("✓ Knight Tile 1 unset");
		notificationService.sendNotification("Knight Tile 1 unset");
	}

	private void onKnightTile1ColorClick(MenuEntry entry)
	{
		notificationService.sendNotification("Change Knight Tile 1 color in the plugin settings");
	}

	private void onKnightTile2SetClick(MenuEntry entry)
	{
		if (client.getTopLevelWorldView() == null)
		{
			log.warn("TopLevelWorldView is null, cannot set Knight Tile 2");
			return;
		}
		
		Tile tile = client.getTopLevelWorldView().getSelectedSceneTile();
		
		if (tile != null)
		{
			WorldPoint location = tile.getWorldLocation();
			tileManager.setKnightTile2(location);
			log.debug("✓ Knight Tile 2 successfully set to: {}", location);
			notificationService.sendNotification("Knight Tile 2 set at: " + location.getX() + ", " + location.getY());
		}
	}

	private void onKnightTile2UnsetClick(MenuEntry entry)
	{
		tileManager.unsetKnightTile2();
		log.debug("✓ Knight Tile 2 unset");
		notificationService.sendNotification("Knight Tile 2 unset");
	}

	private void onKnightTile2ColorClick(MenuEntry entry)
	{
		notificationService.sendNotification("Change Knight Tile 2 color in the plugin settings");
	}

	
	/**
	 * Checks if an NPC is allowed to be set as a target.
	 * @param npcName The cleaned NPC name
	 * @return true if the NPC is allowed, false otherwise
	 */
	private boolean isAllowedNpc(String npcName)
	{
		if (npcName == null)
		{
			return false;
		}
		
		// List of allowed NPCs for targeting
		return npcName.equalsIgnoreCase("Knight of Ardougne") ||
			   npcName.equalsIgnoreCase("Rat") ||
			   npcName.equalsIgnoreCase("Guard");
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		// Safety mode action filtering
		if (safetyModeEnabled && shouldBlockAction(event))
		{
			event.consume();
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", 
				"<col=ff0000>Safety Mode: This action is blocked while safety mode is enabled.</col>", null);
			return;
		}

		// When hasEscaped is true and player interacts, mute notifications until knight returns
		if (tileManager.isHasEscaped() && !notificationService.areNotificationsMuted())
		{
			// Any click interaction while escaped mutes notifications
			if (event.getMenuAction() != MenuAction.CANCEL &&
				event.getMenuAction() != MenuAction.WALK)
			{
				notificationService.muteNotifications();
				log.debug("Notifications muted - player interacted while knight escaped");
			}
		}

		// Check if the click is an NPC interaction
		if (event.getMenuAction() != MenuAction.NPC_FIRST_OPTION &&
			event.getMenuAction() != MenuAction.NPC_SECOND_OPTION &&
			event.getMenuAction() != MenuAction.NPC_THIRD_OPTION &&
			event.getMenuAction() != MenuAction.NPC_FOURTH_OPTION &&
			event.getMenuAction() != MenuAction.NPC_FIFTH_OPTION)
		{
			return;
		}

		// Get the NPC that was clicked
		String targetName = cleanNpcName(event.getMenuTarget());

		// Check if this is the NPC we're tracking and if it's allowed
		String configuredNpc = config.targetNpc().getNpcName();
		if (configuredNpc != null && !configuredNpc.isEmpty())
		{
			if (isAllowedNpc(targetName) && targetName.equalsIgnoreCase(configuredNpc))
			{
				// Check if player is trying to attack with bad magic bonus
				String menuOption = event.getMenuOption();
				if (menuOption != null && menuOption.equalsIgnoreCase("Attack") && hasBadMagicBonus)
				{
					// Block the attack action
					event.consume();
					
					// Show warning notification
					Instant now = Instant.now();
					if (lastBonusWarning == null || Duration.between(lastBonusWarning, now).getSeconds() > 5)
					{
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", 
							"<col=ff0000>Warning: Your magic attack bonus is too high for splashing! (Need -64 or lower)</col>", null);
						lastBonusWarning = now;
					}
					return;
				}

				// Only restart timer if session is already active
				// Session start is handled by onInteractingChanged
				if (timerEnd != null && timerEnd.isAfter(Instant.now()))
				{
					// Restart timer if clicking knight during active session
					startTimer();
					log.debug("Timer restarted by clicking knight");
				}
			}
		}
	}

	private void startTimer()
	{
		int durationMinutes = config.timerDuration();
		timerEnd = Instant.now().plus(Duration.ofMinutes(durationMinutes));
		hasNotified = false;
		
		log.debug("Timer started for {} minutes", durationMinutes);
		
		if (config.enableWelcomeMessage())
		{
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", 
				String.format("Timer started: %d minutes", durationMinutes), null);
		}
		
		// Start session when timer starts (player engaged with target)
		if (config.enableStatistics() && !sessionManager.hasActiveSession())
		{
			startSession(config.selectedSpell());
		}
	}

	/**
	 * Cleans an NPC name by removing color tags, level information, and trailing whitespace.
	 * @param npcName The raw NPC name from the game (e.g., "<col=ffffff>Knight of Ardougne (level-46)")
	 * @return The cleaned NPC name (e.g., "Knight of Ardougne")
	 */
	private String cleanNpcName(String npcName)
	{
		if (npcName == null)
		{
			return null;
		}
		
		// Remove color tags like <col=ffffff>
		String cleaned = npcName.replaceAll("<.*?>", "");
		
		// Remove level information like (level-46)
		cleaned = cleaned.replaceAll("\\s*\\([^)]*\\)\\s*$", "");
		
		// Trim any remaining whitespace
		return cleaned.trim();
	}

	/**
	 * Check if the player's magic attack bonus is too high for splashing.
	 * For reliable splashing, magic attack bonus should be -64 or lower.
	 * @return true if magic attack bonus is greater than -64 (too high)
	 */
	private boolean hasBadMagicAttackBonus()
	{
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return false;
		}

		// Get magic attack bonus directly from client
		int magicAttackBonus = client.getBoostedSkillLevel(Skill.MAGIC);
		
		// Actually we need the equipment bonus, not skill level
		// Use the player's combat stats - magic attack is stored in the player's stats
		// For now, we'll check equipment manually
		
		// Get equipment container
		ItemContainer equipment = client.getItemContainer(InterfaceID.INVENTORY);
		if (equipment == null)
		{
			return false;
		}

		magicAttackBonus = 0;

		// Sum up magic attack bonus from all equipment slots
		Item[] items = equipment.getItems();
		for (int i = 0; i < items.length; i++)
		{
			Item item = items[i];
			if (item != null && item.getId() > 0)
			{
				ItemStats itemStats = itemManager.getItemStats(item.getId());
				if (itemStats != null && itemStats.getEquipment() != null)
				{
					magicAttackBonus += itemStats.getEquipment().getAmagic();
				}
			}
		}

		// Return true if bonus is greater than -64 (bad for splashing)
		return magicAttackBonus > -64;
	}

	// ==================== Session Management ====================

	private void startSession(SplashSpell spell)
	{
		// Finalize any existing session first
		sessionManager.finalizeSession();

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return;
		}

		String playerName = localPlayer.getName();
		int world = client.getWorld();
		boolean stickyKnight = isStickyKnight();

		sessionManager.startSession(playerName, spell, timerEnd, world, stickyKnight);

		lastStatsSample = Instant.now();
		
		log.debug("Splash session started for {} using {}", playerName, spell);
	}

	
	private void sampleSessionStatistics()
	{
		SplashSession session = sessionManager.getCurrentSession();
		if (session == null || !session.isActive())
		{
			return;
		}

		// Update magic XP
		session.setCurrentMagicXp(client.getSkillExperience(Skill.MAGIC));

		// Update rune count
		SplashSpell spell = session.getSpell();
		if (spell != null)
		{
			session.setCurrentRuneCount(countLimitingRunes(spell));
		}

		// Count nearby players
		int nearbyPlayers = countNearbyPlayers(config.playerCountRadius());
		sessionManager.recordPlayerCountSample(nearbyPlayers);

		// Add pickpocketers to session from tracker
		for (String pickpocketer : playerTracker.getPickpocketers())
		{
			sessionManager.addPickpocketer(pickpocketer);
		}
	}

	public int countNearbyPlayers(int radius)
	{
		if (client.getTopLevelWorldView() == null || client.getLocalPlayer() == null)
		{
			return 0;
		}

		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		int count = 0;

		for (Player player : client.getTopLevelWorldView().players())
		{
			if (player != null && player != client.getLocalPlayer())
			{
				WorldPoint otherLocation = player.getWorldLocation();
				if (otherLocation != null && playerLocation.distanceTo(otherLocation) <= radius)
				{
					count++;
				}
			}
		}

		return count;
	}

	/**
	 * Get remaining casts for the current spell (from session or config).
	 * Delegates to RuneCalculator service.
	 */
	public int getRemainingCastsForCurrentSpell()
	{
		return runeCalculator.getRemainingCasts(getCurrentSpell());
	}

	/**
	 * Get infinite runes from equipped staves.
	 * Delegates to RuneCalculator service.
	 */
	public java.util.Set<Integer> getInfiniteRunesFromEquipment()
	{
		return runeCalculator.getInfiniteRunesFromEquipment();
	}

	/**
	 * Count limiting runes for a spell.
	 * Delegates to RuneCalculator service.
	 */
	private int countLimitingRunes(SplashSpell spell)
	{
		return runeCalculator.getRemainingCasts(spell);
	}

	/**
	 * Get the current spell from session or config.
	 */
	private SplashSpell getCurrentSpell()
	{
		SplashSession session = sessionManager.getCurrentSession();
		if (session != null && session.getSpell() != null)
		{
			return session.getSpell();
		}
		return config != null ? config.selectedSpell() : null;
	}

	/**
	 * Check if current target is a sticky knight.
	 * Delegates to KnightDetector service.
	 */
	private boolean isStickyKnight()
	{
		return knightDetector.isStickyKnight(tileManager.getCurrentTarget());
	}

	// ==================== Event Handlers ====================

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		Actor actor = event.getActor();

		// Check if local player is casting a spell
		if (actor == client.getLocalPlayer())
		{
			int animationId = actor.getAnimation();
			
			// Common magic casting animation IDs
			boolean isCasting = (animationId >= 711 && animationId <= 717) ||  // Standard spells
							   (animationId >= 1162 && animationId <= 1167) || // Ancient spells
							   (animationId >= 1978 && animationId <= 1993) || // Lunar spells
							   (Constants.isStandardSpellAnimation(animationId));
			
			if (isCasting)
			{
				// Get who the player is currently interacting with
				Actor interactingTarget = client.getLocalPlayer().getInteracting();
				
				if (interactingTarget != null && interactingTarget.getName() != null)
				{
					String targetName = cleanNpcName(interactingTarget.getName());
					String configuredNpc = config.targetNpc().getNpcName();
					
					if (configuredNpc != null && !configuredNpc.isEmpty() &&
						targetName != null && targetName.equalsIgnoreCase(configuredNpc))
					{
						// Check if we already have an active session
						if (timerEnd == null || timerEnd.isBefore(Instant.now()))
						{
							// Start session when player is actually casting spells at the knight
							tileManager.setCurrentTarget(interactingTarget);
							startTimer();
							log.debug("Session started by detecting spell animation on {} (animation: {})", targetName, animationId);
						}
					}
				}
			}
		}

		// Check if a player near the knight is pickpocketing
		if (actor instanceof Player && actor != client.getLocalPlayer())
		{
			Player player = (Player) actor;
			int animationId = player.getAnimation();
			
			// Pickpocket animation ID
			if (animationId == 881)
			{
				// Check if they're near the knight
				if (tileManager.getCurrentTarget() != null)
				{
					WorldPoint playerPos = player.getWorldLocation();
					WorldPoint knightPos = tileManager.getCurrentTarget().getWorldLocation();
					
					if (playerPos != null && knightPos != null && playerPos.distanceTo(knightPos) <= 1)
					{
						String playerName = player.getName();
						if (playerName != null)
						{
							playerTracker.addPickpocketer(playerName);
							sessionManager.addPickpocketer(playerName);
						}
					}
				}
			}
		}
	}

	/**
	 * Update visual notification state when timer expires.
	 */
	private void updateVisualNotificationState()
	{
		if (showVisualNotification && visualNotificationEnd != null)
		{
			if (Instant.now().isAfter(visualNotificationEnd))
			{
				showVisualNotification = false;
				visualNotificationEnd = null;
			}
		}
	}

	/**
	 * Check if timer has expired and send notification.
	 */
	private void checkTimerExpiration()
	{
		if (timerEnd != null && !hasNotified)
		{
			Duration remaining = Duration.between(Instant.now(), timerEnd);
			if (remaining.isNegative() || remaining.isZero())
			{
				notificationService.sendTimerNotification("Splash timer has expired!");
				hasNotified = true;
				log.debug("Timer expired - notification sent");
			}
		}
	}

	/**
	 * Check HP threshold when knight can attack.
	 */
	private void checkHpThreshold()
	{
		if (tileManager.isHasEscaped() && config != null && config.enableHpNotification())
		{
			// Validate client is available
			if (client == null)
			{
				return;
			}
			
			int currentHp = client.getBoostedSkillLevel(Skill.HITPOINTS);
			if (currentHp <= config.hpThreshold())
			{
				notificationService.sendHpNotification("HP is low (" + currentHp + ")! Knight may be attacking you!");
			}
		}
	}

	
	
	/**
	 * Update session statistics and panel.
	 */
	private void updateSessionStatistics()
	{
		if (config != null && config.enableStatistics())
		{
			// Validate sessionManager before using
			if (sessionManager == null)
			{
				return;
			}
			
			// Update cached values on client thread for UI access
			cachedRemainingCasts = getRemainingCastsForCurrentSpell();
			cachedInfiniteRunes = getInfiniteRunesFromEquipment();
			
			Instant now = Instant.now();
			if (sessionManager.hasActiveSession())
			{
				// Get accumulated rune usage from session (tracked per cast)
				SplashSession currentSession = sessionManager.getCurrentSession();
				if (currentSession != null)
				{
					cachedActualRuneUsage = currentSession.getActualRuneUsage();
					cachedRuneCost = currentSession.getRuneCostGp();
				}
				
				// Check for session timeout via service
				if (sessionManager.checkSessionTimeout())
				{
					// Reset timer when session goes idle
					timerEnd = null;
					hasNotified = false;
				}
				else if (lastStatsSample == null || 
					Duration.between(lastStatsSample, now).getSeconds() >= config.statisticsInterval())
				{
					sampleSessionStatistics();
					lastStatsSample = now;
				}
			}
			
			// Update statistics panel
			if (statisticsPanel != null)
			{
				statisticsPanel.updatePanel();
			}
		}
	}

	/**
	 * Check if an action should be blocked in safety mode.
	 */
	private boolean shouldBlockAction(MenuOptionClicked event)
	{
		String option = event.getMenuOption();
		
		// Allowed actions that reset timer - return false (not blocked)
		if (isAllowedAction(event))
		{
			// Reset splash timer for allowed actions
			if (timerEnd != null && timerEnd.isAfter(Instant.now()))
			{
				startTimer();
				log.debug("Timer restarted by allowed action: {}", option);
			}
			return false;
		}
		
		// Block all other actions
		return true;
	}

	/**
	 * Check if an action is allowed in safety mode.
	 */
	private boolean isAllowedAction(MenuOptionClicked event)
	{
		String option = event.getMenuOption();
		MenuAction action = event.getMenuAction();
		
		// Allow clicking the knight (NPC interactions)
		if (action == MenuAction.NPC_FIRST_OPTION ||
			action == MenuAction.NPC_SECOND_OPTION ||
			action == MenuAction.NPC_THIRD_OPTION ||
			action == MenuAction.NPC_FOURTH_OPTION ||
			action == MenuAction.NPC_FIFTH_OPTION)
		{
			String targetName = cleanNpcName(event.getMenuTarget());
			String configuredNpc = config.targetNpc().getNpcName();
			if (configuredNpc != null && !configuredNpc.isEmpty() &&
				targetName != null && targetName.equalsIgnoreCase(configuredNpc))
			{
				return true;
			}
		}
		
		// Allow unequipping items from equipment menu
		if (action == MenuAction.CC_OP && option != null && option.equalsIgnoreCase("Remove"))
		{
			return true;
		}
		
		// Allow clicking "use" menu option
		if (option != null && option.equalsIgnoreCase("Use"))
		{
			return true;
		}
		
		// Allow clicking stackable items in inventory (but only if they're actually stackable)
		if (action == MenuAction.CC_OP)
		{
			ItemContainer inventory = client.getItemContainer(InterfaceID.INVENTORY);
			if (inventory != null)
			{
				Item item = inventory.getItem(event.getParam0());
				if (item != null)
				{
					ItemComposition itemDef = client.getItemDefinition(item.getId());
					if (itemDef != null && itemDef.isStackable())
					{
						return true;
					}
				}
			}
			// If it's an inventory item action but not stackable, it's blocked
			// Don't return false here, let the method continue to check other conditions
		}
		
		// Block all other actions
		return false;
	}

	/**
	 * Toggle safety mode on/off.
	 */
	public void toggleSafetyMode()
	{
		safetyModeEnabled = !safetyModeEnabled;
		log.debug("Safety mode toggled: {}", safetyModeEnabled ? "ON" : "OFF");
		
		// Send notification to user (must be on client thread)
		String message = safetyModeEnabled ? 
			"<col=00ff00>Safety mode ENABLED</col>" : 
			"<col=ff0000>Safety mode DISABLED</col>";
		clientThread.invoke(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", message, null));
	}

	/**
	 * Key listener for safety mode hotkey.
	 */
	private final KeyListener safetyModeKeyListener = new KeyListener()
	{
		@Override
		public void keyTyped(KeyEvent e)
		{
		}

		@Override
		public void keyPressed(KeyEvent e)
		{
			ModifierlessKeybind hotkey = config.safetyModeHotkey();
			if (hotkey.matches(e))
			{
				toggleSafetyMode();
				e.consume();
			}
		}

		@Override
		public void keyReleased(KeyEvent e)
		{
		}
	};

	}

package xyz.peppie.splashhelper.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.Cursor;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.game.ItemManager;
import xyz.peppie.splashhelper.model.SplashSession;
import xyz.peppie.splashhelper.model.SplashSpell;
import xyz.peppie.splashhelper.model.SessionStatField;
import xyz.peppie.splashhelper.SplashHelperConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.QuantityFormatter;
import xyz.peppie.splashhelper.service.SessionManager;

public class SplashSessionHistoryBox extends JPanel
{
	public interface SessionDeleteListener
	{
		void onSessionDeleted(SplashSessionHistoryBox box);
	}

	private static final DateTimeFormatter DAY_FORMAT = DateTimeFormatter.ofPattern("EEE");
	private static final DateTimeFormatter FULL_FORMAT = DateTimeFormatter.ofPattern("EEE HH:mm");

	private final SplashSession session;
	private final SplashHelperConfig config;
	private final SessionManager sessionManager;
	private final SessionDeleteListener deleteListener;
	private final JPanel titlePanel;
	private final JLabel titleLabel;
	private final JPanel contentPanel;
	private final SplashSupplyTrackerBox runeBox;
	private boolean collapsed;

	public SplashSessionHistoryBox(SplashSession session, boolean startCollapsed, ItemManager itemManager, SplashHelperConfig config, SessionManager sessionManager, SessionDeleteListener deleteListener)
	{
		this.session = session;
		this.config = config;
		this.sessionManager = sessionManager;
		this.deleteListener = deleteListener;
		this.collapsed = startCollapsed;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, ColorScheme.DARK_GRAY_COLOR.darker()));

		// Title panel (clickable to collapse/expand)
		titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		titlePanel.setBorder(new EmptyBorder(7, 10, 7, 10));
		titlePanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

		titleLabel = new JLabel();
		titleLabel.setForeground(Color.ORANGE);
		titleLabel.setFont(FontManager.getRunescapeBoldFont());
		titlePanel.add(titleLabel, BorderLayout.WEST);

		// Collapse indicator
		JLabel collapseIndicator = new JLabel();
		collapseIndicator.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		collapseIndicator.setFont(FontManager.getRunescapeSmallFont());
		titlePanel.add(collapseIndicator, BorderLayout.EAST);

		titlePanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					toggleCollapse();
				}
				else if (SwingUtilities.isRightMouseButton(e))
				{
					showContextMenu(e);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				titlePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
			}
		});

		add(titlePanel);

		// Content panel with session details
		contentPanel = new JPanel();
		contentPanel.setLayout(new GridLayout(0, 1, 0, 4));
		contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		contentPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

		// Add stat rows
		// Always show these fields (not configurable)
		addStatRow("Player:", session.getPlayerName() != null ? session.getPlayerName() : "-");
		addStatRow("World:", String.valueOf(session.getWorld()));
		addStatRow("Knight:", session.isStickyKnight() ? "STICKY" : "Normal");
		addStatRow("Time:", formatDuration(session.getSessionDurationSeconds()));
		
		// Conditionally show configurable fields
		if (config.sessionHistoryFields().contains(SessionStatField.SPELL))
			addStatRow("Spell:", session.getSpell() != null ? session.getSpell().getName() : "Unknown");
		if (config.sessionHistoryFields().contains(SessionStatField.CASTS))
			addStatRow("Casts:", String.valueOf(session.getSpellsCast()));
		if (config.sessionHistoryFields().contains(SessionStatField.XP_GAINED))
			addStatRow("XP Gained:", formatNumber(session.getMagicXpGained()));
		if (config.sessionHistoryFields().contains(SessionStatField.XP_PER_HOUR))
			addStatRow("XP/Hour:", formatNumber((int) session.getXpPerHour()) + "/hr");
		if (config.sessionHistoryFields().contains(SessionStatField.RUNE_COST))
			addStatRow("Rune Cost:", formatNumber((int) session.getRuneCostGp()) + " gp");
		if (config.sessionHistoryFields().contains(SessionStatField.NEARBY_PLAYERS))
			addStatRow("Avg Players:", String.format("%.1f", session.getAveragePlayerCount()));
		if (config.sessionHistoryFields().contains(SessionStatField.HIGHEST_PLAYERS))
			addStatRow("Highest Players:", String.valueOf(session.getHighestPlayerCount()));

		add(contentPanel);

		// Rune usage box - use actual rune usage from session (excludes infinite runes)
		runeBox = new SplashSupplyTrackerBox(itemManager, "Runes Used");
		List<int[]> runeUsage = session.getActualRuneUsage();
		if (runeUsage == null || runeUsage.isEmpty())
		{
			// Fallback to spell runes if no actual usage stored (for old sessions)
			runeUsage = getRuneUsageFromSpell(session.getSpell());
		}
		runeBox.buildItems(runeUsage, session.getSpellsCast());
		add(runeBox);

		// Set initial state
		updateTitle();
		contentPanel.setVisible(!collapsed);
		runeBox.setVisible(!collapsed);
	}

	private List<int[]> getRuneUsageFromSpell(SplashSpell spell)
	{
		List<int[]> runeUsage = new ArrayList<>();
		if (spell != null)
		{
			for (SplashSpell.RuneCost cost : spell.getRuneCosts())
			{
				runeUsage.add(new int[]{cost.getItemId(), cost.getAmount()});
			}
		}
		return runeUsage;
	}

	private void toggleCollapse()
	{
		collapsed = !collapsed;
		contentPanel.setVisible(!collapsed);
		runeBox.setVisible(!collapsed);
		updateTitle();
		revalidate();
		repaint();
	}

	public void expand()
	{
		if (collapsed)
		{
			collapsed = false;
			contentPanel.setVisible(true);
			runeBox.setVisible(true);
			updateTitle();
			revalidate();
			repaint();
		}
	}

	public void collapse()
	{
		if (!collapsed)
		{
			collapsed = true;
			contentPanel.setVisible(false);
			runeBox.setVisible(false);
			updateTitle();
			revalidate();
			repaint();
		}
	}

	public boolean isCollapsed()
	{
		return collapsed;
	}

	private void updateTitle()
	{
		if (collapsed)
		{
			// Collapsed: "<day> - <duration> session"
			LocalDateTime start = LocalDateTime.ofInstant(session.getStartTime(), ZoneId.systemDefault());
			String day = start.format(DAY_FORMAT);
			String duration = formatDuration(session.getSessionDurationSeconds());
			titleLabel.setText(day + " - " + duration + " session");
		}
		else
		{
			// Expanded: "<day> <start time> - <day> <end time>"
			LocalDateTime start = LocalDateTime.ofInstant(session.getStartTime(), ZoneId.systemDefault());
			Instant endInstant = session.getEndTime() != null ? session.getEndTime() : Instant.now();
			LocalDateTime end = LocalDateTime.ofInstant(endInstant, ZoneId.systemDefault());
			
			String startStr = start.format(FULL_FORMAT);
			String endStr = end.format(FULL_FORMAT);
			titleLabel.setText(startStr + " - " + endStr);
		}
	}

	private void addStatRow(String labelText, String value)
	{
		JPanel rowPanel = new JPanel(new BorderLayout());
		rowPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JLabel label = new JLabel(labelText);
		label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		label.setFont(FontManager.getRunescapeSmallFont());

		JLabel valueLabel = new JLabel(value);
		valueLabel.setForeground(Color.GRAY);
		valueLabel.setFont(FontManager.getRunescapeSmallFont());

		rowPanel.add(label, BorderLayout.WEST);
		rowPanel.add(valueLabel, BorderLayout.EAST);
		contentPanel.add(rowPanel);
	}

	private String formatDuration(long seconds)
	{
		if (seconds < 60)
		{
			return seconds + "s";
		}
		else if (seconds < 3600)
		{
			return String.format("%d:%02d", seconds / 60, seconds % 60);
		}
		else
		{
			return String.format("%d:%02d:%02d", seconds / 3600, (seconds % 3600) / 60, seconds % 60);
		}
	}

	private String formatNumber(int number)
	{
		return QuantityFormatter.formatNumber(number);
	}

	public SplashSession getSession()
	{
		return session;
	}

	/**
	 * Show context menu with delete option
	 */
	private void showContextMenu(MouseEvent e)
	{
		javax.swing.JPopupMenu contextMenu = new javax.swing.JPopupMenu();
		javax.swing.JMenuItem deleteItem = new javax.swing.JMenuItem("Delete Session");
		
		deleteItem.addActionListener(event -> showDeleteConfirmation());
		contextMenu.add(deleteItem);
		
		contextMenu.show(this, e.getX(), e.getY());
	}

	/**
	 * Show confirmation dialog for deleting session
	 */
	private void showDeleteConfirmation()
	{
		String sessionInfo = String.format("%s - %s session", 
			session.getPlayerName() != null ? session.getPlayerName() : "Unknown",
			formatDuration(session.getSessionDurationSeconds()));
		
		int result = JOptionPane.showConfirmDialog(
			this,
			"Are you sure you want to delete this session?\n\n" + sessionInfo,
			"Delete Session",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE
		);
		
		if (result == JOptionPane.YES_OPTION)
		{
			sessionManager.deleteSession(session);
			// Notify parent to handle removal properly
			if (deleteListener != null)
			{
				deleteListener.onSessionDeleted(this);
			}
		}
	}
}
package xyz.peppie.splashhelper.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import net.runelite.client.game.ItemManager;
import xyz.peppie.splashhelper.model.SplashSession;
import xyz.peppie.splashhelper.model.OverallStatField;
import xyz.peppie.splashhelper.model.SessionStatField;
import xyz.peppie.splashhelper.SplashHelperConfig;
import xyz.peppie.splashhelper.SplashHelperPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import xyz.peppie.splashhelper.service.SessionManager;

public class SplashStatisticsPanel extends PluginPanel implements SplashSessionHistoryBox.SessionDeleteListener
{
    private final SplashHelperPlugin plugin;
    private final SplashHelperConfig config;
    private final ItemManager itemManager;
    private final SessionManager sessionManager;

    // Main layout container
    private final JPanel layoutPanel = new JPanel();
    private final PluginErrorPanel errorPanel = new PluginErrorPanel();

    // Overall statistics
    private final JPanel overallPanel = new JPanel();
    private final JLabel overallSessionsLabel = new JLabel("0");
    private final JLabel overallTimeLabel = new JLabel("0:00");
    private final JLabel overallCastsLabel = new JLabel("0");
    private final JLabel overallXpLabel = new JLabel("0");
    private final JLabel overallCostLabel = new JLabel("0 gp");
    private final JLabel overallRemainingLabel = new JLabel("0");
    private final JLabel overallStatusLabel = new JLabel("-");
    private final JLabel overallPlayerCountLabel = new JLabel("0");
    private final JLabel overallHoursRemainingLabel = new JLabel("0.0h");
    private final JLabel overallPotentialXpLabel = new JLabel("0");
    private final JLabel overallGpPerHourLabel = new JLabel("0 gp/h");
    private final JLabel overallHighestPlayerCountLabel = new JLabel("0");

    // Current session
    private final JPanel currentPanel = new JPanel();
    private final JLabel playerLabel = new JLabel("-");
    private final JLabel spellLabel = new JLabel("-");
    private final JLabel worldLabel = new JLabel("-");
    private final JLabel stickyLabel = new JLabel("-");
    private final JLabel timeLabel = new JLabel("0:00");
    private final JLabel castsLabel = new JLabel("0");
    private final JLabel xpGainedLabel = new JLabel("0");
    private final JLabel xpHourLabel = new JLabel("0");
    private final JLabel runeCostLabel = new JLabel("0 gp");
    private final JLabel playerCountLabel = new JLabel("0");
    private final JLabel highestPlayerCountLabel = new JLabel("0");

    // Supply tracker
    private SplashSupplyTrackerBox supplyBox;

    // Session history
    private final JPanel historyContainer = new JPanel();
    private final List<SplashSessionHistoryBox> historyBoxes = new ArrayList<>();
    private int lastHistorySize = 0;

    public SplashStatisticsPanel(SplashHelperPlugin plugin, SplashHelperConfig config, ItemManager itemManager, SessionManager sessionManager)
    {
        super(true);
        this.plugin = plugin;
        this.config = config;
        this.itemManager = itemManager;
        this.sessionManager = sessionManager;

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        // Create layout panel for wrapping (like LootTrackerPanel)
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));
        add(layoutPanel, BorderLayout.NORTH);

        // Build initial panels
        buildPanels();

        // Add error panel (shown when no data)
        errorPanel.setContent("Splash Statistics", "Start splashing to see statistics.");
        add(errorPanel, BorderLayout.CENTER);
    }

    /**
     * Rebuild all panels to reflect current config settings.
     * Called when config changes to update visibility of fields.
     */
    public void rebuildPanels()
    {
        SwingUtilities.invokeLater(() ->
        {
            // Clear existing panels
            layoutPanel.removeAll();
            overallPanel.removeAll();
            currentPanel.removeAll();
            historyContainer.removeAll();
            historyBoxes.clear();
            lastHistorySize = 0;

            // Rebuild panels with current config
            buildPanels();

            // Restore history if session history panel is enabled
            if (config.showSessionHistory())
            {
                List<SplashSession> history = plugin.getSessionHistory();
                if (history != null && !history.isEmpty())
                {
                    updateHistoryDisplay(history);
                }
            }

            // Refresh display
            revalidate();
            repaint();
        });
    }

    private void buildPanels()
    {
        // Only add panels if they are enabled in config
        if (config.showOverallStats())
        {
            layoutPanel.add(buildOverallPanel());
            layoutPanel.add(javax.swing.Box.createVerticalStrut(10));
        }
        
        if (config.showCurrentSession())
        {
            layoutPanel.add(buildCurrentSessionPanel(itemManager));
            layoutPanel.add(javax.swing.Box.createVerticalStrut(10));
        }
        
        if (config.showSessionHistory())
        {
            layoutPanel.add(buildHistoryPanel());
        }
    }

    private JPanel buildOverallPanel()
    {
        JPanel overallContainer = new JPanel();
        overallContainer.setLayout(new BoxLayout(overallContainer, BoxLayout.Y_AXIS));
        overallContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        overallContainer.setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, ColorScheme.DARK_GRAY_COLOR.darker()));

        JPanel overallTitlePanel = new JPanel(new BorderLayout());
        overallTitlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
        overallTitlePanel.setBorder(new EmptyBorder(7, 10, 7, 10));
        JLabel overallTitle = new JLabel("Overall Statistics");
        overallTitle.setForeground(Color.CYAN);
        overallTitle.setFont(FontManager.getRunescapeBoldFont());
        overallTitlePanel.add(overallTitle, BorderLayout.WEST);
        overallContainer.add(overallTitlePanel);

        overallPanel.setLayout(new GridLayout(0, 1, 0, 4));
        overallPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        overallPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        overallContainer.add(overallPanel);

        // Always show these fields (not configurable)
        addStatRow(overallPanel, "Sessions:", overallSessionsLabel);
        addStatRow(overallPanel, "Total Time:", overallTimeLabel);
        
        // Conditionally show configurable fields
        if (config.overallStatFields().contains(OverallStatField.TOTAL_CASTS))
            addStatRow(overallPanel, "Total Casts:", overallCastsLabel);
        if (config.overallStatFields().contains(OverallStatField.TOTAL_XP))
            addStatRow(overallPanel, "Total XP:", overallXpLabel);
        if (config.overallStatFields().contains(OverallStatField.TOTAL_COST))
            addStatRow(overallPanel, "Total Cost:", overallCostLabel);
        if (config.overallStatFields().contains(OverallStatField.REMAINING_CASTS))
            addStatRow(overallPanel, "Remaining:", overallRemainingLabel);
        if (config.overallStatFields().contains(OverallStatField.HOURS_REMAINING))
            addStatRow(overallPanel, "Hours Remaining:", overallHoursRemainingLabel);
        if (config.overallStatFields().contains(OverallStatField.POTENTIAL_XP))
            addStatRow(overallPanel, "Potential XP:", overallPotentialXpLabel);
        if (config.overallStatFields().contains(OverallStatField.GP_PER_HOUR))
            addStatRow(overallPanel, "GP/Hour:", overallGpPerHourLabel);
        
        // Always show status (not configurable)
        addStatRow(overallPanel, "Status:", overallStatusLabel);
        
        // Conditionally show player count fields
        if (config.overallStatFields().contains(OverallStatField.CURRENT_PLAYERS))
            addStatRow(overallPanel, "Current Players:", overallPlayerCountLabel);
        if (config.overallStatFields().contains(OverallStatField.HIGHEST_PLAYERS))
            addStatRow(overallPanel, "Highest Players:", overallHighestPlayerCountLabel);

        return overallContainer;
    }

    private JPanel buildCurrentSessionPanel(ItemManager itemManager)
    {
        JPanel currentContainer = new JPanel();
        currentContainer.setLayout(new BoxLayout(currentContainer, BoxLayout.Y_AXIS));
        currentContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        currentContainer.setBorder(BorderFactory.createMatteBorder(1, 1, 1, 1, ColorScheme.DARK_GRAY_COLOR.darker()));

        JPanel currentTitlePanel = new JPanel(new BorderLayout());
        currentTitlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
        currentTitlePanel.setBorder(new EmptyBorder(7, 10, 7, 10));
        JLabel currentTitle = new JLabel("Current Session");
        currentTitle.setForeground(Color.ORANGE);
        currentTitle.setFont(FontManager.getRunescapeBoldFont());
        currentTitlePanel.add(currentTitle, BorderLayout.WEST);
        currentContainer.add(currentTitlePanel);

        currentPanel.setLayout(new GridLayout(0, 1, 0, 4));
        currentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        currentPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        currentContainer.add(currentPanel);

        // Always show these fields (not configurable)
        addStatRow(currentPanel, "Player:", playerLabel);
        addStatRow(currentPanel, "World:", worldLabel);
        addStatRow(currentPanel, "Knight:", stickyLabel);
        addStatRow(currentPanel, "Time:", timeLabel);
        
        // Conditionally show configurable fields
        if (config.currentSessionFields().contains(SessionStatField.SPELL))
            addStatRow(currentPanel, "Spell:", spellLabel);
        if (config.currentSessionFields().contains(SessionStatField.CASTS))
            addStatRow(currentPanel, "Casts:", castsLabel);
        if (config.currentSessionFields().contains(SessionStatField.XP_GAINED))
            addStatRow(currentPanel, "XP Gained:", xpGainedLabel);
        if (config.currentSessionFields().contains(SessionStatField.XP_PER_HOUR))
            addStatRow(currentPanel, "XP/Hour:", xpHourLabel);
        if (config.currentSessionFields().contains(SessionStatField.RUNE_COST))
            addStatRow(currentPanel, "Rune Cost:", runeCostLabel);
        if (config.currentSessionFields().contains(SessionStatField.NEARBY_PLAYERS))
            addStatRow(currentPanel, "Nearby Players:", playerCountLabel);
        if (config.currentSessionFields().contains(SessionStatField.HIGHEST_PLAYERS))
            addStatRow(currentPanel, "Highest Players:", highestPlayerCountLabel);

        supplyBox = new SplashSupplyTrackerBox(itemManager, "Runes Used");
        currentContainer.add(supplyBox);

        return currentContainer;
    }

    private JPanel buildHistoryPanel()
    {
        historyContainer.setLayout(new BoxLayout(historyContainer, BoxLayout.Y_AXIS));
        historyContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        return historyContainer;
    }

    private void updateHistoryDisplay(List<SplashSession> history)
    {
        if (history.size() == lastHistorySize)
        {
            return;
        }

        // Clear existing history boxes
        historyContainer.removeAll();
        historyBoxes.clear();

        // Add session boxes in reverse order (newest first)
        for (int i = history.size() - 1; i >= 0; i--)
        {
            SplashSession session = history.get(i);
            // Only the latest session should be expanded, others collapsed
            boolean isLatest = (i == history.size() - 1);
            
            SplashSessionHistoryBox historyBox = new SplashSessionHistoryBox(session, !isLatest, itemManager, config, sessionManager, this);
            historyBoxes.add(historyBox);
            
            // Add to container
            historyContainer.add(historyBox);
            
            // Add spacer between boxes
            if (i > 0)
            {
                historyContainer.add(javax.swing.Box.createVerticalStrut(10));
            }
        }

        lastHistorySize = history.size();
        historyContainer.revalidate();
        historyContainer.repaint();
    }

    private void addStatRow(JPanel panel, String labelText, JLabel valueLabel)
    {
        JPanel rowPanel = new JPanel(new BorderLayout());
        rowPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JLabel label = new JLabel(labelText);
        label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        label.setFont(FontManager.getRunescapeSmallFont());

        valueLabel.setForeground(Color.WHITE);
        valueLabel.setFont(FontManager.getRunescapeSmallFont());

        rowPanel.add(label, BorderLayout.WEST);
        rowPanel.add(valueLabel, BorderLayout.EAST);
        panel.add(rowPanel);
    }

    public void updatePanel()
    {
        if (!config.enableStatistics())
        {
            return;
        }

        SwingUtilities.invokeLater(() -> {
            SplashSession currentSession = plugin.getCurrentSession();
            SplashSession displaySession = plugin.getDisplayableSession();
            java.util.List<SplashSession> history = plugin.getSessionHistory();

            boolean hasActiveSession = currentSession != null && currentSession.isActive();
            boolean hasDisplayableSession = displaySession != null;
            boolean hasHistory = !history.isEmpty();
            boolean hasData = hasActiveSession || hasDisplayableSession || hasHistory;

            if (!hasData)
            {
                errorPanel.setVisible(true);
                return;
            }

            // Show data panel
            layoutPanel.setVisible(true);
            errorPanel.setVisible(false);

            // Calculate totals
            int totalSessions = history.size() + (hasActiveSession ? 1 : 0);
            long totalSeconds = history.stream().mapToLong(SplashSession::getSessionDurationSeconds).sum();
            int totalCasts = history.stream().mapToInt(SplashSession::getSpellsCast).sum();
            int totalXp = history.stream().mapToInt(SplashSession::getMagicXpGained).sum();
            long totalCost = history.stream().mapToLong(SplashSession::getRuneCostGp).sum();

            if (hasActiveSession && currentSession != null)
            {
                totalSeconds += currentSession.getSessionDurationSeconds();
                totalCasts += currentSession.getSpellsCast();
                totalXp += currentSession.getMagicXpGained();
                totalCost += plugin.getCachedRuneCost();  // Current session cost from cache
            }

            // Update overall stats
            overallSessionsLabel.setText(String.valueOf(totalSessions));
            overallTimeLabel.setText(formatDuration(totalSeconds));
            overallCastsLabel.setText(formatNumber(totalCasts));
            overallXpLabel.setText(formatNumber(totalXp));
            overallCostLabel.setText(formatNumber((int) totalCost) + " gp");
            overallCostLabel.setForeground(Color.ORANGE);

            // Update remaining casts (using cached value from client thread)
            int remaining = plugin.getCachedRemainingCasts();
            overallRemainingLabel.setText(String.valueOf(remaining));
            if (remaining > 100)
            {
                overallRemainingLabel.setForeground(Color.GREEN);
            }
            else if (remaining > 20)
            {
                overallRemainingLabel.setForeground(Color.YELLOW);
            }
            else
            {
                overallRemainingLabel.setForeground(Color.RED);
            }

            // Calculate hours remaining (assuming 1 cast per 3 seconds = 1200 casts/hour)
            double hoursRemaining = remaining / 1200.0;
            overallHoursRemainingLabel.setText(String.format("%.1fh", hoursRemaining));
            overallHoursRemainingLabel.setForeground(Color.CYAN);

            // Calculate potential XP (using current session spell XP if available)
            int potentialXp = 0;
            if (hasActiveSession && currentSession != null && currentSession.getSpell() != null)
            {
                potentialXp = (int) (remaining * currentSession.getSpell().getBaseXp());
            }
            overallPotentialXpLabel.setText(formatNumber(potentialXp));
            overallPotentialXpLabel.setForeground(Color.CYAN);

            // Calculate GP per hour
            long gpPerHour = 0;
            if (hasActiveSession && currentSession != null)
            {
                long sessionDuration = currentSession.getSessionDurationSeconds();
                if (sessionDuration > 0)
                {
                    gpPerHour = (currentSession.getRuneCostGp() * 3600) / sessionDuration;
                }
            }
            overallGpPerHourLabel.setText(formatNumber((int) gpPerHour) + " gp/h");
            overallGpPerHourLabel.setForeground(Color.ORANGE);

            // Update highest player count across all sessions
            int highestPlayers = 0;
            for (SplashSession session : history)
            {
                if (session.getHighestPlayerCount() > highestPlayers)
                {
                    highestPlayers = session.getHighestPlayerCount();
                }
            }
            if (hasActiveSession && currentSession != null && currentSession.getHighestPlayerCount() > highestPlayers)
            {
                highestPlayers = currentSession.getHighestPlayerCount();
            }
            overallHighestPlayerCountLabel.setText(String.valueOf(highestPlayers));
            overallHighestPlayerCountLabel.setForeground(Color.CYAN);

            // Update current player count
            int currentPlayerCount = plugin.countNearbyPlayers(config.playerCountRadius());
            overallPlayerCountLabel.setText(String.valueOf(currentPlayerCount));
            overallPlayerCountLabel.setForeground(Color.CYAN);

            // Update status
            if (hasActiveSession)
            {
                if (plugin.isHasEscaped())
                {
                    overallStatusLabel.setText("ESCAPED!");
                    overallStatusLabel.setForeground(Color.RED);
                }
                else
                {
                    overallStatusLabel.setText("Splashing");
                    overallStatusLabel.setForeground(Color.GREEN);
                }
            }
            else
            {
                overallStatusLabel.setText("Idle");
                overallStatusLabel.setForeground(Color.GRAY);
            }

            // Update current session display
            if (hasActiveSession && currentSession != null)
            {
                currentPanel.setVisible(true);
                supplyBox.setVisible(true);

                playerLabel.setText(currentSession.getPlayerName() != null ? currentSession.getPlayerName() : "-");

                if (currentSession.getSpell() != null)
                {
                    spellLabel.setText(currentSession.getSpell().getName());
                    spellLabel.setForeground(Color.YELLOW);
                }
                else
                {
                    spellLabel.setText("Unknown");
                    spellLabel.setForeground(Color.GRAY);
                }

                worldLabel.setText(String.valueOf(currentSession.getWorld()));

                if (currentSession.isStickyKnight())
                {
                    stickyLabel.setText("Sticky");
                    stickyLabel.setForeground(Color.GREEN);
                }
                else
                {
                    stickyLabel.setText("Normal");
                    stickyLabel.setForeground(Color.WHITE);
                }

                timeLabel.setText(formatDuration(currentSession.getSessionDurationSeconds()));
                timeLabel.setForeground(Color.GREEN);

                castsLabel.setText(String.valueOf(currentSession.getSpellsCast()));

                xpGainedLabel.setText(formatNumber(currentSession.getMagicXpGained()));
                xpHourLabel.setText(formatNumber((int) currentSession.getXpPerHour()) + "/hr");
                xpHourLabel.setForeground(Color.CYAN);

                // Update supply box with actual rune usage (combo runes, excludes infinite)
                java.util.List<int[]> actualRuneUsage = plugin.getCachedActualRuneUsage();
                supplyBox.buildItems(actualRuneUsage, currentSession.getSpellsCast());

                // Use cached rune cost (calculated on client thread in plugin)
                long sessionCost = plugin.getCachedRuneCost();
                runeCostLabel.setText(formatNumber((int) sessionCost) + " gp");
                runeCostLabel.setForeground(Color.ORANGE);

                // Update nearby player count
                double avgPlayerCount = currentSession.getAveragePlayerCount();
                playerCountLabel.setText(String.format("%.1f avg", avgPlayerCount));
                playerCountLabel.setForeground(Color.CYAN);

                // Update highest player count
                highestPlayerCountLabel.setText(String.valueOf(currentSession.getHighestPlayerCount()));
                highestPlayerCountLabel.setForeground(Color.CYAN);
            }
            else
            {
                // No active session - reset current session to zeroed values
                currentPanel.setVisible(true);
                supplyBox.setVisible(true);

                playerLabel.setText("-");
                spellLabel.setText("-");
                spellLabel.setForeground(Color.GRAY);
                worldLabel.setText("-");
                stickyLabel.setText("-");
                stickyLabel.setForeground(Color.GRAY);
                timeLabel.setText("0:00");
                timeLabel.setForeground(Color.GRAY);
                castsLabel.setText("0");
                xpGainedLabel.setText("0");
                xpHourLabel.setText("0/hr");
                xpHourLabel.setForeground(Color.GRAY);
                runeCostLabel.setText("0 gp");
                runeCostLabel.setForeground(Color.GRAY);
                playerCountLabel.setText("0");
                playerCountLabel.setForeground(Color.GRAY);
                highestPlayerCountLabel.setText("0");
                highestPlayerCountLabel.setForeground(Color.GRAY);

                // Show empty runes row
                supplyBox.buildItems(new java.util.ArrayList<>(), 0);
            }

            // Update session history
            updateHistoryDisplay(history);

            revalidate();
            repaint();
        });
    }

    private String formatDuration(long seconds)
    {
        long minutes = seconds / 60;
        long hours = minutes / 60;
        if (hours > 0)
        {
            return String.format("%d:%02d:%02d", hours, minutes % 60, seconds % 60);
        }
        return String.format("%d:%02d", minutes, seconds % 60);
    }

    private String formatNumber(int number)
    {
        if (number >= 1000000)
        {
            return String.format("%.1fM", number / 1000000.0);
        }
        else if (number >= 1000)
        {
            return String.format("%.1fK", number / 1000.0);
        }
        return String.valueOf(number);
    }

    @Override
    public void onSessionDeleted(SplashSessionHistoryBox box)
    {
        // Remove the box from our tracking list
        historyBoxes.remove(box);
        
        // Find the index of the box in the container
        int boxIndex = -1;
        for (int i = 0; i < historyContainer.getComponentCount(); i++)
        {
            if (historyContainer.getComponent(i) == box)
            {
                boxIndex = i;
                break;
            }
        }
        
        if (boxIndex >= 0)
        {
            // Remove the box
            historyContainer.remove(box);
            
            // Remove the associated spacer (if it exists)
            // Spacers are added after boxes, so check if there's a spacer at boxIndex + 1
            if (boxIndex < historyContainer.getComponentCount())
            {
                java.awt.Component nextComponent = historyContainer.getComponent(boxIndex);
                if (nextComponent instanceof javax.swing.Box.Filler)
                {
                    historyContainer.remove(nextComponent);
                }
            }
            
            // Refresh the container
            historyContainer.revalidate();
            historyContainer.repaint();
        }
    }
}

package xyz.peppie.splashhelper.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.client.game.ItemManager;
import xyz.peppie.splashhelper.model.SplashSpell;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.QuantityFormatter;

public class SplashSupplyTrackerBox extends JPanel
{
	private static final int ITEMS_PER_ROW = 5;
	private static final int ITEM_SIZE = 36;

	private final JPanel itemContainer = new JPanel();
	private final JLabel titleLabel = new JLabel();
	private final JPanel boxTitle = new JPanel();
	private final ItemManager itemManager;

	public SplashSupplyTrackerBox(ItemManager itemManager, String title)
	{
		this.itemManager = itemManager;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		boxTitle.setLayout(new BorderLayout());
		boxTitle.setBorder(new EmptyBorder(5, 5, 5, 5));
		boxTitle.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		titleLabel.setText(title);
		titleLabel.setFont(FontManager.getRunescapeSmallFont());
		titleLabel.setForeground(Color.WHITE);
		boxTitle.add(titleLabel, BorderLayout.WEST);

		itemContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		itemContainer.setBorder(new EmptyBorder(1, 1, 1, 1));

		add(boxTitle);
		add(itemContainer);
	}

	/**
	 * Build items using actual rune usage data.
	 * @param actualRuneUsage List of int[2] arrays: [itemId, totalAmountUsed] - excludes infinite runes
	 * @param spellsCast Number of spells cast
	 */
	public void buildItems(java.util.List<int[]> actualRuneUsage, int spellsCast)
	{
		setVisible(true);
		itemContainer.removeAll();

		int runeCount = (actualRuneUsage == null) ? 0 : actualRuneUsage.size();

		// Calculate rows needed (minimum 1 row for empty state)
		int rowSize = runeCount == 0 ? 1 : ((runeCount % ITEMS_PER_ROW == 0) ? 0 : 1) + runeCount / ITEMS_PER_ROW;
		itemContainer.setLayout(new GridLayout(rowSize, ITEMS_PER_ROW, 1, 1));
		
		// Set preferred height for item container based on rows (with padding)
		int containerHeight = rowSize * ITEM_SIZE + 8; // 20 for padding (10 top + 10 bottom)
		itemContainer.setPreferredSize(new Dimension(ITEMS_PER_ROW * ITEM_SIZE, containerHeight));
		itemContainer.setMaximumSize(new Dimension(Integer.MAX_VALUE, containerHeight));

		if (actualRuneUsage != null)
		{
			for (int[] runeData : actualRuneUsage)
			{
				int itemId = runeData[0];
				int totalUsed = runeData[1];  // Now using total amount directly
				int amountPerCast = spellsCast > 0 ? totalUsed / spellsCast : 0;  // Calculate per cast for tooltip
				
				JPanel slotContainer = new JPanel();
				slotContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				slotContainer.setLayout(new BorderLayout());
				slotContainer.setPreferredSize(new Dimension(ITEM_SIZE, ITEM_SIZE));

				JLabel imageLabel = new JLabel();
				imageLabel.setVerticalAlignment(SwingConstants.CENTER);
				imageLabel.setHorizontalAlignment(SwingConstants.CENTER);
				imageLabel.setToolTipText(buildRuneTooltip(itemId, totalUsed, amountPerCast));

				AsyncBufferedImage itemImage = itemManager.getImage(itemId, totalUsed, totalUsed > 1);
				itemImage.addTo(imageLabel);

				slotContainer.add(imageLabel, BorderLayout.CENTER);
				itemContainer.add(slotContainer);
			}
		}

		// Fill remaining slots if needed
		int remaining = (rowSize * ITEMS_PER_ROW) - runeCount;
		for (int i = 0; i < remaining; i++)
		{
			JPanel emptySlot = new JPanel();
			emptySlot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			emptySlot.setPreferredSize(new Dimension(ITEM_SIZE, ITEM_SIZE));
			itemContainer.add(emptySlot);
		}

		itemContainer.revalidate();
		itemContainer.repaint();
	}

	private String buildRuneTooltip(int itemId, int totalUsed, int amountPerCast)
	{
		String runeName = getRuneName(itemId);
		return String.format("<html>%s<br>Used: %s (%d per cast)</html>",
			runeName,
			QuantityFormatter.formatNumber(totalUsed),
			amountPerCast);
	}

	private String getRuneName(int itemId)
	{
		switch (itemId)
		{
			case SplashSpell.ItemID.MIND_RUNE: return "Mind rune";
			case SplashSpell.ItemID.WATER_RUNE: return "Water rune";
			case SplashSpell.ItemID.EARTH_RUNE: return "Earth rune";
			case SplashSpell.ItemID.FIRE_RUNE: return "Fire rune";
			case SplashSpell.ItemID.AIR_RUNE: return "Air rune";
			case SplashSpell.ItemID.BODY_RUNE: return "Body rune";
			case SplashSpell.ItemID.CHAOS_RUNE: return "Chaos rune";
			case SplashSpell.ItemID.DEATH_RUNE: return "Death rune";
			case SplashSpell.ItemID.BLOOD_RUNE: return "Blood rune";
			case SplashSpell.ItemID.WRATH_RUNE: return "Wrath rune";
			// Combination runes
			case 4695: return "Mist rune";
			case 4696: return "Dust rune";
			case 4697: return "Smoke rune";
			case 4698: return "Mud rune";
			case 4694: return "Steam rune";
			case 4699: return "Lava rune";
			default: return "Rune";
		}
	}
}

package xyz.peppie.splashhelper.util;

/**
 * Central location for all constant values used throughout the plugin.
 */
public final class Constants
{
	private Constants() {}

	// ==================== Timing Constants ====================
	public static final int SESSION_TIMEOUT_TICKS = 8;  // 8 game ticks (~4.8 seconds)
	public static final int BOUNDARY_DEBOUNCE_TICKS = 5;
	public static final int VISUAL_NOTIFICATION_DURATION_MS = 2000;

	// ==================== Combination Rune IDs ====================
	public static final int MIST_RUNE = 4695;   // Air + Water
	public static final int DUST_RUNE = 4696;   // Air + Earth
	public static final int SMOKE_RUNE = 4697;  // Air + Fire
	public static final int MUD_RUNE = 4698;    // Water + Earth
	public static final int STEAM_RUNE = 4694;  // Water + Fire
	public static final int LAVA_RUNE = 4699;   // Earth + Fire

	// ==================== Spell Cast Animation IDs ===============

	public static final int WIND_STRIKE = 1162;
	public static final int WATER_STRIKE = 11423;
	public static final int EARTH_STRIKE = 11423;
	public static final int FIRE_STRIKE = 11423;

	public static final int WIND_BOLT = 11423;
	public static final int WATER_BOLT = 11423;
	public static final int EARTH_BOLT = 11423;
	public static final int FIRE_BOLT = 11423;

	public static final int WIND_BLAST = 1162;
	public static final int WATER_BLAST = 11423;
	public static final int EARTH_BLAST = 11423;
	public static final int FIRE_BLAST = 11423;

	public static final int WIND_WAVE = 11430;
	public static final int WATER_WAVE = 11430;
	public static final int EARTH_WAVE = 11430;
	public static final int FIRE_WAVE = 11430;

	public static final int WIND_SURGE = 9145;
	public static final int WATER_SURGE = 9145;
	public static final int EARTH_SURGE = 9145;
	public static final int FIRE_SURGE = 9145;

	// ==================== Rune Pouch IDs ====================
	public static final int RUNE_POUCH = 12791;
	public static final int RUNE_POUCH_DIVINE = 27281;

	// ==================== Rune Pouch Varbits ====================
	public static final int[] RUNE_POUCH_RUNE_VARBITS = {29, 1622, 1623};
	public static final int[] RUNE_POUCH_AMOUNT_VARBITS = {1624, 1625, 1626};

	// ==================== Basic Rune IDs ====================
	public static final int AIR_RUNE = 556;
	public static final int WATER_RUNE = 555;
	public static final int EARTH_RUNE = 557;
	public static final int FIRE_RUNE = 554;
	public static final int MIND_RUNE = 558;
	public static final int BODY_RUNE = 559;
	public static final int CHAOS_RUNE = 562;
	public static final int DEATH_RUNE = 560;
	public static final int BLOOD_RUNE = 565;
	public static final int WRATH_RUNE = 21880;

	// ==================== Staff IDs ====================
	// Air staves
	public static final int STAFF_OF_AIR = 1381;
	public static final int AIR_BATTLESTAFF = 1397;
	public static final int MYSTIC_AIR_STAFF = 1405;
	public static final int SMOKE_BATTLESTAFF = 11998;
	public static final int MYSTIC_SMOKE_STAFF = 12000;
	public static final int DUST_BATTLESTAFF = 20736;
	public static final int MYSTIC_DUST_STAFF = 20739;
	public static final int MIST_BATTLESTAFF = 6562;
	public static final int MYSTIC_MIST_STAFF = 6563;

	// Water staves
	public static final int STAFF_OF_WATER = 1383;
	public static final int WATER_BATTLESTAFF = 1395;
	public static final int MYSTIC_WATER_STAFF = 1403;
	public static final int STEAM_BATTLESTAFF = 11787;
	public static final int MYSTIC_STEAM_STAFF = 12795;
	public static final int MUD_BATTLESTAFF = 6564;
	public static final int MYSTIC_MUD_STAFF = 6565;

	// Earth staves
	public static final int STAFF_OF_EARTH = 1385;
	public static final int EARTH_BATTLESTAFF = 1399;
	public static final int MYSTIC_EARTH_STAFF = 1407;
	public static final int LAVA_BATTLESTAFF = 3053;
	public static final int MYSTIC_LAVA_STAFF = 3054;

	// Fire staves
	public static final int STAFF_OF_FIRE = 1387;
	public static final int FIRE_BATTLESTAFF = 1393;
	public static final int MYSTIC_FIRE_STAFF = 1401;

	// ==================== Knight NPC IDs ====================
	// Female (sticky) knight has a smaller clickbox - detected by NPC ID
	// NPC ID 11936 is the female knight variant (sticky)
	// NPC ID 3297 is the male knight variant (normal)
	public static final int FEMALE_KNIGHT_NPC_ID = 11936;
	public static final int MALE_KNIGHT_NPC_ID = 3297;

	// ==================== Animation IDs ====================
	public static final int ANIMATION_MAGIC_COMBAT = 711;
	public static final int ANIMATION_CURSE = 710;
	public static final int ANIMATION_WEAKEN_CONFUSE = 716;
	public static final int ANIMATION_UNKNOWN_MAGIC = 727;
	public static final int ANIMATION_PICKPOCKET = 881;

	// ==================== NPC IDs ====================
	public static final int KNIGHT_OF_ARDOUGNE = 3297;

	// ==================== Utility Methods ====================
	public static boolean isBasicRune(int id)
	{
		return id == AIR_RUNE || id == WATER_RUNE || id == EARTH_RUNE ||
			id == FIRE_RUNE || id == MIND_RUNE || id == BODY_RUNE ||
			id == CHAOS_RUNE || id == DEATH_RUNE || id == BLOOD_RUNE ||
			id == WRATH_RUNE;
	}

	public static boolean isStandardSpellAnimation(int id)
	{
		return
		id == WIND_STRIKE || id == WATER_STRIKE || id == EARTH_STRIKE || id == FIRE_STRIKE || 
		id == WIND_BOLT || id == WATER_BOLT || id == EARTH_BOLT || id == FIRE_BOLT ||
		id == WIND_BLAST || id == WATER_BLAST || id == EARTH_BLAST || id == FIRE_BLAST ||
		id == WIND_WAVE || id == WATER_WAVE || id == EARTH_WAVE || id == FIRE_WAVE || 
		id == WIND_SURGE || id == WATER_SURGE || id == EARTH_SURGE || id == FIRE_SURGE;
	}

	public static boolean isCombinationRune(int id)
	{
		return id == MIST_RUNE || id == DUST_RUNE || id == MUD_RUNE ||
			id == SMOKE_RUNE || id == STEAM_RUNE || id == LAVA_RUNE;
	}

	public static String getRuneName(int itemId)
	{
		switch (itemId)
		{
			case MIND_RUNE: return "Mind rune";
			case WATER_RUNE: return "Water rune";
			case EARTH_RUNE: return "Earth rune";
			case FIRE_RUNE: return "Fire rune";
			case AIR_RUNE: return "Air rune";
			case BODY_RUNE: return "Body rune";
			case CHAOS_RUNE: return "Chaos rune";
			case DEATH_RUNE: return "Death rune";
			case BLOOD_RUNE: return "Blood rune";
			case WRATH_RUNE: return "Wrath rune";
			case MIST_RUNE: return "Mist rune";
			case DUST_RUNE: return "Dust rune";
			case SMOKE_RUNE: return "Smoke rune";
			case MUD_RUNE: return "Mud rune";
			case STEAM_RUNE: return "Steam rune";
			case LAVA_RUNE: return "Lava rune";
			default: return "Rune";
		}
	}
}

package xyz.peppie.splashhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SplashHelperPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SplashHelperPlugin.class);
		RuneLite.main(args);
	}
}

