/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.betternpchighlight;

import java.util.Collections;
import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(BetterNpcHighlightConfig.CONFIG_GROUP)
public interface BetterNpcHighlightConfig extends Config
{
	String CONFIG_GROUP = "BetterNpcHighlight";

	@Deprecated
	@ConfigItem(
		position = -1,
		keyName = "tagStyleMode",
		name = "Tag Style",
		description = "Sets which highlight style list the NPC tagged is added too",
		hidden = true)
	default tagStyleMode tagStyleMode()
	{
		return null;
	}

	@ConfigSection(
		name = "Global Settings",
		description = "Settings that apply across multiple highlight types",
		position = 0,
		closedByDefault = false
	)
	String globalTagSection = "globalTagStyle";

	@ConfigSection(
		name = "Tile",
		description = "Tile Plugins",
		position = 1,
		closedByDefault = true
	)
	String tileSection = "tile";

	@ConfigSection(
		name = "True Tile",
		description = "True Tile Plugins",
		position = 2,
		closedByDefault = true
	)
	String trueTileSection = "trueTile";

	@ConfigSection(
		name = "South West Tile",
		description = "South West Tile Plugins",
		position = 3,
		closedByDefault = true
	)
	String swTileSection = "swTile";

	@ConfigSection(
		name = "South West True Tile",
		description = "South West True Tile Plugins",
		position = 4,
		closedByDefault = true
	)
	String swTrueTileSection = "swTrueTile";

	@ConfigSection(
		name = "Hull",
		description = "Hull Plugins",
		position = 5,
		closedByDefault = true
	)
	String hullSection = "hull";

	@ConfigSection(
		name = "Area",
		description = "Area Plugins",
		position = 6,
		closedByDefault = true
	)
	String areaSection = "area";

	@ConfigSection(
		name = "Outline",
		description = "Outline Plugins",
		position = 7,
		closedByDefault = true
	)
	String outlineSection = "outline";

	@ConfigSection(
		name = "Clickbox",
		description = "Clickbox Plugins",
		position = 8,
		closedByDefault = true
	)
	String clickboxSection = "clickbox";

	@ConfigSection(
		name = "TURBO MODE",
		description = "Full send",
		position = 9,
		closedByDefault = true
	)
	String turboSection = "turbo";

	@ConfigSection(
		name = "Slayer",
		description = "Slayer Plugins",
		position = 10,
		closedByDefault = true
	)
	String slayerSection = "slayer";

	@ConfigSection(
		name = "Entity Hider",
		description = "Entity Hider Plugins",
		position = 11,
		closedByDefault = true
	)
	String entityHiderSection = "entityHider";

	@ConfigSection(
		name = "Presets",
		description = "Presets Plugins",
		position = 12,
		closedByDefault = true
	)
	String presetsSection = "presets";

	@ConfigSection(
		name = "Instructions",
		description = "Instructions for various features",
		position = 13,
		closedByDefault = true
	)
	String instructionsSection = "instructions";

		@ConfigSection(
		name = "Miscellaneous",
		description = "Miscellaneous Settings",
		position = 14,
		closedByDefault = true
	)
	String miscellaneousSection = "miscellaneous";

	//------------------------------------------------------------//
	// Global tag style section
	//------------------------------------------------------------//
	public static final Set<tagStyleMode> defaultTagStyle = Set.of(tagStyleMode.TILE);
	@ConfigItem(
		position = 0,
		keyName = "tagStyleModeSet",
		name = "Tag Style",
		description = "Sets which highlight styles to apply to an NPC when tagged from the right click menu. Select none to hide the right click menu option.",
		section = globalTagSection
	)
	default Set<tagStyleMode> tagStyleModeSet()
	{
		return defaultTagStyle;
	}

	@ConfigItem(
		position = 1,
		keyName = "useGlobalTileColor",
		name = "Use Global Tile Color",
		description = "Forces tile, true tile, SW tile, and SW true tile to use the same colors. Will not override highlights using a preset.",
		section = globalTagSection
	)
	default boolean useGlobalTileColor()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		position = 2,
		keyName = "globalTileColor",
		name = "Global Tile Color",
		description = "Overrides all other tag style outlines.",
		section = globalTagSection
	)
	default Color globalTileColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 3,
		keyName = "globalFillColor",
		name = "Global Fill Color",
		description = "Overrides all other tag style fill colors.",
		section = globalTagSection
	)
	default Color globalFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	//------------------------------------------------------------//
	// Tile Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "tileHighlight",
		name = "Tile Highlight",
		description = "Highlights NPCs by tile",
		section = tileSection
	)
	default boolean tileHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "tileNames",
		name = "Tile Names",
		description = "List of NPCs to highlight by tile",
		section = tileSection
	)
	default String tileNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "tileNames",
		name = "",
		description = ""
	)
	void setTileNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "tileIds",
		name = "Tile IDs",
		description = "List of NPCs to highlight by tile",
		section = tileSection
	)
	default String tileIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "tileIds",
		name = "",
		description = ""
	)
	void setTileIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "tileColor",
		name = "Highlight Color",
		description = "Sets color of NPC tile highlights",
		section = tileSection
	)
	default Color tileColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "tileFillColor",
		name = "Fill Color",
		description = "Sets the fill color of npc highlights",
		section = tileSection
	)
	default Color tileFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	@Range(min = 0, max = 50)
	@ConfigItem(
		position = 6,
		keyName = "tileWidth",
		name = "Highlight Width",
		description = "Sets the width of npc highlights",
		section = tileSection
	)
	default double tileWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 7,
		keyName = "tileAA",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for tile overlays. Makes them smoother.",
		section = tileSection
	)
	default boolean tileAA()
	{
		return true;
	}

	@ConfigItem(
		position = 8,
		keyName = "tileRave",
		name = "Enable Rave Mode",
		description = "Sets all tile overlays to Rave Mode",
		section = tileSection
	)
	default boolean tileRave()
	{
		return false;
	}

	@ConfigItem(
		position = 9,
		keyName = "tileRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = tileSection
	)
	@Units(Units.MILLISECONDS)
	default int tileRaveSpeed()
	{
		return 6000;
	}

	@ConfigItem(
		position = 10,
		keyName = "tileLines",
		name = "Tile Line Type",
		description = "Sets the tile outline to regular, dashed, or corners only",
		section = tileSection
	)
	default lineType tileLines()
	{
		return lineType.REG;
	}

	//------------------------------------------------------------//
	// True Tile Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "trueTileHighlight",
		name = "True Tile Highlight",
		description = "Highlights npc's true tile",
		section = trueTileSection
	)
	default boolean trueTileHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "trueTileNames",
		name = "True Tile Names",
		description = "List of npc's to highlight true tile",
		section = trueTileSection
	)
	default String trueTileNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "trueTileNames",
		name = "",
		description = ""
	)
	void setTrueTileNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "trueTileIds",
		name = "True Tile IDs",
		description = "List of npc's to highlight true tile",
		section = trueTileSection
	)
	default String trueTileIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "trueTileIds",
		name = "",
		description = ""
	)
	void setTrueTileIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "trueTileColor",
		name = "Highlight Color",
		description = "Sets color of npc highlights",
		section = trueTileSection
	)
	default Color trueTileColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "trueTileFillColor",
		name = "Fill Color",
		description = "Sets the fill color of npc highlights",
		section = trueTileSection
	)
	default Color trueTileFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	@Range(min = 0, max = 50)
	@ConfigItem(
		position = 6,
		keyName = "trueTileWidth",
		name = "Highlight Width",
		description = "Sets the width of npc highlights",
		section = trueTileSection
	)
	default double trueTileWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 7,
		keyName = "trueTileAA",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for true tile overlays. Makes them smoother.",
		section = trueTileSection
	)
	default boolean trueTileAA()
	{
		return true;
	}

	@ConfigItem(
		position = 8,
		keyName = "trueTileRave",
		name = "Enable Rave Mode",
		description = "Sets all true tile overlays to Rave Mode",
		section = trueTileSection
	)
	default boolean trueTileRave()
	{
		return false;
	}

	@ConfigItem(
		position = 9,
		keyName = "trueTileRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = trueTileSection
	)
	@Units(Units.MILLISECONDS)
	default int trueTileRaveSpeed()
	{
		return 6000;
	}

	@ConfigItem(
		position = 10,
		keyName = "trueTileLines",
		name = "True Tile Line Type",
		description = "Sets the true tile outline to regular, dashed, or corners only",
		section = trueTileSection
	)
	default lineType trueTileLines()
	{
		return lineType.REG;
	}

	//------------------------------------------------------------//
	// SW Tile Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "swTileHighlight",
		name = "South West Tile Highlight",
		description = "Highlights npc's south west tile",
		section = swTileSection
	)
	default boolean swTileHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "swTileNames",
		name = "South West Tile Names",
		description = "List of npc's to highlight south west tile",
		section = swTileSection
	)
	default String swTileNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "swTileNames",
		name = "",
		description = ""
	)
	void setSwTileNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "swTileIds",
		name = "South West Tile IDs",
		description = "List of npc's to highlight south west tile",
		section = swTileSection
	)
	default String swTileIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "swTileIds",
		name = "",
		description = ""
	)
	void setSwTileIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "swTileColor",
		name = "Highlight Color",
		description = "Sets color of npc highlights",
		section = swTileSection
	)
	default Color swTileColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "swTileFillColor",
		name = "Fill Color",
		description = "Sets the fill color of npc highlights",
		section = swTileSection
	)
	default Color swTileFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	@Range(min = 0, max = 50)
	@ConfigItem(
		position = 6,
		keyName = "swTileWidth",
		name = "Highlight Width",
		description = "Sets the width of npc highlights",
		section = swTileSection
	)
	default double swTileWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 7,
		keyName = "swTileAA",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for the sw tile overlays. Makes them smoother.",
		section = swTileSection
	)
	default boolean swTileAA()
	{
		return true;
	}

	@ConfigItem(
		position = 8,
		keyName = "swTileRave",
		name = "Enable Rave Mode",
		description = "Sets all sw tile overlays to Rave Mode",
		section = swTileSection
	)
	default boolean swTileRave()
	{
		return false;
	}

	@ConfigItem(
		position = 9,
		keyName = "swTileRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = swTileSection
	)
	@Units(Units.MILLISECONDS)
	default int swTileRaveSpeed()
	{
		return 6000;
	}

	@ConfigItem(
		position = 10,
		keyName = "swTileLines",
		name = "South West Tile Line Type",
		description = "Sets the sw tile outline to regular, dashed, or corners only",
		section = swTileSection
	)
	default lineType swTileLines()
	{
		return lineType.REG;
	}

	//------------------------------------------------------------//
	// SW True Tile Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "swTrueTileHighlight",
		name = "South West True Tile Highlight",
		description = "Enables highlighting NPCs by their south west true tile",
		section = swTrueTileSection
	)
	default boolean swTrueTileHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "swTrueTileNames",
		name = "South West True Tile Names",
		description = "List of NPCs to highlight by their south west true tile",
		section = swTrueTileSection
	)
	default String swTrueTileNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "swTrueTileNames",
		name = "",
		description = ""
	)
	void setSwTrueTileNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "swTrueTileIds",
		name = "South West True Tile IDs",
		description = "List of NPCs to highlight by their south west true tile",
		section = swTrueTileSection
	)
	default String swTrueTileIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "swTrueTileIds",
		name = "",
		description = ""
	)
	void setSwTrueTileIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "swTrueTileColor",
		name = "Highlight Color",
		description = "Sets color of npc highlights",
		section = swTrueTileSection
	)
	default Color swTrueTileColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "swTrueTileFillColor",
		name = "Fill Color",
		description = "Sets the fill color of npc highlights",
		section = swTrueTileSection
	)
	default Color swTrueTileFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	@Range(min = 0, max = 50)
	@ConfigItem(
		position = 6,
		keyName = "swTrueTileWidth",
		name = "Highlight Width",
		description = "Sets the width of npc highlights",
		section = swTrueTileSection
	)
	default double swTrueTileWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 7,
		keyName = "swTrueTileAA",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for the sw true tile overlays. Makes them smoother.",
		section = swTrueTileSection
	)
	default boolean swTrueTileAA()
	{
		return true;
	}

	@ConfigItem(
		position = 8,
		keyName = "swTrueTileRave",
		name = "Enable Rave Mode",
		description = "Sets all sw true tile overlays to Rave Mode",
		section = swTrueTileSection
	)
	default boolean swTrueTileRave()
	{
		return false;
	}

	@ConfigItem(
		position = 9,
		keyName = "swTrueTileRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = swTrueTileSection
	)
	@Units(Units.MILLISECONDS)
	default int swTrueTileRaveSpeed()
	{
		return 6000;
	}

	@ConfigItem(
		position = 10,
		keyName = "swTrueTileLines",
		name = "South West True Tile Line Type",
		description = "Sets the sw true tile outline to regular, dashed, or corners only",
		section = swTrueTileSection
	)
	default lineType swTrueTileLines()
	{
		return lineType.REG;
	}

	//------------------------------------------------------------//
	// Hull Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "hullHighlight",
		name = "Hull Highlight",
		description = "Highlight npc's hull",
		section = hullSection
	)
	default boolean hullHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "hullNames",
		name = "Hull Names",
		description = "List of npc's to highlight hull",
		section = hullSection
	)
	default String hullNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "hullNames",
		name = "",
		description = ""
	)
	void setHullNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "hullIds",
		name = "Hull IDs",
		description = "List of npc's to highlight hull",
		section = hullSection
	)
	default String hullIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "hullIds",
		name = "",
		description = ""
	)
	void setHullIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "hullColor",
		name = "Highlight Color",
		description = "Sets color of npc highlights",
		section = hullSection
	)
	default Color hullColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "hullFillColor",
		name = "Fill Color",
		description = "Sets the fill color of npc highlights",
		section = hullSection
	)
	default Color hullFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	@Range(min = 0, max = 50)
	@ConfigItem(
		position = 6,
		keyName = "hullWidth",
		name = "Highlight Width",
		description = "Sets the width of npc highlights",
		section = hullSection
	)
	default double hullWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 7,
		keyName = "hullAA",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for hull overlays. Makes them smoother.",
		section = hullSection
	)
	default boolean hullAA()
	{
		return true;
	}

	@ConfigItem(
		position = 8,
		keyName = "hullRave",
		name = "Enable Rave Mode",
		description = "Sets all hull overlays to Rave Mode",
		section = hullSection
	)
	default boolean hullRave()
	{
		return false;
	}

	@ConfigItem(
		position = 9,
		keyName = "hullRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = hullSection
	)
	@Units(Units.MILLISECONDS)
	default int hullRaveSpeed()
	{
		return 6000;
	}

	//------------------------------------------------------------//
	// Area Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "areaHighlight",
		name = "Area Highlight",
		description = "Highlights npc's area",
		section = areaSection
	)
	default boolean areaHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "areaNames",
		name = "Area Names",
		description = "List of npc's to highlight area",
		section = areaSection
	)
	default String areaNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "areaNames",
		name = "",
		description = ""
	)
	void setAreaNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "areaIds",
		name = "Area IDs",
		description = "List of npc's to highlight area",
		section = areaSection
	)
	default String areaIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "areaIds",
		name = "",
		description = ""
	)
	void setAreaIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "areaColor",
		name = "Highlight Color",
		description = "Sets color of npc highlights",
		section = areaSection
	)
	default Color areaColor()
	{
		return new Color(0, 255, 255, 50);
	}

	@ConfigItem(
		position = 5,
		keyName = "areaRave",
		name = "Enable Rave Mode",
		description = "Sets all area overlays to Rave Mode",
		section = areaSection
	)
	default boolean areaRave()
	{
		return false;
	}

	@ConfigItem(
		position = 6,
		keyName = "areaRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = areaSection
	)
	@Units(Units.MILLISECONDS)
	default int areaRaveSpeed()
	{
		return 6000;
	}

	//------------------------------------------------------------//
	// Outline Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "outlineHighlight",
		name = "Outline Highlight",
		description = "Highlights npc's outline",
		section = outlineSection
	)
	default boolean outlineHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "outlineNames",
		name = "Outline Names",
		description = "List of npc's to highlight outline",
		section = outlineSection
	)
	default String outlineNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "outlineNames",
		name = "",
		description = ""
	)
	void setOutlineNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "outlineIds",
		name = "Outline IDs",
		description = "List of npc's to highlight outline",
		section = outlineSection
	)
	default String outlineIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "outlineIds",
		name = "",
		description = ""
	)
	void setOutlineIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "outlineColor",
		name = "Highlight Color",
		description = "Sets color of npc highlights",
		section = outlineSection
	)
	default Color outlineColor()
	{
		return Color.CYAN;
	}

	@Range(min = 0, max = 50)
	@ConfigItem(
		position = 5,
		keyName = "outlineWidth",
		name = "Outline Width",
		description = "Sets the width of outline highlights",
		section = outlineSection
	)
	default int outlineWidth()
	{
		return 2;
	}

	@Range(min = 0, max = 5)
	@ConfigItem(
		position = 6,
		keyName = "outlineFeather",
		name = "Outline Feather",
		description = "Sets the feather of the outline highlights",
		section = outlineSection
	)
	default int outlineFeather()
	{
		return 2;
	}

	@ConfigItem(
		position = 7,
		keyName = "outlineRave",
		name = "Enable Rave Mode",
		description = "Sets all outline overlays to Rave Mode",
		section = outlineSection
	)
	default boolean outlineRave()
	{
		return false;
	}

	@ConfigItem(
		position = 8,
		keyName = "outlineRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = outlineSection
	)
	@Units(Units.MILLISECONDS)
	default int outlineRaveSpeed()
	{
		return 6000;
	}

	//------------------------------------------------------------//
	// Clickbox Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "clickboxHighlight",
		name = "Clickbox Highlight",
		description = "Highlights NPCs by clickbox",
		section = clickboxSection
	)
	default boolean clickboxHighlight()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "clickboxNames",
		name = "Clickbox Names",
		description = "List of NPCs to highlight by clickbox",
		section = clickboxSection
	)
	default String clickboxNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "clickboxNames",
		name = "",
		description = ""
	)
	void setClickboxNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "clickboxIds",
		name = "Clickbox IDs",
		description = "List of NPCs to highlight by clickbox",
		section = clickboxSection
	)
	default String clickboxIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "clickboxIds",
		name = "",
		description = ""
	)
	void setClickboxIds(String ids);

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "clickboxColor",
		name = "Highlight Color",
		description = "Sets color of NPC clickbox highlights",
		section = clickboxSection
	)
	default Color clickboxColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "clickboxFillColor",
		name = "Fill Color",
		description = "Sets the fill color of NPC clickbox highlights",
		section = clickboxSection
	)
	default Color clickboxFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	@ConfigItem(
		position = 6,
		keyName = "clickboxAA",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for the clickboxes. Makes them smoother.",
		section = clickboxSection
	)
	default boolean clickboxAA()
	{
		return true;
	}

	@ConfigItem(
		position = 7,
		keyName = "clickboxRave",
		name = "Enable Rave Mode",
		description = "Sets all clickbox overlays to Rave Mode",
		section = clickboxSection
	)
	default boolean clickboxRave()
	{
		return false;
	}

	@ConfigItem(
		position = 8,
		keyName = "clickboxRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = clickboxSection
	)
	@Units(Units.MILLISECONDS)
	default int clickboxRaveSpeed()
	{
		return 6000;
	}

	//------------------------------------------------------------//
	// Turbo Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 0,
		name = "—————— Epilepsy Warning ——————",
		keyName = "epilepsyWarning",
		description = "A warning message will pop up if you try to enable Turbo Highlight. Turbo mode highlights NPCs switching between all styles and colors.",
		section = turboSection
	)
	void epilepsyWarning();

	@ConfigItem(
		position = 1,
		keyName = "turboHighlight",
		name = "Turbo Highlight",
		description = "Highlights NPCs in turbo mode",
		section = turboSection
	)
	default boolean turboHighlight()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "turboNames",
		name = "Turbo Names",
		description = "List of NPCs to do things with",
		section = turboSection
	)
	default String turboNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "turboNames",
		name = "",
		description = ""
	)
	void setTurboNames(String names);

	@ConfigItem(
		position = 3,
		keyName = "turboIds",
		name = "Turbo IDs",
		description = "Can be used to see ghosts if you really want to",
		section = turboSection
	)
	default String turboIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "turboIds",
		name = "",
		description = ""
	)
	void setTurboIds(String ids);

	//------------------------------------------------------------//
	// Slayer Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "slayerHighlight",
		name = "Slayer Task Highlight",
		description = "Highlights NPCs that are assigned as your slayer task <br>Uses the 'Slayer' plugin. Keep it on!",
		section = slayerSection
	)
	default boolean slayerHighlight()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "taskHighlightStyle",
		name = "Slayer Highlight Style",
		description = "Picks the highlight style you want for NPCs on your slayer task",
		section = slayerSection
	)
	default Set<tagStyleMode> taskHighlightStyle()
	{
		return Collections.emptySet();
	}

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "taskColor",
		name = "Highlight Color",
		description = "Sets color of slayer task npc highlights",
		section = slayerSection
	)
	default Color taskColor()
	{
		return new Color(224, 60, 49, 255);
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "taskFillColor",
		name = "Fill Color",
		description = "Sets the fill color of slayer task npc highlights",
		section = slayerSection
	)
	default Color taskFillColor()
	{
		return new Color(224, 60, 49, 20);
	}

	@ConfigItem(
		position = 6,
		keyName = "slayerAA",
		name = "Anti-Aliasing",
		description = "Turns on anti-aliasing for the slayer highlights. Makes them smoother.",
		section = slayerSection
	)
	default boolean slayerAA()
	{
		return true;
	}

	@ConfigItem(
		position = 7,
		keyName = "slayerRave",
		name = "Enable Rave Mode",
		description = "Sets all slayer overlays to Rave Mode",
		section = slayerSection
	)
	default boolean slayerRave()
	{
		return false;
	}

	@ConfigItem(
		position = 8,
		keyName = "slayerRaveSpeed",
		name = "Rave Speed",
		description = "Sets the speed the overlays rave at",
		section = slayerSection
	)
	@Units(Units.MILLISECONDS)
	default int slayerRaveSpeed()
	{
		return 6000;
	}

	//------------------------------------------------------------//
	// Entity Hider Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "entityHiderToggle",
		name = "Entity Hider",
		description = "Enables hiding of specific NPCs",
		section = entityHiderSection
	)
	default boolean entityHiderToggle()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "entityHiderCommands",
		name = "Entity Hider Commands",
		description = "Enables the use of commands to add/remove NPCs to the Names/IDs list <br>Read the guide in Instructions section",
		section = entityHiderSection
	)
	default boolean entityHiderCommands()
	{
		return true;
	}

	@ConfigItem(
		position = 3,
		keyName = "entityHiderNames",
		name = "Entity Hider Names",
		description = "NPCs by Name to hide",
		section = entityHiderSection
	)
	default String entityHiderNames()
	{
		return "";
	}

	@ConfigItem(
		keyName = "entityHiderNames",
		name = "",
		description = ""
	)
	void setEntityHiderNames(String names);

	@ConfigItem(
		position = 4,
		keyName = "entityHiderIds",
		name = "Entity Hider IDs",
		description = "NPCs by ID to hide",
		section = entityHiderSection
	)
	default String entityHiderIds()
	{
		return "";
	}

	@ConfigItem(
		keyName = "entityHiderIds",
		name = "",
		description = ""
	)
	void setEntityHiderIds(String ids);

	//------------------------------------------------------------//
	// Presets Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 1,
		keyName = "presetColorAmount",
		name = "Preset Colors Amount",
		description = "The amount of preset colors you want in the Tag sub-menu",
		section = presetsSection
	)
	default presetColorAmount presetColorAmount()
	{
		return presetColorAmount.ZERO;
	}

	@Alpha
	@ConfigItem(
		position = 2,
		keyName = "presetColor1",
		name = "Preset Color 1",
		description = "Sets color for the first preset color",
		section = presetsSection
	)
	default Color presetColor1()
	{
		return new Color(224, 60, 49, 255);
	}

	@Alpha
	@ConfigItem(
		position = 3,
		keyName = "presetFillColor1",
		name = "Preset Fill Color 1",
		description = "Sets the fill color for the first preset color",
		section = presetsSection
	)
	default Color presetFillColor1()
	{
		return new Color(224, 60, 49, 20);
	}

	@Alpha
	@ConfigItem(
		position = 4,
		keyName = "presetColor2",
		name = "Preset Color 2",
		description = "Sets color for the second preset color",
		section = presetsSection
	)
	default Color presetColor2()
	{
		return new Color(37, 197, 79, 255);
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "presetFillColor2",
		name = "Preset Fill Color 2",
		description = "Sets the fill color for the second preset color",
		section = presetsSection
	)
	default Color presetFillColor2()
	{
		return new Color(37, 197, 79, 20);
	}

	@Alpha
	@ConfigItem(
		position = 6,
		keyName = "presetColor3",
		name = "Preset Color 3",
		description = "Sets color for the third preset color",
		section = presetsSection
	)
	default Color presetColor3()
	{
		return new Color(207, 138, 253, 255);
	}

	@Alpha
	@ConfigItem(
		position = 7,
		keyName = "presetFillColor3",
		name = "Preset Fill Color 3",
		description = "Sets the fill color for the third preset color",
		section = presetsSection
	)
	default Color presetFillColor3()
	{
		return new Color(207, 138, 253, 20);
	}

	@Alpha
	@ConfigItem(
		position = 8,
		keyName = "presetColor4",
		name = "Preset Color 4",
		description = "Sets color for the fourth preset color",
		section = presetsSection
	)
	default Color presetColor4()
	{
		return new Color(38, 255, 169, 255);
	}

	@Alpha
	@ConfigItem(
		position = 9,
		keyName = "presetFillColor4",
		name = "Preset Fill Color 4",
		description = "Sets the fill color for the fourth preset color",
		section = presetsSection
	)
	default Color presetFillColor4()
	{
		return new Color(38, 255, 169, 20);
	}

	@Alpha
	@ConfigItem(
		position = 10,
		keyName = "presetColor5",
		name = "Preset Color 5",
		description = "Sets color for the fifth preset color",
		section = presetsSection
	)
	default Color presetColor5()
	{
		return new Color(0, 150, 200, 255);
	}

	@Alpha
	@ConfigItem(
		position = 11,
		keyName = "presetFillColor5",
		name = "Preset Fill Color 5",
		description = "Sets the fill color for the fifth preset color",
		section = presetsSection
	)
	default Color presetFillColor5()
	{
		return new Color(0, 150, 200, 20);
	}

	//------------------------------------------------------------//
	// Instructions Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 0,
		keyName = "tagLegend",
		name = "Tag/Untag Legend",
		description = "Legend for highlights to use with the !tag and !untag commands",
		section = instructionsSection
	)
	default String tagLegend()
	{
		return "### Valid Style Format:\n\n" +
			"Tile = \"t\", \"tile\" \n" +
			"True Tile = \"tt\", \"truetile\" \n" +
			"SW Tile = \"sw\", \"swt\", \"swtile\", \"southwesttile\", \"southwest\", \"southwestt\" \n" +
			"SW True Tile = \"swtt\", \"swtruetile\", \"southwesttruetile\", \"southwesttt\" \n" +
			"Hull = \"h\", \"hull\" \n" +
			"Area = \"a\", \"area\" \n" +
			"Outline = \"o\", \"outline\" \n" +
			"Clickbox = \"c\", \"clickbox\", \"box\" \n" +
			"Turbo = \"tu\", \"turbo\" \n";
	}

	@ConfigItem(
		position = 1,
		keyName = "tagInstructions",
		name = "Tag/Untag Instructions",
		description = "Instructions to use the !tag and !untag commands",
		section = instructionsSection
	)
	default String tagInstructions()
	{
		return "### Tag Format:\n\n" +
			"!tag[style] [npc name]\n" +
			"!tag[style] [npc id]\n" +
			"!untag[style] [npc name]\n" +
			"!untag[style] [npc id]\n" +
			"---------------------\n" +
			"### Example:\n\n" +
			"\"!tagswt cow\" -> This would add \"cow\" to the SW True Tile names list\n\n" +
			"\"!untago 1234\" -> This would remove \"1234\" from the Outline IDs list\n";
	}

	@ConfigItem(
		position = 2,
		keyName = "presetInstructions",
		name = "Preset Instructions",
		description = "Instructions to use presets with the !tag and !untag commands",
		section = instructionsSection
	)
	default String presetInstructions()
	{
		return "### Preset Tag Format:\n\n" +
			"!tag[style] [npc name]:[preset #]\n" +
			"!tag[style] [npc id]:[preset #]\n" +
			"!untag[style] [npc name]:[preset #]\n" +
			"!untag[style] [npc id]:[preset #]\n" +
			"---------------------\n" +
			"### Example:\n\n" +
			"\"!tagswt cow:2\" -> This would add \"cow\" to the SW True Tile names list with preset color 2\n" +
			"# Tagging an NPC that already has a preset changes the preset to the new one\n\n" +
			"Untagging is the same, regardless of preset\n";
	}

	@ConfigItem(
		position = 3,
		keyName = "hideInstructions",
		name = "Hide/Unhide Instructions",
		description = "Instructions to use the !hide and !unhide commands",
		section = instructionsSection
	)
	default String hideInstructions()
	{
		return "### Format:\n\n" +
			"!hide [npc name]\n" +
			"!hide [npc id]\n" +
			"!unhide [npc name]\n" +
			"!unhide [npc id]\n" +
			"---------------------\n" +
			"### Example:\n\n" +
			"\"!hide cow\" -> This would add \"cow\" to the Entity Hider names list\n\n" +
			"\"!unhide 1234\" -> This would remove \"1234\" from the Entity Hider IDs list\n";
	}

	//------------------------------------------------------------//
	// Miscellaneous Section
	//------------------------------------------------------------//
	@ConfigItem(
		position = 0,
		keyName = "tagCommands",
		name = "Tag Commands",
		description = "Enables the use of commands to add/remove NPCs to the Names/IDs list <br>Read the guide in Instructions section",
		section = miscellaneousSection
	)
	default boolean tagCommands()
	{
		return true;
	}

	@ConfigItem(
		position = 1,
		keyName = "highlightMenuNames",
		name = "Highlight Menu Names",
		description = "Highlights names in right click menu entry",
		section = miscellaneousSection
	)
	default boolean highlightMenuNames()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "ignoreDeadNpcs",
		name = "Ignore Dead NPCs",
		description = "Doesn't highlight dead NPCs",
		section = miscellaneousSection
	)
	default boolean ignoreDeadNpcs()
	{
		return false;
	}

	@ConfigItem(
		position = 3,
		keyName = "ignoreDeadExclusion",
		name = "Ignore Dead Exclusion Name List",
		description = "List of NPC names to not remove highlight when dead",
		section = miscellaneousSection
	)
	default String ignoreDeadExclusion()
	{
		return "";
	}

	@ConfigItem(
		position = 4,
		keyName = "ignoreDeadExclusionID",
		name = "Ignore Dead Exclusion ID List",
		description = "List of NPC IDs to not remove highlight when dead",
		section = miscellaneousSection
	)
	default String ignoreDeadExclusionID()
	{
		return "";
	}

	@ConfigItem(
		position = 5,
		keyName = "drawBeneath",
		name = "Draw Overlays Beneath NPCs",
		description = "Overlays will appear behind/below NPCs. GPU plugin must be turned on",
		section = miscellaneousSection
	)
	default boolean drawBeneath()
	{
		return false;
	}

	@Range(max = 20)
	@ConfigItem(
		position = 6,
		keyName = "drawBeneathLimit",
		name = "Draw Beneath Limit",
		description = "Sets the amount of NPCs to have the overlay draw beneath. The higher the number, the more it affects FPS",
		section = miscellaneousSection
	)
	default int drawBeneathLimit()
	{
		return 10;
	}

	@ConfigItem(
		position = 7,
		keyName = "drawBeneathList",
		name = "Draw Beneath List",
		description = "Sets specific NPCs to have the overlay draw beneath. Empty list will use Draw Beneath Limit",
		section = miscellaneousSection
	)
	default String drawBeneathList()
	{
		return "";
	}

	@ConfigItem(
		position = 8,
		keyName = "renderDistance",
		name = "Render Distance",
		description = "Limits overlays to be drawn to within the chosen distance from the local player. <br>Short = 7 tiles, Medium = 11 tiles",
		section = miscellaneousSection
	)
	default renderDistance renderDistance()
	{
		return renderDistance.NONE;
	}

	@ConfigItem(
		position = 9,
		keyName = "highlightPets",
		name = "Highlight pets",
		description = "Highlights followers/pets that are in any of your lists",
		section = miscellaneousSection
	)
	default boolean highlightPets()
	{
		return false;
	}

	@ConfigItem(
		position = 10,
		keyName = "deadNpcMenuColor",
		name = "Dead NPC Menu Color",
		description = "Highlights names in right click menu entry when an NPC is dead",
		section = miscellaneousSection
	)
	Color deadNpcMenuColor();

	@ConfigItem(
		position = 11,
		keyName = "respawnTimer",
		name = "Respawn Timer",
		description = "Marks tile and shows timer for when a marker NPC will respawn",
		section = miscellaneousSection
	)
	default respawnTimerMode respawnTimer()
	{
		return respawnTimerMode.OFF;
	}

	@Alpha
	@ConfigItem(
		position = 12,
		keyName = "respawnTimerColor",
		name = "Respawn Time Color",
		description = "Sets the color of the text for Respawn Timer",
		section = miscellaneousSection
	)
	default Color respawnTimerColor()
	{
		return Color.WHITE;
	}

	@Alpha
	@ConfigItem(
		position = 13,
		keyName = "respawnOutlineColor",
		name = "Respawn Outline Color",
		description = "Sets the color of the tile for Respawn Timer",
		section = miscellaneousSection
	)
	default Color respawnOutlineColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		position = 14,
		keyName = "respawnFillColor",
		name = "Respawn Fill Color",
		description = "Sets the fill color of the tile for Respawn Timer",
		section = miscellaneousSection
	)
	default Color respawnFillColor()
	{
		return new Color(0, 255, 255, 20);
	}

	@Range(min = 1, max = 10)
	@ConfigItem(
		position = 15,
		keyName = "respawnTileWidth",
		name = "Respawn Tile Width",
		description = "Sets the width of the tile for Respawn Timer",
		section = miscellaneousSection
	)
	default int respawnTileWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 16,
		keyName = "displayName",
		name = "Display Name",
		description = "Shows name of NPCs in the list above them",
		section = miscellaneousSection
	)
	default String displayName()
	{
		return "";
	}

	@ConfigItem(
		position = 17,
		keyName = "fontBackground",
		name = "Font Background",
		description = "Puts an outline, shadow, or nothing behind font overlays",
		section = miscellaneousSection
	)
	default background fontBackground()
	{
		return background.SHADOW;
	}

	@ConfigItem(
		position = 18,
		keyName = "npcMinimapMode",
		name = "Highlight Minimap",
		description = "Highlights NPC on minimap and/or displays name",
		section = miscellaneousSection
	)
	default npcMinimapMode npcMinimapMode()
	{
		return npcMinimapMode.OFF;
	}

	@ConfigItem(
		position = 19,
		keyName = "debugNPC",
		name = "Debug NPC Info",
		description = "Highlights all NPCs with their Name and ID",
		section = miscellaneousSection
	)
	default boolean debugNPC()
	{
		return false;
	}

	//------------------------------------------------------------//
	// Enums
	//------------------------------------------------------------//
	@Getter
	@RequiredArgsConstructor
	enum tagStyleMode
	{
		NONE("None", "none"),
		TILE("Tile", "tile"),
		TRUE_TILE("True Tile", "trueTile"),
		SW_TILE("SW Tile", "swTile"),
		SW_TRUE_TILE("SW True Tile", "swTrueTile"),
		HULL("Hull", "hull"),
		AREA("Area", "area"),
		OUTLINE("Outline", "outline"),
		CLICKBOX("Clickbox", "clickbox"),
		TURBO("Turbo", "turbo"),
		;

		@Getter
		private final String group;

		@Getter
		private final String key;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum lineType
	{
		REG("Regular"),
		DASH("Dashed"),
		CORNER("Corners"),
		;

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum presetColorAmount
	{
		ZERO("None"),
		ONE("One"),
		TWO("Two"),
		THREE("Three"),
		FOUR("Four"),
		FIVE("Five"),
		;

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@RequiredArgsConstructor
	enum background
	{
		OFF("None"),
		SHADOW("Shadow"),
		OUTLINE("Outline"),
		;

		@Getter
		private final String group;

		@Override
		public String toString()
		{
			return group;
		}
	}

	@Getter
	@AllArgsConstructor
	enum renderDistance
	{
		SHORT("Short", 7),
		MED("Medium", 11),
		NONE("No Limit", 0); //14 = max distance

		private final String group;
		private final int distance;

		@Override
		public String toString()
		{
			return group;
		}
	}

	enum respawnTimerMode
	{
		OFF,
		TICKS,
		SECONDS
	}

	enum npcMinimapMode
	{
		OFF,
		DOT,
		NAME,
		BOTH
	}
}

package com.betternpchighlight.overlays;

import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.*;
import javax.inject.Inject;

import com.betternpchighlight.BetterNpcHighlightConfig;
import com.betternpchighlight.data.NPCInfo;
import com.betternpchighlight.data.NameAndIdContainer;
import com.betternpchighlight.managers.ColorManager;

import java.awt.*;
import net.runelite.client.util.Text;

public class BetterNpcMinimapOverlay extends Overlay
{
	@Inject
	private BetterNpcHighlightConfig config;

	@Inject
	private NameAndIdContainer nameAndIdContainer;

	@Inject
	private ColorManager colorManager;

	@Inject
	private BetterNpcMinimapOverlay() {
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		for (NPCInfo npcInfo : nameAndIdContainer.npcList)
		{
			NPC npc = npcInfo.getNpc();
			if (npc.getName() != null && config.npcMinimapMode() != BetterNpcHighlightConfig.npcMinimapMode.OFF)
			{
				Color color = colorManager.getSpecificColor(npcInfo);

				NPCComposition npcComposition = npc.getTransformedComposition();
				if (color != null && npcComposition != null && npcComposition.isInteractible())
				{
					Point minimapLocation = npc.getMinimapLocation();
					if (minimapLocation != null)
					{
						if (config.npcMinimapMode() == BetterNpcHighlightConfig.npcMinimapMode.DOT || config.npcMinimapMode() == BetterNpcHighlightConfig.npcMinimapMode.BOTH)
						{
							OverlayUtil.renderMinimapLocation(graphics, minimapLocation, color);
						}

						if (config.npcMinimapMode() == BetterNpcHighlightConfig.npcMinimapMode.NAME || config.npcMinimapMode() == BetterNpcHighlightConfig.npcMinimapMode.BOTH)
						{
							OverlayUtil.renderTextLocation(graphics, minimapLocation, Text.removeTags(npc.getName()), color);
						}
					}
				}
			}
		}
		return null;
	}
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2023, geheur <http://github.com/geheur>
 * Copyright (c) 2021, LeikvollE <http://github.com/LeikvollE>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.betternpchighlight.overlays;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.Collectors;
import net.runelite.api.Point;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;

import com.betternpchighlight.BetterNpcHighlightConfig;
import com.betternpchighlight.BetterNpcHighlightPlugin;
import com.betternpchighlight.data.NPCInfo;
import com.betternpchighlight.data.NameAndIdContainer;
import com.betternpchighlight.data.NpcSpawn;
import com.betternpchighlight.managers.ColorManager;

import java.awt.*;
import java.time.Instant;
import java.util.Random;
import net.runelite.client.util.Text;
import net.runelite.client.util.WildcardMatcher;

public class BetterNpcHighlightOverlay extends Overlay
{
	@Inject
	private Client client;

	@Inject
	private BetterNpcHighlightPlugin plugin;

	@Inject
	private BetterNpcHighlightConfig config;

	@Inject
	private ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private NpcUtil npcUtil;

	@Inject
	private ColorManager colorManager;

	@Inject
	private NameAndIdContainer nameAndIdContainer;

	@Inject
	private BetterNpcHighlightOverlay()
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	public Dimension render(Graphics2D graphics)
	{
		for (NPCInfo npcInfo : nameAndIdContainer.npcList)
		{
			NPC npc = npcInfo.getNpc();
			NPCComposition npcComposition = npc.getTransformedComposition();
			if (npcComposition != null && ((npc.getName() != null && !npc.getName().equals("") && !npc.getName().equals("null")) || !isInvisible(npc.getModel())))
			{
				boolean showWhileDead = (!npc.isDead() && !npcUtil.isDying(npc)) || !config.ignoreDeadNpcs() || npcInfo.isIgnoreDead();
				boolean showNPC = (npcComposition.isFollower() && config.highlightPets()) || (!npcComposition.isFollower() && showWhileDead);

				if (showNPC && withinDistanceLimit(npc))
				{
					if (config.slayerHighlight() && npcInfo.isTask())
					{
						for (BetterNpcHighlightConfig.tagStyleMode mode : BetterNpcHighlightConfig.tagStyleMode.values())
						{
							if (config.taskHighlightStyle().contains(mode))
							{
								renderNpcOverlay(graphics, npcInfo, mode.getKey());
							}
						}
					}
					else
					{
						if (config.tileHighlight() && npcInfo.getTile().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "tile");
						}

						if (config.trueTileHighlight() && npcInfo.getTrueTile().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "trueTile");
						}

						if (config.swTileHighlight() && npcInfo.getSwTile().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "swTile");
						}

						if (config.swTrueTileHighlight() && npcInfo.getSwTrueTile().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "swTrueTile");
						}

						if (config.hullHighlight() && npcInfo.getHull().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "hull");
						}

						if (config.areaHighlight() && npcInfo.getArea().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "area");
						}

						if (config.outlineHighlight() && npcInfo.getOutline().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "outline");
						}

						if (config.clickboxHighlight() && npcInfo.getClickbox().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "clickbox");
						}

						if (config.turboHighlight() && npcInfo.getTurbo().isHighlight())
						{
							renderNpcOverlay(graphics, npcInfo, "turbo");
						}
					}

					if (nameAndIdContainer.namesToDisplay.size() > 0 && npc.getName() != null)
					{
						for (String str : nameAndIdContainer.namesToDisplay)
						{
							if (WildcardMatcher.matches(str, npc.getName().toLowerCase()))
							{
								String text = Text.removeTags(npc.getName());
								Point textLoc = npc.getCanvasTextLocation(graphics, text, npc.getLogicalHeight() + 40);
								if (textLoc != null)
								{
									drawTextBackground(graphics, textLoc, text);
									OverlayUtil.renderTextLocation(graphics, textLoc, text, colorManager.getSpecificColor(npcInfo));
									break;
								}
							}
						}
					}
				}
			}
		}

		if (config.drawBeneath() && client.isGpu() && client.getLocalPlayer() != null)
		{
			// Limits the number of npcs drawn below overlays, ranks the NPCs by distance to player.
			LocalPoint lp = LocalPoint.fromWorld(client, client.getLocalPlayer().getWorldLocation());
			if (lp != null)
			{
				ArrayList<NPCInfo> closestNPCs = nameAndIdContainer.npcList;
				if (!nameAndIdContainer.beneathNPCs.isEmpty())
				{
					closestNPCs = new ArrayList<>();
					for (NPCInfo npcInfo : nameAndIdContainer.npcList)
					{
						if (!npcInfo.getNpc().isDead() && !npcUtil.isDying(npcInfo.getNpc()))
						{
							for (String str : nameAndIdContainer.beneathNPCs)
							{
								if (npcInfo.getNpc().getName() != null && WildcardMatcher.matches(str, npcInfo.getNpc().getName().toLowerCase()))
								{
									closestNPCs.add(npcInfo);
									break;
								}
							}
						}
					}
				}
				closestNPCs
					.stream()
					.sorted(Comparator.comparingInt(n -> n.getNpc().getLocalLocation().distanceTo(lp)))
					.limit(config.drawBeneathLimit())
					.collect(Collectors.toList())
					.forEach(nInfo -> removeActor(graphics, nInfo.getNpc()));
			}
		}

		if (config.debugNPC())
		{
			for (NPC npc : client.getNpcs())
			{
				NPCComposition npcComposition = npc.getTransformedComposition();
				//Do not show debug info for NPCs with invisible models
				if (npcComposition != null && ((npc.getName() != null && !npc.getName().equals("") && !npc.getName().equals("null")) || !isInvisible(npc.getModel())))
				{
					LocalPoint lp = npc.getLocalLocation();
					if (lp != null)
					{
						Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, npcComposition.getSize());
						if (tilePoly != null)
						{
							renderPoly(graphics, Color.GRAY, new Color(0, 0, 0, 0), 255, 0, tilePoly, config.tileWidth(), true);
							String text = "N: " + npc.getName() + " | ID: " + npc.getId();
							Point textLoc = npc.getCanvasTextLocation(graphics, text, npc.getLogicalHeight() + 40);
							if (textLoc != null)
							{
								drawTextBackground(graphics, textLoc, text);
								OverlayUtil.renderTextLocation(graphics, textLoc, text, Color.WHITE);
							}
						}
					}
				}
			}
		}

		if (config.respawnTimer() != BetterNpcHighlightConfig.respawnTimerMode.OFF)
		{
			for (NpcSpawn n : nameAndIdContainer.npcSpawns)
			{
				if (n.spawnPoint != null && n.respawnTime != -1 && n.dead)
				{
					final LocalPoint lp = LocalPoint.fromWorld(client, n.spawnPoint.getX(), n.spawnPoint.getY());

					if (lp != null)
					{
						final LocalPoint centerLp = new LocalPoint(lp.getX() + Perspective.LOCAL_TILE_SIZE * (n.size - 1) / 2, lp.getY() + Perspective.LOCAL_TILE_SIZE * (n.size - 1) / 2);
						Color outlineColor = config.respawnOutlineColor();
						Color fillColor = config.respawnFillColor();
						Color raveColor = Color.WHITE;
						int width = config.respawnTileWidth();
						if (colorManager.getTurboIndex(n.id, n.name.toLowerCase()) != -1)
						{
							raveColor = nameAndIdContainer.turboColors.get(colorManager.getTurboIndex(n.id, n.name.toLowerCase()));
							outlineColor = new Color(raveColor.getRed(), raveColor.getGreen(), raveColor.getBlue(), new Random().nextInt(254) + 1);
							fillColor = new Color(raveColor.getRed(), raveColor.getGreen(), raveColor.getBlue(), new Random().nextInt(254) + 1);
							width = plugin.turboTileWidth;
						}

						Polygon tilePoly = Perspective.getCanvasTileAreaPoly(client, centerLp, n.size);
						if (tilePoly != null)
						{
							renderPoly(graphics, outlineColor, fillColor, outlineColor.getAlpha(), fillColor.getAlpha(), tilePoly, width, true);
						}

						String text;
						if (config.respawnTimer() == BetterNpcHighlightConfig.respawnTimerMode.SECONDS)
						{
							final Instant now = Instant.now();
							final double baseTick = (n.respawnTime - (client.getTickCount() - n.diedOnTick)) * (Constants.GAME_TICK_LENGTH / 1000.0);
							final double sinceLast = (now.toEpochMilli() - plugin.lastTickUpdate.toEpochMilli()) / 1000.0;
							final double timeLeft = Math.max(0, baseTick - sinceLast);
							text = String.valueOf(timeLeft);
							if (text.contains("."))
							{
								text = text.substring(0, text.indexOf(".") + 2);
							}
						}
						else
						{
							text = String.valueOf(Math.max(0, (n.respawnTime - (client.getTickCount() - n.diedOnTick))));
						}

						Point textLoc = Perspective.getCanvasTextLocation(client, graphics, centerLp, text, 0);
						if (textLoc != null)
						{
							drawTextBackground(graphics, textLoc, text);
							if (raveColor != Color.WHITE)
							{
								OverlayUtil.renderTextLocation(graphics, textLoc, text, new Color(raveColor.getRed(), raveColor.getGreen(), raveColor.getBlue(), new Random().nextInt(205) + 50));
							}
							else
							{
								OverlayUtil.renderTextLocation(graphics, textLoc, text, config.respawnTimerColor());
							}
						}
					}
				}
			}
		}
		return null;
	}

	/**
	 * Create overlays for NPCs to highlight.
	 *
	 * @param graphics  graphics
	 * @param npcInfo   NPCInfo
	 * @param highlight Style to highlight the NPC
	 */
	protected void renderNpcOverlay(Graphics2D graphics, NPCInfo npcInfo, String highlight)
	{
		NPC npc = npcInfo.getNpc();
		NPCComposition npcComposition = npc.getTransformedComposition();
		if (npcComposition != null)
		{
			int size = npcComposition.getSize();
			Polygon tilePoly;
			LocalPoint lp;
			Color line;
			Color fill;
			int lineAlpha;
			int fillAlpha;
			boolean antialias;
			boolean isTask = npcInfo.isTask() && config.slayerHighlight();

			switch (highlight)
			{
				case "hull":
					line = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskColor()
						: config.hullRave() ? colorManager.getRaveColor(config.hullRaveSpeed()) : npcInfo.getHull().getColor();
					fill = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskFillColor()
						: config.hullRave() ? colorManager.getRaveColor(config.hullRaveSpeed()) : npcInfo.getHull().getFill();
					lineAlpha = isTask ? config.taskColor().getAlpha() : npcInfo.getHull().getColor().getAlpha();
					fillAlpha = isTask ? config.taskFillColor().getAlpha() : npcInfo.getHull().getFill().getAlpha();
					antialias = isTask ? config.slayerAA() : config.hullAA();

					Shape hull = npc.getConvexHull();
					if (hull != null)
					{
						renderPoly(graphics, line, fill, lineAlpha, fillAlpha, hull, config.hullWidth(), antialias);
					}
					break;
				case "tile":
					line = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskColor()
						: config.tileRave() ? colorManager.getRaveColor(config.tileRaveSpeed()) : npcInfo.getTile().getColor();
					fill = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskFillColor()
						: config.tileRave() ? colorManager.getRaveColor(config.tileRaveSpeed()) : npcInfo.getTile().getFill();
					lineAlpha = isTask ? config.taskColor().getAlpha() : npcInfo.getTile().getColor().getAlpha();
					fillAlpha = isTask ? config.taskFillColor().getAlpha() : npcInfo.getTile().getFill().getAlpha();
					antialias = isTask ? config.slayerAA() : config.tileAA();

					lp = npc.getLocalLocation();
					if (lp != null)
					{
						tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
						if (tilePoly != null)
						{
							switch (config.tileLines())
							{
								case REG:
									renderPoly(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.tileWidth(), antialias);
									break;
								case DASH:
									renderPolygonDashed(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.tileWidth(), size, antialias);
									break;
								case CORNER:
									renderPolygonCorners(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.tileWidth(), antialias);
									break;
							}
						}
					}
					break;
				case "trueTile":
					line = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskColor()
						: config.trueTileRave() ? colorManager.getRaveColor(config.trueTileRaveSpeed()) : npcInfo.getTrueTile().getColor();
					fill = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskFillColor()
						: config.trueTileRave() ? colorManager.getRaveColor(config.trueTileRaveSpeed()) : npcInfo.getTrueTile().getFill();
					lineAlpha = isTask ? config.taskColor().getAlpha() : npcInfo.getTrueTile().getColor().getAlpha();
					fillAlpha = isTask ? config.taskFillColor().getAlpha() : npcInfo.getTrueTile().getFill().getAlpha();
					antialias = isTask ? config.slayerAA() : config.trueTileAA();

					lp = LocalPoint.fromWorld(client, npc.getWorldLocation());
					if (lp != null)
					{
						lp = new LocalPoint(lp.getX() + size * 128 / 2 - 64, lp.getY() + size * 128 / 2 - 64);
						tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
						if (tilePoly != null)
						{
							switch (config.trueTileLines())
							{
								case REG:
									renderPoly(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.trueTileWidth(), antialias);
									break;
								case DASH:
									renderPolygonDashed(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.trueTileWidth(), size, antialias);
									break;
								case CORNER:
									renderPolygonCorners(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.trueTileWidth(), antialias);
									break;
							}
						}
					}
					break;
				case "swTile":
					line = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskColor()
						: config.swTileRave() ? colorManager.getRaveColor(config.swTileRaveSpeed()) : npcInfo.getSwTile().getColor();
					fill = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskFillColor()
						: config.swTileRave() ? colorManager.getRaveColor(config.swTileRaveSpeed()) : npcInfo.getSwTile().getFill();
					lineAlpha = isTask ? config.taskColor().getAlpha() : npcInfo.getSwTile().getColor().getAlpha();
					fillAlpha = isTask ? config.taskFillColor().getAlpha() : npcInfo.getSwTile().getFill().getAlpha();
					antialias = isTask ? config.slayerAA() : config.swTileAA();

					lp = npc.getLocalLocation();
					if (lp != null)
					{
						int x = lp.getX() - (size - 1) * 128 / 2;
						int y = lp.getY() - (size - 1) * 128 / 2;
						tilePoly = Perspective.getCanvasTilePoly(client, new LocalPoint(x, y));
						if (tilePoly != null)
						{
							switch (config.swTileLines())
							{
								case REG:
									renderPoly(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.swTileWidth(), antialias);
									break;
								case DASH:
									renderPolygonDashed(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.swTileWidth(), size, antialias);
									break;
								case CORNER:
									renderPolygonCorners(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.swTileWidth(), antialias);
									break;
							}
						}
					}
					break;
				case "swTrueTile":
					line = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskColor()
						: config.swTrueTileRave() ? colorManager.getRaveColor(config.swTrueTileRaveSpeed()) : npcInfo.getSwTrueTile().getColor();
					fill = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskFillColor()
						: config.swTrueTileRave() ? colorManager.getRaveColor(config.swTrueTileRaveSpeed()) : npcInfo.getSwTrueTile().getFill();
					lineAlpha = isTask ? config.taskColor().getAlpha() : npcInfo.getSwTrueTile().getColor().getAlpha();
					fillAlpha = isTask ? config.taskFillColor().getAlpha() : npcInfo.getSwTrueTile().getFill().getAlpha();
					antialias = isTask ? config.slayerAA() : config.swTrueTileAA();

					lp = LocalPoint.fromWorld(client, npc.getWorldLocation());
					if (lp != null)
					{
						tilePoly = Perspective.getCanvasTilePoly(client, lp);
						if (tilePoly != null)
						{
							switch (config.swTrueTileLines())
							{
								case REG:
									renderPoly(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.swTrueTileWidth(), antialias);
									break;
								case DASH:
									renderPolygonDashed(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.swTrueTileWidth(), size, antialias);
									break;
								case CORNER:
									renderPolygonCorners(graphics, line, fill, lineAlpha, fillAlpha, tilePoly, config.swTrueTileWidth(), antialias);
									break;
							}
						}
					}
					break;
				case "outline":
					line = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskColor()
						: config.outlineRave() ? colorManager.getRaveColor(config.outlineRaveSpeed()) : npcInfo.getOutline().getColor();

					modelOutlineRenderer.drawOutline(npc, config.outlineWidth(), line, config.outlineFeather());
					break;
				case "area":
					Color color = npcInfo.getArea().getFill() != null ? npcInfo.getArea().getFill() : npcInfo.getArea().getColor();
					fill = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskFillColor()
						: config.areaRave() ? colorManager.getRaveColor(config.areaRaveSpeed()) : color;
					fillAlpha = isTask ? config.taskFillColor().getAlpha() : color.getAlpha();

					Shape area = npc.getConvexHull();
					if (area != null)
					{
						graphics.setColor(fill.getAlpha() == 0 ? new Color(fill.getRed(), fill.getGreen(), fill.getGreen(), 50)
							: new Color(fill.getRed(), fill.getGreen(), fill.getBlue(), fillAlpha));
						graphics.fill(area);
					}
					break;
				case "clickbox":
					line = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskColor()
						: config.clickboxRave() ? colorManager.getRaveColor(config.clickboxRaveSpeed()) : npcInfo.getClickbox().getColor();
					fill = isTask ? config.slayerRave() ? colorManager.getRaveColor(config.slayerRaveSpeed()) : config.taskFillColor()
						: config.clickboxRave() ? colorManager.getRaveColor(config.clickboxRaveSpeed()) : npcInfo.getClickbox().getFill();
					lineAlpha = isTask ? config.taskColor().getAlpha() : npcInfo.getClickbox().getColor().getAlpha();
					fillAlpha = isTask ? config.taskFillColor().getAlpha() : npcInfo.getClickbox().getFill().getAlpha();

					lp = npc.getLocalLocation();
					if (lp != null)
					{
						Shape clickbox = Perspective.getClickbox(client, npc.getWorldView(), npc.getModel(), npc.getCurrentOrientation(), lp.getX(), lp.getY(),
							Perspective.getTileHeight(client, lp, npc.getWorldLocation().getPlane()));
						renderClickbox(graphics, clickbox, client.getMouseCanvasPosition(), line, fill, lineAlpha, fillAlpha, line.darker(), config.clickboxAA());
					}
					break;
				case "turbo":
				Color raveColor = nameAndIdContainer.turboColors.get(colorManager.getTurboIndex(npc.getId(), npc.getName().toLowerCase()));
					if (raveColor != null)
					{
						line = new Color(raveColor.getRed(), raveColor.getGreen(), raveColor.getBlue(), new Random().nextInt(254) + 1);
						fill = new Color(raveColor.getRed(), raveColor.getGreen(), raveColor.getBlue(), new Random().nextInt(254) + 1);
						int tileMode = new Random().nextInt(3);

						if (plugin.turboModeStyle == 0)
						{
							lp = npc.getLocalLocation();
							if (lp != null)
							{
								tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
								if (tilePoly != null)
								{
									if (tileMode == 0)
									{
										renderPoly(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, true);
									}
									else if (tileMode == 1)
									{
										renderPolygonDashed(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, size,true);
									}
									else
									{
										renderPolygonCorners(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, true);
									}
								}
							}
						}
						else if (plugin.turboModeStyle == 1)
						{
							lp = LocalPoint.fromWorld(client, npc.getWorldLocation());
							if (lp != null)
							{
								lp = new LocalPoint(lp.getX() + size * 128 / 2 - 64, lp.getY() + size * 128 / 2 - 64);
								tilePoly = Perspective.getCanvasTileAreaPoly(client, lp, size);
								if (tilePoly != null)
								{
									if (tileMode == 0)
									{
										renderPoly(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, true);
									}
									else if (tileMode == 1)
									{
										renderPolygonDashed(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, size,true);
									}
									else
									{
										renderPolygonCorners(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, true);
									}
								}
							}
						}
						else if (plugin.turboModeStyle == 2)
						{
							lp = npc.getLocalLocation();
							if (lp != null)
							{
								int x = lp.getX() - (size - 1) * 128 / 2;
								int y = lp.getY() - (size - 1) * 128 / 2;
								tilePoly = Perspective.getCanvasTilePoly(client, new LocalPoint(x, y));
								if (tilePoly != null)
								{
									if (tileMode == 0)
									{
										renderPoly(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, true);
									}
									else if (tileMode == 1)
									{
										renderPolygonDashed(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, size,true);
									}
									else
									{
										renderPolygonCorners(graphics, line, fill, line.getAlpha(), fill.getAlpha(), tilePoly, plugin.turboTileWidth, true);
									}
								}
							}
						}
						else if (plugin.turboModeStyle == 3)
						{
							if (npc.getConvexHull() != null)
							{
								renderPoly(graphics, line, fill, line.getAlpha(), fill.getAlpha(), npc.getConvexHull(), plugin.turboTileWidth, true);
							}
						}
						else if (plugin.turboModeStyle == 4)
						{
							if (npc.getConvexHull() != null)
							{
								graphics.setColor(fill);
								graphics.fill(npc.getConvexHull());
							}
						}
						else
						{
							modelOutlineRenderer.drawOutline(npc, plugin.turboTileWidth, line, plugin.turboOutlineFeather);
						}
					}
					break;
			}
		}
	}

	private void renderPoly(Graphics2D graphics, Color outlineColor, Color fillColor, int lineAlpha, int fillAlpha, Shape polygon, double width, boolean antiAlias)
	{
		if (polygon != null)
		{
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antiAlias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(new Color(outlineColor.getRed(), outlineColor.getGreen(), outlineColor.getBlue(), lineAlpha));
			graphics.setStroke(new BasicStroke((float) width));
			graphics.draw(polygon);
			graphics.setColor(new Color(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), fillAlpha));
			graphics.fill(polygon);
		}
	}

	public static void renderClickbox(Graphics2D graphics, Shape area, Point mousePosition, Color line, Color fill, int lineAlpha, int fillAlpha, Color hovered, boolean antiAlias)
	{
		if (area != null)
		{
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antiAlias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			if (area.contains(mousePosition.getX(), mousePosition.getY()))
			{
				graphics.setColor(new Color(hovered.getRed(), hovered.getGreen(), hovered.getBlue(), lineAlpha));
			}
			else
			{
				graphics.setColor(new Color(line.getRed(), line.getGreen(), line.getBlue(), lineAlpha));
			}
			graphics.draw(area);
			graphics.setColor(new Color(fill.getRed(), fill.getGreen(), fill.getBlue(), fillAlpha));
			graphics.fill(area);
		}
	}

	/**
	 * Draws only the corners of NPC tile highlights - Made by Geheur
	 *
	 * @param graphics
	 * @param outlineColor
	 * @param fillColor
	 * @param lineAlpha
	 * @param fillAlpha
	 * @param poly
	 * @param width
	 * @param antiAlias
	 */
	private static void renderPolygonCorners(Graphics2D graphics, Color outlineColor, Color fillColor, int lineAlpha, int fillAlpha, Shape poly, double width, boolean antiAlias)
	{
		if (poly instanceof Polygon)
		{
			Polygon p = (Polygon) poly;
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antiAlias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(new Color(outlineColor.getRed(), outlineColor.getGreen(), outlineColor.getBlue(), lineAlpha));
			graphics.setStroke(new BasicStroke((float) width));

			int divisor = 7;
			for (int i = 0; i < p.npoints; i++)
			{
				int ptx = p.xpoints[i];
				int pty = p.ypoints[i];
				int prev = (i - 1) < 0 ? 3 : (i - 1);
				int next = (i + 1) > 3 ? 0 : (i + 1);
				int ptxN = ((p.xpoints[next]) - ptx) / divisor + ptx;
				int ptyN = ((p.ypoints[next]) - pty) / divisor + pty;
				int ptxP = ((p.xpoints[prev]) - ptx) / divisor + ptx;
				int ptyP = ((p.ypoints[prev]) - pty) / divisor + pty;
				graphics.drawLine(ptx, pty, ptxN, ptyN);
				graphics.drawLine(ptx, pty, ptxP, ptyP);
			}

			graphics.setColor(new Color(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), fillAlpha));
			graphics.fill(poly);
		}
	}

	/**
	 * Draws the corners and dashed lines along each side of NPC tile highlights - Made by Geheur
	 *
	 * @param graphics
	 * @param outlineColor
	 * @param fillColor
	 * @param lineAlpha
	 * @param fillAlpha
	 * @param poly
	 * @param width
	 * @param tiles
	 * @param antiAlias
	 */
	private static void renderPolygonDashed(Graphics2D graphics, Color outlineColor, Color fillColor, int lineAlpha, int fillAlpha, Shape poly,
											double width, int tiles, boolean antiAlias)
	{
		if (poly instanceof Polygon)
		{
			Polygon p = (Polygon) poly;
			graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, antiAlias ? RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);
			graphics.setColor(new Color(outlineColor.getRed(), outlineColor.getGreen(), outlineColor.getBlue(), lineAlpha));
			graphics.setStroke(new BasicStroke((float) width));

			int divisor = 7 * tiles;
			for (int i = 0; i < p.npoints; i++)
			{
				int ptx = p.xpoints[i];
				int pty = p.ypoints[i];
				int next = (i + 1) > 3 ? 0 : (i + 1);
				int ptxN = (p.xpoints[next]) - ptx;
				int ptyN = (p.ypoints[next]) - pty;
				float length = (float) Point2D.distance(ptx, pty, ptx + ptxN, pty + ptyN);
				float dashLength = length * 2f / divisor;
				float spaceLength = length * 5f / divisor;
				Stroke s = new BasicStroke((float) width, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10, new float[]{dashLength, spaceLength}, dashLength / 2);
				graphics.setStroke(s);
				graphics.drawLine(ptx, pty, ptx + ptxN, pty + ptyN);
			}

			graphics.setColor(new Color(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), fillAlpha));
			graphics.fill(poly);
		}
	}

	private void drawTextBackground(Graphics2D graphics, Point textLoc, String text)
	{
		switch (config.fontBackground())
		{
			case OUTLINE:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() + 1), text, Color.BLACK);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX(), textLoc.getY() - 1), text, Color.BLACK);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY()), text, Color.BLACK);
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() - 1, textLoc.getY()), text, Color.BLACK);
				break;
			}
			case SHADOW:
			{
				OverlayUtil.renderTextLocation(graphics, new Point(textLoc.getX() + 1, textLoc.getY() + 1), text, Color.BLACK);
				break;
			}
			default:
				break;
		}
	}

	//Copied from Skretzo
	private static boolean isInvisible(Model model)
	{
		// If all the values in model.getFaceColors3() are -1 then the model is invisible
		for (int value : model.getFaceColors3())
		{
			if (value != -1)
			{
				return false;
			}
		}
		return true;
	}

	//Made by LeikvollE
	private void removeActor(final Graphics2D graphics, final Actor actor)
	{
		final int clipX1 = client.getViewportXOffset();
		final int clipY1 = client.getViewportYOffset();
		final int clipX2 = client.getViewportWidth() + clipX1;
		final int clipY2 = client.getViewportHeight() + clipY1;
		Object origAA = graphics.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
		Model model = actor.getModel();
		int vCount = model.getVerticesCount();
		float[] x3d = model.getVerticesX();
		float[] y3d = model.getVerticesY();
		float[] z3d = model.getVerticesZ();

		int[] x2d = new int[vCount];
		int[] y2d = new int[vCount];

		int size = 1;
		if (actor instanceof NPC)
		{
			NPCComposition composition = ((NPC) actor).getTransformedComposition();
			if (composition != null)
			{
				size = composition.getSize();
			}
		}

		final LocalPoint lp = actor.getLocalLocation();

		final int localX = lp.getX();
		final int localY = lp.getY();
		final int northEastX = lp.getX() + Perspective.LOCAL_TILE_SIZE * (size - 1) / 2;
		final int northEastY = lp.getY() + Perspective.LOCAL_TILE_SIZE * (size - 1) / 2;
		final LocalPoint northEastLp = new LocalPoint(northEastX, northEastY);
		int localZ = Perspective.getTileHeight(client, northEastLp, client.getPlane());
		int rotation = actor.getCurrentOrientation();

		Perspective.modelToCanvas(client, vCount, localX, localY, localZ, rotation, x3d, z3d, y3d, x2d, y2d);

		boolean anyVisible = false;

		for (int i = 0; i < vCount; i++)
		{
			int x = x2d[i];
			int y = y2d[i];

			boolean visibleX = x >= clipX1 && x < clipX2;
			boolean visibleY = y >= clipY1 && y < clipY2;
			anyVisible |= visibleX && visibleY;
		}

		if (!anyVisible)
		{
			return;
		}

		int tCount = model.getFaceCount();
		int[] tx = model.getFaceIndices1();
		int[] ty = model.getFaceIndices2();
		int[] tz = model.getFaceIndices3();

		Composite orig = graphics.getComposite();
		graphics.setComposite(AlphaComposite.Clear);
		graphics.setColor(Color.WHITE);
		for (int i = 0; i < tCount; i++)
		{
			// Cull tris facing away from the camera
			if (getTriDirection(x2d[tx[i]], y2d[tx[i]], x2d[ty[i]], y2d[ty[i]], x2d[tz[i]], y2d[tz[i]]) >= 0)
			{
				continue;
			}
			Polygon p = new Polygon(
				new int[]{x2d[tx[i]], x2d[ty[i]], x2d[tz[i]]},
				new int[]{y2d[tx[i]], y2d[ty[i]], y2d[tz[i]]},
				3);
			graphics.fill(p);

		}
		graphics.setComposite(orig);
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, origAA);
	}

	private int getTriDirection(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		int x4 = x2 - x1;
		int y4 = y2 - y1;
		int x5 = x3 - x1;
		int y5 = y3 - y1;
		return x4 * y5 - y4 * x5;
	}

	private boolean withinDistanceLimit(NPC npc)
	{
		final int maxDistance = config.renderDistance().getDistance();
		return maxDistance == 0 || npc.getWorldArea().distanceTo(client.getLocalPlayer().getWorldArea()) - 1 <= maxDistance;
	}
}

package com.betternpchighlight.data;

import java.awt.Color;
import java.util.ArrayList;

import javax.inject.Singleton;

import net.runelite.api.NPC;

@Singleton
public class NameAndIdContainer {
  public String currentTask = "";
  public boolean confirmedWarning = false;
  public ArrayList<NPCInfo> npcList = new ArrayList<>();
  public NPCInfo getNpcInfoByNpc(NPC npc) {
    return npcList.stream().filter(npcInfo -> npcInfo.getNpc() == npc).findFirst().orElse(null);
  }

  public ArrayList<String> tileNames = new ArrayList<>();
  public ArrayList<String> tileIds = new ArrayList<>();
  public ArrayList<String> trueTileNames = new ArrayList<>();
  public ArrayList<String> trueTileIds = new ArrayList<>();
  public ArrayList<String> swTileNames = new ArrayList<>();
  public ArrayList<String> swTileIds = new ArrayList<>();
  public ArrayList<String> swTrueTileNames = new ArrayList<>();
  public ArrayList<String> swTrueTileIds = new ArrayList<>();
  public ArrayList<String> hullNames = new ArrayList<>();
  public ArrayList<String> hullIds = new ArrayList<>();
  public ArrayList<String> areaNames = new ArrayList<>();
  public ArrayList<String> areaIds = new ArrayList<>();
  public ArrayList<String> outlineNames = new ArrayList<>();
  public ArrayList<String> outlineIds = new ArrayList<>();
  public ArrayList<String> clickboxNames = new ArrayList<>();
  public ArrayList<String> clickboxIds = new ArrayList<>();
  public ArrayList<String> turboNames = new ArrayList<>();
  public ArrayList<String> turboIds = new ArrayList<>();
  public ArrayList<Color> turboColors = new ArrayList<>();
  public ArrayList<NpcSpawn> npcSpawns = new ArrayList<>();
  public ArrayList<String> namesToDisplay = new ArrayList<>();
  public ArrayList<String> ignoreDeadExclusionList = new ArrayList<>();
  public ArrayList<String> ignoreDeadExclusionIDList = new ArrayList<>();
  public ArrayList<String> hiddenNames = new ArrayList<>();
  public ArrayList<String> hiddenIds = new ArrayList<>();
  public ArrayList<String> beneathNPCs = new ArrayList<>();

  public void clearAll() {
    tileNames.clear();
    tileIds.clear();
    trueTileNames.clear();
    trueTileIds.clear();
    swTileNames.clear();
    swTileIds.clear();
    swTrueTileNames.clear();
    swTrueTileIds.clear();
    hullNames.clear();
    hullIds.clear();
    areaNames.clear();
    areaIds.clear();
    outlineNames.clear();
    outlineIds.clear();
    clickboxNames.clear();
    clickboxIds.clear();
    turboNames.clear();
    turboIds.clear();
    hiddenNames.clear();
    hiddenIds.clear();
    beneathNPCs.clear();
    ignoreDeadExclusionList.clear();
    ignoreDeadExclusionIDList.clear();
    namesToDisplay.clear();
    npcSpawns.clear();
  }
}

package com.betternpchighlight.data;

import lombok.Getter;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;

@Getter()
public class NpcSpawn {
	public int index;
	public String name;
	public int id;
	public int size;
	public int diedOnTick;
	public int respawnTime;
	public ArrayList<WorldPoint> spawnLocations;
	public WorldPoint spawnPoint;
	public boolean dead;

	public NpcSpawn(NPC npc) {
		this.name = npc.getName();
		this.id = npc.getId();
		this.index = npc.getIndex();
		this.spawnLocations = new ArrayList<>();
		this.respawnTime = -1;
		this.diedOnTick = -1;
		this.spawnPoint = null;
		this.dead = true;

		final NPCComposition composition = npc.getTransformedComposition();
		size = composition != null ? composition.getSize() : 1;
	}
}

package com.betternpchighlight.data;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.NPC;
import net.runelite.client.plugins.slayer.SlayerPluginService;
import java.awt.Color;

import com.betternpchighlight.BetterNpcHighlightConfig;
import com.betternpchighlight.BetterNpcHighlightPlugin;
import com.betternpchighlight.managers.ConfigTransformManager;
import com.betternpchighlight.managers.SlayerPluginManager;

@Getter
@Setter
public class NPCInfo {
	NPC npc;
	HighlightColor tile;
	HighlightColor trueTile;
	HighlightColor swTile;
	HighlightColor swTrueTile;
	HighlightColor hull;
	HighlightColor area;
	HighlightColor outline;
	HighlightColor clickbox;
	HighlightColor turbo;
	boolean isTask;
	boolean ignoreDead;

	public NPCInfo(NPC npc, BetterNpcHighlightPlugin plugin, SlayerPluginService slayerPluginService, BetterNpcHighlightConfig config,
			SlayerPluginManager slayerPluginIntegration, NameAndIdContainer nameAndIdContainer, ConfigTransformManager configTransformManager) {
		Color globalTileColor = config.useGlobalTileColor() ? config.globalTileColor() : null;
		Color globalFillColor = config.useGlobalTileColor() ? config.globalFillColor() : null;

		this.npc = npc;
		this.tile = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.tileNames, nameAndIdContainer.tileIds, npc,
				coalesceColor(globalTileColor, config.tileColor()), coalesceColor(globalFillColor, config.tileFillColor()));
		this.trueTile = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.trueTileNames, nameAndIdContainer.trueTileIds, npc,
				coalesceColor(globalTileColor, config.trueTileColor()), coalesceColor(globalFillColor, config.trueTileFillColor()));
		this.swTile = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.swTileNames, nameAndIdContainer.swTileIds, npc,
				coalesceColor(globalTileColor, config.swTileColor()), coalesceColor(globalFillColor, config.swTileFillColor()));
		this.swTrueTile = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.swTrueTileNames, nameAndIdContainer.swTrueTileIds, npc,
				coalesceColor(globalTileColor, config.swTrueTileColor()), coalesceColor(globalFillColor, config.swTrueTileFillColor()));

		this.hull = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.hullNames, nameAndIdContainer.hullIds, npc, config.hullColor(),
				config.hullFillColor());
		this.area = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.areaNames, nameAndIdContainer.areaIds, npc, config.areaColor(),
				null);
		this.outline = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.outlineNames, nameAndIdContainer.outlineIds, npc,
				config.outlineColor(), null);
		this.clickbox = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.clickboxNames, nameAndIdContainer.clickboxIds, npc,
				config.clickboxColor(), config.clickboxFillColor());
		this.turbo = configTransformManager.getHighlightColorFromNameOrIdList(nameAndIdContainer.turboNames, nameAndIdContainer.turboIds, npc, null, null);
		this.isTask = slayerPluginIntegration.checkSlayerPluginEnabled() && slayerPluginService != null
				&& slayerPluginService.getTargets().contains(npc);
		this.ignoreDead = configTransformManager.isInSpecificNameList(nameAndIdContainer.ignoreDeadExclusionList, npc)
				|| configTransformManager.isInSpecificIdList(nameAndIdContainer.ignoreDeadExclusionIDList, npc);
	}

	private Color coalesceColor(Color color, Color defaultColor) {
		return color != null ? color : defaultColor;
	}
}

package com.betternpchighlight.data;

import java.awt.Color;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class HighlightColor {
	boolean isHighlight;
	Color color;
	Color fill;
}

package com.betternpchighlight.managers;

import java.awt.Color;
import java.util.Random;

import javax.inject.Inject;

import com.betternpchighlight.BetterNpcHighlightConfig;
import com.betternpchighlight.data.NPCInfo;
import com.betternpchighlight.data.NameAndIdContainer;

import net.runelite.api.Client;
import net.runelite.client.util.WildcardMatcher;

public class ColorManager {
  @Inject
  private Client client;

  @Inject
  private BetterNpcHighlightConfig config;

  @Inject
  private NameAndIdContainer nameAndIdContainer;

  /**
   * Color of the NPC in the list Used for Minimap dot and displayed names
   *
   * @return Color
   */
  public Color getSpecificColor(NPCInfo n) {
    if (n.isTask() && config.slayerHighlight())
    {
      return config.slayerRave() ? getRaveColor(config.slayerRaveSpeed()) : config.taskColor();
    }
    else if (n.getTile().isHighlight() && config.tileHighlight())
    {
      return config.tileRave() ? getRaveColor(config.tileRaveSpeed()) : n.getTile().getColor();
    }
    else if (n.getTrueTile().isHighlight() && config.trueTileHighlight())
    {
      return config.trueTileRave() ? getRaveColor(config.trueTileRaveSpeed()) : n.getTrueTile().getColor();
    }
    else if (n.getSwTile().isHighlight() && config.swTileHighlight())
    {
      return config.swTileRave() ? getRaveColor(config.swTileRaveSpeed()) : n.getSwTile().getColor();
    }
    else if (n.getSwTrueTile().isHighlight() && config.swTrueTileHighlight())
    {
      return config.swTrueTileRave() ? getRaveColor(config.swTrueTileRaveSpeed()) : n.getSwTrueTile().getColor();
    }
    else if (n.getHull().isHighlight() && config.hullHighlight())
    {
      return config.hullRave() ? getRaveColor(config.hullRaveSpeed()) : n.getHull().getColor();
    }
    else if (n.getArea().isHighlight() && config.areaHighlight())
    {
      return config.areaRave() ? getRaveColor(config.areaRaveSpeed()) : n.getArea().getColor();
    }
    else if (n.getOutline().isHighlight() && config.outlineHighlight())
    {
      return config.outlineRave() ? getRaveColor(config.outlineRaveSpeed()) : n.getOutline().getColor();
    }
    else if (n.getClickbox().isHighlight() && config.clickboxHighlight())
    {
      return config.clickboxRave() ? getRaveColor(config.clickboxRaveSpeed()) : n.getClickbox().getColor();
    }
    else if (n.getTurbo().isHighlight() && config.turboHighlight())
    {
      return getTurboIndex(n.getNpc().getId(), n.getNpc().getName()) != -1
          ? nameAndIdContainer.turboColors.get(getTurboIndex(n.getNpc().getId(), n.getNpc().getName()))
          : Color.WHITE;
    }
    else
    {
      return null;
    }
  }

  /**
   * Returns color of either the config or a preset if selected
   *
   * @return Color
   */
  public Color getHighlightColor(String preset, Color color) {
    switch (preset) {
    case "1":
      return config.presetColor1();
    case "2":
      return config.presetColor2();
    case "3":
      return config.presetColor3();
    case "4":
      return config.presetColor4();
    case "5":
      return config.presetColor5();
    }

    return color;
  }

  /**
   * Returns fill color of either the config or a preset if selected
   *
   * @return Color
   */
  public Color getHighlightFillColor(String preset, Color color) {
    switch (preset) {
    case "1":
      return config.presetFillColor1();
    case "2":
      return config.presetFillColor2();
    case "3":
      return config.presetFillColor3();
    case "4":
      return config.presetFillColor4();
    case "5":
      return config.presetFillColor5();
    }

    return color;
  }

  /**
   * Color of the tag menu (ex. "Tag-Hull")
   *
   * @return Color
   */
  public Color getTagColor() {
    if (config.useGlobalTileColor())
    {
      return config.globalTileColor();
    }
    if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.TILE))
    {
      return config.tileColor();
    }
    else if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.TRUE_TILE))
    {
      return config.trueTileColor();
    }
    else if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.SW_TILE))
    {
      return config.swTileColor();
    }
    else if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.SW_TRUE_TILE))
    {
      return config.swTrueTileColor();
    }
    else if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.HULL))
    {
      return config.hullColor();
    }
    else if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.AREA))
    {
      return config.areaColor();
    }
    else if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.OUTLINE))
    {
      return config.outlineColor();
    }
    else if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.CLICKBOX))
    {
      return config.clickboxColor();
    }
    else
    {
      return Color.getHSBColor(new Random().nextFloat(), 1.0F, 1.0F);
    }
  }

  public Color getRaveColor(int speed) {
    int ticks = speed / 20;
    return Color.getHSBColor((client.getGameCycle() % ticks) / ((float) ticks), 1.0f, 1.0f);
  }

  public int getTurboIndex(int id, String name) {
    if (nameAndIdContainer.turboIds.contains(String.valueOf(id)))
    {
      return nameAndIdContainer.turboIds.indexOf(String.valueOf(id));
    }
    else if (name != null)
    {
      int index = nameAndIdContainer.turboIds.size();
      for (String str : nameAndIdContainer.turboNames)
      {
        if (WildcardMatcher.matches(str, name))
        {
          return index;
        }
        index++;
      }
    }
    return -1;
  }
}

package com.betternpchighlight.managers;

import java.awt.Color;
import java.util.ArrayList;
import javax.inject.Inject;
import org.apache.commons.lang3.StringUtils;

import com.betternpchighlight.BetterNpcHighlightConfig;
import com.betternpchighlight.BetterNpcHighlightPlugin;
import com.betternpchighlight.data.HighlightColor;
import com.betternpchighlight.data.NPCInfo;
import com.betternpchighlight.data.NameAndIdContainer;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.slayer.SlayerPluginService;
import net.runelite.client.util.Text;
import net.runelite.client.util.WildcardMatcher;

public class ConfigTransformManager {
	@Inject
	private ClientThread clientThread;

	@Inject
	private Client client;

	@Inject
	private SlayerPluginService slayerPluginService;

	@Inject
	private SlayerPluginManager slayerPluginIntegration;

	@Inject
	private NameAndIdContainer nameAndIdContainer;

	@Inject
	private BetterNpcHighlightConfig config;

	@Inject
	private BetterNpcHighlightPlugin plugin;

	@Inject
	private ColorManager colorManager;

	public void splitList(String configStr, ArrayList<String> strList) {
		clientThread.invokeLater(() -> {
			if (!configStr.equals(""))
			{
				for (String str : configStr.split(","))
				{
					if (!str.trim().equals(""))
					{
						strList.add(str.trim().toLowerCase());
					}
				}
			}
		});
	}

	public void updateConfig(ConfigChanged event) {
		switch (event.getKey()) {
		case "tileNames":
			nameAndIdContainer.tileNames.clear();
			splitList(config.tileNames(), nameAndIdContainer.tileNames);
			recreateList();
			break;
		case "tileIds":
			nameAndIdContainer.tileIds.clear();
			splitList(config.tileIds(), nameAndIdContainer.tileIds);
			recreateList();
			break;
		case "trueTileNames":
			nameAndIdContainer.trueTileNames.clear();
			splitList(config.trueTileNames(), nameAndIdContainer.trueTileNames);
			recreateList();
			break;
		case "trueTileIds":
			nameAndIdContainer.trueTileIds.clear();
			splitList(config.trueTileIds(), nameAndIdContainer.trueTileIds);
			recreateList();
			break;
		case "swTileNames":
			nameAndIdContainer.swTileNames.clear();
			splitList(config.swTileNames(), nameAndIdContainer.swTileNames);
			recreateList();
			break;
		case "swTileIds":
			nameAndIdContainer.swTileIds.clear();
			splitList(config.swTileIds(), nameAndIdContainer.swTileIds);
			recreateList();
			break;
		case "swTrueTileNames":
			nameAndIdContainer.swTrueTileNames.clear();
			splitList(config.swTrueTileNames(), nameAndIdContainer.swTrueTileNames);
			recreateList();
			break;
		case "swTrueTileIds":
			nameAndIdContainer.swTrueTileIds.clear();
			splitList(config.swTrueTileIds(), nameAndIdContainer.swTrueTileIds);
			recreateList();
			break;
		case "hullNames":
			nameAndIdContainer.hullNames.clear();
			splitList(config.hullNames(), nameAndIdContainer.hullNames);
			recreateList();
			break;
		case "hullIds":
			nameAndIdContainer.hullIds.clear();
			splitList(config.hullIds(), nameAndIdContainer.hullIds);
			recreateList();
			break;
		case "areaNames":
			nameAndIdContainer.areaNames.clear();
			splitList(config.areaNames(), nameAndIdContainer.areaNames);
			recreateList();
			break;
		case "areaIds":
			nameAndIdContainer.areaIds.clear();
			splitList(config.areaIds(), nameAndIdContainer.areaIds);
			recreateList();
			break;
		case "outlineNames":
			nameAndIdContainer.outlineNames.clear();
			splitList(config.outlineNames(), nameAndIdContainer.outlineNames);
			recreateList();
			break;
		case "outlineIds":
			nameAndIdContainer.outlineIds.clear();
			splitList(config.outlineIds(), nameAndIdContainer.outlineIds);
			recreateList();
			break;
		case "clickboxNames":
			nameAndIdContainer.clickboxNames.clear();
			splitList(config.clickboxNames(), nameAndIdContainer.clickboxNames);
			recreateList();
			break;
		case "clickboxIds":
			nameAndIdContainer.clickboxIds.clear();
			splitList(config.clickboxIds(), nameAndIdContainer.clickboxIds);
			recreateList();
			break;
		case "turboNames":
			nameAndIdContainer.turboNames.clear();
			splitList(config.turboNames(), nameAndIdContainer.turboNames);
			recreateList();
			break;
		case "turboIds":
			nameAndIdContainer.turboIds.clear();
			splitList(config.turboIds(), nameAndIdContainer.turboIds);
			recreateList();
			break;
		case "displayName":
			nameAndIdContainer.namesToDisplay.clear();
			splitList(config.displayName(), nameAndIdContainer.namesToDisplay);
			break;
		case "ignoreDeadExclusion":
			nameAndIdContainer.ignoreDeadExclusionList.clear();
			splitList(config.ignoreDeadExclusion(), nameAndIdContainer.ignoreDeadExclusionList);
			recreateList();
			break;
		case "ignoreDeadExclusionID":
			nameAndIdContainer.ignoreDeadExclusionIDList.clear();
			splitList(config.ignoreDeadExclusionID(), nameAndIdContainer.ignoreDeadExclusionIDList);
			recreateList();
			break;
		case "turboHighlight":
			if (event.getNewValue().equals("true"))
			{
				if (!nameAndIdContainer.confirmedWarning)
				{
					plugin.showEpilepsyWarning();
				}
				else
				{
					nameAndIdContainer.confirmedWarning = false;
				}
			}
			break;
		case "entityHiderNames":
			nameAndIdContainer.hiddenNames.clear();
			splitList(config.entityHiderNames(), nameAndIdContainer.hiddenNames);
			break;
		case "entityHiderIds":
			nameAndIdContainer.hiddenIds.clear();
			splitList(config.entityHiderIds(), nameAndIdContainer.hiddenIds);
			break;
		case "drawBeneathList":
			nameAndIdContainer.beneathNPCs.clear();
			splitList(config.drawBeneathList(), nameAndIdContainer.beneathNPCs);
			break;
		case "slayerHighlight":
			slayerPluginIntegration.enableSlayerPlugin();
			break;
		case "tileColor":
		case "tileFillColor":
		case "trueTileColor":
		case "trueTileFillColor":
		case "swTileColor":
		case "swTileFillColor":
		case "swTrueTileColor":
		case "swTrueTileFillColor":
		case "hullColor":
		case "hullFillColor":
		case "areaColor":
		case "outlineColor":
		case "clickboxColor":
		case "clickboxFillColor":
		case "taskColor":
		case "taskFillColor":
		case "presetColor1":
		case "presetFillColor1":
		case "presetColor2":
		case "presetFillColor2":
		case "presetColor3":
		case "presetFillColor3":
		case "presetColor4":
		case "presetFillColor4":
		case "presetColor5":
		case "presetFillColor5":
		case "useGlobalTileColor":
		case "globalTileColor":
		case "globalFillColor":
			recreateList();
			break;
		}
	}

	public void recreateList() {
		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN && client.getLocalPlayer() != null
					&& client.getLocalPlayer().getPlayerComposition() != null)
			{
				nameAndIdContainer.npcList.clear();

				for (NPC npc : client.getTopLevelWorldView().npcs())
				{
					NPCInfo npcInfo = plugin.checkValidNPC(npc);
					if (npcInfo != null)
					{
						nameAndIdContainer.npcList.add(npcInfo);
					}
				}
				nameAndIdContainer.currentTask = slayerPluginService.getTask();
			}
		});
	}

	public String configListToString(boolean tagOrHide, String name, ArrayList<String> strList, int preset) {
		if (tagOrHide)
		{
			boolean foundName = false;
			String newName = preset > 0 ? name + ":" + preset : name;
			for (String str : strList)
			{
				if (str.startsWith(name + ":") || str.equalsIgnoreCase(name))
				{
					strList.set(strList.indexOf(str), newName);
					foundName = true;
				}
			}

			if (!foundName)
			{
				strList.add(newName);
			}
		}
		else
		{
			strList.removeIf(str -> str.toLowerCase().startsWith(name + ":") || str.equalsIgnoreCase(name));
		}
		return Text.toCSV(strList);
	}

	public void updateListConfig(boolean add, String name, int preset) {
		if (!add)
		{
			removeAllTagStyles(name);
		}
		else
		{
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.TILE))
			{
				config.setTileNames(configListToString(add, name, nameAndIdContainer.tileNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.TRUE_TILE))
			{
				config.setTrueTileNames(configListToString(add, name, nameAndIdContainer.trueTileNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.SW_TILE))
			{
				config.setSwTileNames(configListToString(add, name, nameAndIdContainer.swTileNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.SW_TRUE_TILE))
			{
				config.setSwTrueTileNames(configListToString(add, name, nameAndIdContainer.swTrueTileNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.HULL))
			{
				config.setHullNames(configListToString(add, name, nameAndIdContainer.hullNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.AREA))
			{
				config.setAreaNames(configListToString(add, name, nameAndIdContainer.areaNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.OUTLINE))
			{
				config.setOutlineNames(configListToString(add, name, nameAndIdContainer.outlineNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.CLICKBOX))
			{
				config.setClickboxNames(configListToString(add, name, nameAndIdContainer.clickboxNames, preset));
			}
			if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.TURBO))
			{
				config.setTurboNames(configListToString(add, name, nameAndIdContainer.turboNames, 0));
			}
		}
	}

	public HighlightColor getHighlightColorFromNameOrIdList(ArrayList<String> strList, ArrayList<String> idList, NPC npc, Color configColor,
			Color configFillColor) {
		for (String entry : idList)
		{
			int id = -1;
			String preset = "";
			if (entry.contains(":"))
			{
				String[] strArr = entry.split(":");
				if (StringUtils.isNumeric(strArr[0]))
				{
					id = Integer.parseInt(strArr[0]);
				}
				preset = strArr[1];
			}
			else if (StringUtils.isNumeric(entry))
			{
				id = Integer.parseInt(entry);
			}

			if (id == npc.getId())
			{
				return new HighlightColor(true, colorManager.getHighlightColor(preset, configColor),
						colorManager.getHighlightFillColor(preset, configFillColor));
			}
		}

		if (npc.getName() != null)
		{
			String name = npc.getName().toLowerCase();
			for (String entry : strList)
			{
				String nameStr = entry;
				String preset = "";
				if (entry.contains(":"))
				{
					String[] strArr = entry.split(":");
					nameStr = strArr[0];
					preset = strArr[1];
				}

				if (WildcardMatcher.matches(nameStr, name))
				{
					return new HighlightColor(true, colorManager.getHighlightColor(preset, configColor),
							colorManager.getHighlightFillColor(preset, configFillColor));
				}
			}
		}
		return new HighlightColor(false, configColor, configFillColor);
	}

	public boolean isInSpecificNameList(ArrayList<String> strList, NPC npc) {
		if (npc.getName() != null)
		{
			String name = npc.getName().toLowerCase();
			for (String entry : strList)
			{
				String nameStr = entry;
				if (entry.contains(":"))
				{
					String[] strArr = entry.split(":");
					nameStr = strArr[0];
				}

				if (WildcardMatcher.matches(nameStr, name))
				{
					return true;
				}
			}
		}
		return false;
	}

	public boolean isInSpecificIdList(ArrayList<String> strList, NPC npc) {
		int id = npc.getId();
		for (String entry : strList)
		{
			String idStr = entry;
			if (entry.contains(":"))
			{
				String[] strArr = entry.split(":");
				idStr = strArr[0];
			}

			if (StringUtils.isNumeric(idStr) && Integer.parseInt(idStr) == id)
			{
				return true;
			}
		}
		return false;
	}

	public boolean isInAnyNameList(NPC npc) {
		return isInSpecificNameList(nameAndIdContainer.tileNames, npc) || isInSpecificNameList(nameAndIdContainer.trueTileNames, npc)
				|| isInSpecificNameList(nameAndIdContainer.swTileNames, npc) || isInSpecificNameList(nameAndIdContainer.swTrueTileNames, npc)
				|| isInSpecificNameList(nameAndIdContainer.hullNames, npc) || isInSpecificNameList(nameAndIdContainer.areaNames, npc)
				|| isInSpecificNameList(nameAndIdContainer.outlineNames, npc) || isInSpecificNameList(nameAndIdContainer.clickboxNames, npc)
				|| isInSpecificNameList(nameAndIdContainer.turboNames, npc);
	}

	public boolean isInAnyIdList(NPC npc) {
		return isInSpecificIdList(nameAndIdContainer.tileIds, npc) || isInSpecificIdList(nameAndIdContainer.trueTileIds, npc)
				|| isInSpecificIdList(nameAndIdContainer.swTileIds, npc) || isInSpecificIdList(nameAndIdContainer.swTrueTileIds, npc)
				|| isInSpecificIdList(nameAndIdContainer.hullIds, npc) || isInSpecificIdList(nameAndIdContainer.areaIds, npc)
				|| isInSpecificIdList(nameAndIdContainer.outlineIds, npc) || isInSpecificIdList(nameAndIdContainer.clickboxIds, npc)
				|| isInSpecificIdList(nameAndIdContainer.turboIds, npc);
	}

	public boolean isInAnyList(NPC npc) {
		return isInAnyNameList(npc) || isInAnyIdList(npc);
	}

	private void removeAllTagStyles(String name) {
		config.setTileNames(configListToString(false, name, nameAndIdContainer.tileNames, 0));
		config.setTrueTileNames(configListToString(false, name, nameAndIdContainer.trueTileNames, 0));
		config.setSwTileNames(configListToString(false, name, nameAndIdContainer.swTileNames, 0));
		config.setSwTrueTileNames(configListToString(false, name, nameAndIdContainer.swTrueTileNames, 0));
		config.setHullNames(configListToString(false, name, nameAndIdContainer.hullNames, 0));
		config.setAreaNames(configListToString(false, name, nameAndIdContainer.areaNames, 0));
		config.setOutlineNames(configListToString(false, name, nameAndIdContainer.outlineNames, 0));
		config.setClickboxNames(configListToString(false, name, nameAndIdContainer.clickboxNames, 0));
		config.setTurboNames(configListToString(false, name, nameAndIdContainer.turboNames, 0));
	}
}

package com.betternpchighlight.managers;

import java.util.Optional;

import javax.inject.Inject;

import com.betternpchighlight.BetterNpcHighlightConfig;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;

@Slf4j
public class SlayerPluginManager {
  @Inject
  private PluginManager pluginManager;

  @Inject
  private BetterNpcHighlightConfig config;

  public boolean checkSlayerPluginEnabled() {
    final Optional<Plugin> slayerPlugin = pluginManager.getPlugins().stream().filter(p -> p.getName().equals("Slayer")).findFirst();
    return slayerPlugin.isPresent() && pluginManager.isPluginEnabled(slayerPlugin.get());
  }

  public String enableSlayerPlugin() {
    try
    {
      final Optional<Plugin> slayerPlugin = pluginManager.getPlugins().stream().filter(p -> p.getName().equals("Slayer")).findFirst();
      if (slayerPlugin.isPresent() && !pluginManager.isPluginEnabled(slayerPlugin.get()) && config.slayerHighlight())
      {
        pluginManager.setPluginEnabled(slayerPlugin.get(), true);
        pluginManager.startPlugin(slayerPlugin.get());
        return "";
      }
    }
    catch (PluginInstantiationException ex)
    {
      log.error("error starting slayer plugin", ex);
    }

    return "";
  }
}

package com.betternpchighlight.managers;

import java.awt.event.KeyEvent;

import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;

import com.betternpchighlight.BetterNpcHighlightConfig;
import com.betternpchighlight.data.NameAndIdContainer;
import com.google.inject.Singleton;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.VarClientInt;
import net.runelite.api.VarClientStr;
import net.runelite.api.vars.InputType;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;

@Singleton
public class ChatCommandManager implements KeyListener {
  @Inject
  private Client client;

  @Inject
  private BetterNpcHighlightConfig config;

  @Inject
  private KeyManager keyManager;

  @Inject
  private ChatMessageManager chatMessageManager;

  @Inject
  private ConfigTransformManager configTransformManager;

  @Inject
  private NameAndIdContainer nameAndIdContainer;

  private static final String HIDE_COMMAND = "!hide";
  private static final String UNHIDE_COMMAND = "!unhide";
  private static final String TAG_COMMAND = "!tag";
  private static final String UNTAG_COMMAND = "!untag";

  public void registerKeyListener() {
    keyManager.registerKeyListener(this);
  }

  public void unregisterKeyListener() {
    keyManager.unregisterKeyListener(this);
  }

  public void keyPressed(KeyEvent e) {
    // Enter is pressed
    if (e.getKeyCode() == 10)
    {
      int inputType = client.getVarcIntValue(VarClientInt.INPUT_TYPE);
      if (inputType == InputType.PRIVATE_MESSAGE.getType() || inputType == InputType.NONE.getType())
      {
        int var;
        if (inputType == InputType.PRIVATE_MESSAGE.getType())
        {
          var = VarClientStr.INPUT_TEXT;
        }
        else
        {
          var = VarClientStr.CHATBOX_TYPED_TEXT;
        }

        if (client.getVarcStrValue(var) != null && !client.getVarcStrValue(var).isEmpty())
        {
          String text = client.getVarcStrValue(var).toLowerCase();
          if (config.entityHiderCommands() && (text.startsWith(HIDE_COMMAND) || text.startsWith(UNHIDE_COMMAND)))
          {
            hideNPCCommand(text, var);
          }
          else if (config.tagCommands() && (text.startsWith(TAG_COMMAND) || text.startsWith(UNTAG_COMMAND)))
          {
            tagNPCCommand(text, var);
          }
        }
      }
    }
  }

  public void hideNPCCommand(String text, int var) {
    String npcToHide = text.replace(text.startsWith(HIDE_COMMAND) ? HIDE_COMMAND : UNHIDE_COMMAND, "").trim();
    boolean hide = text.startsWith(HIDE_COMMAND);

    if (!npcToHide.isEmpty())
    {
      if (StringUtils.isNumeric(npcToHide))
      {
        config.setEntityHiderIds(configTransformManager.configListToString(hide, npcToHide, nameAndIdContainer.hiddenIds, 0));
      }
      else
      {
        config.setEntityHiderNames(configTransformManager.configListToString(hide, npcToHide, nameAndIdContainer.hiddenNames, 0));
      }
    }
    else
    {
      printMessage("Please enter a valid NPC name or ID!");
    }

    // Set typed text to nothing
    client.setVarcStrValue(var, "");
  }

  public void tagNPCCommand(String text, int var) {
    if (text.trim().equals(TAG_COMMAND) || text.trim().equals(UNTAG_COMMAND))
    {
      printMessage("Please enter a tag abbreviation followed by a valid NPC name or ID!");
    }
    else if (text.contains(TAG_COMMAND + " ") || text.contains(UNTAG_COMMAND + " "))
    {
      printMessage("Please enter a valid tag abbreviation!");
    }
    else if (!text.trim().contains(" "))
    {
      printMessage("Please enter a valid NPC name or ID!");
    }
    else
    {
      String npcToTag = text.substring(text.indexOf(" ") + 1).toLowerCase().trim();
      int preset = 0;
      if (npcToTag.contains(":"))
      {
        String[] strArr = npcToTag.split(":");
        npcToTag = strArr[0];
        if (StringUtils.isNumeric(strArr[1]))
          preset = Integer.parseInt(strArr[1]);
      }
      boolean tag = text.startsWith(TAG_COMMAND);

      if (!npcToTag.isEmpty())
      {
        if (validateCommand(text, "t ") || validateCommand(text, "tile "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setTileIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.tileIds, preset));
          }
          else
          {
            config.setTileNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.tileNames, preset));
          }
        }
        else if (validateCommand(text, "tt ") || validateCommand(text, "truetile "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setTrueTileIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.trueTileIds, preset));
          }
          else
          {
            config.setTrueTileNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.trueTileNames, preset));
          }
        }
        else if (validateCommand(text, "sw ") || validateCommand(text, "swt ") || validateCommand(text, "southwesttile ")
            || validateCommand(text, "southwest ") || validateCommand(text, "swtile ") || validateCommand(text, "southwestt "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setSwTileIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.swTileIds, preset));
          }
          else
          {
            config.setSwTileNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.swTileNames, preset));
          }
        }
        else if (validateCommand(text, "swtt ") || validateCommand(text, "swtruetile ") || validateCommand(text, "southwesttruetile ")
            || validateCommand(text, "southwesttt "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setSwTrueTileIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.swTrueTileIds, preset));
          }
          else
          {
            config.setSwTrueTileNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.swTrueTileNames, preset));
          }
        }
        else if (validateCommand(text, "h ") || validateCommand(text, "hull "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setHullIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.hullIds, preset));
          }
          else
          {
            config.setHullNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.hullNames, preset));
          }
        }
        else if (validateCommand(text, "a ") || validateCommand(text, "area "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setAreaIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.areaIds, preset));
          }
          else
          {
            config.setAreaNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.areaNames, preset));
          }
        }
        else if (validateCommand(text, "o ") || validateCommand(text, "outline "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setOutlineIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.outlineIds, preset));
          }
          else
          {
            config.setOutlineNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.outlineNames, preset));
          }
        }
        else if (validateCommand(text, "c ") || validateCommand(text, "clickbox ") || validateCommand(text, "box "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setClickboxIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.clickboxIds, preset));
          }
          else
          {
            config.setClickboxNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.clickboxNames, preset));
          }
        }
        else if (validateCommand(text, "tu ") || validateCommand(text, "turbo "))
        {
          if (StringUtils.isNumeric(npcToTag))
          {
            config.setTurboIds(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.turboIds, preset));
          }
          else
          {
            config.setTurboNames(configTransformManager.configListToString(tag, npcToTag, nameAndIdContainer.turboNames, preset));
          }
        }
      }
    }
    // Set typed text to nothing
    client.setVarcStrValue(var, "");
  }

  public boolean validateCommand(String command, String type) {
    return command.startsWith(TAG_COMMAND + type) || command.startsWith(UNTAG_COMMAND + type);
  }

  public void printMessage(String msg) {
    final ChatMessageBuilder message = new ChatMessageBuilder().append(ChatColorType.HIGHLIGHT).append(msg);

    chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.CONSOLE).runeLiteFormattedMessage(message.build()).build());
  }

  public void keyReleased(KeyEvent e) {
  }

  public void keyTyped(KeyEvent e) {
  }
}

package com.betternpchighlight.managers;

import static net.runelite.api.MenuAction.MENU_ACTION_DEPRIORITIZE_OFFSET;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Set;

import javax.inject.Inject;

import com.betternpchighlight.BetterNpcHighlightConfig;
import com.betternpchighlight.data.NPCInfo;
import com.betternpchighlight.data.NameAndIdContainer;
import com.google.common.collect.ImmutableSet;

import net.runelite.api.Client;
import net.runelite.api.KeyCode;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;

public class MenuManager {
  @Inject
  private Client client;

  @Inject
  private BetterNpcHighlightConfig config;

  @Inject
  private NameAndIdContainer nameAndIdContainer;

  @Inject
  private NpcUtil npcUtil;

  @Inject
  private ColorManager colorManager;

  @Inject
  private ConfigTransformManager configTransformManager;

  private static final Set<MenuAction> NPC_MENU_ACTIONS = ImmutableSet.of(MenuAction.NPC_FIRST_OPTION, MenuAction.NPC_SECOND_OPTION,
      MenuAction.NPC_THIRD_OPTION, MenuAction.NPC_FOURTH_OPTION, MenuAction.NPC_FIFTH_OPTION, MenuAction.WIDGET_TARGET_ON_NPC,
      MenuAction.ITEM_USE_ON_NPC);

  public void craftMenu(MenuEntryAdded event) {
    // add craft menu entry
    int type = event.getType();
    if (type >= MENU_ACTION_DEPRIORITIZE_OFFSET)
    {
      type -= MENU_ACTION_DEPRIORITIZE_OFFSET;
    }

    final MenuAction menuAction = MenuAction.of(type);

    // Colorize all name in all menu entries except examine and tag/untag
    if (NPC_MENU_ACTIONS.contains(menuAction))
    {
      NPC npc = client.getTopLevelWorldView().npcs().byIndex(event.getIdentifier());

      // Get name for menu item coloring
      Color color = null;
      if (npcUtil.isDying(npc))
      {
        color = config.deadNpcMenuColor();
      }
      else if (config.highlightMenuNames() && npc.getName() != null && configTransformManager.isInAnyList(npc))
      {
        for (NPCInfo npcInfo : nameAndIdContainer.npcList)
        {
          if (npcInfo.getNpc() == npc)
          {
            color = colorManager.getSpecificColor(npcInfo);
            break;
          }
        }

        if (color == null)
        {
          color = colorManager.getTagColor();
        }
      }

      if (color != null)
      {
        MenuEntry[] menuEntries = client.getMenuEntries();
        final MenuEntry menuEntry = menuEntries[menuEntries.length - 1];
        final String target = ColorUtil.prependColorTag(Text.removeTags(event.getTarget()), color);
        menuEntry.setTarget(target);
        client.setMenuEntries(menuEntries);
      }
    }
    // Colorize examine and tag/untag menu options
    else if (menuAction == MenuAction.EXAMINE_NPC)
    {
      final NPC npc = client.getTopLevelWorldView().npcs().byIndex(event.getIdentifier());

      if (npc != null)
      {
        String option;
        // if there is an NPC name AND
        // ((tag style none is selected, and so is another option) OR
        // (tag style none is not selected, and another is))
        if (npc.getName() != null
            && ((config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.NONE) && config.tagStyleModeSet().size() > 1)
                || (!config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.NONE) && !config.tagStyleModeSet().isEmpty())))
        {
          // If the NPC is tagged by name in any way, show "Untag-NPC", else show "Tag-NPC"
          if (configTransformManager.isInAnyList(npc))
          {
            option = "Untag-NPC";
          }
          else
          {
            option = "Tag-NPC";
          }

          // If the menu option is untag, and either highlight menu names is on or dead NPC color is set, colorize the existing examine entry
          if (option.equals("Untag-NPC") && (config.highlightMenuNames() || (npc.isDead() && config.deadNpcMenuColor() != null)))
          {
            MenuEntry[] menuEntries = client.getMenuEntries();
            final MenuEntry menuEntry = menuEntries[menuEntries.length - 1];

            Color displayColor = getNpcDisplayColor(npc);
            if (npc.isDead() && config.deadNpcMenuColor() != null)
            {
              displayColor = config.deadNpcMenuColor();
            }

            String target = ColorUtil.prependColorTag(Text.removeTags(event.getTarget()), displayColor);
            menuEntry.setTarget(target);
            client.setMenuEntries(menuEntries);
          }

          // If shift is held, handle the tag/untag menu option
          if (client.isKeyPressed(KeyCode.KC_SHIFT))
          {
            String tagAllEntry;
            // If highlight menu names is enabled or the npc is dead and there is a dead color set
            if (config.highlightMenuNames() || (npc.isDead() && config.deadNpcMenuColor() != null))
            {
              Color displayColor = getNpcDisplayColor(npc);
              if (npc.isDead() && config.deadNpcMenuColor() != null)
              {
                displayColor = config.deadNpcMenuColor();
              }
              String colorCode = Integer.toHexString(displayColor.getRGB());
              tagAllEntry = "<col=" + colorCode.substring(2) + ">" + Text.removeTags(event.getTarget());
            }
            else
            {
              tagAllEntry = event.getTarget();
            }

            int idx = -1;
            MenuEntry parent = client.createMenuEntry(idx).setOption(option).setTarget(tagAllEntry).setIdentifier(event.getIdentifier())
                .setParam0(event.getActionParam0()).setParam1(event.getActionParam1()).setType(MenuAction.RUNELITE).onClick(this::tagNPC);

            if (parent != null)
            {
              this.customColorTag(idx, npc, parent);
            }
          }
        }
      }
    }
  }

  public void customColorTag(int idx, NPC npc, MenuEntry parent) {

    // add X amount of preset colors based off of config
    if (config.presetColorAmount() != BetterNpcHighlightConfig.presetColorAmount.ZERO)
    {
      List<Color> colors = loadPresetColors();
      Menu submenu = parent.createSubMenu();

      if (colors.size() > 0)
      {
        int index = 1;
        for (final Color c : colors)
        {
          if (c != null)
          {
            int preset = index;
            submenu.createMenuEntry(0).setOption(ColorUtil.prependColorTag("Preset color " + index, c)).setType(MenuAction.RUNELITE)
                .onClick(e -> {
                  if (npc.getName() != null)
                  {
                    configTransformManager.updateListConfig(true, npc.getName().toLowerCase(), preset);
                  }
                });
            index++;
          }
        }
      }

      for (NPCInfo n : nameAndIdContainer.npcList)
      {
        if (n.getNpc() == npc)
        {
          submenu.createMenuEntry(0).setOption("Reset color").setType(MenuAction.RUNELITE).onClick(e -> {
            if (npc.getName() != null)
            {
              configTransformManager.updateListConfig(true, npc.getName().toLowerCase(), 0);
            }
          });
          break;
        }
      }
    }
  }

  private void tagNPC(MenuEntry event) {
    if (event.getType() == MenuAction.RUNELITE)
    {
      if (event.getOption().equals("Tag-NPC") || event.getOption().equals("Untag-NPC"))
      {
        final int id = event.getIdentifier();
        final NPC npc = client.getTopLevelWorldView().npcs().byIndex(id);
        boolean tag = event.getOption().equals("Tag-NPC");
        if (npc.getName() != null)
        {
          configTransformManager.updateListConfig(tag, npc.getName().toLowerCase(), 0);
        }
      }
    }
  }

  /**
   * Gets the color to display for an NPC, considering turbo mode, specific highlight color, or fallback to tag color.
   */
  private Color getNpcDisplayColor(NPC npc) {
    if (config.tagStyleModeSet().contains(BetterNpcHighlightConfig.tagStyleMode.TURBO)
        && configTransformManager.isInSpecificNameList(nameAndIdContainer.turboNames, npc))
    {
      return Color.getHSBColor(new Random().nextFloat(), 1.0F, 1.0F);
    }

    NPCInfo npcInfo = nameAndIdContainer.getNpcInfoByNpc(npc);
    if (npcInfo != null)
    {
      Color highlightColor = colorManager.getSpecificColor(npcInfo);
      if (highlightColor != null)
      {
        return highlightColor;
      }
    }

    return colorManager.getTagColor();
  }

  /**
   * Loads preset colors based on config amount setting.
   */
  private List<Color> loadPresetColors() {
    List<Color> colors = new ArrayList<>();
    BetterNpcHighlightConfig.presetColorAmount amount = config.presetColorAmount();

    if (amount == BetterNpcHighlightConfig.presetColorAmount.ONE)
    {
      colors.add(config.presetColor1());
    }
    else if (amount == BetterNpcHighlightConfig.presetColorAmount.TWO)
    {
      colors.add(config.presetColor1());
      colors.add(config.presetColor2());
    }
    else if (amount == BetterNpcHighlightConfig.presetColorAmount.THREE)
    {
      colors.add(config.presetColor1());
      colors.add(config.presetColor2());
      colors.add(config.presetColor3());
    }
    else if (amount == BetterNpcHighlightConfig.presetColorAmount.FOUR)
    {
      colors.add(config.presetColor1());
      colors.add(config.presetColor2());
      colors.add(config.presetColor3());
      colors.add(config.presetColor4());
    }
    else if (amount == BetterNpcHighlightConfig.presetColorAmount.FIVE)
    {
      colors.add(config.presetColor1());
      colors.add(config.presetColor2());
      colors.add(config.presetColor3());
      colors.add(config.presetColor4());
      colors.add(config.presetColor5());
    }

    return colors;
  }
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.betternpchighlight;

import com.betternpchighlight.data.NPCInfo;
import com.betternpchighlight.data.NameAndIdContainer;
import com.betternpchighlight.data.NpcSpawn;
import com.betternpchighlight.managers.ChatCommandManager;
import com.betternpchighlight.managers.ConfigTransformManager;
import com.betternpchighlight.managers.MenuManager;
import com.betternpchighlight.managers.SlayerPluginManager;
import com.betternpchighlight.overlays.BetterNpcHighlightOverlay;
import com.betternpchighlight.overlays.BetterNpcMinimapOverlay;
import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;
import java.awt.event.KeyEvent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.vars.InputType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.Hooks;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.slayer.SlayerPlugin;
import net.runelite.client.plugins.slayer.SlayerPluginService;
import net.runelite.client.ui.overlay.OverlayManager;
import org.apache.commons.lang3.StringUtils;
import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;
import java.util.Random;
import java.util.Set;

@Slf4j
@PluginDescriptor(name = "Better NPC Highlight", description = "A more customizable NPC highlight", tags = { "npc", "highlight",
		"indicators", "respawn", "hide", "entity", "custom", "id", "name" })
@PluginDependency(SlayerPlugin.class)
public class BetterNpcHighlightPlugin extends Plugin {
	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BetterNpcHighlightOverlay overlay;

	@Inject
	private BetterNpcHighlightConfig config;

	@Inject
	private BetterNpcMinimapOverlay mapOverlay;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Hooks hooks;

	@Inject
	private SlayerPluginService slayerPluginService;

	@Inject
	private ClientThread clientThread;

	@Inject
	private SlayerPluginManager slayerPluginIntegration;

	@Inject
	private MenuManager menuManager;

	@Inject
	private ConfigTransformManager configTransformManager;

	@Inject
	private NameAndIdContainer nameAndIdContainer;

	@Inject
	private ChatCommandManager chatCommandManager;

	public Instant lastTickUpdate;
	public int turboModeStyle = 0;
	public int turboTileWidth = 0;
	public int turboOutlineWidth = 0;
	public int turboOutlineFeather = 0;

	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	@Provides
	BetterNpcHighlightConfig providesConfig(ConfigManager configManager) {
		migrateOldConfig(configManager);
		return configManager.getConfig(BetterNpcHighlightConfig.class);
	}

	protected void startUp() {
		clientThread.invokeLater(() -> {
			reset();
			overlayManager.add(overlay);
			overlayManager.add(mapOverlay);
			configTransformManager.splitList(config.tileNames(), nameAndIdContainer.tileNames);
			configTransformManager.splitList(config.tileIds(), nameAndIdContainer.tileIds);
			configTransformManager.splitList(config.trueTileNames(), nameAndIdContainer.trueTileNames);
			configTransformManager.splitList(config.trueTileIds(), nameAndIdContainer.trueTileIds);
			configTransformManager.splitList(config.swTileNames(), nameAndIdContainer.swTileNames);
			configTransformManager.splitList(config.swTileIds(), nameAndIdContainer.swTileIds);
			configTransformManager.splitList(config.swTrueTileNames(), nameAndIdContainer.swTrueTileNames);
			configTransformManager.splitList(config.swTrueTileIds(), nameAndIdContainer.swTrueTileIds);
			configTransformManager.splitList(config.hullNames(), nameAndIdContainer.hullNames);
			configTransformManager.splitList(config.hullIds(), nameAndIdContainer.hullIds);
			configTransformManager.splitList(config.areaNames(), nameAndIdContainer.areaNames);
			configTransformManager.splitList(config.areaIds(), nameAndIdContainer.areaIds);
			configTransformManager.splitList(config.outlineNames(), nameAndIdContainer.outlineNames);
			configTransformManager.splitList(config.outlineIds(), nameAndIdContainer.outlineIds);
			configTransformManager.splitList(config.clickboxNames(), nameAndIdContainer.clickboxNames);
			configTransformManager.splitList(config.clickboxIds(), nameAndIdContainer.clickboxIds);
			configTransformManager.splitList(config.turboNames(), nameAndIdContainer.turboNames);
			configTransformManager.splitList(config.turboIds(), nameAndIdContainer.turboIds);
			configTransformManager.splitList(config.displayName(), nameAndIdContainer.namesToDisplay);
			configTransformManager.splitList(config.ignoreDeadExclusion(), nameAndIdContainer.ignoreDeadExclusionList);
			configTransformManager.splitList(config.ignoreDeadExclusionID(), nameAndIdContainer.ignoreDeadExclusionIDList);
			configTransformManager.splitList(config.entityHiderNames(), nameAndIdContainer.hiddenNames);
			configTransformManager.splitList(config.entityHiderIds(), nameAndIdContainer.hiddenIds);
			configTransformManager.splitList(config.drawBeneathList(), nameAndIdContainer.beneathNPCs);

			hooks.registerRenderableDrawListener(drawListener);
			chatCommandManager.registerKeyListener();
			slayerPluginIntegration.enableSlayerPlugin();

			if (client.getGameState() == GameState.LOGGED_IN)
			{
				configTransformManager.recreateList();
			}
		});
	}

	protected void shutDown() {
		reset();
		overlayManager.remove(overlay);
		overlayManager.remove(mapOverlay);
		hooks.unregisterRenderableDrawListener(drawListener);
		chatCommandManager.unregisterKeyListener();
	}

	private void migrateOldConfig(ConfigManager configManager) {
		// migrate old tag style mode config into the new set version of config if
		// possible
		try
		{
			String oldValue = configManager.getConfiguration(BetterNpcHighlightConfig.CONFIG_GROUP, "tagStyleMode");
			String newValue = configManager.getConfiguration(BetterNpcHighlightConfig.CONFIG_GROUP, "tagStyleModeSet");
			if (oldValue != null && newValue == null)
			{
				log.debug("BNPC: Migrating old tag style mode config to new set version");

				// Parse the old enum string value
				BetterNpcHighlightConfig.tagStyleMode oldMode = BetterNpcHighlightConfig.tagStyleMode.valueOf(oldValue.toUpperCase());

				// Convert to Set format
				Set<BetterNpcHighlightConfig.tagStyleMode> newModeSet = Set.of(oldMode);

				// Save the properly serialized Set to the new config
				configManager.setConfiguration(BetterNpcHighlightConfig.CONFIG_GROUP, "tagStyleModeSet", newModeSet);
			}
		}
		catch (Exception e)
		{
			// Could not migrate, ignore
			log.debug("BNPC: Could not migrate old tag style mode config to new set version", e);
		}
	}

	private void reset() {
		nameAndIdContainer.npcList.clear();
		nameAndIdContainer.currentTask = "";
		nameAndIdContainer.clearAll();
		turboModeStyle = 0;
		turboTileWidth = 0;
		turboOutlineWidth = 0;
		turboOutlineFeather = 0;
		nameAndIdContainer.confirmedWarning = false;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (event.getGroup().equals(BetterNpcHighlightConfig.CONFIG_GROUP))
		{
			configTransformManager.updateConfig(event);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOGIN_SCREEN || event.getGameState() == GameState.HOPPING)
		{
			nameAndIdContainer.npcSpawns.clear();
			nameAndIdContainer.npcList.clear();
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		menuManager.craftMenu(event);
	}

	@Subscribe(priority = -1)
	public void onNpcSpawned(NpcSpawned event) {
		NPC npc = event.getNpc();

		for (NpcSpawn n : nameAndIdContainer.npcSpawns)
		{
			if (npc.getIndex() == n.index && npc.getId() == n.id)
			{
				if (n.spawnPoint == null && n.diedOnTick != -1)
				{
					WorldPoint wp = client.isInInstancedRegion() ? WorldPoint.fromLocalInstance(client, npc.getLocalLocation())
							: WorldPoint.fromLocal(client, npc.getLocalLocation());
					if (n.spawnLocations.contains(wp))
					{
						n.spawnPoint = wp;
						n.respawnTime = client.getTickCount() - n.diedOnTick + 1;
					}
					else
					{
						n.spawnLocations.add(wp);
					}
				}
				n.dead = false;
				break;
			}
		}

		NPCInfo npcInfo = checkValidNPC(npc);
		if (npcInfo != null)
		{
			nameAndIdContainer.npcList.add(npcInfo);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event) {
		NPC npc = event.getNpc();

		if (npc.isDead())
		{
			if (nameAndIdContainer.npcList.stream().anyMatch(n -> n.getNpc() == npc)
					&& nameAndIdContainer.npcSpawns.stream().noneMatch(n -> n.index == npc.getIndex()))
			{
				nameAndIdContainer.npcSpawns.add(new NpcSpawn(npc));
			}
			else
			{
				for (NpcSpawn n : nameAndIdContainer.npcSpawns)
				{
					if (npc.getIndex() == n.index && npc.getId() == n.id)
					{
						n.diedOnTick = client.getTickCount();
						n.dead = true;
						break;
					}
				}
			}
		}

		nameAndIdContainer.npcList.removeIf(n -> n.getNpc().getIndex() == npc.getIndex());
	}

	@Subscribe(priority = -1)
	public void onNpcChanged(NpcChanged event) {
		NPC npc = event.getNpc();

		nameAndIdContainer.npcList.removeIf(n -> n.getNpc().getIndex() == npc.getIndex());

		NPCInfo npcInfo = checkValidNPC(npc);
		if (npcInfo != null)
		{
			nameAndIdContainer.npcList.add(npcInfo);
		}
	}

	@Subscribe(priority = -1)
	public void onGameTick(GameTick event) {
		if (slayerPluginIntegration.checkSlayerPluginEnabled() && !nameAndIdContainer.currentTask.equals(slayerPluginService.getTask()))
		{
			configTransformManager.recreateList();
		}

		lastTickUpdate = Instant.now();
		nameAndIdContainer.turboColors.clear();
		for (int i = 0; i < nameAndIdContainer.npcList.size(); i++)
		{
			nameAndIdContainer.turboColors.add(Color.getHSBColor(new Random().nextFloat(), 1.0F, 1.0F));
		}
		turboModeStyle = new Random().nextInt(6);
		turboTileWidth = new Random().nextInt(10) + 1;
		turboOutlineWidth = new Random().nextInt(50) + 1;
		turboOutlineFeather = new Random().nextInt(4);
	}

	public NPCInfo checkValidNPC(NPC npc) {
		NPCInfo n = new NPCInfo(npc, this, slayerPluginService, config, slayerPluginIntegration, nameAndIdContainer, configTransformManager);
		if (n.getTile().isHighlight() || n.getTrueTile().isHighlight() || n.getSwTile().isHighlight() || n.getSwTrueTile().isHighlight()
				|| n.getHull().isHighlight() || n.getArea().isHighlight() || n.getOutline().isHighlight() || n.getClickbox().isHighlight()
				|| n.getTurbo().isHighlight() || n.isTask())
		{
			return n;
		}
		return null;
	}

	public void showEpilepsyWarning() {
		configManager.setConfiguration(BetterNpcHighlightConfig.CONFIG_GROUP, "turboHighlight", false);
		Font font = (Font) UIManager.get("OptionPane.buttonFont");
		Object[] options = { "Okay, I accept the risk", "No, this is an affront to my eyes" };
		JLabel label = new JLabel(
				"<html><p>Turning this on will cause any NPCs highlighted with this style to change colors and styles rapidly.</p></html>");

		if (JOptionPane.showOptionDialog(new JFrame(), label, "EPILEPSY WARNING - Occular Abhorrence", JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE, null, options, options[1]) == 0)
		{
			nameAndIdContainer.confirmedWarning = true;
			configManager.setConfiguration(BetterNpcHighlightConfig.CONFIG_GROUP, "turboHighlight", true);
		}
		UIManager.put("OptionPane.buttonFont", font);
	}

	@VisibleForTesting
	boolean shouldDraw(Renderable renderable, boolean drawingUI) {
		if (renderable instanceof NPC)
		{
			NPC npc = (NPC) renderable;

			if (config.entityHiderToggle())
			{
				return !nameAndIdContainer.hiddenIds.contains(String.valueOf(npc.getId()))
						&& (npc.getName() != null && !nameAndIdContainer.hiddenNames.contains(npc.getName().toLowerCase()));
			}
		}
		return true;
	}
}

package com.betternpchighlight;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BetterNpcHighlightTest {
  public static void main(String[] args) throws Exception {
    ExternalPluginManager.loadBuiltin(BetterNpcHighlightPlugin.class);
    RuneLite.main(args);
  }
}
