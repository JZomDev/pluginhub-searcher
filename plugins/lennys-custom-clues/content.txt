package com.lennyscustomclues;

import net.runelite.api.AnimationID;

public class AnimationTriggers
{
	public static boolean isTriggerAnimation(int animationId)
	{
		// Check for digging animation
		if (animationId == AnimationID.DIG) // 830
		{
			return true;
		}

		// Check for supported emote animations
		return EmoteData.getEmoteName(animationId) != null && !EmoteData.getEmoteName(animationId).equals("Unknown Emote");
	}

	public static boolean isDigAnimation(int animationId)
	{
		return animationId == AnimationID.DIG;
	}

	public static boolean isEmoteAnimation(int animationId)
	{
		String emoteName = EmoteData.getEmoteName(animationId);
		return emoteName != null && !emoteName.equals("Unknown Emote");
	}
}
package com.lennyscustomclues;

import com.lennyscustomclues.constraints.*;
import com.lennyscustomclues.ApiClient.GameStateSubmission;
import java.util.ArrayList;
import java.util.List;

public class AnswerBuilder
{
	private String rewardText;
	private List<Constraint> constraints;

	public AnswerBuilder()
	{
		this.constraints = new ArrayList<>();
		this.rewardText = "";
	}

	public void addConstraint(Constraint constraint)
	{
		constraints.add(constraint);
	}

	public void removeConstraint(int index)
	{
		if (index >= 0 && index < constraints.size())
		{
			constraints.remove(index);
		}
	}

	public String toJson()
	{
		// TODO: Convert answer structure to JSON for export/API submission
		return "{}";
	}

	public void clear()
	{
		constraints.clear();
		rewardText = "";
	}

	// Getters and setters
	public String getRewardText() { return rewardText; }
	public void setRewardText(String rewardText) { this.rewardText = rewardText; }
	public List<Constraint> getConstraints() { return constraints; }
	public void setConstraints(List<Constraint> constraints) { this.constraints = constraints; }

	public int getConstraintCount()
	{
		return constraints.size();
	}

	public Constraint getConstraint(int index)
	{
		if (index >= 0 && index < constraints.size())
		{
			return constraints.get(index);
		}
		return null;
	}
}
package com.lennyscustomclues;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Singleton
public class ApiClient
{
	private static final String API_BASE_URL = "https://us-central1-spatial-cargo-409717.cloudfunctions.net/lennys-labyrinth-api";
	private static final String SUBMIT_GUESS_ENDPOINT = "/submit-guess";
	private static final String VALIDATE_KEY_ENDPOINT = "/validate-key";
	private static final String CREATE_ANSWER_ENDPOINT = "/create-answer";
	private static final String ANSWER_ENDPOINT = "/answer";
	private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

	private final OkHttpClient httpClient;
	private final Gson gson;

	@Inject
	public ApiClient(OkHttpClient okHttpClient, Gson gson)
	{
		this.httpClient = okHttpClient;
		this.gson = gson;
	}

	public CompletableFuture<ApiResponse> submitGuess(GameStateSubmission gameState)
	{
		CompletableFuture<ApiResponse> future = new CompletableFuture<>();

		try
		{
			String json = gson.toJson(gameState);
			log.debug("Submitting game state JSON: {}", json);

			RequestBody body = RequestBody.create(JSON, json);
			Request request = new Request.Builder()
				.url(API_BASE_URL + SUBMIT_GUESS_ENDPOINT)
				.post(body)
				.build();

			httpClient.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.error("API request failed", e);
					future.complete(ApiResponse.error("Network error: " + e.getMessage()));
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					try (response)
					{
						String responseBody = response.body() != null ? response.body().string() : "";
						log.debug("API response code: {}, body: {}", response.code(), responseBody);

						if (response.isSuccessful())
						{
							try
							{
								ApiResponse apiResponse = gson.fromJson(responseBody, ApiResponse.class);
								future.complete(apiResponse);
							}
							catch (JsonSyntaxException e)
							{
								log.error("Failed to parse API response JSON", e);
								future.complete(ApiResponse.error("Invalid response format"));
							}
						}
						else
						{
							String errorMessage = String.format("Server error %d: %s", response.code(), responseBody);
							future.complete(ApiResponse.error(errorMessage));
						}
					}
					catch (IOException e)
					{
						log.error("Failed to read response body", e);
						future.complete(ApiResponse.error("Failed to read server response"));
					}
				}
			});
		}
		catch (Exception e)
		{
			log.error("Failed to create API request", e);
			future.complete(ApiResponse.error("Request creation failed: " + e.getMessage()));
		}

		return future;
	}

	public CompletableFuture<ApiResponse> validateEventKey(String eventKey)
	{
		CompletableFuture<ApiResponse> future = new CompletableFuture<>();

		try
		{
			log.debug("Validating event key: {}", eventKey);

			String encodedEventKey = URLEncoder.encode(eventKey, StandardCharsets.UTF_8);
			Request request = new Request.Builder()
				.url(API_BASE_URL + VALIDATE_KEY_ENDPOINT + "/" + encodedEventKey)
				.get()
				.build();

			httpClient.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.error("Event key validation request failed", e);
					future.complete(ApiResponse.errorWithType("NETWORK_ERROR", "Network error: " + e.getMessage()));
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					try (response)
					{
						String responseBody = response.body() != null ? response.body().string() : "";
						log.debug("Event key validation response code: {}, body: {}", response.code(), responseBody);

						if (response.isSuccessful())
						{
							try
							{
								ApiResponse apiResponse = gson.fromJson(responseBody, ApiResponse.class);
								future.complete(apiResponse);
							}
							catch (JsonSyntaxException e)
							{
								log.error("Failed to parse event key validation response JSON", e);
								future.complete(ApiResponse.errorWithType("PARSE_ERROR", "Invalid response format"));
							}
						}
						else if (response.code() == 404)
						{
							// 404 means event key not found - this is expected for invalid keys
							future.complete(ApiResponse.errorWithType("KEY_NOT_FOUND", "Event key not found"));
						}
						else
						{
							// Any other HTTP error (500, 503, etc.)
							log.error("Server error response: {} - {}", response.code(), responseBody);
							future.complete(ApiResponse.errorWithType("SERVER_ERROR", "Server error: " + response.code()));
						}
					}
					catch (IOException e)
					{
						log.error("Failed to read event key validation response body", e);
						future.complete(ApiResponse.errorWithType("IO_ERROR", "Failed to read server response"));
					}
				}
			});
		}
		catch (Exception e)
		{
			log.error("Failed to create event key validation request", e);
			future.complete(ApiResponse.errorWithType("REQUEST_ERROR", "Request creation failed: " + e.getMessage()));
		}

		return future;
	}

	public CompletableFuture<ApiResponse> createAnswer(String eventKey, String secretKey, AnswerBuilder answerBuilder)
	{
		CompletableFuture<ApiResponse> future = new CompletableFuture<>();

		try
		{
			// Build the answer request
			CreateAnswerRequest request = new CreateAnswerRequest();
			request.event_key = eventKey;
			request.answer = new AnswerData();
			request.answer.reward_text = answerBuilder.getRewardText();
			request.answer.secret_key = secretKey.isEmpty() ? null : secretKey;

			// Convert constraints to JSON
			request.answer.constraints = new java.util.ArrayList<>();
			for (int i = 0; i < answerBuilder.getConstraintCount(); i++)
			{
				com.lennyscustomclues.constraints.Constraint constraint = answerBuilder.getConstraint(i);
				// Serialize each constraint as a map
				if (constraint instanceof com.lennyscustomclues.constraints.LocationConstraint)
				{
					com.lennyscustomclues.constraints.LocationConstraint locConstraint = (com.lennyscustomclues.constraints.LocationConstraint) constraint;
					java.util.Map<String, Object> constraintMap = new java.util.HashMap<>();
					constraintMap.put("constraint_type", locConstraint.getConstraintType());
					constraintMap.put("type", locConstraint.getType());

					if (locConstraint.getExactX() != null) constraintMap.put("exact_x", locConstraint.getExactX());
					if (locConstraint.getExactY() != null) constraintMap.put("exact_y", locConstraint.getExactY());
					if (locConstraint.getMinX() != null) constraintMap.put("min_x", locConstraint.getMinX());
					if (locConstraint.getMaxX() != null) constraintMap.put("max_x", locConstraint.getMaxX());
					if (locConstraint.getMinY() != null) constraintMap.put("min_y", locConstraint.getMinY());
					if (locConstraint.getMaxY() != null) constraintMap.put("max_y", locConstraint.getMaxY());
					if (locConstraint.getPlane() != null) constraintMap.put("plane", locConstraint.getPlane());
					if (locConstraint.getTolerance() != null) constraintMap.put("tolerance", locConstraint.getTolerance());

					request.answer.constraints.add(constraintMap);
				}
				else if (constraint instanceof com.lennyscustomclues.constraints.ActionConstraint)
				{
					com.lennyscustomclues.constraints.ActionConstraint actionConstraint = (com.lennyscustomclues.constraints.ActionConstraint) constraint;
					java.util.Map<String, Object> constraintMap = new java.util.HashMap<>();
					constraintMap.put("constraint_type", actionConstraint.getConstraintType());
					constraintMap.put("type", actionConstraint.getType());

					if (actionConstraint.getEmoteId() != null) constraintMap.put("emote_id", actionConstraint.getEmoteId());
					if (actionConstraint.getEmoteIds() != null) constraintMap.put("emote_ids", actionConstraint.getEmoteIds());
					if (actionConstraint.getNpcId() != null) constraintMap.put("npc_id", actionConstraint.getNpcId());
					if (actionConstraint.getNpcIds() != null) constraintMap.put("npc_ids", actionConstraint.getNpcIds());
					if (actionConstraint.getInteractionType() != null) constraintMap.put("interaction_type", actionConstraint.getInteractionType());
					if (actionConstraint.getInteractionTypes() != null) constraintMap.put("interaction_types", actionConstraint.getInteractionTypes());

					request.answer.constraints.add(constraintMap);
				}
			}

			String json = gson.toJson(request);
			log.debug("Creating answer JSON: {}", json);

			RequestBody body = RequestBody.create(JSON, json);
			Request httpRequest = new Request.Builder()
				.url(API_BASE_URL + CREATE_ANSWER_ENDPOINT)
				.post(body)
				.build();

			httpClient.newCall(httpRequest).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.error("Create answer request failed", e);
					future.complete(ApiResponse.errorWithType("NETWORK_ERROR", "Network error: " + e.getMessage()));
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					try (response)
					{
						String responseBody = response.body() != null ? response.body().string() : "";
						log.debug("Create answer response code: {}, body: {}", response.code(), responseBody);

						if (response.code() == 201)
						{
							// 201 Created - success
							try
							{
								ApiResponse apiResponse = gson.fromJson(responseBody, ApiResponse.class);
								future.complete(apiResponse);
							}
							catch (JsonSyntaxException e)
							{
								log.error("Failed to parse create answer response JSON", e);
								future.complete(ApiResponse.success("Answer created successfully"));
							}
						}
						else if (response.code() == 409)
						{
							// 409 Conflict - key already exists
							future.complete(ApiResponse.errorWithType("KEY_ALREADY_EXISTS", "Event key already exists"));
						}
						else if (response.code() == 400)
						{
							// 400 Bad Request - validation error
							try
							{
								ApiResponse apiResponse = gson.fromJson(responseBody, ApiResponse.class);
								future.complete(apiResponse);
							}
							catch (JsonSyntaxException e)
							{
								future.complete(ApiResponse.errorWithType("VALIDATION_ERROR", "Invalid request: " + responseBody));
							}
						}
						else
						{
							// Any other HTTP error (500, 503, etc.)
							log.error("Server error response: {} - {}", response.code(), responseBody);
							future.complete(ApiResponse.errorWithType("SERVER_ERROR", "Server error: " + response.code()));
						}
					}
					catch (IOException e)
					{
						log.error("Failed to read create answer response body", e);
						future.complete(ApiResponse.errorWithType("IO_ERROR", "Failed to read server response"));
					}
				}
			});
		}
		catch (Exception e)
		{
			log.error("Failed to create answer request", e);
			future.complete(ApiResponse.errorWithType("REQUEST_ERROR", "Request creation failed: " + e.getMessage()));
		}

		return future;
	}

	public CompletableFuture<GetAnswerResponse> getAnswer(String eventKey, String secretKey)
	{
		CompletableFuture<GetAnswerResponse> future = new CompletableFuture<>();

		try
		{
			log.debug("Getting answer for event key: {}", eventKey);

			String encodedEventKey = URLEncoder.encode(eventKey, StandardCharsets.UTF_8);
			String encodedSecretKey = URLEncoder.encode(secretKey, StandardCharsets.UTF_8);

			Request request = new Request.Builder()
				.url(API_BASE_URL + ANSWER_ENDPOINT + "/" + encodedEventKey + "?secret_key=" + encodedSecretKey)
				.get()
				.build();

			httpClient.newCall(request).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.error("Get answer request failed", e);
					future.complete(GetAnswerResponse.error("NETWORK_ERROR", "Network error: " + e.getMessage()));
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					try (response)
					{
						String responseBody = response.body() != null ? response.body().string() : "";
						log.debug("Get answer response code: {}, body: {}", response.code(), responseBody);

						if (response.isSuccessful())
						{
							try
							{
								GetAnswerResponse apiResponse = gson.fromJson(responseBody, GetAnswerResponse.class);
								future.complete(apiResponse);
							}
							catch (JsonSyntaxException e)
							{
								log.error("Failed to parse get answer response JSON", e);
								future.complete(GetAnswerResponse.error("PARSE_ERROR", "Invalid response format"));
							}
						}
						else if (response.code() == 404)
						{
							future.complete(GetAnswerResponse.error("NOT_FOUND", "Event key not found"));
						}
						else if (response.code() == 401)
						{
							future.complete(GetAnswerResponse.error("UNAUTHORIZED", "Invalid secret key"));
						}
						else if (response.code() == 400)
						{
							future.complete(GetAnswerResponse.error("BAD_REQUEST", "Bad request"));
						}
						else
						{
							log.error("Server error response: {} - {}", response.code(), responseBody);
							future.complete(GetAnswerResponse.error("SERVER_ERROR", "Server error: " + response.code()));
						}
					}
					catch (IOException e)
					{
						log.error("Failed to read get answer response body", e);
						future.complete(GetAnswerResponse.error("IO_ERROR", "Failed to read server response"));
					}
				}
			});
		}
		catch (Exception e)
		{
			log.error("Failed to create get answer request", e);
			future.complete(GetAnswerResponse.error("REQUEST_ERROR", "Request creation failed: " + e.getMessage()));
		}

		return future;
	}

	public CompletableFuture<ApiResponse> updateAnswer(String eventKey, String secretKey, AnswerBuilder answerBuilder)
	{
		CompletableFuture<ApiResponse> future = new CompletableFuture<>();

		try
		{
			// Build the answer data
			AnswerData answerData = new AnswerData();
			answerData.reward_text = answerBuilder.getRewardText();

			// Convert constraints to JSON
			answerData.constraints = new java.util.ArrayList<>();
			for (int i = 0; i < answerBuilder.getConstraintCount(); i++)
			{
				com.lennyscustomclues.constraints.Constraint constraint = answerBuilder.getConstraint(i);
				// Serialize each constraint as a map
				if (constraint instanceof com.lennyscustomclues.constraints.LocationConstraint)
				{
					com.lennyscustomclues.constraints.LocationConstraint locConstraint = (com.lennyscustomclues.constraints.LocationConstraint) constraint;
					java.util.Map<String, Object> constraintMap = new java.util.HashMap<>();
					constraintMap.put("constraint_type", locConstraint.getConstraintType());
					constraintMap.put("type", locConstraint.getType());

					if (locConstraint.getExactX() != null) constraintMap.put("exact_x", locConstraint.getExactX());
					if (locConstraint.getExactY() != null) constraintMap.put("exact_y", locConstraint.getExactY());
					if (locConstraint.getMinX() != null) constraintMap.put("min_x", locConstraint.getMinX());
					if (locConstraint.getMaxX() != null) constraintMap.put("max_x", locConstraint.getMaxX());
					if (locConstraint.getMinY() != null) constraintMap.put("min_y", locConstraint.getMinY());
					if (locConstraint.getMaxY() != null) constraintMap.put("max_y", locConstraint.getMaxY());
					if (locConstraint.getPlane() != null) constraintMap.put("plane", locConstraint.getPlane());
					if (locConstraint.getTolerance() != null) constraintMap.put("tolerance", locConstraint.getTolerance());

					answerData.constraints.add(constraintMap);
				}
				else if (constraint instanceof com.lennyscustomclues.constraints.ActionConstraint)
				{
					com.lennyscustomclues.constraints.ActionConstraint actionConstraint = (com.lennyscustomclues.constraints.ActionConstraint) constraint;
					java.util.Map<String, Object> constraintMap = new java.util.HashMap<>();
					constraintMap.put("constraint_type", actionConstraint.getConstraintType());
					constraintMap.put("type", actionConstraint.getType());

					if (actionConstraint.getEmoteId() != null) constraintMap.put("emote_id", actionConstraint.getEmoteId());
					if (actionConstraint.getEmoteIds() != null) constraintMap.put("emote_ids", actionConstraint.getEmoteIds());
					if (actionConstraint.getNpcId() != null) constraintMap.put("npc_id", actionConstraint.getNpcId());
					if (actionConstraint.getNpcIds() != null) constraintMap.put("npc_ids", actionConstraint.getNpcIds());
					if (actionConstraint.getInteractionType() != null) constraintMap.put("interaction_type", actionConstraint.getInteractionType());
					if (actionConstraint.getInteractionTypes() != null) constraintMap.put("interaction_types", actionConstraint.getInteractionTypes());

					answerData.constraints.add(constraintMap);
				}
			}

			String json = gson.toJson(answerData);
			log.debug("Updating answer JSON: {}", json);

			String encodedEventKey = URLEncoder.encode(eventKey, StandardCharsets.UTF_8);
			String encodedSecretKey = URLEncoder.encode(secretKey, StandardCharsets.UTF_8);

			RequestBody body = RequestBody.create(JSON, json);
			Request httpRequest = new Request.Builder()
				.url(API_BASE_URL + ANSWER_ENDPOINT + "/" + encodedEventKey + "?secret_key=" + encodedSecretKey)
				.patch(body)
				.build();

			httpClient.newCall(httpRequest).enqueue(new Callback()
			{
				@Override
				public void onFailure(Call call, IOException e)
				{
					log.error("Update answer request failed", e);
					future.complete(ApiResponse.errorWithType("NETWORK_ERROR", "Network error: " + e.getMessage()));
				}

				@Override
				public void onResponse(Call call, Response response)
				{
					try (response)
					{
						String responseBody = response.body() != null ? response.body().string() : "";
						log.debug("Update answer response code: {}, body: {}", response.code(), responseBody);

						if (response.isSuccessful())
						{
							try
							{
								ApiResponse apiResponse = gson.fromJson(responseBody, ApiResponse.class);
								future.complete(apiResponse);
							}
							catch (JsonSyntaxException e)
							{
								log.error("Failed to parse update answer response JSON", e);
								future.complete(ApiResponse.success("Answer updated successfully"));
							}
						}
						else if (response.code() == 404)
						{
							future.complete(ApiResponse.errorWithType("NOT_FOUND", "Event key not found"));
						}
						else if (response.code() == 401)
						{
							future.complete(ApiResponse.errorWithType("UNAUTHORIZED", "Invalid secret key"));
						}
						else if (response.code() == 400)
						{
							try
							{
								ApiResponse apiResponse = gson.fromJson(responseBody, ApiResponse.class);
								future.complete(apiResponse);
							}
							catch (JsonSyntaxException e)
							{
								future.complete(ApiResponse.errorWithType("VALIDATION_ERROR", "Invalid request: " + responseBody));
							}
						}
						else
						{
							log.error("Server error response: {} - {}", response.code(), responseBody);
							future.complete(ApiResponse.errorWithType("SERVER_ERROR", "Server error: " + response.code()));
						}
					}
					catch (IOException e)
					{
						log.error("Failed to read update answer response body", e);
						future.complete(ApiResponse.errorWithType("IO_ERROR", "Failed to read server response"));
					}
				}
			});
		}
		catch (Exception e)
		{
			log.error("Failed to create update answer request", e);
			future.complete(ApiResponse.errorWithType("REQUEST_ERROR", "Request creation failed: " + e.getMessage()));
		}

		return future;
	}

	// Inner classes for data structures matching the server API
	public static class GameStateSubmission
	{
		public LocationData location;
		public List<ItemData> inventory;
		public List<ItemData> worn_items;
		public Integer emote_id;
		public Integer npc_id;
		public String interaction_type;
		public String event_key;
		public String rsn;

		public GameStateSubmission(LocationData location, List<ItemData> inventory, 
			List<ItemData> wornItems, Integer emoteId, Integer npcId, 
			String interactionType, String eventKey, String rsn)
		{
			this.location = location;
			this.inventory = inventory;
			this.worn_items = wornItems;
			this.emote_id = emoteId;
			this.npc_id = npcId;
			this.interaction_type = interactionType;
			this.event_key = eventKey;
			this.rsn = rsn;
		}
	}

	public static class LocationData
	{
		public WorldCoords world;
		public LocalCoords local;

		public LocationData(WorldCoords world, LocalCoords local)
		{
			this.world = world;
			this.local = local;
		}
	}

	public static class WorldCoords
	{
		public int x;
		public int y;
		public int plane;

		public WorldCoords(int x, int y, int plane)
		{
			this.x = x;
			this.y = y;
			this.plane = plane;
		}
	}

	public static class LocalCoords
	{
		public int sceneX;
		public int sceneY;

		public LocalCoords(int sceneX, int sceneY)
		{
			this.sceneX = sceneX;
			this.sceneY = sceneY;
		}
	}

	public static class ItemData
	{
		public int slot;
		public int id;
		public int quantity;

		public ItemData(int slot, int id, int quantity)
		{
			this.slot = slot;
			this.id = id;
			this.quantity = quantity;
		}
	}

	public static class ApiResponse
	{
		public boolean success;
		public String message;
		public String errorType; // For client-side error handling

		public ApiResponse(boolean success, String message)
		{
			this.success = success;
			this.message = message;
			this.errorType = null;
		}

		private ApiResponse(boolean success, String message, String errorType)
		{
			this.success = success;
			this.message = message;
			this.errorType = errorType;
		}

		public static ApiResponse success(String message)
		{
			return new ApiResponse(true, message);
		}

		public static ApiResponse error(String message)
		{
			return new ApiResponse(false, message);
		}

		public static ApiResponse errorWithType(String errorType, String message)
		{
			return new ApiResponse(false, message, errorType);
		}
	}

	public static class CreateAnswerRequest
	{
		public String event_key;
		public AnswerData answer;
	}

	public static class AnswerData
	{
		public String reward_text;
		public List<java.util.Map<String, Object>> constraints;
		public String secret_key;
	}

	public static class GetAnswerResponse
	{
		public String reward_text;
		public List<java.util.Map<String, Object>> constraints;
		public List<PlayerCompletion> completed_by;
		public String errorType;
		public String errorMessage;

		public boolean isSuccess()
		{
			return errorType == null;
		}

		public static GetAnswerResponse error(String errorType, String errorMessage)
		{
			GetAnswerResponse response = new GetAnswerResponse();
			response.errorType = errorType;
			response.errorMessage = errorMessage;
			return response;
		}
	}

	public static class PlayerCompletion
	{
		public String rsn;
		public String timestamp;
	}
}
package com.lennyscustomclues;

import net.runelite.api.Client;
import net.runelite.api.SoundEffectID;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Slf4j
@Singleton
public class CelebrationManager
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private LennysCustomCluesConfig config;

	@Inject
	private ScheduledExecutorService scheduledExecutorService;

	public void triggerVictoryCelebration(String puzzleName)
	{
		clientThread.invokeLater(() -> {
			log.info("Triggering victory celebration for puzzle: {}", puzzleName);

			if (config.showCelebrationSound())
			{
				playVictorySound();
			}

			if (config.showCelebrationFireworks())
			{
				triggerFireworks();
			}
		});
	}

	private void playVictorySound()
	{
		try
		{
			// Play a celebratory sound - using the triumphant fanfare sound (ID 2930)
			client.playSoundEffect(2930);
			log.debug("Played victory sound effect");
		}
		catch (Exception e)
		{
			log.warn("Failed to play victory sound", e);
		}
	}

	private void triggerFireworks()
	{
		try
		{
			if (client.getLocalPlayer() != null)
			{
				// Create the vanilla OSRS level-up fireworks animation on the player
				// SpotAnim ID 199 is the standard fireworks that appear when leveling up
				// Height set to 100 to display above the player's head
				client.getLocalPlayer().createSpotAnim(0, 199, 100, 0);

				// Also play the level-up sound effects for authenticity
				client.playSoundEffect(2396); // Level up sound 1

				// Schedule the second sound effect with a delay using ScheduledExecutorService
				// to avoid blocking the client thread
				scheduledExecutorService.schedule(() -> {
					clientThread.invokeLater(() -> {
						client.playSoundEffect(2384); // Level up sound 2
					});
				}, 583, TimeUnit.MILLISECONDS); // 35 game ticks delay (35 * 16.67ms = ~583ms)

				log.debug("Triggered vanilla fireworks animation (SpotAnim 199) on player");
			}
		}
		catch (Exception e)
		{
			log.warn("Failed to trigger fireworks", e);
		}
	}
}
package com.lennyscustomclues.constraints;

import java.util.List;

public class ActionConstraint implements Constraint
{
	private String type; // "emote", "npc_interaction", "any_emote", "any_npc"
	private Integer emoteId;
	private List<Integer> emoteIds;
	private Integer npcId;
	private List<Integer> npcIds;
	private String interactionType;
	private List<String> interactionTypes;

	public ActionConstraint()
	{
		// Default constructor for JSON deserialization
	}

	public ActionConstraint(String type)
	{
		this.type = type;
	}


	@Override
	public String description()
	{
		switch (type)
		{
			case "emote":
				return "Must perform specific emote";
			case "any_emote":
				return "Must perform one of specified emotes";
			case "npc_interaction":
				return "Must interact with specified NPC";
			case "any_npc":
				return "Must interact with any NPC";
			default:
				return "Action constraint";
		}
	}

	@Override
	public String getConstraintType()
	{
		return "action";
	}

	// Getters and setters
	public String getType() { return type; }
	public void setType(String type) { this.type = type; }
	public Integer getEmoteId() { return emoteId; }
	public void setEmoteId(Integer emoteId) { this.emoteId = emoteId; }
	public List<Integer> getEmoteIds() { return emoteIds; }
	public void setEmoteIds(List<Integer> emoteIds) { this.emoteIds = emoteIds; }
	public Integer getNpcId() { return npcId; }
	public void setNpcId(Integer npcId) { this.npcId = npcId; }
	public List<Integer> getNpcIds() { return npcIds; }
	public void setNpcIds(List<Integer> npcIds) { this.npcIds = npcIds; }
	public String getInteractionType() { return interactionType; }
	public void setInteractionType(String interactionType) { this.interactionType = interactionType; }
	public List<String> getInteractionTypes() { return interactionTypes; }
	public void setInteractionTypes(List<String> interactionTypes) { this.interactionTypes = interactionTypes; }
}
package com.lennyscustomclues.constraints;

public interface Constraint
{
	String description();
	String getConstraintType();
}
package com.lennyscustomclues.constraints;

import java.util.List;

public class EquipmentConstraint implements Constraint
{
	private String type; // "contains", "exact_slot", "any_of"
	private Integer itemId;
	private List<Integer> itemIds; // For "any_of" type
	private Integer slot;
	private Integer minQuantity;

	public EquipmentConstraint()
	{
		// Default constructor for JSON deserialization
	}

	public EquipmentConstraint(String type)
	{
		this.type = type;
	}


	@Override
	public String description()
	{
		switch (type)
		{
			case "contains":
				return "Must have specified item equipped";
			case "exact_slot":
				return "Specific equipment slot must contain specified item";
			case "any_of":
				return "Must have at least one of specified items equipped";
			default:
				return "Equipment constraint";
		}
	}

	@Override
	public String getConstraintType()
	{
		return "equipment";
	}

	// Getters and setters
	public String getType() { return type; }
	public void setType(String type) { this.type = type; }
	public Integer getItemId() { return itemId; }
	public void setItemId(Integer itemId) { this.itemId = itemId; }
	public List<Integer> getItemIds() { return itemIds; }
	public void setItemIds(List<Integer> itemIds) { this.itemIds = itemIds; }
	public Integer getSlot() { return slot; }
	public void setSlot(Integer slot) { this.slot = slot; }
	public Integer getMinQuantity() { return minQuantity; }
	public void setMinQuantity(Integer minQuantity) { this.minQuantity = minQuantity; }
}
package com.lennyscustomclues.constraints;

import java.util.List;

public class EventKeyConstraint implements Constraint
{
	private String type; // "exact", "prefix", "suffix", "any_of"
	private String exactKey;
	private String prefix;
	private String suffix;
	private List<String> allowedKeys;

	public EventKeyConstraint()
	{
		// Default constructor for JSON deserialization
	}

	public EventKeyConstraint(String type)
	{
		this.type = type;
	}


	@Override
	public String description()
	{
		switch (type)
		{
			case "exact":
				return "Must have exact event key";
			case "any_of":
				return "Must have one of allowed event keys";
			default:
				return "Event key constraint";
		}
	}

	@Override
	public String getConstraintType()
	{
		return "event_key";
	}

	// Getters and setters
	public String getType() { return type; }
	public void setType(String type) { this.type = type; }
	public String getExactKey() { return exactKey; }
	public void setExactKey(String exactKey) { this.exactKey = exactKey; }
	public String getPrefix() { return prefix; }
	public void setPrefix(String prefix) { this.prefix = prefix; }
	public String getSuffix() { return suffix; }
	public void setSuffix(String suffix) { this.suffix = suffix; }
	public List<String> getAllowedKeys() { return allowedKeys; }
	public void setAllowedKeys(List<String> allowedKeys) { this.allowedKeys = allowedKeys; }
}
package com.lennyscustomclues.constraints;

import java.util.List;

public class InventoryConstraint implements Constraint
{
	private String type; // "contains", "exact", "minimum_quantity", "any_of"
	private Integer itemId;
	private List<Integer> itemIds; // For "any_of" type
	private Integer minQuantity;
	private Integer exactSlot;
	private Integer requiredSlot;

	public InventoryConstraint()
	{
		// Default constructor for JSON deserialization
	}

	public InventoryConstraint(String type)
	{
		this.type = type;
	}


	@Override
	public String description()
	{
		switch (type)
		{
			case "contains":
				return "Inventory must contain specified item";
			case "any_of":
				return "Inventory must contain at least one of specified items";
			case "exact":
				return "Specific inventory slot must contain specified item";
			default:
				return "Inventory constraint";
		}
	}

	@Override
	public String getConstraintType()
	{
		return "inventory";
	}

	// Getters and setters
	public String getType() { return type; }
	public void setType(String type) { this.type = type; }
	public Integer getItemId() { return itemId; }
	public void setItemId(Integer itemId) { this.itemId = itemId; }
	public List<Integer> getItemIds() { return itemIds; }
	public void setItemIds(List<Integer> itemIds) { this.itemIds = itemIds; }
	public Integer getMinQuantity() { return minQuantity; }
	public void setMinQuantity(Integer minQuantity) { this.minQuantity = minQuantity; }
	public Integer getExactSlot() { return exactSlot; }
	public void setExactSlot(Integer exactSlot) { this.exactSlot = exactSlot; }
	public Integer getRequiredSlot() { return requiredSlot; }
	public void setRequiredSlot(Integer requiredSlot) { this.requiredSlot = requiredSlot; }
}
package com.lennyscustomclues.constraints;

public class LocationConstraint implements Constraint
{
	private String type; // "exact", "bounds", "tolerance"
	private Integer minX;
	private Integer maxX;
	private Integer minY;
	private Integer maxY;
	private Integer exactX;
	private Integer exactY;
	private Integer plane;
	private Integer tolerance; // For tolerance type

	public LocationConstraint()
	{
		// Default constructor for JSON deserialization
	}

	public LocationConstraint(String type)
	{
		this.type = type;
	}


	@Override
	public String description()
	{
		switch (type)
		{
			case "exact":
				return "Must be at exact coordinates";
			case "bounds":
				return "Must be within specified area bounds";
			case "tolerance":
				return "Must be within tolerance of target location";
			default:
				return "Location constraint";
		}
	}

	@Override
	public String getConstraintType()
	{
		return "location";
	}

	// Getters and setters
	public String getType() { return type; }
	public void setType(String type) { this.type = type; }
	public Integer getMinX() { return minX; }
	public void setMinX(Integer minX) { this.minX = minX; }
	public Integer getMaxX() { return maxX; }
	public void setMaxX(Integer maxX) { this.maxX = maxX; }
	public Integer getMinY() { return minY; }
	public void setMinY(Integer minY) { this.minY = minY; }
	public Integer getMaxY() { return maxY; }
	public void setMaxY(Integer maxY) { this.maxY = maxY; }
	public Integer getExactX() { return exactX; }
	public void setExactX(Integer exactX) { this.exactX = exactX; }
	public Integer getExactY() { return exactY; }
	public void setExactY(Integer exactY) { this.exactY = exactY; }
	public Integer getPlane() { return plane; }
	public void setPlane(Integer plane) { this.plane = plane; }
	public Integer getTolerance() { return tolerance; }
	public void setTolerance(Integer tolerance) { this.tolerance = tolerance; }
}
package com.lennyscustomclues.dialogs;

import com.lennyscustomclues.constraints.*;
import com.lennyscustomclues.AnswerBuilder;
import com.lennyscustomclues.ApiClient;
import com.lennyscustomclues.EmoteData;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

public class AnswerBuilderDialog extends JDialog
{
	private AnswerBuilder answerBuilder;
	private Client client;
	private ApiClient apiClient;

	// Fields for update mode
	private boolean isUpdateMode;
	private String eventKey;
	private String secretKey;

	private JTextArea rewardTextArea;
	private JLabel statusLabel;

	// Required Action section
	private JComboBox<String> requiredActionCombo;

	// Location Constraint section
	private JComboBox<String> locationTypeCombo;
	private JPanel locationFieldsPanel;
	private Map<String, JTextField> locationFields;
	private Map<String, JLabel> locationLabels;
	private JButton useCurrentLocationButton;
	private JLabel coordinatesLabel;
	private Timer coordinateUpdateTimer;

	// Emote Constraint section
	private JPanel emoteSelectionPanel;
	private JLabel emoteDisplayLabel;
	private JButton selectEmoteButton;
	private ActionConstraint emoteConstraint;

	// Buttons
	private JButton clearAnswerButton;
	private JButton submitAnswerButton;
	private JButton cancelButton;

	// Constructor for creating a new answer
	public AnswerBuilderDialog(JFrame parent, Client client, ApiClient apiClient)
	{
		this(parent, client, apiClient, null, null, null, null);
	}

	// Constructor for updating an existing answer
	public AnswerBuilderDialog(JFrame parent, Client client, ApiClient apiClient,
		String eventKey, String secretKey, String rewardText, java.util.List<java.util.Map<String, Object>> constraints)
	{
		super(parent, eventKey != null ? "Update Answer" : "Create Answer", false); // false = non-modal
		this.client = client;
		this.apiClient = apiClient;
		this.answerBuilder = new AnswerBuilder();
		this.locationFields = new HashMap<>();
		this.locationLabels = new HashMap<>();
		this.isUpdateMode = eventKey != null;
		this.eventKey = eventKey;
		this.secretKey = secretKey;

		initializeUI();

		// Pre-populate fields if in update mode
		if (isUpdateMode && rewardText != null)
		{
			prepopulateFields(rewardText, constraints);
		}

		startCoordinateUpdates();
		pack();
		setMinimumSize(new Dimension(500, 600));
		setLocationRelativeTo(parent);
		setAlwaysOnTop(true); // Keep dialog visible above game client
	}

	private void initializeUI()
	{
		setLayout(new BorderLayout());
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title
		JLabel titleLabel = new JLabel("Answer Builder");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(FontManager.getRunescapeFont());
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		// Main content panel - single column layout
		JPanel mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		// 1. Reward text area
		JPanel rewardPanel = new JPanel(new BorderLayout());
		rewardPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		rewardPanel.setBorder(BorderFactory.createTitledBorder("Reward Text (Required)"));
		rewardPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 100));

		rewardTextArea = new JTextArea(3, 0);
		rewardTextArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		rewardTextArea.setForeground(Color.WHITE);
		rewardTextArea.setLineWrap(true);
		rewardTextArea.setWrapStyleWord(true);
		rewardTextArea.setToolTipText("This reward text will be shown to players that solve your puzzle!");
		rewardTextArea.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
			public void insertUpdate(javax.swing.event.DocumentEvent e) { updateSubmitButtonState(); }
			public void removeUpdate(javax.swing.event.DocumentEvent e) { updateSubmitButtonState(); }
			public void changedUpdate(javax.swing.event.DocumentEvent e) { updateSubmitButtonState(); }
		});
		JScrollPane rewardScrollPane = new JScrollPane(rewardTextArea);
		rewardPanel.add(rewardScrollPane, BorderLayout.CENTER);

		// 2. Required Action section
		JPanel requiredActionPanel = new JPanel();
		requiredActionPanel.setLayout(new BoxLayout(requiredActionPanel, BoxLayout.Y_AXIS));
		requiredActionPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		requiredActionPanel.setBorder(BorderFactory.createTitledBorder("Required Action"));

		JPanel actionTypePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		actionTypePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JLabel actionLabel = new JLabel("Action Type:");
		actionLabel.setForeground(Color.WHITE);
		actionTypePanel.add(actionLabel);

		requiredActionCombo = new JComboBox<>(new String[]{"Dig with a spade", "Perform an Emote"});
		requiredActionCombo.addActionListener(this::onActionTypeChanged);
		actionTypePanel.add(requiredActionCombo);

		requiredActionPanel.add(actionTypePanel);

		// Emote selection panel (initially hidden)
		emoteSelectionPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		emoteSelectionPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		emoteSelectionPanel.setVisible(false);

		emoteDisplayLabel = new JLabel("No emote selected");
		emoteDisplayLabel.setForeground(Color.LIGHT_GRAY);
		emoteSelectionPanel.add(emoteDisplayLabel);

		selectEmoteButton = new JButton("Select Emote");
		selectEmoteButton.addActionListener(this::onSelectEmote);
		emoteSelectionPanel.add(selectEmoteButton);

		JButton clearEmoteButton = new JButton("Clear");
		clearEmoteButton.addActionListener(this::onClearEmote);
		emoteSelectionPanel.add(clearEmoteButton);

		requiredActionPanel.add(emoteSelectionPanel);

		// 3. Location Constraint section
		JPanel locationConstraintPanel = new JPanel();
		locationConstraintPanel.setLayout(new BoxLayout(locationConstraintPanel, BoxLayout.Y_AXIS));
		locationConstraintPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		locationConstraintPanel.setBorder(BorderFactory.createTitledBorder("Location Constraint"));

		// Location type dropdown and coordinates display
		JPanel locationTopPanel = new JPanel(new BorderLayout());
		locationTopPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel locationTypePanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		locationTypePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		JLabel locationTypeLabel = new JLabel("Type:");
		locationTypeLabel.setForeground(Color.WHITE);
		locationTypePanel.add(locationTypeLabel);

		locationTypeCombo = new JComboBox<>(new String[]{"Exact Tile", "Near a Tile", "Within a Rectangle", "None"});
		locationTypeCombo.addActionListener(this::onLocationTypeChanged);
		locationTypePanel.add(locationTypeCombo);

		// Coordinates display
		JPanel coordinatesPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		coordinatesPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		coordinatesLabel = new JLabel("Current Location: Loading...");
		coordinatesLabel.setForeground(Color.CYAN);
		coordinatesLabel.setFont(coordinatesLabel.getFont().deriveFont(Font.BOLD));
		coordinatesPanel.add(coordinatesLabel);

		locationTopPanel.add(locationTypePanel, BorderLayout.NORTH);
		locationTopPanel.add(coordinatesPanel, BorderLayout.SOUTH);

		// Dynamic location fields panel
		locationFieldsPanel = new JPanel(new GridBagLayout());
		locationFieldsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		createLocationFields();

		locationConstraintPanel.add(locationTopPanel);
		locationConstraintPanel.add(locationFieldsPanel);

		// 4. Required Worn Items section
		JPanel wornItemsPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
		wornItemsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		wornItemsPanel.setBorder(BorderFactory.createTitledBorder("Required Worn Items"));
		wornItemsPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 60));

		JLabel wornItemsLabel = new JLabel("Will be implemented soon!");
		wornItemsLabel.setForeground(Color.LIGHT_GRAY);
		wornItemsPanel.add(wornItemsLabel);

		// 5. Clear button panel (centered)
		JPanel clearButtonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		clearButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		clearButtonPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));

		// 6. Submit button panel
		JPanel submitPanel = new JPanel(new FlowLayout());
		submitPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		submitPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 50));

		createButtons();

		clearButtonPanel.add(clearAnswerButton);

		submitPanel.add(submitAnswerButton);
		submitPanel.add(cancelButton);

		// Status label
		statusLabel = new JLabel("Ready to build answer");
		statusLabel.setForeground(Color.WHITE);
		statusLabel.setHorizontalAlignment(SwingConstants.CENTER);

		// Add all sections to main panel
		mainPanel.add(rewardPanel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(requiredActionPanel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(locationConstraintPanel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(wornItemsPanel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(clearButtonPanel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(submitPanel);

		add(titleLabel, BorderLayout.NORTH);
		add(mainPanel, BorderLayout.CENTER);
		add(statusLabel, BorderLayout.SOUTH);

		updateLocationFieldsVisibility();
	}

	private void createButtons()
	{
		clearAnswerButton = new JButton("Clear All");
		clearAnswerButton.addActionListener(this::onClearAnswer);

		submitAnswerButton = new JButton(isUpdateMode ? "Update on Server" : "Submit to Server");
		submitAnswerButton.addActionListener(this::onSubmitAnswer);
		submitAnswerButton.setEnabled(false); // Initially disabled

		cancelButton = new JButton("Cancel and discard changes");
		cancelButton.addActionListener(this::onCancel);
	}

	private void onCancel(ActionEvent e)
	{
		int result = JOptionPane.showConfirmDialog(
			this,
			"Are you sure you want to cancel and discard all changes?",
			"Confirm Cancel",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE
		);

		if (result == JOptionPane.YES_OPTION)
		{
			dispose();
		}
	}

	private void createLocationFields()
	{
		// Create all possible fields
		locationFields.put("exactX", createNumberField());
		locationFields.put("exactY", createNumberField());
		locationFields.put("point1X", createNumberField());
		locationFields.put("point1Y", createNumberField());
		locationFields.put("point2X", createNumberField());
		locationFields.put("point2Y", createNumberField());
		locationFields.put("plane", createNumberField());
		locationFields.put("tolerance", createNumberField());

		// Create corresponding labels
		locationLabels.put("exactX", createLabel("Exact X:"));
		locationLabels.put("exactY", createLabel("Exact Y:"));
		locationLabels.put("point1X", createLabel("Point 1 X:"));
		locationLabels.put("point1Y", createLabel("Point 1 Y:"));
		locationLabels.put("point2X", createLabel("Point 2 X:"));
		locationLabels.put("point2Y", createLabel("Point 2 Y:"));
		locationLabels.put("plane", createLabel("Plane (optional):"));
		locationLabels.put("tolerance", createLabel("Tolerance:"));
	}

	private JTextField createNumberField()
	{
		JTextField field = new JTextField(20);
		field.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		field.setForeground(Color.WHITE);
		return field;
	}

	private JLabel createLabel(String text)
	{
		JLabel label = new JLabel(text);
		label.setForeground(Color.WHITE);
		return label;
	}

	private void onActionTypeChanged(ActionEvent e)
	{
		String selectedAction = (String) requiredActionCombo.getSelectedItem();
		boolean isEmoteAction = "Perform an Emote".equals(selectedAction);

		emoteSelectionPanel.setVisible(isEmoteAction);
		pack(); // Resize dialog to fit new content
	}

	private void onLocationTypeChanged(ActionEvent e)
	{
		updateLocationFieldsVisibility();
		pack(); // Resize dialog to fit new content
	}

	private void updateLocationFieldsVisibility()
	{
		String selectedType = (String) locationTypeCombo.getSelectedItem();

		// Clear the panel
		locationFieldsPanel.removeAll();

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = new Insets(5, 5, 5, 5);
		gbc.anchor = GridBagConstraints.WEST;

		int row = 0;

		// Map UI labels to internal constraint types
		String constraintType;
		switch (selectedType)
		{
			case "Exact Tile":
				constraintType = "exact";
				addFieldToPanel(gbc, row++, "exactX");
				addFieldToPanel(gbc, row++, "exactY");
				break;

			case "Within a Rectangle":
				constraintType = "bounds";
				addFieldToPanel(gbc, row++, "point1X");
				addFieldToPanel(gbc, row++, "point1Y");

				// Add "Use Current Location" button for Point 1
				JButton usePoint1Button = new JButton("Use Current Location for Point 1");
				usePoint1Button.addActionListener(e -> onUseCurrentLocationForPoint(1));
				gbc.gridx = 0;
				gbc.gridy = row++;
				gbc.gridwidth = 2;
				gbc.fill = GridBagConstraints.HORIZONTAL;
				gbc.insets = new Insets(5, 5, 10, 5);
				locationFieldsPanel.add(usePoint1Button, gbc);
				gbc.gridwidth = 1;
				gbc.insets = new Insets(5, 5, 5, 5);

				addFieldToPanel(gbc, row++, "point2X");
				addFieldToPanel(gbc, row++, "point2Y");

				// Add "Use Current Location" button for Point 2
				JButton usePoint2Button = new JButton("Use Current Location for Point 2");
				usePoint2Button.addActionListener(e -> onUseCurrentLocationForPoint(2));
				gbc.gridx = 0;
				gbc.gridy = row++;
				gbc.gridwidth = 2;
				gbc.fill = GridBagConstraints.HORIZONTAL;
				gbc.insets = new Insets(5, 5, 10, 5);
				locationFieldsPanel.add(usePoint2Button, gbc);
				gbc.gridwidth = 1;
				gbc.insets = new Insets(5, 5, 5, 5);
				break;

			case "None":
				// No location constraint fields needed
				constraintType = null;
				break;

			case "Near a Tile":
			default:
				constraintType = "tolerance";
				addFieldToPanel(gbc, row++, "exactX");
				addFieldToPanel(gbc, row++, "exactY");
				addFieldToPanel(gbc, row++, "tolerance");
				break;
		}

		// Always add plane field (optional for all types except None)
		if (!"None".equals(selectedType))
		{
			addFieldToPanel(gbc, row++, "plane");
		}

		// Add "Use Current Location" button for exact and tolerance types
		if ("Exact Tile".equals(selectedType) || "Near a Tile".equals(selectedType))
		{
			useCurrentLocationButton = new JButton("Use Current Location");
			useCurrentLocationButton.addActionListener(this::onUseCurrentLocation);

			gbc.gridx = 0;
			gbc.gridy = row;
			gbc.gridwidth = 2;
			gbc.fill = GridBagConstraints.HORIZONTAL;
			gbc.insets = new Insets(10, 5, 5, 5);
			locationFieldsPanel.add(useCurrentLocationButton, gbc);
			gbc.gridwidth = 1;
			gbc.insets = new Insets(5, 5, 5, 5);
		}

		// Refresh the panel
		locationFieldsPanel.revalidate();
		locationFieldsPanel.repaint();
	}

	private void addFieldToPanel(GridBagConstraints gbc, int row, String fieldName)
	{
		JLabel label = locationLabels.get(fieldName);
		JTextField field = locationFields.get(fieldName);

		if (label != null && field != null)
		{
			// Add label
			gbc.gridx = 0;
			gbc.gridy = row;
			gbc.fill = GridBagConstraints.NONE;
			locationFieldsPanel.add(label, gbc);

			// Add field
			gbc.gridx = 1;
			gbc.fill = GridBagConstraints.HORIZONTAL;
			gbc.weightx = 1.0;
			locationFieldsPanel.add(field, gbc);
			gbc.weightx = 0.0;
		}
	}

	private void onUseCurrentLocation(ActionEvent e)
	{
		WorldPoint currentLocation = getCurrentPlayerLocation();
		if (currentLocation != null)
		{
			JTextField exactXField = locationFields.get("exactX");
			JTextField exactYField = locationFields.get("exactY");
			JTextField planeField = locationFields.get("plane");

			if (exactXField != null) exactXField.setText(String.valueOf(currentLocation.getX()));
			if (exactYField != null) exactYField.setText(String.valueOf(currentLocation.getY()));
			if (planeField != null) planeField.setText(String.valueOf(currentLocation.getPlane()));
		}
	}

	private void onUseCurrentLocationForPoint(int pointNumber)
	{
		WorldPoint currentLocation = getCurrentPlayerLocation();
		if (currentLocation != null)
		{
			String xFieldName = "point" + pointNumber + "X";
			String yFieldName = "point" + pointNumber + "Y";

			JTextField xField = locationFields.get(xFieldName);
			JTextField yField = locationFields.get(yFieldName);
			JTextField planeField = locationFields.get("plane");

			if (xField != null) xField.setText(String.valueOf(currentLocation.getX()));
			if (yField != null) yField.setText(String.valueOf(currentLocation.getY()));
			if (planeField != null) planeField.setText(String.valueOf(currentLocation.getPlane()));
		}
	}

	private void onSelectEmote(ActionEvent e)
	{
		Window parentWindow = SwingUtilities.getWindowAncestor(this);
		JFrame parentFrame = (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;

		EmoteConstraintDialog dialog = new EmoteConstraintDialog(
			parentFrame,
			emoteConstraint,
			constraint -> {
				emoteConstraint = constraint;
				updateEmoteDisplay();
			}
		);

		dialog.setVisible(true);
	}

	private void onClearEmote(ActionEvent e)
	{
		emoteConstraint = null;
		updateEmoteDisplay();
	}

	private void updateEmoteDisplay()
	{
		if (emoteConstraint != null && emoteConstraint.getEmoteId() != null)
		{
			String emoteName = EmoteData.getEmoteName(emoteConstraint.getEmoteId());
			emoteDisplayLabel.setText("Selected: " + emoteName);
			emoteDisplayLabel.setForeground(Color.WHITE);
		}
		else
		{
			emoteDisplayLabel.setText("No emote selected");
			emoteDisplayLabel.setForeground(Color.LIGHT_GRAY);
		}
	}

	private void onSubmitAnswer(ActionEvent e)
	{
		try
		{
			// Clear any existing data first
			answerBuilder.clear();

			// Update the answer builder with current reward text
			answerBuilder.setRewardText(rewardTextArea.getText().trim());

			// Build and add the location constraint (if not "None")
			LocationConstraint locationConstraint = buildLocationConstraint();
			if (locationConstraint != null)
			{
				answerBuilder.addConstraint(locationConstraint);
			}

			// Add the emote constraint if "Perform an Emote" is selected
			String selectedAction = (String) requiredActionCombo.getSelectedItem();
			if ("Perform an Emote".equals(selectedAction))
			{
				if (emoteConstraint == null || emoteConstraint.getEmoteId() == null)
				{
					JOptionPane.showMessageDialog(this, "Please select an emote", "Emote Required", JOptionPane.WARNING_MESSAGE);
					return;
				}
				answerBuilder.addConstraint(emoteConstraint);
			}

			if (isUpdateMode)
			{
				// Update mode - directly submit the update
				statusLabel.setText("Updating answer on server...");
				statusLabel.setForeground(java.awt.Color.YELLOW);

				apiClient.updateAnswer(eventKey, secretKey, answerBuilder).thenAccept(response -> {
					javax.swing.SwingUtilities.invokeLater(() -> {
						if (response.success)
						{
							// Show success popup
							JOptionPane.showMessageDialog(
								AnswerBuilderDialog.this,
								"Answer updated successfully",
								"Success",
								JOptionPane.INFORMATION_MESSAGE
							);

							// Close the dialog
							AnswerBuilderDialog.this.dispose();
						}
						else
						{
							// Handle different error types with appropriate messages
							String errorMessage = " Failed to update answer: " + response.message;
							if ("NOT_FOUND".equals(response.errorType))
							{
								errorMessage = " Event key not found";
							}
							else if ("UNAUTHORIZED".equals(response.errorType))
							{
								errorMessage = " Invalid secret key";
							}
							else if ("NETWORK_ERROR".equals(response.errorType))
							{
								errorMessage = " Network error: " + response.message;
							}
							else if ("VALIDATION_ERROR".equals(response.errorType))
							{
								errorMessage = " Validation error: " + response.message;
							}
							else if ("SERVER_ERROR".equals(response.errorType))
							{
								errorMessage = " Server error: " + response.message;
							}

							statusLabel.setText(errorMessage);
							statusLabel.setForeground(java.awt.Color.RED);
						}
					});
				});
			}
			else
			{
				// Create mode - show dialog to get event key and secret key
				// Find the parent frame
				Window parentWindow = SwingUtilities.getWindowAncestor(this);
				JFrame parentFrame = (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;

				SubmitAnswerDialog dialog = new SubmitAnswerDialog(
					parentFrame,
					answerBuilder,
					apiClient,
					(eventKey, secretKey) -> {
						// Handle the submission
						statusLabel.setText("Submitting answer to server...");
						statusLabel.setForeground(java.awt.Color.YELLOW);

						// Actually submit the answer to the server
						apiClient.createAnswer(eventKey, secretKey, answerBuilder).thenAccept(response -> {
							javax.swing.SwingUtilities.invokeLater(() -> {
								if (response.success)
								{
									// Show success popup
									JOptionPane.showMessageDialog(
										AnswerBuilderDialog.this,
										"Answer submitted successfully",
										"Success",
										JOptionPane.INFORMATION_MESSAGE
									);

									// Close both dialogs
									AnswerBuilderDialog.this.dispose();
								}
								else
								{
									// Handle different error types with appropriate messages
									String errorMessage = " Failed to submit answer: " + response.message;
									if ("KEY_ALREADY_EXISTS".equals(response.errorType))
									{
										errorMessage = " Event key '" + eventKey + "' already exists";
									}
									else if ("NETWORK_ERROR".equals(response.errorType))
									{
										errorMessage = " Network error: " + response.message;
									}
									else if ("VALIDATION_ERROR".equals(response.errorType))
									{
										errorMessage = " Validation error: " + response.message;
									}
									else if ("SERVER_ERROR".equals(response.errorType))
									{
										errorMessage = " Server error: " + response.message;
									}

									statusLabel.setText(errorMessage);
									statusLabel.setForeground(java.awt.Color.RED);
								}
							});
						});
					}
				);

				dialog.setVisible(true);
			}
		}
		catch (NumberFormatException ex)
		{
			JOptionPane.showMessageDialog(this, "Please enter valid numbers for location fields", "Input Error", JOptionPane.ERROR_MESSAGE);
		}
		catch (IllegalArgumentException ex)
		{
			JOptionPane.showMessageDialog(this, ex.getMessage(), "Validation Error", JOptionPane.ERROR_MESSAGE);
		}
	}

	private LocationConstraint buildLocationConstraint()
	{
		String selectedType = (String) locationTypeCombo.getSelectedItem();
		String constraintType;

		switch (selectedType)
		{
			case "Exact Tile":
				constraintType = "exact";
				break;
			case "Within a Rectangle":
				constraintType = "bounds";
				break;
			case "None":
				return null; // No location constraint
			case "Near a Tile":
			default:
				constraintType = "tolerance";
				break;
		}

		LocationConstraint constraint = new LocationConstraint(constraintType);
		constraint.setExactX(parseInteger("exactX"));
		constraint.setExactY(parseInteger("exactY"));
		constraint.setPlane(parseInteger("plane"));
		constraint.setTolerance(parseInteger("tolerance"));

		// For bounds type, calculate min/max from the two points
		if ("bounds".equals(constraintType))
		{
			Integer point1X = parseInteger("point1X");
			Integer point1Y = parseInteger("point1Y");
			Integer point2X = parseInteger("point2X");
			Integer point2Y = parseInteger("point2Y");

			if (point1X != null && point2X != null)
			{
				constraint.setMinX(Math.min(point1X, point2X));
				constraint.setMaxX(Math.max(point1X, point2X));
			}

			if (point1Y != null && point2Y != null)
			{
				constraint.setMinY(Math.min(point1Y, point2Y));
				constraint.setMaxY(Math.max(point1Y, point2Y));
			}
		}

		return constraint;
	}

	private Integer parseInteger(String fieldName)
	{
		JTextField field = locationFields.get(fieldName);
		if (field == null)
		{
			return null;
		}

		String text = field.getText();
		if (text == null || text.trim().isEmpty())
		{
			return null;
		}
		return Integer.parseInt(text.trim());
	}

	private void onClearAnswer(ActionEvent e)
	{
		int result = JOptionPane.showConfirmDialog(
			this,
			"Are you sure you want to clear all drafted answer information?",
			"Confirm Clear",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE
		);

		if (result == JOptionPane.YES_OPTION)
		{
			answerBuilder.clear();
			rewardTextArea.setText("");
			requiredActionCombo.setSelectedItem("Dig with a spade");
			clearLocationFields();
			emoteConstraint = null;
			updateEmoteDisplay();
			updateSubmitButtonState();
			statusLabel.setText("Answer cleared");
		}
	}

	private void clearLocationFields()
	{
		for (JTextField field : locationFields.values())
		{
			field.setText("");
		}
	}

	private void updateSubmitButtonState()
	{
		boolean hasRewardText = rewardTextArea != null && !rewardTextArea.getText().trim().isEmpty();

		if (submitAnswerButton != null)
		{
			submitAnswerButton.setEnabled(hasRewardText);
		}
	}

	private void startCoordinateUpdates()
	{
		// Update coordinates every 500ms
		coordinateUpdateTimer = new Timer(500, e -> updateCoordinatesDisplay());
		coordinateUpdateTimer.start();
		updateCoordinatesDisplay(); // Initial update
	}

	private void stopCoordinateUpdates()
	{
		if (coordinateUpdateTimer != null)
		{
			coordinateUpdateTimer.stop();
		}
	}

	private void updateCoordinatesDisplay()
	{
		SwingUtilities.invokeLater(() -> {
			WorldPoint location = getCurrentPlayerLocation();
			if (location != null)
			{
				coordinatesLabel.setText(String.format("Current Location: X:%d Y:%d Plane:%d",
					location.getX(), location.getY(), location.getPlane()));
			}
			else
			{
				coordinatesLabel.setText("Current Location: Not available");
			}
		});
	}

	private WorldPoint getCurrentPlayerLocation()
	{
		if (client == null) return null;

		Player player = client.getLocalPlayer();
		if (player == null) return null;

		return player.getWorldLocation();
	}

	private void prepopulateFields(String rewardText, java.util.List<java.util.Map<String, Object>> constraints)
	{
		// Set reward text
		rewardTextArea.setText(rewardText);

		// Parse and set constraints if present
		if (constraints != null && !constraints.isEmpty())
		{
			for (java.util.Map<String, Object> constraintMap : constraints)
			{
				String constraintType = (String) constraintMap.get("constraint_type");

				if ("location".equals(constraintType))
				{
					String type = (String) constraintMap.get("type");

					// Set the location type in the dropdown
					if ("exact".equals(type))
					{
						locationTypeCombo.setSelectedItem("Exact Tile");
						setIntegerField("exactX", constraintMap.get("exact_x"));
						setIntegerField("exactY", constraintMap.get("exact_y"));
					}
					else if ("tolerance".equals(type))
					{
						locationTypeCombo.setSelectedItem("Near a Tile");
						setIntegerField("exactX", constraintMap.get("exact_x"));
						setIntegerField("exactY", constraintMap.get("exact_y"));
						setIntegerField("tolerance", constraintMap.get("tolerance"));
					}
					else if ("bounds".equals(type))
					{
						locationTypeCombo.setSelectedItem("Within a Rectangle");
						// Convert min/max back to point1/point2 for display
						setIntegerField("point1X", constraintMap.get("min_x"));
						setIntegerField("point1Y", constraintMap.get("min_y"));
						setIntegerField("point2X", constraintMap.get("max_x"));
						setIntegerField("point2Y", constraintMap.get("max_y"));
					}

					// Set plane if present
					setIntegerField("plane", constraintMap.get("plane"));
				}
				else if ("action".equals(constraintType))
				{
					String type = (String) constraintMap.get("type");

					if ("emote".equals(type))
					{
						Object emoteIdObj = constraintMap.get("emote_id");
						if (emoteIdObj != null)
						{
							Integer emoteId = null;
							if (emoteIdObj instanceof Number)
							{
								emoteId = ((Number) emoteIdObj).intValue();
							}

							if (emoteId != null)
							{
								// Set the action type to "Perform an Emote"
								requiredActionCombo.setSelectedItem("Perform an Emote");

								emoteConstraint = new ActionConstraint("emote");
								emoteConstraint.setEmoteId(emoteId);
								updateEmoteDisplay();
							}
						}
					}
				}
			}
		}

		updateSubmitButtonState();
	}

	private void setIntegerField(String fieldName, Object value)
	{
		JTextField field = locationFields.get(fieldName);
		if (field != null && value != null)
		{
			// Handle both Integer and Double from JSON parsing
			if (value instanceof Number)
			{
				field.setText(String.valueOf(((Number) value).intValue()));
			}
			else if (value instanceof String)
			{
				field.setText((String) value);
			}
		}
	}

	@Override
	public void dispose()
	{
		stopCoordinateUpdates();
		super.dispose();
	}

	public AnswerBuilder getAnswerBuilder()
	{
		return answerBuilder;
	}
}

package com.lennyscustomclues.dialogs;

import com.lennyscustomclues.EmoteData;
import com.lennyscustomclues.constraints.ActionConstraint;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

public class EmoteConstraintDialog extends JDialog
{
	private JTextField searchField;
	private JList<String> emoteList;
	private DefaultListModel<String> listModel;
	private List<String> allEmoteNames;

	private ActionConstraint constraint;
	private Consumer<ActionConstraint> onSave;
	private boolean cancelled = true;

	public EmoteConstraintDialog(JFrame parent, ActionConstraint existing, Consumer<ActionConstraint> onSave)
	{
		super(parent, "Emote Constraint", false); // false = non-modal
		this.onSave = onSave;
		this.constraint = existing != null ? existing : new ActionConstraint("emote");

		// Get all emote names
		allEmoteNames = new ArrayList<>(EmoteData.getEmotes().keySet());

		initializeUI();
		populateFields();
		pack();
		setLocationRelativeTo(parent);
		setAlwaysOnTop(true);
	}

	private void initializeUI()
	{
		setLayout(new BorderLayout(10, 10));
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Top panel with instructions and search
		JPanel topPanel = new JPanel(new BorderLayout(5, 5));
		topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		topPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 0, 10));

		JLabel instructionLabel = new JLabel("Select an emote:");
		instructionLabel.setForeground(Color.WHITE);
		topPanel.add(instructionLabel, BorderLayout.NORTH);

		// Search field
		JPanel searchPanel = new JPanel(new BorderLayout(5, 0));
		searchPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JLabel searchLabel = new JLabel("Search:");
		searchLabel.setForeground(Color.WHITE);
		searchPanel.add(searchLabel, BorderLayout.WEST);

		searchField = new JTextField(20);
		searchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchField.setForeground(Color.WHITE);
		searchField.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				filterEmotes();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				filterEmotes();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				filterEmotes();
			}
		});
		searchPanel.add(searchField, BorderLayout.CENTER);

		topPanel.add(searchPanel, BorderLayout.SOUTH);

		// Center panel with emote list
		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		centerPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		listModel = new DefaultListModel<>();
		for (String emoteName : allEmoteNames)
		{
			listModel.addElement(emoteName);
		}

		emoteList = new JList<>(listModel);
		emoteList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		emoteList.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		emoteList.setForeground(Color.WHITE);
		emoteList.setVisibleRowCount(15);

		JScrollPane scrollPane = new JScrollPane(emoteList);
		scrollPane.setPreferredSize(new Dimension(300, 300));
		centerPanel.add(scrollPane, BorderLayout.CENTER);

		// Buttons panel
		JPanel buttonPanel = new JPanel(new FlowLayout());
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		buttonPanel.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));

		JButton saveButton = new JButton("Save");
		JButton cancelButton = new JButton("Cancel");

		saveButton.addActionListener(this::onSave);
		cancelButton.addActionListener(this::onCancel);

		buttonPanel.add(saveButton);
		buttonPanel.add(cancelButton);

		add(topPanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);
		add(buttonPanel, BorderLayout.SOUTH);
	}

	private void populateFields()
	{
		// If editing an existing constraint, select the corresponding emote
		if (constraint.getEmoteId() != null)
		{
			String emoteName = EmoteData.getEmoteName(constraint.getEmoteId());
			if (emoteName != null && !emoteName.equals("Unknown Emote"))
			{
				emoteList.setSelectedValue(emoteName, true);
			}
		}
	}

	private void filterEmotes()
	{
		String searchText = searchField.getText().toLowerCase();
		listModel.clear();

		for (String emoteName : allEmoteNames)
		{
			if (emoteName.toLowerCase().contains(searchText))
			{
				listModel.addElement(emoteName);
			}
		}

		// If there's only one match, select it
		if (listModel.getSize() == 1)
		{
			emoteList.setSelectedIndex(0);
		}
	}

	private void onSave(ActionEvent e)
	{
		String selectedEmote = emoteList.getSelectedValue();
		if (selectedEmote == null)
		{
			JOptionPane.showMessageDialog(this, "Please select an emote", "Selection Required", JOptionPane.WARNING_MESSAGE);
			return;
		}

		Integer emoteId = EmoteData.getEmoteId(selectedEmote);
		if (emoteId == null)
		{
			JOptionPane.showMessageDialog(this, "Invalid emote selected", "Error", JOptionPane.ERROR_MESSAGE);
			return;
		}

		constraint.setType("emote");
		constraint.setEmoteId(emoteId);

		cancelled = false;
		onSave.accept(constraint);
		dispose();
	}

	private void onCancel(ActionEvent e)
	{
		cancelled = true;
		dispose();
	}

	public boolean wasCancelled()
	{
		return cancelled;
	}
}

package com.lennyscustomclues.dialogs;

import com.lennyscustomclues.ApiClient;
import com.lennyscustomclues.EmoteData;
import com.lennyscustomclues.constraints.LocationConstraint;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

public class EventInfoDialog extends JDialog
{
	private ApiClient apiClient;
	private Client client;
	private JFrame parentFrame;
	private String eventKey;
	private String secretKey;
	private String rewardText;
	private List<Map<String, Object>> constraints;
	private List<ApiClient.PlayerCompletion> completedBy;

	// UI components that need to be refreshed
	private JPanel mainPanel;
	private JLabel statusLabel;

	public EventInfoDialog(JFrame parent, Client client, ApiClient apiClient,
		String eventKey, String secretKey, String rewardText,
		List<Map<String, Object>> constraints, List<ApiClient.PlayerCompletion> completedBy)
	{
		super(parent, "Event Information", true);
		this.parentFrame = parent;
		this.client = client;
		this.apiClient = apiClient;
		this.eventKey = eventKey;
		this.secretKey = secretKey;
		this.rewardText = rewardText;
		this.constraints = constraints;
		this.completedBy = completedBy;

		initializeUI();
		pack();
		setMinimumSize(new Dimension(600, 500));
		setLocationRelativeTo(parent);
	}

	private void initializeUI()
	{
		setLayout(new BorderLayout());
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title
		JLabel titleLabel = new JLabel("Event: " + eventKey);
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		// Main content panel
		mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		// Answer summary panel
		JPanel summaryPanel = createAnswerSummaryPanel();

		// Solvers panel
		JPanel solversPanel = createSolversPanel();

		mainPanel.add(summaryPanel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(solversPanel);

		// Bottom panel with buttons and status
		JPanel bottomPanel = new JPanel();
		bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Buttons panel
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JButton refreshButton = new JButton("Refresh");
		refreshButton.addActionListener(e -> onRefresh());
		buttonPanel.add(refreshButton);

		JButton editButton = new JButton("Edit Answer");
		editButton.addActionListener(e -> onEditAnswer());
		buttonPanel.add(editButton);

		JButton closeButton = new JButton("Close");
		closeButton.addActionListener(e -> dispose());
		buttonPanel.add(closeButton);

		// Status label
		statusLabel = new JLabel(" ");
		statusLabel.setForeground(Color.WHITE);
		statusLabel.setHorizontalAlignment(SwingConstants.CENTER);
		statusLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));

		bottomPanel.add(buttonPanel);
		bottomPanel.add(statusLabel);

		add(titleLabel, BorderLayout.NORTH);
		add(mainPanel, BorderLayout.CENTER);
		add(bottomPanel, BorderLayout.SOUTH);
	}

	private JPanel createAnswerSummaryPanel()
	{
		JPanel panel = new JPanel(new BorderLayout());
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(BorderFactory.createTitledBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			"Answer Summary",
			0,
			0,
			FontManager.getRunescapeFont(),
			Color.WHITE
		));

		// Build the summary text
		StringBuilder summaryBuilder = new StringBuilder();
		summaryBuilder.append("Reward: ").append(rewardText != null && !rewardText.trim().isEmpty() ? rewardText : "(No reward text specified)").append("\n\n");

		if (constraints == null || constraints.isEmpty())
		{
			summaryBuilder.append("No constraints defined");
		}
		else
		{
			// Check if there's an emote constraint
			String requiredAction = "Dig with a spade";
			for (Map<String, Object> constraintMap : constraints)
			{
				String constraintType = (String) constraintMap.get("constraint_type");
				if ("action".equals(constraintType))
				{
					String type = (String) constraintMap.get("type");
					if ("emote".equals(type))
					{
						Object emoteIdObj = constraintMap.get("emote_id");
						if (emoteIdObj != null)
						{
							Integer emoteId = null;
							if (emoteIdObj instanceof Number)
							{
								emoteId = ((Number) emoteIdObj).intValue();
							}
							if (emoteId != null)
							{
								String emoteName = EmoteData.getEmoteName(emoteId);
								requiredAction = "Perform an Emote: " + emoteName;
							}
						}
					}
				}
			}
			summaryBuilder.append("Required Action: ").append(requiredAction).append("\n");

			for (Map<String, Object> constraintMap : constraints)
			{
				String constraintType = (String) constraintMap.get("constraint_type");
				if ("location".equals(constraintType))
				{
					summaryBuilder.append(getLocationConstraintDescription(constraintMap));
				}
			}
		}

		JTextArea summaryArea = new JTextArea(summaryBuilder.toString());
		summaryArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		summaryArea.setForeground(Color.WHITE);
		summaryArea.setFont(FontManager.getRunescapeSmallFont());
		summaryArea.setEditable(false);
		summaryArea.setLineWrap(true);
		summaryArea.setWrapStyleWord(true);

		JScrollPane scrollPane = new JScrollPane(summaryArea);
		scrollPane.setPreferredSize(new Dimension(0, 120));
		panel.add(scrollPane, BorderLayout.CENTER);

		return panel;
	}

	private JPanel createSolversPanel()
	{
		JPanel panel = new JPanel(new BorderLayout());
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(BorderFactory.createTitledBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			"Players Who Solved This Event",
			0,
			0,
			FontManager.getRunescapeFont(),
			Color.WHITE
		));

		// Create table
		String[] columnNames = {"Rank", "Player Name", "Completed At"};
		DefaultTableModel tableModel = new DefaultTableModel(columnNames, 0) {
			@Override
			public boolean isCellEditable(int row, int column) {
				return false; // Make table non-editable
			}
		};

		// Add data to table
		if (completedBy != null && !completedBy.isEmpty())
		{
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			dateFormat.setTimeZone(TimeZone.getDefault());

			for (int i = 0; i < completedBy.size(); i++)
			{
				ApiClient.PlayerCompletion completion = completedBy.get(i);
				String rank = String.valueOf(i + 1);
				String playerName = completion.rsn;
				String timestamp = formatTimestamp(completion.timestamp);

				tableModel.addRow(new Object[]{rank, playerName, timestamp});
			}
		}

		JTable table = new JTable(tableModel);
		table.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		table.setForeground(Color.WHITE);
		table.setFont(FontManager.getRunescapeSmallFont());
		table.setSelectionBackground(ColorScheme.MEDIUM_GRAY_COLOR);
		table.setSelectionForeground(Color.WHITE);
		table.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);
		table.setShowGrid(true);
		table.setRowHeight(25);

		// Center align the Rank column
		DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
		centerRenderer.setHorizontalAlignment(SwingConstants.CENTER);
		table.getColumnModel().getColumn(0).setCellRenderer(centerRenderer);
		table.getColumnModel().getColumn(0).setPreferredWidth(50);
		table.getColumnModel().getColumn(1).setPreferredWidth(150);
		table.getColumnModel().getColumn(2).setPreferredWidth(200);

		// Style table header
		table.getTableHeader().setBackground(ColorScheme.DARKER_GRAY_COLOR);
		table.getTableHeader().setForeground(Color.WHITE);
		table.getTableHeader().setFont(FontManager.getRunescapeFont());

		JScrollPane scrollPane = new JScrollPane(table);
		scrollPane.setPreferredSize(new Dimension(0, 200));

		// Add message if no players have solved it yet
		if (completedBy == null || completedBy.isEmpty())
		{
			JLabel noSolversLabel = new JLabel("No players have solved this event yet");
			noSolversLabel.setForeground(Color.LIGHT_GRAY);
			noSolversLabel.setFont(FontManager.getRunescapeSmallFont());
			noSolversLabel.setHorizontalAlignment(SwingConstants.CENTER);
			panel.add(noSolversLabel, BorderLayout.CENTER);
		}
		else
		{
			panel.add(scrollPane, BorderLayout.CENTER);
		}

		return panel;
	}

	private String formatTimestamp(String timestamp)
	{
		if (timestamp == null || timestamp.isEmpty())
		{
			return "Unknown";
		}

		try
		{
			// Parse ISO 8601 timestamp (e.g., "2024-11-23T12:34:56.789Z")
			SimpleDateFormat inputFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
			inputFormat.setTimeZone(TimeZone.getTimeZone("UTC"));

			// Handle both with and without milliseconds
			String cleanTimestamp = timestamp.replace("Z", "");
			if (cleanTimestamp.contains("."))
			{
				cleanTimestamp = cleanTimestamp.substring(0, cleanTimestamp.indexOf("."));
			}

			Date date = inputFormat.parse(cleanTimestamp);

			// Format to local time
			SimpleDateFormat outputFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			outputFormat.setTimeZone(TimeZone.getDefault());
			return outputFormat.format(date);
		}
		catch (Exception e)
		{
			// If parsing fails, return the original timestamp
			return timestamp;
		}
	}

	private String getLocationConstraintDescription(Map<String, Object> constraintMap)
	{
		StringBuilder desc = new StringBuilder();
		String type = (String) constraintMap.get("type");

		switch (type)
		{
			case "exact":
				desc.append("Location: Exact tile (");
				desc.append("X: ").append(getIntValue(constraintMap, "exact_x"));
				desc.append(", Y: ").append(getIntValue(constraintMap, "exact_y"));
				if (constraintMap.containsKey("plane"))
				{
					desc.append(", Plane: ").append(getIntValue(constraintMap, "plane"));
				}
				desc.append(")");
				break;

			case "bounds":
				desc.append("Location: Within rectangle (");
				desc.append("X: ").append(getIntValue(constraintMap, "min_x")).append("-").append(getIntValue(constraintMap, "max_x"));
				desc.append(", Y: ").append(getIntValue(constraintMap, "min_y")).append("-").append(getIntValue(constraintMap, "max_y"));
				if (constraintMap.containsKey("plane"))
				{
					desc.append(", Plane: ").append(getIntValue(constraintMap, "plane"));
				}
				desc.append(")");
				break;

			case "tolerance":
				desc.append("Location: Near tile (");
				desc.append("X: ").append(getIntValue(constraintMap, "exact_x"));
				desc.append(", Y: ").append(getIntValue(constraintMap, "exact_y"));
				if (constraintMap.containsKey("tolerance"))
				{
					desc.append(", within ").append(getIntValue(constraintMap, "tolerance")).append(" tiles");
				}
				if (constraintMap.containsKey("plane"))
				{
					desc.append(", Plane: ").append(getIntValue(constraintMap, "plane"));
				}
				desc.append(")");
				break;

			default:
				desc.append("Location: ").append(type);
				break;
		}

		return desc.toString();
	}

	private int getIntValue(Map<String, Object> map, String key)
	{
		Object value = map.get(key);
		if (value instanceof Number)
		{
			return ((Number) value).intValue();
		}
		return 0;
	}

	private void onEditAnswer()
	{
		// Close this dialog
		dispose();

		// Open the answer builder dialog in update mode
		AnswerBuilderDialog answerDialog = new AnswerBuilderDialog(
			parentFrame,
			client,
			apiClient,
			eventKey,
			secretKey,
			rewardText,
			constraints
		);
		answerDialog.setVisible(true);
	}

	private void onRefresh()
	{
		statusLabel.setText("Refreshing...");
		statusLabel.setForeground(Color.YELLOW);

		// Make API request to get the latest answer data
		apiClient.getAnswer(eventKey, secretKey).thenAccept(response -> {
			SwingUtilities.invokeLater(() -> {
				if (response.isSuccess())
				{
					// Update the stored data
					this.rewardText = response.reward_text;
					this.constraints = response.constraints;
					this.completedBy = response.completed_by;

					// Rebuild the UI panels
					mainPanel.removeAll();

					JPanel summaryPanel = createAnswerSummaryPanel();
					JPanel solversPanel = createSolversPanel();

					mainPanel.add(summaryPanel);
					mainPanel.add(Box.createVerticalStrut(10));
					mainPanel.add(solversPanel);

					// Refresh the display
					mainPanel.revalidate();
					mainPanel.repaint();

					statusLabel.setText("Refreshed successfully!");
					statusLabel.setForeground(Color.GREEN);

					// Clear status message after 3 seconds
					Timer timer = new Timer(3000, e -> {
						statusLabel.setText(" ");
					});
					timer.setRepeats(false);
					timer.start();
				}
				else
				{
					// Handle error
					String errorMessage = "Refresh failed: ";
					if ("NOT_FOUND".equals(response.errorType))
					{
						errorMessage += "Event key not found";
					}
					else if ("UNAUTHORIZED".equals(response.errorType))
					{
						errorMessage += "Invalid secret key";
					}
					else if ("NETWORK_ERROR".equals(response.errorType))
					{
						errorMessage += "Network error";
					}
					else
					{
						errorMessage += response.errorMessage;
					}

					statusLabel.setText(errorMessage);
					statusLabel.setForeground(Color.RED);
				}
			});
		});
	}
}

package com.lennyscustomclues.dialogs;

import com.lennyscustomclues.constraints.LocationConstraint;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

public class LocationConstraintDialog extends JDialog
{
	private JComboBox<String> typeCombo;
	private JPanel dynamicFieldsPanel;
	private Map<String, JTextField> fields;
	private Map<String, JLabel> labels;
	private JLabel coordinatesLabel;
	private JButton useCurrentLocationButton;
	private Timer coordinateUpdateTimer;
	
	private LocationConstraint constraint;
	private Consumer<LocationConstraint> onSave;
	private Client client;
	private boolean cancelled = true;

	public LocationConstraintDialog(JFrame parent, LocationConstraint existing, Consumer<LocationConstraint> onSave, Client client)
	{
		super(parent, "Location Constraint", false); // false = non-modal
		this.onSave = onSave;
		this.client = client;
		this.constraint = existing != null ? existing : new LocationConstraint("exact");
		this.fields = new HashMap<>();
		this.labels = new HashMap<>();
		
		initializeUI();
		populateFields();
		startCoordinateUpdates();
		pack();
		setLocationRelativeTo(parent);
		setAlwaysOnTop(true); // Keep dialog visible above game client
	}

	private void initializeUI()
	{
		setLayout(new BorderLayout());
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Top panel with type selection and coordinates
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Type selection
		JPanel typePanel = new JPanel(new FlowLayout());
		typePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		JLabel typeLabel = new JLabel("Type:");
		typeLabel.setForeground(Color.WHITE);
		typePanel.add(typeLabel);
		typeCombo = new JComboBox<>(new String[]{"exact", "bounds", "tolerance"});
		typeCombo.addActionListener(this::onTypeChanged);
		typePanel.add(typeCombo);

		// Coordinates display
		JPanel coordinatesPanel = new JPanel(new FlowLayout());
		coordinatesPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		coordinatesLabel = new JLabel("Current Location: Loading...");
		coordinatesLabel.setForeground(Color.CYAN);
		coordinatesLabel.setFont(coordinatesLabel.getFont().deriveFont(Font.BOLD));
		coordinatesPanel.add(coordinatesLabel);

		topPanel.add(typePanel, BorderLayout.NORTH);
		topPanel.add(coordinatesPanel, BorderLayout.SOUTH);

		// Dynamic fields panel
		dynamicFieldsPanel = new JPanel(new GridBagLayout());
		dynamicFieldsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Create all possible fields
		createFields();

		// Buttons panel
		JPanel buttonPanel = new JPanel(new FlowLayout());
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		
		JButton saveButton = new JButton("Save");
		JButton cancelButton = new JButton("Cancel");
		
		saveButton.addActionListener(this::onSave);
		cancelButton.addActionListener(this::onCancel);
		
		buttonPanel.add(saveButton);
		buttonPanel.add(cancelButton);

		add(topPanel, BorderLayout.NORTH);
		add(dynamicFieldsPanel, BorderLayout.CENTER);
		add(buttonPanel, BorderLayout.SOUTH);
	}

	private void createFields()
	{
		// Create all possible fields
		fields.put("exactX", createNumberField());
		fields.put("exactY", createNumberField());
		fields.put("point1X", createNumberField());
		fields.put("point1Y", createNumberField());
		fields.put("point2X", createNumberField());
		fields.put("point2Y", createNumberField());
		fields.put("plane", createNumberField());
		fields.put("tolerance", createNumberField());

		// Create corresponding labels
		labels.put("exactX", createLabel("Exact X:"));
		labels.put("exactY", createLabel("Exact Y:"));
		labels.put("point1X", createLabel("Point 1 X:"));
		labels.put("point1Y", createLabel("Point 1 Y:"));
		labels.put("point2X", createLabel("Point 2 X:"));
		labels.put("point2Y", createLabel("Point 2 Y:"));
		labels.put("plane", createLabel("Plane (optional):"));
		labels.put("tolerance", createLabel("Tolerance:"));
	}

	private JTextField createNumberField()
	{
		JTextField field = new JTextField(20); // Doubled from 10 to 20
		field.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		field.setForeground(Color.WHITE);
		return field;
	}

	private JLabel createLabel(String text)
	{
		JLabel label = new JLabel(text);
		label.setForeground(Color.WHITE);
		return label;
	}

	private void populateFields()
	{
		typeCombo.setSelectedItem(constraint.getType());
		setIntegerField("exactX", constraint.getExactX());
		setIntegerField("exactY", constraint.getExactY());
		// Convert min/max to point1/point2 for display
		setIntegerField("point1X", constraint.getMinX());
		setIntegerField("point1Y", constraint.getMinY());
		setIntegerField("point2X", constraint.getMaxX());
		setIntegerField("point2Y", constraint.getMaxY());
		setIntegerField("plane", constraint.getPlane());
		setIntegerField("tolerance", constraint.getTolerance());
		updateFieldsVisibility();
	}

	private void setIntegerField(String fieldName, Integer value)
	{
		JTextField field = fields.get(fieldName);
		if (field != null)
		{
			field.setText(value != null ? value.toString() : "");
		}
	}

	private void onTypeChanged(ActionEvent e)
	{
		updateFieldsVisibility();
		pack(); // Resize dialog to fit new content
	}

	private void updateFieldsVisibility()
	{
		String selectedType = (String) typeCombo.getSelectedItem();

		// Clear the panel
		dynamicFieldsPanel.removeAll();

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = new Insets(5, 5, 5, 5);
		gbc.anchor = GridBagConstraints.WEST;

		int row = 0;

		// Add fields based on selected type
		switch (selectedType)
		{
			case "exact":
				addFieldToPanel(gbc, row++, "exactX");
				addFieldToPanel(gbc, row++, "exactY");
				break;

			case "bounds":
				addFieldToPanel(gbc, row++, "point1X");
				addFieldToPanel(gbc, row++, "point1Y");

				// Add "Use Current Location" button for Point 1
				JButton usePoint1Button = new JButton("Use Current Location for Point 1");
				usePoint1Button.addActionListener(e -> onUseCurrentLocationForPoint(1));
				gbc.gridx = 0;
				gbc.gridy = row++;
				gbc.gridwidth = 2;
				gbc.fill = GridBagConstraints.HORIZONTAL;
				gbc.insets = new Insets(5, 5, 10, 5);
				dynamicFieldsPanel.add(usePoint1Button, gbc);
				gbc.gridwidth = 1;
				gbc.insets = new Insets(5, 5, 5, 5);

				addFieldToPanel(gbc, row++, "point2X");
				addFieldToPanel(gbc, row++, "point2Y");

				// Add "Use Current Location" button for Point 2
				JButton usePoint2Button = new JButton("Use Current Location for Point 2");
				usePoint2Button.addActionListener(e -> onUseCurrentLocationForPoint(2));
				gbc.gridx = 0;
				gbc.gridy = row++;
				gbc.gridwidth = 2;
				gbc.fill = GridBagConstraints.HORIZONTAL;
				gbc.insets = new Insets(5, 5, 10, 5);
				dynamicFieldsPanel.add(usePoint2Button, gbc);
				gbc.gridwidth = 1;
				gbc.insets = new Insets(5, 5, 5, 5);
				break;

			case "tolerance":
				addFieldToPanel(gbc, row++, "exactX");
				addFieldToPanel(gbc, row++, "exactY");
				addFieldToPanel(gbc, row++, "tolerance");
				break;
		}

		// Always add plane field (optional for all types)
		addFieldToPanel(gbc, row++, "plane");

		// Add "Use Current Location" button for exact and tolerance types
		if ("exact".equals(selectedType) || "tolerance".equals(selectedType))
		{
			useCurrentLocationButton = new JButton("Use Current Location");
			useCurrentLocationButton.addActionListener(this::onUseCurrentLocation);

			gbc.gridx = 0;
			gbc.gridy = row;
			gbc.gridwidth = 2;
			gbc.fill = GridBagConstraints.HORIZONTAL;
			gbc.insets = new Insets(10, 5, 5, 5);
			dynamicFieldsPanel.add(useCurrentLocationButton, gbc);
			gbc.gridwidth = 1;
			gbc.insets = new Insets(5, 5, 5, 5);
		}

		// Refresh the panel
		dynamicFieldsPanel.revalidate();
		dynamicFieldsPanel.repaint();
	}

	private void addFieldToPanel(GridBagConstraints gbc, int row, String fieldName)
	{
		JLabel label = labels.get(fieldName);
		JTextField field = fields.get(fieldName);
		
		if (label != null && field != null)
		{
			// Add label
			gbc.gridx = 0;
			gbc.gridy = row;
			gbc.fill = GridBagConstraints.NONE;
			dynamicFieldsPanel.add(label, gbc);
			
			// Add field
			gbc.gridx = 1;
			gbc.fill = GridBagConstraints.HORIZONTAL;
			gbc.weightx = 1.0;
			dynamicFieldsPanel.add(field, gbc);
			gbc.weightx = 0.0;
		}
	}

	private void onSave(ActionEvent e)
	{
		try
		{
			String selectedType = (String) typeCombo.getSelectedItem();
			constraint.setType(selectedType);
			constraint.setExactX(parseInteger("exactX"));
			constraint.setExactY(parseInteger("exactY"));
			constraint.setPlane(parseInteger("plane"));
			constraint.setTolerance(parseInteger("tolerance"));

			// For bounds type, calculate min/max from the two points
			if ("bounds".equals(selectedType))
			{
				Integer point1X = parseInteger("point1X");
				Integer point1Y = parseInteger("point1Y");
				Integer point2X = parseInteger("point2X");
				Integer point2Y = parseInteger("point2Y");

				if (point1X != null && point2X != null)
				{
					constraint.setMinX(Math.min(point1X, point2X));
					constraint.setMaxX(Math.max(point1X, point2X));
				}

				if (point1Y != null && point2Y != null)
				{
					constraint.setMinY(Math.min(point1Y, point2Y));
					constraint.setMaxY(Math.max(point1Y, point2Y));
				}
			}

			cancelled = false;
			onSave.accept(constraint);
			stopCoordinateUpdates();
			dispose();
		}
		catch (NumberFormatException ex)
		{
			JOptionPane.showMessageDialog(this, "Please enter valid numbers", "Input Error", JOptionPane.ERROR_MESSAGE);
		}
	}

	private void onCancel(ActionEvent e)
	{
		cancelled = true;
		stopCoordinateUpdates();
		dispose();
	}

	private void onUseCurrentLocation(ActionEvent e)
	{
		WorldPoint currentLocation = getCurrentPlayerLocation();
		if (currentLocation != null)
		{
			JTextField exactXField = fields.get("exactX");
			JTextField exactYField = fields.get("exactY");
			JTextField planeField = fields.get("plane");

			if (exactXField != null) exactXField.setText(String.valueOf(currentLocation.getX()));
			if (exactYField != null) exactYField.setText(String.valueOf(currentLocation.getY()));
			if (planeField != null) planeField.setText(String.valueOf(currentLocation.getPlane()));
		}
	}

	private void onUseCurrentLocationForPoint(int pointNumber)
	{
		WorldPoint currentLocation = getCurrentPlayerLocation();
		if (currentLocation != null)
		{
			String xFieldName = "point" + pointNumber + "X";
			String yFieldName = "point" + pointNumber + "Y";

			JTextField xField = fields.get(xFieldName);
			JTextField yField = fields.get(yFieldName);
			JTextField planeField = fields.get("plane");

			if (xField != null) xField.setText(String.valueOf(currentLocation.getX()));
			if (yField != null) yField.setText(String.valueOf(currentLocation.getY()));
			if (planeField != null) planeField.setText(String.valueOf(currentLocation.getPlane()));
		}
	}

	private void startCoordinateUpdates()
	{
		// Update coordinates every 500ms
		coordinateUpdateTimer = new Timer(500, e -> updateCoordinatesDisplay());
		coordinateUpdateTimer.start();
		updateCoordinatesDisplay(); // Initial update
	}

	private void stopCoordinateUpdates()
	{
		if (coordinateUpdateTimer != null)
		{
			coordinateUpdateTimer.stop();
		}
	}

	private void updateCoordinatesDisplay()
	{
		SwingUtilities.invokeLater(() -> {
			WorldPoint location = getCurrentPlayerLocation();
			if (location != null)
			{
				coordinatesLabel.setText(String.format("Current Location: X:%d Y:%d Plane:%d", 
					location.getX(), location.getY(), location.getPlane()));
			}
			else
			{
				coordinatesLabel.setText("Current Location: Not available");
			}
		});
	}

	private WorldPoint getCurrentPlayerLocation()
	{
		if (client == null) return null;
		
		Player player = client.getLocalPlayer();
		if (player == null) return null;
		
		return player.getWorldLocation();
	}

	private Integer parseInteger(String fieldName)
	{
		JTextField field = fields.get(fieldName);
		if (field == null)
		{
			return null;
		}
		
		String text = field.getText();
		if (text == null || text.trim().isEmpty())
		{
			return null;
		}
		return Integer.parseInt(text.trim());
	}

	public boolean wasCancelled()
	{
		return cancelled;
	}

	@Override
	public void dispose()
	{
		stopCoordinateUpdates();
		super.dispose();
	}
}
package com.lennyscustomclues.dialogs;

import com.lennyscustomclues.ApiClient;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import java.awt.*;

public class ManageEventDialog extends JDialog
{
	private ApiClient apiClient;
	private Client client;
	private JFrame parentFrame;

	private JTextField eventKeyField;
	private JTextField secretKeyField;
	private JButton submitButton;
	private JButton cancelButton;
	private JLabel statusLabel;

	public ManageEventDialog(JFrame parent, Client client, ApiClient apiClient)
	{
		super(parent, "Manage Existing Event", true);
		this.parentFrame = parent;
		this.client = client;
		this.apiClient = apiClient;

		initializeUI();
		pack();
		setMinimumSize(new Dimension(400, 200));
		setLocationRelativeTo(parent);
	}

	private void initializeUI()
	{
		setLayout(new BorderLayout());
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title
		JLabel titleLabel = new JLabel("Enter Event Credentials");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(FontManager.getRunescapeFont());
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		// Main content panel
		JPanel mainPanel = new JPanel(new GridBagLayout());
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = new Insets(5, 5, 5, 5);
		gbc.anchor = GridBagConstraints.WEST;

		// Event Key label and field
		JLabel eventKeyLabel = new JLabel("Event Key:");
		eventKeyLabel.setForeground(Color.WHITE);
		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.fill = GridBagConstraints.NONE;
		mainPanel.add(eventKeyLabel, gbc);

		eventKeyField = new JTextField(20);
		eventKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		eventKeyField.setForeground(Color.WHITE);
		gbc.gridx = 1;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.weightx = 1.0;
		mainPanel.add(eventKeyField, gbc);

		// Secret Key label and field
		JLabel secretKeyLabel = new JLabel("Secret Key:");
		secretKeyLabel.setForeground(Color.WHITE);
		gbc.gridx = 0;
		gbc.gridy = 1;
		gbc.fill = GridBagConstraints.NONE;
		gbc.weightx = 0.0;
		mainPanel.add(secretKeyLabel, gbc);

		secretKeyField = new JTextField(20);
		secretKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		secretKeyField.setForeground(Color.WHITE);
		gbc.gridx = 1;
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.weightx = 1.0;
		mainPanel.add(secretKeyField, gbc);

		// Bottom panel containing buttons and status
		JPanel bottomPanel = new JPanel();
		bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Buttons panel
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		submitButton = new JButton("Load Event");
		submitButton.addActionListener(e -> onSubmit());
		buttonPanel.add(submitButton);

		cancelButton = new JButton("Cancel");
		cancelButton.addActionListener(e -> dispose());
		buttonPanel.add(cancelButton);

		// Status label
		statusLabel = new JLabel(" ");
		statusLabel.setForeground(Color.WHITE);
		statusLabel.setHorizontalAlignment(SwingConstants.CENTER);
		statusLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));

		bottomPanel.add(buttonPanel);
		bottomPanel.add(statusLabel);

		add(titleLabel, BorderLayout.NORTH);
		add(mainPanel, BorderLayout.CENTER);
		add(bottomPanel, BorderLayout.SOUTH);
	}

	private void onSubmit()
	{
		String eventKey = eventKeyField.getText().trim();
		String secretKey = secretKeyField.getText().trim();

		if (eventKey.isEmpty())
		{
			statusLabel.setText("Event key is required");
			statusLabel.setForeground(Color.RED);
			return;
		}

		if (secretKey.isEmpty())
		{
			statusLabel.setText("Secret key is required");
			statusLabel.setForeground(Color.RED);
			return;
		}

		// Disable buttons while loading
		submitButton.setEnabled(false);
		statusLabel.setText("Loading event...");
		statusLabel.setForeground(Color.YELLOW);

		// Make API request to get the answer
		apiClient.getAnswer(eventKey, secretKey).thenAccept(response -> {
			SwingUtilities.invokeLater(() -> {
				submitButton.setEnabled(true);

				if (response.isSuccess())
				{
					// Successfully retrieved the answer - open the event info dialog
					statusLabel.setText("Event loaded successfully!");
					statusLabel.setForeground(Color.GREEN);

					// Close this dialog
					dispose();

					// Open the event info dialog to show answer summary and solvers
					EventInfoDialog eventInfoDialog = new EventInfoDialog(
						parentFrame,
						client,
						apiClient,
						eventKey,
						secretKey,
						response.reward_text,
						response.constraints,
						response.completed_by
					);
					eventInfoDialog.setVisible(true);
				}
				else
				{
					// Handle error
					String errorMessage = "Failed to load event: ";
					if ("NOT_FOUND".equals(response.errorType))
					{
						errorMessage += "Event key not found";
					}
					else if ("UNAUTHORIZED".equals(response.errorType))
					{
						errorMessage += "Invalid secret key";
					}
					else if ("NETWORK_ERROR".equals(response.errorType))
					{
						errorMessage += "Network error";
					}
					else
					{
						errorMessage += response.errorMessage;
					}

					statusLabel.setText(errorMessage);
					statusLabel.setForeground(Color.RED);
				}
			});
		});
	}
}

package com.lennyscustomclues.dialogs;

import com.lennyscustomclues.AnswerBuilder;
import com.lennyscustomclues.ApiClient;
import com.lennyscustomclues.EmoteData;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.util.function.BiConsumer;

public class SubmitAnswerDialog extends JDialog
{
	private JTextField eventKeyField;
	private JTextField secretKeyField;
	private JButton validateKeyButton;
	private JButton submitButton;
	private JButton cancelButton;
	private JLabel validationStatusLabel;

	private AnswerBuilder answerBuilder;
	private ApiClient apiClient;
	private BiConsumer<String, String> onSubmit;
	private boolean cancelled = true;
	private boolean keyValidated = false;

	public SubmitAnswerDialog(JFrame parent, AnswerBuilder answerBuilder, ApiClient apiClient, BiConsumer<String, String> onSubmit)
	{
		super(parent, "Submit Answer to Server", false); // Non-modal
		this.answerBuilder = answerBuilder;
		this.apiClient = apiClient;
		this.onSubmit = onSubmit;
		
		initializeUI();
		pack();
		setLocationRelativeTo(parent);
		setAlwaysOnTop(true);
	}

	private void initializeUI()
	{
		setLayout(new BorderLayout());
		getContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Main content panel
		JPanel mainPanel = new JPanel();
		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		mainPanel.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));

		// Title/instructions
		JLabel titleLabel = new JLabel("Submit Answer to Server");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 14f));
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		JLabel instructionLabel = new JLabel("<html><div style='text-align: center;'>Enter an event key to associate with this answer.<br/>The key must be unique and not already in use.</div></html>");
		instructionLabel.setForeground(Color.LIGHT_GRAY);
		instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// Answer summary
		JPanel summaryPanel = new JPanel(new BorderLayout());
		summaryPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		summaryPanel.setBorder(BorderFactory.createTitledBorder("Answer Summary"));
		summaryPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 150));

		String rewardText = answerBuilder.getRewardText();
		if (rewardText == null || rewardText.trim().isEmpty())
		{
			rewardText = "(No reward text specified)";
		}

		// Build human-readable constraint descriptions
		StringBuilder summaryBuilder = new StringBuilder();
		summaryBuilder.append("Reward: ").append(rewardText).append("\n\n");

		if (answerBuilder.getConstraintCount() == 0)
		{
			summaryBuilder.append("No constraints defined");
		}
		else
		{
			// Check if there's an emote constraint
			String requiredAction = "Dig with a spade";
			for (int i = 0; i < answerBuilder.getConstraintCount(); i++)
			{
				com.lennyscustomclues.constraints.Constraint constraint = answerBuilder.getConstraint(i);
				if (constraint instanceof com.lennyscustomclues.constraints.ActionConstraint)
				{
					com.lennyscustomclues.constraints.ActionConstraint actionConstraint =
						(com.lennyscustomclues.constraints.ActionConstraint) constraint;
					if ("emote".equals(actionConstraint.getType()) && actionConstraint.getEmoteId() != null)
					{
						String emoteName = EmoteData.getEmoteName(actionConstraint.getEmoteId());
						requiredAction = "Perform an Emote: " + emoteName;
					}
				}
			}
			summaryBuilder.append("Required Action: ").append(requiredAction).append("\n");

			for (int i = 0; i < answerBuilder.getConstraintCount(); i++)
			{
				com.lennyscustomclues.constraints.Constraint constraint = answerBuilder.getConstraint(i);
				if (constraint instanceof com.lennyscustomclues.constraints.LocationConstraint)
				{
					summaryBuilder.append(getLocationConstraintDescription((com.lennyscustomclues.constraints.LocationConstraint) constraint));
				}
			}
		}

		JTextArea summaryArea = new JTextArea(summaryBuilder.toString());
		summaryArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		summaryArea.setForeground(Color.WHITE);
		summaryArea.setEditable(false);
		summaryArea.setLineWrap(true);
		summaryArea.setWrapStyleWord(true);
		JScrollPane summaryScroll = new JScrollPane(summaryArea);
		summaryPanel.add(summaryScroll, BorderLayout.CENTER);

		// Event key input panel
		JPanel eventKeyPanel = new JPanel(new BorderLayout());
		eventKeyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		eventKeyPanel.setBorder(BorderFactory.createTitledBorder("Event Key"));

		eventKeyField = new JTextField(20);
		eventKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		eventKeyField.setForeground(Color.WHITE);
		eventKeyField.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
			public void insertUpdate(javax.swing.event.DocumentEvent e) { onEventKeyChanged(); }
			public void removeUpdate(javax.swing.event.DocumentEvent e) { onEventKeyChanged(); }
			public void changedUpdate(javax.swing.event.DocumentEvent e) { onEventKeyChanged(); }
		});

		validateKeyButton = new JButton("Validate Key");
		validateKeyButton.addActionListener(this::onValidateKey);
		validateKeyButton.setEnabled(false);

		JPanel keyInputPanel = new JPanel(new BorderLayout());
		keyInputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		keyInputPanel.add(eventKeyField, BorderLayout.CENTER);
		keyInputPanel.add(validateKeyButton, BorderLayout.EAST);

		validationStatusLabel = new JLabel(" ");
		validationStatusLabel.setForeground(Color.GRAY);

		eventKeyPanel.add(keyInputPanel, BorderLayout.NORTH);
		eventKeyPanel.add(validationStatusLabel, BorderLayout.SOUTH);

		// Secret key input panel
		JPanel secretKeyPanel = new JPanel(new BorderLayout());
		secretKeyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		secretKeyPanel.setBorder(BorderFactory.createTitledBorder("Secret Key (Optional)"));

		secretKeyField = new JTextField(20);
		secretKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		secretKeyField.setForeground(Color.WHITE);

		JLabel secretKeyInfoLabel = new JLabel("<html><i>Used to retrieve and update this answer later</i></html>");
		secretKeyInfoLabel.setForeground(Color.LIGHT_GRAY);
		secretKeyInfoLabel.setFont(secretKeyInfoLabel.getFont().deriveFont(11f));

		secretKeyPanel.add(secretKeyField, BorderLayout.NORTH);
		secretKeyPanel.add(secretKeyInfoLabel, BorderLayout.SOUTH);

		// Button panel
		JPanel buttonPanel = new JPanel(new FlowLayout());
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		submitButton = new JButton("Submit Answer");
		submitButton.addActionListener(this::onSubmit);
		submitButton.setEnabled(false); // Initially disabled

		cancelButton = new JButton("Cancel");
		cancelButton.addActionListener(this::onCancel);

		buttonPanel.add(submitButton);
		buttonPanel.add(cancelButton);

		// Add all components
		mainPanel.add(titleLabel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(instructionLabel);
		mainPanel.add(Box.createVerticalStrut(15));
		mainPanel.add(summaryPanel);
		mainPanel.add(Box.createVerticalStrut(15));
		mainPanel.add(eventKeyPanel);
		mainPanel.add(Box.createVerticalStrut(10));
		mainPanel.add(secretKeyPanel);

		add(mainPanel, BorderLayout.CENTER);
		add(buttonPanel, BorderLayout.SOUTH);
	}

	private void onEventKeyChanged()
	{
		String eventKey = eventKeyField.getText().trim();
		keyValidated = false;
		validationStatusLabel.setText(" ");
		validationStatusLabel.setForeground(Color.GRAY);
		
		validateKeyButton.setEnabled(!eventKey.isEmpty());
		submitButton.setEnabled(false);
	}

	private void onValidateKey(ActionEvent e)
	{
		String eventKey = eventKeyField.getText().trim();
		if (eventKey.isEmpty())
		{
			return;
		}

		validateKeyButton.setEnabled(false);
		validationStatusLabel.setText("Validating key...");
		validationStatusLabel.setForeground(Color.YELLOW);

		// Validate the key with the API
		apiClient.validateEventKey(eventKey).thenAccept(response -> {
			SwingUtilities.invokeLater(() -> {
				if (response.success)
				{
					// 200 response means key already exists - NOT available for new answer
					keyValidated = false;
					validationStatusLabel.setText(" Key already exists");
					validationStatusLabel.setForeground(Color.RED);
					submitButton.setEnabled(false);
				}
				else
				{
					// Non-success response
					if ("KEY_NOT_FOUND".equals(response.errorType))
					{
						// 404 means key doesn't exist - GOOD for creating new answer
						keyValidated = true;
						validationStatusLabel.setText(" Key is available");
						validationStatusLabel.setForeground(Color.GREEN);
						submitButton.setEnabled(true);
					}
					else
					{
						// Other error (server error, network error, etc.)
						keyValidated = false;
						validationStatusLabel.setText(" " + response.message);
						validationStatusLabel.setForeground(Color.RED);
						submitButton.setEnabled(false);
					}
				}
				validateKeyButton.setEnabled(true);
			});
		});
	}

	private void onSubmit(ActionEvent e)
	{
		if (!keyValidated)
		{
			JOptionPane.showMessageDialog(this, "Please validate the event key first.", "Validation Required", JOptionPane.WARNING_MESSAGE);
			return;
		}

		String eventKey = eventKeyField.getText().trim();
		if (eventKey.isEmpty())
		{
			JOptionPane.showMessageDialog(this, "Please enter an event key.", "Event Key Required", JOptionPane.WARNING_MESSAGE);
			return;
		}

		String secretKey = secretKeyField.getText().trim();

		// Warn if no secret key is provided
		if (secretKey.isEmpty())
		{
			int result = JOptionPane.showConfirmDialog(
				this,
				"You have not set a secret key for this event, which means you won't be able to inspect or update the answer in any way after creation.\n\nAre you sure you don't want to set a secret key?",
				"No Secret Key Set",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE
			);

			if (result != JOptionPane.YES_OPTION)
			{
				return; // User chose not to proceed
			}
		}

		cancelled = false;
		onSubmit.accept(eventKey, secretKey);
		dispose();
	}

	private void onCancel(ActionEvent e)
	{
		cancelled = true;
		dispose();
	}

	public boolean wasCancelled()
	{
		return cancelled;
	}

	private String getLocationConstraintDescription(com.lennyscustomclues.constraints.LocationConstraint constraint)
	{
		StringBuilder desc = new StringBuilder();
		String type = constraint.getType();

		switch (type)
		{
			case "exact":
				desc.append("Location: Exact tile (");
				desc.append("X: ").append(constraint.getExactX());
				desc.append(", Y: ").append(constraint.getExactY());
				if (constraint.getPlane() != null)
				{
					desc.append(", Plane: ").append(constraint.getPlane());
				}
				desc.append(")");
				break;

			case "bounds":
				desc.append("Location: Within rectangle (");
				desc.append("X: ").append(constraint.getMinX()).append("-").append(constraint.getMaxX());
				desc.append(", Y: ").append(constraint.getMinY()).append("-").append(constraint.getMaxY());
				if (constraint.getPlane() != null)
				{
					desc.append(", Plane: ").append(constraint.getPlane());
				}
				desc.append(")");
				break;

			case "tolerance":
				desc.append("Location: Near tile (");
				desc.append("X: ").append(constraint.getExactX());
				desc.append(", Y: ").append(constraint.getExactY());
				if (constraint.getTolerance() != null)
				{
					desc.append(", within ").append(constraint.getTolerance()).append(" tiles");
				}
				if (constraint.getPlane() != null)
				{
					desc.append(", Plane: ").append(constraint.getPlane());
				}
				desc.append(")");
				break;

			default:
				desc.append("Location: ").append(constraint.description());
				break;
		}

		return desc.toString();
	}
}
package com.lennyscustomclues;

import java.util.LinkedHashMap;
import java.util.Map;

public class EmoteData
{
	private static final Map<String, Integer> EMOTES = new LinkedHashMap<>();

	static
	{
		EMOTES.put("Yes", 855);
		EMOTES.put("No", 856);
		EMOTES.put("Bow", 858);
		EMOTES.put("Angry", 859);
		EMOTES.put("Think", 857);
		EMOTES.put("Wave", 863);
		EMOTES.put("Shrug", 2113);
		EMOTES.put("Cheer", 862);
		EMOTES.put("Beckon", 864);
		EMOTES.put("Laugh", 861);
		EMOTES.put("Jump for Joy", 2109);
		EMOTES.put("Yawn", 2111);
		EMOTES.put("Dance", 866);
		EMOTES.put("Jig", 2106);
		EMOTES.put("Spin", 2107);
		EMOTES.put("Headbang", 2108);
		EMOTES.put("Cry", 860);
		EMOTES.put("Blow Kiss", 1374);
		EMOTES.put("Panic", 2105);
		EMOTES.put("Raspberry", 2110);
		EMOTES.put("Clap", 865);
		EMOTES.put("Salute", 2112);
		EMOTES.put("Goblin Bow", 2127);
		EMOTES.put("Goblin Salute", 2128);
		EMOTES.put("Glass Box", 1131);
		EMOTES.put("Climb Rope", 1130);
		EMOTES.put("Lean", 1129);
		EMOTES.put("Glass Wall", 1128);
		EMOTES.put("Idea", 4276);
		EMOTES.put("Stamp", 4278);
		EMOTES.put("Flap", 4280);
		EMOTES.put("Slap Head", 4275);
		EMOTES.put("Zombie Walk", 3544);
		EMOTES.put("Zombie Dance", 3543);
		EMOTES.put("Scared", 2836);
		EMOTES.put("Rabbit Hop", 6111);
		EMOTES.put("Sit up", 874);
		EMOTES.put("Push up", 872);
		EMOTES.put("Star jump", 870);
		EMOTES.put("Jog", 868);
		EMOTES.put("Flex", 8917);
		EMOTES.put("Zombie Hand", 1708);
		EMOTES.put("Hypermobile Drinker", 7131);
		EMOTES.put("Smooth dance", 7533);
		EMOTES.put("Crazy dance", 7537);
		EMOTES.put("Premier Shield", 7751);
		EMOTES.put("Party", 10031);
		EMOTES.put("Trick", 10503);
		EMOTES.put("Fortis Salute", 10796);
		EMOTES.put("Sit down", 10061);
	}

	public static Map<String, Integer> getEmotes()
	{
		return EMOTES;
	}

	public static String getEmoteName(int emoteId)
	{
		for (Map.Entry<String, Integer> entry : EMOTES.entrySet())
		{
			if (entry.getValue() == emoteId)
			{
				return entry.getKey();
			}
		}
		return "Unknown Emote";
	}

	public static Integer getEmoteId(String emoteName)
	{
		return EMOTES.get(emoteName);
	}
}

package com.lennyscustomclues;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.util.function.Consumer;

public class EventKeyDialog extends JDialog
{
	private final JTextField eventKeyField;
	private final JButton submitButton;
	private final JButton cancelButton;
	private final JLabel statusLabel;
	private final Consumer<String> onEventKeySet;
	private final ApiClient apiClient;
	private boolean submitted = false;
	private boolean validating = false;

	public EventKeyDialog(JFrame parent, String currentEventKey, boolean isChanging, Consumer<String> onEventKeySet, ApiClient apiClient)
	{
		super(parent, isChanging ? "Change Event Key" : "Set Event Key", true);
		this.onEventKeySet = onEventKeySet;
		this.apiClient = apiClient;

		// Setup dialog properties
		setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
		setResizable(false);

		// Create components
		JPanel mainPanel = new JPanel();
		mainPanel.setLayout(new BorderLayout(10, 10));
		mainPanel.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title label
		JLabel titleLabel = new JLabel("Enter event key:");
		titleLabel.setFont(FontManager.getRunescapeFont());
		titleLabel.setForeground(Color.WHITE);

		// Text field
		eventKeyField = new JTextField(20);
		eventKeyField.setFont(FontManager.getRunescapeFont());
		eventKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		eventKeyField.setForeground(Color.WHITE);
		eventKeyField.setCaretColor(Color.WHITE);
		eventKeyField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(5, 5, 5, 5)
		));

		// Pre-fill if changing
		if (isChanging && currentEventKey != null)
		{
			eventKeyField.setText(currentEventKey);
			eventKeyField.selectAll();
		}

		// Status label for validation feedback
		statusLabel = new JLabel(" "); // Space to maintain height
		statusLabel.setFont(FontManager.getRunescapeSmallFont());
		statusLabel.setHorizontalAlignment(SwingConstants.CENTER);

		// Buttons
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 0));
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		cancelButton = new JButton("Cancel");
		styleButton(cancelButton);
		cancelButton.addActionListener(this::onCancelClick);

		submitButton = new JButton("Submit");
		styleButton(submitButton);
		submitButton.addActionListener(this::onSubmitClick);

		buttonPanel.add(cancelButton);
		buttonPanel.add(submitButton);

		// Layout
		JPanel inputPanel = new JPanel(new BorderLayout(0, 5));
		inputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		inputPanel.add(titleLabel, BorderLayout.NORTH);
		inputPanel.add(eventKeyField, BorderLayout.CENTER);
		inputPanel.add(statusLabel, BorderLayout.SOUTH);

		mainPanel.add(inputPanel, BorderLayout.CENTER);
		mainPanel.add(buttonPanel, BorderLayout.SOUTH);

		add(mainPanel);

		// Setup keyboard shortcuts
		setupKeyBindings();

		// Pack and center
		pack();
		setLocationRelativeTo(parent);

		// Focus text field
		SwingUtilities.invokeLater(() -> eventKeyField.requestFocusInWindow());
	}

	private void styleButton(JButton button)
	{
		button.setFont(FontManager.getRunescapeFont());
		button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		button.setForeground(Color.WHITE);
		button.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(5, 15, 5, 15)
		));
		button.setFocusPainted(false);
	}

	private void setupKeyBindings()
	{
		// Enter key submits
		eventKeyField.addActionListener(this::onSubmitClick);

		// Escape key cancels
		getRootPane().registerKeyboardAction(
			this::onCancelClick,
			KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),
			JComponent.WHEN_IN_FOCUSED_WINDOW
		);

		// Make Submit the default button
		getRootPane().setDefaultButton(submitButton);
	}

	private void onSubmitClick(ActionEvent e)
	{
		if (validating)
		{
			return; // Ignore if already validating
		}

		String eventKey = eventKeyField.getText().trim();
		
		if (eventKey.isEmpty())
		{
			setStatusMessage("Event key cannot be empty.", true);
			eventKeyField.requestFocusInWindow();
			return;
		}

		// Start validation
		validating = true;
		setButtonsEnabled(false);
		setStatusMessage("Validating event key...", false);

		apiClient.validateEventKey(eventKey).thenAccept(response -> {
			SwingUtilities.invokeLater(() -> {
				validating = false;
				setButtonsEnabled(true);

				if (response.success)
				{
					// Key is valid, proceed
					submitted = true;
					onEventKeySet.accept(eventKey);
					dispose();
				}
				else
				{
					// Handle different error types with user-friendly messages
					String userMessage = getUserFriendlyErrorMessage(response);
					setStatusMessage(userMessage, true);
					eventKeyField.requestFocusInWindow();
					eventKeyField.selectAll();
				}
			});
		}).exceptionally(throwable -> {
			SwingUtilities.invokeLater(() -> {
				validating = false;
				setButtonsEnabled(true);
				setStatusMessage("Can't reach the server", true);
				eventKeyField.requestFocusInWindow();
			});
			return null;
		});
	}

	private String getUserFriendlyErrorMessage(ApiClient.ApiResponse response)
	{
		if (response.errorType != null)
		{
			switch (response.errorType)
			{
				case "KEY_NOT_FOUND":
					return "Invalid event key";
				case "NETWORK_ERROR":
				case "IO_ERROR":
				case "REQUEST_ERROR":
					return "Can't reach the server";
				case "SERVER_ERROR":
				case "PARSE_ERROR":
				default:
					return "An unexpected error occurred";
			}
		}
		
		// Fallback for responses without error type
		return "Invalid event key";
	}

	private void onCancelClick(ActionEvent e)
	{
		if (!validating)
		{
			dispose();
		}
	}

	private void setStatusMessage(String message, boolean isError)
	{
		if (isError)
		{
			statusLabel.setForeground(Color.RED);
		}
		else
		{
			statusLabel.setForeground(Color.LIGHT_GRAY);
		}
		statusLabel.setText(message);
	}

	private void setButtonsEnabled(boolean enabled)
	{
		submitButton.setEnabled(enabled);
		cancelButton.setEnabled(enabled);
		eventKeyField.setEnabled(enabled);
		
		if (enabled)
		{
			submitButton.setText("Submit");
		}
		else
		{
			submitButton.setText("Validating...");
		}
	}

	public boolean wasSubmitted()
	{
		return submitted;
	}
}
package com.lennyscustomclues;

import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class GameStateCapture
{
	@Inject
	private Client client;

	public List<ApiClient.ItemData> getInventoryData()
	{
		List<ApiClient.ItemData> inventoryItems = new ArrayList<>();
		ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);

		if (inventory == null)
		{
			return inventoryItems;
		}

		Item[] items = inventory.getItems();
		for (int i = 0; i < items.length; i++)
		{
			Item item = items[i];
			if (item != null && item.getId() != -1)
			{
				inventoryItems.add(new ApiClient.ItemData(i, item.getId(), item.getQuantity()));
			}
		}

		return inventoryItems;
	}

	public List<ApiClient.ItemData> getWornItemsData()
	{
		List<ApiClient.ItemData> wornItems = new ArrayList<>();
		ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);

		if (equipment == null)
		{
			return wornItems;
		}

		Item[] items = equipment.getItems();
		for (int i = 0; i < items.length; i++)
		{
			Item item = items[i];
			if (item != null && item.getId() != -1)
			{
				wornItems.add(new ApiClient.ItemData(i, item.getId(), item.getQuantity()));
			}
		}

		return wornItems;
	}

	public ApiClient.LocationData getLocationData(WorldPoint worldLocation, LocalPoint localLocation)
	{
		ApiClient.WorldCoords worldCoords = new ApiClient.WorldCoords(
			worldLocation.getX(), worldLocation.getY(), worldLocation.getPlane());
		
		ApiClient.LocalCoords localCoords = new ApiClient.LocalCoords(
			localLocation.getSceneX(), localLocation.getSceneY());
		
		return new ApiClient.LocationData(worldCoords, localCoords);
	}

	public ApiClient.GameStateSubmission createGameStateSubmission(ApiClient.LocationData locationData, 
		List<ApiClient.ItemData> inventoryData, List<ApiClient.ItemData> wornItemsData, 
		Integer emoteId, Integer npcId, String interactionType, String eventKey)
	{
		// Get player's RSN (RuneScape Name)
		Player localPlayer = client.getLocalPlayer();
		String rsn = (localPlayer != null) ? localPlayer.getName() : null;
		
		return new ApiClient.GameStateSubmission(locationData, inventoryData, wornItemsData, 
			emoteId, npcId, interactionType, eventKey, rsn);
	}
}
package com.lennyscustomclues;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Singleton
public class GameStateService
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private LennysCustomCluesConfig config;

	@Inject
	private ApiClient apiClient;

	@Inject
	private GameStateCapture gameStateCapture;

	@Inject
	private CelebrationManager celebrationManager;

	private LennysCustomCluesPanel panel;

	// Event key management
	private String currentEventKey = "";

	public void setPanel(LennysCustomCluesPanel panel)
	{
		this.panel = panel;
	}

	public String getEventKey()
	{
		return currentEventKey;
	}

	public void setEventKey(String eventKey)
	{
		this.currentEventKey = (eventKey != null) ? eventKey.trim() : "";
		if (panel != null)
		{
			panel.onEventKeyChanged();
		}
	}

	public void clearEventKey()
	{
		this.currentEventKey = "";
		if (panel != null)
		{
			panel.onEventKeyChanged();
		}
	}

	public boolean hasEventKey()
	{
		return !currentEventKey.isEmpty();
	}

	private boolean isEventKeyValid()
	{
		return hasEventKey();
	}

	public void captureFromAnimation(int animationId)
	{
		clientThread.invokeLater(() -> {
			if (!isEventKeyValid())
			{
				if (config.debug())
				{
					client.addChatMessage(
						ChatMessageType.GAMEMESSAGE,
						"",
						"[LL-debug] Game state capture skipped - Event Key is empty (Animation ID: " + animationId + ")",
						null
					);
				}
				return;
			}

			String eventKey = getEventKey();

			// Determine if this is a dig or emote animation
			if (AnimationTriggers.isDigAnimation(animationId))
			{
				captureGameState("dig", "Digging animation (ID: " + animationId + ")", null, null, null, eventKey);
			}
			else if (AnimationTriggers.isEmoteAnimation(animationId))
			{
				String emoteName = EmoteData.getEmoteName(animationId);
				captureGameState("emote", "Emote: " + emoteName + " (ID: " + animationId + ")", animationId, null, null, eventKey);
			}
		});
	}

	private void captureGameState(String trigger, String additionalInfo, Integer emoteId, Integer npcId, String interactionType, String eventKey)
	{
		Player player = client.getLocalPlayer();
		if (player != null)
		{
			WorldPoint worldLocation = player.getWorldLocation();
			LocalPoint localLocation = player.getLocalLocation();

			ApiClient.LocationData locationData = gameStateCapture.getLocationData(worldLocation, localLocation);
			List<ApiClient.ItemData> inventoryData = gameStateCapture.getInventoryData();
			List<ApiClient.ItemData> wornItemsData = gameStateCapture.getWornItemsData();
			
			ApiClient.GameStateSubmission gameStateSubmission = gameStateCapture.createGameStateSubmission(
				locationData, inventoryData, wornItemsData, emoteId, npcId, interactionType, eventKey);

			// Log submission info
			log.info("=== Lenny's Custom Clues Game State Submission ({}) ===", trigger);
			log.info("Trigger info: {}", additionalInfo);
			log.info("Event Key: {}, Inventory: {} items, Worn: {} items", 
				eventKey, inventoryData.size(), wornItemsData.size());

			// Update UI immediately
			if (panel != null)
			{
				panel.updateStatusLabel(String.format(
					"<html><div style='text-align: center;'>Submitting...<br/>Trigger: %s<br/>%s<br/>Event: %s</div></html>",
					trigger,
					additionalInfo,
					eventKey
				));
			}

			// Submit to API
			CompletableFuture<ApiClient.ApiResponse> future = apiClient.submitGuess(gameStateSubmission);
			future.thenAccept(this::handleApiResponse);

			// Show initial message in chat (debug mode only)
			if (config.debug())
			{
				client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"",
					"[LL-debug] Submitting guess for '" + eventKey + "'...",
					null
				);
			}
		}
		else
		{
			if (panel != null)
			{
				panel.updateStatusLabel("Player not found");
			}
		}
	}

	private void handleApiResponse(ApiClient.ApiResponse response)
	{
		// Update UI
		if (panel != null)
		{
			String statusText;
			if (response.success)
			{
				statusText = String.format(
					"<html><div style='text-align: center;'><font color='green'> CORRECT!</font><br/>%s</div></html>",
					response.message
				);
			}
			else
			{
				statusText = String.format(
					"<html><div style='text-align: center;'><font color='red'> %s</font><br/>%s</div></html>",
					response.success ? "SUCCESS" : "FAILED",
					response.message
				);
			}
			panel.updateStatusLabel(statusText);
		}

		// Trigger victory celebration if successful
		if (response.success && celebrationManager != null)
		{
			celebrationManager.triggerVictoryCelebration(currentEventKey);
		}

		// Add message to in-game chat on client thread
		clientThread.invokeLater(() -> {
			if (response.success)
			{
				// Always show success messages
				String chatMessage = "[Lenny's Custom Clues] " + response.message;
				client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"",
					chatMessage,
					null
				);
			}
			else if (config.debug())
			{
				// Only show failure messages in debug mode
				String chatMessage = "[LL-debug] " + response.message;
				client.addChatMessage(
					ChatMessageType.GAMEMESSAGE,
					"",
					chatMessage,
					null
				);
			}
		});
	}
}
package com.lennyscustomclues;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("lennyscustomclues")
public interface LennysCustomCluesConfig extends Config
{
	@ConfigItem(
		keyName = "debug",
		name = "Debug Mode",
		description = "Show all animation IDs in chat when player performs animations"
	)
	default boolean debug()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showCelebrationSound",
		name = "Victory sound effects",
		description = "Play a celebratory sound when you solve a puzzle correctly"
	)
	default boolean showCelebrationSound()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showCelebrationFireworks",
		name = "Victory fireworks",
		description = "Show fireworks when you solve a puzzle correctly"
	)
	default boolean showCelebrationFireworks()
	{
		return true;
	}

}
package com.lennyscustomclues;

import com.lennyscustomclues.dialogs.AnswerBuilderDialog;
import com.lennyscustomclues.dialogs.ManageEventDialog;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;

@Singleton
public class LennysCustomCluesPanel extends PluginPanel
{
	@Inject
	private GameStateService gameStateService;

	@Inject
	private ApiClient apiClient;

	@Inject
	private Client client;

	private JLabel titleLabel;
	private JPanel buttonPanel;
	private JLabel statusLabel;
	private JLabel instructionalLabel;
	private JLabel resultLabel;

	// Buttons for different states
	private JButton setEventKeyButton;
	private JButton unsetEventKeyButton;
	private JButton changeEventKeyButton;
	private JButton createAnswerButton;
	private JButton manageEventButton;

	public LennysCustomCluesPanel()
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Title label
		titleLabel = new JLabel("Lenny's Custom Clues");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(FontManager.getRunescapeFont());
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);

		// Button panel - will be dynamically populated
		buttonPanel = new JPanel();
		buttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Status label
		statusLabel = new JLabel();
		statusLabel.setForeground(Color.WHITE);
		statusLabel.setHorizontalAlignment(SwingConstants.CENTER);

		// Create all buttons
		createButtons();

		// Layout
		add(titleLabel, BorderLayout.NORTH);
		add(buttonPanel, BorderLayout.CENTER);
		add(statusLabel, BorderLayout.SOUTH);

		// UI state will be initialized in initialize() after injection
	}

	private void createButtons()
	{
		setEventKeyButton = new JButton("Set Event Key");
		setEventKeyButton.addActionListener(this::onSetEventKeyClick);
		setEventKeyButton.setAlignmentX(Component.LEFT_ALIGNMENT);
		setEventKeyButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, setEventKeyButton.getPreferredSize().height));

		unsetEventKeyButton = new JButton("Unset Event Key");
		unsetEventKeyButton.addActionListener(this::onUnsetEventKeyClick);
		unsetEventKeyButton.setAlignmentX(Component.LEFT_ALIGNMENT);
		unsetEventKeyButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, unsetEventKeyButton.getPreferredSize().height));

		changeEventKeyButton = new JButton("Change Event Key");
		changeEventKeyButton.addActionListener(this::onChangeEventKeyClick);
		changeEventKeyButton.setAlignmentX(Component.LEFT_ALIGNMENT);
		changeEventKeyButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, changeEventKeyButton.getPreferredSize().height));

		createAnswerButton = new JButton("Create a new event");
		createAnswerButton.addActionListener(this::onCreateAnswerClick);
		createAnswerButton.setAlignmentX(Component.LEFT_ALIGNMENT);
		createAnswerButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, createAnswerButton.getPreferredSize().height));

		manageEventButton = new JButton("Manage existing event");
		manageEventButton.addActionListener(this::onManageEventClick);
		manageEventButton.setAlignmentX(Component.LEFT_ALIGNMENT);
		manageEventButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, manageEventButton.getPreferredSize().height));
	}

	@Inject
	public void initialize()
	{
		// Set up the bidirectional reference with the service
		gameStateService.setPanel(this);
		
		// Initialize UI state now that injection is complete
		updatePanelForEventKeyState();
	}

	public void onEventKeyChanged()
	{
		SwingUtilities.invokeLater(this::updatePanelForEventKeyState);
	}

	private void updatePanelForEventKeyState()
	{
		buttonPanel.removeAll();

		if (gameStateService.hasEventKey())
		{
			showEventKeySetState();
		}
		else
		{
			showNoEventKeyState();
		}

		buttonPanel.revalidate();
		buttonPanel.repaint();
	}

	private void showNoEventKeyState()
	{
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));
		buttonPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		// Play in an event section
		buttonPanel.add(createSectionLabel("Play in an event"));
		buttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		buttonPanel.add(setEventKeyButton);

		// Spacing between sections
		buttonPanel.add(Box.createRigidArea(new Dimension(0, 15)));

		// Event management section
		buttonPanel.add(createSectionLabel("Event management"));
		buttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		buttonPanel.add(createAnswerButton);
		buttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		buttonPanel.add(manageEventButton);

		statusLabel.setText("");
	}

	private void showEventKeySetState()
	{
		buttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));
		buttonPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		String eventKey = gameStateService.getEventKey();

		// Playing in event section
		buttonPanel.add(createSectionLabel("Playing in: " + eventKey));
		buttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));

		// Instructional text
		instructionalLabel = new JLabel("<html>Try and solve the clue!<br/>Good luck!</html>");
		instructionalLabel.setForeground(Color.WHITE);
		instructionalLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		buttonPanel.add(instructionalLabel);
		buttonPanel.add(Box.createRigidArea(new Dimension(0, 10)));

		// Result text area
		resultLabel = new JLabel("");
		resultLabel.setForeground(Color.WHITE);
		resultLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		buttonPanel.add(resultLabel);

		// Push buttons to bottom
		buttonPanel.add(Box.createVerticalGlue());

		// Event key buttons
		buttonPanel.add(changeEventKeyButton);
		buttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		buttonPanel.add(unsetEventKeyButton);

		statusLabel.setText("");
	}

	private JLabel createSectionLabel(String text)
	{
		JLabel label = new JLabel(text);
		label.setForeground(ColorScheme.BRAND_ORANGE);
		label.setFont(FontManager.getRunescapeBoldFont());
		label.setAlignmentX(Component.LEFT_ALIGNMENT);
		return label;
	}

	private void onSetEventKeyClick(ActionEvent e)
	{
		showEventKeyDialog(null, false);
	}

	private void onChangeEventKeyClick(ActionEvent e)
	{
		showEventKeyDialog(gameStateService.getEventKey(), true);
	}

	private void onUnsetEventKeyClick(ActionEvent e)
	{
		gameStateService.clearEventKey();
	}

	private void showEventKeyDialog(String currentEventKey, boolean isChanging)
	{
		// Find the parent frame
		Window parentWindow = SwingUtilities.getWindowAncestor(this);
		JFrame parentFrame = (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;

		EventKeyDialog dialog = new EventKeyDialog(
			parentFrame,
			currentEventKey,
			isChanging,
			eventKey -> gameStateService.setEventKey(eventKey),
			apiClient
		);

		dialog.setVisible(true);
	}

	private void onCreateAnswerClick(ActionEvent e)
	{
		// Find the parent frame
		Window parentWindow = SwingUtilities.getWindowAncestor(this);
		JFrame parentFrame = (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;

		AnswerBuilderDialog dialog = new AnswerBuilderDialog(
			parentFrame,
			client,
			apiClient
		);

		dialog.setVisible(true);
	}

	private void onManageEventClick(ActionEvent e)
	{
		// Find the parent frame
		Window parentWindow = SwingUtilities.getWindowAncestor(this);
		JFrame parentFrame = (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;

		ManageEventDialog dialog = new ManageEventDialog(
			parentFrame,
			client,
			apiClient
		);

		dialog.setVisible(true);
	}

	public void updateStatusLabel(String text)
	{
		SwingUtilities.invokeLater(() -> {
			if (resultLabel != null)
			{
				resultLabel.setText(text);
				buttonPanel.revalidate();
				buttonPanel.repaint();
			}
		});
	}
}
package com.lennyscustomclues;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

@Slf4j
@PluginDescriptor(
	name = "Lenny's Custom Clues"
)
public class LennysCustomCluesPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private LennysCustomCluesConfig config;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private MainPanel mainPanel;

	@Inject
	private GameStateService gameStateService;

	@Inject
	private CelebrationManager celebrationManager;

	private NavigationButton navButton;

	@Override
	protected void startUp() throws Exception
	{
		log.info("Lenny's Custom Clues started!");

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/util/clue_arrow.png");

		navButton = NavigationButton.builder()
			.tooltip("Lenny's Custom Clues")
			.icon(icon)
			.priority(5)
			.panel(mainPanel)
			.build();

		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Lenny's Custom Clues stopped!");
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		// No chat message on login
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		// Only process player animations
		if (!(event.getActor() instanceof Player))
		{
			return;
		}

		Player player = (Player) event.getActor();

		// Only track local player animations
		if (player != client.getLocalPlayer())
		{
			return;
		}

		int animationId = player.getAnimation();

		// Debug mode: show all animation IDs in chat
		if (config.debug())
		{
			client.addChatMessage(
				ChatMessageType.GAMEMESSAGE,
				"",
				"[LL-debug] Animation ID: " + animationId,
				null
			);
		}

		// Check for digging animation
		if (AnimationTriggers.isTriggerAnimation(animationId))
		{
			log.info("Digging detected with animation ID: {}", animationId);
			gameStateService.captureFromAnimation(animationId);
		}
	}

	@Provides
	LennysCustomCluesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LennysCustomCluesConfig.class);
	}
}
package com.lennyscustomclues;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;

@Singleton
public class MainPanel extends PluginPanel
{
	@Inject
	private LennysCustomCluesPanel normalPanel;

	public MainPanel()
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);
	}

	@Inject
	public void initialize()
	{
		// Initialize child panel
		normalPanel.initialize();

		// Add the normal panel
		add(normalPanel, BorderLayout.CENTER);
	}
}
package com.lennyscustomclues;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LennysCustomCluesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LennysCustomCluesPlugin.class);
		RuneLite.main(args);
	}
}
