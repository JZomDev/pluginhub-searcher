package com.github.Chrisioman.PvMTickCounter;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

@ConfigGroup("PvMTickCounter")
public interface TickCounterConfig extends Config {

        @ConfigItem(
                keyName = "showDamage",
                name = "Show damage",
                description = "Show Individual Damage"
        )
        default boolean showDamage()
        {
                return true;
        }

        @ConfigItem(
                keyName = "damageTitleColor",
                name = "Damage Title Color",
                description = "Damage Title Color"
        )
        default Color damageTitleColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "damageTextColor",
                name = "Damage Text Color",
                description = "Damage Text Color"
        )
        default Color damageTextColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "showMaxHits",
                name = "Show Max Hits",
                description = "Counts Max Hits"
        )
        default boolean showMaxHits()
        {
                return true;
        }

        @ConfigItem(
                keyName = "MHTitleColor",
                name = "Damage Title Color",
                description = "Damage Title Color"
        )
        default Color MHTitleColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "MHTextColor",
                name = "MH Text Color",
                description = "MH Text Color"
        )
        default Color MHTextColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "showDamagePerTick",
                name = "Show Damage Per Combat Tick",
                description = "Calculates Damage Per Combat Tick"
        )
        default boolean showDamagePerTick()
        {
                return false;
        }

        @ConfigItem(
                keyName = "DPTTitleColor",
                name = "DPT Text Color",
                description = "DPT Text Color"
        )
        default Color DPTTitleColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "DPTTextColor",
                name = "DPT Text Color",
                description = "DPT Text Color"
        )
        default Color DPTTextColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "showDamagePerSecond",
                name = "Show Damage Per Second",
                description = "Calculates Damage Per Second"
        )
        default boolean showDPSCalc()
        {
                return false;
        }

        @ConfigItem(
                keyName = "DPSTitleColor",
                name = "DPS Text Color",
                description = "DPS Text Color"
        )
        default Color DPSTitleColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "DPTTextColor",
                name = "DPT Text Color",
                description = "DPS Text Color"
        )
        default Color DPSTextColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "showElapsedTime",
                name = "Elapsed Time",
                description = ""
        )
        default boolean showElapsedTime()
        {
                return false;
        }

        @ConfigItem(
                keyName = "ETTitleColor",
                name = "Elapsed Time Text Color",
                description = ""
        )
        default Color ETTitleColor(){ return Color.WHITE; }

        @ConfigItem(
                keyName = "ETTextColor",
                name = "Elapsed Time Text Color",
                description = ""
        )
        default Color ETTextColor(){ return Color.WHITE; }



        @ConfigItem(
        keyName = "resetInstance",
        name = "Reset on new instances",
        description = "",
        position = 1
)
default boolean instance()
        {
        return true;
        }
@Alpha
@ConfigItem(
        keyName = "selfColor",
        name = "Your color",
        description = "",
        position = 3
)
default Color selfColor()
        {
        return Color.green;
        }
@ConfigItem(
        keyName = "totalEnabled",
        name = "Show total ticks",
        description = "",
        position = 5
)
default boolean totalEnabled()
        {
        return true;
        }
@Alpha
@ConfigItem(
        keyName = "totalColor",
        name = "Total Ticks color",
        description = "",
        position = 6
)
default Color totalColor()
        {
        return Color.RED;
        }
@Alpha
@ConfigItem(
        keyName = "otherColor",
        name = "Other players color",
        description = "",
        position = 4
)
default Color otherColor()
        {
        return Color.white;
        }
@Alpha
@ConfigItem(
        keyName = "titleColor",
        name = "Tick Title color",
        description = "",
        position = 2
)
default Color titleColor()
        {
        return Color.white;
        }
        @ConfigItem(
                keyName = "maxPlayers",
                name = "Max Players Shown",
                description = "Number of players to show in Combat Ticks list (0 = only you)",
                position = 1,
                section = "overlay"
        )
        default int maxPlayers()
        {
                return 10;
        }


}

package com.github.Chrisioman.PvMTickCounter;


import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.LinkedHashMap;

public class TickCounterOverlay extends OverlayPanel
{
    private final TickCounterPlugin plugin;
    private final TickCounterConfig config;
    private final Client client;

    @Inject
    public TickCounterOverlay(TickCounterPlugin plugin, Client client, TickCounterConfig config)
    {
        super(plugin);
        setPosition(OverlayPosition.BOTTOM_RIGHT);
        this.plugin = plugin;
        this.client = client;
        this.config = config;

        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY, "Reset", "PvM Tick Counter"));
    }

    @Override
    public Dimension render(Graphics2D g)
    {
        List<LayoutableRenderableEntity> elems = panelComponent.getChildren();
        elems.clear();

        // Damage
        if (config.showDamage() && plugin.getDamage() > 0)
        {
            elems.add(TitleComponent.builder().text("Damage Dealt").color(config.damageTitleColor()).build());
            elems.add(TitleComponent.builder().text(plugin.getDamage().toString()).color(config.damageTextColor()).build());
        }

        // Max Hits
        if (config.showMaxHits() && plugin.getMH() > 0)
        {
            elems.add(TitleComponent.builder().text("# Max Hits").color(config.MHTitleColor()).build());
            elems.add(TitleComponent.builder().text(plugin.getMH().toString()).color(config.MHTextColor()).build());
        }

        // Damage per Tick
        if (config.showDamagePerTick() && Float.parseFloat(plugin.getDamagePerTick()) > 0.00)
        {
            elems.add(TitleComponent.builder().text("Damage/Combat Tick").color(config.DPTTitleColor()).build());
            elems.add(TitleComponent.builder().text(plugin.getDamagePerTick()).color(config.DPTTextColor()).build());
        }

        // DPS
        if (config.showDPSCalc() && Float.parseFloat(plugin.getDPS()) > 0.00)
        {
            elems.add(TitleComponent.builder().text("Damage/Second").color(config.DPSTitleColor()).build());
            elems.add(TitleComponent.builder().text(plugin.getDPS()).color(config.DPSTextColor()).build());
        }

        // Elapsed Time
        if (config.showElapsedTime() && plugin.getElapsedTime() != null)
        {
            elems.add(TitleComponent.builder().text("Elapsed Time").color(config.ETTitleColor()).build());
            elems.add(TitleComponent.builder().text(plugin.getElapsedTime()).color(config.ETTextColor()).build());
        }

        // Combat ticks per player
        List<Map.Entry<String, Integer>> list = new ArrayList<>(plugin.activity.entrySet());
        list.sort((o1, o2) -> {
            int cmp = -Integer.compare(o1.getValue(), o2.getValue());
            if (cmp == 0)
                cmp = o1.getKey().compareTo(o2.getKey());
            return cmp;
        });

        // Build display map with maxPlayers and only include local player if ticks > 0
        String localName = client.getLocalPlayer() != null ? client.getLocalPlayer().getName() : null;
        Map<String, Integer> displayMap = new LinkedHashMap<>();
        int added = 0;
        for (Map.Entry<String, Integer> e : list)
        {
            if (config.maxPlayers() > 0 && added >= config.maxPlayers())
                break;

            displayMap.put(e.getKey(), e.getValue());
            added++;
        }

        if (localName != null && plugin.activity.getOrDefault(localName, 0) > 0 &&
                !displayMap.containsKey(localName))
        {
            displayMap.put(localName, plugin.activity.get(localName));
        }

        if (!displayMap.isEmpty())
            elems.add(TitleComponent.builder().text("Combat Ticks").color(config.titleColor()).build());

        int total = 0;
        for (Map.Entry<String, Integer> e : displayMap.entrySet())
        {
            total += e.getValue();
            Color leftColor = e.getKey().equals(localName) ? config.selfColor() : config.otherColor();
            Color rightColor = leftColor;
            elems.add(LineComponent.builder()
                    .left(e.getKey())
                    .right(e.getValue().toString())
                    .leftColor(leftColor)
                    .rightColor(rightColor)
                    .build());
        }

        // Total ticks
        if (config.totalEnabled() && !displayMap.isEmpty())
        {
            elems.add(LineComponent.builder()
                    .left("Total")
                    .right(String.valueOf(total))
                    .leftColor(config.totalColor())
                    .rightColor(config.totalColor())
                    .build());
        }

        return super.render(g);
    }
}
package com.github.Chrisioman.PvMTickCounter;


import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.kit.KitType;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@PluginDescriptor(name = "PvM Tick Counter")
public class TickCounterPlugin extends Plugin
{
    @Inject private OverlayManager overlayManager;
    @Inject private TickCounterConfig config;
    @Inject private Client client;
    @Inject private TickCounterOverlay overlay;

    private TickCounterUtil id;
    private int amount = 0;
    private int MHCount = 0;
    private boolean initTime = false;
    private Instant startTime;

    // Activity map
    Map<String, Integer> activity = new HashMap<>();

    // QuickAnimation map for continuous weapons
    Map<Player, QuickAnimation> quickAnims = new HashMap<>();

    boolean instanced = false;
    boolean prevInstance = false;

    @Provides
    TickCounterConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(TickCounterConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        id = new TickCounterUtil();
        id.init();
        overlayManager.add(overlay);
    }

    @Override
    protected void shutDown() throws Exception
    {
        overlayManager.remove(overlay);
        activity.clear();
        quickAnims.clear();
        amount = 0;
        MHCount = 0;
        initTime = false;
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
    {
        Actor actor = hitsplatApplied.getActor();
        if (!(actor instanceof NPC))
            return;

        Hitsplat hitsplat = hitsplatApplied.getHitsplat();
        if (hitsplat.isMine())
        {
            int hit = hitsplat.getAmount();
            amount += hit;
            if (hitsplat.getHitsplatType() == HitsplatID.DAMAGE_MAX_ME ||
                    hitsplat.getHitsplatType() == HitsplatID.DAMAGE_MAX_ME_CYAN ||
                    hitsplat.getHitsplatType() == HitsplatID.DAMAGE_MAX_ME_ORANGE ||
                    hitsplat.getHitsplatType() == HitsplatID.DAMAGE_MAX_ME_YELLOW ||
                    hitsplat.getHitsplatType() == HitsplatID.DAMAGE_MAX_ME_WHITE)
            {
                MHCount++;
            }
        }
    }

    public Integer getDamage() { return amount; }
    public Integer getMH() { return MHCount; }

    public String getDamagePerTick()
    {
        return String.format("%.2f",
                amount / (float) activity.getOrDefault(client.getLocalPlayer().getName(), 1));
    }

    public String getDPS()
    {
        if (startTime == null) return "0";
        long milli = Duration.between(startTime, Instant.now()).toMillis();
        float sec = milli / 1000f;
        float dps = amount / sec;
        return String.format("%.2f", dps);
    }

    public String getElapsedTime()
    {
        if (startTime == null || !initTime) return null;
        long seconds = Duration.between(startTime, Instant.now()).toSeconds();
        long HH = seconds / 3600;
        long MM = (seconds % 3600) / 60;
        long SS = seconds % 60;
        return String.format("%02d:%02d:%02d", HH, MM, SS);
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged e)
    {
        if (!(e.getActor() instanceof Player))
            return;

        Player p = (Player) e.getActor();
        int weapon = -1;
        if (p.getPlayerComposition() != null)
            weapon = p.getPlayerComposition().getEquipmentId(KitType.WEAPON);

        int animation = p.getAnimation();
        int currentTick = client.getTickCount();
        QuickAnimation curQuick = quickAnims.get(p);

        // Determine delta from utility
        int delta = id.getTicks(animation, weapon, p);

        // Start DPS timer for local player
        if (p == client.getLocalPlayer() && !initTime && config.showDPSCalc() && delta > 0)
        {
            initTime = true;
            startTime = Instant.now();
        }
        else if (initTime && !config.showDPSCalc())
        {
            initTime = false;
        }

        // Determine if this is a QuickAnimation weapon
        QuickAnimation newQuick = null;

        // Blowpipe / Blazing Blowpipe / Sailing Blowpipe
        if ((animation == 5061 || animation == 10656 || animation == 13144 || animation == 13145) &&
                (weapon == 12926 || weapon == 28688 || weapon == 31583 || weapon == 31579 || weapon == 31575))
        {
            newQuick = new QuickAnimation(2, animation, weapon, currentTick);
        }
        // Eye of Ayak regular attack
        else if (animation == 12397 && weapon == 31113)
        {
            newQuick = new QuickAnimation(3, animation, weapon, currentTick);
        }
        // Eye of Ayak special attack
        else if (animation == 12394 && weapon == 31113)
        {
            newQuick = new QuickAnimation(5, animation, weapon, currentTick);
        }

        // LOGIC UPDATE: Separate handling to ensure ticks are added immediately for new sequences
        if (newQuick != null)
        {
            // Update map and add initial ticks immediately
            quickAnims.put(p, newQuick);
            String name = p.getName();
            activity.put(name, activity.getOrDefault(name, 0) + newQuick.delta);
        }
        else
        {
            // Standard weapon handling
            if (delta > 0)
            {
                String name = p.getName();
                activity.put(name, activity.getOrDefault(name, 0) + delta);
            }

            // Stop QuickAnimation if animation changes or resets (and we aren't starting a new one)
            if (curQuick != null && (animation != curQuick.animation))
            {
                quickAnims.remove(p);
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick)
    {
        int currentTick = client.getTickCount();

        // Tick QuickAnimations
        for (Map.Entry<Player, QuickAnimation> entry : quickAnims.entrySet())
        {
            QuickAnimation q = entry.getValue();
            // Only apply if enough ticks have passed
            if (currentTick >= q.eligibleAt())
            {
                String name = entry.getKey().getName();
                activity.put(name, activity.getOrDefault(name, 0) + q.delta);
                // FIX: Add delta to lastTick instead of setting to currentTick.
                // This keeps the rhythm perfect even though we check 1 tick late.
                q.lastTick += q.delta;
            }
        }

        prevInstance = instanced;
        instanced = client.isInInstancedRegion();
        if (!prevInstance && instanced && config.instance())
        {
            activity.clear();
            quickAnims.clear();
            amount = 0;
            MHCount = 0;
            initTime = false;
        }
    }

    @Subscribe
    public void onOverlayMenuClicked(OverlayMenuClicked event)
    {
        if (event.getEntry().getMenuAction() == MenuAction.RUNELITE_OVERLAY &&
                event.getEntry().getTarget().equals("PvM Tick Counter") &&
                event.getEntry().getOption().equals("Reset"))
        {
            activity.clear();
            quickAnims.clear();
            amount = 0;
            MHCount = 0;
            initTime = false;
        }
    }

    // QuickAnimation class inside plugin
    private static class QuickAnimation
    {
        private final int delta;
        private final int animation;
        private final int weapon;
        private int lastTick;

        QuickAnimation(int delta, int animation, int weapon, int lastTick)
        {
            this.delta = delta;
            this.animation = animation;
            this.weapon = weapon;
            this.lastTick = lastTick;
        }

        int eligibleAt()
        {
            // FIX: Add +1 tick buffer.
            // This ensures we don't count the next attack if you click off exactly as it was due.
            return lastTick + delta + 1;
        }
    }
}




package com.github.Chrisioman.PvMTickCounter;



import net.runelite.api.Player;
import java.util.HashMap;

public class TickCounterUtil
{
    HashMap<Integer, Integer> aniTM;

    public void init()
    {
        aniTM = new HashMap<>();

        aniTM.put(7855, -1); // Mixed ticks - surge (5) / harm orb (4)
        aniTM.put(426, -1); // bow shoot
        aniTM.put(390, -1); // Generic Slash (4) + swift blade (3) + Osmumten's Fang (5)
        aniTM.put(8288, -1); // dhl Stab (4) + swift blade (3)
        aniTM.put(393, -1); // Staff bash (5) + Claw Scratch (4)
        aniTM.put(400, -1); // Pickaxe smash (5) + Inquisitor's Mace Stab (4)
        aniTM.put(401, -1); // dwh bop (6) + Ham Joint (3) + (axe + pickaxe) (5)
        aniTM.put(428, -1); // Chally swipe + Zamorakian Hasta Swipe
        aniTM.put(440, -1); // Chally jab
        aniTM.put(7045, -1); // Sara Sword + Godsword
        aniTM.put(7054, -1); // Sara Sword + Godsword
        aniTM.put(1378, -1); // Voidwaker special and ??
        aniTM.put(1711, -1); // Zammy Spear + Blue Moon
        aniTM.put(8145, -1); // Rapier + Belle's Folly

        aniTM.put(7617, 2); // rune knife
        aniTM.put(8194, 2); // dragon knife
        aniTM.put(5061, -1); // blowpipe (QuickAnimation handled)
        aniTM.put(7554, 2); // Dart throw

        aniTM.put(2323, 3); // Event RPG
        aniTM.put(7618, 3); // Chinchompa
        aniTM.put(2075, 3); // Karil's CB
        aniTM.put(9964, 3); // Webweaver Spec
        aniTM.put(12397, -1); // Eye of Ayak regular attack (QuickAnimation handled)
        aniTM.put(12394, -1); // Eye of Ayak special attack (QuickAnimation handled)
        aniTM.put(11057, 3); // Eclipse Atlatl

        aniTM.put(376, 4); // dds stab
        aniTM.put(245, 4); // Ursine Mace
        aniTM.put(9963, 4); // Ursine Spec
        aniTM.put(377, 4); // dds slash
        aniTM.put(422, 4); // punch
        aniTM.put(423, 4); // kick
        aniTM.put(381, 4); // Zamorakian Hasta
        aniTM.put(386, 4); // lunge
        aniTM.put(419, 4); // Keris Smash/Zamorakian Hasta Pound
        aniTM.put(1062, 4); // dds spec
        aniTM.put(1067, 4); // claw stab
        aniTM.put(1167, 4); // trident cast
        aniTM.put(1658, 4); // whip
        aniTM.put(2890, 4); // Arclight Special
        aniTM.put(3294, 4); // Abby Dagger Slash
        aniTM.put(3297, 4); // Abby Dagger Poke
        aniTM.put(3298, 4); // Bludgeon Attack
        aniTM.put(3299, 4); // Bludgeon Spec
        aniTM.put(3300, 4); // Abby Dagger Spec
        aniTM.put(7514, 4); // Claw Spec
        aniTM.put(7515, 4); // Dragon Sword Spec
        aniTM.put(8289, 4); // Dhl Slash
        aniTM.put(8290, 4); // Dhl Crush
        aniTM.put(4503, 4); // Inquisitor's Mace Crush
        aniTM.put(10501, 4); // Warped Sceptre
        aniTM.put(10989, 4); // Dual Macuahuitl
        aniTM.put(11275, 4); // Voidwaker Spec
        aniTM.put(1132, 4); // Sara Sword Spec
        aniTM.put(11133, 4); // Scorching Bow Spec

        aniTM.put(395, 5); // Axe
        aniTM.put(708, 5); // Iban's Blast
        aniTM.put(2062, 5); // Verac's Flail
        aniTM.put(2068, 5); // Torag's Hammers
        aniTM.put(2080, 5); // Guthans Warspear
        aniTM.put(2081, 5);
        aniTM.put(2082, 5);
        aniTM.put(1162, 5); // strike/bolt spells
        aniTM.put(10091, 5); // Bursting/Blitz spells
        aniTM.put(10092, 5); // Barrage Spell
        aniTM.put(6118, 5); // Osmumten's Fang Special
        aniTM.put(9471, 5); // Osmumten's Fang Stab
        aniTM.put(7552, 5); // Generic Crossbow
        aniTM.put(9493, 5); // Tumeken's Shadow
        aniTM.put(8056, 5); // Scythe Swing
        aniTM.put(8010, 5); // Blisterwood Flail
        aniTM.put(7004, 5); // Leaf-Bladed B-Axe chop
        aniTM.put(3852, 5); // Leaf-Bladed B-Axe Smash
        aniTM.put(9168, 5); // Zaryte Crossbow
        aniTM.put(10171, 5); // Soulreaper Axe Smash
        aniTM.put(10172, 5); // Soulreaper Axe Chop/Hack/Block
        aniTM.put(10173, 5); // Soulreaper Axe Spec
        aniTM.put(1710, 5); // Blue Moon Spear
        aniTM.put(1712, 5); // Blue Moon Spear


        aniTM.put(2078, 6); // Ahrim's Staff
        aniTM.put(5865, 6); // Barrelchest Anchor
        aniTM.put(5870, 6); // Barrelchest Special
        aniTM.put(7055, 6); // godsword autos
        aniTM.put(7511, 6); // dinh's attack
        aniTM.put(7516, 6); // maul attack
        aniTM.put(7555, 6); // ballista attack
        aniTM.put(7638, 6); // zgs spec
        aniTM.put(7640, 6); // sgs spec
        aniTM.put(7642, 6); // bgs spec
        aniTM.put(7643, 6); // bgs spec
        aniTM.put(7644, 6); // ags spec
        aniTM.put(10923, 6); // T. Ralos
        aniTM.put(10914, 6); // T. Ralos Spec
        aniTM.put(11430, 6); // Twinflame Staff

        aniTM.put(1203, 7); // Chally spec
        aniTM.put(2066, 7); // DH axe
        aniTM.put(2067, 7); // DH Axe Smash

        aniTM.put(9544, 12); // Keris of Curruption Spec
    }

    public Integer getTicks(Integer animationID, Integer weaponID, Player p)
    {
        // Blowpipe handled by QuickAnimation
        if(animationID == 5061 || animationID == 10656)
            return 0;

        // Eye of Ayak handled by QuickAnimation
        if(animationID == 12397 || animationID == 12394)
            return 0;

        // Sailing Blowpipe handled by QuickAnimation
        if(animationID == 13144 || animationID == 13145)
            return 0;

        // Default ticks from map
        Integer ticks = aniTM.getOrDefault(animationID, 0);
        if(ticks > 0){
            return ticks;
        }else{
            if(animationID == 7855){
                if(weaponID == 24423)
                    return 4;
                else
                    return 5;
            }
            if(animationID == 426){
                if(weaponID == 25886 || weaponID == 25867 || weaponID == 25869 || weaponID == 25884 || weaponID == 25888 ||
                        weaponID == 25890 || weaponID == 25892 || weaponID == 25894 || weaponID == 25896 || weaponID == 25865 ||
                        weaponID == 23855 || weaponID == 23856 || weaponID == 23857 || weaponID == 23901 || weaponID == 23902 || weaponID == 23903 || weaponID == 29591)
                    return 4;
                else if(weaponID == 20997)
                    return 5;
                else
                    return 3;
            }
            if(animationID == 390){
                if(weaponID == 26219 || weaponID == 27246 || weaponID == 31248)
                    return 5;
                else if(weaponID == 24219)
                    return 3;
                else
                    return 4;
            }
            if(animationID == 8145){
                if(weaponID == 31248)
                    return 5;
                else
                    return 4;
            }
            if(animationID == 8288){
                if(weaponID == 24219)
                    return 3;
                else
                    return 4;
            }
            if(animationID == 393){
                if(weaponID == 13652)
                    return 4;
                else
                    return 5;
            }
            if(animationID == 1711){
                if(weaponID == 28988)
                    return 5;
                else
                    return 4;
            }
            if(animationID == 400){
                if(weaponID == 24417)
                    return 4;
                else
                    return 5;
            }
            if(animationID == 401){
                if(weaponID == 13576) //dwh
                    return 6;
                else if(weaponID == 23360) // ham joint
                    return 3;
                else
                    return 5;
            }
            if(animationID == 440){
                if(weaponID == 23895 || weaponID == 23896 || weaponID == 23897 || weaponID == 23849 || weaponID == 23850 || weaponID == 23851 || weaponID == 11889) //CG Chally
                    return 4;
                else if(weaponID == 29796) // Noxious Halberd
                    return 5;
                else
                    return 7;
            }
            if(animationID == 428){
                if(weaponID == 23895 || weaponID == 23896 || weaponID == 23897 || weaponID == 23849 || weaponID == 23850 || weaponID == 23851) //CG Chally
                    return 4;
                else if(weaponID == 29796) // Noxious Halberd
                    return 5;
                else
                    return 7;
            }
            if(animationID == 1378){
                if(weaponID == 27690) //voidwaker special
                    return 4;
                else
                    return 6;
            }
            if(animationID == 7045){
                if(weaponID == 11838) // Sara Sword
                    return 4;
                else
                    return 6;
            }

            if(animationID == 7054){
                if(weaponID == 11838) // Sara Sword
                    return 4;
                else
                    return 6;
            }
        }

        return 0;
    }
}
package com.example;

import com.github.Chrisioman.PvMTickCounter.TickCounterPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(TickCounterPlugin.class);
		RuneLite.main(args);
	}
}
