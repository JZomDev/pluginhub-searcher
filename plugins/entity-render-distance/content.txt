package com.entityrenderdistance;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.Varbits;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class EntityRenderDistanceMinimapOverlay extends Overlay
{
    private final Client client;
    private final EntityRenderDistanceConfig config;

    // Updated to use 16 tiles to match the world overlay.
    private static final int TILE_RADIUS = 16;

    @Inject
    public EntityRenderDistanceMinimapOverlay(Client client, EntityRenderDistanceConfig config)
    {
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGH);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Check if the minimap overlay is enabled, and if the client is ready.
        if (!config.enableMinimapBox() || EntityRenderDistanceUtils.isClientNotReady(client))
        {
            return null;
        }

        Widget minimapWidget = getMinimapWidget();
        if (minimapWidget == null || minimapWidget.isHidden())
        {
            return null;
        }

        Rectangle bounds = minimapWidget.getBounds();
        int widgetCenterX = bounds.x + bounds.width / 2;
        int widgetCenterY = bounds.y + bounds.height / 2;

        double zoom = client.getMinimapZoom();
        if (zoom <= 0)
        {
            zoom = 3.0;
        }
        // Do not render box if zoom exceeds 5.00.
        if (zoom > 5.00)
        {
            return null;
        }

        double scale = (bounds.width / 48.0) * (zoom / 3.0);

        WorldPoint centerWP = client.getLocalPlayer().getWorldLocation();
        int plane = centerWP.getPlane();

        int minX = centerWP.getX() - TILE_RADIUS;
        int maxX = centerWP.getX() + TILE_RADIUS;
        int minY = centerWP.getY() - TILE_RADIUS;
        int maxY = centerWP.getY() + TILE_RADIUS;

        // Use the utility method for wilderness-checking
        if (config.onlyInWilderness() && EntityRenderDistanceUtils.noTileInWilderness(minX, maxX, minY, maxY, plane, centerWP))
        {
            return null;
        }

        LocalPoint playerLocal = client.getLocalPlayer().getLocalLocation();
        java.awt.Point centerCanvas;
        {
            Point apiPt = Perspective.localToMinimap(client, playerLocal);
            centerCanvas = (apiPt != null)
                    ? new java.awt.Point(apiPt.getX(), apiPt.getY())
                    : new java.awt.Point(widgetCenterX, widgetCenterY);
        }

        // Sample points along each edge.
        List<java.awt.Point> topPoints = new ArrayList<>();
        List<java.awt.Point> rightPoints = new ArrayList<>();
        List<java.awt.Point> bottomPoints = new ArrayList<>();
        List<java.awt.Point> leftPoints = new ArrayList<>();

        for (int x = minX; x <= maxX; x++)
        {
            WorldPoint wp = new WorldPoint(x, maxY, plane);
            java.awt.Point p = convertWorldPointToCanvas(wp, centerWP, centerCanvas, bounds, scale, zoom);
            if (p != null)
                topPoints.add(p);
        }
        for (int y = maxY - 1; y >= minY; y--)
        {
            WorldPoint wp = new WorldPoint(maxX, y, plane);
            java.awt.Point p = convertWorldPointToCanvas(wp, centerWP, centerCanvas, bounds, scale, zoom);
            if (p != null)
                rightPoints.add(p);
        }
        for (int x = maxX - 1; x >= minX; x--)
        {
            WorldPoint wp = new WorldPoint(x, minY, plane);
            java.awt.Point p = convertWorldPointToCanvas(wp, centerWP, centerCanvas, bounds, scale, zoom);
            if (p != null)
                bottomPoints.add(p);
        }
        for (int y = minY + 1; y < maxY; y++)
        {
            WorldPoint wp = new WorldPoint(minX, y, plane);
            java.awt.Point p = convertWorldPointToCanvas(wp, centerWP, centerCanvas, bounds, scale, zoom);
            if (p != null)
                leftPoints.add(p);
        }

        Shape oldClip = graphics.getClip();
        graphics.setClip(bounds);
        graphics.setColor(config.minimapBorderColour());

        // Rendering modes:
        // Mode A: When zoom <= 3.50, draw a closed polygon connecting all sampled points.
        if (zoom <= 3.50)
        {
            List<java.awt.Point> allPoints = new ArrayList<>();
            allPoints.addAll(topPoints);
            allPoints.addAll(rightPoints);
            allPoints.addAll(bottomPoints);
            allPoints.addAll(leftPoints);
            if (allPoints.size() >= 2)
            {
                for (int i = 0; i < allPoints.size() - 1; i++)
                {
                    java.awt.Point start = allPoints.get(i);
                    java.awt.Point end = allPoints.get(i + 1);
                    graphics.drawLine(start.x, start.y, end.x, end.y);
                }
                java.awt.Point first = allPoints.get(0);
                java.awt.Point last = allPoints.get(allPoints.size() - 1);
                graphics.drawLine(last.x, last.y, first.x, first.y);
            }
        }
        // Mode B: For zoom between 3.50 and 5.00: draw each side as a single line
        // (using the first and last sample point for that edge).
        else // (3.50 < zoom <= 5.00)
        {
            if (topPoints.size() >= 2)
            {
                java.awt.Point start = topPoints.get(0);
                java.awt.Point end = topPoints.get(topPoints.size() - 1);
                graphics.drawLine(start.x, start.y, end.x, end.y);
            }
            if (rightPoints.size() >= 2)
            {
                java.awt.Point start = rightPoints.get(0);
                java.awt.Point end = rightPoints.get(rightPoints.size() - 1);
                graphics.drawLine(start.x, start.y, end.x, end.y);
            }
            if (bottomPoints.size() >= 2)
            {
                java.awt.Point start = bottomPoints.get(0);
                java.awt.Point end = bottomPoints.get(bottomPoints.size() - 1);
                graphics.drawLine(start.x, start.y, end.x, end.y);
            }
            if (leftPoints.size() >= 2)
            {
                java.awt.Point start = leftPoints.get(0);
                java.awt.Point end = leftPoints.get(leftPoints.size() - 1);
                graphics.drawLine(start.x, start.y, end.x, end.y);
            }
        }

        graphics.setClip(oldClip);
        return null;
    }

    /**
     * Converts a given world point to a canvas point on the minimap.
     * We assume players are mostly using zooms above 3.50, so if the built-in conversion is available,
     * use that directly. Only if zoom is 3.50 or below, do we apply a fallback estimation.
     */
    private java.awt.Point convertWorldPointToCanvas(WorldPoint wp, WorldPoint centerWP,
                                                     java.awt.Point centerCanvas, Rectangle bounds,
                                                     double scale, double zoom)
    {
        LocalPoint lp = LocalPoint.fromWorld(client, wp);
        if (lp != null)
        {
            Point apiPt = Perspective.localToMinimap(client, lp);
            if (apiPt != null)
            {
                // For zoom above 3.50, simply use built-in conversion.
                return new java.awt.Point(apiPt.getX(), apiPt.getY());
            }
        }

        // Fallback estimation for zoom 3.50 or below.
        if (zoom <= 3.50)
        {
            int dx = wp.getX() - centerWP.getX();
            int dy = wp.getY() - centerWP.getY();
            int estimatedX = centerCanvas.x + (int)(dx * scale);
            int estimatedY = centerCanvas.y - (int)(dy * scale);
            estimatedX = clamp(estimatedX, bounds.x, bounds.x + bounds.width);
            estimatedY = clamp(estimatedY, bounds.y, bounds.y + bounds.height);
            return new java.awt.Point(estimatedX, estimatedY);
        }

        // For zooms above 3.50, if built-in breakdown occurs (unlikely), we simply return null.
        return null;
    }

    private int clamp(int value, int min, int max)
    {
        return Math.max(min, Math.min(value, max));
    }

    private Widget getMinimapWidget()
    {
        if (client.isResized())
        {
            if (client.getVarbitValue(Varbits.SIDE_PANELS) == 1)
            {
                return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_MINIMAP_DRAW_AREA);
            }
            else
            {
                return client.getWidget(ComponentID.RESIZABLE_VIEWPORT_MINIMAP_DRAW_AREA);
            }
        }
        return client.getWidget(ComponentID.FIXED_VIEWPORT_MINIMAP_DRAW_AREA);
    }
}

package com.entityrenderdistance;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;

public class EntityRenderDistanceUtils
{
    /**
     * Returns true if the given world point is in the wilderness.
     * The wilderness area is defined by the rectangle (2941, 3520) to (3392, 3968),
     * with an additional constraint on the x-coordinate based on the y-coordinate.
     */
    public static boolean isInWilderness(WorldPoint wp)
    {
        // Check overall wilderness boundaries.
        if (wp.getX() < 2941 || wp.getX() > 3392 || wp.getY() < 3520 || wp.getY() > 3968)
        {
            return false;
        }

        // Calculate the wilderness level based on the Y-coordinate.
        int level = (wp.getY() - 3520) / 8 + 1;

        // The point is considered to be in the wilderness if its X-coordinate meets the minimum required
        // for the given wilderness level.
        return wp.getX() >= 2941 + (level - 1) * 8;
    }

    /**
     * Returns true if any of the defined bounding tiles (corners or the player's current point)
     * is in the wilderness.
     *
     * @param minX the minimum x coordinate of the box
     * @param maxX the maximum x coordinate of the box
     * @param minY the minimum y coordinate of the box
     * @param maxY the maximum y coordinate of the box
     * @param plane the plane (or level) on which the world point resides
     * @param playerPoint the player's current world location
     */
    public static boolean noTileInWilderness(int minX, int maxX, int minY, int maxY, int plane, WorldPoint playerPoint)
    {
        // Check the player's current point first.
        if (isInWilderness(playerPoint))
        {
            return false;
        }

        // Create the four corner points.
        WorldPoint nw = new WorldPoint(minX, maxY, plane);
        WorldPoint ne = new WorldPoint(maxX, maxY, plane);
        WorldPoint se = new WorldPoint(maxX, minY, plane);
        WorldPoint sw = new WorldPoint(minX, minY, plane);

        // Return true if none of these are in the wilderness.
        return !(isInWilderness(nw) || isInWilderness(ne) || isInWilderness(se) || isInWilderness(sw));
    }

    /**
     * Checks if the client is in a valid state for rendering overlays.
     * Returns true if the game state is LOGGED_IN and the local player is not null.
     */
    public static boolean isClientNotReady(Client client)
    {
        return client.getGameState() != GameState.LOGGED_IN || client.getLocalPlayer() == null;
    }
}

package com.entityrenderdistance;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class EntityRenderDistanceOverlay extends Overlay
{
    private final Client client;
    private final EntityRenderDistanceConfig config;

    // Render distance in tiles (draws a box covering 2*RADIUS + 1 tiles on each side)
    private static final int RADIUS = 16;
    // One tile in local coordinates is 128 units; half a tile = 64 units.
    private static final int HALF_TILE = 64;

    @Inject
    public EntityRenderDistanceOverlay(Client client, EntityRenderDistanceConfig config)
    {
        this.client = client;
        this.config = config;
        setPosition(OverlayPosition.DYNAMIC);
        // setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Check if the world overlay is enabled, and if the client is ready.
        if (!config.enableOverlayBox() || EntityRenderDistanceUtils.isClientNotReady(client))
        {
            return null;
        }

        Player localPlayer = client.getLocalPlayer();
        WorldPoint worldLocation = localPlayer.getWorldLocation();
        int plane = worldLocation.getPlane();
        int centerX = worldLocation.getX();
        int centerY = worldLocation.getY();

        int minX = centerX - RADIUS;
        int maxX = centerX + RADIUS;
        int minY = centerY - RADIUS;
        int maxY = centerY + RADIUS;

        // Use the utility method for wilderness detection.
        if (config.onlyInWilderness() && EntityRenderDistanceUtils.noTileInWilderness(minX, maxX, minY, maxY, plane, worldLocation))
        {
            return null;
        }

        List<java.awt.Point> canvasPoints = new ArrayList<>();

        for (int x = minX; x <= maxX; x++)
        {
            WorldPoint wp = new WorldPoint(x, maxY, plane);
            LocalPoint lp = LocalPoint.fromWorld(client, wp);
            if (lp != null)
            {
                LocalPoint adjusted = new LocalPoint(lp.getX(), lp.getY() + HALF_TILE);
                Point rPoint = Perspective.localToCanvas(client, adjusted, 0);
                if (rPoint != null)
                    canvasPoints.add(new java.awt.Point(rPoint.getX(), rPoint.getY()));
            }
        }

        for (int y = maxY - 1; y >= minY; y--)
        {
            WorldPoint wp = new WorldPoint(maxX, y, plane);
            LocalPoint lp = LocalPoint.fromWorld(client, wp);
            if (lp != null)
            {
                LocalPoint adjusted = new LocalPoint(lp.getX() + HALF_TILE, lp.getY());
                Point rPoint = Perspective.localToCanvas(client, adjusted, 0);
                if (rPoint != null)
                    canvasPoints.add(new java.awt.Point(rPoint.getX(), rPoint.getY()));
            }
        }

        for (int x = maxX - 1; x >= minX; x--)
        {
            WorldPoint wp = new WorldPoint(x, minY, plane);
            LocalPoint lp = LocalPoint.fromWorld(client, wp);
            if (lp != null)
            {
                LocalPoint adjusted = new LocalPoint(lp.getX(), lp.getY() - HALF_TILE);
                Point rPoint = Perspective.localToCanvas(client, adjusted, 0);
                if (rPoint != null)
                    canvasPoints.add(new java.awt.Point(rPoint.getX(), rPoint.getY()));
            }
        }

        for (int y = minY + 1; y < maxY; y++)
        {
            WorldPoint wp = new WorldPoint(minX, y, plane);
            LocalPoint lp = LocalPoint.fromWorld(client, wp);
            if (lp != null)
            {
                LocalPoint adjusted = new LocalPoint(lp.getX() - HALF_TILE, lp.getY());
                Point rPoint = Perspective.localToCanvas(client, adjusted, 0);
                if (rPoint != null)
                    canvasPoints.add(new java.awt.Point(rPoint.getX(), rPoint.getY()));
            }
        }

        if (canvasPoints.size() < 3)
        {
            return null;
        }

        Polygon boundary = new Polygon();
        for (java.awt.Point p : canvasPoints)
        {
            boundary.addPoint(p.x, p.y);
        }

        graphics.setColor(config.overlayBorderColour());
        graphics.draw(boundary);

        return null;
    }
}

package com.entityrenderdistance;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("entityrenderdistance")
public interface EntityRenderDistanceConfig extends Config
{
	// The ungrouped wilderness setting appears on its own.
	@ConfigItem(
			keyName = "onlyInWilderness",
			name = "Only show in Wilderness",
			description = "Only display overlays while in, or near, the wilderness.",
			position = 0
	)
	default boolean onlyInWilderness()
	{
		return false;
	}

	// Overlay (world) box settings group.
	@ConfigSection(
			name = "Overlay Box",
			description = "Settings for the world overlay box",
			position = 1
	)
	String overlayBoxSection = "overlayBoxSection";

	@ConfigItem(
			keyName = "enableOverlayBox",
			name = "Enable overlay box",
			description = "Enable the main world overlay box",
			section = overlayBoxSection,
			position = 0
	)
	default boolean enableOverlayBox()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
			keyName = "overlayBorderColour",
			name = "Border colour",
			description = "The border colour of the overlay box drawn around the player",
			section = overlayBoxSection,
			position = 1
	)
	default Color overlayBorderColour()
	{
		return new Color(255, 173, 0, 150);
	}

	// Minimap box settings group.
	@ConfigSection(
			name = "Minimap Box",
			description = "Settings for the minimap box",
			position = 2
	)
	String minimapBoxSection = "minimapBoxSection";

	@ConfigItem(
			keyName = "enableMinimapBox",
			name = "Enable minimap box",
			description = "Enable the minimap overlay box",
			section = minimapBoxSection,
			position = 0
	)
	default boolean enableMinimapBox()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
			keyName = "minimapBorderColour",
			name = "Border colour",
			description = "The border colour of the overlay drawn on the minimap",
			section = minimapBoxSection,
			position = 1
	)
	default Color minimapBorderColour()
	{
		return new Color(255, 173, 0, 150);
	}
}

package com.entityrenderdistance;

import com.google.inject.Provides;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;

@PluginDescriptor(
		name = "Entity Render Distance",
		description = "Draws boxes around the player to mark the maximum entity render distance",
		enabledByDefault = true
)
public class EntityRenderDistancePlugin extends Plugin
{

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private EntityRenderDistanceOverlay overlay;

	@Inject
	private EntityRenderDistanceMinimapOverlay minimapOverlay;

	@Override
	protected void startUp()
	{
		overlayManager.add(overlay); // world overlay
		overlayManager.add(minimapOverlay);
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(overlay);
		overlayManager.remove(minimapOverlay);
	}

	@Provides
	EntityRenderDistanceConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(EntityRenderDistanceConfig.class);
	}
}

package com.entityrenderdistance;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class EntityRenderDistance
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(EntityRenderDistancePlugin.class);
		RuneLite.main(args);
	}
}
