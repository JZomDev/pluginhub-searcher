package com.fogofwar.util;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.gameval.VarbitID;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class ClientState {
    private final Client client;
    @Inject
    public ClientState(Client client) { this.client = client; }
    public boolean isNotInWilderness() { return client.getVarbitValue(VarbitID.INSIDE_WILDERNESS) != 1; }
    public boolean isClientNotReady() { return client.getGameState() != GameState.LOGGED_IN || client.getLocalPlayer() == null; }
}
package com.fogofwar.util;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;

public final class MinimapUtil {
    private static final int SIDE_PANELS_ID = 4607;
    private static final int FIXED_PARENT_ID = 548;
    private static final int FIXED_CHILD_ID = 21;
    private static final int STRETCH_PARENT_ID = 161;
    private static final int STRETCH_CHILD_ID = 30;
    private static final int PRE_EOC_PARENT_ID = 164;
    private static final int PRE_EOC_CHILD_ID = 30;
    private MinimapUtil() {}
    public static Widget getMinimapWidget(Client client) {
        if (client.isResized()) {
            if (client.getVarbitValue(SIDE_PANELS_ID) == 1) {
                return client.getWidget(PRE_EOC_PARENT_ID, PRE_EOC_CHILD_ID);
            }
            return client.getWidget(STRETCH_PARENT_ID, STRETCH_CHILD_ID);
        }
        return client.getWidget(FIXED_PARENT_ID, FIXED_CHILD_ID);
    }
}
package com.fogofwar.util;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class AreaManager {
    private final Client client;
    private final EventBus eventBus;
    private final List<ExcludedArea> excludedAreas = new ArrayList<>();
    @Getter
    private boolean playerInExcludedArea = false;
    @Inject
    public AreaManager(Client client, EventBus eventBus) {
        this.client = client;
        this.eventBus = eventBus;
        excludedAreas.add(new ExcludedArea(2367, 5053, 2432, 5119, 0));         // TzHaar Fight Cave
        excludedAreas.add(new ExcludedArea(2256, 5328, 2286, 5359, 0));         // Inferno
        excludedAreas.add(new ExcludedArea(3500, 5100, 4000, 5440, 0, 1));      // Tombs of Amascut
        excludedAreas.add(new ExcludedArea(3136, 4216, 3366, 4474, 0, 1, 2));   // Theatre of Blood
        excludedAreas.add(new ExcludedArea(2215, 5935, 2325, 6035, 0, 1, 2));   // Hallowed Sepulchre Floor 1
        excludedAreas.add(new ExcludedArea(2475, 5935, 2585, 6035, 0, 1, 2));   // Hallowed Sepulchre Floor 2
        excludedAreas.add(new ExcludedArea(2225, 5795, 2575, 5915, 0, 1, 2));   // Hallowed Sepulchre Floors 3-5
        excludedAreas.add(new ExcludedArea(3150, 5690, 3380, 5770, 0, 1, 2));   // Chambers of Xeric
        excludedAreas.add(new ExcludedArea(3250, 5120, 3370, 5700, 0, 1, 2));   // Chambers of Xeric
    }
    public void start() {
        eventBus.register(this);
        if (client.getGameState() == GameState.LOGGED_IN) {
            checkArea();
        }
    }
    public void stop() {
        eventBus.unregister(this);
    }
    @Subscribe
    @SuppressWarnings("unused")
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGED_IN) {
            checkArea();
        } else if (event.getGameState() == GameState.LOADING) {
            playerInExcludedArea = false;
        }
    }
    private void checkArea() {
        if (client.getLocalPlayer() == null) {
            playerInExcludedArea = false;
            return;
        }
        WorldPoint playerPoint = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
        for (ExcludedArea area : excludedAreas) {
            if (area.contains(playerPoint)) {
                playerInExcludedArea = true;
                return;
            }
        }
        playerInExcludedArea = false;
    }
}
package com.fogofwar.util;

import com.google.common.collect.ImmutableSet;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;

import java.util.Set;

@Value
public class ExcludedArea {
    int minX;
    int minY;
    int maxX;
    int maxY;
    Set<Integer> planes;

    public ExcludedArea(int minX, int minY, int maxX, int maxY, Integer... planes) {
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
        this.planes = ImmutableSet.copyOf(planes);
    }

    public boolean contains(WorldPoint point) {
        return this.planes.contains(point.getPlane()) &&
                point.getX() >= minX && point.getX() <= maxX &&
                point.getY() >= minY && point.getY() <= maxY;
    }
}
package com.fogofwar.util;

import com.fogofwar.FogOfWarConfig;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class DynamicRenderDistance {
    private final Client client;
    private final FogOfWarConfig config;
    private final EventBus eventBus;
    @Getter
    private int currentRenderDistance;
    @Inject
    public DynamicRenderDistance(Client client, FogOfWarConfig config, EventBus eventBus) {
        this.client = client;
        this.config = config;
        this.eventBus = eventBus;
        this.currentRenderDistance = config.renderDistanceRadius();
    }
    public void start() {
        eventBus.register(this);
    }
    public void stop() {
        eventBus.unregister(this);
    }
    @Subscribe
    @SuppressWarnings("unused")
    public void onGameTick(GameTick event) {
        if (client.getGameState() != GameState.LOGGED_IN || client.getLocalPlayer() == null) {
            this.currentRenderDistance = config.renderDistanceRadius();
            return;
        }
        if (!config.enableDynamicRenderDistance()) {
            this.currentRenderDistance = config.renderDistanceRadius();
            return;
        }
        WorldView worldView = client.getTopLevelWorldView();
        List<Player> players = new ArrayList<>();
        for (Player p : worldView.players()) {
            if (p != null) {
                players.add(p);
            }
        }
        if (players.size() >= config.dynamicRenderDistancePlayerThreshold()) {
            int maxDistTiles = 0;
            WorldPoint playerWorldPoint = client.getLocalPlayer().getWorldLocation();
            int playerTileX = playerWorldPoint.getX();
            int playerTileY = playerWorldPoint.getY();
            for (Player p : players) {
                WorldPoint wp = p.getWorldLocation();
                if (wp == null) continue;
                int distTiles = Math.max(Math.abs(wp.getX() - playerTileX), Math.abs(wp.getY() - playerTileY));
                if (distTiles > maxDistTiles) {
                    maxDistTiles = distTiles;
                    if (maxDistTiles >= config.renderDistanceRadius()) {
                        maxDistTiles = config.renderDistanceRadius();
                        break;
                    }
                }
            }
            this.currentRenderDistance = maxDistTiles;
        } else {
            this.currentRenderDistance = config.renderDistanceRadius();
        }
    }
}
package com.fogofwar;

import com.fogofwar.box.FogOfWarMinimapOverlay;
import com.fogofwar.box.FogOfWarWorldOverlay;
import com.fogofwar.debug.PlaneDisplayOverlay;
import com.fogofwar.fade.FadingPlayerManager;
import com.fogofwar.util.AreaManager;
import com.fogofwar.util.DynamicRenderDistance;
import com.google.inject.Provides;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
@PluginDescriptor(
        name = "Fog of War",
        description = "Applies a fog of war effect outside of the player render distance, in both the world and on the minimap.",
        configName = "EntityRenderDistancePlugin"
)
public class FogOfWarPlugin extends Plugin {
    @Inject
    @SuppressWarnings("unused")
    private OverlayManager overlayManager;
    @Inject
    @SuppressWarnings("unused")
    private FogOfWarWorldOverlay worldOverlay;
    @Inject
    @SuppressWarnings("unused")
    private FogOfWarMinimapOverlay minimapOverlay;
    @Inject
    @SuppressWarnings("unused")
    private FadingPlayerManager fadingPlayerManager;
    @Inject
    @SuppressWarnings("unused")
    private DynamicRenderDistance dynamicRenderDistance;
    @Inject
    @SuppressWarnings("unused")
    private AreaManager areaManager;
    @Inject
    @SuppressWarnings("unused")
    private PlaneDisplayOverlay planeDisplayOverlay;
    @Override
    protected void startUp() {
        overlayManager.add(worldOverlay);
        overlayManager.add(minimapOverlay);
        overlayManager.add(planeDisplayOverlay);
        fadingPlayerManager.start();
        dynamicRenderDistance.start();
        areaManager.start();
    }
    @Override
    protected void shutDown() {
        overlayManager.remove(worldOverlay);
        overlayManager.remove(minimapOverlay);
        overlayManager.remove(planeDisplayOverlay);
        fadingPlayerManager.stop();
        dynamicRenderDistance.stop();
        areaManager.stop();
    }
    @Provides
    @SuppressWarnings("unused")
    FogOfWarConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(FogOfWarConfig.class);
    }
}
package com.fogofwar.debug;

import com.fogofwar.FogOfWarConfig;
import com.fogofwar.util.ClientState;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import javax.inject.Inject;
import java.awt.*;

public class PlaneDisplayOverlay extends OverlayPanel {
    private final Client client;
    private final FogOfWarConfig config;
    private final ClientState clientState;
    @Inject
    public PlaneDisplayOverlay(Client client, FogOfWarConfig config, ClientState clientState) {
        this.client = client;
        this.config = config;
        this.clientState = clientState;
        setPosition(OverlayPosition.TOP_LEFT);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.showPlaneDisplay() || clientState.isClientNotReady()) {
            return null;
        }
        int plane = client.getLocalPlayer().getWorldLocation().getPlane();
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Current plane:")
                .right(String.valueOf(plane))
                .build());
        return super.render(graphics);
    }
}
package com.fogofwar;

import net.runelite.client.config.*;

import java.awt.*;
@ConfigGroup("entityrenderdistance")
public interface FogOfWarConfig extends Config {
    @ConfigItem(
            keyName = "onlyInWilderness",
            name = "Only show in Wilderness",
            description = "Only display overlays while in the Wilderness.",
            position = 0
    )
    default boolean onlyInWilderness() { return false; }
    @ConfigSection(
            name = "World",
            description = "Settings for the world overlay",
            position = 2
    )
    String worldSection = "worldSection";
    @ConfigItem(
            keyName = "showWorldFog",
            name = "Fog of war",
            description = "Shades the area outside of the render distance with a fog effect.",
            section = worldSection,
            position = 0
    )
    default boolean showWorldFog() { return true; }
    @Alpha
    @ConfigItem(
            keyName = "worldFogColour",
            name = "Fog colour",
            description = "The colour of the world's fog of war effect.",
            section = worldSection,
            position = 1
    )
    default Color worldFogColour() { return new Color(0, 0, 0, 125); }
    @ConfigItem(
            keyName = "excludeEntities",
            name = "Exclude Entities from Fog",
            description = "Prevents the fog from drawing on top of players and NPCs. May impact performance in crowded areas.",
            section = worldSection,
            position = 2
    )
    default boolean excludeEntities() { return true; }
    @ConfigItem(
            keyName = "showWorldBorder",
            name = "Show border",
            description = "Shows the render distance border in the world view.",
            section = worldSection,
            position = 3
    )
    default boolean showWorldBorder() { return false; }
    @Alpha
    @ConfigItem(
            keyName = "worldBorderColour",
            name = "Border colour",
            description = "The colour of the world render distance border.",
            section = worldSection,
            position = 4
    )
    default Color worldBorderColour() { return new Color(0, 0, 0, 125); }
    @Range(min = 1, max = 16)
    @ConfigItem(
            keyName = "worldBorderThickness",
            name = "Border thickness",
            description = "The thickness of the world render distance border.",
            section = worldSection,
            position = 5
    )
    default int worldBorderThickness() { return 1; }
    @ConfigSection(
            name = "Minimap",
            description = "Settings for the minimap overlay",
            position = 3
    )
    String minimapSection = "minimapSection";
    @ConfigItem(
            keyName = "showMinimapFog",
            name = "Fog of war",
            description = "Shades the area outside the render distance on the minimap with a fog effect.",
            section = minimapSection,
            position = 0
    )
    default boolean showMinimapFog() { return true; }
    @Alpha
    @ConfigItem(
            keyName = "minimapFogColour",
            name = "Fog colour",
            description = "The colour of the minimap's fog of war effect.",
            section = minimapSection,
            position = 1
    )
    default Color minimapFogColour() { return new Color(0, 0, 0, 125); }
    @ConfigItem(
            keyName = "showMinimapBorder",
            name = "Show border",
            description = "Shows the render distance border on the minimap.",
            section = minimapSection,
            position = 2
    )
    default boolean showMinimapBorder() { return false; }
    @Alpha
    @ConfigItem(
            keyName = "minimapBorderColour",
            name = "Border colour",
            description = "The colour of the minimap render distance border.",
            section = minimapSection,
            position = 3
    )
    default Color minimapBorderColour() { return new Color(0, 0, 0, 125); }
    @Range(min = 1, max = 16)
    @ConfigItem(
            keyName = "minimapBorderThickness",
            name = "Border thickness",
            description = "The thickness of the minimap render distance border.",
            section = minimapSection,
            position = 4
    )
    default int minimapBorderThickness() { return 1; }
    @ConfigSection(
            name = "Fading Players",
            description = "Settings for marking players that leave render distance",
            position = 4
    )
    String fadingPlayerSection = "fadingPlayerSection";
    @ConfigItem(
            keyName = "enableFadingPlayers",
            name = "Enable fading player tiles",
            description = "Mark players that leave render distance with a fading marker.",
            section = fadingPlayerSection,
            position = 0
    )
    default boolean enableFadingPlayers() { return false; }
    @ConfigItem(
            keyName = "onlyFadeAtRenderLimit",
            name = "Only fade at the limit",
            description = "Only create a fading marker if the player disappears at the edge of the render distance.",
            section = fadingPlayerSection,
            position = 1
    )
    default boolean onlyFadeAtRenderLimit() { return true; }
    @ConfigItem(
            keyName = "extrapolateMovement",
            name = "Extrapolate movement",
            description = "Fading player markers will continue to move based on their last known velocity.",
            section = fadingPlayerSection,
            position = 2
    )
    default boolean extrapolateMovement() { return true; }
    @ConfigItem(
            keyName = "showFadeNames",
            name = "Label tiles after players",
            description = "Show the player's name on the fading marker in the world view.",
            section = fadingPlayerSection,
            position = 3
    )
    default boolean showFadeNames() { return true; }
    @ConfigItem(
            keyName = "showFadingInWorld",
            name = "Show in world",
            description = "Show fading player markers in the main game view.",
            section = fadingPlayerSection,
            position = 4
    )
    default boolean showFadingInWorld() { return true; }
    @ConfigItem(
            keyName = "showFadingOnMinimap",
            name = "Show on minimap",
            description = "Show fading player markers on the minimap.",
            section = fadingPlayerSection,
            position = 5
    )
    default boolean showFadingOnMinimap() { return true; }
    @Range(min = 1, max = 16)
    @ConfigItem(
            keyName = "fadeDuration",
            name = "Fade duration (ticks)",
            description = "How many game ticks it takes for a marker to completely fade.",
            section = fadingPlayerSection,
            position = 6
    )
    default int fadeDuration() { return 2; }
    @Alpha
    @ConfigItem(
            keyName = "fadeColor",
            name = "Fade marker colour",
            description = "The colour of the fading tile marker.",
            section = fadingPlayerSection,
            position = 7
    )
    default Color fadeColor() { return new Color(255, 0, 0, 150); }
    @ConfigSection(
            name = "Tweaks",
            description = "Advanced settings for experimental features.",
            position = 5,
            closedByDefault = true
    )
    String tweaksSection = "tweaksSection";
    @Range(min = 1, max = 64)
    @ConfigItem(
            keyName = "renderDistanceRadius",
            name = "Maximum render distance",
            description = "Sets the maximum possible render distance the plugin will use (normally 15).<br>Note: this does NOT change the game's render distance. Adjust this only if Jagex changes the render distance in a future game update.",
            section = tweaksSection,
            position = 0
    )
    default int renderDistanceRadius() { return 15; }
    @ConfigItem(
            keyName = "enableDynamicRenderDistance",
            name = "Enable dynamic render distance",
            description = "(Experimental) Automatically scales the render distance based on player count in high-population areas.",
            section = tweaksSection,
            position = 1
    )
    default boolean enableDynamicRenderDistance() { return false; }
    @Range(min = 1, max = 500)
    @ConfigItem(
            keyName = "dynamicRenderDistancePlayerThreshold",
            name = "Player count trigger",
            description = "(Experimental) The number of players needed to trigger the dynamic render distance check.",
            section = tweaksSection,
            position = 2
    )
    default int dynamicRenderDistancePlayerThreshold() { return 100; }
    @ConfigItem(
            keyName = "showPlaneDisplay",
            name = "Show Plane Display",
            description = "Shows the player's current plane in an overlay. Useful for debugging.",
            section = tweaksSection,
            position = 3
    )
    default boolean showPlaneDisplay() { return false; }
}
package com.fogofwar.fade;

import com.fogofwar.FogOfWarConfig;
import com.fogofwar.util.AreaManager;
import com.fogofwar.util.DynamicRenderDistance;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

@Singleton
public class FadingPlayerManager {
    @Inject
    @SuppressWarnings("unused")
    private Client client;
    @Inject
    @SuppressWarnings("unused")
    private FogOfWarConfig config;
    @Inject
    @SuppressWarnings("unused")
    private OverlayManager overlayManager;
    @Inject
    @SuppressWarnings("unused")
    private EventBus eventBus;
    @Inject
    @SuppressWarnings("unused")
    private FadingPlayerOverlay fadingPlayerOverlay;
    @Inject
    @SuppressWarnings("unused")
    private FadingPlayerMinimapOverlay fadingPlayerMinimapOverlay;
    @Inject
    @SuppressWarnings("unused")
    private DynamicRenderDistance dynamicRenderDistance;
    @Inject
    @SuppressWarnings("unused")
    private AreaManager areaManager;
    @Getter
    private final Map<Player, FadingPlayer> fadingPlayers = new HashMap<>();
    private final Map<Player, WorldPoint> lastTickPlayerLocations = new HashMap<>();
    private final Map<Player, WorldPoint> twoTicksAgoPlayerLocations = new HashMap<>();
    public void start() {
        overlayManager.add(fadingPlayerOverlay);
        overlayManager.add(fadingPlayerMinimapOverlay);
        eventBus.register(this);
    }
    public void stop() {
        overlayManager.remove(fadingPlayerOverlay);
        overlayManager.remove(fadingPlayerMinimapOverlay);
        eventBus.unregister(this);
        clearAllTracking();
    }
    @Subscribe
    @SuppressWarnings("unused")
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOADING) clearAllTracking();
    }
    @Subscribe
    @SuppressWarnings("unused")
    public void onGameTick(GameTick event) {
        if (client.getGameState() != GameState.LOGGED_IN) {
            clearAllTracking();
            return;
        }
        if (areaManager.isPlayerInExcludedArea()) {
            if (!fadingPlayers.isEmpty()) {
                clearAllTracking();
            }
            return;
        }
        if (config.enableFadingPlayers()) {
            handleFadingPlayers();
            updatePlayerTracking();
        } else {
            clearAllTracking();
        }
    }
    private void clearAllTracking() {
        fadingPlayers.clear();
        lastTickPlayerLocations.clear();
        twoTicksAgoPlayerLocations.clear();
    }
    private void handleFadingPlayers() {
        fadingPlayers.entrySet().removeIf(entry -> {
            FadingPlayer fp = entry.getValue();
            fp.setTicksSinceDisappeared(fp.getTicksSinceDisappeared() + 1);
            if (fp.getTicksSinceDisappeared() > config.fadeDuration()) return true;
            WorldPoint localPlayerLocation = client.getLocalPlayer().getWorldLocation();
            if (fp.getTicksSinceDisappeared() > 1 && fp.getLastLocation().distanceTo(localPlayerLocation) <= dynamicRenderDistance.getCurrentRenderDistance()) {
                return true;
            }
            if (config.extrapolateMovement()) {
                WorldPoint nextPos = new WorldPoint(
                        fp.getLastLocation().getX() + fp.getVelocity().getX(),
                        fp.getLastLocation().getY() + fp.getVelocity().getY(),
                        fp.getLastLocation().getPlane()
                );
                fp.setLastLocation(nextPos);
            }
            return false;
        });
    }
    private void updatePlayerTracking() {
        Map<Player, WorldPoint> currentPlayerLocations = new HashMap<>();
        Set<String> currentPlayerNames = new HashSet<>();
        for (Player player : client.getTopLevelWorldView().players()) {
            if (player != null && player != client.getLocalPlayer()) {
                currentPlayerLocations.put(player, player.getWorldLocation());
                if (player.getName() != null) {
                    currentPlayerNames.add(player.getName());
                }
            }
        }
        Set<Player> disappearedPlayers = new HashSet<>(lastTickPlayerLocations.keySet());
        disappearedPlayers.removeAll(currentPlayerLocations.keySet());
        WorldPoint currentLocalPlayerLocation = client.getLocalPlayer().getWorldLocation();
        for (Player player : disappearedPlayers) {
            if (fadingPlayers.containsKey(player)) continue;
            WorldPoint lastLocation = lastTickPlayerLocations.get(player);
            if (lastLocation == null) continue;
            WorldPoint twoTicksAgoLocation = twoTicksAgoPlayerLocations.get(player);
            WorldPoint velocity = (twoTicksAgoLocation != null)
                    ? new WorldPoint(lastLocation.getX() - twoTicksAgoLocation.getX(), lastLocation.getY() - twoTicksAgoLocation.getY(), 0)
                    : new WorldPoint(0, 0, 0);
            int renderDistance = dynamicRenderDistance.getCurrentRenderDistance();
            int velocityMagnitude = Math.abs(velocity.getX()) + Math.abs(velocity.getY());
            int distanceFromPlayer = lastLocation.distanceTo(currentLocalPlayerLocation);
            boolean isAtRenderLimit = distanceFromPlayer >= renderDistance - 1;
            boolean isRunningNearLimit = distanceFromPlayer >= renderDistance - 2 && velocityMagnitude >= 2;
            if (config.onlyFadeAtRenderLimit()) {
                if (!isAtRenderLimit && !isRunningNearLimit) {
                    continue;
                }
            }
            WorldPoint initialFadeLocation;
            if (config.extrapolateMovement()) {
                int dx = lastLocation.getX() - currentLocalPlayerLocation.getX();
                int dy = lastLocation.getY() - currentLocalPlayerLocation.getY();
                boolean onXEdge = Math.abs(dx) >= renderDistance - 1;
                boolean onYEdge = Math.abs(dy) >= renderDistance - 1;
                WorldPoint predictedNextLocation = new WorldPoint(lastLocation.getX() + velocity.getX(), lastLocation.getY() + velocity.getY(), lastLocation.getPlane());
                boolean isMovingIntoRenderArea = (onXEdge && dx * velocity.getX() < 0) || (onYEdge && dy * velocity.getY() < 0);
                if (isMovingIntoRenderArea) {
                    int pushX = onXEdge ? Integer.signum(dx) : 0;
                    int pushY = onYEdge ? Integer.signum(dy) : 0;
                    initialFadeLocation = new WorldPoint(predictedNextLocation.getX() + pushX, predictedNextLocation.getY() + pushY, predictedNextLocation.getPlane());
                } else {
                    initialFadeLocation = predictedNextLocation;
                    if (isAtRenderLimit || isRunningNearLimit) {
                        while (initialFadeLocation.distanceTo(currentLocalPlayerLocation) <= renderDistance) {
                            int pushX = 0;
                            int pushY = 0;
                            if (Math.abs(dx) > Math.abs(dy)) {
                                pushX = Integer.signum(dx);
                            } else if (Math.abs(dy) > Math.abs(dx)) {
                                pushY = Integer.signum(dy);
                            } else {
                                pushX = Integer.signum(dx);
                                pushY = Integer.signum(dy);
                            }
                            initialFadeLocation = new WorldPoint(initialFadeLocation.getX() + pushX, initialFadeLocation.getY() + pushY, initialFadeLocation.getPlane());
                        }
                    }
                }
            } else {
                initialFadeLocation = lastLocation;
            }
            FadingPlayer fp = new FadingPlayer(player, velocity);
            fp.setLastLocation(initialFadeLocation);
            fadingPlayers.put(player, fp);
        }
        twoTicksAgoPlayerLocations.clear();
        twoTicksAgoPlayerLocations.putAll(lastTickPlayerLocations);
        lastTickPlayerLocations.clear();
        lastTickPlayerLocations.putAll(currentPlayerLocations);
        if (!fadingPlayers.isEmpty() && !currentPlayerNames.isEmpty()) {
            fadingPlayers.entrySet().removeIf(entry -> {
                Player fadingPlayer = entry.getKey();
                return fadingPlayer.getName() != null && currentPlayerNames.contains(fadingPlayer.getName());
            });
        }
    }
}
package com.fogofwar.fade;

import com.fogofwar.FogOfWarConfig;
import com.fogofwar.util.ClientState;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
public class FadingPlayerOverlay extends Overlay {
    private final Client client;
    private final FogOfWarConfig config;
    private final FadingPlayerManager manager;
    private final ClientState clientState;
    @Inject
    protected FadingPlayerOverlay(Client client, FogOfWarConfig config, FadingPlayerManager manager, ClientState clientState) {
        this.client = client;
        this.config = config;
        this.manager = manager;
        this.clientState = clientState;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_HIGH);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.enableFadingPlayers() || !config.showFadingInWorld() || clientState.isClientNotReady()) return null;
        if (config.onlyInWilderness() && clientState.isNotInWilderness()) return null;
        for (FadingPlayer fadingPlayer : manager.getFadingPlayers().values()) {
            renderFadingPlayer(graphics, fadingPlayer);
        }
        return null;
    }
    private void renderFadingPlayer(Graphics2D graphics, FadingPlayer fadingPlayer) {
        WorldPoint wp = fadingPlayer.getLastLocation();
        WorldView wv = client.getTopLevelWorldView();
        LocalPoint lp = LocalPoint.fromWorld(wv, wp);
        if (lp == null) return;
        Polygon poly = Perspective.getCanvasTilePoly(client, lp);
        if (poly == null) return;
        float fadeDuration = Math.max(1, config.fadeDuration());
        float remainingTicks = fadeDuration - fadingPlayer.getTicksSinceDisappeared();
        float opacity = remainingTicks / fadeDuration;
        if (opacity <= 0) return;
        Color base = config.fadeColor();
        Color color = new Color(
                base.getRed() / 255f,
                base.getGreen() / 255f,
                base.getBlue() / 255f,
                (base.getAlpha() / 255f) * opacity
        );
        graphics.setColor(color);
        graphics.fill(poly);
        if (config.showFadeNames()) {
            String name = fadingPlayer.getPlayer().getName();
            if (name != null) {
                Point textLoc = Perspective.getCanvasTextLocation(client, graphics, lp, name, 0);
                if (textLoc != null) OverlayUtil.renderTextLocation(graphics, textLoc, name, color);
            }
        }
    }
}
package com.fogofwar.fade;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;

@Getter
class FadingPlayer {
    private final Player player;
    @Setter
    private WorldPoint lastLocation;
    private final WorldPoint velocity;
    @Setter
    private int ticksSinceDisappeared = 0;
    FadingPlayer(Player player, WorldPoint velocity) {
        this.player = player;
        this.velocity = velocity;
        this.lastLocation = player.getWorldLocation();
    }
}
package com.fogofwar.fade;

import com.fogofwar.FogOfWarConfig;
import com.fogofwar.util.ClientState;
import com.fogofwar.util.MinimapUtil;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

public class FadingPlayerMinimapOverlay extends Overlay {
    private static final int DOT_SIZE = 4;
    private final Client client;
    private final FogOfWarConfig config;
    private final ClientState clientState;
    private final FadingPlayerManager manager;
    @Inject
    protected FadingPlayerMinimapOverlay(Client client, FogOfWarConfig config, ClientState clientState, FadingPlayerManager manager) {
        this.client = client;
        this.config = config;
        this.clientState = clientState;
        this.manager = manager;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_HIGH);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.enableFadingPlayers() || !config.showFadingOnMinimap() || clientState.isClientNotReady()) return null;
        if (config.onlyInWilderness() && clientState.isNotInWilderness()) return null;
        Widget minimapWidget = MinimapUtil.getMinimapWidget(client);
        if (minimapWidget == null) return null;
        Shape oldClip = graphics.getClip();
        graphics.setClip(minimapWidget.getBounds());
        for (FadingPlayer fadingPlayer : manager.getFadingPlayers().values()) {
            renderFadingPlayer(graphics, fadingPlayer);
        }
        graphics.setClip(oldClip);
        return null;
    }
    private void renderFadingPlayer(Graphics2D graphics, FadingPlayer fadingPlayer) {
        WorldPoint wp = fadingPlayer.getLastLocation();
        WorldView wv = client.getTopLevelWorldView();
        LocalPoint lp = LocalPoint.fromWorld(wv, wp);
        if (lp == null) return;
        Point mp = Perspective.localToMinimap(client, lp);
        if (mp == null) return;
        float fadeDuration = Math.max(1, config.fadeDuration());
        float remainingTicks = fadeDuration - fadingPlayer.getTicksSinceDisappeared();
        float opacity = remainingTicks / fadeDuration;
        Color color = new Color(
                config.fadeColor().getRed() / 255f,
                config.fadeColor().getGreen() / 255f,
                config.fadeColor().getBlue() / 255f,
                opacity
        );
        Color shadedColor = color.darker();
        int x = mp.getX() - DOT_SIZE / 2;
        int y = mp.getY() - DOT_SIZE / 2 + 1;
        graphics.setColor(shadedColor);
        graphics.fillArc(x, y, DOT_SIZE, DOT_SIZE, 180, 180);
        graphics.setColor(color);
        graphics.fillArc(x, y, DOT_SIZE, DOT_SIZE, 0, 180);
    }
}
package com.fogofwar.box;

import com.fogofwar.FogOfWarConfig;
import com.fogofwar.util.AreaManager;
import com.fogofwar.util.ClientState;
import com.fogofwar.util.DynamicRenderDistance;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.util.ArrayList;
import java.util.List;

public class FogOfWarWorldOverlay extends Overlay {
    private final Client client;
    private final FogOfWarConfig config;
    private final ClientState clientState;
    private final DynamicRenderDistance dynamicRenderDistance;
    private final AreaManager areaManager;
    private final List<net.runelite.api.Point> boundaryPoints = new ArrayList<>();
    private final GeneralPath path = new GeneralPath();
    @Inject
    public FogOfWarWorldOverlay(Client client, FogOfWarConfig config, ClientState clientState, DynamicRenderDistance dynamicRenderDistance, AreaManager areaManager) {
        this.client = client;
        this.config = config;
        this.clientState = clientState;
        this.dynamicRenderDistance = dynamicRenderDistance;
        this.areaManager = areaManager;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if (areaManager.isPlayerInExcludedArea() || clientState.isClientNotReady() || (config.onlyInWilderness() && clientState.isNotInWilderness())) {
            return null;
        }
        int radius = dynamicRenderDistance.getCurrentRenderDistance();
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        GeneralPath renderAreaBoundary = createRenderAreaBoundary(playerLocation, radius);
        if (renderAreaBoundary == null) {
            if (config.showWorldFog()) {
                Rectangle viewport = new Rectangle(client.getViewportXOffset(), client.getViewportYOffset(), client.getViewportWidth(), client.getViewportHeight());
                graphics.setColor(config.worldFogColour());
                graphics.fill(viewport);
            }
            return null;
        }
        if (config.showWorldFog()) {
            renderWorldFog(graphics, renderAreaBoundary);
        }
        if (config.showWorldBorder()) {
            renderWorldBorder(graphics, renderAreaBoundary);
        }
        return null;
    }
    private void subtractEntitiesFromFog(Area fogArea) {
        WorldView worldView = client.getTopLevelWorldView();
        for (Player player : worldView.players()) {
            if (player == null) continue;
            Shape convexHull = player.getConvexHull();
            if (convexHull != null) {
                fogArea.subtract(new Area(convexHull));
            }
        }
        for (NPC npc : worldView.npcs()) {
            if (npc == null) continue;
            Shape convexHull = npc.getConvexHull();
            if (convexHull != null) {
                fogArea.subtract(new Area(convexHull));
            }
        }
    }
    private void renderWorldFog(Graphics2D graphics, GeneralPath renderAreaBoundary) {
        Rectangle viewport = new Rectangle(
                client.getViewportXOffset(),
                client.getViewportYOffset(),
                client.getViewportWidth(),
                client.getViewportHeight()
        );
        Area screenArea = new Area(viewport);
        screenArea.subtract(new Area(renderAreaBoundary));
        if (config.excludeEntities()) {
            subtractEntitiesFromFog(screenArea);
        }
        graphics.setColor(config.worldFogColour());
        graphics.fill(screenArea);
    }
    private void renderWorldBorder(Graphics2D graphics, GeneralPath renderAreaBoundary) {
        graphics.setColor(config.worldBorderColour());
        graphics.setStroke(new BasicStroke(config.worldBorderThickness()));
        graphics.draw(renderAreaBoundary);
    }
    private GeneralPath createRenderAreaBoundary(WorldPoint centerWp, int radius) {
        LocalPoint centerLp = LocalPoint.fromWorld(client.getTopLevelWorldView(), centerWp);
        if (centerLp == null) return null;
        boundaryPoints.clear();
        int localRadius = radius * 128 + 64;
        int plane = centerWp.getPlane();
        int sampleCount = Math.max(1, radius / 4) * 4;
        int step = (localRadius * 2) / sampleCount;
        for (int i = 0; i < sampleCount; i++) { addPoint(boundaryPoints, centerLp.getX() - localRadius + (i * step), centerLp.getY() + localRadius, plane); }
        for (int i = 0; i < sampleCount; i++) { addPoint(boundaryPoints, centerLp.getX() + localRadius, centerLp.getY() + localRadius - (i * step), plane); }
        for (int i = 0; i < sampleCount; i++) { addPoint(boundaryPoints, centerLp.getX() + localRadius - (i * step), centerLp.getY() - localRadius, plane); }
        for (int i = 0; i < sampleCount; i++) { addPoint(boundaryPoints, centerLp.getX() - localRadius, centerLp.getY() - localRadius + (i * step), plane); }
        return createPathFromPoints(boundaryPoints);
    }
    private void addPoint(List<net.runelite.api.Point> points, int localX, int localY, int plane) {
        LocalPoint lp = new LocalPoint(localX, localY, client.getTopLevelWorldView());
        net.runelite.api.Point canvasPoint = Perspective.localToCanvas(client, lp, plane);
        if (canvasPoint != null) {
            points.add(canvasPoint);
        }
    }
    private GeneralPath createPathFromPoints(List<net.runelite.api.Point> points) {
        if (points.isEmpty()) return null;
        path.reset();
        path.moveTo(points.get(0).getX(), points.get(0).getY());
        for (int i = 1; i < points.size(); i++) {
            path.lineTo(points.get(i).getX(), points.get(i).getY());
        }
        path.closePath();
        return path;
    }
}
package com.fogofwar.box;

import com.fogofwar.FogOfWarConfig;
import com.fogofwar.util.AreaManager;
import com.fogofwar.util.ClientState;
import com.fogofwar.util.DynamicRenderDistance;
import com.fogofwar.util.MinimapUtil;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.Ellipse2D;
import java.awt.geom.GeneralPath;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class FogOfWarMinimapOverlay extends Overlay {
    private final Client client;
    private final FogOfWarConfig config;
    private final ClientState clientState;
    private final DynamicRenderDistance dynamicRenderDistance;
    private final AreaManager areaManager;
    private static final int MINIMAP_GROUP_ID = 164;
    private static final int HEALTH_ORB_CHILD_ID = 16;
    private static final int PRAYER_ORB_CHILD_ID = 17;
    private static final int RUN_ORB_CHILD_ID = 18;
    private static final int SPEC_ORB_CHILD_ID = 19;
    private static final int ORBS_GROUP_ID = 160;
    private static final int WORLD_MAP_ORB_CHILD_ID = 48;
    private static final int HALF_TILE_OFFSET = 64;
    @Inject
    public FogOfWarMinimapOverlay(Client client, FogOfWarConfig config, ClientState clientState, DynamicRenderDistance dynamicRenderDistance, AreaManager areaManager) {
        this.client = client;
        this.config = config;
        this.clientState = clientState;
        this.dynamicRenderDistance = dynamicRenderDistance;
        this.areaManager = areaManager;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(Overlay.PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if (areaManager.isPlayerInExcludedArea() || clientState.isClientNotReady() || (config.onlyInWilderness() && clientState.isNotInWilderness())) {
            return null;
        }
        Widget minimap = MinimapUtil.getMinimapWidget(client);
        if (minimap == null || minimap.isHidden()) return null;
        Shape minimapClipShape = getMinimapClipShape(minimap);
        Shape oldClip = graphics.getClip();
        graphics.setClip(minimapClipShape);
        int radius = dynamicRenderDistance.getCurrentRenderDistance();
        WorldPoint centerWp = client.getLocalPlayer().getWorldLocation();
        List<Point> boundaryPoints = getBoundaryPointsWithNulls(centerWp, radius);
        GeneralPath fogPath = createClippedRenderAreaPath(boundaryPoints, minimap.getBounds());
        if (fogPath == null) {
            graphics.setClip(oldClip);
            return null;
        }
        if (config.showMinimapFog()) {
            renderMinimapFog(graphics, minimapClipShape, fogPath);
        }
        if (config.showMinimapBorder()) {
            GeneralPath borderPath = createMinimapBorderPath(boundaryPoints);
            renderMinimapBorder(graphics, borderPath);
        }
        graphics.setClip(oldClip);
        return null;
    }
    private Shape getMinimapClipShape(Widget minimapWidget) {
        Rectangle bounds = minimapWidget.getBounds();
        Area clipArea = new Area(new Ellipse2D.Double(bounds.getX() - 1, bounds.getY() - 1, bounds.getWidth() + 2, bounds.getHeight() + 2));
        int[] orbChildIds = {HEALTH_ORB_CHILD_ID, PRAYER_ORB_CHILD_ID, RUN_ORB_CHILD_ID, SPEC_ORB_CHILD_ID};
        for (int childId : orbChildIds) {
            Widget orb = client.getWidget(MINIMAP_GROUP_ID, childId);
            if (orb != null && !orb.isHidden()) {
                Rectangle orbBounds = orb.getBounds();
                clipArea.subtract(new Area(new Ellipse2D.Double(orbBounds.getX(), orbBounds.getY(), orbBounds.getWidth(), orbBounds.getHeight())));
            }
        }
        Widget worldMapOrb = client.getWidget(ORBS_GROUP_ID, WORLD_MAP_ORB_CHILD_ID);
        if (worldMapOrb != null && !worldMapOrb.isHidden()) {
            Rectangle orbBounds = worldMapOrb.getBounds();
            clipArea.subtract(new Area(new Ellipse2D.Double(orbBounds.getX(), orbBounds.getY(), orbBounds.getWidth(), orbBounds.getHeight())));
        }
        return clipArea;
    }
    private void renderMinimapBorder(Graphics2D graphics, GeneralPath borderPath) {
        graphics.setColor(config.minimapBorderColour());
        graphics.setStroke(new BasicStroke(config.minimapBorderThickness()));
        graphics.draw(borderPath);
    }
    private GeneralPath createMinimapBorderPath(List<Point> boundaryPoints) {
        GeneralPath path = new GeneralPath();
        for (int i = 0; i < boundaryPoints.size(); i++) {
            Point p1 = boundaryPoints.get(i);
            Point p2 = boundaryPoints.get((i + 1) % boundaryPoints.size());
            if (p1 != null && p2 != null) {
                path.moveTo(p1.getX(), p1.getY());
                path.lineTo(p2.getX(), p2.getY());
            }
        }
        return path;
    }
    private void renderMinimapFog(Graphics2D graphics, Shape minimapClipShape, GeneralPath renderAreaPath) {
        Area renderArea = new Area(renderAreaPath);
        if (renderArea.contains(minimapClipShape.getBounds2D())) {
            return;
        }
        Area fogArea = new Area(minimapClipShape);
        fogArea.subtract(renderArea);
        graphics.setColor(config.minimapFogColour());
        graphics.fill(fogArea);
    }
    private GeneralPath createClippedRenderAreaPath(List<Point> boundaryPoints, Rectangle minimapBounds) {
        List<Point> visiblePoints = boundaryPoints.stream().filter(Objects::nonNull).collect(Collectors.toList());
        if (visiblePoints.isEmpty()) return createFullMinimapCoveragePath(minimapBounds);
        if (visiblePoints.size() == boundaryPoints.size()) {
            GeneralPath path = new GeneralPath();
            Point first = visiblePoints.get(0);
            path.moveTo(first.getX(), first.getY());
            for (int i = 1; i < visiblePoints.size(); i++) {
                path.lineTo(visiblePoints.get(i).getX(), visiblePoints.get(i).getY());
            }
            path.closePath();
            return path;
        }
        int firstVisible = -1;
        for (int i = 0; i < boundaryPoints.size(); i++) {
            if (boundaryPoints.get(i) != null) {
                firstVisible = i;
                break;
            }
        }
        if (firstVisible == -1) return null;
        GeneralPath path = new GeneralPath();
        path.moveTo(boundaryPoints.get(firstVisible).getX(), boundaryPoints.get(firstVisible).getY());
        int n = boundaryPoints.size();
        for (int i = 0; i < n; i++) {
            int currentIndex = (firstVisible + i) % n;
            int nextIndex = (firstVisible + i + 1) % n;
            Point p1 = boundaryPoints.get(currentIndex);
            Point p2 = boundaryPoints.get(nextIndex);
            if (p1 != null) {
                if (p2 != null) {
                    path.lineTo(p2.getX(), p2.getY());
                } else {
                    int nextVisibleIndex = -1;
                    for (int j = 2; j < n; j++) {
                        if (boundaryPoints.get((currentIndex + j) % n) != null) {
                            nextVisibleIndex = (currentIndex + j) % n;
                            break;
                        }
                    }
                    if (nextVisibleIndex != -1) {
                        Point nextVisiblePoint = boundaryPoints.get(nextVisibleIndex);
                        addArcToPath(path, p1, nextVisiblePoint, minimapBounds);
                    }
                }
            }
        }
        path.closePath();
        return path;
    }
    private void addArcToPath(GeneralPath path, Point p1, Point p2, Rectangle minimapBounds) {
        double centerX = minimapBounds.getCenterX();
        double centerY = minimapBounds.getCenterY();
        double radius = minimapBounds.width / 2.0 + 1;
        double startAngle = Math.toDegrees(Math.atan2(p1.getY() - centerY, p1.getX() - centerX));
        double endAngle = Math.toDegrees(Math.atan2(p2.getY() - centerY, p2.getX() - centerX));
        double sweep = endAngle - startAngle;
        if (sweep <= -180) { sweep += 360; } else if (sweep > 180) { sweep -= 360; }
        int numSteps = (int) (Math.abs(sweep) / 10) + 1;
        for (int i = 1; i <= numSteps; i++) {
            double currentAngleRad = Math.toRadians(startAngle + (sweep * i / numSteps));
            float x = (float) (centerX + radius * Math.cos(currentAngleRad));
            float y = (float) (centerY + radius * Math.sin(currentAngleRad));
            path.lineTo(x, y);
        }
    }
    private List<Point> getBoundaryPointsWithNulls(WorldPoint center, int radius) {
        List<Point> boundaryPoints = new ArrayList<>();
        int sampleRate = Math.max(1, radius / 12);
        boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() - radius, center.getY() - radius, center.getPlane()), -HALF_TILE_OFFSET, -HALF_TILE_OFFSET));
        for (int x = -radius; x <= radius; x += sampleRate) { boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() + x, center.getY() - radius, center.getPlane()), 0, -HALF_TILE_OFFSET)); }
        boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() + radius, center.getY() - radius, center.getPlane()), HALF_TILE_OFFSET, -HALF_TILE_OFFSET));
        for (int y = -radius; y <= radius; y += sampleRate) { boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() + radius, center.getY() + y, center.getPlane()), HALF_TILE_OFFSET, 0)); }
        boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() + radius, center.getY() + radius, center.getPlane()), HALF_TILE_OFFSET, HALF_TILE_OFFSET));
        for (int x = radius; x >= -radius; x -= sampleRate) { boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() + x, center.getY() + radius, center.getPlane()), 0, HALF_TILE_OFFSET)); }
        boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() - radius, center.getY() + radius, center.getPlane()), -HALF_TILE_OFFSET, HALF_TILE_OFFSET));
        for (int y = radius; y >= -radius; y -= sampleRate) { boundaryPoints.add(getMinimapPointWithOffset(new WorldPoint(center.getX() - radius, center.getY() + y, center.getPlane()), -HALF_TILE_OFFSET, 0)); }
        return boundaryPoints;
    }
    private Point getMinimapPointWithOffset(WorldPoint worldPoint, int xOffset, int yOffset) {
        LocalPoint lp = LocalPoint.fromWorld(client.getTopLevelWorldView(), worldPoint);
        if (lp == null) return null;
        LocalPoint offsetLp = new LocalPoint(lp.getX() + xOffset, lp.getY() + yOffset, client.getTopLevelWorldView());
        return Perspective.localToMinimap(client, offsetLp);
    }
    private GeneralPath createFullMinimapCoveragePath(Rectangle minimapBounds) {
        GeneralPath fullPath = new GeneralPath();
        double centerX = minimapBounds.getCenterX();
        double centerY = minimapBounds.getCenterY();
        double radius = Math.max(minimapBounds.width, minimapBounds.height);
        int numSegments = 32;
        for (int i = 0; i < numSegments; i++) {
            double angle = 2 * Math.PI * i / numSegments;
            double x = centerX + radius * Math.cos(angle);
            double y = centerY + radius * Math.sin(angle);
            if (i == 0) {
                fullPath.moveTo(x, y);
            } else {
                fullPath.lineTo(x, y);
            }
        }
        fullPath.closePath();
        return fullPath;
    }
}
package com.fogofwar;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FogOfWar {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(FogOfWarPlugin.class);
        RuneLite.main(args);
    }
}
