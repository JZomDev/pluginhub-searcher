/*
	BSD 2-Clause License

	Copyright (c) 2024, zom
	Copyright (c) 2023, InfernoStats

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	1. Redistributions of source code must retain the above copyright notice, this
	   list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright notice,
	   this list of conditions and the following disclaimer in the documentation
	   and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.dt2PerfectBossFailure;

import java.awt.Color;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;


@ConfigGroup(dt2pbfConfig.DT2_UTILITIES_CONFIG_GROUP)
public interface dt2pbfConfig extends net.runelite.client.config.Config
{
	String DT2_UTILITIES_CONFIG_GROUP = "dt2perfectBossNotifier";
	@ConfigItem(
		position = 0,
		keyName = "infobox",
		name = "Display infobox",
		description = "Show infobox displaying kill perfection status"
	)
	default boolean infobox()
	{
		return true;
	}

	@ConfigItem(
		position = 1,
		keyName = "chatMessage",
		name = "Chat messages",
		description = "Show message in chat when failing a perfect kill"
	)
	default boolean chatbox()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "notifyRepeatedly",
		name = "Notify repeat failure",
		description = "Show failure message/play sound for each mistake"
	)
	default boolean notifyRepeatedly()
	{
		return false;
	}

	// Sound section
	@ConfigSection(
		name="Sound",
		description="Sound notification",
		position=4,
		closedByDefault = false
	)
	String soundNotification = "soundNotification";

	@ConfigItem(
		keyName = "audiblyNotify",
		name = "Play sound",
		description = "Play a sound on failure",
		section = soundNotification
	)
	default boolean audiblyNotify()
	{
		return false;
	}

	@ConfigItem(
		keyName = "soundSelection",
		name = "Notification Sound",
		description = "A RuneScape sound ID to be notified with",
		section = soundNotification
	)
	default int soundSelection()
	{
		return 1043;
	}

	// Highlight section
	@ConfigSection(
		name="Highlight",
		description="Show kill status on boss",
		position=5,
		closedByDefault = false
	)
	String highlightSection = "highlightSection";

	@ConfigItem(
		position = 0,
		keyName = "feather",
		name = "Outline feather",
		description = "",
		section=highlightSection
	)
	default int feather() {return 2;}

	@ConfigItem(
		position = 0,
		keyName = "highlightWidth",
		name = "Highlight width",
		description = "Width of the edge",
		section=highlightSection
	)
	default double borderWidth() {return 2;}

	@ConfigItem(
		position = 1,
		keyName = "highlightDuke",
		name = "Duke",
		description="Highlight Duke",
		section=highlightSection
	)
	default overlayTypes highlightDuke() {
		return overlayTypes.NONE;
	}

	@Alpha
	@ConfigItem(
		position = 2,
		keyName = "dukePerfectHighlight",
		name = "Duke perfect highlight color",
		description = "The color Duke is highlighted when you haven't made a mistake",
		section=highlightSection
	)
	default Color dukePerfect() {return Color.green;}

	@Alpha
	@ConfigItem(
		position = 3,
		keyName = "dukeFailureHighlight",
		name = "Duke failure highlight color",
		description = "The color Duke is highlighted when you've made a mistake",
		section=highlightSection
	)
	default Color dukeFailure() {return Color.red;}

	@ConfigItem(
		position = 4,
		keyName = "highlightWhisperer",
		name = "Whisperer",
		description="Highlight Whisperer",
		section=highlightSection
	)
	default overlayTypes highlightWhisperer() {
		return overlayTypes.NONE;
	}

	@Alpha
	@ConfigItem(
		position = 5,
		keyName = "dukePerfectHighlight",
		name = "Whisperer perfect highlight color",
		description = "The color Whisperer is highlighted when you haven't made a mistake",
		section=highlightSection
	)
	default Color whispererPerfect() {return Color.green;}

	@Alpha
	@ConfigItem(
		position = 6,
		keyName = "whispererFailureHighlight",
		name = "Whisperer failure highlight color",
		description = "The color Whisperer is highlighted when you've made a mistake",
		section=highlightSection
	)
	default Color whispererFailure() {return Color.red;}

	@ConfigItem(
		position = 7,
		keyName = "highlightVardorvis",
		name = "Vardorvis",
		description="Highlight Vardorvis",
		section=highlightSection
	)
	default overlayTypes highlightVardorvis() {
		return overlayTypes.NONE;
	}

	@Alpha
	@ConfigItem(
		position = 8,
		keyName = "vardorvisPerfectHighlight",
		name = "Vardorvis perfect highlight color",
		description = "The color Vardorvis is highlighted when you haven't made a mistake",
		section=highlightSection
	)
	default Color vardorvisPerfect() {return Color.green;}

	@Alpha
	@ConfigItem(
		position = 9,
		keyName = "vardorvisFailureHighlight",
		name = "Vardorvis failure highlight color",
		description = "The color Vardorvis is highlighted when you've made a mistake",
		section=highlightSection
	)
	default Color vardorvisFailure() {return Color.red;}

	@ConfigItem(
		position = 10,
		keyName = "highlightLeviathan",
		name = "Leviathan",
		description="Highlight Leviathan",
		section=highlightSection
	)
	default overlayTypes highlightLeviathan() {
		return overlayTypes.NONE;
	}

	@Alpha
	@ConfigItem(
		position = 11,
		keyName = "leviathanPerfectHighlight",
		name = "Leviathan perfect highlight color",
		description = "The color Duke is highlighted when you haven't made a mistake",
		section=highlightSection
	)
	default Color leviathanPerfect() {return Color.green;}

	@Alpha
	@ConfigItem(
		position = 12,
		keyName = "leviathanFailureHighlight",
		name = "Leviathan failure highlight color",
		description = "The color Leviathan is highlighted when you've made a mistake",
		section=highlightSection
	)
	default Color leviathanFailure() {return Color.red;}

	// Vardorvis pillars
	@ConfigSection(
		name="Vardorvis pillars",
		description="Show or hide pillars in Vardorvis' arena",
		position=6,
		closedByDefault = false
	)
	String vardorvisPillars = "vardorvisPillars";

	@ConfigItem(
		position = 1,
		keyName = "hidePillars",
		name = "Hide pillars",
		description = "Hide the pillars in Vardorvis' arena",
		section = vardorvisPillars
	)
	default boolean hidePillars()
	{
		return false;
	}

	@ConfigItem(
		position = 2,
		keyName = "drawPillarLocation",
		name = "Draw pillars",
		description = "Display the pillar locations where you can't click",
		section = vardorvisPillars
	)
	default boolean drawPillarLocation()
	{
		return true;
	}

	@ConfigItem(
		position = 3,
		keyName = "borderColor",
		name = "Border color",
		description = "Fill color where the pillars used to be",
		section = vardorvisPillars
	)
	default Color borderColor()
	{
		return new Color(0x64FFFF00, true);
	}

	@ConfigItem(
		position = 4,
		keyName = "borderWidth",
		name = "Border Width",
		description = "Width of the marked tile border",
		section = vardorvisPillars
	)
	default double pillarBorderWidth()
	{
		return 2;
	}

	@ConfigItem(
		position = 5,
		keyName = "fillOpacity",
		name = "Fill Opacity",
		description = "Opacity of the tile fill color",
		section = vardorvisPillars
	)
	@Range(
		max = 255
	)
	default int fillOpacity()
	{
		return 50;
	}

	@ConfigSection(
		name="Projectile Swaps",
		description="Swap projectiles per boss",
		position=7,
		closedByDefault = false
	)
	String projectileSwaps = "projectileSwaps";

	// Whisperer Projectiles
	@Getter
	@AllArgsConstructor
	enum WhispererStyle
	{
		Default(2444,2445),
		Inferno(1378, 1380),
		CoX(1343, 1341),
		ToB(1607, 1606),
		ToA(2241, 2224);

		private final int range;
		private final int magic;
	}

	@ConfigItem(
		keyName = "whispererProjectileStyle",
		name = "Whisperer projectiles",
		description = "The projectile you want to replace Whisperer's",
		section = projectileSwaps,
		position = 0
	)
	default WhispererStyle whispererProjectileStyle()
	{
		return WhispererStyle.Default;
	}

	@ConfigItem(
		keyName = "vardorvisProjectiles",
		name = "Vardorvis Projectiles",
		description = "",
		section = projectileSwaps,
		position = 1
	)
	default String explanation()
	{
		return "Please install the separate \"Vardorvis Projectiles\" plugin for now";
	}
}

/*
	BSD 2-Clause License

	Copyright (c) 2023, InfernoStats

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	1. Redistributions of source code must retain the above copyright notice, this
	   list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright notice,
	   this list of conditions and the following disclaimer in the documentation
	   and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.dt2PerfectBossFailure.whispererUtils;

import com.dt2PerfectBossFailure.dt2pbfConfig;
import com.dt2PerfectBossFailure.dt2pbfPlugin;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Projectile;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class WhispererProjectileSwapper
{
	// Vardorvis' Head Projectile IDs
	private static final int MAGIC_PROJECTILE = 2445;
	private static final int RANGE_PROJECTILE = 2444;

	private final Client client;
	private final dt2pbfConfig config;
	private final dt2pbfPlugin plugin;

	@Inject
	private WhispererProjectileSwapper(Client client, dt2pbfPlugin plugin, dt2pbfConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	/* @Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved)
	{
		if(config.whispererProjectileStyle()== dt2pbfConfig.WhispererStyle.Default)
			return;
		Projectile projectile = projectileMoved.getProjectile();
		if (projectile.getId() == RANGE_PROJECTILE)
		{
			replaceProjectile(projectile, config.whispererProjectileStyle().getRange());
		}
		else if (projectile.getId() == MAGIC_PROJECTILE)
		{
			replaceProjectile(projectile, config.whispererProjectileStyle().getMagic());
		}
	}

	private void replaceProjectile(Projectile projectile, int projectileId)
	{
		Projectile p = client.createProjectile(projectileId,
			projectile.getFloor(),
			projectile.getX1(), projectile.getY1(),
			projectile.getHeight(),
			projectile.getStartCycle(), projectile.getEndCycle(),
			projectile.getSlope(),
			projectile.getStartHeight(), projectile.getEndHeight(),
			projectile.getInteracting(),
			projectile.getTarget().getX(), projectile.getTarget().getY());

		client.getProjectiles().addLast(p);
		projectile.setEndCycle(0);
	} */ // uncomment after RL fix :)
}

package com.dt2PerfectBossFailure;

import com.dt2PerfectBossFailure.bossFailure.Duke;
import com.dt2PerfectBossFailure.bossFailure.Leviathan;
import com.dt2PerfectBossFailure.bossFailure.Vardorvis;
import com.dt2PerfectBossFailure.bossFailure.Whisperer;
import com.dt2PerfectBossFailure.vardorvisUtils.VardorvisPillarHider;
import com.dt2PerfectBossFailure.vardorvisUtils.VardorvisPillarOverlay;
import com.dt2PerfectBossFailure.whispererUtils.WhispererProjectileSwapper;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GraphicsObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
@PluginDescriptor(
	name = "DT2 Boss Utilities",
	description="Change Whisperer projectiles, hide Vardorvis pillars, track perfect kill status.",
	tags= {"desert", "treasure", "dt2", "perfect","vardorvis","whisperer","duke","leviathan"}
)
public class dt2pbfPlugin extends Plugin
{
	@Inject
	public Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private dt2pbfConfig config;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private EventBus eventBus;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Duke duke;

	@Inject
	private Whisperer whisperer;

	@Inject
	public WhispererProjectileSwapper whispererProjectileSwapper;

	@Inject
	private Vardorvis vardorvis;

	@Inject
	private Leviathan leviathan;

	@Inject
	private dt2pbfBossOverlay dt2pbfBossOverlay;

	@Inject
	public VardorvisPillarHider vardorvisPillarHider;

	@Inject
	private VardorvisPillarOverlay vardorvisPillarOverlay;

	private InfoBox infoBox;
	public String initialReason = "Perfect";
	public ArrayList<String> reasons = new ArrayList<String>();
	public boolean notified = false;
	public WorldPoint lastLocation = null;
	//Regions
	private static final int[] BOSS_REGION_IDS = {4405, 8291, 12132, 10595};

	private static final String[] BOSS_NAMES = {"duke sucellus", "vardorvis", "the leviathan", "the whisperer","odd figure"};

	@Override
	protected void startUp() throws Exception
	{
		eventBus.register(vardorvisPillarHider);
		eventBus.register(whispererProjectileSwapper);
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invoke(vardorvisPillarHider::hide);
		}
		overlayManager.add(vardorvisPillarOverlay);
		eventBus.register(duke);
		eventBus.register(whisperer);
		eventBus.register(vardorvis);
		eventBus.register(leviathan);
		dt2boss.DUKE.initialize(config.dukePerfect(),config.dukeFailure(),config.highlightDuke());
		dt2boss.WHISPERER.initialize(config.whispererPerfect(),config.whispererFailure(),config.highlightWhisperer());
		dt2boss.VARDORVIS.initialize(config.vardorvisPerfect(),config.whispererFailure(),config.highlightVardorvis());
		dt2boss.LEVIATHAN.initialize(config.leviathanPerfect(),config.leviathanFailure(),config.highlightLeviathan());
		overlayManager.add(dt2pbfBossOverlay);
		reset();
	}

	@Override
	protected void shutDown() throws Exception
	{
		eventBus.unregister(duke);
		eventBus.unregister(whisperer);
		eventBus.unregister(vardorvis);
		eventBus.unregister(leviathan);
		eventBus.unregister(vardorvisPillarHider);
		eventBus.unregister(whispererProjectileSwapper);
		removeInfobox();
		overlayManager.remove(dt2pbfBossOverlay);
		clientThread.invoke(() ->
		{
			if (client.getGameState() == GameState.LOGGED_IN)
			{
				client.setGameState(GameState.LOADING);
			}
		});
		overlayManager.remove(vardorvisPillarOverlay);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (!inBossRegion())
		{
			lastLocation = null;
			return;
		}
		lastLocation = client.getLocalPlayer().getWorldLocation();
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event)
	{
		if (config.infobox() && ArrayUtils.contains(BOSS_NAMES, event.getNpc().getName().toLowerCase()) && !event.getNpc().getName().contains("Head"))
		{
			reset();
		}
	}

	@Subscribe
	public void onActorDeath(ActorDeath event)
	{
		if (inBossRegion())
		{
			if (event.getActor().equals(client.getLocalPlayer()))
			{
				reset();
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage message)
	{
		if (message.getType() != ChatMessageType.GAMEMESSAGE)
		{
			return;
		}

		if (message.getMessage().contains("Oh dear, you are dead"))
		{
			reset();
		}

		if (message.getMessage().contains("kill count is:"))
		{
			reset();
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event)
	{
		if (event.getActor().getName()==null)
		{
			return;
		}
		// Vardorvis' head scuffs the contains check
		if (ArrayUtils.contains(BOSS_NAMES, event.getActor().getName().toLowerCase().trim()) && !event.getActor().getName().toLowerCase().contains("head"))
		{
			reset();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			if (!inBossRegion())
			{
				removeInfobox();
				reset();
				return;
			}
			reset();
		}
	}


	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if(!configChanged.getGroup().equalsIgnoreCase(config.DT2_UTILITIES_CONFIG_GROUP))
		{
			return;
		}
		switch(configChanged.getKey())
		{
			case "infobox":
			{
				if (Boolean.parseBoolean(configChanged.getNewValue()))
				{
					reset();
				}
				else
				{
					removeInfobox();
				}
			}
			break;
			case "highlightDuke":
			{
				dt2boss.DUKE.setRender(config.highlightDuke());
			}
			break;

			case "highlightWhisperer":
			{
				dt2boss.WHISPERER.setRender(config.highlightWhisperer());
			}
			break;

			case "highlightVardorvis":
			{
				dt2boss.VARDORVIS.setRender(config.highlightVardorvis());
			}
			break;

			case "highlightLeviathan":
			{
				dt2boss.LEVIATHAN.setRender(config.highlightLeviathan());
			}
			break;
			// Perfect Colors
			case "dukePerfectHighlight":
			{
				dt2boss.DUKE.setPerfectColor(config.dukePerfect());
			}
			break;

			case "whispererPerfectHighlight":
			{
				dt2boss.WHISPERER.setPerfectColor(config.whispererPerfect());
			}
			break;

			case "vardorvisPerfectHighlight":
			{
				dt2boss.VARDORVIS.setPerfectColor(config.vardorvisPerfect());
			}
			break;

			case "leviathanPerfectHighlight":
			{
				dt2boss.LEVIATHAN.setPerfectColor(config.leviathanPerfect());
			}
			break;

			// Failure Colors
			case "dukeFailureHighlight":
			{
				dt2boss.DUKE.setFailureColor(config.dukeFailure());
			}
			break;

			case "whispererFailureHighlight":
			{
				dt2boss.WHISPERER.setFailureColor(config.whispererFailure());
			}
			break;

			case "vardorvisFailureHighlight":
			{
				dt2boss.VARDORVIS.setFailureColor(config.vardorvisFailure());
			}
			break;

			case "leviathanFailureHighlight":
			{
				dt2boss.LEVIATHAN.setFailureColor(config.leviathanFailure());
			}
			break;
		}
	}

	public boolean checkCollision(GraphicsObject object)
	{
		if(lastLocation == null)
		{
			return false;
		}
		LocalPoint localPoint = object.getLocation();
		WorldPoint worldPoint = WorldPoint.fromLocal(client, localPoint);
		return lastLocation.equals(worldPoint);
	}

	private boolean inBossRegion()
	{
		for(int region : BOSS_REGION_IDS)
		{
			if(client.getLocalPlayer()==null)
			{
				return false;
			}
			if (WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID()==region)
			{

				return true;
			}
		}
		return false;
	}

	public int getCurrentRegion()
	{
		return WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID();
	}

	public void notifyFailure(String bossName, String reason)
	{
		if (initialReason.equals("Perfect"))
		{
			initialReason = reason;
		}
		reasons.add(reason);
		if (notified && !config.notifyRepeatedly())
		{
			return;
		}

		if (config.chatbox())
		{
			String chatMessage = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append("Perfect " + bossName + " failed: " + reason)
				.build();

			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.FRIENDSCHATNOTIFICATION)
				.runeLiteFormattedMessage(chatMessage)
				.build());
		}

		if (infoBox != null)
		{
			removeInfobox();
		}
		createInfobox(true, reason);

		if (config.audiblyNotify())
		{
			client.playSoundEffect(config.soundSelection());
		}

		notified = true;
	}

	public void reset()
	{
		initialReason = "Perfect";
		if (infoBox != null)
		{
			removeInfobox();
		}
		if(config.infobox())
		{
			createInfobox(false, initialReason);
		}
		notified = false;
		if(reasons!=null)
		{
			reasons.clear();
		}
	}

	private void createInfobox(Boolean failed, String reason)
	{
		if (!config.infobox())
		{
			return;
		}
		if (infoBox == null && inBossRegion())
		{
			BufferedImage icon;
			if (failed)
			{
				icon = ImageUtil.loadImageResource(dt2pbfPlugin.class, "/icons/X_mark.png");
			}
			else
			{
				icon = ImageUtil.loadImageResource(dt2pbfPlugin.class, "/icons/Yes_check.png");
			}
			infoBox = new dt2pbfInfobox(this);
			infoBox.setImage(icon);
			infoBoxManager.addInfoBox(infoBox);
		}
	}

	private void removeInfobox()
	{
		if (infoBox != null)
		{
			infoBoxManager.removeInfoBox(infoBox);
			infoBox = null;
		}
	}

	@Provides
	dt2pbfConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(dt2pbfConfig.class);
	}
}

/*
 * Copyright (c) 2024, zom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.dt2PerfectBossFailure.vardorvisUtils;

import com.dt2PerfectBossFailure.dt2pbfConfig;
import com.dt2PerfectBossFailure.dt2pbfPlugin;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import java.util.HashSet;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
public class VardorvisPillarOverlay extends Overlay
{
		private static final int MAX_DRAW_DISTANCE = 32;

		private final Client client;
		private final dt2pbfConfig config;
		private final dt2pbfPlugin plugin;

		@Inject
		private VardorvisPillarOverlay(Client client, dt2pbfPlugin plugin, dt2pbfConfig config)
		{
			this.client = client;
			this.plugin = plugin;
			this.config = config;
			setPosition(OverlayPosition.DYNAMIC);
			setPriority(PRIORITY_LOW);
			setLayer(OverlayLayer.ABOVE_SCENE);
		}

		@Override
		public Dimension render(Graphics2D graphics)
		{
			if (!config.drawPillarLocation() || !config.hidePillars())
			{
				return null;
			}
			final HashSet<Tile> tiles = plugin.vardorvisPillarHider.getPillarTiles();
			if (tiles.isEmpty())
			{
				return null;
			}

			Stroke stroke = new BasicStroke((float) config.pillarBorderWidth());
			for (final Tile tile : tiles)
			{
				if(tile==null)
					continue;
				WorldPoint worldPoint = tile.getWorldLocation();
				if (worldPoint.getPlane() != client.getPlane())
				{
					continue;
				}

				Color tileColor = config.borderColor();

				drawTile(graphics, worldPoint, tileColor, stroke);
			}

			return null;
		}

		private void drawTile(Graphics2D graphics, WorldPoint point, Color color, Stroke borderStroke)
		{
			WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

			if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
			{
				return;
			}

			LocalPoint lp = LocalPoint.fromWorld(client, point);
			if (lp == null)
			{
				return;
			}

			Polygon poly = Perspective.getCanvasTilePoly(client, lp);
			if (poly != null)
			{
				OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, config.fillOpacity()), borderStroke);
			}
		}
}

/*
 * Copyright (c) 2024, zom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.dt2PerfectBossFailure.vardorvisUtils;

import com.dt2PerfectBossFailure.dt2pbfConfig;
import com.google.common.collect.ImmutableSet;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
public class VardorvisPillarHider
{
	@Inject
	private dt2pbfConfig config;

	@Inject
	private ClientThread clientThread;

	private static final Set<Integer> HIDE = ImmutableSet.of(
		48419,
		48420,
		48422,
		48423,
		48424,
		48426,
		48427,
		48428
	);

	@Getter
	private HashSet<Tile> pillarTiles = new HashSet<>();

	@Inject
	private Client client;

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			hide();
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if(!configChanged.getGroup().equalsIgnoreCase(config.DT2_UTILITIES_CONFIG_GROUP))
		{
			return;
		}
		if(configChanged.getKey().equals("hidePillars"))
		{
			if(Boolean.parseBoolean(configChanged.getNewValue()))
			{
				hide();
				return;
			}
			clientThread.invoke(() ->
			{
				if (client.getGameState() == GameState.LOGGED_IN)
				{
					client.setGameState(GameState.LOADING);
				}
			});
		}
	}

	public void hide()
	{
		pillarTiles.clear();
		if (!isInVardorvisArea() || !config.hidePillars())
		{
			return;
		}

		Scene scene = client.getScene();
		Tile[][] tiles = scene.getTiles()[0];
		int cnt = 0;
		for (int x = 0; x < Constants.SCENE_SIZE; ++x)
		{
			for (int y = 0; y < Constants.SCENE_SIZE; ++y)
			{
				Tile tile = tiles[x][y];
				if (tile == null)
				{
					continue;
				}

				for (GameObject gameObject : tile.getGameObjects())
				{
					if (gameObject != null && HIDE.contains(gameObject.getId()))
					{
						scene.removeGameObject(gameObject);
						pillarTiles.add(tile);
						++cnt;
						break;
					}
				}
			}
			log.debug("Removed {} objects", cnt);
		}
	}

	private boolean isInVardorvisArea()
	{
		// 17, 53
		return ArrayUtils.contains(client.getMapRegions(), (17 << 8) | 53);
	}
}

package com.dt2PerfectBossFailure;

import static com.dt2PerfectBossFailure.bossFailure.Duke.DUKE_IDS;
import static com.dt2PerfectBossFailure.bossFailure.Leviathan.LEVIATHAN_IDS;
import static com.dt2PerfectBossFailure.bossFailure.Vardorvis.VARDORVIS_IDS;
import static com.dt2PerfectBossFailure.bossFailure.Whisperer.WHISPERER_IDS;
import java.awt.Color;

public enum dt2boss
{
	DUKE(DUKE_IDS,Color.WHITE,Color.WHITE,overlayTypes.NONE),
	WHISPERER(WHISPERER_IDS,Color.WHITE,Color.WHITE,overlayTypes.NONE),
	VARDORVIS(VARDORVIS_IDS,Color.WHITE,Color.WHITE,overlayTypes.NONE),
	LEVIATHAN(LEVIATHAN_IDS,Color.WHITE,Color.WHITE,overlayTypes.NONE);
	public int[] ids;
	public Color perfectColor;
	public Color failureColor;
	public overlayTypes render;

	dt2boss(int[] boss_ids, Color color1, Color color2, overlayTypes render)
	{
		this.ids = boss_ids;
		this.perfectColor = color1;
		this.failureColor = color2;
		this.render = render;
	}

	public void initialize(Color perfectColor, Color failureColor, overlayTypes render)
	{
		this.perfectColor=perfectColor;
		this.failureColor=failureColor;
		this.render=render;
	}

	public int[] getIds() {
		return ids;
	}
	public Color getPerfectColor() {
		return perfectColor;
	}

	public void setPerfectColor(Color perfectColor) {
		this.perfectColor = perfectColor;
	}

	public Color getFailureColor() {
		return failureColor;
	}

	public void setFailureColor(Color failureColor) {
		this.failureColor = failureColor;
	}

	public overlayTypes render()
	{
		return this.render;
	}

	public void setRender(overlayTypes render)
	{
		this.render = render;
	}
}


package com.dt2PerfectBossFailure;

import java.awt.Color;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;

public class dt2pbfInfobox extends InfoBox
{
	private final dt2pbfPlugin plugin;

	@Inject
	public dt2pbfInfobox(dt2pbfPlugin plugin)
	{
		super(null, plugin);
		this.plugin = plugin;
		setPriority(InfoBoxPriority.MED);
	}

	@Override
	public String getText()
	{
		return "";
	}
	@Override
	public Color getTextColor()
	{
		return Color.WHITE;
	}

	@Override
	public String getTooltip()
	{
		return plugin.initialReason;
	}

}

package com.dt2PerfectBossFailure.bossFailure;

import com.dt2PerfectBossFailure.dt2pbfPlugin;
import com.dt2PerfectBossFailure.dt2pbfConfig;
import com.google.inject.Inject;
import java.util.Iterator;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Deque;
import net.runelite.api.GraphicsObject;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Player;
import net.runelite.api.GameState;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.client.eventbus.Subscribe;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
public class Duke
{
	@Inject
	private Client client;

	@Inject
	private dt2pbfPlugin plugin;

	@Inject
	private dt2pbfConfig config;

	// Duke
	private int projectileEndTick = -1;
	private static final int DUKE_VENT = 12198;
	private static final int DUKE_MAGIC_PROJECTILE = 2434;
	private static final String DUKE = "Duke Sucellus";
	private static final String EXTREMITY_FREEZE_MESSAGE = "You've been frozen in place!";
	private static final String DUKE_FREEZE_MESSAGE = "You have been frozen!";
	private static final int DUKE_REGION_ID = 12132;
	private static final int[] DUKE_ICICLES = {2440, 2441, 2442, 2443};
	//WHY ARE THERE SO MANY
	public static final int[] DUKE_IDS = {NpcID.DUKE_SUCELLUS_12167, NpcID.DUKE_SUCELLUS, NpcID.DUKE_SUCELLUS_12191, NpcID.DUKE_SUCELLUS_12192, NpcID.DUKE_SUCELLUS_12193, NpcID.DUKE_SUCELLUS_12194,
		NpcID.DUKE_SUCELLUS_12195, NpcID.DUKE_SUCELLUS_12196};

	private boolean inDukeRegion()
	{
		if (!client.getGameState().equals(GameState.LOGGED_IN) || client.getLocalPlayer() == null)
		{
			return false;
		}
		return plugin.getCurrentRegion()==DUKE_REGION_ID;
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if(projectileEndTick == -1)
		{
			return;
		}
		if(projectileEndTick <= client.getGameCycle())
		{
			projectileEndTick = -1;
		}
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved event)
	{
		if (!inDukeRegion() || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}
		if (event.getProjectile().getId() == DUKE_MAGIC_PROJECTILE && projectileEndTick == -1)
		{
			projectileEndTick = event.getProjectile().getEndCycle()+1;
			plugin.notifyFailure(DUKE, "You were hit by Duke Sucellus's magic attack.");
		}
	}

	// Duke: Extremities/Gaze
	@Subscribe
	public void onChatMessage(ChatMessage message)
	{
		if (message.getType() != ChatMessageType.GAMEMESSAGE || !inDukeRegion() || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}

		if (message.getMessage().contains(EXTREMITY_FREEZE_MESSAGE))
		{
			plugin.notifyFailure(DUKE, "You were frozen.");
		}

		if (message.getMessage().contains(DUKE_FREEZE_MESSAGE))
		{
			plugin.notifyFailure(DUKE, "Duke gazed upon you.");
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		if (!inDukeRegion() || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}
		Actor target = hitsplatApplied.getActor();

		if (!(target instanceof Player))
		{
			return;
		}
		Hitsplat hitsplat = hitsplatApplied.getHitsplat();
		if (hitsplat.isMine() && target == client.getLocalPlayer() && hitsplat.getHitsplatType() != HitsplatID.BLOCK_ME)
		{
			Deque<GraphicsObject> graphicsObjects = client.getGraphicsObjects();
			Iterator<GraphicsObject> iterator = graphicsObjects.iterator();
			while (iterator.hasNext())
			{
				GraphicsObject obj = iterator.next();
				if (ArrayUtils.contains(DUKE_ICICLES, obj.getId()) && checkCollision(obj))
				{
						plugin.notifyFailure(DUKE, "You were hit by Duke's melee");
						return;
				}
			}
			/*
			* TODO: Track active vents and check how long they've been active.
			* Race condition where duke melees as soon as the vent is active but the vent isn't applying the damage
			*/
			List<NPC> npcs = client.getNpcs();
			for (NPC npc : npcs)
			{
				// Vents
				if (npc.getId() == DUKE_VENT)
				{
					WorldArea ventArea = new WorldArea(npc.getWorldLocation(), 3, 3);
					if (client.getLocalPlayer().getWorldLocation().isInArea(ventArea))
					{
						plugin.notifyFailure(DUKE, "You took damage from the Duke's vents.");
						return;
					}
				}
			}
		}
	}

	private boolean checkCollision(GraphicsObject obj)
	{
		LocalPoint localPoint = obj.getLocation();
		WorldPoint worldPoint = WorldPoint.fromLocal(client, localPoint);
		return worldPoint.equals(plugin.lastLocation);
	}
}

package com.dt2PerfectBossFailure.bossFailure;

import com.dt2PerfectBossFailure.dt2pbfPlugin;
import com.dt2PerfectBossFailure.dt2pbfConfig;
import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.NpcID;
import net.runelite.api.Player;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.eventbus.Subscribe;

@Slf4j
public class Whisperer
{
	@Inject
	private Client client;

	@Inject
	private dt2pbfPlugin plugin;

	@Inject
	private dt2pbfConfig config;

	public static final int[] WHISPERER_IDS = {NpcID.THE_WHISPERER,NpcID.THE_WHISPERER_12205,NpcID.THE_WHISPERER_12206,NpcID.THE_WHISPERER_12207};
	private static final int WHISPERER_REGION_ID = 10595;
	private static final String WHISPERER = "The Whisperer";

	private boolean inWhispererRegion()
	{
		if (!client.getGameState().equals(GameState.LOGGED_IN) || client.getLocalPlayer() == null)
		{
			return false;
		}
		return plugin.getCurrentRegion()==WHISPERER_REGION_ID;
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		if (!inWhispererRegion() || !(hitsplatApplied.getActor() instanceof Player) || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}

		Hitsplat hitsplat = hitsplatApplied.getHitsplat();
		if (hitsplat.isMine() && hitsplatApplied.getActor() == client.getLocalPlayer() && hitsplat.getHitsplatType() != HitsplatID.BLOCK_ME)
		{
			plugin.notifyFailure(WHISPERER, "You took avoidable damage.");
		}
	}
}

package com.dt2PerfectBossFailure.bossFailure;

import com.dt2PerfectBossFailure.dt2pbfPlugin;
import com.dt2PerfectBossFailure.dt2pbfConfig;
import com.google.inject.Inject;
import java.util.Iterator;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ActorSpotAnim;
import net.runelite.api.Client;
import net.runelite.api.Deque;
import net.runelite.api.GameState;
import net.runelite.api.GraphicsObject;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.IterableHashTable;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.eventbus.Subscribe;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
public class Leviathan
{
	@Inject
	private Client client;

	@Inject
	private dt2pbfPlugin plugin;

	@Inject
	private dt2pbfConfig config;

	// Leviathan
	private static final String LEVIATHAN = "The Leviathan";
	public static final int[] LEVIATHAN_IDS = {NpcID.THE_LEVIATHAN, NpcID.THE_LEVIATHAN_12215, NpcID.THE_LEVIATHAN_12219, NpcID.THE_LEVIATHAN_12221};
	private static final int LEVIATHAN_RANGED_SPOT_ANIM = 2490;
	private static final int LEVIATHAN_MAGE_SPOT_ANIM = 2492;
	private static final int LEVIATHAN_MELEE_SPOT_ANIM = 2491;
	private static final int[] LEVIATHAN_SPECIAL_ATTACK_ANIMATIONS = {10285, 10286, 10287, 10289, 10288, 10290};
	private static final int[] LEVIATHAN_SMOKE_BLAST_BOULDERS_ANIM = {10289, 10288, 10287};
	private static final int LEVIATHAN_SMOKE_BLAST_ANIM = 10290;
	private static final int[] LEVIATHAN_LIGHTNING_ANIM = {10285, 10286};
	private static final int BOULDER_MOVE_ANIM = 1114;
	private static final int[] LEVIATHAN_BOULDER_SHADOWS = {2475, 2476, 2477, 2478, 2479, 2480};
	private int leviathanSpecial = -1;
	private static final int LEVIATHAN_REGION_ID = 8291;

	private boolean inLeviathanRegion()
	{
		if (!client.getGameState().equals(GameState.LOGGED_IN) || client.getLocalPlayer() == null)
		{
			return false;
		}
		return plugin.getCurrentRegion()==LEVIATHAN_REGION_ID;
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged graphicChanged)
	{
		if(!inLeviathanRegion() || !graphicChanged.getActor().equals(client.getLocalPlayer()) || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}
		// Check projectiles
		IterableHashTable<ActorSpotAnim> spotAnims = client.getLocalPlayer().getSpotAnims();
		Iterator<ActorSpotAnim> animsIterator = spotAnims.iterator();
		while (animsIterator.hasNext())
		{
			ActorSpotAnim anim = animsIterator.next();
			if(anim.getId() == LEVIATHAN_RANGED_SPOT_ANIM)
			{
				plugin.notifyFailure(LEVIATHAN,"You were hit by a ranged projectile off prayer.");
				return;
			}
			if(anim.getId() == LEVIATHAN_MELEE_SPOT_ANIM)
			{
				plugin.notifyFailure(LEVIATHAN,"You were hit by a melee projectile off prayer.");
				return;
			}
			if(anim.getId() == LEVIATHAN_MAGE_SPOT_ANIM)
			{
				plugin.notifyFailure(LEVIATHAN,"You were hit by a mage projectile off prayer.");
				return;
			}
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (!inLeviathanRegion() || event.getActor().getName() == null || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}
		NPC npc;
		if (event.getActor() instanceof NPC)
		{
			npc = (NPC) event.getActor();
			// Leviathan Specials
			if (ArrayUtils.contains(LEVIATHAN_IDS, npc.getId()))
			{
				// Leviathan is always in one of these animations prior to damage hitting the player,
				// so we can reliably assume the hitsplatApplied will come after the leviathanSpecial has been set
				leviathanSpecial = ArrayUtils.contains(LEVIATHAN_SPECIAL_ATTACK_ANIMATIONS, npc.getAnimation()) ? npc.getAnimation() : -1;
			}
		}
		else if (event.getActor().equals(client.getLocalPlayer()) && event.getActor().getAnimation() == BOULDER_MOVE_ANIM)
		{
			plugin.notifyFailure(LEVIATHAN, "You were hit by falling rubble");
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
	{
		if (!inLeviathanRegion() || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}
		if (!(hitsplatApplied.getActor() == client.getLocalPlayer()))
		{
			return;
		}
		Hitsplat hitsplat = hitsplatApplied.getHitsplat();
		if (hitsplat.isMine() && hitsplat.getHitsplatType() != HitsplatID.BLOCK_ME)
		{
			Deque<GraphicsObject> graphicsObjects = client.getGraphicsObjects();
			Iterator<GraphicsObject> iterator = graphicsObjects.iterator();
			while (iterator.hasNext())
			{
				GraphicsObject obj = iterator.next();
				if (ArrayUtils.contains(LEVIATHAN_BOULDER_SHADOWS, obj.getId()))
				{
					if (checkCollision(obj))
					{
						log.debug("Found possible collision");
						log.debug("ObjectID: " + obj.getId());
						log.debug("Animation Frame: " + obj.getAnimationFrame());
						if (obj.getAnimationFrame() < 3)
						{
							return;
						}
						plugin.notifyFailure(LEVIATHAN, "You were hit by falling rubble");
						return;
					}
				}
			}

			// Check pathfinder or special (special might be checked differently soon O.O)
			if(ArrayUtils.contains(LEVIATHAN_SPECIAL_ATTACK_ANIMATIONS,leviathanSpecial))
			{
				if(LEVIATHAN_SMOKE_BLAST_ANIM == leviathanSpecial)
				{
					plugin.notifyFailure(LEVIATHAN, "You were hit by the smoke blast.");
					return;
				}
				if(ArrayUtils.contains(LEVIATHAN_SMOKE_BLAST_BOULDERS_ANIM,leviathanSpecial))
				{
					plugin.notifyFailure(LEVIATHAN, "You were hit by falling rubble.");
					return;
				}
				if(ArrayUtils.contains(LEVIATHAN_LIGHTNING_ANIM,leviathanSpecial))
				{
					plugin.notifyFailure(LEVIATHAN, "You were hit by lightning.");
					return;
				}
			}

			List<NPC> npcs = client.getNpcs();
			for (NPC npc : npcs)
			{
				if (npc.getId() == NpcID.ABYSSAL_PATHFINDER)
				{
					plugin.notifyFailure(LEVIATHAN, "You were hit outside the pathfinder.");
					return;
				}
			}
		}
	}
	private boolean checkCollision(GraphicsObject obj)
	{
		// WorldPoint currentLocation = client.getLocalPlayer().getWorldLocation();
		LocalPoint localPoint = obj.getLocation();
		WorldPoint worldPoint = WorldPoint.fromLocal(client, localPoint);
		return worldPoint.equals(plugin.lastLocation);
	}
}

package com.dt2PerfectBossFailure.bossFailure;

import com.dt2PerfectBossFailure.dt2pbfPlugin;
import com.dt2PerfectBossFailure.dt2pbfConfig;
import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Prayer;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GraphicsObjectCreated;
import net.runelite.client.eventbus.Subscribe;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
public class Vardorvis
{
	@Inject
	private Client client;

	@Inject
	private dt2pbfPlugin plugin;

	@Inject
	private dt2pbfConfig config;

	public static final int[] VARDORVIS_IDS = {NpcID.VARDORVIS,NpcID.VARDORVIS_12224,NpcID.VARDORVIS_12425,NpcID.VARDORVIS_12426,NpcID.VARDORVIS_12228};
	private static final int VARDORVIS_REGION_ID = 4405;
	private static final String VARDORVIS = "Vardorvis";
	private static final String VARDORVIS_PROJECTILE_MESSAGE = "You've been injured and can't use protection prayers!";
	private static final String VARDORVIS_AXE_MESSAGE = "You have started bleeding!";
	private static final String VARDORVIS_CAPTCHA_MESSAGE = "The tendrils tighten around you, damaging you in the process!";
	private static final int[] VARDORVIS_ATTACKS = {10340, 10341, 10342, 10343};
	private static final int VARDORVIS_SPIKE = 2512;

	private boolean inVardorvisRegion()
	{
		if (!client.getGameState().equals(GameState.LOGGED_IN) || client.getLocalPlayer() == null)
		{
			return false;
		}
		return plugin.getCurrentRegion()==VARDORVIS_REGION_ID;
	}

	// Vardorvis dash attack
	// TODO: Improve this. Can probably be simplified like Duke melees in onHitsplatApplied...
	//  but race conditions
	@Subscribe
	public void onGraphicsObjectCreated(GraphicsObjectCreated event)
	{
		if (!inVardorvisRegion() || plugin.notified)
		{
			return;
		}
		if (event.getGraphicsObject().getId() == VARDORVIS_SPIKE)
		{
			if (plugin.checkCollision(event.getGraphicsObject()))
			{
				plugin.notifyFailure(VARDORVIS, "You were hit by a ground spike.");
			}
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (!inVardorvisRegion() || event.getActor().getName() == null)
		{
			return;
		}
		NPC npc;
		if (event.getActor() instanceof NPC)
		{
			npc = (NPC) event.getActor();
			// Vardorvis Auto-Attacks
			if (npc.isInteracting())
			{
				if (npc.getInteracting().equals(client.getLocalPlayer()))
				{
					if (npc.getId() == NpcID.VARDORVIS)
					{
						if (ArrayUtils.contains(VARDORVIS_ATTACKS, npc.getAnimation()) && client.getServerVarbitValue(Prayer.PROTECT_FROM_MELEE.getVarbit()) != 1 && client.getServerVarbitValue(Prayer.RP_DAMPEN_MELEE.getVarbit()) != 1)
						{
							plugin.notifyFailure(VARDORVIS, "You were hit off-prayer.");
						}
					}
				}
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage message)
	{
		if (message.getType() != ChatMessageType.GAMEMESSAGE || !inVardorvisRegion() || (plugin.notified && !config.notifyRepeatedly()))
		{
			return;
		}
		/*
		// This doesn't actually cause failure, it just allows the being hit by melee of prayer to happen
		if (message.getMessage().contains(VARDORVIS_PROJECTILE_MESSAGE))
		{
			plugin.notifyFailure(VARDORVIS, "You were hit by a head projectile off-prayer.");
		}
		*/

		if (message.getMessage().contains(VARDORVIS_AXE_MESSAGE))
		{
			plugin.notifyFailure(VARDORVIS, "You were hit by an axe.");
		}

		if (message.getMessage().contains(VARDORVIS_CAPTCHA_MESSAGE))
		{
			plugin.notifyFailure(VARDORVIS, "You failed to complete the captcha.");
		}
	}
}

package com.dt2PerfectBossFailure;

public enum overlayTypes
{
	NONE,
	HULL,
	TILE,
	TRUE_TILE,
	OUTLINE
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2023, geheur <http://github.com/geheur>
 * Copyright (c) 2021, LeikvollE <http://github.com/LeikvollE>
 * Copyright (c) 2024, DominickCobb-rs <http://github.com/DominickCobb-rs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.dt2PerfectBossFailure;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Shape;
import java.awt.Stroke;
import lombok.extern.slf4j.Slf4j;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import org.apache.commons.lang3.ArrayUtils;

@Slf4j
public class dt2pbfBossOverlay extends Overlay {
	@Inject
	private Client client;

	@Inject
	private dt2pbfPlugin plugin;

	@Inject
	private dt2pbfConfig config;

	@Inject
	private ModelOutlineRenderer modelOutlineRenderer;

	public dt2pbfBossOverlay()
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Stroke stroke = new BasicStroke((float) config.borderWidth());
		for (dt2boss boss : dt2boss.values())
		{
			if (boss.render()==overlayTypes.NONE)
			{
				continue;
			}
			for (NPC npc : client.getNpcs())
			{
				if (ArrayUtils.contains(boss.getIds(), npc.getId()))
				{
					NPCComposition npcComposition = npc.getTransformedComposition();
					int size = npcComposition.getSize();
					Color color = plugin.notified ? boss.getFailureColor() : boss.getPerfectColor();
					int alpha = (int) (color.getAlpha() * 0.3);
					Color fillColor = new Color(color.getRed(), color.getGreen(), color.getBlue(), alpha);
					switch (boss.render())
					{
						case HULL:
							Shape hull = npc.getConvexHull();
							if (hull != null)
							{
								OverlayUtil.renderPolygon(graphics, hull, color, fillColor, stroke);
							}
							break;
						case TILE:
							Polygon poly = npc.getCanvasTilePoly();
							if (poly != null)
							{
								OverlayUtil.renderPolygon(graphics, poly, color, fillColor, stroke);
							}
							break;
						// Snippets from the BetterNPCHighlightOverlay.java in both of the following
						case TRUE_TILE:
							LocalPoint lp = LocalPoint.fromWorld(client, npc.getWorldLocation());
							if (lp != null)
							{
								lp = new LocalPoint(lp.getX() + size * 128 / 2 - 64, lp.getY() + size * 128 / 2 - 64);
								Polygon tile = Perspective.getCanvasTileAreaPoly(client, lp, size);
								if (tile != null)
								{
									OverlayUtil.renderPolygon(graphics, tile, color, fillColor, stroke);
								}
							}
							break;
						case OUTLINE:
							modelOutlineRenderer.drawOutline(npc,(int)config.borderWidth(),color,config.feather());
							break;

					}
				}
			}
		}
		return null;
	}
}

package com.dt2PerfectBossFailure;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class dt2pbfTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(dt2pbfPlugin.class);
		RuneLite.main(args);
	}
}
