package com.monsterhp;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;

import net.runelite.api.*;
import static net.runelite.api.gameval.NpcID.*;

@Getter
public class BossUtil {

    // Tombs of Amascut - String identification seems like the way to identify these bosses (with blacklist control)
    private static final ImmutableSet<String> TOA_BOSS_NAMES = ImmutableSet.of("Akkha", "Kephri", "Zebak", "Ba-Ba", "Tumeken's Warden", "Elidinis' Warden");

    // Chambers of Xeric - Some ids for cox that support varbits
    private static final ImmutableSet<Integer> COX_BOSS_IDS = ImmutableSet.of(
        // The Great Olm
        OLM_HEAD,
        // Tekton
        RAIDS_TEKTON_WAITING, RAIDS_TEKTON_WALKING_STANDARD, RAIDS_TEKTON_FIGHTING_STANDARD, RAIDS_TEKTON_WALKING_ENRAGED, RAIDS_TEKTON_FIGHTING_ENRAGED, RAIDS_TEKTON_HAMMERING,
        // Vespula
        RAIDS_VESPULA_FLYING, RAIDS_VESPULA_ENRAGED, RAIDS_VESPULA_WALKING, RAIDS_VESPULA_PORTAL,
        // Muttadile
        RAIDS_DOGODILE_SUBMERGED, RAIDS_DOGODILE_JUNIOR, RAIDS_DOGODILE,
        // Vasa
        RAIDS_VASANISTIRIO_WALKING, RAIDS_VASANISTIRIO_HEALING
    );

    // Desert Treasure 2
    private static final ImmutableSet<Integer> DT2_BOSS_IDS = ImmutableSet.of(
        LEVIATHAN,
        VARDORVIS, VARDORVIS_BASE_POSTQUEST,
        WHISPERER,
        DUKE_SUCELLUS_AWAKE, DUKE_SUCELLUS_ASLEEP
    );

    // Generic bosses - bosses that does not have a specific section
    private static final ImmutableSet<Integer> GEN_BOSS_IDS = ImmutableSet.of(
        YAMA
    );

    // Doom of Mokhaiotl
    public static final ImmutableSet<Integer> DOOM_BOSS_IDS = ImmutableSet.of(
        DOM_BOSS,
        DOM_BOSS_SHIELDED,
        DOM_BOSS_BURROWED
    );

    private static final ImmutableSet<Integer> ALL_BOSS_IDS = 
        ImmutableSet.<Integer>builder()
            .addAll(GEN_BOSS_IDS)
            .addAll(COX_BOSS_IDS)
            .addAll(DT2_BOSS_IDS)
            .addAll(DOOM_BOSS_IDS)
            .build();

    public static boolean isNpcBossFromTOA(NPC npc) {
        int id = npc.getId();
        String name = npc.getName();
        boolean isWardenP1 = (id == TOA_WARDEN_TUMEKEN_PHASE1 || id == TOA_WARDEN_ELIDINIS_PHASE1);

        return name != null && TOA_BOSS_NAMES.contains(name) && !isWardenP1;
    }

    public static boolean isNpcBoss(NPC npc) {
        if (ALL_BOSS_IDS.contains(npc.getId())) {
            return true;
        }
        // Only check TOA names if ID lookup fails
        return isNpcBossFromTOA(npc);
    }
}

package com.monsterhp;

import java.awt.Color;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import net.runelite.client.config.*;

@ConfigGroup("MonsterHP")
public interface MonsterHPConfig extends Config {
    enum FontStyle {
        BOLD("Bold"),
        ITALICS("Italics"),
        BOLD_ITALICS("Bold and italics"),
        DEFAULT("Default");

        String name;

        FontStyle(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }
    }

    @Getter
    @RequiredArgsConstructor
    enum Background
    {
        OFF("Off"),
        SHADOW("Shadow"),
        OUTLINE("Outline");

        @Getter
        private final String group;

        @Override
        public String toString()
        {
            return group;
        }
    }

    @ConfigSection(
            name = "HP Settings",
            description = "Settings relating to HP",
            position = 1
    )
    String hp_settings = "hp_settings";

    @ConfigSection(
            name = "Font Settings",
            description = "Settings relating to fonts",
            position = 2
    )
    String font_settings = "font_settings";

    @ConfigItem(
            position = 0,
            keyName = "showOverlay",
            name = "Show HP over chosen NPCs",
            description = "Configures whether or not to have the HP shown over the chosen NPCs"
    )
    default boolean showOverlay() {
        return true;
    }

    @ConfigItem(
            position = 1,
            keyName = "npcToShowHp",
            name = "NPC Names",
            description = "Enter names of NPCs where you wish to use this plugin",
            section = hp_settings
    )
    default String npcToShowHp() {
        return "";
    }

    @ConfigItem(
            position = 2,
            keyName = "npcIdToShowHp",
            name = "NPC Ids",
            description = "Enter Id of NPCs where you wish to use this plugin (optional)",
            section = hp_settings
    )
    default String npcIdToShowHp() {
        return "";
    }

    @ConfigItem(
            position = 3,
            keyName = "npcShowAll",
            name = "Show All",
            description = "Show for all NPCs",
            section = hp_settings
    )
    default boolean npcShowAll() {
        return false;
    }

    @ConfigItem(
            position = 4,
            keyName = "npcShowAllBlacklist",
            name = "Show all blacklist",
            description = "blacklist npc names from show all option",
            section = hp_settings
    )
    default String npcShowAllBlacklist() {
        return "";
    }

    @ConfigItem(
            position = 5,
            keyName = "npcHideFull",
            name = "Hide HP when full",
            description = "Hides the HP when the npc has not been damaged. Works nicely with the Show All option",
            section = hp_settings
    )
    default boolean npcHideFull() {
        return false;
    }

    @Alpha
    @Range(
            max = 300
    )
    @ConfigItem(
            position = 6,
            keyName = "normalHPColor",
            name = "Default HP overlay color",
            description = "Choose the color to be used on the HP",
            section = hp_settings
    )
    default Color normalHPColor() {
        return Color.GREEN;
    }

    @ConfigItem(
            position = 7,
            keyName = "useLowHP",
            name = "Use low HP threshold",
            description = "Configures whether or not you wish to use a 2nd color when the monster HP hits below the low HP threshold",
            section = hp_settings
    )
    default boolean useLowHP() {
        return true;
    }

    @ConfigItem(
            position = 8,
            keyName = "lowHPThreshold",
            name = "Low HP threshold",
            description = "Used to set the low HP threshold",
            section = hp_settings
    )
    default int lowHPThreshold() {
        return 25;
    }
    @Alpha
    @ConfigItem(
            position = 9,
            keyName = "lowHPColor",
            name = "Overlay color Low HP",
            description = "Choose the color to be used when the HP of the npc is below the chosen HP threshold",
            section = hp_settings
    )
    default Color lowHPColor() {
        return Color.RED;
    }

    @ConfigItem(
            position = 10,
            keyName = "aboveHPBar",
            name = "Above HP bar",
            description = "Hp above the monsters HP bar, otherwise the Hp is show on the body of the NPC",
            section = hp_settings
    )
    default boolean aboveHPBar() {
        return true;
    }

    @ConfigItem(
            position = 11,
            keyName = "HPHeight",
            name = "Height of the HP",
            description = "Change the vertical offset of the HP above the npc body or the HP bar",
            section = hp_settings
    )
    default int HPHeight() {
        return 50;
    }

    @ConfigItem(
            position = 12,
            keyName = "hideDeath",
            name = "Hide HP on death",
            description = "Hides the HP when the npc dies. Works nicely with the entity hider: Hide Dead NPCs option",
            section = hp_settings
    )
    default boolean hideDeath() {
        return false;
    }

    @ConfigItem(
            position = 13,
            keyName = "stackHp",
            name = "Stack monster HP",
            description = "Stacks the HP numbers on top of each other if multiple npc's are on the same tile",
            section = hp_settings
    )
    default boolean stackHp() {
        return false;
    }

    @Range(
            min = 0,
            max = 2
    )
    @ConfigItem(
            position = 14,
            keyName = "decimalHp",
            name = "Amount of decimals",
            description = "Show 0-2 decimals of precision, e.g. 13.33 instead of 13.",
            section = hp_settings
    )
    default int decimalHp() {
        return 0;
    }

    @ConfigItem(
            position = 15,
            keyName = "customFont",
            name = "Enable custom fonts",
            description = "Enabling this setting makes it possible to use the custom font from the box below this",
            section = font_settings
    )
    default boolean customFont() {
        return true;
    }

    @ConfigItem(
            position = 16,
            keyName = "fontName",
            name = "Font",
            description = "Name of the font to use for the HP shown. Leave blank to use RuneLite setting.",
            section = font_settings
    )
    default String fontName() {
        return "roboto";
    }

    @ConfigItem(
            position = 17,
            keyName = "fontStyle",
            name = "Style",
            description = "Style of the font to use for the HP shown. Only works with custom font.",
            section = font_settings
    )
    default FontStyle fontStyle() {
        return FontStyle.DEFAULT;
    }

    @ConfigItem(
            position = 18,
            keyName = "fontSize",
            name = "Size",
            description = "Size of the font to use for HP text. Only works with custom font.",
            section = font_settings
    )
    default int fontSize() {
        return 15;
    }

    @ConfigItem(
            position = 19,
            keyName = "numericHealth",
            name = "Numeric All Health",
            description = "Tries to show the numeric health of all tagged monsters instead of percentage.",
            section = hp_settings
    )
    default boolean numericAllHealth() {
        return false;
    }

    @ConfigItem(
            position = 20,
            name = "Background",
            keyName = "fontBackground",
            description = "Background of the HP text",
            section = font_settings
    )
    default Background fontBackground()
    {
        return Background.SHADOW;
    }

    @Range(
            min = 1,
            max = 100
    )
    @ConfigItem(
            position = 21,
            keyName = "fontShadowSize",
            name = "Shadow size",
            description = "Offset of the shadow drawn, requires font backgrounds.",
            section = font_settings
    )
    default int fontShadowSize() {
        return 1;
    }

    @Range(
            min = 1,
            max = 100
    )
    @ConfigItem(
            position = 22,
            keyName = "fontOutlineSize",
            name = "Outline size",
            description = "Size of the outline drawn, requires font backgrounds.",
            section = font_settings
    )
    default int fontOutlineSize() {
        return 4;
    }
    @Alpha
    @ConfigItem(
            position = 23,
            keyName = "fontOutlineColor",
            name = "Outline color",
            description = "Choose the color for the text outline",
            section = font_settings
    )
    default Color fontOutlineColor() {
        return Color.BLACK;
    }

    @ConfigItem(
            position = 24,
            keyName = "gradientHP",
            name = "Gradient HP",
            description = "HP will be gradient from color preset A to B depending on the percentage. (Overwrites low HP threshold setting)",
            section = hp_settings
    )
    default boolean useGradientHP() {
        return true;
    }

    @Alpha
    @ConfigItem(
            position = 25,
            keyName = "gradientHPColorA",
            name = "Gradient color A",
            description = "Choose the color for gradient A",
            section = hp_settings
    )
    default Color gradientHPColorA() {
        return Color.GREEN;
    }

    @Alpha
    @ConfigItem(
            position = 26,
            keyName = "gradientHPColorB",
            name = "Gradient color B",
            description = "Choose the color for gradient B",
            section = hp_settings
    )
    default Color gradientHPColorB() {
        return Color.RED;
    }

    @ConfigItem(
            keyName = "appendPercentSymbol",
            name = "Append % symbol",
            description = "Toggle whether to append a % symbol to the monster HP display",
            position = 27,
            section = hp_settings
    )
    default boolean appendPercentSymbol()
    {
        return false;
    }
}

package com.monsterhp;

import java.awt.*;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import javax.inject.Inject;
import java.util.ArrayList;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.game.NPCManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import static net.runelite.api.gameval.NpcID.*;
import static net.runelite.api.gameval.VarbitID.*;

@Slf4j
public class MonsterHPOverlay extends Overlay {
    @Inject
    private Client client;

    private final MonsterHPPlugin plugin;
    private final MonsterHPConfig config;

    private NPCManager npcManager;
    protected String lastFont = "";
    protected int lastFontSize = 0;
    protected boolean useRunescapeFont = true;
    protected MonsterHPConfig.FontStyle lastFontStyle = MonsterHPConfig.FontStyle.DEFAULT;
    protected Font font = null;

    NumberFormat format = new DecimalFormat("#");
    NumberFormat oneDecimalFormat = new DecimalFormat("#.0");
    NumberFormat twoDecimalFormat = new DecimalFormat("#.00");

    @Inject
    MonsterHPOverlay(MonsterHPPlugin plugin, MonsterHPConfig config, NPCManager npcManager) {
        setPriority(0.75f);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.plugin = plugin;
        this.config = config;
        this.npcManager = npcManager;
    }

    protected void handleFont(Graphics2D graphics) {
        if (font != null) {
            graphics.setFont(font);
            if (useRunescapeFont) {
                graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
            }
        }
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        updateFont();
        handleFont(graphics);
        if (config.showOverlay()) {
            ArrayList<NPC> stackedNpcs = new ArrayList<>();
            plugin.getWanderingNPCs().forEach((id, npc) -> renderTimer(npc, graphics, stackedNpcs));
        }
        return null;
    }

    private String getCurrentHpString(WanderingNPC wnpc) {
        boolean showNumericHealth = config.numericAllHealth() || wnpc.getIsTypeNumeric() == 1;
        NPC npc = wnpc.getNpc();

        // Numeric
        if (showNumericHealth) {
            String healthRatio = format.format(wnpc.getHealthRatio());

            // getCurrentHp() returns numeric hp value if set, default is WanderingNpc value 100
            boolean usePercentage = wnpc.getCurrentHp() == 100 && wnpc.getHealthRatio() < 100.0;

            if (BossUtil.isNpcBoss(npc)) {
                // Defaults to percentage if numeric fails
                final int curHp = client.getVarbitValue(HPBAR_HUD_HP);
                return usePercentage ? healthRatio : String.valueOf(curHp);
            }

            // Defaults to percentage if numeric fails
            return usePercentage ? healthRatio : String.valueOf((int) (wnpc.getCurrentHp()));
        }

        // Percentage
        switch (config.decimalHp()) {
            case 1:  return String.valueOf(oneDecimalFormat.format(wnpc.getHealthRatio()));
            case 2:  return String.valueOf(twoDecimalFormat.format(wnpc.getHealthRatio()));
            default: return String.valueOf((wnpc.getHealthRatio() >= 1) ? format.format(wnpc.getHealthRatio()) : twoDecimalFormat.format(wnpc.getHealthRatio()));
        }
    }


    private void renderTimer(final WanderingNPC wnpc, final Graphics2D graphics, ArrayList<NPC> stackedNpcs) {
        if (wnpc == null || wnpc.isDead()) {
            return;
        }

        // Get NPC from WanderingNPC
        NPC npc = wnpc.getNpc();

        // NPC Health Ratio
        double wNpcHealthRatio = wnpc.getHealthRatio();

        // Skip npc with full hp if enabled
        if (config.npcHideFull() && wNpcHealthRatio == 100) return;

        // Get max health through NPC manager, returns null if not found
        Integer maxHealth = npcManager.getHealth(npc.getId());

        // Health fix for some bosses (that are not correctly set in npcManager)
        if (BossUtil.isNpcBoss(npc)) {
            maxHealth = client.getVarbitValue(HPBAR_HUD_BASEHP);

            // Special check for Chambers of xeric(cox) - check if both hands are dead (allows OLM_HEAD to be main varbit source)
            if (npc.getId() == OLM_HEAD && isCoxOlmHandsAlive()) {
                return;
            }

            if (maxHealth <= 0) return;
        }

        // Use Numeric health
        boolean isUsingNumeric = config.numericAllHealth() || wnpc.getIsTypeNumeric() == 1;
        if (isUsingNumeric && maxHealth != null) {
            // Use the current health ratio and round it according to monsters max hp
            double numericHealth = (int) Math.floor((wNpcHealthRatio / 100) * maxHealth);
            wnpc.setCurrentHp(numericHealth);
        }

        // Coloring
        Color timerColor = config.normalHPColor();
        boolean isHealthBelowThreshold = wNpcHealthRatio < config.lowHPThreshold();
        if (config.useLowHP() && isHealthBelowThreshold) {
            timerColor = config.lowHPColor();
        }

        if (config.useGradientHP()) {
            if (maxHealth != null && maxHealth > 1) {
                int curNumericHealth = (int) Math.floor((wNpcHealthRatio / 100) * maxHealth);
                timerColor = getGradientHpColor(curNumericHealth, maxHealth);
            } else { // Try percentage based gradient hp - happens if npcManager can't get numeric max health.
                int curNumericHealth = (int) Math.floor(wNpcHealthRatio);
                timerColor = getGradientHpColor(curNumericHealth, 100);
            }
        }

        String currentHPString = getCurrentHpString(wnpc);
        if (config.appendPercentSymbol() && !isUsingNumeric) {
            currentHPString += "%";
        }

        if (config.stackHp()) {
            /*
             * Stack method created by github.com/MoreBuchus in his tzhaar-hp-tracker plugin
             * i Xines just modified this method to work with Monster HP plugin.
             * So credits goes to Buchus for the method.
             */

            int offset = 0;
            NPC firstStack = null;
            for (NPC sNpc : stackedNpcs) {
                if (sNpc.getWorldLocation().getX() == npc.getWorldLocation().getX() && sNpc.getWorldLocation().getY() == npc.getWorldLocation().getY()) {
                    if (firstStack == null) {
                        firstStack = npc;
                    }
                    offset += graphics.getFontMetrics().getHeight();
                }
            }

            int zOffset = config.HPHeight();
            if (config.aboveHPBar()) {
                zOffset += npc.getLogicalHeight();
            }

            stackedNpcs.add(npc);

            Point textLocation = offset > 0 ? firstStack.getCanvasTextLocation(graphics, currentHPString, zOffset) : npc.getCanvasTextLocation(graphics, currentHPString, zOffset);
            if (textLocation != null) {
                Point stackOffset = new Point(textLocation.getX(), textLocation.getY() - offset);
                handleText(graphics, stackOffset, currentHPString, timerColor);
            }
        } else {
            Point canvasPoint;
            if (config.aboveHPBar()) {
                canvasPoint = npc.getCanvasTextLocation(graphics, currentHPString, npc.getLogicalHeight() + config.HPHeight());
            } else {
                canvasPoint = npc.getCanvasTextLocation(graphics, currentHPString, config.HPHeight());
            }

            if (canvasPoint != null) {
                handleText(graphics, canvasPoint, currentHPString, timerColor);
            }
        }
    }

    // Returns true if either of olm hands are alive
    private boolean isCoxOlmHandsAlive() {
        for (WanderingNPC wnpc : plugin.getWanderingNPCs().values()) {
            NPC npc = wnpc.getNpc();
            if (npc == null) continue;

            int id = npc.getId();
            if ((id == OLM_HAND_RIGHT || id == OLM_HAND_LEFT) && !npc.isDead()) {
                return true;
            }
        }

        return false;
    }

    private void updateFont() {
        //only perform anything within this function if any settings related to the font have changed
        if (!lastFont.equals(config.fontName()) || lastFontSize != config.fontSize() || lastFontStyle != config.fontStyle()) {
            if (config.customFont()) {
                lastFont = config.fontName();
            }
            lastFontSize = config.fontSize();
            lastFontStyle = config.fontStyle();

            //use runescape font as default
            if (config.fontName().equals("") || !config.customFont()) {
                if (config.fontSize() < 16) {
                    font = FontManager.getRunescapeSmallFont();
                } else if (config.fontStyle() == MonsterHPConfig.FontStyle.BOLD || config.fontStyle() == MonsterHPConfig.FontStyle.BOLD_ITALICS) {
                    font = FontManager.getRunescapeBoldFont();
                } else {
                    font = FontManager.getRunescapeFont();
                }

                if (config.fontSize() > 16) {
                    font = font.deriveFont((float) config.fontSize());
                }

                if (config.fontStyle() == MonsterHPConfig.FontStyle.BOLD) {
                    font = font.deriveFont(Font.BOLD);
                }
                if (config.fontStyle() == MonsterHPConfig.FontStyle.ITALICS) {
                    font = font.deriveFont(Font.ITALIC);
                }
                if (config.fontStyle() == MonsterHPConfig.FontStyle.BOLD_ITALICS) {
                    font = font.deriveFont(Font.ITALIC | Font.BOLD);
                }

                useRunescapeFont = true;
                return;
            }

            int style = Font.PLAIN;
            switch (config.fontStyle()) {
                case BOLD:
                    style = Font.BOLD;
                    break;
                case ITALICS:
                    style = Font.ITALIC;
                    break;
                case BOLD_ITALICS:
                    style = Font.BOLD | Font.ITALIC;
                    break;
            }

            font = new Font(config.fontName(), style, config.fontSize());
            useRunescapeFont = false;
        }
    }

    private void handleText(Graphics2D graphics, Point textLoc, String text, Color color)
    {
        switch (config.fontBackground())
        {
            case OUTLINE:
            {
                // Create a new Graphics2D instance to avoid modifying the original one
                Graphics2D g2d = (Graphics2D) graphics.create();

                // Enable antialiasing for smoother text (just to be sure)
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                // Translate the graphics
                g2d.translate(textLoc.getX(), textLoc.getY());

                // Set outline color
                g2d.setColor(config.fontOutlineColor());

                // Text layout
                TextLayout tl = new TextLayout(text, graphics.getFont(), g2d.getFontRenderContext());

                // Get the outline shape
                Shape shape = tl.getOutline(null);

                // Set outline thickness and try to prevent artifacts on sharp angles
                g2d.setStroke(new BasicStroke((float) config.fontOutlineSize(), BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));

                // Draw the outline
                g2d.draw(shape);

                // Set fill color
                g2d.setColor(color);

                // Fill the shape
                g2d.fill(shape);

                // Dispose of the temporary Graphics2D instance
                g2d.dispose();

                break;
            }
            case SHADOW:
            {
                int offsetShadow = config.fontShadowSize();

                graphics.setColor(new Color(0,0,0, color.getAlpha()));
                graphics.drawString(text, textLoc.getX() + offsetShadow, textLoc.getY() + offsetShadow);
                graphics.setColor(color);
                graphics.drawString(text, textLoc.getX(), textLoc.getY());
                break;
            }
            case OFF:
                // Mini shadow
                graphics.setColor(new Color(0,0,0, color.getAlpha()));
                graphics.drawString(text, textLoc.getX() + 1, textLoc.getY() + 1);

                // Draw string (renderTextLocation does not support alpha coloring or is broken...)
                graphics.setColor(color);
                graphics.drawString(text, textLoc.getX(), textLoc.getY());
                break;
            default:
                break;
        }
    }

    private Color getGradientHpColor(int currentHealth, int maxHealth) {
        // Ensure currentHealth is between 0 and maxHealth
        currentHealth = Math.min(maxHealth, Math.max(0, currentHealth));

        // Calculate the health percentage
        double healthPercentage = (double) currentHealth / maxHealth;

        // Get config RGB values
        Color colorA = config.gradientHPColorA();
        Color colorB = config.gradientHPColorB();

        // Calculate the gradient depending on percentage and RGB values
        int red = (int) (colorB.getRed() + (colorA.getRed() - colorB.getRed()) * healthPercentage);
        int green = (int) (colorB.getGreen() + (colorA.getGreen() - colorB.getGreen()) * healthPercentage);
        int blue = (int) (colorB.getBlue() + (colorA.getBlue() - colorB.getBlue()) * healthPercentage);

        return new Color(red, green, blue);
    }
}
package com.monsterhp;


import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.inject.Inject;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import net.runelite.client.util.WildcardMatcher;
import static net.runelite.api.gameval.NpcID.*;
import static net.runelite.api.gameval.VarbitID.*;

@Slf4j
@PluginDescriptor(
        name = "Monster HP Percentage"
)
public class MonsterHPPlugin extends Plugin {
    @Inject
    private Client client;

    @Inject
    private MonsterHPConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private MonsterHPOverlay monsterhpoverlay;

    @Inject
    private ClientThread clientThread;

    @Getter(AccessLevel.PACKAGE)
    private final Map<Integer, WanderingNPC> wanderingNPCs = new HashMap<>();

    private List<String> selectedNpcs = new ArrayList<>();

    private List<String> selectedNpcsWithRules = new ArrayList<>();

    private List<String> selectedNpcIDs = new ArrayList<>();

    private List<String> npcShowAllBlacklist = new ArrayList<>();

    private boolean npcShowAll = true;

    private HashMap<Integer, WorldPoint> npcLocations = new HashMap<>();

    @Provides
    MonsterHPConfig getConfig(ConfigManager configManager) {
        return configManager.getConfig(MonsterHPConfig.class);
    }

    @Override
    protected void startUp() throws Exception {
        overlayManager.add(monsterhpoverlay);
        selectedNpcs = getSelectedNpcNames(false);
        selectedNpcsWithRules = getSelectedNpcNames(true);
        selectedNpcIDs = getSelectedNpcIds();

        this.npcShowAll = config.npcShowAll();
        npcShowAllBlacklist = getShowAllBlacklistNames();

        clientThread.invokeLater(this::rebuildAllNpcs);
    }

    @Override
    protected void shutDown() throws Exception {
        overlayManager.remove(monsterhpoverlay);
        wanderingNPCs.clear();
        npcLocations.clear();
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned npcSpawned) {
        final NPC npc = npcSpawned.getNpc();
        if (!isNpcInList(npc)) return;

        WanderingNPC wnpc = new WanderingNPC(npc);

        if (isNpcNumericDefined(npc))
            wnpc.setIsTypeNumeric(1);

        Integer thresholdOverride = getNpcThreshold(npc);
        if (thresholdOverride != null)
            wnpc.setHealthThreshold(thresholdOverride);

        wanderingNPCs.put(npc.getIndex(), wnpc);
        npcLocations.put(npc.getIndex(), npc.getWorldLocation());
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned npcDespawned) {
        final NPC npc = npcDespawned.getNpc();

        if (npc == null || !isNpcInList(npc)) return;

        wanderingNPCs.remove(npc.getIndex());
        npcLocations.remove(npc.getIndex());
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN ||
            gameStateChanged.getGameState() == GameState.HOPPING) {
            wanderingNPCs.clear();
            npcLocations.clear();
        }
    }

    // onNpcChanged is mostly required for id listing to work when npc is changing id but name remain the same
    // Example: npcs like phantom muspah have multiple ids(transitions) but same static name
    // so this applies and removes the text accordingly on npc id change if in list
    @Subscribe
    public void onNpcChanged(NpcChanged e) {
        final NPC npc = e.getNpc();
        int id = npc.getId();
        int idx = npc.getIndex();

        // Duke Sucellus have no onNpcDespawned when dying but fires sometimes on instance leaving if npc is not dead but in 12167(DUKE_SUCELLUS_ASLEEP) state...
        // So we have to do this special little step
        if (id == DUKE_SUCELLUS_DEAD || id == DUKE_SUCELLUS_DEAD_QUEST) {
            wanderingNPCs.remove(idx);
            npcLocations.remove(idx);
        }

        // Actual method
        if (isNpcInList(npc)) {
            WanderingNPC wnpc = new WanderingNPC(npc);

            if (isNpcNumericDefined(npc))
                wnpc.setIsTypeNumeric(1);

            Integer thresholdOverride = getNpcThreshold(npc);
            if (thresholdOverride != null)
                wnpc.setHealthThreshold(thresholdOverride);

            wanderingNPCs.put(idx, wnpc);
            npcLocations.put(idx, npc.getWorldLocation());
        } else {
            wanderingNPCs.remove(idx);
            npcLocations.remove(idx);
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (!config.showOverlay()) {
            return;
        }

        HashMap<WorldPoint, Integer> locationCount = new HashMap<>();
        for (WorldPoint location : npcLocations.values()) {
            locationCount.merge(location, 1, Integer::sum);
        }

        for (NPC npc : client.getTopLevelWorldView().npcs()) {
            if (!isNpcInList(npc)) {
                continue;
            }

            final WanderingNPC wnpc = wanderingNPCs.get(npc.getIndex());

            if (wnpc != null) {
                updateWnpcProperties(npc, wnpc, locationCount);
            }
        }
    }

    private void updateWnpcProperties(NPC npc, WanderingNPC wnpc, Map<WorldPoint, Integer> locationCount) {
        // Runelite api npc actor method to calculate npc hp ratio
        double monsterHp = ((double) npc.getHealthRatio() / (double) npc.getHealthScale() * 100);

        // Without a jagex health api we have to use duct tape fixes.
        // Normally we'd just use getHealthRatio and getHealthScale, but for some NPCS like TOA raid bosses we have to use varbits
        boolean isBoss = BossUtil.isNpcBoss(npc);
        if (isBoss) {
            final int curHp = client.getVarbitValue(HPBAR_HUD_HP);
            final int maxHp = client.getVarbitValue(HPBAR_HUD_BASEHP);
            if (maxHp > 0 && curHp >= 0) {
                double hpVarbitRatio = 100.0 * curHp / maxHp;
                if (hpVarbitRatio > 0) {
                    monsterHp = hpVarbitRatio;
                }
            } else {
                // If we can't get data just don't update.
                return;
            }
        }

        // Doom of Mokhaiotl - Burrow or shielded transition support
        boolean isDoomBoss = BossUtil.DOOM_BOSS_IDS.contains(npc.getId());

        // Update WanderingNPC properties
        if (!npc.isDead() && ((npc.getHealthRatio() / npc.getHealthScale() != 1) || isDoomBoss)) {
            wnpc.setHealthRatio(monsterHp);
            wnpc.setCurrentLocation(npc.getWorldLocation());
            wnpc.setDead(false);

            WorldPoint currentLocation = wnpc.getCurrentLocation();

            if (locationCount.containsKey(currentLocation)) {
                wnpc.setOffset(locationCount.get(currentLocation) - 1);
                locationCount.put(currentLocation, locationCount.get(currentLocation) - 1);
            }
        } else if (npc.isDead()) {
            wnpc.setHealthRatio(0);
            if (config.hideDeath()) {
                wnpc.setDead(true);
            }
        }

        npcLocations.put(wnpc.getNpcIndex(), wnpc.getCurrentLocation());
    }

    private boolean isNpcNameInShowAllBlacklist(String npcName) {
        // Check for exact match or wildcard match
        return npcName != null && (npcShowAllBlacklist.contains(npcName) ||
                npcShowAllBlacklist.stream().anyMatch(pattern -> WildcardMatcher.matches(pattern, npcName)));
    }

    private boolean isNpcNameInList(String npcName) {
        // Check for exact match or wildcard match
        return npcName != null && (selectedNpcs.contains(npcName) ||
                selectedNpcs.stream().anyMatch(pattern -> WildcardMatcher.matches(pattern, npcName)));
    }

    private boolean isNpcIdInList(int npcId) {
        return selectedNpcIDs.contains(String.valueOf(npcId));
    }

    private boolean isNpcInList(NPC npc) {
        if (isNpcIdBlacklisted(npc)) return false;

        String npcName = npc.getName();
        String npcNameLower = npcName == null ? null : npcName.toLowerCase();

        boolean isInList = (isNpcNameInList(npcNameLower) || isNpcIdInList(npc.getId()));

        if (!isInList) {
            return this.npcShowAll && !isNpcNameInShowAllBlacklist(npcNameLower);
        }

        return true;
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        if (Objects.equals(configChanged.getGroup(), "MonsterHP") && (Objects.equals(configChanged.getKey(), "npcShowAll") || Objects.equals(configChanged.getKey(), "npcShowAllBlacklist") || Objects.equals(configChanged.getKey(), "npcToShowHp") || Objects.equals(configChanged.getKey(), "npcIdToShowHp"))) {
            selectedNpcs = getSelectedNpcNames(false);
            selectedNpcsWithRules = getSelectedNpcNames(true);
            selectedNpcIDs = getSelectedNpcIds();

            this.npcShowAll = config.npcShowAll();
            npcShowAllBlacklist = getShowAllBlacklistNames();

            clientThread.invokeLater(this::rebuildAllNpcs);
        }
    }

    List<String> getShowAllBlacklistNames() {
        String configNPCs = config.npcShowAllBlacklist().toLowerCase();
        return configNPCs.isEmpty() ? Collections.emptyList() : Text.fromCSV(configNPCs);
    }

    @VisibleForTesting
    List<String> getSelectedNpcNames(boolean includeRuleDisplay) {
        String configNPCs = config.npcToShowHp().toLowerCase();
        if (configNPCs.isEmpty()) {
            return Collections.emptyList();
        }

        // "Raw" contains the comma-separated RAW text, this includes npc rules like ":n"
        List<String> selectedNpcNamesRaw = Text.fromCSV(configNPCs);

        // If false, remove all rules from the string to create a list of only the NPC names
        if (!includeRuleDisplay) {
            List<String> strippedNpcNames = new ArrayList<>(selectedNpcNamesRaw);

            // Strips the rule suffixes from each name if present
            strippedNpcNames.replaceAll(npcName -> {
                if (!npcName.contains(":")) {
                    return npcName;
                }

                // Handle edge cases like "::" or ":::".. where split[0] would be empty or non-existent
                String[] parts = npcName.split(":");
                return parts.length > 0 && !parts[0].isEmpty() ? parts[0] : npcName;
            });

            return strippedNpcNames;
        }

        return selectedNpcNamesRaw;
    }

    @VisibleForTesting
    List<String> getSelectedNpcIds() {
        String configNPCIDs = config.npcIdToShowHp().toLowerCase();
        if (configNPCIDs.isEmpty()) {
            return Collections.emptyList();
        }

        return Text.fromCSV(configNPCIDs);
    }

    
    boolean isNpcNumericDefined(NPC npc) {
        String npcName = Objects.requireNonNull(npc.getName()).toLowerCase();
        for (String npcRaw : selectedNpcsWithRules) {
            NpcRule rule = getNpcRule(npcRaw);
            if (WildcardMatcher.matches(rule.namePattern, npcName)) {
                return rule.numeric;
            }
        }
        return false;
    }

    Integer getNpcThreshold(NPC npc) {
        String npcName = Objects.requireNonNull(npc.getName()).toLowerCase();
        for (String npcRaw : selectedNpcsWithRules) {
            NpcRule rule = getNpcRule(npcRaw);
            if (WildcardMatcher.matches(rule.namePattern, npcName)) {
                return rule.threshold;
            }
        }
        return null;
    }

    private void rebuildAllNpcs() {
        wanderingNPCs.clear();

        if (client.getGameState() != GameState.LOGGED_IN &&
            client.getGameState() != GameState.LOADING) {
            // NPCs are still in the client after logging out, ignore them
            return;
        }

        for (NPC npc : client.getTopLevelWorldView().npcs()) {
            if (isNpcInList(npc)) {
                WanderingNPC wnpc = new WanderingNPC(npc);

                if (isNpcNumericDefined(npc))
                    wnpc.setIsTypeNumeric(1);

                Integer thresholdOverride = getNpcThreshold(npc);
                if (thresholdOverride != null)
                    wnpc.setHealthThreshold(thresholdOverride);

                wanderingNPCs.put(npc.getIndex(), wnpc);
                npcLocations.put(npc.getIndex(), npc.getWorldLocation());
            }
        }
    }

    // Not to be confused with show all blacklist, this is for specific npc ids
    public boolean isNpcIdBlacklisted(NPC npc) {
        String npcName = npc.getName();
        if (npcName != null) {
            int id = npc.getId();

            switch (npcName) {
                case "Duke Sucellus": // duke sucellus - allow only fight id to be tracked from duke
                    return id != DUKE_SUCELLUS_AWAKE && id != DUKE_SUCELLUS_ASLEEP;
                case "Vardorvis":
                    return id == VARDORVIS_BASE_POSTQUEST; // Vardorvis outside instance.
                case "Akkha":
                    return id == AKKHA_SPAWN; // Pre-enter room idle Akkha id 11789
                case "Muttadile":
                    // On name tagging this is duplicating dogodile junior's hp to submerged version
                    // this is due to name matching, I doubt anybody want submerged version
                    return id == RAIDS_DOGODILE_SUBMERGED;
                case "Yama":
                    // Blacklist everything but Yama the boss
                    return id != YAMA;
                default:
                    return false;
            }
        }

        return false;
    }

    public static NpcRule getNpcRule(String npcRaw) {
        String[] parts = npcRaw.split(":");

        // Name should always be first part index e.g., 'Guard' from: 'Guard:n:10'.
        String name = (parts.length > 0 && !parts[0].isEmpty()) ? parts[0] : "";
        boolean numeric = false;
        Integer threshold = null;

        for (String s : parts) {
            if (s.equalsIgnoreCase("n")) {
                numeric = true;
            } else {
                try {
                    threshold = Integer.parseInt(s);
                }
                catch (NumberFormatException ignored) {} // ignore invalid parts
            }
        }

        return new NpcRule(name, numeric, threshold);
    }
}
package com.monsterhp;

public class NpcRule {
    public final String namePattern;
    public final boolean numeric;
    public final Integer threshold;

    public NpcRule(String namePattern, boolean numeric, Integer threshold) {
        this.namePattern = namePattern;
        this.numeric = numeric;
        this.threshold = threshold;
    }
}
package com.monsterhp;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;

public class WanderingNPC {
    @Getter
    private final int npcIndex;

    @Getter
    private final String npcName;

    @Getter
    private final int id;
    @Getter
    @Setter
    private NPC npc;

    @Getter
    @Setter
    private WorldPoint currentLocation;

    @Getter
    @Setter
    private double currentHp;

    @Getter
    @Setter
    private double healthRatio;

    @Getter
    @Setter
    private double healthScale;

    @Getter
    @Setter
    private boolean isDead;

    @Getter
    @Setter
    private int offset;

    @Getter
    @Setter
    private int isTypeNumeric;

    @Getter
    @Setter
    private int healthThreshold;

    WanderingNPC(NPC npc) {
        this.npc = npc;
        this.id = npc.getId();
        this.npcName = npc.getName();
        this.npcIndex = npc.getIndex();
        this.currentLocation = npc.getWorldLocation();
        this.currentHp = 100;
        this.healthRatio = 100;
        this.healthScale = npc.getHealthScale();
        this.isDead = false;
        this.offset = 0;
        this.isTypeNumeric = 0;
        this.healthThreshold = 0;
    }
}
package com.monsterhp;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MonsterHPPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MonsterHPPlugin.class);
		RuneLite.main(args);
	}
}
