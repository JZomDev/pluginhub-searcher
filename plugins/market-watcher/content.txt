package com.marketwatcher;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MarketWatcherPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MarketWatcherPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher;

import com.google.inject.Provides;
import com.marketwatcher.config.PricePeriodType;
import com.marketwatcher.config.MarketWatcherConfig;
import static com.marketwatcher.config.MarketWatcherConfig.AUTO_REFRESH_INTERVAL;
import static com.marketwatcher.config.MarketWatcherConfig.PRICE_PERIOD_ONE_QUANTITY;
import static com.marketwatcher.config.MarketWatcherConfig.PRICE_PERIOD_ONE_TYPE;
import static com.marketwatcher.config.MarketWatcherConfig.PRICE_PERIOD_THREE_QUANTITY;
import static com.marketwatcher.config.MarketWatcherConfig.PRICE_PERIOD_THREE_TYPE;
import static com.marketwatcher.config.MarketWatcherConfig.PRICE_PERIOD_TWO_QUANTITY;
import static com.marketwatcher.config.MarketWatcherConfig.PRICE_PERIOD_TWO_TYPE;
import com.marketwatcher.utilities.WikiItemDetails;
import com.marketwatcher.utilities.WikiRequestResult;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import javax.swing.*;

import com.marketwatcher.data.MarketWatcherItem;
import com.marketwatcher.data.MarketWatcherTab;
import com.marketwatcher.data.MarketWatcherTabDataManager;

import static com.marketwatcher.utilities.Constants.*;

import com.marketwatcher.ui.MarketWatcherPluginPanel;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import lombok.extern.slf4j.Slf4j;

import java.awt.image.BufferedImage;
import java.math.BigInteger;
import java.util.*;
import java.util.List;
import java.time.Instant;

import com.google.gson.Gson;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import lombok.Getter;
import lombok.Setter;
import net.runelite.client.util.LinkBrowser;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
@PluginDescriptor(
	name = PLUGIN_NAME
)
public class MarketWatcherPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "marketwatcher";
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private ItemManager itemManager;
	@Inject
	private ConfigManager configManager;
	@Inject
	private Gson gson;
	@Inject
	private MarketWatcherTabDataManager dataManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Getter
	@Setter
	private List<MarketWatcherItem> items = new ArrayList<>();

	@Getter
	@Setter
	private List<MarketWatcherTab> tabs = new ArrayList<>();

	@Getter
	@Setter
	Map<Integer, Map<String, String>> itemPriceMap = new HashMap<>();

	private OkHttpClient okHttpClient;
	private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

	private MarketWatcherPluginPanel panel;
	@Inject
	@Getter
	private MarketWatcherConfig config;

	private NavigationButton navButton;

	private boolean isActive;
	private static final String ADD_EDIT_TAB_MESSAGE = "Enter the name of this tab (30 chars max).";
	private static final String ADD_NEW_TAB_TITLE = "Add New Tab";
	private static final String EDIT_TAB_TITLE = "Edit Tab";

	public int configPricePeriodOneQty;
	public int configPricePeriodTwoQty;
	public int configPricePeriodThreeQty;

	public PricePeriodType configPeriodOneType;
	public PricePeriodType configPeriodTwoType;
	public PricePeriodType configPeriodThreeType;
	private final Runnable dataRefresh = this::refreshItemData;
	private ScheduledFuture<?> refreshHandler;
	private final ConcurrentHashMap.KeySetView<String, ?> pendingConfigChanges = ConcurrentHashMap.newKeySet();

	private HashMap<PricePeriodType, Integer> typeMap = new HashMap<PricePeriodType, Integer>();


	// Refresh item data. Every 12h by default.
	public void refreshItemData()
	{
		try
		{
			fetchItemData();
			clientThread.invokeLater(() -> dataManager.loadData());
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		}
		catch (Exception e)
		{
			System.out.println(e);
		}
		updateItemPrices();
	}

	// Retrieve item price histories for one week, month, and three months.
	// Store prices in a map to be accessed during search at any pointer later on.
	protected void fetchItemData() throws Exception
	{
		retrieveItemPriceHistories(configPeriodOneType, configPricePeriodOneQty, "period1");
		retrieveItemPriceHistories(configPeriodTwoType, configPricePeriodTwoQty, "period2");
		retrieveItemPriceHistories(configPeriodThreeType, configPricePeriodTwoQty, "period3");
	}

	@Override
	protected void startUp() throws Exception
	{
		updateCachedConfigs();

		typeMap.put(PricePeriodType.Days, UNIX_DAY);
		typeMap.put(PricePeriodType.Weeks, UNIX_WEEK);
		typeMap.put(PricePeriodType.Months, UNIX_MONTH);

		refreshHandler = scheduler.scheduleAtFixedRate(dataRefresh, 0, config.refreshInterval(), TimeUnit.HOURS);

		isActive = true;

		panel = injector.getInstance(MarketWatcherPluginPanel.class);

		final BufferedImage icon = ImageUtil.loadImageResource(MarketWatcherPlugin.class, PANEL_ICON_PATH);

		navButton = NavigationButton.builder().tooltip(PLUGIN_NAME).icon(icon).priority(11).panel(panel).build();

		clientToolbar.addNavigation(navButton);

		this.dataManager = new MarketWatcherTabDataManager(this, client, configManager, itemManager, gson);

		clientThread.invokeLater(() -> dataManager.loadData());
	}

	@Override
	protected void shutDown()
	{
		clientToolbar.removeNavigation(navButton);
		refreshHandler.cancel(true);
		isActive = false;
	}

	@Provides
	MarketWatcherConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(MarketWatcherConfig.class);
	}

	public void addItem(MarketWatcherItem item)
	{
		clientThread.invokeLater(() ->
		{
			if (!containsItem(item))
			{
				items.add(item);
				dataManager.saveData();
				processPendingConfigChanges();
				SwingUtilities.invokeLater(() ->
				{
					panel.switchToMarketWatch();
					panel.updateMarketWatchPanel();
				});
			}
			else
			{
				SwingUtilities.invokeLater(() -> panel.containsItemWarning());
			}
		});
	}

	public void removeItem(MarketWatcherItem item)
	{
		clientThread.invokeLater(() -> {
			items.remove(item);
			dataManager.saveData();
			processPendingConfigChanges();
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		});
	}

	public void addItemsToTab(MarketWatcherTab tab, List<String> itemNames)
	{
		clientThread.invokeLater(() -> {
			for (String itemName : itemNames)
			{
				MarketWatcherItem item = items.stream().filter(o -> o.getName().equals(itemName)).findFirst().orElse(null);
				tab.getItems().add(item);
				items.remove(item);
			}
			dataManager.saveData();
			processPendingConfigChanges();
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		});
	}

	public void removeItemFromTab(MarketWatcherTab tab, MarketWatcherItem item)
	{
		clientThread.invokeLater(() -> {
			tab.getItems().remove(item);
			items.add(item);
			dataManager.saveData();
			processPendingConfigChanges();
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		});
	}

	public void switchTabCollapse(MarketWatcherTab tab)
	{
		clientThread.invokeLater(() -> {
			tab.setCollapsed(!tab.isCollapsed());
			dataManager.saveData();
			processPendingConfigChanges();
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		});
	}

	public void addTab()
	{
		String name = JOptionPane.showInputDialog(panel, ADD_EDIT_TAB_MESSAGE, ADD_NEW_TAB_TITLE, JOptionPane.PLAIN_MESSAGE);

		if (name == null || name.isEmpty())
		{
			return;
		}

		if (name.length() > 30)
		{
			name = name.substring(0, 30);
		}

		String tabName = name;
		clientThread.invokeLater(() -> {
			MarketWatcherTab tab = new MarketWatcherTab(tabName, new ArrayList<>());

			if (!tabs.contains(tab))
			{
				tabs.add(tab);
				dataManager.saveData();
				processPendingConfigChanges();
				SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
			}
		});
	}

	public void showHelp()
	{
		processPendingConfigChanges();
		SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		JOptionPane.showMessageDialog(panel, "Each item displays price history with three price periods. Periods can be configured in plugin settings\nFor each time period, the price lows, mediums, and highs are color coded in rows. \nLows are the left number. Mediums are the center number. Highs are the right number.", "Information", JOptionPane.INFORMATION_MESSAGE);
	}

	public void shiftItem(int itemIndex, boolean shiftUp)
	{
		clientThread.invokeLater(() -> {
			MarketWatcherItem shiftedItem = items.get(itemIndex);

			// Out of bounds is checked before call in item panel
			if (shiftUp)
			{
				items.set(itemIndex, items.get(itemIndex - 1));
				items.set(itemIndex - 1, shiftedItem);
			}
			else
			{
				items.set(itemIndex, items.get(itemIndex + 1));
				items.set(itemIndex + 1, shiftedItem);
			}

			dataManager.saveData();
			processPendingConfigChanges();
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		});
	}

	public void shiftItemInTab(MarketWatcherTab tab, int itemIndex, boolean shiftUp)
	{
		clientThread.invokeLater(() -> {
			List<MarketWatcherItem> tabItems = tab.getItems();
			MarketWatcherItem shiftedItem = tab.getItems().get(itemIndex);

			// Out of bounds is checked before call in tab item panel
			if (shiftUp)
			{
				tabItems.set(itemIndex, tabItems.get(itemIndex - 1));
				tabItems.set(itemIndex - 1, shiftedItem);
			}
			else
			{
				tabItems.set(itemIndex, tabItems.get(itemIndex + 1));
				tabItems.set(itemIndex + 1, shiftedItem);
			}

			dataManager.saveData();
			processPendingConfigChanges();
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		});
	}

	public void removeTab(MarketWatcherTab tab)
	{
		clientThread.invokeLater(() -> {
			// Move items out of tab and delete
			items.addAll(tab.getItems());
			tabs.remove(tab);
			dataManager.saveData();
			processPendingConfigChanges();
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		});
	}

	public void updateItemPrices()
	{
		// Tab item prices
		for (MarketWatcherTab tab : tabs)
		{
			for (MarketWatcherItem item : tab.getItems())
			{
				item.setGePrice(itemManager.getItemPrice(item.getItemId()));
			}
		}

		// Individual prices
		for (MarketWatcherItem item : items)
		{
			item.setGePrice(itemManager.getItemPrice(item.getItemId()));
		}

		if (panel != null)
		{
			SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
		}
	}

	public void editTab(MarketWatcherTab tab)
	{
		String name = JOptionPane.showInputDialog(panel, ADD_EDIT_TAB_MESSAGE, EDIT_TAB_TITLE, JOptionPane.PLAIN_MESSAGE);

		if (name == null || name.isEmpty())
		{
			return;
		}

		if (name.length() > 30)
		{
			name = name.substring(0, 30);
		}

		String tabName = name;
		clientThread.invokeLater(() -> {
			MarketWatcherTab nameCheck = tabs.stream().filter(o -> o.getName().equals(tabName)).findFirst().orElse(null);

			if (nameCheck == null)
			{
				tab.setName(tabName);
				dataManager.saveData();
				processPendingConfigChanges();
				SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
			}
		});
	}

	public void openWikiPriceLink(int itemId)
	{
		final String url = OSRS_WIKI_ITEM_REQUEST_BASE_URL + itemId;
		LinkBrowser.browse(url);
	}

	private boolean containsItem(MarketWatcherItem newItem)
	{
		for (MarketWatcherTab tab : tabs)
		{
			if (tab.getItems().contains(newItem))
			{
				return true;
			}
		}
		return items.contains(newItem);
	}

	private void retrieveItemPriceHistories(PricePeriodType periodType, int periodQty, String periodNumber) throws Exception
	{
		String resp = EMPTY_STRING;

		long unixTimestamp = Instant.now().getEpochSecond();
		String unixTimeString = EMPTY_STRING;

		long periodDifference = (unixTimestamp - typeMap.get(periodType) * periodQty);

		long periodTimeBuffer = periodDifference % SECONDS_IN_SIX_HOURS;

		unixTimeString = String.valueOf(periodDifference - periodTimeBuffer);

		Request request = new Request.Builder()
			.url(OSRS_WIKI_PRICES_6H_REQUEST_URL + unixTimeString)
			.header("User-Agent", "Market Watcher Plugin")
			.build();

		okHttpClient = injector.getInstance(OkHttpClient.class);

		try (Response response = okHttpClient.newCall(request).execute())
		{
			resp = response.body().string();
		}
		catch (Exception e)
		{
			System.out.println(e);
		}

		WikiRequestResult wikiRequestResult = gson.fromJson(resp, WikiRequestResult.class);

		for (Map.Entry<Integer, WikiItemDetails> entry : wikiRequestResult.getData().entrySet())
		{
			String lowPrice = Integer.toString(entry.getValue().getAvgLowPrice());
			String medPrice = NOT_AVAILABLE;
			String highPrice = Integer.toString(entry.getValue().getAvgHighPrice());

			if (highPrice.equals("0"))
			{
				highPrice = NOT_AVAILABLE;
			}

			if (lowPrice.equals("0"))
			{
				lowPrice = NOT_AVAILABLE;
			}

			if (!highPrice.equals(NOT_AVAILABLE) && !lowPrice.equals(NOT_AVAILABLE))
			{
				BigInteger highPriceInteger = BigInteger.valueOf(Integer.parseInt(highPrice));
				BigInteger lowPriceInteger = BigInteger.valueOf(Integer.parseInt(lowPrice));

				medPrice = String.valueOf(highPriceInteger.add(lowPriceInteger).divide(new BigInteger("2")));
			}
			int currentID = entry.getKey();
			Map<String, String> timeFrameValuesMapping = itemPriceMap.get(currentID);

			if (timeFrameValuesMapping == null)
			{
				Map<String, String> timeFrameValues = new HashMap<>();
				timeFrameValues.put(periodNumber + LOW, lowPrice);
				timeFrameValues.put(periodNumber + MED, medPrice);
				timeFrameValues.put(periodNumber + HIGH, highPrice);
				itemPriceMap.put(currentID, timeFrameValues);
			}
			else
			{
				timeFrameValuesMapping.put(periodNumber + LOW, lowPrice);
				timeFrameValuesMapping.put(periodNumber + MED, medPrice);
				timeFrameValuesMapping.put(periodNumber + HIGH, highPrice);
			}

		}
	}

	private void updateCachedConfigs()
	{
		configPricePeriodOneQty = config.pricePeriodOneQty();
		configPricePeriodTwoQty = config.pricePeriodTwoQty();
		configPricePeriodThreeQty = config.pricePeriodThreeQty();

		configPeriodOneType = config.pricePeriodOneType();
		configPeriodTwoType = config.pricePeriodTwoType();
		configPeriodThreeType = config.pricePeriodThreeType();

	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		// Exit if the plugin is off or the config is unrelated to the plugin
		if (!isActive || !event.getGroup().equals(CONFIG_GROUP))
		{
			return;
		}

		pendingConfigChanges.add(event.getKey());
	}


	private void processPendingConfigChanges()
	{
		clientThread.invoke(() -> {
			if (pendingConfigChanges.isEmpty())
			{
				return;
			}

			try
			{
				synchronized (this)
				{
					updateCachedConfigs();

					log.debug("Processing {} pending Market Watcher config changes: {}", pendingConfigChanges.size(), pendingConfigChanges);

					boolean refetchData = false;


					for (String key : pendingConfigChanges)
					{
						switch (key)
						{
							case PRICE_PERIOD_ONE_QUANTITY:
							case PRICE_PERIOD_ONE_TYPE:
							case PRICE_PERIOD_TWO_QUANTITY:
							case PRICE_PERIOD_TWO_TYPE:
							case PRICE_PERIOD_THREE_QUANTITY:
							case PRICE_PERIOD_THREE_TYPE:
							case AUTO_REFRESH_INTERVAL:
								refetchData = true;
								break;
						}
					}

					if (refetchData)
					{
						scheduler.execute(dataRefresh);
						clientThread.invokeLater(() -> dataManager.loadData());
						SwingUtilities.invokeLater(() -> panel.updateMarketWatchPanel());
					}
				}
			}
			catch (Throwable ex)
			{
				log.error("Error while changing settings:", ex);
			}
			finally
			{
				pendingConfigChanges.clear();
			}
		});
	}
}

/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.data;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import static com.marketwatcher.utilities.Constants.NOT_AVAILABLE;

import net.runelite.client.util.AsyncBufferedImage;

@AllArgsConstructor
public class MarketWatcherItem implements Comparable<MarketWatcherItem>
{
	@Getter
	private AsyncBufferedImage image;

	@Getter
	private String name;

	@Getter
	private int itemId;

	@Getter
	@Setter
	private int gePrice;

	@Getter
	@Setter
	private String periodOneLow;
	@Getter
	@Setter
	private String periodOneMed;
	@Getter
	@Setter
	private String periodOneHigh;
	@Getter
	@Setter
	private String periodTwoLow;
	@Getter
	@Setter
	private String periodTwoMed;
	@Getter
	@Setter
	private String periodTwoHigh;
	@Getter
	@Setter
	private String periodThreeLow;
	@Getter
	@Setter
	private String periodThreeMed;
	@Getter
	@Setter
	private String periodThreeHigh;


	public MarketWatcherItem(AsyncBufferedImage itemImage, String itemName, int itemID, int itemPrice)
	{
		image = itemImage;
		name = itemName;
		itemId = itemID;
		gePrice = itemPrice;
		periodOneLow = NOT_AVAILABLE;
		periodOneMed = NOT_AVAILABLE;
		periodOneHigh = NOT_AVAILABLE;
		periodTwoLow = NOT_AVAILABLE;
		periodTwoMed = NOT_AVAILABLE;
		periodTwoHigh = NOT_AVAILABLE;
		periodThreeLow = NOT_AVAILABLE;
		periodThreeMed = NOT_AVAILABLE;
		periodThreeHigh = NOT_AVAILABLE;
	}

	@Override
	public boolean equals(Object obj)
	{
		if (!(obj instanceof MarketWatcherItem))
		{
			return false;
		}

		final MarketWatcherItem item = (MarketWatcherItem) obj;
		return item.getItemId() == this.itemId;
	}

	@Override
	public int compareTo(MarketWatcherItem other)
	{
		return Integer.compare(gePrice, other.getGePrice());
	}
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.data;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.List;

@AllArgsConstructor
public class MarketWatcherTab
{
	@Getter
	@Setter
	private String name;

	@Getter
	@Setter
	private boolean collapsed;

	@Getter
	private final List<MarketWatcherItem> items;

	public MarketWatcherTab(String name, List<MarketWatcherItem> items)
	{
		this.name = name;
		collapsed = false;
		this.items = items;
	}

	@Override
	public boolean equals(Object obj)
	{
		if (!(obj instanceof MarketWatcherTab))
		{
			return false;
		}

		final MarketWatcherTab tab = (MarketWatcherTab) obj;
		return tab.getName().equals(this.name);
	}
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.data;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class MarketWatcherTabData
{
	private String name;
	private boolean collapsed;
	private List<Integer> items;
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.data;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.marketwatcher.MarketWatcherPlugin;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

import javax.inject.Inject;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static com.marketwatcher.utilities.Constants.*;
import static com.marketwatcher.utilities.PriceUtils.createMarketWatchItemWithPriceMap;

@Slf4j
public class MarketWatcherTabDataManager
{
	private static final String CONFIG_KEY_ITEMIDS = "itemIds";
	private static final String CONFIG_KEY_TABS = "tabs";
	private static final String LOAD_ITEM_ERROR = "Exception occurred while loading items";
	private static final String LOAD_TAB_ERROR = "Exception occurred while loading tabs";
	private static final String EMPTY_ARRAY = "[]";
	private final MarketWatcherPlugin plugin;
	private final Client client;
	private final ConfigManager configManager;
	private final ItemManager itemManager;
	private final Gson gson;

	private List<Integer> itemIds = new ArrayList<>();
	private final Type itemsType = new TypeToken<ArrayList<Integer>>()
	{
	}.getType();

	private List<MarketWatcherTabData> tabs = new ArrayList<>();
	private final Type tabsType = new TypeToken<ArrayList<MarketWatcherTabData>>()
	{
	}.getType();

	@Inject
	public MarketWatcherTabDataManager(MarketWatcherPlugin plugin, Client client, ConfigManager configManager, ItemManager itemManager, Gson gson)
	{
		this.plugin = plugin;
		this.client = client;
		this.configManager = configManager;
		this.itemManager = itemManager;
		this.gson = gson;
	}

	public boolean loadData()
	{
		// Load later if not at login screen to prevent data loss
		if (client.getGameState().getState() < GameState.LOGIN_SCREEN.getState())
		{
			return false;
		}

		// Individual Items
		itemIds.clear();

		String itemsJson = configManager.getConfiguration(CONFIG_TAB, CONFIG_KEY_ITEMIDS);
		if (itemsJson == null || itemsJson.equals(EMPTY_ARRAY))
		{
			plugin.setItems(new ArrayList<>());
		}
		else
		{
			try
			{
				itemIds = gson.fromJson(itemsJson, itemsType);
				convertItems();
			}
			catch (Exception e)
			{
				log.error(LOAD_ITEM_ERROR, e);
				plugin.setItems(new ArrayList<>());
			}
		}

		// Tabs and their items
		tabs.clear();

		String tabsJson = configManager.getConfiguration(CONFIG_TAB, CONFIG_KEY_TABS);
		if (tabsJson == null || tabsJson.equals(EMPTY_ARRAY))
		{
			plugin.setTabs(new ArrayList<>());
		}
		else
		{
			try
			{
				tabs = gson.fromJson(tabsJson, tabsType);
				convertTabs();
			}
			catch (Exception e)
			{
				log.error(LOAD_TAB_ERROR, e);
				plugin.setTabs(new ArrayList<>());
			}
		}

		plugin.updateItemPrices();
		return true;
	}

	public void saveData()
	{
		// Individual Items
		itemIds.clear();

		for (MarketWatcherItem item : plugin.getItems())
		{
			itemIds.add(item.getItemId());
		}

		final String itemsJson = gson.toJson(itemIds);
		configManager.setConfiguration(CONFIG_TAB, CONFIG_KEY_ITEMIDS, itemsJson);

		// Tabs and their items
		tabs.clear();

		for (MarketWatcherTab tab : plugin.getTabs())
		{
			List<Integer> tabItems = new ArrayList<>();
			for (MarketWatcherItem item : tab.getItems())
			{
				tabItems.add(item.getItemId());
			}

			tabs.add(new MarketWatcherTabData(tab.getName(), tab.isCollapsed(), tabItems));
		}

		final String tabsJson = gson.toJson(tabs);
		configManager.setConfiguration(CONFIG_TAB, CONFIG_KEY_TABS, tabsJson);
	}

	private void convertItems()
	{
		List<MarketWatcherItem> watchItems = new ArrayList<>();

		for (Integer itemId : itemIds)
		{
			watchItems.add(convertIdToItem(itemId));
		}

		plugin.setItems(watchItems);
	}

	private void convertTabs()
	{
		List<MarketWatcherTab> watchTabs = new ArrayList<>();

		for (MarketWatcherTabData tab : tabs)
		{
			List<MarketWatcherItem> tabItems = new ArrayList<>();
			for (Integer itemId : tab.getItems())
			{
				tabItems.add(convertIdToItem(itemId));
			}

			watchTabs.add(new MarketWatcherTab(tab.getName(), tab.isCollapsed(), tabItems));
		}

		plugin.setTabs(watchTabs);
	}

	private MarketWatcherItem convertIdToItem(int itemId)
	{
		AsyncBufferedImage itemImage = itemManager.getImage(itemId);
		String itemName = itemManager.getItemComposition(itemId).getName();
		Map<String, String> itemPriceMap = plugin.getItemPriceMap().get(itemId);

		return createMarketWatchItemWithPriceMap(itemImage, itemName, itemId, 0, itemPriceMap);
	}
}
/*
 * Copyright (c) 2024, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.config;


import com.marketwatcher.MarketWatcherPlugin;
import com.marketwatcher.config.PricePeriodType;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(MarketWatcherPlugin.CONFIG_GROUP)
public interface MarketWatcherConfig extends Config
{
	@ConfigSection(
		name = "General",
		description = "General settings",
		position = 0
	)
	String generalSettings = "generalSettings";
	String AUTO_REFRESH_INTERVAL = "autoRefreshInterval";

	@ConfigItem(
		keyName = AUTO_REFRESH_INTERVAL,
		name = "Auto Refresh Interval",
		description = "Set a time to automatically refresh item prices.",
		position = 0,
		section = generalSettings
	)
	@Range(min = 6, max = 24)
	@Units(" hours")
	default int refreshInterval()
	{
		return 12;
	}

	String COLOR_BLIND_MODE = "colorBlindMode";

	@ConfigItem(
		keyName = COLOR_BLIND_MODE,
		name = "Color Blind Mode",
		description = "Colorblind friendly prices",
		position = 1,
		section = generalSettings
	)

	default boolean colorBlindMode()
	{
		return false;
	}


	String PRICE_PERIOD_ONE_QUANTITY = "pricePeriodOneQuantity";
	@ConfigSection(
		name = "Price Period 1",
		description = "First Price Period",
		position = 1
	)
	String pricePeriodOne = "pricePeriodOne";

	@ConfigItem(
		keyName = PRICE_PERIOD_ONE_QUANTITY,
		name = "Quantity",
		description = "Set the quantity for the first price period.",
		position = 0,
		section = pricePeriodOne
	)
	@Range(min = 1, max = 24)
	default int pricePeriodOneQty()
	{
		return 1;
	}

	String PRICE_PERIOD_ONE_TYPE = "pricePeriodOneType";

	@ConfigItem(
		keyName = PRICE_PERIOD_ONE_TYPE,
		name = "Type",
		description = "Set the first price period type.",
		position = 1,
		section = pricePeriodOne
	)
	default PricePeriodType pricePeriodOneType()
	{
		return PricePeriodType.Days;
	}

	String PRICE_PERIOD_TWO_QUANTITY = "pricePeriodTwoQuantity";
	@ConfigSection(
		name = "Price Period 2",
		description = "Second Price Period",
		position = 2
	)
	String pricePeriodTwo = "pricePeriodTwo";

	@ConfigItem(
		keyName = PRICE_PERIOD_TWO_QUANTITY,
		name = "Quantity",
		description = "Set the quantity for the second price period.",
		position = 0,
		section = pricePeriodTwo
	)
	@Range(min = 1, max = 24)
	default int pricePeriodTwoQty()
	{
		return 3;
	}

	String PRICE_PERIOD_TWO_TYPE = "pricePeriodTwoType";

	@ConfigItem(
		keyName = PRICE_PERIOD_TWO_TYPE,
		name = "Type",
		description = "Set the second price period type.",
		position = 1,
		section = pricePeriodTwo
	)
	default PricePeriodType pricePeriodTwoType()
	{
		return PricePeriodType.Weeks;
	}

	String PRICE_PERIOD_THREE_QUANTITY = "pricePeriodThreeQuantity";
	@ConfigSection(
		name = "Price Period 3",
		description = "Third Price Period",
		position = 2
	)
	String pricePeriodThree = "pricePeriodThree";

	@ConfigItem(
		keyName = PRICE_PERIOD_THREE_QUANTITY,
		name = "Quantity",
		description = "Set the quantity for the third price period.",
		position = 0,
		section = pricePeriodThree
	)
	@Range(min = 1, max = 24)
	default int pricePeriodThreeQty()
	{
		return 3;
	}

	String PRICE_PERIOD_THREE_TYPE = "pricePeriodThreeType";

	@ConfigItem(
		keyName = PRICE_PERIOD_THREE_TYPE,
		name = "Type",
		description = "Set the third price period type.",
		position = 1,
		section = pricePeriodThree
	)
	default PricePeriodType pricePeriodThreeType()
	{
		return PricePeriodType.Months;
	}

}

package com.marketwatcher.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum PricePeriodType
{
	Days,
	Weeks,
	Months
}

/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.ui;

import com.marketwatcher.MarketWatcherPlugin;
import com.marketwatcher.data.MarketWatcherTab;
import com.marketwatcher.data.MarketWatcherItem;

import static com.marketwatcher.utilities.Constants.*;
import static com.marketwatcher.utilities.PanelUtils.createRightPanel;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class MarketWatcherTabItemPanel extends JPanel
{
	private static final String REMOVE_TITLE = "Warning";
	private static final String REMOVE_MESSAGE = "Are you sure you want to remove this item from the tab?";
	private static final ImageIcon REMOVE_ICON;
	private static final ImageIcon REMOVE_HOVER_ICON;
	private static final ImageIcon SHIFT_UP_ICON;
	private static final ImageIcon SHIFT_UP_HOVER_ICON;
	private static final ImageIcon SHIFT_DOWN_ICON;
	private static final ImageIcon SHIFT_DOWN_HOVER_ICON;

	static
	{
		final BufferedImage removeImage = ImageUtil.loadImageResource(MarketWatcherPluginPanel.class, DELETE_ICON_PATH);
		REMOVE_ICON = new ImageIcon(removeImage);
		REMOVE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(removeImage, 0.53f));

		final BufferedImage shiftUpImage = ImageUtil.loadImageResource(MarketWatcherPlugin.class, SHIFT_UP_ICON_PATH);
		SHIFT_UP_ICON = new ImageIcon(shiftUpImage);
		SHIFT_UP_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(shiftUpImage, 0.53f));

		final BufferedImage shiftDownImage = ImageUtil.loadImageResource(MarketWatcherPlugin.class, SHIFT_DOWN_ICON_PATH);
		SHIFT_DOWN_ICON = new ImageIcon(shiftDownImage);
		SHIFT_DOWN_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(shiftDownImage, 0.53f));
	}

	MarketWatcherTabItemPanel(MarketWatcherPlugin plugin, MarketWatcherTab tab, MarketWatcherItem item)
	{
		setLayout(new BorderLayout(5, 0));
		setBorder(new EmptyBorder(5, 0, 5, 0));

		int itemIndex = tab.getItems().indexOf(item);
		int itemsSize = tab.getItems().size();

		JPanel rightPanel = createRightPanel(item, plugin, COMPACT);

		// Action Panel (Delete, Shift item)
		JPanel actionPanel = new JPanel(new BorderLayout());
		actionPanel.setBackground(new Color(0, 0, 0, 0));
		actionPanel.setOpaque(false);

		// Delete Item
		JLabel deleteItem = new JLabel(REMOVE_ICON);
		deleteItem.setBorder(new EmptyBorder(0, 0, 0, 5));
		deleteItem.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (removeConfirm())
				{
					plugin.removeItemFromTab(tab, item);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				deleteItem.setIcon(REMOVE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				deleteItem.setIcon(REMOVE_ICON);
			}
		});
		actionPanel.add(deleteItem, BorderLayout.NORTH);

		// Shift Item Panel
		JPanel shiftItemPanel = new JPanel(new BorderLayout());
		shiftItemPanel.setOpaque(false);

		// Shift item up
		JLabel shiftUp = new JLabel(SHIFT_UP_ICON);
		shiftUp.setBorder(new EmptyBorder(0, 0, 15, 5));

		if (itemIndex == 0)
		{
			shiftUp.setIcon(SHIFT_UP_HOVER_ICON);
		}

		shiftUp.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (itemIndex != 0)
				{
					plugin.shiftItemInTab(tab, itemIndex, true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				shiftUp.setIcon(SHIFT_UP_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (itemIndex != 0)
				{
					shiftUp.setIcon(SHIFT_UP_ICON);
				}
			}
		});
		shiftItemPanel.add(shiftUp, BorderLayout.NORTH);

		// Shift item down
		JLabel shiftDown = new JLabel(SHIFT_DOWN_ICON);
		shiftDown.setBorder(new EmptyBorder(15, 0, 20, 5));

		if (itemIndex == itemsSize - 1)
		{
			shiftDown.setIcon(SHIFT_DOWN_HOVER_ICON);
		}

		shiftDown.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (itemIndex != itemsSize - 1)
				{
					plugin.shiftItemInTab(tab, itemIndex, false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				shiftDown.setIcon(SHIFT_DOWN_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (itemIndex != itemsSize - 1)
				{
					shiftDown.setIcon(SHIFT_DOWN_ICON);
				}
			}
		});
		shiftItemPanel.add(shiftDown, BorderLayout.EAST);

		actionPanel.add(shiftItemPanel, BorderLayout.SOUTH);

		add(rightPanel, BorderLayout.WEST);
		add(actionPanel, BorderLayout.EAST);
	}

	private boolean removeConfirm()
	{
		int confirm = JOptionPane.showConfirmDialog(this,
			REMOVE_MESSAGE, REMOVE_TITLE, JOptionPane.YES_NO_OPTION);

		return confirm == JOptionPane.YES_NO_OPTION;
	}

	@Override
	protected void paintComponent(Graphics g)
	{
		g.setColor(ColorScheme.DARK_GRAY_COLOR);
		g.fillRect(0, 0, this.getWidth(), this.getHeight());
	}

}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.ui;

import com.google.common.base.Strings;
import com.marketwatcher.MarketWatcherPlugin;
import com.marketwatcher.data.MarketWatcherItem;
import com.marketwatcher.data.MarketWatcherTab;

import static com.marketwatcher.utilities.Constants.*;
import static com.marketwatcher.utilities.PriceUtils.createMarketWatchItemWithPriceMap;

import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.item.ItemPrice;
import net.runelite.client.game.ItemManager;

import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.ImageIcon;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class MarketWatcherPluginPanel extends PluginPanel
{
	private final MarketWatcherPlugin plugin;
	private final ClientThread clientThread;
	private final RuneLiteConfig runeLiteConfig;
	private final ItemManager itemManager;

	private static final int MAX_SEARCH_ITEMS = 100;

	private static final String MARKET_WATCH_PANEL = "MARKET_WATCH_PANEL";
	private static final String SEARCH_PANEL = "SEARCH_PANEL";
	private static final String RESULTS_PANEL = "RESULTS_PANEL";
	private static final String ERROR_PANEL = "ERROR_PANEL";

	private static final String PANEL_TITLE = "Market Watcher";
	private static final String GE_SEARCH_TITLE = "Grand Exchange Search";
	private static final String CONTAINS_ITEM_TITLE = "Info";
	private static final String SEARCH_PROMPT = "Search for an item to select";
	private static final String INFO_TOOLTIP = "Information";
	private static final String ADD_ITEM_TOOLTIP = "Add an item from the Grand Exchange";
	private static final String ADD_TAB_ITEM_TOOLTIP = "Add an item tab";
	private static final String CONTAINS_ITEM_MESSAGE = "This item is already being tracked.";
	private static final String SEARCH_ERROR = "No results found.";
	private static final String SEARCH_ERROR_MESSAGE = "No items were found with that name, please try again.";
	private static final String CANCEL = "Cancel";
	private static final ImageIcon INFO_ICON;
	private static final ImageIcon INFO_HOVER_ICON;
	private static final ImageIcon ADD_ICON;
	private static final ImageIcon ADD_HOVER_ICON;

	private static final ImageIcon ADD_TAB_ICON;

	private static final ImageIcon ADD_TAB_HOVER_ICON;

	private static final ImageIcon CANCEL_ICON;
	private static final ImageIcon CANCEL_HOVER_ICON;
	private final JLabel cancelItem = new JLabel(CANCEL_ICON);

	private final CardLayout centerCard = new CardLayout();
	private final CardLayout searchCard = new CardLayout();

	private final JPanel centerPanel = new JPanel(centerCard);
	private final JPanel marketWatcherPanel = new JPanel(new BorderLayout());
	private final JPanel titlePanel = new JPanel(new BorderLayout());
	private final JPanel searchPanel = new JPanel(new BorderLayout());
	private final JPanel searchCenterPanel = new JPanel(searchCard);
	private final JPanel searchResultsPanel = new JPanel();
	private final JPanel marketWatcherItemsPanel = new JPanel();
	private final IconTextField searchBar = new IconTextField();
	private final PluginErrorPanel searchErrorPanel = new PluginErrorPanel();
	private final GridBagConstraints constraints = new GridBagConstraints();
	private final JLabel title = new JLabel();
	private final JPanel actionPanel = new JPanel(new BorderLayout());
	private final JLabel information = new JLabel(INFO_ICON);
	private final JLabel addTabItem = new JLabel(ADD_TAB_ICON);
	private final JLabel addItem = new JLabel(ADD_ICON);

	private final List<MarketWatcherItem> searchItems = new ArrayList<>();

	static
	{
		final BufferedImage infoImage = ImageUtil.loadImageResource(MarketWatcherPluginPanel.class, INFO_ICON_PATH);
		INFO_ICON = new ImageIcon(infoImage);
		INFO_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(infoImage, 0.53f));

		final BufferedImage addImage = ImageUtil.loadImageResource(MarketWatcherPluginPanel.class, ADD_ICON_PATH);
		ADD_ICON = new ImageIcon(addImage);
		ADD_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addImage, 0.53f));

		final BufferedImage addTabImage = ImageUtil.loadImageResource(MarketWatcherPluginPanel.class, ADD_TAB_ICON_PATH);
		ADD_TAB_ICON = new ImageIcon(addTabImage);
		ADD_TAB_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addTabImage, 0.53f));

		final BufferedImage cancelImage = ImageUtil.loadImageResource(MarketWatcherPluginPanel.class, CANCEL_ICON_PATH);
		CANCEL_ICON = new ImageIcon(cancelImage);
		CANCEL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(cancelImage, 0.53f));
	}


	@Inject
	MarketWatcherPluginPanel(MarketWatcherPlugin plugin, ClientThread clientThread, RuneLiteConfig runeLiteConfig, ItemManager itemManager) throws IOException
	{
		super(false);
		this.plugin = plugin;
		this.clientThread = clientThread;
		this.runeLiteConfig = runeLiteConfig;
		this.itemManager = itemManager;

		setLayout(new BorderLayout());
		JPanel container = new JPanel(new BorderLayout());
		container.setBorder(new EmptyBorder(10, 10, 10, 10));

		title.setText(PANEL_TITLE);
		title.setForeground(Color.WHITE);
		title.setBorder(new EmptyBorder(0, 0, 0, 0));
		title.setPreferredSize(new Dimension(100, 10));

		JPanel actions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 3));


		// Info Button
		information.setToolTipText(INFO_TOOLTIP);
		information.setBorder(new EmptyBorder(0, 0, 0, 10));
		information.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				plugin.showHelp();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				information.setIcon(INFO_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				information.setIcon(INFO_ICON);
			}
		});

		actionPanel.add(information, BorderLayout.LINE_START);

		// Add Tab Button
		addTabItem.setToolTipText(ADD_TAB_ITEM_TOOLTIP);
		addTabItem.setBorder(new EmptyBorder(0, 0, 0, 10));
		addTabItem.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				plugin.addTab();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				addTabItem.setIcon(ADD_TAB_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				addTabItem.setIcon(ADD_TAB_ICON);
			}
		});
		actionPanel.add(addTabItem, BorderLayout.CENTER);

		// Add Item Button
		addItem.setToolTipText(ADD_ITEM_TOOLTIP);
		addItem.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				switchToSearch();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				addItem.setIcon(ADD_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				addItem.setIcon(ADD_ICON);
			}
		});

		actionPanel.add(addItem, BorderLayout.LINE_END);

		actions.add(actionPanel);

		// Cancel Button
		cancelItem.setToolTipText(CANCEL);
		cancelItem.setVisible(false);
		cancelItem.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				switchToMarketWatch();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				cancelItem.setIcon(CANCEL_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				cancelItem.setIcon(CANCEL_ICON);
			}
		});
		actions.add(cancelItem);

		titlePanel.setBorder(new EmptyBorder(0, 0, 10, 0));
		titlePanel.add(title, BorderLayout.LINE_START);
		titlePanel.add(actions, BorderLayout.LINE_END);

		// Market Watch Items Panel
		marketWatcherItemsPanel.setLayout(new GridBagLayout());

		JPanel pWrapper = new JPanel(new BorderLayout());
		pWrapper.add(marketWatcherItemsPanel, BorderLayout.NORTH);

		JScrollPane marketWrapper = new JScrollPane(pWrapper);
		marketWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		marketWrapper.setBorder(new EmptyBorder(5, 0, 0, 0));
		marketWrapper.getVerticalScrollBar().setPreferredSize(new Dimension(12, 0));
		marketWrapper.getVerticalScrollBar().setBorder(new EmptyBorder(5, 5, 0, 0));

		// Market Watch Panel
		marketWatcherPanel.add(marketWrapper, BorderLayout.CENTER);

		// Search Results Panel
		searchResultsPanel.setLayout(new GridBagLayout());

		JPanel searchResultsWrapper = new JPanel(new BorderLayout());
		searchResultsWrapper.add(searchResultsPanel, BorderLayout.NORTH);

		JScrollPane resultsWrapper = new JScrollPane(searchResultsWrapper);
		resultsWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);
		resultsWrapper.setBorder(new EmptyBorder(5, 0, 0, 0));
		resultsWrapper.getVerticalScrollBar().setPreferredSize(new Dimension(12, 0));
		resultsWrapper.getVerticalScrollBar().setBorder(new EmptyBorder(5, 5, 0, 0));

		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.gridwidth = 1;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		// Search Error Panel
		searchErrorPanel.setContent(GE_SEARCH_TITLE,
			SEARCH_PROMPT);

		JPanel errorWrapper = new JPanel(new BorderLayout());
		errorWrapper.add(searchErrorPanel, BorderLayout.NORTH);

		// Search Center Panel
		searchCenterPanel.add(resultsWrapper, RESULTS_PANEL);
		searchCenterPanel.add(errorWrapper, ERROR_PANEL);
		searchCard.show(searchCenterPanel, ERROR_PANEL);

		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 15, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.addClearListener(this::searchForItems);
		searchBar.addKeyListener(new KeyListener()
		{
			@Override
			public void keyTyped(KeyEvent e)
			{
			}

			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					searchForItems();
				}
			}

			@Override
			public void keyReleased(KeyEvent e)
			{
			}
		});

		// Search Panel
		searchPanel.add(searchBar, BorderLayout.NORTH);
		searchPanel.add(searchCenterPanel, BorderLayout.CENTER);

		// Center Panel
		centerPanel.add(marketWatcherPanel, MARKET_WATCH_PANEL);
		centerPanel.add(searchPanel, SEARCH_PANEL);
		centerCard.show(centerPanel, MARKET_WATCH_PANEL);

		container.add(titlePanel, BorderLayout.NORTH);
		container.add(centerPanel, BorderLayout.CENTER);
		add(container, BorderLayout.CENTER);
	}

	public void switchToMarketWatch()
	{
		cancelItem.setVisible(false);
		actionPanel.setVisible(true);
		centerCard.show(centerPanel, MARKET_WATCH_PANEL);
	}

	private void switchToSearch()
	{
		actionPanel.setVisible(false);
		cancelItem.setVisible(true);
		centerCard.show(centerPanel, SEARCH_PANEL);
	}

	private void searchForItems()
	{
		String lookup = searchBar.getText();
		searchResultsPanel.removeAll();
		if (Strings.isNullOrEmpty(lookup))
		{
			searchResultsPanel.removeAll();
			SwingUtilities.invokeLater(searchResultsPanel::updateUI);
			return;
		}

		List<ItemPrice> results = itemManager.search(searchBar.getText());
		if (results.isEmpty())
		{
			searchErrorPanel.setContent(SEARCH_ERROR, SEARCH_ERROR_MESSAGE);
			searchCard.show(searchCenterPanel, ERROR_PANEL);
			return;
		}

		clientThread.invokeLater(() -> processResults(results));


	}


	private void processResults(List<ItemPrice> results)
	{
		searchItems.clear();
		searchCard.show(searchCenterPanel, RESULTS_PANEL);

		int count = 0;
		boolean useActivelyTradedPrice = runeLiteConfig.useWikiItemPrices();

		// Add each result to items list
		for (ItemPrice item : results)
		{
			if (count++ > MAX_SEARCH_ITEMS)
			{
				break;
			}

			int itemId = item.getId();
			AsyncBufferedImage itemImage = itemManager.getImage(itemId);
			int itemPrice = useActivelyTradedPrice ? itemManager.getWikiPrice(item) : item.getPrice();

			Map<String, String> itemPriceMap = plugin.getItemPriceMap().get(itemId);

			MarketWatcherItem resultItem = createMarketWatchItemWithPriceMap(itemImage, item.getName(), itemId, itemPrice, itemPriceMap);

			searchItems.add(resultItem);
		}

		// Add each item in list to panel
		SwingUtilities.invokeLater(() ->
		{
			int index = 0;
			for (MarketWatcherItem item : searchItems)
			{
				MarketWatcherTabResultPanel panel = new MarketWatcherTabResultPanel(plugin, item);

				if (index++ > 0)
				{
					searchResultsPanel.add(createMarginWrapper(panel), constraints);
				}
				else
				{
					searchResultsPanel.add(panel, constraints);
				}

				constraints.gridy++;
			}

			validate();
		});
	}

	public void updateMarketWatchPanel()
	{
		marketWatcherItemsPanel.removeAll();

		constraints.gridy++;

		int index = 0;

		// Tabs
		for (MarketWatcherTab tab : plugin.getTabs())
		{
			MarketWatcherTabPanel panel = new MarketWatcherTabPanel(plugin, this, tab);

			if (index++ > 0)
			{
				marketWatcherItemsPanel.add(createMarginWrapper(panel), constraints);
			}
			else
			{
				marketWatcherItemsPanel.add(panel, constraints);
			}

			constraints.gridy++;
		}

		// Individual items
		for (MarketWatcherItem item : plugin.getItems())
		{
			MarketWatcherItemPanel panel = new MarketWatcherItemPanel(plugin, item);

			if (index++ > 0)
			{
				marketWatcherItemsPanel.add(createMarginWrapper(panel), constraints);
			}
			else
			{
				marketWatcherItemsPanel.add(panel, constraints);
			}

			constraints.gridy++;
		}

		validate();
	}

	public void containsItemWarning()
	{
		JOptionPane.showConfirmDialog(this,
			CONTAINS_ITEM_MESSAGE, CONTAINS_ITEM_TITLE, JOptionPane.DEFAULT_OPTION);
	}

	private JPanel createMarginWrapper(JPanel panel)
	{
		JPanel marginWrapper = new JPanel(new BorderLayout());
		marginWrapper.setBorder(new EmptyBorder(5, 0, 0, 0));
		marginWrapper.add(panel, BorderLayout.NORTH);
		return marginWrapper;
	}
}

/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.ui;

import com.marketwatcher.data.MarketWatcherItem;
import com.marketwatcher.MarketWatcherPlugin;

import static com.marketwatcher.utilities.Constants.GP;
import static com.marketwatcher.utilities.Constants.NOT_AVAILABLE;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

public class MarketWatcherTabResultPanel extends JPanel
{
	private static final Dimension IMAGE_SIZE = new Dimension(32, 32);

	MarketWatcherTabResultPanel(MarketWatcherPlugin plugin, MarketWatcherItem item)
	{
		setLayout(new BorderLayout(5, 0));
		setToolTipText(item.getName());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		Color background = getBackground();
		List<JPanel> panels = new ArrayList<>();
		panels.add(this);

		MouseAdapter itemPanelMouseListener = new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				plugin.addItem(item);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				for (JPanel panel : panels)
				{
					panel.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
				}
				setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				for (JPanel panel : panels)
				{
					panel.setBackground(background);
				}
				setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		};

		addMouseListener(itemPanelMouseListener);
		setBorder(new EmptyBorder(5, 5, 5, 0));

		// Image
		JLabel itemImage = new JLabel();
		itemImage.setPreferredSize(IMAGE_SIZE);
		if (item.getImage() != null)
		{
			item.getImage().addTo(itemImage);
		}
		add(itemImage, BorderLayout.LINE_START);

		// Item Details Panel
		JPanel rightPanel = new JPanel(new GridLayout(2, 1));
		panels.add(rightPanel);
		rightPanel.setBackground(background);

		// Item Name
		JLabel itemName = new JLabel();
		itemName.setForeground(Color.WHITE);
		itemName.setMaximumSize(new Dimension(0, 0));
		itemName.setPreferredSize(new Dimension(0, 0));
		itemName.setText(item.getName());
		rightPanel.add(itemName);

		// GE Price
		JLabel gePriceLabel = new JLabel();
		if (item.getGePrice() > 0)
		{
			gePriceLabel.setText(QuantityFormatter.formatNumber(item.getGePrice()) + GP);
		}
		else
		{
			gePriceLabel.setText(NOT_AVAILABLE);
		}
		gePriceLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		rightPanel.add(gePriceLabel);

		add(rightPanel, BorderLayout.CENTER);
	}
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.ui;

import com.marketwatcher.MarketWatcherPlugin;
import com.marketwatcher.data.MarketWatcherItem;

import static com.marketwatcher.utilities.Constants.*;
import static com.marketwatcher.utilities.PanelUtils.createRightPanel;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class MarketWatcherItemPanel extends JPanel
{
	private static final String DELETE_TITLE = "Warning";
	private static final String DELETE_MESSAGE = "Are you sure you want to delete this item?";
	private static final ImageIcon DELETE_ICON;
	private static final ImageIcon DELETE_HOVER_ICON;
	private static final ImageIcon SHIFT_UP_ICON;
	private static final ImageIcon SHIFT_UP_HOVER_ICON;
	private static final ImageIcon SHIFT_DOWN_ICON;
	private static final ImageIcon SHIFT_DOWN_HOVER_ICON;

	static
	{
		final BufferedImage deleteImage = ImageUtil.loadImageResource(MarketWatcherItemPanel.class, DELETE_ICON_PATH);
		DELETE_ICON = new ImageIcon(deleteImage);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImage, 0.53f));

		final BufferedImage shiftUpImage = ImageUtil.loadImageResource(MarketWatcherItemPanel.class, SHIFT_UP_ICON_PATH);
		SHIFT_UP_ICON = new ImageIcon(shiftUpImage);
		SHIFT_UP_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(shiftUpImage, 0.53f));

		final BufferedImage shiftDownImage = ImageUtil.loadImageResource(MarketWatcherItemPanel.class, SHIFT_DOWN_ICON_PATH);
		SHIFT_DOWN_ICON = new ImageIcon(shiftDownImage);
		SHIFT_DOWN_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(shiftDownImage, 0.53f));
	}

	MarketWatcherItemPanel(MarketWatcherPlugin plugin, MarketWatcherItem item)
	{
		setLayout(new BorderLayout(5, 0));
		setBorder(new EmptyBorder(5, 5, 5, 0));

		int itemIndex = plugin.getItems().indexOf(item);
		int itemsSize = plugin.getItems().size();

		JPanel rightPanel = createRightPanel(item, plugin, STANDARD);

		// Action Panel (Delete, Shift item)
		JPanel actionPanel = new JPanel(new BorderLayout());
		actionPanel.setBackground(new Color(0, 0, 0, 0));
		actionPanel.setOpaque(false);

		// Delete Item
		JLabel deleteItem = new JLabel(DELETE_ICON);
		deleteItem.setBorder(new EmptyBorder(0, 0, 0, 3));
		deleteItem.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (deleteConfirm())
				{
					plugin.removeItem(item);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				deleteItem.setIcon(DELETE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				deleteItem.setIcon(DELETE_ICON);
			}
		});
		actionPanel.add(deleteItem, BorderLayout.NORTH);

		// Shift Item Panel
		JPanel shiftItemPanel = new JPanel(new BorderLayout());
		shiftItemPanel.setOpaque(false);

		// Shift item up
		JLabel shiftUp = new JLabel(SHIFT_UP_ICON);
		shiftUp.setBorder(new EmptyBorder(0, 0, 15, 5));

		if (itemIndex == 0)
		{
			shiftUp.setIcon(SHIFT_UP_HOVER_ICON);
		}

		shiftUp.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (itemIndex != 0)
				{
					plugin.shiftItem(itemIndex, true);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				shiftUp.setIcon(SHIFT_UP_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (itemIndex != 0)
				{
					shiftUp.setIcon(SHIFT_UP_ICON);
				}
			}
		});
		shiftItemPanel.add(shiftUp, BorderLayout.NORTH);

		// Shift item down
		JLabel shiftDown = new JLabel(SHIFT_DOWN_ICON);
		shiftDown.setBorder(new EmptyBorder(15, 0, 20, 5));

		if (itemIndex == itemsSize - 1)
		{
			shiftDown.setIcon(SHIFT_DOWN_HOVER_ICON);
		}

		shiftDown.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (itemIndex != itemsSize - 1)
				{
					plugin.shiftItem(itemIndex, false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				shiftDown.setIcon(SHIFT_DOWN_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (itemIndex != itemsSize - 1)
				{
					shiftDown.setIcon(SHIFT_DOWN_ICON);
				}
			}
		});
		shiftItemPanel.add(shiftDown, BorderLayout.EAST);
		actionPanel.add(shiftItemPanel, BorderLayout.SOUTH);

		add(rightPanel, BorderLayout.WEST);
		add(actionPanel, BorderLayout.EAST);
	}

	private boolean deleteConfirm()
	{
		int confirm = JOptionPane.showConfirmDialog(this,
			DELETE_MESSAGE, DELETE_TITLE, JOptionPane.YES_NO_OPTION);

		return confirm == JOptionPane.YES_NO_OPTION;
	}


	@Override
	protected void paintComponent(Graphics g)
	{
		g.setColor(ColorScheme.DARKER_GRAY_COLOR);
		g.fillRect(0, 0, this.getWidth(), this.getHeight());
	}

}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.ui;

import net.runelite.client.ui.ColorScheme;

import javax.swing.DefaultListCellRenderer;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.List;

public class MarketWatcherSelectionPanel
{
	private final JList<String> list;
	private ActionListener okEvent;
	private final JDialog dialog;
	private static final String OK = "Ok";
	private static final String CANCEL = "Cancel";
	private static final String TITLE = "Select Items";
	private static final String MESSAGE = "Select items to add to this tab";
	private static final String SUBMESSAGE = "Ctrl+Click to select multiple items";

	public MarketWatcherSelectionPanel(JPanel parent, String[] options)
	{
		this.list = new JList<>(options);
		this.list.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Top Panel
		JPanel topPanel = new JPanel(new BorderLayout());

		JLabel message = new JLabel(MESSAGE);
		message.setHorizontalAlignment(SwingConstants.CENTER);
		JLabel subMessage = new JLabel(SUBMESSAGE);
		subMessage.setHorizontalAlignment(SwingConstants.CENTER);

		topPanel.add(message, BorderLayout.NORTH);
		topPanel.add(subMessage, BorderLayout.CENTER);

		// Center Panel with Items
		JPanel centerPanel = new JPanel(new BorderLayout(5, 5));
		centerPanel.setPreferredSize(new Dimension(250, 300));

		DefaultListCellRenderer renderer = (DefaultListCellRenderer) list.getCellRenderer();
		renderer.setHorizontalAlignment(SwingConstants.CENTER);

		JScrollPane scrollPane = new JScrollPane();
		scrollPane.setViewportView(list);

		centerPanel.add(topPanel, BorderLayout.NORTH);
		centerPanel.add(scrollPane, BorderLayout.CENTER);

		// Options
		JOptionPane optionPane = new JOptionPane(centerPanel);

		JButton okButton = new JButton(OK);
		okButton.addActionListener(this::onOkButtonClick);

		JButton cancelButton = new JButton(CANCEL);
		cancelButton.addActionListener(this::onCancelButtonClick);

		optionPane.setOptions(new Object[]{okButton, cancelButton});

		dialog = optionPane.createDialog(parent, TITLE);
		dialog.setTitle(TITLE);
	}

	public List<String> getSelectedItems()
	{
		return list.getSelectedValuesList();
	}

	public void setOnOk(ActionListener event)
	{
		okEvent = event;
	}

	private void onOkButtonClick(ActionEvent e)
	{
		if (okEvent != null)
		{
			okEvent.actionPerformed(e);
		}
		dialog.setVisible(false);
	}

	private void onCancelButtonClick(ActionEvent e)
	{
		dialog.setVisible(false);
	}

	public void show()
	{
		dialog.setVisible(true);
	}
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.ui;

import com.marketwatcher.MarketWatcherPlugin;
import com.marketwatcher.data.MarketWatcherTab;
import com.marketwatcher.data.MarketWatcherItem;

import static com.marketwatcher.utilities.Constants.*;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.List;

public class MarketWatcherTabPanel extends JPanel
{
	private static final String DELETE_TITLE = "Delete Tab";
	private static final String DELETE_MESSAGE = "Are you sure you want to delete this tab? This will not delete the items.";
	private static final ImageIcon ADD_ICON;
	private static final ImageIcon ADD_HOVER_ICON;
	private static final ImageIcon EDIT_ICON;
	private static final ImageIcon EDIT_HOVER_ICON;
	private static final ImageIcon DELETE_TAB_ICON;
	private static final ImageIcon DELETE_TAB_HOVER_ICON;
	private static final ImageIcon COLLAPSED_ICON;
	private static final ImageIcon COLLAPSED_HOVER_ICON;
	private static final ImageIcon UNCOLLAPSED_ICON;
	private static final ImageIcon UNCOLLAPSED_HOVER_ICON;
	private final boolean collapsed;

	static
	{
		final BufferedImage addImage = ImageUtil.loadImageResource(MarketWatcherPlugin.class, ADD_TAB_ITEM_ICON_PATH);
		ADD_ICON = new ImageIcon(ImageUtil.alphaOffset(addImage, 0.53f));
		ADD_HOVER_ICON = new ImageIcon(addImage);

		final BufferedImage editImage = ImageUtil.loadImageResource(MarketWatcherPlugin.class, EDIT_TAB_ICON_PATH);
		EDIT_ICON = new ImageIcon(ImageUtil.alphaOffset(editImage, 0.53f));
		EDIT_HOVER_ICON = new ImageIcon(editImage);

		final BufferedImage deleteTabImage = ImageUtil.loadImageResource(MarketWatcherPlugin.class, DELETE_TAB_ICON_PATH);
		DELETE_TAB_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteTabImage, 0.53f));
		DELETE_TAB_HOVER_ICON = new ImageIcon(deleteTabImage);

		final BufferedImage collapsedImage = ImageUtil.loadImageResource(MarketWatcherPlugin.class, COLLAPSE_ICON_PATH);
		COLLAPSED_ICON = new ImageIcon(collapsedImage);
		COLLAPSED_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(collapsedImage, 0.53f));

		final BufferedImage uncollapsedImage = ImageUtil.loadImageResource(MarketWatcherPlugin.class, SHIFT_DOWN_ICON_PATH);
		UNCOLLAPSED_ICON = new ImageIcon(uncollapsedImage);
		UNCOLLAPSED_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(uncollapsedImage, 0.53f));
	}

	MarketWatcherTabPanel(MarketWatcherPlugin plugin, MarketWatcherPluginPanel panel, MarketWatcherTab tab)
	{
		setLayout(new BorderLayout(5, 0));
		setBorder(new EmptyBorder(5, 5, 5, 0));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		this.collapsed = tab.isCollapsed();

		// Top Panel
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setOpaque(false);

		// Collapse and Names
		JPanel leftActions = new JPanel(new BorderLayout());
		leftActions.setOpaque(false);

		// Tab Name
		JLabel tabName = new JLabel();
		tabName.setForeground(Color.WHITE);
		tabName.setBorder(new EmptyBorder(0, 5, 0, 0));
		tabName.setPreferredSize(new Dimension(120, 0));
		tabName.setText(tab.getName());
		tabName.setToolTipText((tab.getName()));

		// Collapse
		JLabel collapseButton = new JLabel();
		collapseButton.setOpaque(false);

		if (collapsed)
		{
			tabName.setPreferredSize(new Dimension(120, 0));

			collapseButton.setIcon(COLLAPSED_ICON);
			collapseButton.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					plugin.switchTabCollapse(tab);
				}

				@Override
				public void mouseEntered(MouseEvent e)
				{
					collapseButton.setIcon(COLLAPSED_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					collapseButton.setIcon(COLLAPSED_ICON);
				}
			});

			leftActions.add(tabName, BorderLayout.EAST);
			leftActions.add(collapseButton, BorderLayout.WEST);
			topPanel.add(leftActions, BorderLayout.WEST);

			add(topPanel, BorderLayout.CENTER);
		}
		else
		{
			collapseButton.setIcon(UNCOLLAPSED_ICON);
			collapseButton.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					plugin.switchTabCollapse(tab);
				}

				@Override
				public void mouseEntered(MouseEvent e)
				{
					collapseButton.setIcon(UNCOLLAPSED_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					collapseButton.setIcon(UNCOLLAPSED_ICON);
				}
			});

			leftActions.add(tabName, BorderLayout.EAST);
			leftActions.add(collapseButton, BorderLayout.WEST);

			topPanel.add(leftActions, BorderLayout.WEST);

			// Actions Panel
			JPanel rightActions = new JPanel(new BorderLayout());
			rightActions.setBorder(new EmptyBorder(0, 0, 0, 5));
			rightActions.setOpaque(false);

			// Delete Button
			JLabel deleteBtn = new JLabel(DELETE_TAB_ICON);
			deleteBtn.setVerticalAlignment(SwingConstants.CENTER);
			deleteBtn.setBorder(new EmptyBorder(0, 0, 0, 5));
			deleteBtn.setOpaque(false);
			deleteBtn.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					if (deleteConfirm())
					{
						plugin.removeTab(tab);
					}
				}

				@Override
				public void mouseEntered(MouseEvent e)
				{
					deleteBtn.setIcon(DELETE_TAB_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					deleteBtn.setIcon(DELETE_TAB_ICON);
				}
			});

			rightActions.add(deleteBtn, BorderLayout.LINE_START);

			// Edit Button
			JLabel edit = new JLabel(EDIT_ICON);
			edit.setVerticalAlignment(SwingConstants.CENTER);
			edit.setBorder(new EmptyBorder(0, 0, 0, 5));
			edit.setOpaque(false);
			edit.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					plugin.editTab(tab);
				}

				@Override
				public void mouseEntered(MouseEvent e)
				{
					edit.setIcon(EDIT_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					edit.setIcon(EDIT_ICON);
				}
			});

			rightActions.add(edit, BorderLayout.CENTER);

			JLabel addItem = new JLabel(ADD_ICON);
			addItem.setOpaque(false);
			addItem.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					final String[] itemNames = plugin.getItems().stream().map(MarketWatcherItem::getName).toArray(String[]::new);
					Arrays.sort(itemNames, String.CASE_INSENSITIVE_ORDER);

					MarketWatcherSelectionPanel selection = new MarketWatcherSelectionPanel(panel, itemNames);
					selection.setOnOk(e1 -> {
						List<String> selectedItems = selection.getSelectedItems();
						if (!selectedItems.isEmpty())
						{
							plugin.addItemsToTab(tab, selectedItems);
						}
					});
					selection.show();
				}

				@Override
				public void mouseEntered(MouseEvent e)
				{
					addItem.setIcon(ADD_HOVER_ICON);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					addItem.setIcon(ADD_ICON);
				}
			});
			rightActions.add(addItem, BorderLayout.LINE_END);

			topPanel.add(rightActions, BorderLayout.EAST);

			// Tab Items
			GridBagConstraints constraints = new GridBagConstraints();
			constraints.fill = GridBagConstraints.HORIZONTAL;
			constraints.gridwidth = 1;
			constraints.weightx = 1;
			constraints.gridx = 0;
			constraints.gridy = 1;

			JPanel itemsPanel = new JPanel();
			itemsPanel.setLayout(new GridBagLayout());
			itemsPanel.setBorder(new EmptyBorder(5, 5, 0, 5));
			itemsPanel.setOpaque(false);

			int index = 0;
			for (MarketWatcherItem item : tab.getItems())
			{
				MarketWatcherTabItemPanel itemPanel = new MarketWatcherTabItemPanel(plugin, tab, item);

				if (index++ > 0)
				{
					itemsPanel.add(createMarginWrapper(itemPanel), constraints);
				}
				else
				{
					itemsPanel.add(itemPanel, constraints);
				}

				constraints.gridy++;
			}

			add(topPanel, BorderLayout.NORTH);
			add(itemsPanel, BorderLayout.CENTER);
		}
	}

	private boolean deleteConfirm()
	{
		int confirm = JOptionPane.showConfirmDialog(this,
			DELETE_MESSAGE, DELETE_TITLE, JOptionPane.YES_NO_OPTION);

		return confirm == JOptionPane.YES_NO_OPTION;
	}

	private JPanel createMarginWrapper(JPanel panel)
	{
		JPanel marginWrapper = new JPanel(new BorderLayout());
		marginWrapper.setOpaque(false);
		marginWrapper.setBorder(new EmptyBorder(5, 0, 0, 0));
		marginWrapper.add(panel, BorderLayout.NORTH);
		return marginWrapper;
	}


	@Override
	protected void paintComponent(Graphics g)
	{
		g.setColor(ColorScheme.DARKER_GRAY_COLOR);
		g.fillRect(0, 0, this.getWidth(), this.getHeight());
	}
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.utilities;

import lombok.Data;


@Data
public class WikiItemDetails
{
	int avgHighPrice;
	long highPriceVolume;
	int avgLowPrice;
	long lowPriceVolume;
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.utilities;

public final class Constants
{
	private Constants()
	{
		// restrict instantiation
	}

	public static final String PLUGIN_NAME = "Market Watcher";
	public static final String CONFIG_TAB = "marketwatch";
	public static final String K_THOUSAND = "K";
	public static final String M_MILLION = "M";
	public static final String B_BILLION = "B";
	public static final String NOT_AVAILABLE = "N/A";
	public static final String NULL = "null";

	public static final String TRUNCATION_STRING = "...";
	public static final String STANDARD = "Standard";
	public static final String COMPACT = "Compact";

	public static final int UNIX_DAY = 86400;
	public static final int UNIX_WEEK = 604800;

	public static final int UNIX_MONTH = 2592000;

	public static final int SECONDS_IN_SIX_HOURS = 21600;

	public static final String ONE_WEEK = "oneWeek";
	public static final String ONE_MONTH = "oneMonth";
	public static final String THREE_MONTHS = "threeMonths";

	public static final String LOW = "Low";
	public static final String MED = "Med";
	public static final String HIGH = "High";

	public static final String PERIOD_ONE_LOW = "period1Low";
	public static final String PERIOD_ONE_MED = "period1Med";
	public static final String PERIOD_ONE_HIGH = "period1High";
	public static final String PERIOD_TWO_LOW = "period2Low";
	public static final String PERIOD_TWO_MED = "period2Med";
	public static final String PERIOD_TWO_HIGH = "period2High";
	public static final String PERIOD_THREE_LOW = "period3Low";
	public static final String PERIOD_THREE_MED = "period3Med";
	public static final String PERIOD_THREE_HIGH = "period3High";
	public static final String GP = " gp";

	public static final String OSRS_WIKI_PRICES_6H_REQUEST_URL = "https://prices.runescape.wiki/api/v1/osrs/6h?timestamp=";

	public static final String OSRS_WIKI_ITEM_REQUEST_BASE_URL = "https://prices.runescape.wiki/osrs/item/";
	public static final String COMMA = ",";
	public static final String EMPTY_STRING = "";

	public static final String PANEL_ICON_PATH = "/panelicon.png";
	public static final String DELETE_ICON_PATH = "/deleteicon.png";
	public static final String SHIFT_UP_ICON_PATH = "/shiftupicon.png";
	public static final String SHIFT_DOWN_ICON_PATH = "/shiftdownicon.png";
	public static final String ADD_TAB_ITEM_ICON_PATH = "/addtabitemicon.png";
	public static final String EDIT_TAB_ICON_PATH = "/edittabicon.png";
	public static final String DELETE_TAB_ICON_PATH = "/trashicon.png";
	public static final String COLLAPSE_ICON_PATH = "/collapseicon.png";
	public static final String INFO_ICON_PATH = "/infoicon.png";
	public static final String ADD_ICON_PATH = "/addicon.png";
	public static final String ADD_TAB_ICON_PATH = "/addtabicon.png";
	public static final String CANCEL_ICON_PATH = "/cancelicon.png";

}

/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.utilities;

import lombok.Data;

import java.util.Map;

@Data
public class WikiRequestResult
{
	Map<Integer, WikiItemDetails> data;
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.utilities;

import com.marketwatcher.MarketWatcherPlugin;
import com.marketwatcher.data.MarketWatcherItem;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.Cursor;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.QuantityFormatter;

import javax.swing.*;
import java.awt.*;

import static com.marketwatcher.utilities.Constants.*;
import static com.marketwatcher.utilities.Constants.STANDARD;
import static com.marketwatcher.utilities.PriceUtils.manageItemPrices;

public final class PanelUtils
{

	private PanelUtils()
	{
	}

	public static JPanel createRightPanel(MarketWatcherItem item, MarketWatcherPlugin plugin, String viewType)
	{
		// Image
		JLabel itemImage = new JLabel();
		itemImage.setMinimumSize(new Dimension(32, 32));
		itemImage.setPreferredSize(new Dimension(32, 32));
		itemImage.setMaximumSize(new Dimension(32, 32));

		String periodOneLow = item.getPeriodOneLow();
		String periodOneMed = item.getPeriodOneMed();
		String periodOneHigh = item.getPeriodOneHigh();
		String periodTwoLow = item.getPeriodTwoLow();
		String periodTwoMed = item.getPeriodTwoMed();
		String periodTwoHigh = item.getPeriodTwoHigh();
		String periodThreeLow = item.getPeriodThreeLow();
		String periodThreeMed = item.getPeriodThreeMed();
		String periodThreeHigh = item.getPeriodThreeHigh();

		String[] periodOnePrices = manageItemPrices(periodOneLow, periodOneMed, periodOneHigh, viewType);
		String[] periodTwoPrices = manageItemPrices(periodTwoLow, periodTwoMed, periodTwoHigh, viewType);
		String[] periodThreePrices = manageItemPrices(periodThreeLow, periodThreeMed, periodThreeHigh, viewType);

		if (item.getImage() != null)
		{
			item.getImage().addTo(itemImage);
		}

		itemImage.setToolTipText("Open Wiki Price Page");
		itemImage.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				itemImage.setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				itemImage.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				plugin.openWikiPriceLink(item.getItemId());
			}
		});


		GridBagConstraints gbc = new GridBagConstraints();
		// Item Details Panel
		JPanel rightPanel = new JPanel(new GridBagLayout());
		rightPanel.setBackground(new Color(0, 0, 0, 0));

		// Item Name
		JLabel itemName = new JLabel();
		itemName.setForeground(Color.WHITE);

		String dispLabel = item.getName().substring(0, Math.min(item.getName().length(), 22));
		if (dispLabel.length() == 22)
		{
			dispLabel = dispLabel.concat(TRUNCATION_STRING);
		}
		itemName.setText(dispLabel);
		itemName.setToolTipText(item.getName());
		itemName.setMaximumSize(new Dimension(30, 15));

		rightPanel.add(itemImage, getGbc(gbc, 0, 0, 1, 2, 0, 0, new Insets(0, 0, 0, 3)));
		rightPanel.add(itemName, getGbc(gbc, 1, 0, 5, 1, 0, 0, new Insets(0, 0, 0, 0)));

		// GE Price
		JLabel gePriceLabel = new JLabel();
		if (item.getGePrice() > 0)
		{
			gePriceLabel.setText(QuantityFormatter.formatNumber(item.getGePrice()) + GP);
		}
		else
		{
			gePriceLabel.setText(NOT_AVAILABLE);
		}
		gePriceLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		rightPanel.add(gePriceLabel, getGbc(gbc, 1, 1, 5, 1, 0, 0, new Insets(0, 0, 0, 0)));

		Integer topBottomInset = viewType.equals(STANDARD) ? 1 : 3;
		Insets medPriceInsets = viewType.equals(STANDARD) ? new Insets(1, 3, 1, 3) : new Insets(3, 3, 3, 3);
		Insets lowHighPriceInsets = viewType.equals(STANDARD) ? new Insets(1, 0, 1, 0) : new Insets(3, 0, 3, 3);

		JLabel timeType = new JLabel();

		timeType.setForeground(Color.WHITE);

		int periodOneQty = plugin.configPricePeriodOneQty;
		String periodOneType = plugin.configPeriodOneType.name();

		timeType.setText(Integer.toString(periodOneQty) + periodOneType.charAt(0) + ":");
		timeType.setToolTipText(Integer.toString(periodOneQty) + " " + periodOneType);
		rightPanel.add(timeType, getGbc(gbc, 0, 2, 1, 1, 0, 0, new Insets(5, 0, topBottomInset, 0)));

		JLabel lowPeriodOnePrice = new JLabel();

		boolean isColorBlindMode = plugin.getConfig().colorBlindMode();
		Color lowColor = isColorBlindMode ? new Color(136, 204, 238) : Color.GREEN;
		Color medColor = isColorBlindMode ? new Color(221, 204, 119) : Color.YELLOW;
		Color highColor = isColorBlindMode ? new Color(170, 68, 153) : Color.RED;

		lowPeriodOnePrice.setForeground(lowColor);
		lowPeriodOnePrice.setText(periodOnePrices[0]);
		lowPeriodOnePrice.setToolTipText(LOW + ": " + formatTooltip(periodOneLow));
		rightPanel.add(lowPeriodOnePrice, getGbc(gbc, 1, 2, 1, 1, 0, 0, new Insets(5, 0, topBottomInset, 0)));

		JLabel medPeriodOnePrice = new JLabel();

		medPeriodOnePrice.setForeground(medColor);
		medPeriodOnePrice.setText(periodOnePrices[1]);
		medPeriodOnePrice.setToolTipText(MED + ": " + formatTooltip(periodOneMed));
		rightPanel.add(medPeriodOnePrice, getGbc(gbc, 2, 2, 1, 1, 0, 0, new Insets(5, 3, topBottomInset, 3)));
		JLabel highPeriodOnePrice = new JLabel();

		highPeriodOnePrice.setForeground(highColor);
		highPeriodOnePrice.setText(periodOnePrices[2]);
		highPeriodOnePrice.setToolTipText(HIGH + ": " + formatTooltip(periodOneHigh));
		rightPanel.add(highPeriodOnePrice, getGbc(gbc, 3, 2, 1, 1, 0, 0, new Insets(5, 0, topBottomInset, 0)));

		JLabel timeType2 = new JLabel();

		timeType2.setForeground(Color.WHITE);


		int periodTwoQty = plugin.configPricePeriodTwoQty;
		String periodTwoType = plugin.configPeriodTwoType.name();

		timeType2.setText(Integer.toString(periodTwoQty) + periodTwoType.charAt(0) + ":");
		timeType2.setToolTipText(Integer.toString(periodTwoQty) + " " + periodTwoType);

		rightPanel.add(timeType2, getGbc(gbc, 0, 3, 1, 1, 0, 0, new Insets(topBottomInset, 0, topBottomInset, 0)));

		JLabel lowPeriodTwoPrice = new JLabel();

		lowPeriodTwoPrice.setForeground(lowColor);
		lowPeriodTwoPrice.setText(periodTwoPrices[0]);
		lowPeriodTwoPrice.setToolTipText(LOW + ": " + formatTooltip(periodTwoLow));
		rightPanel.add(lowPeriodTwoPrice, getGbc(gbc, 1, 3, 1, 1, 0, 0, lowHighPriceInsets));

		JLabel medPeriodTwoPrice = new JLabel();

		medPeriodTwoPrice.setForeground(medColor);
		medPeriodTwoPrice.setText(periodTwoPrices[1]);
		medPeriodTwoPrice.setToolTipText(MED + ": " + formatTooltip(periodTwoMed));
		rightPanel.add(medPeriodTwoPrice, getGbc(gbc, 2, 3, 1, 1, 0, 0, medPriceInsets));

		JLabel highPeriodTwoPrice = new JLabel();

		highPeriodTwoPrice.setForeground(highColor);
		highPeriodTwoPrice.setText(periodTwoPrices[2]);
		highPeriodTwoPrice.setToolTipText(HIGH + ": " + formatTooltip(periodTwoHigh));
		rightPanel.add(highPeriodTwoPrice, getGbc(gbc, 3, 3, 1, 1, 0, 0, lowHighPriceInsets));

		JLabel timeType3 = new JLabel();

		timeType3.setForeground(Color.WHITE);

		int periodThreeQty = plugin.configPricePeriodThreeQty;
		String periodThreeType = plugin.configPeriodThreeType.name();

		timeType3.setText(Integer.toString(periodThreeQty) + periodThreeType.charAt(0) + ":");
		timeType3.setToolTipText(Integer.toString(periodThreeQty) + " " + periodThreeType);

		rightPanel.add(timeType3, getGbc(gbc, 0, 4, 1, 1, 0, 0, new Insets(topBottomInset, 0, topBottomInset, 0)));

		JLabel lowPeriodThreePrice = new JLabel();

		lowPeriodThreePrice.setForeground(lowColor);
		lowPeriodThreePrice.setText(periodThreePrices[0]);
		lowPeriodThreePrice.setToolTipText(LOW + ": " + formatTooltip(periodThreeLow));
		rightPanel.add(lowPeriodThreePrice, getGbc(gbc, 1, 4, 1, 1, 0, 0, lowHighPriceInsets));

		JLabel medPeriodThreePrice = new JLabel();

		medPeriodThreePrice.setForeground(medColor);
		medPeriodThreePrice.setText(periodThreePrices[1]);
		medPeriodThreePrice.setToolTipText(MED + ": " + formatTooltip(periodThreeMed));
		rightPanel.add(medPeriodThreePrice, getGbc(gbc, 2, 4, 1, 1, 0, 0, medPriceInsets));

		JLabel highPeriodThreePrice = new JLabel();

		highPeriodThreePrice.setForeground(highColor);
		highPeriodThreePrice.setText(periodThreePrices[2]);
		highPeriodThreePrice.setToolTipText(HIGH + ": " + formatTooltip(periodThreeHigh));
		rightPanel.add(highPeriodThreePrice, getGbc(gbc, 3, 4, 1, 1, 0, 0, lowHighPriceInsets));

		return rightPanel;
	}

	public static GridBagConstraints getGbc(GridBagConstraints gbc, int gridx, int gridy, int gridWidth, int gridHeight, int paddingX, int paddingY, Insets insets)
	{
		if ((gridx == 1 && gridy == 0) || (gridx == 0 && gridy == 0))
		{
			gbc.fill = GridBagConstraints.HORIZONTAL;
		}
		gbc.gridwidth = gridWidth;
		gbc.gridheight = gridHeight;
		gbc.weightx = 0;
		gbc.weighty = 0;
		gbc.gridx = gridx;
		gbc.gridy = gridy;
		gbc.ipadx = paddingX;
		gbc.ipady = paddingY;
		gbc.insets = insets;

		return gbc;
	}

	public static String formatTooltip(String tooltip)
	{

		if (tooltip.equals(NOT_AVAILABLE) || tooltip.equals(NULL))
		{
			return NOT_AVAILABLE;
		}
		else
		{
			return QuantityFormatter.formatNumber(Integer.parseInt(tooltip));
		}
	}
}
/*
 * Copyright (c) 2023, Bob Tabrizi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.marketwatcher.utilities;

import com.marketwatcher.data.MarketWatcherItem;
import net.runelite.client.util.AsyncBufferedImage;

import java.text.DecimalFormat;
import java.util.Map;

import static com.marketwatcher.utilities.Constants.*;

public final class PriceUtils
{

	private PriceUtils()
	{
	}

	public static String standardPricePadder(String price)
	{
		if (price.length() == 1)
		{
			price = price + "\u2800" + "\u2800" + "\u2800" + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 2)
		{
			price = price + "\u2800" + "\u2800" + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 3)
		{
			price = price + "\u2800" + "\u202F" + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 4 && !price.contains(M_MILLION) && !price.contains(K_THOUSAND))
		{
			price = price + "\u2800" + "\u202F";
			return price;
		}
		if (price.length() == 4 && (price.contains(M_MILLION) || price.contains(K_THOUSAND)))
		{
			price = price + "\u2800" + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 5 && !price.contains(M_MILLION) && !price.contains(K_THOUSAND) && !price.contains(B_BILLION))
		{
			price = price + "\u2800";
			return price;
		}

		if (price.length() == 5 && price.contains(K_THOUSAND))
		{
			price = price + "\u2800";
			return price;
		}
		if (price.length() == 5 && price.contains(M_MILLION))
		{
			price = price + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 5 && price.contains(B_BILLION))
		{
			price = price + "\u2800" + "\u202F";
			return price;
		}

		if (price.length() == 6)
		{
			price = price + "\u202F";
			return price;
		}

		return price;
	}

	public static String compactPricePadder(String price)
	{
		if (price.length() == 1)
		{
			price = price + "\u2800" + "\u2800" + "\u2800";
			return price;
		}
		if (price.length() == 2)
		{
			price = price + "\u2800" + "\u2800" + "\u202F";
			return price;
		}
		if (price.length() == 3)
		{
			price = price + "\u2800" + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 4 && !price.contains(M_MILLION) && !price.contains(K_THOUSAND))
		{
			price = price + "\u202F" + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 4 && (price.contains(M_MILLION) || price.contains(K_THOUSAND)))
		{
			price = price + "\u2800";
			return price;
		}
		if (price.length() == 5 && !price.contains(M_MILLION) && !price.contains(K_THOUSAND) && !price.contains(B_BILLION))
		{
			price = price + "\u202F" + "\u202F" + "\u202F";
			return price;
		}

		if (price.length() == 5 && price.contains(K_THOUSAND))
		{
			price = price + "\u202F" + "\u202F";
			return price;
		}
		if (price.length() == 5 && price.contains(M_MILLION))
		{
			price = price + "\u202F";
			return price;
		}
		if (price.length() == 5 && price.contains(B_BILLION))
		{
			price = price + "\u202F" + "\u202F";
			return price;
		}

		return price;
	}

	public static String[] manageItemPrices(String lowPrice, String medPrice, String highPrice, String viewType)
	{
		final DecimalFormat df = new DecimalFormat("0.0");
		final DecimalFormat df2 = new DecimalFormat("0.00");
		highPrice = truncatePrices(highPrice, df, df2, viewType);
		medPrice = truncatePrices(medPrice, df, df2, viewType);
		lowPrice = truncatePrices(lowPrice, df, df2, viewType);

		return new String[]{lowPrice, medPrice, highPrice};
	}

	public static String truncatePrices(String price, DecimalFormat df, DecimalFormat df2, String viewType)
	{
		if (price.equals(NULL))
		{
			price = NOT_AVAILABLE;
			return price;
		}

		if (price.length() >= 5 && price.length() < 7)
		{
			price = df.format((float) Integer.parseInt(price) / 1000) + K_THOUSAND;
		}
		else if (price.length() >= 7 && price.length() < 10)
		{
			price = df.format((float) Integer.parseInt(price) / 1000000) + M_MILLION;
		}
		else if (price.length() >= 10)
		{
			price = df2.format((float) Integer.parseInt(price) / 1000000000) + B_BILLION;
		}

		if (viewType.equals(STANDARD))
		{
			price = standardPricePadder(price);
		}
		else if (viewType.equals(COMPACT))
		{
			price = compactPricePadder(price);
		}
		return price;
	}

	public static MarketWatcherItem createMarketWatchItemWithPriceMap(AsyncBufferedImage itemImage, String itemName, int itemId, int itemPrice, Map<String, String> itemPriceMap)
	{
		String periodOneLow = NOT_AVAILABLE;
		String periodOneMed = NOT_AVAILABLE;
		String periodOneHigh = NOT_AVAILABLE;

		String periodTwoLow = NOT_AVAILABLE;
		String periodTwoMed = NOT_AVAILABLE;
		String periodTwoHigh = NOT_AVAILABLE;

		String periodThreeLow = NOT_AVAILABLE;
		String periodThreeMed = NOT_AVAILABLE;
		String periodThreeHigh = NOT_AVAILABLE;

		if (itemPriceMap != null)
		{
			periodOneLow = itemPriceMap.get(PERIOD_ONE_LOW) != null ? itemPriceMap.get(PERIOD_ONE_LOW) : NOT_AVAILABLE;
			periodOneMed = itemPriceMap.get(PERIOD_ONE_MED) != null ? itemPriceMap.get(PERIOD_ONE_MED) : NOT_AVAILABLE;
			periodOneHigh = itemPriceMap.get(PERIOD_ONE_HIGH) != null ? itemPriceMap.get(PERIOD_ONE_HIGH) : NOT_AVAILABLE;

			periodTwoLow = itemPriceMap.get(PERIOD_TWO_LOW) != null ? itemPriceMap.get(PERIOD_TWO_LOW) : NOT_AVAILABLE;
			periodTwoMed = itemPriceMap.get(PERIOD_TWO_MED) != null ? itemPriceMap.get(PERIOD_TWO_MED) : NOT_AVAILABLE;
			periodTwoHigh = itemPriceMap.get(PERIOD_TWO_HIGH) != null ? itemPriceMap.get(PERIOD_TWO_HIGH) : NOT_AVAILABLE;

			periodThreeLow = itemPriceMap.get(PERIOD_THREE_LOW) != null ? itemPriceMap.get(PERIOD_THREE_LOW) : NOT_AVAILABLE;
			periodThreeMed = itemPriceMap.get(PERIOD_THREE_MED) != null ? itemPriceMap.get(PERIOD_THREE_MED) : NOT_AVAILABLE;
			periodThreeHigh = itemPriceMap.get(PERIOD_THREE_HIGH) != null ? itemPriceMap.get(PERIOD_THREE_HIGH) : NOT_AVAILABLE;
		}

		return new MarketWatcherItem(itemImage, itemName, itemId, itemPrice, periodOneLow, periodOneMed, periodOneHigh, periodTwoLow, periodTwoMed, periodTwoHigh, periodThreeLow, periodThreeMed, periodThreeHigh);
	}


}
