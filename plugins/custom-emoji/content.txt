package com.customemoji;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;

import net.runelite.api.IndexedSprite;
import net.runelite.client.util.ImageUtil;

/**
 * Utility class for preprocessing emoji images for RuneLite compatibility.
 * Handles image resizing, color quantization, and transparency corrections.
 */
public class CustomEmojiImageUtilities 
{
    // Constants
    private static final int MAX_PALETTE_SIZE = 255;
    private static final int NEAR_BLACK_VALUE = 1; // RGB(1,1,1) to avoid transparency issues

    private CustomEmojiImageUtilities()
    {
    }

    /**
     * Manually converts an IndexedSprite to a BufferedImage using pixel data.
     * @param sprite The IndexedSprite to convert
     * @return A BufferedImage representation of the sprite
     */
    public static BufferedImage indexedSpriteToBufferedImage(IndexedSprite sprite)
    {
        if (sprite == null)
        {
            return null;
        }
        
        int width = sprite.getWidth();
        int height = sprite.getHeight();
        byte[] pixels = sprite.getPixels();
        int[] palette = sprite.getPalette();
              
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        
        if (pixels != null && palette != null)
        {
            // Convert indexed pixels to ARGB using the palette
            int[] argbPixels = new int[width * height];
            
            for (int i = 0; i < pixels.length && i < argbPixels.length; i++)
            {
                int index = pixels[i] & 0xFF; // Convert byte to unsigned int
                if (index < palette.length)
                {
                    // Get color from palette
                    int color = palette[index];
                    // Ensure alpha channel is set (if color doesn't have alpha, add it)
                    if ((color & 0xFF000000) == 0 && color != 0)
                    {
                        // If no alpha channel set but color is not black, make it opaque
                        color = color | 0xFF000000;
                    }
                    argbPixels[i] = color;
                }
                else
                {
                    // Index out of bounds - make it opaque red for debugging
                    argbPixels[i] = 0xFFFF0000;
                }
            }
            
            image.setRGB(0, 0, width, height, argbPixels, 0, width);
        }
        
        return image;
    }
    
    /**
     * Normalizes an image by applying resizing, quantization, and black pixel fixes.
     * Resizing is enabled by default.
     * @param image The input image to normalize
     * @param config Configuration settings for resizing
     * @return The normalized image ready for RuneLite
     */
    public static BufferedImage normalizeImage(BufferedImage image, CustomEmojiConfig config)
    {
        return normalizeImage(image, config, true);
    }

    /**
     * Normalizes an image by applying resizing, quantization, and black pixel fixes.
     * @param image The input image to normalize
     * @param config Configuration settings for resizing
     * @param shouldResize Whether to apply resizing to this specific image
     * @return The normalized image ready for RuneLite
     */
    public static BufferedImage normalizeImage(BufferedImage image, CustomEmojiConfig config, boolean shouldResize)
    {
        BufferedImage sizedResult = image;
        int maxImageHeight = config.maxImageHeight();
        if (shouldResize && image.getHeight() > maxImageHeight)
        {
            // Calculate new width while preserving aspect ratio
            double scaleFactor = (double) maxImageHeight / image.getHeight();
            int scaledWidth = (int) Math.round(image.getWidth() * scaleFactor);

            sizedResult = ImageUtil.resizeImage(image, scaledWidth, maxImageHeight, true);
        }

        BufferedImage quantizedResult = quantizeIfNeeded(sizedResult, MAX_PALETTE_SIZE);
        return fixPureBlackPixels(quantizedResult);
    }

    /**
     * Fixes pure black pixels by converting them to near-black to prevent
     * RuneLite from treating them as transparent.
     * @param image The input image
     * @return Image with corrected black pixels
     */
    public static BufferedImage fixPureBlackPixels(BufferedImage image)
    {
        BufferedImage result = new BufferedImage(
            image.getWidth(),
            image.getHeight(),
            BufferedImage.TYPE_INT_ARGB
        );
        
        for (int y = 0; y < image.getHeight(); y++)
        {
            for (int x = 0; x < image.getWidth(); x++)
            {
                int argb = image.getRGB(x, y);
                int alpha = (argb >> 24) & 0xff;
                int red = (argb >> 16) & 0xff;
                int green = (argb >> 8) & 0xff;
                int blue = argb & 0xff;
                
                // If pixel is opaque pure black, make it slightly not-black
                if (alpha > 0 && red == 0 && green == 0 && blue == 0)
                {
                    // Change to RGB (1,1,1) which is visually indistinguishable from black
                    // but won't be treated as transparent by RuneLite
                    int newArgb = (alpha << 24) | 
                                  (NEAR_BLACK_VALUE << 16) | 
                                  (NEAR_BLACK_VALUE << 8) | 
                                  NEAR_BLACK_VALUE;
                    result.setRGB(x, y, newArgb);
                }
                else
                {
                    result.setRGB(x, y, argb);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Checks if image has more colors than allowed and quantizes if needed.
     * @param image The input BufferedImage
     * @param maxColors Maximum number of colors allowed
     * @return A BufferedImage with maxColors or fewer
     */
    public static BufferedImage quantizeIfNeeded(BufferedImage image, int maxColors) {
        Set<Integer> uniqueColors = getUniqueColors(image);
        
        if (uniqueColors.size() <= maxColors) {
            return image; // No quantization needed
        }
        
        return quantizeToColors(image, maxColors);
    }
    
    /**
     * Gets all unique colors in the image
     * @param image The input BufferedImage
     * @return Set of unique RGB color values
     */
    private static Set<Integer> getUniqueColors(BufferedImage image) {
        Set<Integer> colors = new HashSet<>();
        
        for (int y = 0; y < image.getHeight(); y++) {
            for (int x = 0; x < image.getWidth(); x++) {
                colors.add(image.getRGB(x, y));
            }
        }
        
        return colors;
    }
    
    /**
     * Quantizes image to specified number of colors using median cut algorithm.
     * Handles transparency separately to preserve alpha values.
     * @param image The input BufferedImage
     * @param maxColors Maximum number of colors
     * @return Quantized BufferedImage with preserved transparency
     */
    private static BufferedImage quantizeToColors(BufferedImage image, int maxColors) {
        // Separate opaque and transparent colors
        Set<Integer> uniqueColors = getUniqueColors(image);
        List<Color> opaqueColors = new ArrayList<>();
        boolean hasTransparency = false;
        
        for (Integer argb : uniqueColors) {
            Color color = new Color(argb, true);
            if (color.getAlpha() == 0) {
                hasTransparency = true;
            } else {
                // Only add non-transparent colors to quantization
                opaqueColors.add(color);
            }
        }
        
        // Account for transparent color in palette if present
        int effectiveMaxColors = hasTransparency ? maxColors - 1 : maxColors;
        
        // If already within limit, return original
        if (opaqueColors.size() <= effectiveMaxColors) {
            return image;
        }
        
        // Apply median cut quantization only to opaque colors
        List<Color> palette = medianCut(opaqueColors, effectiveMaxColors);
        
        // Add transparent color to palette if needed
        if (hasTransparency) {
            palette.add(new Color(0, 0, 0, 0));
        }
        
        // Create new quantized image
        return applyPalette(image, palette);
    }
    
    /**
     * Median cut algorithm for color quantization
     */
    private static List<Color> medianCut(List<Color> colors, int maxColors) {
        List<ColorBox> boxes = new ArrayList<>();
        boxes.add(new ColorBox(colors));
        
        while (boxes.size() < maxColors) {
            // Find box with largest range
            ColorBox largestBox = null;
            int largestRange = -1;
            
            for (ColorBox box : boxes) {
                int range = box.getLargestRange();
                if (range > largestRange) {
                    largestRange = range;
                    largestBox = box;
                }
            }
            
            if (largestBox == null || largestRange == 0) {
                break; // Can't split further
            }
            
            // Split the box
            ColorBox[] split = largestBox.split();
            boxes.remove(largestBox);
            boxes.add(split[0]);
            boxes.add(split[1]);
        }
        
        // Get average color from each box
        List<Color> palette = new ArrayList<>();
        for (ColorBox box : boxes) {
            palette.add(box.getAverageColor());
        }
        
        return palette;
    }
    
    /**
     * Apply palette to image using nearest color matching
     */
    private static BufferedImage applyPalette(BufferedImage original, List<Color> palette) {
        BufferedImage result = new BufferedImage(
            original.getWidth(), 
            original.getHeight(), 
            BufferedImage.TYPE_INT_ARGB
        );
        
        for (int y = 0; y < original.getHeight(); y++) {
            for (int x = 0; x < original.getWidth(); x++) {
                int argb = original.getRGB(x, y);
                Color originalColor = new Color(argb, true);
                
                // Keep fully transparent pixels as-is
                if (originalColor.getAlpha() == 0) {
                    result.setRGB(x, y, 0); // Fully transparent
                } else {
                    // For non-transparent pixels, find nearest opaque color
                    List<Color> opaquePalette = new ArrayList<>();
                    for (Color c : palette) {
                        if (c.getAlpha() > 0) {
                            opaquePalette.add(c);
                        }
                    }
                    Color nearestColor = findNearestColor(originalColor, opaquePalette);
                    // Combine nearest RGB with original alpha
                    int newArgb = (originalColor.getAlpha() << 24) | 
                                  (nearestColor.getRed() << 16) | 
                                  (nearestColor.getGreen() << 8) | 
                                  nearestColor.getBlue();
                    result.setRGB(x, y, newArgb);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Find nearest color in palette using Euclidean distance
     */
    private static Color findNearestColor(Color target, List<Color> palette)
    {
        if (palette == null || palette.isEmpty())
        {
            return new Color(target.getRed(), target.getGreen(), target.getBlue());
        }

        Color nearest = palette.get(0);
        double minDistance = colorDistance(target, nearest);

        for (Color color : palette) {
            double distance = colorDistance(target, color);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = color;
            }
        }

        return nearest;
    }
    
    /**
     * Calculate Euclidean distance between two colors (RGB only, not alpha)
     */
    private static double colorDistance(Color c1, Color c2) {
        int dr = c1.getRed() - c2.getRed();
        int dg = c1.getGreen() - c2.getGreen();
        int db = c1.getBlue() - c2.getBlue();
        // Don't include alpha in distance calculation since we preserve original alpha
        return Math.sqrt(dr * dr + dg * dg + db * db);
    }
    
    /**
     * Helper class for median cut algorithm
     */
    private static class ColorBox {
        private List<Color> colors;
        
        public ColorBox(List<Color> colors) {
            this.colors = new ArrayList<>(colors);
        }
        
        public int getLargestRange() {
            if (colors.isEmpty()) return 0;
            
            int minR = 255;
            int maxR = 0;
            int minG = 255;
            int maxG = 0;
            int minB = 255;
            int maxB = 0;

            for (Color color : colors) {
                minR = Math.min(minR, color.getRed());
                maxR = Math.max(maxR, color.getRed());
                minG = Math.min(minG, color.getGreen());
                maxG = Math.max(maxG, color.getGreen());
                minB = Math.min(minB, color.getBlue());
                maxB = Math.max(maxB, color.getBlue());
            }

            int rangeR = maxR - minR;
            int rangeG = maxG - minG;
            int rangeB = maxB - minB;

            return Math.max(rangeR, Math.max(rangeG, rangeB));
        }

        public ColorBox[] split() {
            if (colors.size() <= 1) {
                return new ColorBox[]{this, new ColorBox(new ArrayList<>())};
            }

            // Find dimension with largest range
            int minR = 255;
            int maxR = 0;
            int minG = 255;
            int maxG = 0;
            int minB = 255;
            int maxB = 0;
            
            for (Color color : colors) {
                minR = Math.min(minR, color.getRed());
                maxR = Math.max(maxR, color.getRed());
                minG = Math.min(minG, color.getGreen());
                maxG = Math.max(maxG, color.getGreen());
                minB = Math.min(minB, color.getBlue());
                maxB = Math.max(maxB, color.getBlue());
            }
            
            int rangeR = maxR - minR;
            int rangeG = maxG - minG;
            int rangeB = maxB - minB;
            
            // Sort by the dimension with largest range (RGB only)
            if (rangeR >= rangeG && rangeR >= rangeB) {
                colors.sort(Comparator.comparingInt(Color::getRed));
            } else if (rangeG >= rangeB) {
                colors.sort(Comparator.comparingInt(Color::getGreen));
            } else {
                colors.sort(Comparator.comparingInt(Color::getBlue));
            }
            
            // Split at median
            int median = colors.size() / 2;
            List<Color> left = colors.subList(0, median);
            List<Color> right = colors.subList(median, colors.size());
            
            return new ColorBox[]{new ColorBox(left), new ColorBox(right)};
        }
        
        public Color getAverageColor() {
            if (colors.isEmpty()) return Color.BLACK;
            
            long sumR = 0;
            long sumG = 0;
            long sumB = 0;
            
            for (Color color : colors) {
                sumR += color.getRed();
                sumG += color.getGreen();
                sumB += color.getBlue();
            }
            
            int avgR = (int) (sumR / colors.size());
            int avgG = (int) (sumG / colors.size());
            int avgB = (int) (sumB / colors.size());
            
            // Return opaque color since we handle alpha separately
            return new Color(avgR, avgG, avgB);
        }
    }
}
package com.customemoji;

import java.util.HashSet;
import java.util.Set;

public final class PluginUtils
{
	private PluginUtils()
	{
	}

	public static Set<String> parseDisabledEmojis(String disabledEmojisString)
	{
		Set<String> result = new HashSet<>();

		if (disabledEmojisString != null && !disabledEmojisString.trim().isEmpty())
		{
			String[] parts = disabledEmojisString.split(",");
			for (String part : parts)
			{
				String trimmed = part.trim();
				if (!trimmed.isEmpty())
				{
					result.add(trimmed);
				}
			}
		}

		return result;
	}

	public static Set<String> parseResizingDisabledEmojis(String resizingDisabledEmojisString)
	{
		Set<String> result = new HashSet<>();

		if (resizingDisabledEmojisString != null && !resizingDisabledEmojisString.trim().isEmpty())
		{
			String[] parts = resizingDisabledEmojisString.split(",");
			for (String part : parts)
			{
				String trimmed = part.trim();
				if (!trimmed.isEmpty())
				{
					result.add(trimmed);
				}
			}
		}

		return result;
	}
}

package com.customemoji;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.customemoji.model.Emoji;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.IconID;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.util.Map;

@Slf4j
@Singleton
public class CustomEmojiTooltip extends Overlay
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    @Inject
    private TooltipManager tooltipManager;

    @Inject
    private MouseManager mouseManager;

    @Inject
    private ChatIconManager chatIconManager;

    @Inject
    private Map<String, Emoji> emojis;

    // Tooltip state
    private String hoveredEmojiName = null;
    private Point mousePosition = null;

    private final MouseListener mouseListener = new MouseListener()
	{
		@Override
		public MouseEvent mouseClicked(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mousePressed(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseReleased(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseEntered(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseExited(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseDragged(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseMoved(MouseEvent mouseEvent)
		{
			Point currentPoint = mouseEvent.getPoint();

			// Only update if mouse actually moved a good bit
			if (mousePosition == null || 
				Math.abs(currentPoint.x - mousePosition.x) > 2 || 
				Math.abs(currentPoint.y - mousePosition.y) > 2)
			{
				mousePosition = currentPoint;

				// Delegate to overlay for tooltip handling
				updateHoveredEmoji(currentPoint);
			}
			return mouseEvent;
		}
	};

    protected void startUp()
    {
        if (mouseManager != null)
        {
            mouseManager.registerMouseListener(mouseListener);
        }
    }

    protected void shutDown()
    {
        if (mouseManager != null)
        {
            mouseManager.unregisterMouseListener(mouseListener);
        }
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        showTooltip();
        return null;
    }

    private void showTooltip()
    {
        if (hoveredEmojiName != null && !hoveredEmojiName.isEmpty() && config.showEmojiTooltips())
        {
            tooltipManager.add(new Tooltip(hoveredEmojiName));
        }
    }

    private void updateHoveredEmoji(Point mousePoint)
    {
        this.mousePosition = mousePoint;

        String foundEmoji = null;

        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null || !isPointInWidget(chatbox, mousePoint))
        {
            this.hoveredEmojiName = null;
            return;
        }

        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        
        foundEmoji = this.checkWidgetsForEmoji(dynamicChildren, mousePoint);
        this.hoveredEmojiName = foundEmoji;
    }

    private String checkWidgetsForEmoji(Widget[] widgets, Point mousePoint)
    {
        if (widgets == null)
        {
            return null;
        }

        for (Widget widget : widgets)
        {
            if (widget == null)
            {
                continue;
            }
            
            // Check if mouse is within widget bounds (with expanded Y for tall emojis)
            if (isPointInWidgetWithEmojiPadding(widget, mousePoint))
            {
                String text = widget.getText();
                if (text != null && text.contains("<img="))
                {
                    String hoveredEmoji = findEmojiAtPosition(widget, text, mousePoint);
                    if (hoveredEmoji != null)
                    {
                        return hoveredEmoji;
                    }
                }
            }
        }
        return null;
    }

    private boolean isPointInWidgetWithEmojiPadding(Widget widget, Point point)
    {
        net.runelite.api.Point canvasLocation = widget.getCanvasLocation();
        if (canvasLocation == null)
        {
            return false;
        }

        int x = canvasLocation.getX();
        int y = canvasLocation.getY();
        int width = widget.getWidth();
        int height = widget.getHeight();

        // Emojis can extend above and below the widget's 14px height
        // Add padding to account for taller emojis (up to ~32px tall emojis)
        int verticalPadding = this.config.chatMessageSpacing() + this.config.chatMessageSpacing();

        return point.x >= x && point.x <= x + width &&
               point.y >= y - verticalPadding && point.y <= y + height + verticalPadding;
    }

    private boolean isPointInWidget(Widget widget, Point point)
    {
        net.runelite.api.Point canvasLocation = widget.getCanvasLocation();
        if (canvasLocation == null)
        {
            return false;
        }

        int x = canvasLocation.getX();
        int y = canvasLocation.getY();
        int width = widget.getWidth();
        int height = widget.getHeight();

        return point.x >= x && point.x <= x + width &&
               point.y >= y && point.y <= y + height;
    }

    private String findEmojiAtPosition(Widget widget, String text, Point mousePoint)
    {
        int imageId = EmojiPositionCalculator.findEmojiAtPoint(
            widget,
            text,
            mousePoint.x,
            mousePoint.y,
            this::getEmojiDimension
        );

        if (imageId >= 0)
        {
            return this.findEmojiNameById(imageId);
        }

        return null;
    }

    private Dimension getEmojiDimension(int imageId)
    {
        // Try to get dimension from modIcons sprite array directly
        IndexedSprite[] modIcons = this.client.getModIcons();
        if (modIcons != null && imageId >= 0 && imageId < modIcons.length)
        {
            IndexedSprite sprite = modIcons[imageId];
            if (sprite != null)
            {
                return new Dimension(sprite.getWidth(), sprite.getHeight());
            }
        }
        return null;
    }

    private String findEmojiNameById(int imageId)
    {
        // Check custom emojis first
        for (Emoji emoji : this.emojis.values())
        {
            if (this.chatIconManager.chatIconIndex(emoji.getId()) == imageId)
            {
                return emoji.getText();
            }
        }

        // Check built-in RuneLite IconIDs
        for (IconID icon : IconID.values())
        {
            if (icon.getIndex() == imageId)
            {
                return this.formatIconName(icon.name());
            }
        }

        return null;
    }

    private String formatIconName(String enumName)
    {
        // Convert PLAYER_MODERATOR to "Player Moderator"
        String[] words = enumName.toLowerCase().split("_");
        StringBuilder result = new StringBuilder();
        for (String word : words)
        {
            if (result.length() > 0)
            {
                result.append(" ");
            }
            result.append(Character.toUpperCase(word.charAt(0)));
            result.append(word.substring(1));
        }
        return result.toString();
    }
}

package com.customemoji;

import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.annotation.Nullable;
import java.awt.Rectangle;

import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.function.Supplier;

@Slf4j
@Singleton
public class ChatSpacingManager
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    private final Map<Integer, List<Widget>> originalChatPositions = new HashMap<>();
    private static final int LAST_MESSAGE_PADDING = 4;
    private int scrolledUpPixels = 0;

    public void clearStoredPositions()
    {
        this.originalChatPositions.clear();
    }

    public void captureScrollPosition()
    {
        Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return;
        }

        int scrollY = chatbox.getScrollY();
        int scrollHeight = chatbox.getScrollHeight();
        int visibleHeight = chatbox.getHeight();

        if (scrollHeight <= visibleHeight) // Cant scroll if there aren't enough messages
        {
            this.scrolledUpPixels = 0;
            return;
        }

        // Calculate how far up from the bottom the user has scrolled (in pixels)
        int newValue = scrollHeight - (visibleHeight + scrollY);

        if (newValue == this.scrolledUpPixels)
        {
            return;
        }

        this.scrolledUpPixels = newValue;
        log.debug("Captured scroll position: {} pixels from bottom", this.scrolledUpPixels);
    }

    public void applyChatSpacing()
    {
        int spacingAdjustment = config.chatMessageSpacing();

        if (spacingAdjustment == 0)
        {
            return; // Setting is essentially disabled
        }

        Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null || chatbox.isHidden())
        {
            return;
        }

        Widget[] dynamicChildren = this.getChildren(chatbox::getDynamicChildren); // Needed for visible stuff
        Widget[] staticChildren = this.getChildren(chatbox::getStaticChildren); // Needed for right-click context menus

        // Handle null arrays
        if (dynamicChildren == null) dynamicChildren = new Widget[0];
        if (staticChildren == null) staticChildren = new Widget[0];

        // Combine dynamic and static children into a single array
        Widget[] allChildren = new Widget[dynamicChildren.length + staticChildren.length];
        System.arraycopy(dynamicChildren, 0, allChildren, 0, dynamicChildren.length);
        System.arraycopy(staticChildren, 0, allChildren, dynamicChildren.length, staticChildren.length);

        Rectangle bounds = this.adjustChildren(allChildren, spacingAdjustment);

        this.updateChatBox(chatbox, bounds);
    }

    private void updateChatBox(Widget chatbox, Rectangle bounds)
    {
        if (bounds == null)
        {
            return;
        }

        int visibleHeight = chatbox.getHeight();

        if (visibleHeight > bounds.height)
        {
            return;
        }

        // Calculate new scroll height based on the bounds of all widgets
        int newScrollHeight = bounds.height + LAST_MESSAGE_PADDING;

        log.debug(String.valueOf(newScrollHeight));

        // Update the scroll height
        chatbox.setScrollHeight(newScrollHeight);

        // Restore scroll position based on how many lines the user was scrolled up from bottom
        boolean atBottom = this.scrolledUpPixels == 0.0;

        float scrolledUpPixelsLocal = atBottom ? this.scrolledUpPixels : this.scrolledUpPixels + this.config.chatMessageSpacing();

        int newScrollY = (int) (newScrollHeight - visibleHeight - scrolledUpPixelsLocal);
        newScrollY = Math.max(0, newScrollY);

        chatbox.revalidateScroll();

        this.client.runScript(ScriptID.UPDATE_SCROLLBAR, InterfaceID.Chatbox.CHATSCROLLBAR, InterfaceID.Chatbox.SCROLLAREA, newScrollY);

        this.captureScrollPosition();
    }

    @Nullable
    private Rectangle adjustChildren(Widget[] children, int spacingAdjustment)
    {
        if (children == null)
        {
            return null;
        }

        // Sort the array so that we adjust them in the proper order. The parent widget
        // has them in the proper order, but split by static or dynamic widget category.
        Widget[] sortedChildren = this.sortByYPosition(children);

        // Reverse the children array so last becomes first.
        // This makes it simpler to adjust the positions of every widget.
        // We start at the oldest message at the very top and work our way down
        Widget[] reversedSortedChildren = reverseArrayOrder(sortedChildren);

        // Group widgets by their original Y position
        Map<Integer, List<Widget>> widgetsByOriginalY = new HashMap<>();

        for (Widget child : reversedSortedChildren)
        {
            if (child == null || child.isHidden())
            {
                continue;
            }

            int storedY = this.resolveOriginalYPosition(child);
            widgetsByOriginalY.computeIfAbsent(storedY, k -> new ArrayList<>()).add(child);
        }

        // Sort the original Y positions and apply spacing to each group
        List<Integer> sortedOriginalYs = new ArrayList<>(widgetsByOriginalY.keySet());
        sortedOriginalYs.sort(Integer::compareTo);

        // Track bounds for the bounding rectangle
        int minX = 0;
        int minY = 0;
        int maxX = 0;
        int maxY = 0;

        int lastLineHeight = 0;

        int counter = 0;
        for (Integer originalYPos : sortedOriginalYs)
        {
            List<Widget> widgetsAtThisY = widgetsByOriginalY.get(originalYPos);
            int newY = originalYPos + (counter * spacingAdjustment);
            
            // Apply the same Y position and settings to all widgets at the same original y position
            // This is done so that all elements line up with each other.
            for (Widget child : widgetsAtThisY)
            {
                child.setOriginalY(newY);
                child.revalidate();

                // Update bounding rectangle
                int childX = child.getOriginalX();
                int childY = child.getOriginalY();
                int childRight = childX + child.getOriginalWidth();
                int childBottom = childY + child.getOriginalHeight();

                minX = Math.min(minX, childX);
                minY = Math.min(minY, childY);
                maxX = Math.max(maxX, childRight);
                maxY = Math.max(maxY, childBottom);

                if (counter == 0)
                {
                    lastLineHeight = Math.max(lastLineHeight, child.getOriginalHeight());
                }
                
            }

            counter++;
        }

        boolean hasWidgets = minX != Integer.MAX_VALUE;
        if (!hasWidgets)
        {
            return null;
        }

        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }

    private Widget[] sortByYPosition(Widget[] array)
    {
        // Sort by stored Y position
        Arrays.sort(array, (w1, w2) -> {
            if (w1 == null && w2 == null) return 0;
            if (w1 == null) return 1;
            if (w2 == null) return -1;
            
            // Find the stored Y position for each widget by searching through originalChatPositions
            Integer storedY1 = getStoredYPosition(w1);
            Integer storedY2 = getStoredYPosition(w2);
            
            // Use stored position if available, otherwise use current position
            int y1 = storedY1 != null ? storedY1 : w1.getOriginalY();
            int y2 = storedY2 != null ? storedY2 : w2.getOriginalY();
            
            return Integer.compare(y1, y2);
        });

        return array;
    }
    
    private Integer getStoredYPosition(Widget widget)
    {
        // Search through originalChatPositions to find which Y position this widget belongs to
        for (Map.Entry<Integer, List<Widget>> entry : this.originalChatPositions.entrySet())
        {
            if (entry.getValue().contains(widget))
            {
                return entry.getKey();
            }
        }
        // If not found in stored positions, return null
        return null;
    }

    private int resolveOriginalYPosition(Widget widget)
    {
        int currentY = widget.getOriginalY();

        Integer storedY = this.getStoredYPosition(widget);
        if (storedY != null && storedY != currentY)
        {
            return storedY;
        }

        boolean isAlreadyStored = this.originalChatPositions.values().stream()
            .anyMatch(widgets -> widgets.contains(widget));

        if (!isAlreadyStored)
        {
            this.originalChatPositions
                .computeIfAbsent(currentY, k -> new ArrayList<>())
                .add(widget);
        }

        return currentY;
    }

    private static Widget[] reverseArrayOrder(Widget[] array)
    {
        int len = array.length;
        Widget[] result = new Widget[len];
        
        for (int i = 0; i < len; i++)
        {
            result[i] = array[len - 1 - i];
        }

        return result;
    }

    private Widget[] getChildren(Supplier<Widget[]> childrenSupplier)
    {
        Widget[] children = childrenSupplier.get();
        if (children == null)
        {
            return new Widget[0];
        }

        List<Widget> result = new ArrayList<>();
        for (Widget child : children)
        {
            int height = child.getOriginalHeight();

            if (height == 0)
            {
                continue;
            }

            result.add(child);
        }

        return result.toArray(new Widget[0]);
    }
}
/**
 * Author: Louis Hong
 */

package com.customemoji;

import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

/**
 * Mom: We have Rust at home<br>
 * Rust at home: {@link Result}
 */
@NonNull
public interface Result<@NonNull V, @NonNull E>
{

	@NonNull
	static <V, E> Result<V, E> Ok(V value)
	{
		return new OkResult<>(value);
	}

	@NonNull
	static <E> Result<Void, E> Ok()
	{
		return new OkResult<>(null);
	}

	@NonNull
	static <V, E> Result<V, E> Error(@NonNull E exception)
	{
		return new ErrorResult<>(exception);
	}

	@NonNull
	static <V, E> Result<V, E> PartialOk(V value, E exception)
	{
		return new PartialResult<>(value, exception);
	}


	boolean isOk();

	boolean isError();

	void ifOk(@NonNull Consumer<? super V> then);

	void ifOk(@NonNull Runnable then);

	void ifError(@NonNull Consumer<? super E> then);

	<V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper);

	<E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper);

	Optional<V> toOptional();

	@NonNull
	V unwrap() throws IllegalUnwrapException;

	@NonNull
	E unwrapError() throws IllegalUnwrapException;


	@NonNull
	static <V> Result<V, NoSuchElementException> fromNullable(@Nullable V value)
	{
		if (value == null)
		{
			return Error(new NoSuchElementException("Value is null"));
		}
		else
		{
			return Ok(value);
		}
	}

	@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
	@NonNull
	static <V> Result<V, NoSuchElementException> fromOptional(Optional<V> value)
	{
		if (value.isEmpty())
		{
			return Error(new NoSuchElementException("Value is null"));
		}
		else
		{
			return Ok(value.get());
		}
	}

	@AllArgsConstructor(access=AccessLevel.PUBLIC)
	class OkResult<@NonNull V, E> implements Result<V, E>
	{
		private final V value;

		@Override
		public boolean isOk() {return true;}

		@Override
		public boolean isError() {return false;}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then)
		{
			then.accept(value);
		}

		@Override
		public void ifOk(@NonNull Runnable then)
		{
			then.run();
		}

		@Override
		public void ifError(@NonNull Consumer<? super E> then) {}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new OkResult<>(mapper.apply(value));
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new OkResult<>(value);
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.of(value);
		}

		@Override
		public @NonNull V unwrap()
		{
			return value;
		}

		@Override
		public @NonNull E unwrapError() throws IllegalUnwrapException
		{
			throw new IllegalUnwrapException("Cannot unwrap error from Ok result");
		}

	}

	@Slf4j
	@AllArgsConstructor(access=AccessLevel.PRIVATE)
	class ErrorResult<V, @NonNull E> implements Result<V, E>
	{
		private final E exception;

		@Override
		public boolean isOk() {return false;}

		@Override
		public boolean isError() {return true;}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then) {}

		@Override
		public void ifOk(@NonNull Runnable then) {}

		@Override
		public void ifError(@NonNull Consumer<? super E> then)
		{
			then.accept(exception);
		}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new ErrorResult<>(exception);
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new ErrorResult<>(mapper.apply(exception));
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.empty();
		}

		@Override
		public @NonNull V unwrap() throws IllegalStateException
		{
			throw new IllegalUnwrapException("Cannot unwrap value from Error result");
		}

		@Override
		public @NonNull E unwrapError()
		{
			return exception;
		}
	}

	@Slf4j
	@AllArgsConstructor(access=AccessLevel.PRIVATE)
	class PartialResult<V, @NonNull E> implements Result<V, E>
	{
		private final V value;
		private final E exception;

		@Override
		public boolean isOk()
		{
			return true;
		}

		@Override
		public boolean isError()
		{
			return true;
		}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then)
		{
			then.accept(value);
		}

		@Override
		public void ifOk(@NonNull Runnable then)
		{
			then.run();
		}

		@Override
		public void ifError(@NonNull Consumer<? super E> then)
		{
			then.accept(exception);
		}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new PartialResult<>(mapper.apply(value), exception);
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new PartialResult<>(value, mapper.apply(exception));
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.of(value);
		}

		@Override
		public @NonNull V unwrap()
		{
			return value;
		}

		@Override
		public @NonNull E unwrapError()
		{
			return exception;
		}
	}

	class IllegalUnwrapException extends IllegalStateException
	{
		public IllegalUnwrapException(String message)
		{
			super(message);
		}
	}

	class ResultFutures
	{
		@NonNull
		public static <V, E extends Throwable> ListenableFuture<Result<V, E>> immediateError(@NonNull E exception)
		{
			return Futures.immediateFuture(Error(exception));
		}

		@NonNull
		public static <V, E extends Throwable> ListenableFuture<Result<V, E>> immediateOk(@NonNull V value)
		{
			return Futures.immediateFuture(Ok(value));
		}

		@NonNull
		public static <E extends Throwable> ListenableFuture<Result<Void, E>> immediateOk()
		{
			return Futures.immediateFuture(Ok());
		}

	}
}

package com.customemoji;

import static com.customemoji.Result.Error;
import static com.customemoji.Result.Ok;
import static com.customemoji.Result.PartialOk;
import com.customemoji.model.Emoji;
import com.customemoji.model.Soundoji;
import com.google.common.io.Resources;
import com.google.inject.Provides;
import com.google.inject.Provider;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Stream;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Named;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import javax.swing.SwingUtilities;

import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.RuneLite;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import com.customemoji.panel.CustomEmojiPanel;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;

@Slf4j
@PluginDescriptor(
		name = "Custom Emoji",
		description = "Allows you to use custom emojis in chat messages",
		tags = {"emoji", "chat", "message", "custom", "icon", "emote", "text", "clan", "notification"}
)
public class CustomEmojiPlugin extends Plugin
{
	public static final String EMOJI_ERROR_COMMAND = "emojierror";
	public static final String EMOJI_FOLDER_COMMAND = "emojifolder";
	public static final String SOUNDOJI_FOLDER_COMMAND = "soundojifolder";
	public static final String PRINT_ALL_EMOJI_COMMAND = "emojiprint";

	public static final File SOUNDOJIS_FOLDER = RuneLite.RUNELITE_DIR.toPath().resolve("soundojis").toFile();
	public static final File EMOJIS_FOLDER = RuneLite.RUNELITE_DIR.toPath().resolve("emojis").toFile();

	public static final URL EXAMPLE_EMOJI = Resources.getResource(CustomEmojiPlugin.class, "checkmark.png");
	public static final URL EXAMPLE_SOUNDOJI = Resources.getResource(CustomEmojiPlugin.class, "customemoji.wav");

	public static final float NOISE_FLOOR = -60f;

	private static final Pattern WHITESPACE_REGEXP = Pattern.compile("[\\s\\u00A0]");

	@Inject
	private EventBus eventBus;

	@Inject
	private CustomEmojiOverlay overlay;

	@Inject
	private CustomEmojiTooltip tooltip;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private CustomEmojiConfig config;

	@Inject
	private ChatIconManager chatIconManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private AudioPlayer audioPlayer;

	@Inject
	private ChatSpacingManager chatSpacingManager;

	@Inject
	private Provider<CustomEmojiPanel> panelProvider;

	@Getter
	protected final Map<String, Emoji> emojis = new HashMap<>();
	private final Map<String, Soundoji> soundojis = new HashMap<>();
	private final List<String> errors = new ArrayList<>();
	private WatchService watchService;
	private ExecutorService watcherExecutor;
	private ScheduledExecutorService debounceExecutor;
	private ScheduledFuture<?> pendingReload;
	private CustomEmojiPanel panel;
	private NavigationButton navButton;

	private void setup()
	{
		if (EMOJIS_FOLDER.mkdir())
		{
			// copy example emoji
			File exampleEmoji = new File(EMOJIS_FOLDER, "com/customemoji/checkmark.png");
			try (InputStream in = EXAMPLE_EMOJI.openStream())
			{
				Files.copy(in, exampleEmoji.toPath());
			}
			catch (IOException e)
			{
				log.error("Failed to copy example emoji", e);
			}
		}

		if (SOUNDOJIS_FOLDER.mkdir())
		{
			// copy example soundoji
			File exampleSoundoji = new File(SOUNDOJIS_FOLDER, "com/customemoji/customemoji.wav");
			try (InputStream in = EXAMPLE_SOUNDOJI.openStream())
			{
				Files.copy(in, exampleSoundoji.toPath());
			}
			catch (IOException e)
			{
				log.error("Failed to copy example soundoji", e);
			}
		}
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted e)
	{
		switch (e.getCommand())
		{
			case EMOJI_FOLDER_COMMAND:
				LinkBrowser.open(EMOJIS_FOLDER.toString());
				break;
			case SOUNDOJI_FOLDER_COMMAND:
				LinkBrowser.open(SOUNDOJIS_FOLDER.toString());
				break;
			case EMOJI_ERROR_COMMAND:

				for (String error : errors)
				{
					client.addChatMessage(ChatMessageType.CONSOLE, "", error, null);
				}
				break;
			case PRINT_ALL_EMOJI_COMMAND:
				StringBuilder sb = new StringBuilder();

				sb.append("Currently loaded emoji: ");

				for (Map.Entry<String, Emoji> entry : this.emojis.entrySet())
				{
					sb.append(entry.getKey()).append(" ");
				}

				String message = updateMessage(sb.toString(), false);
				client.addChatMessage(ChatMessageType.CONSOLE, "Currently loaded emoji", message, null);

				break;
			default:
				break;
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		setup();

		loadEmojis();
		loadSoundojis();

		if (config.showPanel())
		{
			showButton();
		}

		overlay.startUp();
		overlayManager.add(overlay);

		tooltip.startUp();
		overlayManager.add(tooltip);

		// Apply initial chat spacing
		clientThread.invokeLater(chatSpacingManager::applyChatSpacing);

		try
		{
			setupFileWatcher();
		}
		catch (IOException e)
		{
			log.error("Failed to setup file watcher", e);
		}

		if (!errors.isEmpty())
		{
			clientThread.invokeLater(() ->
			{
				String message =
						"<col=FF0000>Custom Emoji: There were " + errors.size() +
								" errors loading emojis and soundojis.<br><col=FF0000>Use <col=00FFFF>::emojierror <col=FF0000>to see them.";
				client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);
			});
		}
		else
		{
			log.debug("<col=00FF00>Custom Emoji: Loaded " + emojis.size() + soundojis.size() + " emojis and soundojis.");
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		shutdownFileWatcher();
		emojis.clear();
		errors.clear();
		chatSpacingManager.clearStoredPositions();

		overlay.shutDown();
		overlayManager.remove(overlay);

		tooltip.shutDown();
		overlayManager.remove(tooltip);

		if (panel != null)
		{
			hideButton();
		}

		// Clear soundojis - AudioPlayer handles clip management automatically
		soundojis.clear();

		log.debug("Plugin shutdown complete - all containers cleared");
	}

	private void showButton()
	{
		// Create panel lazily after emojis are loaded
		panel = panelProvider.get();

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "../../com/customemoji/smiley.png");

		navButton = NavigationButton.builder()
			.tooltip("Custom Emoji")
			.icon(icon)
			.priority(5)
			.panel(panel)
			.build();

		clientToolbar.addNavigation(navButton);
	}

	private void hideButton()
	{
		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
			navButton = null;
		}
		panel = null;
	}

	private void shutdownFileWatcher()
	{
		log.debug("Starting file watcher shutdown");

		// Cancel any pending reload debounce task first to prevent new reloads
		if (pendingReload != null)
		{
			boolean cancelled = pendingReload.cancel(true); // Use true to interrupt if running
			log.debug("Pending reload task cancelled: {}", cancelled);
			pendingReload = null; // Clear reference
		}

		shutdownExecutor(debounceExecutor, "debounce executor");
		shutdownExecutor(watcherExecutor, "watcher executor");

		// Close watch service first to interrupt the blocking take() call
		if (watchService != null)
		{
			try
			{
				watchService.close();
				log.debug("Watch service closed");
			}
			catch (IOException e)
			{
				log.error("Failed to close watch service", e);
			}
			watchService = null; // Clear reference
		}

		// Clear executor references
		debounceExecutor = null;
		watcherExecutor = null;

		log.debug("File watcher shutdown complete");
	}

	private void shutdownExecutor(ExecutorService executor, String executorName)
	{
		if (executor == null)
		{
			return;
		}

		log.debug("Shutting down {}", executorName);
		executor.shutdownNow();
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		switch (chatMessage.getType())
		{
			case PUBLICCHAT:
			case MODCHAT:
			case FRIENDSCHAT:
			case CLAN_CHAT:
			case CLAN_GUEST_CHAT:
			case CLAN_GIM_CHAT:
			case PRIVATECHAT:
			case PRIVATECHATOUT:
			case MODPRIVATECHAT:
				break;
			default:
				return;
		}

		final MessageNode messageNode = chatMessage.getMessageNode();
		final String message = messageNode.getValue();
		final String updatedMessage = updateMessage(message, true);

		if (updatedMessage == null)
		{
			return;
		}

		messageNode.setValue(updatedMessage);
	}

	@Subscribe
	public void onOverheadTextChanged(final OverheadTextChanged event)
	{
		if (!(event.getActor() instanceof Player))
		{
			return;
		}

		final String message = event.getOverheadText();
		final String updatedMessage = updateMessage(message, false);

		if (updatedMessage == null)
		{
			return;
		}

		event.getActor().setOverheadText(updatedMessage);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		// Apply chat spacing when chat-related widgets are loaded
		if (event.getGroupId() == InterfaceID.Chatbox.SCROLLAREA)
		{
			clientThread.invokeLater(chatSpacingManager::applyChatSpacing);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("custom-emote"))
		{
			return;
		}
		boolean shouldRefreshPanel = true;

		switch (event.getKey())
		{
			case CustomEmojiConfig.KEY_CHAT_MESSAGE_SPACING:
				clientThread.invokeLater(chatSpacingManager::applyChatSpacing);
				break;
			case CustomEmojiConfig.KEY_MAX_IMAGE_HEIGHT:
				scheduleReload(true);
				break;
			case CustomEmojiConfig.KEY_SHOW_SIDE_PANEL:
				if (this.config.showPanel())
				{
					this.showButton();
				}
				else
				{
					this.hideButton();
				}
				break;
			case CustomEmojiConfig.KEY_DISABLED_EMOJIS:
				// Panel already updated itself, skip redundant refresh
				shouldRefreshPanel = false;
				break;
			default:
				break;
		}

		if (shouldRefreshPanel && this.panel != null)
		{
			SwingUtilities.invokeLater(() -> panel.updateFromConfig());
		}

	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event)
	{
		switch (event.getIndex())
		{
			case VarClientID.CHAT_LASTREBUILD:
				this.chatSpacingManager.clearStoredPositions();
				this.clientThread.invokeAtTickEnd(this.chatSpacingManager::applyChatSpacing);
				break;
			case VarClientID.CHAT_LASTSCROLLPOS:
				this.clientThread.invokeAtTickEnd(this.chatSpacingManager::captureScrollPosition);
				break;
			default:
				break;
		}
	}

	public static BufferedImage scaleDown(BufferedImage originalImage, int targetHeight)
	{
		int originalWidth = originalImage.getWidth();
		int originalHeight = originalImage.getHeight();

		// Do not scale if already short enough
		if (originalHeight <= targetHeight)
		{
			return originalImage;
		}

		// Compute new width while preserving aspect ratio
		double scaleFactor = (double) targetHeight / originalHeight;
		int newWidth = (int) Math.round(originalWidth * scaleFactor);

		// Create scaled image
		return ImageUtil.resizeImage(originalImage, newWidth, targetHeight);
	}

	@Nullable
	String updateMessage(final String message, boolean sound)
	{
		final String[] messageWords = WHITESPACE_REGEXP.split(message);

		boolean editedMessage = false;
		for (int i = 0; i < messageWords.length; i++)
		{
			// Remove tags except for <lt> and <gt>
			final String trigger = Text.removeFormattingTags(messageWords[i]);

			final Emoji emoji = emojis.get(trigger.toLowerCase());
			final Soundoji soundoji = soundojis.get(trigger.toLowerCase());

			if (emoji != null && this.isEmojiEnabled(emoji.getText()))
			{
				messageWords[i] = messageWords[i].replace(trigger,
						"<img=" + this.chatIconManager.chatIconIndex(emoji.getId()) + ">");
				editedMessage = true;
				log.debug("Replacing {} with emoji {}", trigger, emoji.getText());
			}

			if (soundoji != null)
			{
				if (sound)
				{
					try
					{
						this.audioPlayer.play(soundoji.getFile(), volumeToGain(this.config.volume()));
					}
					catch (IOException | UnsupportedAudioFileException | LineUnavailableException e)
					{
						log.error("Failed to play soundoji: " + soundoji.getText(), e);
					}
				}
				messageWords[i] = messageWords[i].replace(trigger, "*" + trigger + "*");
				editedMessage = true;
				log.debug("Playing soundoji {}", trigger);
			}

		}

		// If we haven't edited the message any, don't update it.
		if (!editedMessage)
		{
			return null;
		}

		return String.join(" ", messageWords);
	}

	boolean isEmojiEnabled(String emojiName)
	{
		return !PluginUtils.parseDisabledEmojis(this.config.disabledEmojis()).contains(emojiName);
	}

	public void loadEmojis()
	{
		File emojiFolder = EMOJIS_FOLDER;
		if (emojiFolder.mkdir())
		{
			log.error("Created emoji folder");
		}

		var result = loadEmojisFolder(emojiFolder);
		result.ifOk(list ->
		{
			list.forEach(e -> emojis.put(e.getText(), e));
			log.info("Loaded {} emojis", result.unwrap().size());
		});
		result.ifError(e ->
			e.forEach(t ->
			{
				String fileName = extractFileName(t.getMessage());
				log.debug("Skipped non-emoji file: {}", fileName);
			})
		);
	}

	private void loadSoundojis()
	{
		File soundojiFolder = SOUNDOJIS_FOLDER;
		if (soundojiFolder.mkdir())
		{
			log.error("Created soundoji folder");
		}

		var result = this.loadSoundojisFolder(soundojiFolder);
		result.ifOk(list ->
		{
			list.forEach(e -> this.soundojis.put(e.getText(), e));
			log.info("Loaded {} soundojis", result.unwrap().size());
		});
		result.ifError(e ->
			e.forEach(t ->
			{
				String fileName = extractFileName(t.getMessage());
				log.debug("Skipped non-audio file: {}", fileName);
			})
		);
	}

	private Result<List<Soundoji>, List<Throwable>> loadSoundojisFolder(File soundojiFolder)
	{
		// recursively flattenFolder files in the folder
		List<File> files = flattenFolder(soundojiFolder);

		if (!soundojiFolder.isDirectory())
		{
			return Error(List.of(new IllegalArgumentException("Not a folder " + soundojiFolder)));
		}

		List<Soundoji> loaded = new ArrayList<>();
		List<Throwable> localErrors = new ArrayList<>();

		for (File file : files)
		{
			Result<Soundoji, Throwable> result = loadSoundoji(file);
			result.ifOk(loaded::add);
			result.ifError(localErrors::add);
		}

		if (localErrors.isEmpty())
		{
			return Ok(loaded);
		}
		else
		{
			return PartialOk(loaded, localErrors);
		}
	}

	private Result<List<Emoji>, List<Throwable>> loadEmojisFolder(File folder)
	{
		// recursively flattenFolder files in the folder
		List<File> files = flattenFolder(folder);

		if (!folder.isDirectory())
		{
			return Error(List.of(new IllegalArgumentException("Not a folder " + folder)));
		}

		List<Emoji> loaded = new ArrayList<>();
		List<Throwable> localErrors = new ArrayList<>();

		for (File file : files)
		{
			Result<Emoji, Throwable> result = loadEmoji(file);
			result.ifOk(loaded::add);
			result.ifError(localErrors::add);
		}

		if (localErrors.isEmpty())
		{
			return Ok(loaded);
		}
		else
		{
			return PartialOk(loaded, localErrors);
		}

	}

	private Result<Soundoji, Throwable> loadSoundoji(File file)
	{
		int extension = file.getName().lastIndexOf('.');

		if (extension < 0)
		{
			return Error(new IllegalArgumentException("Illegal file name " + file));
		}

		String text = file.getName().substring(0, extension).toLowerCase();
		return Ok(new Soundoji(text, file));

	}


	private List<File> flattenFolder(@NonNull File folder)
	{
		return flattenFolder(folder, 0);
	}

	private List<File> flattenFolder(@NonNull File folder, int depth)
	{
		// sanity guard
		final long MAX_DEPTH = 8;

		if (depth > MAX_DEPTH)
		{
			log.warn("Max depth of {} was reached path:{}", depth, folder);
			return List.of();
		}

		// file found
		if (!folder.isDirectory())
		{
			return List.of(folder);
		}

		// no childs
		File[] childs = folder.listFiles();
		if (childs == null)
		{
			return List.of();
		}

		List<File> flattened = new ArrayList<>();
		for (File child : childs)
		{
			flattened.addAll(flattenFolder(child, depth + 1));
		}

		return flattened;
	}

	private Result<Emoji, Throwable> loadEmoji(File file)
	{
		int extension = file.getName().lastIndexOf('.');

		if (extension < 0)
		{
			return Error(new IllegalArgumentException("Illegal file name <col=00FFFF>" + file));
		}

		String text = file.getName().substring(0, extension).toLowerCase();
		long fileModified = file.lastModified();

		// Check if we already have an emoji with this name
		Emoji existingEmoji = this.emojis.get(text);

		// If emoji exists and file hasn't been modified, return existing emoji unchanged
		if (existingEmoji != null && existingEmoji.getLastModified() == fileModified)
		{
			log.debug("Emoji file unchanged, skipping: {} (last modified: {})", text, fileModified);
			return Ok(existingEmoji);
		}

		// File has been modified or is new, need to load image
		Result<BufferedImage, Throwable> image = loadImage(file);

		if (image.isOk())
		{
			try
			{
				int id;

				boolean shouldResize = this.shouldResizeEmoji(text);
				BufferedImage normalizedImage = CustomEmojiImageUtilities.normalizeImage(image.unwrap(), this.config, shouldResize);

				if (existingEmoji != null)
				{
					// Update existing emoji in place
					this.chatIconManager.updateChatIcon(existingEmoji.getId(), normalizedImage);
					id = existingEmoji.getId();
					log.info("Updated existing chat icon for emoji: {} (id: {})", text, id);
				}
				else
				{
					// Register new emoji
					id = chatIconManager.registerChatIcon(normalizedImage);
					log.info("Registered new chat icon for emoji: {} (id: {})", text, id);
				}

				Dimension dimension = new Dimension(normalizedImage.getWidth(), normalizedImage.getHeight());

				return Ok(new Emoji(id, text, file, fileModified, dimension));
			}
			catch (RuntimeException e)
			{
				return Error(new RuntimeException(
						"<col=FF0000>" + file.getName() + "</col> failed because <col=FF0000>" + e.getMessage(),
						e));
			}
		}
		else
		{
			Throwable throwable = image.unwrapError();
			return Error(new RuntimeException(
					"<col=FF0000>" + file.getName() + "</col> failed because <col=FF0000>" + throwable.getMessage(),
					throwable));
		}
	}

	/**
	 * Reloads a single emoji with updated resizing settings.
	 * @param emojiName The name of the emoji to reload
	 */
	public void reloadSingleEmoji(String emojiName)
	{
		Emoji emoji = this.emojis.get(emojiName);
		if (emoji == null)
		{
			log.warn("Cannot reload emoji '{}' - not found", emojiName);
			return;
		}

		File file = emoji.getFile();
		Result<BufferedImage, Throwable> imageResult = loadImage(file);

		if (imageResult.isOk())
		{
			try
			{
				boolean shouldResize = this.shouldResizeEmoji(emojiName);
				BufferedImage normalizedImage = CustomEmojiImageUtilities.normalizeImage(imageResult.unwrap(), this.config, shouldResize);

				this.chatIconManager.updateChatIcon(emoji.getId(), normalizedImage);

				Dimension dimension = new Dimension(normalizedImage.getWidth(), normalizedImage.getHeight());
				Emoji updatedEmoji = new Emoji(emoji.getId(), emojiName, file, file.lastModified(), dimension);
				this.emojis.put(emojiName, updatedEmoji);

				log.info("Reloaded emoji '{}' with resizing={}", emojiName, shouldResize);
			}
			catch (RuntimeException e)
			{
				log.error("Failed to reload emoji '{}'", emojiName, e);
			}
		}
		else
		{
			log.error("Failed to load image for emoji '{}'", emojiName, imageResult.unwrapError());
		}
	}

	/**
	 * Determines if a specific emoji should be resized based on per-emoji settings.
	 * Returns true if the emoji is NOT in the resizing disabled list.
	 */
	private boolean shouldResizeEmoji(String emojiName)
	{
		Set<String> resizingDisabledEmojis = PluginUtils.parseResizingDisabledEmojis(this.config.resizingDisabledEmojis());
		return !resizingDisabledEmojis.contains(emojiName);
	}

	public static Result<BufferedImage, Throwable> loadImage(final File file)
	{
		try (InputStream in = new FileInputStream(file))
		{
			synchronized (ImageIO.class)
			{
				BufferedImage read = ImageIO.read(in);
				if (read == null)
				{
					return Error(new IOException("image format not supported. (PNG,JPG,GIF only)"));
				}

				return Ok(read);
			}
		}
		catch (IllegalArgumentException | IOException e)
		{
			return Error(e);
		}
	}

	private static String extractFileName(String errorMessage)
	{
		// Extract just the filename from error messages like:
		// "<col=FF0000>filename.ext</col> failed because..."
		// or "Illegal file name <col=00FFFF>C:\full\path\filename"
		if (errorMessage.contains("<col="))
		{
			int start = errorMessage.indexOf(">");
			int end = errorMessage.indexOf("</col>");
			if (start != -1 && end != -1 && start < end)
			{
				String fullPath = errorMessage.substring(start + 1, end);
				// Extract just the filename from full path
				return fullPath.substring(fullPath.lastIndexOf(File.separator) + 1);
			}
		}

		// Fallback: try to extract filename from full path
		if (errorMessage.contains(File.separator))
		{
			String[] parts = errorMessage.split("[" + Pattern.quote(File.separator) + "]");
			if (parts.length > 0)
			{
				return parts[parts.length - 1];
			}
		}

		return errorMessage;
	}

	public static float volumeToGain(int volume100)
	{
		// range[NOISE_FLOOR, 0]
		float gainDB;

		// Graph of the function
		// https://www.desmos.com/calculator/wdhsfbxgeo

		// clamp to 0-100
		float volume = Math.min(100, volume100);
		// convert linear volume 0-100 to log control
		if (volume <= 0.1)
		{
			gainDB = NOISE_FLOOR;
		}
		else
		{
			gainDB = (float) (10 * (Math.log(volume / 100)));
		}

		return gainDB;
	}

	private void setupFileWatcher() throws IOException
	{
		watchService = FileSystems.getDefault().newWatchService();

		// Register emoji and soundoji folders for watching
		Path emojiPath = EMOJIS_FOLDER.toPath();
		Path soundojiPath = SOUNDOJIS_FOLDER.toPath();

		if (Files.exists(emojiPath))
		{
			registerRecursively(emojiPath);
		}

		if (Files.exists(soundojiPath))
		{
			registerRecursively(soundojiPath);
		}

		watcherExecutor = Executors.newSingleThreadExecutor(r ->
		{
			Thread t = new Thread(r, "CustomEmoji-FileWatcher");
			t.setDaemon(true);
			return t;
		});

		// Create executor for debouncing reloads (many files changed at once, potentially from a git pull)
		debounceExecutor = Executors.newSingleThreadScheduledExecutor(r ->
		{
			Thread t = new Thread(r, "CustomEmoji-Debouncer");
			t.setDaemon(true);
			return t;
		});

		watcherExecutor.submit(this::watchForChanges);

		log.info("File watcher setup complete for emoji folders");
	}

	private void registerRecursively(Path path) throws IOException
	{
		path.register(watchService,
			StandardWatchEventKinds.ENTRY_CREATE,
			StandardWatchEventKinds.ENTRY_DELETE,
			StandardWatchEventKinds.ENTRY_MODIFY);

		try (Stream<Path> walkStream = Files.walk(path))
		{
			walkStream
				.filter(Files::isDirectory)
				.filter(p -> !p.equals(path))
				.filter(p -> !p.getFileName().toString().equals(".git")) // Ignore .git folders
				.forEach(subPath ->
				{
					try
					{
						subPath.register(watchService,
							StandardWatchEventKinds.ENTRY_CREATE,
							StandardWatchEventKinds.ENTRY_DELETE,
							StandardWatchEventKinds.ENTRY_MODIFY);
					}
					catch (IOException e)
					{
						log.error("Failed to register subdirectory for watching: " + subPath, e);
					}
				});
		}
	}

	private void watchForChanges()
	{
		while (!Thread.currentThread().isInterrupted())
		{
			try
			{
				// Check if watch service is still open before attempting to use it
				if (watchService == null)
				{
					log.debug("Watch service is null, stopping file watcher");
					break;
				}

				WatchKey key = watchService.take();

				// Check again after take() in case watch service was closed
				if (watchService == null)
				{
					log.debug("Watch service closed during take(), stopping file watcher");
					break;
				}

				boolean shouldReload = false;
				for (WatchEvent<?> event : key.pollEvents())
				{
					if (event == null || event.kind() == StandardWatchEventKinds.OVERFLOW)
					{
						continue;
					}

					@SuppressWarnings("unchecked")
					WatchEvent<Path> pathEvent = (WatchEvent<Path>) event;

					Path changed = pathEvent.context();

					// Skip if context is null (can happen during shutdown or filesystem issues)
					if (changed == null)
					{
						log.debug("Skipping file event with null context");
						continue;
					}

					// Only reload if it's an image or audio file
					if (isEmojiFile(changed) || isSoundojiFile(changed))
					{
						shouldReload = true;
						log.debug("Detected change in emoji/soundoji file: " + changed);
					}

					// If new directory created, register it for watching
					if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE)
					{
						if (key.watchable() == null)
						{
							log.debug("Skipping directory registration - key watchable is null");
							continue;
						}

						Path fullPath = ((Path) key.watchable()).resolve(changed);
						if (Files.isDirectory(fullPath))
						{
							try
							{
								// Check if watch service is still valid before registering
								if (watchService != null)
								{
									registerRecursively(fullPath);
									log.debug("Registered new directory for watching: " + fullPath);
								}
							}
							catch (IOException e)
							{
								log.error("Failed to register new directory: " + fullPath, e);
							}
						}
					}
				}

				if (shouldReload)
				{
					scheduleReload(false);
				}

				if (!key.reset())
				{
					// Key is no longer valid (directory was deleted/replaced, e.g., during git branch switch)
					// Don't break the loop - re-register all directories to pick up new structure
					log.debug("Watch key reset failed, re-registering directories");
					try
					{
						Path emojiPath = EMOJIS_FOLDER.toPath();
						Path soundojiPath = SOUNDOJIS_FOLDER.toPath();

						if (Files.exists(emojiPath))
						{
							registerRecursively(emojiPath);
						}
						if (Files.exists(soundojiPath))
						{
							registerRecursively(soundojiPath);
						}
					}
					catch (IOException e)
					{
						log.error("Failed to re-register directories after key reset failure", e);
					}
				}
			}
			catch (InterruptedException e)
			{
				log.debug("File watcher interrupted, stopping");
				Thread.currentThread().interrupt();
				break;
			}
			catch (Exception e)
			{
				// Check if this is due to closed watch service
				if (watchService == null)
				{
					log.debug("File watcher error due to closed watch service, stopping");
					break;
				}
				log.error("Error in file watcher", e);
				// Break on repeated errors to prevent spam
				break;
			}
		}
		log.debug("File watcher thread exiting");
	}

	private boolean isEmojiFile(Path path)
	{
		String fileName = path.getFileName().toString().toLowerCase();
		return fileName.endsWith(".png") || fileName.endsWith(".jpg") || fileName.endsWith(".jpeg") || fileName.endsWith(".gif");
	}

	private boolean isSoundojiFile(Path path)
	{
		String fileName = path.getFileName().toString().toLowerCase();
		return fileName.endsWith(".wav");
	}

	private void reloadEmojis(boolean force)
	{
		log.info("Reloading emojis and soundojis due to file changes");

		// Store current emoji names for deletion detection
		Set<String> currentEmojiNames = new HashSet<>(emojis.keySet());

		if (force)
		{
			emojis.clear();
		}

		soundojis.clear();

		errors.clear();

		// Reload emojis (using updateChatIcon for existing, registerChatIcon for new)
		File emojiFolder = EMOJIS_FOLDER;
		if (emojiFolder.exists())
		{
			var result = loadEmojisFolder(emojiFolder);

			// Track which emojis are still present
			Set<String> newEmojiNames = new HashSet<>();
			result.ifOk(list ->
			{
				list.forEach(e ->
				{
					emojis.put(e.getText(), e);
					newEmojiNames.add(e.getText());
				});
				log.info("Loaded {} emojis", result.unwrap().size());
			});
			result.ifError(e ->
			{
				e.forEach(t ->
				{
					String fileName = extractFileName(t.getMessage());
					log.debug("Skipped non-emoji file: {}", fileName);
				});
			});

			// Remove deleted emojis from our map
			currentEmojiNames.removeAll(newEmojiNames);
			currentEmojiNames.forEach(deletedEmoji ->
			{
				log.debug("Removing deleted emoji: {}", deletedEmoji);
				emojis.remove(deletedEmoji);
			});
		}
		else
		{
			log.warn("Emoji folder does not exist: {}", emojiFolder);
			emojis.clear();
		}

		loadSoundojis();

		String message = String.format("<col=00FF00>Custom Emoji: Reloaded %d emojis and %d soundojis", emojis.size(), soundojis.size());

		client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);

		// Refresh the panel to show updated emoji tree
		if (panel != null)
		{
			SwingUtilities.invokeLater(() -> panel.refreshEmojiTree());
		}
	}

	private void scheduleReload(boolean force)
	{
		synchronized (this)
		{
			// Don't schedule reload if debounceExecutor is null (during shutdown)
			if (debounceExecutor.isShutdown())
			{
				log.debug("Skipping reload schedule - executor is shutdown");
				return;
			}

			// Cancel any pending reload
			if (pendingReload != null && !pendingReload.isDone())
			{
				pendingReload.cancel(false);
				log.debug("Cancelled pending emoji reload due to new file changes");
			}

			// Schedule new reload with debounce delay
			pendingReload = debounceExecutor.schedule(() ->
			{
				clientThread.invokeLater(() -> reloadEmojis(force));
			}, 500, TimeUnit.MILLISECONDS);

			log.debug("Scheduled emoji reload with 500ms debounce");
		}
	}

	@Provides
	CustomEmojiConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CustomEmojiConfig.class);
	}

	@Provides
	Map<String, Emoji> provideEmojis()
	{
		return this.emojis;
	}

	@Provides
	@Named("disabledEmojis")
	Set<String> provideDisabledEmojis()
	{
		return PluginUtils.parseDisabledEmojis(this.config.disabledEmojis());
	}

	@Provides
	@Named("resizingDisabledEmojis")
	Set<String> provideResizingDisabledEmojis()
	{
		return PluginUtils.parseResizingDisabledEmojis(this.config.resizingDisabledEmojis());
	}

	public void openConfiguration()
	{
		// We don't have access to the ConfigPlugin so let's just emulate an overlay click
		this.eventBus.post(new OverlayMenuClicked(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, null, null), this.overlay));
	}
}

package com.customemoji.model;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;

import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.client.game.ChatIconManager;

import com.customemoji.CustomEmojiImageUtilities;

@Value
public class Emoji
{
	int id;
	String text;
	File file;
	long lastModified;
	Dimension dimension;

	public BufferedImage getCacheImage(Client client, ChatIconManager chatIconManager)
	{
		int iconIndex = chatIconManager.chatIconIndex(this.id);
		if (iconIndex < 0)
		{
			return null;
		}

		IndexedSprite[] modIcons = client.getModIcons();
		if (modIcons == null || iconIndex >= modIcons.length)
		{
			return null;
		}

		IndexedSprite indexedSprite = modIcons[iconIndex];
		if (indexedSprite != null)
		{
			return CustomEmojiImageUtilities.indexedSpriteToBufferedImage(indexedSprite);
		}

		return null;
	}
}
package com.customemoji.model;

import java.io.File;

import lombok.Value;

@Value
public class Soundoji
{
	String text;
	File file;
}
package com.customemoji;

import java.awt.Rectangle;

/**
 * Represents the calculated position and bounds of an emoji within a chat widget.
 */
public class EmojiPosition
{
    private final int imageId;
    private final Rectangle bounds;

    public EmojiPosition(int imageId, Rectangle bounds)
    {
        this.imageId = imageId;
        this.bounds = bounds;
    }

    public int getImageId()
    {
        return this.imageId;
    }

    public Rectangle getBounds()
    {
        return this.bounds;
    }

    public int getX()
    {
        return this.bounds.x;
    }

    public int getY()
    {
        return this.bounds.y;
    }

    public int getWidth()
    {
        return this.bounds.width;
    }

    public int getHeight()
    {
        return this.bounds.height;
    }

    public boolean containsPoint(int x, int y)
    {
        return this.bounds.contains(x, y);
    }
}
package com.customemoji;

import net.runelite.client.config.*;

@ConfigGroup(CustomEmojiConfig.KEY_CONFIG_GROUP)
public interface CustomEmojiConfig extends Config
{
	// Configuration constants
	String KEY_CONFIG_GROUP = "custom-emote";
	String KEY_MAX_IMAGE_HEIGHT = "max_image_height";
	String KEY_SUGGESTION_OVERLAY = "suggestion_overlay";
	String KEY_OVERLAY_MAX_SUGGESTIONS = "overlay_max_suggestions";
	String KEY_SHOW_EMOJI_TOOLTIPS = "show_emoji_tooltips";
	String KEY_VOLUME = "volume";
	String KEY_CHAT_MESSAGE_SPACING = "chat_message_spacing";
	String KEY_SHOW_SIDE_PANEL = "show_panel";
	String KEY_DISABLED_EMOJIS = "disabled_emojis";
	String KEY_RESIZING_DISABLED_EMOJIS = "resizing_disabled_emojis";
	
	// Emoji section
	@ConfigSection(
			name = "Emoji Settings",
			description = "Emoji configuration options",
			position = 1
	)
	String EMOJI_SECTION = "emojiSettingsSection";

	@ConfigItem(
			keyName = KEY_MAX_IMAGE_HEIGHT,
			name = "Max Emoji Height",
			description = "Configures the maximum image height (in pixels) for emojis with resizing enabled.",
			section = EMOJI_SECTION,
			position = 0
	)
	default int maxImageHeight() { return 24; }

	@ConfigItem(
		keyName = KEY_SUGGESTION_OVERLAY,
		name = "Show Suggestion Overlay",
		description = "Displays a list of potential emoji in an overlay while you're typing a chat message.",
		section = EMOJI_SECTION,
		position = 1
	)
	default boolean showOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_OVERLAY_MAX_SUGGESTIONS,
		name = "Max Suggestions",
		description = "Configures the maximum number of suggestions for the emoji suggestion overlay.",
		section = EMOJI_SECTION,
		position = 2
	)
	default int maxImageSuggestions() { return 10; }

	@ConfigItem(
		keyName = KEY_SHOW_EMOJI_TOOLTIPS,
		name = "Show Emoji Tooltips",
		description = "Shows the emoji name in a tooltip when hovering over emojis in chat messages.",
		section = EMOJI_SECTION,
		position = 3
	)
	default boolean showEmojiTooltips() { return true; }

	// Soundoji section
	@ConfigSection(
			name = "Soundoji",
			description = "Soundoji configuration options",
			position = 2
	)
	String SOUNDOJI_SECTION = "overlaySection";

	@ConfigItem(
			keyName = KEY_VOLUME,
			name = "Soundoji Volume",
			description = "Volume of soundojis. [0-100]",
			position = 0,
			section = SOUNDOJI_SECTION
	)
	@Range(min = 0, max = 100)
	default int volume()
	{
		return 70;
	}

	// Chat section
	@ConfigSection(
			name = "Chat Widget",
			description = "Chat display configuration options",
			position = 3
	)
	String CHAT_SECTION = "chatSection";

	@ConfigItem(
			keyName = KEY_CHAT_MESSAGE_SPACING,
			name = "Chat Message Spacing",
			description = "Adjusts the vertical spacing between chat messages (in pixels). Default is 0.",
			section = CHAT_SECTION,
			position = 0
	)
	@Range(min = 0, max = 20)
	default int chatMessageSpacing()
	{
		return 0;
	}

	@ConfigItem(
			keyName = KEY_SHOW_SIDE_PANEL,
			name = "Show Emoji Panel",
			description = "Show the emoji selection panel in the sidebar",
			section = EMOJI_SECTION,
			position = 4
	)
	default boolean showPanel()
	{
		return true;
	}

	@ConfigItem(
			keyName = KEY_DISABLED_EMOJIS,
			name = "",
			description = "",
			hidden = true
	)
	default String disabledEmojis()
	{
		return "";
	}

	@ConfigItem(
		keyName = KEY_RESIZING_DISABLED_EMOJIS,
		name = "",
		description = "",
		hidden = true
	)
	default String resizingDisabledEmojis()
	{
		return "";
	}
}

package com.customemoji;

import net.runelite.api.FontTypeFace;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;

import java.awt.Dimension;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lombok.extern.slf4j.Slf4j;

/**
 * Utility class for calculating emoji positions within chat widgets.
 * Shared between CustomEmojiTooltip and debug overlay.
 */
@Slf4j
public class EmojiPositionCalculator
{
    private static final Pattern IMG_PATTERN = Pattern.compile("<img=(\\d+)>");
    private static final int LINE_HEIGHT = 14;
    private static final int VERTICAL_OFFSET = 2;
    private static final int DEFAULT_EMOJI_SIZE = 18;

    /**
     * Functional interface for looking up emoji dimensions by image ID.
     */
    @FunctionalInterface
    public interface DimensionLookup
    {
        Dimension getDimension(int imageId);
    }

    /**
     * Calculates the positions of all emojis in the given widget text.
     *
     * @param widget The widget containing the text
     * @param text The text content (with img tags)
     * @param dimensionLookup Function to look up emoji dimensions by image ID
     * @return List of EmojiPosition objects with absolute coordinates
     */
    public static List<EmojiPosition> calculateEmojiPositions(Widget widget, String text, DimensionLookup dimensionLookup)
    {
        List<EmojiPosition> positions = new ArrayList<>();

        Matcher matcher = IMG_PATTERN.matcher(text);
        Point widgetPos = widget.getCanvasLocation();
        if (widgetPos == null)
        {
            return positions;
        }

        FontTypeFace font;
        try
        {
            font = widget.getFont();
        }
        catch (Exception e)
        {
            log.error("Error getting font for widget", e);
            return positions;
        }

        if (font == null)
        {
            return positions;
        }

        int textIndex = 0;
        int currentX = 0;
        int currentLine = 0;

        while (matcher.find())
        {
            String textBefore = text.substring(textIndex, matcher.start());
            String cleanTextBefore = removeHtmlTags(textBefore);

            // Simulate word-based line wrapping (OSRS wraps at spaces, not mid-word)
            String[] words = cleanTextBefore.split("(?<= )");
            for (String word : words)
            {
                int wordWidth = font.getTextWidth(word);
                if (currentX + wordWidth > widget.getWidth() && currentX > 0)
                {
                    currentX = 0;
                    currentLine++;
                }
                currentX += wordWidth;
            }

            String imageIdStr = matcher.group(1);
            int imageId = Integer.parseInt(imageIdStr);

            // Get emoji dimensions
            int emojiWidth = DEFAULT_EMOJI_SIZE;
            int emojiHeight = DEFAULT_EMOJI_SIZE;

            Dimension dimension = dimensionLookup.getDimension(imageId);
            if (dimension != null)
            {
                emojiWidth = dimension.width;
                emojiHeight = dimension.height;
            }

            // Check if emoji itself would wrap to next line
            if (currentX + emojiWidth > widget.getWidth() && currentX > 0)
            {
                currentX = 0;
                currentLine++;
            }

            int emojiStartX = currentX;

            // Calculate Y position based on which line the emoji is on
            // Emoji is bottom-aligned within the line, but offset 2px up from the bottom
            int lineBottomY = (currentLine + 1) * LINE_HEIGHT;
            int emojiBottomY = lineBottomY - VERTICAL_OFFSET;
            int emojiTopY = emojiBottomY - emojiHeight;

            int absoluteX = widgetPos.getX() + emojiStartX;
            int absoluteY = widgetPos.getY() + emojiTopY;

            Rectangle bounds = new Rectangle(absoluteX, absoluteY, emojiWidth, emojiHeight);
            positions.add(new EmojiPosition(imageId, bounds));

            currentX = emojiStartX + emojiWidth;
            textIndex = matcher.end();
        }

        return positions;
    }

    /**
     * Finds the emoji at the given point within a widget.
     *
     * @param widget The widget containing the text
     * @param text The text content (with img tags)
     * @param pointX Absolute X coordinate to check
     * @param pointY Absolute Y coordinate to check
     * @param dimensionLookup Function to look up emoji dimensions by image ID
     * @return The image ID of the emoji at the point, or -1 if none found
     */
    public static int findEmojiAtPoint(Widget widget, String text, int pointX, int pointY, DimensionLookup dimensionLookup)
    {
        List<EmojiPosition> positions = calculateEmojiPositions(widget, text, dimensionLookup);

        for (EmojiPosition position : positions)
        {
            if (position.containsPoint(pointX, pointY))
            {
                return position.getImageId();
            }
        }

        return -1;
    }

    private static String removeHtmlTags(String text)
    {
        if (text == null)
        {
            return "";
        }
        return text.replaceAll("<[^>]*>", "");
    }
}
package com.customemoji.panel;

import com.customemoji.CustomEmojiPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ImageUtil;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Desktop;
import java.awt.FlowLayout;
import java.awt.Insets;
import java.io.File;
import java.net.URI;

/**
 * Header panel containing the title and action buttons (settings, GitHub, folder).
 */
@Slf4j
public class HeaderPanel extends JPanel
{
	private static final String GITHUB_URL = "https://github.com/LouisGameDev/runelite-custom-emoji";

	private final transient Runnable openSettingsAction;

	public HeaderPanel(Runnable openSettingsAction)
	{
		super(new BorderLayout());
		this.openSettingsAction = openSettingsAction;
		this.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		this.initializeComponents();
	}

	private void initializeComponents()
	{
		JLabel titleLabel = new JLabel("Custom Emoji");
		titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));

		JPanel buttonsPanel = this.createButtonsPanel();

		this.add(titleLabel, BorderLayout.WEST);
		this.add(buttonsPanel, BorderLayout.EAST);
	}

	private JPanel createButtonsPanel()
	{
		JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));

		JButton settingsButton = this.createButton(PanelConstants.ICON_WRENCH, "Open plugin settings");
		settingsButton.addActionListener(e -> this.openSettings());

		JButton githubButton = this.createButton(PanelConstants.ICON_GITHUB, "Open GitHub repository");
		githubButton.addActionListener(e -> this.openGitHub());

		JButton folderButton = this.createButton(PanelConstants.ICON_FOLDER_FILL, "Open emoji folder");
		folderButton.addActionListener(e -> this.openEmojiFolder());

		buttonsPanel.add(settingsButton);
		buttonsPanel.add(githubButton);
		buttonsPanel.add(folderButton);

		return buttonsPanel;
	}

	private JButton createButton(String iconName, String tooltip)
	{
		JButton button = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, iconName)));
		button.setToolTipText(tooltip);
		button.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		button.setMargin(new Insets(0, 0, 0, 0));
		return button;
	}

	private void openSettings()
	{
		this.openSettingsAction.run();
	}

	private void openGitHub()
	{
		try
		{
			Desktop desktop = Desktop.getDesktop();
			desktop.browse(new URI(GITHUB_URL));
		}
		catch (Exception e)
		{
			log.warn("Failed to open GitHub", e);
		}
	}

	private void openEmojiFolder()
	{
		try
		{
			File emojisFolder = CustomEmojiPlugin.EMOJIS_FOLDER;
			if (emojisFolder.exists())
			{
				Desktop desktop = Desktop.getDesktop();
				desktop.open(emojisFolder);
			}
		}
		catch (Exception e)
		{
			log.warn("Failed to open emoji folder", e);
		}
	}
}


package com.customemoji.panel;

import java.awt.Color;
import java.awt.Dimension;

/**
 * Centralized color and dimension constants for the panel UI.
 */
public final class PanelConstants
{
	private PanelConstants()
	{
		// Utility class - prevent instantiation
	}

	// Background colors
	public static final Color HEADER_BACKGROUND = new Color(30, 30, 30);
	public static final Color CONTENT_BACKGROUND = new Color(40, 40, 40);
	public static final Color ROW_HOVER_BACKGROUND = new Color(50, 50, 50);

	// Border colors
	public static final Color HEADER_BORDER = new Color(60, 60, 60);

	// Text colors
	public static final Color FOLDER_TEXT = new Color(220, 138, 0);
	public static final Color ENABLED_TEXT = Color.WHITE;
	public static final Color DISABLED_TEXT = Color.GRAY;

	// Warning/error colors
	public static final Color WARNING_FILL = new Color(255, 150, 50);
	public static final Color WARNING_BORDER = new Color(200, 100, 0);

	// Dimensions
	public static final Dimension HEADER_BUTTON_SIZE = new Dimension(30, 25);

	// Icon file names
	public static final String ICON_ARROW_LEFT = "arrow-left.png";
	public static final String ICON_ARROW_CLOCKWISE = "arrow-clockwise.png";
	public static final String ICON_ARROWS_CONTRACT = "arrows-angle-contract.png";
	public static final String ICON_ARROWS_EXPAND = "arrows-angle-expand.png";
	public static final String ICON_BOUNDING_BOX = "bounding-box.png";
	public static final String ICON_FOLDER_FILL = "folder-fill.png";
	public static final String ICON_GITHUB = "github.png";
	public static final String ICON_WRENCH = "wrench.png";
	public static final String ICON_WARNING = "exclamation-triangle-fill.png";
}


package com.customemoji.panel;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.UIManager;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.function.Consumer;

/**
 * Search panel with a text field and magnifying glass icon for filtering emojis.
 * Search is triggered when the user presses Enter.
 */
public class SearchPanel extends JPanel
{
	private static final String PLACEHOLDER_TEXT = "Press Enter to search";
	private static final String TEXTFIELD_FOREGROUND = "TextField.foreground";

	private JTextField searchField;
	private JButton clearButton;
	private transient Consumer<String> searchCallback;
	private boolean showingPlaceholder = true;
	private boolean ignoringDocumentChanges = false;

	public SearchPanel(Consumer<String> searchCallback)
	{
		super(new BorderLayout(5, 0));
		this.searchCallback = searchCallback;
		this.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		this.initializeComponents();
	}

	public String getSearchText()
	{
		if (this.showingPlaceholder)
		{
			return "";
		}
		return this.searchField.getText();
	}

	public void setSearchText(String text)
	{
		if (text == null || text.isEmpty())
		{
			this.clearSearch();
		}
		else
		{
			this.searchField.setText(text);
			this.searchField.setForeground(UIManager.getColor(TEXTFIELD_FOREGROUND));
			this.showingPlaceholder = false;
			this.updateClearButtonVisibility();
		}
	}

	public void clearSearch()
	{
		boolean hadText = !this.showingPlaceholder && !this.searchField.getText().isEmpty();

		this.ignoringDocumentChanges = true;
		if (this.searchField.hasFocus())
		{
			this.searchField.setText("");
			this.searchField.setForeground(UIManager.getColor(TEXTFIELD_FOREGROUND));
			this.showingPlaceholder = false;
		}
		else
		{
			this.searchField.setText(PLACEHOLDER_TEXT);
			this.searchField.setForeground(Color.GRAY);
			this.showingPlaceholder = true;
		}
		this.ignoringDocumentChanges = false;

		this.clearButton.setVisible(false);

		if (hadText && this.searchCallback != null)
		{
			this.searchCallback.accept("");
		}
	}

	private void initializeComponents()
	{
		this.searchField = new JTextField(PLACEHOLDER_TEXT);
		this.searchField.setForeground(Color.GRAY);
		this.searchField.setPreferredSize(new Dimension(200, 25));
		this.searchField.setMinimumSize(new Dimension(200, 25));
		this.searchField.setMaximumSize(new Dimension(200, 25));

		this.setupPlaceholderBehavior();
		this.setupKeyListeners();

		JLabel searchIcon = new JLabel("");
		searchIcon.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

		this.clearButton = new JButton("");
		this.clearButton.setPreferredSize(new Dimension(20, 20));
		this.clearButton.setMargin(new Insets(0, 0, 0, 0));
		this.clearButton.setBorder(BorderFactory.createEmptyBorder());
		this.clearButton.setContentAreaFilled(false);
		this.clearButton.setFocusPainted(false);
		this.clearButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		this.clearButton.setToolTipText("Clear search");
		this.clearButton.setVisible(false);
		this.clearButton.addActionListener(e -> this.clearSearch());

		JPanel searchFieldPanel = new JPanel(new BorderLayout());
		searchFieldPanel.add(searchIcon, BorderLayout.WEST);
		searchFieldPanel.add(this.searchField, BorderLayout.CENTER);
		searchFieldPanel.add(this.clearButton, BorderLayout.EAST);
		searchFieldPanel.setBorder(this.searchField.getBorder());
		searchFieldPanel.setBackground(this.searchField.getBackground());

		this.searchField.setBorder(BorderFactory.createEmptyBorder());

		this.add(searchFieldPanel, BorderLayout.CENTER);
	}

	private void setupPlaceholderBehavior()
	{
		this.searchField.addFocusListener(new FocusListener()
		{
			@Override
			public void focusGained(FocusEvent e)
			{
				if (SearchPanel.this.showingPlaceholder)
				{
					SearchPanel.this.ignoringDocumentChanges = true;
					SearchPanel.this.searchField.setText("");
					SearchPanel.this.ignoringDocumentChanges = false;
					SearchPanel.this.searchField.setForeground(UIManager.getColor(TEXTFIELD_FOREGROUND));
					SearchPanel.this.showingPlaceholder = false;
					SearchPanel.this.updateClearButtonVisibility();
				}
			}

			@Override
			public void focusLost(FocusEvent e)
			{
				if (SearchPanel.this.searchField.getText().isEmpty())
				{
					SearchPanel.this.showingPlaceholder = true;
					SearchPanel.this.ignoringDocumentChanges = true;
					SearchPanel.this.searchField.setText(PLACEHOLDER_TEXT);
					SearchPanel.this.ignoringDocumentChanges = false;
					SearchPanel.this.searchField.setForeground(Color.GRAY);
					SearchPanel.this.clearButton.setVisible(false);
				}
			}
		});

		this.searchField.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				SearchPanel.this.updateClearButtonVisibility();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				SearchPanel.this.updateClearButtonVisibility();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				SearchPanel.this.updateClearButtonVisibility();
			}
		});
	}

	private void setupKeyListeners()
	{
		this.searchField.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					SearchPanel.this.performSearch();
				}
				else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					SearchPanel.this.searchField.transferFocus();
				}
			}
		});
	}

	private void updateClearButtonVisibility()
	{
		if (this.ignoringDocumentChanges)
		{
			return;
		}
		boolean hasText = !this.showingPlaceholder && !this.searchField.getText().isEmpty();
		this.clearButton.setVisible(hasText);
	}

	private void performSearch()
	{
		if (this.searchCallback != null && !this.showingPlaceholder)
		{
			String searchText = this.searchField.getText().toLowerCase().trim();
			this.searchCallback.accept(searchText);
		}
	}
}


package com.customemoji.panel.tree;

import com.customemoji.CustomEmojiPlugin;
import com.customemoji.model.Emoji;
import net.runelite.api.Client;
import net.runelite.client.game.ChatIconManager;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Builds and manages the folder structure for the emoji tree.
 */
public class FolderStructureBuilder
{
	public static final String PATH_SEPARATOR = "/";
	public static final String ROOT_FOLDER_NAME = "All Emoji";

	private final Client client;
	private final ChatIconManager chatIconManager;
	private final Map<String, Emoji> emojis;
	private final Set<String> disabledEmojis;
	private final Set<String> resizingDisabledEmojis;

	private Map<String, List<EmojiTreeNode>> folderContents = new HashMap<>();

	public FolderStructureBuilder(Client client, ChatIconManager chatIconManager,
								   Map<String, Emoji> emojis,
								   Set<String> disabledEmojis,
								   Set<String> resizingDisabledEmojis)
	{
		this.client = client;
		this.chatIconManager = chatIconManager;
		this.emojis = emojis;
		this.disabledEmojis = disabledEmojis;
		this.resizingDisabledEmojis = resizingDisabledEmojis;
	}

	public Map<String, List<EmojiTreeNode>> build(String searchFilter)
	{
		this.folderContents.clear();
		File emojisFolder = CustomEmojiPlugin.EMOJIS_FOLDER;

		Map<String, Set<String>> subfoldersByPath = new HashMap<>();
		subfoldersByPath.put("", new HashSet<>());
		subfoldersByPath.get("").add(ROOT_FOLDER_NAME);
		subfoldersByPath.put(ROOT_FOLDER_NAME, new HashSet<>());

		for (Map.Entry<String, Emoji> entry : this.emojis.entrySet())
		{
			String emojiName = entry.getKey();
			Emoji emoji = entry.getValue();
			File emojiFile = emoji.getFile();

			boolean matchesFilter = this.matchesSearchFilter(emojiName, emojiFile, emojisFolder, searchFilter);
			if (!matchesFilter)
			{
				continue;
			}

			String relativeFolderPath = this.extractFolderPath(emojiFile, emojisFolder);
			String folderPath = relativeFolderPath.isEmpty()
				? ROOT_FOLDER_NAME
				: ROOT_FOLDER_NAME + PATH_SEPARATOR + relativeFolderPath;
			this.registerParentFolders(folderPath, subfoldersByPath);
			this.addEmojiItem(emojiName, emoji, folderPath);
		}

		this.addFolderItems(subfoldersByPath);
		this.sortFolderContents();

		return this.folderContents;
	}

	public Map<String, List<EmojiTreeNode>> getFolderContents()
	{
		return this.folderContents;
	}

	public boolean calculateFolderEnabled(String folderPath)
	{
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			String path = entry.getKey();
			boolean isInFolder = path.equals(folderPath) || path.startsWith(folderPath + PATH_SEPARATOR);

			if (isInFolder)
			{
				for (EmojiTreeNode item : entry.getValue())
				{
					boolean isEmojiEnabled = !item.isFolder() && item.isEnabled();
					if (isEmojiEnabled)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	public boolean calculateFolderResizingEnabled(String folderPath)
	{
		List<String> enabledEmojiNames = this.getEnabledEmojiNamesInFolder(folderPath);
		boolean hasNoEnabledEmojis = enabledEmojiNames.isEmpty();

		if (hasNoEnabledEmojis)
		{
			return false;
		}

		boolean anyHasResizingDisabled = this.anyEmojiHasResizingDisabled(enabledEmojiNames);
		return !anyHasResizingDisabled;
	}

	public String extractFolderPath(File emojiFile, File baseFolder)
	{
		String relativePath = baseFolder.toPath().relativize(emojiFile.toPath()).toString();
		String[] pathParts = relativePath.split("[\\\\/]");

		StringBuilder folderPath = new StringBuilder();
		for (int i = 0; i < pathParts.length - 1; i++)
		{
			if (folderPath.length() > 0)
			{
				folderPath.append(PATH_SEPARATOR);
			}
			folderPath.append(pathParts[i]);
		}

		return folderPath.toString();
	}

	private boolean matchesSearchFilter(String emojiName, File emojiFile, File emojisFolder, String searchFilter)
	{
		if (searchFilter.isEmpty())
		{
			return true;
		}

		boolean nameMatches = emojiName.toLowerCase().contains(searchFilter);
		if (nameMatches)
		{
			return true;
		}

		return this.folderPathMatchesFilter(emojiFile, emojisFolder, searchFilter);
	}

	private boolean folderPathMatchesFilter(File emojiFile, File emojisFolder, String searchFilter)
	{
		String relativePath = emojisFolder.toPath().relativize(emojiFile.toPath()).toString();
		String[] pathParts = relativePath.split("[\\\\\\/]");

		for (int i = 0; i < pathParts.length - 1; i++)
		{
			boolean folderMatches = pathParts[i].toLowerCase().contains(searchFilter);
			if (folderMatches)
			{
				return true;
			}
		}
		return false;
	}

	private void registerParentFolders(String folderPath, Map<String, Set<String>> subfoldersByPath)
	{
		String[] pathParts = folderPath.isEmpty() ? new String[0] : folderPath.split(PATH_SEPARATOR);
		String currentPathStr = "";

		for (int i = 0; i < pathParts.length; i++)
		{
			String parentPath = currentPathStr;
			currentPathStr = this.appendPathSegment(currentPathStr, pathParts[i]);

			subfoldersByPath.computeIfAbsent(parentPath, k -> new HashSet<>()).add(pathParts[i]);
			subfoldersByPath.computeIfAbsent(currentPathStr, k -> new HashSet<>());
		}
	}

	private String appendPathSegment(String basePath, String segment)
	{
		if (basePath.isEmpty())
		{
			return segment;
		}
		return basePath + PATH_SEPARATOR + segment;
	}

	private void addEmojiItem(String emojiName, Emoji emoji, String folderPath)
	{
		BufferedImage emojiImage = this.loadEmojiImage(emoji);
		boolean failedToLoad = (emojiImage == null);
		boolean isEnabled = !this.disabledEmojis.contains(emojiName);
		boolean isResizingEnabled = !this.resizingDisabledEmojis.contains(emojiName);

		EmojiTreeNode item = EmojiTreeNode.createEmoji(emojiName, isEnabled, isResizingEnabled, emojiImage, failedToLoad);
		this.folderContents.computeIfAbsent(folderPath, k -> new ArrayList<>()).add(item);
	}

	private void addFolderItems(Map<String, Set<String>> subfoldersByPath)
	{
		for (Map.Entry<String, Set<String>> entry : subfoldersByPath.entrySet())
		{
			String parentPath = entry.getKey();
			for (String subfolder : entry.getValue())
			{
				String fullSubfolderPath = parentPath.isEmpty() ? subfolder : parentPath + PATH_SEPARATOR + subfolder;
				boolean isEnabled = this.calculateFolderEnabled(fullSubfolderPath);
				boolean isResizingEnabled = this.calculateFolderResizingEnabled(fullSubfolderPath);
				EmojiTreeNode folderItem = EmojiTreeNode.createFolder(subfolder, isEnabled, isResizingEnabled);
				this.folderContents.computeIfAbsent(parentPath, k -> new ArrayList<>()).add(folderItem);
			}
		}
	}

	private void sortFolderContents()
	{
		for (List<EmojiTreeNode> items : this.folderContents.values())
		{
			items.sort(this::compareTreeNodes);
		}
	}

	private int compareTreeNodes(EmojiTreeNode a, EmojiTreeNode b)
	{
		boolean aIsFolder = a.isFolder();
		boolean bIsFolder = b.isFolder();

		if (aIsFolder && !bIsFolder)
		{
			return -1;
		}
		if (!aIsFolder && bIsFolder)
		{
			return 1;
		}
		return a.getName().compareToIgnoreCase(b.getName());
	}

	private List<String> getEnabledEmojiNamesInFolder(String folderPath)
	{
		List<String> result = new ArrayList<>();

		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (!isInFolder)
			{
				continue;
			}

			for (EmojiTreeNode item : entry.getValue())
			{
				boolean isEnabledEmoji = !item.isFolder() && !this.disabledEmojis.contains(item.getName());
				if (isEnabledEmoji)
				{
					result.add(item.getName());
				}
			}
		}

		return result;
	}

	private boolean isPathInFolder(String path, String folderPath)
	{
		return path.equals(folderPath) || path.startsWith(folderPath + PATH_SEPARATOR);
	}

	private boolean anyEmojiHasResizingDisabled(List<String> emojiNames)
	{
		for (String name : emojiNames)
		{
			if (this.resizingDisabledEmojis.contains(name))
			{
				return true;
			}
		}
		return false;
	}

	private BufferedImage loadEmojiImage(Emoji emoji)
	{
		return emoji.getCacheImage(this.client, this.chatIconManager);
	}
}


package com.customemoji.panel.tree;

import javax.swing.JButton;
import javax.swing.JLabel;
import java.util.ArrayList;
import java.util.List;

/**
 * Manages navigation state and header updates for the emoji tree panel.
 */
public class NavigationController
{
	private static final String PATH_SEPARATOR = "/";

	private final JButton backButton;
	private final JLabel pathLabel;
	private final Runnable onNavigationChanged;

	private List<String> currentPath = new ArrayList<>();
	private String currentSearchFilter = "";

	public NavigationController(JButton backButton, JLabel pathLabel, Runnable onNavigationChanged)
	{
		this.backButton = backButton;
		this.pathLabel = pathLabel;
		this.onNavigationChanged = onNavigationChanged;
	}

	public void navigateToFolder(List<String> path)
	{
		this.currentPath = new ArrayList<>(path);
		this.updateHeader();
		this.onNavigationChanged.run();
	}

	public void navigateBack()
	{
		if (!this.currentPath.isEmpty())
		{
			this.currentPath.remove(this.currentPath.size() - 1);
			this.updateHeader();
			this.onNavigationChanged.run();
		}
	}

	public void navigateToRoot()
	{
		this.currentPath.clear();
		this.updateHeader();
		this.onNavigationChanged.run();
	}

	public void updateHeader()
	{
		boolean isSearching = !this.currentSearchFilter.isEmpty();
		boolean isAtRoot = this.currentPath.isEmpty();
		this.backButton.setEnabled(!isAtRoot && !isSearching);

		if (isSearching)
		{
			this.pathLabel.setText("Search results");
		}
		else if (isAtRoot)
		{
			this.pathLabel.setText("Root");
		}
		else
		{
			String currentFolder = this.currentPath.get(this.currentPath.size() - 1);
			this.pathLabel.setText(currentFolder);
		}
	}

	public String getCurrentFolderPath()
	{
		return String.join(PATH_SEPARATOR, this.currentPath);
	}

	public List<String> getCurrentPath()
	{
		return new ArrayList<>(this.currentPath);
	}

	public void setSearchFilter(String filter)
	{
		this.currentSearchFilter = filter;
		this.updateHeader();
	}

	public String getSearchFilter()
	{
		return this.currentSearchFilter;
	}

	public boolean isSearching()
	{
		return !this.currentSearchFilter.isEmpty();
	}

	public boolean pathExists(java.util.Map<String, ?> folderContents)
	{
		if (this.currentPath.isEmpty())
		{
			return true;
		}
		String pathKey = String.join(PATH_SEPARATOR, this.currentPath);
		return folderContents.containsKey(pathKey);
	}

	public void resetPathIfInvalid(java.util.Map<String, ?> folderContents)
	{
		if (!this.currentPath.isEmpty() && !this.pathExists(folderContents))
		{
			this.currentPath.clear();
		}
	}
}


package com.customemoji.panel.tree;

import com.customemoji.CustomEmojiPlugin;
import com.customemoji.panel.PanelConstants;
import net.runelite.client.util.ImageUtil;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

/**
 * Builds row panels for displaying emoji tree items.
 */
public class RowPanelBuilder
{
	private static final int MAX_IMAGE_WIDTH = 20;

	private final EmojiToggleHandler toggleHandler;
	private final Consumer<List<String>> onFolderClicked;
	private final List<String> currentPath;

	public RowPanelBuilder(EmojiToggleHandler toggleHandler,
							Consumer<List<String>> onFolderClicked,
							List<String> currentPath)
	{
		this.toggleHandler = toggleHandler;
		this.onFolderClicked = onFolderClicked;
		this.currentPath = currentPath;
	}

	public JPanel createRowPanel(EmojiTreeNode item, String currentFolderPath)
	{
		JPanel rowPanel = new JPanel(new BorderLayout());
		rowPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);
		rowPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 28));
		rowPanel.setPreferredSize(new Dimension(200, 28));

		JPanel leftPanel = this.createLeftPanel(item);
		JLabel nameLabel = this.createNameLabel(item);
		leftPanel.add(nameLabel);

		rowPanel.add(leftPanel, BorderLayout.CENTER);

		Component toggleControl = this.createToggleControl(item, currentFolderPath);
		rowPanel.add(toggleControl, BorderLayout.EAST);

		if (item.isFolder())
		{
			this.addFolderClickHandler(rowPanel, leftPanel, nameLabel, item);
		}

		return rowPanel;
	}

	private JPanel createLeftPanel(EmojiTreeNode item)
	{
		JPanel leftPanel = new JPanel();
		leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.X_AXIS));
		leftPanel.setOpaque(false);
		leftPanel.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));

		if (item.isFolder())
		{
			this.addFolderIcon(leftPanel);
		}
		else if (item.getImage() != null)
		{
			this.addEmojiImage(leftPanel, item.getImage());
		}
		else
		{
			this.addPlaceholderOrWarning(leftPanel, item);
		}

		return leftPanel;
	}

	private void addFolderIcon(JPanel leftPanel)
	{
		JLabel folderIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_FOLDER_FILL)));
		leftPanel.add(folderIcon);
		leftPanel.add(Box.createHorizontalStrut(5));
	}

	private void addEmojiImage(JPanel leftPanel, BufferedImage image)
	{
		BufferedImage displayImage = this.scaleImageForDisplay(image, MAX_IMAGE_WIDTH);
		int imageHeight = displayImage.getHeight();
		int imageWidth = displayImage.getWidth();

		JPanel imageContainer = new JPanel();
		imageContainer.setLayout(new BoxLayout(imageContainer, BoxLayout.X_AXIS));
		imageContainer.setOpaque(false);
		imageContainer.setPreferredSize(new Dimension(MAX_IMAGE_WIDTH, imageHeight));
		imageContainer.setMinimumSize(new Dimension(MAX_IMAGE_WIDTH, imageHeight));
		imageContainer.setMaximumSize(new Dimension(MAX_IMAGE_WIDTH, imageHeight));

		imageContainer.add(Box.createHorizontalGlue());

		JLabel imageLabel = new JLabel(new ImageIcon(displayImage));
		imageLabel.setPreferredSize(new Dimension(imageWidth, imageHeight));
		imageLabel.setMinimumSize(new Dimension(imageWidth, imageHeight));
		imageLabel.setMaximumSize(new Dimension(imageWidth, imageHeight));
		imageContainer.add(imageLabel);

		leftPanel.add(imageContainer);
		leftPanel.add(Box.createHorizontalStrut(5));
	}

	private void addPlaceholderOrWarning(JPanel leftPanel, EmojiTreeNode item)
	{
		if (item.isFailedToLoad())
		{
			JPanel warningContainer = new JPanel();
			warningContainer.setLayout(new BoxLayout(warningContainer, BoxLayout.X_AXIS));
			warningContainer.setOpaque(false);
			warningContainer.setPreferredSize(new Dimension(MAX_IMAGE_WIDTH, 16));
			warningContainer.setMinimumSize(new Dimension(MAX_IMAGE_WIDTH, 16));
			warningContainer.setMaximumSize(new Dimension(MAX_IMAGE_WIDTH, 16));

			warningContainer.add(Box.createHorizontalGlue());

			JLabel warningLabel = new JLabel(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_WARNING)));
			warningLabel.setToolTipText("Failed to load emoji image");
			warningContainer.add(warningLabel);

			leftPanel.add(warningContainer);
			leftPanel.add(Box.createHorizontalStrut(5));
		}
		else
		{
			leftPanel.add(Box.createHorizontalStrut(MAX_IMAGE_WIDTH + 5));
		}
	}

	private JLabel createNameLabel(EmojiTreeNode item)
	{
		JLabel nameLabel = new JLabel(item.getName());
		nameLabel.setToolTipText(item.getName());

		if (item.isFolder())
		{
			nameLabel.setBorder(BorderFactory.createEmptyBorder(3, 0, 0, 0));
		}

		if (item.isEnabled())
		{
			nameLabel.setFont(nameLabel.getFont().deriveFont(Font.BOLD));
			if (item.isFolder())
			{
				nameLabel.setForeground(PanelConstants.FOLDER_TEXT);
			}
			else
			{
				nameLabel.setForeground(PanelConstants.ENABLED_TEXT);
			}
		}
		else
		{
			nameLabel.setFont(nameLabel.getFont().deriveFont(Font.PLAIN));
			nameLabel.setForeground(PanelConstants.DISABLED_TEXT);
		}

		boolean isFailedEmoji = !item.isFolder() && item.isFailedToLoad();
		if (isFailedEmoji)
		{
			nameLabel.setForeground(PanelConstants.WARNING_FILL);
			nameLabel.setText(item.getName() + " (!)");
		}

		return nameLabel;
	}

	private Component createToggleControl(EmojiTreeNode item, String currentFolderPath)
	{
		if (this.toggleHandler.isResizingMode())
		{
			return this.createResizeToggleButton(item, currentFolderPath);
		}
		else
		{
			return this.createEnableCheckbox(item, currentFolderPath);
		}
	}

	private JCheckBox createEnableCheckbox(EmojiTreeNode item, String currentFolderPath)
	{
		JCheckBox checkBox = new JCheckBox();
		checkBox.setOpaque(false);
		checkBox.setFocusable(false);
		checkBox.setSelected(item.isEnabled());
		checkBox.addActionListener(e -> this.toggleHandler.handleItemToggle(item, checkBox.isSelected(), currentFolderPath));
		return checkBox;
	}

	private JButton createResizeToggleButton(EmojiTreeNode item, String currentFolderPath)
	{
		boolean isResizingEnabled = item.isResizingEnabled();
		String iconName = isResizingEnabled ? PanelConstants.ICON_ARROWS_CONTRACT : PanelConstants.ICON_ARROWS_EXPAND;

		JButton button = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, iconName)));
		button.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		button.setMargin(new Insets(0, 0, 0, 0));
		button.setFocusable(false);

		boolean isDisabledEmoji = !item.isFolder() && !item.isEnabled();
		if (this.toggleHandler.isLoading())
		{
			button.setEnabled(false);
			button.setToolTipText("Loading...");
		}
		else if (isDisabledEmoji)
		{
			button.setEnabled(false);
			button.setToolTipText("Enable this emoji first to configure resizing");
		}
		else
		{
			String tooltip = isResizingEnabled ? "Resize enabled (click to disable)" : "Resize disabled (click to enable)";
			button.setToolTipText(tooltip);
		}

		button.addActionListener(e -> this.toggleHandler.handleItemToggle(item, !item.isResizingEnabled(), currentFolderPath));

		return button;
	}

	private void addFolderClickHandler(JPanel rowPanel, JPanel leftPanel, JLabel nameLabel, EmojiTreeNode item)
	{
		rowPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		leftPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

		MouseAdapter folderClickHandler = new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				List<String> newPath = new ArrayList<>(currentPath);
				newPath.add(item.getName());
				onFolderClicked.accept(newPath);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				rowPanel.setBackground(PanelConstants.ROW_HOVER_BACKGROUND);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				rowPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);
			}
		};

		leftPanel.addMouseListener(folderClickHandler);
		nameLabel.addMouseListener(folderClickHandler);
	}

	private BufferedImage scaleImageForDisplay(BufferedImage image, int maxSize)
	{
		int width = image.getWidth();
		int height = image.getHeight();

		boolean needsScaling = width > maxSize || height > maxSize;
		if (!needsScaling)
		{
			return image;
		}

		double scale = Math.min((double) maxSize / width, (double) maxSize / height);
		int newWidth = (int) Math.round(width * scale);
		int newHeight = (int) Math.round(height * scale);

		return ImageUtil.resizeImage(image, newWidth, newHeight);
	}
}


package com.customemoji.panel.tree;

import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;

/**
 * Handles toggle operations for enabling/disabling emojis and resizing mode.
 */
public class EmojiToggleHandler
{
	public static final String PATH_SEPARATOR = "/";
	public static final String MODE_ENABLE_DISABLE = "Enable/Disable";
	public static final String MODE_RESIZING = "Resizing";

	private final Set<String> disabledEmojis;
	private final Set<String> resizingDisabledEmojis;
	private final ScheduledExecutorService executor;
	private final Runnable onContentRefreshNeeded;
	private final Runnable onFolderStatesUpdateNeeded;
	private final JScrollPane scrollPane;
	private final JPanel contentPanel;

	private Consumer<Set<String>> onDisabledEmojisChanged;
	private Consumer<Set<String>> onResizingDisabledEmojisChanged;
	private Consumer<String> onEmojiResizingToggled;

	private String currentMode = MODE_ENABLE_DISABLE;
	private boolean isLoading = false;

	private Map<String, List<EmojiTreeNode>> folderContents;

	public EmojiToggleHandler(Set<String> disabledEmojis,
							   Set<String> resizingDisabledEmojis,
							   ScheduledExecutorService executor,
							   JScrollPane scrollPane,
							   JPanel contentPanel,
							   Runnable onContentRefreshNeeded,
							   Runnable onFolderStatesUpdateNeeded)
	{
		this.disabledEmojis = disabledEmojis;
		this.resizingDisabledEmojis = resizingDisabledEmojis;
		this.executor = executor;
		this.scrollPane = scrollPane;
		this.contentPanel = contentPanel;
		this.onContentRefreshNeeded = onContentRefreshNeeded;
		this.onFolderStatesUpdateNeeded = onFolderStatesUpdateNeeded;
	}

	public void setFolderContents(Map<String, List<EmojiTreeNode>> folderContents)
	{
		this.folderContents = folderContents;
	}

	public void setOnDisabledEmojisChanged(Consumer<Set<String>> callback)
	{
		this.onDisabledEmojisChanged = callback;
	}

	public void setOnResizingDisabledEmojisChanged(Consumer<Set<String>> callback)
	{
		this.onResizingDisabledEmojisChanged = callback;
	}

	public void setOnEmojiResizingToggled(Consumer<String> callback)
	{
		this.onEmojiResizingToggled = callback;
	}

	public String getCurrentMode()
	{
		return this.currentMode;
	}

	public void setCurrentMode(String mode)
	{
		this.currentMode = mode;
	}

	public boolean isResizingMode()
	{
		return MODE_RESIZING.equals(this.currentMode);
	}

	public void toggleMode()
	{
		boolean isCurrentlyResizeMode = MODE_RESIZING.equals(this.currentMode);
		this.currentMode = isCurrentlyResizeMode ? MODE_ENABLE_DISABLE : MODE_RESIZING;
	}

	public boolean isLoading()
	{
		return this.isLoading;
	}

	public void handleItemToggle(EmojiTreeNode item, boolean checked, String currentFolderPath)
	{
		if (this.isResizingMode())
		{
			this.handleResizingToggle(item, checked, currentFolderPath);
		}
		else
		{
			this.handleEnableDisableToggle(item, checked, currentFolderPath);
		}
	}

	public void updateAllFolderStates(FolderStructureBuilder structureBuilder)
	{
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			String parentPath = entry.getKey();
			for (EmojiTreeNode item : entry.getValue())
			{
				if (item.isFolder())
				{
					String fullPath = parentPath.isEmpty() ? item.getName() : parentPath + PATH_SEPARATOR + item.getName();
					item.setEnabled(structureBuilder.calculateFolderEnabled(fullPath));
					item.setResizingEnabled(structureBuilder.calculateFolderResizingEnabled(fullPath));
				}
			}
		}
	}

	private void handleEnableDisableToggle(EmojiTreeNode item, boolean enabled, String currentFolderPath)
	{
		item.setEnabled(enabled);

		if (item.isFolder())
		{
			String targetPath = currentFolderPath.isEmpty() ? item.getName() : currentFolderPath + PATH_SEPARATOR + item.getName();
			this.toggleFolderEmojisEnabled(targetPath, enabled);

			this.onFolderStatesUpdateNeeded.run();
			int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
			this.onContentRefreshNeeded.run();
			SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(scrollPosition));
		}
		else
		{
			if (enabled)
			{
				this.disabledEmojis.remove(item.getName());
			}
			else
			{
				this.disabledEmojis.add(item.getName());
			}
			this.onFolderStatesUpdateNeeded.run();
			int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
			this.onContentRefreshNeeded.run();
			SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(scrollPosition));
		}

		this.notifyDisabledEmojisChanged();
	}

	private void handleResizingToggle(EmojiTreeNode item, boolean resizingEnabled, String currentFolderPath)
	{
		if (this.isLoading)
		{
			return;
		}

		this.isLoading = true;
		item.setResizingEnabled(resizingEnabled);

		if (item.isFolder())
		{
			this.handleFolderResizingToggle(item, resizingEnabled, currentFolderPath);
		}
		else
		{
			this.handleSingleEmojiResizingToggle(item, resizingEnabled);
		}
	}

	private void handleSingleEmojiResizingToggle(EmojiTreeNode item, boolean resizingEnabled)
	{
		int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
		this.disableAllButtons();

		if (resizingEnabled)
		{
			this.resizingDisabledEmojis.remove(item.getName());
		}
		else
		{
			this.resizingDisabledEmojis.add(item.getName());
		}

		this.notifyResizingDisabledEmojisChanged();

		this.executor.execute(() ->
		{
			this.notifyEmojiResizingToggled(item.getName());

			SwingUtilities.invokeLater(() ->
			{
				this.isLoading = false;
				this.onContentRefreshNeeded.run();
				SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(scrollPosition));
			});
		});
	}

	private void handleFolderResizingToggle(EmojiTreeNode item, boolean resizingEnabled, String currentFolderPath)
	{
		int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
		this.disableAllButtons();

		String targetPath = currentFolderPath.isEmpty() ? item.getName() : currentFolderPath + PATH_SEPARATOR + item.getName();
		List<String> emojisToReload = this.toggleFolderEmojisResizing(targetPath, resizingEnabled);

		this.notifyResizingDisabledEmojisChanged();

		this.executor.execute(() ->
		{
			for (String emojiName : emojisToReload)
			{
				this.notifyEmojiResizingToggled(emojiName);
			}

			SwingUtilities.invokeLater(() ->
			{
				this.isLoading = false;
				this.onFolderStatesUpdateNeeded.run();
				this.onContentRefreshNeeded.run();
				this.scrollPane.getVerticalScrollBar().setValue(scrollPosition);
			});
		});
	}

	private void toggleFolderEmojisEnabled(String folderPath, boolean enabled)
	{
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (isInFolder)
			{
				this.toggleEmojisEnabledInList(entry.getValue(), enabled);
			}
		}
	}

	private List<String> toggleFolderEmojisResizing(String folderPath, boolean resizingEnabled)
	{
		List<String> toggledEmojis = new ArrayList<>();
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (isInFolder)
			{
				List<String> toggled = this.toggleEmojisResizingInList(entry.getValue(), resizingEnabled);
				toggledEmojis.addAll(toggled);
			}
		}
		return toggledEmojis;
	}

	private boolean isPathInFolder(String path, String folderPath)
	{
		boolean isExactMatch = path.equals(folderPath);
		boolean isSubfolder = path.startsWith(folderPath + PATH_SEPARATOR);
		return isExactMatch || isSubfolder;
	}

	private void toggleEmojisEnabledInList(List<EmojiTreeNode> items, boolean enabled)
	{
		for (EmojiTreeNode item : items)
		{
			if (!item.isFolder())
			{
				this.updateEmojiEnabledState(item, enabled);
			}
		}
	}

	private List<String> toggleEmojisResizingInList(List<EmojiTreeNode> items, boolean resizingEnabled)
	{
		List<String> toggledEmojis = new ArrayList<>();
		for (EmojiTreeNode item : items)
		{
			boolean isEnabledEmoji = !item.isFolder() && item.isEnabled();
			if (isEnabledEmoji)
			{
				this.updateEmojiResizingState(item, resizingEnabled);
				toggledEmojis.add(item.getName());
			}
		}
		return toggledEmojis;
	}

	private void updateEmojiEnabledState(EmojiTreeNode item, boolean enabled)
	{
		item.setEnabled(enabled);
		if (enabled)
		{
			this.disabledEmojis.remove(item.getName());
		}
		else
		{
			this.disabledEmojis.add(item.getName());
		}
	}

	private void updateEmojiResizingState(EmojiTreeNode item, boolean resizingEnabled)
	{
		item.setResizingEnabled(resizingEnabled);
		if (resizingEnabled)
		{
			this.resizingDisabledEmojis.remove(item.getName());
		}
		else
		{
			this.resizingDisabledEmojis.add(item.getName());
		}
	}

	private void notifyDisabledEmojisChanged()
	{
		if (this.onDisabledEmojisChanged != null)
		{
			this.onDisabledEmojisChanged.accept(new HashSet<>(this.disabledEmojis));
		}
	}

	private void notifyResizingDisabledEmojisChanged()
	{
		if (this.onResizingDisabledEmojisChanged != null)
		{
			this.onResizingDisabledEmojisChanged.accept(new HashSet<>(this.resizingDisabledEmojis));
		}
	}

	private void notifyEmojiResizingToggled(String emojiName)
	{
		if (this.onEmojiResizingToggled != null)
		{
			this.onEmojiResizingToggled.accept(emojiName);
		}
	}

	private void disableAllButtons()
	{
		for (Component component : this.contentPanel.getComponents())
		{
			boolean isRowPanel = component instanceof JPanel;
			if (!isRowPanel)
			{
				continue;
			}

			JPanel rowPanel = (JPanel) component;
			for (Component child : rowPanel.getComponents())
			{
				boolean isButton = child instanceof JButton;
				if (isButton)
				{
					JButton button = (JButton) child;
					button.setEnabled(false);
					button.paintImmediately(button.getBounds());
				}
			}
		}
	}
}


package com.customemoji.panel.tree;

import java.awt.image.BufferedImage;

/**
 * Represents a node in the emoji tree structure.
 * Can be either a folder or an individual emoji.
 */
public class EmojiTreeNode
{
	private final String name;
	private final boolean isFolder;
	private boolean isEnabled;
	private boolean resizingEnabled;
	private BufferedImage image;
	private final boolean failedToLoad;

	private EmojiTreeNode(String name, boolean isFolder, boolean isEnabled,
						  boolean resizingEnabled, BufferedImage image, boolean failedToLoad)
	{
		this.name = name;
		this.isFolder = isFolder;
		this.isEnabled = isEnabled;
		this.resizingEnabled = resizingEnabled;
		this.image = image;
		this.failedToLoad = failedToLoad;
	}

	public static EmojiTreeNode createFolder(String name, boolean enabled, boolean resizingEnabled)
	{
		return new EmojiTreeNode(name, true, enabled, resizingEnabled, null, false);
	}

	public static EmojiTreeNode createEmoji(String name, boolean enabled, boolean resizingEnabled,
											BufferedImage image, boolean failedToLoad)
	{
		return new EmojiTreeNode(name, false, enabled, resizingEnabled, image, failedToLoad);
	}

	public String getName()
	{
		return this.name;
	}

	public boolean isFolder()
	{
		return this.isFolder;
	}

	public boolean isEnabled()
	{
		return this.isEnabled;
	}

	public void setEnabled(boolean enabled)
	{
		this.isEnabled = enabled;
	}

	public boolean isResizingEnabled()
	{
		return this.resizingEnabled;
	}

	public void setResizingEnabled(boolean resizingEnabled)
	{
		this.resizingEnabled = resizingEnabled;
	}

	public BufferedImage getImage()
	{
		return this.image;
	}

	public void setImage(BufferedImage image)
	{
		this.image = image;
	}

	public boolean isFailedToLoad()
	{
		return this.failedToLoad;
	}

	@Override
	public String toString()
	{
		return this.name;
	}
}


package com.customemoji.panel.tree;

import com.customemoji.CustomEmojiPlugin;
import com.customemoji.model.Emoji;
import com.customemoji.panel.PanelConstants;
import net.runelite.api.Client;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.inject.Named;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;

/**
 * Panel containing an explorer-style emoji browser with folder navigation.
 */
public class EmojiTreePanel extends JPanel
{
	private final Client client;
	private final ChatIconManager chatIconManager;
	private final Map<String, Emoji> emojis;
	private final ScheduledExecutorService executor;

	private Set<String> disabledEmojis;
	private Set<String> resizingDisabledEmojis;
	private JPanel contentPanel;
	private JScrollPane scrollPane;
	private JButton resizeModeButton;
	private transient FolderStructureBuilder structureBuilder;
	private transient NavigationController navigationController;
	private transient EmojiToggleHandler toggleHandler;
	private transient Map<String, List<EmojiTreeNode>> folderContents = new HashMap<>();

	@Inject
	public EmojiTreePanel(Client client, ChatIconManager chatIconManager,
						  Map<String, Emoji> emojis,
						  @Named("disabledEmojis") Set<String> disabledEmojis,
						  @Named("resizingDisabledEmojis") Set<String> resizingDisabledEmojis,
						  ScheduledExecutorService executor)
	{
		this.client = client;
		this.chatIconManager = chatIconManager;
		this.emojis = emojis;
		this.executor = executor;
		this.disabledEmojis = new HashSet<>(disabledEmojis);
		this.resizingDisabledEmojis = new HashSet<>(resizingDisabledEmojis);

		this.setLayout(new BorderLayout());
		this.initializeComponents();
		this.buildFolderStructure();
		this.navigationController.navigateToFolder(new ArrayList<>());
	}

	public void setOnDisabledEmojisChanged(Consumer<Set<String>> callback)
	{
		this.toggleHandler.setOnDisabledEmojisChanged(callback);
	}

	public void setOnResizingDisabledEmojisChanged(Consumer<Set<String>> callback)
	{
		this.toggleHandler.setOnResizingDisabledEmojisChanged(callback);
	}

	public void setOnEmojiResizingToggled(Consumer<String> callback)
	{
		this.toggleHandler.setOnEmojiResizingToggled(callback);
	}

	public void setSearchFilter(String filter)
	{
		String normalizedFilter = filter.toLowerCase().trim();
		if (!normalizedFilter.equals(this.navigationController.getSearchFilter()))
		{
			this.navigationController.setSearchFilter(normalizedFilter);
			this.rebuildAndRefresh();
		}
	}

	public void clearSearchFilter()
	{
		this.navigationController.setSearchFilter("");
	}

	public void updateDisabledEmojis(Set<String> disabledEmojis)
	{
		this.disabledEmojis = new HashSet<>(disabledEmojis);
		this.rebuildAndRefresh();
	}

	public Set<String> getDisabledEmojis()
	{
		return new HashSet<>(this.disabledEmojis);
	}

	public void updateResizingDisabledEmojis(Set<String> resizingDisabledEmojis)
	{
		this.resizingDisabledEmojis = new HashSet<>(resizingDisabledEmojis);
		this.rebuildAndRefresh();
	}

	public Set<String> getResizingDisabledEmojis()
	{
		return new HashSet<>(this.resizingDisabledEmojis);
	}

	private void initializeComponents()
	{
		this.contentPanel = new JPanel();
		this.contentPanel.setLayout(new BoxLayout(this.contentPanel, BoxLayout.Y_AXIS));
		this.contentPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);

		this.scrollPane = new JScrollPane(this.contentPanel);
		this.scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		this.scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		this.scrollPane.setBorder(BorderFactory.createEmptyBorder());
		this.scrollPane.getViewport().setBackground(PanelConstants.CONTENT_BACKGROUND);

		this.toggleHandler = new EmojiToggleHandler(
			this.disabledEmojis,
			this.resizingDisabledEmojis,
			this.executor,
			this.scrollPane,
			this.contentPanel,
			this::updateContent,
			this::updateAllFolderStates
		);

		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBackground(PanelConstants.HEADER_BACKGROUND);
		headerPanel.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, PanelConstants.HEADER_BORDER));

		JButton backButton = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_ARROW_LEFT)));
		backButton.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		backButton.setMaximumSize(PanelConstants.HEADER_BUTTON_SIZE);
		backButton.setFocusable(false);
		backButton.setEnabled(false);
		backButton.setToolTipText("Go back a directory");

		JLabel pathLabel = new JLabel("Emojis");
		pathLabel.setForeground(PanelConstants.FOLDER_TEXT);
		pathLabel.setFont(pathLabel.getFont().deriveFont(Font.BOLD));

		this.navigationController = new NavigationController(backButton, pathLabel, this::updateContent);
		backButton.addActionListener(e -> this.navigationController.navigateBack());

		this.resizeModeButton = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_BOUNDING_BOX)));
		this.resizeModeButton.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		this.resizeModeButton.setMaximumSize(PanelConstants.HEADER_BUTTON_SIZE);
		this.resizeModeButton.setFocusable(false);
		this.resizeModeButton.setToolTipText("Toggle resize mode");
		this.updateResizeModeButtonColor();
		this.resizeModeButton.addActionListener(e ->
		{
			this.toggleHandler.toggleMode();
			this.updateResizeModeButtonColor();
			this.buildFolderStructure();
			this.updateContent();
		});

		JButton refreshButton = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_ARROW_CLOCKWISE)));
		refreshButton.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		refreshButton.setMaximumSize(PanelConstants.HEADER_BUTTON_SIZE);
		refreshButton.setFocusable(false);
		refreshButton.setToolTipText("Refresh view");
		refreshButton.addActionListener(e ->
		{
			this.buildFolderStructure();
			this.updateContent();
		});

		JPanel navPanel = new JPanel();
		navPanel.setLayout(new BoxLayout(navPanel, BoxLayout.X_AXIS));
		navPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);
		navPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 4, 0));
		navPanel.add(backButton);
		navPanel.add(Box.createHorizontalStrut(4));
		navPanel.add(refreshButton);
		navPanel.add(Box.createHorizontalStrut(4));
		navPanel.add(this.resizeModeButton);
		navPanel.add(Box.createHorizontalStrut(8));
		navPanel.add(pathLabel);

		headerPanel.add(navPanel, BorderLayout.CENTER);

		this.add(headerPanel, BorderLayout.NORTH);
		this.add(this.scrollPane, BorderLayout.CENTER);
	}

	private void buildFolderStructure()
	{
		this.structureBuilder = new FolderStructureBuilder(
			this.client,
			this.chatIconManager,
			this.emojis,
			this.disabledEmojis,
			this.resizingDisabledEmojis
		);
		this.folderContents = this.structureBuilder.build(this.navigationController.getSearchFilter());
		this.toggleHandler.setFolderContents(this.folderContents);
	}

	private void updateAllFolderStates()
	{
		this.toggleHandler.updateAllFolderStates(this.structureBuilder);
	}

	private void updateContent()
	{
		this.contentPanel.removeAll();

		List<EmojiTreeNode> items = this.getItemsForCurrentView();

		String currentFolderPath = this.navigationController.getCurrentFolderPath();
		RowPanelBuilder rowBuilder = new RowPanelBuilder(
			this.toggleHandler,
			this.navigationController::navigateToFolder,
			this.navigationController.getCurrentPath()
		);

		for (EmojiTreeNode item : items)
		{
			JPanel rowPanel = rowBuilder.createRowPanel(item, currentFolderPath);
			this.contentPanel.add(rowPanel);
		}

		this.contentPanel.add(Box.createVerticalGlue());

		this.contentPanel.revalidate();
		this.contentPanel.repaint();

		SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(0));
	}

	private List<EmojiTreeNode> getItemsForCurrentView()
	{
		if (this.navigationController.isSearching())
		{
			List<EmojiTreeNode> items = new ArrayList<>();
			for (List<EmojiTreeNode> folderItems : this.folderContents.values())
			{
				for (EmojiTreeNode item : folderItems)
				{
					if (!item.isFolder())
					{
						items.add(item);
					}
				}
			}
			items.sort((a, b) -> a.getName().compareToIgnoreCase(b.getName()));
			return items;
		}
		else
		{
			String pathKey = this.navigationController.getCurrentFolderPath();
			return this.folderContents.getOrDefault(pathKey, new ArrayList<>());
		}
	}

	private void rebuildAndRefresh()
	{
		Runnable task = () ->
		{
			this.buildFolderStructure();

			this.navigationController.resetPathIfInvalid(this.folderContents);

			this.navigationController.updateHeader();
			this.updateContent();
		};

		if (SwingUtilities.isEventDispatchThread())
		{
			task.run();
		}
		else
		{
			SwingUtilities.invokeLater(task);
		}
	}

	private void updateResizeModeButtonColor()
	{
		boolean isResizeMode = this.toggleHandler.isResizingMode();
		if (isResizeMode)
		{
			this.resizeModeButton.setBorder(BorderFactory.createMatteBorder(0, 0, 2, 0, Color.GREEN));
			this.resizeModeButton.setToolTipText("Resize mode active - click to switch to enable/disable mode");
		}
		else
		{
			this.resizeModeButton.setBorder(BorderFactory.createEmptyBorder());
			this.resizeModeButton.setToolTipText("Click to toggle resize mode");
		}
	}
}


package com.customemoji.panel;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.CustomEmojiPlugin;
import com.customemoji.PluginUtils;
import com.customemoji.panel.tree.EmojiTreePanel;
import com.google.inject.Provider;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Panel for managing custom emojis with a tree view showing folders and individual emojis.
 * Supports searching by emoji name or folder name, checkbox enabling/disabling, and
 * persistent configuration storage.
 */
public class CustomEmojiPanel extends PluginPanel
{
	private final CustomEmojiPlugin plugin;
	private final CustomEmojiConfig config;
	private final ConfigManager configManager;
	private final ScheduledExecutorService executor;
	private Set<String> disabledEmojis = new HashSet<>();
	private Set<String> resizingDisabledEmojis = new HashSet<>();
	private SearchPanel searchPanel;
	private EmojiTreePanel emojiTreePanel;

	@Inject
	public CustomEmojiPanel(CustomEmojiPlugin plugin, CustomEmojiConfig config, ConfigManager configManager,
							Provider<EmojiTreePanel> emojiTreePanelProvider, ScheduledExecutorService executor)
	{
		this.plugin = plugin;
		this.configManager = configManager;
		this.config = config;
		this.executor = executor;
		this.disabledEmojis = PluginUtils.parseDisabledEmojis(config.disabledEmojis());
		this.resizingDisabledEmojis = PluginUtils.parseResizingDisabledEmojis(config.resizingDisabledEmojis());

		this.setLayout(new BorderLayout());
		this.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		this.setMinimumSize(new Dimension(150, 100));

		this.searchPanel = new SearchPanel(this::onSearchChanged);
		this.emojiTreePanel = emojiTreePanelProvider.get();
		this.emojiTreePanel.setOnDisabledEmojisChanged(this::onDisabledEmojisChanged);
		this.emojiTreePanel.setOnResizingDisabledEmojisChanged(this::onResizingDisabledEmojisChanged);
		this.emojiTreePanel.setOnEmojiResizingToggled(this::onEmojiResizingToggled);

		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.add(new HeaderPanel(plugin::openConfiguration), BorderLayout.NORTH);
		topPanel.add(this.searchPanel, BorderLayout.CENTER);

		this.add(topPanel, BorderLayout.NORTH);
		this.add(this.emojiTreePanel, BorderLayout.CENTER);
	}

	@Override
	public Dimension getPreferredSize()
	{
		return this.getPanelDimension();
	}

	@Override
	public Dimension getMaximumSize()
	{
		return this.getPanelDimension();
	}

	@Override
	public Dimension getMinimumSize()
	{
		return new Dimension(200, 150);
	}

	public void refreshEmojiTree()
	{
		this.refreshEmojiTree(true);
	}

	public void refreshEmojiTree(boolean clearSearch)
	{
		this.disabledEmojis = PluginUtils.parseDisabledEmojis(this.config.disabledEmojis());

		if (clearSearch)
		{
			this.searchPanel.clearSearch();
			this.emojiTreePanel.clearSearchFilter();
		}

		this.emojiTreePanel.updateDisabledEmojis(this.disabledEmojis);
	}

	public Set<String> getDisabledEmojis()
	{
		return new HashSet<>(this.disabledEmojis);
	}

	public void updateFromConfig()
	{
		this.refreshEmojiTree(false);
	}

	private void onSearchChanged(String searchText)
	{
		this.emojiTreePanel.setSearchFilter(searchText);
	}

	private void onDisabledEmojisChanged(Set<String> newDisabledEmojis)
	{
		this.disabledEmojis = newDisabledEmojis;
		this.saveDisabledEmojis();
	}

	private void onResizingDisabledEmojisChanged(Set<String> newResizingDisabledEmojis)
	{
		this.resizingDisabledEmojis = newResizingDisabledEmojis;
		this.saveResizingDisabledEmojis();
	}

	private void onEmojiResizingToggled(String emojiName)
	{
		this.plugin.reloadSingleEmoji(emojiName);
	}

	private Dimension getPanelDimension()
	{
		Container parent = this.getParent();
		if (parent != null && parent.getSize().width > 0 && parent.getSize().height > 0)
		{
			return new Dimension(parent.getSize().width - 5, parent.getSize().height - 5);
		}
		return new Dimension(245, 395);
	}

	private void saveDisabledEmojis()
	{
		String disabledEmojisString = String.join(",", this.disabledEmojis);
		this.executor.execute(() -> this.configManager.setConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, CustomEmojiConfig.KEY_DISABLED_EMOJIS, disabledEmojisString));
	}

	private void saveResizingDisabledEmojis()
	{
		String resizingDisabledEmojisString = String.join(",", this.resizingDisabledEmojis);
		this.executor.execute(() -> this.configManager.setConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, CustomEmojiConfig.KEY_RESIZING_DISABLED_EMOJIS, resizingDisabledEmojisString));
	}
}

package com.customemoji;

import lombok.NonNull;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.util.Text;

import javax.inject.Inject;

import com.customemoji.model.Emoji;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

class CustomEmojiOverlay extends OverlayPanel
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    @Inject
    private ChatIconManager chatIconManager;

    @Inject
	private KeyManager keyManager;

    @Inject
    private Map<String, Emoji> emojis;

    private String inputText;
    private Map<String, Emoji> emojiSuggestions = new HashMap<>();
    private final Map<String, BufferedImage> normalizedImageCache = new HashMap<>();

    @Inject
    public CustomEmojiOverlay(CustomEmojiPlugin plugin)
    {
        super(plugin);
        this.getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, "Configure", "Custom Emoji overlay"));
    }

    protected final KeyListener typingListener = new KeyListener()
    {
        @Override
        public void focusLost()
        {
            KeyListener.super.focusLost();
        }

        @Override public void keyReleased(KeyEvent e)
        {
            Widget input = client.getWidget(InterfaceID.Chatbox.INPUT);

            if (input == null)
            {
                return;
            }

            inputText = extractChatInput(input.getText());
            if (inputText == null)
            {
                inputText = "";
            }
            emojiSuggestions = getEmojiSuggestions(inputText);
            clearImageCache();
        }

        @Override
        public void keyTyped(KeyEvent e)
        {
            // Do nothing
        }

        @Override
        public void keyPressed(KeyEvent e)
        {
            // Do nothing
        }

    };

    protected void startUp()
    {
        panelComponent.setGap(new Point(0,2));

        if (keyManager != null)
        {
            keyManager.registerKeyListener(typingListener);
        }
    }

    protected void shutDown()
    {
        if (keyManager != null)
        {
            keyManager.unregisterKeyListener(typingListener);
        }
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Don't render suggestions overlay if tooltips are being shown or if disabled
        if (!config.showOverlay() || client.isMenuOpen())
        {
            return null;
        }

        if (emojiSuggestions.isEmpty())
        {
            return null;
        }

        String extractedInput = extractChatInput(this.inputText);
        String searchTerm = extractedInput != null ? extractedInput.toLowerCase() : "";

        for (Emoji emoji : this.emojiSuggestions.values())
        {
            this.addEmojiToOverlay(emoji, searchTerm);
        }

        return super.render(graphics);
    }

    private void addEmojiToOverlay(Emoji emoji, String searchTerm)
    {
        ImageComponent imageComponent = new ImageComponent(emoji.getCacheImage(this.client, this.chatIconManager));

        // build line component with highlighted text
        String highlightedText = this.createHighlightedText(emoji.getText(), searchTerm);
        LineComponent lineComponent = LineComponent.builder().right(highlightedText).build();
        SplitComponent splitComponent = SplitComponent.builder().first(imageComponent).second(lineComponent).orientation(ComponentOrientation.HORIZONTAL).build();

        panelComponent.getChildren().add(splitComponent);
    }
    
    private String createHighlightedText(String text, String searchTerm)
    {
        if (searchTerm.isEmpty())
        {
            return text;
        }
        
        String lowerText = text.toLowerCase();
        String lowerSearch = searchTerm.toLowerCase();
        int index = lowerText.indexOf(lowerSearch);
        
        if (index == -1)
        {
            return text;
        }
        
        StringBuilder result = new StringBuilder();
        result.append(text.substring(0, index));
        result.append("<col=00ff00>");  // Green highlight
        result.append(text.substring(index, index + searchTerm.length()));
        result.append("<col=ffffff>");  // Reset to white
        result.append(text.substring(index + searchTerm.length()));
        
        return result.toString();
    }

    private static String extractChatInput(String input)
    {
        input = Text.removeTags(input);
        input = removePlayerName(input);
        input = removeChatInputAsterisk(input);
        input = removeBeforeLastSpace(input);

        return input;
    }

    @NonNull
    private Map<String, Emoji> getEmojiSuggestions(@NonNull String searchTerm)
    {
        if (searchTerm.trim().isEmpty() || searchTerm.length() < 3)
        {
            return new HashMap<>();
        }

        String lowerSearch = searchTerm.toLowerCase();

        // Get disabled emojis from config
        Set<String> disabledEmojis = PluginUtils.parseDisabledEmojis(this.config.disabledEmojis());

        // Get all matching entries (excluding disabled emojis)
        List<Map.Entry<String, Emoji>> matchingEntries = new ArrayList<>();
        for (Map.Entry<String, Emoji> entry : this.emojis.entrySet())
        {
            String emojiName = entry.getKey();
            boolean isDisabled = disabledEmojis.contains(emojiName);
            boolean matchesSearch = emojiName.toLowerCase().contains(lowerSearch);

            if (matchesSearch && !isDisabled)
            {
                matchingEntries.add(entry);
            }
        }
        
        // Sort by relevance
        this.sortByRelevance(matchingEntries, lowerSearch);

        // Build result map with limit
        Map<String, Emoji> matches = new LinkedHashMap<>();
        int limit = Math.min(matchingEntries.size(), this.config.maxImageSuggestions());

        for (int i = limit - 1; i >= 0; i--)
        {
            Map.Entry<String, Emoji> entry = matchingEntries.get(i);
            matches.put(entry.getKey(), entry.getValue());
        }

        return matches;
    }

    private void sortByRelevance(List<Map.Entry<String, Emoji>> entries, String searchTerm)
    {
        entries.sort((a, b) -> {
            String nameA = a.getKey().toLowerCase();
            String nameB = b.getKey().toLowerCase();
            
            // Exact matches come first
            boolean exactA = nameA.equals(searchTerm);
            boolean exactB = nameB.equals(searchTerm);
            if (exactA != exactB) return exactA ? -1 : 1;
            
            // Then prefix matches
            boolean prefixA = nameA.startsWith(searchTerm);
            boolean prefixB = nameB.startsWith(searchTerm);
            if (prefixA != prefixB) return prefixA ? -1 : 1;
            
            // Then by position of match (earlier is better)
            int posA = nameA.indexOf(searchTerm);
            int posB = nameB.indexOf(searchTerm);
            if (posA != posB) return Integer.compare(posA, posB);
            
            // Finally by length (shorter names are better)
            return Integer.compare(nameA.length(), nameB.length());
        });
    }

    private void clearImageCache()
    {
        normalizedImageCache.clear();
    }

    private static String removeBeforeLastSpace(String input)
    {
        if (input == null || input.isBlank())
        {
            return input;
        }

        int lastSpaceIndex = input.lastIndexOf(' ');
        if (lastSpaceIndex == -1)
        {
            return input; // No space found, return original string
        }

        return input.substring(lastSpaceIndex + 1);
    }

    private static String removeChatInputAsterisk(String input)
    {
        if (input != null && input.endsWith("*"))
        {
            return input.substring(0, input.length() - 1);
        }

        return input;
    }

    private static String removePlayerName(String input) {
        if (input == null || input.isBlank()) {
            return input;
        }

        int colonIndex = input.indexOf(':');

        if (colonIndex == -1)
        {
            return input;
        }

        return input.substring(colonIndex + 2);
    }
}

package com.customemoji;

import com.customemoji.debugplugin.CustomEmojiDebugPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CustomEmojiPlugin.class, CustomEmojiDebugPlugin.class);
		RuneLite.main(args);
	}
}
package com.customemoji;

import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import java.awt.image.BufferedImage;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.overlay.OverlayManager;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import org.mockito.Mock;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class Testing
{

    @Mock
    @Bind
    private Client client;

    @Mock
    @Bind
    private ClientThread clientThread;

    @Mock
    @Bind
    private ConfigManager configManager;

    @Mock
    @Bind
    private OverlayManager overlayManager;

    @Mock
    @Bind
    private MouseManager mouseManager;

    @Mock
    @Bind
    private KeyManager keyManager;

    @Mock
    @Bind
    private RuneLiteConfig runeLiteConfig;

    @Mock
    @Bind
    private ChatMessageManager chatMessageManager;

    @Mock
    @Bind
    private ChatIconManager chatIconManager;

    @Mock
    @Bind
    private CustomEmojiConfig customEmojiConfig;

    @Inject
    private CustomEmojiPlugin customEmojiPlugin;

    private int iconId;

    @Before
    public void before() throws Exception
    {
        Guice.createInjector(BoundFieldModule.of(this))
                .injectMembers(this);

        when(chatIconManager.registerChatIcon(any(BufferedImage.class)))
                .thenAnswer(a ->
                {
                    int currentId = iconId;
                    iconId++;
                    return currentId;
                });
        when(chatIconManager.chatIconIndex(anyInt()))
                .thenReturn(0);
    }

    @Test
    public void testOnChatMessage() throws Exception
    {

        customEmojiPlugin.startUp();

        MessageNode messageNode = mock(MessageNode.class);
        // With chat recolor, message may be wrapped in col tags
        when(messageNode.getValue()).thenReturn("<col=ff0000>monkaw pipe</col>");

        ChatMessage chatMessage = new ChatMessage();
        chatMessage.setType(ChatMessageType.PUBLICCHAT);
        chatMessage.setMessageNode(messageNode);

        customEmojiPlugin.onChatMessage(chatMessage);

        verify(messageNode).setValue("<col=ff0000><img=0> pipe</col>");

        System.out.println();
    }
}
package com.customemoji.debugplugin;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("custom-emoji-debug")
public interface CustomEmojiDebugConfig extends Config
{
    @ConfigItem(
        keyName = "showEmojiHitboxes",
        name = "Show Emoji Hitboxes",
        description = "Draws cyan borders around emoji hit areas in chat",
        position = 0
    )
    default boolean showEmojiHitboxes()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showRawTextTooltip",
        name = "Show Raw Text Tooltip",
        description = "Shows raw widget text when hovering over chat messages",
        position = 1
    )
    default boolean showRawTextTooltip()
    {
        return true;
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;

import com.google.inject.Provides;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(
    name = "Custom Emoji Debug",
    developerPlugin = true
)
public class CustomEmojiDebugPlugin extends Plugin
{
    private static final String EMOJI_DEBUG_COMMAND = "emojidebug";

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private EmojiHitboxOverlay hitboxOverlay;

    @Inject
    private RawTextTooltipOverlay rawTextTooltipOverlay;

    @Inject
    private Client client;

    @Subscribe
    public void onCommandExecuted(CommandExecuted event)
    {
        if (!event.getCommand().equalsIgnoreCase(EMOJI_DEBUG_COMMAND))
        {
            return;
        }

        String[] args = event.getArguments();
        if (args.length == 0)
        {
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", "Usage: ::emojidebug <icon_id>", null);
            return;
        }

        try
        {
            int iconId = Integer.parseInt(args[0]);
            String message = "Icon " + iconId + ": <img=" + iconId + ">";
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);
        }
        catch (NumberFormatException e)
        {
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", "Invalid icon ID: " + args[0], null);
        }
    }

    @Override
    protected void startUp() throws Exception
    {
        this.overlayManager.add(this.hitboxOverlay);
        this.overlayManager.add(this.rawTextTooltipOverlay);
    }

    @Override
    protected void shutDown() throws Exception
    {
        this.overlayManager.remove(this.hitboxOverlay);
        this.overlayManager.remove(this.rawTextTooltipOverlay);
    }

    @Provides
    CustomEmojiDebugConfig provideDebugConfig(ConfigManager configManager)
    {
        return configManager.getConfig(CustomEmojiDebugConfig.class);
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;
import javax.inject.Singleton;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;

@Singleton
public class RawTextTooltipOverlay extends Overlay
{
    private static final int TOOLTIP_PADDING = 4;
    private static final int TOOLTIP_OFFSET_Y = 20;
    private static final Color BACKGROUND_COLOR = new Color(70, 61, 50, 220);
    private static final Color BORDER_COLOR = new Color(40, 35, 30);
    private static final Color TEXT_COLOR = Color.WHITE;

    @Inject
    private Client client;

    @Inject
    private CustomEmojiDebugConfig config;

    public RawTextTooltipOverlay()
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!this.config.showRawTextTooltip())
        {
            return null;
        }

        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return null;
        }

        net.runelite.api.Point mousePos = this.client.getMouseCanvasPosition();
        if (mousePos == null)
        {
            return null;
        }

        int mouseX = mousePos.getX();
        int mouseY = mousePos.getY();

        Widget hoveredWidget = this.findHoveredWidget(chatbox, mouseX, mouseY);
        if (hoveredWidget == null)
        {
            return null;
        }

        String rawText = hoveredWidget.getText();
        if (rawText == null || rawText.isEmpty())
        {
            return null;
        }

        this.drawTooltip(graphics, rawText, mouseX, mouseY);

        return null;
    }

    private void drawTooltip(Graphics2D graphics, String text, int mouseX, int mouseY)
    {
        Font originalFont = graphics.getFont();
        Font tooltipFont = new Font(Font.MONOSPACED, Font.PLAIN, 12);
        graphics.setFont(tooltipFont);

        FontMetrics fm = graphics.getFontMetrics();
        int textWidth = fm.stringWidth(text);
        int textHeight = fm.getHeight();

        int tooltipX = mouseX;
        int tooltipY = mouseY + TOOLTIP_OFFSET_Y;

        int boxWidth = textWidth + TOOLTIP_PADDING * 2;
        int boxHeight = textHeight + TOOLTIP_PADDING * 2;

        graphics.setColor(BACKGROUND_COLOR);
        graphics.fillRect(tooltipX, tooltipY, boxWidth, boxHeight);

        graphics.setColor(BORDER_COLOR);
        graphics.drawRect(tooltipX, tooltipY, boxWidth, boxHeight);

        graphics.setColor(TEXT_COLOR);
        graphics.drawString(text, tooltipX + TOOLTIP_PADDING, tooltipY + TOOLTIP_PADDING + fm.getAscent());

        graphics.setFont(originalFont);
    }

    private Widget findHoveredWidget(Widget chatbox, int mouseX, int mouseY)
    {
        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        if (dynamicChildren == null)
        {
            return null;
        }

        for (Widget widget : dynamicChildren)
        {
            if (widget == null)
            {
                continue;
            }

            net.runelite.api.Point widgetPos = widget.getCanvasLocation();
            if (widgetPos == null)
            {
                continue;
            }

            int widgetX = widgetPos.getX();
            int widgetY = widgetPos.getY();
            int widgetWidth = widget.getWidth();
            int widgetHeight = widget.getHeight();

            boolean isHovered = mouseX >= widgetX && mouseX <= widgetX + widgetWidth
                && mouseY >= widgetY && mouseY <= widgetY + widgetHeight;

            if (isHovered)
            {
                return widget;
            }
        }

        return null;
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.customemoji.EmojiPosition;
import com.customemoji.EmojiPositionCalculator;

import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class EmojiHitboxOverlay extends Overlay
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiDebugConfig config;

    public EmojiHitboxOverlay()
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (this.config.showEmojiHitboxes())
        {
            this.drawEmojiHitBorders(graphics);
        }
        return null;
    }

    private void drawEmojiHitBorders(Graphics2D graphics)
    {
        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return;
        }

        List<Rectangle> rectangles = new ArrayList<>();
        this.collectAllEmojiRectangles(chatbox, rectangles);

        if (rectangles.isEmpty())
        {
            return;
        }

        // Get the chatbox visible bounds to clip drawing
        net.runelite.api.Point chatboxPos = chatbox.getCanvasLocation();
        int chatboxX = chatboxPos.getX();
        int chatboxY = chatboxPos.getY();
        int chatboxWidth = chatbox.getWidth();
        int chatboxHeight = chatbox.getHeight();
        Rectangle chatboxBounds = new Rectangle(chatboxX, chatboxY, chatboxWidth, chatboxHeight);

        // Save original clip and set clip to chatbox bounds
        Shape originalClip = graphics.getClip();
        graphics.setClip(chatboxBounds);

        Color originalColor = graphics.getColor();
        graphics.setColor(Color.CYAN);

        for (Rectangle rect : rectangles)
        {
            graphics.drawRect(rect.x, rect.y, rect.width, rect.height);
        }

        graphics.setColor(originalColor);
        graphics.setClip(originalClip);
    }

    private void collectAllEmojiRectangles(Widget chatbox, List<Rectangle> rectangles)
    {
        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        if (dynamicChildren == null)
        {
            return;
        }

        for (Widget widget : dynamicChildren)
        {
            if (widget == null)
            {
                continue;
            }

            String text = widget.getText();
            if (text != null && text.contains("<img="))
            {
                this.collectEmojiRectanglesFromWidget(widget, text, rectangles);
            }
        }
    }

    private void collectEmojiRectanglesFromWidget(Widget widget, String text, List<Rectangle> rectangles)
    {
        List<EmojiPosition> positions = EmojiPositionCalculator.calculateEmojiPositions(
            widget,
            text,
            this::getSpriteDimension
        );

        for (EmojiPosition position : positions)
        {
            rectangles.add(position.getBounds());
        }
    }

    private Dimension getSpriteDimension(int imageId)
    {
        IndexedSprite[] modIcons = this.client.getModIcons();
        if (modIcons == null || imageId < 0 || imageId >= modIcons.length)
        {
            return null;
        }

        IndexedSprite sprite = modIcons[imageId];
        if (sprite == null)
        {
            return null;
        }

        return new Dimension(sprite.getWidth(), sprite.getHeight());
    }
}
