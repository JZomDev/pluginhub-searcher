package com.customemoji;

import com.customemoji.model.Emoji;

import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.annotations.VarCInt;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.widgets.Widget;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;

import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class PluginUtils
{
	public static final Pattern IMAGE_TAG_PATTERN = Pattern.compile("<img=(\\d+)>");
	private static final Pattern WHITESPACE_PATTERN = Pattern.compile("[\\s\\u00A0]");

	private PluginUtils()
	{
	}

	public static Dimension getEmojiDimension(IndexedSprite[] modIcons, int imageId)
	{
		if (modIcons == null || imageId < 0 || imageId >= modIcons.length)
		{
			return null;
		}

		IndexedSprite sprite = modIcons[imageId];
		if (sprite == null)
		{
			return null;
		}

		return new Dimension(sprite.getWidth(), sprite.getHeight());
	}

	public static List<Integer> getImageIdsFromText(String text)
	{
		List<Integer> imageIds = new ArrayList<>();

		if (text == null || text.isEmpty())
		{
			return imageIds;
		}

		Matcher matcher = IMAGE_TAG_PATTERN.matcher(text);
		while (matcher.find())
		{
			String idString = matcher.group(1);
			int id = Integer.parseInt(idString);
			imageIds.add(id);
		}

		return imageIds;
	}

	public static List<String> findEmojiTriggersInMessage(String message, Map<String, Emoji> emojis)
	{
		List<String> found = new ArrayList<>();

		if (message == null || message.isEmpty() || emojis == null)
		{
			return found;
		}

		String[] words = WHITESPACE_PATTERN.split(message);
		for (String word : words)
		{
			String trigger = Text.removeFormattingTags(word)
				.replaceAll("(^\\p{Punct}+)|(\\p{Punct}+$)", "")
				.toLowerCase();

			if (trigger.isEmpty())
			{
				continue;
			}

			if (emojis.containsKey(trigger))
			{
				found.add(trigger);
			}
		}

		return found;
	}

	public static int findMaxEmojiHeightInWidget(Widget widget, IndexedSprite[] modIcons)
	{
		if (widget == null)
		{
			return 0;
		}

		int maxHeight = 0;
		String text = widget.getText();
		List<Integer> imageIds = PluginUtils.getImageIdsFromText(text);

		for (int imageId : imageIds)
		{
			Dimension dimension = PluginUtils.getEmojiDimension(modIcons, imageId);
			if (dimension != null)
			{
				maxHeight = Math.max(maxHeight, dimension.height);
			}
		}

		return maxHeight;
	}

	public static Set<String> parseDisabledEmojis(String disabledEmojisString)
	{
		Set<String> result = new HashSet<>();

		if (disabledEmojisString != null && !disabledEmojisString.trim().isEmpty())
		{
			String[] parts = disabledEmojisString.split(",");
			for (String part : parts)
			{
				String trimmed = part.trim();
				if (!trimmed.isEmpty())
				{
					result.add(trimmed);
				}
			}
		}

		return result;
	}

	public static Set<String> parseResizingDisabledEmojis(String resizingDisabledEmojisString)
	{
		Set<String> result = new HashSet<>();

		if (resizingDisabledEmojisString != null && !resizingDisabledEmojisString.trim().isEmpty())
		{
			String[] parts = resizingDisabledEmojisString.split(",");
			for (String part : parts)
			{
				String trimmed = part.trim();
				if (!trimmed.isEmpty())
				{
					result.add(trimmed);
				}
			}
		}

		return result;
	}

	public static Map<Integer, Emoji> buildEmojiLookup(Supplier<Map<String, Emoji>> emojisSupplier)
	{
		Map<Integer, Emoji> lookup = new HashMap<>();

		if (emojisSupplier == null)
		{
			return lookup;
		}

		for (Emoji emoji : emojisSupplier.get().values())
		{
			int imageId = emoji.getImageId();
			if (imageId < 0)
			{
				continue;
			}

			lookup.put(imageId, emoji);

			int zeroWidthImageId = emoji.getZeroWidthImageId();
			if (zeroWidthImageId >= 0)
			{
				lookup.put(zeroWidthImageId, emoji);
			}
		}

		return lookup;
	}

	public static boolean hasImgTag(String text)
	{
		return text != null && text.contains("<img=");
	}

	public static boolean isZeroWidthId(Emoji emoji, int imageId)
	{
		if (emoji == null)
		{
			return false;
		}
		int zeroWidthImageId = emoji.getZeroWidthImageId();
		return zeroWidthImageId >= 0 && zeroWidthImageId == imageId;
	}

	public static void linkZeroWidthEmojisToTarget(
		List<EmojiPosition> positions,
		Map<Integer, Emoji> emojiLookup)
	{
		java.awt.Rectangle lastBaseEmojiBounds = null;

		for (EmojiPosition position : positions)
		{
			Emoji emoji = emojiLookup.get(position.getImageId());
			boolean isZeroWidth = PluginUtils.isZeroWidthId(emoji, position.getImageId());

			if (isZeroWidth)
			{
				position.setBaseEmojiBounds(lastBaseEmojiBounds);
			}

			if (!isZeroWidth && emoji != null)
			{
				lastBaseEmojiBounds = position.getBounds();
			}
		}
	}

	public static Emoji findEmojiByImageId(int imageId, Map<String, Emoji> emojis)
	{
		for (Emoji emoji : emojis.values())
		{
			if (emoji.getImageId() == imageId)
			{
				return emoji;
			}

			int zeroWidthImageId = emoji.getZeroWidthImageId();
			if (zeroWidthImageId >= 0 && zeroWidthImageId == imageId)
			{
				return emoji;
			}
		}

		return null;
	}

	public static boolean getIsMouseInWidget(Client client, Widget widget)
	{
		net.runelite.api.Point mouseCanvasPosition = client.getMouseCanvasPosition();
		if (mouseCanvasPosition == null)
		{
			return false;
		}

		return widget != null && !widget.isHidden() && widget.contains(mouseCanvasPosition);
	}
	
	public static boolean getIsMouseInChatWidget(Client client)
	{
		Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
		boolean inChatbox = PluginUtils.getIsMouseInWidget(client, chatbox);
		if (inChatbox)
		{
			return true;
		}

		Widget pmChat = client.getWidget(InterfaceID.PmChat.CONTAINER);
		return PluginUtils.getIsMouseInWidget(client, pmChat);
	}

	public static List<Widget> getVisibleChatWidgets(Client client)
	{
		if (client.getVarcIntValue(VarClientID.CHAT_VIEW) == 1337) // Chatbox is "minimized"
		{
			return null;
		}

		List<Widget> result = new ArrayList<>();

		Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
		List<Widget> chatboxWidgets = PluginUtils.getVisibleChildWidgets(chatbox);
		if (chatboxWidgets != null)
		{
			result.addAll(chatboxWidgets);
		}

		Widget pmChat = client.getWidget(InterfaceID.PmChat.CONTAINER);
		List<Widget> pmChatWidgets = PluginUtils.getVisibleChildWidgets(pmChat);
		if (pmChatWidgets != null)
		{
			result.addAll(pmChatWidgets);
		}

		return result.isEmpty() ? null : result;
	}

	public static List<Widget> getVisibleChildWidgets(Widget parent)
	{
		if (parent == null || parent.isHidden())
		{
			return null;
		}

		List<Widget> result = new ArrayList<>();

		Widget[] dynamicChildren = parent.getChildren();
		if (dynamicChildren == null)
		{
			return result;
		}

		for (Widget widget : dynamicChildren)
		{
			if (widget == null || !PluginUtils.isWidgetVisible(parent, widget))
			{
				continue;
			}

			result.add(widget);
		}

		return result;
	}

	public static boolean isWidgetVisible(Widget parent, Widget child)
	{
		if (child.isHidden())
		{
			return false;
		}

        int widgetTop = child.getRelativeY();
        int widgetBottom = widgetTop + child.getHeight();

        int viewportTop = parent.getScrollY();
        int viewportBottom = viewportTop + parent.getHeight();

        boolean bottomInView = widgetBottom >= viewportTop;
        boolean topInView = widgetTop <= viewportBottom;

        return bottomInView && topInView;
    }

	public static boolean isAnimatedGif(File file)
	{
		String fileName = file.getName().toLowerCase();
		boolean isGif = fileName.endsWith(".gif");
		if (!isGif)
		{
			return false;
		}

		try (ImageInputStream stream = ImageIO.createImageInputStream(file))
		{
			if (stream == null)
			{
				return false;
			}

			Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName("gif");
			if (!readers.hasNext())
			{
				return false;
			}

			ImageReader reader = readers.next();
			try
			{
				reader.setInput(stream);
				int frameCount = reader.getNumImages(true);
				return frameCount > 1;
			}
			finally
			{
				reader.dispose();
			}
		}
		catch (IOException e)
		{
			return false;
		}
	}

	public static BufferedImage resizeImage(BufferedImage image, int maxImageHeight)
	{
		if (image.getHeight() <= maxImageHeight)
		{
			return image;
		}

		double scaleFactor = (double) maxImageHeight / image.getHeight();
		int scaledWidth = (int) Math.round(image.getWidth() * scaleFactor);

		return ImageUtil.resizeImage(image, scaledWidth, maxImageHeight, true);
	}

	public static int getScrolledUpPixels(Client client)
	{
		Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
		if (chatbox == null)
		{
			return 0;
		}

		int scrollY = chatbox.getScrollY();
		int scrollHeight = chatbox.getScrollHeight();
		int visibleHeight = chatbox.getHeight();

		if (scrollHeight <= visibleHeight)
		{
			return 0;
		}

		return scrollHeight - (visibleHeight + scrollY);
	}
}

package com.customemoji;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.customemoji.model.Emoji;
import com.customemoji.service.EmojiStateManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.IconID;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Slf4j
@Singleton
public class CustomEmojiTooltip extends Overlay
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    @Inject
    private TooltipManager tooltipManager;

    @Inject
    private Map<String, Emoji> emojis;

    @Inject
    private EmojiStateManager emojiStateManager;

    private static final String MENU_OPTION_EMOJI = "Emoji";

    protected void startUp()
    {
        // No longer need mouse listener - we check position in render()
    }

    protected void shutDown()
    {
        // Nothing to clean up
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (this.client.isMenuOpen() || !this.config.showEmojiTooltips())
        {
            return null;
        }

        if (PluginUtils.getVisibleChatWidgets(client) == null)
        {
            return null;
        }

        List<String> hoveredEmojis = this.findHoveredEmojis();
        if (hoveredEmojis != null && !hoveredEmojis.isEmpty())
        {
            String tooltipText = String.join(" + ", hoveredEmojis);
            this.tooltipManager.add(new Tooltip(tooltipText));
        }

        return null;
    }

    private List<String> findHoveredEmojis()
    {
        net.runelite.api.Point mouseCanvasPosition = this.client.getMouseCanvasPosition();

        if (mouseCanvasPosition == null)
        {
            return null;
        }

        Point mousePoint = new Point(mouseCanvasPosition.getX(), mouseCanvasPosition.getY());

        List<Widget> children = PluginUtils.getVisibleChatWidgets(this.client);

        if (children == null)
        {
            return null;
        }

        for (Widget widget : children)
        {
            String text = widget.getText();
            if (text == null || !PluginUtils.hasImgTag(text))
            {
                continue;
            }

            // Only check X bounds here - tall emojis can extend above/below the widget's Y bounds
            // The emoji vertical filtering in findEmojisAtPosition handles Y checking
            Rectangle bounds = widget.getBounds();
            if (bounds == null)
            {
                continue;
            }
            boolean mouseInXRange = mousePoint.x >= bounds.x && mousePoint.x <= bounds.x + bounds.width;
            if (!mouseInXRange)
            {
                continue;
            }

            // Mouse X is within this widget - check for emojis
            List<String> emojisInWidget = this.findEmojisAtPosition(widget, text, mousePoint, bounds);
            if (!emojisInWidget.isEmpty())
            {
                return emojisInWidget;
            }
        }

        return new ArrayList<>();
    }

    private List<String> findEmojisAtPosition(Widget widget, String text, Point mousePoint, Rectangle widgetBounds)
    {
        List<EmojiPosition> positions = EmojiPositionCalculator.calculateEmojiPositions(
            widget,
            text,
            id -> PluginUtils.getEmojiDimension(this.client.getModIcons(), id)
        );

        this.linkZeroWidthEmojisToTarget(positions);

        List<String> emojiNames = new ArrayList<>();
        for (EmojiPosition position : positions)
        {
            // Skip emojis whose vertical bounds don't contain the mouse Y
            int emojiTop = position.getY();
            int emojiBottom = emojiTop + position.getHeight();
            boolean mouseInVerticalRange = mousePoint.y >= emojiTop && mousePoint.y <= emojiBottom;
            if (!mouseInVerticalRange)
            {
                continue;
            }

            boolean isHovered = this.isPositionHovered(position, mousePoint);
            if (isHovered)
            {
                String name = this.findEmojiNameById(position.getImageId());
                if (name != null)
                {
                    emojiNames.add(name);
                }
            }
        }

        return emojiNames;
    }

    private void linkZeroWidthEmojisToTarget(List<EmojiPosition> positions)
    {
        Rectangle lastBaseEmojiBounds = null;

        for (EmojiPosition position : positions)
        {
            Emoji emoji = PluginUtils.findEmojiByImageId(position.getImageId(), this.emojis);
            boolean isZeroWidth = PluginUtils.isZeroWidthId(emoji, position.getImageId());

            if (isZeroWidth)
            {
                position.setBaseEmojiBounds(lastBaseEmojiBounds);
            }

            if (!isZeroWidth && emoji != null)
            {
                lastBaseEmojiBounds = position.getBounds();
            }
        }
    }

    private boolean isPositionHovered(EmojiPosition position, Point mousePoint)
    {
        if (position.hasBaseEmojiBounds())
        {
            return position.getBaseEmojiBounds().contains(mousePoint.x, mousePoint.y);
        }
        return position.containsPoint(mousePoint.x, mousePoint.y);
    }

    private String findEmojiNameById(int imageId)
    {
        Emoji emoji = PluginUtils.findEmojiByImageId(imageId, this.emojis);
        if (emoji != null)
        {
            return emoji.getText();
        }

        // Check built-in RuneLite IconIDs
        for (IconID icon : IconID.values())
        {
            if (icon.getIndex() == imageId)
            {
                return this.formatIconName(icon.name());
            }
        }

        return null;
    }

    private String formatIconName(String enumName)
    {
        // Convert PLAYER_MODERATOR to "Player Moderator"
        String[] words = enumName.toLowerCase().split("_");
        StringBuilder result = new StringBuilder();
        for (String word : words)
        {
            if (result.length() > 0)
            {
                result.append(" ");
            }
            result.append(Character.toUpperCase(word.charAt(0)));
            result.append(word.substring(1));
        }
        return result.toString();
    }

    public void onMenuOpened()
    {
        if (this.emojis == null || this.emojis.isEmpty())
        {
            return;
        }    

        if (PluginUtils.getVisibleChatWidgets(this.client) == null || !PluginUtils.getIsMouseInChatWidget(this.client))
        {
            return;
        }

        List<String> emojiNames = this.findHoveredEmojis();

        List<String> customEmojiNames = this.filterCustomEmojis(emojiNames);
        if (!customEmojiNames.isEmpty())
        {
            this.addContextMenuEntries(customEmojiNames);
        }
    }

    private List<String> filterCustomEmojis(List<String> emojiNames)
    {
        List<String> customEmojis = new ArrayList<>();
        for (String name : emojiNames)
        {
            boolean isCustomEmoji = this.emojis.containsKey(name.toLowerCase());
            if (isCustomEmoji)
            {
                customEmojis.add(name);
            }
        }
        return customEmojis;
    }

    private void addContextMenuEntries(List<String> emojiNames)
    {
        for (int i = emojiNames.size() - 1; i >= 0; i--) // Reverse order to maintain correct menu order
        {
            String emojiName = emojiNames.get(i);
            this.addEmojiMenuEntry(emojiName);
        }
    }

    private void addEmojiMenuEntry(String emojiName)
    {
        boolean isEnabled = this.emojiStateManager.isEmojiEnabled(emojiName);
        boolean isResizingEnabled = this.emojiStateManager.isResizingEnabled(emojiName);

        MenuEntry parent = this.client.getMenu().createMenuEntry(-1)
            .setOption(MENU_OPTION_EMOJI)
            .setTarget("<col=ffff00>" + emojiName + "</col>")
            .setType(MenuAction.RUNELITE);

        Menu submenu = parent.createSubMenu();

        String enableOption = isEnabled ? "Hide" : "Show";
        submenu.createMenuEntry(0)
            .setOption(enableOption)
            .setType(MenuAction.RUNELITE)
            .onClick(e -> this.emojiStateManager.setEmojiEnabled(emojiName, !isEnabled));

        if (isEnabled)
        {
            String resizeOption = isResizingEnabled ? "Full Size" : "Scale Down";
            submenu.createMenuEntry(0)
                .setOption(resizeOption)
                .setType(MenuAction.RUNELITE)
                .onClick(e -> this.emojiStateManager.setEmojiResizing(emojiName, !isResizingEnabled));
        }
    }
}

package com.customemoji;

import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.ScriptID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.widgets.Widget;

import javax.annotation.Nullable;
import java.awt.Rectangle;

import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.function.Supplier;

import com.customemoji.EmojiPositionCalculator.SpacingInfo;
import com.customemoji.model.Emoji;

@Slf4j
@Singleton
public class ChatSpacingManager
{
    private static final int LAST_MESSAGE_PADDING = 4;

    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    private Supplier<Map<Integer, Emoji>> emojiLookupSupplier;

    private final Map<Integer, List<Widget>> chatboxPositions = new HashMap<>();
    private final Map<Integer, List<Widget>> pmChatPositions = new HashMap<>();
    private int scrolledUpPixels = 0;

    public void setEmojiLookupSupplier(Supplier<Map<Integer, Emoji>> supplier)
    {
        this.emojiLookupSupplier = supplier;
    }

    public void clearStoredPositions()
    {
        this.chatboxPositions.clear();
        this.pmChatPositions.clear();
    }

    public void captureScrollPosition()
    {
        int newValue = PluginUtils.getScrolledUpPixels(this.client);

        if (newValue == this.scrolledUpPixels)
        {
            return;
        }

        this.scrolledUpPixels = newValue;
    }

    public void applyChatSpacing()
    {
        int spacingAdjustment = this.config.chatMessageSpacing();
        boolean dynamicSpacing = this.config.dynamicEmojiSpacing();

        boolean noSpacingNeeded = spacingAdjustment == 0 && !dynamicSpacing;
        if (noSpacingNeeded)
        {
            return;
        }

        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        this.processWidget(chatbox, this.chatboxPositions, spacingAdjustment, dynamicSpacing, false, true);

        boolean splitChatEnabled = this.client.getVarpValue(VarPlayerID.OPTION_PM) == 1;
        if (splitChatEnabled)
        {
            Widget pmChat = this.client.getWidget(InterfaceID.PmChat.CONTAINER);
            this.processWidget(pmChat, this.pmChatPositions, spacingAdjustment, dynamicSpacing, true, false);
        }
    }

    private void processWidget(Widget widget, Map<Integer, List<Widget>> positionMap, int spacing, boolean dynamic, boolean invert, boolean scrollable)
    {
        if (widget == null || widget.isHidden())
        {
            return;
        }

        Widget[] children = this.getCombinedChildren(widget);
        Rectangle bounds = this.adjustChildren(children, spacing, dynamic, invert, positionMap);

        if (scrollable)
        {
            this.updateChatBox(widget, bounds);
        }
    }

    private Widget[] getCombinedChildren(Widget parent)
    {
        Widget[] dynamicChildren = this.getChildren(parent::getDynamicChildren);
        Widget[] staticChildren = this.getChildren(parent::getStaticChildren);

        if (dynamicChildren == null)
        {
            dynamicChildren = new Widget[0];
        }
        if (staticChildren == null)
        {
            staticChildren = new Widget[0];
        }

        Widget[] allChildren = new Widget[dynamicChildren.length + staticChildren.length];
        System.arraycopy(dynamicChildren, 0, allChildren, 0, dynamicChildren.length);
        System.arraycopy(staticChildren, 0, allChildren, dynamicChildren.length, staticChildren.length);
        return allChildren;
    }

    private void updateChatBox(Widget chatbox, Rectangle bounds)
    {
        if (bounds == null)
        {
            return;
        }

        int visibleHeight = chatbox.getHeight();

        if (visibleHeight > bounds.height)
        {
            return;
        }

        if (chatbox.getDynamicChildren() == null || chatbox.getDynamicChildren().length < 2)
        {
            return;
        }

        Widget firstChild = chatbox.getDynamicChildren()[1]; // First message widget

        if (firstChild == null)
        {
            return;
        }

        IndexedSprite[] modIcons = this.client.getModIcons();
        EmojiPositionCalculator.DimensionLookup dimensionLookup = imageId -> PluginUtils.getEmojiDimension(modIcons, imageId);
        Set<Integer> customEmojiIds = this.emojiLookupSupplier.get().keySet();
        SpacingInfo spacingInfo = EmojiPositionCalculator.calculateSpacingForWidget(firstChild, dimensionLookup, customEmojiIds);

        // Calculate new scroll height based on the bounds of all widgets
        int newScrollHeight = bounds.height + LAST_MESSAGE_PADDING;

        log.debug(String.valueOf(newScrollHeight));

        // Update the scroll height
        chatbox.setScrollHeight(newScrollHeight);

        // Restore scroll position based on how many lines the user was scrolled up from bottom
        boolean atBottom = this.scrolledUpPixels == 0.0;

        float scrolledUpPixelsLocal = atBottom ? this.scrolledUpPixels : this.scrolledUpPixels + firstChild.getHeight() + spacingInfo.aboveSpacing + config.chatMessageSpacing();

        int newScrollY = (int) (newScrollHeight - visibleHeight - scrolledUpPixelsLocal);
        newScrollY = Math.max(0, newScrollY);

        chatbox.revalidateScroll();

        this.client.runScript(ScriptID.UPDATE_SCROLLBAR, InterfaceID.Chatbox.CHATSCROLLBAR, InterfaceID.Chatbox.SCROLLAREA, newScrollY);

        this.captureScrollPosition();
    }

    @Nullable
    private Rectangle adjustChildren(Widget[] children, int spacingAdjustment, boolean dynamicSpacing, boolean invertSpacing, Map<Integer, List<Widget>> positionMap)
    {
        if (children == null)
        {
            return null;
        }

        // Sort the array so that we adjust them in the proper order. The parent widget
        // has them in the proper order, but split by static or dynamic widget category.
        Widget[] sortedChildren = this.sortByYPosition(children, positionMap);

        // Reverse the children array so last becomes first.
        // This makes it simpler to adjust the positions of every widget.
        // We start at the oldest message at the very top and work our way down
        Widget[] reversedSortedChildren = ChatSpacingManager.reverseArrayOrder(sortedChildren);

        // Group widgets by their original Y position
        Map<Integer, List<Widget>> widgetsByOriginalY = new HashMap<>();

        for (Widget child : reversedSortedChildren)
        {
            if (child == null || child.isHidden())
            {
                continue;
            }

            int storedY = this.resolveOriginalYPosition(child, positionMap);
            widgetsByOriginalY.computeIfAbsent(storedY, k -> new ArrayList<>()).add(child);
        }

        // Sort the original Y positions and apply spacing to each group
        List<Integer> sortedOriginalYs = new ArrayList<>(widgetsByOriginalY.keySet());
        sortedOriginalYs.sort(Integer::compareTo);

        // Track bounds for the bounding rectangle
        int minX = 0;
        int minY = 0;
        int maxX = 0;
        int maxY = 0;

        int lastLineHeight = 0;

        IndexedSprite[] modIcons = dynamicSpacing ? this.client.getModIcons() : null;
        EmojiPositionCalculator.DimensionLookup dimensionLookup = dynamicSpacing
            ? imageId -> PluginUtils.getEmojiDimension(modIcons, imageId)
            : null;

        Set<Integer> customEmojiIds = Collections.emptySet();
        if (dynamicSpacing && this.emojiLookupSupplier != null)
        {
            customEmojiIds = this.emojiLookupSupplier.get().keySet();
        }

        int cumulativeEmojiSpacing = 0;
        int counter = 0;
        for (Integer originalYPos : sortedOriginalYs)
        {
            List<Widget> widgetsAtThisY = widgetsByOriginalY.get(originalYPos);

            // Calculate spacing needed for this row based on emoji positions
            int aboveSpacing = 0;
            int belowSpacing = 0;
            if (dynamicSpacing)
            {
                for (Widget child : widgetsAtThisY)
                {
                    EmojiPositionCalculator.SpacingInfo spacing = EmojiPositionCalculator.calculateSpacingForWidget(child, dimensionLookup, customEmojiIds);
                    aboveSpacing = Math.max(aboveSpacing, spacing.aboveSpacing);
                    belowSpacing = Math.max(belowSpacing, spacing.belowSpacing);
                }

                // Add extra spacing for THIS row if it has tall emojis on the first line
                // (first-line emoji extend upward, so push this row down)
                cumulativeEmojiSpacing += invertSpacing ? belowSpacing : aboveSpacing;
            }

            int newY = originalYPos + (counter * spacingAdjustment) + cumulativeEmojiSpacing;

            // Apply the same Y position and settings to all widgets at the same original y position
            // This is done so that all elements line up with each other.
            for (Widget child : widgetsAtThisY)
            {
                child.setOriginalY(newY);
                child.revalidate();

                // Update bounding rectangle
                int childX = child.getOriginalX();
                int childY = child.getOriginalY();
                int childRight = childX + child.getOriginalWidth();
                int childBottom = childY + child.getOriginalHeight();

                // Add extra height for wrapped line emoji that extend beyond widget bounds
                childBottom += belowSpacing;

                minX = Math.min(minX, childX);
                minY = Math.min(minY, childY);
                maxX = Math.max(maxX, childRight);
                maxY = Math.max(maxY, childBottom);

                if (counter == 0)
                {
                    lastLineHeight = Math.max(lastLineHeight, child.getOriginalHeight());
                }
            }

            // Add extra spacing for tall emojis on wrapped lines
            // (wrapped-line emoji extend downward, so push subsequent rows down)
            if (dynamicSpacing)
            {
                cumulativeEmojiSpacing += invertSpacing ? aboveSpacing : belowSpacing;
            }

            counter++;
        }

        boolean hasWidgets = minX != Integer.MAX_VALUE;
        if (!hasWidgets)
        {
            return null;
        }

        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }

    private Widget[] sortByYPosition(Widget[] array, Map<Integer, List<Widget>> positionMap)
    {
        // Sort by stored Y position
        Arrays.sort(array, (w1, w2) -> {
            if (w1 == null && w2 == null) return 0;
            if (w1 == null) return 1;
            if (w2 == null) return -1;

            // Find the stored Y position for each widget
            Integer storedY1 = this.getStoredYPosition(w1, positionMap);
            Integer storedY2 = this.getStoredYPosition(w2, positionMap);

            // Use stored position if available, otherwise use current position
            int y1 = storedY1 != null ? storedY1 : w1.getOriginalY();
            int y2 = storedY2 != null ? storedY2 : w2.getOriginalY();

            return Integer.compare(y1, y2);
        });

        return array;
    }

    private Integer getStoredYPosition(Widget widget, Map<Integer, List<Widget>> positionMap)
    {
        for (Map.Entry<Integer, List<Widget>> entry : positionMap.entrySet())
        {
            if (entry.getValue().contains(widget))
            {
                return entry.getKey();
            }
        }
        return null;
    }

    private int resolveOriginalYPosition(Widget widget, Map<Integer, List<Widget>> positionMap)
    {
        int currentY = widget.getOriginalY();

        Integer storedY = this.getStoredYPosition(widget, positionMap);
        if (storedY != null && storedY != currentY)
        {
            return storedY;
        }

        boolean isAlreadyStored = positionMap.values().stream()
            .anyMatch(widgets -> widgets.contains(widget));

        if (!isAlreadyStored)
        {
            positionMap
                .computeIfAbsent(currentY, k -> new ArrayList<>())
                .add(widget);
        }

        return currentY;
    }

    private static Widget[] reverseArrayOrder(Widget[] array)
    {
        int len = array.length;
        Widget[] result = new Widget[len];
        
        for (int i = 0; i < len; i++)
        {
            result[i] = array[len - 1 - i];
        }

        return result;
    }

    private Widget[] getChildren(Supplier<Widget[]> childrenSupplier)
    {
        Widget[] children = childrenSupplier.get();
        if (children == null)
        {
            return new Widget[0];
        }

        List<Widget> result = new ArrayList<>();
        for (Widget child : children)
        {
            int height = child.getHeight();

            if (height == 0)
            {
                continue;
            }

            result.add(child);
        }

        return result.toArray(new Widget[0]);
    }
}
package com.customemoji.io;

import com.customemoji.CustomEmojiPlugin;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import lombok.Getter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

@Slf4j
public class GitHubEmojiDownloader
{
	// Only these two GitHub domains are ever contacted - user input is restricted to "owner/repo" format
	private static final HttpUrl GITHUB_API_BASE = HttpUrl.parse("https://api.github.com");
	private static final HttpUrl GITHUB_RAW_BASE = HttpUrl.parse("https://raw.githubusercontent.com");
	private static final Set<String> ALLOWED_EXTENSIONS = Set.of(".png", ".jpg", ".jpeg", ".gif");
	private static final long MAX_FILE_SIZE_BYTES = 10L * 1024 * 1024;

	public static final File GITHUB_PACK_FOLDER = new File(CustomEmojiPlugin.EMOJIS_FOLDER, "github-pack");
	private static final File METADATA_FILE = new File(GITHUB_PACK_FOLDER, "github-download.json");

	private final OkHttpClient okHttpClient;
	private final Gson gson;
	private final ScheduledExecutorService executor;
	public final AtomicBoolean isDownloading = new AtomicBoolean(false);
	private final AtomicReference<Future<?>> currentTask = new AtomicReference<>();
	private final AtomicReference<DownloadProgress> currentProgress = new AtomicReference<>(null);
	private volatile boolean cancelled = false;

	@Value
	public static class RepoConfig
	{
		String owner;
		String repo;
		String branch;
	}

	@Value
	public static class DownloadMetadata
	{
		String repoIdentifier;
		String branch;
		Map<String, String> files;
		long lastDownload;
	}

	@Value
	public static class TreeEntry
	{
		String path;
		String sha;
		long size;
	}

	@Value
	public static class DownloadResult
	{
		boolean success;
		int downloaded;
		int failed;
		int deleted;
		String errorMessage;
		List<String> changedEmojiNames;

		public boolean hasChanges()
		{
			return this.downloaded > 0 || this.deleted > 0;
		}

		public String formatMessage()
		{
			if (!this.success)
			{
				return "Custom Emoji: <col=FF0000>" + this.errorMessage;
			}

			List<String> parts = new ArrayList<>();
			if (this.downloaded > 0)
			{
				parts.add(String.format("Downloaded %d emoji%s", this.downloaded, this.downloaded == 1 ? "" : "s"));
			}
			if (this.deleted > 0)
			{
				parts.add(String.format("Removed %d emoji%s", this.deleted, this.deleted == 1 ? "" : "s"));
			}
			if (this.failed > 0)
			{
				parts.add(String.format("<col=FF6600>(%d failed)", this.failed));
			}

			String message = parts.isEmpty() ? "Already up to date" : String.join(", ", parts);
			return "Custom Emoji: <col=00FF00>" + message;
		}

		public String formatPanelMessage()
		{
			if (!this.success)
			{
				return this.errorMessage;
			}

			List<String> parts = new ArrayList<>();
			if (this.downloaded > 0)
			{
				parts.add(String.format("Downloaded %d emoji%s", this.downloaded, this.downloaded == 1 ? "" : "s"));
			}
			if (this.deleted > 0)
			{
				parts.add(String.format("Removed %d emoji%s", this.deleted, this.deleted == 1 ? "" : "s"));
			}
			if (this.failed > 0)
			{
				parts.add(String.format("(%d failed)", this.failed));
			}

			return parts.isEmpty() ? "Already up to date" : String.join(", ", parts);
		}
	}

	@Getter
	public enum DownloadStage
	{
		FETCHING_METADATA("Fetching repository info..."),
		DELETING_OLD("Removing old files..."),
		DOWNLOADING("Downloading..."),
		COMPLETE("Complete");

		private final String displayText;

		DownloadStage(String displayText)
		{
			this.displayText = displayText;
		}
	}

	@Value
	public static class DownloadProgress
	{
		DownloadStage stage;
		int totalFiles;
		int currentFileIndex;
		String currentFileName;

		public double getPercentage()
		{
			if (this.totalFiles == 0)
			{
				return 0.0;
			}
			return (double) this.currentFileIndex / this.totalFiles;
		}
	}

	public GitHubEmojiDownloader(OkHttpClient okHttpClient, Gson gson, ScheduledExecutorService executor)
	{
		this.okHttpClient = okHttpClient;
		this.gson = gson;
		this.executor = executor;
	}

	public DownloadProgress getCurrentProgress()
	{
		return this.currentProgress.get();
	}

	public RepoConfig parseRepoIdentifier(String input)
	{
		if (input == null || input.trim().isEmpty())
		{
			return null;
		}

		// Reject URLs - only "owner/repo" or "owner/repo/tree/branch" allowed
		String trimmed = input.trim();
		boolean looksLikeUrl = trimmed.contains("://") || trimmed.startsWith("http") || trimmed.startsWith("www.");
		if (looksLikeUrl)
		{
			return null;
		}

		String[] parts = trimmed.split("/");

		if (parts.length < 2 || parts[0].isEmpty() || parts[1].isEmpty())
		{
			return null;
		}

		if (parts.length == 2)
		{
			return new RepoConfig(parts[0], parts[1], null);
		}

		if (parts.length == 4 && parts[2].equals("tree") && !parts[3].isEmpty())
		{
			return new RepoConfig(parts[0], parts[1], parts[3]);
		}

		return null;
	}

	public void downloadEmojis(String repoIdentifier, Consumer<DownloadResult> onComplete)
	{
		this.downloadEmojis(repoIdentifier, null, onComplete);
	}

	public void downloadEmojis(String repoIdentifier, Runnable onStarted, Consumer<DownloadResult> onComplete)
	{
		this.cancelCurrentDownload();

		this.cancelled = false;
		this.isDownloading.set(true);

		Future<?> task = this.executor.submit(() ->
		{
			try
			{
				DownloadResult result = this.performDownload(repoIdentifier, onStarted);
				if (!this.cancelled)
				{
					onComplete.accept(result);
				}
			}
			catch (Exception e)
			{
				if (!this.cancelled)
				{
					log.error("GitHub download failed", e);
					onComplete.accept(new DownloadResult(false, 0, 0, 0, e.getMessage(), List.of()));
				}
			}
			finally
			{
				this.isDownloading.set(false);
				this.currentProgress.set(null);
				this.currentTask.set(null);
			}
		});

		this.currentTask.set(task);
	}

	private void cancelCurrentDownload()
	{
		this.cancelled = true;
		this.currentProgress.set(null);
		Future<?> task = this.currentTask.getAndSet(null);
		if (task != null)
		{
			task.cancel(true);
		}
	}

	public void shutdown()
	{
		this.cancelCurrentDownload();
	}

	private DownloadResult cancelledResult()
	{
		return new DownloadResult(false, 0, 0, 0, "Download cancelled", List.of());
	}

	private DownloadResult performDownload(String repoIdentifier, Runnable onStarted)
	{
		this.currentProgress.set(new DownloadProgress(DownloadStage.FETCHING_METADATA, 0, 0, null));

		RepoConfig config = this.parseRepoIdentifier(repoIdentifier);
		if (config == null)
		{
			return new DownloadResult(false, 0, 0, 0, "Invalid format. Use: user/repo or user/repo/tree/branch", List.of());
		}

		if (this.cancelled)
		{
			return this.cancelledResult();
		}

		String repoPath = config.getOwner() + "/" + config.getRepo();
		String branch = config.getBranch() != null ? config.getBranch() : this.fetchDefaultBranch(config);
		if (this.cancelled)
		{
			return this.cancelledResult();
		}
		if (branch == null)
		{
			return new DownloadResult(false, 0, 0, 0, "Repository not found: " + repoPath, List.of());
		}

		List<TreeEntry> remoteFiles = this.fetchRepoTree(config, branch);
		if (this.cancelled)
		{
			return this.cancelledResult();
		}
		if (remoteFiles == null)
		{
			String errorMessage = config.getBranch() != null
				? "Branch '" + branch + "' not found in " + repoPath
				: "Could not access repository: " + repoPath;
			return new DownloadResult(false, 0, 0, 0, errorMessage, List.of());
		}

		if (onStarted != null)
		{
			onStarted.run();
		}

		GITHUB_PACK_FOLDER.mkdirs();

		DownloadMetadata localMetadata = this.loadMetadata();
		boolean repoChanged = localMetadata != null && !repoIdentifier.equals(localMetadata.getRepoIdentifier());

		if (repoChanged)
		{
			this.clearGitHubPackFolder();
		}

		Map<String, String> localFiles = repoChanged || localMetadata == null ? new HashMap<>() : localMetadata.getFiles();

		Set<String> remoteFilePaths = new HashSet<>();
		List<TreeEntry> toDownload = new ArrayList<>();

		for (TreeEntry entry : remoteFiles)
		{
			remoteFilePaths.add(entry.getPath());
			String localSha = localFiles.get(entry.getPath());
			File localFile = this.toLocalFile(entry.getPath());

			if (localFile.exists())
			{
				boolean shaMismatch = localSha == null || !localSha.equals(entry.getSha());
				boolean sizeMismatch = localFile.length() != entry.getSize();

				if (shaMismatch || sizeMismatch)
				{
					try
					{
						Files.delete(localFile.toPath());
					}
					catch (IOException e)
					{
						log.warn("Failed to delete mismatched file: {}", localFile.getPath());
					}
				}
			}

			boolean shaChanged = localSha == null || !localSha.equals(entry.getSha());
			boolean fileMissing = !localFile.exists();

			if (shaChanged || fileMissing)
			{
				toDownload.add(entry);
			}
		}

		this.currentProgress.set(new DownloadProgress(DownloadStage.DELETING_OLD, 0, 0, null));
		int deleted = this.deleteRemovedFiles(localFiles.keySet(), remoteFilePaths);

		int downloaded = 0;
		int failed = 0;
		int fileIndex = 0;
		int totalToDownload = toDownload.size();
		Map<String, String> newFileHashes = new HashMap<>();
		List<String> changedEmojiNames = new ArrayList<>();

		for (TreeEntry entry : toDownload)
		{
			if (this.cancelled)
			{
				break;
			}

			fileIndex++;
			String fileName = this.extractFileName(entry.getPath());
			this.currentProgress.set(new DownloadProgress(DownloadStage.DOWNLOADING, totalToDownload, fileIndex, fileName));

			if (this.downloadFile(config.getOwner(), config.getRepo(), branch, entry))
			{
				downloaded++;
				newFileHashes.put(entry.getPath(), entry.getSha());
				String emojiName = this.extractEmojiName(fileName);
				changedEmojiNames.add(emojiName);
			}
			else
			{
				failed++;
			}
		}

		if (this.cancelled)
		{
			return this.cancelledResult();
		}

		Map<String, String> allFiles = new HashMap<>(localFiles);
		allFiles.keySet().retainAll(remoteFilePaths);
		allFiles.putAll(newFileHashes);

		this.saveMetadata(new DownloadMetadata(repoIdentifier, branch, allFiles, System.currentTimeMillis()));

		return new DownloadResult(true, downloaded, failed, deleted, null, changedEmojiNames);
	}

	private String fetchDefaultBranch(RepoConfig config)
	{
		HttpUrl url = GITHUB_API_BASE.newBuilder()
			.addPathSegment("repos")
			.addPathSegment(config.getOwner())
			.addPathSegment(config.getRepo())
			.build();

		JsonObject json = this.fetchJson(url);
		return json != null && json.has("default_branch") ? json.get("default_branch").getAsString() : null;
	}

	private List<TreeEntry> fetchRepoTree(RepoConfig config, String branch)
	{
		HttpUrl url = GITHUB_API_BASE.newBuilder()
			.addPathSegment("repos")
			.addPathSegment(config.getOwner())
			.addPathSegment(config.getRepo())
			.addPathSegment("git")
			.addPathSegment("trees")
			.addPathSegment(branch)
			.addQueryParameter("recursive", "1")
			.build();

		JsonObject json = this.fetchJson(url);
		if (json == null || !json.has("tree"))
		{
			return null;
		}

		List<TreeEntry> entries = new ArrayList<>();
		JsonArray treeArray = json.getAsJsonArray("tree");

		for (JsonElement element : treeArray)
		{
			JsonObject entry = element.getAsJsonObject();
			String type = entry.get("type").getAsString();
			String path = entry.get("path").getAsString();
			String sha = entry.get("sha").getAsString();
			long size = entry.has("size") ? entry.get("size").getAsLong() : 0;

			boolean isFile = "blob".equals(type);
			boolean validFile = isFile && this.isAllowedExtension(path) && this.isPathSafe(path) && size <= MAX_FILE_SIZE_BYTES;
			if (validFile)
			{
				entries.add(new TreeEntry(path, sha, size));
			}
		}

		return entries;
	}

	private JsonObject fetchJson(HttpUrl url)
	{
		Request request = new Request.Builder()
			.url(url)
			.header("Accept", "application/vnd.github.v3+json")
			.build();

		try (Response response = this.okHttpClient.newCall(request).execute())
		{
			ResponseBody body = response.body();
			if (!response.isSuccessful() || body == null)
			{
				log.error("GitHub API error: {}", response.code());
				return null;
			}
			return this.gson.fromJson(body.string(), JsonObject.class);
		}
		catch (IOException e)
		{
			log.error("GitHub API request failed", e);
			return null;
		}
	}

	private boolean downloadFile(String owner, String repo, String branch, TreeEntry entry)
	{
		HttpUrl.Builder urlBuilder = GITHUB_RAW_BASE.newBuilder()
			.addPathSegment(owner)
			.addPathSegment(repo)
			.addPathSegment(branch);

		for (String segment : entry.getPath().split("/"))
		{
			urlBuilder.addPathSegment(segment);
		}

		File destination = this.toLocalFile(entry.getPath());
		if (!this.isDestinationSafe(destination))
		{
			return false;
		}

		File parentDir = destination.getParentFile();
		if (parentDir != null)
		{
			parentDir.mkdirs();
		}

		Request request = new Request.Builder().url(urlBuilder.build()).build();

		try (Response response = this.okHttpClient.newCall(request).execute())
		{
			ResponseBody body = response.body();
			if (!response.isSuccessful() || body == null)
			{
				return false;
			}

			if (destination.exists())
			{
				Files.delete(destination.toPath());
			}

			Files.copy(new BufferedInputStream(body.byteStream()), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);

			long actualSize = destination.length();
			long entrySize = entry.getSize();
			if (actualSize != entrySize)
			{
				log.warn("Size mismatch for {}: expected {} but got {}", entry.getPath(), entry.getSize(), actualSize);
				Files.delete(destination.toPath());
				return false;
			}

			return true;
		}
		catch (IOException e)
		{
			log.error("Download failed: {}", entry.getPath(), e);
			return false;
		}
	}

	private boolean isAllowedExtension(String path)
	{
		String lower = path.toLowerCase();
		return ALLOWED_EXTENSIONS.stream().anyMatch(lower::endsWith);
	}

	private boolean isPathSafe(String path)
	{
		return path != null && !path.isEmpty() && !path.contains("..") && !path.startsWith("/") && !path.startsWith("\\");
	}

	private String extractFileName(String path)
	{
		int lastSlash = path.lastIndexOf('/');
		return lastSlash >= 0 ? path.substring(lastSlash + 1) : path;
	}

	private String extractEmojiName(String fileName)
	{
		int lastDot = fileName.lastIndexOf('.');
		return lastDot >= 0 ? fileName.substring(0, lastDot).toLowerCase() : fileName.toLowerCase();
	}

	private boolean isDestinationSafe(File destination)
	{
		try
		{
			return destination.getCanonicalPath().startsWith(GITHUB_PACK_FOLDER.getCanonicalPath());
		}
		catch (IOException e)
		{
			return false;
		}
	}

	private File toLocalFile(String remotePath)
	{
		return new File(GITHUB_PACK_FOLDER, remotePath.replace("/", File.separator));
	}

	private int deleteRemovedFiles(Set<String> localPaths, Set<String> remotePaths)
	{
		int deleted = 0;
		for (String path : localPaths)
		{
			boolean stillExistsRemotely = remotePaths.contains(path);
			if (stillExistsRemotely)
			{
				continue;
			}

			File fileToDelete = this.toLocalFile(path);
			boolean safeToDelete = this.isDestinationSafe(fileToDelete);
			if (safeToDelete)
			{
				try
				{
					Files.deleteIfExists(fileToDelete.toPath());
					deleted++;
				}
				catch (IOException e)
				{
					log.warn("Failed to delete: {}", path);
				}
			}
			else
			{
				log.warn("Skipping unsafe delete path: {}", path);
			}
		}
		return deleted;
	}

	private void clearGitHubPackFolder()
	{
		File[] files = GITHUB_PACK_FOLDER.listFiles();
		if (files == null)
		{
			return;
		}

		for (File file : files)
		{
			this.deleteRecursively(file);
		}
	}

	private void deleteRecursively(File file)
	{
		if (file.isDirectory())
		{
			File[] children = file.listFiles();
			if (children != null)
			{
				for (File child : children)
				{
					this.deleteRecursively(child);
				}
			}
		}

		try
		{
			Files.deleteIfExists(file.toPath());
		}
		catch (IOException e)
		{
			log.warn("Failed to delete: {}", file.getPath());
		}
	}

	public boolean hasDownloadedBefore()
	{
		return METADATA_FILE.exists();
	}

	private DownloadMetadata loadMetadata()
	{
		if (!METADATA_FILE.exists())
		{
			return null;
		}

		try
		{
			String json = Files.readString(METADATA_FILE.toPath());
			return this.gson.fromJson(json, DownloadMetadata.class);
		}
		catch (Exception e)
		{
			log.error("Failed to load metadata", e);
			return null;
		}
	}

	private void saveMetadata(DownloadMetadata metadata)
	{
		try
		{
			Files.writeString(METADATA_FILE.toPath(), this.gson.toJson(metadata));
		}
		catch (IOException e)
		{
			log.error("Failed to save metadata", e);
		}
	}
}

/**
 * Author: Louis Hong
 */

package com.customemoji;

import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

/**
 * Mom: We have Rust at home<br>
 * Rust at home: {@link Result}
 */
@NonNull
public interface Result<@NonNull V, @NonNull E>
{

	@NonNull
	static <V, E> Result<V, E> Ok(V value)
	{
		return new OkResult<>(value);
	}

	@NonNull
	static <E> Result<Void, E> Ok()
	{
		return new OkResult<>(null);
	}

	@NonNull
	static <V, E> Result<V, E> Error(@NonNull E exception)
	{
		return new ErrorResult<>(exception);
	}

	@NonNull
	static <V, E> Result<V, E> PartialOk(V value, E exception)
	{
		return new PartialResult<>(value, exception);
	}


	boolean isOk();

	boolean isError();

	void ifOk(@NonNull Consumer<? super V> then);

	void ifOk(@NonNull Runnable then);

	void ifError(@NonNull Consumer<? super E> then);

	<V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper);

	<E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper);

	Optional<V> toOptional();

	@NonNull
	V unwrap() throws IllegalUnwrapException;

	@NonNull
	E unwrapError() throws IllegalUnwrapException;


	@NonNull
	static <V> Result<V, NoSuchElementException> fromNullable(@Nullable V value)
	{
		if (value == null)
		{
			return Error(new NoSuchElementException("Value is null"));
		}
		else
		{
			return Ok(value);
		}
	}

	@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
	@NonNull
	static <V> Result<V, NoSuchElementException> fromOptional(Optional<V> value)
	{
		if (value.isEmpty())
		{
			return Error(new NoSuchElementException("Value is null"));
		}
		else
		{
			return Ok(value.get());
		}
	}

	@AllArgsConstructor(access=AccessLevel.PUBLIC)
	class OkResult<@NonNull V, E> implements Result<V, E>
	{
		private final V value;

		@Override
		public boolean isOk() {return true;}

		@Override
		public boolean isError() {return false;}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then)
		{
			then.accept(value);
		}

		@Override
		public void ifOk(@NonNull Runnable then)
		{
			then.run();
		}

		@Override
		public void ifError(@NonNull Consumer<? super E> then) {}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new OkResult<>(mapper.apply(value));
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new OkResult<>(value);
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.of(value);
		}

		@Override
		public @NonNull V unwrap()
		{
			return value;
		}

		@Override
		public @NonNull E unwrapError() throws IllegalUnwrapException
		{
			throw new IllegalUnwrapException("Cannot unwrap error from Ok result");
		}

	}

	@Slf4j
	@AllArgsConstructor(access=AccessLevel.PRIVATE)
	class ErrorResult<V, @NonNull E> implements Result<V, E>
	{
		private final E exception;

		@Override
		public boolean isOk() {return false;}

		@Override
		public boolean isError() {return true;}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then) {}

		@Override
		public void ifOk(@NonNull Runnable then) {}

		@Override
		public void ifError(@NonNull Consumer<? super E> then)
		{
			then.accept(exception);
		}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new ErrorResult<>(exception);
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new ErrorResult<>(mapper.apply(exception));
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.empty();
		}

		@Override
		public @NonNull V unwrap() throws IllegalStateException
		{
			throw new IllegalUnwrapException("Cannot unwrap value from Error result");
		}

		@Override
		public @NonNull E unwrapError()
		{
			return exception;
		}
	}

	@Slf4j
	@AllArgsConstructor(access=AccessLevel.PRIVATE)
	class PartialResult<V, @NonNull E> implements Result<V, E>
	{
		private final V value;
		private final E exception;

		@Override
		public boolean isOk()
		{
			return true;
		}

		@Override
		public boolean isError()
		{
			return true;
		}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then)
		{
			then.accept(value);
		}

		@Override
		public void ifOk(@NonNull Runnable then)
		{
			then.run();
		}

		@Override
		public void ifError(@NonNull Consumer<? super E> then)
		{
			then.accept(exception);
		}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new PartialResult<>(mapper.apply(value), exception);
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new PartialResult<>(value, mapper.apply(exception));
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.of(value);
		}

		@Override
		public @NonNull V unwrap()
		{
			return value;
		}

		@Override
		public @NonNull E unwrapError()
		{
			return exception;
		}
	}

	class IllegalUnwrapException extends IllegalStateException
	{
		public IllegalUnwrapException(String message)
		{
			super(message);
		}
	}

	class ResultFutures
	{
		@NonNull
		public static <V, E extends Throwable> ListenableFuture<Result<V, E>> immediateError(@NonNull E exception)
		{
			return Futures.immediateFuture(Error(exception));
		}

		@NonNull
		public static <V, E extends Throwable> ListenableFuture<Result<V, E>> immediateOk(@NonNull V value)
		{
			return Futures.immediateFuture(Ok(value));
		}

		@NonNull
		public static <E extends Throwable> ListenableFuture<Result<Void, E>> immediateOk()
		{
			return Futures.immediateFuture(Ok());
		}

	}
}

package com.customemoji;

import static com.customemoji.Result.Error;
import static com.customemoji.Result.Ok;
import static com.customemoji.Result.PartialOk;
import com.customemoji.animation.AnimationManager;
import com.customemoji.model.AnimatedEmoji;
import com.customemoji.model.Emoji;
import com.customemoji.model.Soundoji;
import com.customemoji.model.StaticEmoji;
import com.customemoji.io.GitHubEmojiDownloader;
import com.customemoji.renderer.ChatEmojiRenderer;
import com.customemoji.renderer.NewMessageBannerRenderer;
import com.customemoji.renderer.OverheadEmojiRenderer;
import com.customemoji.renderer.SplitPrivateChatEmojiRenderer;
import com.customemoji.service.EmojiStateManager;
import com.customemoji.service.EmojiUsageRecorder;
import com.google.common.io.Resources;
import com.google.gson.Gson;
import com.google.inject.Provides;
import com.google.inject.Provider;
import okhttp3.OkHttpClient;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.stream.Collectors;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.UnaryOperator;
import java.util.regex.Pattern;

import javax.annotation.Nullable;
import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import javax.inject.Inject;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import java.util.Iterator;
import javax.swing.SwingUtilities;

import lombok.Getter;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.IterableHashTable;
import net.runelite.api.MessageNode;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.events.VarClientStrChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.RuneLite;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import com.customemoji.panel.CustomEmojiPanel;
import com.customemoji.panel.PanelConstants;
import com.customemoji.panel.StatusMessagePanel;

import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;

@Slf4j
@PluginDescriptor(
		name = "Custom Emoji",
		description = "Allows you to use custom emojis in chat messages",
		tags = {"emoji", "chat", "message", "custom", "icon", "emote", "text", "clan", "notification"}
)
public class CustomEmojiPlugin extends Plugin
{
	public static final String EMOJI_ERROR_COMMAND = "emojierror";
	public static final String EMOJI_FOLDER_COMMAND = "emojifolder";
	public static final String SOUNDOJI_FOLDER_COMMAND = "soundojifolder";

	public static final File SOUNDOJIS_FOLDER = RuneLite.RUNELITE_DIR.toPath().resolve("soundojis").toFile();
	public static final File EMOJIS_FOLDER = RuneLite.RUNELITE_DIR.toPath().resolve("emojis").toFile();

	public static final URL EXAMPLE_EMOJI = Resources.getResource(CustomEmojiPlugin.class, "checkmark.png");
	public static final URL EXAMPLE_SOUNDOJI = Resources.getResource(CustomEmojiPlugin.class, "customemoji.wav");

	public static final float NOISE_FLOOR = -60f;

	private static final Pattern WHITESPACE_REGEXP = Pattern.compile("[\\s\\u00A0]");
	private static final String IMG_TAG_PREFIX = "<img=";
	private static final int MAX_REGISTRATION_RETRIES = 10;
	private static final String UNKNOWN_EMOJI_PLACEHOLDER = "[?]";

	@Inject
	private EventBus eventBus;

	@Inject
	private CustomEmojiOverlay overlay;

	@Inject
	private CustomEmojiTooltip tooltip;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private CustomEmojiConfig config;

	@Inject
	private ChatIconManager chatIconManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private AudioPlayer audioPlayer;

	@Inject
	private ChatSpacingManager chatSpacingManager;

	@Inject
	private AnimationManager animationManager;

	@Inject
	private ChatEmojiRenderer chatEmojiRenderer;

	@Inject
	private SplitPrivateChatEmojiRenderer splitPrivateChatEmojiRenderer;

	@Inject
	private OverheadEmojiRenderer overheadEmojiRenderer;

	@Inject
	private NewMessageBannerRenderer newMessageBannerRenderer;

	@Inject
	private Provider<CustomEmojiPanel> panelProvider;

	@Inject
	private EmojiStateManager emojiStateManager;

	@Inject
	private EmojiUsageRecorder usageRecorder;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	private GitHubEmojiDownloader githubDownloader;

	@Getter
	protected final Map<String, Emoji> emojis = new ConcurrentHashMap<>();
	private final Map<String, Soundoji> soundojis = new ConcurrentHashMap<>();
	private final List<String> errors = Collections.synchronizedList(new ArrayList<>());

	@lombok.Value
	private static class LoadedEmoji
	{
		String name;
		File file;
		long lastModified;
		BufferedImage image;
		Integer existingId;
		boolean animated;
	}

	private ScheduledExecutorService debounceExecutor;
	private ScheduledFuture<?> pendingReload;
	private CustomEmojiPanel panel;
	private NavigationButton navButton;

	private void setup()
	{
		if (EMOJIS_FOLDER.mkdir())
		{
			// copy example emoji
			File exampleEmoji = new File(EMOJIS_FOLDER, "checkmark.png");
			try (InputStream in = EXAMPLE_EMOJI.openStream())
			{
				Files.copy(in, exampleEmoji.toPath());
			}
			catch (IOException e)
			{
				log.error("Failed to copy example emoji", e);
			}
		}

		if (SOUNDOJIS_FOLDER.mkdir())
		{
			// copy example soundoji
			File exampleSoundoji = new File(SOUNDOJIS_FOLDER, "customemoji.wav");
			try (InputStream in = EXAMPLE_SOUNDOJI.openStream())
			{
				Files.copy(in, exampleSoundoji.toPath());
			}
			catch (IOException e)
			{
				log.error("Failed to copy example soundoji", e);
			}
		}
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted e)
	{
		switch (e.getCommand())
		{
			case EMOJI_FOLDER_COMMAND:
				LinkBrowser.open(EMOJIS_FOLDER.toString());
				break;
			case SOUNDOJI_FOLDER_COMMAND:
				LinkBrowser.open(SOUNDOJIS_FOLDER.toString());
				break;
			case EMOJI_ERROR_COMMAND:

				for (String error : errors)
				{
					client.addChatMessage(ChatMessageType.CONSOLE, "", error, null);
				}
				break;
			default:
				break;
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		setup();
		this.animationManager.initialize();

		this.githubDownloader = new GitHubEmojiDownloader(this.okHttpClient, this.gson, this.executor);

		this.emojiStateManager.setOnEmojiEnabled(this::replaceEnabledEmojiInChat);
		this.emojiStateManager.setOnEmojiDisabled(this::replaceDisabledEmojiInChat);
		this.emojiStateManager.setOnEmojiResizingToggled(this::handleEmojiResizingToggled);

		this.usageRecorder.setEmojisSupplier(() -> this.emojis);
		this.eventBus.register(this.usageRecorder);

		loadSoundojis();

		if (this.isGitHubDownloadConfigured())
		{
			this.triggerGitHubDownloadForStartup();
		}
		else
		{
			this.loadEmojisAsync(this::replaceAllTextWithEmojis);
		}

		this.toggleButton(this.config.showPanel());

		overlay.startUp();
		overlayManager.add(overlay);

		tooltip.startUp();
		overlayManager.add(tooltip);

		this.newMessageBannerRenderer.startUp();
		this.overlayManager.add(this.newMessageBannerRenderer);

		// Set up animation overlays (they check config.animationLoadingMode() during render)
		this.setupAnimationOverlays();

		this.chatSpacingManager.setEmojiLookupSupplier(() ->
			PluginUtils.buildEmojiLookup(() -> this.emojis));

		// Apply initial chat spacing
		clientThread.invokeLater(chatSpacingManager::applyChatSpacing);

		// Create executor for debouncing reloads (many files changed at once, potentially from a git pull)
		debounceExecutor = Executors.newSingleThreadScheduledExecutor(r ->
		{
			Thread t = new Thread(r, "CustomEmoji-Debouncer");
			t.setDaemon(true);
			return t;
		});

		if (!errors.isEmpty())
		{
			String message = "There were " + errors.size() + " errors loading emojis. Use ::emojierror to see them.";
			this.showPanelStatus(message, StatusMessagePanel.MessageType.ERROR, false);
		}
		else
		{
			log.debug("Custom Emoji: Loaded " + emojis.size() + soundojis.size() + " emojis and soundojis.");
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		this.replaceAllEmojisWithText();

		this.eventBus.unregister(this.usageRecorder);

		this.githubDownloader.shutdown();
		this.shutdownDebounceExecutor();
		emojis.clear();
		errors.clear();
		chatSpacingManager.clearStoredPositions();

		overlay.shutDown();
		overlayManager.remove(overlay);

		tooltip.shutDown();
		overlayManager.remove(tooltip);

		this.newMessageBannerRenderer.shutDown();
		this.overlayManager.remove(this.newMessageBannerRenderer);

		// Clean up animation overlays
		this.teardownAnimationOverlays();
		this.animationManager.shutdown();

		if (panel != null)
		{
			this.toggleButton(false);
		}

		// Clear soundojis - AudioPlayer handles clip management automatically
		soundojis.clear();

		log.debug("Plugin shutdown complete - all containers cleared");
	}

	private void triggerGitHubDownloadForStartup()
	{
		this.githubDownloader.downloadEmojis(this.config.githubRepoUrl(), null, result ->
		{
			StatusMessagePanel.MessageType messageType = result.isSuccess()
				? StatusMessagePanel.MessageType.SUCCESS
				: StatusMessagePanel.MessageType.ERROR;
			this.showPanelStatus(result.formatPanelMessage(), messageType);

			this.loadEmojisAsync(this::replaceAllTextWithEmojis);
		});
	}

	public void triggerGitHubDownloadAndReload()
	{
		if (!this.isGitHubDownloadConfigured())
		{
			this.showPanelStatus("GitHub download disabled - configure repository in settings", StatusMessagePanel.MessageType.WARNING);
			return;
		}

		Runnable onStarted = () ->
		{
			if (this.navButton != null)
			{
				SwingUtilities.invokeLater(() -> this.clientToolbar.openPanel(this.navButton));
			}
		};

		boolean hadPreviousDownload = this.githubDownloader.hasDownloadedBefore();

		this.replaceAllEmojisWithText();

		this.githubDownloader.downloadEmojis(this.config.githubRepoUrl(), onStarted, result ->
		{
			if (!result.isSuccess())
			{
				this.clientThread.invokeLater(() ->
					this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", result.formatMessage(), null));
			}
			else
			{
				StatusMessagePanel.MessageType messageType = StatusMessagePanel.MessageType.SUCCESS;
				this.showPanelStatus(result.formatPanelMessage(), messageType);
			}

			if (result.hasChanges())
			{
				List<String> changedNames = result.getChangedEmojiNames();
				if (this.panel != null && hadPreviousDownload)
				{
					this.panel.setPendingRecentlyDownloaded(changedNames);
				}
				this.forceReloadChangedEmojis(changedNames);
			}

			this.clientThread.invokeLater(this::replaceAllTextWithEmojis);
		});
	}

	public boolean isGitHubDownloadConfigured()
	{
		String repoIdentifier = this.config.githubRepoUrl();
		return repoIdentifier != null && !repoIdentifier.trim().isEmpty();
	}

	private String formatReloadMessage(int added, int deleted, int soundojis)
	{
		List<String> parts = new ArrayList<>();
		if (added > 0)
		{
			parts.add(String.format("Loaded %d emoji%s", added, added == 1 ? "" : "s"));
		}
		if (deleted > 0)
		{
			parts.add(String.format("Removed %d emoji%s", deleted, deleted == 1 ? "" : "s"));
		}
		if (soundojis > 0)
		{
			parts.add(String.format("(%d soundoji%s)", soundojis, soundojis == 1 ? "" : "s"));
		}

		return parts.isEmpty() ? "Already up to date" : String.join(", ", parts);
	}

	private void toggleButton(boolean show)
	{
		if (show)
		{
			// Create panel lazily after emojis are loaded
			panel = panelProvider.get();
			panel.setProgressSupplier(this.githubDownloader::getCurrentProgress);

			final BufferedImage icon = ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_SMILEY);
			navButton = NavigationButton.builder().tooltip("Custom Emoji").icon(icon).priority(5).panel(panel).build();

			clientToolbar.addNavigation(navButton);
		}
		else
		{
			if (navButton != null)
			{
				clientToolbar.removeNavigation(navButton);
				navButton = null;
			}
			if (panel != null)
			{
				panel.stopProgressPolling();
				panel = null;
			}
		}
	}

	private void showPanelStatus(String message, StatusMessagePanel.MessageType type)
	{
		if (this.panel != null)
		{
			SwingUtilities.invokeLater(() -> this.panel.showStatusMessage(message, type));
		}
	}

	private void showPanelStatus(String message, StatusMessagePanel.MessageType type, boolean autoDismiss)
	{
		if (this.panel != null)
		{
			SwingUtilities.invokeLater(() -> this.panel.showStatusMessage(message, type, autoDismiss));
		}
	}

	private void setupAnimationOverlays()
	{
		this.chatEmojiRenderer.setEmojisSupplier(() -> this.emojis);
		this.chatEmojiRenderer.setAnimationLoader(this.animationManager::getOrLoadAnimation);
		this.chatEmojiRenderer.setMarkVisibleCallback(this.animationManager::markAnimationVisible);
		this.chatEmojiRenderer.setUnloadStaleCallback(this.animationManager::unloadStaleAnimations);
		this.overlayManager.add(this.chatEmojiRenderer);

		this.splitPrivateChatEmojiRenderer.setEmojisSupplier(() -> this.emojis);
		this.splitPrivateChatEmojiRenderer.setAnimationLoader(this.animationManager::getOrLoadAnimation);
		this.splitPrivateChatEmojiRenderer.setMarkVisibleCallback(this.animationManager::markAnimationVisible);
		this.splitPrivateChatEmojiRenderer.setUnloadStaleCallback(this.animationManager::unloadStaleAnimations);
		this.overlayManager.add(this.splitPrivateChatEmojiRenderer);

		this.overheadEmojiRenderer.setEmojisSupplier(() -> this.emojis);
		this.overheadEmojiRenderer.setAnimationLoader(this.animationManager::getOrLoadAnimation);
		this.overheadEmojiRenderer.setMarkVisibleCallback(this.animationManager::markAnimationVisible);
		this.overlayManager.add(this.overheadEmojiRenderer);

		log.debug("Animation overlays set up");
	}

	private void teardownAnimationOverlays()
	{
		this.overlayManager.remove(this.chatEmojiRenderer);
		this.overlayManager.remove(this.splitPrivateChatEmojiRenderer);
		this.overlayManager.remove(this.overheadEmojiRenderer);
		this.animationManager.clearAllAnimations();
		log.debug("Animation overlays torn down");
	}

	private void shutdownDebounceExecutor()
	{
		if (this.pendingReload != null)
		{
			this.pendingReload.cancel(true);
			this.pendingReload = null;
		}

		if (this.debounceExecutor != null)
		{
			this.debounceExecutor.shutdownNow();
			this.debounceExecutor = null;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		this.clientThread.invokeLater(() -> this.newMessageBannerRenderer.onNewMessage());

		if (!this.shouldUpdateChatMessage(chatMessage.getType()))
		{
			return;
		}

		final MessageNode messageNode = chatMessage.getMessageNode();
		final String message = messageNode.getValue();
		final String updatedMessage = this.updateMessage(message, true);
		if (updatedMessage == null)
		{
			return;
		}

		messageNode.setValue(updatedMessage);
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if (!"chatFilterCheck".equals(event.getEventName()))
		{
			return;
		}

		CustomEmojiConfig.DisabledEmojiFilterMode filterMode = this.config.disabledEmojiFilterMode();

		if (filterMode == CustomEmojiConfig.DisabledEmojiFilterMode.OFF)
		{
			return;
		}

		int[] intStack = this.client.getIntStack();
		int intStackSize = this.client.getIntStackSize();
		Object[] objectStack = this.client.getObjectStack();
		int objectStackSize = this.client.getObjectStackSize();

		int messageId = intStack[intStackSize - 1];
		MessageNode messageNode = this.client.getMessages().get(messageId);
		String senderName = Text.toJagexName(Text.removeTags(messageNode.getName()));
		String localPlayerName = this.client.getLocalPlayer().getName();
		boolean isFromLocalPlayer = senderName.equals(localPlayerName);

		if (isFromLocalPlayer)
		{
			return;
		}

		String message = (String) objectStack[objectStackSize - 1];

		boolean requireAll = filterMode == CustomEmojiConfig.DisabledEmojiFilterMode.LENIENT;
		boolean shouldFilter = this.shouldFilterMessage(message, requireAll);

		if (shouldFilter)
		{
			intStack[intStackSize - 3] = 0;
		}
	}

	@Subscribe
	public void onOverheadTextChanged(final OverheadTextChanged event)
	{
		if (!(event.getActor() instanceof Player))
		{
			return;
		}

		final String message = event.getOverheadText();
		final String updatedMessage = this.updateMessage(message, false);

		if (updatedMessage == null)
		{
			return;
		}

		event.getActor().setOverheadText(updatedMessage);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		// Apply chat spacing when chat-related widgets are loaded
		int groupId = event.getGroupId();
		boolean isChatbox = groupId == InterfaceID.Chatbox.SCROLLAREA;
		boolean isPmChat = groupId == InterfaceID.PmChat.CONTAINER;

		if (isChatbox || isPmChat)
		{
			clientThread.invokeLater(chatSpacingManager::applyChatSpacing);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("custom-emote"))
		{
			return;
		}

		switch (event.getKey())
		{
			case CustomEmojiConfig.KEY_DYNAMIC_EMOJI_SPACING:
			case CustomEmojiConfig.KEY_CHAT_MESSAGE_SPACING:
				clientThread.invokeLater(chatSpacingManager::applyChatSpacing);
				break;
			case CustomEmojiConfig.KEY_MAX_IMAGE_HEIGHT:
				scheduleReload(true);
				break;
			case CustomEmojiConfig.KEY_RESIZING_DISABLED_EMOJIS:
				this.clientThread.invokeLater(this.chatSpacingManager::applyChatSpacing);
				// intentional fallthrough
			case CustomEmojiConfig.KEY_ANIMATION_LOADING_MODE:
				this.animationManager.clearAllAnimations();
				break;
			case CustomEmojiConfig.KEY_SHOW_SIDE_PANEL:
				this.toggleButton(this.config.showPanel());
				break;
			case CustomEmojiConfig.KEY_GITHUB_ADDRESS:
				this.triggerGitHubDownloadAndReload();
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event)
	{
		switch (event.getIndex())
		{
			case VarClientID.MESLAYERMODE:
			case VarClientID.CHAT_LASTREBUILD:
				this.chatSpacingManager.clearStoredPositions();
				// intentional fallthrough
			case VarClientID.CHAT_FORCE_CHATBOX_REBUILD: // Triggered when a friend logs in/out
				this.clientThread.invokeAtTickEnd(this.chatSpacingManager::applyChatSpacing);
				break;
			case VarClientID.CHAT_LASTSCROLLPOS:
				this.clientThread.invokeAtTickEnd(this.chatSpacingManager::captureScrollPosition);
				this.newMessageBannerRenderer.onScrollPositionChanged();
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onVarClientStrChanged(VarClientStrChanged event)
	{
		int index = event.getIndex();
		String value = this.client.getVarcStrValue(index);

		if (value.startsWith("!") || value.startsWith("::"))
		{
			return; // Skip command messages
		}

		boolean isNormalChatInput  = index == VarClientID.CHATINPUT;
		boolean isPrivateChatInput = index == VarClientID.MESLAYERINPUT;

		if (isNormalChatInput || isPrivateChatInput)
		{
			this.overlay.updateChatInput(value);
		}
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		this.tooltip.onMenuOpened();
	}

	@Nullable
	String updateMessage(final String message, boolean sound)
	{
		final String[] messageWords = WHITESPACE_REGEXP.split(message);

		boolean editedMessage = false;
		boolean previousWasEmoji = false;

		for (int i = 0; i < messageWords.length; i++)
		{
			// Remove tags except for <lt> and <gt>
			final String trigger = Text.removeFormattingTags(messageWords[i]);

			final Emoji emoji = emojis.get(trigger.toLowerCase());
			final Soundoji soundoji = soundojis.get(trigger.toLowerCase());

			if (emoji != null && this.isEmojiEnabled(emoji.getText()))
			{
				int imageId = this.getImageIdForEmoji(emoji, previousWasEmoji);
				messageWords[i] = messageWords[i].replace(trigger, IMG_TAG_PREFIX + imageId + ">");
				editedMessage = true;
				previousWasEmoji = true;
				log.debug("Replacing {} with emoji {}", trigger, emoji.getText());
			}
			else
			{
				// Check if this word is already an image tag (existing emoji)
				previousWasEmoji = messageWords[i].contains(IMG_TAG_PREFIX);
			}

			if (soundoji != null)
			{
				if (sound)
				{
					try
					{
						this.audioPlayer.play(soundoji.getFile(), volumeToGain(this.config.volume()));
					}
					catch (IOException | UnsupportedAudioFileException | LineUnavailableException e)
					{
						log.error("Failed to play soundoji: " + soundoji.getText(), e);
					}
				}
				messageWords[i] = messageWords[i].replace(trigger, "*" + trigger + "*");
				editedMessage = true;
				log.debug("Playing soundoji {}", trigger);
			}

		}

		// If we haven't edited the message any, don't update it.
		if (!editedMessage)
		{
			return null;
		}

		return String.join(" ", messageWords);
	}

	private int getImageIdForEmoji(Emoji emoji, boolean previousWasEmoji)
	{
		if (emoji.hasZeroWidthId() && previousWasEmoji)
		{
			return this.chatIconManager.chatIconIndex(emoji.getZeroWidthId());
		}
		return this.chatIconManager.chatIconIndex(emoji.getId());
	}

	boolean isEmojiEnabled(String emojiName)
	{
		return this.emojiStateManager.isEmojiEnabled(emojiName);
	}

	public void loadEmojis()
	{
		this.loadEmojisAsync(null);
	}

	private void loadEmojisAsync(Runnable onComplete)
	{
		File emojiFolder = EMOJIS_FOLDER;
		if (emojiFolder.mkdir())
		{
			log.debug("Created emoji folder");
			if (onComplete != null)
			{
				onComplete.run();
			}
			return;
		}

		this.executor.submit(() ->
		{
			Result<List<LoadedEmoji>, List<Throwable>> result = this.prepareEmojisFromFolder(emojiFolder);

			this.clientThread.invokeLater(() ->
			{
				result.ifOk(loadedList ->
				{
					List<Emoji> registered = this.registerLoadedEmojis(loadedList);
					registered.forEach(emoji -> this.emojis.put(emoji.getText(), emoji));
					log.info("Loaded {} emojis", registered.size());
				});

				result.ifError(loadErrors ->
				{
					for (Throwable throwable : loadErrors)
					{
						String message = throwable.getMessage();
						boolean isSkippedFile = message.contains("image format not supported")
							|| message.contains("Illegal file name")
							|| message.contains("file unchanged");
						if (!isSkippedFile)
						{
							log.warn("Failed to load emoji: {}", message);
							this.errors.add(message);
						}
					}
				});

				// Refresh the panel to show updated emoji tree
				if (this.panel != null)
				{
					SwingUtilities.invokeLater(() -> this.panel.refreshEmojiTree());
				}

				if (onComplete != null)
				{
					this.clientThread.invokeLater(() -> this.clientThread.invokeLater(onComplete));
				}
			});
		});
	}

	private void loadSoundojis()
	{
		File soundojiFolder = SOUNDOJIS_FOLDER;
		if (soundojiFolder.mkdir())
		{
			log.error("Created soundoji folder");
		}

		var result = this.loadSoundojisFolder(soundojiFolder);
		result.ifOk(list ->
		{
			list.forEach(e -> this.soundojis.put(e.getText(), e));
			log.info("Loaded {} soundojis", result.unwrap().size());
		});
		result.ifError(e ->
			e.forEach(t ->
			{
				String fileName = extractFileName(t.getMessage());
				log.debug("Skipped non-audio file: {}", fileName);
			})
		);
	}

	private Result<List<Soundoji>, List<Throwable>> loadSoundojisFolder(File soundojiFolder)
	{
		// recursively flattenFolder files in the folder
		List<File> files = flattenFolder(soundojiFolder);

		if (!soundojiFolder.isDirectory())
		{
			return Error(List.of(new IllegalArgumentException("Not a folder " + soundojiFolder)));
		}

		List<Soundoji> loaded = new ArrayList<>();
		List<Throwable> localErrors = new ArrayList<>();

		for (File file : files)
		{
			Result<Soundoji, Throwable> result = loadSoundoji(file);
			result.ifOk(loaded::add);
			result.ifError(localErrors::add);
		}

		if (localErrors.isEmpty())
		{
			return Ok(loaded);
		}
		else
		{
			return PartialOk(loaded, localErrors);
		}
	}

	private Result<List<LoadedEmoji>, List<Throwable>> prepareEmojisFromFolder(File folder)
	{
		List<File> files = flattenFolder(folder);

		if (!folder.isDirectory())
		{
			return Error(List.of(new IllegalArgumentException("Not a folder " + folder)));
		}

		List<LoadedEmoji> prepared = new ArrayList<>();
		List<Throwable> prepareErrors = new ArrayList<>();

		for (File file : files)
		{
			Result<LoadedEmoji, Throwable> result = this.prepareEmoji(file);
			result.ifOk(prepared::add);
			result.ifError(prepareErrors::add);
		}

		if (prepareErrors.isEmpty())
		{
			return Ok(prepared);
		}
		else
		{
			return PartialOk(prepared, prepareErrors);
		}
	}

	private Result<LoadedEmoji, Throwable> prepareEmoji(File file)
	{
		int extension = file.getName().lastIndexOf('.');

		if (extension < 0)
		{
			return Error(new IllegalArgumentException("Illegal file name <col=00FFFF>" + file));
		}

		String name = file.getName().substring(0, extension).toLowerCase();
		long fileModified = file.lastModified();

		Emoji existingEmoji = this.emojis.get(name);

		if (existingEmoji != null && existingEmoji.getLastModified() == fileModified)
		{
			return Error(new IllegalArgumentException("Emoji file unchanged: " + name));
		}

		// Local emoji priority: if a local emoji exists and the new file is from github-pack, skip it
		if (existingEmoji != null)
		{
			boolean existingIsLocal = !existingEmoji.getFile().getPath().contains("github-pack");
			boolean newIsGithub = file.getPath().contains("github-pack");
			if (existingIsLocal && newIsGithub)
			{
				return Error(new IllegalArgumentException("Skipped - local emoji takes priority: " + name));
			}
		}

		Result<BufferedImage, Throwable> imageResult = loadImage(file);

		if (!imageResult.isOk())
		{
			Throwable throwable = imageResult.unwrapError();
			return Error(new RuntimeException(
				"<col=FF0000>" + file.getName() + "</col> failed because <col=FF0000>" + throwable.getMessage(),
				throwable));
		}

		try
		{
			boolean shouldResize = this.shouldResizeEmoji(name);
			BufferedImage normalizedImage = shouldResize ? PluginUtils.resizeImage(imageResult.unwrap(), this.config.maxImageHeight()) : imageResult.unwrap();
			boolean isAnimated = PluginUtils.isAnimatedGif(file);
			Integer existingId = existingEmoji != null ? existingEmoji.getId() : null;

			return Ok(new LoadedEmoji(name, file, fileModified, normalizedImage, existingId, isAnimated));
		}
		catch (RuntimeException e)
		{
			return Error(new RuntimeException(
				"<col=FF0000>" + file.getName() + "</col> failed because <col=FF0000>" + e.getMessage(),
				e));
		}
	}

	private List<Emoji> registerLoadedEmojis(List<LoadedEmoji> loadedEmojis)
	{
		List<Emoji> registered = new ArrayList<>();

		for (LoadedEmoji loaded : loadedEmojis)
		{
			Emoji emoji = this.registerLoadedEmoji(loaded);
			registered.add(emoji);
		}

		return registered;
	}

	private Emoji registerLoadedEmoji(LoadedEmoji loaded)
	{
		int width = loaded.getImage().getWidth();
		int height = loaded.getImage().getHeight();
		Dimension dim = new Dimension(width, height);
		String name = loaded.getName();
		File file = loaded.getFile();
		long lastModified = loaded.getLastModified();
		Integer existingId = loaded.getExistingId();

		BufferedImage staticImage = loaded.getImage();
		BufferedImage placeholderImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

		int iconId;
		if (existingId != null)
		{
			iconId = existingId;
			this.chatIconManager.updateChatIcon(iconId, placeholderImage);
			log.info("Updated existing chat icon for emoji: {} (id: {})", name, iconId);
		}
		else
		{
			iconId = this.chatIconManager.registerChatIcon(placeholderImage);
			log.info("Registered new chat icon for emoji: {} (id: {})", name, iconId);
		}

		int zeroWidthId = -1;
		boolean isZeroWidth = name.endsWith("00");
		if (isZeroWidth)
		{
			BufferedImage zeroWidthPlaceholder = new BufferedImage(1, height, BufferedImage.TYPE_INT_ARGB);
			zeroWidthId = this.chatIconManager.registerChatIcon(zeroWidthPlaceholder);
			log.info("Registered zero-width placeholder for emoji: {} (zeroWidthId: {})", name, zeroWidthId);
		}

		if (loaded.isAnimated())
		{
			return new AnimatedEmoji(iconId, zeroWidthId, -1, -1, name, file, lastModified, dim, staticImage);
		}

		return new StaticEmoji(iconId, zeroWidthId, -1, -1, name, file, lastModified, dim, staticImage);
	}

	private Result<Soundoji, Throwable> loadSoundoji(File file)
	{
		int extension = file.getName().lastIndexOf('.');

		if (extension < 0)
		{
			return Error(new IllegalArgumentException("Illegal file name " + file));
		}

		String text = file.getName().substring(0, extension).toLowerCase();
		return Ok(new Soundoji(text, file));

	}


	private List<File> flattenFolder(@NonNull File folder)
	{
		return flattenFolder(folder, 0);
	}

	private List<File> flattenFolder(@NonNull File folder, int depth)
	{
		// sanity guard
		final long MAX_DEPTH = 8;

		if (depth > MAX_DEPTH)
		{
			log.warn("Max depth of {} was reached path:{}", depth, folder);
			return List.of();
		}

		// file found
		if (!folder.isDirectory())
		{
			return List.of(folder);
		}

		// no childs
		File[] childs = folder.listFiles();
		if (childs == null)
		{
			return List.of();
		}

		List<File> flattened = new ArrayList<>();
		for (File child : childs)
		{
			flattened.addAll(flattenFolder(child, depth + 1));
		}

		return flattened;
	}

	public void forceReloadChangedEmojis(List<String> emojiNames)
	{
		if (emojiNames == null || emojiNames.isEmpty())
		{
			return;
		}

		for (String emojiName : emojiNames)
		{
			this.emojis.remove(emojiName);
			log.debug("Removed emoji '{}' from cache to force reload", emojiName);
		}

		this.scheduleReload(false, false);
	}

	public void reloadSingleEmoji(String emojiName)
	{
		this.reloadSingleEmoji(emojiName, null);
	}

	public void reloadSingleEmoji(String emojiName, Runnable onComplete)
	{
		Emoji emoji = this.emojis.get(emojiName);
		if (emoji == null)
		{
			log.warn("Cannot reload emoji '{}' - not found", emojiName);
			if (onComplete != null)
			{
				onComplete.run();
			}
			return;
		}

		File file = emoji.getFile();

		this.executor.submit(() ->
		{
			Result<BufferedImage, Throwable> imageResult = loadImage(file);

			if (!imageResult.isOk())
			{
				log.error("Failed to load image for emoji '{}'", emojiName, imageResult.unwrapError());
				if (onComplete != null)
				{
					this.clientThread.invokeLater(onComplete);
				}
				return;
			}

			try
			{
				boolean shouldResize = this.shouldResizeEmoji(emojiName);
				BufferedImage normalizedImage = shouldResize ? PluginUtils.resizeImage(imageResult.unwrap(), this.config.maxImageHeight()) : imageResult.unwrap();
				long fileModified = file.lastModified();
				boolean isAnimated = PluginUtils.isAnimatedGif(file);
				LoadedEmoji loaded = new LoadedEmoji(emojiName, file, fileModified, normalizedImage, emoji.getId(), isAnimated);

				this.clientThread.invokeLater(() ->
				{
					Emoji updatedEmoji = this.registerLoadedEmoji(loaded);
					updatedEmoji.setImageId(emoji.getImageId());
					updatedEmoji.setZeroWidthImageId(emoji.getZeroWidthImageId());
					this.emojis.put(emojiName, updatedEmoji);
					log.info("Reloaded emoji '{}' with resizing={}", emojiName, shouldResize);

					if (onComplete != null)
					{
						onComplete.run();
					}
				});
			}
			catch (RuntimeException e)
			{
				log.error("Failed to reload emoji '{}'", emojiName, e);
				if (onComplete != null)
				{
					this.clientThread.invokeLater(onComplete);
				}
			}
		});
	}

	/**
	 * Determines if a specific emoji should be resized based on per-emoji settings.
	 * Returns true if the emoji is NOT in the resizing disabled list.
	 */
	private boolean shouldResizeEmoji(String emojiName)
	{
		return this.emojiStateManager.isResizingEnabled(emojiName);
	}

	private void replaceEnabledEmojiInChat(String emojiName)
	{
		this.replaceEmojiInChat(emojiName, true);
	}

	private void replaceDisabledEmojiInChat(String emojiName)
	{
		this.replaceEmojiInChat(emojiName, false);
	}

	private void replaceEmojiInChat(String emojiName, boolean showAsImage)
	{
		Emoji emoji = this.emojis.get(emojiName);
		if (emoji == null)
		{
			return;
		}

		this.waitForRegistration(emoji, () ->
		{
			this.populateImageId(emoji);
			this.processAllChatMessages(value ->
			{
				if (showAsImage)
				{
					String updated = this.updateMessage(value, false);
					return updated != null ? updated : value;
				}
				return this.replaceEmojiTagsWithText(value, emoji, emojiName);
			});
		});
	}

	private void replaceAllEmojisWithText()
	{
		this.processAllChatMessages(value ->
		{
			String updated = value;
			for (Emoji emoji : this.emojis.values())
			{
				String emojiText = emoji.getText();
				boolean hasValidText = emojiText != null && !emojiText.isEmpty();
				String replacement = hasValidText ? emojiText : UNKNOWN_EMOJI_PLACEHOLDER;
				updated = this.replaceEmojiTagsWithText(updated, emoji, replacement);
			}
			return updated;
		});
	}

	private String replaceEmojiTagsWithText(String message, Emoji emoji, String replacement)
	{
		int imageId = this.chatIconManager.chatIconIndex(emoji.getId());
		String imageTag = IMG_TAG_PREFIX + imageId + ">";

		String updated = message.replace(imageTag, replacement);

		if (emoji.hasZeroWidthId())
		{
			int zeroWidthId = this.chatIconManager.chatIconIndex(emoji.getZeroWidthId());
			String zeroWidthTag = IMG_TAG_PREFIX + zeroWidthId + ">";
			updated = updated.replace(zeroWidthTag, replacement);
		}

		return updated;
	}

	private void replaceAllTextWithEmojis()
	{
		List<Emoji> enabledEmojis = this.emojis.values().stream()
			.filter(emoji -> this.emojiStateManager.isEmojiEnabled(emoji.getText()))
			.collect(Collectors.toList());

		this.waitForRegistration(enabledEmojis, () ->
		{
			this.populateImageIds(enabledEmojis);
			this.processAllChatMessages(message ->
			{
				String updated = this.updateMessage(message, false);
				return updated != null ? updated : message;
			});
		});
	}

	private void processAllChatMessages(UnaryOperator<String> transformer)
	{
		log.debug("Processing all chat messages...");
		IterableHashTable<MessageNode> messages = this.client.getMessages();
		for (MessageNode messageNode : messages)
		{
			ChatMessageType type = messageNode.getType();
			String value = messageNode.getValue();

			boolean shouldProcess = shouldUpdateChatMessage(type) && value != null;
			if (shouldProcess)
			{
				String updatedValue = transformer.apply(value);
				if (!updatedValue.equals(value))
				{
					messageNode.setValue(updatedValue);
				}
			}
		}
		this.client.refreshChat();
	}

	private void waitForRegistration(Emoji emoji, Runnable onRegistered)
	{
		this.waitForRegistration(List.of(emoji), onRegistered, 0);
	}

	private void waitForRegistration(Collection<Emoji> emojis, Runnable onRegistered)
	{
		this.waitForRegistration(emojis, onRegistered, 0);
	}

	private void waitForRegistration(Collection<Emoji> emojis, Runnable onRegistered, int retryCount)
	{
		boolean allRegistered = emojis.stream()
			.allMatch(emoji -> this.chatIconManager.chatIconIndex(emoji.getId()) >= 0);

		if (allRegistered)
		{
			onRegistered.run();
			return;
		}

		if (retryCount >= MAX_REGISTRATION_RETRIES)
		{
			log.warn("Max retries reached waiting for {} emoji(s) registration", emojis.size());
			return;
		}

		this.clientThread.invokeLater(() -> this.waitForRegistration(emojis, onRegistered, retryCount + 1));
	}

	private void populateImageIds(Collection<Emoji> emojis)
	{
		for (Emoji emoji : emojis)
		{
			this.populateImageId(emoji);
		}
	}

	private void populateImageId(Emoji emoji)
	{
		int imageId = this.chatIconManager.chatIconIndex(emoji.getId());
		emoji.setImageId(imageId);

		if (emoji.hasZeroWidthId())
		{
			int zeroWidthImageId = this.chatIconManager.chatIconIndex(emoji.getZeroWidthId());
			emoji.setZeroWidthImageId(zeroWidthImageId);
		}
	}

	private void handleEmojiResizingToggled(String emojiName)
	{
		Emoji emoji = this.emojis.get(emojiName);
		if (emoji instanceof AnimatedEmoji)
		{
			this.animationManager.invalidateAnimation(emoji.getId());
		}

		this.reloadSingleEmoji(emojiName, this.chatSpacingManager::applyChatSpacing);
	}

	public static Result<BufferedImage, Throwable> loadImage(final File file)
	{
		String fileName = file.getName().toLowerCase();
		boolean isSupportedFormat = fileName.endsWith(".png") ||
									fileName.endsWith(".jpg") ||
									fileName.endsWith(".jpeg") ||
									fileName.endsWith(".gif");

		if (!isSupportedFormat)
		{
			return Error(new IOException("image format not supported. (PNG,JPG,GIF only)"));
		}

		try (ImageInputStream imageStream = ImageIO.createImageInputStream(file))
		{
			if (imageStream != null)
			{
				Iterator<ImageReader> readers = ImageIO.getImageReaders(imageStream);
				while (readers.hasNext())
				{
					ImageReader reader = readers.next();
					try
					{
						reader.setInput(imageStream);
						BufferedImage image = reader.read(0);
						if (image != null)
						{
							return Ok(image);
						}
					}
					finally
					{
						reader.dispose();
					}
				}
			}
		}
		catch (IOException e)
		{
			// Primary method failed, do InputStream fallback
		}

		try (InputStream in = new FileInputStream(file))
		{
			synchronized (ImageIO.class)
			{
				BufferedImage read = ImageIO.read(in);
				if (read != null)
				{
					return Ok(read);
				}
			}
		}
		catch (IllegalArgumentException | IOException e)
		{
			return Error(e);
		}

		return Error(new IOException("failed to read image"));
	}

	private static String extractFileName(String errorMessage)
	{
		// Extract just the filename from error messages like:
		// "<col=FF0000>filename.ext</col> failed because..."
		// or "Illegal file name <col=00FFFF>C:\full\path\filename"
		if (errorMessage.contains("<col="))
		{
			int start = errorMessage.indexOf(">");
			int end = errorMessage.indexOf("</col>");
			if (start != -1 && end != -1 && start < end)
			{
				String fullPath = errorMessage.substring(start + 1, end);
				// Extract just the filename from full path
				return fullPath.substring(fullPath.lastIndexOf(File.separator) + 1);
			}
		}

		// Fallback: try to extract filename from full path
		if (errorMessage.contains(File.separator))
		{
			String[] parts = errorMessage.split("[" + Pattern.quote(File.separator) + "]");
			if (parts.length > 0)
			{
				return parts[parts.length - 1];
			}
		}

		return errorMessage;
	}

	public static float volumeToGain(int volume100)
	{
		// range[NOISE_FLOOR, 0]
		float gainDB;

		// Graph of the function
		// https://www.desmos.com/calculator/wdhsfbxgeo

		// clamp to 0-100
		float volume = Math.min(100, volume100);
		// convert linear volume 0-100 to log control
		if (volume <= 0.1)
		{
			gainDB = NOISE_FLOOR;
		}
		else
		{
			gainDB = (float) (10 * (Math.log(volume / 100)));
		}

		return gainDB;
	}

	private void reloadEmojis(boolean force, boolean showStatus)
	{
		log.info("Reloading emojis and soundojis due to file changes");

		// Replace all emoji images with text on the client thread, then continue reload
		this.clientThread.invokeLater(() ->
		{
			this.replaceAllEmojisWithText();
			this.continueReloadAfterTextReplacement(force, showStatus);
		});
	}

	private void continueReloadAfterTextReplacement(boolean force, boolean showStatus)
	{
		// Store current emoji names for deletion detection
		Set<String> currentEmojiNames = new HashSet<>(this.emojis.keySet());

		if (force)
		{
			this.emojis.clear();
		}

		this.soundojis.clear();
		this.errors.clear();

		File emojiFolder = EMOJIS_FOLDER;
		if (!emojiFolder.exists())
		{
			log.warn("Emoji folder does not exist: {}", emojiFolder);
			this.emojis.clear();
			this.loadSoundojis();
			return;
		}

		// Run heavy I/O work on background thread
		this.executor.submit(() ->
		{
			Result<List<LoadedEmoji>, List<Throwable>> result = this.prepareEmojisFromFolder(emojiFolder);

			// Register with ChatIconManager on client thread
			this.clientThread.invokeLater(() ->
			{
				Set<String> newEmojiNames = new HashSet<>();

				int[] addedCount = {0};

				result.ifOk(loadedList ->
				{
					List<Emoji> registered = this.registerLoadedEmojis(loadedList);
					registered.forEach(emoji ->
					{
						this.emojis.put(emoji.getText(), emoji);
						newEmojiNames.add(emoji.getText());
					});
					addedCount[0] = registered.size();
					log.info("Loaded {} emojis", registered.size());
				});

				result.ifError(loadErrors ->
				{
					for (Throwable throwable : loadErrors)
					{
						String message = throwable.getMessage();

						// Track unchanged emojis to prevent deletion
						if (message.contains("file unchanged"))
						{
							int colonIndex = message.lastIndexOf(": ");
							if (colonIndex != -1)
							{
								String name = message.substring(colonIndex + 2);
								newEmojiNames.add(name);
							}
							continue;
						}

						boolean isSkippedFile = message.contains("image format not supported")
							|| message.contains("Illegal file name");
						if (!isSkippedFile)
						{
							log.warn("Failed to load emoji: {}", message);
							this.errors.add(message);
						}
					}
				});

				// Remove deleted emojis from our map
				currentEmojiNames.removeAll(newEmojiNames);
				currentEmojiNames.forEach(deletedEmoji ->
				{
					log.debug("Removing deleted emoji: {}", deletedEmoji);
					this.emojis.remove(deletedEmoji);
				});

				this.loadSoundojis();

				int deletedCount = currentEmojiNames.size();
				if (showStatus)
				{
					String statusMessage = this.formatReloadMessage(addedCount[0], deletedCount, this.soundojis.size());
					this.showPanelStatus(statusMessage, StatusMessagePanel.MessageType.SUCCESS);
				}

				// Refresh the panel to show updated emoji tree
				if (this.panel != null)
				{
					SwingUtilities.invokeLater(() -> this.panel.refreshEmojiTree());
				}

				this.clientThread.invokeLater(this::replaceAllTextWithEmojis);
			});
		});
	}

	public void scheduleReload(boolean force)
	{
		this.scheduleReload(force, true);
	}

	public void scheduleReload(boolean force, boolean showStatus)
	{
		synchronized (this)
		{
			// Don't schedule reload if debounceExecutor is null or shutdown (during shutdown)
			if (this.debounceExecutor == null || this.debounceExecutor.isShutdown())
			{
				log.debug("Skipping reload schedule - executor is shutdown");
				return;
			}

			// Cancel any pending reload
			if (pendingReload != null && !pendingReload.isDone())
			{
				pendingReload.cancel(false);
				log.debug("Cancelled pending emoji reload due to new file changes");
			}

			// Schedule new reload with debounce delay
			pendingReload = debounceExecutor.schedule(() -> this.reloadEmojis(force, showStatus), 500, TimeUnit.MILLISECONDS);

			log.debug("Scheduled emoji reload with 500ms debounce");
		}
	}

	private boolean shouldUpdateChatMessage(ChatMessageType type)
	{
		if (this.githubDownloader.isDownloading.get())
		{
			return false;
		}

		switch (type)
		{
			case PRIVATECHAT:
			case PRIVATECHATOUT:
			case MODPRIVATECHAT:
				return this.config.splitPrivateChat();
			case PUBLICCHAT:
			case MODCHAT:
			case FRIENDSCHAT:
			case CLAN_CHAT:
			case CLAN_GUEST_CHAT:
			case CLAN_GIM_CHAT:
				return true;
			default:
				return false;
		}
	}

	private boolean shouldFilterMessage(String message, boolean requireAll)
	{
		String[] messageWords = WHITESPACE_REGEXP.split(message);
		int disabledCount = 0;
		int wordCount = 0;

		for (String word : messageWords)
		{
			String trigger = Text.removeFormattingTags(word).replaceAll("(^\\p{Punct}+)|(\\p{Punct}+$)", "").toLowerCase();
			boolean shouldSkip = trigger.isEmpty() || trigger.endsWith("00");

			if (shouldSkip)
			{
				continue;
			}

			wordCount++;
			Emoji emoji = this.emojis.get(trigger);
			boolean isDisabled = emoji != null && !this.isEmojiEnabled(emoji.getText());

			if (isDisabled)
			{
				disabledCount++;
				if (!requireAll)
				{
					return true;
				}
			}
			else if (requireAll)
			{
				return false;
			}
		}

		return requireAll && disabledCount > 0 && disabledCount == wordCount;
	}

	@Provides
	CustomEmojiConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CustomEmojiConfig.class);
	}

	@Provides
	Map<String, Emoji> provideEmojis()
	{
		return this.emojis;
	}

	public void openConfiguration()
	{
		// We don't have access to the ConfigPlugin so let's just emulate an overlay click
		this.eventBus.post(new OverlayMenuClicked(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, null, null), this.overlay));
	}
}

package com.customemoji.model;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class StaticEmoji implements Emoji
{
	private final int id;
	private final int zeroWidthId;
	private int imageId;
	private int zeroWidthImageId;
	private final String text;
	private final File file;
	private final long lastModified;
	private final Dimension dimension;
	private final BufferedImage staticImage;
}

package com.customemoji.model;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class AnimatedEmoji implements Emoji
{
	private final int id;
	private final int zeroWidthId;
	private int imageId;
	private int zeroWidthImageId;
	private final String text;
	private final File file;
	private final long lastModified;
	private final Dimension dimension;
	private final BufferedImage staticImage;
}

package com.customemoji.model;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.File;

public interface Emoji
{
	int getId();

	int getZeroWidthId();

	default boolean hasZeroWidthId()
	{
		return this.getZeroWidthId() >= 0;
	}

	int getImageId();

	void setImageId(int imageId);

	int getZeroWidthImageId();

	void setZeroWidthImageId(int zeroWidthImageId);

	String getText();

	File getFile();

	long getLastModified();

	Dimension getDimension();

	BufferedImage getStaticImage();
}
package com.customemoji.model;

import java.io.File;

import lombok.Value;

@Value
public class Soundoji
{
	String text;
	File file;
}
package com.customemoji;

import java.awt.Rectangle;

/**
 * Represents the calculated position and bounds of an emoji within a chat widget.
 */
public class EmojiPosition
{
    private final int imageId;
    private final Rectangle bounds;
    private final int lineNumber;
    private Rectangle baseEmojiBounds;

    public EmojiPosition(int imageId, Rectangle bounds, int lineNumber)
    {
        this.imageId = imageId;
        this.bounds = bounds;
        this.lineNumber = lineNumber;
        this.baseEmojiBounds = null;
    }

    public int getImageId()
    {
        return this.imageId;
    }

    public Rectangle getBounds()
    {
        return this.bounds;
    }

    public int getX()
    {
        return this.bounds.x;
    }

    public int getY()
    {
        return this.bounds.y;
    }

    public int getWidth()
    {
        return this.bounds.width;
    }

    public int getHeight()
    {
        return this.bounds.height;
    }

    public boolean containsPoint(int x, int y)
    {
        return this.bounds.contains(x, y);
    }

    public int getLineNumber()
    {
        return this.lineNumber;
    }

    public Rectangle getBaseEmojiBounds()
    {
        return this.baseEmojiBounds;
    }

    public void setBaseEmojiBounds(Rectangle baseEmojiBounds)
    {
        this.baseEmojiBounds = baseEmojiBounds;
    }

    public boolean hasBaseEmojiBounds()
    {
        return this.baseEmojiBounds != null;
    }
}
package com.customemoji.renderer;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.EmojiPosition;
import com.customemoji.EmojiPositionCalculator;
import com.customemoji.PluginUtils;
import com.customemoji.model.Emoji;

import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayLayer;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Singleton
public class OverheadEmojiRenderer extends EmojiRendererBase
{
	@Inject
	public OverheadEmojiRenderer(Client client, CustomEmojiConfig config)
	{
		super(client, config);
		this.setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (this.emojisSupplier == null)
		{
			return null;
		}

		if (this.client.getTopLevelWorldView() == null)
		{
			return null;
		}

		List<Player> players = this.client.getTopLevelWorldView().players().stream().collect(Collectors.toList());
		if (players.isEmpty())
		{
			return null;
		}

		Map<Integer, Emoji> emojiLookup = PluginUtils.buildEmojiLookup(this.emojisSupplier);
		Set<Integer> visibleEmojiIds = new HashSet<>();

		for (Player player : players)
		{
			if (!this.shouldShowOverheadForPlayer(player))
			{
				continue;
			}

			this.renderPlayerOverhead(graphics, player, visibleEmojiIds, emojiLookup);
		}

		this.cleanupStaleEmojis(visibleEmojiIds);

		return null;
	}

	private void renderPlayerOverhead(Graphics2D graphics, Player player, Set<Integer> visibleEmojiIds, Map<Integer, Emoji> emojiLookup)
	{
		if (player == null)
		{
			return;
		}

		String overheadText = player.getOverheadText();
		if (overheadText == null || overheadText.isEmpty())
		{
			return;
		}

		Point centerPoint = player.getCanvasTextLocation(graphics, "", player.getLogicalHeight());
		if (centerPoint == null)
		{
			return;
		}

		int centerX = centerPoint.getX();
		int baseY = centerPoint.getY();

		IndexedSprite[] modIcons = this.client.getModIcons();
		EmojiPositionCalculator.DimensionLookup dimensionLookup = imageId -> PluginUtils.getEmojiDimension(modIcons, imageId);

		List<EmojiPosition> positions = EmojiPositionCalculator.calculateOverheadEmojiPositions(graphics, overheadText, centerX, baseY, dimensionLookup);

		PluginUtils.linkZeroWidthEmojisToTarget(positions, emojiLookup);

		for (EmojiPosition position : positions)
		{
			Emoji emoji = emojiLookup.get(position.getImageId());
			if (emoji != null)
			{
				this.renderEmoji(graphics, emoji, position, visibleEmojiIds);
			}
		}
	}

	private void renderEmoji(Graphics2D graphics, Emoji emoji, EmojiPosition position, Set<Integer> visibleEmojiIds)
	{
		if (this.isEmojiDisabled(emoji))
		{
			return;
		}

		int emojiId = emoji.getId();
		BufferedImage image = this.resolveEmojiImage(emoji, emojiId, visibleEmojiIds);
		this.drawEmojiImage(graphics, image, position);
	}

	private boolean shouldShowOverheadForPlayer(Player player)
	{
		boolean isLocalPlayer = player == this.client.getLocalPlayer();

		if (isLocalPlayer)
		{
			return true;
		}

		Widget publicChatFilterWidget = this.client.getWidget(InterfaceID.Chatbox.CHAT_PUBLIC_FILTER);
		if (publicChatFilterWidget == null)
		{
			return true;
		}

		String filterText = publicChatFilterWidget.getText();
		if (filterText == null)
		{
			return true;
		}

		boolean isOn = filterText.contains("On");
		boolean isHide = filterText.contains("Hide");
		boolean isFriends = filterText.contains("Friends");
		boolean isOff = filterText.contains("Off");
		boolean isAutochat = filterText.contains("Autochat");

		if (isOn || isHide)
		{
			return true;
		}

		if (isOff || isAutochat)
		{
			return false;
		}

		if (isFriends)
		{
			String playerName = player.getName();
			if (playerName == null)
			{
				return false;
			}

			boolean isFriend = this.client.isFriended(playerName, false);
			return isFriend;
		}

		return true;
	}
}

package com.customemoji.renderer;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.PluginUtils;
import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.MouseAdapter;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.awt.event.MouseEvent;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;

@Slf4j
@Singleton
public class NewMessageBannerRenderer extends Overlay
{
	// Banner mode constants
	private static final int BAR_HEIGHT = 16;
	private static final Color BAR_COLOR = new Color(0, 0, 0, 128);
	private static final Color BAR_HOVER_COLOR = new Color(0, 0, 0, 180);
	private static final Color TEXT_COLOR = Color.WHITE;
	private static final String MESSAGE_TEXT = "New Messages Below";

	// Arrow mode constants
	private static final int CIRCLE_DIAMETER = 21;
	private static final int CIRCLE_MARGIN = 4;
	private static final Color CIRCLE_COLOR = new Color(0, 0, 0, 160);
	private static final Color CIRCLE_HOVER_COLOR = new Color(0, 0, 0, 200);
	private static final Color ARROW_COLOR = Color.WHITE;

	private final Client client;
	private final ClientThread clientThread;
	private final EventBus eventBus;
	private final CustomEmojiConfig config;
	private final MouseManager mouseManager;

	private boolean hasNewMessageWhileScrolledUp = false;
	private Rectangle indicatorBounds = null;
	private int scrolledUpPixels = 0;
	private volatile boolean chatboxIsClickThrough = false;
	private volatile boolean chatboxIsTransparent = false;
	private boolean consumeNextClick = false;

	private final MouseAdapter mouseListener = new MouseAdapter()
	{
		@Override
		public MouseEvent mousePressed(MouseEvent event)
		{
			if (isMouseOverIndicator())
			{
				consumeNextClick = true;
				event.consume();
			}
			return event;
		}

		@Override
		public MouseEvent mouseReleased(MouseEvent event)
		{
			if (consumeNextClick)
			{
				consumeNextClick = false;
				scrollToBottom();
				event.consume();
			}
			return event;
		}
	};

	@Inject
	public NewMessageBannerRenderer(Client client, ClientThread clientThread, EventBus eventBus, CustomEmojiConfig config, MouseManager mouseManager)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.eventBus = eventBus;
		this.config = config;
		this.mouseManager = mouseManager;

		this.setPosition(OverlayPosition.DYNAMIC);
		this.setLayer(OverlayLayer.MANUAL);
		this.setPriority(0.6f);
		int interfaceID = WidgetUtil.componentToInterface(InterfaceID.Chatbox.CHATDISPLAY);
		this.drawAfterInterface(interfaceID);
	}

	public void startUp()
	{
		this.eventBus.register(this);
		this.mouseManager.registerMouseListener(this.mouseListener);
		this.clientThread.invokeLater(() ->
		{
			this.chatboxIsClickThrough = this.client.getVarbitValue(VarbitID.TRANSPARENT_CHATBOX_BLOCKCLICK) == 0;
			this.chatboxIsTransparent = this.client.getVarbitValue(VarbitID.CHATBOX_TRANSPARENCY) == 1;

			this.captureScrollPosition();
		});
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.mouseManager.unregisterMouseListener(this.mouseListener);
		this.resetIndicator();
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		switch (event.getVarbitId()) {
			case VarbitID.TRANSPARENT_CHATBOX_BLOCKCLICK:
				this.chatboxIsClickThrough = event.getValue() == 0;
				break;
			case VarbitID.CHATBOX_TRANSPARENCY:
				this.chatboxIsTransparent = event.getValue() == 1;
			default:
				break;
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		CustomEmojiConfig.NewMessageIndicatorMode mode = this.config.newMessageIndicatorMode();

		if (mode == CustomEmojiConfig.NewMessageIndicatorMode.OFF)
		{
			return null;
		}

		Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);

		if (chatbox == null || chatbox.isHidden())
		{
			this.indicatorBounds = null;
			return null;
		}

		if (this.scrolledUpPixels <= 0)
		{
			this.indicatorBounds = null;
			return null;
		}

		Rectangle bounds = chatbox.getBounds();
		if (bounds == null)
		{
			this.indicatorBounds = null;
			return null;
		}

		boolean shouldShow = this.hasNewMessageWhileScrolledUp && this.scrolledUpPixels > 0;

		if (!shouldShow)
		{
			this.indicatorBounds = null;
			return null;
		}

		this.setPreferredLocation(new Point(bounds.x, bounds.y));

		Shape originalClip = graphics.getClip();
		graphics.setClip(new Rectangle(0, 0, bounds.width, bounds.height));

		boolean isClickable = !(this.chatboxIsClickThrough && this.chatboxIsTransparent);

		Dimension result;
		if (mode == CustomEmojiConfig.NewMessageIndicatorMode.ARROW)
		{
			result = this.renderArrowIndicator(graphics, bounds, isClickable);
		}
		else
		{
			result = this.renderBannerIndicator(graphics, bounds, isClickable);
		}

		graphics.setClip(originalClip);
		return result;
	}

	private Dimension renderBannerIndicator(Graphics2D graphics, Rectangle bounds, boolean isClickable)
	{
		int drawX = 0;
		int drawY = bounds.height - BAR_HEIGHT;

		this.indicatorBounds = new Rectangle(bounds.x, bounds.y + drawY, bounds.width, BAR_HEIGHT);

		boolean isHovering = this.handleMouseInput(isClickable);

		Rectangle drawRect = new Rectangle(drawX, drawY, bounds.width, BAR_HEIGHT);
		Color barColor = isHovering ? BAR_HOVER_COLOR : BAR_COLOR;
		graphics.setColor(barColor);
		graphics.fill(drawRect);

		graphics.setColor(TEXT_COLOR);
		Font font = FontManager.getRunescapeSmallFont();

		if (font == null)
		{
			return null;
		}

		graphics.setFont(font);

		FontMetrics fontMetrics = graphics.getFontMetrics();
		int textWidth = fontMetrics.stringWidth(MESSAGE_TEXT);

		int textX = drawX + (bounds.width - textWidth) / 2;
		int textY = drawY + (BAR_HEIGHT + fontMetrics.getAscent() - fontMetrics.getDescent()) / 2;

		graphics.drawString(MESSAGE_TEXT, textX, textY);

		return new Dimension(bounds.width, BAR_HEIGHT);
	}

	private Dimension renderArrowIndicator(Graphics2D graphics, Rectangle bounds, boolean isClickable)
	{
		int circleX = bounds.width - CIRCLE_DIAMETER - CIRCLE_MARGIN;
		int circleY = bounds.height - CIRCLE_DIAMETER - CIRCLE_MARGIN;

		this.indicatorBounds = new Rectangle(
			bounds.x + circleX,
			bounds.y + circleY,
			CIRCLE_DIAMETER,
			CIRCLE_DIAMETER
		);

		boolean isHovering = this.handleMouseInput(isClickable);

		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		Ellipse2D circle = new Ellipse2D.Double(circleX, circleY, CIRCLE_DIAMETER, CIRCLE_DIAMETER);
		Color circleColor = isHovering ? CIRCLE_HOVER_COLOR : CIRCLE_COLOR;
		graphics.setColor(circleColor);
		graphics.fill(circle);

		// Draw down arrow
		graphics.setColor(ARROW_COLOR);
		graphics.setStroke(new BasicStroke(2f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));

		double centerX = circleX + CIRCLE_DIAMETER / 2.0;
		double centerY = circleY + CIRCLE_DIAMETER / 2.0;
		int arrowSize = 5;

		// Vertical line
		double lineTop = centerY - arrowSize;
		double lineBottom = centerY + arrowSize - 1;
		java.awt.geom.Line2D verticalLine = new java.awt.geom.Line2D.Double(centerX, lineTop, centerX, lineBottom);
		graphics.draw(verticalLine);

		// Arrow head
		java.awt.geom.Line2D leftHead = new java.awt.geom.Line2D.Double(centerX - arrowSize, centerY, centerX, lineBottom);
		java.awt.geom.Line2D rightHead = new java.awt.geom.Line2D.Double(centerX + arrowSize, centerY, centerX, lineBottom);
		graphics.draw(leftHead);
		graphics.draw(rightHead);

		return new Dimension(CIRCLE_DIAMETER, CIRCLE_DIAMETER);
	}

	private boolean handleMouseInput(boolean isClickable)
	{
		if (this.indicatorBounds == null || !isClickable)
		{
			return false;
		}

		net.runelite.api.Point mousePos = this.client.getMouseCanvasPosition();
		boolean isOverIndicator = this.indicatorBounds.contains(mousePos.getX(), mousePos.getY());

		Cursor cursor = isOverIndicator ? Cursor.getPredefinedCursor(Cursor.HAND_CURSOR) : Cursor.getDefaultCursor();
		this.client.getCanvas().setCursor(cursor);

		return isOverIndicator;
	}

	public void onNewMessage()
	{
		log.info("onNewMessage called, scrolledUpPixels={}", this.scrolledUpPixels);
		this.captureScrollPosition();
		if (this.scrolledUpPixels > 0)
		{
			this.hasNewMessageWhileScrolledUp = true;
		}
	}

	public void onScrollPositionChanged()
	{
		this.captureScrollPosition();

		if (this.scrolledUpPixels == 0)
		{
			this.resetIndicator();
		}
	}

	public void resetIndicator()
	{
		this.hasNewMessageWhileScrolledUp = false;
		this.indicatorBounds = null;

		this.client.getCanvas().setCursor(Cursor.getDefaultCursor());
	}

	public void scrollToBottom()
	{
		this.clientThread.invokeLater(() ->
		{
			Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);

			if (chatbox == null || chatbox.isHidden())
			{
				return;
			}

			int scrollHeight = chatbox.getScrollHeight();
			this.client.runScript(ScriptID.UPDATE_SCROLLBAR, InterfaceID.Chatbox.CHATSCROLLBAR, InterfaceID.Chatbox.SCROLLAREA, scrollHeight);
			this.resetIndicator();
		});
	}

	public void captureScrollPosition()
	{
		int newValue = PluginUtils.getScrolledUpPixels(this.client);

		if (newValue == this.scrolledUpPixels)
		{
			return;
		}

		this.scrolledUpPixels = newValue;
	}

	private boolean isMouseOverIndicator()
	{
		if (this.indicatorBounds == null)
		{
			return false;
		}

		boolean isClickable = !(this.chatboxIsClickThrough && this.chatboxIsTransparent);
		if (!isClickable)
		{
			return false;
		}

		net.runelite.api.Point mousePos = this.client.getMouseCanvasPosition();
		return this.indicatorBounds.contains(mousePos.getX(), mousePos.getY());
	}
}

package com.customemoji.renderer;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.EmojiPosition;
import com.customemoji.PluginUtils;
import com.customemoji.animation.GifAnimation;
import com.customemoji.model.AnimatedEmoji;
import com.customemoji.model.Emoji;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

public abstract class EmojiRendererBase extends Overlay
{
	protected static final int MAX_RENDERED_ANIMATIONS = 300;
	protected static final long LOAD_DEBOUNCE_MS = 150;

	protected final Client client;
	protected final CustomEmojiConfig config;

	protected final Map<Integer, Long> emojiFirstSeenTime = new HashMap<>();

	protected Supplier<Map<String, Emoji>> emojisSupplier;
	protected Function<AnimatedEmoji, GifAnimation> animationLoader;
	protected Consumer<Integer> markVisibleCallback;

	protected EmojiRendererBase(Client client, CustomEmojiConfig config)
	{
		this.client = client;
		this.config = config;
		this.setPosition(OverlayPosition.DYNAMIC);
	}

	public void setEmojisSupplier(Supplier<Map<String, Emoji>> supplier)
	{
		this.emojisSupplier = supplier;
	}

	public void setAnimationLoader(Function<AnimatedEmoji, GifAnimation> loader)
	{
		this.animationLoader = loader;
	}

	public void setMarkVisibleCallback(Consumer<Integer> callback)
	{
		this.markVisibleCallback = callback;
	}

	protected BufferedImage resolveEmojiImage(Emoji emoji, int emojiId, Set<Integer> visibleEmojiIds)
	{
		visibleEmojiIds.add(emojiId);

		boolean isAnimatedEmoji = emoji instanceof AnimatedEmoji;
		if (!isAnimatedEmoji)
		{
			return emoji.getStaticImage();
		}

		AnimatedEmoji animatedEmoji = (AnimatedEmoji) emoji;
		BufferedImage animatedFrame = this.tryGetAnimatedFrame(animatedEmoji, emojiId, visibleEmojiIds);
		if (animatedFrame != null)
		{
			return animatedFrame;
		}

		return emoji.getStaticImage();
	}

	protected BufferedImage tryGetAnimatedFrame(AnimatedEmoji animatedEmoji, int emojiId, Set<Integer> visibleEmojiIds)
	{
		boolean animationsEnabled = this.config.animationLoadingMode() != CustomEmojiConfig.AnimationLoadingMode.OFF;
		boolean hasAnimationLoader = this.animationLoader != null;
		boolean hasPassedDebounce = this.hasPassedLoadDebounce(emojiId);
		boolean capacityExceeded = visibleEmojiIds.size() > MAX_RENDERED_ANIMATIONS;
		boolean shouldLoadAnimation = animationsEnabled && hasAnimationLoader && hasPassedDebounce && !capacityExceeded;
		if (!shouldLoadAnimation)
		{
			return null;
		}

		if (this.markVisibleCallback != null)
		{
			this.markVisibleCallback.accept(emojiId);
		}

		GifAnimation animation = this.animationLoader.apply(animatedEmoji);
		if (animation == null)
		{
			return null;
		}

		return animation.getCurrentFrame();
	}

	protected boolean hasPassedLoadDebounce(int emojiId)
	{
		long currentTime = System.currentTimeMillis();
		long firstSeenTime = this.emojiFirstSeenTime.computeIfAbsent(emojiId, k -> currentTime);
		long visibleDuration = currentTime - firstSeenTime;
		return visibleDuration >= LOAD_DEBOUNCE_MS;
	}

	protected void drawEmojiImage(Graphics2D graphics, BufferedImage image, EmojiPosition position)
	{
		int drawX = position.getX();
		int drawY = position.getY();
		int drawWidth = image.getWidth();
		int drawHeight = image.getHeight();

		if (position.hasBaseEmojiBounds())
		{
			Rectangle baseEmojiBounds = position.getBaseEmojiBounds();
			drawX = baseEmojiBounds.x + (baseEmojiBounds.width - drawWidth) / 2;
			drawY = baseEmojiBounds.y + (baseEmojiBounds.height - drawHeight) / 2;
		}

		graphics.drawImage(image, drawX, drawY, drawWidth, drawHeight, null);
	}

	protected boolean isEmojiDisabled(Emoji emoji)
	{
		Set<String> disabledEmojis = PluginUtils.parseDisabledEmojis(this.config.disabledEmojis());
		return disabledEmojis.contains(emoji.getText());
	}

	protected void cleanupStaleEmojis(Set<Integer> visibleEmojiIds)
	{
		this.emojiFirstSeenTime.keySet().retainAll(visibleEmojiIds);
	}

	protected void onRenderComplete()
	{
	}
}

package com.customemoji.renderer;

import com.customemoji.CustomEmojiConfig;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class ChatEmojiRenderer extends EmojiWidgetRenderer
{
	@Inject
	public ChatEmojiRenderer(Client client, CustomEmojiConfig config)
	{
		super(client, config, InterfaceID.Chatbox.SCROLLAREA);
		this.setPriority(0.5f);
	}
}

package com.customemoji.renderer;

import com.customemoji.CustomEmojiConfig;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.ui.overlay.OverlayLayer;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class SplitPrivateChatEmojiRenderer extends EmojiWidgetRenderer
{
	@Inject
	public SplitPrivateChatEmojiRenderer(Client client, CustomEmojiConfig config)
	{
		super(client, config, InterfaceID.PmChat.CONTAINER);
	}
}

package com.customemoji.renderer;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.EmojiPosition;
import com.customemoji.EmojiPositionCalculator;
import com.customemoji.PluginUtils;
import com.customemoji.model.Emoji;

import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.image.BufferedImage;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

public abstract class EmojiWidgetRenderer extends EmojiRendererBase
{
	protected final int widgetId;
	protected Consumer<Set<Integer>> unloadStaleCallback;

	protected EmojiWidgetRenderer(Client client, CustomEmojiConfig config, int widgetId)
	{
		super(client, config);
		this.widgetId = widgetId;

		this.setPosition(OverlayPosition.DYNAMIC);
		this.setLayer(OverlayLayer.MANUAL);
		this.setPriority(0.9f);
		int interfaceID = WidgetUtil.componentToInterface(this.widgetId);
		this.drawAfterInterface(interfaceID);
	}

	public void setUnloadStaleCallback(Consumer<Set<Integer>> callback)
	{
		this.unloadStaleCallback = callback;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (this.emojisSupplier == null)
		{
			return null;
		}

		Widget targetWidget = this.client.getWidget(this.widgetId);
		if (targetWidget == null || targetWidget.isHidden())
		{
			return null;
		}

		Rectangle bounds = targetWidget.getBounds();
		if (bounds == null)
		{
			return null;
		}

		List<Widget> visibleChildren = PluginUtils.getVisibleChildWidgets(targetWidget);
		if (visibleChildren == null || visibleChildren.isEmpty())
		{
			return null;
		}

		Map<Integer, Emoji> emojiLookup = PluginUtils.buildEmojiLookup(this.emojisSupplier);

		Set<Integer> visibleEmojiIds = new HashSet<>();
		Shape originalClip = graphics.getClip();

		graphics.setClip(bounds);

		for (Widget widget : visibleChildren)
		{
			this.processWidget(widget, graphics, visibleEmojiIds, emojiLookup);
		}

		graphics.setClip(originalClip);

		this.cleanupStaleEmojis(visibleEmojiIds);
		if (this.unloadStaleCallback != null)
		{
			this.unloadStaleCallback.accept(visibleEmojiIds);
		}

		this.onRenderComplete();

		return null;
	}

	protected void processWidget(Widget widget, Graphics2D graphics, Set<Integer> visibleEmojiIds, Map<Integer, Emoji> emojiLookup)
	{
		if (widget == null)
		{
			return;
		}

		String text = widget.getText();
		if (!PluginUtils.hasImgTag(text))
		{
			return;
		}

		List<EmojiPosition> positions = EmojiPositionCalculator.calculateEmojiPositions(
			widget,
			text,
			imageId -> PluginUtils.getEmojiDimension(this.client.getModIcons(), imageId)
		);

		PluginUtils.linkZeroWidthEmojisToTarget(positions, emojiLookup);

		for (EmojiPosition position : positions)
		{
			this.renderEmoji(position, graphics, visibleEmojiIds, emojiLookup);
		}
	}

	protected void renderEmoji(EmojiPosition position, Graphics2D graphics, Set<Integer> visibleEmojiIds, Map<Integer, Emoji> emojiLookup)
	{
		int imageId = position.getImageId();
		Emoji emoji = emojiLookup.get(imageId);
		if (emoji == null)
		{
			return;
		}

		if (this.isEmojiDisabled(emoji))
		{
			return;
		}

		int emojiId = emoji.getId();
		BufferedImage image = this.resolveEmojiImage(emoji, emojiId, visibleEmojiIds);
		this.drawEmojiImage(graphics, image, position);
	}
}

package com.customemoji;

import net.runelite.client.config.*;

@ConfigGroup(CustomEmojiConfig.KEY_CONFIG_GROUP)
public interface CustomEmojiConfig extends Config
{
	String KEY_CONFIG_GROUP = "custom-emote";

	// Display section
	String KEY_SPLIT_PRIVATE_CHAT = "split_private_chat";
	String KEY_DYNAMIC_EMOJI_SPACING = "dynamic_emoji_spacing";
	String KEY_CHAT_MESSAGE_SPACING = "chat_message_spacing";
	String KEY_MAX_IMAGE_HEIGHT = "max_image_height";
	String KEY_ANIMATION_LOADING_MODE = "animation_loading_mode";
	String KEY_FILTER_DISABLED_EMOJI_MESSAGES = "filter_disabled_emoji_messages";

	// UI Components section
	String KEY_SHOW_SIDE_PANEL = "show_panel";
	String KEY_SHOW_EMOJI_TOOLTIPS = "show_emoji_tooltips";
	String KEY_OVERLAY_MAX_SUGGESTIONS = "overlay_max_suggestions";
	String KEY_NEW_MESSAGE_INDICATOR_MODE = "new_message_indicator_mode";

	// GitHub section
	String KEY_GITHUB_ADDRESS = "github_repo_address";

	// Soundoji section
	String KEY_VOLUME = "volume";

	// Hidden
	String KEY_DISABLED_EMOJIS = "disabled_emojis";
	String KEY_RESIZING_DISABLED_EMOJIS = "resizing_disabled_emojis";

	@ConfigSection(
		name = "Display",
		description = "General emoji display settings",
		position = 0
	)
	String DISPLAY_SECTION = "displaySection";

	@ConfigItem(
		keyName = KEY_SPLIT_PRIVATE_CHAT,
		name = "Split Private Chat",
		description = "Display emojis in the split private chat window.",
		section = DISPLAY_SECTION,
		position = 0
	)
	default boolean splitPrivateChat()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_DYNAMIC_EMOJI_SPACING,
		name = "Dynamic Spacing",
		description = "Dynamically add extra spacing for lines with tall emojis.",
		section = DISPLAY_SECTION,
		position = 1
	)
	default boolean dynamicEmojiSpacing()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_CHAT_MESSAGE_SPACING,
		name = "Extra Spacing",
		description = "Extra vertical spacing between chat messages (in pixels).",
		section = DISPLAY_SECTION,
		position = 2
	)
	@Range(min = 0, max = 20)
	default int chatMessageSpacing()
	{
		return 0;
	}

	@ConfigItem(
		keyName = KEY_MAX_IMAGE_HEIGHT,
		name = "Max Emoji Height",
		description = "Maximum height (in pixels) for emojis with resizing enabled.",
		section = DISPLAY_SECTION,
		position = 3
	)
	@Range(min = 0, max = 100)
	default int maxImageHeight()
	{
		return 24;
	}

	@ConfigItem(
		keyName = KEY_ANIMATION_LOADING_MODE,
		name = "Animation Mode",
		description = "<b>Off:</b> Animations disabled.<br>" +
					  "<b>Lazy:</b> Loads frames progressively as needed. <b>[Recommended]</b><br>" +
					  "<b>Eager:</b> Loads all frames immediately.",
		section = DISPLAY_SECTION,
		position = 4
	)
	default AnimationLoadingMode animationLoadingMode()
	{
		return AnimationLoadingMode.LAZY;
	}

	@ConfigItem(
		keyName = KEY_FILTER_DISABLED_EMOJI_MESSAGES,
		name = "Message Filter",
		description = "<b>Off:</b> No filtering applied.<br>" +
			"<b>Lenient:</b> Hide messages containing only disabled emojis.<br>" +
			"<b>Strict:</b> Hide messages containing any disabled emoji.",
		section = DISPLAY_SECTION,
		position = 5
	)
	default DisabledEmojiFilterMode disabledEmojiFilterMode()
	{
		return DisabledEmojiFilterMode.OFF;
	}

	@ConfigSection(
		name = "UI Components",
		description = "Plugin panels, tooltips, and overlays",
		position = 1
	)
	String UI_COMPONENTS_SECTION = "uiComponentsSection";

	@ConfigItem(
		keyName = KEY_SHOW_SIDE_PANEL,
		name = "Show Sidebar Panel",
		description = "Show the emoji panel in the sidebar.",
		section = UI_COMPONENTS_SECTION,
		position = 0
	)
	default boolean showPanel()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_SHOW_EMOJI_TOOLTIPS,
		name = "Show Tooltips",
		description = "Display emoji name when hovering over emojis in chat.",
		section = UI_COMPONENTS_SECTION,
		position = 1
	)
	default boolean showEmojiTooltips()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_OVERLAY_MAX_SUGGESTIONS,
		name = "Max Suggestions",
		description = "Maximum number of emoji suggestions to display. <b>(0 = disabled)</b>",
		section = UI_COMPONENTS_SECTION,
		position = 3
	)
	default int maxImageSuggestions()
	{
		return 10;
	}

	@ConfigItem(
		keyName = KEY_NEW_MESSAGE_INDICATOR_MODE,
		name = "New Message Indicator",
		description = "<b>Off:</b> No indicator shown.<br>" +
					  "<b>Banner:</b> Shows a banner at the bottom of the chat.<br>" +
					  "<b>Arrow:</b> Shows a circular arrow button at the bottom-right.<br><br>" +
					  "When clicked, the chat will scroll to the latest message.<br>" +
					  "<b>Note:</b> The indicator is not clickable when <u>Transparent chatbox</u> and<br>" +
					  "<u>Click through transparent chatbox</u> are enabled.",
		section = UI_COMPONENTS_SECTION,
		position = 4
	)
	default NewMessageIndicatorMode newMessageIndicatorMode()
	{
		return NewMessageIndicatorMode.BANNER;
	}

	@ConfigSection(
		name = "GitHub Emoji Pack",
		description = "Download emojis from a GitHub repository",
		position = 2
	)
	String GITHUB_SECTION = "githubSection";

	@ConfigItem(
		keyName = KEY_GITHUB_ADDRESS,
		name = "Repository",
		description = "GitHub repository in format 'user/repo' or 'user/repo/tree/branch'. Leave empty to disable.",
		section = GITHUB_SECTION,
		position = 0
	)
	default String githubRepoUrl()
	{
		return "";
	}

	@ConfigSection(
		name = "Soundoji",
		description = "Sound-enabled emoji settings",
		position = 3
	)
	String SOUNDOJI_SECTION = "overlaySection";

	@ConfigItem(
		keyName = KEY_VOLUME,
		name = "Volume",
		description = "Soundoji playback volume. [0-100]",
		section = SOUNDOJI_SECTION,
		position = 0
	)
	@Range(min = 0, max = 100)
	default int volume()
	{
		return 70;
	}

	@ConfigItem(
		keyName = KEY_DISABLED_EMOJIS,
		name = "",
		description = "",
		hidden = true
	)
	default String disabledEmojis()
	{
		return "";
	}

	@ConfigItem(
		keyName = KEY_RESIZING_DISABLED_EMOJIS,
		name = "",
		description = "",
		hidden = true
	)
	default String resizingDisabledEmojis()
	{
		return "";
	}

	enum AnimationLoadingMode
	{
		OFF("Off"),
		LAZY("Lazy"),
		EAGER("Eager");

		private final String name;

		AnimationLoadingMode(String name)
		{
			this.name = name;
		}

		@Override
		public String toString()
		{
			return this.name;
		}
	}

	enum DisabledEmojiFilterMode
	{
		OFF("Off"),
		LENIENT("Lenient"),
		STRICT("Strict");

		private final String name;

		DisabledEmojiFilterMode(String name)
		{
			this.name = name;
		}

		@Override
		public String toString()
		{
			return this.name;
		}
	}

	enum NewMessageIndicatorMode
	{
		OFF("Off"),
		BANNER("Banner"),
		ARROW("Arrow");

		private final String name;

		NewMessageIndicatorMode(String name)
		{
			this.name = name;
		}

		@Override
		public String toString()
		{
			return this.name;
		}
	}
}

package com.customemoji.service;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.PluginUtils;
import com.customemoji.model.Emoji;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Year;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;

@Slf4j
@Singleton
public class EmojiUsageRecorder
{
	private static final String USAGE_KEY_PREFIX = "usage_";

	private final ConfigManager configManager;
	private final Client client;
	private Supplier<Map<String, Emoji>> emojisSupplier;

	@Inject
	public EmojiUsageRecorder(ConfigManager configManager, Client client)
	{
		this.configManager = configManager;
		this.client = client;
	}

	public void setEmojisSupplier(Supplier<Map<String, Emoji>> supplier)
	{
		this.emojisSupplier = supplier;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (this.emojisSupplier == null)
		{
			return;
		}

		boolean isRecordableType = this.isRecordableMessageType(event.getType());
		if (!isRecordableType)
		{
			return;
		}

		boolean isFromLocalPlayer = this.isFromLocalPlayer(event.getName());
		if (!isFromLocalPlayer)
		{
			return;
		}

		String message = event.getMessage();
		this.recordUsage(message);
	}

	private boolean isRecordableMessageType(ChatMessageType type)
	{
		return type == ChatMessageType.PUBLICCHAT
			|| type == ChatMessageType.PRIVATECHATOUT
			|| type == ChatMessageType.FRIENDSCHAT
			|| type == ChatMessageType.CLAN_CHAT;
	}

	private boolean isFromLocalPlayer(String senderName)
	{
		Player localPlayer = this.client.getLocalPlayer();
		if (localPlayer == null)
		{
			return false;
		}

		String localPlayerName = localPlayer.getName();
		if (localPlayerName == null)
		{
			return false;
		}

		String normalizedSender = Text.toJagexName(Text.removeTags(senderName));
		return localPlayerName.equals(normalizedSender);
	}

	private void recordUsage(String message)
	{
		Map<String, Emoji> emojis = this.emojisSupplier.get();
		List<String> emojisFound = PluginUtils.findEmojiTriggersInMessage(message, emojis);

		for (String emojiName : emojisFound)
		{
			this.incrementCount(emojiName);
		}
	}

	private void incrementCount(String emojiName)
	{
		String key = USAGE_KEY_PREFIX + Year.now().getValue() + "_" + emojiName;
		String current = this.configManager.getConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, key);
		int count = (current != null) ? Integer.parseInt(current) : 0;
		this.configManager.setConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, key, String.valueOf(count + 1));
		log.debug("Incremented usage count for {}: {}", emojiName, count + 1);
	}
}

package com.customemoji.service;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.PluginUtils;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;

@Singleton
public class EmojiStateManager
{
	private final ConfigManager configManager;
	private final CustomEmojiConfig config;
	private final Object stateLock = new Object();

	private Consumer<String> onEmojiEnabled;
	private Consumer<String> onEmojiDisabled;
	private Consumer<String> onEmojiResizingToggled;

	@Inject
	public EmojiStateManager(ConfigManager configManager, CustomEmojiConfig config)
	{
		this.configManager = configManager;
		this.config = config;
	}

	public void setOnEmojiEnabled(Consumer<String> callback)
	{
		this.onEmojiEnabled = callback;
	}

	public void setOnEmojiDisabled(Consumer<String> callback)
	{
		this.onEmojiDisabled = callback;
	}

	public void setOnEmojiResizingToggled(Consumer<String> callback)
	{
		this.onEmojiResizingToggled = callback;
	}

	public boolean isEmojiEnabled(String emojiName)
	{
		synchronized (this.stateLock)
		{
			Set<String> disabled = PluginUtils.parseDisabledEmojis(this.config.disabledEmojis());
			return !disabled.contains(emojiName);
		}
	}

	public boolean isResizingEnabled(String emojiName)
	{
		synchronized (this.stateLock)
		{
			Set<String> resizingDisabled = PluginUtils.parseResizingDisabledEmojis(this.config.resizingDisabledEmojis());
			return !resizingDisabled.contains(emojiName);
		}
	}

	public Set<String> getDisabledEmojis()
	{
		synchronized (this.stateLock)
		{
			return new HashSet<>(PluginUtils.parseDisabledEmojis(this.config.disabledEmojis()));
		}
	}

	public Set<String> getResizingDisabledEmojis()
	{
		synchronized (this.stateLock)
		{
			return new HashSet<>(PluginUtils.parseResizingDisabledEmojis(this.config.resizingDisabledEmojis()));
		}
	}

	public void setEmojiEnabled(String emojiName, boolean enabled)
	{
		synchronized (this.stateLock)
		{
			Set<String> disabled = new HashSet<>(PluginUtils.parseDisabledEmojis(this.config.disabledEmojis()));

			if (enabled)
			{
				disabled.remove(emojiName);
			}
			else
			{
				disabled.add(emojiName);
			}

			String serialized = String.join(",", disabled);
			this.configManager.setConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, CustomEmojiConfig.KEY_DISABLED_EMOJIS, serialized);
		}

		if (enabled && this.onEmojiEnabled != null)
		{
			this.onEmojiEnabled.accept(emojiName);
		}
		else if (!enabled && this.onEmojiDisabled != null)
		{
			this.onEmojiDisabled.accept(emojiName);
		}
	}

	public void setEmojiResizing(String emojiName, boolean resizingEnabled)
	{
		synchronized (this.stateLock)
		{
			Set<String> resizingDisabled = new HashSet<>(PluginUtils.parseResizingDisabledEmojis(this.config.resizingDisabledEmojis()));

			if (resizingEnabled)
			{
				resizingDisabled.remove(emojiName);
			}
			else
			{
				resizingDisabled.add(emojiName);
			}

			String serialized = String.join(",", resizingDisabled);
			this.configManager.setConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, CustomEmojiConfig.KEY_RESIZING_DISABLED_EMOJIS, serialized);
		}

		if (this.onEmojiResizingToggled != null)
		{
			this.onEmojiResizingToggled.accept(emojiName);
		}
	}

	public void setMultipleEmojisEnabled(Set<String> emojiNames, boolean enabled)
	{
		if (emojiNames == null || emojiNames.isEmpty())
		{
			return;
		}

		Set<String> emojisToNotify = new HashSet<>();

		synchronized (this.stateLock)
		{
			Set<String> disabled = new HashSet<>(PluginUtils.parseDisabledEmojis(this.config.disabledEmojis()));

			for (String emojiName : emojiNames)
			{
				boolean wasDisabled = disabled.contains(emojiName);

				if (enabled)
				{
					disabled.remove(emojiName);
					if (wasDisabled)
					{
						emojisToNotify.add(emojiName);
					}
				}
				else
				{
					disabled.add(emojiName);
					if (!wasDisabled)
					{
						emojisToNotify.add(emojiName);
					}
				}
			}

			String serialized = String.join(",", disabled);
			this.configManager.setConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, CustomEmojiConfig.KEY_DISABLED_EMOJIS, serialized);
		}

		if (enabled && this.onEmojiEnabled != null)
		{
			for (String emojiName : emojisToNotify)
			{
				this.onEmojiEnabled.accept(emojiName);
			}
		}
		else if (!enabled && this.onEmojiDisabled != null)
		{
			for (String emojiName : emojisToNotify)
			{
				this.onEmojiDisabled.accept(emojiName);
			}
		}
	}

	public void setMultipleEmojisResizing(Set<String> emojiNames, boolean resizingEnabled)
	{
		if (emojiNames == null || emojiNames.isEmpty())
		{
			return;
		}

		Set<String> emojisToNotify = new HashSet<>();

		synchronized (this.stateLock)
		{
			Set<String> resizingDisabled = new HashSet<>(PluginUtils.parseResizingDisabledEmojis(this.config.resizingDisabledEmojis()));

			for (String emojiName : emojiNames)
			{
				boolean wasResizingEnabled = !resizingDisabled.contains(emojiName);
				boolean stateChanged = wasResizingEnabled != resizingEnabled;

				if (resizingEnabled)
				{
					resizingDisabled.remove(emojiName);
				}
				else
				{
					resizingDisabled.add(emojiName);
				}

				if (stateChanged)
				{
					emojisToNotify.add(emojiName);
				}
			}

			String serialized = String.join(",", resizingDisabled);
			this.configManager.setConfiguration(CustomEmojiConfig.KEY_CONFIG_GROUP, CustomEmojiConfig.KEY_RESIZING_DISABLED_EMOJIS, serialized);
		}

		if (this.onEmojiResizingToggled != null)
		{
			for (String emojiName : emojisToNotify)
			{
				this.onEmojiResizingToggled.accept(emojiName);
			}
		}
	}
}

package com.customemoji;

import net.runelite.api.FontTypeFace;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.FontManager;

import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;

import lombok.extern.slf4j.Slf4j;

/**
 * Utility class for calculating emoji positions within chat widgets.
 * Shared between CustomEmojiTooltip and debug overlay.
 */
@Slf4j
public class EmojiPositionCalculator
{
    private static final int LINE_HEIGHT = 14;
    private static final int VERTICAL_OFFSET = 2;
    private static final int DEFAULT_EMOJI_SIZE = 18;

    /**
     * Functional interface for looking up emoji dimensions by image ID.
     */
    @FunctionalInterface
    public interface DimensionLookup
    {
        Dimension getDimension(int imageId);
    }

    /**
     * Calculates the positions of all emojis in the given widget text.
     *
     * @param widget The widget containing the text
     * @param text The text content (with img tags)
     * @param dimensionLookup Function to look up emoji dimensions by image ID
     * @return List of EmojiPosition objects with absolute coordinates
     */
    public static List<EmojiPosition> calculateEmojiPositions(Widget widget, String text, DimensionLookup dimensionLookup)
    {
        List<EmojiPosition> positions = new ArrayList<>();

        Matcher matcher = PluginUtils.IMAGE_TAG_PATTERN.matcher(text);
        Point widgetPos = widget.getCanvasLocation();
        if (widgetPos == null)
        {
            return positions;
        }

        FontTypeFace font;
        try
        {
            font = widget.getFont();
        }
        catch (Exception e)
        {
            log.error("Error getting font for widget", e);
            return positions;
        }

        if (font == null)
        {
            return positions;
        }

        int textIndex = 0;
        int currentX = 0;
        int currentLine = 0;

        while (matcher.find())
        {
            String textBefore = text.substring(textIndex, matcher.start());
            String cleanTextBefore = removeHtmlTags(textBefore);

            // Simulate word-based line wrapping (OSRS wraps at spaces, not mid-word)
            String[] words = cleanTextBefore.split("(?<= )");
            for (String word : words)
            {
                int wordWidth = font.getTextWidth(word);
                if (currentX + wordWidth > widget.getWidth() && currentX > 0)
                {
                    currentX = 0;
                    currentLine++;
                }
                currentX += wordWidth;
            }

            String imageIdStr = matcher.group(1);
            int imageId = Integer.parseInt(imageIdStr);

            // Get emoji dimensions
            int emojiWidth = DEFAULT_EMOJI_SIZE;
            int emojiHeight = DEFAULT_EMOJI_SIZE;

            Dimension dimension = dimensionLookup.getDimension(imageId);
            if (dimension != null)
            {
                emojiWidth = dimension.width;
                emojiHeight = dimension.height;
            }

            // Check if emoji itself would wrap to next line
            if (currentX + emojiWidth > widget.getWidth() && currentX > 0)
            {
                currentX = 0;
                currentLine++;
            }

            int emojiStartX = currentX;

            // Calculate Y position based on which line the emoji is on
            // Emoji is bottom-aligned within the line, but offset 2px up from the bottom
            int lineBottomY = (currentLine + 1) * LINE_HEIGHT;
            int emojiBottomY = lineBottomY;
            int emojiTopY = emojiBottomY - emojiHeight;

            // Adjust Y for tall emoji on wrapped lines to prevent overlap with previous line
            boolean isOnWrappedLine = currentLine > 0;
            boolean isTooTall = emojiHeight > LINE_HEIGHT;
            boolean isTooWide = emojiWidth > widget.getWidth();
            if (isOnWrappedLine && isTooTall && !isTooWide)
            {
                emojiTopY += emojiHeight - LINE_HEIGHT + (LINE_HEIGHT * (currentLine - 1));
            }
            else if (isOnWrappedLine && isTooWide)
            {
                //continue; // Skip rendering overly wide emojis that wrap
            }

            int absoluteX = widgetPos.getX() + emojiStartX;
            int absoluteY = widgetPos.getY() + emojiTopY;

            Rectangle bounds = new Rectangle(absoluteX, absoluteY, emojiWidth, emojiHeight);
            positions.add(new EmojiPosition(imageId, bounds, currentLine));

            currentX = emojiStartX + emojiWidth;
            textIndex = matcher.end();
        }

        return positions;
    }

    /**
     * Finds the emoji at the given point within a widget.
     *
     * @param widget The widget containing the text
     * @param text The text content (with img tags)
     * @param pointX Absolute X coordinate to check
     * @param pointY Absolute Y coordinate to check
     * @param dimensionLookup Function to look up emoji dimensions by image ID
     * @return The image ID of the emoji at the point, or -1 if none found
     */
    public static int findEmojiAtPoint(Widget widget, String text, int pointX, int pointY, DimensionLookup dimensionLookup)
    {
        List<EmojiPosition> positions = calculateEmojiPositions(widget, text, dimensionLookup);

        for (EmojiPosition position : positions)
        {
            if (position.containsPoint(pointX, pointY))
            {
                return position.getImageId();
            }
        }

        return -1;
    }

    public static List<EmojiPosition> calculateOverheadEmojiPositions(Graphics2D graphics, String text, int centerX, int baseY, DimensionLookup dimensionLookup)
    {
        List<EmojiPosition> positions = new ArrayList<>();

        Font font = FontManager.getRunescapeBoldFont();
        FontMetrics metrics = graphics.getFontMetrics(font);

        int totalWidth = EmojiPositionCalculator.calculateOverheadTotalWidth(text, metrics, dimensionLookup);
        int xOffset = totalWidth / 2;
        int startX = centerX - xOffset;

        int currentX = startX;
        int textIndex = 0;
        Matcher matcher = PluginUtils.IMAGE_TAG_PATTERN.matcher(text);

        while (matcher.find())
        {
            String textBefore = text.substring(textIndex, matcher.start());
            String cleanText = EmojiPositionCalculator.removeHtmlTags(textBefore);
            currentX += metrics.stringWidth(cleanText);

            int imageId = Integer.parseInt(matcher.group(1));
            Dimension emojiDim = dimensionLookup.getDimension(imageId);
            int emojiWidth = emojiDim != null ? emojiDim.width : DEFAULT_EMOJI_SIZE;
            int emojiHeight = emojiDim != null ? emojiDim.height : DEFAULT_EMOJI_SIZE;

            int emojiY = baseY - emojiHeight + VERTICAL_OFFSET;
            Rectangle bounds = new Rectangle(currentX, emojiY, emojiWidth, emojiHeight);
            positions.add(new EmojiPosition(imageId, bounds, 0));

            currentX += emojiWidth;
            textIndex = matcher.end();
        }

        return positions;
    }

    private static int calculateOverheadTotalWidth(String text, FontMetrics metrics, DimensionLookup dimensionLookup)
    {
        int totalWidth = 0;
        int textIndex = 0;
        Matcher matcher = PluginUtils.IMAGE_TAG_PATTERN.matcher(text);

        while (matcher.find())
        {
            String textBefore = text.substring(textIndex, matcher.start());
            String cleanText = EmojiPositionCalculator.removeHtmlTags(textBefore);
            totalWidth += metrics.stringWidth(cleanText);

            int imageId = Integer.parseInt(matcher.group(1));
            Dimension emojiDim = dimensionLookup.getDimension(imageId);
            int emojiWidth = emojiDim != null ? emojiDim.width : DEFAULT_EMOJI_SIZE;
            totalWidth += emojiWidth;

            textIndex = matcher.end();
        }

        String remainingText = text.substring(textIndex);
        String cleanRemaining = EmojiPositionCalculator.removeHtmlTags(remainingText);
        totalWidth += metrics.stringWidth(cleanRemaining);

        return totalWidth;
    }

    private static String removeHtmlTags(String text)
    {
        if (text == null)
        {
            return "";
        }
        return text.replaceAll("<[^>]*>", "");
    }

    public static class SpacingInfo
    {
        public final int aboveSpacing;
        public final int belowSpacing;

        public SpacingInfo(int aboveSpacing, int belowSpacing)
        {
            this.aboveSpacing = aboveSpacing;
            this.belowSpacing = belowSpacing;
        }
    }

    public static SpacingInfo calculateSpacingForWidget(Widget widget, DimensionLookup dimensionLookup, Set<Integer> customEmojiImageIds)
    {
        String text = widget.getText();
        if (text == null || !PluginUtils.hasImgTag(text))
        {
            return new SpacingInfo(0, 0);
        }

        List<EmojiPosition> positions = EmojiPositionCalculator.calculateEmojiPositions(widget, text, dimensionLookup);
        if (positions.isEmpty())
        {
            return new SpacingInfo(0, 0);
        }

        net.runelite.api.Point widgetPos = widget.getCanvasLocation();
        if (widgetPos == null)
        {
            return new SpacingInfo(0, 0);
        }

        int widgetTop = widgetPos.getY();
        int widgetBottom = widgetTop + widget.getHeight();

        int minEmojiTop = Integer.MAX_VALUE;
        int maxEmojiBottom = Integer.MIN_VALUE;

        for (EmojiPosition position : positions)
        {
            boolean isCustomEmoji = customEmojiImageIds.contains(position.getImageId());
            if (!isCustomEmoji)
            {
                continue;
            }

            int emojiTop = position.getY();
            int emojiBottom = emojiTop + position.getHeight();

            minEmojiTop = Math.min(minEmojiTop, emojiTop);
            maxEmojiBottom = Math.max(maxEmojiBottom, emojiBottom);
        }

        if (minEmojiTop == Integer.MAX_VALUE)
        {
            return new SpacingInfo(0, 0);
        }

        int aboveSpacing = Math.max(0, widgetTop - minEmojiTop);
        int belowSpacing = Math.max(0, maxEmojiBottom - widgetBottom);

        return new SpacingInfo(aboveSpacing, belowSpacing);
    }
}
package com.customemoji.panel;

import com.customemoji.io.GitHubEmojiDownloader.DownloadProgress;
import com.customemoji.io.GitHubEmojiDownloader.DownloadStage;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import java.awt.BorderLayout;
import java.awt.Color;
import java.util.function.Supplier;

public class DownloadProgressPanel extends JPanel
{
    private static final int POLL_INTERVAL_MS = 100;
    private static final Color PROGRESS_COLOR = new Color(0, 200, 83);
    private static final Color PROGRESS_BACKGROUND = new Color(50, 50, 50);

    private final JProgressBar progressBar;
    private final JLabel statusLabel;
    private final Timer pollTimer;

    private Supplier<DownloadProgress> progressSupplier;
    private boolean wasVisible = false;

    public DownloadProgressPanel()
    {
        this.setLayout(new BorderLayout(0, 4));
        this.setBackground(PanelConstants.CONTENT_BACKGROUND);
        this.setBorder(BorderFactory.createCompoundBorder(
            BorderFactory.createMatteBorder(1, 0, 0, 0, PanelConstants.HEADER_BORDER),
            BorderFactory.createEmptyBorder(8, 8, 8, 8)
        ));

        JLabel titleLabel = new JLabel("Downloading Emojis");
        titleLabel.setForeground(Color.WHITE);
        this.add(titleLabel, BorderLayout.NORTH);

        this.progressBar = new JProgressBar(0, 100);
        this.progressBar.setStringPainted(true);
        this.progressBar.setForeground(PROGRESS_COLOR);
        this.progressBar.setBackground(PROGRESS_BACKGROUND);
        this.add(this.progressBar, BorderLayout.CENTER);

        this.statusLabel = new JLabel(" ");
        this.statusLabel.setForeground(new Color(200, 200, 200));
        this.add(this.statusLabel, BorderLayout.SOUTH);

        this.pollTimer = new Timer(POLL_INTERVAL_MS, e -> this.updateProgress());

        this.setVisible(false);
    }

    public void setProgressSupplier(Supplier<DownloadProgress> progressSupplier)
    {
        this.progressSupplier = progressSupplier;
        this.pollTimer.start();
    }

    public void stopPolling()
    {
        this.pollTimer.stop();
    }

    private void updateProgress()
    {
        if (this.progressSupplier == null)
        {
            return;
        }

        DownloadProgress progress = this.progressSupplier.get();

        SwingUtilities.invokeLater(() -> {
            if (progress == null)
            {
                if (this.wasVisible)
                {
                    this.setVisible(false);
                    this.wasVisible = false;
                    this.revalidate();
                    this.repaint();
                }
                return;
            }

            if (!this.wasVisible)
            {
                this.setVisible(true);
                this.wasVisible = true;
            }

            DownloadStage stage = progress.getStage();
            int total = progress.getTotalFiles();
            int current = progress.getCurrentFileIndex();

            boolean isDownloading = stage == DownloadStage.DOWNLOADING && total > 0;
            if (isDownloading)
            {
                this.progressBar.setMaximum(total);
                this.progressBar.setValue(current);
                this.progressBar.setString(current + " / " + total);
            }
            else
            {
                this.progressBar.setMaximum(100);
                this.progressBar.setValue(0);
                this.progressBar.setString("");
            }

            String statusText = this.getStatusText(progress);
            this.statusLabel.setText(statusText);

            this.revalidate();
            this.repaint();
        });
    }

    private String getStatusText(DownloadProgress progress)
    {
        DownloadStage stage = progress.getStage();

        boolean hasFileName = stage == DownloadStage.DOWNLOADING && progress.getCurrentFileName() != null;
        if (hasFileName)
        {
            return progress.getCurrentFileName();
        }

        return stage.getDisplayText();
    }
}

package com.customemoji.panel;

import com.customemoji.CustomEmojiPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.Insets;
import java.awt.image.BufferedImage;
import java.io.File;

/**
 * Header panel containing the title and action buttons (settings, GitHub, folder).
 */
@Slf4j
public class HeaderPanel extends JPanel
{
	private static final String GITHUB_URL = "https://github.com/LouisGameDev/runelite-custom-emoji";

	private final transient Runnable openSettingsAction;

	public HeaderPanel(Runnable openSettingsAction)
	{
		super(new BorderLayout());
		this.openSettingsAction = openSettingsAction;
		this.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		this.initializeComponents();
	}

	private void initializeComponents()
	{
		BufferedImage smileyImage = ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_SMILEY);
		BufferedImage resizedSmiley = ImageUtil.resizeImage(smileyImage, 24, 24);

		JLabel titleLabel = new JLabel("Custom Emoji");
		titleLabel.setIcon(new ImageIcon(resizedSmiley));
		titleLabel.setToolTipText(":)");
		titleLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));

		JPanel buttonsPanel = this.createButtonsPanel();

		this.add(titleLabel, BorderLayout.WEST);
		this.add(buttonsPanel, BorderLayout.EAST);
	}

	private JPanel createButtonsPanel()
	{
		JPanel buttonsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));

		JButton settingsButton = this.createButton(PanelConstants.ICON_WRENCH, "Open plugin settings");
		settingsButton.addActionListener(e -> this.openSettings());

		JButton githubButton = this.createButton(PanelConstants.ICON_GITHUB, "Open GitHub repository");
		githubButton.addActionListener(e -> this.openGitHub());

		JButton folderButton = this.createButton(PanelConstants.ICON_FOLDER_FILL, "Open emoji folder");
		folderButton.addActionListener(e -> this.openEmojiFolder());

		buttonsPanel.add(settingsButton);
		buttonsPanel.add(githubButton);
		buttonsPanel.add(folderButton);

		return buttonsPanel;
	}

	private JButton createButton(String iconName, String tooltip)
	{
		JButton button = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, iconName)));
		button.setToolTipText(tooltip);
		button.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		button.setMargin(new Insets(0, 0, 0, 0));
		return button;
	}

	private void openSettings()
	{
		this.openSettingsAction.run();
	}

	private void openGitHub()
	{
		LinkBrowser.browse(GITHUB_URL);
	}

	private void openEmojiFolder()
	{
		File emojisFolder = CustomEmojiPlugin.EMOJIS_FOLDER;
		if (emojisFolder.exists())
		{
			LinkBrowser.open(emojisFolder.getAbsolutePath());
		}
	}
}


package com.customemoji.panel;

import java.awt.Color;
import java.awt.Dimension;

/**
 * Centralized color and dimension constants for the panel UI.
 */
public final class PanelConstants
{
	private PanelConstants()
	{
		// Utility class - prevent instantiation
	}

	// Background colors
	public static final Color HEADER_BACKGROUND = new Color(30, 30, 30);
	public static final Color CONTENT_BACKGROUND = new Color(40, 40, 40);
	public static final Color ROW_HOVER_BACKGROUND = new Color(50, 50, 50);

	// Border colors
	public static final Color HEADER_BORDER = new Color(60, 60, 60);

	// Text colors
	public static final Color FOLDER_TEXT = new Color(220, 138, 0);
	public static final Color ENABLED_TEXT = Color.WHITE;
	public static final Color DISABLED_TEXT = Color.GRAY;

	// Warning/error colors
	public static final Color WARNING_FILL = new Color(255, 150, 50);
	public static final Color WARNING_BORDER = new Color(200, 100, 0);

	// Dimensions
	public static final Dimension HEADER_BUTTON_SIZE = new Dimension(30, 25);

	// Icon file names
	public static final String ICON_SMILEY = "smiley.png";
	public static final String ICON_ARROW_LEFT = "arrow-left.png";
	public static final String ICON_ARROW_CLOCKWISE = "arrow-clockwise.png";
	public static final String ICON_ARROWS_CONTRACT = "arrows-angle-contract.png";
	public static final String ICON_ARROWS_EXPAND = "arrows-angle-expand.png";
	public static final String ICON_BOUNDING_BOX = "bounding-box.png";
	public static final String ICON_FOLDER_FILL = "folder-fill.png";
	public static final String ICON_GITHUB = "github.png";
	public static final String ICON_WRENCH = "wrench.png";
	public static final String ICON_WARNING = "exclamation-triangle-fill.png";
	public static final String ICON_DOWNLOAD = "download.png";

}


package com.customemoji.panel;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.UIManager;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.function.Consumer;

/**
 * Search panel with a text field and magnifying glass icon for filtering emojis.
 * Search is triggered when the user presses Enter.
 */
public class SearchPanel extends JPanel
{
	private static final String PLACEHOLDER_TEXT = "Press Enter to search";
	private static final String TEXTFIELD_FOREGROUND = "TextField.foreground";

	private JTextField searchField;
	private JButton clearButton;
	private transient Consumer<String> searchCallback;
	private boolean showingPlaceholder = true;
	private boolean ignoringDocumentChanges = false;

	public SearchPanel(Consumer<String> searchCallback)
	{
		super(new BorderLayout(5, 0));
		this.searchCallback = searchCallback;
		this.setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		this.initializeComponents();
	}

	public String getSearchText()
	{
		if (this.showingPlaceholder)
		{
			return "";
		}
		return this.searchField.getText();
	}

	public void setSearchText(String text)
	{
		if (text == null || text.isEmpty())
		{
			this.clearSearch();
		}
		else
		{
			this.searchField.setText(text);
			this.searchField.setForeground(UIManager.getColor(TEXTFIELD_FOREGROUND));
			this.showingPlaceholder = false;
			this.updateClearButtonVisibility();
		}
	}

	public void clearSearch()
	{
		boolean hadText = !this.showingPlaceholder && !this.searchField.getText().isEmpty();

		this.ignoringDocumentChanges = true;
		if (this.searchField.hasFocus())
		{
			this.searchField.setText("");
			this.searchField.setForeground(UIManager.getColor(TEXTFIELD_FOREGROUND));
			this.showingPlaceholder = false;
		}
		else
		{
			this.searchField.setText(PLACEHOLDER_TEXT);
			this.searchField.setForeground(Color.GRAY);
			this.showingPlaceholder = true;
		}
		this.ignoringDocumentChanges = false;

		this.clearButton.setVisible(false);

		if (hadText && this.searchCallback != null)
		{
			this.searchCallback.accept("");
		}
	}

	private void initializeComponents()
	{
		this.searchField = new JTextField(PLACEHOLDER_TEXT);
		this.searchField.setForeground(Color.GRAY);
		this.searchField.setPreferredSize(new Dimension(200, 25));
		this.searchField.setMinimumSize(new Dimension(200, 25));
		this.searchField.setMaximumSize(new Dimension(200, 25));

		this.setupPlaceholderBehavior();
		this.setupKeyListeners();

		JLabel searchIcon = new JLabel("");
		searchIcon.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 5));

		this.clearButton = new JButton("");
		this.clearButton.setPreferredSize(new Dimension(20, 20));
		this.clearButton.setMargin(new Insets(0, 0, 0, 0));
		this.clearButton.setBorder(BorderFactory.createEmptyBorder());
		this.clearButton.setContentAreaFilled(false);
		this.clearButton.setFocusPainted(false);
		this.clearButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		this.clearButton.setToolTipText("Clear search");
		this.clearButton.setVisible(false);
		this.clearButton.addActionListener(e -> this.clearSearch());

		JPanel searchFieldPanel = new JPanel(new BorderLayout());
		searchFieldPanel.add(searchIcon, BorderLayout.WEST);
		searchFieldPanel.add(this.searchField, BorderLayout.CENTER);
		searchFieldPanel.add(this.clearButton, BorderLayout.EAST);
		searchFieldPanel.setBorder(this.searchField.getBorder());
		searchFieldPanel.setBackground(this.searchField.getBackground());

		this.searchField.setBorder(BorderFactory.createEmptyBorder());

		this.add(searchFieldPanel, BorderLayout.CENTER);
	}

	private void setupPlaceholderBehavior()
	{
		this.searchField.addFocusListener(new FocusListener()
		{
			@Override
			public void focusGained(FocusEvent e)
			{
				if (SearchPanel.this.showingPlaceholder)
				{
					SearchPanel.this.ignoringDocumentChanges = true;
					SearchPanel.this.searchField.setText("");
					SearchPanel.this.ignoringDocumentChanges = false;
					SearchPanel.this.searchField.setForeground(UIManager.getColor(TEXTFIELD_FOREGROUND));
					SearchPanel.this.showingPlaceholder = false;
					SearchPanel.this.updateClearButtonVisibility();
				}
			}

			@Override
			public void focusLost(FocusEvent e)
			{
				if (SearchPanel.this.searchField.getText().isEmpty())
				{
					SearchPanel.this.showingPlaceholder = true;
					SearchPanel.this.ignoringDocumentChanges = true;
					SearchPanel.this.searchField.setText(PLACEHOLDER_TEXT);
					SearchPanel.this.ignoringDocumentChanges = false;
					SearchPanel.this.searchField.setForeground(Color.GRAY);
					SearchPanel.this.clearButton.setVisible(false);
				}
			}
		});

		this.searchField.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				SearchPanel.this.updateClearButtonVisibility();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				SearchPanel.this.updateClearButtonVisibility();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				SearchPanel.this.updateClearButtonVisibility();
			}
		});
	}

	private void setupKeyListeners()
	{
		this.searchField.addKeyListener(new KeyAdapter()
		{
			@Override
			public void keyPressed(KeyEvent e)
			{
				if (e.getKeyCode() == KeyEvent.VK_ENTER)
				{
					SearchPanel.this.performSearch();
				}
				else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
				{
					SearchPanel.this.searchField.transferFocus();
				}
			}
		});
	}

	private void updateClearButtonVisibility()
	{
		if (this.ignoringDocumentChanges)
		{
			return;
		}
		boolean hasText = !this.showingPlaceholder && !this.searchField.getText().isEmpty();
		this.clearButton.setVisible(hasText);
	}

	private void performSearch()
	{
		if (this.searchCallback != null && !this.showingPlaceholder)
		{
			String searchText = this.searchField.getText().toLowerCase().trim();
			this.searchCallback.accept(searchText);
		}
	}
}


package com.customemoji.panel.tree;

import com.customemoji.CustomEmojiPlugin;
import com.customemoji.model.Emoji;

import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Builds and manages the folder structure for the emoji tree.
 */
public class FolderStructureBuilder
{
	public static final String PATH_SEPARATOR = "/";
	public static final String ROOT_FOLDER_NAME = "All Emoji";

	private final Map<String, Emoji> emojis;
	private final Set<String> disabledEmojis;
	private final Set<String> resizingDisabledEmojis;

	private Map<String, List<EmojiTreeNode>> folderContents = new HashMap<>();

	public FolderStructureBuilder(Map<String, Emoji> emojis,
								   Set<String> disabledEmojis,
								   Set<String> resizingDisabledEmojis)
	{
		this.emojis = emojis;
		this.disabledEmojis = disabledEmojis;
		this.resizingDisabledEmojis = resizingDisabledEmojis;
	}

	public Map<String, List<EmojiTreeNode>> build(String searchFilter)
	{
		this.folderContents.clear();
		File emojisFolder = CustomEmojiPlugin.EMOJIS_FOLDER;

		Map<String, Set<String>> subfoldersByPath = new HashMap<>();
		subfoldersByPath.put("", new HashSet<>());
		subfoldersByPath.get("").add(ROOT_FOLDER_NAME);
		subfoldersByPath.put(ROOT_FOLDER_NAME, new HashSet<>());

		for (Map.Entry<String, Emoji> entry : this.emojis.entrySet())
		{
			String emojiName = entry.getKey();
			Emoji emoji = entry.getValue();
			File emojiFile = emoji.getFile();

			boolean matchesFilter = this.matchesSearchFilter(emojiName, emojiFile, emojisFolder, searchFilter);
			if (!matchesFilter)
			{
				continue;
			}

			String relativeFolderPath = this.extractFolderPath(emojiFile, emojisFolder);
			String folderPath = relativeFolderPath.isEmpty()
				? ROOT_FOLDER_NAME
				: ROOT_FOLDER_NAME + PATH_SEPARATOR + relativeFolderPath;
			this.registerParentFolders(folderPath, subfoldersByPath);
			this.addEmojiItem(emojiName, emoji, folderPath);
		}

		this.addFolderItems(subfoldersByPath);
		this.sortFolderContents();

		return this.folderContents;
	}

	public Map<String, List<EmojiTreeNode>> getFolderContents()
	{
		return this.folderContents;
	}

	public boolean calculateFolderEnabled(String folderPath)
	{
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			String path = entry.getKey();
			boolean isInFolder = path.equals(folderPath) || path.startsWith(folderPath + PATH_SEPARATOR);

			if (isInFolder)
			{
				for (EmojiTreeNode item : entry.getValue())
				{
					boolean isEmojiEnabled = !item.isFolder() && item.isEnabled();
					if (isEmojiEnabled)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	public boolean calculateFolderResizingEnabled(String folderPath)
	{
		List<String> enabledEmojiNames = this.getEnabledEmojiNamesInFolder(folderPath);
		boolean hasNoEnabledEmojis = enabledEmojiNames.isEmpty();

		if (hasNoEnabledEmojis)
		{
			return false;
		}

		boolean anyHasResizingDisabled = this.anyEmojiHasResizingDisabled(enabledEmojiNames);
		return !anyHasResizingDisabled;
	}

	public String extractFolderPath(File emojiFile, File baseFolder)
	{
		String relativePath = baseFolder.toPath().relativize(emojiFile.toPath()).toString();
		String[] pathParts = relativePath.split("[\\\\/]");

		StringBuilder folderPath = new StringBuilder();
		for (int i = 0; i < pathParts.length - 1; i++)
		{
			if (folderPath.length() > 0)
			{
				folderPath.append(PATH_SEPARATOR);
			}
			folderPath.append(pathParts[i]);
		}

		return folderPath.toString();
	}

	private boolean matchesSearchFilter(String emojiName, File emojiFile, File emojisFolder, String searchFilter)
	{
		if (searchFilter.isEmpty())
		{
			return true;
		}

		boolean nameMatches = emojiName.toLowerCase().contains(searchFilter);
		if (nameMatches)
		{
			return true;
		}

		return this.folderPathMatchesFilter(emojiFile, emojisFolder, searchFilter);
	}

	private boolean folderPathMatchesFilter(File emojiFile, File emojisFolder, String searchFilter)
	{
		String relativePath = emojisFolder.toPath().relativize(emojiFile.toPath()).toString();
		String[] pathParts = relativePath.split("[\\\\\\/]");

		for (int i = 0; i < pathParts.length - 1; i++)
		{
			boolean folderMatches = pathParts[i].toLowerCase().contains(searchFilter);
			if (folderMatches)
			{
				return true;
			}
		}
		return false;
	}

	private void registerParentFolders(String folderPath, Map<String, Set<String>> subfoldersByPath)
	{
		String[] pathParts = folderPath.isEmpty() ? new String[0] : folderPath.split(PATH_SEPARATOR);
		String currentPathStr = "";

		for (int i = 0; i < pathParts.length; i++)
		{
			String parentPath = currentPathStr;
			currentPathStr = this.appendPathSegment(currentPathStr, pathParts[i]);

			subfoldersByPath.computeIfAbsent(parentPath, k -> new HashSet<>()).add(pathParts[i]);
			subfoldersByPath.computeIfAbsent(currentPathStr, k -> new HashSet<>());
		}
	}

	private String appendPathSegment(String basePath, String segment)
	{
		if (basePath.isEmpty())
		{
			return segment;
		}
		return basePath + PATH_SEPARATOR + segment;
	}

	private void addEmojiItem(String emojiName, Emoji emoji, String folderPath)
	{
		BufferedImage emojiImage = this.loadEmojiImage(emoji);
		boolean failedToLoad = (emojiImage == null);
		boolean isEnabled = !this.disabledEmojis.contains(emojiName);
		boolean isResizingEnabled = !this.resizingDisabledEmojis.contains(emojiName);

		EmojiTreeNode item = EmojiTreeNode.createEmoji(emojiName, isEnabled, isResizingEnabled, emojiImage, failedToLoad);
		this.folderContents.computeIfAbsent(folderPath, k -> new ArrayList<>()).add(item);
	}

	private void addFolderItems(Map<String, Set<String>> subfoldersByPath)
	{
		for (Map.Entry<String, Set<String>> entry : subfoldersByPath.entrySet())
		{
			String parentPath = entry.getKey();
			for (String subfolder : entry.getValue())
			{
				String fullSubfolderPath = parentPath.isEmpty() ? subfolder : parentPath + PATH_SEPARATOR + subfolder;
				boolean isEnabled = this.calculateFolderEnabled(fullSubfolderPath);
				boolean isResizingEnabled = this.calculateFolderResizingEnabled(fullSubfolderPath);
				EmojiTreeNode folderItem = EmojiTreeNode.createFolder(subfolder, isEnabled, isResizingEnabled);
				this.folderContents.computeIfAbsent(parentPath, k -> new ArrayList<>()).add(folderItem);
			}
		}
	}

	private void sortFolderContents()
	{
		for (List<EmojiTreeNode> items : this.folderContents.values())
		{
			items.sort(this::compareTreeNodes);
		}
	}

	private int compareTreeNodes(EmojiTreeNode a, EmojiTreeNode b)
	{
		boolean aIsFolder = a.isFolder();
		boolean bIsFolder = b.isFolder();

		if (aIsFolder && !bIsFolder)
		{
			return -1;
		}
		if (!aIsFolder && bIsFolder)
		{
			return 1;
		}
		return a.getName().compareToIgnoreCase(b.getName());
	}

	private List<String> getEnabledEmojiNamesInFolder(String folderPath)
	{
		List<String> result = new ArrayList<>();

		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (!isInFolder)
			{
				continue;
			}

			for (EmojiTreeNode item : entry.getValue())
			{
				boolean isEnabledEmoji = !item.isFolder() && !this.disabledEmojis.contains(item.getName());
				if (isEnabledEmoji)
				{
					result.add(item.getName());
				}
			}
		}

		return result;
	}

	private boolean isPathInFolder(String path, String folderPath)
	{
		return path.equals(folderPath) || path.startsWith(folderPath + PATH_SEPARATOR);
	}

	private boolean anyEmojiHasResizingDisabled(List<String> emojiNames)
	{
		for (String name : emojiNames)
		{
			if (this.resizingDisabledEmojis.contains(name))
			{
				return true;
			}
		}
		return false;
	}

	private BufferedImage loadEmojiImage(Emoji emoji)
	{
		return emoji.getStaticImage();
	}
}


package com.customemoji.panel.tree;

import javax.swing.JButton;
import javax.swing.JLabel;
import java.util.ArrayList;
import java.util.List;

/**
 * Manages navigation state and header updates for the emoji tree panel.
 */
public class NavigationController
{
	private static final String PATH_SEPARATOR = "/";
	private static final int MAX_RECENTLY_DOWNLOADED_DISPLAY = 50;

	private final JButton backButton;
	private final JLabel pathLabel;
	private final Runnable onNavigationChanged;

	private List<String> currentPath = new ArrayList<>();
	private String currentSearchFilter = "";
	private List<String> recentlyDownloadedEmojis = new ArrayList<>();
	private int totalRecentlyDownloadedCount = 0;

	public NavigationController(JButton backButton, JLabel pathLabel, Runnable onNavigationChanged)
	{
		this.backButton = backButton;
		this.pathLabel = pathLabel;
		this.onNavigationChanged = onNavigationChanged;
	}

	public void navigateToFolder(List<String> path)
	{
		this.currentPath = new ArrayList<>(path);
		this.updateHeader();
		this.onNavigationChanged.run();
	}

	public void navigateBack()
	{
		if (!this.recentlyDownloadedEmojis.isEmpty())
		{
			this.recentlyDownloadedEmojis.clear();
			this.totalRecentlyDownloadedCount = 0;
			this.updateHeader();
			this.onNavigationChanged.run();
			return;
		}

		if (!this.currentPath.isEmpty())
		{
			this.currentPath.remove(this.currentPath.size() - 1);
			this.updateHeader();
			this.onNavigationChanged.run();
		}
	}

	public void navigateToRoot()
	{
		this.currentPath.clear();
		this.updateHeader();
		this.onNavigationChanged.run();
	}

	public void updateHeader()
	{
		boolean isRecentlyDownloaded = !this.recentlyDownloadedEmojis.isEmpty();
		boolean isSearching = !this.currentSearchFilter.isEmpty();
		boolean isAtRoot = this.currentPath.isEmpty();
		this.backButton.setEnabled(isRecentlyDownloaded || (!isAtRoot && !isSearching));

		if (isRecentlyDownloaded)
		{
			boolean hasMore = this.totalRecentlyDownloadedCount > MAX_RECENTLY_DOWNLOADED_DISPLAY;
			String countText = hasMore
				? MAX_RECENTLY_DOWNLOADED_DISPLAY + "+"
				: String.valueOf(this.recentlyDownloadedEmojis.size());
			this.pathLabel.setText("New Emoji (" + countText + ")");
		}
		else if (isSearching)
		{
			this.pathLabel.setText("Search results");
		}
		else if (isAtRoot)
		{
			this.pathLabel.setText("Root");
		}
		else
		{
			String currentFolder = this.currentPath.get(this.currentPath.size() - 1);
			this.pathLabel.setText(currentFolder);
		}
	}

	public String getCurrentFolderPath()
	{
		return String.join(PATH_SEPARATOR, this.currentPath);
	}

	public List<String> getCurrentPath()
	{
		return new ArrayList<>(this.currentPath);
	}

	public void setSearchFilter(String filter)
	{
		this.currentSearchFilter = filter;
		if (!filter.isEmpty())
		{
			this.recentlyDownloadedEmojis.clear();
			this.totalRecentlyDownloadedCount = 0;
		}
		this.updateHeader();
	}

	public String getSearchFilter()
	{
		return this.currentSearchFilter;
	}

	public boolean isSearching()
	{
		return !this.currentSearchFilter.isEmpty();
	}

	public boolean pathExists(java.util.Map<String, ?> folderContents)
	{
		if (this.currentPath.isEmpty())
		{
			return true;
		}
		String pathKey = String.join(PATH_SEPARATOR, this.currentPath);
		return folderContents.containsKey(pathKey);
	}

	public void resetPathIfInvalid(java.util.Map<String, ?> folderContents)
	{
		if (!this.currentPath.isEmpty() && !this.pathExists(folderContents))
		{
			this.currentPath.clear();
		}
	}

	public void setRecentlyDownloadedEmojis(List<String> emojiNames)
	{
		this.totalRecentlyDownloadedCount = emojiNames.size();
		if (emojiNames.size() > MAX_RECENTLY_DOWNLOADED_DISPLAY)
		{
			this.recentlyDownloadedEmojis = new ArrayList<>(emojiNames.subList(0, MAX_RECENTLY_DOWNLOADED_DISPLAY));
		}
		else
		{
			this.recentlyDownloadedEmojis = new ArrayList<>(emojiNames);
		}
		this.currentPath.clear();
	}

	public boolean isShowingRecentlyDownloaded()
	{
		return !this.recentlyDownloadedEmojis.isEmpty();
	}

	public List<String> getRecentlyDownloadedEmojis()
	{
		return new ArrayList<>(this.recentlyDownloadedEmojis);
	}
}


package com.customemoji.panel.tree;

import com.customemoji.CustomEmojiPlugin;
import com.customemoji.panel.PanelConstants;
import net.runelite.client.util.ImageUtil;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

/**
 * Builds row panels for displaying emoji tree items.
 */
public class RowPanelBuilder
{
	private static final int MAX_IMAGE_WIDTH = 20;

	private final EmojiToggleHandler toggleHandler;
	private final Consumer<List<String>> onFolderClicked;
	private final List<String> currentPath;

	public RowPanelBuilder(EmojiToggleHandler toggleHandler,
							Consumer<List<String>> onFolderClicked,
							List<String> currentPath)
	{
		this.toggleHandler = toggleHandler;
		this.onFolderClicked = onFolderClicked;
		this.currentPath = currentPath;
	}

	public JPanel createRowPanel(EmojiTreeNode item, String currentFolderPath)
	{
		JPanel rowPanel = new JPanel(new BorderLayout());
		rowPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);
		rowPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 28));
		rowPanel.setPreferredSize(new Dimension(200, 28));

		JPanel leftPanel = this.createLeftPanel(item);
		JLabel nameLabel = this.createNameLabel(item);
		leftPanel.add(nameLabel);

		rowPanel.add(leftPanel, BorderLayout.CENTER);

		Component toggleControl = this.createToggleControl(item, currentFolderPath);
		rowPanel.add(toggleControl, BorderLayout.EAST);

		if (item.isFolder())
		{
			this.addFolderClickHandler(rowPanel, leftPanel, nameLabel, item);
		}

		return rowPanel;
	}

	private JPanel createLeftPanel(EmojiTreeNode item)
	{
		JPanel leftPanel = new JPanel();
		leftPanel.setLayout(new BoxLayout(leftPanel, BoxLayout.X_AXIS));
		leftPanel.setOpaque(false);
		leftPanel.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));

		if (item.isFolder())
		{
			this.addFolderIcon(leftPanel);
		}
		else if (item.getImage() != null)
		{
			this.addEmojiImage(leftPanel, item.getImage());
		}
		else
		{
			this.addPlaceholderOrWarning(leftPanel, item);
		}

		return leftPanel;
	}

	private void addFolderIcon(JPanel leftPanel)
	{
		JLabel folderIcon = new JLabel(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_FOLDER_FILL)));
		leftPanel.add(folderIcon);
		leftPanel.add(Box.createHorizontalStrut(5));
	}

	private void addEmojiImage(JPanel leftPanel, BufferedImage image)
	{
		BufferedImage displayImage = this.scaleImageForDisplay(image, MAX_IMAGE_WIDTH);
		int imageHeight = displayImage.getHeight();
		int imageWidth = displayImage.getWidth();

		JPanel imageContainer = new JPanel();
		imageContainer.setLayout(new BoxLayout(imageContainer, BoxLayout.X_AXIS));
		imageContainer.setOpaque(false);
		imageContainer.setPreferredSize(new Dimension(MAX_IMAGE_WIDTH, imageHeight));
		imageContainer.setMinimumSize(new Dimension(MAX_IMAGE_WIDTH, imageHeight));
		imageContainer.setMaximumSize(new Dimension(MAX_IMAGE_WIDTH, imageHeight));

		imageContainer.add(Box.createHorizontalGlue());

		JLabel imageLabel = new JLabel(new ImageIcon(displayImage));
		imageLabel.setPreferredSize(new Dimension(imageWidth, imageHeight));
		imageLabel.setMinimumSize(new Dimension(imageWidth, imageHeight));
		imageLabel.setMaximumSize(new Dimension(imageWidth, imageHeight));
		imageContainer.add(imageLabel);

		leftPanel.add(imageContainer);
		leftPanel.add(Box.createHorizontalStrut(5));
	}

	private void addPlaceholderOrWarning(JPanel leftPanel, EmojiTreeNode item)
	{
		if (item.isFailedToLoad())
		{
			JPanel warningContainer = new JPanel();
			warningContainer.setLayout(new BoxLayout(warningContainer, BoxLayout.X_AXIS));
			warningContainer.setOpaque(false);
			warningContainer.setPreferredSize(new Dimension(MAX_IMAGE_WIDTH, 16));
			warningContainer.setMinimumSize(new Dimension(MAX_IMAGE_WIDTH, 16));
			warningContainer.setMaximumSize(new Dimension(MAX_IMAGE_WIDTH, 16));

			warningContainer.add(Box.createHorizontalGlue());

			JLabel warningLabel = new JLabel(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_WARNING)));
			warningLabel.setToolTipText("Failed to load emoji image");
			warningContainer.add(warningLabel);

			leftPanel.add(warningContainer);
			leftPanel.add(Box.createHorizontalStrut(5));
		}
		else
		{
			leftPanel.add(Box.createHorizontalStrut(MAX_IMAGE_WIDTH + 5));
		}
	}

	private JLabel createNameLabel(EmojiTreeNode item)
	{
		JLabel nameLabel = new JLabel(item.getName());
		nameLabel.setToolTipText(item.getName());

		if (item.isFolder())
		{
			nameLabel.setBorder(BorderFactory.createEmptyBorder(3, 0, 0, 0));
		}

		if (item.isEnabled())
		{
			nameLabel.setFont(nameLabel.getFont().deriveFont(Font.BOLD));
			if (item.isFolder())
			{
				nameLabel.setForeground(PanelConstants.FOLDER_TEXT);
			}
			else
			{
				nameLabel.setForeground(PanelConstants.ENABLED_TEXT);
			}
		}
		else
		{
			nameLabel.setFont(nameLabel.getFont().deriveFont(Font.PLAIN));
			nameLabel.setForeground(PanelConstants.DISABLED_TEXT);
		}

		boolean isFailedEmoji = !item.isFolder() && item.isFailedToLoad();
		if (isFailedEmoji)
		{
			nameLabel.setForeground(PanelConstants.WARNING_FILL);
			nameLabel.setText(item.getName() + " (!)");
		}

		return nameLabel;
	}

	private Component createToggleControl(EmojiTreeNode item, String currentFolderPath)
	{
		if (this.toggleHandler.isResizingMode())
		{
			return this.createResizeToggleButton(item, currentFolderPath);
		}
		else
		{
			return this.createEnableCheckbox(item, currentFolderPath);
		}
	}

	private JCheckBox createEnableCheckbox(EmojiTreeNode item, String currentFolderPath)
	{
		JCheckBox checkBox = new JCheckBox();
		checkBox.setOpaque(false);
		checkBox.setFocusable(false);
		checkBox.setSelected(item.isEnabled());
		checkBox.addActionListener(e -> this.toggleHandler.handleItemToggle(item, checkBox.isSelected(), currentFolderPath));
		return checkBox;
	}

	private JButton createResizeToggleButton(EmojiTreeNode item, String currentFolderPath)
	{
		boolean isResizingEnabled = item.isResizingEnabled();
		String iconName = isResizingEnabled ? PanelConstants.ICON_ARROWS_CONTRACT : PanelConstants.ICON_ARROWS_EXPAND;

		JButton button = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, iconName)));
		button.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		button.setMargin(new Insets(0, 0, 0, 0));
		button.setFocusable(false);

		boolean isDisabledEmoji = !item.isFolder() && !item.isEnabled();
		if (this.toggleHandler.isLoading())
		{
			button.setEnabled(false);
			button.setToolTipText("Loading...");
		}
		else if (isDisabledEmoji)
		{
			button.setEnabled(false);
			button.setToolTipText("Enable this emoji first to configure resizing");
		}
		else
		{
			String tooltip = isResizingEnabled ? "Resize enabled (click to disable)" : "Resize disabled (click to enable)";
			button.setToolTipText(tooltip);
		}

		button.addActionListener(e -> this.toggleHandler.handleItemToggle(item, !item.isResizingEnabled(), currentFolderPath));

		return button;
	}

	private void addFolderClickHandler(JPanel rowPanel, JPanel leftPanel, JLabel nameLabel, EmojiTreeNode item)
	{
		rowPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		leftPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

		MouseAdapter folderClickHandler = new MouseAdapter()
		{
			@Override
			public void mouseReleased(MouseEvent e)
			{
				List<String> newPath = new ArrayList<>(currentPath);
				newPath.add(item.getName());
				onFolderClicked.accept(newPath);
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				rowPanel.setBackground(PanelConstants.ROW_HOVER_BACKGROUND);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				rowPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);
			}
		};

		leftPanel.addMouseListener(folderClickHandler);
		nameLabel.addMouseListener(folderClickHandler);
	}

	private BufferedImage scaleImageForDisplay(BufferedImage image, int maxSize)
	{
		int width = image.getWidth();
		int height = image.getHeight();

		boolean needsScaling = width > maxSize || height > maxSize;
		if (!needsScaling)
		{
			return image;
		}

		double scale = Math.min((double) maxSize / width, (double) maxSize / height);
		int newWidth = (int) Math.round(width * scale);
		int newHeight = (int) Math.round(height * scale);

		return ImageUtil.resizeImage(image, newWidth, newHeight);
	}
}


package com.customemoji.panel.tree;

import com.customemoji.service.EmojiStateManager;

import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Handles toggle operations for enabling/disabling emojis and resizing mode.
 */
public class EmojiToggleHandler
{
	public static final String PATH_SEPARATOR = "/";
	public static final String MODE_ENABLE_DISABLE = "Enable/Disable";
	public static final String MODE_RESIZING = "Resizing";

	private final EmojiStateManager emojiStateManager;
	private final Runnable onContentRefreshNeeded;
	private final Runnable onFolderStatesUpdateNeeded;
	private final JScrollPane scrollPane;
	private final JPanel contentPanel;

	private String currentMode = MODE_ENABLE_DISABLE;
	private boolean isLoading = false;

	private Map<String, List<EmojiTreeNode>> folderContents;

	public EmojiToggleHandler(EmojiStateManager emojiStateManager,
							   JScrollPane scrollPane,
							   JPanel contentPanel,
							   Runnable onContentRefreshNeeded,
							   Runnable onFolderStatesUpdateNeeded)
	{
		this.emojiStateManager = emojiStateManager;
		this.scrollPane = scrollPane;
		this.contentPanel = contentPanel;
		this.onContentRefreshNeeded = onContentRefreshNeeded;
		this.onFolderStatesUpdateNeeded = onFolderStatesUpdateNeeded;
	}

	public void setFolderContents(Map<String, List<EmojiTreeNode>> folderContents)
	{
		this.folderContents = folderContents;
	}

	public String getCurrentMode()
	{
		return this.currentMode;
	}

	public void setCurrentMode(String mode)
	{
		this.currentMode = mode;
	}

	public boolean isResizingMode()
	{
		return MODE_RESIZING.equals(this.currentMode);
	}

	public void toggleMode()
	{
		boolean isCurrentlyResizeMode = MODE_RESIZING.equals(this.currentMode);
		this.currentMode = isCurrentlyResizeMode ? MODE_ENABLE_DISABLE : MODE_RESIZING;
	}

	public boolean isLoading()
	{
		return this.isLoading;
	}

	public void handleItemToggle(EmojiTreeNode item, boolean checked, String currentFolderPath)
	{
		if (this.isResizingMode())
		{
			this.handleResizingToggle(item, checked, currentFolderPath);
		}
		else
		{
			this.handleEnableDisableToggle(item, checked, currentFolderPath);
		}
	}

	public void updateAllFolderStates(FolderStructureBuilder structureBuilder)
	{
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			String parentPath = entry.getKey();
			for (EmojiTreeNode item : entry.getValue())
			{
				if (item.isFolder())
				{
					String fullPath = parentPath.isEmpty() ? item.getName() : parentPath + PATH_SEPARATOR + item.getName();
					item.setEnabled(structureBuilder.calculateFolderEnabled(fullPath));
					item.setResizingEnabled(structureBuilder.calculateFolderResizingEnabled(fullPath));
				}
			}
		}
	}

	private void handleEnableDisableToggle(EmojiTreeNode item, boolean enabled, String currentFolderPath)
	{
		item.setEnabled(enabled);

		if (item.isFolder())
		{
			String targetPath = currentFolderPath.isEmpty() ? item.getName() : currentFolderPath + PATH_SEPARATOR + item.getName();
			Set<String> emojisToToggle = this.collectFolderEmojis(targetPath);
			this.updateFolderEmojiNodes(targetPath, enabled);

			this.emojiStateManager.setMultipleEmojisEnabled(emojisToToggle, enabled);

			this.onFolderStatesUpdateNeeded.run();
			int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
			this.onContentRefreshNeeded.run();
			SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(scrollPosition));
		}
		else
		{
			this.emojiStateManager.setEmojiEnabled(item.getName(), enabled);

			this.onFolderStatesUpdateNeeded.run();
			int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
			this.onContentRefreshNeeded.run();
			SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(scrollPosition));
		}
	}

	private void handleResizingToggle(EmojiTreeNode item, boolean resizingEnabled, String currentFolderPath)
	{
		if (this.isLoading)
		{
			return;
		}

		this.isLoading = true;
		item.setResizingEnabled(resizingEnabled);

		if (item.isFolder())
		{
			this.handleFolderResizingToggle(item, resizingEnabled, currentFolderPath);
		}
		else
		{
			this.handleSingleEmojiResizingToggle(item, resizingEnabled);
		}
	}

	private void handleSingleEmojiResizingToggle(EmojiTreeNode item, boolean resizingEnabled)
	{
		int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
		this.disableAllButtons();

		this.emojiStateManager.setEmojiResizing(item.getName(), resizingEnabled);

		SwingUtilities.invokeLater(() ->
		{
			this.isLoading = false;
			this.onContentRefreshNeeded.run();
			SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(scrollPosition));
		});
	}

	private void handleFolderResizingToggle(EmojiTreeNode item, boolean resizingEnabled, String currentFolderPath)
	{
		int scrollPosition = this.scrollPane.getVerticalScrollBar().getValue();
		this.disableAllButtons();

		String targetPath = currentFolderPath.isEmpty() ? item.getName() : currentFolderPath + PATH_SEPARATOR + item.getName();
		Set<String> emojisToToggle = this.collectEnabledFolderEmojis(targetPath);
		this.updateFolderEmojiResizingNodes(targetPath, resizingEnabled);

		this.emojiStateManager.setMultipleEmojisResizing(emojisToToggle, resizingEnabled);

		SwingUtilities.invokeLater(() ->
		{
			this.isLoading = false;
			this.onFolderStatesUpdateNeeded.run();
			this.onContentRefreshNeeded.run();
			this.scrollPane.getVerticalScrollBar().setValue(scrollPosition);
		});
	}

	private Set<String> collectFolderEmojis(String folderPath)
	{
		Set<String> emojis = new HashSet<>();
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (isInFolder)
			{
				for (EmojiTreeNode item : entry.getValue())
				{
					if (!item.isFolder())
					{
						emojis.add(item.getName());
					}
				}
			}
		}
		return emojis;
	}

	private Set<String> collectEnabledFolderEmojis(String folderPath)
	{
		Set<String> emojis = new HashSet<>();
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (isInFolder)
			{
				for (EmojiTreeNode item : entry.getValue())
				{
					boolean isEnabledEmoji = !item.isFolder() && item.isEnabled();
					if (isEnabledEmoji)
					{
						emojis.add(item.getName());
					}
				}
			}
		}
		return emojis;
	}

	private void updateFolderEmojiNodes(String folderPath, boolean enabled)
	{
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (isInFolder)
			{
				for (EmojiTreeNode item : entry.getValue())
				{
					if (!item.isFolder())
					{
						item.setEnabled(enabled);
					}
				}
			}
		}
	}

	private void updateFolderEmojiResizingNodes(String folderPath, boolean resizingEnabled)
	{
		for (Map.Entry<String, List<EmojiTreeNode>> entry : this.folderContents.entrySet())
		{
			boolean isInFolder = this.isPathInFolder(entry.getKey(), folderPath);
			if (isInFolder)
			{
				for (EmojiTreeNode item : entry.getValue())
				{
					boolean isEnabledEmoji = !item.isFolder() && item.isEnabled();
					if (isEnabledEmoji)
					{
						item.setResizingEnabled(resizingEnabled);
					}
				}
			}
		}
	}

	private boolean isPathInFolder(String path, String folderPath)
	{
		boolean isExactMatch = path.equals(folderPath);
		boolean isSubfolder = path.startsWith(folderPath + PATH_SEPARATOR);
		return isExactMatch || isSubfolder;
	}

	private void disableAllButtons()
	{
		for (Component component : this.contentPanel.getComponents())
		{
			boolean isRowPanel = component instanceof JPanel;
			if (!isRowPanel)
			{
				continue;
			}

			JPanel rowPanel = (JPanel) component;
			for (Component child : rowPanel.getComponents())
			{
				boolean isButton = child instanceof JButton;
				if (isButton)
				{
					JButton button = (JButton) child;
					button.setEnabled(false);
					button.paintImmediately(button.getBounds());
				}
			}
		}
	}
}

package com.customemoji.panel.tree;

import java.awt.image.BufferedImage;

/**
 * Represents a node in the emoji tree structure.
 * Can be either a folder or an individual emoji.
 */
public class EmojiTreeNode
{
	private final String name;
	private final boolean isFolder;
	private boolean isEnabled;
	private boolean resizingEnabled;
	private BufferedImage image;
	private final boolean failedToLoad;

	private EmojiTreeNode(String name, boolean isFolder, boolean isEnabled,
						  boolean resizingEnabled, BufferedImage image, boolean failedToLoad)
	{
		this.name = name;
		this.isFolder = isFolder;
		this.isEnabled = isEnabled;
		this.resizingEnabled = resizingEnabled;
		this.image = image;
		this.failedToLoad = failedToLoad;
	}

	public static EmojiTreeNode createFolder(String name, boolean enabled, boolean resizingEnabled)
	{
		return new EmojiTreeNode(name, true, enabled, resizingEnabled, null, false);
	}

	public static EmojiTreeNode createEmoji(String name, boolean enabled, boolean resizingEnabled,
											BufferedImage image, boolean failedToLoad)
	{
		return new EmojiTreeNode(name, false, enabled, resizingEnabled, image, failedToLoad);
	}

	public String getName()
	{
		return this.name;
	}

	public boolean isFolder()
	{
		return this.isFolder;
	}

	public boolean isEnabled()
	{
		return this.isEnabled;
	}

	public void setEnabled(boolean enabled)
	{
		this.isEnabled = enabled;
	}

	public boolean isResizingEnabled()
	{
		return this.resizingEnabled;
	}

	public void setResizingEnabled(boolean resizingEnabled)
	{
		this.resizingEnabled = resizingEnabled;
	}

	public BufferedImage getImage()
	{
		return this.image;
	}

	public void setImage(BufferedImage image)
	{
		this.image = image;
	}

	public boolean isFailedToLoad()
	{
		return this.failedToLoad;
	}

	@Override
	public String toString()
	{
		return this.name;
	}
}


package com.customemoji.panel.tree;

import com.customemoji.CustomEmojiPlugin;
import com.customemoji.io.GitHubEmojiDownloader.DownloadProgress;
import com.customemoji.model.Emoji;
import com.customemoji.panel.DownloadProgressPanel;
import com.customemoji.panel.PanelConstants;
import com.customemoji.panel.StatusMessagePanel;
import com.customemoji.service.EmojiStateManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.util.function.Supplier;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Panel containing an explorer-style emoji browser with folder navigation.
 */
public class EmojiTreePanel extends JPanel
{
	private final Map<String, Emoji> emojis;
	private final EmojiStateManager emojiStateManager;

	private Set<String> disabledEmojis;
	private Set<String> resizingDisabledEmojis;
	private JPanel contentPanel;
	private JScrollPane scrollPane;
	private JButton resizeModeButton;
	private JButton downloadButton;
	private DownloadProgressPanel downloadProgressPanel;
	private StatusMessagePanel statusMessagePanel;
	private transient Runnable onDownloadClicked;
	private transient Runnable onReloadClicked;
	private transient FolderStructureBuilder structureBuilder;
	private transient NavigationController navigationController;
	private transient EmojiToggleHandler toggleHandler;
	private transient Map<String, List<EmojiTreeNode>> folderContents = new HashMap<>();

	@Inject
	public EmojiTreePanel(Map<String, Emoji> emojis, EmojiStateManager emojiStateManager)
	{
		this.emojis = emojis;
		this.emojiStateManager = emojiStateManager;
		this.disabledEmojis = this.emojiStateManager.getDisabledEmojis();
		this.resizingDisabledEmojis = this.emojiStateManager.getResizingDisabledEmojis();

		this.setLayout(new BorderLayout());
		this.initializeComponents();
		this.buildFolderStructure();
		this.navigationController.navigateToFolder(new ArrayList<>());
	}

	public void setSearchFilter(String filter)
	{
		String normalizedFilter = filter.toLowerCase().trim();
		if (!normalizedFilter.equals(this.navigationController.getSearchFilter()))
		{
			this.navigationController.setSearchFilter(normalizedFilter);
			this.rebuildAndRefresh();
		}
	}

	public void clearSearchFilter()
	{
		this.navigationController.setSearchFilter("");
	}

	public void updateDisabledEmojis(Set<String> disabledEmojis)
	{
		this.disabledEmojis = new HashSet<>(disabledEmojis);
		this.rebuildAndRefresh();
	}

	public Set<String> getDisabledEmojis()
	{
		return new HashSet<>(this.disabledEmojis);
	}

	public void updateResizingDisabledEmojis(Set<String> resizingDisabledEmojis)
	{
		this.resizingDisabledEmojis = new HashSet<>(resizingDisabledEmojis);
		this.rebuildAndRefresh();
	}

	public Set<String> getResizingDisabledEmojis()
	{
		return new HashSet<>(this.resizingDisabledEmojis);
	}

	private void initializeComponents()
	{
		this.contentPanel = new JPanel();
		this.contentPanel.setLayout(new BoxLayout(this.contentPanel, BoxLayout.Y_AXIS));
		this.contentPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);

		this.scrollPane = new JScrollPane(this.contentPanel);
		this.scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		this.scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		this.scrollPane.setBorder(BorderFactory.createEmptyBorder());
		this.scrollPane.getViewport().setBackground(PanelConstants.CONTENT_BACKGROUND);

		this.toggleHandler = new EmojiToggleHandler(
			this.emojiStateManager,
			this.scrollPane,
			this.contentPanel,
			this::updateContent,
			this::updateAllFolderStates
		);

		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBackground(PanelConstants.HEADER_BACKGROUND);
		headerPanel.setBorder(BorderFactory.createMatteBorder(0, 0, 1, 0, PanelConstants.HEADER_BORDER));

		JButton backButton = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_ARROW_LEFT)));
		backButton.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		backButton.setMaximumSize(PanelConstants.HEADER_BUTTON_SIZE);
		backButton.setFocusable(false);
		backButton.setEnabled(false);
		backButton.setToolTipText("Go back a directory");

		JLabel pathLabel = new JLabel("Emojis");
		pathLabel.setForeground(PanelConstants.FOLDER_TEXT);
		pathLabel.setFont(pathLabel.getFont().deriveFont(Font.BOLD));

		this.navigationController = new NavigationController(backButton, pathLabel, this::updateContent);
		backButton.addActionListener(e -> this.navigationController.navigateBack());

		this.resizeModeButton = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_BOUNDING_BOX)));
		this.resizeModeButton.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		this.resizeModeButton.setMaximumSize(PanelConstants.HEADER_BUTTON_SIZE);
		this.resizeModeButton.setFocusable(false);
		this.resizeModeButton.setToolTipText("Toggle resize mode");
		this.updateResizeModeButtonColor();
		this.resizeModeButton.addActionListener(e ->
		{
			this.toggleHandler.toggleMode();
			this.updateResizeModeButtonColor();
			this.buildFolderStructure();
			this.updateContent();
		});

		JButton refreshButton = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_ARROW_CLOCKWISE)));
		refreshButton.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		refreshButton.setMaximumSize(PanelConstants.HEADER_BUTTON_SIZE);
		refreshButton.setFocusable(false);
		refreshButton.setToolTipText("Reload all emojis");
		refreshButton.addActionListener(e ->
		{
			if (this.onReloadClicked != null)
			{
				this.onReloadClicked.run();
			}
		});

		this.downloadButton = new JButton(new ImageIcon(ImageUtil.loadImageResource(CustomEmojiPlugin.class, PanelConstants.ICON_DOWNLOAD)));
		this.downloadButton.setPreferredSize(PanelConstants.HEADER_BUTTON_SIZE);
		this.downloadButton.setMaximumSize(PanelConstants.HEADER_BUTTON_SIZE);
		this.downloadButton.setFocusable(false);
		this.downloadButton.setToolTipText("Download emojis from GitHub");
		this.downloadButton.setVisible(false);
		this.downloadButton.addActionListener(e ->
		{
			if (this.onDownloadClicked != null)
			{
				this.onDownloadClicked.run();
			}
		});

		JPanel navPanel = new JPanel();
		navPanel.setLayout(new BoxLayout(navPanel, BoxLayout.X_AXIS));
		navPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);
		navPanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 4, 0));
		navPanel.add(backButton);
		navPanel.add(Box.createHorizontalStrut(4));
		navPanel.add(refreshButton);
		navPanel.add(Box.createHorizontalStrut(4));
		navPanel.add(this.downloadButton);
		navPanel.add(Box.createHorizontalStrut(4));
		navPanel.add(this.resizeModeButton);
		navPanel.add(Box.createHorizontalStrut(8));
		navPanel.add(pathLabel);

		headerPanel.add(navPanel, BorderLayout.CENTER);

		this.downloadProgressPanel = new DownloadProgressPanel();
		this.statusMessagePanel = new StatusMessagePanel();

		JPanel bottomPanel = new JPanel();
		bottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));
		bottomPanel.setBackground(PanelConstants.CONTENT_BACKGROUND);
		bottomPanel.add(this.downloadProgressPanel);
		bottomPanel.add(this.statusMessagePanel);

		this.add(headerPanel, BorderLayout.NORTH);
		this.add(this.scrollPane, BorderLayout.CENTER);
		this.add(bottomPanel, BorderLayout.SOUTH);
	}

	private void buildFolderStructure()
	{
		this.structureBuilder = new FolderStructureBuilder(
			this.emojis,
			this.disabledEmojis,
			this.resizingDisabledEmojis
		);
		this.folderContents = this.structureBuilder.build(this.navigationController.getSearchFilter());
		this.toggleHandler.setFolderContents(this.folderContents);
	}

	private void updateAllFolderStates()
	{
		this.toggleHandler.updateAllFolderStates(this.structureBuilder);
	}

	private void updateContent()
	{
		this.contentPanel.removeAll();

		List<EmojiTreeNode> items = this.getItemsForCurrentView();

		String currentFolderPath = this.navigationController.getCurrentFolderPath();
		RowPanelBuilder rowBuilder = new RowPanelBuilder(
			this.toggleHandler,
			this.navigationController::navigateToFolder,
			this.navigationController.getCurrentPath()
		);

		for (EmojiTreeNode item : items)
		{
			JPanel rowPanel = rowBuilder.createRowPanel(item, currentFolderPath);
			this.contentPanel.add(rowPanel);
		}

		this.contentPanel.add(Box.createVerticalGlue());

		this.contentPanel.revalidate();
		this.contentPanel.repaint();

		SwingUtilities.invokeLater(() -> this.scrollPane.getVerticalScrollBar().setValue(0));
	}

	private List<EmojiTreeNode> getItemsForCurrentView()
	{
		if (this.navigationController.isShowingRecentlyDownloaded())
		{
			return this.getRecentlyDownloadedItems();
		}

		if (this.navigationController.isSearching())
		{
			List<EmojiTreeNode> items = new ArrayList<>();
			for (List<EmojiTreeNode> folderItems : this.folderContents.values())
			{
				for (EmojiTreeNode item : folderItems)
				{
					if (!item.isFolder())
					{
						items.add(item);
					}
				}
			}
			items.sort((a, b) -> a.getName().compareToIgnoreCase(b.getName()));
			return items;
		}
		else
		{
			String pathKey = this.navigationController.getCurrentFolderPath();
			return this.folderContents.getOrDefault(pathKey, new ArrayList<>());
		}
	}

	private List<EmojiTreeNode> getRecentlyDownloadedItems()
	{
		List<String> emojiNames = this.navigationController.getRecentlyDownloadedEmojis();
		List<EmojiTreeNode> items = new ArrayList<>();

		for (List<EmojiTreeNode> folderItems : this.folderContents.values())
		{
			for (EmojiTreeNode item : folderItems)
			{
				boolean isMatchingEmoji = !item.isFolder() && emojiNames.contains(item.getName());
				if (isMatchingEmoji)
				{
					items.add(item);
				}
			}
		}

		items.sort((a, b) -> a.getName().compareToIgnoreCase(b.getName()));
		return items;
	}

	private void rebuildAndRefresh()
	{
		Runnable task = () ->
		{
			this.buildFolderStructure();

			this.navigationController.resetPathIfInvalid(this.folderContents);

			this.navigationController.updateHeader();
			this.updateContent();
		};

		if (SwingUtilities.isEventDispatchThread())
		{
			task.run();
		}
		else
		{
			SwingUtilities.invokeLater(task);
		}
	}

	private void updateResizeModeButtonColor()
	{
		boolean isResizeMode = this.toggleHandler.isResizingMode();
		if (isResizeMode)
		{
			this.resizeModeButton.setBorder(BorderFactory.createMatteBorder(0, 0, 2, 0, Color.GREEN));
			this.resizeModeButton.setToolTipText("Resize mode active - click to switch to enable/disable mode");
		}
		else
		{
			this.resizeModeButton.setBorder(BorderFactory.createEmptyBorder());
			this.resizeModeButton.setToolTipText("Click to toggle resize mode");
		}
	}

	public void setOnDownloadClicked(Runnable callback)
	{
		this.onDownloadClicked = callback;
	}

	public void setOnReloadClicked(Runnable callback)
	{
		this.onReloadClicked = callback;
	}

	public void setDownloadButtonVisible(boolean visible)
	{
		this.downloadButton.setVisible(visible);
	}

	public void setProgressSupplier(Supplier<DownloadProgress> progressSupplier)
	{
		this.downloadProgressPanel.setProgressSupplier(progressSupplier);
	}

	public void stopProgressPolling()
	{
		this.downloadProgressPanel.stopPolling();
	}

	public void showStatusMessage(String message, StatusMessagePanel.MessageType type)
	{
		this.statusMessagePanel.showMessage(message, type);
	}

	public void showStatusMessage(String message, StatusMessagePanel.MessageType type, boolean autoDismiss)
	{
		this.statusMessagePanel.showMessage(message, type, autoDismiss);
	}

	public void showRecentlyDownloaded(List<String> emojiNames)
	{
		this.navigationController.setRecentlyDownloadedEmojis(emojiNames);
		this.rebuildAndRefresh();
	}
}


package com.customemoji.panel;

import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import java.awt.BorderLayout;
import java.awt.Color;

public class StatusMessagePanel extends JPanel
{
	private static final int AUTO_DISMISS_MS = 5000;
	private static final Color SUCCESS_COLOR = new Color(0, 200, 83);
	private static final Color WARNING_COLOR = new Color(255, 150, 50);
	private static final Color ERROR_COLOR = new Color(255, 80, 80);
	private static final Color INFO_COLOR = new Color(150, 150, 150);

	private final JLabel messageLabel;
	private Timer dismissTimer;

	public enum MessageType
	{
		SUCCESS,
		WARNING,
		ERROR,
		INFO
	}

	public StatusMessagePanel()
	{
		this.setLayout(new BorderLayout());
		this.setBackground(PanelConstants.CONTENT_BACKGROUND);
		this.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createMatteBorder(1, 0, 0, 0, PanelConstants.HEADER_BORDER),
			BorderFactory.createEmptyBorder(6, 8, 6, 8)
		));

		this.messageLabel = new JLabel();
		this.messageLabel.setForeground(Color.WHITE);
		this.add(this.messageLabel, BorderLayout.CENTER);

		this.setVisible(false);
	}

	public void showMessage(String message, MessageType type)
	{
		this.showMessage(message, type, true);
	}

	public void showMessage(String message, MessageType type, boolean autoDismiss)
	{
		SwingUtilities.invokeLater(() ->
		{
			this.cancelPendingDismiss();

			Color color = this.getColorForType(type);
			this.messageLabel.setForeground(color);
			this.messageLabel.setText(this.wrapText(message));

			this.setVisible(true);
			this.revalidate();
			this.repaint();

			if (autoDismiss)
			{
				this.scheduleDismiss();
			}
		});
	}

	public void dismiss()
	{
		SwingUtilities.invokeLater(() ->
		{
			this.cancelPendingDismiss();
			this.setVisible(false);
			this.revalidate();
			this.repaint();
		});
	}

	private Color getColorForType(MessageType type)
	{
		switch (type)
		{
			case SUCCESS:
				return SUCCESS_COLOR;
			case WARNING:
				return WARNING_COLOR;
			case ERROR:
				return ERROR_COLOR;
			case INFO:
			default:
				return INFO_COLOR;
		}
	}

	private String wrapText(String message)
	{
		return "<html><body style='width: 200px'>" + message + "</body></html>";
	}

	private void scheduleDismiss()
	{
		this.dismissTimer = new Timer(AUTO_DISMISS_MS, e -> this.dismiss());
		this.dismissTimer.setRepeats(false);
		this.dismissTimer.start();
	}

	private void cancelPendingDismiss()
	{
		if (this.dismissTimer != null)
		{
			this.dismissTimer.stop();
			this.dismissTimer = null;
		}
	}
}

package com.customemoji.panel;

import com.customemoji.CustomEmojiPlugin;
import com.customemoji.io.GitHubEmojiDownloader.DownloadProgress;
import com.customemoji.panel.tree.EmojiTreePanel;
import com.customemoji.service.EmojiStateManager;
import com.google.inject.Provider;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Supplier;

/**
 * Panel for managing custom emojis with a tree view showing folders and individual emojis.
 * Supports searching by emoji name or folder name, checkbox enabling/disabling, and
 * persistent configuration storage.
 */
public class CustomEmojiPanel extends PluginPanel
{
	private final CustomEmojiPlugin plugin;
	private final EmojiStateManager emojiStateManager;
	private Set<String> disabledEmojis = new HashSet<>();
	private Set<String> resizingDisabledEmojis = new HashSet<>();
	private List<String> pendingRecentlyDownloaded = new ArrayList<>();
	private SearchPanel searchPanel;
	private EmojiTreePanel emojiTreePanel;

	@Inject
	public CustomEmojiPanel(CustomEmojiPlugin plugin, EmojiStateManager emojiStateManager,
							Provider<EmojiTreePanel> emojiTreePanelProvider)
	{
		this.plugin = plugin;
		this.emojiStateManager = emojiStateManager;
		this.disabledEmojis = this.emojiStateManager.getDisabledEmojis();
		this.resizingDisabledEmojis = this.emojiStateManager.getResizingDisabledEmojis();

		this.setLayout(new BorderLayout());
		this.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		this.setMinimumSize(new Dimension(150, 100));

		this.searchPanel = new SearchPanel(this::onSearchChanged);
		this.emojiTreePanel = emojiTreePanelProvider.get();
		this.emojiTreePanel.setOnDownloadClicked(this.plugin::triggerGitHubDownloadAndReload);
		this.emojiTreePanel.setOnReloadClicked(() -> this.plugin.scheduleReload(true));
		this.emojiTreePanel.setDownloadButtonVisible(this.plugin.isGitHubDownloadConfigured());

		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.add(new HeaderPanel(plugin::openConfiguration), BorderLayout.NORTH);
		topPanel.add(this.searchPanel, BorderLayout.CENTER);

		this.add(topPanel, BorderLayout.NORTH);
		this.add(this.emojiTreePanel, BorderLayout.CENTER);
	}

	@Override
	public Dimension getPreferredSize()
	{
		return this.getPanelDimension();
	}

	@Override
	public Dimension getMaximumSize()
	{
		return this.getPanelDimension();
	}

	@Override
	public Dimension getMinimumSize()
	{
		return new Dimension(200, 150);
	}

	public void refreshEmojiTree()
	{
		this.refreshEmojiTree(true);
	}

	public void refreshEmojiTree(boolean clearSearch)
	{
		this.disabledEmojis = this.emojiStateManager.getDisabledEmojis();
		this.resizingDisabledEmojis = this.emojiStateManager.getResizingDisabledEmojis();

		if (clearSearch)
		{
			this.searchPanel.clearSearch();
			this.emojiTreePanel.clearSearchFilter();
		}

		this.emojiTreePanel.updateDisabledEmojis(this.disabledEmojis);
		this.emojiTreePanel.updateResizingDisabledEmojis(this.resizingDisabledEmojis);

		if (!this.pendingRecentlyDownloaded.isEmpty())
		{
			List<String> toShow = new ArrayList<>(this.pendingRecentlyDownloaded);
			this.pendingRecentlyDownloaded.clear();
			this.emojiTreePanel.showRecentlyDownloaded(toShow);
		}
	}

	public void setPendingRecentlyDownloaded(List<String> emojiNames)
	{
		this.pendingRecentlyDownloaded = new ArrayList<>(emojiNames);
	}

	public Set<String> getDisabledEmojis()
	{
		return new HashSet<>(this.disabledEmojis);
	}

	public void updateFromConfig()
	{
		this.refreshEmojiTree(false);
		this.emojiTreePanel.setDownloadButtonVisible(this.plugin.isGitHubDownloadConfigured());
	}

	public void setProgressSupplier(Supplier<DownloadProgress> progressSupplier)
	{
		this.emojiTreePanel.setProgressSupplier(progressSupplier);
	}

	public void stopProgressPolling()
	{
		this.emojiTreePanel.stopProgressPolling();
	}

	public void showStatusMessage(String message, StatusMessagePanel.MessageType type)
	{
		this.emojiTreePanel.showStatusMessage(message, type);
	}

	public void showStatusMessage(String message, StatusMessagePanel.MessageType type, boolean autoDismiss)
	{
		this.emojiTreePanel.showStatusMessage(message, type, autoDismiss);
	}

	private void onSearchChanged(String searchText)
	{
		this.emojiTreePanel.setSearchFilter(searchText);
	}

	private Dimension getPanelDimension()
	{
		Container parent = this.getParent();
		if (parent != null && parent.getSize().width > 0 && parent.getSize().height > 0)
		{
			return new Dimension(parent.getSize().width - 5, parent.getSize().height - 5);
		}
		return new Dimension(245, 395);
	}
}

package com.customemoji.animation;

import com.customemoji.PluginUtils;

import lombok.extern.slf4j.Slf4j;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataNode;
import javax.imageio.stream.ImageInputStream;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.w3c.dom.NodeList;

@Slf4j
public class GifAnimation implements Closeable
{
	private static final int DEFAULT_FRAME_DELAY_MS = 100;
	private static final int INITIAL_CAPACITY = 16;

	private static final String DISPOSAL_NONE = "none";
	private static final String DISPOSAL_DO_NOT_DISPOSE = "doNotDispose";
	private static final String DISPOSAL_RESTORE_TO_BACKGROUND = "restoreToBackgroundColor";
	private static final String DISPOSAL_RESTORE_TO_PREVIOUS = "restoreToPrevious";

	private byte[] gifData;
	private final int maxHeight;
	private final boolean shouldResize;
	private final boolean useLazyLoading;

	private ImageInputStream imageStream;
	private ImageReader reader;

	private BufferedImage canvas;
	private BufferedImage savedCanvas;
	private int canvasWidth;
	private int canvasHeight;
	private String previousDisposalMethod;
	private Rectangle previousFrameBounds;

	private final List<BufferedImage> frames = new ArrayList<>(INITIAL_CAPACITY);
	private final List<Integer> frameDelays = new ArrayList<>(INITIAL_CAPACITY);

	private int currentFrameIndex;
	private long lastFrameChangeTime;

	private boolean initialized;
	private boolean disposed;
	private boolean allFramesLoaded;
	private boolean backgroundLoadingStarted;
	private boolean preloadingInProgress;

	public GifAnimation(byte[] gifData, int maxHeight, boolean shouldResize, boolean useLazyLoading)
	{
		this.gifData = gifData;
		this.maxHeight = maxHeight;
		this.shouldResize = shouldResize;
		this.useLazyLoading = useLazyLoading;
		this.lastFrameChangeTime = System.currentTimeMillis();
		this.currentFrameIndex = 0;
		this.initialized = false;
		this.disposed = false;
		this.allFramesLoaded = false;
		this.backgroundLoadingStarted = false;
		this.preloadingInProgress = false;
	}

	public synchronized BufferedImage getCurrentFrame()
	{
		if (!this.ensureInitialized())
		{
			return null;
		}

		if (this.frames.isEmpty())
		{
			return null;
		}

		if (this.allFramesLoaded && this.frames.size() == 1)
		{
			return this.frames.get(0);
		}

		int frameIndex = this.calculateCurrentFrameIndex();
		return this.frames.get(frameIndex);
	}

	public synchronized boolean needsPreloading()
	{
		if (!this.useLazyLoading || this.allFramesLoaded || this.preloadingInProgress)
		{
			return false;
		}

		int loadedCount = this.frames.size();
		int framesRemaining = loadedCount - this.currentFrameIndex - 1;
		boolean needsMoreFrames = framesRemaining < 5;

		return needsMoreFrames;
	}

	public void preloadFrames()
	{
		synchronized (this)
		{
			if (this.preloadingInProgress || this.allFramesLoaded)
			{
				return;
			}
			this.preloadingInProgress = true;
		}

		try
		{
			for (int i = 0; i < 5 && !this.allFramesLoaded; i++)
			{
				this.loadNextFrame();
			}
		}
		finally
		{
			synchronized (this)
			{
				this.preloadingInProgress = false;
			}
		}
	}

	public synchronized boolean needsBackgroundLoading()
	{
		if (this.useLazyLoading)
		{
			return false;
		}
		if (!this.initialized || this.disposed || this.allFramesLoaded)
		{
			return false;
		}
		if (this.backgroundLoadingStarted)
		{
			return false;
		}
		this.backgroundLoadingStarted = true;
		return true;
	}

	public void loadAllFrames()
	{
		while (!this.allFramesLoaded && !this.disposed)
		{
			this.loadNextFrame();
		}
	}

	@Override
	public synchronized void close()
	{
		this.disposed = true;
		this.closeReader();
		this.frames.clear();
		this.frameDelays.clear();
	}

	private synchronized boolean ensureInitialized()
	{
		if (this.disposed)
		{
			return false;
		}

		if (this.initialized)
		{
			return true;
		}

		try
		{
			ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(this.gifData);
			this.imageStream = ImageIO.createImageInputStream(byteArrayInputStream);
			if (this.imageStream == null)
			{
				return false;
			}

			Iterator<ImageReader> readers = ImageIO.getImageReadersByFormatName("gif");
			if (!readers.hasNext())
			{
				this.imageStream.close();
				return false;
			}

			this.reader = readers.next();
			this.reader.setInput(this.imageStream);

			this.initializeCanvas();

			boolean loaded = this.loadNextFrame();
			if (!loaded)
			{
				this.close();
				return false;
			}

			this.initialized = true;
			return true;
		}
		catch (IOException e)
		{
			log.debug("Failed to initialize GIF animation", e);
			return false;
		}
	}

	private void initializeCanvas() throws IOException
	{
		IIOMetadata streamMetadata = this.reader.getStreamMetadata();
		if (streamMetadata != null)
		{
			String formatName = streamMetadata.getNativeMetadataFormatName();
			IIOMetadataNode root = (IIOMetadataNode) streamMetadata.getAsTree(formatName);

			NodeList screenDescList = root.getElementsByTagName("LogicalScreenDescriptor");
			if (screenDescList.getLength() > 0)
			{
				IIOMetadataNode screenDesc = (IIOMetadataNode) screenDescList.item(0);
				String widthStr = screenDesc.getAttribute("logicalScreenWidth");
				String heightStr = screenDesc.getAttribute("logicalScreenHeight");

				if (widthStr != null && !widthStr.isEmpty())
				{
					this.canvasWidth = Integer.parseInt(widthStr);
				}
				if (heightStr != null && !heightStr.isEmpty())
				{
					this.canvasHeight = Integer.parseInt(heightStr);
				}
			}
		}

		if (this.canvasWidth == 0 || this.canvasHeight == 0)
		{
			BufferedImage firstFrame = this.reader.read(0);
			this.canvasWidth = firstFrame.getWidth();
			this.canvasHeight = firstFrame.getHeight();
		}

		this.canvas = new BufferedImage(this.canvasWidth, this.canvasHeight, BufferedImage.TYPE_INT_ARGB);
		this.previousDisposalMethod = DISPOSAL_NONE;
		this.previousFrameBounds = null;
	}

	private boolean loadNextFrame()
	{
		int nextIndex;
		synchronized (this)
		{
			if (this.allFramesLoaded || this.disposed)
			{
				return false;
			}
			nextIndex = this.frames.size();
		}

		BufferedImage compositedFrame;
		int delay;
		try
		{
			BufferedImage rawFrame = this.reader.read(nextIndex);

			FrameMetadata metadata = this.getFrameMetadata(nextIndex);
			delay = metadata.delayMs;

			this.applyDisposalMethod();

			boolean needsSaveState = DISPOSAL_RESTORE_TO_PREVIOUS.equals(metadata.disposalMethod);
			if (needsSaveState)
			{
				this.savedCanvas = this.copyCanvas();
			}

			Graphics2D g = this.canvas.createGraphics();
			try
			{
				g.drawImage(rawFrame, metadata.x, metadata.y, null);
			}
			finally
			{
				g.dispose();
			}

			this.previousDisposalMethod = metadata.disposalMethod;
			this.previousFrameBounds = new Rectangle(metadata.x, metadata.y, rawFrame.getWidth(), rawFrame.getHeight());

			BufferedImage canvasCopy = this.copyCanvas();

			compositedFrame = canvasCopy;
			if (this.shouldResize)
			{
				compositedFrame = PluginUtils.resizeImage(canvasCopy, this.maxHeight);
			}
		}
		catch (IndexOutOfBoundsException e)
		{
			synchronized (this)
			{
				this.allFramesLoaded = true;
				this.closeReader();
			}
			return false;
		}
		catch (IOException e)
		{
			log.debug("Failed to load frame {}", nextIndex, e);
			synchronized (this)
			{
				this.allFramesLoaded = true;
				this.closeReader();
			}
			return false;
		}

		synchronized (this)
		{
			if (this.disposed)
			{
				return false;
			}
			this.frames.add(compositedFrame);
			this.frameDelays.add(delay);
		}

		return true;
	}

	private void applyDisposalMethod()
	{
		if (this.previousFrameBounds == null)
		{
			return;
		}

		switch (this.previousDisposalMethod)
		{
			case DISPOSAL_RESTORE_TO_BACKGROUND:
				this.clearPreviousFrameArea();
				break;
			case DISPOSAL_RESTORE_TO_PREVIOUS:
				this.restoreToPreviousCanvas();
				break;
			case DISPOSAL_NONE:
			case DISPOSAL_DO_NOT_DISPOSE:
			default:
				break;
		}
	}

	private void clearPreviousFrameArea()
	{
		Graphics2D g = this.canvas.createGraphics();
		try
		{
			g.setBackground(new Color(0, 0, 0, 0));
			g.clearRect(
				this.previousFrameBounds.x,
				this.previousFrameBounds.y,
				this.previousFrameBounds.width,
				this.previousFrameBounds.height
			);
		}
		finally
		{
			g.dispose();
		}
	}

	private void restoreToPreviousCanvas()
	{
		if (this.savedCanvas == null)
		{
			return;
		}

		Graphics2D g = this.canvas.createGraphics();
		try
		{
			g.setBackground(new Color(0, 0, 0, 0));
			g.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
			g.drawImage(this.savedCanvas, 0, 0, null);
		}
		finally
		{
			g.dispose();
		}
	}

	private BufferedImage copyCanvas()
	{
		BufferedImage copy = new BufferedImage(this.canvasWidth, this.canvasHeight, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = copy.createGraphics();
		try
		{
			g.drawImage(this.canvas, 0, 0, null);
		}
		finally
		{
			g.dispose();
		}
		return copy;
	}

	private FrameMetadata getFrameMetadata(int frameIndex)
	{
		FrameMetadata metadata = new FrameMetadata();
		metadata.x = 0;
		metadata.y = 0;
		metadata.delayMs = DEFAULT_FRAME_DELAY_MS;
		metadata.disposalMethod = DISPOSAL_NONE;

		try
		{
			IIOMetadata frameMetadata = this.reader.getImageMetadata(frameIndex);
			if (frameMetadata == null)
			{
				return metadata;
			}

			String formatName = frameMetadata.getNativeMetadataFormatName();
			IIOMetadataNode root = (IIOMetadataNode) frameMetadata.getAsTree(formatName);

			this.parseImageDescriptor(root, metadata);
			this.parseGraphicControlExtension(root, metadata);
		}
		catch (Exception e)
		{
			log.debug("Failed to get frame metadata for frame {}", frameIndex, e);
		}

		return metadata;
	}

	private void parseImageDescriptor(IIOMetadataNode root, FrameMetadata metadata)
	{
		NodeList imageDescList = root.getElementsByTagName("ImageDescriptor");
		if (imageDescList.getLength() == 0)
		{
			return;
		}

		IIOMetadataNode imageDesc = (IIOMetadataNode) imageDescList.item(0);
		metadata.x = this.parseIntAttribute(imageDesc, "imageLeftPosition", 0);
		metadata.y = this.parseIntAttribute(imageDesc, "imageTopPosition", 0);
	}

	private void parseGraphicControlExtension(IIOMetadataNode root, FrameMetadata metadata)
	{
		NodeList gceList = root.getElementsByTagName("GraphicControlExtension");
		if (gceList.getLength() == 0)
		{
			return;
		}

		IIOMetadataNode gce = (IIOMetadataNode) gceList.item(0);

		int delayHundredths = this.parseIntAttribute(gce, "delayTime", 0);
		int delayMs = delayHundredths * 10;
		metadata.delayMs = delayMs > 0 ? delayMs : DEFAULT_FRAME_DELAY_MS;

		String disposalStr = gce.getAttribute("disposalMethod");
		if (disposalStr != null && !disposalStr.isEmpty())
		{
			metadata.disposalMethod = disposalStr;
		}
	}

	private int parseIntAttribute(IIOMetadataNode node, String attributeName, int defaultValue)
	{
		String value = node.getAttribute(attributeName);
		if (value == null || value.isEmpty())
		{
			return defaultValue;
		}
		return Integer.parseInt(value);
	}

	private int calculateCurrentFrameIndex()
	{
		int loadedCount = this.frames.size();
		if (loadedCount == 0)
		{
			return 0;
		}

		if (loadedCount == 1)
		{
			return 0;
		}

		long now = System.currentTimeMillis();
		int currentDelay = this.frameDelays.get(this.currentFrameIndex);
		long elapsed = now - this.lastFrameChangeTime;

		while (elapsed >= currentDelay)
		{
			elapsed -= currentDelay;
			int nextIndex = this.currentFrameIndex + 1;

			if (nextIndex >= loadedCount)
			{
				if (this.allFramesLoaded)
				{
					nextIndex = 0;
				}
				else
				{
					this.lastFrameChangeTime = now;
					return this.currentFrameIndex;
				}
			}

			this.currentFrameIndex = nextIndex;
			this.lastFrameChangeTime = now - elapsed;
			currentDelay = this.frameDelays.get(this.currentFrameIndex);
		}

		return this.currentFrameIndex;
	}

	private void closeReader()
	{
		if (this.reader != null)
		{
			this.reader.dispose();
			this.reader = null;
		}

		if (this.imageStream != null)
		{
			try
			{
				this.imageStream.close();
			}
			catch (IOException e)
			{
				log.debug("Error closing image stream", e);
			}
			this.imageStream = null;
		}

		this.canvas = null;
		this.savedCanvas = null;
		this.gifData = null;
	}

	private static class FrameMetadata
	{
		int x;
		int y;
		int delayMs;
		String disposalMethod;
	}
}

package com.customemoji.animation;

import com.customemoji.CustomEmojiConfig;
import com.customemoji.CustomEmojiConfig.AnimationLoadingMode;
import com.customemoji.model.AnimatedEmoji;
import com.customemoji.service.EmojiStateManager;

import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Slf4j
@Singleton
public class AnimationManager
{
	private static final long STALE_ANIMATION_TIMEOUT_MS = 500;
	private static final int FRAME_LOADER_THREAD_COUNT = 2;

	private final Map<Integer, GifAnimation> animationCache = new ConcurrentHashMap<>();
	private final Map<Integer, Long> animationLastSeenTime = new ConcurrentHashMap<>();
	private final Set<Integer> pendingAnimationLoads = ConcurrentHashMap.newKeySet();

	private final CustomEmojiConfig config;
	private final EmojiStateManager emojiStateManager;
	private ExecutorService frameLoaderPool;

	@Inject
	public AnimationManager(CustomEmojiConfig config, EmojiStateManager emojiStateManager)
	{
		this.config = config;
		this.emojiStateManager = emojiStateManager;
	}

	public void initialize()
	{
		if (this.frameLoaderPool == null || this.frameLoaderPool.isShutdown())
		{
			this.frameLoaderPool = Executors.newFixedThreadPool(FRAME_LOADER_THREAD_COUNT, this::createLoaderThread);
		}
	}

	public GifAnimation getOrLoadAnimation(AnimatedEmoji emoji)
	{
		int emojiId = emoji.getId();

		GifAnimation cached = this.animationCache.get(emojiId);
		if (cached != null)
		{
			this.startBackgroundLoadingIfNeeded(cached);
			this.startPreloadingIfNeeded(cached);
			return cached;
		}

		synchronized (this.pendingAnimationLoads)
		{
			cached = this.animationCache.get(emojiId);
			if (cached != null)
			{
				this.startBackgroundLoadingIfNeeded(cached);
				this.startPreloadingIfNeeded(cached);
				return cached;
			}

			boolean isAlreadyLoading = this.pendingAnimationLoads.contains(emojiId);
			if (isAlreadyLoading)
			{
				return null;
			}

			this.pendingAnimationLoads.add(emojiId);
		}

		String emojiText = emoji.getText();

		this.frameLoaderPool.submit(() ->
		{
			try
			{
				GifAnimation animation = this.loadAnimation(emoji);
				if (animation != null)
				{
					GifAnimation replaced = this.animationCache.put(emojiId, animation);
					if (replaced != null)
					{
						replaced.close();
					}
					log.debug("Loaded animation: {} (id={})", emojiText, emojiId);
					this.startBackgroundLoadingIfNeeded(animation);
				}
			}
			finally
			{
				this.pendingAnimationLoads.remove(emojiId);
			}
		});

		return null;
	}

	public void markAnimationVisible(int emojiId)
	{
		this.animationLastSeenTime.put(emojiId, System.currentTimeMillis());
	}

	public void unloadStaleAnimations(Set<Integer> currentlyVisibleIds)
	{
		long currentTime = System.currentTimeMillis();

		this.animationCache.entrySet().removeIf(entry ->
		{
			int emojiId = entry.getKey();
			boolean isCurrentlyVisible = currentlyVisibleIds.contains(emojiId);
			if (isCurrentlyVisible)
			{
				return false;
			}

			Long lastSeen = this.animationLastSeenTime.get(emojiId);
			if (lastSeen == null)
			{
				entry.getValue().close();
				return true;
			}

			boolean isStale = (currentTime - lastSeen) > STALE_ANIMATION_TIMEOUT_MS;
			if (isStale)
			{
				this.animationLastSeenTime.remove(emojiId);
				entry.getValue().close();
				log.debug("Unloading stale animation for emoji id: {}", emojiId);
			}
			return isStale;
		});
	}

	public void clearAllAnimations()
	{
		this.animationCache.values().forEach(GifAnimation::close);
		this.animationCache.clear();
		this.animationLastSeenTime.clear();
	}

	public void shutdown()
	{
		this.clearAllAnimations();
		this.frameLoaderPool.shutdownNow();
	}

	public void invalidateAnimation(int emojiId)
	{
		GifAnimation animation = this.animationCache.remove(emojiId);
		if (animation != null)
		{
			animation.close();
		}
		this.animationLastSeenTime.remove(emojiId);
		this.pendingAnimationLoads.remove(emojiId);
	}

		private Thread createLoaderThread(Runnable runnable)
	{
		Thread thread = new Thread(runnable);
		thread.setName("CustomEmoji-FrameLoader");
		thread.setDaemon(true);
		return thread;
	}

	private void startBackgroundLoadingIfNeeded(GifAnimation animation)
	{
		if (animation.needsBackgroundLoading())
		{
			this.frameLoaderPool.submit(animation::loadAllFrames);
		}
	}

	private void startPreloadingIfNeeded(GifAnimation animation)
	{
		if (animation.needsPreloading())
		{
			this.frameLoaderPool.submit(animation::preloadFrames);
		}
	}

	private GifAnimation loadAnimation(AnimatedEmoji emoji)
	{
		File file = emoji.getFile();
		String emojiName = emoji.getText();

		try
		{
			byte[] gifData = Files.readAllBytes(file.toPath());

			int maxHeight = this.config.maxImageHeight();
			boolean shouldResize = this.emojiStateManager.isResizingEnabled(emojiName);
			boolean useLazyLoading = this.config.animationLoadingMode() == AnimationLoadingMode.LAZY;

			GifAnimation animation = new GifAnimation(gifData, maxHeight, shouldResize, useLazyLoading);

			BufferedImage firstFrame = animation.getCurrentFrame();
			if (firstFrame == null)
			{
				animation.close();
				return null;
			}

			return animation;
		}
		catch (IOException e)
		{
			log.error("Failed to load animation for emoji: {}", emojiName, e);
			return null;
		}
	}
}

package com.customemoji;

import com.customemoji.animation.AnimationManager;
import com.customemoji.animation.GifAnimation;
import com.customemoji.model.AnimatedEmoji;
import com.customemoji.model.Emoji;

import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.gameval.VarClientID;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.*;

import javax.inject.Inject;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Slf4j
class CustomEmojiOverlay extends OverlayPanel
{
    private static final int BORDER_OFFSET = 4;
    private static final int GAP = 2;
    private static final int MIN_ROW_HEIGHT = 14;
    private static final int MIN_WORD_LENGTH = 2;

    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    @Inject
    private AnimationManager animationManager;

    @Inject
    private Map<String, Emoji> emojis;

    private Map<String, Emoji> emojiSuggestions = new HashMap<>();
    private final Map<String, BufferedImage> normalizedImageCache = new HashMap<>();
    private final List<AnimatedEmojiPosition> animatedEmojiPositions = new ArrayList<>();

    private static class AnimatedEmojiPosition
    {
        final AnimatedEmoji emoji;
        final int index;

        AnimatedEmojiPosition(AnimatedEmoji emoji, int index)
        {
            this.emoji = emoji;
            this.index = index;
        }
    }

    @Inject
    public CustomEmojiOverlay(CustomEmojiPlugin plugin)
    {
        super(plugin);
        this.getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY_CONFIG, "Configure", "Custom Emoji overlay"));
    }

    protected void updateChatInput(String input)
    {
        this.emojiSuggestions = getEmojiSuggestions(input);
        this.clearImageCache();
    }

    protected void startUp()
    {
        panelComponent.setGap(new Point(0, 2));
    }

    protected void shutDown()
    {
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (this.emojiSuggestions.isEmpty())
        {
            return null;
        }

        this.animatedEmojiPositions.clear();

        // Don't render overlay if it's disabled or a right-click context menu is open
        if (this.config.maxImageSuggestions() == 0 || this.client.isMenuOpen())
        {
            return null;
        }

        // Check current chat input if its empty, user may have cleared it
        String currentRegularInput = this.client.getVarcStrValue(VarClientID.CHATINPUT);
        String currentPrivateInput = this.client.getVarcStrValue(VarClientID.MESLAYERINPUT);

        // Don't render if input text is empty
        if ((currentRegularInput == null || currentRegularInput.isEmpty()) && 
            (currentPrivateInput == null || currentPrivateInput.isEmpty()))
        {
            return null;
        }

        boolean isUsingPrivateInput = currentPrivateInput != null && !currentPrivateInput.isBlank();
        String inputForOverlay = isUsingPrivateInput ? currentPrivateInput : currentRegularInput;

        if (inputForOverlay == null)
        {
            return null;
        }

        String[] words = inputForOverlay.split("\\s+");
        String lastWord = words[words.length - 1].toLowerCase();

        int index = 0;
        for (Emoji emoji : this.emojiSuggestions.values())
        {
            this.addEmojiToOverlay(emoji, lastWord);

            if (emoji instanceof AnimatedEmoji)
            {
                this.animatedEmojiPositions.add(new AnimatedEmojiPosition((AnimatedEmoji) emoji, index));
            }
            index++;
        }

        Dimension dimension = super.render(graphics);

        this.renderAnimations(graphics);

        return dimension;
    }

    private void addEmojiToOverlay(Emoji emoji, String searchTerm)
    {
        BufferedImage displayImage = emoji.getStaticImage();

        if (emoji instanceof AnimatedEmoji)
        {
            displayImage = new BufferedImage(emoji.getDimension().width, emoji.getDimension().height, BufferedImage.TYPE_INT_ARGB);
        }
        
        ImageComponent imageComponent = new ImageComponent(displayImage);

        // build line component with highlighted text
        String highlightedText = this.createHighlightedText(emoji.getText(), searchTerm);
        LineComponent lineComponent = LineComponent.builder().right(highlightedText).build();
        SplitComponent splitComponent = SplitComponent.builder().first(imageComponent).second(lineComponent).orientation(ComponentOrientation.HORIZONTAL).build();

        this.panelComponent.getChildren().add(splitComponent);
    }
    
    private String createHighlightedText(String text, String searchTerm)
    {
        if (searchTerm.isEmpty())
        {
            return text;
        }
        
        String lowerText = text.toLowerCase();
        String lowerSearch = searchTerm.toLowerCase();
        int index = lowerText.indexOf(lowerSearch);
        
        if (index == -1)
        {
            return text;
        }
        
        StringBuilder result = new StringBuilder();
        result.append(text.substring(0, index));
        result.append("<col=00ff00>");  // Green highlight
        result.append(text.substring(index, index + searchTerm.length()));
        result.append("<col=ffffff>");  // Reset to white
        result.append(text.substring(index + searchTerm.length()));
        
        return result.toString();
    }

    @NonNull
    private Map<String, Emoji> getEmojiSuggestions(@NonNull String searchTerm)
    {
        if (searchTerm.trim().isEmpty())
        {
            return new HashMap<>();
        }

        String[] words = searchTerm.split("\\s+");
        String lastWord = words[words.length - 1];

        if (lastWord.length() < MIN_WORD_LENGTH)
        {
            return new HashMap<>();
        }

        String lowerSearch = lastWord.toLowerCase();

        // Get disabled emojis from config
        Set<String> disabledEmojis = PluginUtils.parseDisabledEmojis(this.config.disabledEmojis());

        // Get all matching entries (excluding disabled emojis)
        List<Map.Entry<String, Emoji>> matchingEntries = new ArrayList<>();
        for (Map.Entry<String, Emoji> entry : this.emojis.entrySet())
        {
            String emojiName = entry.getKey();
            boolean isDisabled = disabledEmojis.contains(emojiName);
            boolean matchesSearch = emojiName.toLowerCase().contains(lowerSearch);

            if (matchesSearch && !isDisabled)
            {
                matchingEntries.add(entry);
            }
        }
        
        // Sort by relevance
        this.sortByRelevance(matchingEntries, lowerSearch);

        // Build result map with limit
        Map<String, Emoji> matches = new LinkedHashMap<>();
        int limit = Math.min(matchingEntries.size(), this.config.maxImageSuggestions());

        for (int i = limit - 1; i >= 0; i--)
        {
            Map.Entry<String, Emoji> entry = matchingEntries.get(i);
            matches.put(entry.getKey(), entry.getValue());
        }

        return matches;
    }

    private void sortByRelevance(List<Map.Entry<String, Emoji>> entries, String searchTerm)
    {
        entries.sort((a, b) -> {
            String nameA = a.getKey().toLowerCase();
            String nameB = b.getKey().toLowerCase();
            
            // Exact matches come first
            boolean exactA = nameA.equals(searchTerm);
            boolean exactB = nameB.equals(searchTerm);
            if (exactA != exactB) return exactA ? -1 : 1;
            
            // Then prefix matches
            boolean prefixA = nameA.startsWith(searchTerm);
            boolean prefixB = nameB.startsWith(searchTerm);
            if (prefixA != prefixB) return prefixA ? -1 : 1;
            
            // Then by position of match (earlier is better)
            int posA = nameA.indexOf(searchTerm);
            int posB = nameB.indexOf(searchTerm);
            if (posA != posB) return Integer.compare(posA, posB);
            
            // Finally by length (shorter names are better)
            return Integer.compare(nameA.length(), nameB.length());
        });
    }

    private void renderAnimations(Graphics2D graphics)
    {
        boolean animationsEnabled = this.config.animationLoadingMode() != CustomEmojiConfig.AnimationLoadingMode.OFF;
        if (!animationsEnabled || this.animatedEmojiPositions.isEmpty())
        {
            return;
        }

        // Calculate Y positions for each row
        int[] yPositions = new int[this.emojiSuggestions.size()];
        int currentY = BORDER_OFFSET;
        int i = 0;
        for (Emoji emoji : this.emojiSuggestions.values())
        {
            int imageHeight = emoji.getDimension().height;
            int rowHeight = Math.max(imageHeight, MIN_ROW_HEIGHT);

            yPositions[i] = currentY;
            currentY += rowHeight + GAP;
            i++;
        }

        int x = BORDER_OFFSET;

        for (AnimatedEmojiPosition animatedPosition : this.animatedEmojiPositions)
        {
            if (animatedPosition.index >= yPositions.length)
            {
                continue;
            }

            AnimatedEmoji emoji = animatedPosition.emoji;

            // Mark visible before loading to prevent unloading
            this.animationManager.markAnimationVisible(emoji.getId());

            GifAnimation animation = this.animationManager.getOrLoadAnimation(emoji);
            BufferedImage frame = animation != null ? animation.getCurrentFrame() : null;

            if (frame != null)
            {
                int baseY = yPositions[animatedPosition.index];
                int imageHeight = emoji.getDimension().height;
                int rowHeight = Math.max(imageHeight, MIN_ROW_HEIGHT);
                int y = baseY + (rowHeight - imageHeight) / 2;

                graphics.drawImage(frame, x, y, emoji.getDimension().width, imageHeight, null);
            }
        }
    }

    private void clearImageCache()
    {
        this.normalizedImageCache.clear();
    }
}

package com.customemoji;

import com.customemoji.debugplugin.CustomEmojiDebugPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CustomEmojiPlugin.class, CustomEmojiDebugPlugin.class);
		RuneLite.main(args);
	}
}
package com.customemoji;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.awt.Rectangle;

import org.junit.Test;

import com.customemoji.EmojiPosition;

public class EmojiPositionTest
{
    @Test
    public void containsPoint_pointInside_returnsTrue()
    {
        Rectangle bounds = new Rectangle(10, 10, 20, 20);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertTrue(position.containsPoint(15, 15));
    }

    @Test
    public void containsPoint_pointOutside_returnsFalse()
    {
        Rectangle bounds = new Rectangle(10, 10, 20, 20);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertFalse(position.containsPoint(5, 5));
    }

    @Test
    public void containsPoint_pointOnLeftEdge_returnsTrue()
    {
        Rectangle bounds = new Rectangle(10, 10, 20, 20);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertTrue(position.containsPoint(10, 15));
    }

    @Test
    public void containsPoint_pointOnTopEdge_returnsTrue()
    {
        Rectangle bounds = new Rectangle(10, 10, 20, 20);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertTrue(position.containsPoint(15, 10));
    }

    @Test
    public void containsPoint_pointOnRightEdge_returnsFalse()
    {
        Rectangle bounds = new Rectangle(10, 10, 20, 20);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertFalse(position.containsPoint(30, 15));
    }

    @Test
    public void containsPoint_pointOnBottomEdge_returnsFalse()
    {
        Rectangle bounds = new Rectangle(10, 10, 20, 20);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertFalse(position.containsPoint(15, 30));
    }

    @Test
    public void getImageId_returnsCorrectId()
    {
        Rectangle bounds = new Rectangle(0, 0, 10, 10);
        EmojiPosition position = new EmojiPosition(42, bounds, 0);

        assertEquals(42, position.getImageId());
    }

    @Test
    public void getX_returnsCorrectX()
    {
        Rectangle bounds = new Rectangle(100, 200, 10, 10);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertEquals(100, position.getX());
    }

    @Test
    public void getY_returnsCorrectY()
    {
        Rectangle bounds = new Rectangle(100, 200, 10, 10);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertEquals(200, position.getY());
    }

    @Test
    public void getWidth_returnsCorrectWidth()
    {
        Rectangle bounds = new Rectangle(0, 0, 50, 30);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertEquals(50, position.getWidth());
    }

    @Test
    public void getHeight_returnsCorrectHeight()
    {
        Rectangle bounds = new Rectangle(0, 0, 50, 30);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertEquals(30, position.getHeight());
    }

    @Test
    public void getBounds_returnsSameRectangle()
    {
        Rectangle bounds = new Rectangle(10, 20, 30, 40);
        EmojiPosition position = new EmojiPosition(1, bounds, 0);

        assertEquals(bounds, position.getBounds());
    }
}

package com.customemoji;

import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import java.awt.image.BufferedImage;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.overlay.OverlayManager;
import org.junit.Before;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class Testing
{

    @Mock
    @Bind
    private Client client;

    @Mock
    @Bind
    private ClientThread clientThread;

    @Mock
    @Bind
    private ConfigManager configManager;

    @Mock
    @Bind
    private OverlayManager overlayManager;

    @Mock
    @Bind
    private MouseManager mouseManager;

    @Mock
    @Bind
    private KeyManager keyManager;

    @Mock
    @Bind
    private RuneLiteConfig runeLiteConfig;

    @Mock
    @Bind
    private ChatMessageManager chatMessageManager;

    @Mock
    @Bind
    private ChatIconManager chatIconManager;

    @Mock
    @Bind
    private CustomEmojiConfig customEmojiConfig;

    private int iconId;

    @Before
    public void before() throws Exception
    {
        Guice.createInjector(BoundFieldModule.of(this))
                .injectMembers(this);

        when(chatIconManager.registerChatIcon(any(BufferedImage.class)))
                .thenAnswer(a ->
                {
                    int currentId = iconId;
                    iconId++;
                    return currentId;
                });
        when(chatIconManager.chatIconIndex(anyInt()))
                .thenReturn(0);
    }
}
package com.customemoji.debugplugin;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("custom-emoji-debug")
public interface CustomEmojiDebugConfig extends Config
{
    @ConfigItem(
        keyName = "showEmojiHitboxes",
        name = "Show Emoji Hitboxes",
        description = "Draws cyan borders around emoji hit areas in chat",
        position = 0
    )
    default boolean showEmojiHitboxes()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showRawTextTooltip",
        name = "Show Raw Text Tooltip",
        description = "Shows raw widget text when hovering over chat messages",
        position = 1
    )
    default boolean showRawTextTooltip()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showAnimationCounter",
        name = "Show Animation Counter",
        description = "Shows animation frame counter overlay",
        position = 2
    )
    default boolean showAnimationCounter()
    {
        return false;
    }

    @ConfigItem(
        keyName = "showOverheadCrosshair",
        name = "Show Overhead Crosshair",
        description = "Shows crosshair at overhead emoji positions",
        position = 3
    )
    default boolean showOverheadCrosshair()
    {
        return false;
    }

    @ConfigItem(
        keyName = "showEmojiBorder",
        name = "Show Emoji Border",
        description = "Shows border around overhead emojis",
        position = 4
    )
    default boolean showEmojiBorder()
    {
        return false;
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;

import com.google.inject.Provides;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(
    name = "Custom Emoji Debug",
    developerPlugin = true
)
public class CustomEmojiDebugPlugin extends Plugin
{
    private static final String EMOJI_DEBUG_COMMAND = "emojidebug";

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private EmojiHitboxOverlay hitboxOverlay;

    @Inject
    private RawTextTooltipOverlay rawTextTooltipOverlay;

    @Inject
    private AnimationCounterOverlay animationCounterOverlay;

    @Inject
    private OverheadDebugOverlay overheadDebugOverlay;

    @Inject
    private Client client;

    @Subscribe
    public void onCommandExecuted(CommandExecuted event)
    {
        if (!event.getCommand().equalsIgnoreCase(EMOJI_DEBUG_COMMAND))
        {
            return;
        }

        String[] args = event.getArguments();
        if (args.length == 0)
        {
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", "Usage: ::emojidebug <icon_id>", null);
            return;
        }

        try
        {
            int iconId = Integer.parseInt(args[0]);
            String message = "Icon " + iconId + ": <img=" + iconId + ">";
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);
        }
        catch (NumberFormatException e)
        {
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", "Invalid icon ID: " + args[0], null);
        }
    }

    @Override
    protected void startUp() throws Exception
    {
        this.overlayManager.add(this.hitboxOverlay);
        this.overlayManager.add(this.rawTextTooltipOverlay);
        this.overlayManager.add(this.animationCounterOverlay);
        this.overlayManager.add(this.overheadDebugOverlay);
    }

    @Override
    protected void shutDown() throws Exception
    {
        this.overlayManager.remove(this.hitboxOverlay);
        this.overlayManager.remove(this.rawTextTooltipOverlay);
        this.overlayManager.remove(this.animationCounterOverlay);
        this.overlayManager.remove(this.overheadDebugOverlay);
    }

    @Provides
    CustomEmojiDebugConfig provideDebugConfig(ConfigManager configManager)
    {
        return configManager.getConfig(CustomEmojiDebugConfig.class);
    }
}
package com.customemoji.debugplugin;

import com.customemoji.PluginUtils;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import javax.inject.Singleton;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Singleton
public class OverheadDebugOverlay extends Overlay
{
	private static final Pattern IMG_PATTERN = Pattern.compile("<img=(\\d+)>");

	private final Client client;
	private final CustomEmojiDebugConfig config;

	@Inject
	public OverheadDebugOverlay(Client client, CustomEmojiDebugConfig config)
	{
		this.client = client;
		this.config = config;
		this.setPosition(OverlayPosition.DYNAMIC);
		this.setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		boolean showCrosshair = this.config.showOverheadCrosshair();
		boolean showEmojiBorder = this.config.showEmojiBorder();

		if (!showCrosshair && !showEmojiBorder)
		{
			return null;
		}

		Player localPlayer = this.client.getLocalPlayer();
		if (localPlayer != null && showCrosshair)
		{
			this.renderLocalPlayerCrosshair(graphics, localPlayer);
		}

		if (showEmojiBorder)
		{
			this.renderEmojiBorders(graphics);
		}

		return null;
	}

	private void renderLocalPlayerCrosshair(Graphics2D graphics, Player localPlayer)
	{
		Point debugPoint = localPlayer.getCanvasTextLocation(graphics, "TEST", localPlayer.getLogicalHeight());
		if (debugPoint == null)
		{
			return;
		}

		graphics.setColor(Color.CYAN);
		graphics.drawLine(debugPoint.getX() - 15, debugPoint.getY(), debugPoint.getX() + 15, debugPoint.getY());
		graphics.drawLine(debugPoint.getX(), debugPoint.getY() - 15, debugPoint.getX(), debugPoint.getY() + 15);
	}

	private void renderEmojiBorders(Graphics2D graphics)
	{
		if (this.client.getTopLevelWorldView() == null)
		{
			return;
		}

		List<Player> players = this.client.getTopLevelWorldView().players().stream().collect(Collectors.toList());
		if (players.isEmpty())
		{
			return;
		}

		for (Player player : players)
		{
			this.renderPlayerEmojiBorders(graphics, player);
		}
	}

	private void renderPlayerEmojiBorders(Graphics2D graphics, Player player)
	{
		if (player == null)
		{
			return;
		}

		String overheadText = player.getOverheadText();
		if (overheadText == null || overheadText.isEmpty())
		{
			return;
		}

		boolean hasImageTag = overheadText.contains("<img=");
		if (!hasImageTag)
		{
			return;
		}

		Point basePoint = player.getCanvasTextLocation(graphics, overheadText, player.getLogicalHeight());
		if (basePoint == null)
		{
			return;
		}

		Font font = FontManager.getRunescapeSmallFont();
		FontMetrics metrics = graphics.getFontMetrics(font);
		IndexedSprite[] modIcons = this.client.getModIcons();

		int totalWidth = this.calculateTotalWidth(overheadText, metrics, modIcons);
		int centerX = basePoint.getX();
		int startX = centerX - (totalWidth / 2);

		int currentX = startX;
		int baseY = basePoint.getY();
		int textIndex = 0;
		Matcher matcher = IMG_PATTERN.matcher(overheadText);

		graphics.setColor(Color.MAGENTA);

		while (matcher.find())
		{
			String textBefore = overheadText.substring(textIndex, matcher.start());
			String cleanTextBefore = this.removeHtmlTags(textBefore);
			currentX += metrics.stringWidth(cleanTextBefore);

			int imageId = Integer.parseInt(matcher.group(1));

			Dimension emojiDim = PluginUtils.getEmojiDimension(modIcons, imageId);
			int emojiWidth = emojiDim != null ? emojiDim.width : 12;
			int emojiHeight = emojiDim != null ? emojiDim.height : 12;

			int emojiY = baseY - emojiHeight + 2;
			graphics.drawRect(currentX, emojiY, emojiWidth, emojiHeight);

			currentX += emojiWidth;
			textIndex = matcher.end();
		}
	}

	private int calculateTotalWidth(String text, FontMetrics metrics, IndexedSprite[] modIcons)
	{
		int totalWidth = 0;
		int textIndex = 0;
		Matcher matcher = IMG_PATTERN.matcher(text);

		while (matcher.find())
		{
			String textBefore = text.substring(textIndex, matcher.start());
			String cleanTextBefore = this.removeHtmlTags(textBefore);
			totalWidth += metrics.stringWidth(cleanTextBefore);

			int imageId = Integer.parseInt(matcher.group(1));
			Dimension emojiDim = PluginUtils.getEmojiDimension(modIcons, imageId);
			int emojiWidth = emojiDim != null ? emojiDim.width : 12;
			totalWidth += emojiWidth;

			textIndex = matcher.end();
		}

		String remainingText = text.substring(textIndex);
		String cleanRemaining = this.removeHtmlTags(remainingText);
		totalWidth += metrics.stringWidth(cleanRemaining);

		return totalWidth;
	}

	private String removeHtmlTags(String text)
	{
		if (text == null)
		{
			return "";
		}
		return text.replaceAll("<[^>]*>", "");
	}
}

package com.customemoji.debugplugin;

import javax.inject.Inject;
import javax.inject.Singleton;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;

@Singleton
public class RawTextTooltipOverlay extends Overlay
{
    private static final int TOOLTIP_PADDING = 4;
    private static final int TOOLTIP_OFFSET_Y = 20;
    private static final Color BACKGROUND_COLOR = new Color(70, 61, 50, 220);
    private static final Color BORDER_COLOR = new Color(40, 35, 30);
    private static final Color TEXT_COLOR = Color.WHITE;

    @Inject
    private Client client;

    @Inject
    private CustomEmojiDebugConfig config;

    public RawTextTooltipOverlay()
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!this.config.showRawTextTooltip())
        {
            return null;
        }

        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return null;
        }

        net.runelite.api.Point mousePos = this.client.getMouseCanvasPosition();
        if (mousePos == null)
        {
            return null;
        }

        int mouseX = mousePos.getX();
        int mouseY = mousePos.getY();

        Widget hoveredWidget = this.findHoveredWidget(chatbox, mouseX, mouseY);
        if (hoveredWidget == null)
        {
            return null;
        }

        String rawText = hoveredWidget.getText();
        if (rawText == null || rawText.isEmpty())
        {
            return null;
        }

        this.drawTooltip(graphics, rawText, mouseX, mouseY);

        return null;
    }

    private void drawTooltip(Graphics2D graphics, String text, int mouseX, int mouseY)
    {
        Font originalFont = graphics.getFont();
        Font tooltipFont = new Font(Font.MONOSPACED, Font.PLAIN, 12);
        graphics.setFont(tooltipFont);

        FontMetrics fm = graphics.getFontMetrics();
        int textWidth = fm.stringWidth(text);
        int textHeight = fm.getHeight();

        int tooltipX = mouseX;
        int tooltipY = mouseY + TOOLTIP_OFFSET_Y;

        int boxWidth = textWidth + TOOLTIP_PADDING * 2;
        int boxHeight = textHeight + TOOLTIP_PADDING * 2;

        graphics.setColor(BACKGROUND_COLOR);
        graphics.fillRect(tooltipX, tooltipY, boxWidth, boxHeight);

        graphics.setColor(BORDER_COLOR);
        graphics.drawRect(tooltipX, tooltipY, boxWidth, boxHeight);

        graphics.setColor(TEXT_COLOR);
        graphics.drawString(text, tooltipX + TOOLTIP_PADDING, tooltipY + TOOLTIP_PADDING + fm.getAscent());

        graphics.setFont(originalFont);
    }

    private Widget findHoveredWidget(Widget chatbox, int mouseX, int mouseY)
    {
        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        if (dynamicChildren == null)
        {
            return null;
        }

        for (Widget widget : dynamicChildren)
        {
            if (widget == null)
            {
                continue;
            }

            net.runelite.api.Point widgetPos = widget.getCanvasLocation();
            if (widgetPos == null)
            {
                continue;
            }

            int widgetX = widgetPos.getX();
            int widgetY = widgetPos.getY();
            int widgetWidth = widget.getWidth();
            int widgetHeight = widget.getHeight();

            boolean isHovered = mouseX >= widgetX && mouseX <= widgetX + widgetWidth
                && mouseY >= widgetY && mouseY <= widgetY + widgetHeight;

            if (isHovered)
            {
                return widget;
            }
        }

        return null;
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.customemoji.EmojiPosition;
import com.customemoji.EmojiPositionCalculator;

import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class EmojiHitboxOverlay extends Overlay
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiDebugConfig config;

    public EmojiHitboxOverlay()
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (this.config.showEmojiHitboxes())
        {
            this.drawEmojiHitBorders(graphics);
        }
        return null;
    }

    private void drawEmojiHitBorders(Graphics2D graphics)
    {
        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return;
        }

        List<Rectangle> rectangles = new ArrayList<>();
        this.collectAllEmojiRectangles(chatbox, rectangles);

        if (rectangles.isEmpty())
        {
            return;
        }

        // Get the chatbox visible bounds to clip drawing
        net.runelite.api.Point chatboxPos = chatbox.getCanvasLocation();
        int chatboxX = chatboxPos.getX();
        int chatboxY = chatboxPos.getY();
        int chatboxWidth = chatbox.getWidth();
        int chatboxHeight = chatbox.getHeight();
        Rectangle chatboxBounds = new Rectangle(chatboxX, chatboxY, chatboxWidth, chatboxHeight);

        // Save original clip and set clip to chatbox bounds
        Shape originalClip = graphics.getClip();
        graphics.setClip(chatboxBounds);

        Color originalColor = graphics.getColor();
        graphics.setColor(Color.CYAN);

        for (Rectangle rect : rectangles)
        {
            graphics.drawRect(rect.x, rect.y, rect.width, rect.height);
        }

        graphics.setColor(originalColor);
        graphics.setClip(originalClip);
    }

    private void collectAllEmojiRectangles(Widget chatbox, List<Rectangle> rectangles)
    {
        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        if (dynamicChildren == null)
        {
            return;
        }

        for (Widget widget : dynamicChildren)
        {
            if (widget == null)
            {
                continue;
            }

            String text = widget.getText();
            if (text != null && text.contains("<img="))
            {
                this.collectEmojiRectanglesFromWidget(widget, text, rectangles);
            }
        }
    }

    private void collectEmojiRectanglesFromWidget(Widget widget, String text, List<Rectangle> rectangles)
    {
        List<EmojiPosition> positions = EmojiPositionCalculator.calculateEmojiPositions(
            widget,
            text,
            this::getSpriteDimension
        );

        for (EmojiPosition position : positions)
        {
            rectangles.add(position.getBounds());
        }
    }

    private Dimension getSpriteDimension(int imageId)
    {
        IndexedSprite[] modIcons = this.client.getModIcons();
        if (modIcons == null || imageId < 0 || imageId >= modIcons.length)
        {
            return null;
        }

        IndexedSprite sprite = modIcons[imageId];
        if (sprite == null)
        {
            return null;
        }

        return new Dimension(sprite.getWidth(), sprite.getHeight());
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;
import javax.inject.Singleton;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;

@Singleton
public class AnimationCounterOverlay extends Overlay
{
	private static final String PLUGIN_MESSAGE_NAMESPACE = "custom-emoji";
	private static final String ANIMATION_COUNT_MESSAGE = "animation-count";
	private static final String ANIMATION_COUNT_KEY = "count";

	private final Client client;
	private final CustomEmojiDebugConfig config;
	private final EventBus eventBus;

	private int animatedCount = 0;

	@Inject
	public AnimationCounterOverlay(Client client, CustomEmojiDebugConfig config, EventBus eventBus)
	{
		this.client = client;
		this.config = config;
		this.eventBus = eventBus;

		this.setPosition(OverlayPosition.DYNAMIC);
		this.setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	public void startUp()
	{
		this.eventBus.register(this);
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.animatedCount = 0;
	}

	@Subscribe
	public void onPluginMessage(PluginMessage event)
	{
		boolean isOurNamespace = PLUGIN_MESSAGE_NAMESPACE.equals(event.getNamespace());
		boolean isCountMessage = ANIMATION_COUNT_MESSAGE.equals(event.getName());

		if (!isOurNamespace || !isCountMessage)
		{
			return;
		}

		Object countValue = event.getData().get(ANIMATION_COUNT_KEY);
		if (countValue instanceof Integer)
		{
			this.animatedCount = (Integer) countValue;
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!this.config.showAnimationCounter())
		{
			return null;
		}

		Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
		if (chatbox == null)
		{
			return null;
		}

		Rectangle chatboxBounds = chatbox.getBounds();
		if (chatboxBounds == null)
		{
			return null;
		}

		this.renderCounter(graphics, chatboxBounds);

		return null;
	}

	private void renderCounter(Graphics2D graphics, Rectangle chatboxBounds)
	{
		String text = "Animated: " + this.animatedCount;
		int x = chatboxBounds.x;
		int y = chatboxBounds.y - 5;

		graphics.setColor(Color.BLACK);
		graphics.drawString(text, x + 1, y + 1);
		graphics.setColor(Color.YELLOW);
		graphics.drawString(text, x, y);
	}
}

