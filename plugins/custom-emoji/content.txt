package com.customemoji;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;

import net.runelite.api.IndexedSprite;
import net.runelite.api.SpritePixels;
import net.runelite.client.util.ImageUtil;

/**
 * Utility class for preprocessing emoji images for RuneLite compatibility.
 * Handles image resizing, color quantization, and transparency corrections.
 */
public class CustomEmojiImageUtilities 
{
    // Constants
    private static final int MAX_PALETTE_SIZE = 255;
    private static final int NEAR_BLACK_VALUE = 1; // RGB(1,1,1) to avoid transparency issues
    
    /**
     * Manually converts an IndexedSprite to a BufferedImage using pixel data.
     * @param sprite The IndexedSprite to convert
     * @return A BufferedImage representation of the sprite
     */
    public static BufferedImage indexedSpriteToBufferedImage(IndexedSprite sprite)
    {
        if (sprite == null)
        {
            return null;
        }
        
        int width = sprite.getWidth();
        int height = sprite.getHeight();
        byte[] pixels = sprite.getPixels();
        int[] palette = sprite.getPalette();
              
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        
        if (pixels != null && palette != null)
        {
            // Convert indexed pixels to ARGB using the palette
            int[] argbPixels = new int[width * height];
            
            for (int i = 0; i < pixels.length && i < argbPixels.length; i++)
            {
                int index = pixels[i] & 0xFF; // Convert byte to unsigned int
                if (index < palette.length)
                {
                    // Get color from palette
                    int color = palette[index];
                    // Ensure alpha channel is set (if color doesn't have alpha, add it)
                    if ((color & 0xFF000000) == 0 && color != 0)
                    {
                        // If no alpha channel set but color is not black, make it opaque
                        color = color | 0xFF000000;
                    }
                    argbPixels[i] = color;
                }
                else
                {
                    // Index out of bounds - make it opaque red for debugging
                    argbPixels[i] = 0xFFFF0000;
                }
            }
            
            image.setRGB(0, 0, width, height, argbPixels, 0, width);
        }
        
        return image;
    }
    
    /**
     * Normalizes an image by applying resizing, quantization, and black pixel fixes.
     * @param image The input image to normalize
     * @param config Configuration settings for resizing
     * @return The normalized image ready for RuneLite
     */
    public static BufferedImage normalizeImage(BufferedImage image, CustomEmojiConfig config)
    {
        BufferedImage sizedResult = image;
        int maxImageHeight = config.maxImageHeight();
        if (config.resizeEmoji() && image.getHeight() > maxImageHeight)
        {
            // Calculate new width while preserving aspect ratio
            double scaleFactor = (double) maxImageHeight / image.getHeight();
            int scaledWidth = (int) Math.round(image.getWidth() * scaleFactor);
            
            sizedResult = ImageUtil.resizeImage(image, scaledWidth, maxImageHeight, true);
        }

        BufferedImage quantizedResult = quantizeIfNeeded(sizedResult, MAX_PALETTE_SIZE);
        return fixPureBlackPixels(quantizedResult);
    }

    /**
     * Fixes pure black pixels by converting them to near-black to prevent
     * RuneLite from treating them as transparent.
     * @param image The input image
     * @return Image with corrected black pixels
     */
    public static BufferedImage fixPureBlackPixels(BufferedImage image)
    {
        BufferedImage result = new BufferedImage(
            image.getWidth(),
            image.getHeight(),
            BufferedImage.TYPE_INT_ARGB
        );
        
        for (int y = 0; y < image.getHeight(); y++)
        {
            for (int x = 0; x < image.getWidth(); x++)
            {
                int argb = image.getRGB(x, y);
                int alpha = (argb >> 24) & 0xff;
                int red = (argb >> 16) & 0xff;
                int green = (argb >> 8) & 0xff;
                int blue = argb & 0xff;
                
                // If pixel is opaque pure black, make it slightly not-black
                if (alpha > 0 && red == 0 && green == 0 && blue == 0)
                {
                    // Change to RGB (1,1,1) which is visually indistinguishable from black
                    // but won't be treated as transparent by RuneLite
                    int newArgb = (alpha << 24) | 
                                  (NEAR_BLACK_VALUE << 16) | 
                                  (NEAR_BLACK_VALUE << 8) | 
                                  NEAR_BLACK_VALUE;
                    result.setRGB(x, y, newArgb);
                }
                else
                {
                    result.setRGB(x, y, argb);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Checks if image has more colors than allowed and quantizes if needed.
     * @param image The input BufferedImage
     * @param maxColors Maximum number of colors allowed
     * @return A BufferedImage with maxColors or fewer
     */
    public static BufferedImage quantizeIfNeeded(BufferedImage image, int maxColors) {
        Set<Integer> uniqueColors = getUniqueColors(image);
        
        if (uniqueColors.size() <= maxColors) {
            return image; // No quantization needed
        }
        
        return quantizeToColors(image, maxColors);
    }
    
    /**
     * Gets all unique colors in the image
     * @param image The input BufferedImage
     * @return Set of unique RGB color values
     */
    private static Set<Integer> getUniqueColors(BufferedImage image) {
        Set<Integer> colors = new HashSet<>();
        
        for (int y = 0; y < image.getHeight(); y++) {
            for (int x = 0; x < image.getWidth(); x++) {
                colors.add(image.getRGB(x, y));
            }
        }
        
        return colors;
    }
    
    /**
     * Quantizes image to specified number of colors using median cut algorithm.
     * Handles transparency separately to preserve alpha values.
     * @param image The input BufferedImage
     * @param maxColors Maximum number of colors
     * @return Quantized BufferedImage with preserved transparency
     */
    private static BufferedImage quantizeToColors(BufferedImage image, int maxColors) {
        // Separate opaque and transparent colors
        Set<Integer> uniqueColors = getUniqueColors(image);
        List<Color> opaqueColors = new ArrayList<>();
        boolean hasTransparency = false;
        
        for (Integer argb : uniqueColors) {
            Color color = new Color(argb, true);
            if (color.getAlpha() == 0) {
                hasTransparency = true;
            } else {
                // Only add non-transparent colors to quantization
                opaqueColors.add(color);
            }
        }
        
        // Account for transparent color in palette if present
        int effectiveMaxColors = hasTransparency ? maxColors - 1 : maxColors;
        
        // If already within limit, return original
        if (opaqueColors.size() <= effectiveMaxColors) {
            return image;
        }
        
        // Apply median cut quantization only to opaque colors
        List<Color> palette = medianCut(opaqueColors, effectiveMaxColors);
        
        // Add transparent color to palette if needed
        if (hasTransparency) {
            palette.add(new Color(0, 0, 0, 0));
        }
        
        // Create new quantized image
        return applyPalette(image, palette);
    }
    
    /**
     * Median cut algorithm for color quantization
     */
    private static List<Color> medianCut(List<Color> colors, int maxColors) {
        List<ColorBox> boxes = new ArrayList<>();
        boxes.add(new ColorBox(colors));
        
        while (boxes.size() < maxColors) {
            // Find box with largest range
            ColorBox largestBox = null;
            int largestRange = -1;
            
            for (ColorBox box : boxes) {
                int range = box.getLargestRange();
                if (range > largestRange) {
                    largestRange = range;
                    largestBox = box;
                }
            }
            
            if (largestBox == null || largestRange == 0) {
                break; // Can't split further
            }
            
            // Split the box
            ColorBox[] split = largestBox.split();
            boxes.remove(largestBox);
            boxes.add(split[0]);
            boxes.add(split[1]);
        }
        
        // Get average color from each box
        List<Color> palette = new ArrayList<>();
        for (ColorBox box : boxes) {
            palette.add(box.getAverageColor());
        }
        
        return palette;
    }
    
    /**
     * Apply palette to image using nearest color matching
     */
    private static BufferedImage applyPalette(BufferedImage original, List<Color> palette) {
        BufferedImage result = new BufferedImage(
            original.getWidth(), 
            original.getHeight(), 
            BufferedImage.TYPE_INT_ARGB
        );
        
        for (int y = 0; y < original.getHeight(); y++) {
            for (int x = 0; x < original.getWidth(); x++) {
                int argb = original.getRGB(x, y);
                Color originalColor = new Color(argb, true);
                
                // Keep fully transparent pixels as-is
                if (originalColor.getAlpha() == 0) {
                    result.setRGB(x, y, 0); // Fully transparent
                } else {
                    // For non-transparent pixels, find nearest opaque color
                    List<Color> opaquePalette = new ArrayList<>();
                    for (Color c : palette) {
                        if (c.getAlpha() > 0) {
                            opaquePalette.add(c);
                        }
                    }
                    Color nearestColor = findNearestColor(originalColor, opaquePalette);
                    // Combine nearest RGB with original alpha
                    int newArgb = (originalColor.getAlpha() << 24) | 
                                  (nearestColor.getRed() << 16) | 
                                  (nearestColor.getGreen() << 8) | 
                                  nearestColor.getBlue();
                    result.setRGB(x, y, newArgb);
                }
            }
        }
        
        return result;
    }
    
    /**
     * Find nearest color in palette using Euclidean distance
     */
    private static Color findNearestColor(Color target, List<Color> palette) {
        Color nearest = palette.get(0);
        double minDistance = colorDistance(target, nearest);
        
        for (Color color : palette) {
            double distance = colorDistance(target, color);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = color;
            }
        }
        
        return nearest;
    }
    
    /**
     * Calculate Euclidean distance between two colors (RGB only, not alpha)
     */
    private static double colorDistance(Color c1, Color c2) {
        int dr = c1.getRed() - c2.getRed();
        int dg = c1.getGreen() - c2.getGreen();
        int db = c1.getBlue() - c2.getBlue();
        // Don't include alpha in distance calculation since we preserve original alpha
        return Math.sqrt(dr * dr + dg * dg + db * db);
    }
    
    /**
     * Helper class for median cut algorithm
     */
    private static class ColorBox {
        private List<Color> colors;
        
        public ColorBox(List<Color> colors) {
            this.colors = new ArrayList<>(colors);
        }
        
        public int getLargestRange() {
            if (colors.isEmpty()) return 0;
            
            int minR = 255, maxR = 0;
            int minG = 255, maxG = 0;
            int minB = 255, maxB = 0;
            
            for (Color color : colors) {
                minR = Math.min(minR, color.getRed());
                maxR = Math.max(maxR, color.getRed());
                minG = Math.min(minG, color.getGreen());
                maxG = Math.max(maxG, color.getGreen());
                minB = Math.min(minB, color.getBlue());
                maxB = Math.max(maxB, color.getBlue());
            }
            
            int rangeR = maxR - minR;
            int rangeG = maxG - minG;
            int rangeB = maxB - minB;
            
            return Math.max(rangeR, Math.max(rangeG, rangeB));
        }
        
        public ColorBox[] split() {
            if (colors.size() <= 1) {
                return new ColorBox[]{this, new ColorBox(new ArrayList<>())};
            }
            
            // Find dimension with largest range
            int minR = 255, maxR = 0;
            int minG = 255, maxG = 0;
            int minB = 255, maxB = 0;
            
            for (Color color : colors) {
                minR = Math.min(minR, color.getRed());
                maxR = Math.max(maxR, color.getRed());
                minG = Math.min(minG, color.getGreen());
                maxG = Math.max(maxG, color.getGreen());
                minB = Math.min(minB, color.getBlue());
                maxB = Math.max(maxB, color.getBlue());
            }
            
            int rangeR = maxR - minR;
            int rangeG = maxG - minG;
            int rangeB = maxB - minB;
            
            // Sort by the dimension with largest range (RGB only)
            if (rangeR >= rangeG && rangeR >= rangeB) {
                colors.sort(Comparator.comparingInt(Color::getRed));
            } else if (rangeG >= rangeB) {
                colors.sort(Comparator.comparingInt(Color::getGreen));
            } else {
                colors.sort(Comparator.comparingInt(Color::getBlue));
            }
            
            // Split at median
            int median = colors.size() / 2;
            List<Color> left = colors.subList(0, median);
            List<Color> right = colors.subList(median, colors.size());
            
            return new ColorBox[]{new ColorBox(left), new ColorBox(right)};
        }
        
        public Color getAverageColor() {
            if (colors.isEmpty()) return Color.BLACK;
            
            long sumR = 0, sumG = 0, sumB = 0;
            for (Color color : colors) {
                sumR += color.getRed();
                sumG += color.getGreen();
                sumB += color.getBlue();
            }
            
            int avgR = (int) (sumR / colors.size());
            int avgG = (int) (sumG / colors.size());
            int avgB = (int) (sumB / colors.size());
            
            // Return opaque color since we handle alpha separately
            return new Color(avgR, avgG, avgB);
        }
    }
}
package com.customemoji;

import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.IconID;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.MouseEvent;

@Slf4j
@Singleton
public class CustomEmojiTooltip extends Overlay
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    @Inject
    private CustomEmojiPlugin plugin;

    @Inject
    private TooltipManager tooltipManager;

    @Inject
    private MouseManager mouseManager;

    @Inject
    private ChatIconManager chatIconManager;

    // Tooltip state
    private String hoveredEmojiName = null;
    private Point mousePosition = null;

    private final MouseListener mouseListener = new MouseListener()
	{
		@Override
		public MouseEvent mouseClicked(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mousePressed(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseReleased(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseEntered(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseExited(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseDragged(MouseEvent mouseEvent)
		{
			return mouseEvent;
		}

		@Override
		public MouseEvent mouseMoved(MouseEvent mouseEvent)
		{
			Point currentPoint = mouseEvent.getPoint();

			// Only update if mouse actually moved a good bit
			if (mousePosition == null || 
				Math.abs(currentPoint.x - mousePosition.x) > 2 || 
				Math.abs(currentPoint.y - mousePosition.y) > 2)
			{
				mousePosition = currentPoint;

				// Delegate to overlay for tooltip handling
				updateHoveredEmoji(currentPoint);
			}
			return mouseEvent;
		}
	};

    protected void startUp()
    {
        if (mouseManager != null)
        {
            mouseManager.registerMouseListener(mouseListener);
        }
    }

    protected void shutDown()
    {
        if (mouseManager != null)
        {
            mouseManager.unregisterMouseListener(mouseListener);
        }
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        showTooltip();
        return null;
    }

    private void showTooltip()
    {
        if (hoveredEmojiName != null && !hoveredEmojiName.isEmpty() && config.showEmojiTooltips())
        {
            tooltipManager.add(new Tooltip(hoveredEmojiName));
        }
    }

    private void updateHoveredEmoji(Point mousePoint)
    {
        this.mousePosition = mousePoint;

        String foundEmoji = null;

        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null || isPointInWidget(chatbox, mousePoint) == false)
        {
            this.hoveredEmojiName = null;
            return;
        }

        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        
        foundEmoji = this.checkWidgetsForEmoji(dynamicChildren, mousePoint);
        this.hoveredEmojiName = foundEmoji;
    }

    private String checkWidgetsForEmoji(Widget[] widgets, Point mousePoint)
    {
        if (widgets == null)
        {
            return null;
        }

        for (Widget widget : widgets)
        {
            if (widget == null)
            {
                continue;
            }
            
            // Check if mouse is within widget bounds (with expanded Y for tall emojis)
            if (isPointInWidgetWithEmojiPadding(widget, mousePoint))
            {
                String text = widget.getText();
                if (text != null && text.contains("<img="))
                {
                    String hoveredEmoji = findEmojiAtPosition(widget, text, mousePoint);
                    if (hoveredEmoji != null)
                    {
                        return hoveredEmoji;
                    }
                }
            }
        }
        return null;
    }

    private boolean isPointInWidgetWithEmojiPadding(Widget widget, Point point)
    {
        net.runelite.api.Point canvasLocation = widget.getCanvasLocation();
        if (canvasLocation == null)
        {
            return false;
        }

        int x = canvasLocation.getX();
        int y = canvasLocation.getY();
        int width = widget.getWidth();
        int height = widget.getHeight();

        // Emojis can extend above and below the widget's 14px height
        // Add padding to account for taller emojis (up to ~32px tall emojis)
        int verticalPadding = this.config.chatMessageSpacing() + this.config.chatMessageSpacing();

        return point.x >= x && point.x <= x + width &&
               point.y >= y - verticalPadding && point.y <= y + height + verticalPadding;
    }

    private boolean isPointInWidget(Widget widget, Point point)
    {
        net.runelite.api.Point canvasLocation = widget.getCanvasLocation();
        if (canvasLocation == null)
        {
            return false;
        }

        int x = canvasLocation.getX();
        int y = canvasLocation.getY();
        int width = widget.getWidth();
        int height = widget.getHeight();

        return point.x >= x && point.x <= x + width &&
               point.y >= y && point.y <= y + height;
    }

    private String findEmojiAtPosition(Widget widget, String text, Point mousePoint)
    {
        int imageId = EmojiPositionCalculator.findEmojiAtPoint(
            widget,
            text,
            mousePoint.x,
            mousePoint.y,
            this::getEmojiDimension
        );

        if (imageId >= 0)
        {
            return this.findEmojiNameById(imageId);
        }

        return null;
    }

    private Dimension getEmojiDimension(int imageId)
    {
        // Try to get dimension from modIcons sprite array directly
        IndexedSprite[] modIcons = this.client.getModIcons();
        if (modIcons != null && imageId >= 0 && imageId < modIcons.length)
        {
            IndexedSprite sprite = modIcons[imageId];
            if (sprite != null)
            {
                return new Dimension(sprite.getWidth(), sprite.getHeight());
            }
        }
        return null;
    }

    private String findEmojiNameById(int imageId)
    {
        // Check custom emojis first
        for (CustomEmojiPlugin.Emoji emoji : this.plugin.emojis.values())
        {
            if (this.chatIconManager.chatIconIndex(emoji.getId()) == imageId)
            {
                return emoji.getText();
            }
        }

        // Check built-in RuneLite IconIDs
        for (IconID icon : IconID.values())
        {
            if (icon.getIndex() == imageId)
            {
                return this.formatIconName(icon.name());
            }
        }

        return null;
    }

    private String formatIconName(String enumName)
    {
        // Convert PLAYER_MODERATOR to "Player Moderator"
        String[] words = enumName.toLowerCase().split("_");
        StringBuilder result = new StringBuilder();
        for (String word : words)
        {
            if (result.length() > 0)
            {
                result.append(" ");
            }
            result.append(Character.toUpperCase(word.charAt(0)));
            result.append(word.substring(1));
        }
        return result.toString();
    }
}

package com.customemoji;

import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.annotation.Nullable;
import java.awt.Rectangle;
import javax.inject.Inject;
import javax.inject.Singleton;

import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.function.Supplier;

@Slf4j
@Singleton
public class ChatSpacingManager
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    private final Map<Integer, List<Widget>> originalChatPositions = new HashMap<>();
    private final int LAST_MESSAGE_PADDING = 4;
    private int scrolledUpPixels = 0;

    public void clearStoredPositions()
    {
        this.originalChatPositions.clear();
    }

    public void captureScrollPosition()
    {
        Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return;
        }

        int scrollY = chatbox.getScrollY();
        int scrollHeight = chatbox.getScrollHeight();
        int visibleHeight = chatbox.getHeight();

        if (scrollHeight <= visibleHeight) // Cant scroll if there aren't enough messages
        {
            this.scrolledUpPixels = 0;
            return;
        }

        // Calculate how far up from the bottom the user has scrolled (in lines)
        int newValue = scrollHeight - (visibleHeight + scrollY);

        if (newValue == this.scrolledUpPixels)
        {
            return;
        }

        this.scrolledUpPixels = scrollHeight - (visibleHeight + scrollY);
        log.debug("Captured scroll position: {} pixels from bottom", this.scrolledUpPixels);
    }

    public void applyChatSpacing()
    {
        int spacingAdjustment = config.chatMessageSpacing();

        if (spacingAdjustment == 0)
        {
            return; // Setting is essentially disabled
        }

        Widget chatbox = client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null || chatbox.isHidden())
        {
            return;
        }

        Widget[] dynamicChildren = this.getChildren(chatbox::getDynamicChildren); // Needed for visible stuff
        Widget[] staticChildren = this.getChildren(chatbox::getStaticChildren); // Needed for right-click context menus

        // Handle null arrays
        if (dynamicChildren == null) dynamicChildren = new Widget[0];
        if (staticChildren == null) staticChildren = new Widget[0];

        // Combine dynamic and static children into a single array
        Widget[] allChildren = new Widget[dynamicChildren.length + staticChildren.length];
        System.arraycopy(dynamicChildren, 0, allChildren, 0, dynamicChildren.length);
        System.arraycopy(staticChildren, 0, allChildren, dynamicChildren.length, staticChildren.length);

        Rectangle bounds = this.adjustChildren(allChildren, spacingAdjustment);

        this.updateChatBox(chatbox, bounds);
    }

    private void updateChatBox(Widget chatbox, Rectangle bounds)
    {
        if (bounds == null)
        {
            return;
        }

        int visibleHeight = chatbox.getHeight();

        if (visibleHeight > bounds.height)
        {
            return;
        }

        // Calculate new scroll height based on the bounds of all widgets
        int newScrollHeight = bounds.height + LAST_MESSAGE_PADDING;

        log.debug(String.valueOf(newScrollHeight));

        // Update the scroll height
        chatbox.setScrollHeight(newScrollHeight);

        // Restore scroll position based on how many lines the user was scrolled up from bottom
        boolean atBottom = this.scrolledUpPixels == 0.0;

        float scrolledUpPixelsLocal = atBottom ? this.scrolledUpPixels : this.scrolledUpPixels + this.config.chatMessageSpacing();

        int newScrollY = (int) (newScrollHeight - visibleHeight - scrolledUpPixelsLocal);
        newScrollY = Math.max(0, newScrollY);

        chatbox.revalidateScroll();

        this.client.runScript(ScriptID.UPDATE_SCROLLBAR, InterfaceID.Chatbox.CHATSCROLLBAR, InterfaceID.Chatbox.SCROLLAREA, newScrollY);

        this.captureScrollPosition();
    }

    @Nullable
    private Rectangle adjustChildren(Widget[] children, int spacingAdjustment)
    {
        if (children == null)
        {
            return null;
        }

        // Sort the array so that we adjust them in the proper order. The parent widget
        // has them in the proper order, but split by static or dynamic widget category.
        Widget[] sortedChildren = this.sortByYPosition(children);

        // Reverse the children array so last becomes first.
        // This makes it simpler to adjust the positions of every widget.
        // We start at the oldest message at the very top and work our way down
        Widget[] reversedSortedChildren = reverseArrayOrder(sortedChildren);

        // Group widgets by their original Y position
        Map<Integer, List<Widget>> widgetsByOriginalY = new HashMap<>();

        for (Widget child : reversedSortedChildren)
        {
            if (child == null || child.isHidden())
            {
                continue;
            }

            int storedY = this.resolveOriginalYPosition(child);
            widgetsByOriginalY.computeIfAbsent(storedY, k -> new ArrayList<>()).add(child);
        }

        // Sort the original Y positions and apply spacing to each group
        List<Integer> sortedOriginalYs = new ArrayList<>(widgetsByOriginalY.keySet());
        sortedOriginalYs.sort(Integer::compareTo);

        // Track bounds for the bounding rectangle
        int minX = 0;
        int minY = 0;
        int maxX = 0;
        int maxY = 0;

        int lastLineHeight = 0;

        int counter = 0;
        for (Integer originalYPos : sortedOriginalYs)
        {
            List<Widget> widgetsAtThisY = widgetsByOriginalY.get(originalYPos);
            int newY = originalYPos + (counter * spacingAdjustment);
            
            // Apply the same Y position and settings to all widgets at the same original y position
            // This is done so that all elements line up with each other.
            for (Widget child : widgetsAtThisY)
            {
                child.setOriginalY(newY);
                child.revalidate();

                // Update bounding rectangle
                int childX = child.getOriginalX();
                int childY = child.getOriginalY();
                int childRight = childX + child.getOriginalWidth();
                int childBottom = childY + child.getOriginalHeight();

                minX = Math.min(minX, childX);
                minY = Math.min(minY, childY);
                maxX = Math.max(maxX, childRight);
                maxY = Math.max(maxY, childBottom);

                if (counter == 0)
                {
                    lastLineHeight = Math.max(lastLineHeight, child.getOriginalHeight());
                }
                
            }

            counter++;
        }

        boolean hasWidgets = minX != Integer.MAX_VALUE;
        if (!hasWidgets)
        {
            return null;
        }

        return new Rectangle(minX, minY, maxX - minX, maxY - minY);
    }

    private Widget[] sortByYPosition(Widget[] array)
    {
        // Sort by stored Y position
        Arrays.sort(array, (w1, w2) -> {
            if (w1 == null && w2 == null) return 0;
            if (w1 == null) return 1;
            if (w2 == null) return -1;
            
            // Find the stored Y position for each widget by searching through originalChatPositions
            Integer storedY1 = getStoredYPosition(w1);
            Integer storedY2 = getStoredYPosition(w2);
            
            // Use stored position if available, otherwise use current position
            int y1 = storedY1 != null ? storedY1 : w1.getOriginalY();
            int y2 = storedY2 != null ? storedY2 : w2.getOriginalY();
            
            return Integer.compare(y1, y2);
        });

        return array;
    }
    
    private Integer getStoredYPosition(Widget widget)
    {
        // Search through originalChatPositions to find which Y position this widget belongs to
        for (Map.Entry<Integer, List<Widget>> entry : this.originalChatPositions.entrySet())
        {
            if (entry.getValue().contains(widget))
            {
                return entry.getKey();
            }
        }
        // If not found in stored positions, return null
        return null;
    }

    private int resolveOriginalYPosition(Widget widget)
    {
        int currentY = widget.getOriginalY();

        Integer storedY = this.getStoredYPosition(widget);
        if (storedY != null && storedY != currentY)
        {
            return storedY;
        }

        boolean isAlreadyStored = this.originalChatPositions.values().stream()
            .anyMatch(widgets -> widgets.contains(widget));

        if (!isAlreadyStored)
        {
            this.originalChatPositions
                .computeIfAbsent(currentY, k -> new ArrayList<>())
                .add(widget);
        }

        return currentY;
    }

    private static Widget[] reverseArrayOrder(Widget[] array)
    {
        int len = array.length;
        Widget[] result = new Widget[len];
        
        for (int i = 0; i < len; i++)
        {
            result[i] = array[len - 1 - i];
        }

        return result;
    }

    private Widget[] getChildren(Supplier<Widget[]> childrenSupplier)
    {
        List<Widget> result = new ArrayList<Widget>();
        for (Widget child : childrenSupplier.get()) 
        {
            int height = child.getOriginalHeight();

            if (height == 0)
            {
                continue;
            }

            result.add(child);
        }
        
        return result.toArray(new Widget[0]);
    }
}
/**
 * Author: Louis Hong
 */

package com.customemoji;

import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.function.Function;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;

/**
 * Mom: We have Rust at home<br>
 * Rust at home: {@link Result}
 */
@NonNull
public interface Result<@NonNull V, @NonNull E>
{

	@NonNull
	static <V, E> Result<V, E> Ok(V value)
	{
		return new OkResult<>(value);
	}

	@NonNull
	static <E> Result<Void, E> Ok()
	{
		return new OkResult<>(null);
	}

	@NonNull
	static <V, E> Result<V, E> Error(@NonNull E exception)
	{
		return new ErrorResult<>(exception);
	}

	@NonNull
	static <V, E> Result<V, E> PartialOk(V value, E exception)
	{
		return new PartialResult<>(value, exception);
	}


	boolean isOk();

	boolean isError();

	void ifOk(@NonNull Consumer<? super V> then);

	void ifOk(@NonNull Runnable then);

	void ifError(@NonNull Consumer<? super E> then);

	<V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper);

	<E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper);

	Optional<V> toOptional();

	@NonNull
	V unwrap() throws IllegalUnwrapException;

	@NonNull
	E unwrapError() throws IllegalUnwrapException;


	@NonNull
	static <V> Result<V, NoSuchElementException> fromNullable(@Nullable V value)
	{
		if (value == null)
		{
			return Error(new NoSuchElementException("Value is null"));
		}
		else
		{
			return Ok(value);
		}
	}

	@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
	@NonNull
	static <V> Result<V, NoSuchElementException> fromOptional(Optional<V> value)
	{
		if (value.isEmpty())
		{
			return Error(new NoSuchElementException("Value is null"));
		}
		else
		{
			return Ok(value.get());
		}
	}

	@AllArgsConstructor(access=AccessLevel.PUBLIC)
	class OkResult<@NonNull V, E> implements Result<V, E>
	{
		private final V value;

		@Override
		public boolean isOk() {return true;}

		@Override
		public boolean isError() {return false;}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then)
		{
			then.accept(value);
		}

		@Override
		public void ifOk(@NonNull Runnable then)
		{
			then.run();
		}

		@Override
		public void ifError(@NonNull Consumer<? super E> then) {}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new OkResult<>(mapper.apply(value));
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new OkResult<>(value);
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.of(value);
		}

		@Override
		public @NonNull V unwrap()
		{
			return value;
		}

		@Override
		public @NonNull E unwrapError() throws IllegalUnwrapException
		{
			throw new IllegalUnwrapException("Cannot unwrap error from Ok result");
		}

	}

	@Slf4j
	@AllArgsConstructor(access=AccessLevel.PRIVATE)
	class ErrorResult<V, @NonNull E> implements Result<V, E>
	{
		private final E exception;

		@Override
		public boolean isOk() {return false;}

		@Override
		public boolean isError() {return true;}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then) {}

		@Override
		public void ifOk(@NonNull Runnable then) {}

		@Override
		public void ifError(@NonNull Consumer<? super E> then)
		{
			then.accept(exception);
		}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new ErrorResult<>(exception);
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new ErrorResult<>(mapper.apply(exception));
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.empty();
		}

		@Override
		public @NonNull V unwrap() throws IllegalStateException
		{
			throw new IllegalUnwrapException("Cannot unwrap value from Error result");
		}

		@Override
		public @NonNull E unwrapError()
		{
			return exception;
		}
	}

	@Slf4j
	@AllArgsConstructor(access=AccessLevel.PRIVATE)
	class PartialResult<V, @NonNull E> implements Result<V, E>
	{
		private final V value;
		private final E exception;

		@Override
		public boolean isOk()
		{
			return true;
		}

		@Override
		public boolean isError()
		{
			return true;
		}

		@Override
		public void ifOk(@NonNull Consumer<? super V> then)
		{
			then.accept(value);
		}

		@Override
		public void ifOk(@NonNull Runnable then)
		{
			then.run();
		}

		@Override
		public void ifError(@NonNull Consumer<? super E> then)
		{
			then.accept(exception);
		}

		@Override
		public <V2> Result<V2, E> map(@NonNull Function<? super V, V2> mapper)
		{
			return new PartialResult<>(mapper.apply(value), exception);
		}

		@Override
		public <E2> Result<V, E2> mapError(@NonNull Function<? super E, E2> mapper)
		{
			return new PartialResult<>(value, mapper.apply(exception));
		}

		@Override
		public Optional<V> toOptional()
		{
			return Optional.of(value);
		}

		@Override
		public @NonNull V unwrap()
		{
			return value;
		}

		@Override
		public @NonNull E unwrapError()
		{
			return exception;
		}
	}

	class IllegalUnwrapException extends IllegalStateException
	{
		public IllegalUnwrapException(String message)
		{
			super(message);
		}
	}

	class ResultFutures
	{
		@NonNull
		public static <V, E extends Throwable> ListenableFuture<Result<V, E>> immediateError(@NonNull E exception)
		{
			return Futures.immediateFuture(Error(exception));
		}

		@NonNull
		public static <V, E extends Throwable> ListenableFuture<Result<V, E>> immediateOk(@NonNull V value)
		{
			return Futures.immediateFuture(Ok(value));
		}

		@NonNull
		public static <E extends Throwable> ListenableFuture<Result<Void, E>> immediateOk()
		{
			return Futures.immediateFuture(Ok());
		}

	}
}

package com.customemoji;

import static com.customemoji.Result.Error;
import static com.customemoji.Result.Ok;
import static com.customemoji.Result.PartialOk;
import com.google.common.io.Resources;
import com.google.inject.Provides;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.*;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import lombok.NonNull;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.MessageNode;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.RuneLite;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
		name="Custom Emoji",
		description="Allows you to use custom emojis in chat messages",
		tags={"emoji", "chat", "message", "custom", "icon", "emote", "text", "clan", "notification"}
)
public class CustomEmojiPlugin extends Plugin
{
	public static final String EMOJI_ERROR_COMMAND = "emojierror";
	public static final String EMOJI_FOLDER_COMMAND = "emojifolder";
	public static final String SOUNDOJI_FOLDER_COMMAND = "soundojifolder";
	public static final String PRINT_ALL_EMOJI_COMMAND = "emojiprint";

	public static final File SOUNDOJIS_FOLDER = RuneLite.RUNELITE_DIR.toPath().resolve("soundojis").toFile();
	public static final File EMOJIS_FOLDER = RuneLite.RUNELITE_DIR.toPath().resolve("emojis").toFile();

	public static final URL EXAMPLE_EMOJI = Resources.getResource(CustomEmojiPlugin.class, "checkmark.png");
	public static final URL EXAMPLE_SOUNDOJI = Resources.getResource(CustomEmojiPlugin.class, "customemoji.wav");

	public static final float NOISE_FLOOR = -60f;

	private static final Pattern WHITESPACE_REGEXP = Pattern.compile("[\\s\\u00A0]");

	@Value
	protected static class Emoji
	{
		int id;
		String text;
		File file;
		long lastModified;
		Dimension dimension;

		public BufferedImage getCacheImage(Client client, ChatIconManager chatIconManager)
		{
			int iconIndex = chatIconManager.chatIconIndex(id);
			IndexedSprite indexedSprite = client.getModIcons()[iconIndex];
			if (indexedSprite != null)
			{
				return CustomEmojiImageUtilities.indexedSpriteToBufferedImage(indexedSprite);
			}
			
			return null;
		}
	}

	@Value
	private static class Soundoji
	{
		String text;
		File file;
	}

	@Inject
	private CustomEmojiOverlay overlay;

	@Inject
	private CustomEmojiTooltip tooltip;

	@Inject
	private CustomEmojiConfig config;

	@Inject
	private ChatIconManager chatIconManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private AudioPlayer audioPlayer;

	@Inject
	private ChatSpacingManager chatSpacingManager;

	protected final Map<String, Emoji> emojis = new HashMap<>();
	private final Map<String, Soundoji> soundojis = new HashMap<>();
	private final List<String> errors = new ArrayList<>();
	private WatchService watchService;
	private ExecutorService watcherExecutor;
	private ScheduledExecutorService debounceExecutor;
	private ScheduledFuture<?> pendingReload;

	private void setup()
	{
		if (EMOJIS_FOLDER.mkdir())
		{
			// copy example emoji
			File exampleEmoji = new File(EMOJIS_FOLDER, "com/customemoji/checkmark.png");
			try (InputStream in = EXAMPLE_EMOJI.openStream())
			{
				Files.copy(in, exampleEmoji.toPath());
			} catch (IOException e)
			{
				log.error("Failed to copy example emoji", e);
			}
		}

		if (SOUNDOJIS_FOLDER.mkdir())
		{
			// copy example soundoji
			File exampleSoundoji = new File(SOUNDOJIS_FOLDER, "com/customemoji/customemoji.wav");
			try (InputStream in = EXAMPLE_SOUNDOJI.openStream())
			{
				Files.copy(in, exampleSoundoji.toPath());
			} catch (IOException e)
			{
				log.error("Failed to copy example soundoji", e);
			}
		}
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted e) {
		switch (e.getCommand()) {
			case EMOJI_FOLDER_COMMAND:
				LinkBrowser.open(EMOJIS_FOLDER.toString());
				break;
			case SOUNDOJI_FOLDER_COMMAND:
				LinkBrowser.open(SOUNDOJIS_FOLDER.toString());
				break;
			case EMOJI_ERROR_COMMAND:

				for (String error : errors) {
					client.addChatMessage(ChatMessageType.CONSOLE, "", error, null);
				}
				break;
			case PRINT_ALL_EMOJI_COMMAND:
				StringBuilder sb = new StringBuilder();

				sb.append("Currently loaded emoji: ");
				
				for (Map.Entry<String, CustomEmojiPlugin.Emoji> entry : emojis.entrySet())
				{
					sb.append(entry.getKey() + " ");
				}

				String message = updateMessage(sb.toString(), false);
				client.addChatMessage(ChatMessageType.CONSOLE, "Currently loaded emoji", message, null);
				
				break;
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		setup();

		loadEmojis();
		loadSoundojis();

		overlay.startUp();
		overlayManager.add(overlay);

		tooltip.startUp();
		overlayManager.add(tooltip);
		
		// Apply initial chat spacing
		clientThread.invokeLater(chatSpacingManager::applyChatSpacing);

		try
		{
			setupFileWatcher();
		} catch (IOException e)
		{
			log.error("Failed to setup file watcher", e);
		}

		if (!errors.isEmpty())
		{
			clientThread.invokeLater(() ->
			{
				String message =
						"<col=FF0000>Custom Emoji: There were " + errors.size() +
								" errors loading emojis and soundojis.<br><col=FF0000>Use <col=00FFFF>::emojierror <col=FF0000>to see them.";
				client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);
			});
		}
		else
		{
			log.debug("<col=00FF00>Custom Emoji: Loaded " + emojis.size() + soundojis.size() + " emojis and soundojis.");
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		shutdownFileWatcher();
		emojis.clear();
		errors.clear();
		chatSpacingManager.clearStoredPositions();

		overlay.shutDown();
		overlayManager.remove(overlay);

		tooltip.shutDown();
		overlayManager.remove(tooltip);

		// Clear soundojis - AudioPlayer handles clip management automatically
		soundojis.clear();

		log.debug("Plugin shutdown complete - all containers cleared");
	}


	private void shutdownFileWatcher()
	{
		log.debug("Starting file watcher shutdown");

		// Cancel any pending reload debounce task first to prevent new reloads
		if (pendingReload != null)
		{
			boolean cancelled = pendingReload.cancel(true); // Use true to interrupt if running
			log.debug("Pending reload task cancelled: {}", cancelled);
			pendingReload = null; // Clear reference
		}

		shutdownExecutor(debounceExecutor, "debounce executor");
		shutdownExecutor(watcherExecutor, "watcher executor");

		// Close watch service first to interrupt the blocking take() call
		if (watchService != null)
		{
			try
			{
				watchService.close();
				log.debug("Watch service closed");
			} catch (IOException e)
			{
				log.error("Failed to close watch service", e);
			}
			watchService = null; // Clear reference
		}

		// Clear executor references
		debounceExecutor = null;
		watcherExecutor = null;

		log.debug("File watcher shutdown complete");
	}

	private void shutdownExecutor(ExecutorService executor, String executorName)
	{
		if (executor == null)
		{
			return;
		}

		log.debug("Shutting down {}", executorName);
		executor.shutdownNow();
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		switch (chatMessage.getType())
		{
			case PUBLICCHAT:
			case MODCHAT:
			case FRIENDSCHAT:
			case CLAN_CHAT:
			case CLAN_GUEST_CHAT:
			case CLAN_GIM_CHAT:
			case PRIVATECHAT:
			case PRIVATECHATOUT:
			case MODPRIVATECHAT:
				break;
			default:
				return;
		}

		final MessageNode messageNode = chatMessage.getMessageNode();
		final String message = messageNode.getValue();
		final String updatedMessage = updateMessage(message, true);

		if (updatedMessage == null)
		{
			return;
		}

		messageNode.setValue(updatedMessage);
	}

	@Subscribe
	public void onOverheadTextChanged(final OverheadTextChanged event)
	{
		if (!(event.getActor() instanceof Player))
		{
			return;
		}

		final String message = event.getOverheadText();
		final String updatedMessage = updateMessage(message, false);

		if (updatedMessage == null)
		{
			return;
		}

		event.getActor().setOverheadText(updatedMessage);
	}

  @Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		// Apply chat spacing when chat-related widgets are loaded
		if (event.getGroupId() == InterfaceID.Chatbox.SCROLLAREA)
		{
			clientThread.invokeLater(chatSpacingManager::applyChatSpacing);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getGroup().equals("custom-emote") == false)
		{
			return;
		}
		
		switch (event.getKey()) 
		{
			case CustomEmojiConfig.KEY_CHAT_MESSAGE_SPACING:
				clientThread.invokeLater(chatSpacingManager::applyChatSpacing);
				break;
			case CustomEmojiConfig.KEY_MAX_IMAGE_HEIGHT:
			case CustomEmojiConfig.KEY_RESIZE_EMOJI:
				scheduleReload(true);
				break;
		}
	}

	@Subscribe
	public void onVarClientIntChanged(VarClientIntChanged event)
	{
		switch (event.getIndex()) {
			case VarClientID.CHAT_LASTREBUILD:
				this.chatSpacingManager.clearStoredPositions();
				this.clientThread.invokeAtTickEnd(this.chatSpacingManager::applyChatSpacing);
				break;
			case VarClientID.CHAT_LASTSCROLLPOS:
				this.clientThread.invokeAtTickEnd(this.chatSpacingManager::captureScrollPosition);
				break;
		}
	}

	protected static BufferedImage scaleDown(BufferedImage originalImage, int targetHeight)
	{
		int originalWidth = originalImage.getWidth();
		int originalHeight = originalImage.getHeight();

		// Do not scale if already short enough
		if (originalHeight <= targetHeight) {
			return originalImage;
		}

		// Compute new width while preserving aspect ratio
		double scaleFactor = (double) targetHeight / originalHeight;
		int newWidth = (int) Math.round(originalWidth * scaleFactor);

		// Create scaled image
		return ImageUtil.resizeImage(originalImage, newWidth, targetHeight);
	}

	@Nullable
	String updateMessage(final String message, boolean sound)
	{
		final String[] messageWords = WHITESPACE_REGEXP.split(message);

		boolean editedMessage = false;
		for (int i = 0; i < messageWords.length; i++)
		{
			// Remove tags except for <lt> and <gt>
			final String trigger = Text.removeFormattingTags(messageWords[i]);
			//			final net.runelite.client.plugins.emojis.Emoji emoji = net.runelite.client.plugins.emojis.Emoji.getEmoji(trigger);
			final Emoji emoji = emojis.get(trigger.toLowerCase());
			final Soundoji soundoji = soundojis.get(trigger.toLowerCase());

			if (emoji != null)
			{
				messageWords[i] = messageWords[i].replace(trigger,
						"<img=" + chatIconManager.chatIconIndex(emoji.id) + ">");
				editedMessage = true;
				log.debug("Replacing {} with emoji {}", trigger, emoji.text);
			}

			if (soundoji != null)
			{
				if (sound)
				{
					try {
						audioPlayer.play(soundoji.file, volumeToGain(config.volume()));
					} catch (IOException | UnsupportedAudioFileException | LineUnavailableException e) {
						log.error("Failed to play soundoji: " + soundoji.text, e);
					}
				}
				messageWords[i] = messageWords[i].replace(trigger, "*" + trigger + "*");
				editedMessage = true;
				log.debug("Playing soundoji {}", trigger);
			}

		}

		// If we haven't edited the message any, don't update it.
		if (!editedMessage)
		{
			return null;
		}

		return String.join(" ", messageWords);
	}

	private void loadEmojis()
	{
		File emojiFolder = EMOJIS_FOLDER;
		if (emojiFolder.mkdir())
		{
			log.error("Created emoji folder");
		}

		var result = loadEmojisFolder(emojiFolder);
		result.ifOk(list ->
		{
			list.forEach(e -> emojis.put(e.getText(), e));
			log.info("Loaded {} emojis", result.unwrap().size());
		});
		result.ifError(e ->
		{
			e.forEach(t ->
			{
				String fileName = extractFileName(t.getMessage());
				log.debug("Skipped non-emoji file: {}", fileName);
			});
		});
	}

	private void loadSoundojis()
	{
		File soundojiFolder = SOUNDOJIS_FOLDER;
		if (soundojiFolder.mkdir())
		{
			log.error("Created soundoji folder");
		}

		var result = loadSoundojisFolder(soundojiFolder);
		result.ifOk(list ->
		{
			list.forEach(e -> soundojis.put(e.text, e));
			log.info("Loaded {} soundojis", result.unwrap().size());
		});
		result.ifError(e ->
		{
			e.forEach(t ->
			{
				String fileName = extractFileName(t.getMessage());
				log.debug("Skipped non-audio file: {}", fileName);
			});
		});
	}

	private Result<List<Soundoji>, List<Throwable>> loadSoundojisFolder(File soundojiFolder)
	{
		// recursively flattenFolder files in the folder
		List<File> files = flattenFolder(soundojiFolder);

		if (!soundojiFolder.isDirectory())
		{
			return Error(List.of(new IllegalArgumentException("Not a folder " + soundojiFolder)));
		}

		List<Soundoji> loaded = new ArrayList<>();
		List<Throwable> errors = new ArrayList<>();

		for (File file : files)
		{
			Result<Soundoji, Throwable> result = loadSoundoji(file);
			result.ifOk(loaded::add);
			result.ifError(errors::add);
		}

		if (errors.isEmpty())
		{
			return Ok(loaded);
		}
		else
		{
			return PartialOk(loaded, errors);
		}
	}

	private Result<List<Emoji>, List<Throwable>> loadEmojisFolder(File folder)
	{
		// recursively flattenFolder files in the folder
		List<File> files = flattenFolder(folder);

		if (!folder.isDirectory())
		{
			return Error(List.of(new IllegalArgumentException("Not a folder " + folder)));
		}

		List<Emoji> loaded = new ArrayList<>();
		List<Throwable> errors = new ArrayList<>();

		for (File file : files)
		{
			Result<Emoji, Throwable> result = loadEmoji(file);
			result.ifOk(loaded::add);
			result.ifError(errors::add);
		}

		if (errors.isEmpty())
		{
			return Ok(loaded);
		}
		else
		{
			return PartialOk(loaded, errors);
		}

	}

	private Result<Soundoji, Throwable> loadSoundoji(File file)
	{
		int extension = file.getName().lastIndexOf('.');

		if (extension < 0)
		{
			return Error(new IllegalArgumentException("Illegal file name " + file));
		}

		String text = file.getName().substring(0, extension).toLowerCase();
		return Ok(new Soundoji(text, file));

	}


	private List<File> flattenFolder(@NonNull File folder)
	{
		return flattenFolder(folder, 0);
	}

	private List<File> flattenFolder(@NonNull File folder, int depth)
	{
		// sanity guard
		final long MAX_DEPTH = 8;

		if (depth > MAX_DEPTH)
		{
			log.warn("Max depth of {} was reached path:{}", depth, folder);
			return List.of();
		}

		// file found
		if (!folder.isDirectory())
		{
			return List.of(folder);
		}

		// no childs
		File[] childs = folder.listFiles();
		if (childs == null)
		{
			return List.of();
		}

		List<File> flattened = new ArrayList<>();
		for (File child : childs)
		{
			flattened.addAll(flattenFolder(child, depth + 1));
		}

		return flattened;
	}

	private Result<Emoji, Throwable> loadEmoji(File file)
	{
		int extension = file.getName().lastIndexOf('.');

		if (extension < 0)
		{
			return Error(new IllegalArgumentException("Illegal file name <col=00FFFF>" + file));
		}

		String text = file.getName().substring(0, extension).toLowerCase();
		long fileModified = file.lastModified();

		// Check if we already have an emoji with this name
		Emoji existingEmoji = emojis.get(text);

		// If emoji exists and file hasn't been modified, return existing emoji unchanged
		if (existingEmoji != null && existingEmoji.lastModified == fileModified)
		{
			log.debug("Emoji file unchanged, skipping: {} (last modified: {})", text, fileModified);
			return Ok(existingEmoji);
		}

		// File has been modified or is new, need to load image
		Result<BufferedImage, Throwable> image = loadImage(file);

		if (image.isOk())
		{
			try
			{
				int id;

				BufferedImage normalizedImage = CustomEmojiImageUtilities.normalizeImage(image.unwrap(), config);
				
				if (existingEmoji != null)
				{
					// Update existing emoji in place
					chatIconManager.updateChatIcon(existingEmoji.id, normalizedImage);
					id = existingEmoji.id;
					log.info("Updated existing chat icon for emoji: {} (id: {})", text, id);
				}
				else
				{
					// Register new emoji
					id = chatIconManager.registerChatIcon(normalizedImage);
					log.info("Registered new chat icon for emoji: {} (id: {})", text, id);
				}

				Dimension dimension = new Dimension(normalizedImage.getWidth(), normalizedImage.getHeight());

				return Ok(new Emoji(id, text, file, fileModified, dimension));
			} catch (RuntimeException e)
			{
				return Error(new RuntimeException(
						"<col=FF0000>" + file.getName() + "</col> failed because <col=FF0000>" + e.getMessage(),
						e));
			}
		}
		else
		{
			Throwable throwable = image.unwrapError();
			return Error(new RuntimeException(
					"<col=FF0000>" + file.getName() + "</col> failed because <col=FF0000>" + throwable.getMessage(),
					throwable));
		}
	}

	protected static Result<BufferedImage, Throwable> loadImage(final File file)
	{
		try (InputStream in = new FileInputStream(file))
		{
			synchronized (ImageIO.class)
			{
				BufferedImage read = ImageIO.read(in);
				if (read == null)
				{
					return Error(new IOException("image format not supported. (PNG,JPG,GIF only)"));
				}

				return Ok(read);
			}
		} catch (IllegalArgumentException | IOException e)
		{
			return Error(e);
		}
	}

	private static String extractFileName(String errorMessage)
	{
		// Extract just the filename from error messages like:
		// "<col=FF0000>filename.ext</col> failed because..."
		// or "Illegal file name <col=00FFFF>C:\full\path\filename"
		if (errorMessage.contains("<col="))
		{
			int start = errorMessage.indexOf(">");
			int end = errorMessage.indexOf("</col>");
			if (start != -1 && end != -1 && start < end)
			{
				String fullPath = errorMessage.substring(start + 1, end);
				// Extract just the filename from full path
				return fullPath.substring(fullPath.lastIndexOf(File.separator) + 1);
			}
		}

		// Fallback: try to extract filename from full path
		if (errorMessage.contains(File.separator))
		{
			String[] parts = errorMessage.split("[" + Pattern.quote(File.separator) + "]");
			if (parts.length > 0)
			{
				return parts[parts.length - 1];
			}
		}

		return errorMessage;
	}

	public static float volumeToGain(int volume100)
	{
		// range[NOISE_FLOOR, 0]
		float gainDB;

		// Graph of the function
		// https://www.desmos.com/calculator/wdhsfbxgeo

		// clamp to 0-100
		float volume = Math.min(100, volume100);
		// convert linear volume 0-100 to log control
		if (volume <= 0.1)
		{
			gainDB = NOISE_FLOOR;
		}
		else
		{
			gainDB = (float) (10 * (Math.log(volume / 100)));
		}

		return gainDB;
	}

	private void setupFileWatcher() throws IOException
	{
		watchService = FileSystems.getDefault().newWatchService();

		// Register emoji and soundoji folders for watching
		Path emojiPath = EMOJIS_FOLDER.toPath();
		Path soundojiPath = SOUNDOJIS_FOLDER.toPath();

		if (Files.exists(emojiPath))
		{
			registerRecursively(emojiPath);
		}

		if (Files.exists(soundojiPath))
		{
			registerRecursively(soundojiPath);
		}

		watcherExecutor = Executors.newSingleThreadExecutor(r -> {
			Thread t = new Thread(r, "CustomEmoji-FileWatcher");
			t.setDaemon(true);
			return t;
		});

		// Create executor for debouncing reloads (many files changed at once, potentially from a git pull)
		debounceExecutor = Executors.newSingleThreadScheduledExecutor(r -> {
			Thread t = new Thread(r, "CustomEmoji-Debouncer");
			t.setDaemon(true);
			return t;
		});

		watcherExecutor.submit(this::watchForChanges);

		log.info("File watcher setup complete for emoji folders");
	}

	private void registerRecursively(Path path) throws IOException
	{
		path.register(watchService,
			StandardWatchEventKinds.ENTRY_CREATE,
			StandardWatchEventKinds.ENTRY_DELETE,
			StandardWatchEventKinds.ENTRY_MODIFY);

		Files.walk(path)
			.filter(Files::isDirectory)
			.filter(p -> !p.equals(path))
			.filter(p -> !p.getFileName().toString().equals(".git")) // Ignore .git folders
			.forEach(subPath -> {
				try
				{
					subPath.register(watchService,
						StandardWatchEventKinds.ENTRY_CREATE,
						StandardWatchEventKinds.ENTRY_DELETE,
						StandardWatchEventKinds.ENTRY_MODIFY);
				} catch (IOException e)
				{
					log.error("Failed to register subdirectory for watching: " + subPath, e);
				}
			});
	}

	private void watchForChanges()
	{
		while (!Thread.currentThread().isInterrupted())
		{
			try
			{
				// Check if watch service is still open before attempting to use it
				if (watchService == null)
				{
					log.debug("Watch service is null, stopping file watcher");
					break;
				}

				WatchKey key = watchService.take();

				// Check again after take() in case watch service was closed
				if (watchService == null)
				{
					log.debug("Watch service closed during take(), stopping file watcher");
					break;
				}

				boolean shouldReload = false;
				for (WatchEvent<?> event : key.pollEvents())
				{
					if (event == null || event.kind() == StandardWatchEventKinds.OVERFLOW)
					{
						continue;
					}

					@SuppressWarnings("unchecked")
					WatchEvent<Path> pathEvent = (WatchEvent<Path>) event;

					Path changed = pathEvent.context();

					// Skip if context is null (can happen during shutdown or filesystem issues)
					if (changed == null)
					{
						log.debug("Skipping file event with null context");
						continue;
					}

					// Only reload if it's an image or audio file
					if (isEmojiFile(changed) || isSoundojiFile(changed))
					{
						shouldReload = true;
						log.debug("Detected change in emoji/soundoji file: " + changed);
					}

					// If new directory created, register it for watching
					if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE)
					{
						if (key.watchable() == null)
						{
							log.debug("Skipping directory registration - key watchable is null");
							continue;
						}

						Path fullPath = ((Path) key.watchable()).resolve(changed);
						if (Files.isDirectory(fullPath))
						{
							try
							{
								// Check if watch service is still valid before registering
								if (watchService != null)
								{
									registerRecursively(fullPath);
									log.debug("Registered new directory for watching: " + fullPath);
								}
							} catch (IOException e)
							{
								log.error("Failed to register new directory: " + fullPath, e);
							}
						}
					}
				}

				if (shouldReload)
				{
					scheduleReload(false);
				}

				if (!key.reset())
				{
					log.debug("Watch key reset failed, stopping file watcher");
					break;
				}
			} catch (InterruptedException e)
			{
				log.debug("File watcher interrupted, stopping");
				Thread.currentThread().interrupt();
				break;
			} catch (Exception e)
			{
				// Check if this is due to closed watch service
				if (watchService == null)
				{
					log.debug("File watcher error due to closed watch service, stopping");
					break;
				}
				log.error("Error in file watcher", e);
				// Break on repeated errors to prevent spam
				break;
			}
		}
		log.debug("File watcher thread exiting");
	}

	private boolean isEmojiFile(Path path)
	{
		String fileName = path.getFileName().toString().toLowerCase();
		return fileName.endsWith(".png") || fileName.endsWith(".jpg") || fileName.endsWith(".jpeg") || fileName.endsWith(".gif");
	}

	private boolean isSoundojiFile(Path path)
	{
		String fileName = path.getFileName().toString().toLowerCase();
		return fileName.endsWith(".wav");
	}

	private void reloadEmojis(boolean force)
	{
		log.info("Reloading emojis and soundojis due to file changes");

		// Store current emoji names for deletion detection
		Set<String> currentEmojiNames = new HashSet<>(emojis.keySet());

		if (force)
		{
			emojis.clear();
		}

		soundojis.clear();

		errors.clear();

		// Reload emojis (using updateChatIcon for existing, registerChatIcon for new)
		File emojiFolder = EMOJIS_FOLDER;
		if (emojiFolder.exists())
		{
			var result = loadEmojisFolder(emojiFolder);

			// Track which emojis are still present
			Set<String> newEmojiNames = new HashSet<>();
			result.ifOk(list -> {
				list.forEach(e -> {
					emojis.put(e.getText(), e);
					newEmojiNames.add(e.getText());
				});
				log.info("Loaded {} emojis", result.unwrap().size());
			});
			result.ifError(e -> {
				e.forEach(t -> {
					String fileName = extractFileName(t.getMessage());
					log.debug("Skipped non-emoji file: {}", fileName);
				});
			});

			// Remove deleted emojis from our map
			currentEmojiNames.removeAll(newEmojiNames);
			currentEmojiNames.forEach(deletedEmoji -> {
				log.debug("Removing deleted emoji: {}", deletedEmoji);
				emojis.remove(deletedEmoji);
			});
		}
		else
		{
			log.warn("Emoji folder does not exist: {}", emojiFolder);
			emojis.clear();
		}

		loadSoundojis();

		String message = String.format("<col=00FF00>Custom Emoji: Reloaded %d emojis and %d soundojis", emojis.size(), soundojis.size());

		client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);
	}

	private void scheduleReload(boolean force)
	{
		synchronized (this)
		{
			// Don't schedule reload if debounceExecutor is null (during shutdown)
			if (debounceExecutor.isShutdown())
			{
				log.debug("Skipping reload schedule - executor is shutdown");
				return;
			}

			// Cancel any pending reload
			if (pendingReload != null && !pendingReload.isDone())
			{
				pendingReload.cancel(false);
				log.debug("Cancelled pending emoji reload due to new file changes");
			}

			// Schedule new reload with debounce delay
			pendingReload = debounceExecutor.schedule(() -> {
				clientThread.invokeLater(() -> reloadEmojis(force));
			}, 500, TimeUnit.MILLISECONDS);

			log.debug("Scheduled emoji reload with 500ms debounce");
		}
	}

	@Provides
	CustomEmojiConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CustomEmojiConfig.class);
	}
}

package com.customemoji;

import java.awt.Rectangle;

/**
 * Represents the calculated position and bounds of an emoji within a chat widget.
 */
public class EmojiPosition
{
    private final int imageId;
    private final Rectangle bounds;

    public EmojiPosition(int imageId, Rectangle bounds)
    {
        this.imageId = imageId;
        this.bounds = bounds;
    }

    public int getImageId()
    {
        return this.imageId;
    }

    public Rectangle getBounds()
    {
        return this.bounds;
    }

    public int getX()
    {
        return this.bounds.x;
    }

    public int getY()
    {
        return this.bounds.y;
    }

    public int getWidth()
    {
        return this.bounds.width;
    }

    public int getHeight()
    {
        return this.bounds.height;
    }

    public boolean containsPoint(int x, int y)
    {
        return this.bounds.contains(x, y);
    }
}
package com.customemoji;

import net.runelite.client.config.*;

@ConfigGroup("custom-emote")
public interface CustomEmojiConfig extends Config
{
	// Configuration key constants
	String KEY_RESIZE_EMOJI = "resize_emoji";
	String KEY_MAX_IMAGE_HEIGHT = "max_image_height";
	String KEY_SUGGESTION_OVERLAY = "suggestion_overlay";
	String KEY_OVERLAY_MAX_SUGGESTIONS = "overlay_max_suggestions";
	String KEY_SHOW_EMOJI_TOOLTIPS = "show_emoji_tooltips";
	String KEY_VOLUME = "volume";
	String KEY_CHAT_MESSAGE_SPACING = "chat_message_spacing";
	
	// Info section
	@ConfigSection(
			name = "Info",
			description = "Information",
			position = 0
	)
	String infoSection = "infoSection";

	@ConfigItem(
		keyName = "instructions",
		name = "Instructions",
		description = "Link to instruction",
		position = 0,
		section = infoSection)
	default String __instructions() {
		return "https://github.com/LouisGameDev/runelite-custom-emoji/blob/master/README.md";
	}

	@ConfigItem(
		keyName = "Update 2025-08-14",
		name = "Update 2025-08-14",
		description = "Update Details",
		position = 1,
		section = infoSection
	)
	default String __update() {
		return "!emojifolder has been changed to ::emojifolder. All ! prefix commands are now :: prefix commands.";
	}

	// Emoji section
	@ConfigSection(
			name = "Emoji Settings",
			description = "Emoji configuration options",
			position = 1
	)
	String emojiSection = "emojiSettingsSection";

	@ConfigItem(
			keyName = KEY_RESIZE_EMOJI,
			name = "Resize emoji",
			description = "Configures whether to resize emoji throughout the plugin. Takes effect after plugin reload.",
			section = emojiSection,
			position = 0
	)
	default boolean resizeEmoji() { return false; }

	@ConfigItem(
			keyName = KEY_MAX_IMAGE_HEIGHT,
			name = "Max Emoji Height",
			description = "Configures the maximum image height (in pixels) for the plugin. Only works when 'Resize Emoji' option is enabled.",
			section = emojiSection,
			position = 1
	)
	default int maxImageHeight() { return 24; }

	@ConfigItem(
		keyName = KEY_SUGGESTION_OVERLAY,
		name = "Show Suggestion Overlay",
		description = "Displays a list of potential emoji in an overlay while you're typing a chat message.",
		section = emojiSection,
		position = 2
	)
	default boolean showOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = KEY_OVERLAY_MAX_SUGGESTIONS,
		name = "Max Suggestions",
		description = "Configures the maximum number of suggestions for the emoji suggestion overlay.",
		section = emojiSection,
		position = 3
	)
	default int maxImageSuggestions() { return 10; }

	@ConfigItem(
		keyName = KEY_SHOW_EMOJI_TOOLTIPS,
		name = "Show Emoji Tooltips",
		description = "Shows the emoji name in a tooltip when hovering over emojis in chat messages.",
		section = emojiSection,
		position = 4
	)
	default boolean showEmojiTooltips() { return true; }

	// Soundoji section
	@ConfigSection(
			name = "Soundoji",
			description = "Soundoji configuration options",
			position = 2
	)
	String soundojiSection = "overlaySection";

	@ConfigItem(
			keyName = KEY_VOLUME,
			name = "Soundoji Volume",
			description = "Volume of soundojis. [0-100]",
			position = 0,
			section = soundojiSection
	)
	@Range(min = 0, max = 100)
	default int volume()
	{
		return 70;
	}

	// Chat section
	@ConfigSection(
			name = "Chat Widget",
			description = "Chat display configuration options",
			position = 3
	)
	String chatSection = "chatSection";

	@ConfigItem(
			keyName = KEY_CHAT_MESSAGE_SPACING,
			name = "Chat Message Spacing",
			description = "Adjusts the vertical spacing between chat messages (in pixels). Default is 0.",
			section = chatSection,
			position = 0
	)
	@Range(min = 0, max = 20)
	default int chatMessageSpacing()
	{
		return 0;
	}
}

package com.customemoji;

import net.runelite.api.FontTypeFace;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;

import java.awt.Dimension;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import lombok.extern.slf4j.Slf4j;

/**
 * Utility class for calculating emoji positions within chat widgets.
 * Shared between CustomEmojiTooltip and debug overlay.
 */
@Slf4j
public class EmojiPositionCalculator
{
    private static final Pattern IMG_PATTERN = Pattern.compile("<img=(\\d+)>");
    private static final int LINE_HEIGHT = 14;
    private static final int VERTICAL_OFFSET = 2;
    private static final int DEFAULT_EMOJI_SIZE = 18;

    /**
     * Functional interface for looking up emoji dimensions by image ID.
     */
    @FunctionalInterface
    public interface DimensionLookup
    {
        Dimension getDimension(int imageId);
    }

    /**
     * Calculates the positions of all emojis in the given widget text.
     *
     * @param widget The widget containing the text
     * @param text The text content (with img tags)
     * @param dimensionLookup Function to look up emoji dimensions by image ID
     * @return List of EmojiPosition objects with absolute coordinates
     */
    public static List<EmojiPosition> calculateEmojiPositions(Widget widget, String text, DimensionLookup dimensionLookup)
    {
        List<EmojiPosition> positions = new ArrayList<>();

        Matcher matcher = IMG_PATTERN.matcher(text);
        Point widgetPos = widget.getCanvasLocation();
        if (widgetPos == null)
        {
            return positions;
        }

        FontTypeFace font;
        try
        {
            font = widget.getFont();
        }
        catch (Exception e)
        {
            log.error("Error getting font for widget", e);
            return positions;
        }

        if (font == null)
        {
            return positions;
        }

        int textIndex = 0;
        int currentX = 0;
        int currentLine = 0;

        while (matcher.find())
        {
            String textBefore = text.substring(textIndex, matcher.start());
            String cleanTextBefore = removeHtmlTags(textBefore);

            // Simulate word-based line wrapping (OSRS wraps at spaces, not mid-word)
            String[] words = cleanTextBefore.split("(?<= )");
            for (String word : words)
            {
                int wordWidth = font.getTextWidth(word);
                if (currentX + wordWidth > widget.getWidth() && currentX > 0)
                {
                    currentX = 0;
                    currentLine++;
                }
                currentX += wordWidth;
            }

            String imageIdStr = matcher.group(1);
            int imageId = Integer.parseInt(imageIdStr);

            // Get emoji dimensions
            int emojiWidth = DEFAULT_EMOJI_SIZE;
            int emojiHeight = DEFAULT_EMOJI_SIZE;

            Dimension dimension = dimensionLookup.getDimension(imageId);
            if (dimension != null)
            {
                emojiWidth = dimension.width;
                emojiHeight = dimension.height;
            }

            // Check if emoji itself would wrap to next line
            if (currentX + emojiWidth > widget.getWidth() && currentX > 0)
            {
                currentX = 0;
                currentLine++;
            }

            int emojiStartX = currentX;

            // Calculate Y position based on which line the emoji is on
            // Emoji is bottom-aligned within the line, but offset 2px up from the bottom
            int lineBottomY = (currentLine + 1) * LINE_HEIGHT;
            int emojiBottomY = lineBottomY - VERTICAL_OFFSET;
            int emojiTopY = emojiBottomY - emojiHeight;

            int absoluteX = widgetPos.getX() + emojiStartX;
            int absoluteY = widgetPos.getY() + emojiTopY;

            Rectangle bounds = new Rectangle(absoluteX, absoluteY, emojiWidth, emojiHeight);
            positions.add(new EmojiPosition(imageId, bounds));

            currentX = emojiStartX + emojiWidth;
            textIndex = matcher.end();
        }

        return positions;
    }

    /**
     * Finds the emoji at the given point within a widget.
     *
     * @param widget The widget containing the text
     * @param text The text content (with img tags)
     * @param pointX Absolute X coordinate to check
     * @param pointY Absolute Y coordinate to check
     * @param dimensionLookup Function to look up emoji dimensions by image ID
     * @return The image ID of the emoji at the point, or -1 if none found
     */
    public static int findEmojiAtPoint(Widget widget, String text, int pointX, int pointY, DimensionLookup dimensionLookup)
    {
        List<EmojiPosition> positions = calculateEmojiPositions(widget, text, dimensionLookup);

        for (EmojiPosition position : positions)
        {
            if (position.containsPoint(pointX, pointY))
            {
                return position.getImageId();
            }
        }

        return -1;
    }

    private static String removeHtmlTags(String text)
    {
        if (text == null)
        {
            return "";
        }
        return text.replaceAll("<[^>]*>", "");
    }
}
package com.customemoji;

import lombok.NonNull;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.util.Text;

import javax.inject.Inject;

import com.customemoji.CustomEmojiPlugin.Emoji;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

class CustomEmojiOverlay extends OverlayPanel
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiConfig config;

    @Inject
    private CustomEmojiPlugin plugin;

    @Inject
    private ChatIconManager chatIconManager;

    @Inject
	private KeyManager keyManager;

    private String inputText;
    private Map<String, CustomEmojiPlugin.Emoji> emojiSuggestions = new HashMap<>();
    private final Map<String, BufferedImage> normalizedImageCache = new HashMap<>();

    protected final KeyListener typingListener = new KeyListener()
    {
        @Override
        public void focusLost()
        {
            KeyListener.super.focusLost();
        }

        @Override public void keyReleased(KeyEvent e)
        {
            Widget input = client.getWidget(InterfaceID.Chatbox.INPUT);

            if (input == null)
            {
                return;
            }

            inputText = extractChatInput(input.getText());
            emojiSuggestions = getEmojiSuggestions(inputText);
            clearImageCache();
        }

        @Override
        public void keyTyped(KeyEvent e)
        {
            // Do nothing
        }

        @Override
        public void keyPressed(KeyEvent e)
        {
            // Do nothing
        }

    };

    protected void startUp()
    {
        panelComponent.setGap(new Point(0,2));

        if (keyManager != null)
        {
            keyManager.registerKeyListener(typingListener);
        }
    }

    protected void shutDown()
    {
        if (keyManager != null)
        {
            keyManager.unregisterKeyListener(typingListener);
        }
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Don't render suggestions overlay if tooltips are being shown or if disabled
        if (!config.showOverlay() || client.isMenuOpen())
        {
            return null;
        }

        if (emojiSuggestions.isEmpty())
        {
            return null;
        }

        String searchTerm = extractChatInput(inputText).toLowerCase();
        
        for (CustomEmojiPlugin.Emoji emoji : emojiSuggestions.values())
        {
            addEmojiToOverlay(emoji, searchTerm);
        }

        return super.render(graphics);
    }

    private void addEmojiToOverlay(Emoji emoji, String searchTerm)
    {              
        ImageComponent imageComponent = new ImageComponent(emoji.getCacheImage(client, chatIconManager));

        // build line component with highlighted text
        String highlightedText = createHighlightedText(emoji.getText(), searchTerm);
        LineComponent lineComponent = LineComponent.builder().right(highlightedText).build();
        SplitComponent splitComponent = SplitComponent.builder().first(imageComponent).second(lineComponent).orientation(ComponentOrientation.HORIZONTAL).build();

        panelComponent.getChildren().add(splitComponent);
    }
    
    private String createHighlightedText(String text, String searchTerm)
    {
        if (searchTerm.isEmpty())
        {
            return text;
        }
        
        String lowerText = text.toLowerCase();
        String lowerSearch = searchTerm.toLowerCase();
        int index = lowerText.indexOf(lowerSearch);
        
        if (index == -1)
        {
            return text;
        }
        
        StringBuilder result = new StringBuilder();
        result.append(text.substring(0, index));
        result.append("<col=00ff00>");  // Green highlight
        result.append(text.substring(index, index + searchTerm.length()));
        result.append("<col=ffffff>");  // Reset to white
        result.append(text.substring(index + searchTerm.length()));
        
        return result.toString();
    }

    private static String extractChatInput(String input)
    {
        input = Text.removeTags(input);
        input = removePlayerName(input);
        input = removeChatInputAsterisk(input);
        input = removeBeforeLastSpace(input);

        return input;
    }

    @NonNull
    private Map<String, CustomEmojiPlugin.Emoji> getEmojiSuggestions(@NonNull String searchTerm)
    {
        if (searchTerm.trim().isEmpty() || searchTerm.length() < 3)
        {
            return new HashMap<>();
        }

        String lowerSearch = searchTerm.toLowerCase();
        
        // Get all matching entries
        List<Map.Entry<String, CustomEmojiPlugin.Emoji>> matchingEntries = new ArrayList<>();
        for (Map.Entry<String, CustomEmojiPlugin.Emoji> entry : this.plugin.emojis.entrySet())
        {
            if (entry.getKey().toLowerCase().contains(lowerSearch))
            {
                matchingEntries.add(entry);
            }
        }
        
        // Sort by relevance
        sortByRelevance(matchingEntries, lowerSearch);
        
        // Build result map with limit
        Map<String, CustomEmojiPlugin.Emoji> matches = new LinkedHashMap<>();
        int limit = Math.min(matchingEntries.size(), config.maxImageSuggestions());
        
        for (int i = limit - 1; i >= 0; i--)
        {
            Map.Entry<String, CustomEmojiPlugin.Emoji> entry = matchingEntries.get(i);
            matches.put(entry.getKey(), entry.getValue());
        }

        return matches;
    }
    
    private void sortByRelevance(List<Map.Entry<String, CustomEmojiPlugin.Emoji>> entries, String searchTerm)
    {
        entries.sort((a, b) -> {
            String nameA = a.getKey().toLowerCase();
            String nameB = b.getKey().toLowerCase();
            
            // Exact matches come first
            boolean exactA = nameA.equals(searchTerm);
            boolean exactB = nameB.equals(searchTerm);
            if (exactA != exactB) return exactA ? -1 : 1;
            
            // Then prefix matches
            boolean prefixA = nameA.startsWith(searchTerm);
            boolean prefixB = nameB.startsWith(searchTerm);
            if (prefixA != prefixB) return prefixA ? -1 : 1;
            
            // Then by position of match (earlier is better)
            int posA = nameA.indexOf(searchTerm);
            int posB = nameB.indexOf(searchTerm);
            if (posA != posB) return Integer.compare(posA, posB);
            
            // Finally by length (shorter names are better)
            return Integer.compare(nameA.length(), nameB.length());
        });
    }

    private void clearImageCache()
    {
        normalizedImageCache.clear();
    }

    private static String removeBeforeLastSpace(String input)
    {
        if (input == null || input.isBlank())
        {
            return input;
        }

        int lastSpaceIndex = input.lastIndexOf(' ');
        if (lastSpaceIndex == -1)
        {
            return input; // No space found, return original string
        }

        return input.substring(lastSpaceIndex + 1);
    }

    private static String removeChatInputAsterisk(String input)
    {
        if (input != null && input.endsWith("*"))
        {
            return input.substring(0, input.length() - 1);
        }

        return input;
    }

    private static String removePlayerName(String input) {
        if (input == null || input.isBlank()) {
            return input;
        }

        int colonIndex = input.indexOf(':');

        if (colonIndex == -1)
        {
            return input;
        }

        return input.substring(colonIndex + 2);
    }
}

package com.customemoji;

import com.customemoji.debugplugin.CustomEmojiDebugPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CustomEmojiPlugin.class, CustomEmojiDebugPlugin.class);
		RuneLite.main(args);
	}
}
package com.customemoji;

import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import java.awt.image.BufferedImage;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.ui.overlay.OverlayManager;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import org.mockito.Mock;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class Testing
{

    @Mock
    @Bind
    private Client client;

    @Mock
    @Bind
    private ClientThread clientThread;

    @Mock
    @Bind
    private ConfigManager configManager;

    @Mock
    @Bind
    private OverlayManager overlayManager;

    @Mock
    @Bind
    private MouseManager mouseManager;

    @Mock
    @Bind
    private KeyManager keyManager;

    @Mock
    @Bind
    private RuneLiteConfig runeLiteConfig;

    @Mock
    @Bind
    private ChatMessageManager chatMessageManager;

    @Mock
    @Bind
    private ChatIconManager chatIconManager;

    @Mock
    @Bind
    private CustomEmojiConfig customEmojiConfig;

    @Inject
    private CustomEmojiPlugin customEmojiPlugin;

    private int iconId;

    @Before
    public void before() throws Exception
    {
        Guice.createInjector(BoundFieldModule.of(this))
                .injectMembers(this);

        when(chatIconManager.registerChatIcon(any(BufferedImage.class)))
                .thenAnswer(a ->
                {
                    int currentId = iconId;
                    iconId++;
                    return currentId;
                });
        when(chatIconManager.chatIconIndex(anyInt()))
                .thenReturn(0);

        when(customEmojiConfig.resizeEmoji())
                .thenReturn(false);
    }

    @Test
    public void testOnChatMessage() throws Exception
    {

        customEmojiPlugin.startUp();

        MessageNode messageNode = mock(MessageNode.class);
        // With chat recolor, message may be wrapped in col tags
        when(messageNode.getValue()).thenReturn("<col=ff0000>monkaw pipe</col>");

        ChatMessage chatMessage = new ChatMessage();
        chatMessage.setType(ChatMessageType.PUBLICCHAT);
        chatMessage.setMessageNode(messageNode);

        customEmojiPlugin.onChatMessage(chatMessage);

        verify(messageNode).setValue("<col=ff0000><img=0> pipe</col>");

        System.out.println();
    }
}
package com.customemoji.debugplugin;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("custom-emoji-debug")
public interface CustomEmojiDebugConfig extends Config
{
    @ConfigItem(
        keyName = "showEmojiHitboxes",
        name = "Show Emoji Hitboxes",
        description = "Draws cyan borders around emoji hit areas in chat",
        position = 0
    )
    default boolean showEmojiHitboxes()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showRawTextTooltip",
        name = "Show Raw Text Tooltip",
        description = "Shows raw widget text when hovering over chat messages",
        position = 1
    )
    default boolean showRawTextTooltip()
    {
        return true;
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;

import com.google.inject.Provides;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@PluginDescriptor(
    name = "Custom Emoji Debug",
    developerPlugin = true
)
public class CustomEmojiDebugPlugin extends Plugin
{
    private static final String EMOJI_DEBUG_COMMAND = "emojidebug";

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private EmojiHitboxOverlay hitboxOverlay;

    @Inject
    private RawTextTooltipOverlay rawTextTooltipOverlay;

    @Inject
    private Client client;

    @Subscribe
    public void onCommandExecuted(CommandExecuted event)
    {
        if (!event.getCommand().equalsIgnoreCase(EMOJI_DEBUG_COMMAND))
        {
            return;
        }

        String[] args = event.getArguments();
        if (args.length == 0)
        {
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", "Usage: ::emojidebug <icon_id>", null);
            return;
        }

        try
        {
            int iconId = Integer.parseInt(args[0]);
            String message = "Icon " + iconId + ": <img=" + iconId + ">";
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);
        }
        catch (NumberFormatException e)
        {
            this.client.addChatMessage(ChatMessageType.CONSOLE, "", "Invalid icon ID: " + args[0], null);
        }
    }

    @Override
    protected void startUp() throws Exception
    {
        this.overlayManager.add(this.hitboxOverlay);
        this.overlayManager.add(this.rawTextTooltipOverlay);
    }

    @Override
    protected void shutDown() throws Exception
    {
        this.overlayManager.remove(this.hitboxOverlay);
        this.overlayManager.remove(this.rawTextTooltipOverlay);
    }

    @Provides
    CustomEmojiDebugConfig provideDebugConfig(ConfigManager configManager)
    {
        return configManager.getConfig(CustomEmojiDebugConfig.class);
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;
import javax.inject.Singleton;

import net.runelite.api.Client;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;

@Singleton
public class RawTextTooltipOverlay extends Overlay
{
    private static final int TOOLTIP_PADDING = 4;
    private static final int TOOLTIP_OFFSET_Y = 20;
    private static final Color BACKGROUND_COLOR = new Color(70, 61, 50, 220);
    private static final Color BORDER_COLOR = new Color(40, 35, 30);
    private static final Color TEXT_COLOR = Color.WHITE;

    @Inject
    private Client client;

    @Inject
    private CustomEmojiDebugConfig config;

    public RawTextTooltipOverlay()
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!this.config.showRawTextTooltip())
        {
            return null;
        }

        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return null;
        }

        net.runelite.api.Point mousePos = this.client.getMouseCanvasPosition();
        if (mousePos == null)
        {
            return null;
        }

        int mouseX = mousePos.getX();
        int mouseY = mousePos.getY();

        Widget hoveredWidget = this.findHoveredWidget(chatbox, mouseX, mouseY);
        if (hoveredWidget == null)
        {
            return null;
        }

        String rawText = hoveredWidget.getText();
        if (rawText == null || rawText.isEmpty())
        {
            return null;
        }

        this.drawTooltip(graphics, rawText, mouseX, mouseY);

        return null;
    }

    private void drawTooltip(Graphics2D graphics, String text, int mouseX, int mouseY)
    {
        Font originalFont = graphics.getFont();
        Font tooltipFont = new Font(Font.MONOSPACED, Font.PLAIN, 12);
        graphics.setFont(tooltipFont);

        FontMetrics fm = graphics.getFontMetrics();
        int textWidth = fm.stringWidth(text);
        int textHeight = fm.getHeight();

        int tooltipX = mouseX;
        int tooltipY = mouseY + TOOLTIP_OFFSET_Y;

        int boxWidth = textWidth + TOOLTIP_PADDING * 2;
        int boxHeight = textHeight + TOOLTIP_PADDING * 2;

        graphics.setColor(BACKGROUND_COLOR);
        graphics.fillRect(tooltipX, tooltipY, boxWidth, boxHeight);

        graphics.setColor(BORDER_COLOR);
        graphics.drawRect(tooltipX, tooltipY, boxWidth, boxHeight);

        graphics.setColor(TEXT_COLOR);
        graphics.drawString(text, tooltipX + TOOLTIP_PADDING, tooltipY + TOOLTIP_PADDING + fm.getAscent());

        graphics.setFont(originalFont);
    }

    private Widget findHoveredWidget(Widget chatbox, int mouseX, int mouseY)
    {
        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        if (dynamicChildren == null)
        {
            return null;
        }

        for (Widget widget : dynamicChildren)
        {
            if (widget == null)
            {
                continue;
            }

            net.runelite.api.Point widgetPos = widget.getCanvasLocation();
            if (widgetPos == null)
            {
                continue;
            }

            int widgetX = widgetPos.getX();
            int widgetY = widgetPos.getY();
            int widgetWidth = widget.getWidth();
            int widgetHeight = widget.getHeight();

            boolean isHovered = mouseX >= widgetX && mouseX <= widgetX + widgetWidth
                && mouseY >= widgetY && mouseY <= widgetY + widgetHeight;

            if (isHovered)
            {
                return widget;
            }
        }

        return null;
    }
}
package com.customemoji.debugplugin;

import javax.inject.Inject;
import javax.inject.Singleton;

import com.customemoji.EmojiPosition;
import com.customemoji.EmojiPositionCalculator;

import net.runelite.api.Client;
import net.runelite.api.IconID;
import net.runelite.api.IndexedSprite;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class EmojiHitboxOverlay extends Overlay
{
    @Inject
    private Client client;

    @Inject
    private CustomEmojiDebugConfig config;

    public EmojiHitboxOverlay()
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (this.config.showEmojiHitboxes())
        {
            this.drawEmojiHitBorders(graphics);
        }
        return null;
    }

    private void drawEmojiHitBorders(Graphics2D graphics)
    {
        Widget chatbox = this.client.getWidget(InterfaceID.Chatbox.SCROLLAREA);
        if (chatbox == null)
        {
            return;
        }

        List<Rectangle> rectangles = new ArrayList<>();
        this.collectAllEmojiRectangles(chatbox, rectangles);

        if (rectangles.isEmpty())
        {
            return;
        }

        // Get the chatbox visible bounds to clip drawing
        net.runelite.api.Point chatboxPos = chatbox.getCanvasLocation();
        int chatboxX = chatboxPos.getX();
        int chatboxY = chatboxPos.getY();
        int chatboxWidth = chatbox.getWidth();
        int chatboxHeight = chatbox.getHeight();
        Rectangle chatboxBounds = new Rectangle(chatboxX, chatboxY, chatboxWidth, chatboxHeight);

        // Save original clip and set clip to chatbox bounds
        Shape originalClip = graphics.getClip();
        graphics.setClip(chatboxBounds);

        Color originalColor = graphics.getColor();
        graphics.setColor(Color.CYAN);

        for (Rectangle rect : rectangles)
        {
            graphics.drawRect(rect.x, rect.y, rect.width, rect.height);
        }

        graphics.setColor(originalColor);
        graphics.setClip(originalClip);
    }

    private void collectAllEmojiRectangles(Widget chatbox, List<Rectangle> rectangles)
    {
        Widget[] dynamicChildren = chatbox.getDynamicChildren();
        if (dynamicChildren == null)
        {
            return;
        }

        for (Widget widget : dynamicChildren)
        {
            if (widget == null)
            {
                continue;
            }

            String text = widget.getText();
            if (text != null && text.contains("<img="))
            {
                this.collectEmojiRectanglesFromWidget(widget, text, rectangles);
            }
        }
    }

    private void collectEmojiRectanglesFromWidget(Widget widget, String text, List<Rectangle> rectangles)
    {
        List<EmojiPosition> positions = EmojiPositionCalculator.calculateEmojiPositions(
            widget,
            text,
            this::getSpriteDimension
        );

        for (EmojiPosition position : positions)
        {
            rectangles.add(position.getBounds());
        }
    }

    private Dimension getSpriteDimension(int imageId)
    {
        IndexedSprite[] modIcons = this.client.getModIcons();
        if (modIcons == null || imageId < 0 || imageId >= modIcons.length)
        {
            return null;
        }

        IndexedSprite sprite = modIcons[imageId];
        if (sprite == null)
        {
            return null;
        }

        return new Dimension(sprite.getWidth(), sprite.getHeight());
    }
}
