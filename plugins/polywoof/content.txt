package com.polywoof;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PolywoofPluginText
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PolywoofPlugin.class);
		RuneLite.main(args);
	}
}
package com.polywoof;

import com.polywoof.api.API;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import org.h2.engine.Constants;
import org.h2.jdbcx.JdbcDataSource;

import javax.annotation.ParametersAreNonnullByDefault;
import java.io.File;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

@Slf4j @ParametersAreNonnullByDefault public final class Dictionary implements AutoCloseable
{
	private static final Executor executor = Executors.newSingleThreadExecutor();
	private static final int revision = 2;
	private final JdbcDataSource data = new JdbcDataSource();
	private Connection db;

	public Dictionary(String name)
	{
		this.data.setURL(Constants.START_URL + new File(RuneLite.CACHE_DIR, name).getPath());
	}

	public void open()
	{
		if(status())
		{
			return;
		}

		executor.execute(() ->
		{
			try
			{
				log.info("Trying to open the database");
				Connection db = data.getConnection();

				try
				{
					try(PreparedStatement statement = db.prepareStatement("create table if not exists" +
							"\nINFORMATION_SCHEMA.PROPERTIES (PROPERTY_NAME varchar(256) primary key, PROPERTY_VALUE varchar(256) not null)"))
					{
						statement.executeUpdate();
					}

					try(PreparedStatement preparedStatement = db.prepareStatement("select * from" +
							"\nINFORMATION_SCHEMA.PROPERTIES where PROPERTY_NAME = ? and PROPERTY_VALUE >= ?"))
					{
						preparedStatement.setString(1, "dictionary.revision");
						preparedStatement.setString(2, String.valueOf(revision));

						if(!preparedStatement.executeQuery().next())
						{
							log.info("Trying to drop the schema");
							try(PreparedStatement statement = db.prepareStatement("drop schema if exists" +
									"\nDICTIONARY cascade"))
							{
								statement.executeUpdate();
							}

							try(PreparedStatement statement = db.prepareStatement("merge into" +
									"\nINFORMATION_SCHEMA.PROPERTIES values(?, ?)"))
							{
								statement.setString(1, "dictionary.revision");
								statement.setString(2, String.valueOf(revision));
								statement.executeUpdate();
							}
						}
					}

					try(PreparedStatement statement = db.prepareStatement("create schema if not exists" +
							"\nDICTIONARY"))
					{
						statement.executeUpdate();
					}

					for(API.GameText.Type type : API.GameText.Type.values())
					{
						try(PreparedStatement statement = db.prepareStatement(String.format("create table if not exists" +
								"\nDICTIONARY.%1$s (GAME varchar(%2$s) primary key)", type, type.size)))
						{
							statement.executeUpdate();
						}
					}

					this.db = db;
				}
				catch(SQLException error)
				{
					db.close();
					throw error;
				}
			}
			catch(SQLException error)
			{
				log.error("Failed to open the database", error);
			}
		});
	}

	public void close()
	{
		if(!status())
		{
			return;
		}

		executor.execute(() ->
		{
			try
			{
				log.info("Trying to close the database");
				db.close();
			}
			catch(SQLException error)
			{
				log.error("Failed to close the database", error);
			}
		});
	}

	public boolean status()
	{
		try
		{
			return db != null && !db.isClosed();
		}
		catch(SQLException error)
		{
			log.error("Failed to get the status of the database", error);
		}

		return false;
	}

	public void select(List<API.GameText> textList, API.Language language, Runnable runnable)
	{
		if(!status())
		{
			return;
		}

		executor.execute(() ->
		{
			for(API.GameText gameText : textList)
			{
				if(gameText.cache)
				{
					continue;
				}

				try(PreparedStatement preparedStatement = db.prepareStatement("select * from" +
						"\nINFORMATION_SCHEMA.COLUMNS where TABLE_SCHEMA = ? and TABLE_NAME = ? and COLUMN_NAME = ?"))
				{
					preparedStatement.setString(1, "DICTIONARY");
					preparedStatement.setString(2, gameText.type.toString());
					preparedStatement.setString(3, language.code.toUpperCase());

					if(!preparedStatement.executeQuery().next())
					{
						continue;
					}

					try(PreparedStatement statement = db.prepareStatement(String.format("select `%2$s` from" +
							"\nDICTIONARY.%1$s where GAME = ? and `%2$s` is not null", gameText.type, language.code.toUpperCase())))
					{
						statement.setString(1, gameText.game);
						ResultSet resultSet = statement.executeQuery();

						if(resultSet.next())
						{
							gameText.text = resultSet.getString(language.code.toUpperCase());
							gameText.cache = true;
						}
					}
				}
				catch(SQLException error)
				{
					log.error("Failed to select from the database", error);
				}
			}

			runnable.run();
		});
	}

	public void insert(List<API.GameText> textList, API.Language language, Runnable runnable)
	{
		if(!status())
		{
			return;
		}

		executor.execute(() ->
		{
			for(API.GameText gameText : textList)
			{
				if(gameText.cache)
				{
					continue;
				}

				try
				{
					try(PreparedStatement statement = db.prepareStatement(String.format("alter table" +
							"\nDICTIONARY.%1$s add if not exists `%3$s` varchar(%2$s)", gameText.type, gameText.type.size, language.code.toUpperCase())))
					{
						statement.executeUpdate();
					}

					try(PreparedStatement statement = db.prepareStatement(String.format("merge into" +
							"\nDICTIONARY.%1$s (GAME, `%2$s`) values(?, ?)", gameText.type, language.code.toUpperCase())))
					{
						statement.setString(1, gameText.game);
						statement.setString(2, gameText.text);
						statement.executeUpdate();
					}
				}
				catch(SQLException error)
				{
					log.error("Failed to insert into the database", error);
				}
			}

			runnable.run();
		});
	}
}

package com.polywoof;

import com.google.inject.Provides;
import com.polywoof.api.*;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientUI;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;
import okhttp3.OkHttpClient;

import javax.annotation.ParametersAreNonnullByDefault;
import javax.inject.Inject;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.*;

@Slf4j @ParametersAreNonnullByDefault @PluginDescriptor(
		name = "Polywoof",
		description = "Enjoy Quests in any Language!",
		tags = {
				"helper",
				"language",
				"translation"})
public final class PolywoofPlugin extends Plugin implements MouseListener
{
	private final Dictionary dictionary = new Dictionary("polywoof");
	private final HashMap<TranslationBackend, API> backend = new HashMap<>();
	private final List<API.GameText> previousList = new ArrayList<>();
	private final List<String> examineList = new ArrayList<>();
	private Utils.TextVerifier verifierChatMessage;
	private Utils.TextVerifier verifierOverheadText;
	private Utils.TextVerifier verifierDialog;
	private boolean selectText;
	private int examineTick;

	@Inject private Client client;
	@Inject private ClientThread clientThread;
	@Inject private ClientUI clientUI;
	@Inject private MouseManager mouseManager;
	@Inject private OkHttpClient okHttpClient;
	@Inject private OverlayManager overlayManager;
	@Inject private PolywoofConfig config;
	@Inject private PolywoofOverlay overlay;

	@Provides PolywoofConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PolywoofConfig.class);
	}

	@Override protected void startUp()
	{
		selectText = false;
		mouseManager.registerMouseListener(this);
		overlay.setPosition(OverlayPosition.BOTTOM_LEFT);
		overlay.setPriority(Overlay.PRIORITY_LOW);
		overlay.setLayer(OverlayLayer.ABOVE_WIDGETS);
		overlay.revalidate();
		overlayManager.add(overlay);

		verifierChatMessage = new Utils.TextVerifier(config.filterChatMessage());
		verifierOverheadText = new Utils.TextVerifier(config.filterOverheadText());
		verifierDialog = new Utils.TextVerifier(config.filterDialog());

		dictionary.open();
		backend.put(TranslationBackend.GENERIC, new Generic());
		backend.put(TranslationBackend.DEEPL, new DeepL(okHttpClient, new ErrorHandler(TranslationBackend.DEEPL)));
		backend.put(TranslationBackend.GOOGLE, new Google(okHttpClient, new ErrorHandler(TranslationBackend.GOOGLE)));
		backend.put(TranslationBackend.MYMEMORY, new MyMemory(okHttpClient, new ErrorHandler(TranslationBackend.MYMEMORY)));

		update(config.backend());
		update(TranslationBackend.MYMEMORY);
	}

	@Override protected void shutDown()
	{
		clientUI.setCursor(clientUI.getDefaultCursor());
		mouseManager.unregisterMouseListener(this);
		overlay.clear();
		overlayManager.remove(overlay);

		verifierChatMessage.clear();
		verifierOverheadText.clear();
		verifierDialog.clear();

		dictionary.close();
		backend.clear();
		previousList.clear();
		examineList.clear();
	}

	@Override public MouseEvent mouseClicked(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override public MouseEvent mousePressed(MouseEvent mouseEvent)
	{
		if(!selectText)
		{
			return mouseEvent;
		}

		selectText = false;
		clientThread.invoke(() ->
		{
			Utils.Interface.WidgetData widgetData = Utils.Interface.getWidgetData(client.getMouseCanvasPosition(), client.getWidgetRoots(),	Utils.Interface.Type.ROOT);

			if(widgetData == null)
			{
				return;
			}

			int group = WidgetUtil.componentToInterface(widgetData.widget.getId());
			int id = WidgetUtil.componentToId(widgetData.widget.getId());

			if(config.backend() == TranslationBackend.GENERIC)
			{
				String message = String.format(
						ColorUtil.wrapWithColorTag("[%s %d.%d]", JagexColors.DARK_ORANGE_INTERFACE_TEXT),
						Text.titleCase(widgetData.type), group, id);

				if(!widgetData.widget.getText().isBlank())
				{
					message = String.format("%s «%s»", message, ColorUtil.wrapWithColorTag(widgetData.widget.getText(), Color.WHITE));
				}

				overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
			}
			else if(!widgetData.widget.getText().isBlank())
			{
				List<API.GameText> textList = new ArrayList<>();

				if(widgetData.type == Utils.Interface.Type.DYNAMIC)
				{
					textList.add(new API.GameText(widgetData.widget.getText(), API.GameText.Type.MESSAGE));
				}
				else
				{
					List<Widget> widgetList = new ArrayList<>();

					for(int i = 1; i < Byte.MAX_VALUE; i++)
					{
						Widget widget = client.getWidget(group, id - i);

						if(widget == null || widget.hasListener() || widget.getType() != WidgetType.TEXT)
						{
							break;
						}

						widgetList.add(0, widget);
					}

					widgetList.add(widgetData.widget);

					for(int i = 1; i < Byte.MAX_VALUE; i++)
					{
						Widget widget = client.getWidget(group, id + i);

						if(widget == null || widget.hasListener() || widget.getType() != WidgetType.TEXT)
						{
							break;
						}

						widgetList.add(widget);
					}

					for(String text : Utils.Text.format(widgetList))
					{
						textList.add(new API.GameText(text, API.GameText.Type.SCROLL));
					}
				}

				backend.get(config.forceMyMemory() ? TranslationBackend.MYMEMORY : config.backend()).memoryGet(textList, config.language(), config.ignoreTags(), () -> overlay.put(textList, overlay.timeout(textList)));
			}
		});

		clientUI.setCursor(clientUI.getDefaultCursor());
		mouseEvent.consume();

		return mouseEvent;
	}

	@Override public MouseEvent mouseReleased(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override public MouseEvent mouseEntered(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override public MouseEvent mouseExited(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override public MouseEvent mouseDragged(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Override public MouseEvent mouseMoved(MouseEvent mouseEvent)
	{
		return mouseEvent;
	}

	@Subscribe public void onConfigChanged(ConfigChanged configChanged)
	{
		if(!configChanged.getGroup().equals("polywoof"))
		{
			return;
		}

		switch(configChanged.getKey())
		{
			case "backend":
			case "key":
			case "language":
				if(config.key().equals("pesik"))
				{
					String message = String.format(
							"%s %s",
							ColorUtil.wrapWithColorTag("Секретка..", Color.ORANGE),
							ColorUtil.wrapWithColorTag("Ну тяф и что?", new Color(Color.HSBtoRGB((float)(Math.random() * 255d), 1f, 1f))));

					overlay.put(List.of(API.GameText.create(message, API.GameText.Type.OPTION, false, false)), 10000L);
				}

				update(config.backend());
				break;
			case "quickActions":
				config.toggle(true);
				break;
			case "forceMyMemory":
			case "emailAddress":
				update(TranslationBackend.MYMEMORY);
				break;
			case "fontName":
			case "fontSize":
			case "textShadow":
			case "overlayBackgroundColor":
			case "overlayOutline":
			case "textAlignment":
			case "textWrap":
				overlay.revalidate();
				break;
			case "filterChatMessage":
				verifierChatMessage.update(config.filterChatMessage());
				break;
			case "filterOverheadText":
				verifierOverheadText.update(config.filterOverheadText());
				break;
			case "filterDialog":
				verifierDialog.update(config.filterDialog());
				break;
		}
	}

	@Subscribe public void onChatMessage(ChatMessage chatMessage)
	{
		if(!config.toggle())
		{
			return;
		}

		List<API.GameText> textList = new ArrayList<>();

		switch(chatMessage.getType())
		{
			case GAMEMESSAGE:
				if(!config.translateChatMessage())
				{
					return;
				}

				if(config.showTitle() && !chatMessage.getName().isBlank())
				{
					textList.add(API.GameText.create(chatMessage.getName(), API.GameText.Type.TITLE, config.translateTitle(), config.ignoreTags()));
				}

				textList.add(new API.GameText(chatMessage.getMessage(), API.GameText.Type.MESSAGE));
				break;
			case ITEM_EXAMINE:
			case NPC_EXAMINE:
			case OBJECT_EXAMINE:
				if(!config.translateExamine())
				{
					return;
				}

				if(!examineList.isEmpty())
				{
					String examineTitle = examineList.remove(0);

					if(config.showTitle())
					{
						textList.add(API.GameText.create(examineTitle, API.GameText.Type.TITLE, config.translateTitle(), config.ignoreTags()));
					}
				}

				textList.add(new API.GameText(chatMessage.getMessage(), API.GameText.Type.EXAMINE));
				break;
			default:
				return;
		}

		verifierChatMessage.verify(textList);
		backend.get(config.backend()).dictionaryGet(textList, config.language(), config.ignoreTags(), dictionary, () -> overlay.put(textList, overlay.timeout(textList)));
	}

	@Subscribe public void onGameTick(GameTick gameTick)
	{
		if(config.toggle())
		{
			List<API.GameText> textList = new ArrayList<>();

			if(config.translateDialog())
			{
				Widget dialogPlayerName = client.getWidget(InterfaceID.DIALOG_PLAYER, 4);
				Widget dialogPlayerText = client.getWidget(ComponentID.DIALOG_PLAYER_TEXT);
				Widget dialogNpcName = client.getWidget(ComponentID.DIALOG_NPC_NAME);
				Widget dialogNpcText = client.getWidget(ComponentID.DIALOG_NPC_TEXT);
				Widget dialogSpriteText = client.getWidget(ComponentID.DIALOG_SPRITE_TEXT);
				Widget dialogDoubleSprite = client.getWidget(ComponentID.DIALOG_DOUBLE_SPRITE_TEXT);
				Widget dialogUnknown229 = client.getWidget(229, 1);
				Widget dialogOptionOptions = client.getWidget(ComponentID.DIALOG_OPTION_OPTIONS);

				if(dialogPlayerName != null && dialogPlayerText != null)
				{
					if(config.showTitle())
					{
						textList.add(API.GameText.create(dialogPlayerName.getText(), API.GameText.Type.TITLE, config.translateTitle(), config.ignoreTags()));
					}

					textList.add(new API.GameText(dialogPlayerText.getText(), API.GameText.Type.DIALOG));
				}

				if(dialogNpcName != null && dialogNpcText != null)
				{
					if(config.showTitle())
					{
						textList.add(API.GameText.create(dialogNpcName.getText(), API.GameText.Type.TITLE, config.translateTitle(), config.ignoreTags()));
					}

					textList.add(new API.GameText(dialogNpcText.getText(), API.GameText.Type.DIALOG));
				}

				if(dialogSpriteText != null)
				{
					textList.add(new API.GameText(dialogSpriteText.getText(), API.GameText.Type.DIALOG));
				}

				if(dialogDoubleSprite != null)
				{
					textList.add(new API.GameText(dialogDoubleSprite.getText(), API.GameText.Type.DIALOG));
				}

				if(dialogUnknown229 != null)
				{
					textList.add(new API.GameText(dialogUnknown229.getText(), API.GameText.Type.DIALOG));
				}

				if(dialogOptionOptions != null)
				{
					for(Widget widget : dialogOptionOptions.getDynamicChildren())
					{
						if(widget.getType() == WidgetType.TEXT)
						{
							if(widget.hasListener())
							{
								textList.add(new API.GameText(widget.getText(), API.GameText.Type.OPTION));
							}
							else if(config.showTitle())
							{
								textList.add(API.GameText.create(widget.getText(), API.GameText.Type.TITLE, config.translateTitle(), config.ignoreTags()));
							}
						}
					}
				}
			}

			if(config.translateScroll())
			{
				Widget genericScrollText = client.getWidget(ComponentID.GENERIC_SCROLL_TEXT);

				if(genericScrollText != null)
				{
					for(String text : Utils.Text.format(Arrays.asList(genericScrollText.getNestedChildren())))
					{
						textList.add(new API.GameText(text, API.GameText.Type.SCROLL));
					}
				}
			}

			if(config.translateTreasureClue())
			{
				Widget clueScrollText = client.getWidget(ComponentID.CLUESCROLL_TEXT);

				if(clueScrollText != null)
				{
					textList.add(new API.GameText(clueScrollText.getText(), API.GameText.Type.SCROLL));
				}
			}

			verifierDialog.verify(textList);

			if(textList.isEmpty())
			{
				previousList.clear();
				overlay.pop("default");
			}
			else
			{
				Iterator<API.GameText> iterator = previousList.iterator();

				if(textList.stream().anyMatch(gameText -> !iterator.hasNext() || !iterator.next().game.equals(gameText.game)))
				{
					previousList.clear();
					previousList.addAll(textList);
					overlay.pop("default");
					backend.get(config.backend()).dictionaryGet(textList, config.language(), config.ignoreTags(), dictionary, () -> overlay.set("default", textList));
				}
			}
		}
		else
		{
			previousList.clear();
			overlay.pop("default");
		}

		if(examineTick > 0 && --examineTick < 1)
		{
			examineList.clear();
		}
	}

	@Subscribe public void onMenuOpened(MenuOpened menuOpened)
	{
		if(!config.quickActions() || !overlay.isMouseOver())
		{
			return;
		}

		client.createMenuEntry(1)
				.setOption(config.backend() == TranslationBackend.GENERIC ? "Get" : "Select")
				.setTarget(ColorUtil.wrapWithColorTag(config.backend() == TranslationBackend.GENERIC ? "Widget ID" : "Text", JagexColors.MENU_TARGET))
				.setType(MenuAction.RUNELITE)
				.onClick(menuEntry ->
				{
					clientUI.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
					selectText = true;
				});

		client.createMenuEntry(2)
				.setOption("Get")
				.setTarget(ColorUtil.wrapWithColorTag("API Usage", JagexColors.MENU_TARGET))
				.setType(MenuAction.RUNELITE)
				.onClick(menuEntry ->
				{
					if(config.backend() == TranslationBackend.DEEPL)
					{
						((DeepL)backend.get(TranslationBackend.DEEPL)).usage((characterCount, characterLimit) ->
						{
							double usage = ((double)characterCount / characterLimit);
							String message = String.format(
									"Your current %s usage is %s of the monthly quota!",
									ColorUtil.wrapWithColorTag(config.backend().product, JagexColors.DARK_ORANGE_INTERFACE_TEXT),
									ColorUtil.wrapWithColorTag(Math.round(100d * usage) + "%", ColorUtil.colorLerp(Color.GREEN, Color.RED, usage)));

							overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
						});
					}
					else
					{
						String message = String.format(
								"Not implemented for the %s backend.",
								ColorUtil.wrapWithColorTag(config.backend().product, JagexColors.DARK_ORANGE_INTERFACE_TEXT));

						overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
					}
				});

		client.createMenuEntry(3)
				.setOption(config.toggle() ? "Suspend" : "Resume")
				.setTarget(ColorUtil.wrapWithColorTag("Translation", JagexColors.MENU_TARGET))
				.setType(MenuAction.RUNELITE)
				.onClick(menuEntry ->
				{
					String message = "Translation has been %s!";

					if(config.toggle())
					{
						message = String.format(message, ColorUtil.wrapWithColorTag("suspended", Color.RED));
					}
					else
					{
						message = String.format(message, ColorUtil.wrapWithColorTag("resumed", Color.GREEN));
					}

					overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
					config.toggle(!config.toggle());
				});
	}

	@Subscribe public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		if(!config.toggle() || !config.translateExamine() || !menuOptionClicked.getMenuOption().equals("Examine"))
		{
			return;
		}

		if(menuOptionClicked.getMenuEntry().getNpc() == null)
		{
			examineList.add(menuOptionClicked.getMenuTarget());
		}
		else
		{
			examineList.add(menuOptionClicked.getMenuEntry().getNpc().getName());
		}

		examineTick = 10;
	}

	@Subscribe public void onOverheadTextChanged(OverheadTextChanged overheadTextChanged)
	{
		if(!config.toggle() || !config.translateOverheadText() || !(overheadTextChanged.getActor() instanceof NPC))
		{
			return;
		}

		List<API.GameText> textList = new ArrayList<>();
		NPC npc = (NPC)overheadTextChanged.getActor();

		switch(npc.getId())
		{
			default:
				if(config.showTitle() && npc.getName() != null)
				{
					textList.add(API.GameText.create(npc.getName(), API.GameText.Type.TITLE, config.translateTitle(), config.ignoreTags()));
				}

				textList.add(new API.GameText(overheadTextChanged.getOverheadText(), API.GameText.Type.OVERHEAD));
				break;
			case NpcID.BEE_KEEPER:
			case NpcID.CAPT_ARNAV:
			case NpcID.NILES:
			case NpcID.MILES:
			case NpcID.GILES:
			case NpcID.COUNT_CHECK:
			case NpcID.SERGEANT_DAMIEN:
			case NpcID.DRUNKEN_DWARF:
			case NpcID.EVIL_BOB:
			case NpcID.POSTIE_PETE:
			case NpcID.FREAKY_FORESTER:
			case NpcID.GENIE:
			case NpcID.LEO:
			case NpcID.DR_JEKYLL:
			case NpcID.FROG_PRINCE:
			case NpcID.FROG_PRINCESS:
			case NpcID.MYSTERIOUS_OLD_MAN:
			case NpcID.PILLORY_GUARD:
			case NpcID.FLIPPA:
			case NpcID.TILT:
			case NpcID.QUIZ_MASTER:
			case NpcID.RICK_TURPENTINE:
			case NpcID.SANDWICH_LADY:
			case NpcID.DUNCE:
			case NpcID.TOWN_CRIER:
			case NpcID.ELITE_VOID_KNIGHT:
				return;
		}

		verifierOverheadText.verify(textList);
		backend.get(config.backend()).dictionaryGet(textList, config.language(), config.ignoreTags(), dictionary, () -> overlay.put(textList, overlay.timeout(textList)));
	}

	private void update(TranslationBackend translationBackend)
	{
		switch(translationBackend)
		{
			case DEEPL:
				((DeepL)backend.get(translationBackend)).update(config.key());
				break;
			case GOOGLE:
				((Google)backend.get(translationBackend)).update(config.key());
				break;
			case MYMEMORY:
				((MyMemory)backend.get(translationBackend)).update(config.emailAddress());
				break;
		}

		backend.get(config.key().isBlank() ? TranslationBackend.GENERIC : translationBackend).languageSupport(languageList ->
		{
			API.Language language = backend.get(translationBackend).languageFind(config.language());

			if(language instanceof API.UnknownLanguage)
			{
				String message = String.format(
						"Specified language was %s.",
						ColorUtil.wrapWithColorTag("not found", Color.RED));

				overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
			}
			else if(language instanceof API.ResourceLanguage)
			{
				String message = String.format(
						"%s language was found in the resources.",
						ColorUtil.wrapWithColorTag(language.name, Color.GRAY));

				overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
			}
			else
			{
				String message = String.format(
						"%s language is set for the %s backend!",
						ColorUtil.wrapWithColorTag(language.name, Color.GREEN),
						ColorUtil.wrapWithColorTag(translationBackend.product, JagexColors.DARK_ORANGE_INTERFACE_TEXT));

				overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
				log.info("Got {} trusted languages", languageList.size());
			}
		});
	}

	@AllArgsConstructor(access = AccessLevel.PUBLIC) private final class ErrorHandler implements API.Reportable
	{
		TranslationBackend translationBackend;

		@Override public void report(API backend, Exception error)
		{
			String message = String.format(
					"%s has encountered %s error!",
					ColorUtil.wrapWithColorTag(translationBackend.product, JagexColors.DARK_ORANGE_INTERFACE_TEXT),
					ColorUtil.wrapWithColorTag(error.getMessage(), Color.RED));

			overlay.put(List.of(API.GameText.create(message, API.GameText.Type.MESSAGE, false, false)), 10000L);
		}
	}

	@AllArgsConstructor(access = AccessLevel.PRIVATE) public enum TranslationBackend
	{
		GENERIC("Generic"),
		DEEPL("DeepL API"),
		GOOGLE("Google Translate"),
		MYMEMORY("Translated MyMemory");

		public final String product;
	}
}

package com.polywoof;

import net.runelite.client.config.*;
import net.runelite.client.ui.overlay.components.ComponentConstants;

import java.awt.*;

@ConfigGroup("polywoof") public interface PolywoofConfig extends Config
{
	@ConfigItem(
			keyName = "toggle",
			name = "",
			description = "")
	void toggle(boolean toggle);

	@ConfigItem(
			keyName = "toggle",
			name = "",
			description = "",
			hidden = true)
	default boolean toggle()
	{
		return true;
	}

	@ConfigSection(
			name = "General",
			description = "Settings for the General functionality",
			position = 0)
	String generalSection = "generalSection";

	@ConfigItem(
			keyName = "backend",
			name = "Translation Method",
			description = "Choose the Backend for translations",
			section = generalSection,
			position = 0)
	default PolywoofPlugin.TranslationBackend backend()
	{
		return PolywoofPlugin.TranslationBackend.DEEPL;
	}

	@ConfigItem(
			keyName = "key",
			name = "API Key",
			description = "See the Guide how to get the API Key",
			secret = true,
			section = generalSection,
			position = 1)
	default String key()
	{
		return "";
	}

	@ConfigItem(
			keyName = "language",
			name = "Target Language",
			description = "Type your desired Language",
			section = generalSection,
			position = 2)
	default String language()
	{
		return "ru";
	}

	@Range(min = 1, max = 99) @Units("/99") @ConfigItem(
			keyName = "readingSpeed",
			name = "Reading Skill",
			description = "Affects how quickly Text Boxes disappear",
			section = generalSection,
			position = 3)
	default int readingSpeed()
	{
		return 60;
	}

	@ConfigItem(
			keyName = "quickActions",
			name = "Quick Actions",
			description = "Quick Actions button near Text Boxes",
			section = generalSection,
			position = 4)
	default boolean quickActions()
	{
		return true;
	}

	@ConfigItem(
			keyName = "forceMyMemory",
			name = "Force MyMemory",
			description = "Use MyMemory backend for the Quick Actions",
			section = generalSection,
			position = 5)
	default boolean forceMyMemory()
	{
		return false;
	}

	@ConfigItem(
			keyName = "emailAddress",
			name = "Email Address",
			description = "Used by MyMemory for an additional API Quota",
			secret = true,
			section = generalSection,
			position = 6)
	default String emailAddress()
	{
		return "";
	}

	@ConfigSection(
			name = "Translation",
			description = "Things to be Translated",
			position = 1)
	String translationSection = "translationSection";

	@ConfigItem(
			keyName = "translateTitle",
			name = "Titles",
			description = "Translation for Context Titles",
			section = translationSection,
			position = 0)
	default boolean translateTitle()
	{
		return true;
	}

	@ConfigItem(
			keyName = "translateChatMessage",
			name = "Chat Messages",
			description = "Translation for Chat Messages excluding players",
			section = translationSection,
			position = 1)
	default boolean translateChatMessage()
	{
		return true;
	}

	@ConfigItem(
			keyName = "translateExamine",
			name = "Examines",
			description = "Translation for Object Examines",
			section = translationSection,
			position = 2)
	default boolean translateExamine()
	{
		return true;
	}

	@ConfigItem(
			keyName = "translateOverheadText",
			name = "Overhead Text",
			description = "Translation for Overhead Text excluding players",
			section = translationSection,
			position = 3)
	default boolean translateOverheadText()
	{
		return true;
	}

	@ConfigItem(
			keyName = "translateDialog",
			name = "Dialogs",
			description = "Translation for Dialogs and Options",
			section = translationSection,
			position = 4)
	default boolean translateDialog()
	{
		return true;
	}

	@ConfigItem(
			keyName = "translateScroll",
			name = "Scrolls",
			description = "Translation for Scrolls",
			section = translationSection,
			position = 5)
	default boolean translateScroll()
	{
		return false;
	}

	@ConfigItem(
			keyName = "translateTreasureClue",
			name = "Treasure Clues",
			description = "Translation for Treasure Clues",
			section = translationSection,
			position = 6)
	default boolean translateTreasureClue()
	{
		return false;
	}

	@ConfigSection(
			name = "Appearance",
			description = "Font and Visual tweaks",
			closedByDefault = true,
			position = 2)
	String appearanceSection = "visualSection";

	@ConfigItem(
			keyName = "fontName",
			name = "Font Name",
			description = "Choose your favorite Font",
			section = appearanceSection,
			position = 0)
	default String fontName()
	{
		return "CozetteVector";
	}

	@Range(min = 1, max = 99) @Units("pt") @ConfigItem(
			keyName = "fontSize",
			name = "Font Size",
			description = "Adjust the Font Size for more comfort",
			section = appearanceSection,
			position = 1)
	default int fontSize()
	{
		return 12;
	}

	@ConfigItem(
			keyName = "textShadow",
			name = "Text Shadow",
			description = "Text Shadow for better visibility",
			section = appearanceSection,
			position = 2)
	default boolean textShadow()
	{
		return true;
	}

	@Alpha @ConfigItem(
			keyName = "overlayBackgroundColor",
			name = "Background Color",
			description = "Color of Text Boxes background",
			section = appearanceSection,
			position = 3)
	default Color overlayBackgroundColor()
	{
		return ComponentConstants.STANDARD_BACKGROUND_COLOR;
	}

	@ConfigItem(
			keyName = "overlayOutline",
			name = "Show Outline",
			description = "Outline around Text Boxes",
			section = appearanceSection,
			position = 4)
	default boolean overlayOutline()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showTitle",
			name = "Show Titles",
			description = "Context Titles where text comes from",
			section = appearanceSection,
			position = 5)
	default boolean showTitle()
	{
		return true;
	}

	@ConfigSection(
			name = "Formatting",
			description = "Text Formatting inside of Text Boxes",
			closedByDefault = true,
			position = 3)
	String formattingSection = "formattingSection";

	@ConfigItem(
			keyName = "textAlignment",
			name = "Text Alignment",
			description = "Customize Text Alignment for unusual positions",
			section = formattingSection,
			position = 0)
	default TextBox.Alignment textAlignment()
	{
		return TextBox.Alignment.DEFAULT;
	}

	@ConfigItem(
			keyName = "overlayAlignment",
			name = "Flow Alignment",
			description = "Override default Flow Alignment for Text Boxes",
			section = formattingSection,
			position = 1)
	default TextBox.Behaviour overlayAlignment()
	{
		return TextBox.Behaviour.DEFAULT;
	}

	@Range(min = 32, max = 2277) @Units("px") @ConfigItem(
			keyName = "textWrap",
			name = "Text Wrap Width",
			description = "Set maximum Text Length to fit horizontally",
			section = formattingSection,
			position = 2)
	default int textWrap()
	{
		return 420;
	}

	@ConfigItem(
			keyName = "ignoreTags",
			name = "Ignore Tags",
			description = "Tags are used for text styles, but at the cost of the API Usage",
			section = formattingSection,
			position = 3)
	default boolean ignoreTags()
	{
		return false;
	}

	@ConfigItem(
			keyName = "filterChatMessage",
			name = "Chat Messages Filter",
			description = "Filter for Chat Messages",
			section = formattingSection,
			position = 4)
	default String filterChatMessage()
	{
		return "^[0-9,]+ x Coins\\.$" +
				"\n^You gain [0-9,]+ .+ XP\\.$" +
				"\n^Your .+ lap count is:" +
				"\n^Your reward is:" +
				"\n^<col.+?>Well done! You have completed" +
				"\n^<col.+?>You're assigned to kill" +
				"\n^<col.+?>You have completed your task!" +
				"\n^<col.+?>You've completed </col>[0-9,]+ tasks <col.+?>";
	}

	@ConfigItem(
			keyName = "filterOverheadText",
			name = "Overhead Text Filter",
			description = "Filter for Overhead Text",
			section = formattingSection,
			position = 5)
	default String filterOverheadText()
	{
		return "^[0-9,\\.]+$";
	}

	@ConfigItem(
			keyName = "filterDialog",
			name = "Dialog Text Filter",
			description = "Filter for Dialogs and Options",
			section = formattingSection,
			position = 6)
	default String filterDialog()
	{
		return "^Congratulations, you've just advanced your .+ level\\." +
				"\n^Exchange '.+': 5 coins" +
				"\n^Status: [0-9,]+ damage points left\\." +
				"\n^Your new task is to kill" +
				"\n^You're currently assigned to kill";
	}
}

package com.polywoof;

import com.polywoof.api.API;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.annotation.ParametersAreNonnullByDefault;
import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.*;

@Slf4j @ParametersAreNonnullByDefault public final class PolywoofOverlay extends Overlay
{
	public static final BufferedImage resourceIcon = ImageUtil.loadImageResource(PolywoofPlugin.class, "/icon.png");
	public static final Dimension iconSize = new Dimension(30, 30);
	public static final Tooltip[] tooltips = {
			new Tooltip("Polywoof is " + ColorUtil.wrapWithColorTag("On", Color.GREEN)),
			new Tooltip("Polywoof is " + ColorUtil.wrapWithColorTag("Off", Color.RED)),
			new Tooltip("Polywoof is " + ColorUtil.wrapWithColorTag("Offline", Color.ORANGE)),
			new Tooltip("Polywoof is set to " + ColorUtil.wrapWithColorTag("Generic", Color.GRAY))};

	private final AlphaComposite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER);
	private final List<Component> order = new ArrayList<>();
	private final List<Component> temporary = new ArrayList<>();
	private final Map<String, Component> permanent = new HashMap<>();
	@Getter private boolean mouseOver;
	@Getter private boolean revalidate;

	@Inject private Client client;
	@Inject private PolywoofConfig config;
	@Inject private TooltipManager tooltipManager;

	@Override public Dimension render(Graphics2D graphics)
	{
		if(config.quickActions() && !mouseOver)
		{
			graphics.setComposite(composite.derive(0.2f));
			graphics.drawImage(resourceIcon, 0, 0, iconSize.width, iconSize.height, null);
		}

		if(!permanent.isEmpty() || !temporary.isEmpty())
		{
			OverlayPosition position = Objects.requireNonNullElse(getPreferredPosition(), getPosition());

			int offset = 0;
			int height = -4;

			order.clear();
			order.addAll(permanent.values());
			order.addAll(temporary);

			for(Component component : order)
			{
				if(revalidate)
				{
					component.text.update(config.fontName(), config.fontSize(), config.textWrap());
				}

				height += component.text.update(graphics).height + 4;
			}

			revalidate = false;

			for(Component component : order)
			{
				long opacity = Math.min(300L, System.currentTimeMillis() - component.timestamp);

				if(opacity < 300L)
				{
					component.text.setOpacity(opacity / 300f);
				}
				else
				{
					if(component.timeout == 0L)
					{
						component.text.setOpacity(1f);
					}
					else
					{
						long timeout = Math.min(1000L, component.timestamp + component.timeout - System.currentTimeMillis());

						if(timeout > 0L)
						{
							component.text.setOpacity(timeout / 1000f);
						}
						else
						{
							temporary.remove(component);
						}
					}
				}

				if(config.overlayAlignment() == TextBox.Behaviour.DEFAULT)
				{
					if(getPreferredLocation() == null)
					{
						switch(position)
						{
							case TOP_LEFT:
								TextBox.behaviour = TextBox.Behaviour.TOP_LEFT;
								break;
							case TOP_CENTER:
								TextBox.behaviour = TextBox.Behaviour.TOP;
								break;
							case TOP_RIGHT:
							case CANVAS_TOP_RIGHT:
								TextBox.behaviour = TextBox.Behaviour.TOP_RIGHT;
								break;
							default:
								TextBox.behaviour = TextBox.Behaviour.CENTER;
								break;
							case BOTTOM_LEFT:
								TextBox.behaviour = TextBox.Behaviour.BOTTOM_LEFT;
								break;
							case ABOVE_CHATBOX_RIGHT:
								TextBox.behaviour = TextBox.Behaviour.BOTTOM;
								break;
							case BOTTOM_RIGHT:
								TextBox.behaviour = TextBox.Behaviour.BOTTOM_RIGHT;
								break;
						}
					}
					else
					{
						TextBox.behaviour = TextBox.Behaviour.DEFAULT;
					}
				}
				else
				{
					TextBox.behaviour = config.overlayAlignment();
				}

				switch(TextBox.behaviour)
				{
					case TOP_LEFT:
					case TOP:
					case TOP_RIGHT:
						component.text.setLocation(0, offset);
						break;
					default:
					case DEFAULT:
					case LEFT:
					case CENTER:
					case RIGHT:
						component.text.setLocation(0, offset - height / 2);
						break;
					case BOTTOM_LEFT:
					case BOTTOM:
					case BOTTOM_RIGHT:
						component.text.setLocation(0, -offset);
						break;
				}

				offset += component.text.render(graphics).height + 4;
			}
		}

		if(config.quickActions() && mouseOver)
		{
			mouseOver = false;
			graphics.setComposite(composite.derive(1f));
			graphics.drawImage(resourceIcon, 0, 0, iconSize.width, iconSize.height, null);
		}

		return iconSize;
	}

	@Override public void onMouseOver()
	{
		if(!config.quickActions() || client.isMenuOpen())
		{
			return;
		}

		Tooltip tooltip;

		if(config.toggle())
		{
			if(config.backend() == PolywoofPlugin.TranslationBackend.GENERIC)
			{
				tooltip = tooltips[3];
			}
			else
			{
				tooltip = config.key().isBlank() ? tooltips[2] : tooltips[0];
			}
		}
		else
		{
			tooltip = tooltips[1];
		}

		tooltipManager.add(tooltip);
		mouseOver = true;
	}

	@Override public void revalidate()
	{
		TextBox.alignment = config.textAlignment();
		TextBox.backgroundColor = config.overlayBackgroundColor();
		TextBox.boxOutline = config.overlayOutline();
		TextBox.textShadow = config.textShadow();
		revalidate = true;
	}

	public void set(String key, List<API.GameText> textList)
	{
		if(permanent.containsKey(key))
		{
			temporary.add(0, permanent.get(key));
			permanent.get(key).timeout = System.currentTimeMillis() - permanent.get(key).timestamp + 1500L;
		}

		permanent.put(key, new Component(new TextBox(textList, config.fontName(), config.fontSize(), config.textWrap()), 0L));
	}

	public void put(List<API.GameText> textList, long timestamp)
	{
		temporary.add(0, new Component(new TextBox(textList, config.fontName(), config.fontSize(), config.textWrap()), timestamp));
	}

	public void pop(String key)
	{
		if(!permanent.containsKey(key))
		{
			return;
		}

		temporary.add(0, permanent.get(key));
		permanent.get(key).timeout = System.currentTimeMillis() - permanent.get(key).timestamp + 1500L;
		permanent.remove(key);
	}

	public void clear()
	{
		permanent.clear();
		temporary.clear();
	}

	public long timeout(List<API.GameText> textList)
	{
		long timeout = 0L;

		for(API.GameText gameText : textList)
		{
			timeout += (long)(Utils.Text.filter(Objects.requireNonNullElse(gameText.text, gameText.game), true).length() * 5f / config.readingSpeed());
		}

		return 1500L + timeout * 1000L;
	}

	@AllArgsConstructor(access = AccessLevel.PUBLIC) private static final class Component
	{
		public final TextBox text;
		public final long timestamp = System.currentTimeMillis();
		public long timeout;
	}
}

package com.polywoof;

import com.polywoof.api.API;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;

import javax.annotation.ParametersAreNonnullByDefault;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j @ParametersAreNonnullByDefault public final class Utils
{
	public static final class Text
	{
		private static final Matcher[] matchers = {
				Pattern.compile("<br>").matcher(""),
				Pattern.compile("<.*?>").matcher(""),
				Pattern.compile("^ +| +$|( ) +").matcher("")};

		public static String filter(String text, boolean removeTags)
		{
			text = matchers[0].reset(text).replaceAll(" ");

			if(removeTags)
			{
				text = matchers[1].reset(text).replaceAll("");
			}

			return matchers[2].reset(text).replaceAll("$1");
		}

		public static List<String> format(List<Widget> widgetList)
		{
			List<String> textList = new ArrayList<>();
			StringBuilder text = new StringBuilder();

			for(Widget widget : widgetList)
			{
				if(widget.getType() == WidgetType.TEXT && !widget.getText().isBlank())
				{
					if(text.length() > 0)
					{
						text.append("<br>");
					}

					text.append(widget.getText());
				}
				else if(text.length() > 0)
				{
					textList.add(text.toString());
					text.setLength(0);
				}
			}

			if(text.length() > 0)
			{
				textList.add(text.toString());
			}

			return textList;
		}
	}

	public static final class Interface
	{
		public static WidgetData getWidgetData(Point point, Widget[] widgets, Type type)
		{
			WidgetData widgetData = null;

			for(Widget widget : widgets)
			{
				WidgetData data = getWidgetData(point, widget.getDynamicChildren(), Type.DYNAMIC);

				if(data == null)
				{
					data = getWidgetData(point, widget.getNestedChildren(), Type.NESTED);
				}

				if(data == null)
				{
					data = getWidgetData(point, widget.getStaticChildren(), Type.STATIC);
				}

				if(data == null)
				{
					if(!widget.isHidden() && widget.getType() == WidgetType.TEXT && widget.contains(point))
					{
						widgetData = new WidgetData(widget, type);
					}
				}
				else
				{
					widgetData = data;
				}
			}

			return widgetData;
		}

		@AllArgsConstructor(access = AccessLevel.PRIVATE) public static final class WidgetData
		{
			public Widget widget;
			public Type type;
		}

		public enum Type
		{
			ROOT,
			DYNAMIC,
			NESTED,
			STATIC
		}
	}

	public static final class TextVerifier extends ArrayList<Matcher>
	{
		public TextVerifier(String patterns)
		{
			update(patterns);
		}

		public void verify(List<API.GameText> textList)
		{
			for(Matcher matcher : this)
			{
				textList.removeIf(gameText ->
				{
					switch(gameText.type)
					{
						case MESSAGE:
						case OVERHEAD:
						case DIALOG:
						case OPTION:
							return matcher.reset(gameText.game).find();
					}

					return false;
				});
			}

			if(textList.stream().allMatch(gameText -> gameText.type.equals(API.GameText.Type.TITLE)))
			{
				textList.clear();
			}
		}

		public void update(String patterns)
		{
			clear();

			for(String pattern : patterns.split("\n"))
			{
				add(Pattern.compile(pattern, Pattern.DOTALL).matcher(""));
			}
		}
	}
}

package com.polywoof;

import com.polywoof.api.API;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.RenderableEntity;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.util.ColorUtil;

import javax.annotation.ParametersAreNonnullByDefault;
import java.awt.*;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j @ParametersAreNonnullByDefault public final class TextBox implements RenderableEntity
{
	public static Alignment alignment = Alignment.DEFAULT;
	public static Behaviour behaviour = Behaviour.DEFAULT;
	public static Color backgroundColor = ComponentConstants.STANDARD_BACKGROUND_COLOR;
	public static Font resourceFont = FontManager.getDefaultFont();
	public static boolean boxOutline;
	public static boolean textShadow;

	private static final Matcher contentMatcher = Pattern.compile("<(?<property>.+?)(?:=(?<data>.+?))?/?>|.+?(?=<.+?>|$)").matcher("");
	private final List<API.GameText> textList;
	private final List<ContentPage> content = new ArrayList<>();
	private final Rectangle bounds = new Rectangle();
	private AlphaComposite composite = AlphaComposite.getInstance(AlphaComposite.SRC_OVER);
	private Font font;
	private Font fallbackFont;
	private int textWrap;

	static
	{
		try(InputStream stream = PolywoofPlugin.class.getResourceAsStream("/font.ttf"))
		{
			if(stream == null)
			{
				throw new IllegalArgumentException();
			}

			resourceFont = Font.createFont(Font.TRUETYPE_FONT, stream);
		}
		catch(Exception error)
		{
			log.error("Failed to load the default font", error);
		}
	}

	public TextBox(List<API.GameText> textList, String fontName, int fontSize, int textWrap)
	{
		this.textList = textList;
		update(fontName, fontSize, textWrap);
	}

	@Override public Dimension render(Graphics2D graphics)
	{
		if(bounds.isEmpty())
		{
			return bounds.getSize();
		}

		Point anchor = new Point();
		Point offset = new Point();

		float h;
		float v;
		float a;

		switch(behaviour)
		{
			case TOP_LEFT:
			case LEFT:
			case BOTTOM_LEFT:
				h = 1f;
				break;
			default:
			case DEFAULT:
			case TOP:
			case CENTER:
			case BOTTOM:
				h = 0f;
				break;
			case TOP_RIGHT:
			case RIGHT:
			case BOTTOM_RIGHT:
				h = -1f;
				break;
		}

		switch(behaviour)
		{
			default:
			case DEFAULT:
			case TOP_LEFT:
			case TOP:
			case TOP_RIGHT:
			case LEFT:
			case CENTER:
			case RIGHT:
				v = -1f;
				break;
			case BOTTOM_LEFT:
			case BOTTOM:
			case BOTTOM_RIGHT:
				v = 1f;
				break;
		}

		anchor.x = (int)(bounds.x - bounds.width * (-h / 2f + 0.5f));
		anchor.y = (int)(bounds.y - bounds.height * (v / 2f + 0.5f));

		graphics.setColor(backgroundColor);
		graphics.setComposite(composite);
		graphics.fillRect(anchor.x, anchor.y, bounds.width, bounds.height);

		if(boxOutline)
		{
			graphics.setColor(backgroundColor.darker());
			graphics.drawRect(anchor.x, anchor.y, bounds.width - 1, bounds.height - 1);
			graphics.setColor(backgroundColor.brighter());
			graphics.drawRect(anchor.x + 1, anchor.y + 1, bounds.width - 3, bounds.height - 3);
		}

		Color overrideColor = Color.WHITE;
		Font overrideFont = font;
		FontMetrics metrics = graphics.getFontMetrics(font);

		for(ContentPage contentPage : content)
		{
			switch(contentPage.gameText.type)
			{
				case TITLE:
				case OVERHEAD:
				case OPTION:
					a = 0f;
					break;
				default:
					switch(alignment)
					{
						case FORCE_LEFT:
							a = -1f;
							break;
						default:
						case DEFAULT:
							switch(behaviour)
							{
								case TOP_LEFT:
								case LEFT:
								case BOTTOM_LEFT:
									a = -1f;
									break;
								default:
								case DEFAULT:
								case TOP:
								case CENTER:
								case BOTTOM:
									a = 0f;
									break;
								case TOP_RIGHT:
								case RIGHT:
								case BOTTOM_RIGHT:
									a = 1f;
									break;
							}
							break;
						case FORCE_CENTER:
							a = 0f;
							break;
						case FORCE_RIGHT:
							a = 1f;
							break;
					}
					break;
			}

			for(ElementLine elementLine : contentPage)
			{
				for(Object element : elementLine)
				{
					if(element instanceof String)
					{
						if(overrideFont.canDisplayUpTo((String)element) == -1)
						{
							graphics.setFont(overrideFont);
						}
						else
						{
							graphics.setFont(fallbackFont);
						}

						FontMetrics dynamic = graphics.getFontMetrics();

						anchor.x = bounds.x + offset.x + (int)(bounds.width * ((a / 2f + 0.5f) + (h / 2f - 0.5f)) - elementLine.width * (a / 2f + 0.5f) - metrics.getDescent() * a * 3f);
						anchor.y = bounds.y + offset.y + elementLine.height + metrics.getDescent() - (int)(bounds.height * (v / 2f + 0.5f));

						if(textShadow)
						{
							graphics.setColor(Color.BLACK);
							graphics.drawString((String)element, anchor.x + 1, anchor.y + 1);
						}

						switch(contentPage.gameText.type)
						{
							case TITLE:
								graphics.setColor(JagexColors.DARK_ORANGE_INTERFACE_TEXT);
								break;
							case EXAMINE:
								graphics.setColor(Color.LIGHT_GRAY);
								break;
							case OVERHEAD:
								graphics.setColor(JagexColors.YELLOW_INTERFACE_TEXT);
								break;
							default:
								graphics.setColor(overrideColor);
								break;
						}

						graphics.drawString((String)element, anchor.x, anchor.y);
						offset.x += dynamic.stringWidth((String)element);
					}

					if(element instanceof Color)
					{
						if(element.equals(Color.BLACK))
						{
							overrideColor = Color.WHITE;
						}
						else
						{
							overrideColor = (Color)element;
						}
					}

					if(element instanceof Font)
					{
						overrideFont = (Font)element;
					}
				}

				offset.x = 0;
				offset.y += elementLine.height;
			}

			offset.y += metrics.getDescent();
		}

		return bounds.getSize();
	}

	public Dimension update(Graphics2D graphics)
	{
		if(!bounds.isEmpty())
		{
			return bounds.getSize();
		}

		Font overrideFont = font;
		FontMetrics metrics = graphics.getFontMetrics(font);

		content.clear();

		for(API.GameText gameText : textList)
		{
			ContentPage contentPage = new ContentPage(content, gameText);
			ElementLine elementLine = new ElementLine(contentPage);

			contentMatcher.reset(gameText.text);

			while(contentMatcher.find())
			{
				if(contentMatcher.group("property") == null)
				{
					if(overrideFont.canDisplayUpTo(contentMatcher.group()) == -1)
					{
						graphics.setFont(overrideFont);
					}
					else
					{
						graphics.setFont(fallbackFont);
					}

					FontMetrics dynamic = graphics.getFontMetrics();

					int width = dynamic.stringWidth(contentMatcher.group());
					int height = dynamic.getAscent() + metrics.getDescent();

					if(elementLine.width + width > textWrap)
					{
						int[] codes = contentMatcher.group().codePoints().toArray();
						int cursor = 0;
						int widest = width;
						int prefer = 0;
						int offset = 0;

						for(int i = 0; i < codes.length; i++)
						{
							int code = codes[i];

							widest -= dynamic.charWidth(code);

							if(code == ' ')
							{
								prefer = i + 1;
								offset = widest;
							}

							if(elementLine.width + width - widest > textWrap)
							{
								char append = '\n';

								if(prefer > 0 && i - prefer < 10)
								{
									i = prefer;
									prefer = 0;
									widest = offset;
								}
								else if(i > 0)
								{
									append = '↲';
								}

								elementLine.add(new String(codes, cursor, i - cursor) + append);
								elementLine.width += width - widest;
								elementLine.height = Math.max(height, elementLine.height);

								bounds.width = Math.max(elementLine.width, bounds.width);
								bounds.height += elementLine.height;

								elementLine = new ElementLine(contentPage);
								cursor = i;
								widest += width - widest - dynamic.charWidth(code);
							}
						}

						elementLine.add(new String(codes, cursor, codes.length - cursor));
						elementLine.width += width - widest;
					}
					else
					{
						elementLine.add(contentMatcher.group());
						elementLine.width += width;
					}

					elementLine.height = Math.max(height, elementLine.height);

					bounds.width = Math.max(elementLine.width, bounds.width);
				}
				else
				{
					switch(contentMatcher.group("property"))
					{
						case "br":
							int height = elementLine.height;

							elementLine = new ElementLine(contentPage);
							elementLine.height = height;

							bounds.height += elementLine.height;
							break;
						case "col":
							elementLine.add(ColorUtil.fromHex(contentMatcher.group("data")));
							break;
						case "/col":
							elementLine.add(Color.WHITE);
							break;
						default:
							log.warn("{} not implemented", contentMatcher.group());
							break;
					}
				}
			}

			bounds.height += elementLine.height + metrics.getDescent();
		}

		bounds.width += metrics.getDescent() * 6;
		bounds.height += metrics.getDescent() * 3;

		return bounds.getSize();
	}

	public void setLocation(int x, int y)
	{
		switch(behaviour)
		{
			case TOP_RIGHT:
			case RIGHT:
			case BOTTOM_RIGHT:
				x += PolywoofOverlay.iconSize.width;
				break;
			case DEFAULT:
			case TOP:
			case CENTER:
			case BOTTOM:
				x += PolywoofOverlay.iconSize.width / 2;
				break;
		}

		switch(behaviour)
		{
			case BOTTOM_LEFT:
			case BOTTOM:
			case BOTTOM_RIGHT:
				y += PolywoofOverlay.iconSize.height;
				break;
			case DEFAULT:
			case LEFT:
			case CENTER:
			case RIGHT:
				y += PolywoofOverlay.iconSize.height / 2;
				break;
		}

		bounds.setLocation(x, y);
	}

	public void update(String fontName, int fontSize, int textWrap)
	{
		if(fontName.equals("CozetteVector"))
		{
			font = resourceFont.deriveFont(Font.PLAIN, fontSize);
		}
		else
		{
			font = new Font(fontName, Font.PLAIN, fontSize);
		}

		fallbackFont = new Font(Font.MONOSPACED, Font.PLAIN, fontSize);
		this.textWrap = textWrap;

		bounds.setSize(0, 0);
	}

	public void setOpacity(float opacity)
	{
		composite = composite.derive(opacity);
	}

	private static final class ContentPage extends ArrayList<ElementLine>
	{
		public final API.GameText gameText;

		public ContentPage(List<ContentPage> contentList, API.GameText gameText)
		{
			this.gameText = gameText;
			contentList.add(this);
		}
	}

	private static final class ElementLine extends ArrayList<Object>
	{
		public int width = 0;
		public int height = 0;

		public ElementLine(ContentPage contentPage)
		{
			contentPage.add(this);
		}
	}

	public enum Alignment
	{
		DEFAULT,
		FORCE_LEFT,
		FORCE_CENTER,
		FORCE_RIGHT
	}

	public enum Behaviour
	{
		DEFAULT,
		TOP_LEFT,
		TOP,
		TOP_RIGHT,
		LEFT,
		CENTER,
		RIGHT,
		BOTTOM_LEFT,
		BOTTOM,
		BOTTOM_RIGHT
	}
}

package com.polywoof.api;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.polywoof.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.*;
import org.apache.commons.text.StringEscapeUtils;

import javax.annotation.ParametersAreNonnullByDefault;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j @ParametersAreNonnullByDefault public final class Google extends API
{
	private static final List<Language> trustedLanguageList = new ArrayList<>();
	private static final MediaType mediaType = MediaType.parse("Content-Type: application/json");
	private final OkHttpClient client;
	private String key;

	public Google(OkHttpClient client, Reportable reportable)
	{
		super(reportable);
		this.client = client;
	}

	@Override public void fetch(List<GameText> textList, boolean detectSource, Language language, boolean ignoreTags, Runnable runnable)
	{
		if(!(language instanceof TrustedLanguage))
		{
			return;
		}

		List<GameText> bodyText = textList.stream().filter(gameText -> !gameText.cache).collect(Collectors.toList());

		if(bodyText.isEmpty())
		{
			runnable.run();
		}
		else
		{
			JsonArray jsonArray = new JsonArray();

			for(GameText gameText : bodyText)
			{
				jsonArray.add(Utils.Text.filter(gameText.game, true));
			}

			JsonObject jsonObject = new JsonObject();
			jsonObject.add("q", jsonArray);
			jsonObject.addProperty("target", language.code);
			jsonObject.addProperty("format", "text");

			if(!detectSource)
			{
				jsonObject.addProperty("source", "en-GB");
			}

			fetch("/language/translate/v2", FormBody.create(mediaType, jsonObject.toString()), body ->
			{
				JsonArray json = parser.parse(body).getAsJsonObject().getAsJsonObject("data").getAsJsonArray("translations");

				if(bodyText.size() == json.size())
				{
					Iterator<JsonElement> iterator = json.iterator();

					for(GameText gameText : textList)
					{
						if(!gameText.cache)
						{
							gameText.text = StringEscapeUtils.unescapeHtml4(iterator.next().getAsJsonObject().get("translatedText").getAsString());
						}
					}

					runnable.run();
				}
			});
		}
	}

	@Override public void languageSupport(Supportable supportable)
	{
		synchronized(trustedLanguageList)
		{
			if(trustedLanguageList.isEmpty())
			{
				JsonObject jsonObject = new JsonObject();
				jsonObject.addProperty("target", "en");

				fetch("/language/translate/v2/languages", FormBody.create(mediaType, jsonObject.toString()), body ->
				{
					synchronized(trustedLanguageList)
					{
						JsonArray json = parser.parse(body).getAsJsonObject().getAsJsonObject("data").getAsJsonArray("languages");

						for(JsonElement element : json)
						{
							trustedLanguageList.add(new TrustedLanguage(element.getAsJsonObject()));
						}

						supportable.support(trustedLanguageList);
					}
				});
			}
			else
			{
				supportable.support(trustedLanguageList);
			}
		}
	}

	@Override public Language languageFind(String query)
	{
		synchronized(trustedLanguageList)
		{
			return languageFinder(query, trustedLanguageList, resourceLanguageList);
		}
	}

	public void update(String key)
	{
		if(!key.equals(this.key))
		{
			this.key = key;
		}
	}

	private static void handleCode(int code) throws Exception
	{
		switch(code)
		{
			case 200:
				return;
			case 400:
				throw new Exception("Invalid Argument");
			case 401:
				throw new Exception("Unauthenticated");
			case 429:
				throw new Exception("Resource Exhausted");
			case 503:
				throw new Exception("Unavailable");
			default:
				throw new Exception(String.valueOf(code));
		}
	}

	private void fetch(String path, RequestBody requestBody, Receivable receivable)
	{
		if(key.isBlank())
		{
			return;
		}

		try
		{
			Request.Builder request = new Request.Builder()
					.addHeader("User-Agent", RuneLite.USER_AGENT + " (polywoof)")
					.addHeader("X-goog-api-key", key)
					.addHeader("Accept", "application/json")
					.addHeader("Content-Type", "application/json")
					.addHeader("Content-Length", String.valueOf(requestBody.contentLength()))
					.url("https://translation.googleapis.com" + path)
					.post(requestBody);

			client.newCall(request.build()).enqueue(new Callback()
			{
				@Override public void onFailure(Call call, IOException error)
				{
					handleError(error);
				}

				@Override public void onResponse(Call call, Response response)
				{
					try(ResponseBody responseBody = response.body())
					{
						handleCode(response.code());

						if(responseBody != null)
						{
							receivable.receive(responseBody.string());
						}
					}
					catch(Exception error)
					{
						handleError(error);
					}
				}
			});
		}
		catch(Exception error)
		{
			log.error("Failed to create the API request", error);
		}
	}

	public static final class TrustedLanguage extends Language
	{
		private TrustedLanguage(JsonObject object)
		{
			super(object.get("language").getAsString(), object.get("name").getAsString());
		}
	}

	public interface Receivable
	{
		void receive(String body) throws Exception;
	}
}

package com.polywoof.api;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.polywoof.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.*;
import org.apache.commons.text.StringEscapeUtils;

import javax.annotation.ParametersAreNonnullByDefault;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j @ParametersAreNonnullByDefault public final class DeepL extends API
{
	private static final List<Language> trustedLanguageList = new ArrayList<>();
	private static final MediaType mediaType = MediaType.parse("Content-Type: application/json");
	private final OkHttpClient client;
	private String endpoint;
	private String key;

	public DeepL(OkHttpClient client, Reportable reportable)
	{
		super(reportable);
		this.client = client;
	}

	@Override public void fetch(List<GameText> textList, boolean detectSource, Language language, boolean ignoreTags, Runnable runnable)
	{
		if(!(language instanceof TrustedLanguage))
		{
			return;
		}

		List<GameText> bodyText = textList.stream().filter(gameText -> !gameText.cache).collect(Collectors.toList());

		if(bodyText.isEmpty())
		{
			runnable.run();
		}
		else
		{
			JsonArray jsonArray = new JsonArray();

			for(GameText gameText : bodyText)
			{
				jsonArray.add(Utils.Text.filter(gameText.game, ignoreTags));
			}

			JsonObject jsonObject = new JsonObject();
			jsonObject.add("text", jsonArray);
			jsonObject.addProperty("target_lang", language.code);
			jsonObject.addProperty("context", "runescape; dungeons and dragons; medieval fantasy;");
			jsonObject.addProperty("split_sentences", "nonewlines");
			jsonObject.addProperty("preserve_formatting", true);
			jsonObject.addProperty("formality", "prefer_less");
			jsonObject.addProperty("tag_handling", "xml");

			if(!detectSource)
			{
				jsonObject.addProperty("source_lang", "EN");
			}

			fetch("/v2/translate", FormBody.create(mediaType, jsonObject.toString()), body ->
			{
				JsonArray json = parser.parse(body).getAsJsonObject().getAsJsonArray("translations");

				if(bodyText.size() == json.size())
				{
					Iterator<JsonElement> iterator = json.iterator();

					for(GameText gameText : textList)
					{
						if(!gameText.cache)
						{
							gameText.text = StringEscapeUtils.unescapeHtml4(iterator.next().getAsJsonObject().get("text").getAsString());
						}
					}

					runnable.run();
				}
			});
		}
	}

	@Override public void languageSupport(Supportable supportable)
	{
		synchronized(trustedLanguageList)
		{
			if(trustedLanguageList.isEmpty())
			{
				JsonObject jsonObject = new JsonObject();
				jsonObject.addProperty("type", "target");

				fetch("/v2/languages", FormBody.create(mediaType, jsonObject.toString()), body ->
				{
					synchronized(trustedLanguageList)
					{
						JsonArray json = parser.parse(body).getAsJsonArray();

						for(JsonElement element : json)
						{
							trustedLanguageList.add(new TrustedLanguage(element.getAsJsonObject()));
						}

						supportable.support(trustedLanguageList);
					}
				});
			}
			else
			{
				supportable.support(trustedLanguageList);
			}
		}
	}

	@Override public Language languageFind(String query)
	{
		synchronized(trustedLanguageList)
		{
			return languageFinder(query, trustedLanguageList, resourceLanguageList);
		}
	}

	public void update(String key)
	{
		if(!key.equals(this.key))
		{
			this.key = key;
			endpoint = key.endsWith(":fx") ? "https://api-free.deepl.com" : "https://api.deepl.com";
		}
	}

	public void usage(Usable usable)
	{
		fetch("/v2/usage", FormBody.create(mediaType, "{}"), body ->
		{
			JsonObject json = parser.parse(body).getAsJsonObject();
			usable.usage(json.get("character_count").getAsLong(), json.get("character_limit").getAsLong());
		});
	}

	private static void handleCode(int code) throws Exception
	{
		switch(code)
		{
			case 200:
				return;
			case 400:
				throw new Exception("Bad Request");
			case 403:
				throw new Exception("Forbidden");
			case 429:
				throw new Exception("Too Many Requests");
			case 456:
				throw new Exception("Quota Exceeded");
			case 503:
				throw new Exception("Service Unavailable");
			default:
				throw new Exception(String.valueOf(code));
		}
	}

	private void fetch(String path, RequestBody requestBody, Receivable receivable)
	{
		if(key.isBlank())
		{
			return;
		}

		try
		{
			Request.Builder request = new Request.Builder()
					.addHeader("User-Agent", RuneLite.USER_AGENT + " (polywoof)")
					.addHeader("Authorization", "DeepL-Auth-Key " + key)
					.addHeader("Accept", "application/json")
					.addHeader("Content-Type", "application/json")
					.addHeader("Content-Length", String.valueOf(requestBody.contentLength()))
					.url(endpoint + path)
					.post(requestBody);

			client.newCall(request.build()).enqueue(new Callback()
			{
				@Override public void onFailure(Call call, IOException error)
				{
					handleError(error);
				}

				@Override public void onResponse(Call call, Response response)
				{
					try(ResponseBody responseBody = response.body())
					{
						handleCode(response.code());

						if(responseBody != null)
						{
							receivable.receive(responseBody.string());
						}
					}
					catch(Exception error)
					{
						handleError(error);
					}
				}
			});
		}
		catch(Exception error)
		{
			log.error("Failed to create the API request", error);
		}
	}

	public static final class TrustedLanguage extends Language
	{
		private TrustedLanguage(JsonObject object)
		{
			super(object.get("language").getAsString(), object.get("name").getAsString());
		}
	}

	public interface Receivable
	{
		void receive(String body) throws Exception;
	}

	public interface Usable
	{
		void usage(long characterCount, long characterLimit);
	}
}

package com.polywoof.api;

import com.google.gson.JsonObject;
import com.polywoof.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.*;
import org.apache.commons.text.StringEscapeUtils;

import javax.annotation.ParametersAreNonnullByDefault;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@Slf4j @ParametersAreNonnullByDefault public final class MyMemory extends API
{
	private static final List<Language> trustedLanguageList = new ArrayList<>();
	private final OkHttpClient client;
	private String email;

	static
	{
		synchronized(trustedLanguageList)
		{
			synchronized(resourceLanguageList)
			{
				for(Language language : resourceLanguageList)
				{
					trustedLanguageList.add(new TrustedLanguage(language));
				}
			}
		}
	}

	public MyMemory(OkHttpClient client, Reportable reportable)
	{
		super(reportable);
		this.client = client;
	}

	@Override public void fetch(List<GameText> textList, boolean detectSource, Language language, boolean ignoreTags, Runnable runnable)
	{
		if(!(language instanceof TrustedLanguage))
		{
			return;
		}

		List<GameText> bodyText = textList.stream().filter(gameText -> !gameText.cache).collect(Collectors.toList());

		if(bodyText.isEmpty())
		{
			runnable.run();
		}
		else
		{
			AtomicInteger size = new AtomicInteger();

			for(GameText gameText : bodyText)
			{
				FormBody.Builder request = new FormBody.Builder()
						.add("q", Utils.Text.filter(gameText.game, true))
						.add("langpair", String.format("%s|%s", detectSource ? "Autodetect" : "en-GB", language.code));

				if(!email.equals("demo"))
				{
					request.add("de", email);
				}

				fetch(request.build(), body ->
				{
					try
					{
						JsonObject json = parser.parse(body).getAsJsonObject();
						handleCode(json.get("responseStatus").getAsInt());

						gameText.text = StringEscapeUtils.unescapeHtml4(json.getAsJsonObject("responseData").get("translatedText").getAsString());

						if(bodyText.size() == size.incrementAndGet())
						{
							runnable.run();
						}
					}
					catch(Exception error)
					{
						handleError(error);
					}
				});
			}
		}
	}

	@Override public void languageSupport(Supportable supportable)
	{
		synchronized(trustedLanguageList)
		{
			supportable.support(trustedLanguageList);
		}
	}

	@Override public Language languageFind(String query)
	{
		synchronized(trustedLanguageList)
		{
			return languageFinder(query, trustedLanguageList, resourceLanguageList);
		}
	}

	public void update(String email)
	{
		if(!email.equals(this.email))
		{
			if(!email.isBlank() && !email.matches("^[^@]+@[^@.]+\\.[^@.]+$"))
			{
				email = "demo";
			}

			this.email = email;
		}
	}

	private static void handleCode(int code) throws Exception
	{
		switch(code)
		{
			case 200:
				return;
			case 400:
				throw new Exception("Bad Request");
			case 403:
				throw new Exception("Forbidden");
			case 429:
				throw new Exception("Too Many Requests");
			case 503:
				throw new Exception("Service Unavailable");
			default:
				throw new Exception(String.valueOf(code));
		}
	}

	private void fetch(RequestBody requestBody, Receivable receivable)
	{
		if(email.isBlank())
		{
			return;
		}

		try
		{
			Request.Builder request = new Request.Builder()
					.addHeader("User-Agent", RuneLite.USER_AGENT + " (polywoof)")
					.addHeader("Accept", "application/json")
					.addHeader("Content-Type", "application/x-www-form-urlencoded")
					.addHeader("Content-Length", String.valueOf(requestBody.contentLength()))
					.url("https://api.mymemory.translated.net/get")
					.post(requestBody);

			client.newCall(request.build()).enqueue(new Callback()
			{
				@Override public void onFailure(Call call, IOException error)
				{
					handleError(error);
				}

				@Override public void onResponse(Call call, Response response)
				{
					try(ResponseBody responseBody = response.body())
					{
						handleCode(response.code());

						if(responseBody != null)
						{
							receivable.receive(responseBody.string());
						}
					}
					catch(Exception error)
					{
						handleError(error);
					}
				}
			});
		}
		catch(Exception error)
		{
			log.error("Failed to create the API request", error);
		}
	}

	public static final class TrustedLanguage extends Language
	{
		TrustedLanguage(Language language)
		{
			super(language.code, language.name);
		}
	}

	public interface Receivable
	{
		void receive(String body) throws Exception;
	}
}

package com.polywoof.api;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.polywoof.Dictionary;
import com.polywoof.PolywoofPlugin;
import com.polywoof.Utils;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.annotation.ParametersAreNonnullByDefault;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

@Slf4j @ParametersAreNonnullByDefault @AllArgsConstructor(access = AccessLevel.PUBLIC) public abstract class API
{
	protected static final JsonParser parser = new JsonParser();
	protected static final List<Language> resourceLanguageList = new ArrayList<>();

	private static final HashMap<GameText, Language> memory = new HashMap<>();
	private final Reportable reportable;

	static
	{
		try(InputStream stream = PolywoofPlugin.class.getResourceAsStream("/languages.json"))
		{
			if(stream == null)
			{
				throw new IllegalArgumentException();
			}

			try(InputStreamReader reader = new InputStreamReader(stream))
			{
				synchronized(resourceLanguageList)
				{
					for(JsonElement element : parser.parse(reader).getAsJsonArray())
					{
						resourceLanguageList.add(new ResourceLanguage(element.getAsJsonObject()));
					}
				}
			}
		}
		catch(Exception error)
		{
			log.error("Failed to load languages from the resource", error);
		}
	}

	public abstract void fetch(List<GameText> textList, boolean detectSource, Language language, boolean ignoreTags, Runnable runnable);
	public abstract void languageSupport(Supportable supportable);
	public abstract Language languageFind(String query);

	public final void dictionaryGet(List<GameText> textList, String targetLanguage, boolean ignoreTags, Dictionary dictionary, Runnable runnable)
	{
		Language language = languageFind(targetLanguage);

		if(textList.isEmpty() || language instanceof UnknownLanguage)
		{
			return;
		}

		if(this instanceof Generic || !dictionary.status())
		{
			fetch(textList, false, language, ignoreTags, runnable);
		}
		else
		{
			if(language instanceof ResourceLanguage)
			{
				dictionary.select(textList, language, () ->
				{
					textList.removeIf(gameText -> !gameText.cache);

					if(textList.stream().anyMatch(gameText -> gameText.type != GameText.Type.TITLE))
					{
						runnable.run();
					}
				});
			}
			else
			{
				dictionary.select(textList, language, () -> fetch(textList, false, language, ignoreTags, () -> dictionary.insert(textList, language, runnable)));
			}
		}
	}

	public final void memoryGet(List<GameText> textList, String targetLanguage, boolean ignoreTags, Runnable runnable)
	{
		Language language = languageFind(targetLanguage);

		if(textList.isEmpty() || language instanceof UnknownLanguage)
		{
			return;
		}

		if(this instanceof Generic)
		{
			fetch(textList, true, language, ignoreTags, runnable);
		}
		else
		{
			for(GameText memoryText : memory.keySet())
			{
				for(GameText gameText : textList)
				{
					if(gameText.game.equals(memoryText.game) && memory.get(memoryText).equals(language))
					{
						gameText.text = memoryText.text;
						gameText.cache = true;
					}
				}
			}

			fetch(textList, true, language, ignoreTags, () ->
			{
				for(GameText gameText : textList)
				{
					if(!gameText.cache)
					{
						memory.put(gameText, language);
					}
				}

				runnable.run();
			});
		}
	}

	@SafeVarargs protected static Language languageFinder(String query, List<Language>... languageList)
	{
		query = query.trim().toUpperCase();

		synchronized(resourceLanguageList)
		{
			for(List<Language> languages : languageList)
			{
				for(Language language : languages)
				{
					if(language.code.toUpperCase().equals(query))
					{
						return language;
					}
				}

				for(Language language : languages)
				{
					if(language.name.toUpperCase().equals(query))
					{
						return language;
					}
				}

				for(Language language : languages)
				{
					if(language.code.toUpperCase().startsWith(query))
					{
						return language;
					}
				}

				for(Language language : languages)
				{
					if(language.name.toUpperCase().startsWith(query))
					{
						return language;
					}
				}

				for(Language language : languages)
				{
					if(language.name.toUpperCase().contains(query))
					{
						return language;
					}
				}
			}
		}

		return new UnknownLanguage(query);
	}

	protected void handleError(Exception error)
	{
		reportable.report(this, error);
	}

	@AllArgsConstructor(access = AccessLevel.PROTECTED) public abstract static class Language
	{
		public final String code;
		public final String name;
	}

	public static final class GameText
	{
		public final String game;
		public final Type type;
		public String text;
		public boolean cache;

		public GameText(String game, Type type)
		{
			this.game = game;
			this.type = type;
		}

		public static GameText create(String game, Type type, boolean translate, boolean removeTags)
		{
			GameText gameText = new GameText(game, type);

			if(!translate)
			{
				gameText.text = Utils.Text.filter(game, removeTags);
				gameText.cache = true;
			}

			return gameText;
		}

		@AllArgsConstructor(access = AccessLevel.PRIVATE) public enum Type
		{
			TITLE(256),
			MESSAGE(512),
			EXAMINE(512),
			OVERHEAD(512),
			DIALOG(512),
			OPTION(512),
			SCROLL(2048);

			public final int size;
		}
	}

	public static final class ResourceLanguage extends Language
	{
		private ResourceLanguage(JsonObject object)
		{
			super(object.get("code").getAsString(), object.get("name").getAsString());
		}
	}

	public static final class UnknownLanguage extends Language
	{
		private UnknownLanguage(String code)
		{
			super(code, "Unknown");
		}
	}

	public interface Supportable
	{
		void support(List<Language> languageList);
	}

	public interface Reportable
	{
		void report(API backend, Exception error);
	}
}

package com.polywoof.api;

import lombok.extern.slf4j.Slf4j;

import javax.annotation.ParametersAreNonnullByDefault;
import java.util.List;

@Slf4j @ParametersAreNonnullByDefault public final class Generic extends API
{
	public Generic()
	{
		super((backend, error) -> log.error("Undefinable", error));
	}

	@Override public void fetch(List<GameText> textList, boolean detectSource, Language language, boolean ignoreTags, Runnable runnable)
	{
		if(!(language instanceof ResourceLanguage))
		{
			return;
		}

		for(GameText gameText : textList)
		{
			gameText.text = gameText.game;
			gameText.cache = true;
		}

		runnable.run();
	}

	@Override public void languageSupport(Supportable supportable)
	{
		synchronized(resourceLanguageList)
		{
			supportable.support(resourceLanguageList);
		}
	}

	@Override public Language languageFind(String query)
	{
		return languageFinder(query, resourceLanguageList);
	}
}

