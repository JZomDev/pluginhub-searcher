package com.salverrs.GEFilters;

import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(GEFiltersPlugin.CONFIG_GROUP)
public interface GEFiltersConfig extends Config
{
	@ConfigSection(
			name = "Filters",
			description = "Grand Exchange search filters.",
			position = 0
	)
	String filtersSection = "filters";

	@ConfigSection(
			name = "Inventory Setups",
			description = "Toggle item types from Inventory Setups that will be included in the filter.",
			position = 2
	)
	String inventorySetupsSection = "invsetupsfilter";

	@ConfigSection(
			name = "Preferences",
			description = "Grand Exchange search filter preferences.",
			position = 3
	)
	String preferencesSection = "preferences";

	@ConfigItem(
		keyName = "enableBankTagFilter",
		name = "Enable Bank Tag Filter",
		description = "Filters GE items by bank tag. Requires the Bank Tag plugin to be enabled.",
		section = filtersSection,
		position = 0
	)
	default boolean enableBankTagFilter()
	{
		return true;
	}


	@ConfigItem(
			keyName = "enableInventorySetupsFilter",
			name = "Enable Inventory Setups Filter",
			description = "Filters GE items by inventory setups. Requires the Inventory Setups plugin to be enabled.",
			section = filtersSection,
			position = 1
	)
	default boolean enableInventorySetupsFilter()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableInventoryFilter",
			name = "Enable Inventory Filter",
			description = "Filters GE items by inventory/equipped items.",
			section = filtersSection,
			position = 2
	)
	default boolean enableInventoryFilter()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableRecentItemsFilter",
			name = "Enable Recent Items Filter",
			description = "Filters GE items by recently viewed or recent buy/sell offers.",
			section = filtersSection,
			position = 3
	)
	default boolean enableRecentItemsFilter()
	{
		return true;
	}


	@ConfigItem(
			keyName = "enableInvSetupsEquipment",
			name = "Equipment",
			description = "Show equipment items in the Inventory Setups filter.",
			section = inventorySetupsSection,
			position = 4
	)
	default boolean enableInvSetupsEquipment() { return true; }

	@ConfigItem(
			keyName = "enableInvSetupsInventory",
			name = "Inventory",
			description = "Show inventory items in the Inventory Setups filter.",
			section = inventorySetupsSection,
			position = 5
	)
	default boolean enableInvSetupsInventory() { return true; }

	@ConfigItem(
			keyName = "enableInvSetupsRunePouch",
			name = "Rune Pouch",
			description = "Show Rune pouch runes in the Inventory Setups filter.",
			section = inventorySetupsSection,
			position = 6
	)
	default boolean enableInvSetupsRunePouch() { return true; }

	@ConfigItem(
			keyName = "enableInvSetupsBoltPouch",
			name = "Bolt Pouch",
			description = "Show Bolt pouch bolts in the Inventory Setups filter.",
			section = inventorySetupsSection,
			position = 7
	)
	default boolean enableInvSetupsBoltPouch() { return true; }

	@ConfigItem(
			keyName = "enableInvSetupsQuiver",
			name = "Quiver",
			description = "Show Quiver ammo in the Inventory Setups filter.",
			section = inventorySetupsSection,
			position = 8
	)
	default boolean enableInvSetupsQuiver() { return true; }

	@ConfigItem(
			keyName = "enableInvSetupsAdditionalItems",
			name = "Additional Filtered Items",
			description = "Show additional filtered items the Inventory Setups filter.",
			section = inventorySetupsSection,
			position = 9
	)
	default boolean enableInvSetupsAdditionalItems() { return true; }

	@ConfigItem(
			keyName = "filterTitleColour",
			name = "Filter Title Colour",
			description = "The text colour for filter titles.",
			section = preferencesSection,
			position = 10
	)
	default Color filterTitleColour()
	{
		return new Color(178, 0, 0);
	}


	@ConfigItem(
			keyName = "keyPressOverridesFilter",
			name = "Typing Overrides Active Filter",
			description = "When enabled typing will override the currently active filter and perform a regular search.",
			section = preferencesSection,
			position = 11
	)
	default boolean keyPressOverridesFilter()
	{
		return true;
	}

	@ConfigItem(
			keyName = "hideSearchPrefix",
			name = "Hide Default Search Prefix",
			description = "Hide 'What would you like to buy?' from GE searches.",
			section = preferencesSection,
			position = 12
	)
	default boolean hideSearchPrefix()
	{
		return true;
	}

	@Range(
			max = 20,
			min = 0
	)
	@ConfigItem(
			keyName = "filterHorizontalSpacing",
			name = "Horizontal Spacing",
			description = "The horizontal space between filter buttons (px).",
			section = preferencesSection,
			position = 13
	)
	default int filterHorizontalSpacing()
	{
		return 5;
	}


}

package com.salverrs.GEFilters.Filters;

import java.util.List;

public class FilterUtility
{
    public static short[] getPrimitiveShortArray(List<Short> shorts)
    {
        short[] recentItems = new short[shorts.size()];
        for (int i = 0; i < shorts.size(); i++)
            recentItems[i] = shorts.get(i);
        return recentItems;
    }
}

package com.salverrs.GEFilters.Filters.Events;

import com.salverrs.GEFilters.Filters.SearchFilter;
import com.salverrs.GEFilters.Filters.Model.FilterOption;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class OtherFilterOptionActivated {
    private SearchFilter searchFilter;
    private FilterOption filterOption;

    public OtherFilterOptionActivated(SearchFilter filter, FilterOption option)
    {
        this.searchFilter = filter;
        this.filterOption = option;
    }
}

package com.salverrs.GEFilters.Filters;

import com.salverrs.GEFilters.Filters.Model.FilterOption;
import com.salverrs.GEFilters.GEFiltersPlugin;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.SpriteID;
import net.runelite.api.VarPlayer;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.eventbus.Subscribe;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static net.runelite.http.api.RuneLiteAPI.GSON;

public class RecentItemsSearchFilter extends SearchFilter {
    private static final int MAX_HISTORY_COUNT = 100;
    private static final int SPRITE_ID_MAIN = SpriteID.HOUSE_VIEWER_ROTATE_ANTICLOCKWISE;
    private static final String RECENT_ITEMS_JSON_KEY = "ge-recent-items";
    private static final String RECENT_BUY_OFFERS_JSON_KEY = "ge-recent-buy-offers";
    private static final String RECENT_SELL_OFFERS_JSON_KEY = "ge-recent-sell-offers";
    private static final String TITLE_RECENTLY_VIEWED = "Recently Viewed";
    private static final String TITLE_RECENT_BUY_OFFERS = "Recent Buy Offers";
    private static final String TITLE_RECENT_SELL_OFFERS = "Recent Sell Offers";
    private static final String SEARCH_BASE_RECENTLY_VIEWED = "recently-viewed-items";
    private static final String SEARCH_BASE_RECENT_BUY_OFFERS = "recent-buy-offers";
    private static final String SEARCH_BASE_RECENT_SELL_OFFERS = "recent-sell-offers";

    private FilterOption recentlyViewed, recentBuyOffers, recentSellOffers;
    private ArrayList<Short> recentItemIds, recentBuyOffersItemIds, recentSellOffersItemIds;

    @Override
    protected void onFilterInitialising()
    {
        loadRecentItems();
        loadRecentBuyOfferItems();
        loadRecentSellOfferItems();

        recentlyViewed = new FilterOption(TITLE_RECENTLY_VIEWED, SEARCH_BASE_RECENTLY_VIEWED);
        recentBuyOffers = new FilterOption(TITLE_RECENT_BUY_OFFERS, SEARCH_BASE_RECENT_BUY_OFFERS);
        recentSellOffers = new FilterOption(TITLE_RECENT_SELL_OFFERS, SEARCH_BASE_RECENT_SELL_OFFERS);

        setFilterOptions(recentlyViewed, recentBuyOffers, recentSellOffers);
        setIconSprite(SPRITE_ID_MAIN, 0);
    }

    @Override
    protected void onFilterStarted()
    {
        loadRecentItems();
        loadRecentBuyOfferItems();
        loadRecentSellOfferItems();
    }

    @Override
    protected void onFilterEnabled(FilterOption option)
    {
        if (option == recentlyViewed)
        {
            addItemFilterResults(recentItemIds);
        }
        else if (option == recentBuyOffers)
        {
            addItemFilterResults(recentBuyOffersItemIds);
        }
        else if (option == recentSellOffers)
        {
            addItemFilterResults(recentSellOffersItemIds);
        }
    }

    @Subscribe
    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged newOfferEvent)
    {
        if (!ready)
            return;

        final GrandExchangeOffer offer = newOfferEvent.getOffer();
        final GrandExchangeOfferState offerState = offer.getState();

        if (offerState == GrandExchangeOfferState.BUYING)
        {
            appendToIdList(recentBuyOffersItemIds, (short)offer.getItemId());
            saveRecentBuyOfferItems();
        }
        else if (offerState == GrandExchangeOfferState.SELLING)
        {
            appendToIdList(recentSellOffersItemIds, (short)offer.getItemId());
            saveRecentSellOfferItems();
        }
    }

    @Subscribe
    protected void onVarbitChanged(VarbitChanged event)
    {
        if (!ready)
            return;

        if (event.getVarpId() != VarPlayer.CURRENT_GE_ITEM)
            return;

        final int recentId = client.getVarpValue(VarPlayer.CURRENT_GE_ITEM);

        if (recentId == -1 || recentId == 0)
            return;

        appendToIdList(recentItemIds, (short)recentId);
        saveRecentItems();
    }

    private void appendToIdList(List<Short> itemList, short itemId)
    {
        final int existingIndex = itemList.indexOf(itemId);
        if (existingIndex != -1)
        {
            itemList.remove(existingIndex);
        }

        itemList.add(0, itemId);

        if (itemList.size() == MAX_HISTORY_COUNT)
        {
            itemList.remove(MAX_HISTORY_COUNT - 1);
        }
    }

    private void addItemFilterResults(ArrayList<Short> items)
    {
        if (items == null || items.isEmpty())
            return;

        final short[] itemIds = FilterUtility.getPrimitiveShortArray(items);
        setGESearchResults(itemIds);
    }

    private void saveRecentItems()
    {
        saveItemIdsToConfig(recentItemIds, RECENT_ITEMS_JSON_KEY);
    }

    private void saveRecentBuyOfferItems()
    {
        saveItemIdsToConfig(recentBuyOffersItemIds, RECENT_BUY_OFFERS_JSON_KEY);
    }

    private void saveRecentSellOfferItems()
    {
        saveItemIdsToConfig(recentSellOffersItemIds, RECENT_SELL_OFFERS_JSON_KEY);
    }

    private void saveItemIdsToConfig(List<Short> itemIds, String configKey)
    {
        final Short[] items = new Short[itemIds.size()];
        itemIds.toArray(items);

        final String json = GSON.toJson(items);
        configManager.setConfiguration(GEFiltersPlugin.CONFIG_GROUP_DATA, configKey, json);
    }

    private void loadRecentItems()
    {
        recentItemIds = loadItemIdsFromConfig(RECENT_ITEMS_JSON_KEY);
    }

    private void loadRecentBuyOfferItems()
    {
        recentBuyOffersItemIds = loadItemIdsFromConfig(RECENT_BUY_OFFERS_JSON_KEY);
    }

    private void loadRecentSellOfferItems()
    {
        recentSellOffersItemIds = loadItemIdsFromConfig(RECENT_SELL_OFFERS_JSON_KEY);
    }

    private ArrayList<Short> loadItemIdsFromConfig(String configKey)
    {
        final String itemsJson = configManager.getConfiguration(GEFiltersPlugin.CONFIG_GROUP_DATA, configKey);
        if (itemsJson == null || itemsJson.isEmpty())
        {
            return new ArrayList<Short>();
        }
        else
        {
            final Short[] recentItems = GSON.fromJson(itemsJson, Short[].class);
            return new ArrayList<>(Arrays.asList(recentItems));
        }
    }

}

package com.salverrs.GEFilters.Filters;

import com.salverrs.GEFilters.Filters.Events.OtherFilterOptionActivated;
import com.salverrs.GEFilters.Filters.Model.FilterOption;
import com.salverrs.GEFilters.Filters.Model.SearchState;
import com.salverrs.GEFilters.GEFiltersConfig;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.JagexColors;
import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;

// Heavily inspired by Quest helper's quest item filter - Credit to Zoinkwiz

public abstract class SearchFilter
{
    public static final int ICON_SIZE = 20;
    private static final String CLEAR_FILTER_OPTION = "Clear Filter";
    private static final String QUEST_HELPER_COMP_WIDGET_NAME = "quest helper";
    private static final String QUEST_HELPER_COMP_NAME = "Quest Helper";
    private static final String QUEST_HELPER_FILTER_OPTION = "View missing items";
    private static final int FILTER_TOGGLE_SOUND_ID = SoundEffectID.UI_BOOP;
    private static final int KEY_PRESS_SCRIPT_ID = 905;
    private static final int ICON_BG_SIZE_OFFSET = 6;
    private static final int ICON_BG_POS_OFFSET = 3;
    private static final int WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS = 10616883;
    private static final int WIDGET_ID_CHATBOX_CONTAINER = 10616870;
    private static final int WIDGET_ID_CHATBOX_TITLE = 10616874;
    private static final int WIDGET_ID_CHATBOX_FULL_INPUT = 10616875;
    private boolean qhEnabled;
    private Widget container;
    private Widget iconWidget;
    private Widget backgroundWidget;
    private Widget titleWidget;
    private Widget searchBoxWidget;
    private FilterOption lastOptionActivated;
    private SearchState lastSearchResults;
    private List<String> filterTitles;
    private String currentTitle;
    private int iconSpriteId;
    private int iconSpriteSizeOffset;
    private boolean filterEnabled;

    protected boolean ready;

    private HashMap<String, FilterOption> filterTitleMap;
    private HashMap<String, FilterOption> filterSearchMap;

    @Inject
    protected ConfigManager configManager;
    @Inject
    protected Client client;
    @Inject
    protected ClientThread clientThread;
    @Inject
    private EventBus eventBus;
    @Inject
    private PluginManager pluginManager;
    @Inject
    private GEFiltersConfig config;

    public void start(int xOffset, int yOffset)
    {
        if (isChatInputHidden())
            return;

        if (!ready)
            onFilterInitialising();

        onFilterStarted();

        checkQuestHelperState();
        createWidgets(xOffset, yOffset);
        refreshFilterMenuOptions(false);
        handleReactivation();

        ready = true;
    }

    public void stop()
    {
        container = null;
        trySetHidden(titleWidget, true);
        trySetHidden(iconWidget, true);
        trySetHidden(backgroundWidget, true);

        if (filterEnabled)
        {
            disableFilter(true);
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        if (event.getGroupId() == InterfaceID.GRAND_EXCHANGE)
        {
            disableFilter(true);
        }
    }

    @Subscribe
    protected void onMenuOptionClicked(MenuOptionClicked event)
    {
        if (!ready)
            return;

        final String optionClicked = event.getMenuOption();
        if (optionClicked.contains(QUEST_HELPER_FILTER_OPTION))
        {
            disableFilter(true);
            return;
        }

        final Widget widget = event.getWidget();
        if (widget != backgroundWidget && widget != iconWidget)
            return;

        if (optionClicked.equals(CLEAR_FILTER_OPTION))
        {
            disableFilter(true);
        }
        else
        {
            resolveQuestHelperFilterState();
            FilterOption option = filterTitleMap.get(optionClicked);
            enableFilter(option, false, true);
        }

        client.playSoundEffect(FILTER_TOGGLE_SOUND_ID);
    }

    @Subscribe
    protected void onGrandExchangeSearched(GrandExchangeSearched event)
    {
        if (!ready)
            return;

        final String input = client.getVarcStrValue(VarClientStr.INPUT_TEXT);
        if (!filterSearchMap.containsKey(input))
            return;

        final FilterOption option = filterSearchMap.get(input);

        event.consume();
        onFilterEnabled(option);
    }

    @Subscribe
    protected void onOtherFilterOptionActivated(OtherFilterOptionActivated event)
    {
        if (!ready)
            return;

        if (event.getSearchFilter() == this && event.getFilterOption() == lastOptionActivated)
            return;

        if (filterEnabled)
        {
            disableFilter(false);
        }
    }

    @Subscribe
    private void onScriptPreFired(ScriptPreFired event)
    {
        if (!ready || !filterEnabled || !config.keyPressOverridesFilter())
            return;

        if (event.getScriptId() != KEY_PRESS_SCRIPT_ID)
            return;

        if (!isItemSearchInput())
            return;

        final ScriptEvent scriptEvent = event.getScriptEvent();
        final int typedKeyChar = scriptEvent.getTypedKeyChar();

        if (typedKeyChar == 0)
            return;

        final String character = Character.toString((char)typedKeyChar);
        disableFilter(true);
        searchGE(character, false);
    }

    protected abstract void onFilterInitialising();

    protected abstract void onFilterStarted();

    protected abstract void onFilterEnabled(FilterOption option);

    protected void searchGE(String searchTerm)
    {
        searchGE(searchTerm, true);
    }

    protected void searchGE(String searchTerm, boolean hideSearch)
    {
        client.setVarcStrValue(VarClientStr.INPUT_TEXT, searchTerm);
        client.setVarcIntValue(VarClientInt.INPUT_TYPE, 14);
        forceUpdateSearch(hideSearch);
    }

    protected void setGESearchResults(short[] itemIds)
    {
        client.setGeSearchResultIndex(0);
        client.setGeSearchResultCount(itemIds.length);
        client.setGeSearchResultIds(itemIds);
    }

    protected void setTitle(String title)
    {
        Color titleColour = config.filterTitleColour();
        final int r = titleColour.getRed();
        final int g = titleColour.getGreen();
        final int b = titleColour.getBlue();
        final String hexColor = String.format("%02x%02x%02x", r, g, b);

        currentTitle = title;
        titleWidget.setText("<col=" + hexColor + ">" + currentTitle + "</col>");
    }

    protected void setFilterOptions(FilterOption ...options)
    {
        filterTitles = new ArrayList<>();
        filterTitleMap = new HashMap<>();
        filterSearchMap = new HashMap<>();

        for (FilterOption option : options)
        {
            final String title = option.getTitle();
            filterTitles.add(title);
            filterTitleMap.put(title, option);
            filterSearchMap.put(option.getSearchValue(), option);
        }
    }

    protected void setIconSprite(int spriteId, int sizeOffset)
    {
        iconSpriteId = spriteId;
        iconSpriteSizeOffset = sizeOffset;
    }

    protected void saveSearchState(String search)
    {
        lastSearchResults = new SearchState(currentTitle, search);
    }

    protected boolean hasPreviousSearchState()
    {
        return lastSearchResults != null;
    }

    protected void loadPreviousSearchState()
    {
        if (lastSearchResults == null)
            return;

        final String title = lastSearchResults.getTitle();
        final String searchVal = lastSearchResults.getSearchValue();

        setTitle(title);

        if (searchVal != null)
        {
            searchGE(searchVal);
        }
    }

    protected void resetPreviousSearchState()
    {
        lastSearchResults = null;
    }

    protected void forceUpdateSearch(boolean hideSearchBox)
    {
        clientThread.invokeLater(() ->
        {
            if (searchBoxWidget == null)
                return;

            final Object[] scriptArgs = searchBoxWidget.getOnKeyListener();
            if (scriptArgs == null)
                return;

            client.runScript(scriptArgs);
            searchBoxWidget.setHidden(hideSearchBox);
        });
    }

    protected void setSearchResultsHidden(boolean hidden)
    {
        final Widget resultsContainer = client.getWidget(WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS);
        if (resultsContainer != null)
        {
            resultsContainer.setHidden(hidden);
        }
    }

    private void enableFilter(FilterOption option, boolean silent, boolean clearData)
    {
        if (!ready)
            return;

        filterEnabled = true;
        refreshFilterMenuOptions(true);
        setWidgetActivationState(true, true);

        if (!silent)
        {
            setTitle(option.getTitle());
            searchGE(option.getSearchValue());
        }

        if (clearData)
        {
            option.setData(null);
        }

        lastOptionActivated = option;
        eventBus.post(new OtherFilterOptionActivated(this, option));
    }

    private void disableFilter(boolean clearSearch)
    {
        if (!ready || !filterEnabled)
            return;

        filterEnabled = false;
        refreshFilterMenuOptions(false);
        resetPreviousSearchState();

        filterTitleMap.values().forEach(f -> f.setData(null));

        clientThread.invokeLater(() -> {
            setWidgetActivationState(false, true);
        });

        if (clearSearch)
        {
            client.setVarcStrValue(VarClientStr.INPUT_TEXT, "");
            client.setVarcIntValue(VarClientInt.INPUT_TYPE, 14);
            forceUpdateSearch(false);
        }
    }

    private void handleReactivation()
    {
        if (filterEnabled)
        {
            if (hasPreviousSearchState())
            {
                enableFilter(lastOptionActivated, true, false);
                loadPreviousSearchState();
            }
            else
            {
                enableFilter(lastOptionActivated, false, false);
            }
        }
        else
        {
            resetPreviousSearchState();
        }
    }

    private void setWidgetActivationState(boolean filterEnabled, boolean hideSearchBox)
    {
        if (backgroundWidget != null)
        {
            backgroundWidget.setSpriteId(filterEnabled ? SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL_SELECTED : SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL);
            backgroundWidget.revalidate();
        }

        if (searchBoxWidget != null)
        {
            searchBoxWidget.setHidden(hideSearchBox);
        }

        if (titleWidget != null)
        {
            titleWidget.setHidden(!filterEnabled);
        }
    }

    private void refreshFilterMenuOptions(boolean showClearOption)
    {
        clearFilterOptions();

        if (showClearOption)
        {
            backgroundWidget.setAction(0, CLEAR_FILTER_OPTION);
        }

        int i = showClearOption ? 1 : 0;
        for (String optionTitle : filterTitles)
        {
            backgroundWidget.setAction(i, optionTitle);
            i++;
        }
    }

    private void clearFilterOptions()
    {
        for (int i = 0; i <= filterTitleMap.size(); i++)
        {
            backgroundWidget.setAction(i, null);
        }
    }

    private void checkQuestHelperState()
    {
        final Collection<Plugin> plugins = pluginManager.getPlugins();
        for (Plugin plugin : plugins)
        {
            final String name = plugin.getName();
            if (name.equals(QUEST_HELPER_COMP_NAME))
            {
                qhEnabled = pluginManager.isPluginEnabled(plugin);
                return;
            }
        }

        qhEnabled = false;
    }

    private void resolveQuestHelperFilterState()
    {
        if (!qhEnabled)
            return;

        final Widget[] children = container.getChildren();
        Widget qhIcon = null;

        for (int i = 0; i < children.length; i++)
        {
            final Widget child = children[i];
            if (child.getName().equals(QUEST_HELPER_COMP_WIDGET_NAME))
            {
                qhIcon = child;
                break;
            }
        }

        final boolean filterEnabled =  qhIcon != null && qhIcon.getSpriteId() == SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL_SELECTED;
        if (!filterEnabled)
            return;

        final Object[] filterArgs = qhIcon.getOnOpListener();
        client.runScript(filterArgs);
    }

    private boolean isChatInputHidden()
    {
        final Widget widget = client.getWidget(WIDGET_ID_CHATBOX_CONTAINER);
        return widget == null || widget.isHidden();
    }

    private boolean isItemSearchInput() // Search title is hidden on search input but not for quantity inputs
    {
        if (isChatInputHidden())
            return false;

        final Widget title = client.getWidget(WIDGET_ID_CHATBOX_TITLE);
        return title != null && title.isHidden();
    }

    private void createWidgets(int xOffset, int yOffset)
    {
        container = client.getWidget(WIDGET_ID_CHATBOX_CONTAINER);
        searchBoxWidget = client.getWidget(WIDGET_ID_CHATBOX_FULL_INPUT);
        titleWidget = createTitleWidget();
        backgroundWidget = createGraphicWidget(SpriteID.UNKNOWN_BUTTON_SQUARE_SMALL, ICON_SIZE, ICON_SIZE, xOffset, yOffset);
        iconWidget = createGraphicWidget(
                iconSpriteId,
                ICON_SIZE - ICON_BG_SIZE_OFFSET + iconSpriteSizeOffset, ICON_SIZE - ICON_BG_SIZE_OFFSET + iconSpriteSizeOffset,
                xOffset + ICON_BG_POS_OFFSET - (iconSpriteSizeOffset / 2), yOffset + ICON_BG_POS_OFFSET - (iconSpriteSizeOffset / 2));

    }

    private Widget createGraphicWidget(int spriteId, int width, int height, int x, int y)
    {
        final Widget widget = container.createChild(-1, WidgetType.GRAPHIC);

        widget.setOriginalX(x);
        widget.setOriginalY(y);
        widget.setOriginalWidth(width);
        widget.setOriginalHeight(height);

        widget.setSpriteId(spriteId);
        widget.setOnOpListener(ScriptID.NULL);
        widget.setHasListener(true);
        widget.revalidate();

        return widget;
    }

    private Widget createTitleWidget()
    {
        final Widget chatBoxWidget = client.getWidget(WIDGET_ID_CHATBOX_FULL_INPUT);
        final Widget widget = container.createChild(-1, WidgetType.TEXT);

        if (chatBoxWidget == null)
            return widget;

        widget.setOriginalWidth(chatBoxWidget.getWidth());
        widget.setOriginalHeight(chatBoxWidget.getHeight());
        widget.setOriginalX(0);
        widget.setOriginalY(0);

        widget.setTextShadowed(false);
        widget.setXTextAlignment(1);
        widget.setYTextAlignment(1);
        widget.setFontId(FontID.BOLD_12);
        widget.setTextColor(JagexColors.CHAT_GAME_EXAMINE_TEXT_OPAQUE_BACKGROUND.getRGB());

        widget.setHidden(true);
        widget.revalidate();

        return widget;
    }

    private void trySetHidden(Widget widget, boolean hidden)
    {
        if (widget != null)
        {
            widget.setHidden(hidden);
        }
    }

}

package com.salverrs.GEFilters.Filters.Model;

import net.runelite.api.widgets.Widget;

public class GeSearchResultWidget {
    private short itemId;
    private Widget container;
    private Widget title;
    private Widget icon;

    public GeSearchResultWidget(Widget container, Widget title, Widget icon, short itemId)
    {
        this.container = container;
        this.title = title;
        this.icon = icon;
        this.itemId = itemId;
    }

    public void setTooltipText(String text)
    {
        container.setName("<col=ff9040>" + text + "</col>");
    }

    public void setTitleText(String text)
    {
        title.setText(text);
    }

    public void setSpriteId(short spriteId)
    {
        icon.setType(5);
        icon.setContentType(0);
        icon.setItemId(-1);
        icon.setModelId(-1);
        icon.setModelType(1);

        icon.setSpriteId(spriteId);
        icon.revalidate();
    }

    public void setSpriteOffset(int xOffset, int yOffset)
    {
        icon.setOriginalX(icon.getOriginalX() + xOffset);
        icon.setOriginalY(icon.getOriginalY() + yOffset);
        icon.revalidate();
    }

    public void setSpriteSize(int width, int height)
    {
        icon.setOriginalWidth(width);
        icon.setWidthMode(0);

        icon.setOriginalHeight(height);
        icon.setWidthMode(0);

        icon.revalidate();
    }

    public void setItemIcon(short itemId)
    {
        icon.setItemId(itemId);
        icon.setSpriteId(itemId);
        icon.revalidate();
    }

    public void setOnOpListener(Object... args)
    {
        container.setOnOpListener(args);
    }
}

// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization;

import com.salverrs.GEFilters.Filters.Model.InventorySetups.*;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

public class InventorySetupItemSerializableTypeAdapter extends TypeAdapter<InventorySetupItemSerializable>
{
    @Override
    public void write(JsonWriter out, InventorySetupItemSerializable iss) throws IOException
    {
        if (iss == null)
        {
            out.setSerializeNulls(true);
            out.nullValue();
            out.setSerializeNulls(false);
        }
        else
        {
            out.beginObject();
            out.name("id");
            out.value(iss.getId());
            if (iss.getQ() != null)
            {
                out.name("q");
                out.value(iss.getQ());
            }
            if (iss.getF() != null)
            {
                out.name("f");
                out.value(iss.getF());
            }
            if (iss.getSc() != null)
            {
                out.name("sc");
                out.value(iss.getSc().toString());
            }
            out.endObject();
        }

    }

    @Override
    public InventorySetupItemSerializable read(JsonReader in) throws IOException
    {
        if (in.peek() == JsonToken.NULL)
        {
            in.nextNull();
            return null;
        }

        int id = -1;
        Integer q = null;
        Boolean f = null;
        InventorySetupsStackCompareID sc = null;

        in.beginObject();
        while (in.hasNext())
        {
            JsonToken token = in.peek();
            if (token.equals(JsonToken.NAME))
            {
                //get the current token
                String fieldName = in.nextName();
                switch (fieldName)
                {
                    case "id":
                        id = in.nextInt();
                        break;
                    case "q":
                        q = in.nextInt();
                        break;
                    case "f":
                        f = in.nextBoolean();
                        break;
                    case "sc":
                        sc = InventorySetupsStackCompareID.valueOf(in.nextString());
                        break;
                    default:
                        break;
                }
            }
        }

        in.endObject();
        return new InventorySetupItemSerializable(id, q, f, sc);
    }
}
// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization;

import com.salverrs.GEFilters.Filters.Model.InventorySetups.*;

import lombok.Value;
import javax.annotation.Nullable;

@Value
public class InventorySetupItemSerializable
{
    int id;
    @Nullable
    Integer q;		// Quantity (null = 1)
    @Nullable
    Boolean f;		// Fuzzy (null = FALSE)
    @Nullable
    InventorySetupsStackCompareID sc;	// Stack Compare (null = NONE)

    static public InventorySetupItemSerializable convertFromInventorySetupItem(final InventorySetupsItem item)
    {
        if (item == null || InventorySetupsItem.itemIsDummy(item))
        {
            return null;
        }
        Integer quantity = item.getQuantity() != 1 ? item.getQuantity() : null;
        Boolean fuzzy = item.isFuzzy() ? Boolean.TRUE : null;
        InventorySetupsStackCompareID sc = item.getStackCompare() != InventorySetupsStackCompareID.None ? item.getStackCompare() : null;
        return new InventorySetupItemSerializable(item.getId(), quantity, fuzzy, sc);
    }

    static public InventorySetupsItem convertToInventorySetupItem(final InventorySetupItemSerializable is)
    {
        if (is == null)
        {
            return InventorySetupsItem.getDummyItem();
        }
        int id = is.getId();
        // Name is not saved in the serializable object. It must be obtained from the item manager at runtime
        String name = "";
        int quantity = is.getQ() != null ? is.getQ() : 1;
        boolean fuzzy = is.getF() != null ? is.getF() : Boolean.FALSE;
        InventorySetupsStackCompareID sc = is.getSc() != null ? is.getSc() : InventorySetupsStackCompareID.None;
        return new InventorySetupsItem(id, name, quantity, fuzzy, sc);
    }
}
// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization;

import com.salverrs.GEFilters.Filters.Model.*;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.InventorySetup;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.InventorySetupsItem;
import joptsimple.internal.Strings;
import lombok.Value;

import javax.annotation.Nullable;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Value
public class InventorySetupSerializable
{

    List<InventorySetupItemSerializable> inv;	// inventory
    List<InventorySetupItemSerializable> eq;	// equipment
    @Nullable
    List<InventorySetupItemSerializable> rp;	// rune pouch (null = No rp)
    @Nullable
    List<InventorySetupItemSerializable> bp;	// bolt pouch (null = No bp)
    @Nullable
    List<InventorySetupItemSerializable> qv;	// quiver (null = No qv)
    @Nullable
    Map<Integer, InventorySetupItemSerializable> afi;		// additional filtered items (null = No afi)
    String name;	// name of setup
    @Nullable
    String notes;	// notes (null = empty notes)
    Color hc; 		// highlight color
    @Nullable
    Boolean hd;		// highlight difference (null = false)
    @Nullable
    Color dc;		// display color (null = no color)
    @Nullable
    Boolean fb;		// filter bank (null = false)
    @Nullable
    Boolean uh;		// unordered highlight (null = false)
    @Nullable
    Integer sb;		// Spell book (null = 0 standard)
    @Nullable
    Boolean fv;		// favorite (null = false)
    @Nullable
    Integer iId;	// iconID (null = default item ID for icon view)

    static public InventorySetupSerializable convertFromInventorySetup(final InventorySetup inventorySetup)
    {

        List<InventorySetupItemSerializable> inv = convertListFromInventorySetup(inventorySetup.getInventory());
        List<InventorySetupItemSerializable> eq = convertListFromInventorySetup(inventorySetup.getEquipment());
        List<InventorySetupItemSerializable> rp = convertListFromInventorySetup(inventorySetup.getRune_pouch());
        List<InventorySetupItemSerializable> bp = convertListFromInventorySetup(inventorySetup.getBoltPouch());
        List<InventorySetupItemSerializable> qv = convertListFromInventorySetup(inventorySetup.getQuiver());

        Map<Integer, InventorySetupItemSerializable> afi = null;
        if (inventorySetup.getAdditionalFilteredItems() != null && !inventorySetup.getAdditionalFilteredItems().isEmpty())
        {
            afi = new HashMap<>();
            for (final Integer key : inventorySetup.getAdditionalFilteredItems().keySet())
            {
                afi.put(key, InventorySetupItemSerializable.convertFromInventorySetupItem(inventorySetup.getAdditionalFilteredItems().get(key)));
            }
        }

        String name = inventorySetup.getName();
        String notes = !Strings.isNullOrEmpty(inventorySetup.getNotes()) ? inventorySetup.getNotes() : null;
        Color hc = inventorySetup.getHighlightColor();
        Boolean hd = inventorySetup.isHighlightDifference() ? Boolean.TRUE : null;
        Color dc = inventorySetup.getDisplayColor();
        Boolean fb = inventorySetup.isFilterBank() ? Boolean.TRUE : null;
        Boolean uh = inventorySetup.isUnorderedHighlight() ? Boolean.TRUE : null;
        Integer sb = inventorySetup.getSpellBook() != 0 ? inventorySetup.getSpellBook() : null;
        Boolean fv = inventorySetup.isFavorite() ? Boolean.TRUE : null;
        Integer iId = inventorySetup.getIconID() > 0 ? inventorySetup.getIconID() : null;

        return new InventorySetupSerializable(inv, eq, rp, bp, qv, afi, name, notes, hc, hd, dc, fb, uh, sb, fv, iId);
    }

    static private List<InventorySetupItemSerializable> convertListFromInventorySetup(final List<InventorySetupsItem> items)
    {
        List<InventorySetupItemSerializable> iss_list = null;
        if (items != null)
        {
            iss_list = new ArrayList<>();
            for (final InventorySetupsItem item : items)
            {
                iss_list.add(InventorySetupItemSerializable.convertFromInventorySetupItem(item));
            }
        }
        return iss_list;
    }

    static private List<InventorySetupsItem> convertListToInventorySetup(final List<InventorySetupItemSerializable> iss_items)
    {
        List<InventorySetupsItem> itemList = null;
        if (iss_items != null)
        {
            itemList = new ArrayList<>();
            for (final InventorySetupItemSerializable iss_item : iss_items)
            {
                itemList.add(InventorySetupItemSerializable.convertToInventorySetupItem(iss_item));
            }
        }
        return itemList;
    }

    static public InventorySetup convertToInventorySetup(final InventorySetupSerializable iss)
    {

        // Note that items will not have a name. They will need to be retrieved from the item manager
        // Either immediately after or delayed when a setup is opened
        List<InventorySetupsItem> inv = convertListToInventorySetup(iss.getInv());
        List<InventorySetupsItem> eq = convertListToInventorySetup(iss.getEq());
        List<InventorySetupsItem> rp = convertListToInventorySetup(iss.getRp());
        List<InventorySetupsItem> bp = convertListToInventorySetup(iss.getBp());
        List<InventorySetupsItem> qv = convertListToInventorySetup(iss.getQv());
        Map<Integer, InventorySetupsItem> afi = new HashMap<>();
        if (iss.getAfi() != null)
        {
            for (final Integer key : iss.getAfi().keySet())
            {
                afi.put(key, InventorySetupItemSerializable.convertToInventorySetupItem(iss.getAfi().get(key)));
            }
        }
        String name = iss.getName();
        String notes = iss.getNotes() != null ? iss.getNotes() : "";
        Color hc = iss.getHc();
        boolean hd = iss.getHd() != null ? iss.getHd() : Boolean.FALSE;
        Color dc = iss.getDc();
        boolean fb = iss.getFb() != null ? iss.getFb() : Boolean.FALSE;
        boolean uh = iss.getUh() != null ? iss.getUh() : Boolean.FALSE;
        int sb = iss.getSb() != null ? iss.getSb() : 0;
        boolean fv = iss.getFv() != null ? iss.getFv() : Boolean.FALSE;
        int iId = iss.getIId() != null ? iss.getIId() : -1;

        return new InventorySetup(inv, eq, rp, bp, qv, afi, name, notes, hc, hd, dc, fb, uh, sb, fv, iId);
    }


}
// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

public class LongTypeAdapter extends TypeAdapter<Long>
{

    @Override
    public Long read(JsonReader reader) throws IOException
    {
        if (reader.peek() == JsonToken.NULL)
        {
            reader.nextNull();
            return null;
        }
        String stringValue = reader.nextString();
        try
        {
            return Long.valueOf(stringValue);
        }
        catch (NumberFormatException e)
        {
            return Long.MAX_VALUE;
        }
    }

    @Override
    public void write(JsonWriter writer, Long value) throws IOException
    {
        if (value == null)
        {
            writer.nullValue();
            return;
        }
        writer.value(value);
    }
}
// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// Compatible with inventory-setups v1.19.3 'e0a5eb1d07a68749d448931d24d4ed2000903929' (Oct 7, 2024);
// Modified/simplified from 'InventorySetupsPersistentDataManager' to remove migration logic and to only read from config.

package com.salverrs.GEFilters.Filters.Model.InventorySetups;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization.InventorySetupItemSerializable;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization.InventorySetupItemSerializableTypeAdapter;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization.InventorySetupSerializable;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization.LongTypeAdapter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;


@Slf4j
public class InventorySetupsDataLoader
{
    public static final String CONFIG_GROUP = "inventorysetups";
    private final ConfigManager configManager;
    private Gson gson;
    public static final String CONFIG_KEY_SETUPS_V3_PREFIX = "setupsV3_";
    public static final String CONFIG_KEY_SETUPS_ORDER_V3 = "setupsOrderV3_";

    public InventorySetupsDataLoader(final ConfigManager manager,
                                     final Gson gson)
    {
        this.configManager = manager;
        this.gson = gson.newBuilder().registerTypeAdapter(long.class, new LongTypeAdapter()).create();
        this.gson = gson.newBuilder().registerTypeAdapter(InventorySetupItemSerializable.class, new InventorySetupItemSerializableTypeAdapter()).create();
    }

    public List<InventorySetup> getSetups()
    {
        return loadV3Setups();
    }

    private InventorySetup loadV3Setup(String configKey)
    {
        final String storedData = configManager.getConfiguration(CONFIG_GROUP, configKey);
        try
        {
            return InventorySetupSerializable.convertToInventorySetup(gson.fromJson(storedData, InventorySetupSerializable.class));
        }
        catch (Exception e)
        {
            log.error(String.format("[Ge-filters/Inventory-Setups] Exception occurred while loading %s", configKey), e);
            throw e;
        }
    }

    private List<InventorySetup> loadV3Setups()
    {
        final String wholePrefix = ConfigManager.getWholeKey(CONFIG_GROUP, null, CONFIG_KEY_SETUPS_V3_PREFIX);
        final List<String> loadedSetupWholeKeys = configManager.getConfigurationKeys(wholePrefix);
        Set<String> loadedSetupKeys = loadedSetupWholeKeys.stream().map(
                key -> key.substring(wholePrefix.length() - CONFIG_KEY_SETUPS_V3_PREFIX.length())
        ).collect(Collectors.toSet());

        Type setupsOrderType = new TypeToken<ArrayList<String>>()
        {

        }.getType();
        final String setupsOrderJson = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_SETUPS_ORDER_V3);
        List<String> setupsOrder = gson.fromJson(setupsOrderJson, setupsOrderType);
        if (setupsOrder == null)
        {
            setupsOrder = new ArrayList<>();
        }

        List<InventorySetup> loadedSetups = new ArrayList<>();
        for (final String configHash : setupsOrder)
        {
            final String configKey = CONFIG_KEY_SETUPS_V3_PREFIX + configHash;
            if (loadedSetupKeys.remove(configKey))
            { // Handles if hash is present only in configOrder.
                final InventorySetup setup = loadV3Setup(configKey);
                loadedSetups.add(setup);
            }
        }
        for (final String configKey : loadedSetupKeys)
        {
            // Load any remaining setups not present in setupsOrder. Useful if updateConfig crashes midway.
            //log.info("Loading setup that was missing from Order key: " + configKey);
            final InventorySetup setup = loadV3Setup(configKey);
            loadedSetups.add(setup);
        }
        return loadedSetups;
    }
}

// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups;

import java.awt.Color;
import java.util.List;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
public class InventorySetup implements InventorySetupsDisplayAttributes
{
    @Getter
    private List<InventorySetupsItem> inventory;

    @Getter
    private List<InventorySetupsItem> equipment;

    @Getter
    private List<InventorySetupsItem> rune_pouch;

    @Getter
    private List<InventorySetupsItem> boltPouch;

    @Getter
    private List<InventorySetupsItem> quiver;

    @Getter
    private Map<Integer, InventorySetupsItem> additionalFilteredItems;

    @Getter
    @Setter
    private String name;

    @Getter
    @Setter
    private String notes;

    @Getter
    @Setter
    private Color highlightColor;

    @Getter
    @Setter
    private boolean highlightDifference;

    @Getter
    @Setter
    private Color displayColor;

    @Getter
    @Setter
    private boolean filterBank;

    @Getter
    @Setter
    private boolean unorderedHighlight;

    /*
        0 = Standard
        1 = Ancient
        2 = Lunar
        3 = Arceuus
        4 = NONE

        Avoiding Enum because won't work well with GSON (defaults to null)
    */
    @Getter
    @Setter
    private int spellBook;

    @Getter
    @Setter
    private boolean favorite;

    @Getter
    @Setter
    private int iconID;

    public void updateInventory(final List<InventorySetupsItem> inv)
    {
        inventory = inv;
    }

    public void updateEquipment(final List<InventorySetupsItem> eqp)
    {
        equipment = eqp;
    }

    public void updateRunePouch(final List<InventorySetupsItem> rp)
    {
        rune_pouch = rp;
    }

    public void updateBoltPouch(final List<InventorySetupsItem> bp)
    {
        boltPouch = bp;
    }

    public void updateQuiver(final List<InventorySetupsItem> q)
    {
        quiver = q;
    }

    public void updateAdditionalItems(final Map<Integer, InventorySetupsItem> ai)
    {
        additionalFilteredItems = ai;
    }

    public void updateSpellbook(final int sb)
    {
        spellBook = sb;
    }

    public void updateNotes(final String text)
    {
        notes = text;
    }

}
// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public enum InventorySetupsStackCompareID
{
    // Don't highlight at all
    None(0),

    // Only highlight if stacks are equal
    Standard(1),

    // Only highlight if stack is less than what is in the setup
    Less_Than(2),

    // Only highlight if stack is greater than what is in the setup
    Greater_Than(3);

    private final int type;

    private static final List<InventorySetupsStackCompareID> VALUES;

    static
    {
        VALUES = new ArrayList<>();
        Collections.addAll(VALUES, InventorySetupsStackCompareID.values());
    }

    InventorySetupsStackCompareID(int type)
    {
        this.type = type;
    }

    public int getType()
    {
        return type;
    }

    public static List<InventorySetupsStackCompareID> getValues()
    {
        return VALUES;
    }

    public static String getStringFromValue(final InventorySetupsStackCompareID stackCompare)
    {
        if (stackCompare == null)
        {
            return "";
        }

        switch (stackCompare)
        {
            case None:
                return "";
            case Standard:
                return "!=";
            case Less_Than:
                return "<";
            case Greater_Than:
                return ">";
        }

        return "";
    }

}
// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups;


import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
public class InventorySetupsItem
{
    @Getter
    private final int id;
    @Getter
    @Setter
    private String name;
    @Getter
    @Setter
    private int quantity;
    @Getter
    @Setter
    private boolean fuzzy;
    @Getter
    @Setter
    private InventorySetupsStackCompareID stackCompare;

    public void toggleIsFuzzy()
    {
        fuzzy = !fuzzy;
    }

    public static InventorySetupsItem getDummyItem()
    {
        return new InventorySetupsItem(-1, "", 0, false, InventorySetupsStackCompareID.None);
    }

    public static boolean itemIsDummy(final InventorySetupsItem item)
    {
        // Don't use the name to compare
        return item.getId() == -1 &&
                item.getQuantity() == 0 &&
                !item.isFuzzy() &&
                (item.getStackCompare() == InventorySetupsStackCompareID.None || item.getStackCompare() == null);
    }

}
// All credit to Inventory Setups maintainers - https://github.com/dillydill123/inventory-setups
/*
 * Copyright (c) 2019, dillydill123 <https://github.com/dillydill123>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.salverrs.GEFilters.Filters.Model.InventorySetups;


import java.awt.Color;

public interface InventorySetupsDisplayAttributes
{
    String getName();
    void setName(final String name);
    Color getDisplayColor();
    void setDisplayColor(final Color color);
}
package com.salverrs.GEFilters.Filters.Model;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SearchState {
    private String title;
    private String searchValue;

    public SearchState(String title, String searchValue)
    {
        this.title = title;
        this.searchValue = searchValue;
    }
}

package com.salverrs.GEFilters.Filters.Model;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class GeSearch {
    private String name;
    private short iconItemId;

    public GeSearch(String name, short iconItemId)
    {
        this.name = name;
        this.iconItemId = iconItemId;
    }
}

package com.salverrs.GEFilters.Filters.Model;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class FilterOption
{
    private String title;
    private String searchValue;

    private Object data;

    public FilterOption(String title, String searchValue)
    {
        this.title = title;
        this.searchValue = searchValue;
    }
}

package com.salverrs.GEFilters.Filters;

import com.google.gson.Gson;
import javax.inject.Inject;
import com.salverrs.GEFilters.Filters.Model.FilterOption;
import com.salverrs.GEFilters.Filters.Model.GeSearch;
import com.salverrs.GEFilters.Filters.Model.GeSearchResultWidget;
import com.salverrs.GEFilters.GEFiltersConfig;
import com.salverrs.GEFilters.GEFiltersPlugin;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.*;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.*;
import com.salverrs.GEFilters.Filters.Model.InventorySetups.Serialization.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

public class InventorySetupsSearchFilter extends SearchFilter {

    private static final int SPRITE_ID_MAIN = SpriteID.TAB_EQUIPMENT;
    private static final String TITLE_MAIN = "Inventory Setups";
    private static final String SEARCH_BASE_MAIN = "inventory-setups";
    private static final String INV_SETUPS_MENU_IDENTIFIER = "Open setup";
    private static final String INV_SETUPS_MENU_IDENTIFIER_2 = "Open Section";
    private static final String SETUPS_EXCEPTION_JSON_KEY = "inventory-setups-exceptions";
    private static final int WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS = 10616883;
    private final GEFiltersConfig config;
    private FilterOption inventorySetupsFilter;
    private boolean bankOpen = false;
    private List<String> setupExceptions = new ArrayList<>();
    private Gson gson;
    private List<InventorySetup> inventorySetups = new ArrayList<>();
    private boolean initialLoad = true;

    @Getter
    private final InventorySetupsDataLoader dataManager;

    @Inject
    public InventorySetupsSearchFilter(GEFiltersConfig config, ConfigManager configManager, Gson gson) {
        this.config = config;
        this.gson = gson.newBuilder().registerTypeAdapter(long.class, new LongTypeAdapter()).create();
        this.gson = gson.newBuilder().registerTypeAdapter(InventorySetupItemSerializable.class, new InventorySetupItemSerializableTypeAdapter()).create();

        this.dataManager = new InventorySetupsDataLoader(configManager, gson);
    }

    @Override
    protected void onFilterInitialising()
    {
        inventorySetupsFilter = new FilterOption(TITLE_MAIN, SEARCH_BASE_MAIN);
        setFilterOptions(inventorySetupsFilter);
        setIconSprite(SPRITE_ID_MAIN, 0);
    }

    @Override
    protected void onFilterStarted()
    {
        loadSetupExceptions();

        if (initialLoad) {
            loadUpdatedInventorySetups();
            initialLoad = false;
        }
    }

    @Override
    protected void onFilterEnabled(FilterOption option)
    {
        if (option == inventorySetupsFilter)
        {
            if (option.getData() != null)
            {
                generateSetupResults((String)(option.getData()));
            }
            else
            {
                addInvSetupsFilterOptionResults();
            }
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        if (event.getGroupId() == InterfaceID.BANK)
        {
            bankOpen = true;
        }
    }

    @Override
    public void onWidgetClosed(WidgetClosed event)
    {
        super.onWidgetClosed(event);

        if (event.getGroupId() == InterfaceID.BANK)
        {
            bankOpen = false;
        }
    }

    @Subscribe
    protected void onClientTick(ClientTick clientTick)
    {
        if (client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen())
            return;

        if (!bankOpen)
            return;

        final Menu menu = client.getMenu();
        final List<MenuEntry> entries = new ArrayList<>(Arrays.asList(menu.getMenuEntries()));
        boolean isSetupsMenu = false;

        for (MenuEntry entry : entries)
        {
            final String option = entry.getOption();
            if (option.contains(INV_SETUPS_MENU_IDENTIFIER) || option.contains(INV_SETUPS_MENU_IDENTIFIER_2))
            {
                isSetupsMenu = true;
                break;
            }
        }

        if (!isSetupsMenu)
            return;

        final Set<String> setupNames = getInventorySetupNames();

        final Menu parent = menu.createMenuEntry(-1)
                .setOption("GE Filters Setups")
                .setTarget("")
                .setType(MenuAction.RUNELITE)
                .createSubMenu();


        for (String setup : setupNames)
        {
            if (setupExceptions.contains(setup))
            {
                parent.createMenuEntry(-1)
                        .setOption("Include")
                        .setTarget(setup)
                        .setType(MenuAction.RUNELITE)
                        .onClick(removeSetupFromExceptions(setup));
            }
            else
            {
                parent.createMenuEntry(-1)
                        .setOption("Exclude")
                        .setTarget(setup)
                        .setType(MenuAction.RUNELITE)
                        .onClick(addSetupToExceptions(setup));
            }
        }
    }

    private void addInvSetupsFilterOptionResults()
    {
        final ArrayList<GeSearch> setupFilters = new ArrayList<>();
        final Set<String> setupNames = getInventorySetupNames();

        if (setupNames == null || setupNames.isEmpty())
            return;

        for (String setup : setupNames)
        {
            if (setupExceptions.contains(setup))
                continue;

            setupFilters.add(new GeSearch(setup, (short)SpriteID.TAB_EQUIPMENT));
        }

        setGESearchResults(getEmptySearchResults(setupFilters.size()));
        setSearchResultsHidden(true);

        clientThread.invokeLater(() -> {
            final List<GeSearchResultWidget> searchResultWidgets = getGeSearchResults();
            generateInvSetupsResults(setupFilters, searchResultWidgets);
            setSearchResultsHidden(false);
        });
    }

    private void generateInvSetupsResults(List<GeSearch> filters, List<GeSearchResultWidget> searchResults)
    {
        if (searchResults.isEmpty())
            return;

        int resultIndex = 0;
        final int resultSize = searchResults.size();

        for (GeSearch filter : filters)
        {
            if (resultIndex == resultSize)
                break;

            final String setupName = filter.getName();
            final GeSearchResultWidget searchResult = searchResults.get(resultIndex);

            searchResult.setTitleText(setupName);
            searchResult.setTooltipText(setupName);
            searchResult.setSpriteId(filter.getIconItemId());
            searchResult.setSpriteSize(22, 24);
            searchResult.setSpriteOffset(5, 2);

            searchResult.setOnOpListener((JavaScriptCallback)(e) ->
            {
                final String title = TITLE_MAIN + " - " + setupName;
                inventorySetupsFilter.setData(setupName);
                searchGE(inventorySetupsFilter.getSearchValue());
                setTitle(title);
            });

            resultIndex++;
        }
    }

    private void generateSetupResults(String setupName)
    {
        final String title = TITLE_MAIN + " - " + setupName;
        final InventorySetup setup = getInventorySetup(setupName);

        if (setup == null)
            return;

        final List<InventorySetupsItem> invItems = setup.getInventory();
        final List<InventorySetupsItem> equipmentItems = setup.getEquipment();
        final List<InventorySetupsItem> runePouchItems = setup.getRune_pouch();
        final List<InventorySetupsItem> boltPouchItems = setup.getBoltPouch();
        final List<InventorySetupsItem> quiverItems = setup.getQuiver();
        final List<InventorySetupsItem> additionalFilteredItems = new ArrayList<>(setup.getAdditionalFilteredItems().values());

        List<Short> itemIds = new ArrayList<Short>();

        if (config.enableInvSetupsEquipment() && equipmentItems != null)
            itemIds.addAll(getSetupItemIds(equipmentItems));

        if (config.enableInvSetupsInventory() && invItems != null)
            itemIds.addAll(getSetupItemIds(invItems));

        if (config.enableInvSetupsRunePouch() && runePouchItems != null)
            itemIds.addAll(getSetupItemIds(runePouchItems));

        if (config.enableInvSetupsBoltPouch() && boltPouchItems != null)
            itemIds.addAll(getSetupItemIds(boltPouchItems));

        if (config.enableInvSetupsQuiver() && quiverItems != null)
            itemIds.addAll(getSetupItemIds(quiverItems));

        if (config.enableInvSetupsAdditionalItems())
            itemIds.addAll(getSetupItemIds(additionalFilteredItems));

        setTitle(title);
        addInventorySetupItemResults(itemIds);
        saveSearchState(SEARCH_BASE_MAIN);
    }

    private List<GeSearchResultWidget> getGeSearchResults()
    {
        final List<GeSearchResultWidget> results = new ArrayList<>();
        final Widget[] geSearchResultWidgets = Objects.requireNonNull(client.getWidget(WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS)).getDynamicChildren();
        final Queue<Widget> widgetQueue = new LinkedList<Widget>();

        for (Widget w : geSearchResultWidgets)
        {
            widgetQueue.add(w);

            if (widgetQueue.size() == 3)
            {
                final Widget container = widgetQueue.remove();
                final Widget title = widgetQueue.remove();
                final Widget icon = widgetQueue.remove();
                final short itemId = (short)icon.getItemId();

                results.add(new GeSearchResultWidget(container, title, icon, itemId));
            }
        }

        return results;
    }

    private Consumer<MenuEntry> addSetupToExceptions(String setup)
    {
        return e ->
        {
            if (setupExceptions.contains(setup))
                return;

            setupExceptions.add(setup);
            saveSetupExceptions();
        };
    }

    private Consumer<MenuEntry> removeSetupFromExceptions(String setup)
    {
        return e ->
        {
            if (!setupExceptions.contains(setup))
                return;

            setupExceptions.remove(setup);
            saveSetupExceptions();
        };
    }

    private void saveSetupExceptions()
    {
        final String[] setupExc = new String[setupExceptions.size()];
        setupExceptions.toArray(setupExc);
        final String json = gson.toJson(setupExc);
        configManager.setConfiguration(GEFiltersPlugin.CONFIG_GROUP_DATA, SETUPS_EXCEPTION_JSON_KEY, json);
    }

    private void loadSetupExceptions()
    {
        final String setupExceptionsJson = configManager.getConfiguration(GEFiltersPlugin.CONFIG_GROUP_DATA, SETUPS_EXCEPTION_JSON_KEY);
        if (setupExceptionsJson == null || setupExceptionsJson.isEmpty())
        {
            setupExceptions = new ArrayList<>();
        }
        else
        {
            final String[] setupExc = gson.fromJson(setupExceptionsJson, String[].class);
            setupExceptions = new ArrayList<>(Arrays.asList(setupExc));
        }
    }

    private short[] getEmptySearchResults(int size)
    {
        return new short[size];
    }

    private InventorySetup getInventorySetup(String name)
    {
        return Objects.requireNonNull(inventorySetups).stream().filter(s -> s.getName().equals(name)).findAny().orElse(null);
    }

    private Set<String> getInventorySetupNames()
    {
        return Objects.requireNonNull(inventorySetups).stream()
                .map(InventorySetup::getName)
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(TreeSet::new));
    }

    private List<Short> getSetupItemIds(List<InventorySetupsItem> items)
    {
        return items.stream().map(i -> (short)i.getId()).collect(Collectors.toList());
    }

    private void addInventorySetupItemResults(List<Short> itemIds)
    {
        final List<Short> finalItems = new ArrayList<>();

        for (Short id : itemIds)
        {
            if (id == -1)
                continue;

            ItemComposition composition = client.getItemDefinition(id);
            ItemComposition unnotedComposition = null;

            final int notedId = composition.getLinkedNoteId();
            if (notedId != -1)
            {
                unnotedComposition = client.getItemDefinition(notedId);
            }

            if (finalItems.contains(id) || finalItems.contains((short)notedId))
                    continue;

            if (composition.isTradeable())
            {
                finalItems.add(id);
            }
            else if (unnotedComposition != null && unnotedComposition.isTradeable())
            {
                finalItems.add((short)notedId);
            }
        }

        final short[] itemResultIds = FilterUtility.getPrimitiveShortArray(finalItems);
        setGESearchResults(itemResultIds);
    }

    private void loadUpdatedInventorySetups() {
        if (dataManager == null || clientThread == null)
            return;

        clientThread.invokeLater(() -> inventorySetups = dataManager.getSetups());
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged)
    {
        if (configChanged.getGroup().equals(InventorySetupsDataLoader.CONFIG_GROUP)) {
            loadUpdatedInventorySetups();
        }
    }

}

package com.salverrs.GEFilters.Filters;

import com.salverrs.GEFilters.Filters.Model.FilterOption;
import net.runelite.api.*;

import java.util.ArrayList;
import java.util.List;

public class InventorySearchFilter extends SearchFilter {

    private static final int SPRITE_ID_MAIN = SpriteID.TAB_INVENTORY;
    private static final String TITLE_INVENTORY = "Inventory Items";
    private static final String TITLE_EQUIPMENT = "Equipped Items";
    private static final String SEARCH_BASE_INVENTORY = "inventory-items";
    private static final String SEARCH_BASE_EQUIPMENT = "equipped-items";
    private FilterOption inventoryFilter, equipmentFilter;

    @Override
    protected void onFilterInitialising()
    {
        inventoryFilter = new FilterOption(TITLE_INVENTORY, SEARCH_BASE_INVENTORY);
        equipmentFilter = new FilterOption(TITLE_EQUIPMENT, SEARCH_BASE_EQUIPMENT);

        setFilterOptions(inventoryFilter, equipmentFilter);
        setIconSprite(SPRITE_ID_MAIN, 0);
    }

    @Override
    protected void onFilterStarted()
    {
    }

    @Override
    protected void onFilterEnabled(FilterOption option)
    {
        if (option == inventoryFilter)
        {
            addInventoryContainerResults(InventoryID.INVENTORY);
        }
        else if (option == equipmentFilter)
        {
            addInventoryContainerResults(InventoryID.EQUIPMENT);
        }
    }

    private void addInventoryContainerResults(InventoryID inventoryID)
    {
        final ItemContainer container = client.getItemContainer(inventoryID);
        if (container == null)
            return;

        final Item[] items = container.getItems();
        final List<Short> itemIds = new ArrayList<>();

        for (Item i : items)
        {
            final int id = i.getId();

            if (itemIds.contains((short)id))
                continue;

            final ItemComposition composition = client.getItemDefinition(id);
            ItemComposition unnotedComposition = null;

            final int notedId = composition.getLinkedNoteId();
            if (notedId != -1)
            {
                unnotedComposition = client.getItemDefinition(notedId);
            }

            if (composition.isTradeable())
            {
                itemIds.add((short)id);
            }
            else if (unnotedComposition != null && unnotedComposition.isTradeable())
            {
                itemIds.add((short)notedId);
            }
        }

        final short[] itemResultIds = FilterUtility.getPrimitiveShortArray(itemIds);
        setGESearchResults(itemResultIds);
    }

}

package com.salverrs.GEFilters.Filters;

import com.google.common.base.MoreObjects;
import com.salverrs.GEFilters.Filters.Model.FilterOption;
import com.salverrs.GEFilters.Filters.Model.GeSearch;
import com.salverrs.GEFilters.Filters.Model.GeSearchResultWidget;
import com.salverrs.GEFilters.GEFiltersPlugin;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.*;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.banktags.BankTagsPlugin;
import net.runelite.client.util.Text;

import java.util.*;
import java.util.function.Consumer;

import static net.runelite.http.api.RuneLiteAPI.GSON;

public class BankTabSearchFilter extends SearchFilter {

    private static final int SPRITE_ID_MAIN = SpriteID.MAP_ICON_BANK;
    private static final String TITLE_MAIN = "Bank Tags";
    private static final String SEARCH_BASE_MAIN = "bank-tags";
    private static final String TAG_TAB_MENU_IDENTIFIER = "Export tag tab";
    private static final String TAG_EXCEPTION_JSON_KEY = "bank-tags-exceptions";
    private static final int WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS = 10616883;
    private boolean bankOpen = false;
    private FilterOption bankTabFilter;
    private List<String> tagExceptions = new ArrayList<>();

    @Override
    protected void onFilterInitialising()
    {
        bankTabFilter = new FilterOption(TITLE_MAIN, SEARCH_BASE_MAIN);
        setFilterOptions(bankTabFilter);
        setIconSprite(SPRITE_ID_MAIN, -1);
    }

    @Override
    protected void onFilterStarted()
    {
        loadTagExceptions();
    }

    @Override
    protected void onFilterEnabled(FilterOption option)
    {
        if (option == bankTabFilter)
        {
            addBankTabFilterOptionResults();
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        if (event.getGroupId() == InterfaceID.BANK)
        {
            bankOpen = true;
        }
    }

    @Override
    public void onWidgetClosed(WidgetClosed event)
    {
        super.onWidgetClosed(event);

        if (event.getGroupId() == InterfaceID.BANK)
        {
            bankOpen = false;
        }
    }

    @Subscribe
    protected void onClientTick(ClientTick clientTick)
    {
        if (client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen())
            return;

        if (!bankOpen)
            return;

        final Menu menu = client.getMenu();
        final List<MenuEntry> entries = new ArrayList<>(Arrays.asList(menu.getMenuEntries()));

        String targetFormatted = null;
        String targetTag = null;
        boolean isTagMenu = false;

        for (MenuEntry entry : entries)
        {
            final String option = entry.getOption();
            if (option.contains(TAG_TAB_MENU_IDENTIFIER))
            {
                final String entryTarget = entry.getTarget();
                final String tagName = Text.removeTags(entry.getTarget()).replace("\u00a0"," ");
                isTagMenu = true;
                targetFormatted = entryTarget;
                targetTag = tagName;
                break;
            }
        }

        if (!isTagMenu)
            return;

        if (tagExceptions.contains(targetTag))
        {
            menu.createMenuEntry(-1)
                    .setOption("Include on GE Filters")
                    .setTarget(targetFormatted)
                    .setType(MenuAction.RUNELITE)
                    .onClick(removeTagFromExceptions(targetTag));
        }
        else
        {
            menu.createMenuEntry(-1)
                    .setOption("Exclude from GE Filters")
                    .setTarget(targetFormatted)
                    .setType(MenuAction.RUNELITE)
                    .onClick(addTagToExceptions(targetTag));
        }

    }

    private void addBankTabFilterOptionResults()
    {
        final ArrayList<GeSearch> tagFilters = new ArrayList<>();
        final List<String> tagNames = Text.fromCSV(MoreObjects.firstNonNull(configManager.getConfiguration(BankTagsPlugin.CONFIG_GROUP, BankTagsPlugin.TAG_TABS_CONFIG), ""));

        for (String tag : tagNames)
        {
            if (tagExceptions.contains(tag))
                continue;

            String iconItemId = configManager.getConfiguration(BankTagsPlugin.CONFIG_GROUP, BankTagsPlugin.TAG_ICON_PREFIX + tag);
            iconItemId = iconItemId == null ? "" + ItemID.SPADE : iconItemId;
            tagFilters.add(new GeSearch(tag, Short.parseShort(iconItemId)));
        }

        setGESearchResults(getEmptySearchResults(tagFilters.size()));
        setSearchResultsHidden(true);

        clientThread.invokeLater(() -> {
            final List<GeSearchResultWidget> searchResultWidgets = getGeSearchResults();
            generateBankTabResults(tagFilters, searchResultWidgets);
            setSearchResultsHidden(false);
        });
    }

    private void generateBankTabResults(List<GeSearch> filters, List<GeSearchResultWidget> searchResults)
    {
        if (searchResults.isEmpty())
            return;

        int resultIndex = 0;
        final int resultSize = searchResults.size();

        for (GeSearch filter : filters)
        {
            if (resultIndex == resultSize)
                break;

            final String search = filter.getName();
            final GeSearchResultWidget searchResult = searchResults.get(resultIndex);

            searchResult.setTitleText(search);
            searchResult.setTooltipText(search);
            searchResult.setItemIcon(filter.getIconItemId());
            searchResult.setOnOpListener((JavaScriptCallback)(e) ->
            {
                final String title = TITLE_MAIN + " - " + search;
                final String searchVal = BankTagsPlugin.TAG_SEARCH + search;

                searchGE(searchVal);
                setTitle(title);
                saveSearchState(searchVal);
            });

            resultIndex++;
        }
    }

    private List<GeSearchResultWidget> getGeSearchResults()
    {
        final List<GeSearchResultWidget> results = new ArrayList<>();
        final Widget[] geSearchResultWidgets = Objects.requireNonNull(client.getWidget(WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS)).getDynamicChildren();
        final Queue<Widget> widgetQueue = new LinkedList<Widget>();

        for (Widget w : geSearchResultWidgets)
        {
            widgetQueue.add(w);

            if (widgetQueue.size() == 3)
            {
                final Widget container = widgetQueue.remove();
                final Widget title = widgetQueue.remove();
                final Widget icon = widgetQueue.remove();
                final short itemId = (short)icon.getItemId();

                results.add(new GeSearchResultWidget(container, title, icon, itemId));
            }
        }

        return results;
    }

    private Consumer<MenuEntry> addTagToExceptions(String tag)
    {
        return e ->
        {
            if (tagExceptions.contains(tag))
                return;

            tagExceptions.add(tag);
            saveTagExceptions();
        };
    }

    private Consumer<MenuEntry> removeTagFromExceptions(String tag)
    {
        return e ->
        {
            if (!tagExceptions.contains(tag))
                return;

            tagExceptions.remove(tag);
            saveTagExceptions();
        };
    }

    private void saveTagExceptions()
    {
        final String[] tagExc = new String[tagExceptions.size()];
        tagExceptions.toArray(tagExc);
        final String json = GSON.toJson(tagExc);
        configManager.setConfiguration(GEFiltersPlugin.CONFIG_GROUP_DATA, TAG_EXCEPTION_JSON_KEY, json);
    }

    private void loadTagExceptions()
    {
        final String tagExceptionsJson = configManager.getConfiguration(GEFiltersPlugin.CONFIG_GROUP_DATA, TAG_EXCEPTION_JSON_KEY);
        if (tagExceptionsJson == null || tagExceptionsJson.isEmpty())
        {
            tagExceptions = new ArrayList<>();
        }
        else
        {
            final String[] tagExc = GSON.fromJson(tagExceptionsJson, String[].class);
            tagExceptions = new ArrayList<>(Arrays.asList(tagExc));
        }
    }

    private short[] getEmptySearchResults(int size)
    {
        return new short[size];
    }
}

package com.salverrs.GEFilters;

import com.google.inject.Provides;
import javax.inject.Inject;

import com.salverrs.GEFilters.Filters.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;


@Slf4j
@PluginDescriptor(
	name = "GE Filters",
	description = "Provides advanced search filters for the Grand Exchange, allowing users to sort and organize items efficiently for market flipping, bank setups, and more.",
	tags = {"ge","filter","grand","exchange","search","bank","tag","inventory","setups","sort","market","flipping","equipment","items","tool","qol","utility"},
	enabledByDefault = true
)
public class GEFiltersPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "GE_FILTERS_CONFIG";
	public static final String CONFIG_GROUP_DATA = "GE_FILTERS_CONFIG_DATA";
	public static final String BANK_TAGS_COMP_NAME = "Bank Tags";
	private static final String SEARCH_BUY_PREFIX = "What would you like to buy?";
	public static final String INVENTORY_SETUPS_COMP_NAME = "Inventory Setups";
	private static final int WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS = 10616883;
	private static final int SEARCH_BOX_LOADED_ID = 750;
	private static final int SEARCH_STRING_APPEND_ID = 222;

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private GEFiltersConfig config;
	@Inject
	private ConfigManager configManager;
	@Inject
	private EventBus eventBus;
	@Inject
	private BankTabSearchFilter bankTabSearchFilter;
	@Inject
	private InventorySetupsSearchFilter inventorySetupsSearchFilter;
	@Inject
	private RecentItemsSearchFilter recentItemsSearchFilter;
	@Inject
	private InventorySearchFilter inventorySearchFilter;
	@Inject
	private PluginManager pluginManager;

	private List<SearchFilter> filters;

	@Override
	protected void startUp() throws Exception
	{
		log.info("GE Filters started!");
		clientThread.invoke(() ->
		{
			loadFilters();
			tryStartFilters();
		});
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("GE Filters stopped!");
		clientThread.invoke(this::stopFilters);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		if (event.getScriptId() == SEARCH_BOX_LOADED_ID)
		{
			clientThread.invoke(this::tryStartFilters);
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		// Replace with the correct group ID for GE search if needed
		if (config.hideSearchPrefix() && event.getGroupId() == 1062) // 1062 is commonly GE search group
		{
			clientThread.invokeLater(() -> {
				// Replace with the correct WidgetInfo if available in your RuneLite version
				Widget searchInput = client.getWidget(1062, 44); // 44 is usually the input field index
				if (searchInput != null && SEARCH_BUY_PREFIX.equals(searchInput.getText())) {
					searchInput.setText("");
				}
			});
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (!configChanged.getGroup().equals(GEFiltersPlugin.CONFIG_GROUP))
			return;

		clientThread.invoke(() ->
		{
			stopFilters();
			loadFilters();
			tryStartFilters();
		});
	}

	private void loadFilters()
	{
		filters = new ArrayList<>();

		if (config.enableBankTagFilter() && isPluginEnabled(BANK_TAGS_COMP_NAME))
		{
			filters.add(bankTabSearchFilter);
		}

		if (config.enableInventorySetupsFilter() && isPluginEnabled(INVENTORY_SETUPS_COMP_NAME))
		{
			filters.add(inventorySetupsSearchFilter);
		}

		if (config.enableInventoryFilter())
		{
			filters.add(inventorySearchFilter);
		}

		if (config.enableRecentItemsFilter())
		{
			filters.add(recentItemsSearchFilter);
		}

		registerFilterEvents();
	}

	private void tryStartFilters()
	{
		if (isSearchVisible())
		{
			startFilters();
		}
	}

	private void startFilters()
	{
		final int horizontalSpacing = SearchFilter.ICON_SIZE + config.filterHorizontalSpacing();
		int xOffset = 0;

		for (SearchFilter filter : filters)
		{
			filter.start(xOffset, 0);
			xOffset += horizontalSpacing ;
		}
	}

	private void stopFilters()
	{
		for (SearchFilter filter : filters)
		{
			filter.stop();
		}

		unregisterFilterEvents();
	}

	private void registerFilterEvents()
	{
		for (SearchFilter filter : filters)
		{
			eventBus.register(filter);
		}
	}

	private void unregisterFilterEvents()
	{
		for (SearchFilter filter : filters)
		{
			eventBus.unregister(filter);
		}
	}

	private boolean isPluginEnabled(String pluginName)
	{
		final Collection<Plugin> plugins = pluginManager.getPlugins();
		for (Plugin plugin : plugins)
		{
			final String name = plugin.getName();
			if (name.equals(pluginName))
			{
				return pluginManager.isPluginEnabled(plugin);
			}
		}

		return false;
	}

	private boolean isSearchVisible()
	{
		final Widget widget = client.getWidget(WIDGET_ID_CHATBOX_GE_SEARCH_RESULTS);
		return widget != null && !widget.isHidden();
	}

	@Provides
	GEFiltersConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GEFiltersConfig.class);
	}
}

package com.salverrs.GEFilters;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GEFiltersPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GEFiltersPlugin.class);
		RuneLite.main(args);
	}
}
