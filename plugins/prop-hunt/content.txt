package com.idyl.prophunt;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.concurrent.ThreadLocalRandom;
import javax.inject.Inject;
import javax.inject.Provider;

import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.geometry.SimplePolygon;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.Hooks;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(
	name = "Prop Hunt"
)
public class PropHuntPlugin extends Plugin {
	public final String CONFIG_KEY = "prophunt";
	public final Pattern modelEntry = Pattern.compile("[a-zA-Z]+:[ ]?[0-9]+");

	@Getter
    @Inject
	private Client client;

	@Getter
	@Inject
	private PropHuntConfig config;

	@Inject
	private Hooks hooks;

	@Inject
	private Provider<MenuManager> menuManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private PropHuntDataManager propHuntDataManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PropHuntOverlay propHuntOverlay;

	@Inject
	private ClientToolbar clientToolbar;

	private PropHuntPanel panel;
	private NavigationButton navButton;

	private RuneLiteObject localDisguise;

	private HashMap<String, RuneLiteObject> playerDisguises = new HashMap<>();

	private String[] players;
	private HashMap<String, PropHuntPlayerData> playersData;

	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	private final long SECONDS_BETWEEN_GET = 5;
	private static final int DOT_PLAYER = 2;
	private static final int DOT_FRIEND = 3;
	private static final int DOT_TEAM = 4;
	private static final int DOT_FRIENDSCHAT = 5;
	private static final int DOT_CLAN = 6;

	private SpritePixels[] originalDotSprites;
	private static final String ADD_HIDER = "Add Hider";
	private static final String GUESS = "Guess";
	private static int tickCounter = 0;
	private static final int TICK_INTERVAL = 250;
	@Getter
	private int rightClickCounter = 0;
	private static final int RANDOM_MODEL_UPDATE_INTERVAL = 5000;
	private long lastRandomModelUpdate = 0;

	private String[] seekerList;
	private boolean suppressLobbyPost = false;

	@Override
	protected void startUp() throws Exception {
		playersData = new HashMap<>();
		hooks.registerRenderableDrawListener(drawListener);
		clientThread.invokeLater(() -> transmogPlayer(client.getLocalPlayer()));
		setPlayersFromString(config.players());
		getPlayerConfigs();
		storeOriginalDots();
		if (config.hideMinimapDots()) {
			hideMinimapDots();
		}
		if (client != null) {
			menuManager.get().addPlayerMenuItem(ADD_HIDER);
		}

		panel = new PropHuntPanel(this);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "panel_icon.png");
		navButton = NavigationButton.builder()
				.tooltip("Prop Hunt")
				.priority(5)
				.icon(icon)
				.panel(panel)
				.build();
		clientToolbar.addNavigation(navButton);
		updateDropdown();
		overlayManager.add(propHuntOverlay);
	}

	@Override
	protected void shutDown() throws Exception {
		clientThread.invokeLater(this::removeAllTransmogs);
		configManager.setConfiguration(CONFIG_KEY, "hideMode", false);
		PropHuntPlayerData playerData = new PropHuntPlayerData(client.getLocalPlayer().getName(), false, config.modelID(), config.orientation());
		propHuntDataManager.updatePropHuntApi(playerData);
		overlayManager.remove(propHuntOverlay);
		hooks.unregisterRenderableDrawListener(drawListener);
		clientToolbar.removeNavigation(navButton);
		restoreOriginalDots();
		if (client != null) {
			menuManager.get().removePlayerMenuItem(ADD_HIDER);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (GameState.LOGGED_IN.equals(event.getGameState())) {
			if (config.hideMode()) clientThread.invokeLater(() -> transmogPlayer(client.getLocalPlayer()));

			if (client.getLocalPlayer().getName() != null)
				propHuntDataManager.updatePropHuntApi(new PropHuntPlayerData(client.getLocalPlayer().getName(),
						config.hideMode(), getModelId(), config.orientation()));
		}

		if (event.getGameState() == GameState.LOGIN_SCREEN && originalDotSprites == null) {
			storeOriginalDots();
			if (config.hideMinimapDots()) hideMinimapDots();
		}
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event) {
		clientThread.invokeLater(this::removeAllTransmogs);

		if (event.getKey().equals("lobby")) {
			clientThread.invokeLater(this::removeAllTransmogs);
			String lobby = config.lobby();
			if (lobby != null && !lobby.isEmpty()) {
				propHuntDataManager.fetchPlayers(lobby);
				propHuntDataManager.fetchSeekers(lobby);
			}
			else {
				propHuntDataManager.fetchPlayers(null);
				propHuntDataManager.fetchSeekers(null);
			}
			getPlayerConfigs();
		}

		if (event.getKey().equals("players")) {
			clientThread.invokeLater(this::removeAllTransmogs);
			setPlayersFromString(config.players());
			if(!suppressLobbyPost) {
				if (config.lobby() == null || config.lobby().isEmpty() || Objects.equals(config.lobby(), client.getLocalPlayer().getName())) {
					propHuntDataManager.createLobby(client.getLocalPlayer().getName(), config.players());
				} else if (isSeeker()) {
					propHuntDataManager.createLobby(config.lobby(), config.players());
				}
			}
			getPlayerConfigs();
		}

		if (event.getKey().equals("hideMinimapDots")) {
			if (config.hideMinimapDots()) {
				hideMinimapDots();
			} else {
				restoreOriginalDots();
			}
		}

		if (event.getKey().equals("models")) {
			updateDropdown();
		}

		if (event.getKey().equals("seekers")) {
			propHuntDataManager.postSeekers(client.getLocalPlayer().getName(), config.seekers());
		}

		if (event.getKey().equals("apiURL")) {
			if (config.alternate()) {
				if (!config.apiURL().isEmpty()) {
					propHuntDataManager.setApp1Url((config.apiURL() + ":8080"));
					propHuntDataManager.setApp2Url((config.apiURL() + ":5000"));
				} else {
					propHuntDataManager.setApp1Url((propHuntDataManager.DEFAULT_URL + ":8080"));
					propHuntDataManager.setApp2Url((propHuntDataManager.DEFAULT_URL + ":5000"));
				}
			}
		}

		if (event.getKey().equals("alternate")) {
			if (config.alternate()) {
				if (!config.apiURL().isEmpty()) {
					propHuntDataManager.setApp1Url((config.apiURL() + ":8080"));
					propHuntDataManager.setApp2Url((config.apiURL() + ":5000"));
				} else {
					propHuntDataManager.setApp1Url((propHuntDataManager.DEFAULT_URL + ":8080"));
					propHuntDataManager.setApp2Url((propHuntDataManager.DEFAULT_URL + ":5000"));
					configManager.setConfiguration("prophunt", "apiURL", "");
				}
			} else {
				propHuntDataManager.setApp1Url((propHuntDataManager.DEFAULT_URL + ":8080"));
				propHuntDataManager.setApp2Url((propHuntDataManager.DEFAULT_URL + ":5000"));
				configManager.setConfiguration("prophunt", "apiURL", "");
			}
		}

		if (event.getKey().equals("limitRightClicks")) {
			rightClickCounter = 0;
		}

		if (client.getLocalPlayer() != null) {
			propHuntDataManager.updatePropHuntApi(new PropHuntPlayerData(client.getLocalPlayer().getName(),
					config.hideMode(), getModelId(), config.orientation()));
			clientThread.invokeLater(this::transmogOtherPlayers);
		}

		if (config.hideMode()) {
			clientThread.invokeLater(() -> {
				if (client.getLocalPlayer() != null) {
					transmogPlayer(client.getLocalPlayer());
				}
			});
		}
		panel.updatePanelWithDefaults();
	}

	@Subscribe
	public void onClientTick(final ClientTick event) {
		if (config.hideMode() && localDisguise != null) {
			LocalPoint playerPoint = client.getLocalPlayer().getLocalLocation();
			localDisguise.setLocation(playerPoint, client.getPlane());
		} else {
			if (!config.hideMode()) {
				removeLocalTransmog();
			}
		}
		if (config.lobby() == "" || config.lobby().isEmpty() || Objects.equals(config.lobby(), client.getLocalPlayer().getName())) {
			configManager.setConfiguration(CONFIG_KEY, "lobby", client.getLocalPlayer().getName());
			if (++tickCounter >= TICK_INTERVAL) {
				propHuntDataManager.fetchPlayers(config.lobby());
				tickCounter = 0;
			}
		} else {
			if (++tickCounter >= TICK_INTERVAL) {
				propHuntDataManager.fetchPlayers(config.lobby());
				propHuntDataManager.fetchSeekers(config.lobby());
				tickCounter = 0;
			}
		}
		transmogOtherPlayers();
		client.getPlayers().forEach(this::updatePlayerDisguiseLocation);
		if(client.isMenuOpen() || client.getGameState() != GameState.LOGGED_IN || rightClickCounter >= config.maxRightClicks()) return;
		addMenu();
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event) {
		if (config.limitRightClicks() && !config.hideMode()) {
			if (rightClickCounter >= config.maxRightClicks()) {
				sendHighlightedChatMessage("You have used all of your guesses!");
				return;
			}
			rightClickCounter++;
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		if (playerDisguises == null || playerDisguises.size() == 0) return;

		if (!event.getOption().startsWith("Walk here")) {
			if (config.depriorizteMenuOptions()) event.getMenuEntry().setDeprioritized(true);
			return;
		}

	}

	@Subscribe
	public void onOverlayMenuClicked(OverlayMenuClicked event) {
		if (event.getEntry() == PropHuntOverlay.RESET_ENTRY) {
			rightClickCounter = 0;
		}
	}

	private void onMenuOptionClicked(MenuEntry menuEntry) {
		if (Objects.equals(menuEntry.getOption(), GUESS)) {
			String playerName = checkProp();
			if (playerName != null) {
				playerFound(playerName);
			}
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		String playerList = "";
		if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals(ADD_HIDER)) {
			String playerName = event.getMenuEntry().getPlayer().getName();
			if (playerName == null || playerName.isEmpty()) {return;}
			if (Objects.equals(client.getLocalPlayer().getName(), config.lobby()) || config.lobby() == null || config.lobby().isEmpty()) {
				if (config.players().isEmpty() || config.players() == null) {
					playerList = playerName;
				} else if (config.players().contains(playerName)) {
					sendNormalChatMessage(playerName + " is already in the lobby!");
					playerList = config.players();
				} else {
					playerList = config.players() + "\n" + event.getMenuEntry().getPlayer().getName();
				}
				configManager.setConfiguration(CONFIG_KEY, "players", playerList);
			}
		}
	}

	public void addMenu() {
		MenuEntry[] menuEntries = client.getMenuEntries();
		if (menuEntries.length < 2) return;

		for (MenuEntry menuEntry : menuEntries) {
			if 	   (Objects.equals(menuEntry.getType().toString(), "CC_OP") ||
					Objects.equals(menuEntry.getType().toString(), "RUNELITE_PLAYER") ||
					Objects.equals(menuEntry.getType().toString(), "EXAMINE_NPC") ||
					Objects.equals(menuEntry.getType().toString(), "RUNELITE") ||
					Objects.equals(menuEntry.getType().toString(), "UNKNOWN") ||
					Objects.equals(menuEntry.getType().toString(), "EXAMINE_OBJECT") ||
					Objects.equals(menuEntry.getType().toString(), "WIDGET_TARGET")){
					return;
			}
		}
		client.createMenuEntry(1)
				.setOption(GUESS)
				.setType(MenuAction.GAME_OBJECT_SECOND_OPTION)
				.setDeprioritized(false)
				.setForceLeftClick(false)
				.setIdentifier(0)
				.onClick(this::onMenuOptionClicked);
	}

	private String checkProp(){
		LocalPoint wp = client.getSelectedSceneTile().getLocalLocation();
		for (String player: getPlayerNames()) {
			RuneLiteObject disguise = playerDisguises.get(player);
			if (disguise == null) {
				continue;
			}
			LocalPoint lp = disguise.getLocation();
			Model disguiseModel = client.loadModel(playersData.get(player).modelID);
			if (disguiseModel != null) {
				int minX = lp.getX() - 100;
				int minY = lp.getY() - 100;
				int maxX = lp.getX() + 100;
				int maxY = lp.getY() + 100;
				if (wp.getX() > minX && wp.getX() < maxX && wp.getY() > minY && wp.getY() < maxY)
				{
					return player;
				}
			}
		}
		return null;
	}

	private void playerFound(String playerName) {
		removePlayerTransmog(playerName);

		PropHuntPlayerData playerData = playersData.get(playerName);
		if (playerData != null) {
			playerData.hiding = false;
			String newPlayers = config.players().replace(playerName, "").replaceAll("(?m)^[\\s]*$\\n?", "");;
			if (newPlayers.endsWith("\n")) {
				newPlayers = newPlayers.substring(0, newPlayers.length() - 1);
			}
			configManager.setConfiguration(CONFIG_KEY, "players", newPlayers);
			rightClickCounter--;
		}
		if(config.sound()) {
			client.playSoundEffect(2396);
			client.playSoundEffect(2379);
		}
		sendHighlightedChatMessage(playerName + " has been found!");
	}

	private void sendNormalChatMessage(String message) {
		ChatMessageBuilder msg = new ChatMessageBuilder()
				.append(ChatColorType.NORMAL)
				.append(message);

		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.ITEM_EXAMINE)
				.runeLiteFormattedMessage(msg.build())
				.build());
	}

	private void sendHighlightedChatMessage(String message) {
		ChatMessageBuilder msg = new ChatMessageBuilder()
				.append(ChatColorType.HIGHLIGHT)
				.append(message);

		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(msg.build())
				.build());
	}

	@VisibleForTesting
	boolean shouldDraw(Renderable renderable, boolean drawingUI) {
		if (renderable instanceof Player) {
			Player player = (Player) renderable;
			Player local = client.getLocalPlayer();

			if (player == local) {
				return !config.hideMode();
			}

			if (players == null) return true;

			ArrayList<String> playerList = new ArrayList<>(Arrays.asList(players));

			if (!playerList.contains(player.getName())) {
				PropHuntPlayerData data = playersData.get(player.getName());
				if (data != null) {
					if (data.hiding) {
						transmogPlayer(player, 0, 0, true);
						data.hiding = false;
					}
				}
				return true;
			} else {
				PropHuntPlayerData data = playersData.get(player.getName());
				if (data != null && data.hiding) {
					if (!playerDisguises.containsKey(player.getName())) {
						transmogPlayer(player, data.modelID, data.orientation, false);  // Apply disguise
					}
					return false;
				}
			}

			return true;
		}
		return true;
	}

	private void transmogPlayer(Player player) {
		transmogPlayer(player, getModelId(), config.orientation(), true);
	}

	private void transmogPlayer(Player player, int modelId, int orientation, boolean isLocal) {
		int modelID = isLocal ? modelId : playersData.get(player.getName()).modelID;

		if (isLocal) {
			removeLocalTransmog();
		} else {
			removePlayerTransmog(player);
		}

		RuneLiteObject disguise = client.createRuneLiteObject();
		try {
			LocalPoint loc = LocalPoint.fromWorld(client, player.getWorldLocation());
			if (loc == null) {
				return;
			}
		} catch (NullPointerException e){
			return;
		}

		Model model = client.loadModel(modelID);
		if (model == null) {
			log.warn("Failed to load model with ID: {}", modelID);
			return;
		}

		disguise.setModel(model);
		disguise.setLocation(player.getLocalLocation(), player.getWorldLocation().getPlane());
		disguise.setActive(true);
		disguise.setOrientation(orientation);

		if (isLocal) {
			localDisguise = disguise;
		} else {
			playerDisguises.put(player.getName(), disguise);
		}
	}

	private void transmogOtherPlayers() {
		if(players == null || client.getLocalPlayer() == null) return;

		client.getPlayers().forEach(player -> {
			if(client.getLocalPlayer() == player) return;

			PropHuntPlayerData data = playersData.get(player.getName());

			if(data == null || !data.hiding) return;
			transmogPlayer(player, data.modelID, data.orientation, false);
		});
	}

	private void removeLocalTransmog() {
		if (localDisguise != null)
		{
			localDisguise.setActive(false);
		}
		localDisguise = null;
	}

	private void removeTransmogs()
	{
		playerDisguises.forEach((p, disguise) -> {
			if(disguise == null) return;
			disguise.setActive(false);
		});
	}

	private void removeAllTransmogs() {
		removeTransmogs();
		removeLocalTransmog();
	}

	private void removePlayerTransmog(Player player) {
		if (playerDisguises.containsKey(player.getName())) {
			RuneLiteObject disguise = playerDisguises.get(player.getName());
			if (disguise != null) {
				disguise.setActive(false);
				playerDisguises.remove(player.getName());
			}
		}
	}

	private void removePlayerTransmog(String playerName) {
		if (playerDisguises.containsKey(playerName)) {
			RuneLiteObject disguise = playerDisguises.get(playerName);
			if (disguise != null) {
				disguise.setActive(false);
				playerDisguises.remove(playerName);
			}
		}
	}

	private void updatePlayerDisguiseLocation(Player player) {
		if (player == null || player == client.getLocalPlayer()) {
			return;
		}

		RuneLiteObject disguise = playerDisguises.get(player.getName());
		if (disguise != null) {
			disguise.setLocation(player.getLocalLocation(), player.getWorldLocation().getPlane());
		}
	}

	public void updatePlayerData(HashMap<String, PropHuntPlayerData> data) {
		clientThread.invokeLater(() -> {
			removeTransmogs();
			playersData.clear();
			playerDisguises.clear();
			playersData.putAll(data);
			playersData.values().forEach(player -> playerDisguises.put(player.username, null));
			transmogOtherPlayers();
		});
	}

	public void updatePlayerList(String[] playerList) {
		suppressLobbyPost = true;
		String p = "";
		if (playerList == null) p = "";
		else p = String.join("\n", playerList);

		setPlayersFromString(p);
		configManager.setConfiguration(CONFIG_KEY, "players", p);
		suppressLobbyPost = false;
	}

	public void updateSeekerList(String[] playerList) {
		seekerList = playerList;
	}

	private void updateDropdown() {
		String[] modelList = config.models().split(",");
		PropHuntModelId.map.clear();

		for(String model : modelList) {
			model = model.trim();

			if(!modelEntry.matcher(model).matches()) continue;

			String modelName = model.split(":")[0].trim();
			String modelId = model.split(":")[1].trim();

			PropHuntModelId.add(modelName, Integer.parseInt(modelId));
		}
		//panel.updateComboBox();
	}

	public boolean isHiding(String name) {
		if(name == null) return false;
		PropHuntPlayerData playerData = playersData.get(name);
		if(playerData == null) return false;

		return playerData.hiding;
	}

	public boolean isSeeker(){
		if(getSeekers(config.lobby()) == null) {
			if (config.lobby().equals(client.getLocalPlayer().getName())) {
				return true;
			}
			else return false;
		}
		for (String element : seekerList) {
			if (element != null && element.contains(client.getLocalPlayer().getName())) {
				return true;
			}
		}
		return false;
	}

	
	public String[] getSeekers(String lobbyID){
		propHuntDataManager.fetchSeekers(lobbyID);
		return seekerList;
	}

	private void hideMinimapDots() {
		SpritePixels[] mapDots = client.getMapDots();

		if(mapDots == null) return;

		mapDots[DOT_PLAYER] = client.createSpritePixels(new int[0], 0, 0);
		mapDots[DOT_CLAN] = client.createSpritePixels(new int[0], 0, 0);
		mapDots[DOT_FRIEND] = client.createSpritePixels(new int[0], 0, 0);
		mapDots[DOT_FRIENDSCHAT] = client.createSpritePixels(new int[0], 0, 0);
		mapDots[DOT_TEAM] = client.createSpritePixels(new int[0], 0, 0);
	}

	private void storeOriginalDots()
	{
		SpritePixels[] originalDots = client.getMapDots();

		if (originalDots == null)
		{
			return;
		}

		originalDotSprites = Arrays.copyOf(originalDots, originalDots.length);
	}

	private void restoreOriginalDots()
	{
		SpritePixels[] mapDots = client.getMapDots();

		if (originalDotSprites == null || mapDots == null)
		{
			return;
		}

		System.arraycopy(originalDotSprites, 0, mapDots, 0, mapDots.length);
	}

	@Schedule(
			period = SECONDS_BETWEEN_GET,
			unit = ChronoUnit.SECONDS,
			asynchronous = true
	)
	public void getPlayerConfigs() {
		if(players.length < 1 || config.players().isEmpty()) return;

		propHuntDataManager.getPropHuntersByUsernames(players);
	}

    public String[] getPlayerNames() {
		return players;
	}

	public int getMin() {
		return config.randMinID();
	}

	public int getMax() {
		return config.randMaxID();
	}

	public int getModelId() {
		return config.modelID();
	}

	public boolean getHideMode() {
		return config.hideMode();
	}

	private void setPlayersFromString(String playersString) {
		String[] p = playersString.split("[,\\n]");

		for(int i=0;i<p.length;i++) {
			p[i] = p[i].trim();
		}

		players = p;
	}

	public void setHideMode(boolean hideMode) {
		configManager.setConfiguration(CONFIG_KEY, "hideMode", hideMode);

		if (hideMode) {
			clientThread.invokeLater(() -> transmogPlayer(client.getLocalPlayer()));
		} else {
			clientThread.invokeLater(this::removeLocalTransmog);
		}
	}

	public void setRandomModelID() {
		long currentTime = System.currentTimeMillis();
		if (currentTime - lastRandomModelUpdate < RANDOM_MODEL_UPDATE_INTERVAL) {
			return;
		}
		configManager.setConfiguration(CONFIG_KEY, "modelID", ThreadLocalRandom.current().nextInt(config.randMinID(), config.randMaxID() + 1));
		lastRandomModelUpdate = currentTime; // Update the timestamp
	}

	public void setModelID(PropHuntModelId modelData) {
		configManager.setConfiguration(CONFIG_KEY, "modelID", modelData.getId());
	}

	public void setMinModelID(int minModelID) {
		configManager.setConfiguration(CONFIG_KEY, "randMinID", minModelID);
	}

	public void setMaxModelID(int maxModelID) {
		configManager.setConfiguration(CONFIG_KEY, "randMaxID", maxModelID);
	}

	public void rotateModel(int dir) {
		if(localDisguise != null) {
			int orientation = config.orientation() + 500*dir;
			orientation = (((orientation % 2000) + 2000) % 2000);
			localDisguise.setOrientation(orientation);
			configManager.setConfiguration(CONFIG_KEY, "orientation", orientation);
		}
	}

	@Provides
	PropHuntConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PropHuntConfig.class);
	}

}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.idyl.prophunt;

import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.geometry.SimplePolygon;
import net.runelite.api.model.Jarvis;

import java.util.ArrayList;
import java.util.List;

import static net.runelite.api.Perspective.*;

public class RLUtils {
    /**
     * The following code is from the Runelite API Perspective class
     */
    private static void modelToCanvasCpu(Client client, int end, int x3dCenter, int y3dCenter, int z3dCenter, int rotate, int[] x3d, int[] y3d, int[] z3d, int[] x2d, int[] y2d) {
        final int
                cameraPitch = client.getCameraPitch(),
                cameraYaw = client.getCameraYaw(),

                pitchSin = SINE[cameraPitch],
                pitchCos = COSINE[cameraPitch],
                yawSin = SINE[cameraYaw],
                yawCos = COSINE[cameraYaw],
                rotateSin = SINE[rotate],
                rotateCos = COSINE[rotate],

                cx = x3dCenter - client.getCameraX(),
                cy = y3dCenter - client.getCameraY(),
                cz = z3dCenter - client.getCameraZ(),

                viewportXMiddle = client.getViewportWidth() / 2,
                viewportYMiddle = client.getViewportHeight() / 2,
                viewportXOffset = client.getViewportXOffset(),
                viewportYOffset = client.getViewportYOffset(),

                zoom3d = client.getScale();

        for (int i = 0; i < end; i++) {
            int x = x3d[i];
            int y = y3d[i];
            int z = z3d[i];

            if (rotate != 0) {
                int x0 = x;
                x = x0 * rotateCos + y * rotateSin >> 16;
                y = y * rotateCos - x0 * rotateSin >> 16;
            }

            x += cx;
            y += cy;
            z += cz;

            final int
                    x1 = x * yawCos + y * yawSin >> 16,
                    y1 = y * yawCos - x * yawSin >> 16,
                    y2 = z * pitchCos - y1 * pitchSin >> 16,
                    z1 = y1 * pitchCos + z * pitchSin >> 16;

            int viewX, viewY;

            if (z1 < 50) {
                viewX = Integer.MIN_VALUE;
                viewY = Integer.MIN_VALUE;
            } else {
                viewX = (viewportXMiddle + x1 * zoom3d / z1) + viewportXOffset;
                viewY = (viewportYMiddle + y2 * zoom3d / z1) + viewportYOffset;
            }

            x2d[i] = viewX;
            y2d[i] = viewY;
        }
    }

    public static SimplePolygon calculateAABB(Client client, Model m, int jauOrient, int x, int y, int z, int padding) {
        // Get the AABB of the model
        AABB aabb = m.getAABB(jauOrient);

        int x1 = aabb.getCenterX();
        int y1 = aabb.getCenterZ();
        int z1 = aabb.getCenterY();

        int ex = aabb.getExtremeX();
        int ey = aabb.getExtremeZ();
        int ez = aabb.getExtremeY();

        // Calculate the AABB boundaries
        int x2 = x1 + ex;
        int y2 = y1 + ey;
        int z2 = z1 + ez;

        x1 -= ex;
        y1 -= ey;
        z1 -= ez;

        // Expand the bounding box by the padding value
        x1 -= padding;
        y1 -= padding;
        z1 -= padding;

        x2 += padding;
        y2 += padding;
        z2 += padding;

        // Create the 8 corner points of the expanded bounding box
        int[] xa = new int[]{
                x1, x2, x1, x2,
                x1, x2, x1, x2
        };
        int[] ya = new int[]{
                y1, y1, y2, y2,
                y1, y1, y2, y2
        };
        int[] za = new int[]{
                z1, z1, z1, z1,
                z2, z2, z2, z2
        };

        // Convert these 3D coordinates to 2D canvas coordinates
        int[] x2d = new int[8];
        int[] y2d = new int[8];

        modelToCanvasCpu(client, 8, x, y, z, 0, xa, ya, za, x2d, y2d);

        // Return the convex hull (the 2D projection of the expanded AABB)
        return Jarvis.convexHull(x2d, y2d);
    }
}


package com.idyl.prophunt;

import net.runelite.api.Client;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import javax.inject.Inject;

@ConfigGroup("prophunt")
public interface PropHuntConfig extends Config {
	@ConfigSection(
			name = "Lobby Setup",
			description = "Setup for the game instance.",
			position = 0
	)
	String setupSettings = "setupSettings";

	@ConfigSection(
			name = "Seeker Settings",
			description = "Settings relating to seeking (non-hider).",
			position = 1
	)
	String seekerSettings = "seekerSettings";


	@ConfigSection(
			name = "Additional Seekers",
			description = "Add More Seekers.",
			closedByDefault = true,
			position = 2
	)
	String additionalSettings = "additionalSettings";

	@ConfigSection(
			name = "Advanced Settings",
			description = "Advanced settings.",
			closedByDefault = true,
			position = 3
	)
	String advancedSettings = "advancedSettings";

	@ConfigItem(
			keyName = "lobby",
			name = "Lobby ID (RSN of host)",
			description = "Copy another user's player list (using their RSN)",
			position = 0,
			section = setupSettings,
			secret = true
	)
	default String lobby() {
		return "";
	}

	@ConfigItem(
			keyName = "players",
			name = "Player Names",
			description = "Names of the players you are playing with (comma separated & CaseSensitive)",
			position = 1,
			section = setupSettings
	)
	default String players() {
		return "";
	}

	@ConfigItem(
			name = "players_hidden",
			description = "Used for storing players read from API.",
			keyName = "players_hidden",
			hidden = true
	)
	default String playersHidden() {
		return "";
	}

	@ConfigItem(
			keyName = "playerList",
			name = "On-Screen Player List",
			description = "Display player list in overlay.",
			section = setupSettings,
			position = 2
	)
	default boolean playerList() { return true; }

	@ConfigItem(
			keyName = "hideMinimapDots",
			name = "Hide Minimap Dots",
			description = "Toggle whether minimap dots are hidden. (Recommended for seekers)",
			position = 3,
			section = seekerSettings
	)
	default boolean hideMinimapDots() {
		return false;
	}

	@ConfigItem(
			keyName = "depriorizteMenuOptions",
			name = "Deprioritize Menu Options",
			description = "Forces 'Walk Here' to the top of every menu to better hide props. (Recommended for seekers)",
			position = 5,
			section = seekerSettings
	)
	default boolean depriorizteMenuOptions() {
		return false;
	}

	@ConfigItem(
			keyName = "limitRightClicks",
			name = "Limit Right Clicks",
			description = "Limit the number of right clicks a seeker can do. (Guesses they may take)",
			position = 6,
			section = seekerSettings
	)
	default boolean limitRightClicks() {
		return false;
	}

	@ConfigItem(
			keyName = "maxRightClicks",
			name = "Maximum Right Clicks",
			description = "The number of guesses a seeker can make.",
			position = 7,
			section = seekerSettings
	)
	default int maxRightClicks() {
		return 10;
	}

	@ConfigItem(
			keyName = "sound",
			name = "Sound",
			description = "Play a sound when you find a hider.",
			position = 0,
			section = advancedSettings
	)
	default boolean sound() {
		return false;
	}

	@ConfigItem(
			keyName = "alternate",
			name = "Use alternate API server",
			description = "Toggle use of alternate api server. (ADVANCED)",
			position = 1,
			section = advancedSettings
	)
	default boolean alternate() {
		return false;
	}

	@ConfigItem(
			keyName = "apiURL",
			name = "Alternate API URL",
			description = "URL to alternate API server. (ADVANCED)",
			position = 2,
			section = advancedSettings
	)
	default String apiURL() {
		return "";
	}

	@ConfigItem(
			keyName = "seekers",
			name = "Player Names",
			description = "Names of the players you are seeking with (comma separated & CaseSensitive)",
			position = 1,
			section = additionalSettings
	)
	default String seekers() {
		return "";
	}

	/**
	 * NOT IN USE
	 **/
	@ConfigItem(
			keyName = "models",
			name = "Custom Model List",
			description = "Models that you want to play with (formatted: name: id, ...)",
			position = 2,
			hidden = true,
			section = setupSettings
	)
	default String models() {
		return "Bush: 1565, Crate: 12125, Rock Pile: 1391";
	}

	/** HIDDEN **/
	@ConfigItem(
			keyName = "modelID",
			name = "Model ID",
			description = "The ID of the model you'd like to become.",
			position = 8,
			hidden = true
	)
	default int modelID() {
		return 1565;
	}

	@ConfigItem(
			keyName = "randMinID",
			name = "Min Random Model ID",
			description = "The minimum randomised ID of the model you'd like to become",
			position = 9,
			hidden = true,
			section = setupSettings
	)
	default int randMinID() {
		return 1078;
	}

	@ConfigItem(
			keyName = "randMaxID",
			name = "Max Random Model ID",
			description = "The maximum randomised ID of the model you'd like to become",
			position = 10,
			hidden = true,
			section = setupSettings
	)
	default int randMaxID() {
		return 1724;
	}

	@ConfigItem(
			keyName = "orientation",
			name = "Orientation",
			description = "orientation",
			hidden = true
	)
	default int orientation() {
		return 0;
	}

	@ConfigItem(
			keyName = "hideMode",
			name = "Hide Mode",
			description = "Toggle whether you are currently hiding or not.",
			hidden = true
	)
	default boolean hideMode() {
		return false;
	}

}


package com.idyl.prophunt;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.components.LineComponent;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY;

public class PropHuntOverlay extends OverlayPanel {
    public static OverlayMenuEntry RESET_ENTRY = new OverlayMenuEntry(RUNELITE_OVERLAY, "Reset", "Counter");

    private PropHuntPlugin plugin;
    private PropHuntConfig config;

    @Inject
    private PropHuntOverlay(PropHuntPlugin plugin, PropHuntConfig config) {
        this.plugin = plugin;
        this.config = config;
        getMenuEntries().add(RESET_ENTRY);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
        setPosition(OverlayPosition.BOTTOM_LEFT);

        setClearChildren(false);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        String[] playerNames = plugin.getPlayerNames();

        if (playerNames != null && playerNames.length > 0) {

            int boxWidth = 200;
            int boxHeight = 20 * playerNames.length + 40;
            int yPosition = getBoxYPosition() - boxHeight - 5;
            int textYPosition = yPosition + 10;
            String title = "ACTIVE HIDERS";
            List<String> activeHiders = new ArrayList<>();

            for (String playerName : playerNames) {
                if (playerName != null){
                    if (!playerName.trim().isEmpty() && plugin.isHiding(playerName)) {
                        activeHiders.add(playerName);
                    }
                }
            }

            panelComponent.getChildren().removeIf(component -> component instanceof LineComponent);
            if(activeHiders.isEmpty()){
                title = "NO ACTIVE HIDERS";
            }
            if (config.playerList()){
                LineComponent playerTitleLine = LineComponent.builder()
                        .left(title)
                        .leftColor(Color.YELLOW)
                        .leftFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD))
                        .build();
                playerTitleLine.setPreferredLocation(new Point(10, textYPosition));
                panelComponent.getChildren().add(playerTitleLine);
                textYPosition += 20;

                for (String playerName : activeHiders) {
                    if (playerName != null) {
                        LineComponent playerNameLine = LineComponent.builder()
                                .left(playerName.trim())
                                .leftColor(Color.WHITE)
                                .build();

                        playerNameLine.setPreferredLocation(new Point(10, textYPosition));
                        panelComponent.getChildren().add(playerNameLine);

                        textYPosition += 20;
                    }
                }
                if(config.limitRightClicks()) {
                    LineComponent sepLine = LineComponent.builder()
                            .left("\n")
                            .leftColor(Color.YELLOW)
                            .build();

                    sepLine.setPreferredLocation(new Point(10, textYPosition));
                    panelComponent.getChildren().add(sepLine);
                    textYPosition += 60;
                    sepLine.setPreferredLocation(new Point(10, textYPosition));
                    panelComponent.getChildren().add(sepLine);
                    textYPosition += 60;
                }
            }
            if(config.limitRightClicks()) {
                graphics.setFont(FontManager.getRunescapeFont());
                LineComponent rightClicksRemainingComponent = LineComponent.builder()
                        .left("GUESSES LEFT")
                        .leftColor(Color.WHITE)
                        .leftFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD))
                        .right("" + getClicksRemaining() + "")
                        .rightColor(getColor())
                        .build();
                rightClicksRemainingComponent.setPreferredLocation(new Point(10, textYPosition));
                panelComponent.getChildren().add(rightClicksRemainingComponent);
            }
        }
        return super.render(graphics);
    }

    private int getBoxYPosition() {
        return 0;
    }

    private Color getColor() {
        return getClicksRemaining() > 3 ? Color.GREEN : getClicksRemaining() > 0 ? Color.YELLOW : Color.RED;
    }

    private int getClicksRemaining() {
        return config.maxRightClicks() - plugin.getRightClickCounter();
    }
}

package com.idyl.prophunt;

import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class PropHuntPanel extends PluginPanel implements ActionListener {
    private PropHuntPlugin plugin;

    private JButton myButton;
    private JToggleButton hideModeToggleButton;
    private JTextField modelIdTextField;

    public PropHuntPanel(PropHuntPlugin plugin) {
        this.plugin = plugin;

        // Set layout of the overall panel to BorderLayout
        setLayout(new BorderLayout());

        // Add padding to the top of the whole panel
        setBorder(BorderFactory.createEmptyBorder(40, 0, 0, 0));

        // Create a container panel for the title with padding
        JPanel titlePanel = new JPanel();
        titlePanel.setLayout(new BorderLayout());

        // Title label outside the bordered panel
        JLabel title = new JLabel("Prop Hunt", SwingConstants.CENTER);
        title.setFont(FontManager.getRunescapeBoldFont().deriveFont(30f));
        title.setForeground(Color.YELLOW);

        // Add the title label to the title panel
        titlePanel.add(title, BorderLayout.CENTER);

        // Add padding to the bottom of the title by setting an EmptyBorder on the title panel
        titlePanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));

        // Add the titlePanel (with padding) to the top of the main panel
        add(titlePanel, BorderLayout.NORTH);

        // Create subtitle section below the title
        JPanel subtitlePanel = new JPanel();
        JLabel subtitle = new JLabel("Hider Settings:");
        subtitle.setFont(FontManager.getRunescapeBoldFont().deriveFont(20f));
        subtitle.setHorizontalAlignment(SwingConstants.CENTER);
        subtitlePanel.add(subtitle);

        // Add padding to the subtitle
        subtitlePanel.setBorder(BorderFactory.createEmptyBorder(0, 0, 20, 0));

        // Add the subtitlePanel right below the title section
        add(subtitlePanel, BorderLayout.CENTER);

        // Create the "Model ID" section panel with components
        JPanel modelPanel = createModelPanel();

        // Create the "Orientation" section panel with components
        JPanel orientationPanel = createOrientationPanel();

        // Create the "Hide Mode" section panel with the toggle button
        JPanel hideModePanel = createHideModePanel();

        // Add all sections to the main panel
        JPanel contentPanel = new JPanel();
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.add(modelPanel);
        contentPanel.add(orientationPanel);
        contentPanel.add(hideModePanel);

        add(contentPanel, BorderLayout.SOUTH);
    }

    private JPanel createModelPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        panel.setToolTipText("Set your Model ID.");
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder("Model"),
                BorderFactory.createEmptyBorder(2, 0, 7, 0)
        ));
        GridBagConstraints gbc = new GridBagConstraints();

        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(5, 0, 5, 0);
        JLabel modelIdLabel = new JLabel("Model ID");
        panel.add(modelIdLabel, gbc);

        modelIdTextField = new JTextField(10);
        modelIdTextField.setText(String.valueOf(plugin.getModelId()));
        ((AbstractDocument) modelIdTextField.getDocument()).setDocumentFilter(new NumericDocumentFilter());
        modelIdTextField.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                updateModelId();
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                updateModelId();
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                updateModelId();
            }

            private void updateModelId() {
                try {
                    int modelId = Integer.parseInt(modelIdTextField.getText());
                    plugin.setModelID(new PropHuntModelId("", modelId));
                } catch (NumberFormatException ex) {
                    modelIdTextField.setText("");
                }
            }
        });
        gbc.gridx = 1;
        panel.add(modelIdTextField, gbc);

        JPanel randomPanel = new JPanel();
        randomPanel.setLayout(new GridBagLayout());
        randomPanel.setToolTipText("Set the range of the model IDs you would like to randomize from.");
        randomPanel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder("Randomizer"),
                BorderFactory.createEmptyBorder(2, 30, 7, 30)
        ));

        // Add min ID label and field
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.insets = new Insets(5, 0, 5, 0);
        JLabel minLabel = new JLabel("Min ID");
        randomPanel.add(minLabel, gbc);

        gbc.gridx = 1;
        gbc.gridy = 0;
        gbc.insets = new Insets(5, 0, 5, 0);
        JTextField minField = new JTextField(Integer.toString(plugin.getMin()), 4);
        ((AbstractDocument) minField.getDocument()).setDocumentFilter(new NumericDocumentFilter());
        minField.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                updateMinField();
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                updateMinField();
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                updateMinField();
            }

            private void updateMinField() {
                try {
                    int minValue = Integer.parseInt(minField.getText());
                    plugin.setMinModelID(minValue);
                } catch (NumberFormatException ex) {
                    minField.setText("0");
                }
            }
        });
        randomPanel.add(minField, gbc);

        // Add max ID label and field
        gbc.gridx = 0;
        gbc.gridy = 1;
        JLabel maxLabel = new JLabel("Max ID");
        randomPanel.add(maxLabel, gbc);

        gbc.gridx = 1;
        gbc.gridy = 1;
        JTextField maxField = new JTextField(Integer.toString(plugin.getMax()), 4);
        ((AbstractDocument) maxField.getDocument()).setDocumentFilter(new NumericDocumentFilter());
        maxField.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                updateMaxField();
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                updateMaxField();
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                updateMaxField();
            }

            private void updateMaxField() {
                try {
                    int maxValue = Integer.parseInt(maxField.getText());
                    plugin.setMaxModelID(maxValue);
                } catch (NumberFormatException ex) {
                    maxField.setText("0");
                }
            }
        });
        randomPanel.add(maxField, gbc);

        // Add randomize button inside the randomPanel
        gbc.gridx = 0;
        gbc.gridy = 2;
        gbc.gridwidth = 2;  // Make the button span both columns
        gbc.insets = new Insets(10, 0, 10, 0);
        myButton = new JButton("Randomize Model");
        myButton.addActionListener(this);
        randomPanel.add(myButton, gbc);

        // Add the randomPanel to the main panel
        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.gridwidth = 2;  // Make this panel span across both columns of the grid
        gbc.insets = new Insets(10, 0, 10, 0);
        panel.add(randomPanel, gbc);

        return panel;
    }


    private JPanel createOrientationPanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        panel.setToolTipText("Rotate model orientation.");
        panel.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createTitledBorder("Orientation"),  // Original titled border
                BorderFactory.createEmptyBorder(2, 0, 7, 0)  // 10px top padding, 0 for left, right, and bottom
        ));
        GridBagConstraints gbc = new GridBagConstraints();

        // Rotate clockwise button
        gbc.gridx = 0;
        gbc.gridy = 0;
        JButton rotateClockwiseButton = new JButton("↻");
        rotateClockwiseButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                plugin.rotateModel(1);
            }
        });
        panel.add(rotateClockwiseButton, gbc);

        // Rotate label
        gbc.gridx = 1;
        gbc.gridy = 0;
        JLabel rotateLabel = new JLabel("Rotate");
        panel.add(rotateLabel, gbc);

        // Rotate counter-clockwise button
        gbc.gridx = 2;
        gbc.gridy = 0;
        JButton rotateCounterButton = new JButton("↺");
        rotateCounterButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                plugin.rotateModel(-1);
            }
        });
        panel.add(rotateCounterButton, gbc);

        return panel;
    }

    public JPanel createHideModePanel() {
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        panel.setBorder(BorderFactory.createEmptyBorder(10, 0, 10, 0)); // No label, just padding

        hideModeToggleButton = new JToggleButton();
        hideModeToggleButton.setSelected(plugin.getHideMode());
        if(plugin.getHideMode()) {
            hideModeToggleButton.setText("Hide Mode: ON");
        }
        else {
            hideModeToggleButton.setText("Hide Mode: OFF");
        }
        hideModeToggleButton.addActionListener(e -> toggleHideMode());
        hideModeToggleButton.setFont(FontManager.getRunescapeBoldFont());

        hideModeToggleButton.setBackground(Color.DARK_GRAY);
        hideModeToggleButton.setForeground(hideModeToggleButton.isSelected() ? Color.GREEN : Color.RED);

        hideModeToggleButton.addChangeListener(e -> {
            if (hideModeToggleButton.isSelected()) {
                hideModeToggleButton.setForeground(Color.WHITE);
                hideModeToggleButton.setText("Hide Mode: ON");
            } else {
                hideModeToggleButton.setForeground(Color.RED);
                hideModeToggleButton.setText("Hide Mode: OFF");
            }
        });

        panel.add(hideModeToggleButton, new GridBagConstraints());

        return panel;
    }

    public void updatePanelWithDefaults() {
        PropHuntConfig config = plugin.getConfig();
        hideModeToggleButton.setSelected(config.hideMode());
        hideModeToggleButton.setText(config.hideMode() ? "Hide Mode: ON" : "Hide Mode: OFF");
        hideModeToggleButton.setForeground(config.hideMode() ? Color.GREEN : Color.RED);
    }

    private void updateHideModeButtonText(JToggleButton button, boolean isHideModeOn) {
        if (isHideModeOn) {
            button.setText("Hide Mode: ON");
            button.setForeground(Color.GREEN);
        } else {
            button.setText("Hide Mode: OFF");
            button.setForeground(Color.RED);
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        plugin.setRandomModelID();
        int newModelID = plugin.getModelId();
        modelIdTextField.setText(String.valueOf(newModelID));
        plugin.setModelID(new PropHuntModelId("", newModelID));
    }

    private void toggleHideMode() {
        boolean currentHideMode = hideModeToggleButton.isSelected();
        plugin.setHideMode(currentHideMode);
    }

    static class NumericDocumentFilter extends javax.swing.text.DocumentFilter {
        @Override
        public void insertString(FilterBypass fb, int offset, String string, javax.swing.text.AttributeSet attr)
                throws javax.swing.text.BadLocationException {
            if (string.matches("[0-9]")) {
                super.insertString(fb, offset, string, attr);
            }
        }

        @Override
        public void replace(FilterBypass fb, int offset, int length, String text, javax.swing.text.AttributeSet attrs)
                throws javax.swing.text.BadLocationException {
            if (text.matches("[0-9]*")) {
                super.replace(fb, offset, length, text, attrs);
            }
        }
    }
}

package com.idyl.prophunt;

import lombok.Getter;

import java.util.LinkedHashMap;

public class PropHuntModelId {
    public static LinkedHashMap<String, PropHuntModelId> map = new LinkedHashMap<>();

    @Getter
    private int id;
    @Getter
    private String name;

    public PropHuntModelId(String name, int id) {
        this.id = id;
        this.name = name;
    }

    public static PropHuntModelId valueOf(String name) {
        PropHuntModelId model = map.get(name);
        if (model == null) {
            throw new IllegalArgumentException("No model by the name " + name + " found");
        }
        return model;
    }

    public static void add(String name, int modelID) {
        map.put(name, new PropHuntModelId(name, modelID));
    }
}

package com.idyl.prophunt;

public class PropHuntPlayerData {
    public int modelID;
    public String username;
    public boolean hiding;
    public int orientation;

    public PropHuntPlayerData(String username, boolean hiding, int modelID, int orientation) {
        this.username = username;
        this.hiding = hiding;
        this.modelID = modelID;
        this.orientation = orientation;
    }

    @Override
    public String toString() {
        return "username: "+username+", hiding: "+hiding+", modelID: "+ modelID + ", orientation: "+orientation;
    }
}

package com.idyl.prophunt;

import com.google.gson.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import java.io.IOException;
import java.util.*;


@Slf4j
@Singleton
public class PropHuntDataManager {
    @Getter
    public String DEFAULT_URL = "http://3.133.56.193";

    @Getter
    private String app1Url = DEFAULT_URL + ":8080";

    @Getter
    private String app2Url = DEFAULT_URL + ":5000";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

    @Inject
    private PropHuntPlugin plugin;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private Gson gson;

    public void setApp1Url(String url){
        this.app1Url = url;
        log.debug("Setting app1 url: " + app1Url);
    }

    public void setApp2Url(String url){
        this.app2Url = url;
        log.debug("Setting app2 url: " + app2Url);
    }

    protected void updatePropHuntApi(PropHuntPlayerData data)
    {
        String username = urlifyString(data.username);
        String url = app1Url.concat("/prop-hunters/"+username);

        try
        {
            Request r = new Request.Builder()
                    .url(url)
                    .post(RequestBody.create(JSON, gson.toJson(data)))
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback()
            {
                @Override
                public void onFailure(Call call, IOException e)
                {
                    log.debug("Error sending post data", e);
                }

                @Override
                public void onResponse(Call call, Response response)
                {
                    if (response.isSuccessful())
                    {
                        log.debug("Successfully sent prop hunt data");
                        response.close();
                    }
                    else
                    {
                        log.debug("Post request unsuccessful");
                        response.close();
                    }
                }
            });
        }
        catch (IllegalArgumentException e)
        {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    public void getPropHuntersByUsernames(String[] players) {
        String playersString = urlifyString(String.join(",", players));
        try {
            Request r = new Request.Builder()
                    .url(app1Url.concat("/prop-hunters/".concat(playersString)))
                    .get()
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    log.info("Error getting prop hunt data by username", e);
                }

                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        try {
                            JsonArray j = gson.fromJson(response.body().string(), JsonArray.class);
                            HashMap<String, PropHuntPlayerData> playerData = parsePropHuntData(j);
                            plugin.updatePlayerData(playerData);
                        } catch (IOException | NullPointerException | JsonSyntaxException e) {
                            log.error(e.getMessage());
                        }
                    }

                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    private HashMap<String, PropHuntPlayerData> parsePropHuntData(JsonArray j) {
        HashMap<String, PropHuntPlayerData> l = new HashMap<>();

        for (JsonElement jsonElement : j)
        {
            if (!jsonElement.isJsonObject()) {
                continue;
            }

            JsonObject jObj = jsonElement.getAsJsonObject();

            if (jObj.get("username") == null || jObj.get("username").isJsonNull()) {
                continue;
            }

            String username = jObj.get("username").getAsString();

            Boolean hiding = jObj.has("hiding") ? jObj.get("hiding").getAsBoolean() : null;
            Integer modelID = jObj.has("modelID") ? (jObj.get("modelID").isJsonNull() ? null : jObj.get("modelID").getAsInt()) : null;
            Integer orientation = jObj.has("orientation") ? (jObj.get("orientation").isJsonNull() ? null : jObj.get("orientation").getAsInt()) : null;

            if (hiding == null || modelID == null || orientation == null) {
                continue;
            }

            PropHuntPlayerData d = new PropHuntPlayerData(username, hiding, modelID, orientation);
            l.put(username, d);
        }

        return l;
    }

    public void createLobby(String user, String data) {
        String username = urlifyString(user);
        String url = app2Url.concat("/lobbies/" + username);

        List<String> playerList;
        if (data != null && !data.trim().isEmpty()) {
            playerList = Arrays.asList(data.trim().split(","));
        } else {
            playerList = Arrays.asList(data);
        }

        try {
            Request r = new Request.Builder()
                    .url(url)
                    .post(RequestBody.create(JSON, gson.toJson(playerList)))
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    log.debug("Error sending post data", e);
                }

                @Override
                public void onResponse(Call call, Response response) {
                    if (response.isSuccessful()) {
                        log.debug("Successfully sent prop hunt data");
                        response.close();
                    } else {
                        log.debug("Post request unsuccessful");
                        response.close();
                    }
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    public void fetchPlayers(String lobby_id){
        if (lobby_id == null || lobby_id.isEmpty()) {
            plugin.updatePlayerList(null);
            lobby_id = "";
        }
        try {
            Request r = new Request.Builder()
                    .url(app2Url.concat("/lobbies/".concat(urlifyString(lobby_id))))
                    .get()
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    log.info("Error getting lobby by lobby ID.", e);
                }

                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        try {
                            JsonArray j = gson.fromJson(response.body().string(), JsonArray.class);
                            String[] playerList = new String[j.size()];
                            for (int i = 0; i < j.size(); i++){
                                JsonElement element = j.get(i);
                                if (element != null) {
                                    playerList[i] = element.getAsString();
                                }
                            }
                            plugin.updatePlayerList(playerList);
                        } catch (IOException | NullPointerException | JsonSyntaxException e) {
                            log.error(e.getMessage());
                        }
                    }

                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }

    }

    public void postSeekers(String user, String data) {
        String username = urlifyString(user);
        String url = app2Url.concat("/lobby_seekers/" + username);

        List<String> playerList;
        if (data != null && !data.trim().isEmpty()) {
            playerList = Arrays.asList(data.trim().split(","));
        } else {
            playerList = new ArrayList<>();
        }

        try {
            Request r = new Request.Builder()
                    .url(url)
                    .post(RequestBody.create(JSON, gson.toJson(playerList)))
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    log.debug("Error sending post data", e);
                }

                @Override
                public void onResponse(Call call, Response response) {
                    if (response.isSuccessful()) {
                        log.debug("Successfully sent prop hunt data");
                        response.close();
                    } else {
                        log.debug("Post request unsuccessful");
                        response.close();
                    }
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }
    }

    public void fetchSeekers(String lobby_id){
        if (lobby_id == null || lobby_id.isEmpty()) {
            plugin.updatePlayerList(null);
            lobby_id = "";
        }
        try {
            Request r = new Request.Builder()
                    .url(app2Url.concat("/lobby_seekers/".concat(urlifyString(lobby_id))))
                    .get()
                    .build();

            okHttpClient.newCall(r).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    log.info("Error getting lobby by lobby ID.", e);
                }

                @Override
                public void onResponse(Call call, Response response) throws IOException {
                    if (response.isSuccessful()) {
                        try {
                            JsonArray j = gson.fromJson(response.body().string(), JsonArray.class);
                            String[] playerList = new String[j.size()];
                            for (int i = 0; i < j.size(); i++){
                                JsonElement element = j.get(i);
                                if (element != null) {
                                    playerList[i] = element.getAsString();
                                }
                            }
                            plugin.updateSeekerList(playerList);
                        } catch (IOException | NullPointerException | JsonSyntaxException e) {
                            log.error(e.getMessage());
                        }
                    }

                    response.close();
                }
            });
        } catch (IllegalArgumentException e) {
            log.error("Bad URL given: " + e.getLocalizedMessage());
        }

    }

    private String urlifyString(String str) {
        return str.trim().replaceAll("\\s", "%20");
    }
}

package com.idyl.prophunt;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PropHuntPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PropHuntPlugin.class);
		RuneLite.main(args);
	}
}
