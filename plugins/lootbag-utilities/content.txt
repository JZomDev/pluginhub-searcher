package com.example.lootbagUtilities;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.*;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

import javax.inject.Inject;
import java.util.function.BooleanSupplier;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.Arrays;

@Slf4j
@PluginDescriptor(
        name = "LootbagUtilities"
)
public class LootbagUtilities extends Plugin {
    @Inject
	@SuppressWarnings("unused")
    private Client client;

    @Inject
	@SuppressWarnings("unused")
    private LootbagUtilitiesConfig config;

    // declarative way to remove destroy options on items
    DestroyableItem[] removeDestroyList;

    // Represents an item that can be destroyed and a function
    // to decide if the destroy option should be removed
    static final class DestroyableItem {
        // Whether to remove the destroy option on this item
        public BooleanSupplier removeDestroy;
        // The itemId of the item with a destroy option
        public int itemId;
        // The name of the item with a destroy option. Used only for logging
        public String itemName;

        DestroyableItem(BooleanSupplier removeDestroy, int itemId, String itemName) {
            super();
            this.removeDestroy = removeDestroy;
            this.itemId = itemId;
            this.itemName = itemName;
        }
    }

	static final int LOOTING_BAG_INTERFACE_ID = 5308421;

	private boolean isLootingBagInterfaceOpen() {
		return client.getWidget(LOOTING_BAG_INTERFACE_ID) != null;
	}

    // check varbits to determine if player is in wilderness
    // logs any unexpected varbit
    boolean getInWilderness() {
        int wilderness_varbit = client.getVarbitValue(Varbits.IN_WILDERNESS);
        if (wilderness_varbit == 1) {
            return true;
        } else if (wilderness_varbit == 0) {
            return false;
        } else {
            // This should not happen
            log.warn("Cannot determine if player is in wilderness. IN_WILDERNESS has value {}",
                    wilderness_varbit);
            return false;
        }
    }

    static Boolean removeLootingBagDestroy(LootbagUtilitiesConfig.LootingBagDestroySetting setting, boolean inWilderness) {
        if (setting == LootbagUtilitiesConfig.LootingBagDestroySetting.REMOVE) {
            return true;
        } else if (setting == LootbagUtilitiesConfig.LootingBagDestroySetting.ALLOW) {
            return false;
        } else if (setting == LootbagUtilitiesConfig.LootingBagDestroySetting.ALLOW_IN_WILDY) {
            return !inWilderness;
        } else {
            log.error("An enum was added to LootingBagDestroySetting and this if/else was not updated");
            assert(false);
            return true;
        }
    }

    static DestroyableItem[] genDestroyList(LootbagUtilitiesConfig config, BooleanSupplier getInWilderness) {
        return new DestroyableItem[]{
                new DestroyableItem(
                        () -> removeLootingBagDestroy(config.LootingBagDestroySetting(), getInWilderness.getAsBoolean()),
                        ItemID.LOOTING_BAG,
                        "Looting Bag"
                ),
                new DestroyableItem(
                        () -> removeLootingBagDestroy(config.LootingBagDestroySetting(), getInWilderness.getAsBoolean()),
                        ItemID.LOOTING_BAG_22586,
                        "Open Looting Bag"
                ),
                new DestroyableItem(config::RemoveRunePouchDestroy, ItemID.RUNE_POUCH, "Rune Pouch"),
                new DestroyableItem(config::RemoveRunePouchDestroy, ItemID.RUNE_POUCH_23650, "Rune Pouch"),
                new DestroyableItem(config::RemoveRunePouchDestroy, ItemID.RUNE_POUCH_L, "Rune Pouch(l)"),
                new DestroyableItem(config::RemoveRunePouchDestroy, ItemID.DIVINE_RUNE_POUCH, "Divine Rune Pouch"),
                new DestroyableItem(config::RemoveRunePouchDestroy, ItemID.DIVINE_RUNE_POUCH_L, "Divine Rune Pouch(l)"),
                new DestroyableItem(config::RemoveSeedBoxDestroy, ItemID.SEED_BOX, "Seed Box"),
                new DestroyableItem(config::RemoveSeedBoxDestroy, ItemID.OPEN_SEED_BOX, "Open Seed Box"),
                new DestroyableItem(config::RemoveBoltPouchDestroy, ItemID.BOLT_POUCH, "Bolt Pouch"),
                new DestroyableItem(config::RemoveHerbSackDestroy, ItemID.HERB_SACK, "Herb Sack"),
                new DestroyableItem(config::RemoveHerbSackDestroy, ItemID.OPEN_HERB_SACK, "Herb Sack"),
                new DestroyableItem(config::RemoveCoalBagDestroy, ItemID.COAL_BAG, "Coal Bag"),
                new DestroyableItem(config::RemoveCoalBagDestroy, ItemID.OPEN_COAL_BAG, "Open Coal Bag"),
                new DestroyableItem(config::RemoveCoalBagDestroy, ItemID.COAL_BAG_12019, "Alt Coal Bag"),
                new DestroyableItem(config::RemoveCoalBagDestroy, ItemID.COAL_BAG_25627, "Alt Coal Bag"),
                new DestroyableItem(config::RemoveFishBarrelDestroy, ItemID.FISH_BARREL, "Fish Barrel"),
                new DestroyableItem(config::RemoveFishBarrelDestroy, ItemID.FISH_SACK_BARREL, "Fish Sack Barrel"),
                new DestroyableItem(config::RemoveFishBarrelDestroy, ItemID.OPEN_FISH_BARREL, "Open Fish Barrel"),
                new DestroyableItem(config::RemoveFishBarrelDestroy, ItemID.OPEN_FISH_SACK_BARREL, "Open Fish Sack Barrel"),
                new DestroyableItem(config::RemoveGemBagDestroy, ItemID.GEM_BAG, "Gem Bag"),
                new DestroyableItem(config::RemoveGemBagDestroy, ItemID.GEM_BAG_12020, "Alt Gem Bag"),
                new DestroyableItem(config::RemoveGemBagDestroy, ItemID.GEM_BAG_25628, "Alt Gem Bag"),
                new DestroyableItem(config::RemoveGemBagDestroy, ItemID.OPEN_GEM_BAG, "Open Gem Bag"),
                new DestroyableItem(config::RemoveTackleBoxDestroy, ItemID.TACKLE_BOX, "Tackle Box"),
				new DestroyableItem(config::RemoveForestryDestroy, ItemID.OPEN_FORESTRY_BASKET, "Open Forestry Basket"),
				new DestroyableItem(config::RemoveForestryDestroy, ItemID.FORESTRY_BASKET, "Forestry Basket"),
				new DestroyableItem(config::RemoveForestryDestroy, ItemID.FORESTRY_KIT, "Forestry Kit"),
				new DestroyableItem(config::RemoveForestryDestroy, ItemID.LOG_BASKET, "Log Basket"),
				new DestroyableItem(config::RemoveForestryDestroy, ItemID.OPEN_LOG_BASKET, "Open Log Basket"),
        };
    }

    @Override
    protected void startUp() {
        removeDestroyList = genDestroyList(config, this::getInWilderness);
    }

    @Override
    protected void shutDown() {
    }

    static boolean isLootingBag(int itemId) {

        return
                itemId == ItemID.LOOTING_BAG // Closed looting bag
                        || itemId == ItemID.LOOTING_BAG_22586; //Opened looting bag
    }

    //swap open with use on looting bag
    //mutates in place
    static void doInventorySwaps(MenuEntry[] entries) {
        //can't swap 1 or fewer things
        if (entries.length < 2) {
            return;
        }

        //index of the option at the top of the list/left click option
        int firstIdx = entries.length-1;
        int useIdx = -1;
        for (int i = 0; i < entries.length; i++) {
            MenuEntry entry = entries[i];
            Widget widget = entry.getWidget();
            //right click options of a looting bag
            if (widget!=null && isLootingBag(widget.getItemId())) {
                if (entry.getOption().equals("Use")) {
                    useIdx = i;
                }
            }
        }
        if (useIdx != -1) {
            MenuEntry tmp = entries[firstIdx];
            entries[firstIdx] = entries[useIdx];
            entries[useIdx] = tmp;
        }
    }

    static<T> void swap(T[] array, int first, int second) {
        T tmp = array[first];
        array[first] = array[second];
        array[second] = tmp;
    }

    // do MenuEntry swaps on options in the check/deposit interface of the looting bag
    static void doLootingBagSwaps(MenuEntry[] entries) {
        if (entries.length < 2) {
            return;
        }
        int firstIdx = entries.length-1;
        int depositAllIdx = -1;
        for (int i = 0; i< entries.length; i++) {
            MenuEntry entry = entries[i];
            if (entry.getOption().equals("Store-All")) {
                depositAllIdx = i;
                break;
            }
        }
        //swap option and move other options forward
        if (depositAllIdx != -1) {
            swap(entries, firstIdx, depositAllIdx);
            for(int i=depositAllIdx; i<firstIdx-1; i++) {
                swap(entries, i, i+1);
            }
        }
    }

    @Subscribe
	@SuppressWarnings("unused")
    public void onClientTick(ClientTick clientTick) {
        // don't swap if menu is open, otherwise items repeatedly swap back and forth
        if (client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen()) {
            return;
        }

        MenuEntry[] entries = client.getMenuEntries();

        if (config.leftClickUseLootingBag()) {
            doInventorySwaps(entries);
        }
        if ((config.LootingBagStoreAll() == LootbagUtilitiesConfig.LootingBagStoreAll.LEFT_CLICK ||
                config.LootingBagStoreAll() == LootbagUtilitiesConfig.LootingBagStoreAll.SHIFT_CLICK && client.isKeyPressed(KeyCode.KC_SHIFT))
                && isLootingBagInterfaceOpen()) {
            doLootingBagSwaps(entries);
        }
        client.setMenuEntries(entries);
    }

    // Does all processing related to removing "destroy" MenuEntries.
    // this method is static and takes arguments to make testing easier,
    static MenuEntry[] removeDestroy(MenuEntry[] entries, DestroyableItem[] removeDestroyList) {
        // Remove destroy options on various items
        Stream<MenuEntry> entryStream = Arrays.stream(entries);
        for (DestroyableItem r : removeDestroyList) {
            Predicate<MenuEntry> p = (MenuEntry entry) -> {
                if (entry.getItemId() == r.itemId) {
                    log.debug("Removing destroy option on {}", r.itemName);
                    return true;
                } else {
                    return false;
                }
            };
            if (r.removeDestroy.getAsBoolean()) {
                entryStream = entryStream.filter(
                        (MenuEntry entry) -> !entry.getOption().equals("Destroy") || !p.test(entry)
                );
            }
        }
        return entryStream.toArray(MenuEntry[]::new);
    }

    @Subscribe
	@SuppressWarnings("unused")
    public void onMenuOpened(MenuOpened _unused) {
        MenuEntry[] entries = client.getMenuEntries();
        // Remove destroy options on various items
        entries = removeDestroy(entries, removeDestroyList);

        if ((config.LootingBagStoreAll() == LootbagUtilitiesConfig.LootingBagStoreAll.LEFT_CLICK ||
                config.LootingBagStoreAll() == LootbagUtilitiesConfig.LootingBagStoreAll.SHIFT_CLICK && client.isKeyPressed(KeyCode.KC_SHIFT))
                && isLootingBagInterfaceOpen()) {
            doLootingBagSwaps(entries);
        }

        client.setMenuEntries(entries);
    }

    @Subscribe
	@SuppressWarnings("unused")
    public void onMenuOptionClicked(MenuOptionClicked clickedOption) {
        Widget clickedWidget = clickedOption.getWidget();
        if ( clickedWidget != null
                && isLootingBag(clickedWidget.getItemId())
                && clickedOption.getMenuOption().equals("Destroy")
                && removeLootingBagDestroy(config.LootingBagDestroySetting(), getInWilderness())
        ) {
            //consume event (it is not sent to server)
            clickedOption.consume();
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
                                  "A magical force (LootbagUtilities plugin) prevents you from destroying your looting bag",
                                  ""
            );
            log.debug("User tried to destroy looting bag when not allowed");
        }
    }

    @Provides
	@SuppressWarnings("unused")
    LootbagUtilitiesConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(LootbagUtilitiesConfig.class);
    }
}

package com.example.lootbagUtilities;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("lootbagUtilities")
public interface LootbagUtilitiesConfig extends Config
{
	enum LootingBagDestroySetting {
		ALLOW,
		REMOVE,
		ALLOW_IN_WILDY,
	}

	enum LootingBagStoreAll {
		@SuppressWarnings("unused")
		RIGHT_CLICK,
		LEFT_CLICK,
		SHIFT_CLICK,
	}
	@ConfigItem(
			keyName = "leftClickUseLootingBag",
			name = "Default 'use' looting bag",
			description = "Make 'use' the default option on the looting bag" +
					"This should make wilderness bagging quicker, as you can always left-click" +
					"the looting bag"
	)
	default boolean leftClickUseLootingBag() { return true; }

	@ConfigItem(
			keyName = "removeLootingBagDestroy",
			name = "Allow Destroying the Looting Bag",
			description = "Allow destroying looting bag depending whether in the wilderness"
	)
	default LootingBagDestroySetting LootingBagDestroySetting() {
		return LootingBagDestroySetting.ALLOW_IN_WILDY;
	}

	@ConfigItem(
			keyName = "swapStoreAll",
			name = "Swap store-all in looting bag deposit",
			description = "Make store-all the default option in looting bag deposit interface"
	)
	default LootingBagStoreAll LootingBagStoreAll() {
		return LootingBagStoreAll.SHIFT_CLICK;
	}

	@ConfigSection(
			name = "Other Destroyables",
			description = "Remove destroy option on misc. items",
			position = 99
	)
	String miscDestroyables = "miscDestroyables";

	@ConfigItem(
			keyName = "removeRunePouchDestroy",
			name = "Remove Destroy on Rune Pouch",
			description = "Remove destroy option from Rune Pouch right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveRunePouchDestroy() { return false; }

	@ConfigItem(
			keyName = "removeBoltPouchDestroy",
			name = "Remove Destroy on Bolt Pouch",
			description = "Remove destroy option from Bolt Pouch right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveBoltPouchDestroy() { return false; }

	@ConfigItem(
			keyName = "removeSeedBoxDestroy",
			name = "Remove Destroy on Seed Box",
			description = "Remove destroy option from Seed Box right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveSeedBoxDestroy() { return false; }

	@ConfigItem(
			keyName = "removeHerbSackDestroy",
			name = "Remove Destroy on Herb Sack",
			description = "Remove destroy option from Herb Sack right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveHerbSackDestroy() { return false; }

	@ConfigItem(
			keyName = "removeCoalBagDestroy",
			name = "Remove Destroy on Coal Bag",
			description = "Remove destroy option from Coal Bag right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveCoalBagDestroy() { return false; }

	@ConfigItem(
			keyName = "removeFishBarrelDestroy",
			name = "Remove Destroy on Fish Barrel",
			description = "Remove destroy option from Fish Barrel right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveFishBarrelDestroy() { return false; }

	@ConfigItem(
			keyName = "removeGemBagDestroy",
			name = "Remove Destroy on Gem Bag",
			description = "Remove destroy option from Gem Bag right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveGemBagDestroy() { return false; }

	@ConfigItem(
			keyName = "removeTackleBoxDestroy",
			name = "Remove Destroy on Tackle Box",
			description = "Remove destroy option from Tackle Box right-click menu",
			section = miscDestroyables
	)
	default boolean RemoveTackleBoxDestroy() { return false; }

	@ConfigItem(
		keyName = "removeForestryDestroy",
		name = "Remove Destroy on forestry items",
		description = "Remove destroy option from forestry kit, forestry basket and log basket right-click menu",
		section = miscDestroyables
	)
	default boolean RemoveForestryDestroy() { return false; }
}

package com.example.lootbagUtilities;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LootbagUtilitiesPlayTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LootbagUtilities.class);
		RuneLite.main(args);
	}
}
package com.example.lootbagUtilities;

import net.runelite.api.*;
import net.runelite.api.widgets.Widget;
import org.junit.Test;
import com.example.lootbagUtilities.LootbagUtilities.DestroyableItem;

import net.runelite.client.menus.TestMenuEntry;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;

public class LootbagUtilitiesTest {
    // Wrapper around annoying MenuEntry setters
    private static MenuEntry newMenuEntry(
            String option,
            String target,
            /*int identifier,*/
            int itemId,
            MenuAction type,
            int param0,
            int param1)
    {
        TestMenuEntry entry = new TestMenuEntry();
        entry.setOption(option);
        entry.setTarget(target);
        //entry.setIdentifier(identifier);
        //no idea what the numbers in this constructor mean, they were scraped from right-clicking
        //a looting bag in game to best match real values
        Widget widget = new TestWidget(9764864, 5, 0, 0);
        widget.setItemId(itemId);
        entry.setItemId(itemId);
        entry.setWidget(widget);
        entry.setType(type);
        entry.setParam0(param0);
        entry.setParam1(param1);
        return entry;
    }

    //Script to extract menu entries (copy and paste into runelite jshell):
	/*
subscribe(MenuOpened.class, (MenuOpened e) -> {
    for(MenuEntry entry: client.getMenuEntries()) {
        log.info(
            "newMenuEntry(\"{}\", \"{}\", {}, MenuAction.{}, {}, {}),",
            entry.getOption(),
            entry.getTarget(),
            entry.getIdentifier(),
            entry.getType(),
            entry.getParam0(),
            entry.getParam1()
        );
    }
});
	 */
    static MenuEntry cancelOption = newMenuEntry("Cancel", "", 0, MenuAction.CANCEL, 0, 0);
    static int emerald = ItemID.UNCUT_EMERALD+1;
    static MenuEntry[] rightClickNotedEmeralds = {
            cancelOption,
            newMenuEntry("Examine", "<col=ff9040>Uncut emerald", emerald, MenuAction.CC_OP_LOW_PRIORITY, 5, 9764864),
            newMenuEntry("Drop", "<col=ff9040>Uncut emerald", emerald, MenuAction.CC_OP_LOW_PRIORITY, 5, 9764864),
            newMenuEntry("Use", "<col=ff9040>Uncut emerald", emerald, MenuAction.WIDGET_TARGET, 5, 9764864),
    };
    static MenuEntry[] rightClickGuard = {
            cancelOption,
            newMenuEntry("Examine", "<col=ffff00>Guard<col=ff00>  (level-21)", 9334, MenuAction.EXAMINE_NPC, 0, 0),
            newMenuEntry("Walk here", "", 0, MenuAction.WALK, 228, 34),
            newMenuEntry("Pickpocket", "<col=ffff00>Guard<col=ff00>  (level-21)", 9334, MenuAction.NPC_THIRD_OPTION, 0, 0),
            newMenuEntry("Attack", "<col=ffff00>Guard<col=ff00>  (level-21)", 9334, MenuAction.NPC_SECOND_OPTION, 0, 0),
    };
    static MenuEntry[] rightClickTreeAndSkeleton = {
            cancelOption,
            newMenuEntry("Examine", "<col=ffff>Oak", 10820, MenuAction.EXAMINE_OBJECT, 83, 78),
            newMenuEntry("Examine", "<col=ffff00>Skeleton<col=ff00>  (level-22)", 22109, MenuAction.EXAMINE_NPC, 0, 0),
            newMenuEntry("Walk here", "", 0, MenuAction.WALK, 333, 89),
            newMenuEntry("Chop down", "<col=ffff>Oak", 10820, MenuAction.GAME_OBJECT_FIRST_OPTION, 83, 78),
            newMenuEntry("Attack", "<col=ffff00>Skeleton<col=ff00>  (level-22)", 22109, MenuAction.NPC_SECOND_OPTION, 0, 0),
    };
    static int eek = ItemID.EEK;
    static MenuEntry[] rightClickInventoryEek = {
            cancelOption,
            newMenuEntry("Examine", "<col=ff9040>Eek", eek, MenuAction.CC_OP_LOW_PRIORITY, 9, 9764864),
            newMenuEntry("Destroy", "<col=ff9040>Eek", eek, MenuAction.CC_OP_LOW_PRIORITY, 9, 9764864),
            newMenuEntry("Use", "<col=ff9040>Eek", eek, MenuAction.WIDGET_TARGET, 9, 9764864),
            newMenuEntry("Talk-to", "<col=ff9040>Eek", eek, MenuAction.CC_OP, 9, 9764864),
            newMenuEntry("Hold", "<col=ff9040>Eek", eek, MenuAction.CC_OP, 9, 9764864),
    };
    static MenuEntry[] rightClickEquippedEek = {
            cancelOption,
            newMenuEntry("Examine", "<col=ff9040>Eek</col>", 10, MenuAction.CC_OP_LOW_PRIORITY, -1, 25362450),
            newMenuEntry("Talk-to", "<col=ff9040>Eek</col>", 2, MenuAction.CC_OP, -1, 25362450),
            newMenuEntry("Remove", "<col=ff9040>Eek</col>", 1, MenuAction.CC_OP, -1, 25362450),
    };
    static int plankSack = ItemID.PLANK_SACK;
    static MenuEntry[] shiftRightClickPlankSack = {
            cancelOption,
            newMenuEntry("Examine", "<col=ff9040>Plank sack", plankSack, MenuAction.CC_OP_LOW_PRIORITY, 23, 9764864),
            newMenuEntry("Drop", "<col=ff9040>Plank sack", plankSack, MenuAction.CC_OP_LOW_PRIORITY, 23, 9764864),
            newMenuEntry("Empty", "<col=ff9040>Plank sack", plankSack, MenuAction.CC_OP_LOW_PRIORITY, 23, 9764864),
            newMenuEntry("Use", "<col=ff9040>Plank sack", plankSack, MenuAction.WIDGET_TARGET, 23, 9764864),
            newMenuEntry("Check", "<col=ff9040>Plank sack", plankSack, MenuAction.CC_OP, 23, 9764864),
            newMenuEntry("Fill", "<col=ff9040>Plank sack", plankSack, MenuAction.CC_OP, 23, 9764864),
    };
    static int lootingBag = ItemID.LOOTING_BAG;
    static MenuEntry[] rightClickLootingBag = {
            cancelOption,
            newMenuEntry("Examine", "<col=ff9040>Looting bag", lootingBag, MenuAction.CC_OP_LOW_PRIORITY, 27, 9764864),
            newMenuEntry("Destroy", "<col=ff9040>Looting bag", lootingBag, MenuAction.CC_OP_LOW_PRIORITY, 27, 9764864),
            newMenuEntry("Settings", "<col=ff9040>Looting bag", lootingBag, MenuAction.CC_OP_LOW_PRIORITY, 27, 9764864),
            newMenuEntry("Use", "<col=ff9040>Looting bag", lootingBag, MenuAction.WIDGET_TARGET, 27, 9764864),
            newMenuEntry("Deposit", "<col=ff9040>Looting bag", lootingBag, MenuAction.CC_OP, 27, 9764864),
            newMenuEntry("Check", "<col=ff9040>Looting bag", lootingBag, MenuAction.CC_OP, 27, 9764864),
            newMenuEntry("Open", "<col=ff9040>Looting bag", lootingBag, MenuAction.CC_OP, 27, 9764864),
    };
    static int runePouch = ItemID.RUNE_POUCH;
    static MenuEntry[] rightClickRunePouch = {
            cancelOption,
            newMenuEntry("Examine", "<col=ff9040>Rune pouch", runePouch, MenuAction.CC_OP_LOW_PRIORITY, 24, 9764864),
            newMenuEntry("Destroy", "<col=ff9040>Rune pouch", runePouch, MenuAction.CC_OP_LOW_PRIORITY, 24, 9764864),
            newMenuEntry("Empty", "<col=ff9040>Rune pouch", runePouch, MenuAction.CC_OP_LOW_PRIORITY, 24, 9764864),
            newMenuEntry("Use", "<col=ff9040>Rune pouch", runePouch, MenuAction.WIDGET_TARGET, 24, 9764864),
            newMenuEntry("Open", "<col=ff9040>Rune pouch", runePouch, MenuAction.CC_OP, 24, 9764864),
    };
    static int seedBox = ItemID.OPEN_SEED_BOX;
    static MenuEntry[] rightClickSeedBox = {
            cancelOption,
            newMenuEntry("Examine", "<col=ff9040>Open seed box", seedBox, MenuAction.CC_OP_LOW_PRIORITY, 26, 9764864),
            newMenuEntry("Destroy", "<col=ff9040>Open seed box", seedBox, MenuAction.CC_OP_LOW_PRIORITY, 26, 9764864),
            newMenuEntry("Close", "<col=ff9040>Open seed box", seedBox, MenuAction.CC_OP_LOW_PRIORITY, 26, 9764864),
            newMenuEntry("Use", "<col=ff9040>Open seed box", seedBox, MenuAction.WIDGET_TARGET, 26, 9764864),
            newMenuEntry("Check", "<col=ff9040>Open seed box", seedBox, MenuAction.CC_OP, 26, 9764864),
            newMenuEntry("Empty", "<col=ff9040>Open seed box", seedBox, MenuAction.CC_OP, 26, 9764864),
            newMenuEntry("Fill", "<col=ff9040>Open seed box", seedBox, MenuAction.CC_OP, 26, 9764864),
    };

    // Assert that calling removeDestroyOptions
    static void assertOptionsUnchanged(MenuEntry[] entries, DestroyableItem[] config) {
        MenuEntry[] modifiedEntries = LootbagUtilities.removeDestroy(entries, config);
        assertArrayEquals(entries, modifiedEntries);
    }

    static void assertNoDestroyOption(MenuEntry[] entries)  {
        for(MenuEntry e: entries) {
            assert(!e.getOption().equals("Destroy"));
        }
    }

    @Test
    public void testRemoveDestroy() {
        for (int i = 0; i < 2*2*2; i++) {
            LootbagUtilitiesConfig.LootingBagDestroySetting removeLootingBagDestroy =
            (i % 2 == 0) ?
                    LootbagUtilitiesConfig.LootingBagDestroySetting.ALLOW
                    : LootbagUtilitiesConfig.LootingBagDestroySetting.REMOVE;
            boolean removeRunePouchDestroy = i % 2 == 0;
            boolean removeSeedBoxDestroy = i / 2 % 2 == 0;
            MockLootbagUtilitiesConfig config = new MockLootbagUtilitiesConfig(
                    true,
                    removeLootingBagDestroy,
                    removeRunePouchDestroy,
                    false,
                    removeSeedBoxDestroy,
                    false,
                    false,
                    false,
                    false,
                    false
            );

            DestroyableItem[] removeConfig = LootbagUtilities.genDestroyList(config, () -> false);
            // doesn't mess with right-clicks on a few miscellaneous objects
            assertOptionsUnchanged(rightClickNotedEmeralds, removeConfig);
            assertOptionsUnchanged(rightClickGuard, removeConfig);
            assertOptionsUnchanged(rightClickTreeAndSkeleton, removeConfig);
            assertOptionsUnchanged(rightClickInventoryEek, removeConfig);
            assertOptionsUnchanged(rightClickEquippedEek, removeConfig);
            assertOptionsUnchanged(shiftRightClickPlankSack, removeConfig);

            // Properly removes the destroy option and only the destroy option
            MenuEntry[] modifiedRightClickLootingBag = LootbagUtilities.removeDestroy(rightClickLootingBag, removeConfig);
            if (removeLootingBagDestroy == LootbagUtilitiesConfig.LootingBagDestroySetting.REMOVE) {
                assertEquals(rightClickLootingBag.length - 1, modifiedRightClickLootingBag.length);
                assertNoDestroyOption(modifiedRightClickLootingBag);
            } else {
                assertArrayEquals(rightClickLootingBag, modifiedRightClickLootingBag);
            }

            MenuEntry[] modifiedRightClickRunePouch =  LootbagUtilities.removeDestroy(rightClickRunePouch, removeConfig);
            if (removeRunePouchDestroy) {
                assertEquals(rightClickRunePouch.length - 1, modifiedRightClickRunePouch.length);
                assertNoDestroyOption(modifiedRightClickRunePouch);
            } else {
                assertArrayEquals(rightClickRunePouch, modifiedRightClickRunePouch);
            }

            MenuEntry[] modifiedRightClickSeedBox = LootbagUtilities.removeDestroy(rightClickSeedBox, removeConfig);
            if (removeSeedBoxDestroy) {
                assertEquals(rightClickSeedBox.length - 1, modifiedRightClickSeedBox.length);
                assertNoDestroyOption(modifiedRightClickSeedBox);
            } else {
                assertArrayEquals(rightClickSeedBox, modifiedRightClickSeedBox);
            }
        }
    }

    @Test
    public void testConsumeEvent() {
        //TODO: test LootBagUtilities.consumeEvent
    }
}

package com.example.lootbagUtilities;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class MockLootbagUtilitiesConfig implements LootbagUtilitiesConfig{
    boolean leftClickUseLootingBag;
    LootingBagDestroySetting RemoveLootingBagDestroy;
    boolean RemoveRunePouchDestroy;
    boolean RemoveBoltPouchDestroy;
    boolean RemoveSeedBoxDestroy;
    boolean RemoveHerbSackDestroy;
    boolean RemoveCoalBagDestroy;
    boolean RemoveFishBarrelDestroy;
    boolean RemoveGemBagDestroy;
    boolean RemoveTackleBoxDestroy;

    @Override
    public boolean leftClickUseLootingBag() { return leftClickUseLootingBag; }
    @Override
    public LootingBagDestroySetting LootingBagDestroySetting() { return RemoveLootingBagDestroy; }
    @Override
    public boolean RemoveRunePouchDestroy() { return RemoveRunePouchDestroy; }
    @Override
    public boolean RemoveBoltPouchDestroy() { return RemoveBoltPouchDestroy; }
    @Override
    public boolean RemoveSeedBoxDestroy() { return RemoveSeedBoxDestroy; }
    @Override
    public boolean RemoveHerbSackDestroy() { return RemoveHerbSackDestroy; }
    @Override
    public boolean RemoveCoalBagDestroy() { return RemoveCoalBagDestroy; }
    @Override
    public boolean RemoveFishBarrelDestroy() { return RemoveFishBarrelDestroy; }
    @Override
    public boolean RemoveGemBagDestroy() { return RemoveGemBagDestroy; }
    @Override
    public boolean RemoveTackleBoxDestroy() { return RemoveTackleBoxDestroy; }
}

package com.example.lootbagUtilities;

import net.runelite.api.FontTypeFace;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import org.jetbrains.annotations.Range;

import javax.annotation.Nullable;
import java.awt.*;

public class TestWidget implements Widget {
    int id;
    int type;
    int contentType;
    int clickMask;
    Widget[] children;
    String text;
    int textColor;
    int opacity;
    String name;

    TestWidget(int id, int type, int contentType, int clickMask) {
        this.id = id;
        this.type = type;
        this.contentType = contentType;
        this.clickMask = clickMask;
    }

    @Override
    public int getId() {
        return this.id;
    }

    @Override
    public int getType() {
        return this.type;
    }

    @Override
    public void setType(int type) {
        this.type = type;
    }

    @Override
    public int getContentType() {
        return this.contentType;
    }

    @Override
    public Widget setContentType(int contentType) {
        this.contentType = contentType;
        return this;
    }

    @Override
    public int getClickMask() {
        return this.clickMask;
    }

    @Override
    public Widget setClickMask(int clickMask) {
        this.clickMask = clickMask;
        return this;
    }

    @Override
    public Widget getParent() {
        return null;
    }

    @Override
    public int getParentId() {
        return 0;
    }

    @Override
    public Widget getChild(int index) {
        return this.children[index];
    }

    @Nullable
    @Override
    public Widget[] getChildren() {
        return this.children;
    }

    @Override
    public void setChildren(Widget[] children) {
        this.children = children;
    }

    @Override
    public Widget[] getDynamicChildren() {
        return new Widget[0];
    }

    @Override
    public Widget[] getStaticChildren() {
        return new Widget[0];
    }

    @Override
    public Widget[] getNestedChildren() {
        return new Widget[0];
    }

    @Override
    public int getRelativeX() {
        return 0;
    }

    @Override
    public void setRelativeX(int x) {
    }

    @Override
    public int getRelativeY() {
        return 0;
    }

    @Override
    public void setRelativeY(int y) {

    }

    @Override
    public void setForcedPosition(int x, int y) {

    }

    @Override
    public String getText() {
        return this.text;
    }

    @Override
    public Widget setText(String text) {
        this.text = text;
        return this;
    }

    @Override
    public int getTextColor() {
        return this.textColor;
    }

    @Override
    public Widget setTextColor(int textColor) {
        this.textColor = textColor;
        return this;
    }

    @Override
    public int getOpacity() {
        return this.opacity;
    }

    @Override
    public Widget setOpacity(int transparency) {
        this.opacity = transparency;
        return this;
    }

    @Override
    public String getName() {
        return this.name;
    }

    @Override
    public Widget setName(String name) {
        this.name = name;
        return this;
    }

    @Override
    public int getModelId() {
        return 0;
    }

    @Override
    public Widget setModelId(int id) {
        return null;
    }

    @Override
    public int getModelType() {
        return 0;
    }

    @Override
    public Widget setModelType(int type) {
        return null;
    }

    @Override
    public int getAnimationId() {
        return 0;
    }

    @Override
    public Widget setAnimationId(int animationId) {
        return null;
    }

    @Override
    public @org.jetbrains.annotations.Range(from = 0L, to = 2047L) int getRotationX() {
        return 0;
    }

    @Override
    public Widget setRotationX(@org.jetbrains.annotations.Range(from = 0L, to = 2047L) int modelX) {
        return null;
    }

    @Override
    public @org.jetbrains.annotations.Range(from = 0L, to = 2047L) int getRotationY() {
        return 0;
    }

    @Override
    public Widget setRotationY(@org.jetbrains.annotations.Range(from = 0L, to = 2047L) int modelY) {
        return null;
    }

    @Override
    public @org.jetbrains.annotations.Range(from = 0L, to = 2047L) int getRotationZ() {
        return 0;
    }

    @Override
    public Widget setRotationZ(@Range(from = 0L, to = 2047L) int modelZ) {
        return null;
    }

    @Override
    public int getModelZoom() {
        return 0;
    }

    @Override
    public Widget setModelZoom(int modelZoom) {
        return null;
    }

    @Override
    public int getSpriteId() {
        return 0;
    }

    @Override
    public boolean getSpriteTiling() {
        return false;
    }

    @Override
    public Widget setSpriteTiling(boolean tiling) {
        return null;
    }

    @Override
    public Widget setSpriteId(int spriteId) {
        return null;
    }

    @Override
    public boolean isHidden() {
        return false;
    }

    @Override
    public boolean isSelfHidden() {
        return false;
    }

    @Override
    public Widget setHidden(boolean hidden) {
        return null;
    }

    @Override
    public int getIndex() {
        return 0;
    }

    @Override
    public Point getCanvasLocation() {
        return null;
    }

    @Override
    public int getWidth() {
        return 0;
    }

    @Override
    public void setWidth(int width) {

    }

    @Override
    public int getHeight() {
        return 0;
    }

    @Override
    public void setHeight(int height) {

    }

    @Override
    public Rectangle getBounds() {
        return null;
    }

    @Override
    public int getItemId() {
        return 0;
    }

    @Override
    public Widget setItemId(int itemId) {
        return null;
    }

    @Override
    public int getItemQuantity() {
        return 0;
    }

    @Override
    public Widget setItemQuantity(int quantity) {
        return null;
    }

    @Override
    public boolean contains(Point point) {
        return false;
    }

    @Override
    public int getScrollX() {
        return 0;
    }

    @Override
    public Widget setScrollX(int scrollX) {
        return null;
    }

    @Override
    public int getScrollY() {
        return 0;
    }

    @Override
    public Widget setScrollY(int scrollY) {
        return null;
    }

    @Override
    public int getScrollWidth() {
        return 0;
    }

    @Override
    public Widget setScrollWidth(int width) {
        return null;
    }

    @Override
    public int getScrollHeight() {
        return 0;
    }

    @Override
    public Widget setScrollHeight(int height) {
        return null;
    }

    @Override
    public int getOriginalX() {
        return 0;
    }

    @Override
    public Widget setOriginalX(int originalX) {
        return null;
    }

    @Override
    public int getOriginalY() {
        return 0;
    }

    @Override
    public Widget setOriginalY(int originalY) {
        return null;
    }

    @Override
    public Widget setPos(int x, int y) {
        return null;
    }

    @Override
    public Widget setPos(int x, int y, int xMode, int yMode) {
        return null;
    }

    @Override
    public int getOriginalHeight() {
        return 0;
    }

    @Override
    public Widget setOriginalHeight(int originalHeight) {
        return null;
    }

    @Override
    public int getOriginalWidth() {
        return 0;
    }

    @Override
    public Widget setOriginalWidth(int originalWidth) {
        return null;
    }

    @Override
    public Widget setSize(int width, int height) {
        return null;
    }

    @Override
    public Widget setSize(int width, int height, int widthMode, int heightMode) {
        return null;
    }

    @Override
    public String[] getActions() {
        return new String[0];
    }

    @Override
    public Widget createChild(int index, int type) {
        return null;
    }

    @Override
    public Widget createChild(int type) {
        return null;
    }

    @Override
    public void deleteAllChildren() {

    }

    @Override
    public void setAction(int index, String action) {

    }

    @Override
    public void setOnOpListener(Object... args) {

    }

    @Override
    public void setOnDialogAbortListener(Object... args) {

    }

    @Override
    public void setOnKeyListener(Object... args) {

    }

    @Override
    public void setOnMouseOverListener(Object... args) {

    }

    @Override
    public void setOnMouseRepeatListener(Object... args) {

    }

    @Override
    public void setOnMouseLeaveListener(Object... args) {

    }

    @Override
    public void setOnTimerListener(Object... args) {

    }

    @Override
    public void setOnTargetEnterListener(Object... args) {

    }

    @Override
    public void setOnTargetLeaveListener(Object... args) {

    }

    @Override
    public boolean hasListener() {
        return false;
    }

    @Override
    public Widget setHasListener(boolean hasListener) {
        return null;
    }

    @Override
    public boolean isIf3() {
        return false;
    }

    @Override
    public void revalidate() {

    }

    @Override
    public void revalidateScroll() {

    }

    @Override
    public Object[] getOnOpListener() {
        return new Object[0];
    }

    @Override
    public Object[] getOnKeyListener() {
        return new Object[0];
    }

    @Override
    public Object[] getOnLoadListener() {
        return new Object[0];
    }

    @Override
    public Object[] getOnInvTransmitListener() {
        return new Object[0];
    }

    @Override
    public int getFontId() {
        return 0;
    }

    @Override
    public Widget setFontId(int id) {
        return null;
    }

    @Override
    public int getBorderType() {
        return 0;
    }

    @Override
    public void setBorderType(int thickness) {

    }

    @Override
    public boolean getTextShadowed() {
        return false;
    }

    @Override
    public Widget setTextShadowed(boolean shadowed) {
        return null;
    }

    @Override
    public int getDragDeadZone() {
        return 0;
    }

    @Override
    public void setDragDeadZone(int deadZone) {

    }

    @Override
    public int getDragDeadTime() {
        return 0;
    }

    @Override
    public void setDragDeadTime(int deadTime) {

    }

    @Override
    public int getItemQuantityMode() {
        return 0;
    }

    @Override
    public Widget setItemQuantityMode(int itemQuantityMode) {
        return null;
    }

    @Override
    public int getXPositionMode() {
        return 0;
    }

    @Override
    public Widget setXPositionMode(int xpm) {
        return null;
    }

    @Override
    public int getYPositionMode() {
        return 0;
    }

    @Override
    public Widget setYPositionMode(int ypm) {
        return null;
    }

    @Override
    public int getLineHeight() {
        return 0;
    }

    @Override
    public Widget setLineHeight(int lineHeight) {
        return null;
    }

    @Override
    public int getXTextAlignment() {
        return 0;
    }

    @Override
    public Widget setXTextAlignment(int xta) {
        return null;
    }

    @Override
    public int getYTextAlignment() {
        return 0;
    }

    @Override
    public Widget setYTextAlignment(int yta) {
        return null;
    }

    @Override
    public int getWidthMode() {
        return 0;
    }

    @Override
    public Widget setWidthMode(int widthMode) {
        return null;
    }

    @Override
    public int getHeightMode() {
        return 0;
    }

    @Override
    public Widget setHeightMode(int heightMode) {
        return null;
    }

    @Override
    public FontTypeFace getFont() {
        return null;
    }

    @Override
    public boolean isFilled() {
        return false;
    }

    @Override
    public Widget setFilled(boolean filled) {
        return null;
    }

    @Override
    public String getTargetVerb() {
        return null;
    }

    @Override
    public void setTargetVerb(String targetVerb) {

    }

    @Override
    public boolean getNoClickThrough() {
        return false;
    }

    @Override
    public void setNoClickThrough(boolean noClickThrough) {

    }

    @Override
    public boolean getNoScrollThrough() {
        return false;
    }

    @Override
    public void setNoScrollThrough(boolean noScrollThrough) {

    }

    @Override
    public void setVarTransmitTrigger(int... trigger) {

    }

    @Override
    public void setOnClickListener(Object... args) {

    }

    @Override
    public void setOnHoldListener(Object... args) {

    }

    @Override
    public void setOnReleaseListener(Object... args) {

    }

    @Override
    public void setOnDragCompleteListener(Object... args) {

    }

    @Override
    public void setOnDragListener(Object... args) {

    }

    @Override
    public Widget getDragParent() {
        return null;
    }

    @Override
    public Widget setDragParent(Widget dragParent) {
        return null;
    }

    @Override
    public Object[] getOnVarTransmitListener() {
        return new Object[0];
    }

    @Override
    public void setOnVarTransmitListener(Object... args) {}
	@Override
	public void setOnScrollWheelListener(Object... args) {}
}

