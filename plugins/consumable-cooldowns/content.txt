/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;


import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.FontType;
import net.runelite.client.config.Range;

@ConfigGroup(ConsumableCooldownsConfig.GROUP_NAME)
public interface ConsumableCooldownsConfig extends Config
{
	String GROUP_NAME = "consumablecooldowns";

	@ConfigSection(
		name = "Item cooldown text",
		description = "Options for the consumable item cooldown text",
		position = 99
	)
	String itemCooldownTextSection = "itemCooldownText";

	@ConfigSection(
		name = "Item cooldown indicator",
		description = "Options for the consumable item cooldown indicator",
		position = 100
	)
	String itemCooldownIndicatorSection = "itemCooldownIndicator";

	@ConfigSection(
		name = "Delayed heal infobox",
		description = "Options for the delayed heal infobox",
		position = 101
	)
	String delayedHealInfoboxSection = "delayedHealInfobox";

	@ConfigSection(
		name = "Bottom to top indicator",
		description = "Options for the bottom to top consumable item cooldown indicator",
		closedByDefault = true,
		position = 102
	)
	String itemBottomToTopCooldownIndicatorSection = "itemBottomToTopCooldownIndicator";

	@ConfigItem(
		position = 0,
		keyName = "showItemCooldownPreview",
		name = "Show item cooldown preview",
		description = "Display a preview of the item cooldown indicator and text on all consumable items for configuration purposes"
	)
	default boolean showItemCooldownPreview()
	{
		return false;
	}

	@ConfigItem(
		position = 1,
		keyName = "showDelayedHealInfobox",
		name = "Show delayed heal infobox",
		description = "Show an infobox with the time remaining until the delayed heal from consumables such as cooked moonlight antelope"
	)
	default boolean showDelayedHealInfobox()
	{
		return true;
	}

	@ConfigItem(
		position = 2,
		keyName = "cooldownTextMode",
		name = "Mode",
		description = "Mode used for the cooldown text that displays the duration a consumable item is on cooldown",
		section = itemCooldownTextSection
	)
	default CooldownTextMode cooldownTextMode()
	{
		return CooldownTextMode.GAME_TICKS;
	}

	@ConfigItem(
		position = 3,
		keyName = "textColor",
		name = "Text color",
		description = "Color of consumable item cooldown text",
		section = itemCooldownTextSection
	)
	default Color getTextColor()
	{
		return new Color(17, 255, 255);
	}

	@ConfigItem(
		position = 4,
		keyName = "textShadowColor",
		name = "Text shadow color",
		description = "Color of consumable item cooldown text shadow",
		section = itemCooldownTextSection
	)
	default Color getTextShadowColor()
	{
		return Color.BLACK;
	}

	@ConfigItem(
		position = 5,
		keyName = "fontType",
		name = "Text font type",
		description = "Font type used for consumable item cooldown text",
		section = itemCooldownTextSection
	)
	default FontType getFontType()
	{
		return FontType.BOLD;
	}

	@Range(min = -15, max = 20)
	@ConfigItem(
		position = 6,
		keyName = "textXOffset",
		name = "Text width offset",
		description = "X-axis offset for consumable item cooldown text position. Default value is in the center of the item",
		section = itemCooldownTextSection
	)
	default int getTextXOffset()
	{
		return 3;
	}

	@Range(min = -15, max = 15)
	@ConfigItem(
		position = 7,
		keyName = "textYOffset",
		name = "Text height offset",
		description = "Y-axis offset for consumable item cooldown text position. Default value is in the center of the item",
		section = itemCooldownTextSection
	)
	default int getTextYOffset()
	{
		return 0;
	}

	@ConfigItem(
		position = 8,
		keyName = "cooldownIndicatorMode",
		name = "Mode",
		description = "Indicator mode which should be used to display that a consumable item is on cooldown",
		section = itemCooldownIndicatorSection
	)
	default CooldownIndicatorMode getCooldownIndicatorMode()
	{
		return CooldownIndicatorMode.BOTTOM_TO_TOP;
	}

	@ConfigItem(
		position = 9,
		keyName = "itemCooldownIndicatorFillColor",
		name = "Fill color",
		description = "Color of item cooldown indicator fill",
		section = itemCooldownIndicatorSection
	)
	default Color getItemCooldownIndicatorFillColor()
	{
		return new Color(26, 26, 26);
	}

	@Range(max = 100)
	@ConfigItem(
		position = 10,
		keyName = "itemCooldownIndicatorFillOpacity",
		name = "Fill opacity",
		description = "Opacity of item cooldown indicator fill color when on cooldown. From 0 to 100",
		section = itemCooldownIndicatorSection
	)
	default int getItemCooldownIndicatorFillOpacity()
	{
		return 80;
	}

	@ConfigItem(
		position = 11,
		keyName = "infoboxCooldownTextMode",
		name = "Text mode",
		description = "Mode used for the cooldown text that displays the time remaining until the delayed heal from consumables such as cooked moonlight antelope",
		section = delayedHealInfoboxSection
	)
	default InfoBoxTextMode infoboxCooldownTextMode()
	{
		return InfoBoxTextMode.GAME_TICKS;
	}

	@ConfigItem(
		position = 12,
		keyName = "bottomToTopFullFillDuration",
		name = "Full fill duration",
		description = "The duration the cooldown indicator fill fully covers the item icon at the start of a cooldown. " +
			"This can make the cooldown easier to notice. Only works when using the bottom to top cooldown indicator",
		section = itemBottomToTopCooldownIndicatorSection
	)
	default BottomToTopCooldownIndicatorStartDelay getBottomToTopFullFillDuration()
	{
		return BottomToTopCooldownIndicatorStartDelay.NORMAL;
	}
}

package com.consumablecooldowns;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@EqualsAndHashCode
@Getter
class InventoryIconPixelCoordinates
{
	final int x;
	final int y;
}

/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Item;
import net.runelite.api.ItemID;

@AllArgsConstructor
@Getter(AccessLevel.MODULE)
public class InventoryConsumableItemAction
{
	private final Item[] oldInventory;
	private final int itemId;
	private final int itemSlot;
	private final int actionTick;

	boolean isItemConsumed(Item[] newInventory)
	{
		Item oldItem = oldInventory[itemSlot];
		Item newItem = newInventory[itemSlot];
		boolean multiQuantityConsumable = isMultiQuantityInSameSlotConsumable(oldItem.getId());
		boolean isItemStillInInventorySlot = oldItem.getId() == newItem.getId();
		if (!isItemStillInInventorySlot && !multiQuantityConsumable)
		{
			return true;
		}

		if (!multiQuantityConsumable)
		{
			return false;
		}

		int quantityDifference = oldItem.getQuantity() - newItem.getQuantity();
		return quantityDifference > 0;
	}

	private boolean isMultiQuantityInSameSlotConsumable(int itemId)
	{
		return itemId == ItemID.PURPLE_SWEETS || itemId == ItemID.PURPLE_SWEETS_10476 || itemId == ItemID.HONEY_LOCUST;
	}
}
package com.consumablecooldowns;

import java.awt.Color;
import java.awt.image.BufferedImage;
import net.runelite.client.ui.overlay.infobox.InfoBox;

public class ConsumableCooldownTimer extends InfoBox
{
	private final ConsumableCooldownsPlugin plugin;
	private final ConsumableItemCooldown cooldown;

	ConsumableCooldownTimer(BufferedImage image, int ticks, int clientTicks, ConsumableCooldownsPlugin plugin)
	{
		super(image, plugin);
		this.plugin = plugin;
		this.cooldown = new ConsumableItemCooldown(ticks, clientTicks);
	}

	@Override
	public boolean render()
	{
		return cooldown.getTicks() > 0;
	}

	@Override
	public boolean cull()
	{
		return cooldown.getTicks() < 1;
	}

	@Override
	public String getText()
	{
		if (cooldown.getTicks() < 1)
		{
			return null;
		}

		switch (plugin.config.infoboxCooldownTextMode())
		{
			case GAME_TICKS:
				String tickText = cooldown.getTicks() == 1 ? " tick" : " ticks";
				return cooldown.toGameTicks() + tickText;
			case GAME_TICKS_COMPACT:
				return cooldown.toGameTicks() + "t";
			case GAME_TICKS_NO_SUFFIX:
				return cooldown.toGameTicks();
			case SECONDS_MILLISECONDS:
				return cooldown.toSecondsMilliseconds();
			case MINUTES_SECONDS:
				return cooldown.toMinuteSeconds();
			case SECONDS:
				return cooldown.toSeconds();
			case NONE:
			default:
				return null;
		}
	}

	@Override
	public Color getTextColor()
	{
		return Color.WHITE;
	}

	public void updateCooldownTicks(int ticks)
	{
		cooldown.setTicks(ticks);
	}

	public void updateCooldownClientTicks(int clientTicks)
	{
		cooldown.setClientTicks(clientTicks);
	}
}

package com.consumablecooldowns;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum CooldownTextMode
{
	SECONDS_MILLISECONDS("Seconds & ms"),
	GAME_TICKS("Ticks"),
	NONE("None");

	private final String value;

	public String toString()
	{
		return this.value;
	}
}

/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;

public enum ConsumableItemType
{
	FOOD,
	OVERTIME_FOOD,
	DRINK,
	COMBO_FOOD,
	COOKED_CRAB_MEAT,
	CAKE,
	F2P_FIRST_SLICE,
	F2P_SECOND_SLICE,
	P2P_PIE,
}

/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.geom.Arc2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NullItemID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

@Slf4j
public class ConsumableCooldownsOverlay extends WidgetItemOverlay
{
	private final ConsumableCooldownsPlugin plugin;
	private final ConsumableCooldownsConfig config;
	private final ItemManager itemManager;
	private final Cache<Long, Image> fillCache;
	private final Cache<Long, InventoryIconInfo> inventoryIconInfoCache;

	@Inject
	public ConsumableCooldownsOverlay(ItemManager itemManager, ConsumableCooldownsPlugin plugin,
									  ConsumableCooldownsConfig config)
	{
		this.itemManager = itemManager;
		this.plugin = plugin;
		this.config = config;
		fillCache = CacheBuilder.newBuilder()
			.concurrencyLevel(1)
			.maximumSize(32)
			.build();
		inventoryIconInfoCache = CacheBuilder.newBuilder()
			.concurrencyLevel(1)
			.maximumSize(32)
			.build();

		showOnInventory();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
		renderConsumableCooldowns(graphics, widgetItem);
	}

	void invalidateFillCache()
	{
		fillCache.invalidateAll();
	}

	void invalidateInventoryIconInfoCache()
	{
		inventoryIconInfoCache.invalidateAll();
	}

	private void renderConsumableCooldowns(Graphics2D graphics, WidgetItem widgetItem)
	{
		if (plugin.isNoConsumableCooldownActive())
		{
			return;
		}

		Rectangle slotBounds = widgetItem.getCanvasBounds();
		int itemId = widgetItem.getId();

		// Empty inventory item
		if (itemId == NullItemID.NULL_6512)
		{
			return;
		}

		ConsumableItem consumableItem = plugin.getConsumableItemFromId(itemId);
		if (consumableItem == null)
		{
			return;
		}

		ConsumableItemCooldown cooldownRemaining = plugin.getCooldownForConsumableItem(consumableItem);
		if (cooldownRemaining == null)
		{
			return;
		}

		int opacity = (int) (config.getItemCooldownIndicatorFillOpacity() * 2.55f);
		switch (config.getCooldownIndicatorMode())
		{
			case FILL:
				renderCooldownFill(graphics, widgetItem, slotBounds, opacity);
				break;
			case BOTTOM_TO_TOP:
				renderCooldownBottomToTop(
					graphics,
					getCooldownPercent(consumableItem, cooldownRemaining),
					widgetItem,
					slotBounds,
					opacity
				);
				break;
			case PIE:
				renderCooldownPie(
					graphics,
					getCooldownPercent(consumableItem, cooldownRemaining),
					widgetItem,
					slotBounds,
					opacity
				);
				break;
			case NONE:
				break;
		}
	}

	private float getCooldownPercent(ConsumableItem consumableItem, ConsumableItemCooldown cooldownRemaining)
	{
		ConsumableItemCooldown fullCooldown = plugin.getLastCooldownSourceByType(consumableItem.getType());
		if (fullCooldown == null)
		{
			log.warn("No full cooldown found for consumable item type: {}", consumableItem.getType());
			return 1;
		}

		int elapsedCooldownClientTicks = fullCooldown.getClientTicks() - cooldownRemaining.getClientTicks();
		return (float) elapsedCooldownClientTicks / fullCooldown.getClientTicks();
	}

	private void renderCooldownFill(Graphics2D graphics, WidgetItem widgetItem, Rectangle slotBounds, int opacity)
	{
		final Image image = getFillImage(config.getItemCooldownIndicatorFillColor(), opacity, widgetItem.getId(), widgetItem.getQuantity());
		graphics.drawImage(image, (int) slotBounds.getX(), (int) slotBounds.getY(), null);
	}

	private void renderCooldownBottomToTop(Graphics2D graphics, float percent, WidgetItem widgetItem, Rectangle slotBounds, int opacity)
	{
		int itemId = widgetItem.getId();
		int quantity = widgetItem.getQuantity();

		final Image image = getFillImage(config.getItemCooldownIndicatorFillColor(), opacity, itemId, quantity);
		final InventoryIconInfo inventoryIconInfo = getInventoryIconInfo(itemId, quantity, image);

		int clipHeight;
		Rectangle indicatorBoundingBox;

		// If the item has no icon, or the icon is too small, use the whole slot
		if (inventoryIconInfo.width < 0 || inventoryIconInfo.height < 5)
		{
			clipHeight = Math.min((int) slotBounds.getHeight(), (int) ((1 - percent) * slotBounds.getHeight()));
			indicatorBoundingBox = slotBounds;
		}
		else
		{
			int itemIconHeight = inventoryIconInfo.height + config.getBottomToTopFullFillDuration().ordinal();
			clipHeight = Math.min(itemIconHeight, (int) ((1 - percent) * itemIconHeight));
			indicatorBoundingBox = new Rectangle(
				(int) slotBounds.getX(),
				(int) slotBounds.getY() + inventoryIconInfo.minY,
				inventoryIconInfo.width,
				itemIconHeight
			);
		}

		graphics.setClip((int) slotBounds.getX(), (int) indicatorBoundingBox.getY(), (int) slotBounds.getWidth(), clipHeight);
		graphics.drawImage(image, (int) slotBounds.getX(), (int) slotBounds.getY(), null);
		graphics.setClip(slotBounds); // reset clip
	}

	private void renderCooldownPie(
		Graphics2D graphics,
		float percent,
		WidgetItem widgetItem,
		Rectangle slotBounds,
		int opacity
	)
	{
		int itemId = widgetItem.getId();
		int quantity = widgetItem.getQuantity();

		final Image inventoryItemImage = getFillImage(config.getItemCooldownIndicatorFillColor(), opacity, itemId, quantity);
		final InventoryIconInfo inventoryIconInfo = getInventoryIconInfo(itemId, quantity, inventoryItemImage);

		int halfLength = (int) Math.ceil(inventoryIconInfo.visibleRadius);
		int length = halfLength * 2;
		Rectangle outerFrame = new Rectangle(
			slotBounds.x + (int) (inventoryIconInfo.centroid.getX() - halfLength),
			slotBounds.y + (int) (inventoryIconInfo.centroid.getY() - halfLength),
			length,
			length
		);

		Arc2D.Float arc = new Arc2D.Float(Arc2D.PIE);
		arc.setAngleStart(90); // start at top
		arc.setAngleExtent((1 - percent) * 360); // percentage of pie to draw
		arc.setFrame(outerFrame);

		graphics.setClip(arc);
		graphics.drawImage(inventoryItemImage, (int) slotBounds.getX(), (int) slotBounds.getY(), null);
		graphics.setClip(slotBounds); // reset clip
	}

	private InventoryIconInfo getInventoryIconInfo(int itemId, int quantity, Image image)
	{
		long key = (((long) itemId) << 32) | quantity;
		InventoryIconInfo inventoryIconInfo = inventoryIconInfoCache.getIfPresent(key);
		if (inventoryIconInfo != null)
		{
			return inventoryIconInfo;
		}

		inventoryIconInfo = getInventoryIconInfoFromImage((BufferedImage) image);
		inventoryIconInfoCache.put(key, inventoryIconInfo);
		return inventoryIconInfo;
	}

	private Image getFillImage(Color color, int opacity, int itemId, int qty)
	{
		long key = (((long) itemId) << 32) | qty;
		Image image = fillCache.getIfPresent(key);
		if (image == null)
		{
			final Color fillColor = ColorUtil.colorWithAlpha(color, opacity);
			image = ImageUtil.fillImage(itemManager.getImage(itemId, qty, false), fillColor);
			fillCache.put(key, image);
		}
		return image;
	}

	private static double getImageVisibleRadius(final BufferedImage image, Point2D center)
	{
		double radius = 0;
		for (int x = 0; x < image.getWidth(); x++)
		{
			for (int y = 0; y < image.getHeight(); y++)
			{
				int pixel = image.getRGB(x, y);
				int pixelAlpha = pixel >>> 24;
				if (pixelAlpha == 0)
				{
					continue;
				}

				radius = Math.max(radius, center.distanceSq(x, y));
			}
		}

		return Math.sqrt(radius);
	}

	private InventoryIconInfo getInventoryIconInfoFromImage(BufferedImage inventoryIconImage)
	{
		int minX = inventoryIconImage.getWidth(), minY = inventoryIconImage.getHeight(), maxX = 0, maxY = 0;

		int pixelCount = 0;
		double centroidX = 0;
		double centroidY = 0;

		for (int y = 0; y < (inventoryIconImage.getHeight() - 1); y++)
		{
			for (int x = 0; x < (inventoryIconImage.getWidth() - 1); x++)
			{
				int pixel = inventoryIconImage.getRGB(x, y);
				int pixelAlpha = pixel >>> 24;
				if (pixelAlpha == 0)
				{
					continue;
				}

				minX = Math.min(minX, x);
				minY = Math.min(minY, y);
				maxX = Math.max(maxX, x);
				maxY = Math.max(maxY, y);

				if (config.getCooldownIndicatorMode() == CooldownIndicatorMode.PIE)
				{
					centroidX += x;
					centroidY += y;
					pixelCount++;
				}
			}
		}

		if (config.getCooldownIndicatorMode() == CooldownIndicatorMode.PIE)
		{
			Point2D centroid = new Point2D.Double(centroidX / pixelCount, centroidY / pixelCount);
			double visibleRadius = getImageVisibleRadius(inventoryIconImage, centroid);
			return new InventoryIconInfo(minX, minY, maxX - minX, maxY - minY, centroid, visibleRadius);
		}

		return new InventoryIconInfo(minX, minY, maxX - minX, maxY - minY);
	}
}
package com.consumablecooldowns;

import java.awt.geom.Point2D;

class InventoryIconInfo
{
	final int minX;
	final int minY;
	final int width;
	final int height;
	Point2D centroid;
	double visibleRadius;

	public InventoryIconInfo(int minX, int minY, int width, int height, Point2D centroid, double visibleRadius)
	{
		this.minX = minX;
		this.minY = minY;
		this.width = width;
		this.height = height;
		this.centroid = centroid;
		this.visibleRadius = visibleRadius;
	}

	public InventoryIconInfo(int minX, int minY, int width, int height)
	{
		this.minX = minX;
		this.minY = minY;
		this.width = width;
		this.height = height;
	}
}

/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;

import java.util.function.Predicate;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Constants;

/**
 * Item that incurs a delay when consumed
 */
@Getter(AccessLevel.MODULE)
public class ConsumableItem
{
	private final ConsumableItemType type;
	private final int actionCooldownTicks;
	private final int eatCooldownTicks;
	private final int comboEatCooldownTicks;
	private final int drinkCooldownTicks;
	private final int delayedHealTicks;
	private final Predicate<Integer> itemFilter;

	public ConsumableItem(ConsumableItemType type, int actionCooldownTicks, int eatCooldownTicks, int delayedHealTicks, Predicate<Integer> itemFilter)
	{
		this.type = type;
		this.actionCooldownTicks = actionCooldownTicks;
		this.eatCooldownTicks = eatCooldownTicks;
		this.comboEatCooldownTicks = 0;
		this.drinkCooldownTicks = 0;
		this.delayedHealTicks = delayedHealTicks;
		this.itemFilter = itemFilter;
	}

	public ConsumableItem(ConsumableItemType type, int actionCooldownTicks, int eatCooldownTicks, Predicate<Integer> itemFilter)
	{
		this.type = type;
		this.actionCooldownTicks = actionCooldownTicks;
		this.eatCooldownTicks = eatCooldownTicks;
		this.comboEatCooldownTicks = 0;
		this.drinkCooldownTicks = 0;
		this.delayedHealTicks = 0;
		this.itemFilter = itemFilter;
	}

	public ConsumableItem(ConsumableItemType type, int actionCooldownTicks, int eatCooldownTicks, int comboEatCooldownTicks, int drinkCooldownTicks, Predicate<Integer> itemFilter)
	{
		this.type = type;
		this.actionCooldownTicks = actionCooldownTicks;
		this.eatCooldownTicks = eatCooldownTicks;
		this.comboEatCooldownTicks = comboEatCooldownTicks;
		this.drinkCooldownTicks = drinkCooldownTicks;
		this.delayedHealTicks = 0;
		this.itemFilter = itemFilter;
	}

	public ConsumableItemCooldown getFullCooldown()
	{
		switch (type)
		{
			case FOOD:
			case COOKED_CRAB_MEAT:
			case CAKE:
			case F2P_FIRST_SLICE:
			case F2P_SECOND_SLICE:
			case P2P_PIE:
			case OVERTIME_FOOD:
				return new ConsumableItemCooldown(eatCooldownTicks, cooldownTicksToClientTicks(eatCooldownTicks));
			case DRINK:
				return new ConsumableItemCooldown(drinkCooldownTicks, cooldownTicksToClientTicks(drinkCooldownTicks));
			case COMBO_FOOD:
				return new ConsumableItemCooldown(comboEatCooldownTicks, cooldownTicksToClientTicks(comboEatCooldownTicks));
		}

		return null;
	}

	public ConsumableItemCooldown getFullTimeUntilDelayedHeal()
	{
		if (type != ConsumableItemType.OVERTIME_FOOD)
		{
			return null;
		}

		return new ConsumableItemCooldown(delayedHealTicks, cooldownTicksToClientTicks(delayedHealTicks));
	}

	/**
	 * Converts game ticks to client ticks. The given tick count is decremented by 1 to account that the first tick
	 * is already done when the client notices the item is consumed.
	 *
	 * @param tickCount consumable cooldown in game ticks
	 * @return client ticks count
	 */
	public int cooldownTicksToClientTicks(int tickCount)
	{
		return ((tickCount - 1) * Constants.GAME_TICK_LENGTH) / Constants.CLIENT_TICK_LENGTH;
	}
}
/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;

import com.google.common.collect.ImmutableSet;
import java.util.Set;
import net.runelite.api.ItemID;

public class ConsumableItemIds
{
	public static final Set<Integer> OVERTIME_FOOD_ITEM_IDS = ImmutableSet.of(
		ItemID.COOKED_WILD_KEBBIT,
		ItemID.COOKED_LARUPIA,
		ItemID.COOKED_BARBTAILED_KEBBIT,
		ItemID.COOKED_GRAAHK,
		ItemID.COOKED_KYATT,
		ItemID.COOKED_PYRE_FOX,
		ItemID.COOKED_SUNLIGHT_ANTELOPE,
		ItemID.COOKED_DASHING_KEBBIT,
		ItemID.COOKED_MOONLIGHT_ANTELOPE
	);
	public static final Set<Integer> FOOD_ITEM_IDS = ImmutableSet.of(
		ItemID.ANGLERFISH, ItemID.BLIGHTED_ANGLERFISH,
		ItemID.DARK_CRAB,
		ItemID.TUNA_POTATO,
		ItemID.MANTA_RAY, ItemID.BLIGHTED_MANTA_RAY,
		ItemID.SEA_TURTLE,
		ItemID.SHARK, ItemID.SHARK_6969, ItemID.SHARK_20390,
		ItemID.PADDLEFISH,
		ItemID.PYSK_FISH_0, ItemID.SUPHI_FISH_1, ItemID.LECKISH_FISH_2, ItemID.BRAWK_FISH_3, ItemID.MYCIL_FISH_4, ItemID.ROQED_FISH_5, ItemID.KYREN_FISH_6,
		ItemID.GUANIC_BAT_0, ItemID.PRAEL_BAT_1, ItemID.GIRAL_BAT_2, ItemID.PHLUXIA_BAT_3, ItemID.KRYKET_BAT_4, ItemID.MURNG_BAT_5, ItemID.PSYKK_BAT_6,
		ItemID.UGTHANKI_KEBAB, ItemID.UGTHANKI_KEBAB_1885, ItemID.SUPER_KEBAB,
		ItemID.MUSHROOM_POTATO,
		ItemID.CURRY,
		ItemID.EGG_POTATO,
		ItemID.POTATO_WITH_CHEESE,
		ItemID.MONKFISH, ItemID.MONKFISH_20547,
		ItemID.COOKED_JUBBLY,
		ItemID.COOKED_OOMLIE_WRAP,
		ItemID.CHILLI_POTATO,
		ItemID.POTATO_WITH_BUTTER,
		ItemID.SWORDFISH,
		ItemID.BASS,
		ItemID.TUNA_AND_CORN,
		ItemID.LOBSTER,
		ItemID.STEW,
		ItemID.JUG_OF_WINE,
		ItemID.LAVA_EEL,
		ItemID.CAVE_EEL,
		ItemID.MUSHROOM__ONION,
		ItemID.RAINBOW_FISH,
		ItemID.COOKED_FISHCAKE,
		ItemID.COOKED_CHOMPY, ItemID.COOKED_CHOMPY_7228,
		ItemID.COOKED_SWEETCORN, ItemID.SWEETCORN_7088,
		ItemID.KEBAB,
		ItemID.DRAGONFRUIT,
		ItemID.TUNA, ItemID.CHOPPED_TUNA,
		ItemID.SALMON,
		ItemID.EGG_AND_TOMATO,
		ItemID.PEACH,
		ItemID.COOKED_SLIMY_EEL,
		ItemID.PIKE,
		ItemID.COD,
		ItemID.ROAST_BEAST_MEAT,
		ItemID.TROUT,
		ItemID.PAPAYA_FRUIT,
		ItemID.SPIDER_ON_STICK, ItemID.SPIDER_ON_STICK_6297, ItemID.SPIDER_ON_SHAFT, ItemID.SPIDER_ON_SHAFT_6299, ItemID.SPIDER_ON_SHAFT_6303,
		ItemID.FAT_SNAIL_MEAT,
		ItemID.MACKEREL,
		ItemID.GIANT_CARP,
		ItemID.ROAST_BIRD_MEAT,
		ItemID.FROG_SPAWN,
		ItemID.COOKED_MYSTERY_MEAT,
		ItemID.COOKED_RABBIT,
		ItemID.CHILLI_CON_CARNE,
		ItemID.FRIED_MUSHROOMS,
		ItemID.FRIED_ONIONS,
		ItemID.SCRAMBLED_EGG,
		ItemID.HERRING,
		ItemID.THIN_SNAIL_MEAT, ItemID.LEAN_SNAIL_MEAT,
		ItemID.BREAD,
		ItemID.BAKED_POTATO,
		ItemID.ONION__TOMATO,
		ItemID.SLICE_OF_CAKE, ItemID.CHOCOLATE_SLICE,
		ItemID.SARDINE,
		ItemID.UGTHANKI_MEAT,
		ItemID.COOKED_MEAT, ItemID.COOKED_MEAT_4293,
		ItemID.COOKED_CHICKEN, ItemID.COOKED_CHICKEN_4291,
		ItemID.SPICY_SAUCE,
		ItemID.CHEESE,
		ItemID.SPICY_MINCED_MEAT,
		ItemID.MINCED_MEAT,
		ItemID.BANANA, ItemID.SLICED_BANANA,
		ItemID.TOMATO, ItemID.CHOPPED_TOMATO, ItemID.SPICY_TOMATO,
		ItemID.ANCHOVIES,
		ItemID.SHRIMPS,
		ItemID.POTATO,
		ItemID.WATERMELON_SLICE, ItemID.PINEAPPLE_RING, ItemID.PINEAPPLE_CHUNKS,
		ItemID.ONION, ItemID.CHOPPED_ONION,
		ItemID.ORANGE, ItemID.ORANGE_SLICES,
		ItemID.STRAWBERRY,
		ItemID.CABBAGE,
		ItemID.MINT_CAKE,
		ItemID.PURPLE_SWEETS, ItemID.PURPLE_SWEETS_10476,
		ItemID.HONEY_LOCUST,
		ItemID.BANDAGES, ItemID.BANDAGES_25730,
		ItemID.STRANGE_FRUIT,
		ItemID.WHITE_TREE_FRUIT,
		ItemID.GOUT_TUBER,
		ItemID.JANGERBERRIES,
		ItemID.DWELLBERRIES,
		ItemID.CAVE_NIGHTSHADE,
		ItemID.POT_OF_CREAM,
		ItemID.EQUA_LEAVES,
		ItemID.EDIBLE_SEAWEED,
		ItemID.SCARRED_SCRAPS,
		ItemID.RATIONS,
		ItemID.BAT_SHISH,
		ItemID.COATED_FROGS_LEGS,
		ItemID.FINGERS,
		ItemID.FROGBURGER,
		ItemID.FROGSPAWN_GUMBO,
		ItemID.GREEN_GLOOP_SOUP,
		ItemID.COOKED_BREAM, ItemID.COOKED_MOSS_LIZARD,
		// These brews work as food
		ItemID.CUP_OF_TEA, ItemID.CUP_OF_TEA_1978, ItemID.CUP_OF_TEA_4242, ItemID.CUP_OF_TEA_4243, ItemID.CUP_OF_TEA_4245, ItemID.CUP_OF_TEA_4246,
		ItemID.CUP_OF_TEA_4838, ItemID.CUP_OF_TEA_7730, ItemID.CUP_OF_TEA_7731, ItemID.CUP_OF_TEA_7733, ItemID.CUP_OF_TEA_7734, ItemID.CUP_OF_TEA_7736, ItemID.CUP_OF_TEA_7737,
		ItemID.NETTLE_TEA, ItemID.NETTLE_TEA_4240, ItemID.CHOCOLATEY_MILK, ItemID.TEA_FLASK, ItemID.TEA_FLASK_25617,
		ItemID.DWARVEN_STOUT, ItemID.DWARVEN_STOUTM, ItemID.DWARVEN_STOUT4, ItemID.DWARVEN_STOUT3, ItemID.DWARVEN_STOUT2, ItemID.DWARVEN_STOUT1,
		ItemID.WIZARDS_MIND_BOMB, ItemID.MIND_BOMB4, ItemID.MIND_BOMB3, ItemID.MIND_BOMB2, ItemID.MIND_BOMB1,
		ItemID.MIND_BOMBM4, ItemID.MIND_BOMBM3, ItemID.MIND_BOMBM2, ItemID.MIND_BOMBM1,
		ItemID.CIDER, ItemID.CIDER_7752, ItemID.CIDER4, ItemID.CIDER3, ItemID.CIDER2, ItemID.CIDER1,
		ItemID.CIDERM4, ItemID.CIDERM3, ItemID.CIDERM2, ItemID.CIDERM1, ItemID.MATURE_CIDER,
		ItemID.SLAYERS_RESPITE, ItemID.SLAYERS_RESPITEM, ItemID.SLAYERS_RESPITE4, ItemID.SLAYERS_RESPITE3, ItemID.SLAYERS_RESPITE2, ItemID.SLAYERS_RESPITE1,
		ItemID.SLAYERS_RESPITEM4, ItemID.SLAYERS_RESPITEM3, ItemID.SLAYERS_RESPITEM2, ItemID.SLAYERS_RESPITEM1,
		ItemID.MOONLIGHT_MEAD, ItemID.MOONLIGHT_MEAD_7750, ItemID.MOONLIGHT_MEAD4, ItemID.MOONLIGHT_MEAD3, ItemID.MOONLIGHT_MEAD2, ItemID.MOONLIGHT_MEAD1,
		ItemID.MOONLIGHT_MEADM, ItemID.MOONLIGHT_MEADM4, ItemID.MOONLIGHT_MEADM3, ItemID.MOONLIGHT_MEADM2, ItemID.MOONLIGHT_MEADM1,
		ItemID.DRAGON_BITTER, ItemID.DRAGON_BITTERM, ItemID.DRAGON_BITTERM4, ItemID.DRAGON_BITTERM3, ItemID.DRAGON_BITTERM2, ItemID.DRAGON_BITTERM1,
		ItemID.DRAGON_BITTER_7748, ItemID.DRAGON_BITTER_8243, ItemID.DRAGON_BITTER_8524, ItemID.DRAGON_BITTER4, ItemID.DRAGON_BITTER3, ItemID.DRAGON_BITTER2, ItemID.DRAGON_BITTER1,
		ItemID.CHEFS_DELIGHT, ItemID.CHEFS_DELIGHTM, ItemID.CHEFS_DELIGHTM4, ItemID.CHEFS_DELIGHTM3, ItemID.CHEFS_DELIGHTM2, ItemID.CHEFS_DELIGHTM1,
		ItemID.CHEFS_DELIGHT4, ItemID.CHEFS_DELIGHT3, ItemID.CHEFS_DELIGHT2, ItemID.CHEFS_DELIGHT1,
		ItemID.CHEFS_DELIGHT_7754, ItemID.CHEFS_DELIGHT_8244, ItemID.CHEFS_DELIGHT_8526,
		ItemID.AXEMANS_FOLLY, ItemID.AXEMANS_FOLLYM, ItemID.AXEMANS_FOLLYM4, ItemID.AXEMANS_FOLLYM3, ItemID.AXEMANS_FOLLYM2, ItemID.AXEMANS_FOLLYM1,
		ItemID.AXEMANS_FOLLY4, ItemID.AXEMANS_FOLLY3, ItemID.AXEMANS_FOLLY2, ItemID.AXEMANS_FOLLY1,
		ItemID.ASGARNIAN_ALE, ItemID.ASGARNIAN_ALE_7744, ItemID.ASGARNIAN_ALE_8241, ItemID.ASGARNIAN_ALE_8520,
		ItemID.ASGARNIAN_ALEM4, ItemID.ASGARNIAN_ALEM3, ItemID.ASGARNIAN_ALEM2, ItemID.ASGARNIAN_ALEM1,
		ItemID.ASGARNIAN_ALE4, ItemID.ASGARNIAN_ALE3, ItemID.ASGARNIAN_ALE2, ItemID.ASGARNIAN_ALE1,
		ItemID.GREENMANS_ALE, ItemID.GREENMANS_ALE_7746, ItemID.GREENMANS_ALE_8242, ItemID.GREENMANS_ALE_8522,
		ItemID.GREENMANS_ALEM4, ItemID.GREENMANS_ALEM3, ItemID.GREENMANS_ALEM2, ItemID.GREENMANS_ALEM1,
		ItemID.GREENMANS_ALE4, ItemID.GREENMANS_ALE3, ItemID.GREENMANS_ALE2, ItemID.GREENMANS_ALE1,
		ItemID.LIZARDKICKER, ItemID.GROG,
		ItemID.ELVEN_DAWN, ItemID.BLOODY_BRACER, ItemID.BLOOD_PINT, ItemID.BEER, ItemID.BEER_7740, ItemID.BANDITS_BREW,
		ItemID.SUNBEAM_ALE, ItemID.STEAMFORGE_BREW, ItemID.ECLIPSE_RED, ItemID.MOONLITE, ItemID.SUNSHINE, ItemID.TRAPPERS_TIPPLE,
		ItemID.FRUIT_BLAST, ItemID.FRUIT_BLAST_9514, ItemID.PREMADE_FR_BLAST, ItemID.DIRTY_BLAST, ItemID.PINEAPPLE_PUNCH, ItemID.PINEAPPLE_PUNCH_9512,
		ItemID.PREMADE_P_PUNCH, ItemID.WIZARD_BLIZZARD, ItemID.WIZARD_BLIZZARD_9487, ItemID.WIZARD_BLIZZARD_9489, ItemID.WIZARD_BLIZZARD_9508, ItemID.PREMADE_WIZ_BLZD,
		ItemID.SHORT_GREEN_GUY, ItemID.SHORT_GREEN_GUY_9510, ItemID.PREMADE_SGG, ItemID.DRUNK_DRAGON, ItemID.DRUNK_DRAGON_9516, ItemID.PREMADE_DR_DRAGON,
		ItemID.CHOC_SATURDAY, ItemID.CHOC_SATURDAY_9518, ItemID.PREMADE_CHOC_SDY, ItemID.BLURBERRY_SPECIAL, ItemID.BLURBERRY_SPECIAL_9520, ItemID.PREMADE_BLURB_SP,
		ItemID.WHISKY, ItemID.VODKA, ItemID.KARAMJAN_RUM, ItemID.KARAMJAN_RUM_3164, ItemID.KARAMJAN_RUM_3165,
		ItemID.HALF_FULL_WINE_JUG, ItemID.GIN, ItemID.BRAINDEATH_RUM, ItemID.BRANDY, ItemID.BOTTLE_OF_WINE, ItemID.RUM_28896,
		ItemID.KEG_OF_BEER, ItemID.KEG_OF_BEER_3801, ItemID.KOVACS_GROG, ItemID.BEER_TANKARD,
		ItemID.ARAXYTE_VENOM_SACK, ItemID.BANDAGES_29884, ItemID.VARLAMORIAN_KEBAB,
		ItemID.BLACKBIRD_RED, ItemID.CHILHUAC_RED, ItemID.PRINCIPUM_RED, ItemID.IXCOZTIC_WHITE, ItemID.METZTONALLI_WHITE,
		ItemID.TONAMEYO_WHITE, ItemID.FORTIS_ASH_WHITE, ItemID.IMPERIAL_ROS, ItemID.XOCHIPALTIC_ROS,
		// TODO: Figure out how to handle this accurately
		ItemID.CHUGGING_BARREL,
		net.runelite.api.gameval.ItemID.CAERULA_BERRIES, net.runelite.api.gameval.ItemID.BOWL_DAMIANA_TEA,
		net.runelite.api.gameval.ItemID.BOWL_DAMIANA_TEA_MILKY, net.runelite.api.gameval.ItemID.CUP_DAMIANA_TEA,
		net.runelite.api.gameval.ItemID.CUP_DAMIANA_TEA_MILKY, net.runelite.api.gameval.ItemID.ORANGE_HAT,
		net.runelite.api.gameval.ItemID.BLUEBERRY_MUFFIN, net.runelite.api.gameval.ItemID.EVENT_CORRUPTED_SHARK
	);
	public static final Set<Integer> DRINK_ITEM_IDS = ImmutableSet.of(
		ItemID.GUTHIX_REST4, ItemID.GUTHIX_REST3, ItemID.GUTHIX_REST2, ItemID.GUTHIX_REST1,
		ItemID.ATTACK_POTION4, ItemID.ATTACK_POTION3, ItemID.ATTACK_POTION2, ItemID.ATTACK_POTION1,
		ItemID.ATTACK_MIX2, ItemID.ATTACK_MIX1, ItemID.SUPERATTACK_MIX2, ItemID.SUPERATTACK_MIX1,
		ItemID.SUPER_ATTACK4, ItemID.SUPER_ATTACK3, ItemID.SUPER_ATTACK2, ItemID.SUPER_ATTACK1,
		ItemID.DIVINE_SUPER_ATTACK_POTION4, ItemID.DIVINE_SUPER_ATTACK_POTION3, ItemID.DIVINE_SUPER_ATTACK_POTION2, ItemID.DIVINE_SUPER_ATTACK_POTION1,
		ItemID.STRENGTH_POTION4, ItemID.STRENGTH_POTION3, ItemID.STRENGTH_POTION2, ItemID.STRENGTH_POTION1,
		ItemID.STRENGTH_MIX2, ItemID.STRENGTH_MIX1, ItemID.SUPER_STR_MIX2, ItemID.SUPER_STR_MIX1,
		ItemID.SUPER_STRENGTH4, ItemID.SUPER_STRENGTH3, ItemID.SUPER_STRENGTH2, ItemID.SUPER_STRENGTH1,
		ItemID.DIVINE_SUPER_STRENGTH_POTION4, ItemID.DIVINE_SUPER_STRENGTH_POTION3, ItemID.DIVINE_SUPER_STRENGTH_POTION2, ItemID.DIVINE_SUPER_STRENGTH_POTION1,
		ItemID.DEFENCE_POTION4, ItemID.DEFENCE_POTION3, ItemID.DEFENCE_POTION2, ItemID.DEFENCE_POTION1,
		ItemID.DEFENCE_MIX2, ItemID.DEFENCE_MIX1, ItemID.SUPER_DEF_MIX2, ItemID.SUPER_DEF_MIX1,
		ItemID.SUPER_DEFENCE4, ItemID.SUPER_DEFENCE3, ItemID.SUPER_DEFENCE2, ItemID.SUPER_DEFENCE1,
		ItemID.DIVINE_SUPER_DEFENCE_POTION4, ItemID.DIVINE_SUPER_DEFENCE_POTION3, ItemID.DIVINE_SUPER_DEFENCE_POTION2, ItemID.DIVINE_SUPER_DEFENCE_POTION1,
		ItemID.COMBAT_POTION4, ItemID.COMBAT_POTION3, ItemID.COMBAT_POTION2, ItemID.COMBAT_POTION1,
		ItemID.COMBAT_POTION4_26150, ItemID.COMBAT_POTION3_26151, ItemID.COMBAT_POTION2_26152, ItemID.COMBAT_POTION1_26153,
		ItemID.COMBAT_MIX2, ItemID.COMBAT_MIX1,
		ItemID.SUPER_COMBAT_POTION4, ItemID.SUPER_COMBAT_POTION3, ItemID.SUPER_COMBAT_POTION2, ItemID.SUPER_COMBAT_POTION1,
		ItemID.SUPER_COMBAT_POTION4_23543, ItemID.SUPER_COMBAT_POTION3_23545, ItemID.SUPER_COMBAT_POTION2_23547, ItemID.SUPER_COMBAT_POTION1_23549,
		ItemID.DIVINE_SUPER_COMBAT_POTION4, ItemID.DIVINE_SUPER_COMBAT_POTION3, ItemID.DIVINE_SUPER_COMBAT_POTION2, ItemID.DIVINE_SUPER_COMBAT_POTION1,
		ItemID.RANGING_POTION4, ItemID.RANGING_POTION3, ItemID.RANGING_POTION2, ItemID.RANGING_POTION1,
		ItemID.RANGING_POTION4_23551, ItemID.RANGING_POTION3_23553, ItemID.RANGING_POTION2_23555, ItemID.RANGING_POTION1_23557,
		ItemID.RANGING_MIX2, ItemID.RANGING_MIX1,
		ItemID.SUPER_RANGING_4, ItemID.SUPER_RANGING_3, ItemID.SUPER_RANGING_2, ItemID.SUPER_RANGING_1,
		ItemID.DIVINE_RANGING_POTION4, ItemID.DIVINE_RANGING_POTION3, ItemID.DIVINE_RANGING_POTION2, ItemID.DIVINE_RANGING_POTION1,
		ItemID.BASTION_POTION4, ItemID.BASTION_POTION3, ItemID.BASTION_POTION2, ItemID.BASTION_POTION1,
		ItemID.DIVINE_BASTION_POTION4, ItemID.DIVINE_BASTION_POTION3, ItemID.DIVINE_BASTION_POTION2, ItemID.DIVINE_BASTION_POTION1,
		ItemID.STAMINA_POTION4, ItemID.STAMINA_POTION3, ItemID.STAMINA_POTION2, ItemID.STAMINA_POTION1,
		ItemID.STAMINA_POTION4_23583, ItemID.STAMINA_POTION3_23585, ItemID.STAMINA_POTION2_23587, ItemID.STAMINA_POTION1_23589,
		ItemID.STAMINA_MIX2, ItemID.STAMINA_MIX1,
		ItemID.SUPER_ENERGY4, ItemID.SUPER_ENERGY3, ItemID.SUPER_ENERGY2, ItemID.SUPER_ENERGY1,
		ItemID.SUPER_ENERGY_MIX2, ItemID.SUPER_ENERGY_MIX1,
		ItemID.SUPER_ENERGY4_20548, ItemID.SUPER_ENERGY3_20549, ItemID.SUPER_ENERGY2_20550, ItemID.SUPER_ENERGY1_20551,
		ItemID.ENERGY_POTION4, ItemID.ENERGY_POTION3, ItemID.ENERGY_POTION2, ItemID.ENERGY_POTION1,
		ItemID.ENERGY_MIX2, ItemID.ENERGY_MIX1,
		ItemID.ANTIDOTE4, ItemID.ANTIDOTE3, ItemID.ANTIDOTE2, ItemID.ANTIDOTE1,
		ItemID.ANTIDOTE_MIX2, ItemID.ANTIDOTE_MIX1,
		ItemID.ANTIDOTE4_5952, ItemID.ANTIDOTE3_5954, ItemID.ANTIDOTE2_5956, ItemID.ANTIDOTE1_5958,
		ItemID.SUPERANTIPOISON4, ItemID.SUPERANTIPOISON3, ItemID.SUPERANTIPOISON2, ItemID.SUPERANTIPOISON1,
		ItemID.ANTIPOISON_SUPERMIX2, ItemID.ANTIPOISON_SUPERMIX1,
		ItemID.ANTIPOISON4, ItemID.ANTIPOISON3, ItemID.ANTIPOISON2, ItemID.ANTIPOISON1,
		ItemID.ANTIPOISON_MIX2, ItemID.ANTIPOISON_MIX1,
		ItemID.ANTIVENOM4, ItemID.ANTIVENOM3, ItemID.ANTIVENOM2, ItemID.ANTIVENOM1,
		ItemID.ANTIVENOM4_12913, ItemID.ANTIVENOM3_12915, ItemID.ANTIVENOM2_12917, ItemID.ANTIVENOM1_12919,
		ItemID.SARADOMIN_BREW4, ItemID.SARADOMIN_BREW3, ItemID.SARADOMIN_BREW2, ItemID.SARADOMIN_BREW1,
		ItemID.SARADOMIN_BREW4_23575, ItemID.SARADOMIN_BREW3_23577, ItemID.SARADOMIN_BREW2_23579, ItemID.SARADOMIN_BREW1_23581,
		ItemID.SUPER_RESTORE4, ItemID.SUPER_RESTORE3, ItemID.SUPER_RESTORE2, ItemID.SUPER_RESTORE1,
		ItemID.SUPER_RESTORE4_23567, ItemID.SUPER_RESTORE3_23569, ItemID.SUPER_RESTORE2_23571, ItemID.SUPER_RESTORE1_23573,
		ItemID.SUPER_RESTORE_MIX2, ItemID.SUPER_RESTORE_MIX1,
		ItemID.BLIGHTED_SUPER_RESTORE4, ItemID.BLIGHTED_SUPER_RESTORE3, ItemID.BLIGHTED_SUPER_RESTORE2, ItemID.BLIGHTED_SUPER_RESTORE1,
		ItemID.RESTORE_POTION4, ItemID.RESTORE_POTION3, ItemID.RESTORE_POTION2, ItemID.RESTORE_POTION1,
		ItemID.RESTORE_MIX2, ItemID.RESTORE_MIX1,
		ItemID.SANFEW_SERUM4, ItemID.SANFEW_SERUM3, ItemID.SANFEW_SERUM2, ItemID.SANFEW_SERUM1,
		ItemID.SANFEW_SERUM4_23559, ItemID.SANFEW_SERUM3_23561, ItemID.SANFEW_SERUM2_23563, ItemID.SANFEW_SERUM1_23565,
		ItemID.PRAYER_POTION4, ItemID.PRAYER_POTION3, ItemID.PRAYER_POTION2, ItemID.PRAYER_POTION1,
		ItemID.PRAYER_POTION4_20393, ItemID.PRAYER_POTION3_20394, ItemID.PRAYER_POTION2_20395, ItemID.PRAYER_POTION1_20396,
		ItemID.PRAYER_MIX2, ItemID.PRAYER_MIX1,
		ItemID.MAGIC_POTION4, ItemID.MAGIC_POTION3, ItemID.MAGIC_POTION2, ItemID.MAGIC_POTION1,
		ItemID.MAGIC_MIX2, ItemID.MAGIC_MIX1,
		ItemID.SUPER_MAGIC_POTION_4, ItemID.SUPER_MAGIC_POTION_3, ItemID.SUPER_MAGIC_POTION_2, ItemID.SUPER_MAGIC_POTION_1,
		ItemID.DIVINE_MAGIC_POTION4, ItemID.DIVINE_MAGIC_POTION3, ItemID.DIVINE_MAGIC_POTION2, ItemID.DIVINE_MAGIC_POTION1,
		ItemID.MAGIC_ESSENCE4, ItemID.MAGIC_ESSENCE3, ItemID.MAGIC_ESSENCE2, ItemID.MAGIC_ESSENCE1,
		ItemID.MAGIC_ESSENCE_MIX2, ItemID.MAGIC_ESSENCE_MIX1,
		ItemID.ANTIFIRE_POTION4, ItemID.ANTIFIRE_POTION3, ItemID.ANTIFIRE_POTION2, ItemID.ANTIFIRE_POTION1,
		ItemID.ANTIFIRE_MIX2, ItemID.ANTIFIRE_MIX1,
		ItemID.EXTENDED_ANTIFIRE4, ItemID.EXTENDED_ANTIFIRE3, ItemID.EXTENDED_ANTIFIRE2, ItemID.EXTENDED_ANTIFIRE1,
		ItemID.EXTENDED_ANTIFIRE_MIX2, ItemID.EXTENDED_ANTIFIRE_MIX1,
		ItemID.SUPER_ANTIFIRE_POTION4, ItemID.SUPER_ANTIFIRE_POTION3, ItemID.SUPER_ANTIFIRE_POTION2, ItemID.SUPER_ANTIFIRE_POTION1,
		ItemID.SUPER_ANTIFIRE_MIX2, ItemID.SUPER_ANTIFIRE_MIX1,
		ItemID.EXTENDED_SUPER_ANTIFIRE4, ItemID.EXTENDED_SUPER_ANTIFIRE3, ItemID.EXTENDED_SUPER_ANTIFIRE2, ItemID.EXTENDED_SUPER_ANTIFIRE1,
		ItemID.EXTENDED_SUPER_ANTIFIRE_MIX2, ItemID.EXTENDED_SUPER_ANTIFIRE_MIX1,
		ItemID.ANCIENT_BREW4, ItemID.ANCIENT_BREW3, ItemID.ANCIENT_BREW2, ItemID.ANCIENT_BREW1,
		ItemID.ANCIENT_MIX2, ItemID.ANCIENT_MIX1,
		ItemID.FORGOTTEN_BREW4, ItemID.FORGOTTEN_BREW3, ItemID.FORGOTTEN_BREW2, ItemID.FORGOTTEN_BREW1,
		ItemID.ZAMORAK_BREW4, ItemID.ZAMORAK_BREW3, ItemID.ZAMORAK_BREW2, ItemID.ZAMORAK_BREW1,
		ItemID.ZAMORAK_MIX2, ItemID.ZAMORAK_MIX1,
		ItemID.RELICYMS_BALM4, ItemID.RELICYMS_BALM3, ItemID.RELICYMS_BALM2, ItemID.RELICYMS_BALM1,
		ItemID.RELICYMS_MIX2, ItemID.RELICYMS_MIX1,
		ItemID.MENAPHITE_REMEDY4, ItemID.MENAPHITE_REMEDY3, ItemID.MENAPHITE_REMEDY2, ItemID.MENAPHITE_REMEDY1,
		ItemID.BATTLEMAGE_POTION4, ItemID.BATTLEMAGE_POTION3, ItemID.BATTLEMAGE_POTION2, ItemID.BATTLEMAGE_POTION1,
		ItemID.DIVINE_BATTLEMAGE_POTION4, ItemID.DIVINE_BATTLEMAGE_POTION3, ItemID.DIVINE_BATTLEMAGE_POTION2, ItemID.DIVINE_BATTLEMAGE_POTION1,
		ItemID.HUNTER_POTION4, ItemID.HUNTER_POTION3, ItemID.HUNTER_POTION2, ItemID.HUNTER_POTION1,
		ItemID.HUNTING_MIX2, ItemID.HUNTING_MIX1,
		ItemID.AGILITY_POTION4, ItemID.AGILITY_POTION3, ItemID.AGILITY_POTION2, ItemID.AGILITY_POTION1,
		ItemID.AGILITY_MIX2, ItemID.AGILITY_MIX1,
		ItemID.FISHING_POTION4, ItemID.FISHING_POTION3, ItemID.FISHING_POTION2, ItemID.FISHING_POTION1,
		ItemID.FISHING_MIX2, ItemID.FISHING_MIX1,
		ItemID.PRAYER_ENHANCE_4, ItemID.PRAYER_ENHANCE_3, ItemID.PRAYER_ENHANCE_2, ItemID.PRAYER_ENHANCE_1,
		ItemID.PRAYER_ENHANCE_4_20968, ItemID.PRAYER_ENHANCE_3_20967, ItemID.PRAYER_ENHANCE_2_20966, ItemID.PRAYER_ENHANCE_1_20965,
		ItemID.PRAYER_ENHANCE_4_20972, ItemID.PRAYER_ENHANCE_3_20971, ItemID.PRAYER_ENHANCE_2_20970, ItemID.PRAYER_ENHANCE_1_20969,
		ItemID.XERICS_AID_4, ItemID.XERICS_AID_3, ItemID.XERICS_AID_2, ItemID.XERICS_AID_1,
		ItemID.XERICS_AID_4_20980, ItemID.XERICS_AID_3_20979, ItemID.XERICS_AID_2_20978, ItemID.XERICS_AID_1_20977,
		ItemID.XERICS_AID_4_20984, ItemID.XERICS_AID_3_20983, ItemID.XERICS_AID_2_20982, ItemID.XERICS_AID_1_20981,
		ItemID.REVITALISATION_4, ItemID.REVITALISATION_3, ItemID.REVITALISATION_2, ItemID.REVITALISATION_1,
		ItemID.REVITALISATION_4_20960, ItemID.REVITALISATION_3_20959, ItemID.REVITALISATION_2_20958, ItemID.REVITALISATION_1_20957,
		ItemID.REVITALISATION_POTION_4, ItemID.REVITALISATION_POTION_3, ItemID.REVITALISATION_POTION_2, ItemID.REVITALISATION_POTION_1,
		ItemID.TWISTED_POTION_4, ItemID.TWISTED_POTION_3, ItemID.TWISTED_POTION_2, ItemID.TWISTED_POTION_1,
		ItemID.TWISTED_4, ItemID.TWISTED_3, ItemID.TWISTED_2, ItemID.TWISTED_1,
		ItemID.TWISTED_4_20936, ItemID.TWISTED_3_20935, ItemID.TWISTED_2_20934, ItemID.TWISTED_1_20933,
		ItemID.ELDER_POTION_4, ItemID.ELDER_POTION_3, ItemID.ELDER_POTION_2, ItemID.ELDER_POTION_1,
		ItemID.ELDER_4, ItemID.ELDER_3, ItemID.ELDER_2, ItemID.ELDER_1,
		ItemID.ELDER_4_20924, ItemID.ELDER_3_20923, ItemID.ELDER_2_20922, ItemID.ELDER_1_20921,
		ItemID.KODAI_POTION_4, ItemID.KODAI_POTION_3, ItemID.KODAI_POTION_2, ItemID.KODAI_POTION_1,
		ItemID.KODAI_4, ItemID.KODAI_3, ItemID.KODAI_2, ItemID.KODAI_1,
		ItemID.KODAI_4_20948, ItemID.KODAI_3_20947, ItemID.KODAI_2_20946, ItemID.KODAI_1_20945,
		ItemID.ANTIPOISON_POTION_4, ItemID.ANTIPOISON_POTION_3, ItemID.ANTIPOISON_POTION_2, ItemID.ANTIPOISON_POTION_1,
		ItemID.OVERLOAD_4, ItemID.OVERLOAD_3, ItemID.OVERLOAD_2, ItemID.OVERLOAD_1,
		ItemID.OVERLOAD_4_20988, ItemID.OVERLOAD_3_20987, ItemID.OVERLOAD_2_20986, ItemID.OVERLOAD_1_20985,
		ItemID.OVERLOAD_4_20992, ItemID.OVERLOAD_3_20991, ItemID.OVERLOAD_2_20990, ItemID.OVERLOAD_1_20989,
		ItemID.OVERLOAD_4_20996, ItemID.OVERLOAD_3_20995, ItemID.OVERLOAD_2_20994, ItemID.OVERLOAD_1_20993,
		ItemID.TEARS_OF_ELIDINIS_4, ItemID.TEARS_OF_ELIDINIS_3, ItemID.TEARS_OF_ELIDINIS_2, ItemID.TEARS_OF_ELIDINIS_1,
		ItemID.NECTAR_4, ItemID.NECTAR_3, ItemID.NECTAR_2, ItemID.NECTAR_1,
		ItemID.BLESSED_CRYSTAL_SCARAB_2, ItemID.BLESSED_CRYSTAL_SCARAB_1,
		ItemID.SMELLING_SALTS_2, ItemID.SMELLING_SALTS_1,
		ItemID.LIQUID_ADRENALINE_2, ItemID.LIQUID_ADRENALINE_1,
		ItemID.EGNIOL_POTION_4, ItemID.EGNIOL_POTION_3, ItemID.EGNIOL_POTION_2, ItemID.EGNIOL_POTION_1,
		ItemID.CASTLEWARS_BREW4, ItemID.CASTLEWARS_BREW3, ItemID.CASTLEWARS_BREW2, ItemID.CASTLEWARS_BREW1,
		ItemID.POTION_OF_POWER4, ItemID.POTION_OF_POWER3, ItemID.POTION_OF_POWER2, ItemID.POTION_OF_POWER1,
		ItemID.WINTER_SQIRKJUICE, ItemID.SPRING_SQIRKJUICE, ItemID.SUMMER_SQIRKJUICE, ItemID.AUTUMN_SQIRKJUICE,
		ItemID.SHRINKMEQUICK, ItemID.BRAVERY_POTION, ItemID.STRANGE_POTION_28383, ItemID.STRANGLER_SERUM,
		ItemID.SAPPHIRE_GLACIALIS_MIX_2, ItemID.SAPPHIRE_GLACIALIS_MIX_1,
		ItemID.SNOWY_KNIGHT_MIX_2, ItemID.SNOWY_KNIGHT_MIX_1,
		ItemID.RUBY_HARVEST_MIX_2, ItemID.RUBY_HARVEST_MIX_1,
		ItemID.BLACK_WARLOCK_MIX_2, ItemID.BLACK_WARLOCK_MIX_1,
		ItemID.SUNLIGHT_MOTH_MIX_2, ItemID.SUNLIGHT_MOTH_MIX_1,
		ItemID.MOONLIGHT_MOTH_MIX_2, ItemID.MOONLIGHT_MOTH_MIX_1,
		ItemID.MOONLIGHT_POTION4, ItemID.MOONLIGHT_POTION3, ItemID.MOONLIGHT_POTION2, ItemID.MOONLIGHT_POTION1,
		ItemID.BLIGHTED_OVERLOAD_4, ItemID.BLIGHTED_OVERLOAD_3, ItemID.BLIGHTED_OVERLOAD_2, ItemID.BLIGHTED_OVERLOAD_1,
		ItemID.EXTENDED_ANTIVENOM4, ItemID.EXTENDED_ANTIVENOM3, ItemID.EXTENDED_ANTIVENOM2, ItemID.EXTENDED_ANTIVENOM1,
		ItemID.PRAYER_REGENERATION_POTION4, ItemID.PRAYER_REGENERATION_POTION3, ItemID.PRAYER_REGENERATION_POTION2, ItemID.PRAYER_REGENERATION_POTION1,
		ItemID.GOADING_POTION4, ItemID.GOADING_POTION3, ItemID.GOADING_POTION2, ItemID.GOADING_POTION1,
		net.runelite.api.gameval.ItemID._4DOSESURGE, net.runelite.api.gameval.ItemID._3DOSESURGE, net.runelite.api.gameval.ItemID._2DOSESURGE, net.runelite.api.gameval.ItemID._1DOSESURGE
	);
	public static final Set<Integer> COMBO_FOOD_ITEM_IDS = ImmutableSet.of(
		ItemID.COOKED_KARAMBWAN, ItemID.COOKED_KARAMBWAN_3147, ItemID.COOKED_KARAMBWAN_23533, ItemID.BLIGHTED_KARAMBWAN, ItemID.CRYSTAL_PADDLEFISH,
		ItemID.TOAD_CRUNCHIES, ItemID.TOAD_CRUNCHIES_9538, ItemID.PREMADE_TD_CRUNCH, ItemID.SPICY_CRUNCHIES, ItemID.SPICY_CRUNCHIES_9540,
		ItemID.PREMADE_SY_CRUNCH, ItemID.WORM_CRUNCHIES, ItemID.PREMADE_WM_CRUN, ItemID.CHOCCHIP_CRUNCHIES, ItemID.PREMADE_CH_CRUNCH,
		ItemID.FRUIT_BATTA, ItemID.FRUIT_BATTA_9527, ItemID.PREMADE_FRT_BATTA, ItemID.TOAD_BATTA, ItemID.TOAD_BATTA_9529,
		ItemID.PREMADE_TD_BATTA, ItemID.WORM_BATTA, ItemID.WORM_BATTA_9531, ItemID.PREMADE_WM_BATTA, ItemID.VEGETABLE_BATTA,
		ItemID.VEGETABLE_BATTA_9533, ItemID.PREMADE_VEG_BATTA, ItemID.CHEESETOM_BATTA, ItemID.CHEESETOM_BATTA_9535, ItemID.PREMADE_CT_BATTA,
		ItemID.WORM_HOLE, ItemID.WORM_HOLE_9547, ItemID.PREMADE_WORM_HOLE, ItemID.VEG_BALL, ItemID.VEG_BALL_9549, ItemID.PREMADE_VEG_BALL,
		ItemID.CHOCOLATE_BOMB, ItemID.CHOCOLATE_BOMB_9553, ItemID.PREMADE_CHOC_BOMB, ItemID.TANGLED_TOADS_LEGS, ItemID.TANGLED_TOADS_LEGS_9551,
		ItemID.PREMADE_TTL, ItemID.TOADS_LEGS, ItemID.KING_WORM
	);
	public static final Set<Integer> CAKE_ITEM_IDS = ImmutableSet.of(
		ItemID.CAKE, ItemID.CAKE_24549, ItemID.CHOCOLATE_CAKE, ItemID._23_CAKE, ItemID._23_CHOCOLATE_CAKE
	);
	public static final Set<Integer> F2P_FIRST_SLICE_ITEM_IDS = ImmutableSet.of(
		ItemID.REDBERRY_PIE, ItemID.MEAT_PIE, ItemID.APPLE_PIE, ItemID.PLAIN_PIZZA, ItemID.MEAT_PIZZA, ItemID.ANCHOVY_PIZZA, ItemID.PINEAPPLE_PIZZA
	);
	public static final Set<Integer> F2P_SECOND_SLICE_ITEM_IDS = ImmutableSet.of(
		ItemID.HALF_A_REDBERRY_PIE, ItemID.HALF_A_MEAT_PIE, ItemID._12_PLAIN_PIZZA, ItemID._12_MEAT_PIZZA, ItemID._12_ANCHOVY_PIZZA, ItemID._12_PINEAPPLE_PIZZA
	);
	public static final Set<Integer> P2P_PIE_ITEM_IDS = ImmutableSet.of(
		ItemID.GARDEN_PIE, ItemID.HALF_A_GARDEN_PIE, ItemID.FISH_PIE, ItemID.HALF_A_FISH_PIE, ItemID.BOTANICAL_PIE, ItemID.HALF_A_BOTANICAL_PIE,
		ItemID.MUSHROOM_PIE, ItemID.HALF_A_MUSHROOM_PIE, ItemID.ADMIRAL_PIE, ItemID.HALF_AN_ADMIRAL_PIE, ItemID.DRAGONFRUIT_PIE, ItemID.HALF_A_DRAGONFRUIT_PIE,
		ItemID.WILD_PIE, ItemID.HALF_A_WILD_PIE, ItemID.SUMMER_PIE, ItemID.HALF_A_SUMMER_PIE
	);
	public static final Set<Integer> COOKED_CRAB_MEAT_ITEM_IDS = ImmutableSet.of(
		ItemID.COOKED_GIANT_CRAB_MEAT, ItemID.COOKED_GIANT_CRAB_MEAT_7523, ItemID.COOKED_GIANT_CRAB_MEAT_7524, ItemID.COOKED_GIANT_CRAB_MEAT_7525, ItemID.COOKED_GIANT_CRAB_MEAT_7526
	);
	public static final Set<Integer> NO_DELAY_CONSUMABLE_ITEM_IDS = ImmutableSet.of(
		ItemID.BANDAGES_25202
	);
}

/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;

import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.geom.Rectangle2D;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NullItemID;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.overlay.WidgetItemOverlay;

@Slf4j
public class ConsumableCooldownsTextOverlay extends WidgetItemOverlay
{
	private final ConsumableCooldownsPlugin plugin;
	private final ConsumableCooldownsConfig config;

	@Inject
	public ConsumableCooldownsTextOverlay(ConsumableCooldownsPlugin plugin, ConsumableCooldownsConfig config)
	{
		this.plugin = plugin;
		this.config = config;

		showOnInventory();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
		graphics.setFont(config.getFontType().getFont());
		renderConsumableCooldowns(graphics, widgetItem);
	}

	private void renderConsumableCooldowns(Graphics2D graphics, WidgetItem widgetItem)
	{
		if (plugin.isNoConsumableCooldownActive())
		{
			return;
		}

		Rectangle slotBounds = widgetItem.getCanvasBounds();
		int itemId = widgetItem.getId();

		// Empty inventory item
		if (itemId == NullItemID.NULL_6512)
		{
			return;
		}

		ConsumableItem consumableItem = plugin.getConsumableItemFromId(itemId);
		if (consumableItem == null)
		{
			return;
		}

		ConsumableItemCooldown cooldownRemaining = plugin.getCooldownForConsumableItem(consumableItem);
		if (cooldownRemaining == null)
		{
			return;
		}

		switch (config.cooldownTextMode())
		{
			case GAME_TICKS:
				renderCooldownText(graphics, cooldownRemaining.toGameTicks(), slotBounds);
				break;
			case SECONDS_MILLISECONDS:
				renderCooldownText(graphics, cooldownRemaining.toSecondsMilliseconds(), slotBounds);
				break;
			case NONE:
				break;
		}
	}

	private void renderCooldownText(Graphics2D graphics, String delayText, Rectangle slotBounds)
	{
		if (delayText.equals("0.0"))
		{
			return;
		}

		FontMetrics fm = graphics.getFontMetrics();
		Rectangle2D textBounds = fm.getStringBounds(delayText, graphics);

		int textX = (int) (slotBounds.getX() + (slotBounds.getWidth() / 2) - (textBounds.getWidth() / 2)) - config.getTextXOffset();
		int textY = (int) (slotBounds.getY() + (slotBounds.getHeight() / 2) + (textBounds.getHeight() / 2)) - config.getTextYOffset();

		graphics.setColor(config.getTextShadowColor());
		graphics.drawString(delayText, textX + 1, textY + 1);
		graphics.setColor(config.getTextColor());
		graphics.drawString(delayText, textX, textY);
	}
}
package com.consumablecooldowns;

public enum CooldownIndicatorMode
{
	FILL,
	BOTTOM_TO_TOP,
	PIE,
	NONE
}

/*
 * Copyright (c) 2023, Copy Pasta
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.consumablecooldowns;

import com.google.common.collect.ImmutableSet;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Consumable Cooldowns",
	description = "Displays cooldowns on food & drink items in your inventory",
	tags = {"inventory", "timer", "pvm", "overlay", "cd", "food", "pots", "potion", "highlight"}
)
public class ConsumableCooldownsPlugin extends Plugin
{
	private static final ImmutableSet<ConsumableItem> CONSUMABLES = ImmutableSet.of(
		new ConsumableItem(ConsumableItemType.FOOD, 3, 3, ConsumableItemIds.FOOD_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.OVERTIME_FOOD, 3, 3, 8, ConsumableItemIds.OVERTIME_FOOD_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.DRINK, 0, 3, 0, 3, ConsumableItemIds.DRINK_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.COMBO_FOOD, 2, 3, 3, 3, ConsumableItemIds.COMBO_FOOD_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.CAKE, 3, 2, ConsumableItemIds.CAKE_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.F2P_FIRST_SLICE, 3, 1, ConsumableItemIds.F2P_FIRST_SLICE_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.F2P_SECOND_SLICE, 3, 2, ConsumableItemIds.F2P_SECOND_SLICE_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.P2P_PIE, 3, 1, ConsumableItemIds.P2P_PIE_ITEM_IDS::contains),
		new ConsumableItem(ConsumableItemType.COOKED_CRAB_MEAT, 2, 2, ConsumableItemIds.COOKED_CRAB_MEAT_ITEM_IDS::contains)
	);
	private static final Pattern EAT_PATTERN = Pattern.compile("^eat");
	private static final Pattern DRINK_PATTERN = Pattern.compile("^drink");
	private static final int ITEM_COOLDOWN_PREVIEW_TICKS = 2;
	private static final int ITEM_COOLDOWN_PREVIEW_CLIENT_TICKS = 60;
	private static final int ITEM_COOLDOWN_PREVIEW_GRACE_PERIOD_CLIENT_TICKS = -(Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH);
	private static final int LAST_INVENTORY_SLOT_INDEX = 27;
	private static final boolean SHOULD_LOG_DEBUG = false;

	@Inject
	private Client client;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	protected ConsumableCooldownsConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ConsumableCooldownsOverlay overlay;

	@Inject
	private ConsumableCooldownsTextOverlay textOverlay;

	private int actionCooldownTicks;

	private int eatCooldownTicks;
	private int eatCooldownClientTicks;

	private int drinkCooldownTicks;
	private int drinkCooldownClientTicks;

	private int comboEatCooldownTicks;
	private int comboEatCooldownClientTicks;

	private int ticksTillDelayedHeal;
	private int clientTicksTillDelayedHeal;

	private int previewCooldownTicks;
	private int previewCooldownClientTicks;

	private int lastFoodConsumedTick;
	private ConsumableItem lastFoodConsumed;
	private int lastDrinkConsumedTick;
	private ConsumableItem lastDrinkConsumed;
	private int lastComboFoodConsumedTick;
	private ConsumableItem lastComboFoodConsumed;
	private ConsumableCooldownTimer delayedHealTimer;

	private List<InventoryConsumableItemAction> inventoryConsumableItemActions;

	@Provides
	ConsumableCooldownsConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ConsumableCooldownsConfig.class);
	}

	private void setup()
	{
		actionCooldownTicks = 0;
		eatCooldownTicks = 0;
		comboEatCooldownTicks = 0;
		drinkCooldownTicks = 0;
		ticksTillDelayedHeal = 0;
		eatCooldownClientTicks = 0;
		comboEatCooldownClientTicks = 0;
		drinkCooldownClientTicks = 0;
		clientTicksTillDelayedHeal = 0;
		previewCooldownTicks = ITEM_COOLDOWN_PREVIEW_TICKS;
		previewCooldownClientTicks = ITEM_COOLDOWN_PREVIEW_CLIENT_TICKS;
		lastFoodConsumedTick = -1;
		lastFoodConsumed = null;
		lastDrinkConsumedTick = -1;
		lastDrinkConsumed = null;
		lastComboFoodConsumedTick = -1;
		lastComboFoodConsumed = null;
		delayedHealTimer = null;
	}

	@Override
	protected void startUp() throws Exception
	{
		inventoryConsumableItemActions = new ArrayList<>();
		setup();
		overlayManager.add(overlay);
		overlayManager.add(textOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		inventoryConsumableItemActions = null;
		if (delayedHealTimer != null)
		{
			infoBoxManager.removeInfoBox(delayedHealTimer);
		}

		setup();
		overlayManager.remove(overlay);
		overlayManager.remove(textOverlay);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals(ConsumableCooldownsConfig.GROUP_NAME))
		{
			return;
		}

		switch (event.getKey())
		{
			case "cooldownIndicatorMode":
				overlay.invalidateInventoryIconInfoCache();
				break;
			case "itemCooldownIndicatorFillColor":
			case "itemCooldownIndicatorFillOpacity":
				overlay.invalidateFillCache();
				break;
			case "showDelayedHealInfobox":
				if (delayedHealTimer == null)
				{
					break;
				}

				if (config.showDelayedHealInfobox())
				{
					infoBoxManager.addInfoBox(delayedHealTimer);
					break;
				}

				infoBoxManager.removeInfoBox(delayedHealTimer);
				break;
			case "showItemCooldownPreview":
				if (config.showItemCooldownPreview())
				{
					previewCooldownTicks = ITEM_COOLDOWN_PREVIEW_TICKS;
					previewCooldownClientTicks = ITEM_COOLDOWN_PREVIEW_CLIENT_TICKS;
				}
				break;
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		GameState gameState = event.getGameState();
		if (gameState == GameState.LOGGING_IN || gameState == GameState.CONNECTION_LOST || gameState == GameState.HOPPING)
		{
			inventoryConsumableItemActions.clear();
			setup();
		}
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if (eatCooldownClientTicks > 0)
		{
			eatCooldownClientTicks--;
		}

		if (comboEatCooldownClientTicks > 0)
		{
			comboEatCooldownClientTicks--;
		}

		if (drinkCooldownClientTicks > 0)
		{
			drinkCooldownClientTicks--;
		}

		if (clientTicksTillDelayedHeal > 0)
		{
			clientTicksTillDelayedHeal--;
		}

		if (delayedHealTimer != null)
		{
			delayedHealTimer.updateCooldownClientTicks(clientTicksTillDelayedHeal);
		}

		if (config.showItemCooldownPreview() && previewCooldownClientTicks > ITEM_COOLDOWN_PREVIEW_GRACE_PERIOD_CLIENT_TICKS)
		{
			previewCooldownClientTicks--;
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if (actionCooldownTicks > 0)
		{
			actionCooldownTicks--;
		}

		if (eatCooldownTicks > 0)
		{
			eatCooldownTicks--;
		}

		if (comboEatCooldownTicks > 0)
		{
			comboEatCooldownTicks--;
		}

		if (drinkCooldownTicks > 0)
		{
			drinkCooldownTicks--;
		}

		if (ticksTillDelayedHeal > 0)
		{
			ticksTillDelayedHeal--;
		}

		if (delayedHealTimer != null)
		{
			delayedHealTimer.updateCooldownTicks(ticksTillDelayedHeal);
			if (ticksTillDelayedHeal < 1)
			{
				delayedHealTimer = null;
				logDebug("{} - Removed delayed heal timer", client.getTickCount());
			}
		}

		if (config.showItemCooldownPreview() && previewCooldownTicks > -1)
		{
			previewCooldownTicks--;
		}
		else if (config.showItemCooldownPreview())
		{
			previewCooldownTicks = ITEM_COOLDOWN_PREVIEW_TICKS;
			previewCooldownClientTicks = ITEM_COOLDOWN_PREVIEW_CLIENT_TICKS;
		}

		ListIterator<InventoryConsumableItemAction> actionsIterator = inventoryConsumableItemActions.listIterator();
		while (actionsIterator.hasNext())
		{
			InventoryConsumableItemAction itemAction = actionsIterator.next();
			int ticksSinceAction = client.getTickCount() - itemAction.getActionTick();
			if (ticksSinceAction <= 1)
			{
				continue;
			}

			actionsIterator.remove();
			log.warn("{} - Removed item action (id: {}, slot: {}) from queue (size: {}). More than 1 tick since action on tick: {}", client.getTickCount(), itemAction.getItemId(), itemAction.getItemSlot(), inventoryConsumableItemActions.size(), itemAction.getActionTick());
		}
	}

	@Subscribe
	private void onMenuOptionClicked(final MenuOptionClicked event)
	{
		String menuOption = Text.removeTags(event.getMenuOption()).toLowerCase();
		logDebug("{} - Menu option clicked: {}. Slot: {}", client.getTickCount(), menuOption, event.getMenuEntry().getParam0());
		if (!isConsumableMenuOption(menuOption) || isMenuOptionItemInInventoryActions(event))
		{
			logDebug("{} - Menu option skipped. Consumable: {}, already in actions: {}", client.getTickCount(), isConsumableMenuOption(menuOption), isMenuOptionItemInInventoryActions(event));
			return;
		}

		ItemContainer oldInventory = client.getItemContainer(InventoryID.INVENTORY);
		if (oldInventory == null)
		{
			return;
		}

		// Menu options with a consumable menu option (i.e. drink) can also occur on objects such as PoH rejuvenation pool
		int inventorySlot = event.getMenuEntry().getParam0();
		if (inventorySlot > LAST_INVENTORY_SLOT_INDEX)
		{
			return;
		}

		Item item = oldInventory.getItems()[inventorySlot];
		inventoryConsumableItemActions.add(
			new InventoryConsumableItemAction(oldInventory.getItems(), item.getId(), inventorySlot, client.getTickCount())
		);
		logDebug("{} - Added item in slot: {} with id: {} to queue", client.getTickCount(), inventorySlot, item.getId());
	}

	@Subscribe
	private void onChatMessage(ChatMessage event)
	{
		// Grid master specific logic
		String message = event.getMessage();
		if (message.equals("You bite a chunk out of the corrupted shark, but it quickly regrows."))
		{
			ConsumableItem consumableItem = getConsumableItemFromId(ItemID.EVENT_CORRUPTED_SHARK);
			InventoryConsumableItemAction itemAction = new InventoryConsumableItemAction(null, ItemID.EVENT_CORRUPTED_SHARK, -1, client.getTickCount());
			itemConsumed(consumableItem, itemAction);
		}
		else if (message.equals("Bottomless Brew prevents your potion from being consumed."))
		{
			// All drinks add the same delay, don't try to determine what drink it is, since it is not needed for implementation
			ConsumableItem consumableItem = getConsumableItemFromId(ItemID.STRENGTH4);
			InventoryConsumableItemAction itemAction = new InventoryConsumableItemAction(null, ItemID.STRENGTH4, -1, client.getTickCount());
			itemConsumed(consumableItem, itemAction);
		}
	}

	@Subscribe
	private void onItemContainerChanged(ItemContainerChanged event)
	{
		if (event.getContainerId() != InventoryID.INVENTORY.getId())
		{
			return;
		}

		processInventoryChanges(event.getItemContainer());
		logDebug("{} - Inventory changed. Queue size: {}", client.getTickCount(), inventoryConsumableItemActions.size());
	}

	private void processInventoryChanges(ItemContainer itemContainer)
	{
		ListIterator<InventoryConsumableItemAction> actionsIterator = inventoryConsumableItemActions.listIterator();
		while (actionsIterator.hasNext())
		{
			InventoryConsumableItemAction itemAction = actionsIterator.next();
			logDebug("{} - Item in slot: {} with id: {} and idx: {} with size: {} peeked from queue", client.getTickCount(), itemAction.getItemSlot(), itemAction.getItemId(), actionsIterator.nextIndex(), inventoryConsumableItemActions.size());

			int itemId = itemAction.getItemId();
			ConsumableItem consumableItem = getConsumableItemFromId(itemId);
			if (consumableItem == null)
			{
				logDebug("{} - Item in slot: {} with id: {} skipped. No consumable item found", client.getTickCount(), itemAction.getItemSlot(), itemAction.getItemId());
				actionsIterator.remove();
				continue;
			}

			if (!itemAction.isItemConsumed(itemContainer.getItems()))
			{
				logDebug("{} - Item in slot: {} with id: {} skipped. Item still in slot", client.getTickCount(), itemAction.getItemSlot(), itemAction.getItemId());

				// An item can be consumed one or multiple ticks later than the initial action click due to latency
				// So leave it on the queue if the item is still there on the action tick as it may be consumed the next tick
				if (itemAction.getActionTick() != client.getTickCount())
				{
					actionsIterator.remove();
				}

				continue;
			}

			actionsIterator.remove();
			itemConsumed(consumableItem, itemAction);
		}
	}

	public ConsumableItem getConsumableItemFromId(int itemId)
	{
		for (ConsumableItem consumableItem : CONSUMABLES)
		{
			if (consumableItem.getItemFilter().test(itemId))
			{
				return consumableItem;
			}
		}

		return null;
	}

	private Set<ConsumableItemType> getMaxLastConsumedItemsTickTimers(int max, Map<ConsumableItemType,
		Integer> lastConsumedItemsTickTimers)
	{
		Set<ConsumableItemType> maxTickTimers = new HashSet<>();
		for (Map.Entry<ConsumableItemType, Integer> entry : lastConsumedItemsTickTimers.entrySet())
		{
			if (entry.getValue() == max)
			{
				maxTickTimers.add(entry.getKey());
			}
		}

		return maxTickTimers;
	}

	private ConsumableItem getLastFoodCooldownSource()
	{
		if (eatCooldownTicks == 0 && drinkCooldownTicks == 0 && comboEatCooldownTicks == 0)
		{
			return null;
		}

		Map<ConsumableItemType, Integer> lastConsumedItemsTickTimers = Map.of(
			ConsumableItemType.FOOD, lastFoodConsumedTick,
			ConsumableItemType.DRINK, lastDrinkConsumedTick,
			ConsumableItemType.COMBO_FOOD, lastComboFoodConsumedTick
		);

		int max;
		max = Math.max(lastFoodConsumedTick, lastDrinkConsumedTick);
		max = Math.max(max, lastComboFoodConsumedTick);

		Set<ConsumableItemType> maxCooldownTypes = getMaxLastConsumedItemsTickTimers(max, lastConsumedItemsTickTimers);
		if (maxCooldownTypes.contains(ConsumableItemType.COMBO_FOOD))
		{
			return lastComboFoodConsumed;
		}
		else if (maxCooldownTypes.contains(ConsumableItemType.DRINK))
		{
			return lastDrinkConsumed;
		}
		else if (maxCooldownTypes.contains(ConsumableItemType.FOOD))
		{
			return lastFoodConsumed;
		}

		return null;
	}

	private ConsumableItem getLastDrinkCooldownSource()
	{
		if (drinkCooldownTicks == 0 && comboEatCooldownTicks == 0)
		{
			return null;
		}

		Map<ConsumableItemType, Integer> lastConsumedItemsTickTimers = Map.of(
			ConsumableItemType.DRINK, lastDrinkConsumedTick,
			ConsumableItemType.COMBO_FOOD, lastComboFoodConsumedTick
		);

		int max = Math.max(lastDrinkConsumedTick, lastComboFoodConsumedTick);
		Set<ConsumableItemType> maxCooldownTypes = getMaxLastConsumedItemsTickTimers(max, lastConsumedItemsTickTimers);
		if (maxCooldownTypes.contains(ConsumableItemType.COMBO_FOOD))
		{
			return lastComboFoodConsumed;
		}
		else if (maxCooldownTypes.contains(ConsumableItemType.DRINK))
		{
			return lastDrinkConsumed;
		}

		return null;
	}

	private ConsumableItem getLastComboFoodCooldownSource()
	{
		if (eatCooldownTicks == 0 && comboEatCooldownTicks == 0)
		{
			return null;
		}

		Map<ConsumableItemType, Integer> lastConsumedItemsTickTimers = Map.of(
			ConsumableItemType.FOOD, lastFoodConsumedTick,
			ConsumableItemType.COMBO_FOOD, lastComboFoodConsumedTick
		);

		int max = Math.max(lastFoodConsumedTick, lastComboFoodConsumedTick);
		Set<ConsumableItemType> maxCooldownTypes = getMaxLastConsumedItemsTickTimers(max, lastConsumedItemsTickTimers);
		if (maxCooldownTypes.contains(ConsumableItemType.COMBO_FOOD))
		{
			return lastComboFoodConsumed;
		}
		else if (maxCooldownTypes.contains(ConsumableItemType.FOOD))
		{
			return lastFoodConsumed;
		}

		return null;
	}

	public ConsumableItemCooldown getLastCooldownSourceByType(ConsumableItemType type)
	{
		if (config.showItemCooldownPreview())
		{
			return new ConsumableItemCooldown(ITEM_COOLDOWN_PREVIEW_TICKS, ITEM_COOLDOWN_PREVIEW_CLIENT_TICKS);
		}

		ConsumableItem cooldownSource = null;
		switch (type)
		{
			case FOOD:
			case COOKED_CRAB_MEAT:
			case CAKE:
			case F2P_FIRST_SLICE:
			case F2P_SECOND_SLICE:
			case P2P_PIE:
			case OVERTIME_FOOD:
				cooldownSource = getLastFoodCooldownSource();
				break;
			case DRINK:
				cooldownSource = getLastDrinkCooldownSource();
				break;
			case COMBO_FOOD:
				cooldownSource = getLastComboFoodCooldownSource();
				break;
		}

		if (cooldownSource == null)
		{
			return null;
		}

		return cooldownSource.getFullCooldown();
	}

	public ConsumableItemCooldown getCooldownForConsumableItem(ConsumableItem consumableItem)
	{
		if (config.showItemCooldownPreview())
		{
			return new ConsumableItemCooldown(previewCooldownTicks, previewCooldownClientTicks);
		}

		switch (consumableItem.getType())
		{
			case FOOD:
			case COOKED_CRAB_MEAT:
			case CAKE:
			case F2P_FIRST_SLICE:
			case F2P_SECOND_SLICE:
			case P2P_PIE:
			case OVERTIME_FOOD:
				if (eatCooldownTicks <= 0)
				{
					return null;
				}

				return new ConsumableItemCooldown(eatCooldownTicks, eatCooldownClientTicks);
			case DRINK:
				if (drinkCooldownTicks <= 0)
				{
					return null;
				}

				return new ConsumableItemCooldown(drinkCooldownTicks, drinkCooldownClientTicks);
			case COMBO_FOOD:
				if (comboEatCooldownTicks <= 0)
				{
					return null;
				}

				return new ConsumableItemCooldown(comboEatCooldownTicks, comboEatCooldownClientTicks);
		}

		return null;
	}

	public boolean isNoConsumableCooldownActive()
	{
		return (!config.showItemCooldownPreview() && eatCooldownTicks <= 0 && drinkCooldownTicks <= 0 && comboEatCooldownTicks <= 0) ||
			(config.showItemCooldownPreview() && previewCooldownTicks <= 0);
	}

	private void itemConsumed(ConsumableItem consumableItem, InventoryConsumableItemAction itemAction)
	{
		ConsumableItemType consumableItemType = consumableItem.getType();
		logDebug("{} - {} item with id: {} was consumed", client.getTickCount(), consumableItemType, itemAction.getItemId());

		switch (consumableItemType)
		{
			case FOOD:
			case COOKED_CRAB_MEAT:
			case CAKE:
			case F2P_FIRST_SLICE:
			case F2P_SECOND_SLICE:
			case P2P_PIE:
			case OVERTIME_FOOD:
				lastFoodConsumedTick = client.getTickCount();
				lastFoodConsumed = consumableItem;
				eatCooldownTicks = consumableItem.getEatCooldownTicks();
				eatCooldownClientTicks = consumableItem.cooldownTicksToClientTicks(eatCooldownTicks);
				actionCooldownTicks += consumableItem.getActionCooldownTicks();
				if (consumableItemType == ConsumableItemType.OVERTIME_FOOD)
				{
					ticksTillDelayedHeal = consumableItem.getDelayedHealTicks();
					clientTicksTillDelayedHeal = consumableItem.cooldownTicksToClientTicks(ticksTillDelayedHeal);
					if (delayedHealTimer != null)
					{
						infoBoxManager.removeInfoBox(delayedHealTimer);
						delayedHealTimer = null;
						logDebug("{} - Removed delayed heal timer due to early eat", client.getTickCount());
					}

					final BufferedImage consumableImage = itemManager.getImage(itemAction.getItemId(), 1, false);
					delayedHealTimer = new ConsumableCooldownTimer(consumableImage, ticksTillDelayedHeal, clientTicksTillDelayedHeal, this);
					if (config.showDelayedHealInfobox())
					{
						infoBoxManager.addInfoBox(delayedHealTimer);
					}
				}
				logDebug("{} - FOOD - eat: {}, comboEat: {}, drink: {}, action: {}, delayed heal: {}", client.getTickCount(), eatCooldownTicks, comboEatCooldownTicks, drinkCooldownTicks, actionCooldownTicks, ticksTillDelayedHeal);
				break;
			case DRINK:
				lastDrinkConsumedTick = client.getTickCount();
				lastDrinkConsumed = consumableItem;
				drinkCooldownTicks = consumableItem.getDrinkCooldownTicks();
				drinkCooldownClientTicks = consumableItem.cooldownTicksToClientTicks(drinkCooldownTicks);
				eatCooldownTicks = consumableItem.getEatCooldownTicks();
				eatCooldownClientTicks = consumableItem.cooldownTicksToClientTicks(eatCooldownTicks);
				actionCooldownTicks += consumableItem.getActionCooldownTicks();
				logDebug("{} - POTION - eat: {}, comboEat: {}, drink: {}, action: {}", client.getTickCount(), eatCooldownTicks, comboEatCooldownTicks, drinkCooldownTicks, actionCooldownTicks);
				break;
			case COMBO_FOOD:
				lastComboFoodConsumedTick = client.getTickCount();
				lastComboFoodConsumed = consumableItem;
				eatCooldownTicks = consumableItem.getEatCooldownTicks();
				eatCooldownClientTicks = consumableItem.cooldownTicksToClientTicks(eatCooldownTicks);
				comboEatCooldownTicks = consumableItem.getComboEatCooldownTicks();
				comboEatCooldownClientTicks = consumableItem.cooldownTicksToClientTicks(comboEatCooldownTicks);
				drinkCooldownTicks = consumableItem.getDrinkCooldownTicks();
				drinkCooldownClientTicks = consumableItem.cooldownTicksToClientTicks(drinkCooldownTicks);
				actionCooldownTicks += consumableItem.getActionCooldownTicks();
				logDebug("{} - COMBO - eat: {}, comboEat: {}, drink: {}, action: {}", client.getTickCount(), eatCooldownTicks, comboEatCooldownTicks, drinkCooldownTicks, actionCooldownTicks);
				break;
		}
	}

	private boolean isConsumableMenuOption(String menuOption)
	{
		return EAT_PATTERN.matcher(menuOption).find() || DRINK_PATTERN.matcher(menuOption).find();
	}

	private boolean isMenuOptionItemInInventoryActions(MenuOptionClicked event)
	{
		return inventoryConsumableItemActions.stream().anyMatch(itemAction ->
			itemAction.getItemId() == event.getItemId() && itemAction.getItemSlot() == event.getParam0());
	}

	private void logDebug(String message, Object... args)
	{
		if (SHOULD_LOG_DEBUG)
		{
			log.debug(message, args);
		}
	}
}

package com.consumablecooldowns;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum InfoBoxTextMode
{
	SECONDS_MILLISECONDS("Seconds & ms"),
	MINUTES_SECONDS("Minutes & seconds"),
	SECONDS("Seconds"),
	GAME_TICKS("Ticks"),
	GAME_TICKS_COMPACT("Ticks (compact)"),
	GAME_TICKS_NO_SUFFIX("Ticks (no suffix)"),
	NONE("None");

	private final String value;

	public String toString()
	{
		return this.value;
	}
}

package com.consumablecooldowns;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ConsumableItemCooldown
{
	private int ticks;
	private int clientTicks;

	String toGameTicks()
	{
		return String.valueOf(ticks);
	}

	String toSecondsMilliseconds()
	{
		return Math.abs((clientTicks / 5) / 10) + "." + (Math.abs((clientTicks / 5)) % 10);
	}

	String toSeconds()
	{
		return String.valueOf(Math.abs((clientTicks / 5) / 10));
	}

	String toMinuteSeconds()
	{
		int seconds = Math.abs((clientTicks / 5) / 10);
		if (seconds < 10)
		{
			return "0:0" + seconds;
		}
		else if (seconds < 60)
		{
			return "0:" + seconds;
		}
		else
		{
			return (seconds / 60) + ":" + (seconds % 60);
		}
	}
}

package com.consumablecooldowns;

public enum BottomToTopCooldownIndicatorStartDelay
{
	NONE,
	VERY_SHORT,
	SHORT,
	NORMAL,
	LONG,
	LONGER,
	LONGEST
}

package com.consumablecooldowns;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ConsumableCooldownsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ConsumableCooldownsPlugin.class);
		RuneLite.main(args);
	}
}
