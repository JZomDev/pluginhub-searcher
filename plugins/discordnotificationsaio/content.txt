package com.discordnotificationsaio;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DiscordNotificationsAIOPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin( DiscordNotificationsAIOPlugin.class);
		RuneLite.main(args);
	}
}
	package com.discordnotificationsaio;
	
	import lombok.Data;
	
	@Data
	class NonLootWebhookBody
	{
	private String content;
	private Embed embed;
	
	@Data
	static class Embed
	{
		final UrlEmbed image;
	}
	
	@Data
	static class UrlEmbed
	{
		final String url;
	}
	}
package com.discordnotificationsaio.rarity;

public class Drop {
String id;
String name;

String quantity;
String rarity;
String rolls;

public Drop ()
	{
	}

public String getId ()
	{
	return id;
	}

public void setId ( String id )
	{
	this.id = id;
	}

public String getQuantity ()
	{
	return quantity;
	}

public void setQuantity ( String id )
	{
	this.quantity = quantity;
	}

public String getName ()
	{
	return name;
	}

public void setName ( String name )
	{
	this.name = name;
	}

public String getRolls ()
	{
	return rolls;
	}

public void setRolls ( String rolls )
	{
	this.rolls = rolls;
	}

public String getRarity ()
	{
	return rarity;
	}

public void setRarity ( String rarity )
	{
	this.rarity = rarity;
	}
}

package com.discordnotificationsaio.rarity;
import java.util.ArrayList;

public class Monster
{
	String id;
	ArrayList<Drop> drops;

	public Monster(String id)
	{
		this.id = id;
		drops = new ArrayList<>();
	}

	public String getId()
	{
		return id;
	}

	public void setId(String id)
	{
		this.id = id;
	}

	public ArrayList<Drop> getDrops()
	{
		return drops;
	}

	public void addDrops( Drop drops)
	{
		this.drops.add(drops);
	}
}

package com.discordnotificationsaio;

import com.discordnotificationsaio.rarity.Drop;
import com.discordnotificationsaio.rarity.Monster;
import com.discordnotificationsaio.wiki.WikiItem;
import com.discordnotificationsaio.wiseoldman.Groups;
import com.google.gson.Gson;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;
import org.json.JSONArray;
import org.json.JSONObject;

import javax.inject.Inject;
import javax.swing.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.stream.IntStream;
import static net.runelite.http.api.RuneLiteAPI.GSON;
import static net.runelite.http.api.RuneLiteAPI.CLIENT;

public class ApiTools {
@Inject
private static OkHttpClient okHttpClient;

//public String getWikiIcon ( String itemName ) throws IOException, InterruptedException
//	{
//	String sURL =
//			"https://oldschool.runescape.wiki/api.php?action=query&format=json&formatversion=2&prop=pageimages&titles=" +
//			itemName.replace( " ", "_" ).replace( "%20", "_" );
//	OkHttpClient client = new OkHttpClient();
//	Request request = new Request.Builder()
//			.url( sURL )
//			.header("User-Agent", "skyhawkgaming/better-discord-loot-logger")
//			.build();
//	CompletableFuture<String> icon = new CompletableFuture<>();
//	CompletableFuture.supplyAsync( () ->
//		{
//		okHttpClient.newCall( request ).enqueue( new Callback() {
//			@Override
//			public void onFailure ( @NotNull Call call, @NotNull IOException e )
//				{
//
//				icon.completeExceptionally( e );
//				}
//
//			@Override
//			public void onResponse ( @NotNull Call call, @NotNull Response response ) throws IOException
//				{
//				String responseBody = Objects.requireNonNull( response.body() ).string();
//					if ( responseBody.contains( "source" ) )
//						{
//						WikiItem wikiItem = g.fromJson( responseBody, WikiItem.class );
////						System.out.println(wikiItem.getQuery().getPages().get( 0 ).getThumbnail().getSource());
//						String wikiIcon = wikiItem.getQuery().getPages().get( 0 ).getThumbnail().getSource();
//						icon.complete( wikiIcon );
//						response.close();
//						}
//					}
//
//		} );
//		// System.out.println( icon.getNow( "failed https://oldschool.runescape.wiki/images/Coins_10000.png" ) );
//		return icon;
//		});
//	try
//		{
//		return icon.get();
//		}
//	catch (ExecutionException e)
//		{
//		throw new RuntimeException( e );
//		}
//	}

// TODO: fix wom api methods. Currently failing to grab clan names when using injected okhttpclient
public static Object[] getWomGroupIds ( String playerName ) throws IOException, InterruptedException
	{
	String compUrl =
			"https://api.wiseoldman.net/players/username/" + playerName.replace( " ", "_" ).replace( "%20", "_" ) +
			"/competitions";
	Request request = new Request.Builder().url( compUrl ).build();
//	OkHttpClient client = new OkHttpClient();
	String responseBody = (Objects.requireNonNull( CLIENT.newCall( request ).execute().body() )).string();
	if ( ! responseBody.contains( "groupId" ) )
		{
		return null;
		}
	JSONArray jsonArray = new JSONArray( responseBody );
//	System.out.println(responseBody);
//	System.out.println( Arrays.toString(IntStream.range(0, jsonArray.length())
//	                                             .mapToObj(index -> ((JSONObject) jsonArray.get(index)).optString("groupId")).distinct().sorted().toArray()));
	return (IntStream.range( 0, jsonArray.length() )
	                 .mapToObj( index -> ((JSONObject) jsonArray.get( index )).optString( "groupId" ) ).distinct()
	                 .sorted()).toArray();
	}

public static Object[] getGroupMembers ( int groupId ) throws IOException, InterruptedException
	{
	String groupUrl = "https://api.wiseoldman.net/groups/" + groupId + "/members";
	Request request = new Request.Builder().url( groupUrl ).build();
//	OkHttpClient client = new OkHttpClient();
	String responseBody = (Objects.requireNonNull( CLIENT.newCall( request ).execute().body() )).string();
	if ( ! responseBody.contains( "username" ) )
		{
		return null;
		}
	JSONArray jsonArray = new JSONArray( responseBody );
//        System.out.println(responseBody);
//        System.out.println(Arrays.toString((IntStream.range(0, jsonArray.length())
//                .mapToObj(index -> ((JSONObject) jsonArray.get(index)).optString("displayName")).sorted()).toArray()));
	//	System.out.println( displayNames );
	return (IntStream.range( 0, jsonArray.length() )
	                 .mapToObj( index -> ((JSONObject) jsonArray.get( index )).optString( "displayName" ) )
	                 .sorted( String.CASE_INSENSITIVE_ORDER )).toArray( String[]::new );
	}

public static String getClanName ( int groupId ) throws IOException, InterruptedException
	{
	String groupUrl = String.format( "https://api.wiseoldman.net/groups/%d", groupId );
	Request request = new Request.Builder().url( groupUrl ).build();
//	OkHttpClient client = new OkHttpClient();
	String responseBody = (Objects.requireNonNull( CLIENT.newCall( request ).execute().body() )).string();
	if ( ! responseBody.contains( "name" ) )
		{
		return null;
		}
//        System.out.println(responseBody);
	Groups resJson = GSON.fromJson( responseBody, Groups.class );
//        System.out.println(resJson.getName());
	return resJson.getName();
	}


public static String getItemRarity (ArrayList<Monster> mobs, String npcName, String itemName) throws IOException
	{
	
	final String[] rarity = new String[1];
	Optional<Monster> killed = mobs.stream().filter( monster -> monster.getId().equals(npcName)).findFirst();
	killed.ifPresent(k ->
		{
		Optional<Drop> dropped = k.getDrops().stream().filter( drop -> drop.getName().equals(itemName)).findFirst();
//		dropped.ifPresent(drop -> System.out.println("\n\nRarity of " + drop.getName() + " from " + npcName + " is " + drop.getRarity()));
		dropped.ifPresent( drop -> rarity[0] = (drop.getRarity()));
		if( ! Objects.equals( rarity[0], "Always" ) ) rarity[0]=rarity[0].split("/")[1];
		});
	if (rarity[0] == null) return "";
	return rarity[0];
	}
	
}

package com.discordnotificationsaio;

import com.discordnotificationsaio.rarity.Monster;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;

import static com.discordnotificationsaio.ApiTools.*;
import static java.util.Objects.requireNonNull;

@Slf4j
public class DiscordNotificationsAIOPanel extends PluginPanel {

final JTextField npcName = new JTextField();
final JTextField itemName = new JTextField();
final JLabel thumbnail = new JLabel();
final JTextPane submitInfo = new JTextPane();
final JTextField splitMembers = new JTextField();
private final Client client;
public BufferedImage before;
JPanel womPanel = new JPanel();
JLabel lblGetGroupId = new JLabel();
JComboBox<Object> groupComboBox = new JComboBox<>();
JComboBox<Object> memberList = new JComboBox<>();
JButton btnRefresh = new JButton();
ImageIcon icon = new ImageIcon();

@SneakyThrows
DiscordNotificationsAIOPanel ( DiscordNotificationsAIOPlugin plugin, DiscordNotificationsAIOConfig config, Client client, ArrayList<Monster> mobs )
	{
	this.client = client;
	setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	setBorder( null );
	setBackground( ColorScheme.DARK_GRAY_COLOR );
	GridBagLayout gridBagLayout = new GridBagLayout();
	gridBagLayout.columnWidths = new int[] {158, 0};
	gridBagLayout.rowHeights = new int[] {176, 27, 0, 185, 1, 161, 0};
	gridBagLayout.columnWeights = new double[] {1.0, Double.MIN_VALUE};
	gridBagLayout.rowWeights = new double[] {0.0, 0.0, 0.0, 1.0, 0.0, 1.0, Double.MIN_VALUE};
	setLayout( gridBagLayout );
	
	JPanel lootPanel = new JPanel();
	lootPanel.setAlignmentY( Component.TOP_ALIGNMENT );
	lootPanel.setFont( new Font( "RuneScape", Font.PLAIN, 13 ) );
	lootPanel.setBackground( ColorScheme.DARKER_GRAY_COLOR );
	lootPanel.setBorder( null );
	GridBagConstraints gbc_lootPanel = new GridBagConstraints();
	gbc_lootPanel.ipadx = 1;
	gbc_lootPanel.fill = GridBagConstraints.BOTH;
	gbc_lootPanel.insets = new Insets( 8, 8, 8, 8 );
	gbc_lootPanel.gridx = 0;
	gbc_lootPanel.gridy = 0;
	add( lootPanel, gbc_lootPanel );
	GridBagLayout gbl_lootPanel = new GridBagLayout();
	gbl_lootPanel.columnWidths = new int[] {158, 0};
	gbl_lootPanel.rowHeights = new int[] {45, 35, 35, 35};
	gbl_lootPanel.columnWeights = new double[] {1.0, Double.MIN_VALUE};
	gbl_lootPanel.rowWeights = new double[] {0.0, 0.0, 0.0, 0.0};
	lootPanel.setLayout( gbl_lootPanel );
	
	JLabel lblLootInfo = new JLabel();
	lblLootInfo.setText( "Loot Information" );
	lblLootInfo.setHorizontalTextPosition( SwingConstants.CENTER );
	lblLootInfo.setHorizontalAlignment( SwingConstants.CENTER );
	lblLootInfo.setForeground( Color.WHITE );
	lblLootInfo.setFont( new Font( "RuneScape", Font.BOLD, 18 ) );
	lblLootInfo.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	lblLootInfo.setBorder( new EmptyBorder( 4, 0, 4, 0 ) );
	GridBagConstraints gbc_lblLootInfo = new GridBagConstraints();
	gbc_lblLootInfo.fill = GridBagConstraints.HORIZONTAL;
	gbc_lblLootInfo.anchor = GridBagConstraints.SOUTH;
	gbc_lblLootInfo.insets = new Insets( 8, 0, 5, 0 );
	gbc_lblLootInfo.gridx = 0;
	gbc_lblLootInfo.gridy = 0;
	lootPanel.add( lblLootInfo, gbc_lblLootInfo );
	GridBagConstraints gbc_itemName = new GridBagConstraints();
	gbc_itemName.fill = GridBagConstraints.BOTH;
	gbc_itemName.insets = new Insets( 4, 4, 5, 4 );
	gbc_itemName.gridx = 0;
	gbc_itemName.gridy = 1;
	lootPanel.add( itemName, gbc_itemName );
	itemName.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	itemName.setHorizontalAlignment( SwingConstants.CENTER );
	itemName.setBorder( UIManager.getBorder( "FormattedTextField.border" ) );
	itemName.setForeground( Color.WHITE );
	
	itemName.setEditable( true );
	itemName.setToolTipText( "Item Name" );
	itemName.setBackground( Color.DARK_GRAY );
	itemName.setText( "Item Name" );
	GridBagConstraints gbc_npcName = new GridBagConstraints();
	gbc_npcName.fill = GridBagConstraints.BOTH;
	gbc_npcName.insets = new Insets( 4, 4, 5, 4 );
	gbc_npcName.gridx = 0;
	gbc_npcName.gridy = 2;
	lootPanel.add( npcName, gbc_npcName );
	npcName.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	npcName.setHorizontalAlignment( SwingConstants.CENTER );
	npcName.setBorder( UIManager.getBorder( "FormattedTextField.border" ) );
	npcName.setForeground( Color.WHITE );
	
	npcName.setEditable( true );
	npcName.setToolTipText( "Boss/NPC Name" );
	npcName.setBackground( Color.DARK_GRAY );
	npcName.setText( "Boss/NPC Name" );
	final JButton clearNames = new JButton( "Reset Loot Information" );
	GridBagConstraints gbc_clearNames = new GridBagConstraints();
	gbc_clearNames.gridx = 0;
	gbc_clearNames.gridy = 3;
	lootPanel.add( clearNames, gbc_clearNames );
	clearNames.addActionListener( e ->
		{
		} );
	clearNames.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	clearNames.setForeground( Color.WHITE );
	clearNames.addActionListener( e ->
		{
		itemName.setText( "Item Name" );
		npcName.setText( "Boss/NPC Name" );
		} );
	npcName.addFocusListener( new FocusListener() {
		@Override
		public void focusGained ( FocusEvent e )
			{
			if ( npcName.getText().equals( "Boss/NPC Name" ) )
				{
				npcName.setText( "" );
				}
			}
		
		@Override
		public void focusLost ( FocusEvent e )
			{
			if ( npcName.getText().isEmpty() )
				{
				npcName.setText( "Boss/NPC Name" );
				}
			}
	} );
	itemName.addFocusListener( new FocusListener() {
		@Override
		public void focusGained ( FocusEvent e )
			{
			if ( itemName.getText().equals( "Item Name" ) )
				{
				itemName.setText( "" );
				}
			}
		
		@Override
		public void focusLost ( FocusEvent e )
			{
			if ( itemName.getText().isEmpty() )
				{
				itemName.setText( "Item Name" );
				}
			}
	} );
	
	JPanel splitPanel = new JPanel();
	splitPanel.setBorder( null );
	splitPanel.setBackground( ColorScheme.DARKER_GRAY_COLOR );
	GridBagConstraints gbc_splitPanel = new GridBagConstraints();
	gbc_splitPanel.fill = GridBagConstraints.BOTH;
	gbc_splitPanel.insets = new Insets( 8, 8, 8, 8 );
	gbc_splitPanel.gridx = 0;
	gbc_splitPanel.gridy = 1;
	add( splitPanel, gbc_splitPanel );
	GridBagLayout gbl_splitPanel = new GridBagLayout();
	gbl_splitPanel.columnWidths = new int[] {75, 140, 0};
	gbl_splitPanel.rowHeights = new int[] {45, 35, 35, 0, 0};
	gbl_splitPanel.columnWeights = new double[] {1.0, 0.0, Double.MIN_VALUE};
	gbl_splitPanel.rowWeights = new double[] {0.0, 0.0, 1.0, 0.0, Double.MIN_VALUE};
	splitPanel.setLayout( gbl_splitPanel );
	
	JLabel lblSplitInfo = new JLabel();
	lblSplitInfo.setHorizontalTextPosition( SwingConstants.CENTER );
	GridBagConstraints gbc_lblSplitInfo = new GridBagConstraints();
	gbc_lblSplitInfo.gridwidth = 2;
	gbc_lblSplitInfo.anchor = GridBagConstraints.SOUTH;
	gbc_lblSplitInfo.fill = GridBagConstraints.HORIZONTAL;
	gbc_lblSplitInfo.insets = new Insets( 8, 0, 5, 0 );
	gbc_lblSplitInfo.gridx = 0;
	gbc_lblSplitInfo.gridy = 0;
	splitPanel.add( lblSplitInfo, gbc_lblSplitInfo );
	lblSplitInfo.setText( "Split Information" );
	lblSplitInfo.setHorizontalAlignment( SwingConstants.CENTER );
	lblSplitInfo.setForeground( Color.WHITE );
	lblSplitInfo.setFont( new Font( "RuneScape", Font.BOLD, 18 ) );
	lblSplitInfo.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	lblSplitInfo.setBorder( new EmptyBorder( 4, 0, 4, 0 ) );
	
	final JTextField splitValue = new JTextField();
	GridBagConstraints gbc_splitValue = new GridBagConstraints();
	gbc_splitValue.gridwidth = 2;
	gbc_splitValue.fill = GridBagConstraints.BOTH;
	gbc_splitValue.insets = new Insets( 4, 4, 5, 4 );
	gbc_splitValue.gridx = 0;
	gbc_splitValue.gridy = 1;
	splitPanel.add( splitValue, gbc_splitValue );
	splitValue.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	splitValue.setHorizontalAlignment( SwingConstants.CENTER );
	splitValue.setBorder( UIManager.getBorder( "FormattedTextField.border" ) );
	splitValue.setForeground( Color.WHITE );
	splitValue.setEditable( true );
	splitValue.setToolTipText( "Split Value" );
	splitValue.setBackground( Color.DARK_GRAY );
	splitValue.setText( "Split Value (Per-Player)" );
	
	GridBagConstraints gbc_splitMembers = new GridBagConstraints();
	gbc_splitMembers.gridwidth = 2;
	gbc_splitMembers.insets = new Insets( 4, 4, 5, 4 );
	gbc_splitMembers.fill = GridBagConstraints.BOTH;
	gbc_splitMembers.gridx = 0;
	gbc_splitMembers.gridy = 2;
	splitPanel.add( splitMembers, gbc_splitMembers );
	splitMembers.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	splitMembers.setHorizontalAlignment( SwingConstants.CENTER );
	splitMembers.setBorder( UIManager.getBorder( "FormattedTextField.border" ) );
	splitMembers.setForeground( Color.WHITE );
	splitMembers.setEditable( true );
	splitMembers.setToolTipText( "Split with" );
	splitMembers.setBackground( Color.DARK_GRAY );
	splitMembers.setText( "Split with (Player Names)" );
	
	// submit button
	final JButton submitLoot = new JButton( "Submit" );
	GridBagConstraints gbc_submitLoot = new GridBagConstraints();
	gbc_submitLoot.fill = GridBagConstraints.HORIZONTAL;
	gbc_submitLoot.insets = new Insets( 0, 6, 6, 4 );
	gbc_submitLoot.gridx = 0;
	gbc_submitLoot.gridy = 3;
	splitPanel.add( submitLoot, gbc_submitLoot );
	submitLoot.setSize( new Dimension( 70, 30 ) );
	submitLoot.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	submitLoot.setForeground( Color.WHITE );
	final JButton reTakeScreenshot = new JButton( "Take Screenshot" );
	GridBagConstraints gbc_reTakeScreenshot = new GridBagConstraints();
	gbc_reTakeScreenshot.anchor = GridBagConstraints.EAST;
	gbc_reTakeScreenshot.gridwidth = 1;
	gbc_reTakeScreenshot.insets = new Insets( 0, 0, 6, 6 );
	gbc_reTakeScreenshot.gridx = 1;
	gbc_reTakeScreenshot.gridy = 3;
	splitPanel.add( reTakeScreenshot, gbc_reTakeScreenshot );
	reTakeScreenshot.setSize( new Dimension( 1, 30 ) );
	reTakeScreenshot.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	reTakeScreenshot.setForeground( Color.WHITE );
	reTakeScreenshot.addActionListener( e -> plugin.dataToPanel( npcName.getText(), itemName.getText() ) );
	submitLoot.addActionListener( e ->
		{
		submitLoot( splitValue, splitMembers, itemName, npcName, submitInfo, config, mobs, plugin );
		} );
	splitMembers.addFocusListener( new FocusListener() {
		@Override
		public void focusGained ( FocusEvent e )
			{
			if ( splitMembers.getText().equals( "Split with (Player Names)" ) )
				{
				splitMembers.setText( "" );
				}
			}
		
		@Override
		public void focusLost ( FocusEvent e )
			{
			if ( splitMembers.getText().isEmpty() )
				{
				splitMembers.setText( "Split with (Player Names)" );
				}
			}
	} );
	splitValue.addFocusListener( new FocusListener() {
		@Override
		public void focusGained ( FocusEvent e )
			{
			if ( splitValue.getText().equals( "Split Value (Per-Player)" ) )
				{
				splitValue.setText( "" );
				}
			}
		
		@Override
		public void focusLost ( FocusEvent e )
			{
			if ( splitValue.getText().isEmpty() )
				{
				splitValue.setText( "Split Value (Per-Player)" );
				}
			}
	} );
	submitInfo.setFont( new Font( "RuneScape", Font.PLAIN, 15 ) );
	submitInfo.setPreferredSize( new Dimension( 0, 0 ) );
	submitInfo.setVisible( false );
	submitInfo.setFocusable( false );
	submitInfo.setBackground( ColorScheme.DARK_GRAY_COLOR );
	submitInfo.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	submitInfo.setForeground( Color.WHITE );
	submitInfo.setEditable( false );
	GridBagConstraints gbc_submitInfo = new GridBagConstraints();
	gbc_submitInfo.anchor = GridBagConstraints.SOUTH;
	gbc_submitInfo.fill = GridBagConstraints.HORIZONTAL;
	gbc_submitInfo.gridx = 0;
	gbc_submitInfo.gridy = 2;
	gbc_submitInfo.insets = new Insets( 4, 10, 5, 10 );
	add( submitInfo, gbc_submitInfo );
	
	thumbnail.setAutoscrolls( true );
	thumbnail.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	thumbnail.setForeground( Color.WHITE );
	thumbnail.setIcon( icon );
	GridBagConstraints gbc_thumbnail = new GridBagConstraints();
	gbc_thumbnail.anchor = GridBagConstraints.SOUTH;
	gbc_thumbnail.insets = new Insets( 6, 6, 6, 6 );
	gbc_thumbnail.gridx = 0;
	gbc_thumbnail.gridy = 5;
	add( thumbnail, gbc_thumbnail );
	}

public void panelOverride ( String bossName, String itemDropped, BufferedImage screenshot )
	{
	if ( ! (Objects.equals( npcName.getText(), "" )) && ! (Objects.equals( itemName.getText(), "" )) )
		{
		npcName.setText( bossName );
		itemName.setText( itemDropped );
		submitInfo.setFocusable( true );
		submitInfo.setVisible( true );
		if ( itemName.getText().contains( "Item Name" ) )
			{
			submitInfo.setText( "Could not get Item Information. Please try again after receiving loot." );
			return;
			}
		else
			{
			submitInfo.setText( "Found drop: " + itemDropped + " from " + bossName +
			                    ".\nFill out split info above and click submit to send to Discord." );
			}
		}
	thumbnail.setIcon( new ImageIcon( scaleImage( screenshot, 213, 120 ) ) );
	thumbnail.setHorizontalAlignment( SwingConstants.LEFT );
	before = screenshot;
	}

public BufferedImage scaleImage ( BufferedImage screenshot, int width, int height )
	{
	BufferedImage result = new BufferedImage( width, height, BufferedImage.TYPE_INT_RGB );
	Graphics2D resultGraphics = (Graphics2D) result.getGraphics();
	resultGraphics.setRenderingHint( RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR );
	resultGraphics.drawImage( screenshot, 0, 0, width, height, null );
	resultGraphics.dispose();
	return result;
	}

public void buildWomPanel ()
	{
	SwingUtilities.invokeLater( this::runBuilder );
	}

private void runBuilder ()
	{
	JPanel womPanel = new JPanel();
	womPanel.setFont( new Font( "RuneScape", Font.PLAIN, 13 ) );
	womPanel.setBorder( null );
	womPanel.setBackground( new Color( 30, 30, 30 ) );
	womPanel.setAlignmentY( 0.0f );
	GridBagConstraints gbc_womPanel = new GridBagConstraints();
	gbc_womPanel.anchor = GridBagConstraints.NORTH;
	gbc_womPanel.insets = new Insets( 8, 8, 8, 8 );
	gbc_womPanel.fill = GridBagConstraints.HORIZONTAL;
	gbc_womPanel.gridx = 0;
	gbc_womPanel.gridy = 3;
	add( womPanel, gbc_womPanel );
	GridBagLayout gbl_womPanel = new GridBagLayout();
	gbl_womPanel.columnWidths = new int[] {158, 0, 0};
	gbl_womPanel.rowHeights = new int[] {45, 0, 35, 0};
	gbl_womPanel.columnWeights = new double[] {1.0, 0.0, Double.MIN_VALUE};
	gbl_womPanel.rowWeights = new double[] {0.0, 0.0, 0.0, Double.MIN_VALUE};
	womPanel.setLayout( gbl_womPanel );
	JLabel lblWiseOldMan = new JLabel();
	lblWiseOldMan.setText( "WiseOldMan" );
	lblWiseOldMan.setHorizontalTextPosition( SwingConstants.CENTER );
	lblWiseOldMan.setHorizontalAlignment( SwingConstants.CENTER );
	lblWiseOldMan.setForeground( Color.WHITE );
	lblWiseOldMan.setFont( new Font( "RuneScape", Font.BOLD, 18 ) );
	lblWiseOldMan.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	lblWiseOldMan.setBorder( new EmptyBorder( 4, 0, 4, 0 ) );
	GridBagConstraints gbc_lblWiseOldMan = new GridBagConstraints();
	gbc_lblWiseOldMan.gridwidth = 2;
	gbc_lblWiseOldMan.fill = GridBagConstraints.HORIZONTAL;
	gbc_lblWiseOldMan.anchor = GridBagConstraints.SOUTH;
	gbc_lblWiseOldMan.insets = new Insets( 8, 0, 5, 5 );
	gbc_lblWiseOldMan.gridx = 0;
	gbc_lblWiseOldMan.gridy = 0;
	womPanel.add( lblWiseOldMan, gbc_lblWiseOldMan );
	JLabel lblGetGroupId = new JLabel( "Get List of Members by Group ID:" );
	lblGetGroupId.setForeground( Color.WHITE );
	GridBagConstraints gbc_lblGetGroupId = new GridBagConstraints();
	gbc_lblGetGroupId.gridwidth = 2;
	gbc_lblGetGroupId.insets = new Insets( 0, 0, 5, 5 );
	gbc_lblGetGroupId.gridx = 0;
	gbc_lblGetGroupId.gridy = 1;
	womPanel.add( lblGetGroupId, gbc_lblGetGroupId );
	JComboBox<Object> groupComboBox = new JComboBox<>();
	GridBagConstraints gbc_groupComboBox = new GridBagConstraints();
	gbc_groupComboBox.fill = GridBagConstraints.HORIZONTAL;
	gbc_groupComboBox.insets = new Insets( 4, 4, 5, 4 );
	gbc_groupComboBox.gridx = 0;
	gbc_groupComboBox.gridy = 2;
	womPanel.add( groupComboBox, gbc_groupComboBox );
	JButton btnRefresh = new JButton( "Refresh" );
	btnRefresh.setForeground( Color.WHITE );
	btnRefresh.setComponentOrientation( ComponentOrientation.LEFT_TO_RIGHT );
	GridBagConstraints gbc_btnRefresh = new GridBagConstraints();
	gbc_btnRefresh.insets = new Insets( 4, 4, 5, 4 );
	gbc_btnRefresh.gridx = 1;
	gbc_btnRefresh.gridy = 2;
	womPanel.add( btnRefresh, gbc_btnRefresh );
	JComboBox<Object> memberList = new JComboBox<>();
	GridBagConstraints gbc_memberList = new GridBagConstraints();
	gbc_memberList.insets = new Insets( 4, 4, 5, 4 );
	gbc_memberList.fill = GridBagConstraints.BOTH;
	gbc_memberList.gridx = 0;
	gbc_memberList.gridy = 3;
	memberList.setForeground( Color.WHITE );
	womPanel.add( memberList, gbc_memberList );
	JButton btnAddMember = new JButton( "Add to Split" );
	GridBagConstraints gbc_btnAddMember = new GridBagConstraints();
	gbc_btnAddMember.gridx = 1;
	gbc_btnAddMember.gridy = 3;
	btnAddMember.setForeground( Color.WHITE );
	womPanel.add( btnAddMember, gbc_btnAddMember );
	refreshPanel( womPanel, groupComboBox, memberList, lblGetGroupId, btnRefresh );
	btnRefresh.addActionListener( e -> SwingUtilities.invokeLater( () ->
		{
		int groupIndex = 0;
		if ( Objects.equals( btnRefresh.getText(), "Refresh" ) )
			{refreshPanel( womPanel, groupComboBox, memberList, lblGetGroupId, btnRefresh );}
		if ( Objects.equals( btnRefresh.getText(), "Search" ) )
			{
			groupIndex = groupComboBox.getSelectedIndex();
			}
		int groupId = Integer.parseInt( String.valueOf( (groupComboBox.getSelectedItem()) ) );
		groupComboBox.removeAllItems();
		try
			{
			groupComboBox.setModel( new DefaultComboBoxModel<>(
					requireNonNull( getWomGroupIds( requireNonNull( client.getLocalPlayer().getName() ) ) ) ) );
			}
		catch (IOException | InterruptedException ex)
			{
			throw new RuntimeException( ex );
			}
		memberList.removeAllItems();
		int finalGroupIndex = groupIndex;
		CompletableFuture.runAsync( () ->
			{
			try
				{
				memberList.setModel(
						new DefaultComboBoxModel<>( Objects.requireNonNull( getGroupMembers( groupId ) ) ) );
				}
			catch (IOException | InterruptedException ex)
				{
				throw new RuntimeException( ex );
				}
			
			try
				{
				String clanName = getClanName( groupId );
				lblGetGroupId.setText( clanName );
				}
			catch (IOException | InterruptedException ex)
				{
				throw new RuntimeException( ex );
				}
			groupComboBox.setSelectedIndex( finalGroupIndex );
			btnRefresh.setText( "Search" );
			} );
		} ) );
	btnAddMember.addActionListener( e ->
		{
		if ( splitMembers.getText().contains( "Split with" ) )
			{
			splitMembers.setText( requireNonNull( memberList.getSelectedItem() ).toString() );
			}
		else
			{
			if ( splitMembers.getText().contains( (CharSequence) requireNonNull( memberList.getSelectedItem() ) ) )
				{
				return;
				}
			splitMembers.setText( splitMembers.getText() + ", " + requireNonNull( memberList.getSelectedItem() ) );
			}
		} );
	}

public void submitLoot ( JTextField splitValue, JTextField splitMembers, JTextField itemName, JTextField npcName, JTextPane submitInfo, DiscordNotificationsAIOConfig config, ArrayList<Monster> mobs, DiscordNotificationsAIOPlugin plugin )
	{
	CompletableFuture.runAsync( () ->
		{
		String itemText = "Item Name";
		String npcText = "Boss/NPC Name";
		String valueText = "Split Value (Per-Player)";
		String membersText = "Split with (Player Names)";
		String splitSubmitText = "";
		String notificationType;
		
		submitInfo.setFocusable( true );
		submitInfo.setVisible( true );
		
		if ( ! splitMembers.getText().contains( membersText ) || ! splitValue.getText().contains( valueText ) ||
		     ! itemName.getText().contains( itemText ) || ! npcName.getText().contains( npcText ) )
			{
			splitSubmitText = "Sent screenshot with:\n";
			} else splitSubmitText = splitSubmitText + "Some fields were missing text.\n";
		
		if ( itemName.getText().contains( itemText ) )
			{
			splitSubmitText = splitSubmitText + "Could not get Item Name.";
			}
		else
			{
			splitSubmitText = splitSubmitText + "Item Name: " + itemName.getText();
			}
		
		if ( npcName.getText().contains( npcText ) )
			{
			splitSubmitText = splitSubmitText + "\nCould not get Boss/NPC Name.";
			notificationType = "Manual Upload";
			}
		else
			{
			splitSubmitText = splitSubmitText + "\nBoss/NPC Name: " + npcName.getText();
			notificationType = "Loot Received";
			}
		
		if ( splitValue.getText().contains( valueText ) )
			{
			splitSubmitText = splitSubmitText + "\nCould not get Split Value.";
			}
		else
			{
			splitSubmitText = splitSubmitText + "\nSplit Value: " + splitValue.getText();
			}
		
		if ( splitMembers.getText().contains( membersText ) )
			{
			splitSubmitText = splitSubmitText + "\nCould not get Split Members.";
			}
		else
			{
			notificationType = "Split Loot";
			}
		
		
		if ( ! itemName.getText().contains( itemText ) && ! npcName.getText().contains( npcText ) &&
		     ! splitMembers.getText().contains( membersText ) && ! splitValue.getText().contains( valueText ) )
			{
			try
				{
				String rarity;
				if ( config.includeRarity() )
					{rarity = Objects.requireNonNull( getItemRarity( mobs, npcName.getText(), itemName.getText() ) );}
				else {rarity = "";}
				plugin.sendLootMessage( itemName.getText(), null, npcName.getText(), splitValue.getText(),
						notificationType,
//						getWikiIcon( itemName.getText() )
						"", splitMembers.getText(), rarity, false );
				}
			catch (IOException ex)
				{
				throw new RuntimeException( ex );
				}
			}
		else if ( ! itemName.getText().contains( itemText ) && ! npcName.getText().contains( npcText ) )
			{
			try
				{
				String rarity;
				if ( config.includeRarity() )
					{rarity = Objects.requireNonNull( getItemRarity( mobs, npcName.getText(), itemName.getText() ) );}
				else {rarity = "";}
				plugin.sendLootMessage( itemName.getText(), null, npcName.getText(), "", notificationType,
						itemName.getText(), "", rarity, false );
				}
			catch (IOException ex)
				{
				throw new RuntimeException( ex );
				}
			}
		else if ( (! splitMembers.getText().contains( membersText ) && ! splitValue.getText().contains( valueText )) )
			{
			plugin.sendLootMessage( "a split", null, "", splitValue.getText(), notificationType, "",
					splitMembers.getText(), "", false );
			}
		else if ( itemName.getText().contains( itemText ) || npcName.getText().contains( npcText ) )
			{
			if ( splitValue.getText().contains( valueText ) || splitMembers.getText().contains( membersText ) )
				{splitSubmitText = "Could not get Split or Item Information. Please try again after receiving loot.";}
			else
				{
				splitSubmitText = "Could not get Item Information. Please try again after receiving loot.";
				}
			}
		
		submitInfo.setEditable( true );
		submitInfo.setText( splitSubmitText );
		itemName.setText( itemText );
		npcName.setText( npcText );
		splitValue.setText( valueText );
		splitMembers.setText( membersText );
		} );
	}

public void refreshPanel ( JPanel womPanel, JComboBox<Object> groupComboBox, JComboBox<Object> memberList, JLabel lblGetGroupId, JButton btnRefresh )
	{
	SwingUtilities.invokeLater( () ->
		{
		this.womPanel = womPanel;
		this.groupComboBox = groupComboBox;
		this.memberList = memberList;
		this.lblGetGroupId = lblGetGroupId;
		this.btnRefresh = btnRefresh;
		CompletableFuture.runAsync( () ->
			{
			try
				{
				groupComboBox.setModel( new DefaultComboBoxModel<>(
						requireNonNull( getWomGroupIds( requireNonNull( client.getLocalPlayer().getName() ) ) ) ) );
				int groupId = Integer.parseInt( String.valueOf( (groupComboBox.getSelectedItem()) ) );
				String clanName = getClanName( groupId );
				lblGetGroupId.setText( clanName );
				}
			catch (IOException | InterruptedException ex)
				{
				throw new RuntimeException( ex );
				}
			try
				{
				int groupId = Integer.parseInt( String.valueOf( (groupComboBox.getSelectedItem()) ) );
				memberList.setModel(
						new DefaultComboBoxModel<>( Objects.requireNonNull( getGroupMembers( groupId ) ) ) );
				}
			catch (IOException | InterruptedException ex)
				{
				throw new RuntimeException( ex );
				}
			btnRefresh.setText( "Search" );
			} );
			
		} );
	}
	
}

package com.discordnotificationsaio.wiseoldman;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

public class Groups{

	@SerializedName("score")
	@Expose
	private int score;

	@SerializedName("createdAt")
	@Expose
	private String createdAt;

	@SerializedName("homeworld")
	@Expose
	private Object homeworld;

	@SerializedName("clanChat")
	@Expose
	private String clanChat;

	@SerializedName("memberCount")
	@Expose
	private int memberCount;

	@SerializedName("name")
	@Expose
	private String name;

	@SerializedName("verified")
	@Expose
	private boolean verified;

	@SerializedName("description")
	@Expose
	private Object description;

	@SerializedName("id")
	@Expose
	private int id;

	@SerializedName("updatedAt")
	@Expose
	private String updatedAt;

	public void setScore(int score){
		this.score = score;
	}

	public int getScore(){
		return score;
	}

	public void setCreatedAt(String createdAt){
		this.createdAt = createdAt;
	}

	public String getCreatedAt(){
		return createdAt;
	}

	public void setHomeworld(Object homeworld){
		this.homeworld = homeworld;
	}

	public Object getHomeworld(){
		return homeworld;
	}

	public void setClanChat(String clanChat){
		this.clanChat = clanChat;
	}

	public String getClanChat(){
		return clanChat;
	}

	public void setMemberCount(int memberCount){
		this.memberCount = memberCount;
	}

	public int getMemberCount(){
		return memberCount;
	}

	public void setName(String name){
		this.name = name;
	}

	public String getName(){
		return name;
	}

	public void setVerified(boolean verified){
		this.verified = verified;
	}

	public boolean isVerified(){
		return verified;
	}

	public void setDescription(Object description){
		this.description = description;
	}

	public Object getDescription(){
		return description;
	}

	public void setId(int id){
		this.id = id;
	}

	public int getId(){
		return id;
	}

	public void setUpdatedAt(String updatedAt){
		this.updatedAt = updatedAt;
	}

	public String getUpdatedAt(){
		return updatedAt;
	}

	@Override
 	public String toString(){
		return 
			"Groups{" + 
			"score = '" + score + '\'' + 
			",createdAt = '" + createdAt + '\'' + 
			",homeworld = '" + homeworld + '\'' + 
			",clanChat = '" + clanChat + '\'' + 
			",memberCount = '" + memberCount + '\'' + 
			",name = '" + name + '\'' + 
			",verified = '" + verified + '\'' + 
			",description = '" + description + '\'' + 
			",id = '" + id + '\'' + 
			",updatedAt = '" + updatedAt + '\'' + 
			"}";
		}
}
/*
 * Copyright (c) 2022, RinZ
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.discordnotificationsaio;

import com.discordnotificationsaio.rarity.Drop;
import com.discordnotificationsaio.rarity.Monster;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.input.KeyManager;
import net.runelite.client.party.PartyMember;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.http.api.loottracker.LootRecordType;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;
import org.json.JSONArray;
import org.json.JSONObject;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static com.discordnotificationsaio.ApiTools.getItemRarity;
import static net.runelite.api.widgets.WidgetID.QUEST_COMPLETED_GROUP_ID;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
@PluginDescriptor (name = "Discord Notifications/Split Tracker")
public class DiscordNotificationsAIOPlugin extends Plugin {
private static final String COLLECTION_LOG_TEXT = "New item added to your collection log: ";

private static final Pattern KC_PATTERN = Pattern.compile(
		"Your (?<pre>completion count for |subdued |completed )?(?<boss>.+?) (?<post>(?:(?:kill|harvest|lap|completion) )?(?:count )?)is: <col=ff0000>(?<kc>\\d+)</col>" );
// private Map<String, String> lastValuableDropItems;
private static final Map<String, String> KILLCOUNT_RENAMES = ImmutableMap.of( "Barrows chest", "Barrows Chests" );
// private static final Pattern VALUABLE_DROP_PATTERN =
// Pattern.compile(".*Valuable drop: ([^<>]+?\\(((?:\\d+,?)+)
// coins\\))(?:</col>)?");
private static final ImmutableList<String> PET_MESSAGES =
		ImmutableList.of( "You have a funny feeling like you're being followed",
				"You feel something weird sneaking into your backpack",
				"You have a funny feeling like you would have been followed" );
private static final String COX_DUST_MESSAGE_TEXT = "Dust recipients: ";
private static final String COX_KIT_MESSAGE_TEXT = "Twisted Kit recipients: ";
private static final Pattern TOB_UNIQUE_MESSAGE_PATTERN = Pattern.compile( "(.+) found something special: (.+)" );

private static final Pattern QUEST_PATTERN_1 =
		Pattern.compile( ".+?ve\\.*? (?<verb>been|rebuilt|.+?ed)? ?(?:the )?'?(?<quest>.+?)'?(?: [Qq]uest)?[!.]?$" );

private static final Pattern QUEST_PATTERN_2 =
		Pattern.compile( "'?(?<quest>.+?)'?(?: [Qq]uest)? (?<verb>[a-z]\\w+?ed)?(?: f.*?)?[!.]?$" );

private static final ImmutableList<String> RFD_TAGS = ImmutableList.of( "Another Cook", "freed", "defeated", "saved" );

private static final ImmutableList<String> WORD_QUEST_IN_NAME_TAGS =
		ImmutableList.of( "Another Cook", "Doric", "Heroes", "Legends", "Observatory", "Olaf", "Waterfall" );
private final String rarity = "";
public String playerName;
public String boss;
public String itemName;
public Integer itemKc;
public String bossName;
public String itemValue;
public String notificationType;
@Inject
public Client client;
@Inject
public DiscordNotificationsAIOConfig config;
@Inject
public OkHttpClient okHttpClient;
@Inject
public KeyManager keyManager;
// TODO: Include kc for the other notification types too
// - Collection log entries
// - Pets
@Inject
public DrawManager drawManager;
@Inject
public ConfigManager configManager;
public PartyMember partyMember;
private ClientThread clientThread;
private String lastBossKill;
private int lastBossKC = - 1;
private Hashtable<String, Integer> currentLevels;
private ArrayList<String> leveledSkills;
private boolean shouldSendLevelMessage = false;
private boolean shouldSendQuestMessage = false;
private boolean shouldSendClueMessage = false;
private int ticksWaited = 0;
private boolean shouldSendLootMessage;
private boolean notificationStarted;
@Getter (AccessLevel.PACKAGE)
@Setter (AccessLevel.PACKAGE)
private DiscordNotificationsAIOPanel discordNotificationsAIOPanel;
@Inject
private ItemManager itemManager;
@Inject
private ClientToolbar clientToolbar;
private String playerIconUrl = "";
private ArrayList<Monster> mobs = parseJsonToPojo();
private int colorCode = 0;
private NavigationButton navButton;
private static String itemImageUrl(int itemId)
	{
	return "https://static.runelite.net/cache/item/icon/" + itemId + ".png";
	}

public DiscordNotificationsAIOPlugin () throws IOException {}

private static byte[] convertImageToByteArray ( BufferedImage bufferedImage ) throws IOException
	{
	ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
	ImageIO.write( bufferedImage, "png", byteArrayOutputStream );
	return byteArrayOutputStream.toByteArray();
	}

public static ArrayList<Monster> parseJsonToPojo () throws IOException
	{
	ArrayList<Monster> npcs = new ArrayList<>();
	Monster npc = null;
	Drop drop = null;
	try (BufferedReader br = new BufferedReader(
			new InputStreamReader( DiscordNotificationsAIOPlugin.class.getResourceAsStream( "drop-info.json" ) ) ))
		{
		String line;
		while ( (line = br.readLine()) != null )
			{
			if ( line.contains( ": [" ) )
				{
				npc = new Monster( line.replace( "\": [", "" ).replace( "\"", "" ).replace( " ", "" ) );
				}
			if ( line.contains( "\"n\":" ) )
				{
				drop = new Drop();
				drop.setName( line.replace( "\"n\": ", "" ).replace( ",", "" ).replace( "\"", "" ).trim() );
				}
			if ( line.contains( "\"q\":" ) )
				{
				if ( drop != null )
					{
					drop.setQuantity( line.replace( "\"q\": ", "" ).replace( ",", "" ).replace( "\"", "" ).trim() );
					}
				}
			if ( line.contains( "\"o\":" ) )
				{
				if ( drop != null )
					{
					drop.setRolls(
							line.replace( "\"o\": ", "" ).replace( ",", "" ).replace( "\"", "" ).replace( " ", "" ) );
					}
				}
			if ( line.contains( "\"r\":" ) )
				{
				if ( drop != null )
					{
					drop.setRarity(
							line.replace( "\"r\": ", "" ).replace( ",", "" ).replace( "\"", "" ).replace( " ", "" ) );
					}
				if ( npc != null )
					{
					npc.addDrops( drop );
					}
				}
			if ( line.contains( "]," ) )
				{
				npcs.add( npc );
				}
				
			}
		return npcs;
		}
	}

static String parseQuestCompletedWidget ( final String text )
	{
	// "You have completed The Corsair Curse!"
	final Matcher questMatch1 = QUEST_PATTERN_1.matcher( text );
	// "'One Small Favour' completed!"
	final Matcher questMatch2 = QUEST_PATTERN_2.matcher( text );
	final Matcher questMatchFinal = questMatch1.matches() ? questMatch1 : questMatch2;
	if ( ! questMatchFinal.matches() )
		{
		return "Unable to find quest name!";
		}
	
	String quest = questMatchFinal.group( "quest" );
	String verb = questMatchFinal.group( "verb" ) != null ? questMatchFinal.group( "verb" ) : "";
	
	if ( verb.contains( "kind of" ) )
		{
		quest += " partial completion";
		}
	else if ( verb.contains( "completely" ) )
		{
		quest += " II";
		}
	
	if ( RFD_TAGS.stream().anyMatch( (quest + verb)::contains ) )
		{
		quest = "Recipe for Disaster - " + quest;
		}
	
	if ( WORD_QUEST_IN_NAME_TAGS.stream().anyMatch( quest::contains ) )
		{
		quest += " Quest";
		}
	
	return quest;
	}

@Provides
DiscordNotificationsAIOConfig provideConfig ( ConfigManager configManager )
	{
	return configManager.getConfig( DiscordNotificationsAIOConfig.class );
	}

private void setKc ( String boss, int killcount )
	{
	configManager.setRSProfileConfiguration( "killcount", boss.toLowerCase(), killcount );
	}

private void unsetKc ( String boss )
	{
	configManager.unsetRSProfileConfiguration( "killcount", boss.toLowerCase() );
	}

public int getKc ( String playerName, String boss )
	{
	this.playerName = playerName;
	this.boss = boss;
	Integer killCount = configManager.getRSProfileConfiguration( "killcount", boss.toLowerCase(), int.class );
	return killCount == null ? 0 : killCount;
	}

@Override
protected void startUp () throws Exception
	{
	discordNotificationsAIOPanel = new DiscordNotificationsAIOPanel( this, config, client, mobs );
	
	final BufferedImage icon = ImageUtil.loadImageResource( getClass(), "balance.png" );
	
	currentLevels = new Hashtable<String, Integer>();
	
	leveledSkills = new ArrayList<String>();
	
	navButton = NavigationButton.builder().tooltip( "Split Tracker" ).icon( icon ).priority( 5 )
	                            .panel( discordNotificationsAIOPanel ).build();
	
	clientToolbar.addNavigation( navButton );
	
	}

@Override
protected void shutDown () throws Exception
	{
	notificationStarted = false;
	clientToolbar.removeNavigation( navButton );
	currentLevels = null;
	leveledSkills = null;
	mobs = null;
	}

@Subscribe
public void onUsernameChanged ( UsernameChanged usernameChanged )
	{
	resetState();
	}

@Subscribe
public void onGameStateChanged ( GameStateChanged event )
	{
	if ( event.getGameState().equals( GameState.LOGIN_SCREEN ) )
		{
		resetState();
		}
	else
		{
		switch (client.getAccountType())
			{
			case IRONMAN:
				playerIconUrl = "https://oldschool.runescape.wiki/images/0/09/Ironman_chat_badge.png";
			case HARDCORE_IRONMAN:
				playerIconUrl = "https://oldschool.runescape.wiki/images/b/b8/Hardcore_ironman_chat_badge.png";
			case ULTIMATE_IRONMAN:
				playerIconUrl = "https://oldschool.runescape.wiki/images/0/02/Ultimate_ironman_chat_badge.png";
			case GROUP_IRONMAN:
				playerIconUrl = "https://oldschool.runescape.wiki/images/Group_ironman_chat_badge.png";
			case HARDCORE_GROUP_IRONMAN:
				playerIconUrl = "https://oldschool.runescape.wiki/images/Hardcore_group_ironman_chat_badge.png";
			case NORMAL:
				playerIconUrl =
						"https://oldschool.runescape.wiki/images/thumb/Grand_Exchange_logo.png/225px-Grand_Exchange_logo.png?88cff";
			default:
				playerIconUrl = "";
			}
		shouldSendLootMessage = true;
		}
	}

@Subscribe
public void onGameTick ( GameTick event )
	{
	boolean didCompleteClue = client.getWidget( WidgetInfo.CLUE_SCROLL_REWARD_ITEM_CONTAINER ) != null;
	
	if ( ! client.getGameState().equals( GameState.LOGGED_IN ) )
		{
		return;
		}
	if ( Objects.equals( playerIconUrl, "" ) )
		{
		playerIconUrl = getPlayerIconUrl();
		colorCode = getColorCode();
		CompletableFuture.runAsync( () -> discordNotificationsAIOPanel.buildWomPanel() );
		}
	
	if ( shouldSendClueMessage && didCompleteClue && config.includeClue() )
		{
		shouldSendClueMessage = false;
		sendClueMessage();
		}
	if ( shouldSendQuestMessage && config.includeQuestComplete() &&
	     client.getWidget( WidgetInfo.QUEST_COMPLETED_NAME_TEXT ) != null )
		{
		shouldSendQuestMessage = false;
		String text = client.getWidget( WidgetInfo.QUEST_COMPLETED_NAME_TEXT ).getText();
		String questName = parseQuestCompletedWidget( text );
		sendQuestMessage( questName );
		}
	if ( ! shouldSendLevelMessage )
		{
		return;
		}
	
	if ( ticksWaited < 2 )
		{
		ticksWaited++;
		return;
		}
	
	shouldSendLevelMessage = false;
	ticksWaited = 0;
	sendLevelMessage();
	
	}


// private final List<PartyMember> members = new ArrayList<>();
//
// public PartyMember getMemberById(final long id) {
// for (PartyMember member : members) {
// if (id == member.getMemberId()) {
// return member;
// }
// }
//
// return null;
// }
//
// @Subscribe
// public void onUserJoin(UserJoin message) {
// PartyMember partyMember = getMemberById(message.getMemberId());
// if (partyMember == null) {
// partyMember = new PartyMember(message.getMemberId());
// members.add(partyMember);
// log.info("User {} joins party, {} members", partyMember.getMemberId(),
// members.size());
// }
//
// }

@Subscribe
public void onStatChanged ( net.runelite.api.events.StatChanged statChanged )
	{
	if ( ! config.includeLevelling() )
		{
		return;
		}
	
	String skillName = statChanged.getSkill().getName();
	int newLevel = statChanged.getLevel();
	
	// .contains wasn't behaving so I went with == null
	Integer previousLevel = currentLevels.get( skillName );
	if ( previousLevel == null || previousLevel == 0 )
		{
		currentLevels.put( skillName, newLevel );
		return;
		}
	
	if ( previousLevel != newLevel )
		{
		currentLevels.put( skillName, newLevel );
		
		// Certain activities can multilevel, check if any of the levels are valid for the message.
		for ( int level = previousLevel + 1 ; level <= newLevel ; level++ )
			{
			if ( shouldSendForThisLevel( level ) )
				{
				leveledSkills.add( skillName );
				shouldSendLevelMessage = true;
				break;
				}
			}
		}
	}


// lastValuableDropItems.forEach((name, value) ->
// {
// items.forEach(itemStack ->
// {
// String itemName =
// itemManager.getItemComposition(itemStack.getId()).getName();
// if (itemName == name)
// {
// itemStack.getId()
// }
// });
// });

@Subscribe
public void onNpcLootReceived ( NpcLootReceived event ) throws IOException, InterruptedException,
		                                                               InvocationTargetException
	{
	if ( isPlayerIgnored() ) return;
	if ( ! config.autoLog() ) return;
	NPC npc = event.getNpc();
	Collection<ItemStack> items = event.getItems();
	
	if ( items.isEmpty() || npc == null )
		{
		return;
		}
	
	String npcName = npc.getName();
	
	for ( ItemStack itemStack : items )
		{
		int itemId = itemStack.getId();
		int value = itemManager.getItemPrice( itemId ) * itemStack.getQuantity();
		if ( value >= config.valuableDropThreshold() )
			{
			String itemName = itemManager.getItemComposition( itemId ).getName();
			final String[] rarity = {""};
			rarity[0] = String.valueOf( getItemRarity( mobs, npcName, itemName ) );
			if ( config.includeRarity() && config.rarityThreshold() <= Integer.parseInt( rarity[0] ))
				{
				CompletableFuture.runAsync( () ->
					{
					dataToPanel( npcName, itemName );
					AtomicReference<String> thumbnailUrl = new AtomicReference<>( "" );
					thumbnailUrl.set( itemImageUrl( itemId ) );
					String finalRarity = rarity[0];
					if ( Integer.parseInt( rarity[0] ) >= config.rarityThreshold() )
						{
						sendLootMessage( itemName, lastBossKC == - 1 ? null : getKc( playerName, lastBossKill ), npcName,
								Integer.toString( value ), "Loot Received", thumbnailUrl.get(), "", finalRarity,
								config.autoLog() );
						unsetKc( lastBossKill );
						}
					});
					}
			else if (!config.includeRarity())
				{
				String finalRarity = "";
				dataToPanel( npcName, itemName );
				AtomicReference<String> thumbnailUrl = new AtomicReference<>( "" );
				CompletableFuture.runAsync( () ->
					{
					thumbnailUrl.set( itemImageUrl( itemId ) );
					sendLootMessage( itemName, lastBossKC == - 1 ? null : getKc( playerName, lastBossKill ), npcName,
							Integer.toString( value ), "Loot Received", thumbnailUrl.get(), "", finalRarity,
							config.autoLog() );
					unsetKc( lastBossKill );
					} );
				}
			}
		}
	}

//	private CompletableFuture<ItemData> getLootReceivedItemData(String eventName, LootRecordType lootRecordType, int itemId){
//	CompletableFuture<ItemData> result = new CompletableFuture<>();
//
//	ItemData itemData = lootRecordType == LootRecordType.PICKPOCKET ?
//	                    rarityChecker.CheckRarityPickpocket(eventName, EnrichItem(itemId), itemManager) :
//	                    rarityChecker.CheckRarityEvent(eventName, EnrichItem(itemId), itemManager);
//
//	result.complete(itemData);
//	return result;
//	}
//
//	private CompletableFuture<ItemData> getNPCLootReceivedItemData(int npcId, int itemId, int quantity)
//		{
//		ItemData incomplete = EnrichItem(itemId);
//		return rarityChecker.CheckRarityNPC(npcId, incomplete, itemManager, quantity);
//		}

@Subscribe
public void onLootReceived ( LootReceived lootReceived )
	{
	if ( isPlayerIgnored() ) return;
	
	// Only process EVENTS such as Barrows, CoX etc. and PICKPOCKET
	// For NPCs onNpcLootReceived receives more information and is used instead.
	if ( lootReceived.getType() == LootRecordType.NPC )
		{
		return;
		}
	String npcName = lootReceived.getName();
	
	Collection<ItemStack> items = lootReceived.getItems();
	
	for ( ItemStack itemStack : items )
		{
		int itemId = itemStack.getId();
		int value = itemManager.getItemPrice( itemId ) * itemStack.getQuantity();
		if ( value >= config.valuableDropThreshold() )
			{
			String itemName = itemManager.getItemComposition( itemId ).getName();
			dataToPanel( npcName, itemName );
			final String[] rarity = {""};
			if ( config.includeRarity() )
				{
				CompletableFuture.runAsync( () ->
					{
					dataToPanel( npcName, itemName );
					AtomicReference<String> thumbnailUrl = new AtomicReference<>( "" );
					thumbnailUrl.set( itemImageUrl( itemId ) );
					String finalRarity = rarity[0];
//						if ( Integer.parseInt( rarity[0] ) >= config.rarityThreshold() )
					{
					sendLootMessage( itemName, lastBossKC == - 1 ? null : getKc( playerName, lastBossKill ), npcName,
							Integer.toString( value ), "Loot Received", thumbnailUrl.get(), "", finalRarity,
							config.autoLog() );
					unsetKc( lastBossKill );
					}
					});
				}
			else if (!config.includeRarity())
				{
				rarity[0] = "";
				
				dataToPanel( npcName, itemName );
				AtomicReference<String> thumbnailUrl = new AtomicReference<>( "" );
				String finalRarity = rarity[0];
				CompletableFuture.runAsync( () ->
					{
					thumbnailUrl.set( itemImageUrl( itemId ) );
					sendLootMessage( itemName, lastBossKC == - 1 ? null : getKc( playerName, lastBossKill ), npcName,
							Integer.toString( value ), "Loot Received", thumbnailUrl.get(), "", finalRarity,
							config.autoLog() );
					unsetKc( lastBossKill );
					} );
				}
			}
		}
	}

//	private ItemRarity EnrichItem( int itemId)
//		{
//		ItemRarity r = new ItemRarity();
//		r.ItemId = itemId;
//
//		if(log.isDebugEnabled()){
//		log.debug( MessageFormat.format("Item {0} prices HA{1}, GE{2}", itemId));
//		}
//
//		return r;
//		}

//	private CompletableFuture<Boolean> processNpcNotification(NPC npc, int itemId, int quantity, float rarity)
//		{
//		int npcId = npc.getId();
//		int npcCombatLevel = npc.getCombatLevel();
//		String npcName = npc.getName();
//
//		CompletableFuture<Boolean> f = new CompletableFuture<>();
//		clientThread.invokeLater(() -> {
//		sendLootMessage( itemManager.getItemComposition(itemId).getName(),getKc(playerName,
//				Objects.requireNonNull( npcName ) ),npcName,itemValue,"Loot Received","","",true );
//			});
//		return f;
//		}

@Subscribe
public void onChatMessage ( ChatMessage event )
	{
	{
	if ( event.getType() != ChatMessageType.GAMEMESSAGE )
		{
		return;
		}
	
	String chatMessage = event.getMessage();
	if ( config.setPets() && PET_MESSAGES.stream().anyMatch( chatMessage::contains ) )
		{
		sendPetMessage();
		}
	if ( config.setCollectionLogs() && chatMessage.startsWith( COLLECTION_LOG_TEXT ) &&
	     client.getVarbitValue( Varbits.COLLECTION_LOG_NOTIFICATION ) == 1 )
		{
		String itemName = Text.removeTags( chatMessage ).substring( COLLECTION_LOG_TEXT.length() );
		sendCollectionLogMessage( itemName );
		}
	}
	
	String message = event.getMessage();
	Matcher kcmatcher = KC_PATTERN.matcher( message );
	
	final String playerName = client.getLocalPlayer().getName();
	
	if ( config.includeValuableDrops() )
		{
		if ( kcmatcher.find() )
			{
			lastBossKC = - 1;
			
			final String boss = kcmatcher.group( "boss" );
			final int kc = Integer.parseInt( kcmatcher.group( "kc" ) );
			final String pre = kcmatcher.group( "pre" );
			final String post = kcmatcher.group( "post" );
			
			if ( Strings.isNullOrEmpty( pre ) && Strings.isNullOrEmpty( post ) )
				{
				unsetKc( boss );
				}
			
			String renamedBoss = KILLCOUNT_RENAMES.getOrDefault( boss, boss )
			                                      // The config service doesn't support keys with colons in them
			                                      .replace( ":", "" );
			if ( ! Objects.equals( boss, renamedBoss ) )
				{
				// Unset old TOB kc
				unsetKc( boss );
				unsetKc( boss.replace( ":", "." ) );
				// Unset old story mode
				unsetKc( "Theatre of Blood Story Mode" );
				}
			
			setKc( renamedBoss, kc );
			lastBossKill = renamedBoss;
			lastBossKC = kc;
			}
		}
	// {
	// Matcher matcher = VALUABLE_DROP_PATTERN.matcher(message);
	// if (matcher.matches())
	// {
	// int valuableDropValue = Integer.parseInt(matcher.group(2).replaceAll(",",
	// ""));
	// if (valuableDropValue >= config.valuableDropThreshold())
	// {
	// String[] valuableDrop = matcher.group(1).split(" \\(");
	// String valuableDropName = (String) Array.get(valuableDrop, 0);
	// String valuableDropValueString = matcher.group(2);
	//
	// itemManager.search(valuableDropName);
	//
	// lastValuableDropItems.put(valuableDropName, valuableDropValueString);
	//// sendLootMessage(valuableDropName, getKc(playerName,lastBossKill), "",
	// valuableDropValueString, "Boss Loot");
	// }
	// }
	// }
	// } else {
	// Matcher matcher = VALUABLE_DROP_PATTERN.matcher(message);
	// if (matcher.matches())
	// {
	// int valuableDropValue = Integer.parseInt(matcher.group(2).replaceAll(",",
	// ""));
	// if (valuableDropValue >= config.valuableDropThreshold())
	// {
	// String[] valuableDrop = matcher.group(1).split(" \\(");
	// String valuableDropName = (String) Array.get(valuableDrop, 0);
	// String valuableDropValueString = matcher.group(2);
	// sendLootMessage(valuableDropName, null, "", valuableDropValueString, "Boss
	// Loot");
	// }
	// }
	
	
	if ( config.includeRaidLoot() )
		{
		if ( message.startsWith( COX_DUST_MESSAGE_TEXT ) )
			{
			final String dustRecipient = Text.removeTags( message ).substring( COX_DUST_MESSAGE_TEXT.length() );
			final String dropName = "Metamorphic dust";
			
			if ( dustRecipient.equals( Text.sanitize( Objects.requireNonNull( client.getLocalPlayer().getName() ) ) ) )
				{
				itemName = dropName;
				sendLootMessage( itemName, getKc( playerName, "cox cm" ), "Chambers of Xeric: Challenge Mode", "",
						"Loot Received",
						"https://oldschool.runescape.wiki/images/thumb/Metamorphic_dust_detail.png/150px-Metamorphic_dust_detail.png",
						"", "400", true );
				unsetKc( "cox cm" );
				}
			}
		if ( message.startsWith( COX_KIT_MESSAGE_TEXT ) )
			{
			final String dustRecipient = Text.removeTags( message ).substring( COX_KIT_MESSAGE_TEXT.length() );
			final String dropName = "Twisted ancestral colour kit";
			
			if ( dustRecipient.equals( Text.sanitize( Objects.requireNonNull( client.getLocalPlayer().getName() ) ) ) )
				{
				itemName = dropName;
				sendLootMessage( itemName, getKc( playerName, "Chambers of Xeric Challenge Mode" ),
						"Chambers of Xeric: Challenge Mode", "", "Loot Received",
						"https://oldschool.runescape.wiki/images/thumb/Metamorphic_dust_detail.png/150px-Metamorphic_dust_detail.png",
						"", "75", true );
				unsetKc( "cox cm" );
				}
			}
		
		Matcher tobUniqueMessage = TOB_UNIQUE_MESSAGE_PATTERN.matcher( message );
		if ( tobUniqueMessage.matches() )
			{
			final String lootRecipient = Text.sanitize( tobUniqueMessage.group( 1 ) ).trim();
			final String dropName = tobUniqueMessage.group( 2 ).trim();
			
			if ( lootRecipient.equals( Text.sanitize( Objects.requireNonNull( client.getLocalPlayer().getName() ) ) ) )
				{
				itemName = dropName;
				sendLootMessage( itemName, getKc( playerName, "Theatre of blood" ), "Theatre of Blood", "",
						"Loot Received", "", "", "", true );
				unsetKc( "Theatre of blood" );
				}
			}
		}
	}

private boolean isPlayerIgnored ()
	{
	if ( config.whiteListedRSNs().trim().length() > 0 )
		{
		String playerName = getPlayerName().toLowerCase();
		List<String> whiteListedRSNs = Arrays.asList( config.whiteListedRSNs().split( "," ) );
		
		return whiteListedRSNs.stream().noneMatch( rsn -> rsn.length() > 0 && playerName.equals( rsn.toLowerCase() ) );
		}
	
	return false;
	}

private String getPlayerIconUrl ()
	{
	switch (client.getAccountType())
		{
		case IRONMAN:
			return "https://oldschool.runescape.wiki/images/0/09/Ironman_chat_badge.png";
		case HARDCORE_IRONMAN:
			return "https://oldschool.runescape.wiki/images/b/b8/Hardcore_ironman_chat_badge.png";
		case ULTIMATE_IRONMAN:
			return "https://oldschool.runescape.wiki/images/0/02/Ultimate_ironman_chat_badge.png";
		case GROUP_IRONMAN:
			return "https://oldschool.runescape.wiki/images/Group_ironman_chat_badge.png";
		case HARDCORE_GROUP_IRONMAN:
			return "https://oldschool.runescape.wiki/images/Hardcore_group_ironman_chat_badge.png";
		case NORMAL:
			return "https://oldschool.runescape.wiki/images/thumb/Grand_Exchange_logo.png/225px-Grand_Exchange_logo.png?88cff";
		default:
			return "";
		}
	}

private int getColorCode ()
	{
	switch (client.getAccountType())
		{
		case IRONMAN:
			return 3881787;
		case HARDCORE_IRONMAN:
			return 5832704;
		case ULTIMATE_IRONMAN:
			return 9342606;
		case GROUP_IRONMAN:
			return 6579;
		case HARDCORE_GROUP_IRONMAN:
			return 8454144;
		default:
			return 8817417;
		}
	}

private String getPlayerName ()
	{
	return client.getLocalPlayer().getName();
	}

@Subscribe
public void onScriptPreFired ( ScriptPreFired scriptPreFired )
	{
	switch (scriptPreFired.getScriptId())
		{
		case ScriptID.NOTIFICATION_START:
			notificationStarted = true;
			break;
		case ScriptID.NOTIFICATION_DELAY:
			if ( ! notificationStarted )
				{
				return;
				}
			String notificationTopText = client.getVarcStrValue( VarClientStr.NOTIFICATION_TOP_TEXT );
			String notificationBottomText = client.getVarcStrValue( VarClientStr.NOTIFICATION_BOTTOM_TEXT );
			if ( notificationTopText.equalsIgnoreCase( "Collection log" ) && config.setCollectionLogs() )
				{
				String itemName =
						"**" + Text.removeTags( notificationBottomText ).substring( "New item:".length() ) + "**";
				sendCollectionLogMessage( itemName );
				}
			notificationStarted = false;
			break;
		}
	}

@Subscribe
public void onActorDeath ( ActorDeath actorDeath )
	{
	if ( ! config.includeDeath() )
		{
		return;
		}
	
	Actor actor = actorDeath.getActor();
	if ( actor instanceof Player )
		{
		Player player = (Player) actor;
		if ( player == client.getLocalPlayer() )
			{
			sendDeathMessage();
			}
		}
	}

private boolean shouldSendForThisLevel ( int level )
	{
	return level >= config.minLevel() && levelMeetsIntervalRequirement( level );
	}

private boolean levelMeetsIntervalRequirement ( int level )
	{
	int levelInterval = config.levelInterval();
	
	if ( config.linearLevelMax() > 0 )
		{
		levelInterval = (int) Math.max( Math.ceil( - .1 * level + config.linearLevelMax() ), 1 );
		}
	
	return levelInterval <= 1 || level == 99 || level % levelInterval == 0;
	}

private void sendQuestMessage ( String questName )
	{
	String codeBlocks = "";
	String bold = "**";
	if ( config.codeBlocks() )
		{
		codeBlocks = "`";
		bold = "";
		}
	else {codeBlocks = "";}
	
	String localName = bold + client.getLocalPlayer().getName() + bold;
	
	String questMessageString = config.questMessage().replaceAll( "\\$name", codeBlocks + localName + codeBlocks )
	                                  .replaceAll( "\\$quest", codeBlocks + questName + codeBlocks );
	
	NonLootWebhookBody nonLootWebhookBody = new NonLootWebhookBody();
	nonLootWebhookBody.setContent( questMessageString );
	sendNonLootWebhook( nonLootWebhookBody, config.sendQuestingScreenshot() , "quest");
	}

private void sendDeathMessage ()
	{
	String codeBlocks = "";
	String bold = "**";
	if ( config.codeBlocks() )
		{
		codeBlocks = "`";
		bold = "";
		}
	else {codeBlocks = "";}
	
	String localName = bold + client.getLocalPlayer().getName() + bold;
	
	String deathMessageString = config.deathMessage().replaceAll( "\\$name", codeBlocks + localName + codeBlocks );
	
	NonLootWebhookBody nonLootWebhookBody = new NonLootWebhookBody();
	nonLootWebhookBody.setContent( deathMessageString );
	sendNonLootWebhook( nonLootWebhookBody, config.sendDeathScreenshot(), "death" );
	}

private void sendClueMessage ()
	{
	String codeBlocks = "";
	String bold = "**";
	if ( config.codeBlocks() )
		{
		codeBlocks = "`";
		bold = "";
		}
	else {codeBlocks = "";}
	
	String localName = bold + client.getLocalPlayer().getName() + bold;
	
	String clueMessage = config.clueMessage().replaceAll( "\\$name", codeBlocks + localName + codeBlocks );
	
	NonLootWebhookBody nonLootWebhookBody = new NonLootWebhookBody();
	nonLootWebhookBody.setContent( clueMessage );
	sendNonLootWebhook( nonLootWebhookBody, config.sendClueScreenshot(), "clue" );
	}

private void sendLevelMessage ()
	{
	String codeBlocks = "";
	String bold = "**";
	if ( config.codeBlocks() )
		{
		codeBlocks = "`";
		bold = "";
		}
	else {codeBlocks = "";}
	
	String localName = bold + client.getLocalPlayer().getName() + bold;
	
	String levelUpString = config.levelMessage().replaceAll( "\\$name", codeBlocks + localName + codeBlocks );
	
	String[] skills = new String[leveledSkills.size()];
	skills = leveledSkills.toArray( skills );
	leveledSkills.clear();
	
	for ( int i = 0 ; i < skills.length ; i++ )
		{
		if ( i != 0 )
			{
			levelUpString += config.andLevelMessage();
			}
		
		String fixed = levelUpString.replaceAll( "\\$skill", codeBlocks + skills[i] + codeBlocks )
		                            .replaceAll( "\\$level",
				                            codeBlocks + currentLevels.get( skills[i] ).toString() + codeBlocks );
		
		levelUpString = fixed;
		}
	
	NonLootWebhookBody nonLootWebhookBody = new NonLootWebhookBody();
	nonLootWebhookBody.setContent( levelUpString );
	sendNonLootWebhook( nonLootWebhookBody, config.sendLevellingScreenshot() , "level");
	}

private void sendPetMessage ()
	{
	String codeBlocks = "";
	String bold = "**";
	if ( config.codeBlocks() )
		{
		codeBlocks = "`";
		bold = "";
		}
	else {codeBlocks = "";}
	
	String localName = bold + client.getLocalPlayer().getName() + bold;
	
	String petMessageString = config.petMessage().replaceAll( "\\$name", codeBlocks + localName + codeBlocks );
	
	NonLootWebhookBody nonLootWebhookBody = new NonLootWebhookBody();
	nonLootWebhookBody.setContent( petMessageString );
	sendNonLootWebhook( nonLootWebhookBody, config.sendPetScreenshot(), "pet");
	}

private void sendCollectionLogMessage ( String itemName )
	{
	String codeBlocks = "";
	String bold = "**";
	if ( config.codeBlocks() )
		{
		codeBlocks = "`";
		bold = "";
		}
	else {codeBlocks = "";}
	
	String localName = bold + client.getLocalPlayer().getName() + bold;
	
	String collectionLogMessageString =
			config.collectionLogMessage().replaceAll( "\\$name", codeBlocks + localName + codeBlocks )
			      .replaceAll( "\\$itemName", codeBlocks + itemName + codeBlocks );
	
	NonLootWebhookBody nonLootWebhookBody = new NonLootWebhookBody();
	nonLootWebhookBody.setContent( collectionLogMessageString );
	sendNonLootWebhook( nonLootWebhookBody, config.sendCollectionLogScreenshot(), "log" );
	}

public void sendLootMessage ( String itemName, Integer bossKC, String npcName, String itemValue, String notificationType, String itemImageURL, String splitMembers, String rarity, boolean send )
	{
	this.itemName = itemName;
	this.itemKc = bossKC;
	this.bossName = npcName;
	this.itemValue = itemValue;
	this.notificationType = notificationType;
	String codeBlocksGreenStart = "";
	String codeBlocksYellowStart = "";
//	String codeBlocksOrangeStart = "";
//	String codeBlocksRedStart = "";
	String codeBlocksEnd = "";
	String bold = "**";
	if ( config.codeBlocks() )
		{
		codeBlocksGreenStart = "```glsl\n";
		codeBlocksYellowStart = "```fix\n";
//		codeBlocksOrangeStart = "```elm\n";
//		codeBlocksRedStart = "```diff\n";
		codeBlocksEnd = "\n```";
		bold = "";
		}
	else
		{
		codeBlocksGreenStart = "";
		codeBlocksYellowStart = "";
//		codeBlocksOrangeStart = "";
//		codeBlocksRedStart = "";
		codeBlocksEnd = "";
		}
	
	if ( ! shouldSendLootMessage )
		{
		return;
		}
	
	switch (notificationType)
		{
		case "Split Loot":
			break;
		case "Loot Received":
			itemName = "a rare drop from " + npcName + ": " + itemName;
			break;
		default:
			notificationType = "Manual Upload";
			itemName = "a screenshot";
			break;
		}
	
	String screenshotString = client.getLocalPlayer().getName();
	
	String valueMessage = null;
	if ( ! itemValue.isEmpty() )
		{
		screenshotString += " just received " + itemName + "!";
		valueMessage = itemValue + " gp";
		}
	else if ( ! itemName.isEmpty() )
		{
		screenshotString += " just posted " + itemName + "!";
		}
	else
		{
		screenshotString += " just received " + itemName + "!";
		}
	SimpleDateFormat sdfDate = new SimpleDateFormat( "yyyy-MM-dd" );
	String playerName = client.getLocalPlayer().getName();
	
	JSONObject webhookObject = new JSONObject();
	JSONArray embedsArray = new JSONArray();
	
	JSONObject embedsObject = new JSONObject();
	JSONObject authorObject = new JSONObject();
	authorObject.put( "icon_url", playerIconUrl );
	embedsObject.put( "author", authorObject );
	authorObject.put( "name", notificationType + " - " + playerName );
	embedsObject.put( "title", screenshotString );
	embedsObject.put( "url", "https://wiseoldman.net/players/" + playerName );
	
	JSONObject thumbnailObject = new JSONObject();
	if ( ! Objects.equals( itemImageURL, "" ) )
		{
		thumbnailObject.put( "url", itemImageURL );
		embedsObject.put( "thumbnail", thumbnailObject );
		}
	embedsArray.put( embedsObject );
	webhookObject.put( "embeds", embedsArray );
	JSONArray fieldsArray = new JSONArray();
	embedsObject.putOnce( "fields", fieldsArray );
	embedsObject.putOnce( "color", colorCode );
	JSONObject footerObject = new JSONObject();
	JSONObject rarityField = new JSONObject();
	JSONObject valueField = new JSONObject();
	StringBuilder footerString = new StringBuilder( String.format( "Date: %s", sdfDate.format( new Date() ) ) );
	
	if ( ! itemValue.isEmpty() )
		{
		String descriptionText;
		if ( ! notificationType.equals( "Split Loot" ) )
			{
//			descriptionText = codeBlocksGreenStart + bold + "Value: " + bold + valueMessage + codeBlocksEnd;
			valueField.put( "name", "Value" ).put( "value", codeBlocksGreenStart + valueMessage + codeBlocksEnd )
			          .put( "inline", true );
			fieldsArray.put( valueField );
			if ( ! Objects.equals( rarity, "" ) )
				{
				rarityField.put( "name", "Rarity" ).put( "value", codeBlocksGreenStart + "1/" + rarity + codeBlocksEnd )
				           .put( "inline", true );
				fieldsArray.put( rarityField );
				}
//	if (!rarity.equals(0.0f)) descriptionText = descriptionText + codeBlocksGreenStart + rarity + codeBlocksEnd;
			}
		else
			{
			valueField.put( "name", "Split Value" ).put( "value", codeBlocksGreenStart + valueMessage + codeBlocksEnd )
			          .put( "inline", true );
			fieldsArray.put( valueField );
//			descriptionText = codeBlocksGreenStart + bold + "Split Value: " + bold + valueMessage + codeBlocksEnd;
			if ( ! Objects.equals( rarity, "" ) )
				{
				rarityField.put( "name", "Rarity" ).put( "value", codeBlocksGreenStart + "1/" + rarity + codeBlocksEnd )
				           .put( "inline", true );
				fieldsArray.put( rarityField );
				}
//				{descriptionText = descriptionText + bold + "\nRarity: " + bold + rarity.trim() + codeBlocksEnd;}
			//	if (!rarity.equals(0.0f)) descriptionText = descriptionText + codeBlocksGreenStart + rarity + codeBlocksEnd;
			}
		}
	JSONObject customField = new JSONObject();
	JSONObject bingoField = new JSONObject();
	JSONObject splitField = new JSONObject();
	
	if ( config.includeBingo() && ! Objects.equals( config.bingoString(), "" ) )
		{
		String bingoString = config.bingoString();
		
		bingoField.put( "name", "Event String" )
		          .put( "value", codeBlocksGreenStart + "#" + bingoString + codeBlocksEnd ).put( "inline", true );
		fieldsArray.put( bingoField );
		}
	
	if ( ! config.customValue().equals( "" ) )
		{
		customField.put( "name", config.customField() )
		           .put( "value", codeBlocksYellowStart + config.customValue() + codeBlocksEnd ).put( "inline", true );
		fieldsArray.put( customField );
		}
	
	if ( ! Objects.equals( splitMembers, "" ) )
		{
		splitField.put( "name", "Split With" ).put( "value", codeBlocksYellowStart + splitMembers + codeBlocksEnd )
		          .put( "inline", true );
		fieldsArray.put( splitField );
		}
	
	if ( ! Objects.equals( npcName, "" ) )
//		{
//		try
//			{
//			String npcIconUrl = ApiTools.getWikiIcon( (npcName) );
//			if ( ! npcIconUrl.equals( "" ) ) footerObject.put( "icon_url", npcIconUrl );
//			}
//		catch (IOException | InterruptedException e)
//			{
//			throw new RuntimeException( e );
//			}
//		}
	footerString.append( bossKC == null ? "" : " - Kill Count: " + bossKC );
	
	footerObject.put( "text", footerString );
	embedsObject.put( "footer", footerObject );
	if ( config.rawJson() )
		{
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents( new StringSelection( webhookObject.toString() ), null );
		}
	CompletableFuture.runAsync( () -> sendLootWebhook( webhookObject.toString(), send ) );
	}

public void sendLootWebhook ( String embedsObject, boolean send )
	{
	String configUrl;
	if ( send && config.autoLog() && config.autoWebHookToggle() )
		{
		configUrl = config.valuableWebHookToggle() ? config.valuableWebHook() : config.autoWebHook();
		}
	else if ( ! send && config.autoWebHookToggle() )
		{
		configUrl = config.valuableWebHookToggle() ? config.valuableWebHook() : config.webhook();
		}
	else if ( Objects.equals( config.autoWebHook(), "" ) )
		{
		configUrl = config.valuableWebHookToggle() ? config.valuableWebHook() : config.webhook();
		}
	else
		{
		configUrl = config.valuableWebHookToggle() ? config.valuableWebHook() : config.webhook();
		}
	
	if ( Strings.isNullOrEmpty( configUrl ) )
		{
		}
	else
		{
		
		HttpUrl url = HttpUrl.parse( configUrl );
		MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder().setType( MultipartBody.FORM )
		                                                                      .addFormDataPart( "payload_json",
				                                                                      embedsObject );
		
		if ( config.sendScreenshot() )
			{
			if ( ! send && discordNotificationsAIOPanel.before != null )
				{
				CompletableFuture.runAsync( () -> sendLootWebhookWithBuffer( url, requestBodyBuilder,
						discordNotificationsAIOPanel.before ) );
				}
			else
				{
				CompletableFuture.runAsync( () -> sendLootWebhookWithScreenshot( url, requestBodyBuilder ) );
				}
			}
		else
			{
			CompletableFuture.runAsync( () -> buildRequestAndSend( url, requestBodyBuilder ) );
			}
		}
	}

public void sendLootWebhookWithScreenshot ( HttpUrl url, MultipartBody.Builder requestBodyBuilder )
	{
	drawManager.requestNextFrameListener( image ->
		{
		BufferedImage bufferedImage = (BufferedImage) image;
		byte[] imageBytes;
		try
			{
			imageBytes = convertImageToByteArray( bufferedImage );
			}
		catch (IOException e)
			{
			log.warn( "Error converting image to byte array", e );
			return;
			}
		
		requestBodyBuilder.addFormDataPart( "file", "image.png",
				RequestBody.create( MediaType.parse( "image/png" ), imageBytes ) );
		CompletableFuture.runAsync( () -> buildRequestAndSend( url, requestBodyBuilder ) );
		
		} );
	}

public void sendLootWebhookWithBuffer ( HttpUrl url, MultipartBody.Builder requestBodyBuilder, BufferedImage screenshot )
	{
	
	byte[] imageBytes;
	try
		{
		imageBytes = convertImageToByteArray( screenshot );
		}
	catch (IOException e)
		{
		log.warn( "Error converting image to byte array", e );
		return;
		}
	
	requestBodyBuilder.addFormDataPart( "file", "image.png",
			RequestBody.create( MediaType.parse( "image/png" ), imageBytes ) );
	buildRequestAndSend( url, requestBodyBuilder );
	}

private void sendNonLootWebhook ( NonLootWebhookBody discordWebhookBody, boolean sendScreenshot, String hookType )
	{
	String configUrl;

	if ( config.autoLog() && config.autoWebHookToggle() )
		{
			switch (hookType)
			{
				case "level":
					configUrl = config.levelWebHookToggle() ? config.levelWebHook() : config.autoWebHook();
					break;
				case "quest":
					configUrl = config.questWebHookToggle() ? config.questWebHook() : config.autoWebHook();
					break;
				case "death":
					configUrl = config.deathWebHookToggle() ? config.deathWebHook() : config.autoWebHook();
					break;
				case "clue":
					configUrl = config.clueWebHookToggle() ? config.clueWebHook() : config.autoWebHook();
					break;
				case "pet":
					configUrl = config.petWebHookToggle() ? config.petWebHook() : config.autoWebHook();
					break;
				case "log":
					configUrl = config.logWebHookToggle() ? config.logWebHook() : config.autoWebHook();
					break;
				default:
					configUrl = config.autoWebHook();
			}		}
	else if ( config.autoWebHookToggle() )
		{
			configUrl = getString(hookType);
		}
	else if ( Objects.equals( config.autoWebHook(), "" ) )
		{
			configUrl = getString(hookType);
		}
	else
		{
		configUrl = config.webhook();
		}
	
	if ( Strings.isNullOrEmpty( configUrl ) )
		{
		}
	else
		{
		
		HttpUrl url = HttpUrl.parse( configUrl );
		MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder().setType( MultipartBody.FORM )
		                                                                      .addFormDataPart( "payload_json",
				                                                                      GSON.toJson(
						                                                                      discordWebhookBody ) );
		
		if ( sendScreenshot )
			{
			sendNonLootWebhookWithScreenshot( url, requestBodyBuilder );
			}
		else
			{
			buildRequestAndSend( url, requestBodyBuilder );
			}
		}
	}

	private String getString(String hookType) {
		String configUrl;
		switch (hookType)
		{
			case "level":
				configUrl = config.levelWebHookToggle() ? config.levelWebHook() : config.webhook();
				break;
			case "quest":
				configUrl = config.questWebHookToggle() ? config.questWebHook() : config.webhook();
				break;
			case "death":
				configUrl = config.deathWebHookToggle() ? config.deathWebHook() : config.webhook();
				break;
			case "clue":
				configUrl = config.clueWebHookToggle() ? config.clueWebHook() : config.webhook();
				break;
			case "pet":
				configUrl = config.petWebHookToggle() ? config.petWebHook() : config.webhook();
				break;
			case "log":
				configUrl = config.logWebHookToggle() ? config.logWebHook() : config.webhook();
				break;
			default:
				configUrl = config.webhook();
		}
		return configUrl;
	}

	private void sendNonLootWebhookWithScreenshot ( HttpUrl url, MultipartBody.Builder requestBodyBuilder )
	{
	drawManager.requestNextFrameListener( image ->
		{
		BufferedImage bufferedImage = (BufferedImage) image;
		byte[] imageBytes;
		try
			{
			imageBytes = convertImageToByteArray( bufferedImage );
			}
		catch (IOException e)
			{
			log.warn( "Error converting image to byte array", e );
			return;
			}
		
		requestBodyBuilder.addFormDataPart( "file", "image.png",
				RequestBody.create( MediaType.parse( "image/png" ), imageBytes ) );
		buildRequestAndSend( url, requestBodyBuilder );
		} );
	}

private void buildRequestAndSend ( HttpUrl url, MultipartBody.Builder requestBodyBuilder )
	{
	RequestBody requestBody = requestBodyBuilder.build();
	Request request = new Request.Builder().url( url ).post( requestBody ).build();
	sendRequest( request );
	// System.out.println(request);
	}

private void sendRequest ( Request request )
	{
	okHttpClient.newCall( request ).enqueue( new Callback() {
		@Override
		public void onFailure ( @NotNull Call call, @NotNull IOException e )
			{
			log.debug( "Error submitting webhook", e );
			}
		
		@Override
		public void onResponse ( @NotNull Call call, @NotNull Response response ) throws IOException
			{
			response.close();
			}
	} );
	}

public void dataToPanel ( String bossName, String itemName )
	{
	drawManager.requestNextFrameListener(
			image -> discordNotificationsAIOPanel.panelOverride( bossName, itemName, (BufferedImage) image ) );
	}

private void resetState ()
	{
	currentLevels.clear();
	leveledSkills.clear();
	shouldSendLevelMessage = false;
	shouldSendQuestMessage = false;
	shouldSendClueMessage = false;
	shouldSendLootMessage = false;
	ticksWaited = 0;
	}

@Subscribe
public void onWidgetLoaded ( WidgetLoaded event )
	{
	int groupId = event.getGroupId();
	
	if ( groupId == QUEST_COMPLETED_GROUP_ID )
		{
		shouldSendQuestMessage = true;
		}
	
	if ( groupId == WidgetID.CLUE_SCROLL_REWARD_GROUP_ID )
		{
		shouldSendClueMessage = true;
		}
	}
	
}

/*
 * Copyright (c) 2022, RinZ
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.discordnotificationsaio;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup ("discordnotificationsaio")
public interface DiscordNotificationsAIOConfig extends Config {

// @ConfigItem(
// keyName = "keybind",
// name = "Screenshot Keybind",
// description = "Add keybind to manually take a screenshot and send a message
// of your rare drop",
// position = 4
// )
// default Keybind keybind()
// {
// return Keybind.NOT_SET;
// }

@ConfigSection (name = "Valuable Loot", description = "Options for Valuable Loot Notifications", position = 5)
String valuableLootSection = "valuable loot options";
@ConfigSection (name = "Levelling", description = "The config for levelling notifications", position = 11,
                closedByDefault = true)
String levellingConfig = "levellingConfig";
// Questing config section
@ConfigSection (name = "Questing", description = "The config for questing notifications", position = 19,
                closedByDefault = true)
String questingConfig = "questingConfig";
// Death config section
@ConfigSection (name = "Deaths", description = "The config for death notifications", position = 22,
                closedByDefault = true)
String deathConfig = "deathConfig";
// Clue config section
@ConfigSection (name = "Clue Scrolls", description = "The config for clue scroll notifications", position = 26,
                closedByDefault = true)
String clueConfig = "clueConfig";
// Pet config section
@ConfigSection (name = "Pets", description = "The config for pet notifications", position = 30, closedByDefault = true)
String petConfig = "petConfig";
// Collection Log config section
@ConfigSection (name = "Collection Log", description = "The config for collection log notifications", position = 34,
                closedByDefault = true)
String collectionLogConfig = "collectionLogConfig";
@ConfigSection (name = "Advanced", description = "Advanced/Experimental Options", position = 150)
String advancedSection = "advanced";

@ConfigItem (keyName = "webhook", name = "Default WebHook",
             description = "The main webhook used to send messages to Discord.", position = 1)
String webhook ();

@ConfigItem (keyName = "autoLog", name = "Automatic Notifications",
             description = "Send Notifications to Discord on Level-up, Loot, Deaths, Quests, or Collection Log Completion",
             position = 2)
default boolean autoLog ()
	{
	return true;
	}

@ConfigItem (keyName = "autoWebHookToggle", name = "Use Separate WebHook?",
             description = "Use a secondary WebHook for Automatic Notifications, separate from your Split Tracking one.",
             position = 3)
default boolean autoWebHookToggle ()
	{
	return false;
	}

@ConfigItem (keyName = "autoWebHook", name = "Automatic WebHook",
             description = "Secondary WebHook for Automatic Loot Logging.", position = 4)
String autoWebHook ();

@ConfigItem (keyName = "sendScreenshot", name = "Send Screenshot?",
             description = "Include a screenshot in the discord message?", position = 6, section = valuableLootSection)
default boolean sendScreenshot ()
	{
	return true;
	}

@ConfigItem (keyName = "bingo", name = "Include Bingo/Event String",
             description = "Add an event string to your screenshot's message", position = 7,
             section = valuableLootSection)
default boolean includeBingo ()
	{
	return false;
	}

@ConfigItem (keyName = "bingoString", name = "Custom Bingo/Event String",
             description = "Insert your custom event here.", position = 8, section = valuableLootSection)
default String bingoString ()
	{
	return "ABC123";
	}

@ConfigItem (keyName = "valuableDrop", name = "Include Valuable drops",
             description = "Configures whether valuable drops will be automatically sent to discord.", position = 9,
             section = valuableLootSection)
default boolean includeValuableDrops ()
	{
	return true;
	}

@ConfigItem (keyName = "valuableDropThreshold", name = "Minimum Value",
             description = "The minimum value of a drop for it to send a discord message.", position = 10,
             section = valuableLootSection)
default int valuableDropThreshold ()
	{
	return 100000;
	}

@ConfigItem (keyName = "includeRarity", name = "Include Rarity",
             description = "Include item rarity in the Discord message?", position = 11, section = valuableLootSection)
default boolean includeRarity () {return true;}

@ConfigItem (keyName = "rarityThreshold", name = "Minimum Rarity",
             description = "The minimum rarity of a drop for it to send a discord message. (1/x)", position = 11,
             section = valuableLootSection)
default int rarityThreshold ()
	{
	return 1;
	}

	@ConfigItem (keyName = "valuableWebHookToggle", name = "Separate Loot WebHook?",
			description = "Use a custom WebHook for Valuable Loot Notifications, separate from any other WebHooks.",
			section = valuableLootSection,
			position = 11)
	default boolean valuableWebHookToggle ()
	{
		return false;
	}

	@ConfigItem (keyName = "valuableWebHook", name = "Valuable Loot WebHook",
			description = "Secondary WebHook for Valuable Loot specifically.",
			section = valuableLootSection, position = 11)
	String valuableWebHook ();

@ConfigItem (keyName = "includeLevelling", name = "Send Levelling Notifications",
             description = "Send messages when you level up a skill.", section = levellingConfig, position = 12)
default boolean includeLevelling ()
	{
	return true;
	}
// End levelling config section

@ConfigItem (keyName = "minimumLevel", name = "Minimum level",
             description = "Levels greater than or equal to this value will send a message.", section = levellingConfig,
             position = 13)
default int minLevel ()
	{
	return 0;
	}

@ConfigItem (keyName = "levelInterval", name = "Send every X levels",
             description = "Only levels that are a multiple of this value are sent. Level 99 will always be sent regardless of this value.",
             section = levellingConfig, position = 14)
default int levelInterval ()
	{
	return 1;
	}

@ConfigItem (keyName = "linearLevelModifier", name = "Linear Level Modifier",
             description = "Send every `max(-.1x + linearLevelMax, 1)` levels. Will override `Send every X levels` if set to above zero.",
             section = levellingConfig, position = 15)
default double linearLevelMax ()
	{
	return 0;
	}

@ConfigItem (keyName = "levelMessage", name = "Level Message", description = "Message to send to Discord on Level",
             section = levellingConfig, position = 16)
default String levelMessage () {return "$name leveled $skill to $level";}
// End questing config section

@ConfigItem (keyName = "andLevelMessage", name = "Multi Skill Level Message",
             description = "Message to send to Discord when Multi Skill Level", section = levellingConfig,
             position = 17)
default String andLevelMessage () {return ", and $skill to $level";}

@ConfigItem (keyName = "sendLevellingScreenshot", name = "Send level-up screenshots?",
             description = "Include a screenshot when leveling up.", section = levellingConfig, position = 18)
default boolean sendLevellingScreenshot ()
	{
	return true;
	}
	@ConfigItem (keyName = "levelWebHookToggle", name = "Separate Level-Up WebHook?",
			description = "Use a custom WebHook for Levelling Notifications, separate from any other WebHooks.", section = levellingConfig,
			position = 19)
	default boolean levelWebHookToggle ()
	{
		return false;
	}

	@ConfigItem (keyName = "levelWebHook", name = "Level-Up WebHook",
			description = "Secondary WebHook for levelling up specifically.", section = levellingConfig, position = 20)
	String levelWebHook ();

@ConfigItem (keyName = "includeQuests", name = "Send Quest Notifications",
             description = "Send messages when you complete a quest.", section = questingConfig)
default boolean includeQuestComplete ()
	{
	return true;
	}

@ConfigItem (keyName = "questMessage", name = "Quest Message", description = "Message to send to Discord on Quest",
             section = questingConfig, position = 20)
default String questMessage () {return "$name has just completed: $quest";}
// End death config section

@ConfigItem (keyName = "sendQuestingScreenshot", name = "Include quest screenshots",
             description = "Include a screenshot with the discord notification when leveling up.",
             section = questingConfig, position = 21)
default boolean sendQuestingScreenshot ()
	{
	return true;
	}

	@ConfigItem (keyName = "questWebHookToggle", name = "Separate Quest WebHook?",
			description = "Use a custom WebHook for Quest Notifications, separate from any other WebHooks.", section = questingConfig,
			position = 22)
	default boolean questWebHookToggle ()
	{
		return false;
	}

	@ConfigItem (keyName = "questWebHook", name = "Quest WebHook",
			description = "Secondary WebHook for Quests specifically.", section = questingConfig, position = 23)
	String questWebHook ();

@ConfigItem (keyName = "includeDeaths", name = "Send Death Notifications",
             description = "Send messages when you die to discord.", section = deathConfig, position = 23)
default boolean includeDeath () {return true;}

@ConfigItem (keyName = "deathMessage", name = "Death Message", description = "Message to send to Discord on Death",
             section = deathConfig, position = 24)
default String deathMessage () {return "$name has just died!";}

@ConfigItem (keyName = "sendDeathScreenshot", name = "Include death screenshots",
             description = "Include a screenshot with the discord notification when you die.", section = deathConfig,
             position = 25)
default boolean sendDeathScreenshot ()
	{
	return true;
	}

	@ConfigItem (keyName = "deathWebHookToggle", name = "Separate Death WebHook?",
			description = "Use a custom WebHook for Death Notifications, separate from any other WebHooks.", section = deathConfig,
			position = 26)
	default boolean deathWebHookToggle ()
	{
		return false;
	}

	@ConfigItem (keyName = "deathWebHook", name = "Death WebHook",
			description = "Secondary WebHook for Deaths specifically.", section = deathConfig, position = 27)
	String deathWebHook ();

@ConfigItem (keyName = "includeClues", name = "Send Clue Notifications",
             description = "Send messages when you complete a clue scroll.", section = clueConfig, position = 27)
default boolean includeClue () {return true;}

@ConfigItem (keyName = "clueMessage", name = "Clue Message", description = "Message to send to Discord on Clue",
             section = clueConfig, position = 28)
default String clueMessage () {return "$name has just completed a clue scroll!";}

@ConfigItem (keyName = "sendClueScreenshot", name = "Include Clue screenshots",
             description = "Include a screenshot with the discord notification when you complete a clue.",
             section = clueConfig, position = 29)
default boolean sendClueScreenshot ()
	{
	return true;
	}

	@ConfigItem (keyName = "clueWebHookToggle", name = "Separate Clue WebHook?",
			description = "Use a custom WebHook for Clue Notifications, separate from any other WebHooks.", section = clueConfig,
			position = 30)
	default boolean clueWebHookToggle ()
	{
		return false;
	}

	@ConfigItem (keyName = "clueWebHook", name = "Clue WebHook",
			description = "Secondary WebHook for Clues specifically.", section = clueConfig, position = 31)
	String clueWebHook ();

@ConfigItem (keyName = "includePets", name = "Send Pet Notifications",
             description = "Send messages when you receive a pet.", section = petConfig, position = 31)
default boolean setPets () {return true;}

@ConfigItem (keyName = "petMessage", name = "Pet Message", description = "Message to send to Discord on Pet",
             section = petConfig, position = 32)
default String petMessage () {return "$name has just received a pet!";}

@ConfigItem (keyName = "sendPetScreenshot", name = "Include Pet screenshots",
             description = "Include a screenshot with the discord notification when you receive a pet.",
             section = petConfig, position = 33)
default boolean sendPetScreenshot ()
	{
	return true;
	}

	@ConfigItem (keyName = "petWebHookToggle", name = "Separate Pet WebHook?",
			description = "Use a custom WebHook for Pet Notifications, separate from any other WebHooks.", section = petConfig,
			position = 34)
	default boolean petWebHookToggle ()
	{
		return false;
	}

	@ConfigItem (keyName = "petWebHook", name = "Pet WebHook",
			description = "Secondary WebHook for Pets specifically.", section = petConfig, position = 35)
	String petWebHook ();

@ConfigItem (keyName = "includeCollectionLogs", name = "Send Collection Log Notifications",
             description = "Send messages when you receive a collection log entry.", section = collectionLogConfig,
             position = 35)
default boolean setCollectionLogs () {return true;}

@ConfigItem (keyName = "collectionLogMessage", name = "Collection Log Message",
             description = "Message to send to Discord on Collection Log", section = collectionLogConfig, position = 36)
default String collectionLogMessage () {return "$name just received a new collection log item: $itemName!";}

@ConfigItem (keyName = "sendCollectionLogScreenshot", name = "Include Collection Log screenshots",
             description = "Include a screenshot with the discord notification when you receive a collection log item.",
             section = collectionLogConfig, position = 37)
default boolean sendCollectionLogScreenshot ()
	{
	return true;
	}
	@ConfigItem (keyName = "logWebHookToggle", name = "Separate Collection Log WebHook?",
			description = "Use a custom WebHook for Collection Log Notifications, separate from any other WebHooks.", section = collectionLogConfig,
			position = 38)
	default boolean logWebHookToggle ()
	{
		return false;
	}

	@ConfigItem (keyName = "logWebHook", name = "Collection Log WebHook",
			description = "Secondary WebHook for Collection Log specifically.", section = collectionLogConfig, position = 39)
	String logWebHook ();

@ConfigItem (keyName = "customField", name = "Custom Field Title", description = "", position = 38,
             section = valuableLootSection)
default String customField ()
	{
	return "";
	}

@ConfigItem (keyName = "customValue", name = "Custom Field Value", description = "", position = 39,
             section = valuableLootSection)
default String customValue ()
	{
	return "";
	}

@ConfigItem (keyName = "whiteListedRSNs", name = "Whitelisted RSNs",
             description = "(optional) Comma-separated list of RSNs which are allowed to post to the webhook, can prevent drops being posted from all your accounts",
             section = advancedSection, position = 40)
default String whiteListedRSNs ()
	{
	return "";
	}

@ConfigItem (keyName = "raidLoot", name = "Include raid loot (Experimental)",
             description = "Configures whether a message will be automatically sent to discord when you obtain a raid unique.",
             position = 100, section = valuableLootSection)
default boolean includeRaidLoot ()
	{
	return true;
	}

@ConfigItem (keyName = "codeBlocks", name = "Show Code Blocks?",
             description = "Configures whether a message will have code blocks in the embeds.", position = 100,
             section = advancedSection)
default boolean codeBlocks ()
	{
	return true;
	}

@ConfigItem (keyName = "rawJson", name = "Copy Json to Clipboard",
             description = "Configures or not to copy the webhook's Json output to your clipboard.", position = 101,
             section = advancedSection)
default boolean rawJson ()
	{
	return false;
	}

// @ConfigItem(
// keyName = "partyNames",
// name = "Experimental Party Integration",
// description = "Get current party members in the Split Members Section of the
// Side Panel",
// section = advancedSection,
// position = 70
// )
// default boolean partyNames() {
// return false;
// }

}


package com.discordnotificationsaio.wiki;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

public class WikiItem {

    @SerializedName("batchcomplete")
    @Expose
    private Boolean batchcomplete;
    @SerializedName("query")
    @Expose
    private Query query;

    public Boolean getBatchcomplete() {
        return batchcomplete;
    }

    public void setBatchcomplete(Boolean batchcomplete) {
        this.batchcomplete = batchcomplete;
    }

    public Query getQuery() {
        return query;
    }

    public void setQuery(Query query) {
        this.query = query;
    }

}


package com.discordnotificationsaio.wiki;


import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

public class Page {

    @SerializedName("pageid")
    @Expose
    private Long pageid;
    @SerializedName("ns")
    @Expose
    private Long ns;
    @SerializedName("title")
    @Expose
    private String title;
    @SerializedName("thumbnail")
    @Expose
    private Thumbnail thumbnail;
    @SerializedName("pageimage")
    @Expose
    private String pageimage;

    public Long getPageid() {
        return pageid;
    }

    public void setPageid(Long pageid) {
        this.pageid = pageid;
    }

    public Long getNs() {
        return ns;
    }

    public void setNs(Long ns) {
        this.ns = ns;
    }

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public Thumbnail getThumbnail() {
        return thumbnail;
    }

    public void setThumbnail(Thumbnail thumbnail) {
        this.thumbnail = thumbnail;
    }

    public String getPageimage() {
        return pageimage;
    }

    public void setPageimage(String pageimage) {
        this.pageimage = pageimage;
    }

}


package com.discordnotificationsaio.wiki;

import java.util.List;
import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

public class Query {

    @SerializedName("pages")
    @Expose
    private List<Page> pages = null;

    public List<Page> getPages() {
        return pages;
    }

    public void setPages(List<Page> pages) {
        this.pages = pages;
    }

}


package com.discordnotificationsaio.wiki;

import com.google.gson.annotations.Expose;
import com.google.gson.annotations.SerializedName;

public class Thumbnail {

    @SerializedName("source")
    @Expose
    private String source;
    @SerializedName("width")
    @Expose
    private Long width;
    @SerializedName("height")
    @Expose
    private Long height;

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public Long getWidth() {
        return width;
    }

    public void setWidth(Long width) {
        this.width = width;
    }

    public Long getHeight() {
        return height;
    }

    public void setHeight(Long height) {
        this.height = height;
    }

}

