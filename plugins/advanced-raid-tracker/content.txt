package com.advancedraidtracker;

import com.advancedraidtracker.constants.TobIDs;
import com.advancedraidtracker.constants.TOBRoom;
import com.advancedraidtracker.rooms.tob.*;
import com.advancedraidtracker.ui.charts.LiveChart;
import com.advancedraidtracker.ui.RaidTrackerSidePanel;
import com.advancedraidtracker.utility.*;
import com.advancedraidtracker.utility.datautility.DataWriter;
import com.advancedraidtracker.utility.thrallvengtracking.*;
import com.advancedraidtracker.utility.wrappers.PlayerCopy;
import com.advancedraidtracker.utility.wrappers.PlayerDidAttack;
import com.advancedraidtracker.utility.wrappers.QueuedPlayerAttackLessProjectiles;
import com.advancedraidtracker.utility.wrappers.ThrallOutlineBox;
import com.google.inject.Inject;
import com.google.inject.Provides;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserJoin;
import net.runelite.client.party.events.UserPart;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.specialcounter.SpecialCounterUpdate;
import net.runelite.client.plugins.specialcounter.SpecialWeapon;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.awt.image.BufferedImage;
import java.util.*;
import java.util.List;
import static com.advancedraidtracker.constants.LogID.*;
import static com.advancedraidtracker.constants.TobIDs.*;
import static com.advancedraidtracker.constants.TOBRoom.*;
import static com.advancedraidtracker.utility.RoomUtil.inRegion;
import static com.advancedraidtracker.utility.datautility.LegacyFileUtility.splitLegacyFiles;


@Slf4j
@PluginDescriptor(
        name = "Advanced Raid Tracker",
        description = "Tracking and statistics for Theatre of Blood",
        tags = {"timers", "tob", "tracker", "time", "theatre", "analytics"}
)
public class AdvancedRaidTrackerPlugin extends Plugin
{
    private NavigationButton navButtonPrimary;
    public DataWriter clog;

    private boolean partyIntact = false;

    @Inject
    private AdvancedRaidTrackerConfig config;

    @Inject
    private ItemManager itemManager;

    public AdvancedRaidTrackerPlugin()
    {
    }

    @Provides
    AdvancedRaidTrackerConfig getConfig(ConfigManager configManager)
    {
        return configManager.getConfig(AdvancedRaidTrackerConfig.class);
    }

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    public ClientThread clientThread;

    @Inject
    private PartyService party;

    @Inject
    private Client client;

    private LobbyHandler lobby;
    private MaidenHandler maiden;
    private BloatHandler bloat;
    private NyloHandler nylo;
    private SotetsegHandler sote;
    private XarpusHandler xarpus;
    private VerzikHandler verzik;

    private ArrayList<DamageQueueShell> queuedThrallDamage;

    private ArrayList<QueuedPlayerAttackLessProjectiles> playersAttacked;


    private boolean inTheatre;
    private boolean wasInTheatre;
    private RoomHandler currentRoom;
    int deferredTick;
    public ArrayList<String> currentPlayers;
    public static int scale = -1;
    public boolean verzShieldActive = false;
    public boolean loggingIn = false;

    private ThrallTracker thrallTracker;
    private VengTracker vengTracker;
    private List<PlayerShell> localPlayers;
    private List<ProjectileQueue> activeProjectiles;
    private List<VengDamageQueue> activeVenges;

    @Inject
    private PluginManager pluginManager;

    @Inject
    private EventBus eventBus;

    @Inject
    private WSClient wsClient;

    @Inject
    private ConfigManager configManager;

    Map<Player, Integer> activelyPiping;
    public LiveChart liveFrame;

    @Override
    protected void shutDown()
    {
        partyIntact = false;
        clog.addLine(LEFT_TOB, String.valueOf(client.getTickCount() - currentRoom.roomStartTick), currentRoom.getName());
        clientToolbar.removeNavigation(navButtonPrimary);
    }

    public void openLiveFrame()
    {
        liveFrame.open();
    }

    public int getTick()
    {
        return client.getTickCount();
    }

    public boolean isVerzP2()
    {
        if (currentRoom instanceof VerzikHandler)
        {
            VerzikHandler room = (VerzikHandler) currentRoom;
            return room.roomState == RoomState.VerzikRoomState.PHASE_2 || room.roomState == RoomState.VerzikRoomState.PHASE_2_REDS;
        }
        return false;
    }

    @Override
    protected void startUp() throws Exception
    {
        super.startUp();
        splitLegacyFiles();
        localPlayers = new ArrayList<>();
        thrallTracker = new ThrallTracker(this);
        vengTracker = new VengTracker(this);
        activeProjectiles = new ArrayList<>();
        activeVenges = new ArrayList<>();
        queuedThrallDamage = new ArrayList<>();
        RaidTrackerSidePanel timersPanelPrimary = injector.getInstance(RaidTrackerSidePanel.class);
        partyIntact = false;
        activelyPiping = new LinkedHashMap<>();
        liveFrame = new LiveChart(config, clientThread, configManager);
        playersTextChanged = new ArrayList<>();
        clog = new DataWriter(config);

        final BufferedImage icon = ImageUtil.loadImageResource(AdvancedRaidTrackerPlugin.class, "/com/advancedraidtracker/icon.png");
        navButtonPrimary = NavigationButton.builder().tooltip("Advanced Raid Tracker").icon(icon).priority(10).panel(timersPanelPrimary).build();

        clientToolbar.addNavigation(navButtonPrimary);

        lobby = new LobbyHandler(client, clog, config);
        maiden = new MaidenHandler(client, clog, config, this, itemManager);
        bloat = new BloatHandler(client, clog, config, this);
        nylo = new NyloHandler(client, clog, config, this);
        sote = new SotetsegHandler(client, clog, config, this);
        xarpus = new XarpusHandler(client, clog, config, this);
        verzik = new VerzikHandler(client, clog, config, this, itemManager);
        inTheatre = false;
        wasInTheatre = false;
        deferredTick = 0;
        currentPlayers = new ArrayList<>();
        playersAttacked = new ArrayList<>();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        if(gameStateChanged.getGameState().equals(GameState.LOGGED_IN))
        {
            try
            {
                loggingIn = true;
            }
            catch (Exception e)
            {
                log.info("Failed to set name: " + client.getLocalPlayer().getName());
            }
        }
    }

    /**
     * @return Room as int if inside TOB (0 indexed), -1 otherwise
     */
    private int getRoom()
    {
        if (inRegion(client, LOBBY_REGION))
            return -1;
        else if (inRegion(client, MAIDEN_REGION))
            return 0;
        else if (inRegion(client, BLOAT_REGION))
            return 1;
        else if (inRegion(client, NYLO_REGION))
            return 2;
        else if (inRegion(client, SOTETSEG_REGION) || inRegion(client, SOTETSEG_UNDER_REGION))
            return 3;
        else if (inRegion(client, XARPUS_REGION))
            return 4;
        else if (inRegion(client, VERZIK_REGION))
            return 5;
        return -1;
    }

    private void updateRoom()
    {
        RoomHandler previous = currentRoom;
        int currentRegion = getRoom();
        boolean activeState = false;
        if (inRegion(client, LOBBY_REGION))
        {
            currentRoom = lobby;
        } else if (previous == lobby && inRegion(client, BLOAT_REGION, NYLO_REGION, SOTETSEG_REGION, XARPUS_REGION, VERZIK_REGION))
        {
            deferredTick = client.getTickCount() + 2; //Check two ticks from now for player names in orbs
            clog.checkForEndFlag();
            clog.migrateToNewRaid();
            clog.addLine(ENTERED_TOB);
            clog.addLine(SPECTATE);
            clog.addLine(LATE_START, String.valueOf(currentRegion));
            liveFrame.resetAll();
        }
        if (inRegion(client, MAIDEN_REGION))
        {
            if (previous != maiden)
            {
                currentRoom = maiden;
                enteredMaiden();
                liveFrame.resetAll();
            }
            activeState = true;
        } else if (inRegion(client, BLOAT_REGION))
        {
            if (previous != bloat)
            {
                currentRoom = bloat;
                enteredBloat();
            }
            activeState = true;
        } else if (inRegion(client, NYLO_REGION))
        {
            if (previous != nylo)
            {
                currentRoom = nylo;
                enteredNylo();
            }
            activeState = true;
        } else if (inRegion(client, SOTETSEG_REGION, SOTETSEG_UNDER_REGION))
        {
            if (previous != sote)
            {
                currentRoom = sote;
                enteredSote();
            }
            activeState = true;
        } else if (inRegion(client, XARPUS_REGION))
        {
            if (previous != xarpus)
            {
                currentRoom = xarpus;
                enteredXarpus();
            }
            activeState = true;
        } else if (inRegion(client, VERZIK_REGION))
        {
            if (previous != verzik)
            {
                currentRoom = verzik;
                enteredVerzik();
            }
            activeState = true;
        }
        inTheatre = activeState;
    }

    private void enteredMaiden()
    {
        clog.checkForEndFlag();
        clog.migrateToNewRaid();
        clog.addLine(ENTERED_TOB);
        deferredTick = client.getTickCount() + 2;
        maiden.reset();
        liveFrame.tabbedPane.setSelectedIndex(0);
    }

    private void enteredBloat()
    {
        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(TOBRoom.BLOAT.ordinal()));
        maiden.reset();
        bloat.reset();
        liveFrame.tabbedPane.setSelectedIndex(1);
    }

    private void enteredNylo()
    {
        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(NYLOCAS.ordinal()));
        bloat.reset();
        nylo.reset();
        liveFrame.tabbedPane.setSelectedIndex(2);
    }

    private void enteredSote()
    {
        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(SOTETSEG.ordinal()));
        nylo.reset();
        sote.reset();
        liveFrame.tabbedPane.setSelectedIndex(3);
    }

    private void enteredXarpus()
    {
        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(XARPUS.ordinal()));
        sote.reset();
        xarpus.reset();
        liveFrame.tabbedPane.setSelectedIndex(4);
    }

    private void enteredVerzik()
    {
        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(VERZIK.ordinal()));
        xarpus.reset();
        verzik.reset();
        liveFrame.tabbedPane.setSelectedIndex(5);
    }

    @Subscribe
    public void onSpecialCounterUpdate(SpecialCounterUpdate event)
    {
        if (inTheatre)
        {
            String name = party.getMemberById(event.getMemberId()).getDisplayName();
            if (name == null)
            {
                return;
            }
            boolean playerInRaid = false;
            // Ensures correct names across encodings
            for (String player : currentPlayers)
            {
                if (name.equals(player.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32))))
                {
                    playerInRaid = true;
                    break;
                }
            }
            if (playerInRaid)
            {
                if (event.getWeapon().equals(SpecialWeapon.BANDOS_GODSWORD))
                {
                    clog.addLine(BGS, name, String.valueOf(event.getHit()), String.valueOf(client.getTickCount() - currentRoom.roomStartTick));
                }
                if (event.getWeapon().equals(SpecialWeapon.DRAGON_WARHAMMER))
                {
                    clog.addLine(DWH, name, String.valueOf(client.getTickCount() - currentRoom.roomStartTick));
                }
            }
        }
    }

    private String cleanString(String s1)
    {
        return s1.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32));
    }

    private boolean isPartyComplete()
    {
        if (currentPlayers.size() > party.getMembers().size())
        {
            return false;
        }
        for (String raidPlayer : currentPlayers)
        {
            boolean currentPlayerMatched = false;
            for (PartyMember partyPlayer : party.getMembers())
            {
                if (cleanString(raidPlayer).equals(partyPlayer.getDisplayName()))
                {
                    currentPlayerMatched = true;
                }
            }
            if (!currentPlayerMatched)
            {
                return false;
            }
        }
        return true;
    }

    private void checkPartyUpdate()
    {
        if (inTheatre)
        {
            if (partyIntact)
            {
                if (!isPartyComplete())
                {
                    partyIntact = false;
                    clog.addLine(PARTY_INCOMPLETE);
                }
            } else
            {
                if (isPartyComplete())
                {
                    partyIntact = true;
                    clog.addLine(PARTY_COMPLETE);
                }
            }
        }

    }

    @Subscribe
    public void onPartyChanged(final PartyChanged party)
    {

        checkPartyUpdate();
    }

    @Subscribe
    public void onUserPart(final UserPart event)
    {
        checkPartyUpdate();
    }

    @Subscribe
    public void onUserJoin(final UserJoin event)
    {
        checkPartyUpdate();
    }

    public void addQueuedThrallDamage(int targetIndex, int sourceIndex, int offset, String source)
    {
        queuedThrallDamage.add(new DamageQueueShell(targetIndex, sourceIndex, offset, source, client.getTickCount()));
    }

    public void removeDeadProjectiles()
    {
        activeProjectiles.removeIf(projectileQueue -> projectileQueue.finalTick <= client.getTickCount());
    }

    public void removeDeadVenges()
    {
        activeVenges.removeIf(vengDamageQueue -> vengDamageQueue.appliedTick <= client.getTickCount());
    }

    public void addDelayedLine(TOBRoom room, int value, String description)
    {
        switch (TOBRoom.valueOf(room.value))
        {
            case MAIDEN:
                liveFrame.addMaidenLine(value, description);
                break;
            case BLOAT:
                liveFrame.addBloatLine(value, description);
                break;
            case NYLOCAS:
                liveFrame.addNyloLine(value, description);
                break;
            case SOTETSEG:
                liveFrame.addSoteLine(value, description);
                break;
            case XARPUS:
                liveFrame.addXarpLine(value, description);
                break;
            case VERZIK:
                liveFrame.addVerzikLine(value, description);
                break;
        }
    }

    public void thrallAttackedP2VerzikShield(int tickOffset)
    {
        if (currentRoom instanceof VerzikHandler)
        {
            VerzikHandler room = (VerzikHandler) currentRoom;
            room.thrallAttackedShield(client.getTickCount() + tickOffset);
        }
    }

    public void removeThrallBox(Thrall thrall)
    {
        clog.addLine(THRALL_DESPAWN, thrall.getOwner(), String.valueOf(client.getTickCount() - currentRoom.roomStartTick));
    }

    public void addThrallOutlineBox(ThrallOutlineBox outlineBox)
    {
        clog.addLine(THRALL_SPAWN, outlineBox.owner, String.valueOf(outlineBox.spawnTick), String.valueOf(outlineBox.id));
        liveFrame.getPanel(currentRoom.getName()).addThrallBox(outlineBox);
    }

    public Map<String, PlayerCopy> lastTickPlayer = new HashMap<>();
    public int getRoomTick()
    {
        return client.getTickCount() - currentRoom.roomStartTick;
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if(loggingIn)
        {
            try
            {
                clog.setName(client.getLocalPlayer().getName());
            }
            catch (Exception e)
            {
                log.info("failed to set name?");
            }
            loggingIn = false;
        }
        checkAnimationsThatChanged();
        checkOverheadTextsThatChanged();

        for (Player p : activelyPiping.keySet())
        {
            if ((client.getTickCount() > (activelyPiping.get(p) + 1)) && ((client.getTickCount() - activelyPiping.get(p)-1) % 2 == 0))
            {
                if (p.getAnimation() == BLOWPIPE_ANIMATION || p.getAnimation() == BLOWPIPE_ANIMATION_OR)
                {
                    PlayerCopy previous = lastTickPlayer.get(p.getName());
                    if(previous != null)
                    {
                        clog.addLine(PLAYER_ATTACK,
                                previous.name + ":" + (client.getTickCount() - currentRoom.roomStartTick - 1),
                                previous.animation + ":" + previous.wornItems,
                                "",
                                previous.weapon + ":" + previous.interactingIndex + ":" + previous.interactingID,
                                "-1:" + previous.interactingName);
                        liveFrame.addAttack(new PlayerDidAttack(itemManager,
                                previous.name,
                                String.valueOf(previous.animation),
                                -1,
                                previous.weapon,
                                "-1",
                                "",
                                previous.interactingIndex,
                                previous.interactingID,
                                previous.interactingName,
                                previous.wornItems
                        ), currentRoom.getName());
                    }
                }
            }
            int interactedIndex = -1;
            int interactedID = -1;
            String targetName = "";
            Actor interacted = p.getInteracting();
            if (interacted instanceof NPC)
            {
                NPC npc = (NPC) interacted;
                interactedID = npc.getId();
                interactedIndex = npc.getIndex();
                targetName = npc.getName();
            }
            if (interacted instanceof Player)
            {
                Player player = (Player) interacted;
                targetName = player.getName();
            }
            lastTickPlayer.put(p.getName(), new PlayerCopy(
                    p.getName(), interactedIndex, interactedID, targetName, p.getAnimation(), PlayerWornItems.getStringFromComposition(p.getPlayerComposition()
            ), String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON))));
        }

        for (QueuedPlayerAttackLessProjectiles playerAttackQueuedItem : playersAttacked)
        {
            playerAttackQueuedItem.tick--;
            if (playerAttackQueuedItem.tick == 0)
            {
                for (Projectile projectile : client.getProjectiles())
                {
                    int offset = 41; //zcb
                    if (projectile.getId() == DAWNBRINGER_AUTO_PROJECTILE || projectile.getId() == DAWNBRINGER_SPEC_PROJECTILE)
                    {
                        offset = 51; //dawnbringer
                    }
                    if (projectile.getStartCycle() == client.getGameCycle() + offset)
                    {
                        WorldPoint position = WorldPoint.fromLocal(client, new LocalPoint(projectile.getX1(), projectile.getY1()));
                        if (position.distanceTo(playerAttackQueuedItem.player.getWorldLocation()) == 0)
                        {
                            if (projectile.getId() == DAWNBRINGER_AUTO_PROJECTILE || projectile.getId() == DAWNBRINGER_SPEC_PROJECTILE)
                            {
                                int projectileHitTick = projectile.getRemainingCycles();
                                projectileHitTick = (projectileHitTick / 30);
                                clog.addLine(DAWN_SPEC, playerAttackQueuedItem.player.getName(), String.valueOf(client.getTickCount() - currentRoom.roomStartTick + projectileHitTick + 1));

                            }
                            if (projectile.getId() == DAWNBRINGER_AUTO_PROJECTILE || projectile.getId() == ZCB_PROJECTILE || projectile.getId() == ZCB_SPEC_PROJECTILE || projectile.getId() == DAWNBRINGER_SPEC_PROJECTILE)
                            {
                                int interactedIndex = -1;
                                int interactedID = -1;
                                Actor interacted = playerAttackQueuedItem.player.getInteracting();
                                String targetName = "";
                                if (interacted instanceof NPC)
                                {
                                    NPC npc = (NPC) interacted;
                                    interactedID = npc.getId();
                                    interactedIndex = npc.getIndex();
                                    targetName = npc.getName();
                                }
                                if (interacted instanceof Player)
                                {
                                    Player player = (Player) interacted;
                                    targetName = player.getName();
                                }
                                clog.addLine(PLAYER_ATTACK,
                                        playerAttackQueuedItem.player.getName() + ":" + (client.getTickCount() - currentRoom.roomStartTick),
                                        playerAttackQueuedItem.animation+":"+PlayerWornItems.getStringFromComposition(playerAttackQueuedItem.player.getPlayerComposition()),
                                        playerAttackQueuedItem.spotAnims,
                                        playerAttackQueuedItem.weapon + ":" + interactedIndex + ":" + interactedID,
                                        projectile.getId() + ":" + targetName);
                                liveFrame.addAttack(new PlayerDidAttack(itemManager,
                                                playerAttackQueuedItem.player.getName(),
                                                playerAttackQueuedItem.animation,
                                                0,
                                                playerAttackQueuedItem.weapon,
                                                String.valueOf(projectile.getId()),
                                                playerAttackQueuedItem.spotAnims,
                                                interactedIndex,
                                                interactedID,
                                                targetName,
                                                PlayerWornItems.getStringFromComposition(playerAttackQueuedItem.player.getPlayerComposition()))
                                        , currentRoom.getName());
                            }
                        }
                    }
                }
            }
        }
        playersAttacked.removeIf(p -> p.tick == 0);
        removeDeadProjectiles();
        removeDeadVenges();
        playersTextChanged.clear();
        localPlayers.clear();
        for (Player p : client.getPlayers())
        {
            localPlayers.add(new PlayerShell(p.getWorldLocation(), p.getName()));
            thrallTracker.updatePlayerInteracting(p.getName(), p.getInteracting());
        }
        for (DamageQueueShell damage : queuedThrallDamage)
        {
            damage.offset--;
        }
        thrallTracker.updateTick();
        vengTracker.updateTick();
        updateRoom();
        if (inTheatre)
        {
            wasInTheatre = true;
            currentRoom.updateGameTick(event);

            if (currentRoom.isActive())
            {
				SwingUtilities.invokeLater(() ->
					liveFrame.incrementTick(currentRoom.getName()));
                int HP_VARBIT = 6448;
                liveFrame.getPanel(currentRoom.getName()).addRoomHP(client.getTickCount() - currentRoom.roomStartTick, client.getVarbitValue(HP_VARBIT));
                clog.addLine(UPDATE_HP, String.valueOf(client.getVarbitValue(HP_VARBIT)), String.valueOf(client.getTickCount() - currentRoom.roomStartTick), currentRoom.getName());
            }

            if (client.getTickCount() == deferredTick)
            {
                String[] players = {"", "", "", "", ""};
                int varcStrID = 330; // Widget for player names
                for (int i = varcStrID; i < varcStrID + 5; i++)
                {
                    if (client.getVarcStrValue(i) != null && !client.getVarcStrValue(i).isEmpty())
                    {
                        players[i - varcStrID] = Text.escapeJagex(client.getVarcStrValue(i));
                    }
                }
                for (String s : players)
                {
                    if (!s.isEmpty())
                    {
                        currentPlayers.add(s.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)));
                    }
                }
                liveFrame.setPlayers(currentPlayers);
                checkPartyUpdate();
                boolean flag = false;
                for (String p : players)
                {
                    if (p.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)).equals(Objects.requireNonNull(client.getLocalPlayer().getName()).replaceAll(String.valueOf((char) 160), String.valueOf((char) 32))))
                    {
                        flag = true;
                    }
                }
                deferredTick = 0;
                if (!flag)
                {
                    clog.addLine(SPECTATE);
                }
                clog.addLine(PARTY_MEMBERS, players[0], players[1], players[2], players[3], players[4]);
                maiden.setScale((int) Arrays.stream(players).filter(x -> !x.isEmpty()).count());
                scale = currentPlayers.size();
            }
        } else
        {
            if (wasInTheatre)
            {
                leftRaid();
                wasInTheatre = false;
                return;
            }
        }
        clog.writeFile();
    }

    private void checkOverheadTextsThatChanged()
    {
        for (String player : playersWhoHaveOverheadText)
        {
            for (VengPair vp : playersTextChanged)
            {
                if (vp.player.equals(player))
                {
                    activeVenges.add(new VengDamageQueue(vp.player, vp.hitsplat, client.getTickCount() + 1));
                }
            }
        }
        playersWhoHaveOverheadText.clear();
    }

    private void checkAnimationsThatChanged()
    {
        for(Player p : deferredAnimations)
        {
            checkAnimation(p);
        }
        deferredAnimations.clear();
    }

    private void checkAnimation(Player p)
    {
        if (inTheatre)
        {
            if (p.getPlayerComposition() != null)
            {
                int id = p.getPlayerComposition().getEquipmentId(KitType.WEAPON);
                if (p.getAnimation() == SCYTHE_ANIMATION)
                {
                    if (id == UNCHARGED_SCYTHE || id == UNCHARGED_BLOOD_SCYTHE || id == UNCHARGED_HOLY_SCYTHE)
                    {
                        if (config.showMistakesInChat())
                        {
                            sendChatMessage(p.getName() + " is using an uncharged scythe");
                        }
                    }
                } else if (p.getAnimation() == BOP_ANIMATION)
                {
                    if (id == DRAGON_WARHAMMER || id == DRAGON_WARHAMMER_ALTERNATE)
                    {
                        if (config.showMistakesInChat())
                        {
                            sendChatMessage(p.getName() + " hammer bopped (bad rng)");
                        }
                        clog.addLine(DWH_BOP, p.getName());
                    }
                } else if (p.getAnimation() == WHACK_ANIMATION)
                {
                    if (id == KODAI_WAND || id == KODAI_WAND_ALTERNATE)
                    {
                        if (config.showMistakesInChat())
                        {
                            sendChatMessage(p.getName() + " kodai bopped (nothing they could've done to prevent it)");
                        }
                        clog.addLine(KODAI_BOP, p.getName());
                    }
                } else if (p.getAnimation() == STAB_ANIMATION)
                {
                    if (id == CHALLY)
                    {
                        if (config.showMistakesInChat())
                        {
                            sendChatMessage(p.getName() + " chally poked");
                        }
                        clog.addLine(CHALLY_POKE, p.getName());
                    }
                } else if (p.getAnimation() == TWO_HAND_SWORD_SWING)
                {
                    if(id == BANDOS_GODSWORD || id == BANDOS_GODSWORD_OR)
                    {
                        if (config.showMistakesInChat())
                        {
                            sendChatMessage(p.getName() + " swung BGS without speccing");
                        }
                        clog.addLine(BGS_WHACK, p.getName());
                    }
                }
                StringBuilder animations = new StringBuilder();
                for (ActorSpotAnim anim : p.getSpotAnims())
                {
                    animations.append(anim.getId());
                    animations.append(":");
                }
                if (p.getAnimation() == POWERED_STAFF_ANIMATION || p.getAnimation() == CROSSBOW_ANIMATION)
                {
                    if (p.getAnimation() != POWERED_STAFF_ANIMATION || p.getPlayerComposition().getEquipmentId(KitType.WEAPON) == DAWNBRINGER_ITEM)
                    { //Can be ZCB, Sang, or Dawnbringer. We only care about projectile for dawnbringer or ZCB. Sang & dawnbringer share animation
                        //so this filters powered staves unless it's dawnbringer
                        WorldPoint worldPoint = p.getWorldLocation();
                        playersAttacked.add(new QueuedPlayerAttackLessProjectiles(p, worldPoint, 1, animations.toString(), String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON)), String.valueOf(p.getAnimation())));
                    }
                    else
                    {
                        int interactedIndex = -1;
                        int interactedID = -1;
                        Actor interacted = p.getInteracting();
                        String targetName = "";
                        if (interacted instanceof NPC)
                        {
                            NPC npc = (NPC) interacted;
                            interactedID = npc.getId();
                            interactedIndex = npc.getIndex();
                            targetName = npc.getName();
                        }
                        generatePlayerAttackInfo(p, animations.toString(), interactedIndex, interactedID, interacted, targetName);
                    }
                }
                else if (p.getAnimation() != -1)
                {
                    int interactedIndex = -1;
                    int interactedID = -1;
                    Actor interacted = p.getInteracting();
                    String targetName = "";
                    if (interacted instanceof NPC)
                    {
                        NPC npc = (NPC) interacted;
                        interactedID = npc.getId();
                        interactedIndex = npc.getIndex();
                    }
                    generatePlayerAttackInfo(p, animations.toString(), interactedIndex, interactedID, interacted, targetName);
                    if (p.getAnimation() == BLOWPIPE_ANIMATION || p.getAnimation() == BLOWPIPE_ANIMATION_OR)
                    {
                        activelyPiping.put(p, client.getTickCount());
                        interactedIndex = -1;
                        interactedID = -1;
                        targetName = "";
                        interacted = p.getInteracting();
                        if (interacted instanceof NPC)
                        {
                            NPC npc = (NPC) interacted;
                            interactedID = npc.getId();
                            interactedIndex = npc.getIndex();
                            targetName = npc.getName();
                        }
                        if (interacted instanceof Player)
                        {
                            Player player = (Player) interacted;
                            targetName = player.getName();
                        }
                        lastTickPlayer.put(p.getName(), new PlayerCopy(
                                p.getName(), interactedIndex, interactedID, targetName, p.getAnimation(), PlayerWornItems.getStringFromComposition(p.getPlayerComposition()
                        ), String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON))));
                    }
                    else
                    {
                        activelyPiping.remove(p);
                        lastTickPlayer.remove(p.getName());
                    }
                }
                else
                {
                    activelyPiping.remove(p);
                    lastTickPlayer.remove(p.getName());
                }

            }
        }
    }

    public void leftRaid()
    {
        lastTickPlayer.clear();
        partyIntact = false;
        currentPlayers.clear();
        clog.addLine(LEFT_TOB, String.valueOf(client.getTickCount() - currentRoom.roomStartTick), currentRoom.getName());
        clog.writeFile();
        clog.migrateToNewRaid();
        currentRoom = null;
        activelyPiping.clear();
        deferredAnimations.clear();
    }

    @Subscribe
    public void onActorDeath(ActorDeath event)
    {
        if (inTheatre)
        {
            Actor a = event.getActor();
            if (a instanceof Player)
            {
                clog.addLine(PLAYER_DIED, event.getActor().getName(), String.valueOf(client.getTickCount() - currentRoom.roomStartTick));
            }
        }
    }

    @Subscribe
    public void onGroundObjectSpawned(GroundObjectSpawned event)
    {
        if(inTheatre)
        {
            currentRoom.updateGroundObjectSpawned(event);
        }
    }

    @Subscribe
    public void onGraphicChanged(GraphicChanged event)
    {
        if (event.getActor() instanceof Player)
        {
            int id = -1;
            if (event.getActor().hasSpotAnim(THRALL_CAST_GRAPHIC_MAGE))
            {
                id = THRALL_CAST_GRAPHIC_MAGE;
            } else if (event.getActor().hasSpotAnim(THRALL_CAST_GRAPHIC_MELEE))
            {
                id = THRALL_CAST_GRAPHIC_MELEE;
            } else if (event.getActor().hasSpotAnim(THRALL_CAST_GRAPHIC_RANGE))
            {
                id = THRALL_CAST_GRAPHIC_RANGE;
            } else if (event.getActor().hasSpotAnim(VENG_GRAPHIC))
            {
                vengTracker.vengSelfGraphicApplied((Player) event.getActor());
            } else if (event.getActor().hasSpotAnim(VENG_OTHER_GRAPHIC))
            {
                vengTracker.vengOtherGraphicApplied((Player) event.getActor());
            }
            if (id != -1)
            {
                thrallTracker.playerHasThrallCastSpotAnim((Player) event.getActor(), id);
            }

        }
        if (inTheatre)
        {
            currentRoom.updateGraphicChanged(event);
        }
    }

    @Subscribe
    public void onGraphicsObjectCreated(GraphicsObjectCreated event)
    {
        if (inTheatre)
        {
            currentRoom.updateGraphicsObjectCreated(event);
        }
    }

    @Subscribe
    public void onGameObjectSpawned(GameObjectSpawned event)
    {
        if (inTheatre)
        {
            currentRoom.updateGameObjectSpawned(event);
        }
    }

    @Subscribe
    public void onGameObjectDespawned(GameObjectDespawned event)
    {
        if (inTheatre)
        {
            currentRoom.updateGameObjectDespawned(event);
        }
    }

    @Subscribe
    public void onItemSpawned(ItemSpawned event)
    {
        if (inTheatre)
        {
            currentRoom.updateItemSpawned(event);
        }
    }

    @Subscribe
    public void onProjectileMoved(ProjectileMoved event)
    {
        if (inTheatre)
        {
            int id = event.getProjectile().getId();
            if (id == THRALL_PROJECTILE_RANGE || id == THRALL_PROJECTILE_MAGE)
            {
                if (event.getProjectile().getStartCycle() == client.getGameCycle())
                {
                    thrallTracker.projectileCreated(event.getProjectile(), WorldPoint.fromLocal(client, new LocalPoint(event.getProjectile().getX1(), event.getProjectile().getY1())));
                }
            }
            //Thrall hitsplats come before damage hitsplits unless the source is a projectile that was spawned on a tick before the thrall projectile spawned
            else if (event.getProjectile().getStartCycle() == client.getGameCycle())
            { //Thrall projectiles move slower and the only time this situation occurs in TOB is max distance TBOW/ZCB during maiden
                if (id == TBOW_PROJECTILE || id == ZCB_PROJECTILE || id == ZCB_SPEC_PROJECTILE)
                { //Not sure why 10 is correct instead of 19 (60 - 41 tick delay) but extensive trial and error shows this to be accurate
                    int projectileHitTick = 10 + event.getProjectile().getRemainingCycles();
                    projectileHitTick = (projectileHitTick / 30);
                    if (event.getProjectile().getInteracting() instanceof NPC)
                    {
                        int index = ((NPC) event.getProjectile().getInteracting()).getIndex();
                        activeProjectiles.add(new ProjectileQueue(client.getTickCount(), projectileHitTick + client.getTickCount(), index));
                    }
                }
            }
            if (inTheatre)
            {
                currentRoom.updateProjectileMoved(event);
            }
        }
    }

    public void sendChatMessage(String msg)
    {
        clientThread.invoke(() -> client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, null, false));
    }

    private final ArrayList<Player> deferredAnimations = new ArrayList<>();

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if(event.getGroup().equals("Advanced Raid Tracker") && event.getKey().contains("primary"))
        {
            liveFrame.redrawAll();
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event)
    {
        if(event.getActor() instanceof Player)
        {
            Player p = (Player) event.getActor();
            if(event.getActor().getAnimation() == 6294 || event.getActor().getAnimation() == 722 || event.getActor().getAnimation() == 6299 || event.getActor().getAnimation() == -1)
            {
                checkAnimation(p);
            }
            else
            {
                deferredAnimations.add(p);
            }
        }
        if (inTheatre)
        {
            int id = event.getActor().getAnimation();
            if (event.getActor().getAnimation() == THRALL_CAST_ANIMATION)
            {
                thrallTracker.castThrallAnimation((Player) event.getActor());
            } else if (event.getActor().getAnimation() == MELEE_THRALL_ATTACK_ANIMATION && event.getActor() instanceof NPC)
            {
                thrallTracker.meleeThrallAttacked((NPC) event.getActor());
            } else if (event.getActor().getAnimation() == VENG_CAST)
            {
                vengTracker.vengSelfCast((Player) event.getActor());
            } else if (event.getActor().getAnimation() == VENG_OTHER_CAST)
            {
                vengTracker.vengOtherCast((Player) event.getActor());
            } else if (id == DWH_SPEC)
            {
                clog.addLine(HAMMER_ATTEMPTED, event.getActor().getName());
            } else if (event.getActor().getName() != null && event.getActor().getName().contains("Maiden") && id == MAIDEN_BLOOD_THROW_ANIM)
            {
                clog.addLine(BLOOD_THROWN);
            }
            if (inTheatre)
            {
                currentRoom.updateAnimationChanged(event);
            }
        }
    }

    private void generatePlayerAttackInfo(Player p, String animations, int interactedIndex, int interactedID, Actor interacted, String targetName)
    {
        if (interacted instanceof Player)
        {
            Player player = (Player) interacted;
            targetName = player.getName();
        }
        clog.addLine(PLAYER_ATTACK,
                p.getName() + ":" + (client.getTickCount() - currentRoom.roomStartTick),
                p.getAnimation()+":"+PlayerWornItems.getStringFromComposition(p.getPlayerComposition()),
                animations,
                p.getPlayerComposition().getEquipmentId(KitType.WEAPON) + ":" + interactedIndex + ":" + interactedID,
                "-1:" + targetName);
        liveFrame.addAttack(new PlayerDidAttack(itemManager,
                String.valueOf(p.getName()),
                String.valueOf(p.getAnimation()),
                0,
                String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON)),
                "-1",
                animations,
                interactedIndex,
                interactedID,
                targetName,
                PlayerWornItems.getStringFromComposition(p.getPlayerComposition())
        ), currentRoom.getName());
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged event)
    {
        if (inTheatre)
        {
            currentRoom.updateInteractingChanged(event);
        }
    }

    @Subscribe
    public void onNpcChanged(NpcChanged event)
    {
        if (inTheatre)
        {
            currentRoom.handleNPCChanged(event.getNpc().getId());
        }
    }

    private void handleThrallSpawn(NPC npc)
    {
        ArrayList<PlayerShell> potentialPlayers = new ArrayList<>();
        for (PlayerShell p : localPlayers)
        {
            if (p.worldLocation.distanceTo(npc.getWorldLocation()) == 1)
            {
                potentialPlayers.add(p);
            }
        }
        thrallTracker.thrallSpawned(npc, potentialPlayers);
    }

    @Subscribe
    public void onNpcSpawned(NpcSpawned event)
    {
        int id = event.getNpc().getId();
        if (id == MELEE_THRALL || id == RANGE_THRALL || id == MAGE_THRALL)
        {
            handleThrallSpawn(event.getNpc());
        }
        switch (event.getNpc().getId())
        {
            case TobIDs.MAIDEN_P0:
            case TobIDs.MAIDEN_P1:
            case TobIDs.MAIDEN_P2:
            case TobIDs.MAIDEN_P3:
            case TobIDs.MAIDEN_PRE_DEAD:
            case TobIDs.MAIDEN_DEAD:
            case TobIDs.MAIDEN_MATOMENOS:
            case TobIDs.MAIDEN_P0_HM:
            case TobIDs.MAIDEN_P1_HM:
            case TobIDs.MAIDEN_P2_HM:
            case TobIDs.MAIDEN_P3_HM:
            case TobIDs.MAIDEN_PRE_DEAD_HM:
            case TobIDs.MAIDEN_DEAD_HM:
            case TobIDs.MAIDEN_MATOMENOS_HM:
            case TobIDs.MAIDEN_P0_SM:
            case TobIDs.MAIDEN_P1_SM:
            case TobIDs.MAIDEN_P2_SM:
            case TobIDs.MAIDEN_P3_SM:
            case TobIDs.MAIDEN_PRE_DEAD_SM:
            case TobIDs.MAIDEN_DEAD_SM:
            case TobIDs.MAIDEN_MATOMENOS_SM:
            case TobIDs.MAIDEN_BLOOD:
            case TobIDs.MAIDEN_BLOOD_HM:
            case TobIDs.MAIDEN_BLOOD_SM:
            {
                maiden.updateNpcSpawned(event);
            }
            break;
            case TobIDs.BLOAT:
            case TobIDs.BLOAT_HM:
            case TobIDs.BLOAT_SM:
                bloat.updateNpcSpawned(event);
                break;
            case TobIDs.NYLO_MELEE_SMALL:
            case TobIDs.NYLO_MELEE_SMALL_AGRO:
            case TobIDs.NYLO_RANGE_SMALL:
            case TobIDs.NYLO_RANGE_SMALL_AGRO:
            case TobIDs.NYLO_MAGE_SMALL:
            case TobIDs.NYLO_MAGE_SMALL_AGRO:
            case TobIDs.NYLO_MELEE_BIG:
            case TobIDs.NYLO_MELEE_BIG_AGRO:
            case TobIDs.NYLO_RANGE_BIG:
            case TobIDs.NYLO_RANGE_BIG_AGRO:
            case TobIDs.NYLO_MAGE_BIG:
            case TobIDs.NYLO_MAGE_BIG_AGRO:
            case TobIDs.NYLO_MELEE_SMALL_HM:
            case TobIDs.NYLO_MELEE_SMALL_AGRO_HM:
            case TobIDs.NYLO_RANGE_SMALL_HM:
            case TobIDs.NYLO_RANGE_SMALL_AGRO_HM:
            case TobIDs.NYLO_MAGE_SMALL_HM:
            case TobIDs.NYLO_MAGE_SMALL_AGRO_HM:
            case TobIDs.NYLO_MELEE_BIG_HM:
            case TobIDs.NYLO_MELEE_BIG_AGRO_HM:
            case TobIDs.NYLO_RANGE_BIG_HM:
            case TobIDs.NYLO_RANGE_BIG_AGRO_HM:
            case TobIDs.NYLO_MAGE_BIG_HM:
            case TobIDs.NYLO_MAGE_BIG_AGRO_HM:
            case TobIDs.NYLO_MELEE_SMALL_SM:
            case TobIDs.NYLO_MELEE_SMALL_AGRO_SM:
            case TobIDs.NYLO_RANGE_SMALL_SM:
            case TobIDs.NYLO_RANGE_SMALL_AGRO_SM:
            case TobIDs.NYLO_MAGE_SMALL_SM:
            case TobIDs.NYLO_MAGE_SMALL_AGRO_SM:
            case TobIDs.NYLO_MELEE_BIG_SM:
            case TobIDs.NYLO_MELEE_BIG_AGRO_SM:
            case TobIDs.NYLO_RANGE_BIG_SM:
            case TobIDs.NYLO_RANGE_BIG_AGRO_SM:
            case TobIDs.NYLO_MAGE_BIG_SM:
            case TobIDs.NYLO_MAGE_BIG_AGRO_SM:
            case TobIDs.NYLO_BOSS_DROPPING:
            case TobIDs.NYLO_BOSS_DROPPING_HM:
            case TobIDs.NYLO_BOSS_DROPING_SM:
            case TobIDs.NYLO_BOSS_MELEE:
            case TobIDs.NYLO_BOSS_MELEE_HM:
            case TobIDs.NYLO_BOSS_MELEE_SM:
            case TobIDs.NYLO_BOSS_MAGE:
            case TobIDs.NYLO_BOSS_MAGE_HM:
            case TobIDs.NYLO_BOSS_MAGE_SM:
            case TobIDs.NYLO_BOSS_RANGE:
            case TobIDs.NYLO_BOSS_RANGE_HM:
            case TobIDs.NYLO_BOSS_RANGE_SM:
            case TobIDs.NYLO_PRINKIPAS_DROPPING:
            case TobIDs.NYLO_PRINKIPAS_MELEE:
            case TobIDs.NYLO_PRINKIPAS_MAGIC:
            case TobIDs.NYLO_PRINKIPAS_RANGE:
                nylo.updateNpcSpawned(event);
                break;
            case TobIDs.SOTETSEG_ACTIVE:
            case TobIDs.SOTETSEG_ACTIVE_HM:
            case TobIDs.SOTETSEG_ACTIVE_SM:
            case TobIDs.SOTETSEG_INACTIVE:
            case TobIDs.SOTETSEG_INACTIVE_HM:
            case TobIDs.SOTETSEG_INACTIVE_SM:
                sote.updateNpcSpawned(event);
                break;
            case TobIDs.XARPUS_INACTIVE:
            case TobIDs.XARPUS_P1:
            case TobIDs.XARPUS_P23:
            case TobIDs.XARPUS_DEAD:
            case TobIDs.XARPUS_INACTIVE_HM:
            case TobIDs.XARPUS_P1_HM:
            case TobIDs.XARPUS_P23_HM:
            case TobIDs.XARPUS_DEAD_HM:
            case TobIDs.XARPUS_INACTIVE_SM:
            case TobIDs.XARPUS_P1_SM:
            case TobIDs.XARPUS_P23_SM:
            case TobIDs.XARPUS_DEAD_SM:
                xarpus.updateNpcSpawned(event);
                break;
            case TobIDs.VERZIK_P1_INACTIVE:
            case TobIDs.VERZIK_P1:
            case TobIDs.VERZIK_P2_INACTIVE:
            case TobIDs.VERZIK_P2:
            case TobIDs.VERZIK_P3_INACTIVE:
            case TobIDs.VERZIK_P3:
            case TobIDs.VERZIK_DEAD:
            case TobIDs.VERZIK_P1_INACTIVE_HM:
            case TobIDs.VERZIK_P1_HM:
            case TobIDs.VERZIK_P2_INACTIVE_HM:
            case TobIDs.VERZIK_P2_HM:
            case TobIDs.VERZIK_P3_INACTIVE_HM:
            case TobIDs.VERZIK_P3_HM:
            case TobIDs.VERZIK_DEAD_HM:
            case TobIDs.VERZIK_P1_INACTIVE_SM:
            case TobIDs.VERZIK_P1_SM:
            case TobIDs.VERZIK_P2_INACTIVE_SM:
            case TobIDs.VERZIK_P2_SM:
            case TobIDs.VERZIK_P3_INACTIVE_SM:
            case TobIDs.VERZIK_P3_SM:
            case TobIDs.VERZIK_DEAD_SM:
                verzik.updateNpcSpawned(event);
                break;
            default:
                if (currentRoom != null)
                {
                    currentRoom.updateNpcSpawned(event);
                }
                break;
        }
    }

    @Subscribe
    public void onNpcDespawned(NpcDespawned event)
    {
        int id = event.getNpc().getId();
        if (id == MELEE_THRALL || id == RANGE_THRALL || id == MAGE_THRALL)
        {
            thrallTracker.removeThrall(event.getNpc());
        }
        if (inTheatre)
        {
            currentRoom.updateNpcDespawned(event);
        }
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event)
    {
        if (inTheatre)
        {
            if (event.getActor() instanceof Player && inTheatre)
            {
                playersTextChanged.add(new VengPair(event.getActor().getName(), event.getHitsplat().getAmount()));
            }
            queuedThrallDamage.sort(Comparator.comparing(DamageQueueShell::getSourceIndex));
            int index = -1;
            if (event.getActor() instanceof NPC && event.getHitsplat().getHitsplatType() != HitsplatID.HEAL)
            {
                for (int i = 0; i < queuedThrallDamage.size(); i++)
                {
                    int altIndex = 0;
                    int matchedIndex = -1;
                    boolean postponeThrallHit = false;
                    for (ProjectileQueue projectile : activeProjectiles)
                    {
                        if (projectile.targetIndex == ((NPC) event.getActor()).getIndex())
                        {
                            if (client.getTickCount() == projectile.finalTick)
                            {
                                if (projectile.originTick < queuedThrallDamage.get(i).originTick)
                                {
                                    postponeThrallHit = true;
                                    matchedIndex = altIndex;
                                }
                            }
                        }
                        altIndex++;
                    }
                    if (queuedThrallDamage.get(i).offset == 0 && queuedThrallDamage.get(i).targetIndex == ((NPC) event.getActor()).getIndex())
                    {
                        if (postponeThrallHit)
                        {
                            activeProjectiles.remove(matchedIndex);
                        } else
                        {
                            if (event.getHitsplat().getAmount() <= 3)
                            {
                                index = i;
                                clog.addLine(THRALL_DAMAGED, queuedThrallDamage.get(i).source, String.valueOf(event.getHitsplat().getAmount()));

                            }
                        }
                        if (index != -1)
                        {
                            queuedThrallDamage.remove(index);
                        }
                        if (inTheatre)
                        {
                            currentRoom.updateHitsplatApplied(event);
                        }
                        return;
                    }
                }
                for (VengDamageQueue veng : activeVenges)
                {
                    int expectedDamage = (int) (0.75 * veng.damage);
                    if (event.getHitsplat().getAmount() == expectedDamage)
                    {
                        //todo can be wrong if splat would overkill
                        clog.addLine(VENG_WAS_PROCCED, veng.target, String.valueOf(expectedDamage));
                        if (inTheatre)
                        {
                            currentRoom.updateHitsplatApplied(event);
                        }
                        return;
                    }
                }
            }

            if (inTheatre)
            {
                currentRoom.updateHitsplatApplied(event);
            }
        }
    }


    private ArrayList<VengPair> playersTextChanged;

    private final ArrayList<String> playersWhoHaveOverheadText = new ArrayList<>();

    @Subscribe
    public void onOverheadTextChanged(OverheadTextChanged event)
    {
        if (inTheatre)
        {
            if (event.getOverheadText().equals("Taste vengeance!"))
            {
                playersWhoHaveOverheadText.add(event.getActor().getName());
            }
            if (currentRoom instanceof XarpusHandler)
            {
                xarpus.updateOverheadText(event);
            }
        }
    }
}

package com.advancedraidtracker;

import com.advancedraidtracker.constants.LogID;
import com.advancedraidtracker.utility.wrappers.PlayerDidAttack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;

import java.io.File;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

import static com.advancedraidtracker.constants.TobIDs.EXIT_FLAG;
import static com.advancedraidtracker.constants.TobIDs.SPECTATE_FLAG;

@Slf4j
public class AdvancedTOBData
{
    public final ArrayList<PlayerDidAttack> maidenAttacks = new ArrayList<>();
    public final ArrayList<PlayerDidAttack> bloatAttacks = new ArrayList<>();
    public final ArrayList<PlayerDidAttack> nyloAttacks = new ArrayList<>();
    public final ArrayList<PlayerDidAttack> soteAttacks = new ArrayList<>();
    public final ArrayList<PlayerDidAttack> xarpAttacks = new ArrayList<>();
    public final ArrayList<PlayerDidAttack> verzikAttacks = new ArrayList<>();
    public Map<Integer, Integer> maidenHP = new HashMap<>();
    public Map<Integer, Integer> bloatHP = new HashMap<>();
    public Map<Integer, Integer> nyloHP = new HashMap<>();
    public Map<Integer, Integer> soteHP = new HashMap<>();
    public Map<Integer, Integer> xarpHP = new HashMap<>();
    public Map<Integer, Integer> verzikHP = new HashMap<>();
    public Map<Integer, String> maidenNPCMapping = new HashMap<>();
    public Map<Integer, String> nyloNPCMapping = new HashMap<>();
    public Map<Integer, String> verzikNPCMapping = new HashMap<>();
    private ArrayList<String> globalData;
    private final ItemManager itemManager;

    public static ArrayList<String> getRaidStrings(String path)
    {
        ArrayList<String> lines = new ArrayList<>();
        File file = new File(path);
        try
        {
            Scanner scanner = new Scanner(Files.newInputStream(file.toPath()));
            while(scanner.hasNextLine())
            {
                lines.add(scanner.nextLine());
            }
        }
        catch(Exception ignored)
        {

        }
        return lines;
    }
    public AdvancedTOBData(ArrayList<String> globalData, ItemManager itemManager)
    {
        this.itemManager = itemManager;
        this.globalData = globalData;
        int room = -1;
        for (String s : globalData)
        {
            String[] subData = s.split(",");
            int key = Integer.parseInt(subData[3]);
            if (key == SPECTATE_FLAG)
            {
                room = Integer.parseInt(subData[4]);
            }
        }
        if (room > 0)
        {
            switch (room)
            {
                case 1:
                    if (!(checkExit() && parseBloat()))
                        break;
                case 2:
                    if (!(checkExit() && parseNylo()))
                        break;
                case 3:
                    if (!(checkExit() && parseSotetseg()))
                        break;
                case 4:
                    if (!(checkExit() && parseXarpus()))
                        break;
                case 5:
                    if (checkExit())
                    {
                        parseVerzik();
                    }
            }
        } else
        {
            try
            {
                if (parseMaiden())
                {
                    if (checkExit() && parseBloat())
                    {
                        if (checkExit() && parseNylo())
                        {
                            if (checkExit() && parseSotetseg())
                            {
                                if (checkExit() && parseXarpus())
                                {
                                    if (checkExit())
                                    {
                                        parseVerzik();
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (Exception ignored)
            {
            }
        }
    }

    PlayerDidAttack getPlayerDidAttack(String[] subData)
    {
        String player = subData[4].split(":")[0];
        int tick = Integer.parseInt(subData[4].split(":")[1]);
        String wornItems = "";
        String [] animationAndWorn = subData[5].split(":");
        String animation = animationAndWorn[0];
        if(animationAndWorn.length == 2)
        {
            wornItems = animationAndWorn[1];
        }
        String spotAnims = subData[6];
        String[] subsubData = subData[7].split(":");
        String weapon = subsubData[0];
        int interactedIndex = -1;
        int interactedID = -1;
        if (subsubData.length > 2)
        {
            interactedIndex = Integer.parseInt(subsubData[1]);
            interactedID = Integer.parseInt(subsubData[2]);
        }
        String[] projectileAndTargetData = subData[8].split(":");
        String projectile = projectileAndTargetData[0];
        String targetName = "";
        if (projectileAndTargetData.length > 1)
        {
            targetName = projectileAndTargetData[1];
        }
        return (new PlayerDidAttack(itemManager, player, animation, tick, weapon, projectile, spotAnims, interactedIndex, interactedID, targetName, wornItems));
    }

    private boolean parseMaiden()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        return false;
                    case MAIDEN_0HP:
                    case BLOAT_SPAWNED:
                    case MAIDEN_DESPAWNED:
                        break loop;
                    case PLAYER_ATTACK:
                        maidenAttacks.add(getPlayerDidAttack(subData));
                        break;
                    case UPDATE_HP:
                        maidenHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));
                        break;
                    case ADD_NPC_MAPPING:
                        maidenNPCMapping.put(Integer.parseInt(subData[4]), subData[5]);
                        break;
                }
            }
            catch(Exception ignored)
            {
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean parseBloat()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        return false;
                    case BLOAT_DESPAWN:
                        break loop;
                    case PLAYER_ATTACK:
                        bloatAttacks.add(getPlayerDidAttack(subData));
                        break;
                    case UPDATE_HP:
                        bloatHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));
                        break;
                }
            }
            catch(Exception ignored)
            {
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean parseNylo()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        return false;
                    case NYLO_DESPAWNED:
                        break loop;
                    case PLAYER_ATTACK:
                        nyloAttacks.add(getPlayerDidAttack(subData));
                        break;
                    case UPDATE_HP:
                        nyloHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));
                        break;
                    case ADD_NPC_MAPPING:
                        nyloNPCMapping.put(Integer.parseInt(subData[4]), subData[5]);
                        break;
                }
            }
            catch(Exception ignored)
            {
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean parseSotetseg()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        return false;
                    case SOTETSEG_ENDED:
                        break loop;
                    case PLAYER_ATTACK:
                        soteAttacks.add(getPlayerDidAttack(subData));
                        break;
                    case UPDATE_HP:
                        soteHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));
                        break;

                }
            }
            catch(Exception ignored)
            {
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean parseXarpus()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        return false;
                    case XARPUS_DESPAWNED:
                        break loop;
                    case PLAYER_ATTACK:
                        xarpAttacks.add(getPlayerDidAttack(subData));
                        break;
                    case UPDATE_HP:
                        xarpHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));
                        break;
                }
            }
            catch(Exception ignored)
            {
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private void parseVerzik()
    {
        int activeIndex = 0;
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        return;
                    case PLAYER_ATTACK:
                        verzikAttacks.add(getPlayerDidAttack(subData));
                        break;
                    case UPDATE_HP:
                        verzikHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));
                        break;
                    case ADD_NPC_MAPPING:
                        verzikNPCMapping.put(Integer.parseInt(subData[4]), subData[5]);
                        break;
                    case VERZIK_BOUNCE:
                        if (!subData[5].equalsIgnoreCase(""))
                        { //use fake animation ID when bounce occurs
                            verzikAttacks.add(new PlayerDidAttack(itemManager, subData[4], "100000", Integer.parseInt(subData[5]), "-1", "-1", "-1", -1, -1, "", ""));
                        }
                        break;

                }
            } catch (Exception ignored)
            {
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
    }

    public boolean checkExit()
    {
        return !(globalData.isEmpty() || globalData.get(0).split(",", -1)[3].equals(EXIT_FLAG));
    }
}

package com.advancedraidtracker;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

import java.awt.*;

@ConfigGroup("Advanced Raid Tracker")

public interface AdvancedRaidTrackerConfig extends Config
{
    @ConfigItem(
            position = 0,
            keyName = "chatSplts",
            name = "Chat Splits",
            description = "Display room splits in chatbox."
    )
    default boolean chatSplits()
    {
        return false;
    }

    @ConfigItem(
            position = 1,
            keyName = "writeToLog",
            name = "Track Raid Data",
            description = "Tracks data about the raids you spectate and participate in."
    )
    default boolean writeToLog()
    {
        return true;
    }

    @ConfigItem(
            position = 2,
            keyName = "showMistakesInChat",
            name = "Show mistakes in chat?",
            description = "Shows mistakes (hammer bop, etc) in chat box when they occur."
    )
    default boolean showMistakesInChat()
    {
        return true;
    }

    @ConfigItem(
            position = 3,
            keyName = "chartScaleSize",
            name = "Chart Scale Size",
            description = "Adjusts box size in chart"
    )
    default int chartScaleSize()
    {
        return 26;
    }

    @ConfigItem(
            position = 5,
            keyName = "useIconsOnChart",
            name = "Use icons on chart",
            description = "Replaced letter/colors with icons"
    )
    default boolean useIconsOnChart() { return true;}

    @ConfigItem(
            position = 6,
            keyName = "primaryDark",
            name = "Chart Dark Color",
            description = "Color to use as darkest on chart"
    )
    default Color primaryDark() { return new Color(20, 20, 20);}

    @ConfigItem(
            position = 7,
            keyName = "primaryMiddle",
            name = "Chart Middle Color",
            description = "Color to use as Middle on chart"
    )
    default Color primaryMiddle() { return new Color(30, 30, 30);}

    @ConfigItem(
            position = 8,
            keyName = "primaryLight",
            name = "Chart Light Color",
            description = "Color to use as lightest on chart"
    )
    default Color primaryLight() { return new Color(40, 40, 40);}

    @ConfigItem(
            position = 9,
            keyName = "letterBackgroundOpacity",
            name = "Letter BG Opacity",
            description = "Opacity of letter background color on chart"
    )
    default int letterBackgroundOpacity() { return 180;}

    @ConfigItem(
            position = 9,
            keyName = "iconBackgroundOpacity",
            name = "Icon BG Opacity",
            description = "Opacity of icon background color on chart"
    )
    default int iconBackgroundOpacity() { return 180;}

    @ConfigItem(
            position = 10,
            keyName = "useUnkitted",
            name = "Use unkitted icons",
            description = "Replaces kitted items with unkitted variants on chart icons"
    )
    default boolean useUnkitted(){return false;}
}

package com.advancedraidtracker.ui.charts;

import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.constants.TobIDs;
import com.advancedraidtracker.utility.*;
import com.advancedraidtracker.utility.Point;
import com.advancedraidtracker.utility.weapons.WeaponAttack;
import com.advancedraidtracker.utility.weapons.WeaponDecider;
import com.advancedraidtracker.utility.wrappers.*;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.FontManager;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

@Slf4j
public class ChartPanel extends JPanel implements MouseListener, MouseMotionListener, MouseWheelListener
{
    private final int TITLE_BAR_PLUS_TAB_HEIGHT = 63; //todo figure this out dynamically in the future
    private boolean shouldWrap;
    private BufferedImage img;
    int scale;
    int boxCount;
    int boxHeight;
    int boxWidth;
    private int windowHeight = 600;

    int selectedTick = -1;
    String selectedPlayer = "";

    int selectedRow = -1;
    boolean checkBoxHovered = false;

    int startTick;
    public int endTick;
    @Setter
    ArrayList<String> players = new ArrayList<>();
    String room;
    @Setter
    String roomSpecificText = "";
    private int fontHeight;
    public boolean finished = false;
    private final boolean live;
    private final ArrayList<Integer> autos = new ArrayList<>();
    private Map<Integer, String> NPCMap = new HashMap<>();
    private final ArrayList<DawnSpec> dawnSpecs = new ArrayList<>();
    private final ArrayList<ThrallOutlineBox> thrallOutlineBoxes = new ArrayList<>();
    private final ArrayList<OutlineBox> outlineBoxes = new ArrayList<>();
    private final Map<Integer, String> specific = new HashMap<>();
    private final Map<Integer, String> lines = new HashMap<>();
    private final ArrayList<String> crabDescriptions = new ArrayList<>();

    @Setter
    private Map<Integer, Integer> roomHP = new HashMap<>();
    Map<String, Integer> playerOffsets = new LinkedHashMap<>();
    private final Map<PlayerDidAttack, String> actions = new HashMap<>();

    private final ConfigManager configManager;
    private boolean isActive = false;

    public void setActive(Boolean state)
    {
        isActive = state;
    }

    public boolean shouldDraw()
    {
        return !live || isActive;
    }

    public void enableWrap()
    {
        shouldWrap = true;
        recalculateSize();
    }
    private int boxesToShow = 1;

    public void setSize(int x, int y)
    {
        windowHeight = y;
        if(isActive || !live)
        {
            boxesToShow = Math.min(1+((y-TITLE_BAR_PLUS_TAB_HEIGHT-scale)/boxHeight), boxCount);
            if (img != null)
            {
                img.flush();
            }
            img = new BufferedImage(x, y, BufferedImage.TYPE_INT_ARGB);
            recalculateSize();
        }
    }

	public void release()
	{
		resetGraph();
		img = null;
		removeMouseListener(this);
		removeMouseWheelListener(this);
		removeMouseMotionListener(this);
	}

    private final AdvancedRaidTrackerConfig config;

    public void addRoomSpecificData(int tick, String data)
    {
        specific.put(tick, data);
    }

    public void addRoomSpecificDatum(Map<Integer, String> specificData)
    {
        specific.putAll(specificData);
    }

    public void addLine(int tick, String lineInfo)
    {
        lines.put(tick, lineInfo);
    }

    public void addLines(Map<Integer, String> lineData)
    {
        lines.putAll(lineData);
    }

    public void addRoomHP(int tick, int hp)
    {
        roomHP.put(tick, hp);
    }

    public void addAutos(ArrayList<Integer> autos)
    {
        this.autos.addAll(autos);
    }

    public void addThrallBox(ThrallOutlineBox thrallOutlineBox)
    {
        thrallOutlineBoxes.add(thrallOutlineBox);
    }

    public void addThrallBoxes(ArrayList<ThrallOutlineBox> outlineBoxes)
    {
        thrallOutlineBoxes.addAll(outlineBoxes);
    }

    public void addDawnSpec(DawnSpec dawnSpec)
    {
        this.dawnSpecs.add(dawnSpec);
    }

    public void addDawnSpecs(ArrayList<DawnSpec> dawnSpecs)
    {
        this.dawnSpecs.addAll(dawnSpecs);
        drawGraph();
    }

    public void setRoomFinished(int tick)
    {
        finished = true;
        if (tick - endTick < 10)
        {
            endTick = tick;
        }
        drawGraph();
    }

    public void resetGraph()
    {
        currentBox = 0;
        currentScrollOffset = 0;
        endTick = 0;
        startTick = 0;
        selectedRow = -1;
        selectedTick = -1;
        selectedPlayer = "";
        outlineBoxes.clear();
        autos.clear();
        lines.clear();
        specific.clear();
        dawnSpecs.clear();
        thrallOutlineBoxes.clear();
        players.clear();
        playerOffsets.clear();
        crabDescriptions.clear();
        actions.clear();
        roomHP.clear();
        NPCMap.clear();
        finished = false;
        recalculateSize();
    }

    public void addMaidenCrabs(ArrayList<String> crabDescriptions)
    {
        this.crabDescriptions.addAll(crabDescriptions);
    }

    public void addMaidenCrab(String description)
    {
        crabDescriptions.add(description);
    }

    public void addNPCMapping(int index, String name)
    {
        NPCMap.put(index, name);
    }

    public void setNPCMappings(Map<Integer, String> mapping)
    {
        this.NPCMap = mapping;
    }

    public void redraw()
    {
        recalculateSize();
    }

    public void addAttack(PlayerDidAttack attack)
    {
        if(clientThread != null)
        {
            if(config.useUnkitted())
            {
                attack.useUnkitted();
            }
            clientThread.invoke(attack::setIcons);
            clientThread.invoke(attack::setWornNames);
        }
        WeaponAttack weaponAttack = WeaponDecider.getWeapon(attack.animation, attack.spotAnims, attack.projectile, attack.weapon);
        if (weaponAttack != WeaponAttack.UNDECIDED)
        {
            boolean isTarget = RoomUtil.isPrimaryBoss(attack.targetedID) && attack.targetedID != -1;
            String targetString = weaponAttack.name + ": ";
            String targetName = getBossName(attack.targetedID, attack.targetedIndex, attack.tick);
            if (targetName.equals("?"))
            {
                targetString += attack.targetName;
            } else
            {
                targetString += targetName;
            }
            actions.put(attack, targetString);
            String additionalText = "";
            if (targetString.contains("(on w"))
            {
                additionalText = targetString.substring(targetString.indexOf("(on w") + 5);
                additionalText = "s" + additionalText.substring(0, additionalText.indexOf(")"));
            } else if (targetString.contains("small") || targetString.contains("big"))
            {
                additionalText = getShortenedString(targetString, weaponAttack.name.length());
            } else if (targetString.contains("70s") || targetString.contains("50s") || targetString.contains("30s"))
            {
                String shortenedString = targetString.substring(weaponAttack.name.length()+2);
                shortenedString = shortenedString.substring(0, 2);
                String proc = targetString.substring(targetString.indexOf("0s") - 1, targetString.indexOf("0s") + 1);

                additionalText = proc + shortenedString;
            }
            outlineBoxes.add(new OutlineBox(attack, weaponAttack.shorthand, weaponAttack.color, isTarget, additionalText, weaponAttack));
        }
    }

    private static String getShortenedString(String targetString, int index)
    {
        String shortenedString = targetString.substring(index+3);
        shortenedString = shortenedString.substring(0, shortenedString.indexOf(" "));
        if (targetString.contains("east small"))
        {
            shortenedString += "e";
        } else if (targetString.contains("south small"))
        {
            shortenedString += "s";
        } else if (targetString.contains("west small"))
        {
            shortenedString += "w";
        } else if (targetString.contains("east big"))
        {
            shortenedString += "E";
        } else if (targetString.contains("south big"))
        {
            shortenedString += "S";
        } else if (targetString.contains("west big"))
        {
            shortenedString += "W";
        }
        return shortenedString;
    }

    public void addLiveAttack(PlayerDidAttack attack)
    {
        attack.tick += endTick;
        addAttack(new PlayerDidAttack(attack.itemManager, attack.player, attack.animation, attack.tick, attack.weapon, attack.projectile, attack.spotAnims, attack.targetedIndex, attack.targetedID, attack.targetName, attack.wornItems));
    }

    public void addAttacks(ArrayList<PlayerDidAttack> attacks)
    {
        for (PlayerDidAttack attack : attacks)
        {
            addAttack(attack);
        }
    }

    public void incrementTick()
    {
        endTick++;
        if (endTick % 50 == 0 || endTick == 1)
        {
            recalculateSize();
        } else
        {
            drawGraph();
        }
    }

    public void setTick(int tick)
    {
        endTick = tick;
        recalculateSize();
    }

    public void setStartTick(int tick)
    {
        startTick = tick;
        recalculateSize();
    }

    public void recalculateSize()
    {
        if(!shouldDraw())
        {
            return;
        }
        try
        {
            scale = config.chartScaleSize();
            setBackground(config.primaryDark());
        } catch (Exception ignored)
        {

        }
        int length = endTick - startTick;
        boxCount = (length / 50);
        if (boxCount % 50 != 0)
        {
            boxCount++;
        }
        if (boxCount < 1)
        {
            boxCount = 1;
        }
        boxHeight = ((players.size() + 3) * scale);
        boxWidth = (100 + (scale * 51));

        boxesToShow = Math.min(1+((windowHeight-TITLE_BAR_PLUS_TAB_HEIGHT-scale)/boxHeight), boxCount);

        drawGraph();

    }

    public void sendToBottom()
    {
        recalculateSize();
        if(TITLE_BAR_PLUS_TAB_HEIGHT+scale+boxCount*boxHeight > img.getHeight())
        {
            currentBox = boxCount - 1 - boxesToShow + 1;
            int lastBoxEnd = (boxesToShow * boxHeight) + scale + TITLE_BAR_PLUS_TAB_HEIGHT;
            currentScrollOffset = (currentBox * boxHeight) + (lastBoxEnd - img.getHeight());
        }
    }

    private final ClientThread clientThread;
    public ChartPanel(String room, boolean isLive, AdvancedRaidTrackerConfig config, ClientThread clientThread, ConfigManager configManager)
    {
        this.configManager = configManager;
        this.config = config;
        this.clientThread = clientThread;
        scale = 26;
        live = isLive;
        this.room = room;
        startTick = 0;
        endTick = 0;
        shouldWrap = true;
        boxWidth = 100 + scale * 51;
        img = new BufferedImage(boxWidth + 10, 600, BufferedImage.TYPE_INT_ARGB);
        recalculateSize();
        addMouseListener(this);
        addMouseMotionListener(this);
        addMouseWheelListener(this);
    }

    @Override
    protected void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        if (img != null)
        {
            g.drawImage(img, 0, 0, null);
        }
    }

    @Override
    public Dimension getPreferredSize()
    {
        return new Dimension(img.getWidth(), img.getHeight());
    }

    private Rectangle getStringBounds(Graphics2D g2, String str)
    {
        FontRenderContext frc = g2.getFontRenderContext();
        GlyphVector gv = g2.getFont().createGlyphVector(frc, str);
        return gv.getPixelBounds(null, (float) 0, (float) 0);
    }

    private int getStringWidth(Graphics2D g, String str)
    {
        FontRenderContext frc = g.getFontRenderContext();
        GlyphVector gv = g.getFont().createGlyphVector(frc, str);
        return gv.getPixelBounds(null, 0, 0).width;
    }

    int getYOffset(int tick)
    {
        return ((((tick - startTick) / 50) * boxHeight) + 20)-(currentScrollOffset);
    }

    int getXOffset(int tick)
    {
        return (shouldWrap) ? ((tick - startTick) % 50) * scale : tick * scale;
    }

    private void drawTicks(Graphics2D g)
    {
        for (int i = startTick; i < endTick; i++)
        {
            if(shouldTickBeDrawn(i))
            {
                int xOffset = getXOffset(i);
                int yOffset = getYOffset(i);
                yOffset += scale;
                g.setColor(Color.DARK_GRAY);
                g.setColor(new Color(220, 220, 220));
                Font oldFont = g.getFont();
                g.setFont(oldFont.deriveFont(10.0f));
                int strWidth = getStringBounds(g, String.valueOf(i)).width;
                g.drawString(String.valueOf(i), 100 + xOffset + (scale / 2) - (strWidth / 2), yOffset + (fontHeight / 2));
                g.setFont(oldFont);
            }
        }
    }

    private void drawAutos(Graphics2D g)
    {
        for (Integer i : autos)
        {
            if(shouldTickBeDrawn(i))
            {
                g.setColor(new Color(255, 80, 80, 60));
                int xOffset = getXOffset(i);
                int yOffset = getYOffset(i);
                g.fillRoundRect(xOffset + 100, yOffset + 10, scale, boxHeight - scale, 7, 7);
            }
        }
    }

    private void drawGraphBoxes(Graphics2D g)
    {
        for (int i = 0; i < boxesToShow; i++)
        {
            int startX = 100;
            int startY = boxHeight * i + 30 - (currentScrollOffset-(currentBox*boxHeight));
            int endX = boxWidth - scale;
            int endY = startY + boxHeight;
            g.setColor(new Color(100, 100, 100));

            if(startY > 5)
            {
                g.drawLine(startX, startY + scale, endX, startY + scale);
            }
            g.drawLine(startX, (startY > 5) ? startY + scale : scale+5, startX, endY - scale);
            if(endY-scale > 5 + scale)
            {
                g.drawLine(startX, endY - scale, endX, endY - scale);
            }
            g.drawLine(endX, endY - scale, endX, (startY > 5) ? startY + scale : scale+5);
        }
    }

    public static BufferedImage getScaledImage(BufferedImage image, int width, int height)
    {
        int imageWidth  = image.getWidth();
        int imageHeight = image.getHeight();

        double scaleX = (double)width/imageWidth;
        double scaleY = (double)height/imageHeight;
        AffineTransform scaleTransform = AffineTransform.getScaleInstance(scaleX, scaleY);
        AffineTransformOp bilinearScaleOp = new AffineTransformOp(scaleTransform, AffineTransformOp.TYPE_BILINEAR);

        return bilinearScaleOp.filter(
                image,
                new BufferedImage(width, height, image.getType()));
    }

    private void drawYChartColumn(Graphics2D g)
    {
        g.setColor(Color.WHITE);
        for (int i = 0; i < players.size(); i++)
        {
            playerOffsets.put(players.get(i), i);
            for (int j = currentBox; j < boxesToShow+currentBox; j++)
            {
                g.setColor(Color.DARK_GRAY);
                g.setColor(config.primaryLight());
                int nameRectsY = (j*boxHeight)+((i+2)*scale)+10-3-currentScrollOffset;
                if(nameRectsY > scale + 5)
                {
                    g.fillRoundRect(5, nameRectsY, 90, scale - 6, 10, 10);
                }
                g.setColor(Color.WHITE);
                Font oldFont = g.getFont();
                g.setFont(FontManager.getRunescapeBoldFont());
                int width = getStringWidth(g, players.get(i));
                int margin = 5;
                int subBoxWidth = 90;
                int textPosition = margin + (subBoxWidth-width)/2;
                int yPosition = ((j * boxHeight) + ((i + 2) * scale) + (fontHeight) / 2) + (scale/2) + 8-(currentScrollOffset);
                if(yPosition > scale+5)
                {
                    g.drawString(players.get(i), textPosition, yPosition);
                }

                if (i == 0)
                {
                    int textYPosition = j * boxHeight + ((players.size() + 2) * scale) + (fontHeight / 2) + 20 - currentScrollOffset;
                    if(textYPosition > scale + 5)
                    {
                        g.drawString(roomSpecificText, 5, textYPosition);
                    }
                }
                g.setFont(oldFont);
            }
        }

    }

    private void drawRoomSpecificData(Graphics2D g)
    {
        for (Integer i : specific.keySet())
        {
            int xOffset = getXOffset(i);
            int yOffset = getYOffset(i);
            xOffset += 100;
            yOffset += (playerOffsets.size() + 2) * scale - 10 - currentScrollOffset;
            g.setColor(Color.WHITE);
            int strWidth = getStringBounds(g, "X").width;
            if(yOffset > scale + 5)
            {
                g.drawString("X", xOffset + (scale / 2) - (strWidth / 2), yOffset + (fontHeight / 2) + 10);
            }
        }
    }

    private void drawDawnSpecs(Graphics2D g)
    {
        for (DawnSpec dawnSpec : dawnSpecs)
        {
            String damage = String.valueOf(dawnSpec.getDamage());
            if (dawnSpec.getDamage() != -1)
            {
                int xOffset = (shouldWrap) ? ((dawnSpec.tick - startTick - 2) % 50) * scale : (dawnSpec.tick + 2) * scale;
                int yOffset = getYOffset(dawnSpec.tick);
                xOffset += 100;
                yOffset += (playerOffsets.size() + 3) * scale - 10;
                g.setColor(Color.WHITE);
                int textOffset = (scale / 2) - (getStringBounds(g, damage).width) / 2;
                if(yOffset > scale + 5)
                {
                    g.drawString(damage, xOffset + textOffset, yOffset + (fontHeight / 2) + 10);
                }
            }
        }
    }

    public static BufferedImage createDropShadow(BufferedImage image)
    {
        BufferedImage shadow = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);

        Graphics2D g2 = shadow.createGraphics();
        g2.drawImage(image, 0, 0, null);

        g2.setComposite(AlphaComposite.SrcIn);
        g2.setColor(new Color(0, 0, 0, 128));
        g2.fillRect(0, 0, shadow.getWidth(), shadow.getHeight());

        g2.dispose();
        return shadow;
    }

    private void drawPrimaryBoxes(Graphics2D g)
    {
        for (OutlineBox box : outlineBoxes)
        {
            if (shouldTickBeDrawn(box.tick))
            {
                int xOffset = 100 + ((shouldWrap) ? ((box.tick - startTick) % 50) * scale : box.tick * scale);
                if(playerOffsets.get(box.player) == null)
                {
                    continue;
                }
                int yOffset = ((playerOffsets.get(box.player) + 1) * scale + 30) + (((shouldWrap) ? ((box.tick - startTick) / 50) * boxHeight : 30)-currentScrollOffset);
                if(yOffset > scale + 5)
                {
                    if (config != null && config.useIconsOnChart())
                    {
                        try
                        {
                            if (box.weaponAttack.attackTicks != -1)
                            {
                                int opacity = config.iconBackgroundOpacity();
                                opacity = Math.min(255, opacity);
                                opacity = Math.max(0, opacity);
                                g.setColor(new Color(box.color.getRed(), box.color.getGreen(), box.color.getBlue(), opacity));
                                g.fillRoundRect(xOffset + 2, yOffset + 2, scale - 3, scale - 3, 5, 5);
                                BufferedImage scaled = getScaledImage(box.attack.img, scale - 2, scale - 2);
                                g.drawImage(createDropShadow(scaled), xOffset + 3, yOffset + 3, null);
                                g.drawImage(scaled, xOffset + 2, yOffset + 1, null);
                            }
                        } catch (Exception ignored)
                        {

                        }
                    } else
                    {
                        int opacity = 100;
                        if (config != null)
                        {
                            opacity = config.letterBackgroundOpacity();
                            opacity = Math.min(255, opacity);
                            opacity = Math.max(0, opacity);
                        }
                        g.setColor(new Color(box.color.getRed(), box.color.getGreen(), box.color.getBlue(), opacity));
                        g.fillRoundRect(xOffset + 2, yOffset + 2, scale - 3, scale - 3, 5, 5);
                        g.setColor((box.primaryTarget) ? Color.WHITE : new Color(0, 190, 255));
                        int textOffset = (scale / 2) - (getStringWidth(g, box.letter) / 2);
                        int primaryOffset = yOffset + (box.additionalText.isEmpty() ? (fontHeight / 2) : 0);
                        g.drawString(box.letter, xOffset + textOffset - 1, primaryOffset + (scale / 2) + 1);
                        if (!box.additionalText.isEmpty())
                        {
                            Font f = g.getFont();
                            g.setFont(f.deriveFont(10.0f));
                            textOffset = (scale / 2) - (getStringWidth(g, box.additionalText) / 2);
                            g.setColor(Color.WHITE);
                            g.drawString(box.additionalText, xOffset + textOffset, yOffset + scale - 3);
                            g.setFont(f);
                        }
                    }
                    box.createOutline();
                    g.setColor(box.outlineColor);
                    g.drawRoundRect(xOffset + 1, yOffset + 1, scale - 2, scale - 2, 5, 5);
                }
            }
        }
    }

    private void drawMarkerLines(Graphics2D g)
    {
        if (!live || finished)
        {
            for (Integer i : lines.keySet())
            {
                if(shouldTickBeDrawn(i))
                {
                    int xOffset = getXOffset(i);
                    int yOffset = getYOffset(i);
                    xOffset += 100;
                    yOffset += (scale / 2);
                    g.setColor(new Color(255, 0, 0));
                    g.drawLine(xOffset, Math.max(yOffset, scale + 5), xOffset, yOffset + boxHeight - 20);
                    int stringLength = getStringBounds(g, lines.get(i)).width;
                    g.setColor(Color.WHITE);
                    if(yOffset > scale + 5 )
                    {
                    g.drawString(lines.get(i), xOffset - (stringLength / 2), yOffset - 1);
                    }
                }
            }
        }
    }

    private void drawThrallBoxes(Graphics2D g)
    {
        for (ThrallOutlineBox box : thrallOutlineBoxes)
        {
            g.setColor(new Color(box.getColor().getRed(), box.getColor().getGreen(), box.getColor().getBlue(), 30));

            int maxTick = getMaxTick(box);
            int lastEndTick = box.spawnTick;
            while (lastEndTick < maxTick && shouldTickBeDrawn(lastEndTick))
            {
                    int yOffset = getYOffset(lastEndTick);
                    try
                    {
                        yOffset += (playerOffsets.get(box.owner) + 1) * scale + 10;
                    } catch (Exception e)
                    {
                        break;
                    }
                    int currentEndTick = (shouldWrap) ? lastEndTick + (50 - (lastEndTick % 50) + (startTick % 50)) : maxTick;
                    if (currentEndTick > maxTick)
                    {
                        currentEndTick = maxTick;
                    }
                    int xOffsetStart = (shouldWrap) ? ((lastEndTick - startTick) % 50) * scale : (lastEndTick - 1) * scale;
                    xOffsetStart += 100;
                    int xOffsetEnd = (shouldWrap) ? ((currentEndTick - startTick - 1) % 50) * scale : (currentEndTick - 1) * scale;
                    xOffsetEnd += 100;
                    lastEndTick = currentEndTick;
                    if(yOffset > scale + 5)
                    {
                        g.fillRect(xOffsetStart, yOffset + 1, xOffsetEnd - xOffsetStart + scale, scale - 2);
                    }
            }
        }
    }

    private int getMaxTick(ThrallOutlineBox box)
    {
        int maxTick = box.spawnTick + 99;
        for (ThrallOutlineBox boxCompare : thrallOutlineBoxes)
        {
            if (box.owner.equalsIgnoreCase(boxCompare.owner))
            {
                if (boxCompare.spawnTick > box.spawnTick && boxCompare.spawnTick < (box.spawnTick + 99))
                {
                    maxTick = boxCompare.spawnTick;
                }
            }
        }
        if (endTick < maxTick)
        {
            maxTick = endTick;
        }
        return maxTick;
    }

    private void drawSelectedOutlineBox(Graphics2D g)
    {
        if (selectedTick != -1 && !selectedPlayer.equalsIgnoreCase(""))
        {
            g.setColor(new Color(255, 255, 255));
            int xOffset = 100 + ((shouldWrap) ? ((selectedTick - startTick) % 50) * scale : selectedTick * scale);
            int yOffset = ((playerOffsets.get(selectedPlayer) + 1) * scale + 30) + (((shouldWrap) ? ((selectedTick - startTick) / 50) * boxHeight : 30)-currentScrollOffset);
            if(yOffset > scale + 5)
            {
                g.drawRect(xOffset, yOffset, scale, scale);
            }
        }
    }

    private Point getPoint(int tick, String player)
    {
        return new Point(
                100 + ((shouldWrap) ? ((tick - startTick) % 50) * scale : tick * scale),
                ((playerOffsets.get(player) + 1) * scale + 10) + (((shouldWrap) ? ((tick - startTick) / 50) * boxHeight : 0)-currentScrollOffset));
    }

    private void drawSelectedRow(Graphics2D g)
    {
        if (selectedRow != -1)
        {
            g.setColor(new Color(255, 255, 255));
            int xOffset = 100 + getXOffset(selectedRow);
            int yOffset = 10 + getYOffset(selectedRow);
            g.drawRect(xOffset, yOffset, scale, scale * (players.size() + 2));

            int selectedTickHP = -1;
            try
            {
                selectedTickHP = roomHP.get(selectedRow + 1);
            } catch (Exception ignored)
            {

            }
            int offset = -1;
            switch (room)
            {
                case "Maiden":
                case "Verzik P3":
                    offset = 7;
                    break;
                case "Bloat":
                case "Sotetseg":
                case "Xarpus":
                    offset = 3;
                    break;
                case "Nylocas":
                    offset = 5;
                    offset += (4 - ((offset + selectedRow) % 4));
                    offset -= 2;
                    break;
            }
            String bossWouldHaveDied = (offset != -1) ? "Melee attack on this tick killing would result in: " + RoomUtil.time(selectedRow + 1 + offset + 1) + " (Quick death: " + RoomUtil.time(selectedRow + offset + 1) + ")" : "";
            String HPString = "Boss HP: " + ((selectedTickHP == -1) ? "-" : RoomUtil.varbitHPtoReadable(selectedTickHP));
            HoverBox hoverBox = new HoverBox(HPString, config);
            if (offset != -1)
            {
                hoverBox.addString(bossWouldHaveDied);
            }
            int xPosition = xOffset+scale;
            if(xPosition+hoverBox.getWidth(g) > img.getWidth())
            {
                xPosition = xPosition-hoverBox.getWidth(g)-3*scale;
            }
            hoverBox.setPosition(xPosition, yOffset);
            hoverBox.draw(g);
        }
    }


    private void drawHoverBox(Graphics2D g)
    {
        for (PlayerDidAttack action : actions.keySet())
        {
            if (action.tick == selectedTick && action.player.equals(selectedPlayer))
            {
                if(shouldTickBeDrawn(action.tick))
                {
                    Point location = getPoint(action.tick, action.player);
                    HoverBox hoverBox = new HoverBox(actions.get(action), config);
                    hoverBox.addString("");
                    for (String item : action.wornItemNames)
                    {
                        hoverBox.addString("." + item);
                    }
                    int xPosition = location.getX() + 10;
                    if (xPosition + hoverBox.getWidth(g) > img.getWidth())
                    {
                        xPosition = xPosition - hoverBox.getWidth(g) - scale * 2;
                    }
                    hoverBox.setPosition(xPosition, location.getY() - 10);
                    hoverBox.draw(g);
                }
            }
        }
    }

    private void drawMaidenCrabs(Graphics2D g)
    {
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        g.setColor(new Color(230, 20, 20, 200));
        if (room.equals("Maiden"))
        {
            for (Integer tick : lines.keySet())
            {
                if(lines.get(tick).equals("Dead"))
                {
                    continue;
                }
                String proc = lines.get(tick);
                int xOffset = 100 + getXOffset(tick + 1);
                int yOffset = 10 + getYOffset(tick + 1);
                if(yOffset > scale + 5)
                {
                    continue;
                }
                yOffset -= scale;
                int crabOffsetX = 0;
                int crabOffsetY;

                crabOffsetY = 11;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetY = 20;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetX = 9;
                crabOffsetY = 11;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetY = 20;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetX = 18;
                crabOffsetY = 11;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetY = 20;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetX = 27;
                crabOffsetY = 2;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetY = 20;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetY = 11;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);

                crabOffsetY = 29;
                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);


                for (String crab : crabDescriptions)
                {
                    if (crab.contains(proc))
                    {
                        xOffset = 100 + getXOffset(tick + 1);
                        yOffset = 10 + getYOffset(tick + 1);
                        crabOffsetX = 0;
                        crabOffsetY = 0;
                        if (crab.contains("N1"))
                        {
                            crabOffsetY = 11;
                        } else if (crab.contains("S1"))
                        {
                            crabOffsetY = 20;
                        } else if (crab.contains("N2"))
                        {
                            crabOffsetX = 9;
                            crabOffsetY = 11;
                        } else if (crab.contains("S2"))
                        {
                            crabOffsetX = 9;
                            crabOffsetY = 20;
                        } else if (crab.contains("N3"))
                        {
                            crabOffsetX = 18;
                            crabOffsetY = 11;
                        } else if (crab.contains("S3"))
                        {
                            crabOffsetX = 18;
                            crabOffsetY = 20;
                        } else if (crab.contains("N4 (1)"))
                        {
                            crabOffsetX = 27;
                            crabOffsetY = 2;
                        } else if (crab.contains("S4 (1)"))
                        {
                            crabOffsetX = 27;
                            crabOffsetY = 20;
                        } else if (crab.contains("N4 (2)"))
                        {
                            crabOffsetX = 27;
                            crabOffsetY = 11;
                        } else if (crab.contains("S4 (2)"))
                        {
                            crabOffsetX = 27;
                            crabOffsetY = 29;
                        }
                        crabOffsetY -= scale;
                        g.setColor(new Color(230, 20, 20, 200));
                        g.fillOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);
                    }
                }
            }
        }
    }

    private void drawRoomTime(Graphics2D g)
    {
        g.setColor(Color.WHITE);
        Font oldFont = g.getFont();
        g.setFont(FontManager.getRunescapeBoldFont());
        g.drawString("Time " + RoomUtil.time(endTick), 5, 20);
        g.setFont(oldFont);
    }

    private void drawCheckBox(Graphics2D g)
    {
        g.setColor(Color.WHITE);
        Font oldFont = g.getFont();
        g.setFont(FontManager.getRunescapeBoldFont());
        g.drawString("Use Icons? ", 100, 20);
        if(!checkBoxHovered)
        {
            g.setColor(new Color(140, 140, 140));
        }

        g.drawRect(180, 2, 20, 20);
        if(checkBoxHovered)
        {
            g.setColor(new Color(140, 140, 140));
            g.fillRect(181, 3, 19, 19);
        }
        g.setColor(Color.WHITE);
        if(config.useIconsOnChart())
        {
            g.drawString("x", 186, 17);
        }
        g.setFont(oldFont);
    }

    private void drawBaseBoxes(Graphics2D g)
    {
        for(int i = startTick; i < endTick; i++)
        {
            if(shouldTickBeDrawn(i))
            {
                for (int j = 0; j < playerOffsets.size(); j++)
                {
                    int xOffset = 100 + ((shouldWrap) ? ((i - startTick) % 50) * scale : i * scale);
                    if (playerOffsets.get(players.get(j)) == null)
                    {
                        continue;
                    }
                    shouldWrap = true;
                    int yOffset = ((playerOffsets.get(players.get(j)) + 1) * scale + 30) + ((((i - startTick) / 50) * boxHeight)-currentScrollOffset);
                    g.setColor(config.primaryMiddle());
                    if(yOffset > scale + 5)
                    {
                        g.fillRoundRect(xOffset + 2, yOffset + 2, scale - 3, scale - 3, 5, 5);
                    }
                }
            }
        }
    }

    private void drawGraph()
    {
        if(!shouldDraw())
        {
            return;
        }
        Graphics2D g = (Graphics2D) img.getGraphics();
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        RenderingHints qualityHints = new RenderingHints(
                RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON );
        qualityHints.put(
                RenderingHints.KEY_RENDERING,
                RenderingHints.VALUE_RENDER_QUALITY );
        g.setRenderingHints( qualityHints);
        Color oldColor = g.getColor();

        g.setColor(config.primaryDark());
        g.fillRect(0, 0, img.getWidth(), img.getHeight());


        fontHeight = getStringBounds(g, "a").height;
        g.setColor(Color.WHITE);

        drawTicks(g);
        drawGraphBoxes(g);
        drawBaseBoxes(g);
        drawYChartColumn(g);
        drawRoomSpecificData(g);
        drawDawnSpecs(g);
        drawPrimaryBoxes(g);
        drawAutos(g);
        drawMarkerLines(g);
        drawThrallBoxes(g);
        drawMaidenCrabs(g);
        drawSelectedOutlineBox(g);
        drawSelectedRow(g);
        drawHoverBox(g);
        drawRoomTime(g);
        drawCheckBox(g);

        g.setColor(oldColor);
        g.dispose();
        repaint();
    }

    public boolean shouldTickBeDrawn(int tick)
    {
        return tick >= (startTick + currentBox*50) && tick < (startTick + ((currentBox+boxesToShow)*50));
    }

    public void getTickHovered(int x, int y)
    {
        y = y + currentScrollOffset;
        if (y > 20)
        {
            int boxNumber = (y - 20) / boxHeight;
            if (x > 100)
            {
                int tick = startTick + (50 * boxNumber + ((x - 100) / scale));
                int playerOffsetPosition = (((y - 30 - scale) % boxHeight) / scale);
                if (playerOffsetPosition >= 0 && playerOffsetPosition < players.size() && (y - 30 - scale > 0))
                {
                    selectedTick = tick;
                    selectedPlayer = players.get(playerOffsetPosition);
                    selectedRow = -1;
                } else if (y % boxHeight < 30 + scale)
                {
                    selectedRow = tick;
                    selectedPlayer = "";
                    selectedTick = -1;
                } else
                {
                    selectedPlayer = "";
                    selectedTick = -1;
                    selectedRow = -1;
                }
            } else
            {
                selectedPlayer = "";
                selectedTick = -1;
                selectedRow = -1;
            }
            drawGraph();
        }
    }

    @Override
    public void mouseClicked(MouseEvent e)
    {
        if(checkBoxHovered)
        {
            configManager.setConfiguration("Advanced Raid Tracker", "useIconsOnChart", !config.useIconsOnChart());
            drawGraph();
        }
    }

    @Override
    public void mousePressed(MouseEvent e)
    {

    }


    @Override
    public void mouseReleased(MouseEvent e)
    {
    }

    @Override
    public void mouseEntered(MouseEvent e)
    {
    }

    @Override
    public void mouseExited(MouseEvent e)
    {
        selectedPlayer = "";
        selectedTick = -1;
        selectedRow = -1;
        drawGraph();
    }

    @Override
    public void mouseDragged(MouseEvent e)
    {
    }

    @Override
    public void mouseMoved(MouseEvent e)
    {
        checkBoxHovered = e.getX() >= 180 && e.getX() <= 200 && e.getY() >= 2 && e.getY() <= 22;
        getTickHovered(e.getX(), e.getY());
        drawGraph();
    }

    public String getBossName(int id, int index, int tick)
    {
        try
        {
            switch (id)
            {
                case TobIDs.MAIDEN_P0:
                case TobIDs.MAIDEN_P1:
                case TobIDs.MAIDEN_P2:
                case TobIDs.MAIDEN_P3:
                case TobIDs.MAIDEN_PRE_DEAD:
                case TobIDs.MAIDEN_P0_HM:
                case TobIDs.MAIDEN_P1_HM:
                case TobIDs.MAIDEN_P2_HM:
                case TobIDs.MAIDEN_P3_HM:
                case TobIDs.MAIDEN_PRE_DEAD_HM:
                case TobIDs.MAIDEN_P0_SM:
                case TobIDs.MAIDEN_P1_SM:
                case TobIDs.MAIDEN_P2_SM:
                case TobIDs.MAIDEN_P3_SM:
                case TobIDs.MAIDEN_PRE_DEAD_SM:
                    return "Maiden (" + RoomUtil.varbitHPtoReadable(roomHP.get(tick + 1)) + ")";
                case TobIDs.BLOAT:
                case TobIDs.BLOAT_HM:
                case TobIDs.BLOAT_SM:
                    return "Bloat (" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + ")";
                case TobIDs.NYLO_BOSS_MELEE:
                case TobIDs.NYLO_BOSS_RANGE:
                case TobIDs.NYLO_BOSS_MAGE:
                case TobIDs.NYLO_BOSS_MELEE_HM:
                case TobIDs.NYLO_BOSS_RANGE_HM:
                case TobIDs.NYLO_BOSS_MAGE_HM:
                case TobIDs.NYLO_BOSS_MELEE_SM:
                case TobIDs.NYLO_BOSS_RANGE_SM:
                case TobIDs.NYLO_BOSS_MAGE_SM:
                    return "Nylo Boss (" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + ")";
                case TobIDs.XARPUS_P23:
                case TobIDs.XARPUS_P23_HM:
                case TobIDs.XARPUS_P23_SM:
                    return "Xarpus (" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + ")";
                case TobIDs.VERZIK_P1:
                case TobIDs.VERZIK_P2:
                case TobIDs.VERZIK_P3:
                case TobIDs.VERZIK_P1_HM:
                case TobIDs.VERZIK_P2_HM:
                case TobIDs.VERZIK_P3_HM:
                case TobIDs.VERZIK_P1_SM:
                case TobIDs.VERZIK_P2_SM:
                case TobIDs.VERZIK_P3_SM:
                    return "Verzik (" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + ")";
            }
            for (Integer i : NPCMap.keySet())
            {
                if (i == index)
                {
                    String hp = "-1";
                    try
                    {
                        hp = RoomUtil.varbitHPtoReadable(roomHP.get(tick));
                    } catch (Exception ignored
                    )
                    {
                    }
                    return NPCMap.get(i) + " (Boss: " + hp + ")";
                }
            }
            return "?";
        } catch (Exception e)
        {
            return "?";
        }
    }
    private int currentBox = 0;
    private int currentScrollOffset = 0;
    @Override
    public void mouseWheelMoved(MouseWheelEvent e) //manually implement scrolling
    {
        if(e.getWheelRotation() < 0) //top of the first box aligns to top if you scroll up
        {
            currentBox = Math.max(0, currentBox-1);
            currentScrollOffset = currentBox*boxHeight;
        }
        else //bottom of the bottom box aligns to the bottom if you scroll down
        {
            if(TITLE_BAR_PLUS_TAB_HEIGHT+scale+boxCount*boxHeight > img.getHeight()) //no need to scroll at all if all boxes fit on screen, boxes would jump to bottom and leave dead space
            {
                int lastBox = currentBox + boxesToShow - 1;
                lastBox = Math.min(lastBox + 1, boxCount - 1);
                currentBox = lastBox - boxesToShow + 1;
                int lastBoxEnd = (boxesToShow * boxHeight) + scale + TITLE_BAR_PLUS_TAB_HEIGHT;
                currentScrollOffset = (currentBox * boxHeight) + (lastBoxEnd - img.getHeight());
            }
        }
        recalculateSize();
    }
}

package com.advancedraidtracker.ui.charts;

import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.utility.wrappers.PlayerDidAttack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;

@Slf4j
public class LiveChart extends BaseFrame
{
    public JTabbedPane tabbedPane;

    private final AdvancedRaidTrackerConfig config;
    private final ClientThread clientThread;
    private final ConfigManager configManager;
    Map<String, ChartPanel> tobPanels;


    private final String[] names = {"Maiden", "Bloat", "Nylocas", "Sotetseg", "Xarpus", "Verzik"};
    public LiveChart(AdvancedRaidTrackerConfig config, ClientThread clientThread, ConfigManager configManager)
    {
        this.configManager = configManager;
        this.clientThread = clientThread;
        this.config = config;
        tobPanels = new LinkedHashMap<>();
        for(String name : names)
        {
            tobPanels.put(name, new ChartPanel(name, true, config, clientThread, configManager));
        }

        tabbedPane = new JTabbedPane();
        tabbedPane.addChangeListener(cl->
        {
            String activePanel = names[tabbedPane.getSelectedIndex()];
            for(String panelNames : names)
            {
                if(activePanel.equals(panelNames) && this.isShowing())
                {
                    getPanel(panelNames).setActive(true);
                    getPanel(panelNames).redraw();
                }
                else
                {
                    getPanel(panelNames).setActive(false);
                }
            }
        });
        for(String panelName : tobPanels.keySet())
        {
            tabbedPane.add(panelName, tobPanels.get(panelName));
        }
        addWindowListener(new WindowAdapter()
        {
            @Override
            public void windowClosing(WindowEvent e)
            {
                super.windowClosing(e);
                for(String panelNames : names)
                {
                    getPanel(panelNames).setActive(false);
                }
            }

            @Override
            public void windowOpened(WindowEvent e)
            {
                super.windowOpened(e);
                String activePanel = names[tabbedPane.getSelectedIndex()];
                getPanel(activePanel).setActive(true);
                getPanel(activePanel).redraw();
                pack();
            }
        });

        addComponentListener(new ComponentAdapter()
        {
            @Override
            public void componentResized(ComponentEvent e)
            {
                super.componentResized(e);
                Component c = (Component) e.getSource();
                for(ChartPanel p : tobPanels.values())
                {
                    p.setSize(c.getWidth(), c.getHeight());
                }
            }
        });


        add(tabbedPane);
        pack();
    }

    @Override
    public void close()
    {
        super.close();
    }

    public ChartPanel getPanel(String room)
    {
		if(tobPanels.containsKey(room)) //do not use getOrDefault because it will allocate a BufferedImage every call even if the map does contain the key value
		{
			return tobPanels.get(room);
		}
		else
		{
			return new ChartPanel("", true, config, clientThread, configManager);
		}
    }

    public void incrementTick(String room)
    {
        getPanel(room).incrementTick();
        if (getPanel(room).endTick % 50 == 0)
        {
            for(ChartPanel panel : tobPanels.values())
            {
                panel.sendToBottom();
            }
        }
    }


    public void addAttack(PlayerDidAttack attack, String room)
    {
        getPanel(room).addLiveAttack(attack);
    }

    public void addMaidenLine(int value, String description)
    {
        tobPanels.get("Maiden").addLine(value, description);
    }

    public void addBloatLine(int value, String description)
    {
        tobPanels.get("Bloat").addLine(value, description);
    }

    public void addNyloLine(int value, String description)
    {
        tobPanels.get("Nylocas").addLine(value, description);
    }

    public void addSoteLine(int value, String description)
    {
        tobPanels.get("Sotetseg").addLine(value, description);
    }

    public void addXarpLine(int value, String description)
    {
        tobPanels.get("Xarpus").addLine(value, description);
    }

    public void addVerzikLine(int value, String description)
    {
        tobPanels.get("Verzik").addLine(value, description);
    }

    public void setMaidenFinished(int tick)
    {
        tobPanels.get("Maiden").setRoomFinished(tick);
    }

    public void setBloatFinished(int tick)
    {
        tobPanels.get("Bloat").setRoomFinished(tick);
    }

    public void setNyloFinished(int tick)
    {
        tobPanels.get("Nylocas").setRoomFinished(tick);
    }

    public void setSoteFinished(int tick)
    {
        tobPanels.get("Sotetseg").setRoomFinished(tick);
    }

    public void setXarpFinished(int tick)
    {
        tobPanels.get("Xarpus").setRoomFinished(tick);
    }

    public void setVerzFinished(int tick)
    {
        tobPanels.get("Verzik").setRoomFinished(tick);
    }

    public void resetAll()
    {
        for(ChartPanel panel : tobPanels.values())
        {
            panel.resetGraph();
        }
    }

    public void redrawAll()
    {
        for(ChartPanel panel : tobPanels.values())
        {
            panel.redraw();
        }
    }

    public void setPlayers(ArrayList<String> players)
    {
        ArrayList<String> cleanedPlayers = new ArrayList<>();
        for (String s : players)
        {
            cleanedPlayers.add(s.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)));
        }
        for(ChartPanel panel : tobPanels.values())
        {
            panel.setPlayers(cleanedPlayers);
        }
    }
}

package com.advancedraidtracker.ui.charts;

import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.utility.ItemReference;
import com.advancedraidtracker.utility.Point;
import net.runelite.client.ui.FontManager;
import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.util.ArrayList;

import static com.advancedraidtracker.utility.ItemReference.*;

public class HoverBox
{
    ArrayList<String> info;
    Point location = new Point(0,0);
    private final AdvancedRaidTrackerConfig config;
    public HoverBox(String s, AdvancedRaidTrackerConfig config)
    {
        this.config = config;
        info = new ArrayList<>();
        addString(s);
    }

    public void addString(String s)
    {
        info.add(s);
        if(s.toLowerCase().startsWith(".weapon"))
        {
            setStyle(s);
        }
    }

    public void setPosition(int x, int y)
    {
        location = new Point(x+config.chartScaleSize(), y);
    }

    int style = NONE;

    private void setStyle(String weapon)
    {
        if(anyMatch(weapon, ItemReference.ITEMS[MELEE]))
        {
            style = MELEE;
        }
        else if(anyMatch(weapon, ItemReference.ITEMS[RANGE]))
        {
            style = RANGE;
        }
        else if(anyMatch(weapon, ItemReference.ITEMS[MAGE]))
        {
            style = MAGE;
        }
    }
    private boolean anyMatch(String item, String[] items)
    {
        for(String s : items)
        {
            if(item.toLowerCase().contains(s))
            {
                return true;
            }
        }
        return false;
    }

    public int getWidth(Graphics2D g)
    {
        Font oldFont = g.getFont();
        g.setFont(FontManager.getRunescapeBoldFont());
        int longestString = 0;
        for(String s : info)
        {
            int stringLength = getStringWidth(g, s);
            if (stringLength > longestString)
            {
                longestString = stringLength;
            }
        }
        g.setFont(oldFont);
        return longestString+10;
    }

    public void draw(Graphics2D g)
    {
        Font oldFont = g.getFont();
        g.setFont(FontManager.getRunescapeBoldFont());
        int fontHeight = getStringBounds(g).height;
        g.setColor(config.primaryDark());
        int boxHeight = 10 + (fontHeight+7)*info.size();
        g.fillRoundRect(location.getX(), location.getY(), getWidth(g), boxHeight, 10, 10);
        g.setColor(new Color(200, 200, 200));
        g.drawRoundRect(location.getX(), location.getY(), getWidth(g), boxHeight, 10, 10);

        for(int i = 0; i < info.size(); i++)
        {
            String label = info.get(i);
            if(label.startsWith(".") && label.length() > 1)
            {
                label = label.substring(1);
                if(anyMatch(label, ItemReference.ITEMS[style]))
                {
                    g.setColor(new Color(60, 190, 60));
                }
                else if(anyMatch(label, ItemReference.ITEMS[0]))
                {
                    g.setColor(new Color(120, 120, 120));
                }
                else
                {
                    g.setColor(new Color(190, 30, 30));
                }
            }
            g.drawString(label, location.getX()+5, location.getY() + 5 + (fontHeight+7)*(i+1));
        }
        g.setFont(oldFont);
    }

    private int getStringWidth(Graphics2D g, String str)
    {
        FontRenderContext frc = g.getFontRenderContext();
        GlyphVector gv = g.getFont().createGlyphVector(frc, str);
        return gv.getPixelBounds(null, 0, 0).width;
    }

    private Rectangle getStringBounds(Graphics2D g2)
    {
        FontRenderContext frc = g2.getFontRenderContext();
        GlyphVector gv = g2.getFont().createGlyphVector(frc, "a");
        return gv.getPixelBounds(null, (float) 0, (float) 0);
    }
}

package com.advancedraidtracker.ui.charts;

import com.advancedraidtracker.AdvancedTOBData;
import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.utility.datautility.DataPoint;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import javax.swing.*;
import javax.swing.Timer;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.util.*;

@Slf4j
public class ChartFrame extends BaseFrame
{
    private int frameX = this.getWidth();
    private int frameY = this.getHeight();
    public ChartFrame(ArrayList<SimpleTOBData> roomData, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)
    {
        JTabbedPane basepane = new JTabbedPane();

        JPanel maidenTab = new JPanel();
        JPanel bloatTab = new JPanel();
        JPanel nyloTab = new JPanel();
        JPanel soteTab = new JPanel();
        JPanel xarpTab = new JPanel();
        JPanel verzP1Tab = new JPanel();
        JPanel verzP2Tab = new JPanel();
        JPanel verzP3Tab = new JPanel();

        maidenTab.setLayout(new GridLayout(1, 2));
        bloatTab.setLayout(new GridLayout(1, 2));
        nyloTab.setLayout(new GridLayout(1, 2));
        soteTab.setLayout(new GridLayout(1, 2));
        xarpTab.setLayout(new GridLayout(1, 2));
        verzP1Tab.setLayout(new GridLayout(1, 2));
        verzP2Tab.setLayout(new GridLayout(1, 2));
        verzP3Tab.setLayout(new GridLayout(1, 2));

        JPanel maidenCharts = new JPanel();
        JPanel bloatCharts = new JPanel();
        JPanel nyloCharts = new JPanel();
        JPanel soteCharts = new JPanel();
        JPanel xarpCharts = new JPanel();
        JPanel verzp1Charts = new JPanel();
        JPanel verzp2Charts = new JPanel();
        JPanel verzp3Charts = new JPanel();

        maidenCharts.setLayout(new BoxLayout(maidenCharts, BoxLayout.Y_AXIS));
        bloatCharts.setLayout(new BoxLayout(bloatCharts, BoxLayout.Y_AXIS));
        nyloCharts.setLayout(new BoxLayout(nyloCharts, BoxLayout.Y_AXIS));
        soteCharts.setLayout(new BoxLayout(soteCharts, BoxLayout.Y_AXIS));
        xarpCharts.setLayout(new BoxLayout(xarpCharts, BoxLayout.Y_AXIS));
        verzp1Charts.setLayout(new BoxLayout(verzp1Charts, BoxLayout.Y_AXIS));
        verzp2Charts.setLayout(new BoxLayout(verzp2Charts, BoxLayout.Y_AXIS));
        verzp3Charts.setLayout(new BoxLayout(verzp3Charts, BoxLayout.Y_AXIS));



        for (SimpleTOBData data : roomData)
        {
            AdvancedTOBData advancedData = new AdvancedTOBData(AdvancedTOBData.getRaidStrings(data.filePath), itemManager);
            Map<Integer, String> maidenLines = new LinkedHashMap<>();
            maidenLines.put(data.getValue(DataPoint.MAIDEN_70_SPLIT), "70s");
            maidenLines.put(data.getValue(DataPoint.MAIDEN_50_SPLIT), "50s");
            maidenLines.put(data.getValue(DataPoint.MAIDEN_30_SPLIT), "30s");
            maidenLines.put(data.getValue(DataPoint.MAIDEN_TOTAL_TIME), "Dead");

            Map<Integer, String> bloatLines = new LinkedHashMap<>();
            for (Integer i : data.bloatDowns)
            {
                bloatLines.put(i, "Down");
                bloatLines.put(i + 33, "Moving");
            }

            Map<Integer, String> nyloLines = new LinkedHashMap<>();
            for (Integer i : data.nyloWaveStalled)
            {
                nyloLines.put(i, "Stall");
            }
            nyloLines.put(data.getValue(DataPoint.NYLO_LAST_WAVE), "Last Wave");
            nyloLines.put(data.getValue(DataPoint.NYLO_BOSS_SPAWN), "Boss Spawn");
            for (int i = data.getValue(DataPoint.NYLO_BOSS_SPAWN) + 11; i < data.getNyloTime(); i += 10)
            {
                nyloLines.put(i, "Phase");
            }

            for (Integer i : data.waveSpawns.keySet())
            {
                nyloLines.put(data.waveSpawns.get(i), "W" + i);
            }

            Map<Integer, String> soteLines = new LinkedHashMap<>();
            soteLines.put(data.getValue(DataPoint.SOTE_P1_SPLIT), "Maze1 Start");
            soteLines.put(data.getValue(DataPoint.SOTE_M1_SPLIT), "Maze1 End");

            soteLines.put(data.getValue(DataPoint.SOTE_P2_SPLIT), "Maze2 Start");
            soteLines.put(data.getValue(DataPoint.SOTE_M2_SPLIT), "Maze2 End");


            Map<Integer, String> xarpLines = new LinkedHashMap<>();
            xarpLines.put(data.getValue(DataPoint.XARP_SCREECH), "SCREECH");
            for (int i = data.getValue(DataPoint.XARP_SCREECH) + 8; i < data.getXarpTime(); i += 8)
            {
                xarpLines.put(i, "Turn");
            }

            Map<Integer, String> verzikP2Lines = new LinkedHashMap<>();
            for (Integer i : data.redsProc)
            {
                verzikP2Lines.put(i, "Reds");
                verzikP2Lines.put(i + 10, "Shield End");
            }

            for (Integer i : data.p2Crabs)
            {
                verzikP2Lines.put(i, "Crabs");
            }

            Map<Integer, String> verzikP3Lines = new LinkedHashMap<>();
            for (Integer i : data.websStart)
            {
                if (i % 2 == 0)
                    verzikP3Lines.put(i, "Webs");
            }

            for (Integer i : data.p3Crabs)
            {
                verzikP3Lines.put(i, "Crabs");
            }

            Map<Integer, String> dawnDropsMap = new LinkedHashMap<>();
            for (Integer i : data.dawnDrops)
            {
                dawnDropsMap.put(i, "X");
            }
            ArrayList<Integer> p2autos = new ArrayList<>();
            int lastreset = data.getValue(DataPoint.VERZIK_P1_SPLIT) + 11;
            for (int i = lastreset; i < data.getValue(DataPoint.VERZIK_P2_SPLIT); i++)
            {
                boolean wasNextTick = false;
                for (Integer j : data.redsProc)
                {
                    if (i == j)
                    {
                        lastreset = i + 11;
                    } else if (i == (j - 5) || i == (j - 1))
                    {
                        wasNextTick = true;
                    }
                }
                if ((i - lastreset) % 4 == 0 && i >= lastreset && !wasNextTick)
                {
                    p2autos.add(i);
                }
            }
            int maidenTime = data.getMaidenTime();
            int bloatTime = data.getBloatTime();
            int nyloTime = data.getNyloTime();
            int soteTime = data.getSoteTime();
            int xarpTime = data.getXarpTime();
            int verzP1Time = data.getValue(DataPoint.VERZIK_P1_SPLIT);
            int verzP2Start = data.getValue(DataPoint.VERZIK_P1_SPLIT) + 1;
            int verzP2Time = data.getValue(DataPoint.VERZIK_P2_SPLIT);
            int verzP3Start = verzP2Time + 1;
            int verzP3Time = data.getVerzikTime();


            ArrayList<Integer> p1autos = new ArrayList<>();
            for (int i = 19; i < verzP1Time; i++)
            {
                if (i == 19 || (i - 19) % 14 == 0)
                {
                    p1autos.add(i);
                }
            }

            ChartPanel maidenRCP = new ChartPanel("Maiden", false, config, clientThread, configManager);
            maidenRCP.setNPCMappings(advancedData.maidenNPCMapping);
            maidenRCP.setRoomHP(advancedData.maidenHP);
            maidenRCP.addAttacks(advancedData.maidenAttacks);
            maidenRCP.addMaidenCrabs(data.maidenCrabSpawn);
            maidenRCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                maidenRCP.enableWrap();
            }
            maidenRCP.setStartTick(1);
            maidenRCP.setTick(maidenTime);
            maidenRCP.addLines(maidenLines);
            maidenRCP.addThrallBoxes(data.maidenThrallSpawns);

            ChartPanel bloatRCP = new ChartPanel("Bloat", false, config, clientThread, configManager);
            bloatRCP.setRoomHP(advancedData.bloatHP);
            bloatRCP.addAttacks(advancedData.bloatAttacks);
            bloatRCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                bloatRCP.enableWrap();
            }
            bloatRCP.setStartTick(1);
            bloatRCP.setTick(bloatTime);
            bloatRCP.addLines(bloatLines);
            bloatRCP.addThrallBoxes(data.bloatThrallSpawns);

            ChartPanel nyloRCP = new ChartPanel("Nylocas", false, config, clientThread, configManager);
            nyloRCP.setNPCMappings(advancedData.nyloNPCMapping);
            nyloRCP.setRoomHP(advancedData.nyloHP);
            nyloRCP.addAttacks(advancedData.nyloAttacks);
            nyloRCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                nyloRCP.enableWrap();
            }
            nyloRCP.setStartTick(1);
            nyloRCP.setTick(nyloTime);
            nyloRCP.addLines(nyloLines);
            nyloRCP.addThrallBoxes(data.nyloThrallSpawns);

            ChartPanel soteRCP = new ChartPanel("Sotetseg", false, config, clientThread, configManager);
            soteRCP.setRoomHP(advancedData.soteHP);
            soteRCP.addAttacks(advancedData.soteAttacks);
            soteRCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                soteRCP.enableWrap();
            }
            soteRCP.setStartTick(1);
            soteRCP.setTick(soteTime);
            soteRCP.addLines(soteLines);
            soteRCP.addThrallBoxes(data.soteThrallSpawns);

            ChartPanel xarpRCP = new ChartPanel("Xarpus", false, config, clientThread, configManager);
            xarpRCP.setRoomHP(advancedData.xarpHP);
            xarpRCP.addAttacks(advancedData.xarpAttacks);
            xarpRCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                xarpRCP.enableWrap();
            }
            xarpRCP.setStartTick(1);
            xarpRCP.setTick(xarpTime);
            xarpRCP.addLines(xarpLines);
            xarpRCP.addThrallBoxes(data.xarpusThrallSpawns);

            ChartPanel verzP1RCP = new ChartPanel("Verzik P1", false, config, clientThread, configManager);
            verzP1RCP.setNPCMappings(advancedData.verzikNPCMapping);
            verzP1RCP.setRoomHP(advancedData.verzikHP);
            verzP1RCP.addAttacks(advancedData.verzikAttacks);
            verzP1RCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                verzP1RCP.enableWrap();
            }
            verzP1RCP.setStartTick(1);
            verzP1RCP.setTick(verzP1Time);
            verzP1RCP.addRoomSpecificDatum(dawnDropsMap);
            verzP1RCP.addThrallBoxes(data.verzikThrallSpawns);
            verzP1RCP.setRoomSpecificText("Dawn Appears");
            verzP1RCP.addAutos(p1autos);

            ChartPanel verzP2RCP = new ChartPanel("Verzik P2", false, config, clientThread, configManager);
            verzP2RCP.setNPCMappings(advancedData.verzikNPCMapping);
            verzP2RCP.setRoomHP(advancedData.verzikHP);
            verzP2RCP.addAttacks(advancedData.verzikAttacks);
            verzP2RCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                verzP2RCP.enableWrap();
            }
            verzP2RCP.setStartTick(verzP2Start);
            verzP2RCP.setTick(verzP2Time);
            verzP2RCP.addLines(verzikP2Lines);
            verzP2RCP.addThrallBoxes(data.verzikThrallSpawns);

            ChartPanel verzP3RCP = new ChartPanel("Verzik P3", false, config, clientThread, configManager);
            verzP3RCP.setNPCMappings(advancedData.verzikNPCMapping);
            verzP3RCP.setRoomHP(advancedData.verzikHP);

            verzP3RCP.addAttacks(advancedData.verzikAttacks);
            verzP3RCP.setPlayers(new ArrayList<>(data.players.keySet()));
            if (roomData.size() == 1)
            {
                verzP3RCP.enableWrap();
            }
            verzP3RCP.setStartTick(verzP3Start);
            verzP3RCP.setTick(verzP3Time);
            verzP3RCP.addLines(verzikP3Lines);
            verzP3RCP.addThrallBoxes(data.verzikThrallSpawns);
            verzP2RCP.addAutos(p2autos);
            verzP1RCP.addDawnSpecs(data.dawnSpecs);

            maidenRCP.redraw();
            bloatRCP.redraw();
            nyloRCP.redraw();
            soteRCP.redraw();
            xarpRCP.redraw();
            verzP1RCP.redraw();
            verzP2RCP.redraw();
            verzP3RCP.redraw();

			addWindowListener(new WindowAdapter()
			{
				@Override
				public void windowClosing(WindowEvent e)
				{
					super.windowClosing(e);
					maidenRCP.release();
					bloatRCP.release();
					nyloRCP.release();
					soteRCP.release();
					xarpRCP.release();
					verzP1RCP.release();
					verzP2RCP.release();
					verzP3RCP.release();
				}
			});

            Timer resizeTimer = new Timer(20, e ->
            {
                maidenRCP.setSize(frameX, frameY);
                bloatRCP.setSize(frameX, frameY);
                nyloRCP.setSize(frameX, frameY);
                soteRCP.setSize(frameX, frameY);
                xarpRCP.setSize(frameX, frameY);
                verzP1RCP.setSize(frameX, frameY);
                verzP2RCP.setSize(frameX, frameY);
                verzP3RCP.setSize(frameX, frameY);
            });

            resizeTimer.setRepeats(false);

            addComponentListener(new ComponentAdapter()
            {
                @Override
                public void componentResized(ComponentEvent e)
                {
                    super.componentResized(e);
                    if(resizeTimer.isRunning())
                    {
                        resizeTimer.restart();
                    }
                    else
                    {
                        resizeTimer.start();
                    }
                    Component c = (Component) e.getSource();
                    frameX = c.getWidth();
                    frameY = c.getHeight();
                }
            });

            basepane.addChangeListener(cl->
            {
                maidenRCP.redraw();
                bloatRCP.redraw();
                nyloRCP.redraw();
                soteRCP.redraw();
                xarpRCP.redraw();
                verzP1RCP.redraw();
                verzP2RCP.redraw();
                verzP3RCP.redraw();
            });


            maidenCharts.add(maidenRCP);
            bloatCharts.add(bloatRCP);
            nyloCharts.add(nyloRCP);
            soteCharts.add(soteRCP);
            xarpCharts.add(xarpRCP);
            verzp1Charts.add(verzP1RCP);
            verzp2Charts.add(verzP2RCP);
            verzp3Charts.add(verzP3RCP);



        }

        maidenTab.add(new JScrollPane(maidenCharts));
        bloatTab.add(new JScrollPane(bloatCharts));
        nyloTab.add(new JScrollPane(nyloCharts));
        soteTab.add(new JScrollPane(soteCharts));
        xarpTab.add(new JScrollPane(xarpCharts));
        verzP1Tab.add(new JScrollPane(verzp1Charts));
        verzP2Tab.add(new JScrollPane(verzp2Charts));
        verzP3Tab.add(new JScrollPane(verzp3Charts));

        basepane.addTab("Maiden", maidenTab);
        basepane.addTab("Bloat", bloatTab);
        basepane.addTab("Nylocas", nyloTab);
        basepane.addTab("Sotetseg", soteTab);
        basepane.addTab("Xarpus", xarpTab);
        basepane.addTab("Verzik P1", verzP1Tab);
        basepane.addTab("Verzik P2", verzP2Tab);
        basepane.addTab("Verzik P3", verzP3Tab);

        add(basepane);
        pack();
    }
}

package com.advancedraidtracker.ui.exportraids;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.ui.filters.ConfirmationDialog;
import com.advancedraidtracker.utility.datautility.RaidsManager;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

public class SaveRaids extends BaseFrame
{
    private final JTextField field;

    public SaveRaids(ArrayList<SimpleTOBData> raids)
    {
        getContentPane().removeAll();
        setTitle("Save Raids");
        JPanel borderPanel = new JPanel(new BorderLayout());
        borderPanel.setBorder(BorderFactory.createTitledBorder("Save Raids"));
        JPanel subPanel = new JPanel();
        subPanel.setLayout(new GridLayout(1, 4));
        field = new JTextField();
        subPanel.add(new JLabel("Raids Name: "));
        subPanel.add(field);
        JButton saveButton = getSaveButton(raids);
        subPanel.add(saveButton);
        borderPanel.add(subPanel);
        add(borderPanel);
        pack();
        setLocationRelativeTo(null);
        repaint();
    }

    private JButton getSaveButton(ArrayList<SimpleTOBData> raids)
    {
        JButton saveButton = new JButton("Save");
        saveButton.addActionListener(e ->
        {
            if (RaidsManager.doesRaidExist(field.getText()))
            {
                ConfirmationDialog dialog = new ConfirmationDialog(field.getText(), raids, (JFrame) (SwingUtilities.getRoot((Component) e.getSource())), 1);
                dialog.open();
            } else
            {
                RaidsManager.saveRaids(field.getText(), raids);
                close();
            }
        });
        return saveButton;
    }
}

package com.advancedraidtracker.ui;

import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.utility.wrappers.RaidsArrayWrapper;
import com.advancedraidtracker.utility.datautility.RaidsManager;
import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.io.File;
import java.nio.file.Files;
import java.util.*;

import static com.advancedraidtracker.utility.datautility.DataWriter.PLUGIN_DIRECTORY;

@Slf4j
public class RaidTrackerSidePanel extends PluginPanel
{
    private JLabel raidCountLabel;
    private ArrayList<SimpleTOBData> raidsData;
    private JTable loadRaidsTable;
    private ArrayList<RaidsArrayWrapper> raidSets;

    private Raids raids;

    private AdvancedRaidTrackerPlugin plugin;
    private static AdvancedRaidTrackerConfig config;
    private static ItemManager itemManager;
    private final ConfigManager configManager;

    private JLabel pleaseWait = new JLabel("Parsing Files...", SwingConstants.CENTER);

    @Inject
    RaidTrackerSidePanel(AdvancedRaidTrackerPlugin plugin, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)
    {
        this.configManager = configManager;
        add(pleaseWait);
        new Thread(() ->
        {
            RaidTrackerSidePanel.config = config;
            this.plugin = plugin;
            RaidTrackerSidePanel.itemManager = itemManager;
            raidsData = new ArrayList<>();
            raidsData = getAllRaids();
            raids = new Raids(config, itemManager, clientThread, configManager);
            removeAll();
            buildComponents();
            updateUI();
        }).start();
    }

    private ArrayList<SimpleTOBData> getAllRaids()
    {
        ArrayList<SimpleTOBData> raids = new ArrayList<>();
        try
        {
            File logDirectory = new File(PLUGIN_DIRECTORY);
            File[] logFiles = logDirectory.listFiles();
            int raidCount = 0;
            if(logFiles != null)
            {
                for(File file : logFiles)
                {
                    if(file.isDirectory())
                    {
                        File subDirectory = new File(file.getAbsolutePath()+"/primary/");
                        File[] subDirectoryFiles = subDirectory.listFiles();
                        if(subDirectoryFiles != null)
                        {
                            raidCount += subDirectoryFiles.length;
                        }
                    }
                }
            }
            int index = 0;
            if (logFiles != null)
            {
                for (File file : logFiles)
                {
                    if (file.isDirectory())
                    {
                        File subDirectory = new File(file.getAbsolutePath()+"/primary/");
                        File[] subLogFiles = subDirectory.listFiles();
                        if(subLogFiles != null)
                        {
                            for (File dataFile : subLogFiles)
                            {
                                if (!dataFile.isDirectory())
                                {
                                    if (dataFile.getName().contains("tobdata"))
                                    {
                                        File currentFile = new File(subDirectory.getAbsolutePath() + "/" + dataFile.getName());
                                        parseLogFile(raids, currentFile, subDirectory.getAbsolutePath() + "/" + dataFile.getName());
                                        index++;
                                        if(raidCountLabel != null)
                                        {
                                            raidCountLabel.setText("Refreshing...(" + index + "/" + raidCount + ")");
                                        }
                                        else if(pleaseWait != null)
                                        {
                                            pleaseWait.setText("Parsing Files...(" + index + "/" + raidCount + ")");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (Exception e)
        {
            log.info("Could not retrieve raids");
            e.printStackTrace();
        }
        raids.sort(Comparator.comparing(SimpleTOBData::getDate));
        return raids;
    }

    public static void parseLogFile(ArrayList<SimpleTOBData> raids, File currentFile, String filePath) throws Exception
    {
        Scanner logReader = new Scanner(Files.newInputStream(currentFile.toPath()));
        ArrayList<String> raid = new ArrayList<>();
        boolean raidActive = false;
        boolean spectate = false;
        boolean lateStart = false;
        while (logReader.hasNextLine())
        {
            String line = logReader.nextLine();
            String[] lineSplit = line.split(",");
            if (!raidActive)
            {
                if (lineSplit.length > 3)
                {
                    if (Integer.parseInt(lineSplit[3]) == 0)
                    {
                        raid.add(line);
                        raidActive = true;
                        spectate = false;
                        lateStart = false;
                    }
                }
            } else
            {
                if (lineSplit.length > 3)
                {
                    int value = Integer.parseInt(lineSplit[3]);
                    if(value != 0)
                    {
                        if(value != 801 && value != 576 && value != 587)
                        {
                            if (Integer.parseInt(lineSplit[3]) == 99 && !spectate)
                            {
                                spectate = true;
                                raid.add(line);
                            } else if (value == 98 && !lateStart)
                            {
                                lateStart = true;
                                raid.add(line);
                            } else if (Integer.parseInt(lineSplit[3]) == 4)
                            {
                                raid.add(line);
                                raidActive = false;
                                raids.add(new SimpleTOBData(raid.toArray(new String[0]), filePath, currentFile.getName()));
                                raid.clear();
                            } else if (value != 99 && value != 98)
                            {
                                raid.add(line);
                            }
                        }
                    }
                }
            }
        }
        logReader.close();
    }

    private void buildComponents()
    {
        JPanel container = new JPanel();
        JPanel primaryContainer = new JPanel();

        primaryContainer.setLayout(new GridLayout(5, 1));

        JButton viewRaidsButton = new JButton("View All Raids");
        JButton refreshRaidsButton = new JButton("Refresh");

        JButton tableRaidsButton = new JButton("View Saved Raids From Table");

        viewRaidsButton.addActionListener(
                al ->
                        new Thread(() ->
                        {
                            raids = new Raids(config, itemManager, plugin.clientThread, configManager);
                            raids.createFrame(raidsData);
                            raids.getContentPane().setBackground(Color.BLACK);
                            raids.repaint();
                            raids.open();
                        }).start());

        refreshRaidsButton.addActionListener(
                al ->
                        new Thread(() ->
                        {
                            viewRaidsButton.setEnabled(false);
                            tableRaidsButton.setEnabled(false);
                            raidCountLabel.setText("Refreshing, Please Wait...");
                            raidsData = getAllRaids();
                            DefaultTableModel model = getTableModel();
                            loadRaidsTable.setModel(model);
                            if(raids != null)
                            {
                                raids.clearData();
                                raids = null;
                            }
                            viewRaidsButton.setEnabled(true);
                            tableRaidsButton.setEnabled(true);
                            updateRaidCountLabel();
                        }).start());

        tableRaidsButton.addActionListener(
                al ->
                {
                    raids = new Raids(config, itemManager, plugin.clientThread, configManager);
                    raids.createFrame(getTableData());
                    raids.getContentPane().setBackground(Color.BLACK);
                    raids.repaint();
                    raids.open();
                }
        );

        JButton livePanelButton = new JButton("View Live Room");
        livePanelButton.addActionListener(al ->
                plugin.openLiveFrame());

        raidCountLabel = new JLabel("", SwingConstants.CENTER);
        updateRaidCountLabel();
        primaryContainer.add(raidCountLabel);
        primaryContainer.add(refreshRaidsButton);
        primaryContainer.add(viewRaidsButton);
        primaryContainer.add(tableRaidsButton);
        primaryContainer.add(livePanelButton);

        DefaultTableModel model = getTableModel();
        loadRaidsTable = new JTable(model)
        {
            @Override
            public Class<?> getColumnClass(int column)
            {
                if (column == 0)
                {
                    return String.class;
                }
                return Boolean.class;
            }
        };

        loadRaidsTable.setPreferredScrollableViewportSize(loadRaidsTable.getPreferredScrollableViewportSize());
        JScrollPane scrollPane = new JScrollPane(loadRaidsTable);
        scrollPane.setPreferredSize(new Dimension(225, scrollPane.getPreferredSize().height));
        container.add(primaryContainer);
        container.add(scrollPane);
        add(container);
    }

    private DefaultTableModel getTableModel()
    {
        Object[] columnNames = {"File Name", "Include?"};
        raidSets = RaidsManager.getRaidsSets();
        Object[][] tableData = new Object[raidSets.size()][2];
        for (int i = 0; i < raidSets.size(); i++)
        {
            tableData[i] = new Object[]{raidSets.get(i).filename, false};
        }
        return new DefaultTableModel(tableData, columnNames);
    }

    private ArrayList<SimpleTOBData> getTableData()
    {
        ArrayList<String> includedSets = new ArrayList<>();
        for (int i = 0; i < loadRaidsTable.getRowCount(); i++)
        {
            if ((boolean) loadRaidsTable.getValueAt(i, 1))
            {
                includedSets.add((String) loadRaidsTable.getValueAt(i, 0));
            }
        }
        ArrayList<SimpleTOBData> collectedRaids = new ArrayList<>();
        for (RaidsArrayWrapper set : raidSets)
        {
            for (String s : includedSets)
            {
                if (s.equals(set.filename))
                {
                    collectedRaids.addAll(set.data);
                }
            }
        }
        return collectedRaids;
    }

    private void updateRaidCountLabel()
    {
        raidCountLabel.setText("Raids Found: " + raidsData.size());
    }

}

package com.advancedraidtracker.ui;


import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.filters.*;
import com.advancedraidtracker.ui.buttons.*;
import com.advancedraidtracker.ui.charts.ChartFrame;
import com.advancedraidtracker.ui.comparisonview.ComparisonViewFrame;
import com.advancedraidtracker.ui.comparisonview.ComparisonViewPanel;
import com.advancedraidtracker.ui.comparisonview.NoDataPopUp;
import com.advancedraidtracker.ui.crableaks.CrabLeakInfo;
import com.advancedraidtracker.ui.exportraids.SaveRaids;
import com.advancedraidtracker.ui.filters.LoadFilter;
import com.advancedraidtracker.ui.filters.SaveFilter;
import com.advancedraidtracker.ui.statistics.StatisticTab;
import com.advancedraidtracker.utility.*;
import com.advancedraidtracker.utility.datautility.DataPoint;
import com.advancedraidtracker.utility.datautility.DataWriter;
import com.advancedraidtracker.utility.wrappers.PlayerCorrelatedPointData;
import com.advancedraidtracker.utility.wrappers.StringInt;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import javax.swing.*;
import javax.swing.border.MatteBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import javax.swing.text.BadLocationException;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.*;
import java.util.List;

import static com.advancedraidtracker.utility.UISwingUtility.*;

@Slf4j
public class Raids extends BaseFrame
{
    private final ArrayList<Integer> filteredIndices;
    private JTable comparisonTable;
    private final ArrayList<ArrayList<SimpleTOBData>> comparisons;

    private final JTabbedPane tabbedPane = new JTabbedPane();
    public ArrayList<ImplicitFilter> activeFilters;
    private final JLabel raidsFoundLabel = new JLabel("", SwingConstants.LEFT);
    private final JLabel completionsFound = new JLabel("", SwingConstants.LEFT);
    private JComboBox<String> viewByRaidComboBox;

    private JComboBox<String> sortOrderBox;
    private JComboBox<String> sortOptionsBox;

    Map<String, JLabel> averageLabels = new LinkedHashMap<>();
    Map<String, JLabel> medianLabels = new LinkedHashMap<>();
    Map<String, JLabel> minLabels = new LinkedHashMap<>();
    Map<String, JLabel> maxLabels = new LinkedHashMap<>();
    public JComboBox<String> statisticsBox;
    public JLabel customAverageLabel = new JLabel("", SwingConstants.RIGHT);
    public JLabel customMedianLabel = new JLabel("", SwingConstants.RIGHT);
    public JLabel customModeLabel = new JLabel("", SwingConstants.RIGHT);
    public JLabel customMinLabel = new JLabel("", SwingConstants.RIGHT);
    public JLabel customMaxLabel = new JLabel("", SwingConstants.RIGHT);

    private final ArrayList<Map<String, ArrayList<String>>> aliases;

    private final JTextArea aliasText;

    JTextField dateTextField;
    JCheckBox filterSpectateOnly;
    JCheckBox filterInRaidOnly;
    JCheckBox filterCompletionOnly;
    JCheckBox filterWipeResetOnly;
    JComboBox<String> filterComboBoxScale;
    JCheckBox filterCheckBoxScale;
    JCheckBox filterTodayOnly;
    JCheckBox filterPartyOnly;
    JCheckBox filterPartialData;
    JCheckBox filterPartialOnly;
    JCheckBox filterNormalOnly;
    JTable table;
    JPanel container;
    private JPanel filterTableContainer;
    public ArrayList<SimpleTOBData> currentData;
    private JComboBox<String> timeFilterChoice;
    private JComboBox<String> timeFilterOperator;
    private JTextField timeFilterValue;
    private JTable filterTable;
    private JComboBox<String> playerFilterOperator;
    private JTextField playerFilterValue;
    private JCheckBox timeFollowsTab;
    private StatisticTab maidenTab;
    private StatisticTab bloatTab;
    private StatisticTab nyloTab;
    private StatisticTab soteTab;
    private StatisticTab xarpTab;
    private StatisticTab verzikTab;
    private boolean built = false;
    private JComboBox<String> dateFilterOperator;
    private JComboBox<String> otherIntFilterChoice;
    private JComboBox<String> otherIntFilterOperator;
    private JTextField otherIntFilterValue;
    private JComboBox<String> otherBoolFilterChoice;
    private JComboBox<String> otherBoolFilterOperator;


    private final AdvancedRaidTrackerConfig config;
    private final ItemManager itemManager;
    private final ClientThread clientThread;

    public String[] rooms = {"Maiden", "Bloat","Nylocas","Sotetseg","Xarpus","Verzik","Challenge"};
    private final ConfigManager configManager;

    public Raids(AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)
    {
        for(String s : rooms)
        {
            averageLabels.put(s, getDarkJLabel("", SwingConstants.RIGHT));
            medianLabels.put(s, getDarkJLabel("", SwingConstants.RIGHT));
            minLabels.put(s, getDarkJLabel("", SwingConstants.RIGHT));
            maxLabels.put(s, getDarkJLabel("", SwingConstants.RIGHT));
        }
        this.clientThread = clientThread;
        this.itemManager = itemManager;
        this.configManager = configManager;
        columnHeaders = new ArrayList<>();
        for (String s : columnHeaderNames)
        {
            columnHeaders.add(getCheckBoxMenuItem(s));
        }
        aliases = new ArrayList<>();
        filteredIndices = new ArrayList<>();
        comparisons = new ArrayList<>();
        activeFilters = new ArrayList<>();
        aliasText = new JTextArea();
        this.config = config;
        this.setPreferredSize(new Dimension(1200, 820));
    }

    public void updateCustomStats(ArrayList<SimpleTOBData> raids)
    {
        DataPoint dataPoint = DataPoint.ATTEMPTED_BGS_BLOAT;
        boolean time = dataPoint.type == DataPoint.types.TIME;

        double avg = StatisticGatherer.getGenericAverage(raids, dataPoint);
        double med = StatisticGatherer.getGenericMedian(raids, dataPoint);
        double mod = StatisticGatherer.getGenericMode(raids, dataPoint);
        double min = StatisticGatherer.getGenericMin(raids, dataPoint);
        double max = StatisticGatherer.getGenericMax(raids, dataPoint);

        String avgStr = (time) ? RoomUtil.time(avg) : String.valueOf(avg);
        String medStr = (time) ? RoomUtil.time(med) : String.valueOf(med);
        String modStr = (time) ? RoomUtil.time(mod) : String.valueOf(mod);
        String minStr = (time) ? RoomUtil.time(min) : String.valueOf(min);
        String maxStr = (time) ? RoomUtil.time(max) : String.valueOf(max);

        if (avg == -1) avgStr = "-";
        if (med == -1) medStr = "-";
        if (mod == -1) modStr = "-";
        if (min == -1) minStr = "-";
        if (max == -1) maxStr = "-";

        customAverageLabel.setText(avgStr);
        customMedianLabel.setText(medStr);
        customModeLabel.setText(modStr);
        customMinLabel.setText(minStr);
        customMaxLabel.setText(maxStr);
    }

    private boolean evaluateAllFilters(SimpleTOBData data)
    {
        for (ImplicitFilter filter : activeFilters)
        {
            if (!filter.evaluate(data))
            {
                return false;
            }
        }
        return true;
    }

    public void updateTable()
    {
        int completions = 0;
        ArrayList<SimpleTOBData> tableData = new ArrayList<>();
        for (SimpleTOBData data : currentData)
        {
            boolean shouldDataBeIncluded = true;
            if (filterSpectateOnly.isSelected())
            {
                if (!data.spectated)
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (filterInRaidOnly.isSelected())
            {
                if (data.spectated)
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (filterCompletionOnly.isSelected())
            {
                if (!data.raidCompleted || !data.getOverallTimeAccurate())
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (filterWipeResetOnly.isSelected())
            {
                if (data.raidCompleted)
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (filterPartialData.isSelected())
            {
                if (!(data.maidenStartAccurate == data.maidenEndAccurate &&
                        data.bloatStartAccurate == data.bloatEndAccurate &&
                        data.nyloStartAccurate == data.nyloEndAccurate &&
                        data.soteStartAccurate == data.soteEndAccurate &&
                        data.xarpStartAccurate == data.xarpEndAccurate &&
                        data.verzikStartAccurate == data.verzikEndAccurate))
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (shouldDataBeIncluded && filterTodayOnly.isSelected())
            {
                shouldDataBeIncluded = false;
                Calendar cal1 = Calendar.getInstance();
                Calendar cal2 = Calendar.getInstance();
                cal1.setTime(data.raidStarted);
                cal2.setTime(new Date(System.currentTimeMillis()));
                if (cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH))
                {
                    shouldDataBeIncluded = true;
                }
            }
            if (filterPartyOnly.isSelected())
            {
                if (!data.maidenDefenseAccurate || !data.bloatDefenseAccurate || !data.nyloDefenseAccurate || !data.soteDefenseAccurate || !data.xarpDefenseAccurate)
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (filterNormalOnly.isSelected())
            {
                if (data.storyMode || data.hardMode)
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (filterPartialOnly.isSelected())
            {
                switch (Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString())
                {
                    case "Challenge Time":
                        if (!data.getOverallTimeAccurate())
                        {
                            shouldDataBeIncluded = false;
                        }
                        break;
                    case "Maiden Time":
                        if (!data.maidenStartAccurate || !data.maidenEndAccurate)
                        {
                            shouldDataBeIncluded = false;
                        }
                        break;
                    case "Bloat Time":
                        if (!data.bloatStartAccurate || !data.bloatEndAccurate)
                        {
                            shouldDataBeIncluded = false;
                        }
                        break;
                    case "Nylocas Time":
                        if (!data.nyloStartAccurate || !data.nyloEndAccurate)
                        {
                            shouldDataBeIncluded = false;
                        }
                        break;
                    case "Sotetseg Time":
                        if (!data.soteStartAccurate || !data.soteEndAccurate)
                        {
                            shouldDataBeIncluded = false;
                        }
                        break;
                    case "Xarpus Time":
                        if (!data.xarpStartAccurate || !data.xarpEndAccurate)
                        {
                            shouldDataBeIncluded = false;
                        }
                        break;
                    case "Verzik Time":
                        if (!data.verzikStartAccurate || !data.verzikEndAccurate)
                        {
                            shouldDataBeIncluded = false;
                        }
                        break;
                }
            }
            if (shouldDataBeIncluded && filterCheckBoxScale.isSelected())
            {
                shouldDataBeIncluded = filterComboBoxScale.getSelectedIndex() + 1 == data.getScale();
            }
            for (Integer i : filteredIndices)
            {
                if (data.getValue(DataPoint.RAID_INDEX) == i)
                {
                    shouldDataBeIncluded = false;
                }
            }
            if (!evaluateAllFilters(data))
            {
                shouldDataBeIncluded = false;
            }
            if (shouldDataBeIncluded)
            {
                tableData.add(data);
                if (data.raidCompleted && data.getOverallTimeAccurate())
                {
                    completions++;
                }
            }
        }
        if (sortOptionsBox.getSelectedIndex() == 0)
        {
            if (sortOrderBox.getSelectedIndex() == 0)
            {
                tableData.sort(Comparator.comparing(SimpleTOBData::getDate));
            } else
            {
                tableData.sort(Comparator.comparing(SimpleTOBData::getDate).reversed());
            }
        } else if (sortOptionsBox.getSelectedIndex() == 1)
        {
            if (sortOrderBox.getSelectedIndex() == 0)
            {
                for (SimpleTOBData data : tableData)
                {
                    data.activeValue = Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString();
                }
                tableData.sort(Comparator.comparing(SimpleTOBData::getSpecificTime));
            } else
            {
                for (SimpleTOBData data : tableData)
                {
                    data.activeValue = Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString();
                }
                tableData.sort(Comparator.comparing(SimpleTOBData::getSpecificTime).reversed());
            }
        } else if (sortOptionsBox.getSelectedIndex() == 2)
        {
            if (sortOrderBox.getSelectedIndex() == 0)
            {
                tableData.sort(Comparator.comparing(SimpleTOBData::getScale));
            } else
            {
                tableData.sort(Comparator.comparing(SimpleTOBData::getScale).reversed());
            }
        }

        updateCustomStats(tableData);
        raidsFoundLabel.setText("Raids Found: " + tableData.size());
        completionsFound.setText("Completions Found: " + completions);
        updateTabNames(tableData);

        ArrayList<String> columnNamesDynamic = new ArrayList<>();
        columnNamesDynamic.add("");
        for (JCheckBoxMenuItem item : columnHeaders)
        {
            if (item.getState())
            {
                columnNamesDynamic.add(item.getText());
            }
            if (item.getText().equals("Status"))
            {
                columnNamesDynamic.add(Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString());
            }
        }
        ArrayList<Object[]> tableBuilder = new ArrayList<>();
        for (SimpleTOBData raid : tableData)
        {
            ArrayList<Object> rowBuilder = new ArrayList<>();
            for (String column : columnNamesDynamic)
            {
                rowBuilder.add(getRowData(column, raid));
            }
            tableBuilder.add(rowBuilder.toArray());
        }
        int columns = 0;
        if (!tableBuilder.isEmpty())
        {
            columns = tableBuilder.get(0).length;
        }
        Object[][] tableObject = new Object[tableData.size()][columns];
        int count = 0;
        for (Object[] row : tableBuilder)
        {
            tableObject[count] = row;
            count++;
        }

        table.setModel(new DefaultTableModel(tableObject, columnNamesDynamic.toArray()));
        for (int i = 0; i < table.getColumnCount(); i++)
        {
            if (table.getColumnName(i).equals("View"))
            {
                table.getColumn(table.getColumnName(i)).setCellEditor(new ButtonEditorRoomData(new JCheckBox(), tableData));
                table.getColumn(table.getColumnName(i)).setCellRenderer(new ButtonRenderer());
            } else
            {
                table.getColumn(table.getColumnName(i)).setCellEditor(new NonEditableCell(new JTextField()));
                table.getColumn(table.getColumnName(i)).setCellRenderer(new StripedTableRowCellRenderer());
            }
        }

        resizeColumnWidth(table);
        table.setFillsViewportHeight(true);
        setLabels(tableData);
        container.validate();
        container.repaint();
    }

    public Object getRowData(String column, SimpleTOBData raid)
    {
        switch (column)
        {
            case "":
                return raid.getValue(DataPoint.RAID_INDEX);
            case "Date":
                Calendar cal = Calendar.getInstance();
                cal.setTime(raid.raidStarted);
                return (cal.get(Calendar.MONTH) + 1) + "-" + cal.get(Calendar.DAY_OF_MONTH) + "-" + cal.get(Calendar.YEAR);
            case "Scale":
                return raid.getScaleString();
            case "Status":
                return raid.getRoomStatus();
            case "Players":
                StringBuilder players = new StringBuilder();
                for (String s : raid.players.keySet())
                {
                    players.append(s).append(", ");
                }
                return (players.length() > 2) ? players.substring(0, players.length() - 2) : "";
            case "Spectate":
                return (raid.spectated) ? "Yes" : "No";
            case "View":
                return "View";
            case "Time":
                Calendar cal2 = Calendar.getInstance();
                cal2.setTime(raid.raidStarted);
                int hour = cal2.get(Calendar.HOUR_OF_DAY);
                int minute = cal2.get(Calendar.MINUTE);
                String minuteString = (minute < 10) ? "0" + minute : String.valueOf(minute);
                String period = (hour > 11) ? " PM" : " AM";
                if (hour == 0)
                {
                    hour = 12;
                } else if (hour > 12)
                {
                    hour -= 12;
                }
                return hour + ":" + minuteString + period;
        }
        String valueToDisplay = "(?)";
        try
        {
            PlayerCorrelatedPointData pointData = raid.getSpecificTimeInactiveCorrelated(column);
            if (pointData == null)
            {
                valueToDisplay = String.valueOf(raid.getSpecificTimeInactive(column));
            } else
            {
                if (pointData.value == 0)
                {
                    valueToDisplay = "0";
                } else
                {
                    valueToDisplay = pointData.value + " (" + pointData.player + ")";
                }
            }
        } catch (Exception ignored)
        {

        }
        return (isTime(column) ? RoomUtil.time(valueToDisplay) : valueToDisplay);
    }

    boolean isTime(String value)
    {
        try
        {
            if (!value.contains("Player:"))
            {
                return DataPoint.getValue(value).type == DataPoint.types.TIME;
            }
            else
            {
                return false;
            }
        } catch (Exception e)
        {
            return false;
        }
    }

    private void updateTabNames(ArrayList<SimpleTOBData> data)
    {
        int maidenCount = 0;
        int bloatCount = 0;
        int nyloCount = 0;
        int soteCount = 0;
        int xarpCount = 0;
        int verzikCount = 0;
        for (SimpleTOBData d : data)
        {
            if (d.maidenStartAccurate && d.maidenEndAccurate)
            {
                maidenCount++;
            }
            if (d.bloatStartAccurate && d.bloatEndAccurate)
            {
                bloatCount++;
            }
            if (d.nyloStartAccurate && d.nyloEndAccurate)
            {
                nyloCount++;
            }
            if (d.soteStartAccurate && d.soteEndAccurate)
            {
                soteCount++;
            }
            if (d.xarpStartAccurate && d.xarpEndAccurate)
            {
                xarpCount++;
            }
            if (d.verzikStartAccurate && d.verzikEndAccurate)
            {
                verzikCount++;
            }
        }
        tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
        tabbedPane.setTitleAt(1, "Maiden (" + maidenCount + ")");
        tabbedPane.setTitleAt(2, "Bloat (" + bloatCount + ")");
        tabbedPane.setTitleAt(3, "Nylo (" + nyloCount + ")");
        tabbedPane.setTitleAt(4, "Sotetseg (" + soteCount + ")");
        tabbedPane.setTitleAt(5, "Xarpus (" + xarpCount + ")");
        tabbedPane.setTitleAt(6, "Verzik (" + verzikCount + ")");
    }

    public void resizeColumnWidthFilters(JTable table)
    {
        final TableColumnModel columnModel = table.getColumnModel();
        for (int column = 0; column < table.getColumnCount(); column++)
        {
            int width = 25; // Min width
            for (int row = 0; row < table.getRowCount(); row++)
            {
                TableCellRenderer renderer = table.getCellRenderer(row, column);
                Component comp = table.prepareRenderer(renderer, row, column);
                width = Math.max(comp.getPreferredSize().width + 1, width);
            }
            if (width > 300)
            {
                width = 300;
            }
            columnModel.getColumn(column).setPreferredWidth(width);
        }
    }

    public void resizeColumnWidth(JTable table)
    {
        final TableColumnModel columnModel = table.getColumnModel();
        for (int column = 0; column < table.getColumnCount(); column++)
        {
            int width = 50; // Min width
            for (int row = 0; row < table.getRowCount(); row++)
            {
                TableCellRenderer renderer = table.getCellRenderer(row, column);
                Component comp = table.prepareRenderer(renderer, row, column);
                width = Math.max(comp.getPreferredSize().width + 1, width);
            }
            if (width > 500)
            {
                width = 500;
            }
            columnModel.getColumn(column).setPreferredWidth(width);
        }
    }

    public void setLabels(ArrayList<SimpleTOBData> data)
    {
        setOverallLabels(data);
        maidenTab.updateTab(data);
        bloatTab.updateTab(data);
        nyloTab.updateTab(data);
        soteTab.updateTab(data);
        xarpTab.updateTab(data);
        verzikTab.updateTab(data);
    }

    public void setOverallLabels(ArrayList<SimpleTOBData> data)
    {
        setOverallAverageLabels(data);
        setOverallMedianLabels(data);
        setOverallMinLabels(data);
        setOverallMaxLabels(data);
    }

    public void setOverallAverageLabels(ArrayList<SimpleTOBData> data)
    {
        for(String s : averageLabels.keySet())
        {
            averageLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericAverage(data, DataPoint.getValue(s + " Time"))));
        }
    }

    public void setOverallMedianLabels(ArrayList<SimpleTOBData> data)
    {
        for(String s : medianLabels.keySet())
        {
            medianLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericMedian(data, DataPoint.getValue(s + " Time"))));
        }
    }

    public void setOverallMinLabels(ArrayList<SimpleTOBData> data)
    {
        for(String s : minLabels.keySet())
        {
            minLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericMin(data, DataPoint.getValue(s + " Time"))));
        }
    }

    private void setOverallMaxLabels(ArrayList<SimpleTOBData> data)
    {
        for(String s : maxLabels.keySet())
        {
            maxLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericMax(data, DataPoint.getValue(s + " Time"))));
        }
    }

    private JPopupMenu comboPopupMenu;
    private ArrayList<String> comboStrictData;
    private AbstractButton arrowButton;
    private boolean writing = false;

    private void updateAliases()
    {
        writing = true;
        aliases.clear();
        aliasText.setText("");
        for (String s : DataWriter.readAliasFile())
        {
            aliasText.append(s + "\n");
            String[] split = s.split(":");
            if (split.length != 2)
            {
                continue;
            }
            String name = split[0];
            ArrayList<String> names = new ArrayList<>(Arrays.asList(split[1].split(",")));
            if (!names.isEmpty())
            {
                Map<String, ArrayList<String>> map = new LinkedHashMap<>();
                map.put(name, names);
                aliases.add(map);
            }
        }
        writing = false;
    }

    private void setPopupVisible(boolean visible)
    {
        if (visible)
        {
            comboPopupMenu.show(viewByRaidComboBox, 0, viewByRaidComboBox.getSize().height);
        } else
        {
            comboPopupMenu.setVisible(false);
        }
    }

    private void setComboSelection(String name)
    {
        Vector<String> items = new Vector<>();

        ComparisonViewPanel.addComboItems(name, items, comboStrictData, viewByRaidComboBox);
    }

    private JMenuItem createMenuItemTableHeader(final String name)
    {
        JMenuItem item = new JMenuItem(name);
        item.setBackground(Color.BLACK);
        item.setOpaque(true);
        item.addActionListener(event -> getUpdatedPopupMenu(name));
        return item;
    }

    private JMenuItem createMenuItem(final String name)
    {
        JMenuItem item = new JMenuItem(name);
        item.setBackground(Color.BLACK);
        item.setOpaque(true);
        item.addActionListener(event -> setComboSelection(name));
        return item;
    }


    private final Map<String, String[]> comboPopupData = new LinkedHashMap<>();


    public  JPanel getOverallPanel(String title, Map<String, JLabel> labelMap)
    {
        JPanel panel = new JPanel();
        panel.setLayout(new BorderLayout());
        panel.setBorder(BorderFactory.createTitledBorder(title));

        JPanel subPanel = new JPanel();
        subPanel.setLayout(new GridLayout(7, 2));

        for(String s : rooms)
        {
            JLabel leftLabel = new JLabel(roomColor + s);
            subPanel.add(leftLabel);
            subPanel.add(labelMap.get(s));
        }
        panel.add(subPanel);
        return panel;
    }

    public void clearData()
    {
        if(currentData != null)
        {
            currentData.clear();
        }
        if(comparisons != null)
        {
            comparisons.clear();
        }
        close();
    }

    public void createFrame(ArrayList<SimpleTOBData> data)
    {
        comboPopupData.put("Room Times", DataPoint.getRoomTimes());
        comboPopupData.put("Maiden", DataPoint.getMaidenNames());
        comboPopupData.put("Bloat", DataPoint.getBloatNames());
        comboPopupData.put("Nylocas", DataPoint.getNyloNames());
        comboPopupData.put("Sotetseg", DataPoint.getSoteNames());
        comboPopupData.put("Xarpus", DataPoint.getXarpNames());
        comboPopupData.put("Verzik", DataPoint.getVerzikNames());
        comboPopupData.put("Any", DataPoint.getAnyRoomNames());
        comboPopupMenu = new JPopupMenu();
        comboPopupMenu.setBorder(new MatteBorder(1, 1, 1, 1, Color.DARK_GRAY));

        List<String> allComboValues = new ArrayList<>(comboPopupData.keySet());

        comboStrictData = new ArrayList<>();

        for (String category : allComboValues)
        {
            JMenu menu = new JMenu(category);
            menu.setBackground(Color.BLACK);
            menu.setOpaque(true);
            if (!category.equals("Room Times") && !category.equals("Any"))
            {
                JMenu timeMenu = new JMenu("Time");
                timeMenu.setBackground(Color.BLACK);
                timeMenu.setOpaque(true);
                for (String itemName : DataPoint.filterTimes(comboPopupData.get(category)))
                {
                    timeMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu countMenu = new JMenu("Misc");
                countMenu.setBackground(Color.BLACK);
                countMenu.setOpaque(true);
                for (String itemName : DataPoint.filterInt(comboPopupData.get(category)))
                {
                    countMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu thrallMenu = new JMenu("Thrall");
                thrallMenu.setBackground(Color.BLACK);
                thrallMenu.setOpaque(true);
                for (String itemName : DataPoint.filterThrall(comboPopupData.get(category)))
                {
                    thrallMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu vengMenu = new JMenu("Veng");
                vengMenu.setBackground(Color.BLACK);
                vengMenu.setOpaque(true);
                for (String itemName : DataPoint.filterVeng(comboPopupData.get(category)))
                {
                    vengMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }

                JMenu specMenu = new JMenu("Spec");
                specMenu.setBackground(Color.BLACK);
                specMenu.setOpaque(true);
                for (String itemName : DataPoint.filterSpecs(comboPopupData.get(category)))
                {
                    specMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }

                menu.add(timeMenu);
                menu.add(countMenu);
                menu.add(thrallMenu);
                menu.add(vengMenu);
                menu.add(specMenu);
            } else
            {
                for (String itemName : comboPopupData.get(category))
                {
                    menu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
            }
            comboPopupMenu.add(menu);
        }
        JMenu playerSpecificMenu = new JMenu("Player Specific");
        playerSpecificMenu.setBackground(Color.BLACK);
        playerSpecificMenu.setOpaque(true);
        String[] qualifiers = new String[]{"Maiden", "Bloat", "Nylo", "Sote", "Xarp", "Verz", "deaths"};

        for (String s : qualifiers)
        {
            JMenu room = new JMenu(s);
            room.setBackground(Color.BLACK);
            room.setOpaque(true);
            for (String qualified : DataPoint.getPlayerSpecific())
            {
                if (qualified.contains(s))
                {
                    room.add(createMenuItem("Player: " + qualified));
                    comboStrictData.add("Player: " + qualified);
                }
            }
            playerSpecificMenu.add(room);
        }
        JMenu room = new JMenu("Other");
        room.setBackground(Color.BLACK);
        room.setOpaque(true);
        for (String qualified : DataPoint.getPlayerSpecific())
        {
            boolean anyFlagged = false;
            for (String s : qualifiers)
            {
                if (qualified.contains(s))
                {
                    anyFlagged = true;
                    break;
                }
            }
            if (!anyFlagged)
            {
                room.add(createMenuItem("Player: " + qualified));
                comboStrictData.add("Player: " + qualified);
            }
        }
        playerSpecificMenu.add(room);

        comboPopupMenu.add(playerSpecificMenu);

        viewByRaidComboBox = new JComboBox<>();
        viewByRaidComboBox.setEditable(true);
        viewByRaidComboBox.setPrototypeDisplayValue("Challenge Time");
        viewByRaidComboBox.setSelectedItem("Challenge Time");
        viewByRaidComboBox.setEditable(false);
        for (Component comp : viewByRaidComboBox.getComponents())
        {
            if (comp instanceof AbstractButton)
            {
                arrowButton = (AbstractButton) comp;
                arrowButton.setBackground(Color.BLACK);
            }
        }

        arrowButton.addActionListener(e -> setPopupVisible(!comboPopupMenu.isVisible()));

        viewByRaidComboBox.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                setPopupVisible(!comboPopupMenu.isVisible());
            }
        });

        timeFollowsTab = new JCheckBox("Time Follows Tab");
        timeFollowsTab.setSelected(true);

        for (int i = 0; i < data.size(); i++)
        {
            data.get(i).setIndex(i);
        }

        int completions = 0;
        currentData = data;
        setTitle("Raids");

        JPopupMenu tstMenu = getjPopupMenu();


        table = new JTable();
        table.getTableHeader().setComponentPopupMenu(tstMenu);
        JScrollPane pane = new JScrollPane(table);

        JPanel tablePanel = getTitledPanel("Raids");
        tablePanel.setLayout(new BorderLayout());
        tablePanel.add(pane);


        container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        tabbedPane.addChangeListener(e ->
        {
            if (timeFollowsTab.isSelected())
            {
                if (built)
                {
                    viewByRaidComboBox.setEditable(true);
                    switch (tabbedPane.getSelectedIndex())
                    {
                        case 0:
                            viewByRaidComboBox.setSelectedItem("Challenge Time");
                            break;
                        case 1:
                            viewByRaidComboBox.setSelectedItem("Maiden Time");
                            break;
                        case 2:
                            viewByRaidComboBox.setSelectedItem("Bloat Time");
                            break;
                        case 3:
                            viewByRaidComboBox.setSelectedItem("Nylocas Time");
                            break;
                        case 4:
                            viewByRaidComboBox.setSelectedItem("Sotetseg Time");
                            break;
                        case 5:
                            viewByRaidComboBox.setSelectedItem("Xarpus Time");
                            break;
                        case 6:
                            viewByRaidComboBox.setSelectedItem("Verzik Time");
                            break;

                    }
                    viewByRaidComboBox.setEditable(false);
                    updateTable();
                }
            }
        });
        JComponent overallPanel = new JPanel();
        tabbedPane.addTab("Overall", overallPanel);
        overallPanel.setLayout(new GridLayout(2, 3));

        JPanel overallCustomPanel = new JPanel();
        overallCustomPanel.setLayout(new BorderLayout());
        overallCustomPanel.setBorder(BorderFactory.createTitledBorder(""));

        JPanel customSubPanel = new JPanel();
        customSubPanel.setLayout(new GridLayout(1, 4));

        JPanel chooseStatisticPanel = getTitledPanel("Choose Statistic");
        chooseStatisticPanel.setLayout(new GridLayout(1, 1));

        JPanel resultsPanel = getTitledPanel("Results");
        resultsPanel.setLayout(new GridLayout(5, 2));

        JPanel tableOptionsPanel = getTitledPanel("Table Options");

        JPanel viewRaidByPanel = getTitledPanel("View Raid By");

        sortOptionsBox = new JComboBox<>(new String[]
                {
                        "Date",
                        "Value",
                        "Scale"
                }
        );

        sortOrderBox = new JComboBox<>(new String[]
                {
                        "Ascending",
                        "Descending"
                });

        statisticsBox = new JComboBox<>(DataPoint.getByNames());


        statisticsBox.addActionListener(
                al ->
                        updateTable());

        sortOptionsBox.addActionListener(
                al ->
                        updateTable()
        );

        sortOrderBox.addActionListener(
                al ->
                        updateTable()
        );

        JLabel textCustomAverageLabel = new JLabel("Average:", SwingConstants.LEFT);
        JLabel textCustomMedianLabel = new JLabel("Median:", SwingConstants.LEFT);
        JLabel textCustomModeLabel = new JLabel("Mode:", SwingConstants.LEFT);
        JLabel textCustomMinLabel = new JLabel("Minimum:", SwingConstants.LEFT);
        JLabel textCustomMaxLabel = new JLabel("Maximum:", SwingConstants.LEFT);

        resultsPanel.add(textCustomAverageLabel);
        resultsPanel.add(customAverageLabel);

        resultsPanel.add(textCustomMedianLabel);
        resultsPanel.add(customMedianLabel);

        resultsPanel.add(textCustomModeLabel);
        resultsPanel.add(customModeLabel);

        resultsPanel.add(textCustomMinLabel);
        resultsPanel.add(customMinLabel);

        resultsPanel.add(textCustomMaxLabel);
        resultsPanel.add(customMaxLabel);

        chooseStatisticPanel.add(statisticsBox);

        JButton undoFilter = new JButton("Clear manual filter");
        undoFilter.addActionListener(al ->
        {
            filteredIndices.clear();
            updateTable();
        });

        tableOptionsPanel.add(sortOptionsBox);
        tableOptionsPanel.add(sortOrderBox);
        tableOptionsPanel.add(undoFilter);
        JPanel buttonLine = new JPanel();
        buttonLine.setLayout(new GridLayout(1, 2));
        buttonLine.add(new JLabel("Config"));

        viewByRaidComboBox.addActionListener(
                al ->
                        updateTable());

        viewRaidByPanel.add(viewByRaidComboBox);

        viewRaidByPanel.add(timeFollowsTab);

        viewRaidByPanel.add(raidsFoundLabel);
        viewRaidByPanel.add(completionsFound);
        raidsFoundLabel.setText("Raids found: " + data.size());
        completionsFound.setText("Completions found: " + completions);

        customSubPanel.add(chooseStatisticPanel);
        customSubPanel.add(resultsPanel);
        customSubPanel.add(tableOptionsPanel);
        customSubPanel.add(viewRaidByPanel);

        overallCustomPanel.add(customSubPanel);

        JPanel overallAveragePanel = getOverallPanel("Average", averageLabels);
        JPanel overallMedianPanel = getOverallPanel("Median", medianLabels);
        JPanel overallMinPanel = getOverallPanel("Minimum", minLabels);
        JPanel overallMaxPanel = getOverallPanel("Maximum",maxLabels);

        JPanel topStatPanel = new JPanel();
        topStatPanel.setLayout(new GridLayout(1, 4));

        topStatPanel.add(overallAveragePanel);
        topStatPanel.add(overallMedianPanel);
        topStatPanel.add(overallMinPanel);
        topStatPanel.add(overallMaxPanel);

        overallPanel.add(topStatPanel);
        overallPanel.add(overallCustomPanel);

        maidenTab = new StatisticTab(data, DataPoint.rooms.MAIDEN);
        tabbedPane.addTab("Maiden", maidenTab);
        bloatTab = new StatisticTab(data, DataPoint.rooms.BLOAT);
        tabbedPane.addTab("Bloat", bloatTab);
        nyloTab = new StatisticTab(data, DataPoint.rooms.NYLOCAS);
        tabbedPane.addTab("Nylo", nyloTab);
        soteTab = new StatisticTab(data, DataPoint.rooms.SOTETSEG);
        tabbedPane.addTab("Sotetseg", soteTab);
        xarpTab = new StatisticTab(data, DataPoint.rooms.XARPUS);
        tabbedPane.addTab("Xarpus", xarpTab);
        verzikTab = new StatisticTab(data, DataPoint.rooms.VERZIK);
        tabbedPane.addTab("Verzik", verzikTab);

        tabbedPane.setMinimumSize(new Dimension(100, 300));

        JPanel additionalFiltersPanel = getTitledPanel("Quick Filters");
        additionalFiltersPanel.setLayout(new BorderLayout());
        additionalFiltersPanel.setMinimumSize(new Dimension(200, 300));
        additionalFiltersPanel.setPreferredSize(new Dimension(200, 300));

        filterSpectateOnly = getActionListenCheckBox("Spectate Only", al-> updateTable());
        filterInRaidOnly = getActionListenCheckBox("In Raid Only", al-> updateTable());
        filterCompletionOnly = getActionListenCheckBox("Completion Only", al-> updateTable());
        filterWipeResetOnly = getActionListenCheckBox("Wipe/Reset Only", al-> updateTable());
        filterComboBoxScale = UISwingUtility.getActionListenCheckBox(new String[]{"Solo", "Duo", "Trio", "4-Man", "5-Man"}, al -> updateTable());
        filterCheckBoxScale = getActionListenCheckBox("Scale", al -> updateTable());
        filterTodayOnly = getActionListenCheckBox("Today Only", al -> updateTable());
        filterPartyOnly = getActionListenCheckBox("Party Only", al -> updateTable());
        filterPartialData = getActionListenCheckBox("Filter Partial Raids", al -> updateTable());
        filterPartialOnly = getActionListenCheckBox("Filter Partial Rooms", al -> updateTable());
        filterPartialData.setToolTipText("Removes data sets that have any rooms that were partially completed");
        filterNormalOnly = getActionListenCheckBox("Normal Mode Only", true, al-> updateTable());

        JPanel scaleContainer = new JPanel();
        scaleContainer.setLayout(new BoxLayout(scaleContainer, BoxLayout.X_AXIS));

        JPanel filterHolder = new JPanel();
        filterHolder.setLayout(new GridLayout(10, 1));
        filterHolder.add(filterSpectateOnly);
        filterHolder.add(filterInRaidOnly);
        filterHolder.add(filterCompletionOnly);
        filterHolder.add(filterWipeResetOnly);
        filterHolder.add(filterTodayOnly);
        filterHolder.add(filterPartyOnly);
        filterHolder.add(filterPartialData);
        filterHolder.add(filterPartialOnly);
        filterHolder.add(filterNormalOnly);
        scaleContainer.add(filterCheckBoxScale);
        scaleContainer.add(filterComboBoxScale);
        filterHolder.add(scaleContainer);

        additionalFiltersPanel.add(filterHolder);

        JPanel topContainer = new JPanel();
        topContainer.setLayout(new BoxLayout(topContainer, BoxLayout.X_AXIS));

        topContainer.setPreferredSize(new Dimension(800, 300));
        topContainer.add(tabbedPane);
        topContainer.add(additionalFiltersPanel);
        setLabels(data);
        updateTable();
        container.setPreferredSize(new Dimension(800, 700));

        container.add(topContainer);
        container.add(tablePanel);

        JPanel splitLeftRight = new JPanel();
        splitLeftRight.setLayout(new BoxLayout(splitLeftRight, BoxLayout.X_AXIS));
        splitLeftRight.add(container);

        JPanel rightContainer = new JPanel();
        rightContainer.setPreferredSize(new Dimension(400, 700));
        rightContainer.setLayout(new BoxLayout(rightContainer, BoxLayout.Y_AXIS));

        JPanel rightTopContainer = getTitledPanel("Advanced Filters");
        rightTopContainer.setLayout(new GridLayout(3, 2));

        JPanel filterTimePanel = getTitledPanel("Filter by room or split time");
        filterTimePanel.setLayout(new BoxLayout(filterTimePanel, BoxLayout.Y_AXIS));

        JPanel filterPlayerPanel = getTitledPanel("Filter by players in a raid");
        filterPlayerPanel.setLayout(new GridLayout(2, 2));

        JPanel filterDatePanel = getTitledPanel("Filter by date");
        filterDatePanel.setLayout(new GridLayout(2, 2));

        JPanel filterOtherIntPanel = getTitledPanel("Filter by other condition (int)");
        filterOtherIntPanel.setLayout(new GridLayout(2, 2));

        JPanel filterOtherBoolPanel = getTitledPanel("Filter by other condition (bool)");
        filterOtherBoolPanel.setLayout(new GridLayout(2, 2));


        timeFilterChoice = new JComboBox<>(DataPoint.getTimeNames());

        String[] timeOperatorChoices =
                {
                        "=",
                        "<",
                        ">",
                        "<=",
                        ">="
                };

        timeFilterOperator = new JComboBox<>(timeOperatorChoices);


        timeFilterValue = new JTextField();

        JButton timeFilterAdd = new JButton("Add");
        timeFilterAdd.addActionListener(
                al ->
                {
                    String time = timeFilterValue.getText();
                    if (time.isEmpty())
                    {
                        return;
                    }
                    String timeStr = Objects.requireNonNull(timeFilterChoice.getSelectedItem()) + " " + Objects.requireNonNull(timeFilterOperator.getSelectedItem()) + " " + time;
                    activeFilters.add(new ImplicitFilter(new FilterTime(DataPoint.getValue(String.valueOf(timeFilterChoice.getSelectedItem())), timeFilterOperator.getSelectedIndex(), getTimeFromString(time), timeStr)));
                    updateFilterTable();
                });
        timeFilterAdd.setPreferredSize(new Dimension(55, timeFilterAdd.getPreferredSize().height));
        timeFilterOperator.setPreferredSize(new Dimension(50, timeFilterAdd.getPreferredSize().height));
        timeFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeFilterAdd.getPreferredSize().height));
        timeFilterChoice.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeFilterAdd.getPreferredSize().height));
        timeFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeFilterAdd.getPreferredSize().height));
        timeFilterValue.setPreferredSize(new Dimension(75, timeFilterAdd.getPreferredSize().height));


        JPanel filterTimePanelTop = new JPanel();
        filterTimePanelTop.setLayout(new BoxLayout(filterTimePanelTop, BoxLayout.X_AXIS));
        filterTimePanelTop.add(timeFilterChoice);

        JPanel filterTimePanelBottom = new JPanel();
        filterTimePanelBottom.setLayout(new BoxLayout(filterTimePanelBottom, BoxLayout.X_AXIS));
        filterTimePanelBottom.add(timeFilterOperator);
        filterTimePanelBottom.add(Box.createRigidArea(new Dimension(2, 2)));
        filterTimePanelBottom.add(timeFilterValue);
        filterTimePanelBottom.add(Box.createRigidArea(new Dimension(2, 2)));
        filterTimePanelBottom.add(timeFilterAdd);
        filterTimePanel.add(filterTimePanelTop);
        filterTimePanel.add(Box.createRigidArea(new Dimension(5, 5)));
        filterTimePanel.add(filterTimePanelBottom);

        String[] playersQualifier = {
                "contains exactly",
                "includes",
                "includes any of",
                "excludes",
                "excludes all of"
        };

        playerFilterOperator = new JComboBox<>(playersQualifier);
        playerFilterValue = new JTextField();
        JButton playerFilterAdd = new JButton("Add");
        playerFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, playerFilterAdd.getPreferredSize().height));
        playerFilterValue.setPreferredSize(new Dimension(75, playerFilterAdd.getPreferredSize().height));
        playerFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, playerFilterAdd.getPreferredSize().height));
        playerFilterAdd.setPreferredSize(new Dimension(55, playerFilterAdd.getPreferredSize().height));

        playerFilterAdd.addActionListener(
                al ->
                {
                    String filterStr = "Raid " + playerFilterOperator.getSelectedItem() + " " + playerFilterValue.getText();
                    activeFilters.add(new ImplicitFilter(new FilterPlayers(playerFilterValue.getText(), playerFilterOperator.getSelectedIndex(), filterStr)));
                    updateFilterTable();
                });

        JPanel filterPlayerPanelTop = new JPanel();
        filterPlayerPanelTop.setLayout(new BoxLayout(filterPlayerPanelTop, BoxLayout.X_AXIS));
        JPanel filterPlayerPanelBottom = new JPanel();
        filterPlayerPanelBottom.setLayout(new BoxLayout(filterPlayerPanelBottom, BoxLayout.X_AXIS));

        filterPlayerPanel.setLayout(new BoxLayout(filterPlayerPanel, BoxLayout.Y_AXIS));

        filterPlayerPanelTop.add(playerFilterOperator);
        filterPlayerPanelBottom.add(playerFilterValue);
        filterPlayerPanelBottom.add(Box.createRigidArea(new Dimension(2, 2)));
        filterPlayerPanelBottom.add(playerFilterAdd);

        filterPlayerPanel.add(filterPlayerPanelTop);
        filterPlayerPanel.add(Box.createRigidArea(new Dimension(5, 5)));
        filterPlayerPanel.add(filterPlayerPanelBottom);
        String[] choicesDate =
                {
                        "on",
                        "before",
                        "after"
                };

        dateFilterOperator = new JComboBox<>(choicesDate);
        JTextField dateFilterValue = new JTextField();
        dateFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, dateFilterValue.getPreferredSize().height));


        JButton dateFilterAdd = new JButton("Add");
        dateFilterAdd.addActionListener(
                al ->
                {
                    try
                    {
                        String dateString = dateTextField.getText();
                        String[] datePartial = dateString.split("/");
                        int year = Integer.parseInt(datePartial[0]);
                        int month = Integer.parseInt(datePartial[1]);
                        int day = Integer.parseInt(datePartial[2]);
                        Date date = new GregorianCalendar(year, month-1, day).getTime();
                        String filterStr = "Raid was " + dateFilterOperator.getSelectedItem() + " " + date;
                        activeFilters.add(new ImplicitFilter(new FilterDate(date, dateFilterOperator.getSelectedIndex(), filterStr)));
                    } catch (Exception ignored)
                    {

                    }
                    updateFilterTable();
                });

        dateFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, dateFilterAdd.getPreferredSize().height));
        dateFilterValue.setPreferredSize(new Dimension(90, dateFilterAdd.getPreferredSize().height));

        dateFilterAdd.setMaximumSize(new Dimension(Integer.MAX_VALUE, dateFilterAdd.getPreferredSize().height));
        dateFilterAdd.setPreferredSize(new Dimension(55, dateFilterAdd.getPreferredSize().height));

        JPanel dateTopRow = new JPanel();
        dateTopRow.setLayout(new BoxLayout(dateTopRow, BoxLayout.X_AXIS));

        JPanel dateBottomRow = new JPanel();
        dateBottomRow.setLayout(new BoxLayout(dateBottomRow, BoxLayout.X_AXIS));

        dateTopRow.add(dateFilterOperator);
        dateTopRow.add(Box.createRigidArea(new Dimension(2, 2)));
        dateTopRow.add(dateFilterAdd);
        dateTextField = new JTextField();
        dateBottomRow.add(dateTextField);
        dateBottomRow.add(Box.createRigidArea(new Dimension(5, 5)));
        dateBottomRow.add(new JLabel("YYYY/MM/DD"));
        filterDatePanel.setLayout(new BoxLayout(filterDatePanel, BoxLayout.Y_AXIS));
        filterDatePanel.add(dateTopRow);
        filterDatePanel.add(Box.createRigidArea(new Dimension(5, 5)));
        filterDatePanel.add(dateBottomRow);


        String[] otherIntOperatorChoices = {
                "=",
                "<",
                ">",
                "<=",
                ">="
        };


        otherIntFilterChoice = new JComboBox<>(DataPoint.getOtherIntNames());
        otherIntFilterOperator = new JComboBox<>(otherIntOperatorChoices);
        otherIntFilterValue = new JTextField();

        JButton otherIntAdd = new JButton("Add");
        otherIntAdd.addActionListener(
                al ->
                {
                    String filterStr = Objects.requireNonNull(otherIntFilterChoice.getSelectedItem()) + " " + Objects.requireNonNull(otherIntFilterOperator.getSelectedItem()) + " " + otherIntFilterValue.getText() + " ";
                    activeFilters.add(new ImplicitFilter(new FilterOtherInt(DataPoint.getValue(String.valueOf(otherIntFilterChoice.getSelectedItem())), otherIntFilterOperator.getSelectedIndex(), Integer.parseInt(otherIntFilterValue.getText()), filterStr)));
                    updateFilterTable();
                }
        );

        otherIntFilterChoice.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));

        otherIntFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));
        otherIntFilterValue.setPreferredSize(new Dimension(70, otherIntAdd.getPreferredSize().height));

        otherIntAdd.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));
        otherIntAdd.setPreferredSize(new Dimension(55, otherIntAdd.getPreferredSize().height));

        otherIntFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));
        otherIntFilterOperator.setPreferredSize(new Dimension(50, otherIntAdd.getPreferredSize().height));


        JPanel otherIntTop = new JPanel();
        otherIntTop.setLayout(new BoxLayout(otherIntTop, BoxLayout.X_AXIS));
        JPanel otherIntBottom = new JPanel();
        otherIntBottom.setLayout(new BoxLayout(otherIntBottom, BoxLayout.X_AXIS));

        otherIntTop.add(otherIntFilterChoice);
        otherIntBottom.add(otherIntFilterOperator);
        otherIntBottom.add(Box.createRigidArea(new Dimension(2, 2)));
        otherIntBottom.add(otherIntFilterValue);
        otherIntBottom.add(Box.createRigidArea(new Dimension(2, 2)));
        otherIntBottom.add(otherIntAdd);

        filterOtherIntPanel.setLayout(new BoxLayout(filterOtherIntPanel, BoxLayout.Y_AXIS));
        filterOtherIntPanel.add(otherIntTop);
        filterOtherIntPanel.add(Box.createRigidArea(new Dimension(5, 5)));
        filterOtherIntPanel.add(otherIntBottom);

        String[] choicesOtherBool = {
                "Maiden skip successful",
                "Reset after maiden",
                "Maiden wipe",
                "Reset after bloat",
                "Bloat wipe",
                "Reset after nylo",
                "Nylo wipe",
                "Reset after sote",
                "Sote wipe",
                "Reset after xarp",
                "Xarp wipe",
                "Verzik  wipe",
                "Maiden Scuffed",
        };

        String[] qualifierOtherBool = {
                "True",
                "False"
        };

        otherBoolFilterChoice = new JComboBox<>(choicesOtherBool);
        otherBoolFilterOperator = new JComboBox<>(qualifierOtherBool);

        JButton otherBoolAdd = new JButton("Add Filter");
        otherBoolAdd.addActionListener(
                al ->
                {
                    String filterStr = Objects.requireNonNull(otherBoolFilterChoice.getSelectedItem()) + " " + otherBoolFilterOperator.getSelectedItem();
                    activeFilters.add(new ImplicitFilter(new FilterOtherBool(otherBoolFilterChoice.getSelectedIndex(), otherBoolFilterOperator.getSelectedIndex() == 0, filterStr)));
                    updateFilterTable();
                }
        );

        otherBoolFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherBoolAdd.getPreferredSize().height));
        otherBoolFilterChoice.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherBoolAdd.getPreferredSize().height));

        JPanel filterBoolTop = new JPanel();
        filterBoolTop.setLayout(new BoxLayout(filterBoolTop, BoxLayout.X_AXIS));
        JPanel filterBoolBottom = new JPanel();
        filterBoolBottom.setLayout(new BoxLayout(filterBoolBottom, BoxLayout.X_AXIS));

        filterBoolTop.add(otherBoolFilterChoice);
        filterBoolBottom.add(otherBoolFilterOperator);
        filterBoolBottom.add(Box.createRigidArea(new Dimension(2, 2)));
        filterBoolBottom.add(otherBoolAdd);

        filterOtherBoolPanel.setLayout(new BoxLayout(filterOtherBoolPanel, BoxLayout.Y_AXIS));

        filterOtherBoolPanel.add(filterBoolTop);
        filterOtherBoolPanel.add(Box.createRigidArea(new Dimension(5, 5)));
        filterOtherBoolPanel.add(filterBoolBottom);

        JPanel filterOptions = getTitledPanel("Filter Options");
        rightTopContainer.setPreferredSize(new Dimension(400, 250));
        rightTopContainer.add(filterTimePanel);
        rightTopContainer.add(filterOtherIntPanel);
        rightTopContainer.add(filterPlayerPanel);
        rightTopContainer.add(filterOtherBoolPanel);
        rightTopContainer.add(filterDatePanel);


        JPanel rightBottomContainer = getTitledPanel("Active Filters");
        rightBottomContainer.setPreferredSize(new Dimension(400, 200));

        filterTableContainer = new JPanel();

        JPopupMenu raidPopup = new JPopupMenu();

        JMenuItem analyzeSessions = new JMenuItem("Analyze Sessions");
        analyzeSessions.setBackground(Color.BLACK);
        analyzeSessions.setOpaque(true);
        analyzeSessions.addActionListener(e ->
        {
            updateAliases();
            ArrayList<SimpleTOBData> rows = new ArrayList<>();
            int[] toRemove = table.getSelectedRows();
            for (int j : toRemove)
            {
                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));
            }
            Map<Integer, Map<String, ArrayList<SimpleTOBData>>> sessions = new LinkedHashMap<>();
            for (SimpleTOBData data12 : rows)
            {
                if (!sessions.containsKey(data12.players.size()))
                {
                    Map<String, ArrayList<SimpleTOBData>> scale = new LinkedHashMap<>();
                    ArrayList<SimpleTOBData> list = new ArrayList<>();
                    list.add(data12);
                    scale.put(data12.getPlayerList(aliases), list);
                    sessions.put(data12.players.size(), scale);
                } else
                {
                    if (!sessions.get(data12.players.size()).containsKey(data12.getPlayerList(aliases)))
                    {
                        ArrayList<SimpleTOBData> list = new ArrayList<>();
                        list.add(data12);
                        sessions.get(data12.players.size()).put(data12.getPlayerList(aliases), list);
                    } else
                    {
                        sessions.get(data12.players.size()).get(data12.getPlayerList(aliases)).add(data12);
                    }
                }
            }
            ArrayList<ArrayList<String>> labelSets = new ArrayList<>();
            Map<Integer, ArrayList<ArrayList<SimpleTOBData>>> dataSets = new LinkedHashMap<>();
            for (Integer scale : sessions.keySet())
            {
                ArrayList<ArrayList<SimpleTOBData>> scaleData = new ArrayList<>();
                ArrayList<String> labels = new ArrayList<>();
                for (String playerList : sessions.get(scale).keySet())
                {
                    scaleData.add(sessions.get(scale).get(playerList));
                    labels.add(playerList);
                }
                dataSets.put(scale, scaleData);
                labelSets.add(labels);
            }
            ComparisonViewFrame graphView = new ComparisonViewFrame(dataSets, labelSets, config, itemManager, clientThread, configManager);
            graphView.open();
        });


        JMenuItem addToComparison = new JMenuItem("Add set to comparison");
        addToComparison.setBackground(Color.BLACK);
        addToComparison.setOpaque(true);

        JMenuItem viewGraphs = new JMenuItem("View Graphs");
        viewGraphs.setBackground(Color.BLACK);
        viewGraphs.setOpaque(true);

        JMenuItem viewCharts = new JMenuItem("View Charts");
        viewCharts.setBackground(Color.BLACK);
        viewCharts.setOpaque(true);

        viewCharts.addActionListener(e ->
        {
            ArrayList<SimpleTOBData> rows = new ArrayList<>();
            int[] toRemove = table.getSelectedRows();
            for (int j : toRemove)
            {
                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));
            }
            ChartFrame roomCharts = new ChartFrame(rows, config, itemManager, clientThread, configManager);
            roomCharts.open();
        });

        viewGraphs.addActionListener(e ->
        {
            ArrayList<String> labels = new ArrayList<>();
            ArrayList<SimpleTOBData> rows = new ArrayList<>();
            int[] toRemove = table.getSelectedRows();
            for (int j : toRemove)
            {
                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));
            }
            if (rows.isEmpty())
            {
                new NoDataPopUp().open();
            } else
            {
                labels.add("");
                ArrayList<ArrayList<SimpleTOBData>> data1 = new ArrayList<>();
                data1.add(rows);
                ComparisonViewFrame graphView = new ComparisonViewFrame(data1, labels);
                graphView.open();
            }
        });

        addToComparison.addActionListener(e ->
        {
            ArrayList<SimpleTOBData> rows = new ArrayList<>();
            int[] toRemove = table.getSelectedRows();
            for (int j : toRemove)
            {
                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));
            }
            comparisons.add(rows);
            updateComparisonTable();
        });
        JMenuItem exportRaids = new JMenuItem("Export Selected Raids to CSV");
        exportRaids.setBackground(Color.BLACK);
        exportRaids.setOpaque(true);
        exportRaids.addActionListener(e ->
        {
            ArrayList<SimpleTOBData> rows = new ArrayList<>();
            int[] toRemove = table.getSelectedRows();
            for (int j : toRemove)
            {
                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));
            }
            new SaveRaids(rows).open();
        });

        JMenuItem filterRaids = new JMenuItem("Filter Selected Raids");
        filterRaids.setBackground(Color.BLACK);
        filterRaids.setOpaque(true);
        filterRaids.addActionListener(e ->
        {
            int[] toRemove = table.getSelectedRows();
            for (int j : toRemove)
            {
                filteredIndices.add(Integer.parseInt(table.getModel().getValueAt(j, 0).toString()));
            }

            updateTable();
        });

        JMenuItem filterExclusiveRaids = new JMenuItem("Filter All Except Selected Raids");
        filterExclusiveRaids.setBackground(Color.BLACK);
        filterExclusiveRaids.setOpaque(true);
        filterExclusiveRaids.addActionListener(e ->
        {
            int[] toKeep = table.getSelectedRows();
            for (int i = 0; i < table.getRowCount(); i++)
            {
                boolean found = false;
                for (int k : toKeep)
                {
                    if (i == k)
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                {
                    filteredIndices.add(Integer.parseInt(table.getModel().getValueAt(i, 0).toString()));
                }
            }

            updateTable();
        });
        JMenuItem analyzeCrabs = new JMenuItem("Analyze selection crab leaks");
        analyzeCrabs.setOpaque(true);
        analyzeCrabs.setBackground(Color.BLACK);
        analyzeCrabs.addActionListener(e ->
        {
            ArrayList<ArrayList<StringInt>> crabData = new ArrayList<>();
            int[] toRemove = table.getSelectedRows();
            for (int j : toRemove)
            {
                crabData.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())).maidenCrabs);
            }
            new CrabLeakInfo(crabData);
        });

        raidPopup.add(analyzeCrabs);
        raidPopup.add(exportRaids);
        raidPopup.add(addToComparison);
        raidPopup.add(filterRaids);
        raidPopup.add(filterExclusiveRaids);
        raidPopup.add(analyzeSessions);
        raidPopup.add(viewCharts);
        raidPopup.add(viewGraphs);
        table.setComponentPopupMenu(raidPopup);

        filterTable = new JTable();
        filterTable.setPreferredSize(new Dimension(380, 135));
        JScrollPane tableScrollView = new JScrollPane(filterTable);
        tableScrollView.setPreferredSize(new Dimension(380, 140));
        updateFilterTable();
        filterTableContainer.add(tableScrollView);

        rightBottomContainer.add(filterTableContainer);

        JButton saveFiltersButton = new JButton("Save");
        saveFiltersButton.addActionListener(
                al ->
                {
                    ArrayList<String> quickFiltersState = new ArrayList<>();
                    quickFiltersState.add("QF-Spectate Only:"+filterSpectateOnly.isSelected());
                    quickFiltersState.add("QF-In Raid Only:"+filterInRaidOnly.isSelected());
                    quickFiltersState.add("QF-Completion Only:"+filterCompletionOnly.isSelected());
                    quickFiltersState.add("QF-Wipe/Reset Only:"+filterWipeResetOnly.isSelected());
                    quickFiltersState.add("QF-Today Only:"+filterTodayOnly.isSelected());
                    quickFiltersState.add("QF-Party Only:"+filterPartyOnly.isSelected());
                    quickFiltersState.add("QF-Partial Raids:"+filterPartialData.isSelected());
                    quickFiltersState.add("QF-Partial Rooms:"+filterPartialOnly.isSelected());
                    quickFiltersState.add("QF-Normal Mode Only:"+filterNormalOnly.isSelected());
                    quickFiltersState.add("QF-Scale:"+filterCheckBoxScale.isSelected()+":"+filterComboBoxScale.getSelectedIndex());
                    quickFiltersState.add("QF-View Raid By:"+viewByRaidComboBox.getItemAt(viewByRaidComboBox.getSelectedIndex()));
                    quickFiltersState.add("QF-Table Sort By:"+sortOptionsBox.getItemAt(sortOptionsBox.getSelectedIndex()));
                    quickFiltersState.add("QF-Table Sort:"+sortOrderBox.getItemAt(sortOrderBox.getSelectedIndex()));
                    SaveFilter saveFilter = new SaveFilter(activeFilters, quickFiltersState);
                    saveFilter.open();
                });
        JButton loadFiltersButton = new JButton("Load");
        loadFiltersButton.addActionListener(
                al ->
                        new LoadFilter(this).open());
        JButton clearFiltersButton = new JButton("Clear");
        clearFiltersButton.addActionListener(
                al ->
                {
                    activeFilters.clear();
                    updateFilterTable();
                });
        GridLayout layout = new GridLayout(2, 2);
        layout.setHgap(2);
        layout.setVgap(2);
        filterOptions.setLayout(layout);

        filterOptions.add(saveFiltersButton);
        filterOptions.add(loadFiltersButton);
        filterOptions.add(clearFiltersButton);
        rightTopContainer.add(filterOptions);

        JPanel rightBottomBottomContainer = getTitledPanel("Comparison Options");
        rightBottomBottomContainer.setPreferredSize(new Dimension(400, 250));

        comparisonTable = new JTable();
        JScrollPane comparisonTableScroll = new JScrollPane(comparisonTable);
        comparisonTable.setPreferredSize(new Dimension(380, 170));
        comparisonTableScroll.setPreferredSize(new Dimension(380, 155));
        updateComparisonTable();

        JPanel rightBottomMostContainer = getTitledPanel("Alias Options");

        aliasText.setToolTipText("This applies to the tab names when you use the analyze sessions features. Syntax- Name to be displayed:oldname1,oldname2,oldname3");
        aliasText.getDocument().addDocumentListener(new DocumentListener()
        {
            @Override
            public void insertUpdate(DocumentEvent e)
            {
                try
                {
                    if (!writing)
                        DataWriter.writeAliasFile(e.getDocument().getText(0, e.getDocument().getLength()).replaceAll("\n", System.lineSeparator()));
                } catch (BadLocationException ignored)
                {
                }
            }

            @Override
            public void removeUpdate(DocumentEvent e)
            {
                try
                {
                    if (!writing)
                        DataWriter.writeAliasFile(e.getDocument().getText(0, e.getDocument().getLength()).replaceAll("\n", System.lineSeparator()));
                } catch (BadLocationException ignored)
                {
                }
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {
                try
                {
                    if (!writing)
                        DataWriter.writeAliasFile(e.getDocument().getText(0, e.getDocument().getLength()).replaceAll("\n", System.lineSeparator()));
                } catch (BadLocationException ignored)
                {
                }
            }
        });

        updateAliases();

        JScrollPane aliasScrollPane = new JScrollPane(aliasText);
        aliasScrollPane.setPreferredSize(new Dimension(380, 70));
        rightBottomMostContainer.add(aliasScrollPane);

        rightBottomBottomContainer.add(comparisonTableScroll);
        JButton viewComparisonsButton = new JButton("View Comparisons");
        viewComparisonsButton.addActionListener(al ->
        {
            if (comparisonTable.getModel().getRowCount() == 0)
            {
                new NoDataPopUp().open();
            } else
            {
                ArrayList<String> labels = new ArrayList<>();
                for (int i = 0; i < comparisonTable.getModel().getRowCount(); i++)
                {
                    labels.add(comparisonTable.getModel().getValueAt(i, 1).toString());
                }
                ComparisonViewFrame graphView = new ComparisonViewFrame(comparisons, labels);
                graphView.open();
            }
        });
        rightBottomBottomContainer.add(viewComparisonsButton);

        rightContainer.add(rightTopContainer);
        rightContainer.add(rightBottomContainer);
        rightContainer.add(rightBottomBottomContainer);
        rightContainer.add(rightBottomMostContainer);
        splitLeftRight.add(rightContainer);
        sortOrderBox.setSelectedIndex(1);

        add(splitLeftRight);
        pack();
        built = true;
    }

    public String[] columnHeaderNames = new String[]{"Date", "Time", "Scale", "Status", "Players", "Spectate", "View"};
    public ArrayList<JCheckBoxMenuItem> columnHeaders;

    private void getUpdatedPopupMenu(String newItem)
    {
        JCheckBoxMenuItem item = new JCheckBoxMenuItem(newItem);
        item.setOpaque(true);
        item.setBackground(Color.BLACK);
        item.setState(true);
        item.addActionListener(al ->
                updateTable());
        columnHeaders.add(item);
        table.getTableHeader().setComponentPopupMenu(getjPopupMenu());
        updateTable();
    }

    private JCheckBoxMenuItem getCheckBoxMenuItem(String name)
    {
        JCheckBoxMenuItem item = new JCheckBoxMenuItem(name);
        if (!name.equals("Time"))
        {
            item.setState(true);
        }
        item.setOpaque(true);
        item.setBackground(Color.BLACK);
        item.addActionListener(al ->
        {
            if (built)
            {
                updateTable();
            }
        });
        return item;
    }

    private JPopupMenu getjPopupMenu()
    {
        JPopupMenu baseMenu = new JPopupMenu();

        for (JCheckBoxMenuItem item : columnHeaders)
        {
            baseMenu.add(item);
        }

        List<String> allComboValues = new ArrayList<>(comboPopupData.keySet());

        comboStrictData = new ArrayList<>();

        JMenu addCustom = new JMenu("Add Custom");

        JMenuItem resetCustom = new JMenuItem("Reset Custom Columns");
        resetCustom.setOpaque(true);
        resetCustom.setBackground(Color.BLACK);

        resetCustom.addActionListener(al ->
        {
            columnHeaders.clear();
            for (String column : columnHeaderNames)
            {
                columnHeaders.add(getCheckBoxMenuItem(column));
            }
            table.getTableHeader().setComponentPopupMenu(getjPopupMenu());
            updateTable();
        });

        for (String category : allComboValues)
        {
            JMenu menu = new JMenu(category);
            menu.setBackground(Color.BLACK);
            menu.setOpaque(true);
            if (!category.equals("Room Times") && !category.equals("Any"))
            {
                JMenu timeMenu = new JMenu("Time");
                timeMenu.setBackground(Color.BLACK);
                timeMenu.setOpaque(true);
                for (String itemName : DataPoint.filterTimes(comboPopupData.get(category)))
                {
                    timeMenu.add(createMenuItemTableHeader(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu countMenu = new JMenu("Misc");
                countMenu.setBackground(Color.BLACK);
                countMenu.setOpaque(true);
                for (String itemName : DataPoint.filterInt(comboPopupData.get(category)))
                {
                    countMenu.add(createMenuItemTableHeader(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu thrallMenu = new JMenu("Thrall");
                thrallMenu.setBackground(Color.BLACK);
                thrallMenu.setOpaque(true);
                for (String itemName : DataPoint.filterThrall(comboPopupData.get(category)))
                {
                    thrallMenu.add(createMenuItemTableHeader(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu vengMenu = new JMenu("Veng");
                vengMenu.setBackground(Color.BLACK);
                vengMenu.setOpaque(true);
                for (String itemName : DataPoint.filterVeng(comboPopupData.get(category)))
                {
                    vengMenu.add(createMenuItemTableHeader(itemName));
                    comboStrictData.add(itemName);
                }

                JMenu specMenu = new JMenu("Spec");
                specMenu.setBackground(Color.BLACK);
                specMenu.setOpaque(true);
                for (String itemName : DataPoint.filterSpecs(comboPopupData.get(category)))
                {
                    specMenu.add(createMenuItemTableHeader(itemName));
                    comboStrictData.add(itemName);
                }

                menu.add(timeMenu);
                menu.add(countMenu);
                menu.add(thrallMenu);
                menu.add(vengMenu);
                menu.add(specMenu);
            } else
            {
                for (String itemName : comboPopupData.get(category))
                {
                    menu.add(createMenuItemTableHeader(itemName));
                    comboStrictData.add(itemName);
                }
            }
            addCustom.add(menu);
        }
        JMenu playerSpecificMenu = new JMenu("Player Specific");
        playerSpecificMenu.setBackground(Color.BLACK);
        playerSpecificMenu.setOpaque(true);
        String[] qualifiers = new String[]{"Maiden", "Bloat", "Nylo", "Sote", "Xarp", "Verz", "deaths"};

        for (String s : qualifiers)
        {
            JMenu room = new JMenu(s);
            room.setBackground(Color.BLACK);
            room.setOpaque(true);
            for (String qualified : DataPoint.getPlayerSpecific())
            {
                if (qualified.contains(s))
                {
                    room.add(createMenuItemTableHeader("Player: " + qualified));
                    comboStrictData.add("Player: " + qualified);
                }
            }
            playerSpecificMenu.add(room);
        }
        JMenu room = new JMenu("Other");
        room.setBackground(Color.BLACK);
        room.setOpaque(true);
        for (String qualified : DataPoint.getPlayerSpecific())
        {
            boolean anyFlagged = false;
            for (String s : qualifiers)
            {
                if (qualified.contains(s))
                {
                    anyFlagged = true;
                    break;
                }
            }
            if (!anyFlagged)
            {
                room.add(createMenuItemTableHeader("Player: " + qualified));
                comboStrictData.add("Player: " + qualified);
            }
        }
        playerSpecificMenu.add(room);

        addCustom.setOpaque(true);
        addCustom.setBackground(Color.BLACK);
        addCustom.add(playerSpecificMenu);
        baseMenu.add(addCustom);
        baseMenu.add(resetCustom);

        return baseMenu;
    }

    private int getTimeFromString(String text)
    {
        int ticks = 0;
        String sub = text;
        if (sub.contains(":"))
        {
            ticks += 100 * Integer.parseInt(sub.substring(0, sub.indexOf(":")));
            sub = text.substring(sub.indexOf(":") + 1);
        }
        ticks += (int) ((Double.parseDouble(sub) / 0.6));
        return ticks;
    }

    public void removeFilterRow(int row)
    {
        activeFilters.remove(row);
        updateFilterTable();
    }

    public void removeComparisonRow(int row)
    {
        comparisons.remove(row);
        updateComparisonTable();
    }

    private void updateComparisonTable()
    {
        String[] columnNames = {"Sets", "Label", ""};
        ArrayList<Object[]> tableData = new ArrayList<>();

        int index = 0;
        for (ArrayList<SimpleTOBData> comparison : comparisons)
        {
            Object[] row = {comparison.size() + " raids averaging: " + RoomUtil.time(StatisticGatherer.getOverallTimeAverage(comparison)), "Set " + index, "Remove"};
            tableData.add(row);
            index++;
        }

        Object[][] tableObject = new Object[tableData.size()][2];
        int count = 0;
        for (Object[] row : tableData)
        {
            tableObject[count] = row;
            count++;
        }
        comparisonTable.setModel(new DefaultTableModel(tableObject, columnNames));
        comparisonTable.getColumn("Sets").setCellEditor(new NonEditableCell(new JTextField()));
        comparisonTable.getColumn("").setCellRenderer(new ButtonRenderer());
        comparisonTable.getColumn("").setCellEditor(new ButtonEditorComparisonData(new JCheckBox(), this));
        resizeColumnWidthFilters(comparisonTable);
        comparisonTable.getColumn("").setMaxWidth(100);
        comparisonTable.setFillsViewportHeight(true);
        comparisonTable.validate();
        comparisonTable.repaint();
    }

    public void setFilterState(String state)
    {
        try
        {
            if (state.contains(":"))
            {
                String[] data = state.split(":");
                if (data.length > 1)
                {
                    switch (data[0])
                    {
                        case "Spectate Only":
                            filterSpectateOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "In Raid Only":
                            filterInRaidOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Completion Only":
                            filterCompletionOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Wipe/Reset Only":
                            filterWipeResetOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Today Only":
                            filterTodayOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Party Only":
                            filterPartyOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Partial Raids":
                            filterPartialOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Partial Rooms":
                            filterPartialData.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Normal Mode Only":
                            filterNormalOnly.setSelected(Boolean.parseBoolean(data[1]));
                            break;
                        case "Scale":
                            if(data.length > 2)
                            {
                                filterCheckBoxScale.setSelected(Boolean.parseBoolean(data[1]));
                                filterComboBoxScale.setSelectedIndex(Integer.parseInt(data[2]));
                            }
                            break;
                        case "View Raid By":
                            viewByRaidComboBox.setEditable(true);
                            if(!Objects.equals(data[1], "null"))
                            {
                                viewByRaidComboBox.setSelectedItem(data[1]);
                            }
                            else
                            {
                                viewByRaidComboBox.setSelectedItem("Challenge Time");
                            }
                            viewByRaidComboBox.setEditable(false);
                            break;
                        case "Table Sort By":
                            sortOptionsBox.setSelectedItem(data[1]);
                            break;
                        case "Table Sort":
                            sortOrderBox.setSelectedItem(data[1]);
                            break;
                    }
                }
            }
        }
        catch (Exception e)
        {
            log.info("Failed to set filter state: " + state);
        }
    }

    public void updateFilterTable()
    {
        String[] columnNames = {"Filter Descriptions", ""};
        ArrayList<Object[]> tableData = new ArrayList<>();

        for (ImplicitFilter filter : activeFilters)
        {
            Object[] row = {filter.getFilterDescription(), "Remove"};
            tableData.add(row);
        }

        Object[][] tableObject = new Object[tableData.size()][2];
        int count = 0;
        for (Object[] row : tableData)
        {
            tableObject[count] = row;
            count++;
        }
        filterTable.setModel(new DefaultTableModel(tableObject, columnNames));
        filterTable.setDefaultRenderer(Object.class, new StripedTableRowCellRenderer());
        filterTable.getColumn("Filter Descriptions").setCellEditor(new NonEditableCell(new JTextField()));
        filterTable.getColumn("").setCellRenderer(new ButtonRenderer());
        filterTable.getColumn("").setCellEditor(new ButtonEditorFilterData(new JCheckBox(), this));
        resizeColumnWidthFilters(filterTable);
        filterTable.getColumn("").setMaxWidth(100);
        filterTable.setFillsViewportHeight(true);
        filterTableContainer.validate();
        filterTableContainer.repaint();
        updateTable();
    }
}

package com.advancedraidtracker.ui.crableaks;

import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.utility.RoomUtil;
import com.advancedraidtracker.utility.wrappers.StringInt;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;

public class CrabLeakInfo extends BaseFrame
{

    public CrabLeakInfo(ArrayList<ArrayList<StringInt>> crabs)
    {
        JPanel primary = new JPanel();
        Map<String, Integer> crabLeakSums = new LinkedHashMap<>();
        primary.setBorder(BorderFactory.createTitledBorder("Crab Leak Info (Based on " + crabs.size() + " Raids)"));
        for (ArrayList<StringInt> crabData : crabs)
        {
            for (StringInt crab : crabData)
            {
                if (crabLeakSums.containsKey(crab.string))
                {
                    crabLeakSums.put(crab.string, crabLeakSums.get(crab.string) + crab.val);
                } else
                {
                    crabLeakSums.put(crab.string, crab.val);
                }
            }
        }

        primary.setLayout(new GridLayout(1, 0, 2, 2));

        JPanel panel70s = new JPanel();
        JPanel panel50s = new JPanel();
        JPanel panel30s = new JPanel();
        panel70s.setLayout(new GridLayout(0, 2, 2, 2));
        panel50s.setLayout(new GridLayout(0, 2, 2, 2));
        panel30s.setLayout(new GridLayout(0, 2, 2, 2));
        panel70s.setBorder(BorderFactory.createTitledBorder("70s"));
        panel50s.setBorder(BorderFactory.createTitledBorder("50s"));
        panel30s.setBorder(BorderFactory.createTitledBorder("30s"));

        Color color = new Color(30, 30, 30);
        for (int i = 0; i < 3; i++)
        {
            JLabel test = new JLabel("Crab");
            test.setOpaque(true);
            test.setBackground(Color.BLACK);

            JLabel test2 = new JLabel("Average HP", SwingConstants.RIGHT);
            test2.setOpaque(true);
            test2.setBackground(Color.BLACK);

            JPanel currentPanel = (i == 0) ? panel70s : (i == 1) ? panel50s : panel30s;

            currentPanel.add(test);
            currentPanel.add(test2);
            for (int j = 0; j < 10; j++)
            {
                int averageTemp = 0;
                String crabDescription = RoomUtil.MAIDEN_CRAB_NAMES[(i * 10) + j];
                try
                {
                    averageTemp = (int) ((crabLeakSums.get(RoomUtil.MAIDEN_CRAB_NAMES[(i * 10) + j]) / (double) crabs.size()) * 100);
                } catch (Exception ignored)
                {

                }
                double average = averageTemp / 100.0;

                JLabel desc = new JLabel(crabDescription, SwingConstants.LEFT);
                JLabel avg = new JLabel(String.valueOf(average), SwingConstants.RIGHT);

                if (j % 2 == 0)
                {
                    desc.setOpaque(true);
                    avg.setOpaque(true);
                    avg.setBackground(color);
                    desc.setBackground(color);
                }
                currentPanel.add(desc);
                currentPanel.add(avg);
            }
        }
        primary.add(panel70s);
        primary.add(panel50s);
        primary.add(panel30s);

        add(primary);
        pack();
        open();
    }
}

package com.advancedraidtracker.ui;


import com.formdev.flatlaf.FlatClientProperties;

import com.formdev.flatlaf.ui.FlatNativeWindowBorder;


import javax.swing.*;

public class BaseFrame extends JFrame
{
    public BaseFrame()
    {
        JRootPane rp = getRootPane();
        if (FlatNativeWindowBorder.isSupported())
        {
            rp.putClientProperty(FlatClientProperties.USE_WINDOW_DECORATIONS, true);
        }
        setDefaultCloseOperation(DISPOSE_ON_CLOSE);
    }

    public void open()
    {
        setVisible(true);
        toFront();
        repaint();
    }

    public void close()
    {
        setVisible(false);
    }
}

package com.advancedraidtracker.ui.buttons;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

public class StripedTableRowCellRenderer extends DefaultTableCellRenderer
{
    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
    {
        Component cell = new DefaultTableCellRenderer().getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        if(row % 2 == 0 && !isSelected)
        {
            cell.setBackground(new Color(20, 20, 20));
        }
        return cell;
    }
}

package com.advancedraidtracker.ui.buttons;

import javax.swing.*;
import javax.swing.table.TableCellRenderer;
import java.awt.*;

public class ButtonRenderer extends JButton implements TableCellRenderer
{

    public ButtonRenderer()
    {
        setOpaque(true);
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value,
                                                   boolean isSelected, boolean hasFocus, int row, int column)
    {
        if (isSelected)
        {
            setForeground(table.getSelectionForeground());
            setBackground(table.getSelectionBackground());
        } else
        {
            setForeground(table.getForeground());
        }
        setText((value == null) ? "" : value.toString());
        return this;
    }
}


package com.advancedraidtracker.ui.buttons;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.ui.viewraid.ViewTOBRaid;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

public class ButtonEditorRoomData extends DefaultCellEditor
{

    protected JButton button;
    private String label;
    private boolean isPushed;
    private final ArrayList<SimpleTOBData> data;
    int row;

    public ButtonEditorRoomData(JCheckBox checkBox, ArrayList<SimpleTOBData> data)
    {
        super(checkBox);
        this.data = data;
        button = new JButton();
        button.setOpaque(true);
        button.addActionListener(e -> fireEditingStopped());
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)
    {
        if (isSelected)
        {
            button.setForeground(table.getSelectionForeground());
            button.setBackground(table.getSelectionBackground());
        } else
        {
            button.setForeground(table.getForeground());
            button.setBackground(table.getBackground());
        }
        label = (value == null) ? "" : value.toString();
        button.setText(label);
        isPushed = true;
        this.row = row;
        return button;
    }

    @Override
    public Object getCellEditorValue()
    {
        if (isPushed)
        {
            ViewTOBRaid raid = new ViewTOBRaid(data.get(row));
            //ViewRaidFrame raid = new ViewRaidFrame(data.get(row));
            raid.open();
        }
        isPushed = false;
        return label;
    }

    @Override
    public boolean stopCellEditing()
    {
        isPushed = false;
        return super.stopCellEditing();
    }
}

package com.advancedraidtracker.ui.buttons;

import javax.swing.*;
import java.util.EventObject;

public class NonEditableCell extends DefaultCellEditor
{
    public NonEditableCell(JTextField textField)
    {
        super(textField);
        textField.addActionListener(e -> fireEditingStopped());
    }

    protected void fireEditingStopped()
    {
        super.fireEditingStopped();
    }

    @Override
    public boolean isCellEditable(EventObject anEvent)
    {
        return false;
    }

}

package com.advancedraidtracker.ui.buttons;

import com.advancedraidtracker.ui.Raids;

import javax.swing.*;
import java.awt.*;
public class ButtonEditorComparisonData extends DefaultCellEditor
{
    protected JButton button;
    private String label;
    private boolean isPushed;
    private final Raids frame;
    int row;

    public ButtonEditorComparisonData(JCheckBox checkBox, Raids raidsFrame)
    {
        super(checkBox);
        frame = raidsFrame;
        button = new JButton();
        button.setOpaque(true);
        button.addActionListener(e -> fireEditingStopped());
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)
    {
        if (isSelected)
        {
            button.setForeground(table.getSelectionForeground());
            button.setBackground(table.getSelectionBackground());
        } else
        {
            button.setForeground(table.getForeground());
            button.setBackground(table.getBackground());
        }
        label = (value == null) ? "" : value.toString();
        button.setText(label);
        isPushed = true;
        this.row = row;
        return button;
    }

    @Override
    public Object getCellEditorValue()
    {
        if (isPushed)
        {
            frame.removeComparisonRow(row);
        }
        isPushed = false;
        return label;
    }

    @Override
    public boolean stopCellEditing()
    {
        isPushed = false;
        return super.stopCellEditing();
    }
}

package com.advancedraidtracker.ui.buttons;

import com.advancedraidtracker.ui.Raids;

import javax.swing.*;
import java.awt.*;

public class ButtonEditorFilterData extends DefaultCellEditor
{
    protected JButton button;
    private String label;
    private boolean isPushed;
    private final Raids frame;
    int row;

    public ButtonEditorFilterData(JCheckBox checkBox, Raids raidsFrame)
    {
        super(checkBox);
        frame = raidsFrame;
        button = new JButton();
        button.setOpaque(true);
        button.addActionListener(e -> fireEditingStopped());
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)
    {
        if (isSelected)
        {
            button.setForeground(table.getSelectionForeground());
            button.setBackground(table.getSelectionBackground());
        } else
        {
            button.setForeground(table.getForeground());
            button.setBackground(table.getBackground());
        }
        label = (value == null) ? "" : value.toString();
        button.setText(label);
        isPushed = true;
        this.row = row;
        return button;
    }

    @Override
    public Object getCellEditorValue()
    {
        if (isPushed)
        {
            frame.removeFilterRow(row);
        }
        isPushed = false;
        return label;
    }

    @Override
    public boolean stopCellEditing()
    {
        isPushed = false;
        return super.stopCellEditing();
    }
}

package com.advancedraidtracker.ui.buttons;

import com.advancedraidtracker.filters.Filter;
import com.advancedraidtracker.filters.ImplicitFilter;
import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.ui.Raids;
import com.advancedraidtracker.ui.filters.LoadFilter;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

@Slf4j
public class ButtonEditorLoadFilters extends DefaultCellEditor
{

    protected JButton button;
    private String label;
    private boolean isPushed;
    private final boolean replace;
    int row;
    private final ArrayList<Filter> data;
    private final BaseFrame closeBaseFrame;
    private final Raids filteredRaidsFrame;

    public ButtonEditorLoadFilters(JCheckBox checkBox, Raids filteredRaidsFrame, ArrayList<Filter> data, LoadFilter loadFrame)
    {
        super(checkBox);
        this.data = data;
        this.replace = true;
        this.filteredRaidsFrame = filteredRaidsFrame;
        this.closeBaseFrame = loadFrame;
        button = new JButton();
        button.setOpaque(true);
        button.addActionListener(e -> fireEditingStopped());
    }

    public ButtonEditorLoadFilters(JCheckBox checkBox, Raids filteredRaidsFrame, ArrayList<Filter> data, LoadFilter loadFrame, boolean replace)
    {
        super(checkBox);
        this.data = data;
        this.filteredRaidsFrame = filteredRaidsFrame;
        this.closeBaseFrame = loadFrame;
        button = new JButton();
        button.setOpaque(true);
        this.replace = replace;
        button.addActionListener(e -> fireEditingStopped());
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)
    {
        if (isSelected)
        {
            button.setForeground(table.getSelectionForeground());
            button.setBackground(table.getSelectionBackground());
        } else
        {
            button.setForeground(table.getForeground());
            button.setBackground(table.getBackground());
        }
        label = (value == null) ? "" : value.toString();
        button.setText(label);
        isPushed = true;
        this.row = row;
        return button;
    }

    @Override
    public Object getCellEditorValue()
    {
        if (isPushed)
        {

            if (replace)
                filteredRaidsFrame.activeFilters.clear();
            for (String s : data.get(row).getFilters())
            {
                if(!s.startsWith("QF-"))
                {
                    filteredRaidsFrame.activeFilters.add(new ImplicitFilter(s));
                }
                else
                {
                    filteredRaidsFrame.setFilterState(s.substring(3));
                }
            }
            filteredRaidsFrame.updateFilterTable();
            closeBaseFrame.close();
        }
        isPushed = false;
        return label;
    }

    @Override
    public boolean stopCellEditing()
    {
        isPushed = false;
        return super.stopCellEditing();
    }
}

package com.advancedraidtracker.ui.buttons;

import com.advancedraidtracker.filters.Filter;
import com.advancedraidtracker.ui.filters.ViewFilter;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

public class ButtonEditorViewFilters extends DefaultCellEditor
{

    protected JButton button;
    private String label;
    private boolean isPushed;
    int row;
    private final ArrayList<Filter> data;

    public ButtonEditorViewFilters(JCheckBox checkBox, ArrayList<Filter> data)
    {
        super(checkBox);
        this.data = data;
        button = new JButton();
        button.setOpaque(true);
        button.addActionListener(e -> fireEditingStopped());
    }

    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)
    {
        if (isSelected)
        {
            button.setForeground(table.getSelectionForeground());
            button.setBackground(table.getSelectionBackground());
        } else
        {
            button.setForeground(table.getForeground());
            button.setBackground(table.getBackground());
        }
        label = (value == null) ? "" : value.toString();
        button.setText(label);
        isPushed = true;
        this.row = row;
        return button;
    }


    @Override
    public Object getCellEditorValue()
    {
        if (isPushed)
        {
            ViewFilter frame = new ViewFilter(data.get(row));
            frame.open();
        }
        isPushed = false;
        return label;
    }

    @Override
    public boolean stopCellEditing()
    {
        isPushed = false;
        return super.stopCellEditing();
    }
}

package com.advancedraidtracker.ui.viewraid;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.utility.RoomUtil;
import com.advancedraidtracker.utility.datautility.DataPoint;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.awt.*;
import java.util.Calendar;

import static com.advancedraidtracker.utility.datautility.DataPoint.NYLO_LAST_DEAD;

@Slf4j
public class ViewTOBRaid extends BaseFrame
{
    String INCOMPLETE_MARKER = "-";

    public ViewTOBRaid(SimpleTOBData data)
    {
        String red = "<html><font color='#FF0000'>";
        String soft = "<html><font color='#666666'>";
        String dark = "<html><font color='#404040'>";
        String green = "<html><font color='#33FF33'>";
        String blue = "<html><font color='#6666DD'>";
        String white = "<html><font color='#BBBBBB'>";

        setTitle("View Raid");
        setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));

        JPanel thisSubPanel = new JPanel();
        thisSubPanel.setLayout(new GridLayout(2, 3));

        String maidenColor = (data.maidenTimeAccurate) ? green : (data.maidenStartAccurate || data.maidenEndAccurate) ? blue : red;
        String bloatColor = (data.bloatTimeAccurate) ? green : (data.bloatStartAccurate || data.bloatEndAccurate) ? blue : red;
        String nyloColor = (data.nyloTimeAccurate) ? green : (data.nyloStartAccurate || data.nyloEndAccurate) ? blue : red;
        String soteColor = (data.soteTimeAccurate) ? green : (data.soteStartAccurate || data.soteEndAccurate) ? blue : red;
        String xarpColor = (data.xarpTimeAccurate) ? green : (data.xarpStartAccurate || data.xarpEndAccurate) ? blue : red;
        String verzikColor = (data.verzikTimeAccurate) ? green : (data.verzikStartAccurate || data.verzikEndAccurate) ? blue : red;

        String maidenBodyColor = (data.maidenTimeAccurate) ? white : (data.maidenStartAccurate || data.maidenEndAccurate) ? soft : dark;
        String bloatBodyColor = (data.bloatTimeAccurate) ? white : (data.bloatStartAccurate || data.bloatEndAccurate) ? soft : dark;
        String nyloBodyColor = (data.nyloTimeAccurate) ? white : (data.nyloStartAccurate || data.nyloEndAccurate) ? soft : dark;
        String soteBodyColor = (data.soteTimeAccurate) ? white : (data.soteStartAccurate || data.soteEndAccurate) ? soft : dark;
        String xarpBodyColor = (data.xarpTimeAccurate) ? white : (data.xarpStartAccurate || data.xarpEndAccurate) ? soft : dark;
        String verzikBodyColor = (data.verzikTimeAccurate) ? white : (data.verzikStartAccurate || data.verzikEndAccurate) ? soft : dark;

        JPanel maidenPanel = new JPanel();
        maidenPanel.setLayout(new BorderLayout());

        int maidenEntry = 0;
        int maidenSplit = data.getMaidenTime();

        int bloatEntry = maidenEntry + maidenSplit;
        int bloatSplit = data.getBloatTime();

        int nyloEntry = bloatEntry + bloatSplit;
        int nyloSplit = data.getNyloTime();

        int soteEntry = nyloEntry + nyloSplit;
        int soteSplit = data.getSoteTime();

        int xarpEntry = soteEntry + soteSplit;
        int xarpSplit = data.getXarpTime();

        int verzikEntry = xarpEntry + xarpSplit;

        String bloatSplitStr = RoomUtil.time(bloatSplit);

        String nyloEntryStr = RoomUtil.time(nyloEntry);
        String nyloSplitStr = RoomUtil.time(nyloSplit);

        String soteEntryStr = RoomUtil.time(soteEntry);
        String soteSplitStr = RoomUtil.time(soteSplit);

        String xarpEntryStr = RoomUtil.time(xarpEntry);
        String xarpSplitStr = RoomUtil.time(xarpSplit);

        String verzikEntryStr = RoomUtil.time(verzikEntry);

        maidenPanel.setBorder(BorderFactory.createTitledBorder(maidenColor + "Maiden" + ((data.maidenScuffed) ? " (Scuffed after " + data.firstMaidenCrabScuffed + ")" : "")));

        JPanel bloatPanel = new JPanel();
        bloatPanel.setLayout(new BorderLayout());
        bloatPanel.setBorder(BorderFactory.createTitledBorder(bloatColor + "Bloat - " + bloatBodyColor + nyloEntryStr + " (" + bloatSplitStr + ")"));

        JPanel nylocasPanel = new JPanel();
        nylocasPanel.setLayout(new BorderLayout());
        nylocasPanel.setBorder(BorderFactory.createTitledBorder(nyloColor + "Nylocas - " + nyloBodyColor + soteEntryStr + " (" + nyloSplitStr + ")"));

        JPanel sotetsegPanel = new JPanel();
        sotetsegPanel.setLayout(new BorderLayout());
        sotetsegPanel.setBorder(BorderFactory.createTitledBorder(soteColor + "Sotetseg - " + soteBodyColor + xarpEntryStr + " (" + soteSplitStr + ")"));

        JPanel xarpusPanel = new JPanel();
        xarpusPanel.setLayout(new BorderLayout());
        xarpusPanel.setBorder(BorderFactory.createTitledBorder(xarpColor + "Xarpus - " + xarpBodyColor + verzikEntryStr + " (" + xarpSplitStr + ")"));

        JPanel verzikPanel = new JPanel();
        verzikPanel.setLayout(new BorderLayout());
        verzikPanel.setBorder(BorderFactory.createTitledBorder(verzikColor + "Verzik"));

        JPanel maidenSubPanel = new JPanel();
        GridLayout gl = new GridLayout(10, 2);
        maidenSubPanel.setLayout(gl);

        maidenSubPanel.add(new JLabel(maidenBodyColor + "Blood Spawned (thrown)"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_BLOOD_SPAWNED) + " (" + data.getValue(DataPoint.MAIDEN_BLOOD_THROWN) + ")"));


        maidenSubPanel.add(new JLabel(maidenBodyColor + "Defense"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + ((data.maidenDefenseAccurate) ? data.getValue(DataPoint.MAIDEN_DEFENSE) : INCOMPLETE_MARKER)));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "Crabs leaked"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_CRABS_LEAKED) + ", HP: " + data.getValue(DataPoint.MAIDEN_HP_HEALED)));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "100% leaked"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_CRABS_LEAKED_FULL_HP)));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "Scuffed?"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + ((data.maidenScuffed) ? data.firstMaidenCrabScuffed : "No")));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "Deaths"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_DEATHS)));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "70s"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getValue(DataPoint.MAIDEN_70_SPLIT))));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "50s"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getValue(DataPoint.MAIDEN_50_SPLIT)) + " (" + RoomUtil.time(data.getValue(DataPoint.MAIDEN_50_SPLIT) - data.getValue(DataPoint.MAIDEN_70_SPLIT)) + ")"));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "30s"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getValue(DataPoint.MAIDEN_30_SPLIT)) + " (" + RoomUtil.time(data.getValue(DataPoint.MAIDEN_30_SPLIT) - data.getValue(DataPoint.MAIDEN_50_SPLIT)) + ")"));

        maidenSubPanel.add(new JLabel(maidenBodyColor + "Room time"));
        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getMaidenTime()) + " (" + RoomUtil.time(data.getMaidenTime() - data.getValue(DataPoint.MAIDEN_30_SPLIT)) + ")"));

        JPanel bloatSubPanel = new JPanel();
        bloatSubPanel.setLayout(new GridLayout(8, 2));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "Downs"));
        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_DOWNS)));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "Deaths (1st walk)"));
        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_FIRST_WALK_DEATHS)));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "Deaths (Total)"));
        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_DEATHS)));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "Defense (1st walk)"));
        bloatSubPanel.add(new JLabel(bloatBodyColor + ((data.bloatDefenseAccurate) ?String.valueOf(data.getValue(DataPoint.BLOAT_DEFENSE)) : INCOMPLETE_MARKER)));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "Scythes 1st walk"));
        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_FIRST_WALK_SCYTHES)));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "HP % 1st down"));

        bloatSubPanel.add(new JLabel(bloatBodyColor + (((double) data.getValue(DataPoint.BLOAT_HP_FIRST_DOWN))) + "%"));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "1st down time"));
        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_FIRST_DOWN_TIME)));

        bloatSubPanel.add(new JLabel(bloatBodyColor + "Room time"));
        bloatSubPanel.add(new JLabel(bloatBodyColor + RoomUtil.time(data.getBloatTime())));


        JPanel nylocasSubPanel = new JPanel();
        nylocasSubPanel.setLayout(new GridLayout(9, 2));

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Stalls"));
        nylocasSubPanel.add(new JLabel(nyloBodyColor + data.getValue(DataPoint.NYLO_STALLS_PRE_20) + " " + data.getValue(DataPoint.NYLO_STALLS_POST_20) + " (" + (data.getValue(DataPoint.NYLO_STALLS_TOTAL)) + ")"));

        String nyloSplits = "<html><font color='#999999'>"
                + data.getValue(DataPoint.NYLO_SPLITS_MELEE)
                + "<font color='#00AA00'> "
                + data.getValue(DataPoint.NYLO_SPLITS_RANGE)
                + "<font color ='#2299FF'> "
                + data.getValue(DataPoint.NYLO_SPLITS_MAGE);
        if (nyloBodyColor.equals(dark))
        {
            nyloSplits = nyloBodyColor
                    + data.getValue(DataPoint.NYLO_SPLITS_MELEE) + " "
                    + data.getValue(DataPoint.NYLO_SPLITS_RANGE) + " "
                    + data.getValue(DataPoint.NYLO_SPLITS_MAGE);
        } else if (nyloBodyColor.equals(soft))
        {
            nyloSplits = "<html><font color='#444444'>"
                    + data.getValue(DataPoint.NYLO_SPLITS_MELEE) + "<font color='#008800'> "
                    + data.getValue(DataPoint.NYLO_SPLITS_RANGE) + "<font color ='#0066CC'> "
                    + data.getValue(DataPoint.NYLO_SPLITS_MAGE);
        }
        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Splits"));
        nylocasSubPanel.add(new JLabel(nyloSplits));

        String nyloRotations = "<html><font color='#999999'>"
                + data.getValue(DataPoint.NYLO_ROTATIONS_MELEE) + "<font color='#00AA00'> "
                + data.getValue(DataPoint.NYLO_ROTATIONS_RANGE) + "<font color ='#2299FF'> "
                + data.getValue(DataPoint.NYLO_ROTATIONS_MAGE);

        if (nyloBodyColor.equals(dark))
        {
            nyloRotations = nyloBodyColor
                    + data.getValue(DataPoint.NYLO_ROTATIONS_MELEE) + " "
                    + data.getValue(DataPoint.NYLO_ROTATIONS_RANGE) + " "
                    + data.getValue(DataPoint.NYLO_ROTATIONS_MAGE);
        } else if (nyloBodyColor.equals(soft))
        {
            nyloRotations = "<html><font color='#444444'>"
                    + data.getValue(DataPoint.NYLO_ROTATIONS_MELEE) + "<font color='#008800'> "
                    + data.getValue(DataPoint.NYLO_ROTATIONS_RANGE) + "<font color ='#0066CC'> "
                    + data.getValue(DataPoint.NYLO_ROTATIONS_MAGE);
        }

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Rotations"));
        nylocasSubPanel.add(new JLabel(nyloRotations));

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Defense"));
        nylocasSubPanel.add(new JLabel(nyloBodyColor + ((data.nyloDefenseAccurate) ? String.valueOf(data.getValue(DataPoint.NYLO_DEFENSE)) : INCOMPLETE_MARKER)));

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Deaths"));
        nylocasSubPanel.add(new JLabel(nyloBodyColor + data.getValue(DataPoint.NYLO_DEATHS)));

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Last wave"));
        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getValue(DataPoint.NYLO_LAST_WAVE))));

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Clean up"));
        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getValue(NYLO_LAST_DEAD)) + " (" + RoomUtil.time(data.getValue(NYLO_LAST_DEAD) - data.getValue(DataPoint.NYLO_LAST_WAVE)) + ")"));

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Boss Spawn"));
        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getValue(DataPoint.NYLO_BOSS_SPAWN)) + " (" + RoomUtil.time(data.getValue(DataPoint.NYLO_BOSS_SPAWN) - data.getValue(NYLO_LAST_DEAD)) + ")"));

        nylocasSubPanel.add(new JLabel(nyloBodyColor + "Time"));
        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getNyloTime()) + " (" + RoomUtil.time(data.getNyloTime() - data.getValue(DataPoint.NYLO_BOSS_SPAWN)) + ")"));

        JPanel sotetsegSubPanel = new JPanel();
        sotetsegSubPanel.setLayout(new GridLayout(8, 2));

        sotetsegSubPanel.add(new JLabel(soteBodyColor + "Hammers hit"));
        sotetsegSubPanel.add(new JLabel(soteBodyColor + ((data.soteDefenseAccurate) ? data.getValue(DataPoint.SOTE_SPECS_P1) + " " + data.getValue(DataPoint.SOTE_SPECS_P2) + " " + data.getValue(DataPoint.SOTE_SPECS_P3) + " (" + (data.getValue(DataPoint.SOTE_SPECS_TOTAL)) + ")" : INCOMPLETE_MARKER)));

        sotetsegSubPanel.add(new JLabel(soteBodyColor + "Deaths"));
        sotetsegSubPanel.add(new JLabel(soteBodyColor + data.getValue(DataPoint.SOTE_DEATHS)));

        sotetsegSubPanel.add(new JLabel(soteBodyColor + "First Maze Start"));
        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_P1_SPLIT))));

        sotetsegSubPanel.add(new JLabel(soteBodyColor + "First Maze End"));
        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_M1_SPLIT)) + " (" + RoomUtil.time(data.getValue(DataPoint.SOTE_M1_SPLIT) - data.getValue(DataPoint.SOTE_P1_SPLIT)) + ")"));

        sotetsegSubPanel.add(new JLabel(soteBodyColor + "Second Maze Start"));
        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_P2_SPLIT)) + " (" + RoomUtil.time(data.getValue(DataPoint.SOTE_P2_SPLIT) - data.getValue(DataPoint.SOTE_M1_SPLIT)) + ")"));

        sotetsegSubPanel.add(new JLabel(soteBodyColor + "Second Maze End"));
        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_M2_SPLIT)) + " (" + RoomUtil.time(data.getValue(DataPoint.SOTE_M2_SPLIT) - data.getValue(DataPoint.SOTE_P2_SPLIT)) + ")"));

        sotetsegSubPanel.add(new JLabel(soteBodyColor + "Time"));
        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getSoteTime()) + " (" + RoomUtil.time(data.getSoteTime() - data.getValue(DataPoint.SOTE_M2_SPLIT)) + ")"));

        JPanel xarpusSubPanel = new JPanel();
        xarpusSubPanel.setLayout(new GridLayout(8, 2));

        xarpusSubPanel.add(new JLabel(xarpBodyColor + "Defense"));
        xarpusSubPanel.add(new JLabel(xarpBodyColor + ((data.xarpDefenseAccurate) ? data.getValue(DataPoint.XARP_DEFENSE) : INCOMPLETE_MARKER)));

        xarpusSubPanel.add(new JLabel(xarpBodyColor + "Deaths"));
        xarpusSubPanel.add(new JLabel(xarpBodyColor + data.getValue(DataPoint.XARP_DEATHS)));

        xarpusSubPanel.add(new JLabel(xarpBodyColor + "Healing"));
        xarpusSubPanel.add(new JLabel(xarpBodyColor + data.getValue(DataPoint.XARP_HEALING)));

        xarpusSubPanel.add(new JLabel(xarpBodyColor + "Screech"));
        xarpusSubPanel.add(new JLabel(xarpBodyColor + RoomUtil.time(data.getValue(DataPoint.XARP_SCREECH))));

        xarpusSubPanel.add(new JLabel(xarpBodyColor + "Time"));
        xarpusSubPanel.add(new JLabel(xarpBodyColor + RoomUtil.time(data.getXarpTime()) + " (" + RoomUtil.time(data.getXarpTime() - data.getValue(DataPoint.XARP_SCREECH)) + ")"));

        xarpusSubPanel.add(new JLabel(""));
        xarpusSubPanel.add(new JLabel(""));

        xarpusSubPanel.add(new JLabel(""));
        xarpusSubPanel.add(new JLabel(""));

        xarpusSubPanel.add(new JLabel(""));
        xarpusSubPanel.add(new JLabel(""));

        JPanel verzikSubPanel = new JPanel();
        verzikSubPanel.setLayout(new GridLayout(8, 2));

        verzikSubPanel.add(new JLabel(verzikBodyColor + "Bounces"));
        verzikSubPanel.add(new JLabel(verzikBodyColor + data.getValue(DataPoint.VERZIK_BOUNCES)));

        verzikSubPanel.add(new JLabel(verzikBodyColor + "Deaths"));
        verzikSubPanel.add(new JLabel(verzikBodyColor + data.getValue(DataPoint.VERZIK_DEATHS)));

        verzikSubPanel.add(new JLabel(verzikBodyColor + "Crabs Spawned"));
        verzikSubPanel.add(new JLabel(verzikBodyColor + data.getValue(DataPoint.VERZIK_CRABS_SPAWNED)));

        verzikSubPanel.add(new JLabel(verzikBodyColor + "Phase 1"));
        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getValue(DataPoint.VERZIK_P1_SPLIT))));

        verzikSubPanel.add(new JLabel(verzikBodyColor + "Reds Proc"));
        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getValue(DataPoint.VERZIK_REDS_SPLIT)) + " (" + RoomUtil.time(data.getValue(DataPoint.VERZIK_REDS_SPLIT) - data.getValue(DataPoint.VERZIK_P1_SPLIT)) + ")"));

        verzikSubPanel.add(new JLabel(verzikBodyColor + "Phase 2"));
        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getValue(DataPoint.VERZIK_P2_SPLIT)) + " (" + RoomUtil.time(data.getValue(DataPoint.VERZIK_P2_SPLIT) - data.getValue(DataPoint.VERZIK_P1_SPLIT)) + ")"));

        verzikSubPanel.add(new JLabel(verzikBodyColor + "Time"));
        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getVerzikTime()) + " (" + RoomUtil.time(data.getVerzikTime() - data.getValue(DataPoint.VERZIK_P2_SPLIT)) + ")"));

        maidenPanel.add(maidenSubPanel);
        bloatPanel.add(bloatSubPanel);
        nylocasPanel.add(nylocasSubPanel);
        sotetsegPanel.add(sotetsegSubPanel);
        xarpusPanel.add(xarpusSubPanel);
        verzikPanel.add(verzikSubPanel);

        thisSubPanel.add(maidenPanel);
        thisSubPanel.add(bloatPanel);
        thisSubPanel.add(nylocasPanel);
        thisSubPanel.add(sotetsegPanel);
        thisSubPanel.add(xarpusPanel);
        thisSubPanel.add(verzikPanel);

        JPanel summaryPanel = new JPanel();
        summaryPanel.setLayout(new BorderLayout());
        summaryPanel.setBorder(BorderFactory.createTitledBorder("Summary"));
        summaryPanel.setMinimumSize(new Dimension(100, 30));
        Calendar cal = Calendar.getInstance();
        cal.setTime(data.raidStarted);
        String dateString = (cal.get(Calendar.MONTH) + 1) + "-" + cal.get(Calendar.DAY_OF_MONTH) + "-" + cal.get(Calendar.YEAR);
        JPanel summarySubPanel = new JPanel(new GridLayout(10, 1));
        summarySubPanel.add(new JLabel("Date: " + dateString));
        String scaleString = "";
        switch (data.getScale())
        {
            case 1:
                scaleString = "Solo";
                break;
            case 2:
                scaleString = "Duo";
                break;
            case 3:
                scaleString = "Trio";
                break;
            case 4:
                scaleString = "4 Man";
                break;
            case 5:
                scaleString = "5 Man";
                break;
        }
        summarySubPanel.add(new JLabel("Scale: " + scaleString));
        setSummaryStatus(data, summarySubPanel);
        summarySubPanel.add(new JLabel("Time: " + RoomUtil.time(data.getTimeSum())));
        summarySubPanel.add(new JLabel("Players:"));
        for (String player : data.players.keySet())
        {
            summarySubPanel.add(new JLabel("        " + player + " (" + data.players.get(player) + ")"));
        }

        summaryPanel.add(summarySubPanel);

        JPanel topPanel = new JPanel();
        topPanel.setLayout(new GridLayout(1, 3));
        topPanel.add(summaryPanel);

        JPanel thrallsPanel = new JPanel();
        thrallsPanel.setBorder(BorderFactory.createTitledBorder("Thralls"));
        thrallsPanel.setLayout(new GridLayout(7, 2));

        thrallsPanel.add(new JLabel("Total Thrall Hits: "));
        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_TOTAL)), SwingConstants.RIGHT));

        thrallsPanel.add(new JLabel("Maiden Thrall Hits: "));
        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_MAIDEN)), SwingConstants.RIGHT));

        thrallsPanel.add(new JLabel("Bloat Thrall Hits: "));
        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_BLOAT)), SwingConstants.RIGHT));

        thrallsPanel.add(new JLabel("Nylo Thrall Hits: "));
        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_NYLO)), SwingConstants.RIGHT));

        thrallsPanel.add(new JLabel("Sotetseg Thrall Hits: "));
        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_SOTE)), SwingConstants.RIGHT));

        thrallsPanel.add(new JLabel("Xarpus Thrall Hits: "));
        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_XARP)), SwingConstants.RIGHT));

        thrallsPanel.add(new JLabel("Verzik Thrall Hits: "));
        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_VERZIK)), SwingConstants.RIGHT));


        JPanel vengPanel = new JPanel();
        vengPanel.setBorder(BorderFactory.createTitledBorder("Venges"));
        vengPanel.setLayout(new GridLayout(8, 2));

        vengPanel.add(new JLabel("Venges"));
        vengPanel.add(new JLabel("(Procced/Cast): Damage"));

        vengPanel.add(new JLabel("All Rooms"));
        vengPanel.add(new JLabel("(" + data.getValue(DataPoint.VENG_PROCS_TOTAL) + "/" + data.getValue(DataPoint.VENG_CASTS_TOTAL) + "): " + data.getValue(DataPoint.VENG_DAMAGE_TOTAL), SwingConstants.RIGHT));

        vengPanel.add(new JLabel("Maiden"));
        vengPanel.add(new JLabel("(" + data.getValue(DataPoint.VENG_PROCS_MAIDEN) + "/" + data.getValue(DataPoint.VENG_CASTS_MAIDEN) + "): " + data.getValue(DataPoint.VENG_DAMAGE_MAIDEN), SwingConstants.RIGHT));

        vengPanel.add(new JLabel("Bloat"));
        vengPanel.add(new JLabel("(" + data.getValue(DataPoint.VENG_PROCS_BLOAT) + "/" + data.getValue(DataPoint.VENG_CASTS_BLOAT) + "): " + data.getValue(DataPoint.VENG_DAMAGE_BLOAT), SwingConstants.RIGHT));

        vengPanel.add(new JLabel("Nylo"));
        vengPanel.add(new JLabel("(" + data.getValue(DataPoint.VENG_PROCS_NYLO) + "/" + data.getValue(DataPoint.VENG_CASTS_NYLO) + "): " + data.getValue(DataPoint.VENG_DAMAGE_NYLO), SwingConstants.RIGHT));

        vengPanel.add(new JLabel("Sote"));
        vengPanel.add(new JLabel("(" + data.getValue(DataPoint.VENG_PROCS_SOTE) + "/" + data.getValue(DataPoint.VENG_CASTS_SOTE) + "): " + data.getValue(DataPoint.VENG_DAMAGE_SOTE), SwingConstants.RIGHT));

        vengPanel.add(new JLabel("Xarp"));
        vengPanel.add(new JLabel("(" + data.getValue(DataPoint.VENG_PROCS_XARP) + "/" + data.getValue(DataPoint.VENG_CASTS_XARP) + "): " + data.getValue(DataPoint.VENG_DAMAGE_XARP), SwingConstants.RIGHT));

        vengPanel.add(new JLabel("Verzik"));
        vengPanel.add(new JLabel("(" + data.getValue(DataPoint.VENG_PROCS_VERZIK) + "/" + data.getValue(DataPoint.VENG_CASTS_VERZIK) + "): " + data.getValue(DataPoint.VENG_DAMAGE_VERZIK), SwingConstants.RIGHT));

        topPanel.add(thrallsPanel);
        topPanel.add(vengPanel);

        add(topPanel);
        add(thisSubPanel);

        pack();
    }

    private static void setSummaryStatus(SimpleTOBData data, JPanel summarySubPanel)
    {
        String raidStatusString;
        if (data.maidenWipe)
        {
            raidStatusString = "Maiden Wipe";
        } else if (data.maidenReset)
        {
            raidStatusString = "Maiden Reset";
        } else if (data.bloatWipe)
        {
            raidStatusString = "Bloat Wipe";
        } else if (data.bloatReset)
        {
            raidStatusString = "Bloat Reset";
        } else if (data.nyloWipe)
        {
            raidStatusString = "Nylo Wipe";
        } else if (data.nyloReset)
        {
            raidStatusString = "Nylo Reset";
        } else if (data.soteWipe)
        {
            raidStatusString = "Sotetseg Wipe";
        } else if (data.soteReset)
        {
            raidStatusString = "Sotetseg Reset";
        } else if (data.xarpWipe)
        {
            raidStatusString = "Xarpus Wipe";
        } else if (data.xarpReset)
        {
            raidStatusString = "Xarpus Reset";
        } else if (data.verzikWipe)
        {
            raidStatusString = "Verzik Wipe";
        } else
        {
            raidStatusString = "Completion";
        }
        summarySubPanel.add(new JLabel("Raid Status: " + raidStatusString));
    }
}

package com.advancedraidtracker.ui.statistics;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.utility.RoomUtil;
import com.advancedraidtracker.utility.datautility.DataPoint;
import com.advancedraidtracker.utility.StatisticGatherer;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Objects;

import static com.advancedraidtracker.utility.UISwingUtility.getDarkJLabel;

@Slf4j
public class StatisticRoomPanel extends JPanel
{
    public enum stat
    {
        AVERAGE,
        MEDIAN,
        MODE,
        MINIMUM,
        MAXIMUM
    }

    private final ArrayList<JLabel> timeLabels;
    private final ArrayList<String> labelNames;
    private final stat type;

    public StatisticRoomPanel(ArrayList<SimpleTOBData> data, stat type, DataPoint.rooms room)
    {
        super();
        JPanel subPanel = new JPanel();
        this.type = type;
        timeLabels = new ArrayList<>();
        ArrayList<JLabel> nameLabels = new ArrayList<>();
        labelNames = DataPoint.getTimeNamesByRoom(room);
        for (String s : labelNames)
        {
            nameLabels.add(getDarkJLabel(s.substring(s.indexOf(' ') + 1), SwingConstants.LEFT));
            timeLabels.add(getDarkJLabel("-", SwingConstants.RIGHT));
        }
        String borderString = "";
        switch (type)
        {
            case AVERAGE:
                borderString = "Average";
                break;
            case MEDIAN:
                borderString = "Median";
                break;
            case MODE:
                borderString = "Mode";
                break;
            case MAXIMUM:
                borderString = "Maximum";
                break;
            case MINIMUM:
                borderString = "Minimum";
                break;
        }
        setLayout(new BorderLayout());
        setBorder(BorderFactory.createTitledBorder(borderString));
        subPanel.setLayout(new GridLayout(0, 2));
        for (int i = 0; i < labelNames.size(); i++)
        {
            subPanel.add(nameLabels.get(i));
            subPanel.add(timeLabels.get(i));
        }
        for (int i = labelNames.size(); i < 14; i++)
        {
            subPanel.add(new JLabel(""));
            subPanel.add(new JLabel(""));
        }
        subPanel.setPreferredSize(new Dimension(100, 200));
        JScrollPane scrollPane = new JScrollPane(subPanel);
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        add(scrollPane);
        updateLabels(data);
    }

    public void updateLabels(ArrayList<SimpleTOBData> data)
    {
        for (int i = 0; i < labelNames.size(); i++)
        {
            ArrayList<Integer> collectedData = new ArrayList<>();
            for (SimpleTOBData d : data)
            {
                if (d.getTimeAccurate(Objects.requireNonNull(DataPoint.getValue(labelNames.get(i)))))
                {
                    if (Objects.requireNonNull(DataPoint.getValue(labelNames.get(i))).type != DataPoint.types.TIME || d.getValue(labelNames.get(i)) != 0)
                    {
                        collectedData.add(d.getValue(labelNames.get(i)));
                    }
                }
            }
            double statistic = 0;
            switch (type)
            {
                case AVERAGE:
                    statistic = StatisticGatherer.getGenericAverage(collectedData);
                    break;
                case MEDIAN:
                    statistic = StatisticGatherer.getGenericMedian(collectedData);
                    break;
                case MODE:
                    statistic = StatisticGatherer.getGenericMode(collectedData);
                    break;
                case MINIMUM:
                    statistic = StatisticGatherer.getGenericMin(collectedData, true);
                    break;
                case MAXIMUM:
                    statistic = StatisticGatherer.getGenericMax(collectedData);
                    break;
            }
            timeLabels.get(i).setText(RoomUtil.time(statistic));
        }
        validate();
        repaint();
    }

}

package com.advancedraidtracker.ui.statistics;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.utility.datautility.DataPoint;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

public class StatisticTab extends JPanel
{
    private final ArrayList<StatisticRoomPanel> panels;
    DataPoint.rooms room;
    ArrayList<SimpleTOBData> data;

    public StatisticTab(ArrayList<SimpleTOBData> data, DataPoint.rooms room)
    {
        this.room = room;
        this.data = data;
        JPanel panel = new JPanel();
        panels = new ArrayList<>();
        panel.setLayout(new GridLayout(2, 3));
        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.AVERAGE, room));
        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MEDIAN, room));
        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MODE, room));
        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MINIMUM, room));
        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MAXIMUM, room));
        setLayout(new GridLayout(2, 3));
        for (StatisticRoomPanel roomPanel : panels)
        {
            add(roomPanel);
        }
        JPanel statistics = new JPanel();
        statistics.setBorder(BorderFactory.createTitledBorder("Statistics"));
        add(statistics);

        validate();
        repaint();
    }

    public void updateTab(ArrayList<SimpleTOBData> data)
    {
        for (StatisticRoomPanel roomPanel : panels)
        {
            roomPanel.updateLabels(data);
        }
    }


}

package com.advancedraidtracker.ui.filters;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.filters.ImplicitFilter;
import com.advancedraidtracker.filters.FilterManager;
import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.utility.datautility.RaidsManager;


import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

public class ConfirmationDialog extends BaseFrame
{
    public ConfirmationDialog(String filterName, ArrayList<ImplicitFilter> filters, JFrame root)
    {
        setTitle("Confirm");
        JPanel panelButtons = new JPanel(new GridLayout(1, 2));
        setLayout(new GridLayout(2, 1));
        add(new JLabel("Are you sure you want to overwrite filter " + filterName + "?"));
        JButton yesButton = new JButton("Yes");
        yesButton.addActionListener(e ->
        {
            FilterManager.saveOverwriteFilter(filterName, filters);
            close();
            root.setVisible(false);
        });
        JButton noButton = new JButton("No");
        noButton.addActionListener(e -> close());
        panelButtons.add(yesButton);
        panelButtons.add(noButton);
        add(panelButtons);
        pack();
        setLocationRelativeTo(null);
    }

    public ConfirmationDialog(String raidsName, ArrayList<SimpleTOBData> raids, JFrame root, int mark)
    {
        setTitle("Confirm");
        JPanel panelButtons = new JPanel(new GridLayout(1, 2));
        setLayout(new GridLayout(2, 1));
        add(new JLabel("Are you sure you want to overwrite raids " + raidsName + "?"));
        JButton yesButton = new JButton("Yes");
        yesButton.addActionListener(e ->
        {
            RaidsManager.saveOverwriteRaids(raidsName, raids);
            close();
            root.setVisible(false);
        });
        JButton noButton = new JButton("No");
        noButton.addActionListener(e -> close());
        panelButtons.add(yesButton);
        panelButtons.add(noButton);
        add(panelButtons);
        pack();
        setLocationRelativeTo(null);
    }
}

package com.advancedraidtracker.ui.filters;

import com.advancedraidtracker.filters.ImplicitFilter;
import com.advancedraidtracker.filters.FilterManager;
import com.advancedraidtracker.ui.BaseFrame;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;

public class SaveFilter extends BaseFrame
{
    private final JTextField field;

    public SaveFilter(ArrayList<ImplicitFilter> filters, ArrayList<String> quickFiltersState)
    {
        getContentPane().removeAll();
        setTitle("Save Filter");
        JPanel borderPanel = new JPanel(new BorderLayout());
        borderPanel.setBorder(BorderFactory.createTitledBorder("Save Filter"));
        JPanel subPanel = new JPanel();
        subPanel.setLayout(new GridLayout(1, 0));
        field = new JTextField();
        subPanel.add(new JLabel("Filter Name: "));
        subPanel.add(field);
        JButton saveButton = getSaveButton(filters, quickFiltersState);
        subPanel.add(saveButton);
        JButton saveButtonStrict = getSaveButton(filters);
        subPanel.add(saveButtonStrict);
        borderPanel.add(subPanel);
        add(borderPanel);
        pack();
        setLocationRelativeTo(null);
        repaint();
    }

    private JButton getSaveButton(ArrayList<ImplicitFilter> filters)
    {
        JButton saveButton = new JButton("Save just filter");
        saveButton.addActionListener(e ->
        {
            if (FilterManager.doesFilterExist(field.getText()))
            {
                ConfirmationDialog dialog = new ConfirmationDialog(field.getText(), filters, (JFrame) (SwingUtilities.getRoot((Component) e.getSource())));
                dialog.open();
            } else
            {
                FilterManager.saveFilter(field.getText(), filters);
                close();
            }
        });
        return saveButton;
    }

    private JButton getSaveButton(ArrayList<ImplicitFilter> filters, ArrayList<String> quickFiltersState)
    {
        JButton saveButton = new JButton("Save with quick filters");
        saveButton.addActionListener(e ->
        {
            if (FilterManager.doesFilterExist(field.getText()))
            {
                ConfirmationDialog dialog = new ConfirmationDialog(field.getText(), filters, (JFrame) (SwingUtilities.getRoot((Component) e.getSource())));
                dialog.open();
            } else
            {
                FilterManager.saveFilter(field.getText(), filters, quickFiltersState);
                close();
            }
        });
        return saveButton;
    }
}

package com.advancedraidtracker.ui.filters;

import com.advancedraidtracker.ui.BaseFrame;
import lombok.extern.slf4j.Slf4j;
import com.advancedraidtracker.filters.Filter;

import javax.swing.*;
import java.awt.*;

@Slf4j
public class ViewFilter extends BaseFrame
{
    public ViewFilter(Filter filter)
    {
        setTitle("View Filter");
        setPreferredSize(new Dimension(300, 300));
        JPanel mainPanel = new JPanel();
        mainPanel.setLayout(new BorderLayout());
        mainPanel.setBorder(BorderFactory.createTitledBorder("Filter Details"));
        JPanel pane = new JPanel();
        pane.setLayout(new GridLayout(10, 1));
        for (String s : filter.getFilters())
        {
            String[] splitString = s.split("-");
            if (splitString.length != 0)
            {
                JLabel label = new JLabel(splitString[splitString.length - 1]);
                pane.add(label);
            }
        }
        mainPanel.add(pane);
        add(mainPanel);
        pack();
        setLocationRelativeTo(null);
    }
}

package com.advancedraidtracker.ui.filters;

import com.advancedraidtracker.ui.buttons.ButtonEditorLoadFilters;
import com.advancedraidtracker.ui.buttons.ButtonEditorViewFilters;
import com.advancedraidtracker.ui.buttons.ButtonRenderer;
import com.advancedraidtracker.ui.BaseFrame;
import com.advancedraidtracker.ui.Raids;
import com.advancedraidtracker.ui.buttons.NonEditableCell;
import lombok.extern.slf4j.Slf4j;
import com.advancedraidtracker.filters.Filter;
import com.advancedraidtracker.filters.FilterManager;

import javax.swing.*;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import java.awt.*;
import java.util.ArrayList;

@Slf4j
public class LoadFilter extends BaseFrame
{
    public void resizeColumnWidth(JTable table)
    {
        final TableColumnModel columnModel = table.getColumnModel();
        for (int column = 0; column < table.getColumnCount(); column++)
        {
            int width = 30; // Min width
            for (int row = 0; row < table.getRowCount(); row++)
            {
                TableCellRenderer renderer = table.getCellRenderer(row, column);
                Component comp = table.prepareRenderer(renderer, row, column);
                width = Math.max(comp.getPreferredSize().width + 1, width);
            }
            if (width > 400)
            {
                width = 400;
            }
            columnModel.getColumn(column).setPreferredWidth(width);
        }
    }

    public LoadFilter(Raids FilteredRaidsFrame)
    {
        setTitle("Load Filters");
        JPanel mainPanel = new JPanel(new BorderLayout());
        mainPanel.setBorder(BorderFactory.createTitledBorder("Filters"));

        String[] columnNames = {"Filter Name", "View", "Replace", "Add"};
        ArrayList<Object[]> tableBuilder = new ArrayList<>();

        ArrayList<Filter> filters = FilterManager.getFilters();
        for (Filter filter : filters)
        {
            Object[] row =
                    {
                            filter.getName(),
                            "View Filter",
                            "Replace Active",
                            "Add to Active"
                    };
            tableBuilder.add(row);
        }
        Object[][] tableObject = new Object[filters.size()][4];
        int count = 0;
        for (Object[] row : tableBuilder)
        {
            tableObject[count] = row;
            count++;
        }
        JPanel container = new JPanel();
        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));
        JTable table = new JTable(tableObject, columnNames);
        table.getColumn("Filter Name").setCellEditor(new NonEditableCell(new JTextField()));

        table.getColumn("View").setCellRenderer(new ButtonRenderer());
        table.getColumn("View").setCellEditor(new ButtonEditorViewFilters(new JCheckBox(), filters));

        table.getColumn("Replace").setCellRenderer(new ButtonRenderer());
        table.getColumn("Replace").setCellEditor(new ButtonEditorLoadFilters(new JCheckBox(), FilteredRaidsFrame, filters, this));

        table.getColumn("Add").setCellRenderer(new ButtonRenderer());
        table.getColumn("Add").setCellEditor(new ButtonEditorLoadFilters(new JCheckBox(), FilteredRaidsFrame, filters, this, false));

        resizeColumnWidth(table);
        JScrollPane pane = new JScrollPane(table);
        table.setFillsViewportHeight(true);
        mainPanel.add(pane);
        add(mainPanel);
        pack();
        setLocationRelativeTo(null);
    }
}

package com.advancedraidtracker.ui.comparisonview;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.ui.comparisonview.graph.GraphPanel;
import com.advancedraidtracker.utility.RoomUtil;
import com.advancedraidtracker.utility.datautility.DataPoint;
import com.advancedraidtracker.utility.StatisticGatherer;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import javax.swing.*;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.*;

@Slf4j
public class ComparisonViewPanel extends JPanel
{
    private final JPanel container;
    private final JSlider leftCutOff;
    private final JSlider rightCutOff;
    private final JSlider threshold;

    private final JTextField leftLabel;
    private final JTextField rightLabel;
    private final JTextField thresholdLabel;

    private final JLabel graph1Average;
    private final JLabel graph1Median;
    private final JLabel graph1Maximum;
    private final JLabel graph1Minimum;
    private final JLabel graph1Mode;
    private final JPanel otherPanel = new JPanel();
    private final JLabel graph2Average;
    private final JLabel graph2Median;
    private final JLabel graph2Maximum;
    private final JLabel graph2Minimum;
    private final JLabel graph2Mode;

    private final JLabel graph1PercentThreshold;
    private final JLabel graph2PercentThreshold;

    private String panelName = "Other";
    private JPanel otherTopLeft;
    private JPanel otherTopRight;
    private JPanel otherBottomLeft;
    private JPanel otherBottomRight;
    private final JTabbedPane topGraphTabs;
    private final JTabbedPane bottomGraphTabs;
    private final JCheckBox matchYScales;

    private final JCheckBox matchXScales;

    private final JComboBox<String> compareByComboBox;
    private final JComboBox<String> graphTypeComboBox;
    private boolean time = false;
    ArrayList<ArrayList<SimpleTOBData>> data;

    JPanel scrollTopPanel;
    JPanel scrollBottomPanel;
    JScrollPane scrollTopGraphData;
    JScrollPane scrollBottomGraphData;
    ArrayList<GraphPanel> topGraphs;
    ArrayList<GraphPanel> bottomGraphs;
    ArrayList<String> labels;

    JSpinner groupSizeSpinner;
    SpinnerNumberModel spinnerSizeModel;
    SpinnerNumberModel spinnerOffsetModel;
    JSpinner groupOffsetSpinner;
    JLabel leftThresholdLabel;
    JLabel rightThresholdLabel;

    JCheckBox groupingEnabled;

    private final AdvancedRaidTrackerConfig config;
    private final ItemManager itemManager;
    private final ConfigManager configManager;

    private final ClientThread clientThread;
    public ComparisonViewPanel(ArrayList<ArrayList<SimpleTOBData>> raidData, ArrayList<String> names, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)
    {
        this.configManager = configManager;
        this.clientThread = clientThread;
        this.itemManager = itemManager;
        this.config = config;
        leftLabel = new JTextField("Min cutoff: ");
        rightLabel = new JTextField("Max cutoff: ");
        leftThresholdLabel = new JLabel("% <= ");
        rightThresholdLabel = new JLabel("% <= ");
        thresholdLabel = new JTextField("Threshold: ");
        thresholdLabel.setEditable(false);
        leftLabel.setEditable(false);
        rightLabel.setEditable(false);
        leftCutOff = new JSlider();
        rightCutOff = new JSlider();
        threshold = new JSlider();
        topGraphs = new ArrayList<>();
        bottomGraphs = new ArrayList<>();
        data = raidData;
        matchYScales = new JCheckBox("Match Y-Axis", true);
        matchXScales = new JCheckBox("Match X-Axis", true);

        spinnerSizeModel = new SpinnerNumberModel(1, 1, 100, 1);
        groupSizeSpinner = new JSpinner(spinnerSizeModel);

        spinnerOffsetModel = new SpinnerNumberModel(0, 0, 0, 1);
        groupOffsetSpinner = new JSpinner(spinnerOffsetModel);

        groupingEnabled = new JCheckBox("Enable Grouping?");
        groupingEnabled.setSelected(false);
        groupOffsetSpinner.setEnabled(false);
        groupSizeSpinner.setEnabled(false);

        graphTypeComboBox = new JComboBox<>(new String[]{"Bar Graph", "Pie Chart", "Line Plot"});

        graphTypeComboBox.addActionListener(e ->
        {
            for (GraphPanel panel : topGraphs)
            {
                panel.setGraphType(graphTypeComboBox.getSelectedIndex());
            }
            for (GraphPanel panel : bottomGraphs)
            {
                panel.setGraphType(graphTypeComboBox.getSelectedIndex());
            }
        });
        groupingEnabled.addActionListener(e ->
        {
            for (GraphPanel panel : topGraphs)
            {
                panel.setGroupingEnabled(groupingEnabled.isSelected());
                panel.updateGroupOffset((Integer) groupOffsetSpinner.getValue());
                panel.updateGroupSize((Integer) groupSizeSpinner.getValue());

            }
            for (GraphPanel panel : bottomGraphs)
            {
                panel.setGroupingEnabled(groupingEnabled.isSelected());
                panel.updateGroupOffset((Integer) groupOffsetSpinner.getValue());
                panel.updateGroupSize((Integer) groupSizeSpinner.getValue());


            }
            groupSizeSpinner.setEnabled(groupingEnabled.isSelected());
            groupOffsetSpinner.setEnabled(groupingEnabled.isSelected());

        });

        groupSizeSpinner.addChangeListener(e ->
        {
            for (GraphPanel panel : topGraphs)
            {
                panel.updateGroupSize((int) groupSizeSpinner.getValue());
            }
            for (GraphPanel panel : bottomGraphs)
            {
                panel.updateGroupSize((int) groupSizeSpinner.getValue());
            }
            spinnerOffsetModel.setMaximum((int) groupSizeSpinner.getValue() - 1);
        });

        groupOffsetSpinner.addChangeListener(e ->
        {
            for (GraphPanel panel : topGraphs)
            {
                panel.updateGroupOffset((int) groupOffsetSpinner.getValue());
            }
            for (GraphPanel panel : bottomGraphs)
            {
                panel.updateGroupOffset((int) groupOffsetSpinner.getValue());
            }
            spinnerSizeModel.setMinimum((int) groupOffsetSpinner.getValue() + 1);
        });


        labels = names;

        scrollTopPanel = new JPanel();
        scrollBottomPanel = new JPanel();

        scrollBottomGraphData = new JScrollPane(scrollBottomPanel);
        scrollTopGraphData = new JScrollPane(scrollTopPanel);

        graph1Average = new JLabel("", SwingConstants.RIGHT);
        graph1Median = new JLabel("", SwingConstants.RIGHT);
        graph1Mode = new JLabel("", SwingConstants.RIGHT);
        graph1Maximum = new JLabel("", SwingConstants.RIGHT);
        graph1Minimum = new JLabel("", SwingConstants.RIGHT);
        graph1PercentThreshold = new JLabel("", SwingConstants.RIGHT);

        graph2Average = new JLabel("", SwingConstants.RIGHT);
        graph2Median = new JLabel("", SwingConstants.RIGHT);
        graph2Mode = new JLabel("", SwingConstants.RIGHT);
        graph2Maximum = new JLabel("", SwingConstants.RIGHT);
        graph2Minimum = new JLabel("", SwingConstants.RIGHT);
        graph2PercentThreshold = new JLabel("", SwingConstants.RIGHT);

        topGraphTabs = new JTabbedPane();
        topGraphTabs.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
        topGraphTabs.addChangeListener(cl ->
        {
            switchGraphData();
            updateOtherPanels();
        });
        bottomGraphTabs = new JTabbedPane();
        bottomGraphTabs.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
        bottomGraphTabs.addChangeListener(cl ->
        {
            switchGraphData();
            updateOtherPanels();
        });

        Map<String, String[]> comboPopupData = new LinkedHashMap<>();
        comboPopupData.put("Room Times", DataPoint.getRoomTimes());
        comboPopupData.put("Maiden", DataPoint.getMaidenNames());
        comboPopupData.put("Bloat", DataPoint.getBloatNames());
        comboPopupData.put("Nylocas", DataPoint.getNyloNames());
        comboPopupData.put("Sotetseg", DataPoint.getSoteNames());
        comboPopupData.put("Xarpus", DataPoint.getXarpNames());
        comboPopupData.put("Verzik", DataPoint.getVerzikNames());
        comboPopupData.put("Any", DataPoint.getAnyRoomNames());

        comboPopupMenu = new JPopupMenu();
        comboPopupMenu.setBorder(new MatteBorder(1, 1, 1, 1, Color.DARK_GRAY));

        ArrayList<String> allComboValues = new ArrayList<>(comboPopupData.keySet());

        comboStrictData = new ArrayList<>();

        for (String category : allComboValues)
        {
            JMenu menu = new JMenu(category);
            menu.setBackground(Color.BLACK);
            menu.setOpaque(true);
            if (!category.equals("Room Times") && !category.equals("Any"))
            {
                JMenu timeMenu = new JMenu("Time");
                timeMenu.setBackground(Color.BLACK);
                timeMenu.setOpaque(true);
                for (String itemName : DataPoint.filterTimes(comboPopupData.get(category)))
                {
                    timeMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu countMenu = new JMenu("Misc");
                countMenu.setBackground(Color.BLACK);
                countMenu.setOpaque(true);
                for (String itemName : DataPoint.filterInt(comboPopupData.get(category)))
                {
                    countMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu thrallMenu = new JMenu("Thrall");
                thrallMenu.setBackground(Color.BLACK);
                thrallMenu.setOpaque(true);
                for (String itemName : DataPoint.filterThrall(comboPopupData.get(category)))
                {
                    thrallMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
                JMenu vengMenu = new JMenu("Veng");
                vengMenu.setBackground(Color.BLACK);
                vengMenu.setOpaque(true);
                for (String itemName : DataPoint.filterVeng(comboPopupData.get(category)))
                {
                    vengMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }

                JMenu specMenu = new JMenu("Spec");
                specMenu.setBackground(Color.BLACK);
                specMenu.setOpaque(true);
                for (String itemName : DataPoint.filterSpecs(comboPopupData.get(category)))
                {
                    specMenu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }

                menu.add(timeMenu);
                menu.add(countMenu);
                menu.add(thrallMenu);
                menu.add(vengMenu);
                menu.add(specMenu);
            } else
            {
                for (String itemName : comboPopupData.get(category))
                {
                    menu.add(createMenuItem(itemName));
                    comboStrictData.add(itemName);
                }
            }
            comboPopupMenu.add(menu);
        }
        compareByComboBox = new JComboBox<>();
        compareByComboBox.setEditable(true);
        compareByComboBox.setPrototypeDisplayValue("Maiden Time");
        compareByComboBox.setSelectedItem("Maiden Time");
        compareByComboBox.setEditable(false);
        for (Component comp : compareByComboBox.getComponents())
        {
            if (comp instanceof AbstractButton)
            {
                arrowButton = (AbstractButton) comp;
                arrowButton.setBackground(Color.BLACK);
            }
        }

        arrowButton.addActionListener(e -> setPopupVisible(!comboPopupMenu.isVisible()));

        compareByComboBox.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                setPopupVisible(!comboPopupMenu.isVisible());
            }
        });

        compareByComboBox.addActionListener(al ->
        {
            switchGraphData();
            updateOtherPanels();
        });

        matchYScales.addActionListener(al ->
                switchGraphData());

        matchXScales.addActionListener(al ->
        {
            switchGraphData();
            leftCutOff.setEnabled(matchXScales.isSelected());
            rightCutOff.setEnabled(matchXScales.isSelected());
        });

        container = new JPanel();
        container.setPreferredSize(new Dimension(1000, 730));
        container.setLayout(new BoxLayout(container, BoxLayout.X_AXIS));

        buildUI();
        add(container);
    }

    private int valX = 0;

    private final JPopupMenu comboPopupMenu;
    private final ArrayList<String> comboStrictData;
    private AbstractButton arrowButton;

    private void setComboSelection(String name)
    {
        Vector<String> items = new Vector<>();

        addComboItems(name, items, comboStrictData, compareByComboBox);
    }

    public static void addComboItems(String name, Vector<String> items, ArrayList<String> comboStrictData, JComboBox<String> compareByComboBox)
    {
        for (String item : comboStrictData)
        {
            if (item.endsWith(name))
            {
                items.add(item);
                break;
            }
        }

        compareByComboBox.setModel(new DefaultComboBoxModel<>(items));

        if (items.size() == 1)
        {
            compareByComboBox.setSelectedIndex(0);
        }
    }

    private JMenuItem createMenuItem(final String name)
    {
        JMenuItem item = new JMenuItem(name);
        item.setBackground(Color.BLACK);
        item.setOpaque(true);

        item.addActionListener(event -> setComboSelection(name));
        return item;
    }

    private void setPopupVisible(boolean visible)
    {
        if (visible)
        {
            comboPopupMenu.show(compareByComboBox, 0, compareByComboBox.getSize().height);
        } else
        {
            comboPopupMenu.setVisible(false);
        }
    }

    private void switchGraphData()
    {
        if (topGraphs.size() != bottomGraphs.size())
        {
            return;
        }
        int xHigh = 0;
        int xLow = Integer.MAX_VALUE;
        int yHigh = 0;
        if (!Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString().contains("Player:"))
        {
            time = Objects.requireNonNull(DataPoint.getValue(Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString())).type == DataPoint.types.TIME;
        } else
        {
            time = false;
        }

        for (int i = 0; i < topGraphs.size(); i++)
        {
            topGraphs.get(i).switchKey(Objects.requireNonNull(DataPoint.getValue(Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString())));
            bottomGraphs.get(i).switchKey(Objects.requireNonNull(DataPoint.getValue(Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString())));

            topGraphs.get(i).generateScales();
            bottomGraphs.get(i).generateScales();

            xHigh = Math.max(xHigh, topGraphs.get(i).getScaleXHigh());
            xHigh = Math.max(xHigh, bottomGraphs.get(i).getScaleXHigh());

            yHigh = Math.max(yHigh, topGraphs.get(i).getScaleYHigh());
            yHigh = Math.max(yHigh, bottomGraphs.get(i).getScaleYHigh());

            xLow = Math.min(xLow, topGraphs.get(i).getScaleXLow());
            xLow = Math.min(xLow, bottomGraphs.get(i).getScaleXLow());
        }


        leftCutOff.setMaximum(xHigh);
        leftCutOff.setMinimum(xLow);
        rightCutOff.setMaximum(xHigh);
        rightCutOff.setMinimum(xLow);

        threshold.setMaximum(xHigh);
        threshold.setMinimum(xLow);
        threshold.setValue(((xHigh - xLow) / 2) + xLow);
        setThresholdTimes();

        leftCutOff.setValue(xLow);
        rightCutOff.setValue(xLow);

        updateSliders();
        container.repaint();
        valX = xHigh;
        if (matchYScales.isSelected())
        {
            setYScales(yHigh);
        }
        if (matchXScales.isSelected())
        {
            setXScales(xLow, xHigh);
        }

        redrawGraphs();

    }

    private void setThresholdTimes()
    {
        thresholdLabel.setText("Threshold: " + ((time) ? RoomUtil.time(threshold.getValue()) : threshold.getValue()));
        leftThresholdLabel.setText("% <= " + ((time) ? RoomUtil.time(threshold.getValue()) : threshold.getValue()));
        rightThresholdLabel.setText("% <= " + ((time) ? RoomUtil.time(threshold.getValue()) : threshold.getValue()));
    }

    private void setXScales(int xLow, int xHigh)
    {
        for (int i = 0; i < topGraphs.size(); i++)
        {
            topGraphs.get(i).setScales(xLow, xHigh, topGraphs.get(i).getScaleYHigh());
            bottomGraphs.get(i).setScales(xLow, xHigh, bottomGraphs.get(i).getScaleYHigh());
        }
    }

    private void setYScales(int yHigh)
    {
        for (int i = 0; i < topGraphs.size(); i++)
        {
            topGraphs.get(i).setScales(topGraphs.get(i).getScaleXLow(), topGraphs.get(i).getScaleXHigh(), yHigh);
            bottomGraphs.get(i).setScales(bottomGraphs.get(i).getScaleXLow(), bottomGraphs.get(i).getScaleXHigh(), yHigh);
        }
    }

    private void redrawGraphs(int xLow, int xHigh)
    {
        for (int i = 0; i < topGraphs.size(); i++)
        {
            topGraphs.get(i).setScales(xLow, xHigh, topGraphs.get(i).getScaleYHigh());
            bottomGraphs.get(i).setScales(xLow, xHigh, bottomGraphs.get(i).getScaleYHigh());
            topGraphs.get(i).setBounds();
            topGraphs.get(i).drawGraph();
            bottomGraphs.get(i).setBounds();
            bottomGraphs.get(i).drawGraph();
        }
    }


    private void redrawGraphs()
    {
        for (int i = 0; i < topGraphs.size(); i++)
        {
            topGraphs.get(i).setBounds();
            topGraphs.get(i).drawGraph();
            bottomGraphs.get(i).setBounds();
            bottomGraphs.get(i).drawGraph();
        }
    }

    private void updateCutoffs()
    {
        if (matchXScales.isSelected())
        {
            redrawGraphs(leftCutOff.getValue(), rightCutOff.getMaximum() - rightCutOff.getValue() + rightCutOff.getMinimum());

        }
    }

    private void updateSliders()
    {
        int leftExtent = rightCutOff.getValue() - rightCutOff.getMinimum();
        int rightExtent = leftCutOff.getValue() - leftCutOff.getMinimum();
        rightCutOff.setExtent(rightExtent);
        leftCutOff.setExtent(leftExtent);

        //For some unbelievably bizarre reasons extents can only be set for the upper bound so we have to inverse it

        leftLabel.setText("Min cutoff: " + ((time) ? RoomUtil.time(leftCutOff.getValue()) : leftCutOff.getValue()));
        rightLabel.setText("Max cutoff: " + ((time) ? RoomUtil.time(rightCutOff.getMaximum() - rightCutOff.getValue() + rightCutOff.getMinimum()) : rightCutOff.getMaximum() - rightCutOff.getValue() + rightCutOff.getMinimum()));
        updateCutoffs();
    }

    GraphPanel getGraphPanel(ArrayList<SimpleTOBData> points)
    {
        return new GraphPanel(points, config, itemManager, clientThread, configManager);
    }

    private ArrayList<Integer> getArrayForStatistics(ArrayList<SimpleTOBData> data)
    {
        ArrayList<Integer> arrayToPass = new ArrayList<>();
        for (SimpleTOBData raidData : data)
        {
            int value = raidData.getValue(DataPoint.getValue(String.valueOf(compareByComboBox.getSelectedItem())));
            if (value > -1)
            {
                if (!time || value != 0)
                {
                    switch ((Objects.requireNonNull(DataPoint.getValue(String.valueOf(compareByComboBox.getSelectedItem())))).room)
                    {
                        case MAIDEN:
                            if (!raidData.maidenStartAccurate || !raidData.maidenEndAccurate)
                            {
                                continue;
                            }
                            break;
                        case BLOAT:
                            if (!raidData.bloatStartAccurate || !raidData.bloatEndAccurate)
                            {
                                continue;
                            }
                            break;
                        case NYLOCAS:
                            if (!raidData.nyloStartAccurate || !raidData.nyloEndAccurate)
                            {
                                continue;
                            }
                            break;
                        case SOTETSEG:
                            if (!raidData.soteStartAccurate || !raidData.soteEndAccurate)
                            {
                                continue;
                            }
                            break;
                        case XARPUS:
                            if (!raidData.xarpStartAccurate || !raidData.xarpEndAccurate)
                            {
                                continue;
                            }
                            break;
                        case VERZIK:
                            if (!raidData.verzikStartAccurate || !raidData.verzikEndAccurate)
                            {
                                continue;
                            }
                            break;
                    }
                    arrayToPass.add(value);
                }
            }
        }
        return arrayToPass;
    }

    private String getString(double val)
    {
        return (time) ? RoomUtil.time(val) : String.valueOf(Math.round(val * 100.0) / 100.0);
    }

    private void updateOtherPanels()
    {
        panelName = "Other - " + compareByComboBox.getSelectedItem();
        otherPanel.setBorder(BorderFactory.createTitledBorder(panelName));
        if (topGraphTabs.getSelectedIndex() != -1 && bottomGraphTabs.getSelectedIndex() != -1 && built)
        {
            otherTopLeft.setBorder(BorderFactory.createTitledBorder(topGraphTabs.getTitleAt(topGraphTabs.getSelectedIndex())));
            otherTopRight.setBorder(BorderFactory.createTitledBorder(bottomGraphTabs.getTitleAt(bottomGraphTabs.getSelectedIndex())));

            otherBottomLeft.setBorder(BorderFactory.createTitledBorder(topGraphTabs.getTitleAt(topGraphTabs.getSelectedIndex()) + " values"));
            otherBottomRight.setBorder(BorderFactory.createTitledBorder(bottomGraphTabs.getTitleAt(bottomGraphTabs.getSelectedIndex()) + " values"));

            ArrayList<SimpleTOBData> topGraphData = (data.get(topGraphTabs.getSelectedIndex()));
            ArrayList<SimpleTOBData> bottomGraphData = data.get(bottomGraphTabs.getSelectedIndex());

            String worse = "<html><font color='#F63131'>";
            String better = "<html><font color='#99E622'>";
            String even = "<html><font color='#CCCCF6'>";

            double g1a = StatisticGatherer.getGenericAverage(getArrayForStatistics(topGraphData));
            double g1med = StatisticGatherer.getGenericMedian(getArrayForStatistics(topGraphData));
            double g1mod = StatisticGatherer.getGenericMode(getArrayForStatistics(topGraphData));
            double g1max = StatisticGatherer.getGenericMax(getArrayForStatistics(topGraphData));
            double g1min = StatisticGatherer.getGenericMin(getArrayForStatistics(topGraphData));
            double g1percent = StatisticGatherer.getGenericPercent(getArrayForStatistics(topGraphData), threshold.getValue());

            double g2a = StatisticGatherer.getGenericAverage(getArrayForStatistics(bottomGraphData));
            double g2med = StatisticGatherer.getGenericMedian(getArrayForStatistics(bottomGraphData));
            double g2mod = StatisticGatherer.getGenericMode(getArrayForStatistics(bottomGraphData));
            double g2max = StatisticGatherer.getGenericMax(getArrayForStatistics(bottomGraphData));
            double g2min = StatisticGatherer.getGenericMin(getArrayForStatistics(bottomGraphData));
            double g2percent = StatisticGatherer.getGenericPercent(getArrayForStatistics(bottomGraphData), threshold.getValue());

            String g1as = (g1a < g2a) ? better : g2a == g1a ? even : worse;
            String g1meds = (g1med < g2med) ? better : g2med == g1med ? even : worse;
            String g1mods = (g1mod < g2mod) ? better : g2mod == g1mod ? even : worse;
            String g1maxs = (g1max < g2max) ? better : g2max == g1max ? even : worse;
            String g1mins = (g1min < g2min) ? better : g2min == g1min ? even : worse;
            String g1perc = (g1percent > g2percent) ? better : g1percent == g2percent ? even : worse;

            String g2as = (g1a > g2a) ? better : g2a == g1a ? even : worse;
            String g2meds = (g1med > g2med) ? better : g2med == g1med ? even : worse;
            String g2mods = (g1mod > g2mod) ? better : g2mod == g1mod ? even : worse;
            String g2maxs = (g1max > g2max) ? better : g2max == g1max ? even : worse;
            String g2mins = (g1min > g2min) ? better : g2min == g1min ? even : worse;
            String g2perc = (g2percent > g1percent) ? better : g1percent == g2percent ? even : worse;


            graph1Average.setText(g1as + getString(g1a));
            graph1Median.setText(g1meds + getString(g1med));
            graph1Mode.setText(g1mods + getString(g1mod));
            graph1Maximum.setText(g1maxs + getString(g1max));
            graph1Minimum.setText(g1mins + getString(g1min));
            graph1PercentThreshold.setText(g1perc + (g1percent) + "%");

            graph2Average.setText(g2as + getString(g2a));
            graph2Median.setText(g2meds + getString(g2med));
            graph2Mode.setText(g2mods + getString(g2mod));
            graph2Maximum.setText(g2maxs + getString(g2max));
            graph2Minimum.setText(g2mins + getString(g2min));
            graph2PercentThreshold.setText(g2perc + (g2percent) + "%");


            ArrayList<Integer> topSet = GraphPanel.getCounts(getArrayForStatistics(topGraphData), valX);
            ArrayList<Integer> bottomSet = GraphPanel.getCounts(getArrayForStatistics(bottomGraphData), valX);

            scrollTopPanel.removeAll();
            scrollBottomPanel.removeAll();

            scrollTopPanel.add(new JLabel("Value", SwingConstants.LEFT));
            scrollTopPanel.add(new JLabel("Count", SwingConstants.RIGHT));

            int total = GraphPanel.getCountedTotal(topSet);
            int count = 0;
            count = getCount(topSet, total, count, scrollTopPanel);

            int altCount = 0;
            for (int i = count; i < 16; i++)
            {
                scrollTopPanel.add(new JLabel());
                scrollTopPanel.add(new JLabel());
                altCount++;
            }
            scrollTopPanel.setLayout(new GridLayout(count + 1 + altCount, 2));
            count = 0;

            scrollBottomPanel.add(new JLabel("Value", SwingConstants.LEFT));
            scrollBottomPanel.add(new JLabel("Count", SwingConstants.RIGHT));

            total = GraphPanel.getCountedTotal(bottomSet);

            count = getCount(bottomSet, total, count, scrollBottomPanel);
            altCount = 0;
            for (int i = count; i < 16; i++)
            {
                scrollBottomPanel.add(new JLabel());
                scrollBottomPanel.add(new JLabel());
                altCount++;
            }
            scrollBottomPanel.setLayout(new GridLayout(count + 1 + altCount, 2));

            scrollTopPanel.validate();
            scrollBottomPanel.validate();
        }
        container.repaint();
    }

    private int getCount(ArrayList<Integer> topSet, double total, int count, JPanel scrollTopPanel)
    {
        for (int i = 0; i < topSet.size(); i++)
        {
            if (topSet.get(i) > 0)
            {
                String percent = Math.round((100.0 * topSet.get(i) / total) * 100.0) / 100.0 + "%";
                scrollTopPanel.add(new JLabel(getString(i), SwingConstants.LEFT));
                scrollTopPanel.add(new JLabel(topSet.get(i) + " (" + percent + ")", SwingConstants.RIGHT));
                count++;
            }
        }
        return count;
    }

    private boolean built = false;

    private void buildUI()
    {
        for (int i = 0; i < data.size(); i++)
        {
            GraphPanel topGraph = getGraphPanel(data.get(i));
            GraphPanel bottomGraph = getGraphPanel(data.get(i));
            topGraphTabs.addTab(labels.get(i), topGraph);
            bottomGraphTabs.addTab(labels.get(i), bottomGraph);
            topGraphs.add(topGraph);
            bottomGraphs.add(bottomGraph);
        }
        switchGraphData();

        JPanel leftContainer = new JPanel();
        leftContainer.setLayout(new BoxLayout(leftContainer, BoxLayout.Y_AXIS));

        leftContainer.add(topGraphTabs);
        leftContainer.add(bottomGraphTabs);

        container.add(leftContainer);

        JPanel sidebar = new JPanel();
        sidebar.setPreferredSize(new Dimension(390, 730));

        JPanel graphOptionsPanel = new JPanel();
        graphOptionsPanel.setBorder(BorderFactory.createTitledBorder("Graph Options"));
        graphOptionsPanel.setPreferredSize(new Dimension(210, 215));

        threshold.setPaintLabels(true);
        threshold.setPaintTicks(true);
        threshold.setPaintTrack(true);
        threshold.addChangeListener(cl ->
        {
            Object source = cl.getSource();
            if (source instanceof JSlider)
            {
                if (((JSlider) source).getValueIsAdjusting())
                {
                    setThresholdTimes();
                    updateOtherPanels();
                }
            }
        });
        threshold.setPreferredSize(new Dimension(180, threshold.getPreferredSize().height));
        leftCutOff.setPaintLabels(true);
        leftCutOff.setPaintTicks(true);
        leftCutOff.setPaintTrack(true);

        leftCutOff.addChangeListener(cl ->
        {
            Object source = cl.getSource();
            if (source instanceof JSlider)
            {
                if (((JSlider) source).getValueIsAdjusting())
                {
                    updateSliders();
                }
            }
        });

        rightCutOff.addChangeListener(cl ->
        {
            Object source = cl.getSource();
            if (source instanceof JSlider)
            {
                if (((JSlider) source).getValueIsAdjusting())
                {
                    updateSliders();
                }
            }
        });

        leftCutOff.setPreferredSize(new Dimension(180, leftCutOff.getPreferredSize().height));


        rightCutOff.setPaintTrack(true);
        rightCutOff.setPaintTicks(true);
        rightCutOff.setPaintLabels(true);

        rightCutOff.setInverted(true);

        rightCutOff.setPreferredSize(new Dimension(180, rightCutOff.getPreferredSize().height));


        graphOptionsPanel.add(leftCutOff);
        graphOptionsPanel.add(leftLabel);
        graphOptionsPanel.add(rightCutOff);
        graphOptionsPanel.add(rightLabel);
        graphOptionsPanel.add(matchXScales);
        graphOptionsPanel.add(matchYScales);

        graphOptionsPanel.add(new JLabel(""));

        graphOptionsPanel.add(groupingEnabled);
        graphOptionsPanel.add(new JLabel("Group Size: "));
        graphOptionsPanel.add(groupSizeSpinner);
        graphOptionsPanel.add(new JLabel("Group Offset: "));
        graphOptionsPanel.add(groupOffsetSpinner);

        graphOptionsPanel.add(new JCheckBox("Show Chronological"));
        graphOptionsPanel.add(new JCheckBox("Rotate 90"));

        graphOptionsPanel.add(graphTypeComboBox);

        graphOptionsPanel.add(threshold);
        thresholdLabel.setPreferredSize(new Dimension(140, thresholdLabel.getPreferredSize().height));
        graphOptionsPanel.add(thresholdLabel);

        JPanel compareByPanel = new JPanel();
        compareByPanel.setBorder(BorderFactory.createTitledBorder("Compare by"));
        compareByPanel.setPreferredSize(new Dimension(190, 60));
        compareByPanel.add(compareByComboBox);


        otherPanel.setBorder(BorderFactory.createTitledBorder(panelName));
        otherPanel.setPreferredSize(new Dimension(190, 455));
        otherPanel.setLayout(new BoxLayout(otherPanel, BoxLayout.Y_AXIS));


        JPanel otherTop = new JPanel();
        otherTop.setLayout(new BoxLayout(otherTop, BoxLayout.X_AXIS));

        JPanel otherBottom = new JPanel();
        otherBottom.setLayout(new BoxLayout(otherBottom, BoxLayout.X_AXIS));

        otherTopLeft = new JPanel();
        otherTopLeft.setBorder(BorderFactory.createTitledBorder("Set 0"));
        otherTopLeft.setPreferredSize(new Dimension(100, 125));

        otherTopRight = new JPanel();
        otherTopRight.setBorder(BorderFactory.createTitledBorder("Set 1"));
        otherTopRight.setPreferredSize(new Dimension(100, 125));

        otherTop.add(otherTopLeft);
        otherTop.add(otherTopRight);

        otherBottomLeft = new JPanel();
        otherBottomLeft.setBorder(BorderFactory.createTitledBorder("Values"));

        otherTopLeft.setLayout(new GridLayout(6, 2));
        otherTopRight.setLayout(new GridLayout(6, 2));


        otherTopLeft.add(new JLabel("Average ", SwingConstants.LEFT));
        otherTopLeft.add(graph1Average);
        otherTopLeft.add(new JLabel("Median ", SwingConstants.LEFT));
        otherTopLeft.add(graph1Median);
        otherTopLeft.add(new JLabel("Mode ", SwingConstants.LEFT));
        otherTopLeft.add(graph1Mode);
        otherTopLeft.add(new JLabel("Maximum ", SwingConstants.LEFT));
        otherTopLeft.add(graph1Maximum);
        otherTopLeft.add(new JLabel("Minimum ", SwingConstants.LEFT));
        otherTopLeft.add(graph1Minimum);
        otherTopLeft.add(leftThresholdLabel);
        otherTopLeft.add(graph1PercentThreshold);

        otherTopRight.add(new JLabel("Average ", SwingConstants.LEFT));
        otherTopRight.add(graph2Average);
        otherTopRight.add(new JLabel("Median ", SwingConstants.LEFT));
        otherTopRight.add(graph2Median);
        otherTopRight.add(new JLabel("Mode ", SwingConstants.LEFT));
        otherTopRight.add(graph2Mode);
        otherTopRight.add(new JLabel("Maximum ", SwingConstants.LEFT));
        otherTopRight.add(graph2Maximum);
        otherTopRight.add(new JLabel("Minimum ", SwingConstants.LEFT));
        otherTopRight.add(graph2Minimum);
        otherTopRight.add(rightThresholdLabel);
        otherTopRight.add(graph2PercentThreshold);

        otherBottomRight = new JPanel();
        otherBottomRight.setBorder(BorderFactory.createTitledBorder("Values"));

        scrollTopGraphData.setPreferredSize(new Dimension(150, 250));
        scrollBottomGraphData.setPreferredSize(new Dimension(150, 250));

        scrollTopGraphData.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrollBottomGraphData.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        otherBottomLeft.add(scrollTopGraphData);
        otherBottomRight.add(scrollBottomGraphData);


        otherBottom.add(otherBottomLeft);
        otherBottom.add(otherBottomRight);

        scrollTopPanel.validate();
        scrollBottomPanel.validate();


        otherPanel.add(otherTop);
        otherPanel.add(otherBottom);

        sidebar.setLayout(new BoxLayout(sidebar, BoxLayout.Y_AXIS));

        sidebar.add(compareByPanel);
        sidebar.add(graphOptionsPanel);
        sidebar.add(otherPanel);

        built = true;
        updateOtherPanels();

        container.add(sidebar);
    }
}

package com.advancedraidtracker.ui.comparisonview;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.ui.BaseFrame;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Map;

@Slf4j
public class ComparisonViewFrame extends BaseFrame
{
    public ComparisonViewFrame(ArrayList<ArrayList<SimpleTOBData>> data, ArrayList<String> labels)
    {
        add(new ComparisonViewPanel(data, labels, config, itemManager, clientThread, configManager));
        pack();
    }

    private AdvancedRaidTrackerConfig config;
    private ItemManager itemManager;
    private ClientThread clientThread;
    private ConfigManager configManager;

    public ComparisonViewFrame(Map<Integer, ArrayList<ArrayList<SimpleTOBData>>> dataSets, ArrayList<ArrayList<String>> labelSets, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)
    {
        this.configManager = configManager;
        this.clientThread = clientThread;
        this.itemManager = itemManager;
        this.config = config;
        JTabbedPane pane = new JTabbedPane();
        pane.setBackground(Color.BLACK);
        pane.setOpaque(true);
        int index = 0;
        for (Integer i : dataSets.keySet())
        {
            String tabName = "";
            if (i == 1)
                tabName = "Solo";
            if (i == 2)
                tabName = "Duo";
            if (i == 3)
                tabName = "Trio";
            if (i == 4)
                tabName = "4-Man";
            if (i == 5)
                tabName = "5-Man";
            pane.addTab(tabName, new ComparisonViewPanel(dataSets.get(i), labelSets.get(index), config, itemManager, clientThread, configManager));
            index++;
        }
        add(pane);
        pack();
    }
}

package com.advancedraidtracker.ui.comparisonview.graph;

import com.advancedraidtracker.SimpleTOBData;

import java.util.ArrayList;

public class GraphInternalDataContainer
{
    public ArrayList<SimpleTOBData> fullData;
    public ArrayList<Integer> intData;

    public GraphInternalDataContainer(ArrayList<SimpleTOBData> fullData, ArrayList<Integer> intData)
    {
        this.fullData = fullData;
        this.intData = intData;
    }
}

package com.advancedraidtracker.ui.comparisonview.graph;

import com.advancedraidtracker.SimpleTOBData;

import java.util.ArrayList;

public class GraphInternalBoundMatchedContainer
{
    public ArrayList<ArrayList<SimpleTOBData>> fullData;
    public ArrayList<Integer> intData;

    public GraphInternalBoundMatchedContainer(ArrayList<ArrayList<SimpleTOBData>> fullData, ArrayList<Integer> intData)
    {
        this.fullData = fullData;
        this.intData = intData;
    }
}

package com.advancedraidtracker.ui.comparisonview.graph;

public class PieChartData
{
    public int value;
    public int occurrences;
    public int sections;

    public PieChartData(int value, int occurrences, int total)
    {
        this.value = value;
        this.occurrences = occurrences;
        double percent = (double) occurrences / total;
        this.sections = (int) (percent * 360);
    }
}

package com.advancedraidtracker.ui.comparisonview.graph;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.utility.RoomUtil;
import com.advancedraidtracker.utility.datautility.DataPoint;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Objects;

@Slf4j
public class GraphPanel extends JPanel implements MouseMotionListener, MouseListener, KeyListener
{
    public static final int IMG_WIDTH = 600;
    public static final int IMG_HEIGHT = 300;
    public static final int GRAPH_WIDTH = 500;
    public static final int GRAPH_HEIGHT = 250;
    public static final int GRAPH_XS = 50;
    public static final int GRAPH_XE = 550;
    public static final int GRAPH_YS = 25;
    public static final int GRAPH_YE = 225;

    private final Color[] pieChartColors = {
            Color.decode("#ebdc78"),
            Color.decode("#8be04e"),
            Color.decode("#5ad45a"),
            Color.decode("#00b7c7"),
            Color.decode("#0d88e6"),
            Color.decode("#1a53ff"),
            Color.decode("#4421af"),
            Color.decode("#7c1158"),
            Color.decode("#b30000"),
    };

    private final Color gridColor = new Color(110, 110, 110);
    private ToolTipData activeToolTip;
    private boolean shouldDrawToolTip = false;

    private boolean groupingEnabled = true;

    private int graphType;
    private final ArrayList<Bounds> selectedBounds;
    private Bounds activeBound = new Bounds(-1, -1, -1, -1, null);
    private final ArrayList<Bounds> bounds;
    private final Color gradientStart;
    private final Color gradientEnd;
    private final Color gradientStartHighlighted;
    private final Color gradientEndHighlighted;
    private final Color gradientStartSelected;
    private final Color gradientEndSelected;
    private final Color gradientStartSelectedAndHighlighted;
    private final Color gradientEndSelectedAndHighlighted;
    private DataPoint activeKey;
    private boolean time = false;
    private final BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);
    private final ArrayList<SimpleTOBData> internalData;
    private final AdvancedRaidTrackerConfig config;

    private final ItemManager itemManager;

    private final ClientThread clientThread;
    private final ConfigManager configManager;
    public GraphPanel(ArrayList<SimpleTOBData> data, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)
    {
        this.configManager = configManager;
        this.clientThread = clientThread;
        this.itemManager = itemManager;
        selectedBounds = new ArrayList<>();
        gradientStart = new Color(100, 170, 230, 90);
        gradientEnd = new Color(200, 240, 255, 90);

        gradientStartHighlighted = new Color(100, 170, 230, 215);
        gradientEndHighlighted = new Color(200, 240, 255, 215);

        gradientStartSelected = new Color(100, 170, 230, 190);
        gradientEndSelected = new Color(200, 240, 255, 190);

        gradientStartSelectedAndHighlighted = new Color(100, 170, 230, 240);
        gradientEndSelectedAndHighlighted = new Color(200, 240, 255, 240);
        graphType = 0;
        internalData = data;
        drawBlankBarGraph();
        addMouseMotionListener(this);
        addMouseListener(this);
        addKeyListener(this);
        this.config = config;
        bounds = new ArrayList<>();
    }

    @Override
    protected void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        if (img != null)
        {
            g.drawImage(img, 0, 0, null);
        }
    }

    @Override
    public Dimension getPreferredSize()
    {
        return new Dimension(IMG_WIDTH, IMG_HEIGHT);
    }


    public void switchKey(DataPoint key)
    {
        time = key.type == DataPoint.types.TIME;
        activeKey = key;
    }


    private ArrayList<Integer> filterForTime(ArrayList<Integer> data)
    {
        ArrayList<Integer> arrayToPass = new ArrayList<>();
        for (Integer i : data)
        {
            if (!time || i != 0)
            {
                arrayToPass.add(i);
            }
        }
        return arrayToPass;
    }

    public static ArrayList<Integer> getCounts(ArrayList<Integer> data, int highestValue)
    {
        ArrayList<Integer> countedData = new ArrayList<>();
        for (int i = 0; i < highestValue + 1; i++)
        {
            countedData.add(0);
        }
        for (Integer i : data)
        {
            if (countedData.size() > i && i > -1)
            {
                int incrementedValue = countedData.get(i) + 1;
                countedData.set(i, incrementedValue);
            }
        }
        return countedData;
    }

    public static int getCountedTotal(ArrayList<Integer> data)
    {
        int count = 0;
        for (Integer i : data)
        {
            count += i;
        }
        return count;
    }

    boolean isBarSelected(int left, int right, int top, int bottom)
    {
        for (Bounds b : selectedBounds)
        {
            if (b.getLeft() == left && b.getRight() == right && b.getTop() == top && b.getBottom() == bottom)
            {
                return true;
            }
        }
        return false;
    }

    private void drawBar(Graphics2D g, int width, int height, int left, int count, int total, String value)
    {
        Color oldColor = g.getColor();
        if (height == 0)
        {
            return;
        }
        if (width == 1)
        {
            g.drawLine(left, GRAPH_HEIGHT - GRAPH_YS, left, GRAPH_HEIGHT - GRAPH_YS - height);
        }

        int right = left + width;
        int top = GRAPH_HEIGHT - GRAPH_YS - height;
        int bottom = GRAPH_HEIGHT - GRAPH_YS;

        g.setColor(new Color(100, 170, 230));
        g.drawLine(left, bottom, right, bottom);
        g.drawLine(left, bottom, left, top);
        g.drawLine(left, top, right, top);
        g.drawLine(right, bottom, right, top);

        boolean highlight = (left == activeBound.getLeft() && right == activeBound.getRight() && top == activeBound.getTop() && activeBound.getBottom() == bottom);
        boolean selected = isBarSelected(left, right, top, bottom);


        Paint oldPaint = g.getPaint();
        GradientPaint gradient = new GradientPaint(left, bottom, (highlight && selected) ? gradientStartSelectedAndHighlighted : (highlight) ? gradientStartHighlighted : (selected) ? gradientStartSelected : gradientStart, left, top, (highlight && selected) ? gradientEndSelectedAndHighlighted : (highlight) ? gradientEndHighlighted : (selected) ? gradientEndSelected : gradientEnd);

        g.setPaint(gradient);
        g.fillRect(left, top, width, height);

        if (highlight && selectedBounds.isEmpty())
        {
            String percent = Math.round((100.0 * count / (double) total) * 100.0) / 100.0 + "%";
            String message = value + ": " + count + "/" + total + " (" + percent + ")";
            int msgWidth = g.getFontMetrics().stringWidth(message);
            int msgHeight = g.getFontMetrics().getHeight();

            int ml = left + width / 2 - msgWidth / 2;
            int mb = top - msgHeight / 2;

            activeToolTip = new ToolTipData(ml, mb, message);
            shouldDrawToolTip = true;
        }
        g.setPaint(oldPaint);
        g.setColor(oldColor);
    }

    private int getHighestCount(ArrayList<Integer> data)
    {
        int max = 0;
        int index = 0;
        for (Integer i : data)
        {
            if (time && index == 0)
            {
                index++;
                continue;
            }
            if (i > max)
            {
                max = i;
            }
            index++;
        }
        return max;
    }

    public BufferedImage createStringImage(Graphics g, String s)
    {
        int w = g.getFontMetrics().stringWidth(s) + 5;
        int h = g.getFontMetrics().getHeight();
        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics2D imageGraphics = image.createGraphics();
        imageGraphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        imageGraphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        imageGraphics.setColor(Color.WHITE);
        imageGraphics.setFont(new Font("SansSerif", Font.PLAIN, 12)); //HEIGHT 16
        imageGraphics.drawString(s, 0, h - g.getFontMetrics().getDescent());
        imageGraphics.dispose();
        return image;
    }

    private void drawStringRotated(Graphics g, String s, int tx, int ty)
    {
        int angle = (s.length() == 1) ? 0 : -45;
        AffineTransform aff = AffineTransform.getRotateInstance(Math.toRadians(angle), tx, ty);
        aff.translate(tx, ty);

        Graphics2D g2D = ((Graphics2D) g);
        g2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
        g2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
        g2D.drawImage(createStringImage(g, s), aff, this);
    }

    private String getString(int s)
    {
        return (time) ? RoomUtil.time(s) : String.valueOf(s);
    }

    private int xScaleLow = 0;
    private int xScaleHigh = 0;
    private int yScaleHigh = 0;

    public int getScaleXLow()
    {
        return xScaleLow;
    }

    public int getScaleXHigh()
    {
        return xScaleHigh;
    }

    public int getScaleYHigh()
    {
        return yScaleHigh;
    }

    public void generateScales()
    {
        ArrayList<Integer> data = filterInvalid(getInternalDataSet(activeKey).intData);
        int lowestValue = Integer.MAX_VALUE;
        int highestValue = 0;

        for (Integer i : data)
        {
            if (time && i == 0)
            {
                continue;
            }
            if (i < lowestValue)
            {
                lowestValue = i;
            }
            if (i > highestValue)
            {
                highestValue = i;
            }
        }
        ArrayList<Integer> countedDataSet = getCounts(data, highestValue);
        int highestCount = getHighestCount(countedDataSet);

        xScaleLow = lowestValue;
        xScaleHigh = highestValue;
        yScaleHigh = highestCount;
    }

    public void setScales(int xl, int xh, int yh)
    {
        xScaleLow = xl;
        xScaleHigh = xh;
        yScaleHigh = yh;
    }

    public static GraphInternalBoundMatchedContainer getCounts(GraphInternalDataContainer data, int highestValue)
    {
        ArrayList<Integer> countedIntData = new ArrayList<>();
        ArrayList<ArrayList<SimpleTOBData>> countedFullData = new ArrayList<>();
        for (int i = 0; i < highestValue + 1; i++)
        {
            countedIntData.add(0);
            countedFullData.add(new ArrayList<>());
        }
        for (int i = 0; i < data.intData.size(); i++)
        {
            if (countedIntData.size() > data.intData.get(i) && data.intData.get(i) > -1)
            {
                int incrementedValue = countedIntData.get(data.intData.get(i)) + 1;
                countedIntData.set(data.intData.get(i), incrementedValue);
                countedFullData.get(data.intData.get(i)).add(data.fullData.get(i));
            }
        }
        return new GraphInternalBoundMatchedContainer(countedFullData, countedIntData);
    }

    private int getAlternateYScale(GraphInternalBoundMatchedContainer sets)
    {
        int max = 0;
        for (int i = 0; i < sets.intData.size(); i++)
        {
            int partialSum = 0;
            for (int j = i; j < i + groupSize; j++)
            {
                if (j < sets.intData.size())
                {
                    partialSum += sets.intData.get(j);
                }
            }
            if (partialSum > max)
            {
                max = partialSum;
            }
        }
        return max;
    }

    public void setBounds()
    {
        bounds.clear();
        if (graphType == 0)
        {
            GraphInternalDataContainer graphData = getInternalDataSet(activeKey);
            GraphInternalBoundMatchedContainer countedDataSet = getCounts(graphData, xScaleHigh);
            int highestCount = (groupingEnabled) ? getAlternateYScale(countedDataSet) : yScaleHigh;
            int firstGroupCount = (groupOffset == 0) ? groupSize : groupOffset;
            int bars = (groupingEnabled) ? ((int) (1 + Math.ceil(((double) (1 + xScaleHigh - firstGroupCount - xScaleLow)) / ((double) groupSize)))) : xScaleHigh - xScaleLow + 1;
            int barWidth = GRAPH_WIDTH / (bars);
            int usedWidth = barWidth * bars;
            int startX = GRAPH_XS + (GRAPH_WIDTH / 2) - (usedWidth / 2);
            double scale = (highestCount == 0) ? (GRAPH_HEIGHT * .75) : ((GRAPH_HEIGHT * .75) / highestCount);

            for (int i = Math.max(0, xScaleLow); i < xScaleHigh + 1; i++)
            {
                if (groupingEnabled)
                {
                    if ((i - xScaleLow) % groupSize == groupOffset || i == xScaleLow + groupOffset || i == xScaleLow)
                    {
                        int barOffset = 0;
                        if (i != xScaleLow && groupOffset != 0)
                        {
                            barOffset = 1;
                        }
                        int summedRegion = (groupOffset == 0 || i != xScaleLow) ? sumRegion(countedDataSet, i, groupSize) : sumRegion(countedDataSet, i - groupSize + groupOffset, groupSize);
                        int height = (int) (summedRegion * scale);
                        int barsToDraw = (i - Math.max(0, xScaleLow)) / groupSize;
                        int left = startX + ((barsToDraw + barOffset) * (barWidth));
                        int right = left + barWidth;
                        int top = GRAPH_HEIGHT - GRAPH_YS - height;
                        int bottom = GRAPH_HEIGHT - GRAPH_YS;
                        ArrayList<SimpleTOBData> summedRegionData;
                        if (groupOffset == 0 || i != xScaleLow)
                        {
                            summedRegionData = sumRegionRaidData(countedDataSet, i, groupSize);
                        } else
                        {
                            summedRegionData = sumRegionRaidData(countedDataSet, i - groupSize + groupOffset, groupSize);
                        }
                        bounds.add(new Bounds(left, right, bottom, top, summedRegionData));
                    }
                } else
                {
                    int height = (int) (countedDataSet.intData.get(i) * scale);
                    int left = startX + ((i - xScaleLow) * (barWidth));
                    int right = left + barWidth;
                    int top = GRAPH_HEIGHT - GRAPH_YS - height;
                    int bottom = GRAPH_HEIGHT - GRAPH_YS;
                    bounds.add(new Bounds(left, right, bottom, top, countedDataSet.fullData.get(i)));
                }
            }
        }
    }

    public void setGroupingEnabled(boolean enabled)
    {
        groupingEnabled = enabled;
        setBounds();
        drawGraph();
    }

    public void setGraphType(int type)
    {
        graphType = type;
        setBounds();
        drawGraph();
    }

    public void updateGroupSize(int groupSize)
    {
        this.groupSize = groupSize;
        setBounds();
        drawGraph();
    }

    public void updateGroupOffset(int groupOffset)
    {
        this.groupOffset = groupOffset;
        setBounds();
        drawGraph();
    }

    private int sumRegion(GraphInternalBoundMatchedContainer data, int index, int length)
    {
        int sum = 0;
        for (int i = index; i < index + length; i++)
        {
            if (i < data.intData.size() && i > -1)
            {
                sum += data.intData.get(i);
            }
        }
        return sum;
    }

    private ArrayList<SimpleTOBData> sumRegionRaidData(GraphInternalBoundMatchedContainer data, int index, int length)
    {
        ArrayList<SimpleTOBData> summedData = new ArrayList<>();
        for (int i = index; i < index + length; i++)
        {
            if (i < data.fullData.size() && i > -1)
            {
                summedData.addAll(data.fullData.get(i));
            }
        }
        return summedData;
    }

    private int groupSize = 1;
    private int groupOffset = 0;

    private void drawDragArea()
    {
        if (dragCurrentX != -1 && dragCurrentY != -1)
        {
            int startX = Math.min(dragStartX, dragCurrentX);
            int startY = Math.min(dragStartY, dragCurrentY);
            int endX = Math.max(dragStartX, dragCurrentX);
            int endY = Math.max(dragStartY, dragCurrentY);
            Graphics2D g = (Graphics2D) img.getGraphics();
            Color oldColor = g.getColor();
            g.setColor(new Color(200, 200, 100, 180));
            g.drawRect(startX, startY, Math.abs(endX - startX), Math.abs(endY - startY));
            g.setColor(new Color(200, 200, 100, 70));
            g.fillRect(startX, startY, Math.abs(endX - startX), Math.abs(endY - startY));
            g.setColor(oldColor);
        }

    }

    private void drawToolTip()
    {
        if (shouldDrawToolTip && selectedBounds.isEmpty())
        {
            shouldDrawToolTip = false;
            Graphics2D g = (Graphics2D) img.getGraphics();
            Font oldFont = g.getFont();
            Color oldColor = g.getColor();
            g.setFont(new Font("SansSerif", Font.PLAIN, 14));

            int msgWidth = g.getFontMetrics().stringWidth(activeToolTip.message);
            int msgHeight = g.getFontMetrics().getHeight();


            int left = activeToolTip.messageLeft - 5;
            int bottom = activeToolTip.messageBottom - msgHeight;

            g.setColor(new Color(30, 30, 30, 255));
            g.fillRect(activeToolTip.messageLeft - 5, activeToolTip.messageBottom - msgHeight, msgWidth + 10, msgHeight + 10);
            g.setColor(new Color(100, 100, 100));
            g.drawRect(left, bottom, msgWidth + 10, msgHeight + 10);
            g.setColor(new Color(240, 240, 240));
            g.drawString(activeToolTip.message, activeToolTip.messageLeft, activeToolTip.messageBottom);
            g.setFont(oldFont);
            g.setColor(oldColor);
        }
    }

    public static ArrayList<Integer> filterInvalid(ArrayList<Integer> data)
    {
        ArrayList<Integer> filteredData = new ArrayList<>();
        for (Integer i : data)
        {
            if (i > -1)
            {
                filteredData.add(i);
            }
        }
        return filteredData;
    }

    public void drawGraphTitle(Graphics2D g, int totalCount)
    {
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        Font oldFont = g.getFont();
        Font font = new Font("SansSerif", Font.PLAIN, 14);
        g.setFont(font);
        String title = activeKey.name + " (Based on " + totalCount + " raids)";
        g.drawString(title, 300 - g.getFontMetrics().stringWidth(title) / 2, 16);
        g.setFont(oldFont);
    }

    public void drawGraph()
    {
        Graphics2D g = (Graphics2D) img.getGraphics();
        Stroke oldStroke = g.getStroke();

        drawBlankPanel();
        int lowestValue = xScaleLow;
        int highestValue = xScaleHigh;
        GraphInternalBoundMatchedContainer countedDataSet = getCounts(getInternalDataSet(activeKey), highestValue);
        int totalCount = getCountedTotal(countedDataSet.intData);
        drawGraphTitle(g, totalCount);
        if (graphType == 0)
        {
            drawBlankBarGraph();

            int highestCount = getAlternateYScale(countedDataSet);
            int firstGroupCount = (groupOffset == 0) ? groupSize : groupOffset;
            int bars = ((int) (1 + Math.ceil(((double) (1 + xScaleHigh - firstGroupCount - xScaleLow)) / ((double) groupSize))));
            int barWidth = GRAPH_WIDTH / (bars);
            if (barWidth == 0)
            {
                barWidth = 1;
            }
            int usedWidth = barWidth * bars;
            int startX = GRAPH_XS + (GRAPH_WIDTH / 2) - (usedWidth / 2);
            double scale = ((highestCount == 0) ? (GRAPH_HEIGHT * .75) : ((GRAPH_HEIGHT * .75) / (double) highestCount));
            int horizontalScaleToUse = (highestValue - lowestValue > 100) ? 25 : (highestValue - lowestValue > 50) ? 10 : (highestValue - lowestValue > 10) ? 5 : 1;
            if (barWidth > 16)
            {
                horizontalScaleToUse = 1;
            }

            int verticalScaleToUse = (highestCount > 250) ? 50 : (highestCount > 100) ? 25 : (highestCount > 50) ? 10 : (highestCount > 10) ? 5 : 1;
            if (groupingEnabled)
            {

                drawGraphVerticals(g, highestCount, scale, verticalScaleToUse);

                for (int i = Math.max(lowestValue, 0); i < highestValue + 1; i++)
                {
                    if ((i - lowestValue) % groupSize == groupOffset || i == lowestValue + groupOffset || i == lowestValue)
                    {
                        int barOffset = 0;
                        if (i != lowestValue && groupOffset != 0)
                        {
                            barOffset = 1;
                        }
                        int currentBarCenter = startX + (((i - Math.max(0, xScaleLow)) / groupSize) + barOffset) * (barWidth);
                        int summedRegion = (groupOffset == 0 || i != lowestValue) ? sumRegion(countedDataSet, i, groupSize) : sumRegion(countedDataSet, i - groupSize + groupOffset, groupSize);
                        int height = (int) (summedRegion * scale);
                        int stringOffset = 16 + barWidth / 2 - 8;
                        String axisValue = "";
                        if (i == lowestValue || i == highestValue || i % horizontalScaleToUse == 0)
                        {
                            axisValue = (i == lowestValue && groupOffset != 0) ? getString(i - groupSize + groupOffset) : getString(i);
                            if (groupSize != 1)
                            {
                                if (i != lowestValue || groupOffset == 0)
                                {
                                    axisValue += "-" + getString(i + groupSize - 1);
                                } else
                                {
                                    axisValue += "-" + getString(i);
                                }
                            }
                            FontMetrics m = g.getFontMetrics();
                            int yOffset = (int) (500 - GRAPH_HEIGHT - GRAPH_YS + 10 + (.5 * m.stringWidth(axisValue)));
                            stringOffset -= m.stringWidth(axisValue) - 5;
                            drawStringRotated(g, axisValue, startX + stringOffset + ((((i - Math.max(0, xScaleLow)) / groupSize) + barOffset) * barWidth), yOffset);
                        }
                        drawBar(g, barWidth, height, currentBarCenter, summedRegion, totalCount, axisValue);
                    }
                }

            } else
            {
                ArrayList<Integer> data = filterForTime(filterInvalid(getInternalDataSet(activeKey).intData));

                ArrayList<Integer> intCountedDataSet = getCounts(data, highestValue);
                totalCount = getCountedTotal(intCountedDataSet);

                drawGraphVerticals(g, highestCount, scale, verticalScaleToUse);

                for (int i = Math.max(lowestValue, 0); i < highestValue + 1; i++)
                {
                    int currentBarCenter = startX + ((i - lowestValue) * (barWidth));
                    int height = (int) (intCountedDataSet.get(i) * scale);
                    drawBar(g, barWidth, height, currentBarCenter, intCountedDataSet.get(i), totalCount, getString(i));
                    int stringOffset = 16 + barWidth / 2 - 8;
                    if (i == lowestValue || i == highestValue || i % horizontalScaleToUse == 0)
                    {
                        FontMetrics m = g.getFontMetrics();
                        int yOffset = (int) (500 - GRAPH_HEIGHT - GRAPH_YS + 10 + (.5 * m.stringWidth(getString(i))));
                        stringOffset -= m.stringWidth(getString(i)) - 5;
                        drawStringRotated(g, getString(i), startX + stringOffset + ((i - lowestValue) * barWidth), yOffset);
                    }
                }

            }
            drawToolTip();
            drawDragArea();
            g.setStroke(oldStroke);
            g.dispose();
            repaint();
        } else if (graphType == 1)
        {
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            ArrayList<Integer> data = filterForTime(filterInvalid(getInternalDataSet(activeKey).intData));

            ArrayList<Integer> intCountedDataSet = getCounts(data, highestValue);
            totalCount = getCountedTotal(intCountedDataSet);
            int nonZeroCount = getNonZeroCount(intCountedDataSet);
            if (nonZeroCount > 9)
            {
                g.setColor(Color.WHITE);
                g.drawString("Cannot draw pie chart for this data due to too many values", 50, 50);
                return;
            }
            ArrayList<PieChartData> sortedData = createSortedPieChartData(intCountedDataSet, totalCount);

            int position = 90;
            for (int i = 0; i < sortedData.size(); i++)
            {
                Color c = pieChartColors[i];
                Color opacityAdjusted = new Color(c.getRed(), c.getGreen(), c.getBlue(), 150);
                g.setColor(opacityAdjusted);
                g.fillArc(100, 30, 250, 250, position - sortedData.get(i).sections, sortedData.get(i).sections);
                position -= sortedData.get(i).sections;
            }

            //Draw Plot

            int offset = 50;
            for (int i = 0; i < sortedData.size(); i++)
            {
                Color c = pieChartColors[i];
                Color opacityAdjusted = new Color(c.getRed(), c.getGreen(), c.getBlue(), 150);
                g.setColor(opacityAdjusted);
                g.fillRect(375, offset, 50, 18);
                g.setColor(Color.BLACK);
                g.drawRect(375, offset, 50, 18);
                g.setColor(new Color(200, 200, 200, 200));
                Font oldFont = g.getFont();
                g.setFont(oldFont.deriveFont(18f));
                g.drawString(getString(sortedData.get(i).value), 435, offset + 16);
                g.setFont(oldFont);
                offset += 28;
            }

        } else if (graphType == 2)
        {
            drawBlankBarGraph();
            int yMax = 0;
            int yMin = Integer.MAX_VALUE;
            ArrayList<Integer> data = filterForTime(filterInvalid(getInternalDataSet(activeKey).intData));

            ArrayList<Integer> intCountedDataSet = getCounts(data, highestValue);
            for (int i = 0; i < intCountedDataSet.size(); i++)
            {
                if (intCountedDataSet.get(i) != 0)
                {
                    if (i < yMin)
                    {
                        yMin = i;
                    }
                    if (i > yMax)
                    {
                        yMax = i;
                    }
                }
            }
            int horizontalScale = GRAPH_WIDTH / (totalCount - 1);
            int verticalScale = 200 / (yMax - yMin);
            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            //draw horizontal lines
            g.setColor(new Color(100, 100, 100, 150));
            for (int i = 0; i < yMax - yMin; i++)
            {
                if (yMax - yMin > 6)
                {
                    if (i % ((yMax - yMin) / 6) == 0)
                    {
                        g.drawLine(GRAPH_XS, GRAPH_YE - (i * verticalScale), GRAPH_XE, GRAPH_YE - (i * verticalScale));

                        Color oldColor = g.getColor();
                        g.setColor(new Color(200, 200, 200, 220));
                        g.drawString(getString(i + yMin), GRAPH_XS - g.getFontMetrics().stringWidth(getString(i + yMin)) - 10, GRAPH_YE - (i * verticalScale));
                        g.setColor(oldColor);
                    }
                } else
                {
                    g.drawLine(GRAPH_XS, GRAPH_YE - (i * verticalScale), GRAPH_XE, GRAPH_YE - (i * verticalScale));
                }
            }

            g.setColor(new Color(120, 120, 240, 200));
            for (int i = 0; i < data.size(); i++)
            {
                g.fillOval(GRAPH_XS + (i * horizontalScale) - 1, GRAPH_YE - ((data.get(i) - yMin) * verticalScale) - 2, 4, 4);
                if (i != 0)
                {
                    int previousX = GRAPH_XS + ((i - 1) * horizontalScale) + 1;
                    int previousY = GRAPH_YE - ((data.get(i - 1) - yMin) * verticalScale);
                    g.drawLine(GRAPH_XS + (i * horizontalScale) + 1, GRAPH_YE - ((data.get(i) - yMin) * verticalScale), previousX, previousY);
                }
            }

            //line plot
        }
    }

    private void drawGraphVerticals(Graphics2D g, int highestCount, double scale, int verticalScaleToUse)
    {
        for (int i = 0; i < highestCount + 1; i++)
        {
            {
                int stringOffset = (int) (500 - GRAPH_HEIGHT - GRAPH_YS - scale * i + 8);
                if (i == 0 || i % verticalScaleToUse == 0)
                {
                    Color oldColor = g.getColor();
                    g.setColor(new Color(100, 100, 100, 100));
                    g.drawLine(GRAPH_XS, stringOffset - 8, GRAPH_XE, stringOffset - 8);
                    g.setColor(oldColor);
                    g.drawString(String.valueOf(i), GRAPH_XS - 20, stringOffset);
                }
            }
        }
    }

    private ArrayList<PieChartData> createSortedPieChartData(ArrayList<Integer> data, int total)
    {
        ArrayList<PieChartData> fixedData = new ArrayList<>();
        for (int i = 0; i < data.size(); i++)
        {
            if (data.get(i) != 0)
            {
                fixedData.add(new PieChartData(i, data.get(i), total));
            }
        }
        fixedData.sort((o1, o2) ->
        {
            if (Objects.equals(o1.occurrences, o2.occurrences))
            {
                return 0;
            }
            return o1.occurrences > o2.occurrences ? -1 : 1;
        });
        return fixedData;
    }

    private int getNonZeroCount(ArrayList<Integer> data)
    {
        int count = 0;
        for (Integer i : data)
        {
            if (i != 0)
            {
                count++;
            }
        }
        return count;
    }

    private GraphInternalDataContainer getInternalDataSet(DataPoint key)
    {
        ArrayList<Integer> intDataSet = new ArrayList<>();
        ArrayList<SimpleTOBData> fullDataSet = new ArrayList<>();
        for (SimpleTOBData data : internalData)
        {
            if (data.getValue(key) != -1)
            {
                if (data.getTimeAccurate(key))
                {
                    intDataSet.add(data.getValue(key));
                    fullDataSet.add(data);
                }
            }
        }
        return new GraphInternalDataContainer(fullDataSet, intDataSet);
    }

    private void drawGridLines()
    {
        Graphics g = img.getGraphics();
        g.setColor(gridColor);

        g.drawLine(GRAPH_XS, GRAPH_YS, GRAPH_XE, GRAPH_YS);
        g.drawLine(GRAPH_XS, GRAPH_YS, GRAPH_XS, GRAPH_YE);
        g.drawLine(GRAPH_XS, GRAPH_YE, GRAPH_XE, GRAPH_YE);
        g.drawLine(GRAPH_XE, GRAPH_YE, GRAPH_XE, GRAPH_YS);

        g.dispose();
    }

    public void drawBlankPanel()
    {
        Graphics g = img.getGraphics();
        g.setColor(new Color(40, 40, 40));
        g.fillRect(0, 0, img.getWidth(), img.getHeight());
        g.dispose();

        repaint();
    }

    public void drawBlankBarGraph()
    {
        drawGridLines();
        repaint();
    }

    private boolean checkContains(Bounds bound)
    {
        for (Bounds b : selectedBounds)
        {
            if (b.getBottom() == bound.getBottom() && b.getTop() == bound.getTop() && b.getLeft() == bound.getLeft() && b.getRight() == bound.getRight())
            {
                return true;
            }
        }
        return false;
    }

    private boolean currentlyDragging = false;
    private boolean boundActive = false;
    private int dragStartX = -1;
    private int dragStartY = -1;
    private int dragCurrentX = -1;
    private int dragCurrentY = -1;

    private Bounds getBound(int x, int y)
    {
        for (Bounds bound : bounds)
        {
            if (x >= bound.getLeft() && x <= bound.getRight() && y <= bound.getBottom() && y >= bound.getTop())
            {
                return bound;
            }
        }
        return null;
    }

    private boolean checkOverlap(int left1, int top1, int right1, int bottom1, int left2, int top2, int right2, int bottom2)
    {
        int leftA = Math.min(left1, right1);
        int rightA = Math.max(left1, right1);
        int bottomA = Math.min(top1, bottom1);
        int topA = Math.max(top1, bottom1);

        int leftB = Math.min(left2, right2);
        int rightB = Math.max(left2, right2);
        int bottomB = Math.min(top2, bottom2);
        int topB = Math.max(top2, bottom2);

        return (leftA < rightB && rightA > leftB && topA > bottomB && bottomA < topB);
    }

    private void checkIntersectingBounds()
    {
        ArrayList<Bounds> currentlyIntersecting = new ArrayList<>();
        for (Bounds b : bounds)
        {
            if (checkOverlap(dragStartX, dragStartY, dragCurrentX, dragCurrentY, b.getLeft(), b.getTop(), b.getRight(), b.getBottom()))
            {
                currentlyIntersecting.add(b);
            }
        }
        selectedBounds.clear();
        selectedBounds.addAll(currentlyIntersecting);
    }

    private boolean checkBounds(int x, int y)
    {
        for (Bounds bound : bounds)
        {
            if (x >= bound.getLeft() && x <= bound.getRight() && y <= bound.getBottom() && y >= bound.getTop())
            {
                return true;
            }
        }
        return false;
    }

    private void checkBoundsAndHighlight(int x, int y)
    {
        for (Bounds bound : bounds)
        {
            if (x >= bound.getLeft() && x <= bound.getRight() && y <= bound.getBottom() && y >= bound.getTop())
            {
                if (!boundActive)
                {
                    requestFocusInWindow();
                    activeBound = new Bounds(bound.getLeft(), bound.getRight(), bound.getBottom(), bound.getTop(), bound.raids);
                    boundActive = true;
                    drawGraph();
                }

            } else if (boundActive)
            {
                if (bound.matches(activeBound))
                {
                    activeBound.reset();
                    boundActive = false;
                    drawGraph();
                }
            }
        }
    }

    private ArrayList<SimpleTOBData> mergeSelectedData()
    {
        ArrayList<SimpleTOBData> mergedData = new ArrayList<>();
        for (Bounds b : selectedBounds)
        {
            mergedData.addAll(b.raids);
        }
        return mergedData;
    }

    @Override
    public void mouseDragged(MouseEvent e)
    {
        if (e.isShiftDown() && currentlyDragging)
        {
            dragCurrentX = e.getX();
            dragCurrentY = e.getY();
            checkIntersectingBounds();
            drawGraph();
        }
    }

    @Override
    public void mouseMoved(MouseEvent e)
    {
        checkBoundsAndHighlight(e.getX(), e.getY());
    }

    @Override
    public void mouseClicked(MouseEvent e)
    {
        if (e.isShiftDown() && SwingUtilities.isLeftMouseButton(e) && selectedBounds.isEmpty())
        {
            if (checkBounds(e.getX(), e.getY()))
            {
                selectedBounds.add(getBound(e.getX(), e.getY()));
                drawGraph();
            }
        } else if (e.isShiftDown() && SwingUtilities.isLeftMouseButton(e))
        {
            if (checkBounds(e.getX(), e.getY()))
            {
                Bounds lastBound = selectedBounds.get(selectedBounds.size() - 1);
                addAllBoundsBetween(lastBound, getBound(e.getX(), e.getY()));
                drawGraph();
            }
        } else if (SwingUtilities.isLeftMouseButton(e) && !e.isControlDown())
        {
            selectedBounds.clear();
            if (checkBounds(e.getX(), e.getY()))
            {
                selectedBounds.add(getBound(e.getX(), e.getY()));

                drawGraph();
            }
        }
    }

    private void addAllBoundsBetween(Bounds lastBound, Bounds bound)
    {
        for (Bounds b : bounds)
        {
            if ((b.getLeft() > lastBound.getLeft() && b.getLeft() < bound.getLeft()) || (b.getLeft() < lastBound.getLeft() && b.getLeft() > bound.getLeft()))
            {
                if (!checkContains(b))
                {
                    selectedBounds.add(b);
                }
            }
        }
        selectedBounds.add(bound);
    }

    @Override
    public void mousePressed(MouseEvent e)
    {
        if (SwingUtilities.isRightMouseButton(e))
        {
            if (selectedBounds.isEmpty())
            {
                for (Bounds bound : bounds)
                {
                    if (e.getX() >= bound.getLeft() && e.getX() <= bound.getRight() && e.getY() <= bound.getBottom() && e.getY() >= bound.getTop())
                    {
                        GraphRightClickContextMenu menu = new GraphRightClickContextMenu(bound.raids, config, itemManager, clientThread, configManager);
                        menu.show(e.getComponent(), e.getX(), e.getY());
                    }
                }
            } else
            {
                GraphRightClickContextMenu menu = new GraphRightClickContextMenu(mergeSelectedData(), config, itemManager, clientThread, configManager);
                menu.show(e.getComponent(), e.getX(), e.getY());
            }
        }
        if (SwingUtilities.isLeftMouseButton(e) && e.isShiftDown())
        {
            if (!currentlyDragging)
            {
                dragStartX = e.getX();
                dragStartY = e.getY();
                currentlyDragging = true;
            }
        }
        if (SwingUtilities.isLeftMouseButton(e) && e.isControlDown())
        {
            if (checkBounds(e.getX(), e.getY()))
            {
                Bounds clicked = getBound(e.getX(), e.getY());
                if (checkContains(clicked) && clicked != null)
                {
                    selectedBounds.removeIf(b -> (b.getLeft() == clicked.getLeft() && b.getRight() == clicked.getRight() && b.getTop() == clicked.getTop() && b.getBottom() == clicked.getBottom()));
                } else
                {
                    selectedBounds.add(getBound(e.getX(), e.getY()));
                }
                drawGraph();
            }
        }
        if (SwingUtilities.isLeftMouseButton(e))
        {
            if (!checkBounds(e.getX(), e.getY()))
            {
                selectedBounds.clear();
                drawGraph();
            }
        }
    }

    @Override
    public void mouseReleased(MouseEvent e)
    {
        if (SwingUtilities.isLeftMouseButton(e))
        {
            if (currentlyDragging)
            {
                currentlyDragging = false;
                dragStartX = -1;
                dragStartY = -1;
                dragCurrentX = -1;
                dragCurrentY = -1;
                drawGraph();
            }
        }
    }

    @Override
    public void mouseEntered(MouseEvent e)
    {

    }

    @Override
    public void mouseExited(MouseEvent e)
    {

    }

    @Override
    public void keyTyped(KeyEvent e)
    {

    }

    @Override
    public void keyPressed(KeyEvent e)
    {
        if (e.isShiftDown())
        {
            setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));
        }
    }

    @Override
    public void keyReleased(KeyEvent e)
    {
        if (!e.isShiftDown())
        {
            setCursor(Cursor.getDefaultCursor());
            if (currentlyDragging)
            {
                currentlyDragging = false;
                dragStartX = -1;
                dragStartY = -1;
                dragCurrentX = -1;
                dragCurrentY = -1;
                drawGraph();
            }
        }
    }
}

package com.advancedraidtracker.ui.comparisonview.graph;

import com.advancedraidtracker.SimpleTOBData;
import lombok.Getter;

import java.util.ArrayList;

public class Bounds
{
    @Getter
    private int left;
    @Getter
    private int right;
    @Getter
    private int bottom;
    @Getter
    private int top;

    public ArrayList<SimpleTOBData> raids;

    public Bounds(int l, int r, int b, int t, ArrayList<SimpleTOBData> raids)
    {
        this.raids = raids;
        left = l;
        right = r;
        bottom = b;
        top = t;
    }

    public void reset()
    {
        left = -1;
        bottom = -1;
        top = -1;
        right = -1;
    }

    public boolean matches(Bounds match)
    {
        return (match.getLeft() == left && match.getRight() == right && match.getTop() == top && match.getBottom() == bottom);
    }

}

package com.advancedraidtracker.ui.comparisonview.graph;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.ui.Raids;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;

import javax.swing.*;
import java.util.ArrayList;

@Slf4j
public class GraphRightClickContextMenu extends JPopupMenu
{
    JMenuItem item;

    public GraphRightClickContextMenu(ArrayList<SimpleTOBData> raids, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)
    {
        item = new JMenuItem("Show Represented Raids In New Window");
        item.addActionListener(al ->
        {
            Raids raidFrame = new Raids(config, itemManager, clientThread, configManager);
            raidFrame.createFrame(raids);
            raidFrame.repaint();
            raidFrame.open();
        });
        add(item);
    }
}

package com.advancedraidtracker.ui.comparisonview.graph;

public class ToolTipData
{
    public int messageLeft;
    public int messageBottom;
    public String message;

    public ToolTipData(int ml, int mb, String msg)
    {
        messageLeft = ml;
        messageBottom = mb;
        message = msg;
    }
}

package com.advancedraidtracker.ui.comparisonview;

import com.advancedraidtracker.ui.BaseFrame;

import javax.swing.*;
import java.awt.*;

public class NoDataPopUp extends BaseFrame
{
    public NoDataPopUp()
    {
        setTitle("No Data");
        JPanel container = new JPanel();
        container.add(new JLabel("No data to compare. Add a data set by selecting raids in the table and using the right click context menu -> \"Add set to comparison\"\""));
        JButton okButton = new JButton("Ok");
        okButton.addActionListener(e ->
        {
            close();
            rootPane.setVisible(false);
        });
        container.add(okButton);
        setPreferredSize(new Dimension(800, 100));
        add(container);
        pack();
        setLocationRelativeTo(null);
    }
}

package com.advancedraidtracker;

import com.advancedraidtracker.constants.LogID;
import com.advancedraidtracker.constants.TOBRoom;
import com.advancedraidtracker.utility.datautility.DataManager;
import com.advancedraidtracker.utility.datautility.DataPoint;
import com.advancedraidtracker.utility.wrappers.*;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import static com.advancedraidtracker.constants.TOBRoom.*;
import static com.advancedraidtracker.constants.TobIDs.EXIT_FLAG;
import static com.advancedraidtracker.constants.TobIDs.SPECTATE_FLAG;
import static com.advancedraidtracker.utility.datautility.DataPoint.*;

@Slf4j
public class SimpleTOBData
{
    public boolean maidenStartAccurate = false;
    public boolean bloatStartAccurate = false;
    public boolean nyloStartAccurate = false;
    public boolean soteStartAccurate = false;
    public boolean xarpStartAccurate = false;
    public boolean verzikStartAccurate = false;

    public boolean maidenEndAccurate = false;
    public boolean bloatEndAccurate = false;
    public boolean nyloEndAccurate = false;
    public boolean soteEndAccurate = false;
    public boolean xarpEndAccurate = false;
    public boolean verzikEndAccurate = false;
    public boolean resetBeforeMaiden;

    public boolean spectated = false;
    public boolean partyComplete;
    public boolean hardMode;
    public boolean storyMode;
    public boolean raidCompleted;
    public Date raidStarted;
    private ArrayList<String> globalData;
    public LinkedHashMap<String, Integer> players;
    public String filePath;
    public String fileName;
    public String activeValue = "";
    // Maiden tracking
    public boolean maidenTimeAccurate;
    public boolean maidenDefenseAccurate;
    public boolean maidenScuffed = false;
    public String firstMaidenCrabScuffed = "";
    public ArrayList<StringInt> maidenCrabs = new ArrayList<>();
    public ArrayList<String> maidenCrabSpawn = new ArrayList<>();
    public boolean maidenSpawned = false;
    public boolean maidenSkip;
    public boolean maidenReset;
    public boolean maidenWipe;
    // Bloat tracking
    public ArrayList<Integer> bloatDowns = new ArrayList<>();
    public boolean bloatTimeAccurate;
    public boolean bloatDefenseAccurate;
    public boolean bloatStarted;
    public boolean bloatReset;
    public boolean bloatWipe;
    // Nylo tracking
    public boolean nyloTimeAccurate;
    public boolean nyloDefenseAccurate;
    public boolean nyloWipe;
    public boolean nyloReset;
    public boolean nyloStarted;
    public ArrayList<Integer> nyloWaveStalled = new ArrayList<>();
    public Map<Integer, Integer> waveSpawns = new HashMap<>();
    // Sotetseg tracking
    public boolean soteTimeAccurate;
    public boolean soteDefenseAccurate;
    public boolean soteStarted;
    public boolean soteWipe;
    public boolean soteReset;
    // Xarpus tracking
    public boolean xarpTimeAccurate;
    public boolean xarpDefenseAccurate;
    public boolean xarpWipe;
    public boolean xarpReset;
    public boolean xarpStarted;
    // Verzik tracking
    public boolean verzikWipe;
    public boolean verzikStarted;
    public boolean verzikTimeAccurate;
    public ArrayList<Integer> websStart = new ArrayList<>();
    public ArrayList<DawnSpec> dawnSpecs = new ArrayList<>();
    public ArrayList<Integer> p2Crabs = new ArrayList<>();
    public ArrayList<Integer> p3Crabs = new ArrayList<>();
    public ArrayList<Integer> redsProc = new ArrayList<>();
    public ArrayList<Integer> dawnDrops;
    public ArrayList<PlayerDidAttack> attacksP1;




    // Thrall tracking
    public ArrayList<ThrallOutlineBox> maidenThrallSpawns;
    public ArrayList<ThrallOutlineBox> bloatThrallSpawns;
    public ArrayList<ThrallOutlineBox> nyloThrallSpawns;
    public ArrayList<ThrallOutlineBox> soteThrallSpawns;
    public ArrayList<ThrallOutlineBox> xarpusThrallSpawns;
    public ArrayList<ThrallOutlineBox> verzikThrallSpawns;

    public Map<Integer, Integer> verzikHP = new HashMap<>();

    public Date getDate()
    {
        return raidStarted;
    }

    public int getScale()
    {
        return dataManager.get(PARTY_SIZE);
    }

    public boolean getTimeAccurate(DataPoint param)
    {
        switch (param.room)
        {
            case MAIDEN:
                return maidenStartAccurate && maidenEndAccurate;
            case BLOAT:
                return bloatStartAccurate && bloatEndAccurate;
            case NYLOCAS:
                return nyloStartAccurate && nyloEndAccurate;
            case SOTETSEG:
                return soteStartAccurate && soteEndAccurate;
            case XARPUS:
                return xarpStartAccurate && xarpEndAccurate;
            case VERZIK:
                return verzikStartAccurate && verzikEndAccurate;
            case ANY:
                return true;
            default:
                return false;
        }
    }

    public void setIndex(int index)
    {
        dataManager.set(RAID_INDEX, index);
    }

    public String getPlayerList(ArrayList<Map<String, ArrayList<String>>> aliases)
    {
        StringBuilder list = new StringBuilder();
        ArrayList<String> names = new ArrayList<>();
        for (String s : players.keySet())
        {
            String name = s;
            for (Map<String, ArrayList<String>> alternateNames : aliases)
            {
                for (String alias : alternateNames.keySet())
                {
                    for (String potentialName : alternateNames.get(alias))
                    {
                        if (name.equalsIgnoreCase(potentialName))
                        {
                            name = alias;
                            break;
                        }
                    }
                }
            }
            names.add(name);
        }
        names.sort(String::compareToIgnoreCase);
        for (String s : names)
        {
            list.append(s);
            list.append(",");
        }
        if (list.length() > 0)
        {
            return list.substring(0, list.length() - 1);
        } else
        {
            return "";
        }
    }

    public PlayerCorrelatedPointData getSpecificTimeInactiveCorrelated(String inactive)
    {
        if (inactive.contains("Player: "))
        {
            return dataManager.getHighest(DataPoint.getValue(inactive.substring(8)));
        } else
        {
            return null;
        }
    }

    public int getSpecificTimeInactive(String inactive)
    {
        if (inactive.contains("Player: "))
        {
            return dataManager.getHighest(DataPoint.getValue(inactive.substring(8))).value;
        }
        if (inactive.equals("Challenge Time"))
        {
            return getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();
        }
        return getValue(DataPoint.getValue(inactive));
    }

    public int getSpecificTime()
    {
        if (activeValue.contains("Player: "))
        {
            return dataManager.getHighest(DataPoint.getValue(activeValue.substring(8))).value;
        }
        if (activeValue.equals("Challenge Time"))
        {
            return getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();
        }
        if(getTimeAccurate(Objects.requireNonNull(DataPoint.getValue(activeValue))))
        {
            return getValue(DataPoint.getValue(activeValue));
        }
        else
        {
            return Integer.MAX_VALUE;
        }
    }

    public void setOverallTime()
    {
        int overallTime = getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();
        dataManager.set(DataPoint.CHALLENGE_TIME, overallTime);
    }

    public int getMaidenTime()
    {
        return (maidenStartAccurate && maidenEndAccurate) ? getValue(DataPoint.MAIDEN_TOTAL_TIME) : 0;
    }

    public int getBloatTime()
    {
        return (bloatStartAccurate && bloatEndAccurate) ? getValue(DataPoint.BLOAT_TOTAL_TIME) : 0;
    }

    public int getNyloTime()
    {
        return (nyloStartAccurate && nyloEndAccurate) ? getValue(DataPoint.NYLO_TOTAL_TIME) : 0;
    }

    public int getSoteTime()
    {
        return (soteStartAccurate && soteEndAccurate) ? getValue(DataPoint.SOTE_TOTAL_TIME) : 0;
    }

    public int getXarpTime()
    {
        return (xarpStartAccurate && xarpEndAccurate) ? getValue(DataPoint.XARP_TOTAL_TIME) : 0;
    }

    public int getVerzikTime()
    {
        return (verzikStartAccurate && verzikEndAccurate) ? getValue(DataPoint.VERZIK_TOTAL_TIME) : 0;
    }

    public boolean getOverallTimeAccurate()
    {
        return maidenStartAccurate && maidenEndAccurate
                && bloatStartAccurate && bloatEndAccurate
                && nyloStartAccurate && nyloEndAccurate
                && soteStartAccurate && soteEndAccurate
                && xarpStartAccurate && xarpEndAccurate
                && verzikStartAccurate && verzikEndAccurate;
    }

    public boolean checkExit(TOBRoom room)
    {
        if (globalData.isEmpty() || globalData.get(0).split(",", -1)[3].equals(EXIT_FLAG))
        {
            switch (room)
            {
                case MAIDEN:
                    maidenReset = true;
                    break;
                case BLOAT:
                    if (!bloatEndAccurate)
                    {
                        bloatWipe = true;
                    } else
                    {
                        bloatReset = true;
                    }
                    break;
                case NYLOCAS:
                    nyloReset = true;
                    break;
                case SOTETSEG:
                    soteReset = true;
                    break;
                case XARPUS:
                    xarpReset = true;
                    break;
            }
            return false;
        }
        return true;
    }

    private final DataManager dataManager;

    public int getValue(String name)
    {
        return dataManager.get(name);
    }

    public int getValue(DataPoint point)
    {
        return dataManager.get(point);
    }

    public int getTimeSum()
    {
        return getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();
    }
    public SimpleTOBData(String[] parameters, String filePath, String fileName) throws Exception
    {
        this.filePath = filePath;
        this.fileName = fileName;
        dataManager = new DataManager();
        partyComplete = false;
        maidenDefenseAccurate = false;
        bloatDefenseAccurate = false;
        nyloDefenseAccurate = false;
        soteDefenseAccurate = false;
        xarpDefenseAccurate = false;

        maidenThrallSpawns = new ArrayList<>();
        bloatThrallSpawns = new ArrayList<>();
        nyloThrallSpawns = new ArrayList<>();
        soteThrallSpawns = new ArrayList<>();
        xarpusThrallSpawns = new ArrayList<>();
        verzikThrallSpawns = new ArrayList<>();

        hardMode = false;
        storyMode = false;
        attacksP1 = new ArrayList<>();
        dawnDrops = new ArrayList<>();

        players = new LinkedHashMap<>();
        globalData = new ArrayList<>(Arrays.asList(parameters));
        Date endTime = null;
        int room = -1;
        for (String s : globalData)
        {
            try
            {
                String[] subData = s.split(",");
                int key = Integer.parseInt(subData[3]);
                if (key == SPECTATE_FLAG)
                {
                    room = Integer.parseInt(subData[4]);
                    spectated = true;
                }
                if (String.valueOf(key).equals(EXIT_FLAG))
                {
                    endTime = new Date(Long.parseLong(subData[1]));
                }
            }
            catch (Exception e)
            {
            }
        }
        if (room > 0)
        {
            switch (room)
            {
                case 1:
                    if (!(checkExit(MAIDEN) && parseBloat()))
                        break;
                case 2:
                    if (!(checkExit(BLOAT) && parseNylo()))
                        break;
                case 3:
                    if (!(checkExit(NYLOCAS) && parseSotetseg()))
                        break;
                case 4:
                    if (!(checkExit(SOTETSEG) && parseXarpus()))
                        break;
                case 5:
                    if (checkExit(XARPUS) && parseVerzik())
                    {
                        finishRaid();
                    }
            }
        } else
        {
            try
            {
                if (parseMaiden())
                {
                    if (checkExit(MAIDEN) && parseBloat())
                    {
                        if (checkExit(BLOAT) && parseNylo())
                        {
                            if (checkExit(NYLOCAS) && parseSotetseg())
                            {
                                if (checkExit(SOTETSEG) && parseXarpus())
                                {
                                    if (checkExit(XARPUS) && parseVerzik())
                                    {
                                        finishRaid();
                                    }
                                }
                            }
                        }
                    }
                }
            } catch (Exception ignored)
            {
            }
        }
        setOverallTime();
        if (raidStarted != null && endTime != null)
        {
            long difference = endTime.getTime() - raidStarted.getTime();
            int ticks = (int) (difference / 600);
            dataManager.set(DataPoint.OVERALL_TIME, ticks);
            dataManager.set(DataPoint.TIME_OUTSIDE_ROOMS, dataManager.get(DataPoint.OVERALL_TIME) - dataManager.get(DataPoint.CHALLENGE_TIME));
        }
        globalData.clear();
    }

    private void parseGeneric(String room, String[] subData)
    {
        try
        {
            switch (LogID.valueOf(Integer.parseInt(subData[3])))
            {
                case ENTERED_TOB:
                    raidStarted = new Date(Long.parseLong(subData[1]));
                    break;
                case PARTY_MEMBERS:
                    for (int i = 4; i < 9; i++)
                    {
                        if (!subData[i].isEmpty())
                        {
                            dataManager.increment(PARTY_SIZE);
                            players.put(subData[i].replaceAll("[^\\p{ASCII}]", " ").replaceAll(" +", " "), 0);
                        }
                    }
                    break;
                case DWH:
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " hit hammers")));
                    dataManager.incrementPlayerSpecific(DataPoint.getValue(room + " hit hammers"), subData[4]);
                    if(!room.equals("Verzik"))
                    {
                        dataManager.hammer(Objects.requireNonNull(DataPoint.getValue(room + " defense")));
                    }
                    break;
                case BGS:
                    if (!room.equals("Bloat") || dataManager.get(DataPoint.BLOAT_DOWNS) == 0)
                    {
                        dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " attempted BGS")));
                        dataManager.incrementPlayerSpecific(DataPoint.getValue(room + " attempted BGS"), subData[4]);
                    }
                    if(!room.equals("Verzik"))
                    {
                        dataManager.bgs(Objects.requireNonNull(DataPoint.getValue(room + " defense")), Integer.parseInt(subData[5]));
                    }
                    break;
                case PLAYER_DIED:
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " deaths")));
                    dataManager.increment(DataPoint.TOTAL_DEATHS);
                    dataManager.incrementPlayerSpecific(DataPoint.getValue(room + " deaths"), subData[4]);
                    dataManager.incrementPlayerSpecific(DataPoint.TOTAL_DEATHS, subData[4]);
                    if (players.get(subData[4]) != null)
                    {
                        players.put(subData[4], players.get(subData[4]) + 1);
                    }
                    break;
                case HAMMER_ATTEMPTED:
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " attempted hammers")));
                    dataManager.incrementPlayerSpecific(DataPoint.getValue(room + " attempted hammers"), subData[4]);
                    break;
                case IS_HARD_MODE:
                    hardMode = true;
                    break;
                case IS_STORY_MODE:
                    storyMode = true;
                    break;
                case THRALL_ATTACKED:
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " thrall attacks")));
                    dataManager.increment(DataPoint.THRALL_ATTACKS_TOTAL);
                    break;
                case THRALL_DAMAGED:
                    int amount = Integer.parseInt(subData[5]);
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " thrall damage")), amount);
                    dataManager.increment(DataPoint.THRALL_DAMAGE_TOTAL, amount);
                    break;
                case VENG_WAS_CAST:
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " veng casts")));
                    dataManager.increment(DataPoint.VENG_CASTS_TOTAL);
                    break;
                case VENG_WAS_PROCCED:
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " veng procs")));
                    dataManager.increment(DataPoint.VENG_PROCS_TOTAL);
                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + " veng damage")), Integer.parseInt(subData[5]));
                    dataManager.increment(DataPoint.VENG_DAMAGE_TOTAL, Integer.parseInt(subData[5]));
                    break;
                case KODAI_BOP:
                    dataManager.increment(DataPoint.KODAI_BOPS);
                    dataManager.incrementPlayerSpecific(DataPoint.KODAI_BOPS, subData[4]);
                    break;
                case DWH_BOP:
                    dataManager.increment(DataPoint.DWH_BOPS);
                    dataManager.incrementPlayerSpecific(DataPoint.DWH_BOPS, subData[4]);
                    break;
                case BGS_WHACK:
                    dataManager.increment(DataPoint.BGS_WHACKS);
                    dataManager.incrementPlayerSpecific(DataPoint.BGS_WHACKS, subData[4]);
                    break;
                case CHALLY_POKE:
                    dataManager.increment(DataPoint.CHALLY_POKE);
                    dataManager.incrementPlayerSpecific(DataPoint.CHALLY_POKE, subData[4]);
                    break;
            }
        }
        catch(Exception ignored)
        {

        }
    }

    private boolean parseVerzik()
    {
        int activeIndex = 0;
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            parseGeneric("Verzik", subData);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        if (dataManager.get(DataPoint.VERZIK_TOTAL_TIME) == 0)
                        {
                            if (!verzikStarted)
                            {
                                xarpReset = true;
                            } else
                            {
                                verzikWipe = true;
                            }
                        } else
                        {
                            return true;
                        }
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        Date endTime = new Date(Long.parseLong(subData[1]));
                        long difference = endTime.getTime() - raidStarted.getTime();
                        int ticks = (int) (difference / 600);
                        dataManager.set(DataPoint.OVERALL_TIME, ticks);
                        return false;
                    case DAWN_DROPPED:
                        if (verzikStarted)
                        {
                            dawnDrops.add(Integer.parseInt(subData[4]));
                        }
                        break;
                    case VERZIK_P1_START:
                        verzikStarted = true;
                        break;
                    case VERZIK_P1_DESPAWNED:
                        dataManager.set(DataPoint.VERZIK_P1_SPLIT, Integer.parseInt(subData[4]) - 13);
                        break;
                    case VERZIK_P2_END:
                        dataManager.set(DataPoint.VERZIK_P2_SPLIT, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.VERZIK_P2_DURATION, dataManager.get(DataPoint.VERZIK_P2_SPLIT) - dataManager.get(DataPoint.VERZIK_P1_SPLIT));
                        dataManager.set(DataPoint.VERZIK_REDS_DURATION, dataManager.get(DataPoint.VERZIK_P2_SPLIT)-dataManager.get(VERZIK_REDS_SPLIT));
                        try
                        {
                            int hp = verzikHP.get(dataManager.get(VERZIK_REDS_SPLIT));
                            dataManager.set(DataPoint.VERZIK_REDS_PROC_PERCENT, (hp));
                        } catch
                        (Exception ignored)
                        {

                        }
                        break;
                    case VERZIK_P3_DESPAWNED:
                        dataManager.set(DataPoint.VERZIK_TOTAL_TIME, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.VERZIK_P3_DURATION, dataManager.get(DataPoint.VERZIK_TOTAL_TIME) - dataManager.get(DataPoint.VERZIK_P2_SPLIT));
                        dataManager.set(DataPoint.CHALLENGE_TIME, (Integer.parseInt(subData[4]) + dataManager.get(DataPoint.VERZIK_ENTRY)));
                        break;
                    case VERZIK_CRAB_SPAWNED:
                        if (!subData[4].equalsIgnoreCase(""))
                        {
                            if (dataManager.get(DataPoint.VERZIK_P2_SPLIT) > 1)
                            {
                                if (!p3Crabs.contains(Integer.parseInt(subData[4])))
                                {
                                    p3Crabs.add(Integer.parseInt(subData[4]));
                                }
                            } else
                            {
                                if (!p2Crabs.contains(Integer.parseInt(subData[4])))
                                {
                                    p2Crabs.add(Integer.parseInt(subData[4]));
                                }
                            }
                        }
                        dataManager.increment(VERZIK_CRABS_SPAWNED);
                        break;
                    case VERZIK_P2_REDS_PROC:
                        if (dataManager.get(VERZIK_REDS_SPLIT) == 0)
                        {
                            dataManager.set(VERZIK_REDS_SPLIT, Integer.parseInt(subData[4]));
                            dataManager.set(VERZIK_P2_TILL_REDS, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.VERZIK_P1_SPLIT));
                        }
                        redsProc.add(Integer.parseInt(subData[4]));
                        dataManager.increment(DataPoint.VERZIK_REDS_SETS);
                        break;
                    case ACCURATE_VERZIK_START:
                        verzikStartAccurate = true;
                        break;
                    case ACCURATE_VERZIK_END:
                        verzikEndAccurate = true;
                        verzikTimeAccurate = verzikStartAccurate;
                        break;
                    case DAWN_SPEC:
                        dawnSpecs.add(new DawnSpec(subData[4], Integer.parseInt(subData[5])));
                        break;
                    case DAWN_DAMAGE:
                        for (DawnSpec dawnSpec : dawnSpecs)
                        {
                            if (dawnSpec.tick == Integer.parseInt(subData[5]))
                            {
                                dawnSpec.setDamage(Integer.parseInt(subData[4]));
                            }
                        }
                        break;
                    case UPDATE_HP:
                        verzikHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));
                        break;
                    case WEBS_STARTED:
                        try
                        {
                            websStart.add(Integer.parseInt(subData[4]));
                            if (dataManager.get(DataPoint.VERZIK_HP_AT_WEBS) == -1)
                            {
                                int hp = verzikHP.get(Integer.parseInt(subData[4]) - 1);
                                hp /= 10;
                                dataManager.set(DataPoint.VERZIK_HP_AT_WEBS, hp);
                            }
                        }
                        catch(Exception ignored)
                        {

                        }
                        break;
                    case THRALL_SPAWN:
                        verzikThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));
                        break;
                }
            } catch (Exception e)
            {
                log.info("Failed: " + s);
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean isTimeAccurateThroughRoom(TOBRoom room)
    {
        switch (room)
        {
            case VERZIK:
                if (!verzikTimeAccurate)
                {
                    return false;
                }
            case XARPUS:
                if (!xarpTimeAccurate)
                {
                    return false;
                }
            case SOTETSEG:
                if (!soteTimeAccurate)
                {
                    return false;
                }
            case NYLOCAS:
                if (!nyloTimeAccurate)
                {
                    return false;
                }
            case BLOAT:
                if (!bloatTimeAccurate)
                {
                    return false;
                }
            case MAIDEN:
                return maidenTimeAccurate;
        }
        return false;
    }

    private boolean parseXarpus()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            parseGeneric("Xarp", subData);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        if (dataManager.get(DataPoint.XARP_TOTAL_TIME) != 0)
                        {
                            xarpReset = true;
                        } else
                        {
                            if (!xarpStarted)
                            {
                                soteReset = true;
                            } else
                            {
                                xarpWipe = true;
                            }
                        }
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        Date endTime = new Date(Long.parseLong(subData[1]));
                        long difference = endTime.getTime() - raidStarted.getTime();
                        int ticks = (int) (difference / 600);
                        dataManager.set(DataPoint.OVERALL_TIME, ticks);
                        return false;
                    case XARPUS_STARTED:
                        xarpStarted = true;
                        if (partyComplete)
                        {
                            xarpDefenseAccurate = true;
                        }
                        break;
                    case XARPUS_HEAL:
                        dataManager.increment(DataPoint.XARP_HEALING, getXarpusHealAmount());
                        break;
                    case XARPUS_SCREECH:
                        dataManager.set(DataPoint.XARP_SCREECH, Integer.parseInt(subData[4]));
                        break;
                    case XARPUS_DESPAWNED:
                        dataManager.set(DataPoint.XARP_TOTAL_TIME, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.XARP_POST_SCREECH, dataManager.get(DataPoint.XARP_TOTAL_TIME) - dataManager.get(DataPoint.XARP_SCREECH));
                        if (isTimeAccurateThroughRoom(SOTETSEG))
                            dataManager.set(DataPoint.VERZIK_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.XARP_ENTRY));
                        break loop;
                    case ACCURATE_XARP_START:
                        xarpStartAccurate = true;
                        break;
                    case ACCURATE_XARP_END:
                        xarpTimeAccurate = xarpStartAccurate;
                        xarpEndAccurate = true;
                        break;
                    case THRALL_SPAWN:
                        xarpusThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));
                        break;
                }
            }
            catch(Exception e)
            {
                log.info("Failed on " + s);
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private int getXarpusHealAmount()
    {
        int amount = 0;
        switch (getScale())
        {
            case 5:
                amount = 8;
                break;
            case 4:
                amount = 9;
                break;
            case 3:
                amount = 12;
                break;
            case 2:
                amount = 16;
                break;
            case 1:
                amount = 20;
                break;
        }
        return amount;
    }

    private boolean parseSotetseg()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            parseGeneric("Sote", subData);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case DWH:
                        if (dataManager.get(DataPoint.SOTE_P1_SPLIT) == 0)
                        {
                            dataManager.increment(DataPoint.SOTE_SPECS_P1);
                            dataManager.increment(DataPoint.SOTE_SPECS_TOTAL);
                        } else if (dataManager.get(DataPoint.SOTE_P2_SPLIT) == 0)
                        {
                            dataManager.increment(DataPoint.SOTE_SPECS_P2);
                            dataManager.increment(DataPoint.SOTE_SPECS_TOTAL);
                        } else
                        {
                            dataManager.increment(DataPoint.SOTE_SPECS_P3);
                            dataManager.increment(DataPoint.SOTE_SPECS_TOTAL);
                        }
                        break;
                    case LEFT_TOB:
                        if (dataManager.get(DataPoint.SOTE_TOTAL_TIME) != 0)
                        {
                            soteReset = true;
                        } else
                        {
                            if (!soteStarted)
                            {
                                nyloReset = true;
                            } else
                            {
                                soteWipe = true;
                            }
                        }
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        Date endTime = new Date(Long.parseLong(subData[1]));
                        long difference = endTime.getTime() - raidStarted.getTime();
                        int ticks = (int) (difference / 600);
                        dataManager.set(DataPoint.OVERALL_TIME, ticks);
                        return false;
                    case SOTETSEG_STARTED:
                        soteStarted = true;
                        if (partyComplete)
                        {
                            soteDefenseAccurate = true;
                        }
                        break;
                    case SOTETSEG_FIRST_MAZE_STARTED:
                        dataManager.set(DataPoint.SOTE_P1_SPLIT, Integer.parseInt(subData[4]));
                        break;
                    case SOTETSEG_FIRST_MAZE_ENDED:
                        dataManager.set(DataPoint.SOTE_M1_DURATION, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.SOTE_P1_SPLIT));
                        dataManager.set(DataPoint.SOTE_M1_SPLIT, Integer.parseInt(subData[4]));
                        break;
                    case SOTETSEG_SECOND_MAZE_STARTED:
                        dataManager.set(DataPoint.SOTE_P2_DURATION, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.SOTE_M1_SPLIT));
                        dataManager.set(DataPoint.SOTE_P2_SPLIT, Integer.parseInt(subData[4]));
                        break;
                    case SOTETSEG_SECOND_MAZE_ENDED:
                        dataManager.set(DataPoint.SOTE_M2_DURATION, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.SOTE_P2_SPLIT));
                        dataManager.set(DataPoint.SOTE_M2_SPLIT, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.SOTE_MAZE_SUM, dataManager.get(DataPoint.SOTE_M1_DURATION) + dataManager.get(DataPoint.SOTE_M2_DURATION));
                        break;
                    case SOTETSEG_ENDED:
                        dataManager.set(DataPoint.SOTE_TOTAL_TIME, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.SOTE_P3_DURATION, dataManager.get(DataPoint.SOTE_TOTAL_TIME) - dataManager.get(DataPoint.SOTE_M2_SPLIT));
                        if (isTimeAccurateThroughRoom(NYLOCAS))
                            dataManager.set(DataPoint.XARP_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.SOTE_ENTRY));
                        break loop;
                    case ACCURATE_SOTE_START:
                        soteStartAccurate = true;
                        break;
                    case ACCURATE_SOTE_END:
                        soteEndAccurate = true;
                        soteTimeAccurate = soteStartAccurate;
                        if (soteTimeAccurate && bloatTimeAccurate && !spectated)
                        {
                            nyloStartAccurate = true;
                            nyloEndAccurate = true;
                            nyloTimeAccurate = true;
                        }
                        break;
                    case THRALL_SPAWN:
                        soteThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));
                        break;

                }
            }
            catch(Exception e)
            {
                log.info("Failed on " + s);
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean parseNylo()
    {
        int activeIndex = 0;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            parseGeneric("Nylo", subData);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        if (dataManager.get(NYLOCAS_PILLAR_DESPAWN_TICK) - 5 < dataManager.get(DataPoint.NYLO_BOSS_SPAWN))
                        {
                            dataManager.set(DataPoint.NYLO_BOSS_SPAWN, 0);
                            dataManager.set(DataPoint.NYLO_TOTAL_TIME, 0);
                        }
                        if (dataManager.get(DataPoint.NYLO_TOTAL_TIME) != 0)
                        {
                            nyloReset = true;
                        } else
                        {
                            if (!nyloStarted)
                            {
                                if (!bloatEndAccurate)
                                {
                                    bloatWipe = true;
                                } else
                                {
                                    bloatReset = true;
                                }
                            } else
                            {
                                nyloWipe = true;
                            }
                        }
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        Date endTime = new Date(Long.parseLong(subData[1]));
                        long difference = endTime.getTime() - raidStarted.getTime();
                        int ticks = (int) (difference / 600);
                        dataManager.set(DataPoint.OVERALL_TIME, ticks);
                        return false;
                    case NYLO_PILLAR_SPAWN:
                        nyloStarted = true;
                        break;
                    case NYLO_STALL:
                        nyloWaveStalled.add(Integer.parseInt(subData[5]));
                        dataManager.increment(DataPoint.NYLO_STALLS_TOTAL);
                        if (Integer.parseInt(subData[4]) > 19)
                        {
                            dataManager.increment(DataPoint.NYLO_STALLS_POST_20);
                        } else
                        {
                            dataManager.increment(DataPoint.NYLO_STALLS_PRE_20);
                        }
                        break;
                    case RANGE_SPLIT:
                        dataManager.increment(DataPoint.NYLO_SPLITS_RANGE);
                        break;
                    case MAGE_SPLIT:
                        dataManager.increment(DataPoint.NYLO_SPLITS_MAGE);
                        break;
                    case MELEE_SPLIT:
                        dataManager.increment(DataPoint.NYLO_SPLITS_MELEE);
                        break;
                    case LAST_WAVE:
                        dataManager.set(DataPoint.NYLO_LAST_WAVE, Integer.parseInt(subData[4]));
                        break;
                    case LAST_DEAD:
                        int nyloLastDead = Integer.parseInt(subData[4]);
                        dataManager.set(NYLO_LAST_DEAD, nyloLastDead);
                        int offset = 20 - (nyloLastDead % 4); //4 cycle (16 tick) delay for boss + difference to cycle (4-time%instance reference)
                        dataManager.set(DataPoint.NYLO_BOSS_SPAWN, nyloLastDead + offset);
                        dataManager.set(DataPoint.NYLO_CLEANUP, nyloLastDead - dataManager.get(DataPoint.NYLO_LAST_WAVE));
                        break;
                    case NYLO_WAVE:
                        waveSpawns.put(Integer.parseInt(subData[4]), Integer.parseInt(subData[5]));
                        break;
                    case BOSS_SPAWN: //The number people are used to seeing on timers for boss spawn is actually 2 ticks prior to the spawn call for the boss
                        dataManager.set(DataPoint.NYLO_BOSS_SPAWN, Integer.parseInt(subData[4]) - 2);
                        if (partyComplete)
                        {
                            nyloDefenseAccurate = true;
                        }
                        break;
                    case MELEE_PHASE:
                        dataManager.increment(DataPoint.NYLO_ROTATIONS_MELEE);
                        break;
                    case MAGE_PHASE:
                        dataManager.increment(DataPoint.NYLO_ROTATIONS_MAGE);
                        break;
                    case RANGE_PHASE:
                        dataManager.increment(DataPoint.NYLO_ROTATIONS_RANGE);
                        break;
                    case NYLO_DESPAWNED:
                        if (Integer.parseInt(subData[4]) - dataManager.get(DataPoint.NYLO_BOSS_SPAWN) > 30)
                        {
                            dataManager.set(DataPoint.NYLO_TOTAL_TIME, Integer.parseInt(subData[4]));
                            dataManager.set(DataPoint.NYLO_BOSS_DURATION, dataManager.get(DataPoint.NYLO_TOTAL_TIME) - dataManager.get(DataPoint.NYLO_BOSS_SPAWN));
                            if (isTimeAccurateThroughRoom(BLOAT))
                                dataManager.set(DataPoint.SOTE_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.NYLO_ENTRY));
                        }
                        break loop;
                    case NYLO_PILLAR_DESPAWNED:
                        dataManager.set(NYLOCAS_PILLAR_DESPAWN_TICK, Integer.parseInt(subData[4]));
                        break;
                    case ACCURATE_NYLO_START:
                        nyloStartAccurate = true;
                        break;
                    case ACCURATE_NYLO_END:
                        nyloEndAccurate = true;
                        nyloTimeAccurate = nyloStartAccurate;
                        break;
                    case THRALL_SPAWN:
                        nyloThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));
                        break;
                }
            }
            catch(Exception e)
            {
                log.info("Failed on " + s);
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean parseBloat()
    {
        int activeIndex = 0;
        bloatDefenseAccurate = maidenDefenseAccurate;
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            parseGeneric("Bloat", subData);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case BLOAT_HP_1ST_DOWN:
                        dataManager.set(DataPoint.BLOAT_HP_FIRST_DOWN, Integer.parseInt(subData[4]) / 10);
                        break;
                    case BLOAT_SCYTHE_1ST_WALK:
                        if (dataManager.get(DataPoint.BLOAT_DOWNS) == 0)
                        {
                            dataManager.increment(DataPoint.BLOAT_FIRST_WALK_SCYTHES);
                            dataManager.incrementPlayerSpecific(DataPoint.BLOAT_FIRST_WALK_SCYTHES, subData[4]);
                        }
                        break;
                    case LEFT_TOB:
                        if (bloatEndAccurate)
                        {
                            bloatReset = true;
                        } else
                        {
                            if (!bloatStarted)
                            {
                                maidenReset = true;
                            } else
                            {
                                bloatWipe = true;
                            }
                        }
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        Date endTime = new Date(Long.parseLong(subData[1]));
                        long difference = endTime.getTime() - raidStarted.getTime();
                        int ticks = (int) (difference / 600);
                        dataManager.set(DataPoint.OVERALL_TIME, ticks);
                        return false;
                    case PLAYER_DIED:
                        if (dataManager.get(DataPoint.BLOAT_DOWNS) == 0)
                        {
                            dataManager.increment(DataPoint.BLOAT_FIRST_WALK_DEATHS);
                            dataManager.incrementPlayerSpecific(DataPoint.BLOAT_FIRST_WALK_DEATHS, subData[4]);
                        }
                        break;
                    case BLOAT_SPAWNED:
                        bloatStarted = true;
                        if (partyComplete)
                        {
                            bloatDefenseAccurate = true;
                        }
                        break;
                    case BLOAT_DOWN:
                        if (dataManager.get(DataPoint.BLOAT_DOWNS) == 0)
                        {
                            dataManager.set(DataPoint.BLOAT_FIRST_DOWN_TIME, Integer.parseInt(subData[4]));
                        }
                        dataManager.increment(DataPoint.BLOAT_DOWNS);
                        bloatDowns.add(Integer.parseInt(subData[4]));
                        break;
                    case BLOAT_DESPAWN:
                        dataManager.set(DataPoint.BLOAT_TOTAL_TIME, Integer.parseInt(subData[4]));
                        if (isTimeAccurateThroughRoom(MAIDEN))
                            dataManager.set(DataPoint.NYLO_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.MAIDEN_TOTAL_TIME));
                        break loop;
                    case ACCURATE_BLOAT_START:
                        bloatStartAccurate = true;
                        break;
                    case ACCURATE_BLOAT_END:
                        bloatEndAccurate = true;
                        bloatTimeAccurate = bloatStartAccurate;
                        break;
                    case THRALL_SPAWN:
                        bloatThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));
                        break;
                }
            }
            catch(Exception e)
            {
                log.info("Failed on " + s);
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private boolean parseMaiden()
    {
        int activeIndex = 0;
        String lastProc = " 70s";
        loop:
        for (String s : globalData)
        {
            String[] subData = s.split(",", -1);
            parseGeneric("Maiden", subData);
            try
            {
                switch (LogID.valueOf(Integer.parseInt(subData[3])))
                {
                    case LEFT_TOB:
                        int percent = 100;
                        if (dataManager.get(DataPoint.MAIDEN_CHINS_THROWN) != 0)
                        {
                            double percentDouble = ((double) (dataManager.get(DataPoint.MAIDEN_CHINS_THROWN_WRONG_DISTANCE)) / dataManager.get(DataPoint.MAIDEN_CHINS_THROWN)) * 100;
                            percent = (int) percentDouble;
                        }
                        dataManager.set(DataPoint.MAIDEN_CHIN_CORRECT_DISTANCE_PERCENT, percent);
                        if (dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) != 0)
                        {
                            maidenReset = true;
                        } else
                        {
                            if (!maidenSpawned)
                            {
                                maidenReset = true;
                                resetBeforeMaiden = true;
                            } else
                            {
                                maidenWipe = true;
                            }
                        }
                        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
                        Date endTime = new Date(Long.parseLong(subData[1]));
                        long difference = endTime.getTime() - raidStarted.getTime();
                        int ticks = (int) (difference / 600);
                        dataManager.set(DataPoint.OVERALL_TIME, ticks);
                        return false;
                    case BLOOD_THROWN:
                        dataManager.increment(DataPoint.MAIDEN_BLOOD_THROWN);
                        break;
                    case BLOOD_SPAWNED:
                        dataManager.increment(DataPoint.MAIDEN_BLOOD_SPAWNED);
                        break;
                    case CRAB_LEAK:
                        if (dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) == 0) //TODO: see case 16 fix
                        {
                            dataManager.increment(DataPoint.MAIDEN_CRABS_LEAKED);
                            int crabHP = -1;
                            try
                            {
                                crabHP = Integer.parseInt(subData[5]);

                                maidenCrabs.add(new StringInt(subData[4], crabHP));
                            } catch (Exception ignored)
                            {
                            }
                            dataManager.increment(DataPoint.MAIDEN_HP_HEALED, crabHP * 2);
                            int maxCrabHP = 100;
                            switch (players.size())
                            {
                                case 1:
                                case 2:
                                case 3:
                                    maxCrabHP = 75;
                                    break;
                                case 4:
                                    maxCrabHP = 87;
                                    break;
                            }
                            if (crabHP == maxCrabHP)
                            {
                                dataManager.increment(DataPoint.MAIDEN_CRABS_LEAKED_FULL_HP);
                            }

                            if (subData[4].contains("30"))
                            {
                                maidenSkip = false;
                            }
                        }
                        break;
                    case MAIDEN_PLAYER_DRAINED:
                        dataManager.increment(DataPoint.MAIDEN_MELEE_DRAINS);
                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_MELEE_DRAINS, subData[4]);
                        break;
                    case MAIDEN_SPAWNED:
                        maidenSpawned = true;
                        if (partyComplete)
                        {
                            maidenDefenseAccurate = true;
                        }
                        break;
                    case MAIDEN_70S:
                        dataManager.set(DataPoint.MAIDEN_70_SPLIT, Integer.parseInt(subData[4]));
                        lastProc = " 70s";
                        break;
                    case MAIDEN_50S:
                        dataManager.set(DataPoint.MAIDEN_50_SPLIT, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.MAIDEN_7050_SPLIT, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.MAIDEN_70_SPLIT));
                        lastProc = " 50s";
                        break;
                    case MAIDEN_30S:
                        dataManager.set(DataPoint.MAIDEN_30_SPLIT, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.MAIDEN_5030_SPLIT, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.MAIDEN_50_SPLIT));
                        lastProc = " 30s";
                        break;
                    case MAIDEN_0HP:
                        dataManager.set(DataPoint.MAIDEN_TOTAL_TIME, Integer.parseInt(subData[4]) + 7);
                        dataManager.set(DataPoint.MAIDEN_SKIP_SPLIT, dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) - dataManager.get(DataPoint.MAIDEN_30_SPLIT));
                        if (globalData.get(activeIndex + 1).split(",", -1)[3].equals("4"))
                            maidenReset = true;
                        break loop;
                    case MAIDEN_DESPAWNED:
                        dataManager.set(DataPoint.MAIDEN_TOTAL_TIME, Integer.parseInt(subData[4]));
                        dataManager.set(DataPoint.MAIDEN_SKIP_SPLIT, dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) - dataManager.get(DataPoint.MAIDEN_30_SPLIT));
                        if (globalData.get(activeIndex + 1).split(",", -1)[3].equals("4"))
                            maidenReset = true;
                        break loop;
                    case MATOMENOS_SPAWNED:
                        maidenCrabSpawn.add(subData[4]);
                        break;
                    case MAIDEN_SCUFFED:
                        if (!maidenScuffed)
                        {
                            firstMaidenCrabScuffed = lastProc;
                            if(!maidenCrabSpawn.isEmpty())
                            {
                                firstMaidenCrabScuffed = maidenCrabSpawn.get(maidenCrabSpawn.size()-1);
                            }
                        }
                        maidenScuffed = true;
                        break;
                    case BLOAT_SPAWNED:
                        //todo: joined after maiden was kill. mark this somehow?
                        maidenReset = true; //TODO remove
                        break loop;
                    case SPECTATE:
                        spectated = true;
                        break;
                    case MAIDEN_DINHS_SPEC:
                        dataManager.increment(DataPoint.MAIDEN_DINHS_SPECS);
                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_DINHS_SPECS, subData[4]);
                        String[] targets = subData[6].split(":");
                        int targetCountThisSpec = 0;
                        int crabCountThisSpec = 0;
                        String[] specData = subData[7].split(":");
                        if (specData.length != 5)
                        {
                            break;
                        }
                        for (String target : targets)
                        {
                            String[] targetData = target.split("~");
                            if (targetData.length == 3)
                            {
                                targetCountThisSpec++;
                                String spawnID = targetData[1];
                                if (!spawnID.equals("^")) //Target is crab
                                {
                                    crabCountThisSpec++;
                                }
                            }
                        }
                        int averageHP = Integer.parseInt(specData[0]);
                        int belowThreshold = Integer.parseInt(specData[1]);
                        if (dataManager.get(DataPoint.MAIDEN_DINHS_SPECS) == 0)
                        {
                            int percentCrabsTargeted = (int) ((((double) crabCountThisSpec) / targetCountThisSpec) * 100);
                            int percentCrabsUnder27Targeted = (int) ((((double) belowThreshold) / crabCountThisSpec) * 100);

                            dataManager.set(DataPoint.MAIDEN_DINHS_TARGETS_HIT, targetCountThisSpec);
                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_HIT, crabCountThisSpec);
                            dataManager.set(DataPoint.MAIDEN_DINHS_AVERAGE_HP_HIT, averageHP);
                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED, belowThreshold);
                            dataManager.set(DataPoint.MAIDEN_DINHS_PERCENT_TARGETS_CRAB, percentCrabsTargeted);
                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED_PERCENT, percentCrabsUnder27Targeted);
                        } else
                        {
                            int previousAverage = dataManager.get(DataPoint.MAIDEN_DINHS_AVERAGE_HP_HIT);
                            int previousCrabsHit = dataManager.get(DataPoint.MAIDEN_DINHS_CRABS_HIT);
                            int previousTotalHit = dataManager.get(DataPoint.MAIDEN_DINHS_TARGETS_HIT);
                            int previousBelow27Hit = dataManager.get(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED);

                            dataManager.set(DataPoint.MAIDEN_DINHS_TARGETS_HIT, previousTotalHit + targetCountThisSpec);
                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_HIT, previousCrabsHit + crabCountThisSpec);
                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED, previousBelow27Hit + belowThreshold);

                            int roundedAverageSum = ((previousAverage * previousCrabsHit) + (averageHP * crabCountThisSpec));
                            int roundedAverageCumulative = (int) (((double) roundedAverageSum) / (previousCrabsHit + crabCountThisSpec));

                            dataManager.set(DataPoint.MAIDEN_DINHS_AVERAGE_HP_HIT, roundedAverageCumulative);

                            int percentTargetedCumulative = (int) (((double) (previousCrabsHit + crabCountThisSpec) / (previousTotalHit + targetCountThisSpec)) * 100);

                            dataManager.set(DataPoint.MAIDEN_DINHS_PERCENT_TARGETS_CRAB, percentTargetedCumulative);

                            int percentBelow27Cumulative = (int) ((double) (previousBelow27Hit + belowThreshold) / (previousCrabsHit + crabCountThisSpec));

                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED_PERCENT, percentBelow27Cumulative);
                        }
                        break;
                    case MAIDEN_CHIN_THROWN:
                        dataManager.increment(DataPoint.MAIDEN_CHINS_THROWN);
                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_CHINS_THROWN, subData[4]);
                        if (Integer.parseInt(subData[5]) < 4 || Integer.parseInt(subData[5]) > 6)
                        {
                            dataManager.increment(DataPoint.MAIDEN_CHINS_THROWN_WRONG_DISTANCE);
                            dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_CHINS_THROWN_WRONG_DISTANCE, subData[4]);
                        }
                        break;
                    case ACCURATE_MAIDEN_START:
                        maidenStartAccurate = true;
                        break;
                    case ACCURATE_MAIDEN_END:
                        maidenEndAccurate = true;
                        maidenTimeAccurate = maidenStartAccurate;
                        break;
                    case THRALL_SPAWN:
                        maidenThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));
                        break;
                    case PLAYER_STOOD_IN_THROWN_BLOOD:
                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_THROWN_BLOOD);
                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_THROWN_BLOOD, Integer.parseInt(subData[5]));

                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD);
                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, Integer.parseInt(subData[5]));

                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_THROWN_BLOOD, subData[4]);
                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_THROWN_BLOOD, subData[4], Integer.parseInt(subData[5]));

                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD, subData[4]);
                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, subData[4], Integer.parseInt(subData[5]));
                        break;
                    case PLAYER_STOOD_IN_SPAWNED_BLOOD:
                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_SPAWNED_BLOOD);
                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_SPAWNED_BLOOD, Integer.parseInt(subData[5]));

                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD);
                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, Integer.parseInt(subData[5]));

                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_SPAWNED_BLOOD, subData[4]);
                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_SPAWNED_BLOOD, subData[4], Integer.parseInt(subData[5]));

                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD, subData[4]);
                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, subData[4], Integer.parseInt(subData[5]));
                        break;
                }
            }
            catch(Exception e)
            {
                log.info("Failed on " + s);
            }
            activeIndex++;
        }
        globalData = new ArrayList<>(globalData.subList(activeIndex + 1, globalData.size()));
        return true;
    }

    private void finishRaid()
    {
        raidCompleted = true;
    }


    public String getScaleString()
    {
        String scaleString = "";
        switch (players.size())
        {
            case 1:
                scaleString = "Solo";
                break;
            case 2:
                scaleString = "Duo";
                break;
            case 3:
                scaleString = "Trio";
                break;
            case 4:
                scaleString = "4 Man";
                break;
            case 5:
                scaleString = "5 Man";
                break;
        }
        if (storyMode)
        {
            scaleString += " (Story)";
        }
        if (hardMode)
        {
            scaleString += " (Hard)";
        }
        return scaleString;
    }

    public String getRoomStatus()
    {
        String raidStatusString;
        if (maidenWipe)
        {
            raidStatusString = "Maiden Wipe";
        } else if (maidenReset)
        {
            raidStatusString = "Maiden Reset";
            if (!maidenSpawned)
            {
                raidStatusString += "*";
            }
        } else if (bloatWipe)
        {
            raidStatusString = "Bloat Wipe";
        } else if (bloatReset)
        {
            raidStatusString = "Bloat Reset";
            if (getBloatTime() == 0)
            {
                raidStatusString += "*";
            }
        } else if (nyloWipe)
        {
            raidStatusString = "Nylo Wipe";
        } else if (nyloReset)
        {
            raidStatusString = "Nylo Reset";
            if (getNyloTime() == 0)
            {
                raidStatusString += "*";
            }
        } else if (soteWipe)
        {
            raidStatusString = "Sotetseg Wipe";
        } else if (soteReset)
        {
            raidStatusString = "Sotetseg Reset";
            if (getSoteTime() == 0)
            {
                raidStatusString += "*";
            }
        } else if (xarpWipe)
        {
            raidStatusString = "Xarpus Wipe";
        } else if (xarpReset)
        {
            raidStatusString = "Xarpus Reset";
            if (getXarpTime() == 0)
            {
                raidStatusString += "*";
            }
        } else if (verzikWipe)
        {
            raidStatusString = "Verzik Wipe";
        } else
        {
            raidStatusString = "Completion";
            if (!getOverallTimeAccurate())
            {
                raidStatusString += "*";
            }
        }
        String red = "<html><font color='#FF0000'>";
        String green = "<html><font color='#44AF33'>";
        String yellow = "<html><font color='#EEEE44'>";
        if (raidStatusString.contains("Completion"))
        {
            raidStatusString = green + raidStatusString;
        } else if (raidStatusString.contains("Reset"))
        {
            raidStatusString = yellow + raidStatusString;
        } else
        {
            raidStatusString = red + raidStatusString;
        }
        return raidStatusString;
    }
}


package com.advancedraidtracker.rooms.tob;

import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.constants.TOBRoom;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import com.advancedraidtracker.utility.Point;
import com.advancedraidtracker.utility.RoomUtil;
import com.advancedraidtracker.utility.datautility.DataWriter;

import java.util.ArrayList;

import static com.advancedraidtracker.constants.LogID.*;
import static com.advancedraidtracker.constants.TobIDs.*;
import static com.advancedraidtracker.utility.RoomState.*;
import static com.advancedraidtracker.utility.RoomState.BloatRoomState.*;

@Slf4j
public class BloatHandler extends RoomHandler
{
    public BloatRoomState roomState;

    private final ArrayList<Integer> walks = new ArrayList<>();
    private final ArrayList<Integer> downs = new ArrayList<>();
    private int bloatStartTick = -1;
    private int bloatDeferTick = -1;
    private int bloatDeathTick = -1;
    private final AdvancedRaidTrackerPlugin plugin;

    public BloatHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)
    {
        super(client, clog, config);
        this.plugin = plugin;
        roomState = NOT_STARTED;
    }

    public boolean isActive()
    {
        return !(roomState == NOT_STARTED || roomState == FINISHED);
    }

    public String getName()
    {
        return "Bloat";
    }

    public void reset()
    {
        roomState = NOT_STARTED;
        bloatDeferTick = -1;
        accurateEntry = true;
        bloatStartTick = -1;
        bloatDeathTick = -1;
        walks.clear();
        downs.clear();
        super.reset();
    }

    public void endBloat()
    {
        roomState = FINISHED;
        bloatDeathTick = client.getTickCount() + BLOAT_DEATH_ANIMATION_LENGTH;
        plugin.addDelayedLine(TOBRoom.BLOAT, client.getTickCount() - bloatStartTick, "Dead");
        clog.addLine(ACCURATE_BLOAT_END);
        plugin.liveFrame.setBloatFinished(bloatDeathTick - bloatStartTick);
        if (bloatStartTick != -1)
        {
            sendTimeMessage("Wave 'Bloat last down' complete! Duration: ", splitLastDown(), " Room time: ", bloatDeathTick - bloatStartTick, true);
        }
    }

    public int splitLastDown()
    {
        if (bloatDeathTick != -1)
        {
            if (walks.size() == downs.size() + 1)
            {
                return bloatDeathTick - walks.get(walks.size() - 1);
            } else if (walks.size() == downs.size())
            {
                return bloatDeathTick - downs.get(walks.size() - 1);
            } else
            {
                return -1;
            }
        } else
        {
            return -1;
        }
    }

    public void start()
    {
        bloatStartTick = client.getTickCount();
        roomStartTick = client.getTickCount();
        roomState = WALKING;
    }

    private int getLastWalk()
    {
        if (!downs.isEmpty() && !walks.isEmpty() && downs.size() == walks.size())
        {
            return downs.get(downs.size() - 1) - walks.get(walks.size() - 1);
        } else
        {
            return -1;
        }
    }

    private int getLastDownTime()
    {
        if (!downs.isEmpty())
        {
            return downs.get(downs.size() - 1) - bloatStartTick;
        } else
        {
            return -1;
        }
    }

    private double deferHP = -1;

    public void down()
    {
        clog.addLine(BLOAT_DOWN, String.valueOf(client.getTickCount() - bloatStartTick));
        if (downs.isEmpty())
        {
            int currentBloatHP = client.getVarbitValue(HP_VARBIT);
            clog.addLine(BLOAT_HP_1ST_DOWN, String.valueOf(currentBloatHP));
        }
        downs.add(client.getTickCount());
        roomState = DOWN;
        if (bloatStartTick != -1)
        {
            deferHP = client.getVarbitValue(HP_VARBIT) / 10.0;
            bloatDeferTick = client.getTickCount() + 5; //delay so that the chat message can't be used to know immediately know when bloat has gone down
        }
        plugin.addDelayedLine(TOBRoom.BLOAT, client.getTickCount() - bloatStartTick, "Down");
    }

    public void walk()
    {
        walks.add(client.getTickCount());
        plugin.addDelayedLine(TOBRoom.BLOAT, client.getTickCount() - bloatStartTick, "Moving");
        roomState = WALKING;
    }

    public void updateGameTick(GameTick event)
    {
        if (bloatDeferTick != -1 && bloatDeferTick == client.getTickCount())
        {
            sendTimeMessage("Wave 'Bloat walk' complete! Duration: ", getLastWalk(), getLastDownTime(), true, ", HP: " + deferHP + "%");
            bloatDeferTick = -1;
        }
        if (bloatStartTick == -1)
        { //room time starts when player enters either gate in the bloat region
            if (RoomUtil.crossedLine(BLOAT_REGION, new Point(39, 30), new Point(39, 33), true, client)
                    || RoomUtil.crossedLine(BLOAT_REGION, new Point(24, 30), new Point(24, 33), true, client))
            {
                start();
                walk();
            }
        }

        if (NyloHandler.instanceStart == -1)
        { //Nylo instance timer is started when the first player crosses the unreachable line by the bloat chest
            if (RoomUtil.crossedLine(BLOAT_REGION, new Point(4, 31), new Point(4, 32), true, client))
            {
                NyloHandler.instanceStart = client.getTickCount();
            }
        }
    }

    public void updateAnimationChanged(AnimationChanged event)
    {
        if (event.getActor().getAnimation() == BLOAT_DOWN_ANIMATION)
        {
            down();
        } else if (event.getActor().getName() != null && event.getActor().getAnimation() == -1 && event.getActor().getName().contains("Bloat"))
        {
            walk();
        }
        if (event.getActor().getAnimation() == BLOAT_DEATH_ANIMATION)
        {
            endBloat();
        }
        if (event.getActor().getAnimation() == SCYTHE_ANIMATION)
        {
            if (event.getActor() instanceof Player)
            {
                Player p = (Player) event.getActor();
                clog.addLine(BLOAT_SCYTHE_1ST_WALK, p.getName(), String.valueOf(client.getTickCount() - bloatStartTick));
            }
        }
    }

    public void updateNpcSpawned(NpcSpawned event)
    {
        boolean story = false;
        switch (event.getNpc().getId())
        {
            case BLOAT_SM:
                story = true;
                clog.addLine(IS_STORY_MODE);
            case BLOAT_HM:
                if (!story)
                    clog.addLine(IS_HARD_MODE);
            case BLOAT:
                clog.addLine(BLOAT_SPAWNED);
                if (client.getVarbitValue(ROOM_ACTIVE_VARBIT) != 0)
                {
                    accurateEntry = false;
                } else
                {
                    clog.addLine(ACCURATE_BLOAT_START);
                    clog.addLine(BLOAT_DIRECTION, String.valueOf(event.getNpc().getCurrentOrientation()), String.valueOf(event.getNpc().getIndex()));
                }
                break;
        }
    }

    public void updateNpcDespawned(NpcDespawned event)
    {
        int id = event.getNpc().getId();
        if (id == BLOAT || id == BLOAT_HM || id == BLOAT_SM)
        {
            clog.addLine(BLOAT_DESPAWN, String.valueOf(client.getTickCount() - bloatStartTick));
        }
    }

    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)
    {
        int id = event.getGraphicsObject().getId();
        if(id == 1570 || id == 1571 || id == 1572 || id == 1573) //various bloat hands
        {
            WorldPoint wp = WorldPoint.fromLocal(client, event.getGraphicsObject().getLocation());
            clog.addLine(BLOAT_HAND, String.valueOf(id), String.valueOf(wp.getRegionX()), String.valueOf(wp.getRegionY()), String.valueOf(client.getTickCount()-roomStartTick));
        }
    }
}

package com.advancedraidtracker.rooms.tob;

import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.constants.TOBRoom;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import com.advancedraidtracker.utility.datautility.DataWriter;
import com.advancedraidtracker.utility.RoomState;
import com.advancedraidtracker.utility.nyloutility.NylocasData;
import com.advancedraidtracker.utility.nyloutility.NylocasShell;
import com.advancedraidtracker.utility.nyloutility.NylocasWave;
import com.advancedraidtracker.utility.nyloutility.NylocasWaveMatcher;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

import static com.advancedraidtracker.constants.LogID.*;
import static com.advancedraidtracker.constants.TobIDs.*;
import static com.advancedraidtracker.utility.RoomState.NyloRoomState.*;

@Slf4j
public class NyloHandler extends RoomHandler
{
    public RoomState.NyloRoomState roomState;
    private final ArrayList<NylocasShell> buildWave;

    public NyloHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)
    {
        super(client, clog, config);
        this.plugin = plugin;
        buildWave = new ArrayList<>();
        nylosAlive = new ArrayList<>();
        roomState = NOT_STARTED;
    }

    public static int instanceStart = -1;
    private int pillarsSpawnedTick = -1;
    private int instanceReference = -1;
    private int bossSpawn = -1;
    private int lastDead = -1;
    private int entryTickOffset = -1;
    private int wave31 = -1;
    private final ArrayList<NPC> nylosAlive;
    int currentWave = 0;
    boolean hard = false;
    boolean story = false;
    private final AdvancedRaidTrackerPlugin plugin;
    ArrayList<NPC> bigsDeadThisTick = new ArrayList<>();
    Map<Integer, String> bigDescription = new HashMap<>();

    public void reset()
    {
        currentWave = 0;
        roomState = NOT_STARTED;
        pillarsSpawnedTick = -1;
        instanceReference = -1;
        instanceStart = -1;
        bossSpawn = -1;
        lastDead = -1;
        accurateEntry = true;
        entryTickOffset = -1;
        hard = false;
        story = false;
        wave31 = -1;
        bigsDeadThisTick.clear();
        bigDescription.clear();
        super.reset();
    }

    public boolean isActive()
    {
        return !(roomState == NOT_STARTED || roomState == FINISHED);
    }

    public String getName()
    {
        return "Nylocas";
    }

    private int expectedWaveTick;

    public void updateGameTick(GameTick event)
    {
        bigsDeadThisTick.clear();
        if (!buildWave.isEmpty())
        {
            if (NylocasWaveMatcher.isWave(buildWave))
            {
                NylocasWave wave = NylocasWaveMatcher.getWave();
                if (wave.getWave() == 1)
                {
                    wave1Spawn();
                }
                if (wave.getWave() == 31)
                {
                    wave31Spawn();
                } else
                {
                    expectedWaveTick = client.getTickCount() + ((hard && wave.getWave() % 10 == 0) ? 16 : NylocasWave.waves[wave.getWave()].getDelay());
                    if (hard && (wave.getWave() % 10 == 0)) //in hard mode each wave a prinkipas comes out on (10, 20, 30) has been changed to a 4 cycle natural delay
                    {
                        expectedWaveTick = client.getTickCount() + 16;
                    }
                }
                currentWave = wave.getWave();
                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, "W" + currentWave);
                clog.addLine(NYLO_WAVE, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));
            }
            buildWave.clear();
        }
        if (client.getTickCount() == expectedWaveTick && currentWave != 31)
        {
            clog.addLine(NYLO_STALL, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick), String.valueOf(nylosAlive.size()));
            plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, "Stall");
            expectedWaveTick += 4;
        }
    }

    public void updateNpcSpawned(NpcSpawned event)
    {
        switch (event.getNpc().getId())
        {
            case NYLO_MELEE_SMALL_HM:
            case NYLO_MELEE_SMALL_AGRO_HM:
            case NYLO_MELEE_BIG_HM:
            case NYLO_MELEE_BIG_AGRO_HM:
            case NYLO_RANGE_SMALL_HM:
            case NYLO_RANGE_SMALL_AGRO_HM:
            case NYLO_RANGE_BIG_HM:
            case NYLO_RANGE_BIG_AGRO_HM:
            case NYLO_MAGE_SMALL_HM:
            case NYLO_MAGE_SMALL_AGRO_HM:
            case NYLO_MAGE_BIG_HM:
            case NYLO_MAGE_BIG_AGRO_HM:
                if (!hard)
                {
                    clog.addLine(IS_HARD_MODE);
                }
                hard = true;
            case NYLO_MELEE_SMALL_SM:
            case NYLO_MELEE_SMALL_AGRO_SM:
            case NYLO_MELEE_BIG_SM:
            case NYLO_MELEE_BIG_AGRO_SM:
            case NYLO_RANGE_SMALL_SM:
            case NYLO_RANGE_SMALL_AGRO_SM:
            case NYLO_RANGE_BIG_SM:
            case NYLO_RANGE_BIG_AGRO_SM:
            case NYLO_MAGE_SMALL_SM:
            case NYLO_MAGE_SMALL_AGRO_SM:
            case NYLO_MAGE_BIG_SM:
            case NYLO_MAGE_BIG_AGRO_SM:
                if (!hard)
                {
                    if (!story)
                    {
                        clog.addLine(IS_STORY_MODE);
                    }
                }
                story = true;
            case NYLO_MELEE_BIG:
            case NYLO_MELEE_BIG_AGRO:
            case NYLO_RANGE_BIG:
            case NYLO_RANGE_BIG_AGRO:
            case NYLO_MAGE_BIG:
            case NYLO_MAGE_BIG_AGRO:
            case NYLO_MELEE_SMALL:
            case NYLO_MELEE_SMALL_AGRO:
            case NYLO_RANGE_SMALL:
            case NYLO_RANGE_SMALL_AGRO:
            case NYLO_MAGE_SMALL:
            case NYLO_MAGE_SMALL_AGRO:
                if(pillarsSpawnedTick == -1)
                {
                    startNylo();
                }
                NylocasShell cShell = new NylocasShell(event.getNpc().getId(), event.getNpc().getWorldLocation().getRegionX(), event.getNpc().getWorldLocation().getRegionY());
                if (cShell.isBig())
                {
                    bigDescription.put(event.getNpc().getIndex(), "W" + (currentWave + 1) + " " + cShell.getDescription());
                }
                if (cShell.position != NylocasData.NyloPosition.ROOM)
                {
                    buildWave.add(cShell);
                    plugin.liveFrame.getPanel(getName()).addNPCMapping(event.getNpc().getIndex(), "W" + (currentWave + 1) + " " + cShell.getDescription());
                    clog.addLine(ADD_NPC_MAPPING, String.valueOf(event.getNpc().getIndex()), "W" + (currentWave + 1) + " " + cShell.getDescription());
                } else
                {
                    int matches = 0;
                    String lastMatchedDescription = "";
                    for (NPC npc : bigsDeadThisTick)
                    {
                        int bigX = npc.getWorldLocation().getRegionX();
                        int bigY = npc.getWorldLocation().getRegionY();
                        int littleX = event.getNpc().getWorldLocation().getRegionX();
                        int littleY = event.getNpc().getWorldLocation().getRegionY();
                        if ((bigX == littleX && bigY == littleY) || (littleX - 1 == bigX || littleY - 1 == bigY))
                        {
                            matches++;
                            lastMatchedDescription = bigDescription.get(npc.getIndex());
                        }
                    }
                    if (matches == 1)
                    {
                        clog.addLine(ADD_NPC_MAPPING, String.valueOf(event.getNpc().getIndex()), NylocasShell.getTypeName(event.getNpc().getId()) + " split from " + lastMatchedDescription + "(on w" + currentWave + ")");
                        plugin.liveFrame.getPanel(getName()).addNPCMapping(event.getNpc().getIndex(), NylocasShell.getTypeName(event.getNpc().getId()) + " split from " + lastMatchedDescription + "(on w" + currentWave + ")");
                    }
                    switch (event.getNpc().getId())
                    {
                        case NYLO_MELEE_SMALL:
                        case NYLO_MELEE_SMALL_AGRO:
                        case NYLO_MELEE_SMALL_HM:
                        case NYLO_MELEE_SMALL_AGRO_HM:
                        case NYLO_MELEE_SMALL_SM:
                        case NYLO_MELEE_SMALL_AGRO_SM:
                            clog.addLine(MELEE_SPLIT, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));
                            break;
                        case NYLO_RANGE_SMALL:
                        case NYLO_RANGE_SMALL_AGRO:
                        case NYLO_RANGE_SMALL_HM:
                        case NYLO_RANGE_SMALL_AGRO_HM:
                        case NYLO_RANGE_SMALL_SM:
                        case NYLO_RANGE_SMALL_AGRO_SM:
                            clog.addLine(RANGE_SPLIT, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));
                            break;
                        case NYLO_MAGE_SMALL:
                        case NYLO_MAGE_SMALL_AGRO:
                        case NYLO_MAGE_SMALL_HM:
                        case NYLO_MAGE_SMALL_AGRO_HM:
                        case NYLO_MAGE_SMALL_SM:
                        case NYLO_MAGE_SMALL_AGRO_SM:
                            clog.addLine(MAGE_SPLIT, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));
                            break;
                    }
                }
                nylosAlive.add(event.getNpc());
                break;
            case NYLO_BOSS_MELEE:
            case NYLO_BOSS_RANGE:
            case NYLO_BOSS_MAGE:
            case NYLO_BOSS_MELEE_HM:
            case NYLO_BOSS_RANGE_HM:
            case NYLO_BOSS_MAGE_HM:
            case NYLO_BOSS_MELEE_SM:
            case NYLO_BOSS_RANGE_SM:
            case NYLO_BOSS_MAGE_SM:
                bossSpawned();
                if(pillarsSpawnedTick == -1)
                {
                    startNylo();
                }
                break;
            case NYLO_PILLAR:
            case NYLO_PILLAR_HM:
            case NYLO_PILLAR_SM:
                if (pillarsSpawnedTick == -1)
                {
                    startNylo();
                }
                break;
            case NYLO_PRINKIPAS_DROPPING:
                break;
            case NYLO_PRINKIPAS_MELEE:
            case NYLO_PRINKIPAS_MAGIC:
            case NYLO_PRINKIPAS_RANGE:
                nylosAlive.add(event.getNpc());
                break;

        }
    }

    public void updateNpcDespawned(NpcDespawned event)
    {
        switch (event.getNpc().getId())
        {
            case NYLO_PILLAR:
            case NYLO_PILLAR_HM:
            case NYLO_PILLAR_SM:
                clog.addLine(NYLO_PILLAR_DESPAWNED, String.valueOf(client.getTickCount() - pillarsSpawnedTick));
                break;
            case NYLO_BOSS_MELEE:
            case NYLO_BOSS_RANGE:
            case NYLO_BOSS_MAGE:
            case NYLO_BOSS_MELEE_HM:
            case NYLO_BOSS_RANGE_HM:
            case NYLO_BOSS_MAGE_HM:
            case NYLO_BOSS_MELEE_SM:
            case NYLO_BOSS_RANGE_SM:
            case NYLO_BOSS_MAGE_SM:
            {
                bossKilled();
            }
            break;
            case NYLO_MELEE_BIG:
            case NYLO_MELEE_BIG_AGRO:
            case NYLO_MAGE_BIG:
            case NYLO_MAGE_BIG_AGRO:
            case NYLO_RANGE_BIG:
            case NYLO_RANGE_BIG_AGRO:
            case NYLO_MELEE_BIG_HM:
            case NYLO_MELEE_BIG_AGRO_HM:
            case NYLO_RANGE_BIG_HM:
            case NYLO_RANGE_BIG_AGRO_HM:
            case NYLO_MAGE_BIG_HM:
            case NYLO_MAGE_BIG_AGRO_HM:
            case NYLO_MELEE_BIG_SM:
            case NYLO_MELEE_BIG_AGRO_SM:
            case NYLO_RANGE_BIG_SM:
            case NYLO_RANGE_BIG_AGRO_SM:
            case NYLO_MAGE_BIG_SM:
            case NYLO_MAGE_BIG_AGRO_SM:
                bigsDeadThisTick.add(event.getNpc());
            case NYLO_MELEE_SMALL_HM:
            case NYLO_MELEE_SMALL_AGRO_HM:
            case NYLO_RANGE_SMALL_HM:
            case NYLO_RANGE_SMALL_AGRO_HM:
            case NYLO_MAGE_SMALL_HM:
            case NYLO_MAGE_SMALL_AGRO_HM:
            case NYLO_MELEE_SMALL_SM:
            case NYLO_MELEE_SMALL_AGRO_SM:
            case NYLO_RANGE_SMALL_SM:
            case NYLO_RANGE_SMALL_AGRO_SM:
            case NYLO_MAGE_SMALL_SM:
            case NYLO_MAGE_SMALL_AGRO_SM:
            case NYLO_MELEE_SMALL:
            case NYLO_MELEE_SMALL_AGRO:
            case NYLO_RANGE_SMALL:
            case NYLO_RANGE_SMALL_AGRO:
            case NYLO_MAGE_SMALL:
            case NYLO_MAGE_SMALL_AGRO:
            case NYLO_PRINKIPAS_DROPPING:
            case NYLO_PRINKIPAS_MELEE:
            case NYLO_PRINKIPAS_MAGIC:
            case NYLO_PRINKIPAS_RANGE:
                nylosAlive.remove(event.getNpc());
                if (nylosAlive.isEmpty() && NylocasWaveMatcher.getWave().getWave() == 31)
                {
                    cleanupOver();
                }
                break;
            default:
                break;
        }
    }

    /**
     * Handles saving data about boss phases.
     *
     * @param id ID of new form
     */
    public void handleNPCChanged(int id)
    {
        switch (id)
        {
            case NYLO_BOSS_MELEE:
            case NYLO_BOSS_MELEE_HM:
            case NYLO_BOSS_MELEE_SM:
                clog.addLine(MELEE_PHASE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));
                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, "Phase");
                break;
            case NYLO_BOSS_MAGE:
            case NYLO_BOSS_MAGE_HM:
            case NYLO_BOSS_MAGE_SM:
                clog.addLine(MAGE_PHASE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));
                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, "Phase");
                break;
            case NYLO_BOSS_RANGE:
            case NYLO_BOSS_RANGE_HM:
            case NYLO_BOSS_RANGE_SM:
                clog.addLine(RANGE_PHASE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));
                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, "Phase");
                break;
        }
    }

    private void startNylo()
    {
        if (client.getNpcs().stream().anyMatch(p -> Objects.requireNonNull(p.getName()).toLowerCase().contains("nylo")))
        {
            accurateEntry = false;
        }
        else
        {
            clog.addLine(ACCURATE_NYLO_START);
        }
        clog.addLine(NYLO_PILLAR_SPAWN);
        roomState = WAVES;
        pillarsSpawnedTick = client.getTickCount();
        roomStartTick = client.getTickCount();
    }

    private void wave1Spawn()
    {
        instanceReference = client.getTickCount();
        entryTickOffset = (instanceReference - pillarsSpawnedTick - 4);
    }

    private void wave31Spawn()
    {
        clog.addLine(LAST_WAVE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));
        roomState = CLEANUP;
        int stalls = (client.getTickCount() - pillarsSpawnedTick - entryTickOffset - 236) / 4;
        wave31 = client.getTickCount();
        sendTimeMessage("Wave 'Nylocas last wave' complete! Duration: ", wave31 - pillarsSpawnedTick, " Stalls: ", stalls);
    }

    private void cleanupOver()
    {
        roomState = WAITING_FOR_BOSS;
        lastDead = client.getTickCount();
        clog.addLine(ACCURATE_NYLO_END);
        clog.addLine(LAST_DEAD, String.valueOf(lastDead - pillarsSpawnedTick));
        sendTimeMessage("Wave 'Nylocas waves and cleanup' complete! Duration: ", lastDead - pillarsSpawnedTick, lastDead - wave31);
    }

    private void bossSpawned()
    {
        clog.addLine(BOSS_SPAWN, String.valueOf(client.getTickCount() - pillarsSpawnedTick));
        roomState = BOSS;
        bossSpawn = client.getTickCount() - 2;
        plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick - 2, "W" + currentWave);
        sendTimeMessage("Wave 'Nylocas boss spawn' complete! Duration: ", bossSpawn - pillarsSpawnedTick, bossSpawn - lastDead);
    }

    private void bossKilled()
    {
        roomState = FINISHED;
        int deathTick = client.getTickCount();
        int offset1 = 4 - ((deathTick - instanceReference) % 4);
        if ((4 - ((deathTick - instanceReference) % 4) == 4))
        {
            offset1 = 0;
        }
        plugin.liveFrame.setNyloFinished(deathTick - pillarsSpawnedTick + offset1);
        sendTimeMessage("Wave 'Nylocas boss' complete! Duration: ", deathTick - pillarsSpawnedTick + offset1, deathTick + offset1 - bossSpawn, false);
        clog.addLine(NYLO_DESPAWNED, String.valueOf(deathTick - pillarsSpawnedTick + offset1));
    }
}

package com.advancedraidtracker.rooms.tob;

import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.constants.TOBRoom;
import com.advancedraidtracker.constants.TobIDs;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.*;
import com.advancedraidtracker.utility.Point;
import com.advancedraidtracker.utility.RoomUtil;
import com.advancedraidtracker.utility.datautility.DataWriter;
import com.advancedraidtracker.utility.RoomState;

import static com.advancedraidtracker.constants.LogID.*;
import static com.advancedraidtracker.constants.LogID.ACCURATE_XARP_END;
import static com.advancedraidtracker.constants.LogID.XARPUS_STARTED;
import static com.advancedraidtracker.constants.TobIDs.*;
import static com.advancedraidtracker.utility.RoomState.XarpusRoomState.FINISHED;
@Slf4j
public class XarpusHandler extends RoomHandler
{
    public RoomState.XarpusRoomState roomState = RoomState.XarpusRoomState.NOT_STARTED;
    private final AdvancedRaidTrackerPlugin plugin;

    public XarpusHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)
    {
        super(client, clog, config);
        this.plugin = plugin;
    }

    private int xarpusEntryTick = -1;
    private int xarpusExhumedsEnd = -1;
    private int xarpusScreechTick = -1;
    private int xarpusEndTick = -1;

    public String getName()
    {
        return "Xarpus";
    }

    public boolean isActive()
    {
        return !(roomState == RoomState.XarpusRoomState.NOT_STARTED || roomState == FINISHED);
    }

    public void reset()
    {
        super.reset();
        xarpusEntryTick = -1;
        xarpusExhumedsEnd = -1;
        xarpusScreechTick = -1;
        xarpusEndTick = -1;
        roomState = RoomState.XarpusRoomState.NOT_STARTED;
    }

    public void updateAnimationChanged(AnimationChanged event)
    {
        if (event.getActor().getAnimation() == XARPUS_AWAKENS)
        {
            endExhumeds();
        }
        if (event.getActor().getAnimation() == XARPUS_DEATH_ANIMATION)
        {
            endXarpus();
        }
    }

    public void updateProjectileMoved(ProjectileMoved event)
    {
        if (event.getProjectile().getEndCycle() - event.getProjectile().getStartCycle() == event.getProjectile().getRemainingCycles())
        {
            if (event.getProjectile().getId() == XARPUS_EXHUMED_PROJECTILE)
            {
                clog.addLine(XARPUS_HEAL);
            }
        }
    }

    public void updateOverheadText(OverheadTextChanged event)
    {
        if (event.getActor() instanceof NPC)
        {
            NPC npc = (NPC) event.getActor();
            int id = npc.getId();
            if (id == XARPUS_P23 || id == XARPUS_P23_HM || id == XARPUS_P23_SM)
            {
                startScreech();
            }
        }
    }

    public void updateNpcDespawned(NpcDespawned event)
    {
        switch (event.getNpc().getId())
        {
            case XARPUS_INACTIVE:
            case XARPUS_P1:
            case XARPUS_P23:
            case XARPUS_DEAD:
            case XARPUS_INACTIVE_HM:
            case XARPUS_P1_HM:
            case XARPUS_P23_HM:
            case XARPUS_DEAD_HM:
            case XARPUS_INACTIVE_SM:
            case XARPUS_P1_SM:
            case XARPUS_P23_SM:
            case XARPUS_DEAD_SM:
                clog.addLine(XARPUS_DESPAWNED, String.valueOf(xarpusEndTick - xarpusEntryTick));
        }
    }

    public void updateNpcSpawned(NpcSpawned event)
    {
        boolean story = false;
        switch (event.getNpc().getId())
        {
            case TobIDs.XARPUS_INACTIVE_SM:
            case TobIDs.XARPUS_P1_SM:
            case TobIDs.XARPUS_P23_SM:
            case TobIDs.XARPUS_DEAD_SM:
                story = true;
                clog.addLine(IS_STORY_MODE);
            case TobIDs.XARPUS_INACTIVE_HM:
            case TobIDs.XARPUS_P1_HM:
            case TobIDs.XARPUS_P23_HM:
            case TobIDs.XARPUS_DEAD_HM:
                if (!story)
                    clog.addLine(IS_HARD_MODE);
            case TobIDs.XARPUS_INACTIVE:
            case TobIDs.XARPUS_P1:
            case TobIDs.XARPUS_P23:
            case TobIDs.XARPUS_DEAD:
                clog.addLine(XARPUS_SPAWNED);
        }
    }

    public void updateGameTick(GameTick event)
    {
        if (roomState == RoomState.XarpusRoomState.NOT_STARTED)
        { //Xarpus timer starts when player crosses into region
            if (RoomUtil.crossedLine(XARPUS_REGION, new Point(25, 12), new Point(27, 12), false, client))
            {
                startXarpus();
            }
        }
        if (xarpusScreechTick != -1 && xarpusScreechTick != 0 && client.getTickCount() != xarpusScreechTick && (client.getTickCount() - xarpusScreechTick) % 8 == 0 && isActive())
        {
            plugin.addDelayedLine(TOBRoom.XARPUS, client.getTickCount() - xarpusEntryTick, "Turn");
        }
    }

    private void startScreech()
    {
        clog.addLine(XARPUS_SCREECH, String.valueOf(client.getTickCount() - xarpusEntryTick));
        roomState = RoomState.XarpusRoomState.POSTSCREECH;
        xarpusScreechTick = client.getTickCount();
        String splitMessage = "Wave 'Xarpus phase 2' complete. Duration: " + timeColor() + RoomUtil.time(xarpusScreechTick - xarpusEntryTick) + " (" + RoomUtil.time(xarpusScreechTick - xarpusExhumedsEnd) + ")";
        this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        plugin.addDelayedLine(TOBRoom.XARPUS, xarpusScreechTick - xarpusEntryTick, "SCREECH");
    }

    private void startXarpus()
    {
        roomState = RoomState.XarpusRoomState.EXHUMEDS;
        xarpusEntryTick = client.getTickCount();
        roomStartTick = client.getTickCount();
        clog.addLine(XARPUS_STARTED);
        clog.addLine(ACCURATE_XARP_START);
    }

    private void endExhumeds()
    {
        roomState = RoomState.XarpusRoomState.PRESCREECH;
        xarpusExhumedsEnd = client.getTickCount();
        String splitMessage = "Wave 'Xarpus phase 1' complete. Duration: " + timeColor() + RoomUtil.time(xarpusExhumedsEnd - xarpusEntryTick);
        this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        plugin.addDelayedLine(TOBRoom.XARPUS, client.getTickCount() - xarpusEntryTick + 1, "Exhumeds End");
    }

    private void endXarpus()
    {

        roomState = FINISHED;
        xarpusEndTick = client.getTickCount() + XARPUS_DEATH_ANIMATION_LENGTH;
        clog.addLine(ACCURATE_XARP_END);
        plugin.liveFrame.setXarpFinished(xarpusEndTick - xarpusEntryTick);
        String splitMessage = "Wave 'Xarpus phase 3' complete. Duration: " + timeColor() + RoomUtil.time(xarpusEndTick - xarpusEntryTick) + " (" + RoomUtil.time(xarpusEndTick - xarpusScreechTick) + ")";
        this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
    }
}

package com.advancedraidtracker.rooms.tob;

import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.constants.LogID;
import com.advancedraidtracker.constants.TOBRoom;
import com.advancedraidtracker.utility.Point;
import com.advancedraidtracker.utility.datautility.DataWriter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import com.advancedraidtracker.utility.RoomState;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static com.advancedraidtracker.constants.TobIDs.*;

@Slf4j
public class SotetsegHandler extends RoomHandler
{
    public RoomState.SotetsegRoomState roomState = RoomState.SotetsegRoomState.NOT_STARTED;
    private int soteEntryTick = -1;
    private int soteFirstMazeStart = -1;
    private int soteSecondMazeStart = -1;
    private int soteFirstMazeEnd = -1;
    private int soteSecondMazeEnd = -1;
    private int soteDeathTick = -1;
    private int deferTick = -1;
    private int lastRegion = -1;
    private final AdvancedRaidTrackerPlugin plugin;
    private boolean hasSteppedOnMaze = false;
    private String firstMazeChosen = "";
    private String secondMazeChosen = "";
    private String lastChosen = "";
    private final Map<String, ArrayList<Point>> playerTiles = new HashMap<>();

    private ArrayList<Point> excludedTiles = new ArrayList<>();
    private final AdvancedRaidTrackerConfig config;

    public SotetsegHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)
    {
        super(client, clog, config);
        this.plugin = plugin;
        this.config = config;
    }

    public boolean isActive()
    {
        return !(roomState == RoomState.SotetsegRoomState.NOT_STARTED || roomState == RoomState.SotetsegRoomState.FINISHED);
    }

    public String getName()
    {
        return "Sotetseg";
    }

    public void reset()
    {
        super.reset();
        playerTiles.clear();
        lastChosen = "";
        excludedTiles.clear();
        accurateTimer = true;
        soteEntryTick = -1;
        roomState = RoomState.SotetsegRoomState.NOT_STARTED;
        soteFirstMazeStart = -1;
        soteSecondMazeStart = -1;
        soteFirstMazeEnd = -1;
        soteSecondMazeEnd = -1;
        soteDeathTick = -1;
        lastRegion = -1;
        hasSteppedOnMaze = false;
        firstMazeChosen = "";
        secondMazeChosen = "";
    }

    public void updateNpcSpawned(NpcSpawned event)
    {
        int id = event.getNpc().getId();
        if (id == SOTETSEG_ACTIVE || id == SOTETSEG_ACTIVE_HM || id == SOTETSEG_ACTIVE_SM)
        {
            if (lastRegion == SOTETSEG_UNDERWORLD)
            {
                if (roomState == RoomState.SotetsegRoomState.MAZE_1)
                {
                    endFirstMaze();
                } else if (roomState == RoomState.SotetsegRoomState.MAZE_2)
                {
                    endSecondMaze();
                }
            }
        }
    }

    private ArrayList<Point> currentMaze = new ArrayList<>();

    public void updateGroundObjectSpawned(GroundObjectSpawned event)
    {
        if(!hasSteppedOnMaze)
        {
            if (event.getGroundObject().getId() == SOTETSEG_RED_TILE && lastRegion == SOTETSEG_OVERWORLD)
            {
                hasSteppedOnMaze = true;
                int ticksSinceLastProc = -1;
                if(roomState == RoomState.SotetsegRoomState.MAZE_1)
                {
                    ticksSinceLastProc = client.getTickCount()-soteFirstMazeStart;
                }
                else
                {
                    if(roomState == RoomState.SotetsegRoomState.MAZE_2)
                    {
                        ticksSinceLastProc = client.getTickCount()-soteSecondMazeStart;
                    }
                }
                if(ticksSinceLastProc != -1 && lastRegion == SOTETSEG_OVERWORLD)
                {
                    int distance = Math.abs(event.getGroundObject().getWorldLocation().getRegionX()-15);
                    int stallDuration = 5;
                    int tickOffset = 1 + stallDuration + (int)((distance-0.5)/2.0);
                    if(ticksSinceLastProc > tickOffset && config.showMistakesInChat())
                    {
                        String mazeRunner = (roomState== RoomState.SotetsegRoomState.MAZE_1) ? firstMazeChosen : secondMazeChosen;
                        plugin.sendChatMessage(mazeRunner + " was late to first tile by " + (ticksSinceLastProc-tickOffset) + " ticks");
                    }
                }
            }
        }
        if (event.getGroundObject().getId() == SOTETSEG_RED_TILE && lastRegion == SOTETSEG_OVERWORLD)
        {
            int currentTileX = event.getGroundObject().getWorldLocation().getRegionX();
            int currentTileY = event.getGroundObject().getWorldLocation().getRegionY();
            currentMaze.add(new Point(currentTileX, currentTileY));
        }
    }

    private static ArrayList<Point> removeDuplicatePoints(ArrayList<Point> tiles)
    {
        ArrayList<Point> newTiles = new ArrayList<>();
        Point old = null;
        for(Point p : tiles)
        {
            if(old != null)
            {
                if(!(p.getX() == old.getX() && p.getY() == old.getY()))
                {
                    newTiles.add(p);
                }
            }
            else
            {
                newTiles.add(p);
            }
            old = p;
        }
        return newTiles;
    }

    private ArrayList<Point> addEveryTileBetween(ArrayList<Point> tiles)
    {
        ArrayList<Point> allTiles = new ArrayList<>();
        Point previous = null;
        for(Point p : tiles)
        {
            if(previous != null)
            {
                allTiles.addAll(everyTileBetween(previous, p));
            }
            previous = p;
        }
        return removeDuplicatePoints(allTiles);
    }
    public static ArrayList<Point> everyTileBetween(Point start, Point end)
    {
        if(end.getY() < start.getY())
        {
            return new ArrayList<>();
        }
        ArrayList<Point> crossTiles = new ArrayList<>();
        crossTiles.add(start);
        while (Math.abs(end.getX() - crossTiles.get(crossTiles.size() - 1).getX()) != end.getY() - crossTiles.get(crossTiles.size() - 1).getY())
        {
            if(crossTiles.size() > 1000)
            {
                return new ArrayList<>();
            }
            if (Math.abs(end.getX() - start.getX()) > end.getY() - start.getY())
            {
                int offset = (end.getX() - start.getX() > 0) ? 1 : -1;
                crossTiles.add(new Point(crossTiles.get(crossTiles.size() - 1).getX() + offset, crossTiles.get(crossTiles.size() - 1).getY()));
            } else if (end.getY() - start.getY() > Math.abs(end.getX() - start.getX()))
            {
                crossTiles.add(new Point(crossTiles.get(crossTiles.size() - 1).getX(), crossTiles.get(crossTiles.size() - 1).getY() + 1));
            }
        }
        while (end.getX() != crossTiles.get(crossTiles.size() - 1).getX() && end.getY() != crossTiles.get(crossTiles.size() - 1).getY())
        {
            int offset = (end.getX() - crossTiles.get(crossTiles.size()-1).getX() > 0) ? 1 : -1;
            crossTiles.add(new Point(crossTiles.get(crossTiles.size() - 1).getX() + offset, crossTiles.get(crossTiles.size() - 1).getY() + 1));
        }
        return crossTiles;
    }

    public void updateAnimationChanged(AnimationChanged event)
    {
        if (event.getActor().getAnimation() == SOTETSEG_DEATH_ANIMATION)
        {
            endSotetseg();
        }
    }

    public void startSotetseg()
    {
        soteEntryTick = client.getTickCount();
        roomStartTick = client.getTickCount();
        deferTick = soteEntryTick + 2;
        roomState = RoomState.SotetsegRoomState.PHASE_1;
        clog.addLine(LogID.SOTETSEG_STARTED);
    }

    public void endSotetseg()
    {
        plugin.addDelayedLine(TOBRoom.SOTETSEG, client.getTickCount() - soteEntryTick, "Dead");
        soteDeathTick = client.getTickCount() + SOTETSEG_DEATH_ANIMATION_LENGTH;
        roomState = RoomState.SotetsegRoomState.FINISHED;
        clog.addLine(LogID.ACCURATE_SOTE_END);
        clog.addLine(LogID.SOTETSEG_ENDED, String.valueOf(soteDeathTick - soteEntryTick));
        plugin.liveFrame.setSoteFinished(soteDeathTick - soteEntryTick);
        sendTimeMessage("Wave 'Sotetseg phase 3' complete. Duration: ", soteDeathTick - soteEntryTick, soteDeathTick - soteSecondMazeEnd, false);
    }

    public void startFirstMaze()
    {
        startEitherMaze();
        lastChosen = "";
        excludedTiles.clear();
        currentMaze.clear();
        firstMazeChosen = "";
        hasSteppedOnMaze = false;
        soteFirstMazeStart = client.getTickCount();
        clog.addLine(LogID.SOTETSEG_FIRST_MAZE_STARTED, String.valueOf(soteFirstMazeStart - soteEntryTick));
        roomState = RoomState.SotetsegRoomState.MAZE_1;
        sendTimeMessage("Wave 'Sotetseg phase 1' complete. Duration: ", soteFirstMazeStart - soteEntryTick);
        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteFirstMazeStart - soteEntryTick, "Maze1 Start");
    }

    public void startEitherMaze()
    {
        playerTiles.clear();
        for(String s : plugin.currentPlayers)
        {
            playerTiles.put(s, new ArrayList<>());
        }
    }

    public void endFirstMaze()
    {
        endEitherMaze();
        soteFirstMazeEnd = client.getTickCount();
        clog.addLine(LogID.SOTETSEG_FIRST_MAZE_ENDED, String.valueOf(soteFirstMazeEnd - soteEntryTick));
        roomState = RoomState.SotetsegRoomState.PHASE_2;
        sendTimeMessage("Wave 'Sotetseg maze 1' complete. Duration: ", soteFirstMazeEnd - soteEntryTick, soteFirstMazeEnd - soteFirstMazeStart);
        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteFirstMazeEnd - soteEntryTick, "Maze1 End");
    }

    public void startSecondMaze()
    {
        startEitherMaze();
        lastChosen = "";
        excludedTiles.clear();
        currentMaze.clear();
        secondMazeChosen = "";
        hasSteppedOnMaze = false;
        soteSecondMazeStart = client.getTickCount();
        clog.addLine(LogID.SOTETSEG_SECOND_MAZE_STARTED, String.valueOf(soteSecondMazeStart - soteEntryTick));
        roomState = RoomState.SotetsegRoomState.MAZE_2;
        sendTimeMessage("Wave 'Sotetseg phase 2' complete. Duration: ", soteSecondMazeStart - soteEntryTick, soteSecondMazeStart - soteFirstMazeEnd);
        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteSecondMazeStart - soteEntryTick, "Maze2 Start");
    }
    private static ArrayList<Point> filterMaze(ArrayList<Point> tiles)
    {
        ArrayList<Point> filteredTiles = new ArrayList<>();
        for (Point p : tiles)
        {
            if (p.getY() % 2 == 0)
            {
                filteredTiles.add(p);
            }
        }
        return filteredTiles;
    }

    public ArrayList<Point> findOverlappingTiles(ArrayList<Point> tiles1, ArrayList<Point> tiles2)
    {
        ArrayList<Point> overlap = new ArrayList<>();
        for(Point p1 : tiles1)
        {
            for(Point p2 : tiles2)
            {
                if(p1.getX() == p2.getX() && p1.getY() == p2.getY())
                {
                    overlap.add(p1);
                }
            }
        }
        return overlap;
    }

    public ArrayList<Point> findNonOverlappingTiles(ArrayList<Point> tiles1, ArrayList<Point> tiles2)
    {
        ArrayList<Point> nonOverlappedTiles = new ArrayList<>();
        for(Point p1 : tiles1)
        {
            boolean found = false;
            for(Point p2 : tiles2)
            {
                if (p2.getX() == p1.getX() && p2.getY() == p1.getY())
                {
                    found = true;
                    break;
                }
            }
            if(!found)
            {
                nonOverlappedTiles.add(p1);
            }
        }
        return nonOverlappedTiles;
    }

    public void endEitherMaze()
    {
        if(!currentMaze.isEmpty())
        {
            if(currentMaze.get(currentMaze.size()-1).getY() == 35)
            {
                currentMaze.add(new Point(currentMaze.get(currentMaze.size()-1).getX(), 37));
            }
        }
        currentMaze = removeDuplicatePoints(currentMaze);
        currentMaze = addEveryTileBetween(currentMaze);
        ArrayList<Point> overlap = removeDuplicatePoints(findOverlappingTiles(currentMaze, excludedTiles));
        ArrayList<Point> nonoverlap = removeDuplicatePoints(findNonOverlappingTiles(excludedTiles, currentMaze));
        if(!overlap.isEmpty() && config.showMistakesInChat())
        {
            plugin.sendChatMessage(lastChosen + " ragged " + overlap.size() + " while running the maze");
        }
        if(!nonoverlap.isEmpty() && config.showMistakesInChat())
        {
            plugin.sendChatMessage("Players following the maze ragged " + nonoverlap.size() + " tiles");
        }
        currentMaze = filterMaze(currentMaze);
        excludedTiles = removeDuplicatePoints(excludedTiles);
        playerTiles.replaceAll((s, v) -> addEveryTileBetween(removeDuplicatePoints(v)));
        for(String s : playerTiles.keySet())
        {
            int ragged = 0;
            for(Point tile : playerTiles.get(s))
            {
                for(Point raggedTile : nonoverlap)
                {
                    if(tile.getX() == raggedTile.getX() && tile.getY() == raggedTile.getY())
                    {
                        ragged++;
                    }
                }
            }
            if(ragged > 0)
            {
                plugin.sendChatMessage(s + " ragged " + ragged + " tiles");
            }
        }
    }

    public void endSecondMaze()
    {
        endEitherMaze();
        soteSecondMazeEnd = client.getTickCount();
        clog.addLine(LogID.SOTETSEG_SECOND_MAZE_ENDED, String.valueOf(soteSecondMazeEnd - soteEntryTick));
        roomState = RoomState.SotetsegRoomState.PHASE_3;
        sendTimeMessage("Wave 'Sotetseg maze 2' complete. Duration: ", soteSecondMazeEnd - soteEntryTick, soteSecondMazeEnd - soteSecondMazeStart);
        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteSecondMazeEnd - soteEntryTick, "Maze2 End");
    }

    public String getAboveWorldChosen()
    {
        for(String playerName : plugin.currentPlayers)
        {
            boolean found = false;
            for(Player player : client.getPlayers())
            {
                if(playerName.equals(player.getName()))
                {
                    found = true;
                }
            }
            if(!found)
            {
                return playerName;
            }
        }
        return "";
    }

    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)
    {
        if(event.getGraphicsObject().getId() == SOTETSEG_RAGGED_TILE)
        {
            WorldPoint wp = WorldPoint.fromLocal(client, event.getGraphicsObject().getLocation());
            excludedTiles.add(new Point(wp.getRegionX(), wp.getRegionY()));
        }
    }

    public void updateGameTick(GameTick event)
    {
        lastRegion = client.isInInstancedRegion() ? WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID() : client.getLocalPlayer().getWorldLocation().getRegionID();
        if(roomState == RoomState.SotetsegRoomState.MAZE_1 || roomState == RoomState.SotetsegRoomState.MAZE_2)
        {
            int ticksSinceLastProc;
            if(roomState == RoomState.SotetsegRoomState.MAZE_1)
            {
                ticksSinceLastProc = client.getTickCount()-soteFirstMazeStart;
            }
            else
            {
                ticksSinceLastProc = client.getTickCount() - soteSecondMazeStart;
            }
            if(ticksSinceLastProc > 5)
            {
                for (Player player : client.getPlayers())
                {
                    WorldPoint location = player.getWorldLocation();
                    if (location.getRegionX() <= 22 && location.getRegionX() >= 9)
                    {
                        if (location.getRegionY() >= 21 && location.getRegionY() <= 37)
                        {
                            if (playerTiles.containsKey(player.getName()))
                            {
                                playerTiles.get(player.getName()).add(new Point(location.getRegionX(), location.getRegionY()));
                            }
                        }
                    }
                }
            }
        }
        if (client.getTickCount() == deferTick)
        {
            deferTick = -1;
            if (client.getVarbitValue(HP_VARBIT) == FULL_HP)
            {
                clog.addLine(LogID.ACCURATE_SOTE_START);
            }
        }
        if(client.getTickCount() == soteFirstMazeStart+5)
        {
            if(lastRegion == SOTETSEG_UNDERWORLD)
            {
                firstMazeChosen = client.getLocalPlayer().getName();
            }
            else
            {
                firstMazeChosen = getAboveWorldChosen();
            }
            lastChosen = firstMazeChosen;
        }
        else if(client.getTickCount() == soteSecondMazeStart+5)
        {
            if(lastRegion == SOTETSEG_UNDERWORLD)
            {
                secondMazeChosen = client.getLocalPlayer().getName();
            }
            else
            {
                secondMazeChosen = getAboveWorldChosen();
            }
            lastChosen = secondMazeChosen;
        }
    }

    public void handleNPCChanged(int id)
    {
        if (id == SOTETSEG_ACTIVE || id == SOTETSEG_ACTIVE_HM || id == SOTETSEG_ACTIVE_SM)
        {
            if (roomState == RoomState.SotetsegRoomState.NOT_STARTED)
            {
                if (id == SOTETSEG_ACTIVE_HM)
                {
                    clog.addLine(LogID.IS_HARD_MODE);
                } else if (id == SOTETSEG_ACTIVE_SM)
                {
                    clog.addLine(LogID.IS_STORY_MODE);
                }
                startSotetseg();
            } else if (roomState == RoomState.SotetsegRoomState.MAZE_1)
            {
                endFirstMaze();
            } else if (roomState == RoomState.SotetsegRoomState.MAZE_2)
            {
                endSecondMaze();
            }
        } else if (id == SOTETSEG_INACTIVE || id == SOTETSEG_INACTIVE_HM || id == SOTETSEG_INACTIVE_SM)
        {
            if (roomState == RoomState.SotetsegRoomState.PHASE_1)
            {
                startFirstMaze();
            } else if (roomState == RoomState.SotetsegRoomState.PHASE_2)
            {
                startSecondMaze();
            }
        }
    }
}

package com.advancedraidtracker.rooms.tob;

import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import net.runelite.api.Client;
import com.advancedraidtracker.utility.datautility.DataWriter;

public class LobbyHandler extends RoomHandler
{
    public LobbyHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config)
    {
        super(client, clog, config);
    }
}

package com.advancedraidtracker.rooms.tob;


import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.utility.datautility.DataWriter;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.*;
import com.advancedraidtracker.utility.RoomUtil;

public class RoomHandler
{
    protected Client client;
    protected DataWriter clog;
    public int roomStartTick = -1;

    private final AdvancedRaidTrackerConfig config;
    protected boolean accurateTimer = true;
    protected boolean accurateEntry = true;
    @Getter
    @Setter
    int scale;

    protected String defaultColor()
    {
        return (client.isResized()) ? "<col=FFFFFF>" : "<col=000000>";
    }

    protected String timeColor()
    {
        return "<col=EF1020>";
    }

    public RoomHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config)
    {
        this.client = client;
        this.clog = clog;
        this.config = config;
    }

    private String accuracy()
    {
        return (accurateTimer) ? "" : "**";
    }

    private String entry()
    {
        return (accurateEntry) ? "" : "*";
    }

    protected void sendTimeMessage(String message, int duration)
    {
        if (config.chatSplits())
        {
            String splitMessage = message + timeColor() + RoomUtil.time(duration) + entry() + accuracy();
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        }
    }

    protected void sendTimeMessage(String message, int duration, int split)
    {
        if (config.chatSplits())
        {
            String splitMessage = message + timeColor() + RoomUtil.time(duration) + entry() + accuracy() + " (" + RoomUtil.time(split) + ")";
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        }
    }

    protected void sendTimeMessage(String message, int duration, int split, boolean bloat)
    {
        if (config.chatSplits())
        {
            String splitMessage;
            if (bloat)
            {
                splitMessage = message + timeColor() + duration + entry() + accuracy() + " (" + RoomUtil.time(split) + ")";
            } else
            {
                splitMessage = message + timeColor() + RoomUtil.time(split) + entry() + accuracy() + defaultColor() + " Room time: " + timeColor() + RoomUtil.time(duration);
            }
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        }
    }

    protected void sendTimeMessage(String message, int duration, int split, boolean bloat, String alternate)
    {
        if (config.chatSplits())
        {
            String splitMessage;
            if (bloat)
            {
                splitMessage = message + timeColor() + duration + entry() + accuracy() + " (" + RoomUtil.time(split) + ")" + defaultColor() + alternate;
            } else
            {
                splitMessage = message + timeColor() + RoomUtil.time(split) + entry() + accuracy() + defaultColor() + " Room time: " + timeColor() + RoomUtil.time(duration) + defaultColor() + alternate;
            }
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        }
    }

    protected void sendTimeMessage(String message, int duration, String alternateText, int alternateNumber)
    {
        if (config.chatSplits())
        {
            String splitMessage = message + timeColor() + RoomUtil.time(duration) + entry() + accuracy() + defaultColor() + alternateText + timeColor() + alternateNumber;
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        }
    }


    protected void sendTimeMessage(String message, int duration, String alternateText, int alternateNumber, boolean bloat)
    {
        if (config.chatSplits())
        {
            String splitMessage = message + timeColor() + duration + entry() + accuracy() + alternateText + RoomUtil.time(alternateNumber);
            client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", splitMessage, null, false);
        }
    }

    public void handleNPCChanged(int id)
    {
    }

    public void updateNpcSpawned(NpcSpawned event)
    {
    }

    public void updateNpcDespawned(NpcDespawned event)
    {
    }

    public void updateOverheadText(OverheadTextChanged event)
    {
    }

    public void updateGameTick(GameTick event)
    {
    }

    public void updateItemSpawned(ItemSpawned event)
    {

    }

    public void updateAnimationChanged(AnimationChanged event)
    {
    }

    public void updateInteractingChanged(InteractingChanged event)
    {
    }

    public void updateHitsplatApplied(HitsplatApplied event)
    {
    }

    public void updateGraphicChanged(GraphicChanged event)
    {
    }

    public void updateProjectileMoved(ProjectileMoved event)
    {
    }

    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)
    {
    }

    public void updateGameObjectSpawned(GameObjectSpawned event)
    {
    }

    public void updateGameObjectDespawned(GameObjectDespawned event)
    {
    }

    public void updateGroundObjectSpawned(GroundObjectSpawned event)
    {

    }

    public String getName()
    {
        return "";
    }

    public boolean isActive()
    {
        return false;
    }

    public void reset()
    {
        roomStartTick = -1;
    }
}

package com.advancedraidtracker.rooms.tob;

import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.AdvancedRaidTrackerConfig;

import com.advancedraidtracker.constants.TOBRoom;
import com.advancedraidtracker.constants.TobIDs;
import com.advancedraidtracker.utility.*;

import com.advancedraidtracker.utility.datautility.DataWriter;
import com.advancedraidtracker.utility.maidenbloodtracking.BloodDamageToBeApplied;
import com.advancedraidtracker.utility.maidenbloodtracking.BloodPositionWrapper;
import com.advancedraidtracker.utility.wrappers.NPCTimeInChunkShell;
import com.advancedraidtracker.utility.wrappers.PlayerHitsWrapper;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;

import java.util.*;
import java.util.stream.Collectors;

import static com.advancedraidtracker.constants.LogID.*;
import static com.advancedraidtracker.constants.TobIDs.*;
import static com.advancedraidtracker.utility.ItemReference.*;
import static com.advancedraidtracker.utility.RoomUtil.crossedLine;

import com.advancedraidtracker.utility.wrappers.MaidenCrab;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemEquipmentStats;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStats;

@Slf4j
public class MaidenHandler extends RoomHandler
{
    public RoomState.MaidenRoomState roomState;

    int maidenStartTick;
    int p70;
    int p50;
    int p30;
    int maidenDeathTick;
    NPC maidenNPC;
    int bloodHeals = 0;

    private final com.advancedraidtracker.utility.Point MAIDEN_GATE_START = new com.advancedraidtracker.utility.Point(32 , 29);
    private final com.advancedraidtracker.utility.Point MAIDEN_GATE_END = new com.advancedraidtracker.utility.Point(32, 32);

    public int deferVarbitCheck = -1;
    ArrayList<MaidenCrab> maidenCrabs = new ArrayList<>();
    ArrayList<MaidenCrab> deferredCrabs = new ArrayList<>();

    ArrayList<PlayerHitsWrapper> hitsplatsPerPlayer;
    ArrayList<BloodPositionWrapper> thrownBloodLocations;
    ArrayList<WorldPoint> spawnedBloodLocations;
    ArrayList<Integer> maidenHeals;
    ArrayList<BloodDamageToBeApplied> queuedBloodDamage;

    ArrayList<Player> dinhsers;


    ArrayList<NPCTimeInChunkShell> npcs;


    AdvancedRaidTrackerConfig config;
    AdvancedRaidTrackerPlugin plugin;

    private final ItemManager itemManager;

    public MaidenHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin, ItemManager itemManager)
    {
        super(client, clog, config);
        this.plugin = plugin;
        this.itemManager = itemManager;
        roomState = RoomState.MaidenRoomState.NOT_STARTED;
        p70 = -1;
        p50 = -1;
        p30 = -1;
        maidenStartTick = -1;
        maidenDeathTick = -1;
        accurateEntry = true;
        hitsplatsPerPlayer = new ArrayList<>();
        thrownBloodLocations = new ArrayList<>();
        spawnedBloodLocations = new ArrayList<>();
        maidenHeals = new ArrayList<>();
        queuedBloodDamage = new ArrayList<>();
        npcs = new ArrayList<>();
        dinhsers = new ArrayList<>();
        this.config = config;
    }

    public boolean isActive()
    {
        return !(roomState == RoomState.MaidenRoomState.NOT_STARTED || roomState == RoomState.MaidenRoomState.FINISHED);
    }

    public String getName()
    {
        return "Maiden";
    }

    public void reset()
    {
        roomState = RoomState.MaidenRoomState.NOT_STARTED;
        accurateEntry = true;
        p70 = -1;
        p50 = -1;
        p30 = -1;
        maidenStartTick = -1;
        maidenDeathTick = -1;
        hitsplatsPerPlayer.clear();
        thrownBloodLocations.clear();
        maidenHeals.clear();
        queuedBloodDamage.clear();
        deferredCrabs.clear();
        bloodHeals = 0;
        npcs.clear();
        dinhsers.clear();
        super.reset();
    }

    public void startMaiden()
    {
        // Room already started, ignore request.
        if (maidenStartTick != -1)
            return;

        maidenStartTick = client.getTickCount();
        roomStartTick = client.getTickCount();
        deferVarbitCheck = maidenStartTick + 2;
    }

    public void proc70()
    {
        p70 = super.client.getTickCount();
        roomState = RoomState.MaidenRoomState.PHASE_2;
        if (maidenStartTick != -1)
            sendTimeMessage("Wave 'Maiden phase 1' complete! Duration: ", p70 - maidenStartTick);
        clog.addLine(MAIDEN_70S, String.valueOf(p70 - maidenStartTick));
        plugin.addDelayedLine(TOBRoom.MAIDEN, p70 - maidenStartTick - 2, "70s");

    }

    public void proc50()
    {
        p50 = super.client.getTickCount();
        roomState = RoomState.MaidenRoomState.PHASE_3;
        if (maidenStartTick != -1)
            sendTimeMessage("Wave 'Maiden phase 2' complete! Duration: ", p50 - maidenStartTick, p50 - p70);
        clog.addLine(MAIDEN_50S, String.valueOf(p50 - maidenStartTick));
        plugin.addDelayedLine(TOBRoom.MAIDEN, p50 - maidenStartTick - 2, "50s");
    }

    public void proc30()
    {
        p30 = super.client.getTickCount();
        roomState = RoomState.MaidenRoomState.PHASE_4;
        if (maidenStartTick != -1)
            sendTimeMessage("Wave 'Maiden phase 3' complete! Duration: ", p30 - maidenStartTick, p30 - p50);
        clog.addLine(MAIDEN_30S, String.valueOf(p30 - maidenStartTick));
        plugin.addDelayedLine(TOBRoom.MAIDEN, p30 - maidenStartTick - 2, "30s");
    }

    public void endMaiden()
    {
        roomState = RoomState.MaidenRoomState.FINISHED;
        maidenDeathTick = client.getTickCount() + MAIDEN_DEATH_ANIMATION_LENGTH;
        if (maidenStartTick != -1)
            sendTimeMessage("Wave 'Maiden Skip' complete! Duration: ", maidenDeathTick - maidenStartTick, maidenDeathTick - p30, false);
        clog.addLine(ACCURATE_MAIDEN_END);
        clog.addLine(MAIDEN_0HP, String.valueOf(client.getTickCount() - maidenStartTick));
        plugin.addDelayedLine(TOBRoom.MAIDEN, client.getTickCount() - maidenStartTick, "Dead");
        plugin.liveFrame.setMaidenFinished(maidenDeathTick - maidenStartTick);
    }

    private boolean didAuto = false;

    public void updateAnimationChanged(AnimationChanged event)
    {
        if (event.getActor().getAnimation() == MAIDEN_DEATH_ANIMATION)
        {
            endMaiden();
        } else if (event.getActor().getAnimation() == CHINCHOMPA_THROWN_ANIMATION)
        {
            if (event.getActor() instanceof Player)
            {
                Player player = (Player) event.getActor();
                Actor target = player.getInteracting();
                int distance = target.getWorldArea().distanceTo(player.getWorldLocation());
                clog.addLine(MAIDEN_CHIN_THROWN, player.getName(), String.valueOf(distance));
                if (distance < 4 || distance > 6)
                {
                    if (config.showMistakesInChat())
                    {
                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", player.getName() + " chinned from " + distance + " tiles away.", null, false);
                    }
                }
            }
        } else if (event.getActor().getAnimation() == DINHS_BULWARK_ANIMATION)
        {
            dinhsers.add((Player) event.getActor());
        }
        else if(event.getActor().getAnimation() == MAIDEN_AUTO_ANIMATION)
        {
            didAuto = true;
        }
    }

    public int getDrainedStat(Player player) //Assumes berserker/ultor
    {
        if(player == null)
        {
            return NONE;
        }
        int stab = 0;
        int slash = 0;
        int crush = 0;
        int magic = 0;
        int range = 0;
        PlayerComposition pc = player.getPlayerComposition();
        int[] wornItems = {
                pc.getEquipmentId(KitType.HEAD),
                pc.getEquipmentId(KitType.CAPE),
                pc.getEquipmentId(KitType.AMULET),
                pc.getEquipmentId(KitType.WEAPON),
                pc.getEquipmentId(KitType.TORSO),
                pc.getEquipmentId(KitType.SHIELD),
                pc.getEquipmentId(KitType.LEGS),
                pc.getEquipmentId(KitType.HANDS),
                pc.getEquipmentId(KitType.BOOTS)
        };
        for(int item : wornItems)
        {
            ItemStats itemStats = itemManager.getItemStats(item);
            if(itemStats != null)
            {
                ItemEquipmentStats itemEquipmentStats = itemStats.getEquipment();
                stab += itemEquipmentStats.getAstab();
                slash += itemEquipmentStats.getAslash();
                crush += itemEquipmentStats.getAcrush();
                magic += itemEquipmentStats.getAmagic();
                range += itemEquipmentStats.getArange();
            }
        }
        if((stab >= magic && stab >= range) || (slash >= magic && slash >= range) || (crush >= magic && crush >= range))
        {
            return MELEE;
        }
        else if(magic > range)
        {
            return MAGE;
        }
        else
        {
            return RANGE;
        }
    }

    public void updateNpcDespawned(NpcDespawned event)
    {
        NPC npc = event.getNpc();
        switch (npc.getId())
        {
            case TobIDs.MAIDEN_P0:
            case TobIDs.MAIDEN_P1:
            case TobIDs.MAIDEN_P2:
            case TobIDs.MAIDEN_P3:
            case TobIDs.MAIDEN_PRE_DEAD:
            case TobIDs.MAIDEN_DEAD:
            case TobIDs.MAIDEN_P0_HM:
            case TobIDs.MAIDEN_P1_HM:
            case TobIDs.MAIDEN_P2_HM:
            case TobIDs.MAIDEN_P3_HM:
            case TobIDs.MAIDEN_PRE_DEAD_HM:
            case TobIDs.MAIDEN_DEAD_HM:
            case TobIDs.MAIDEN_P0_SM:
            case TobIDs.MAIDEN_P1_SM:
            case TobIDs.MAIDEN_P2_SM:
            case TobIDs.MAIDEN_P3_SM:
            case TobIDs.MAIDEN_PRE_DEAD_SM:
            case TobIDs.MAIDEN_DEAD_SM:
                clog.addLine(MAIDEN_DESPAWNED, String.valueOf(client.getTickCount() - maidenStartTick));
                break;
            case MAIDEN_MATOMENOS:
            case MAIDEN_MATOMENOS_HM:
            case MAIDEN_MATOMENOS_SM:
                maidenCrabs.removeIf(x -> x.crab.equals(event.getNpc()));
            default:
                break;
        }
    }

    public void updateNpcSpawned(NpcSpawned event)
    {
        NPC npc = event.getNpc();
        boolean story = false;
        switch (npc.getId())
        {
            case MAIDEN_P0_SM:
            case MAIDEN_P1_SM:
            case MAIDEN_P2_SM:
            case MAIDEN_P3_SM:
            case MAIDEN_PRE_DEAD_SM:
            case MAIDEN_DEAD_SM:
                story = true;
                clog.addLine(IS_STORY_MODE);
            case MAIDEN_P0_HM:
            case MAIDEN_P1_HM:
            case MAIDEN_P2_HM:
            case MAIDEN_P3_HM:
            case MAIDEN_PRE_DEAD_HM:
            case MAIDEN_DEAD_HM:
                if (!story)
                    clog.addLine(IS_HARD_MODE);
            case MAIDEN_P0:
            case MAIDEN_P1:
            case MAIDEN_P2:
            case MAIDEN_P3:
            case MAIDEN_DEAD:
                clog.addLine(MAIDEN_SPAWNED);
                maidenNPC = npc;
                startMaiden();
                break;
            case MAIDEN_MATOMENOS:
            case MAIDEN_MATOMENOS_HM:
            case MAIDEN_MATOMENOS_SM:
                String crabName = identifySpawn(npc);
                clog.addLine(ADD_NPC_MAPPING, String.valueOf(npc.getIndex()), crabName);
                plugin.liveFrame.getPanel(getName()).addNPCMapping(npc.getIndex(), crabName);
                plugin.liveFrame.getPanel(getName()).addMaidenCrab(crabName);
                MaidenCrab crab = new MaidenCrab(npc, AdvancedRaidTrackerPlugin.scale, crabName);
                logCrabSpawn(crab.description);
                maidenCrabs.add(crab);
                break;
            case TobIDs.MAIDEN_BLOOD:
            case TobIDs.MAIDEN_BLOOD_HM:
            case TobIDs.MAIDEN_BLOOD_SM:
                clog.addLine(BLOOD_SPAWNED);
                break;
        }
    }

    public void handleNPCChanged(int id)
    {
        switch (id)
        {
            case MAIDEN_P1:
            case MAIDEN_P1_HM:
            case MAIDEN_P1_SM:
                proc70();
                break;
            case MAIDEN_P2:
            case MAIDEN_P2_HM:
            case MAIDEN_P2_SM:
                proc50();
                break;
            case MAIDEN_P3:
            case MAIDEN_P3_HM:
            case MAIDEN_P3_SM:
                proc30();
                break;
            case MAIDEN_DEAD:
            case MAIDEN_DEAD_HM:
            case MAIDEN_DEAD_SM:
                break;
        }
    }

    private void logCrabSpawn(String description)
    {
        clog.addLine(MATOMENOS_SPAWNED, description);
    }

    private void applyBlood()
    {
        for (BloodDamageToBeApplied p : queuedBloodDamage)
        {
            int bloodDamage = -1;
            Optional<PlayerHitsWrapper> hits = hitsplatsPerPlayer.stream().filter(playerHitsWrapper -> playerHitsWrapper.name.equals(p.playerName)).findAny();
            if (hits.isPresent())
            {
                bloodDamage = hits.get().hitsplats.get(hits.get().hitsplats.size() - 1); //Last hitsplat is blood
            }
            if (bloodDamage != -1)
            {
                if (p.bloodTicksAlive == -1)
                {
                    clog.addLine(PLAYER_STOOD_IN_SPAWNED_BLOOD, p.playerName, String.valueOf(bloodDamage)); //player, dmg
                } else
                {
                    clog.addLine(PLAYER_STOOD_IN_THROWN_BLOOD, p.playerName, String.valueOf(bloodDamage), String.valueOf(p.bloodTicksAlive)); //player, dmg, blood tick
                }
                bloodHeals++;
            }
        }
    }

    private void assessBloodForNextTick()
    {
        queuedBloodDamage.clear();
        for (Player p : client.getPlayers())
        {
            for (BloodPositionWrapper blood : thrownBloodLocations)
            {
                if (blood.initialTick <= client.getTickCount() && p.getWorldLocation().distanceTo(blood.location) == 0)
                {
                    queuedBloodDamage.add(new BloodDamageToBeApplied(p.getName(), 10 - (blood.finalTick - client.getTickCount())));
                }
            }
            for (WorldPoint blood : spawnedBloodLocations)
            {
                if (p.getWorldLocation().distanceTo(blood) == 0)
                {
                    queuedBloodDamage.add(new BloodDamageToBeApplied(p.getName(), -1));
                }
            }
        }

        thrownBloodLocations.removeIf(bloodPositionWrapper -> bloodPositionWrapper.finalTick <= client.getTickCount());
    }

    private void handleCrabHeals()
    {
        for (int i = 0; i < maidenHeals.size() - bloodHeals; i++)
        {
            clog.addLine(CRAB_HEALED_MAIDEN, String.valueOf(maidenHeals.get(i)));
        }
        bloodHeals = 0;
    }

    private int findChunk(int x, int y)
    {
        int chunkX = 3 - ((x - 8) / 8);
        int chunkY = 3 - ((y - 16) / 8);
        return (4 * chunkX) + chunkY;
    }

    private void trackNPCMovements()
    {
        ArrayList<NPCTimeInChunkShell> merge = new ArrayList<>();
        for (NPC npc : client.getNpcs())
        {
            if (npcs.stream().noneMatch(o -> o.npc.getIndex() == npc.getIndex()))
            {
                merge.add(new NPCTimeInChunkShell(npc, findChunk(npc.getWorldLocation().getRegionX(), npc.getWorldLocation().getRegionY()), 0));
            } else
            {
                int index = -1;
                for (int i = 0; i < npcs.size(); i++)
                {
                    if (npc.getIndex() == npcs.get(i).npc.getIndex())
                    {
                        index = i;
                    }
                }
                if (index != -1)
                {
                    npcs.get(index).marked = true;
                    if (npcs.get(index).chunk == findChunk(npc.getWorldLocation().getRegionX(), npc.getWorldLocation().getRegionY()))
                    {
                        npcs.get(index).timeInChunk++;
                    } else
                    {
                        npcs.get(index).chunk = findChunk(npc.getWorldLocation().getRegionX(), npc.getWorldLocation().getRegionY());
                        npcs.get(index).timeInChunk = 0;
                    }
                }

            }
        }
        npcs.removeIf(o -> !o.marked);
        for (NPCTimeInChunkShell npc : npcs)
        {
            npc.marked = false;
        }
        npcs.addAll(merge);
    }

    /*
    Dinhs spec targets are picked in order of chunk relative to the player where they use the spec at, this grid:
    7 4 1
    8 5 2
    9 6 3
    is always centered around the player being in chunk 5, and the check starts in chunk 1, then moves to chunk 2, all the way to 9
    if it will cross over 9 NPCs while checking a chunk, the NPCs are chosen on a last in first selected basis based on when
    that NPC entered that chunk. The NPC must also be in a 11x11 area centered around the player to be targeted.

    If multiple NPCs enter the chunk on the same tick, they are chosen by lowest NPC index first
     */

    private void analyzeDinhs()
    {
        for (Player p : dinhsers)
        {
            ArrayList<NPC> targets = new ArrayList<>();
            if (p.getInteracting() instanceof NPC)
            {
                NPC primaryTarget = (NPC) p.getInteracting();
                int primaryIndex = primaryTarget.getIndex();
                int centerX = p.getWorldLocation().getRegionX();
                int centerY = p.getWorldLocation().getRegionY();
                int centerChunk = findChunk(centerX, centerY);
                int minChunk = centerChunk - 4;
                int maxChunk = centerChunk + 4;
                for (int i = minChunk; i <= maxChunk; i++)
                {
                    ArrayList<NPCTimeInChunkShell> potentialTargets = new ArrayList<>();
                    int maxToInclude = 9 - targets.size();
                    if (maxToInclude > 0)
                    {
                        for (NPCTimeInChunkShell npc : npcs)
                        {
                            if (npc.chunk == i)
                            { //For some reason Maiden is NEVER targeted by additional dinhs hitsplat. Related to large non-moving NPCs
                                if (!Objects.requireNonNull(npc.npc.getName()).contains("Maiden") && !npc.npc.getName().contains("null") && npc.npc.getHealthRatio() != 0)
                                {
                                    if (npc.npc.getWorldLocation().getRegionX() <= centerX + 5 &&
                                            npc.npc.getWorldLocation().getRegionX() >= centerX - 5 &&
                                            npc.npc.getWorldLocation().getRegionY() <= centerY + 5 &&
                                            npc.npc.getWorldLocation().getRegionY() >= centerY - 5)
                                    {
                                        potentialTargets.add(npc);
                                    }
                                }
                            }
                        }
                        if (potentialTargets.size() > maxToInclude) //DO NOT REPLACE SORT METHODS WITH LIST.SORT OR WILL HAVE UNDEFINED RESULTS
                        {
                            Collections.sort(potentialTargets, Comparator.comparing(NPCTimeInChunkShell::getIndex));
                            Collections.sort(potentialTargets, Comparator.comparing(NPCTimeInChunkShell::getTimeInChunk));
                            for (int j = 0; j < maxToInclude; j++)
                            {
                                targets.add(potentialTargets.get(j).npc);
                            }

                        } else
                        {
                            for (NPCTimeInChunkShell npc : potentialTargets)
                            {
                                targets.add(npc.npc);
                            }
                        }
                    }
                }
                String whichCrab = "";
                int primaryHP = 0;
                boolean didDoubleHit = false;
                for (MaidenCrab crab : maidenCrabs)
                {
                    if (primaryTarget.getIndex() == crab.crab.getIndex())
                    {
                        whichCrab = crab.description;
                        primaryHP = crab.health;
                    }
                }
                String value3 = primaryTarget.getName() + "(" + whichCrab + ")" + ":" + primaryHP;
                StringBuilder value4 = new StringBuilder();
                if (targets.size() < 9)
                {
                    if (config.showMistakesInChat())
                    {
                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", p.getName() + " only targeted " + targets.size() + " additional NPCs with dinhs spec.", null, false);
                    }
                }
                ArrayList<Integer> healths = new ArrayList<>();
                for (NPC npc : targets)
                {
                    if (npc.getIndex() == primaryIndex)
                    {
                        didDoubleHit = true;
                    }
                    String additionalDescription = "^";
                    int hp = -1;
                    for (MaidenCrab crab : maidenCrabs)
                    {
                        if (crab.crab.getIndex() == npc.getIndex())
                        {
                            additionalDescription = crab.description;
                            hp = crab.health;
                            healths.add(hp);
                        }
                    }
                    value4.append(npc.getName()).append("~").append(additionalDescription).append("~").append(hp).append(":");
                }
                String value5 = getTargetsBelow27(healths, targets, didDoubleHit);
                clog.addLine(MAIDEN_DINHS_SPEC, p.getName(), value3, value4.toString(), value5);
            }
        }
        dinhsers.clear();
    }

    private static String getTargetsBelow27(ArrayList<Integer> healths, ArrayList<NPC> targets, boolean didDoubleHit)
    {
        double total = 0;
        double count = healths.size();
        int belowThreshold = 0;
        for (Integer i : healths)
        {
            total += i;
            if (i < 27)
            {
                belowThreshold++;
            }
        }
        double average = total / healths.size();
        return ((int) average) + ":" + belowThreshold + ":" + ((int) count) + ":" + targets.size() + ":" + didDoubleHit;
    }

    public void updateGameTick(GameTick event)
    {
        if (roomStartTick == -1 && crossedLine(12613, MAIDEN_GATE_START, MAIDEN_GATE_END, true, client)) {
            clog.addLine(MAIDEN_SPAWNED);
            startMaiden();
        }
        trackNPCMovements();
        analyzeDinhs();

        applyBlood();
        handleCrabHeals();
        assessBloodForNextTick();
        hitsplatsPerPlayer.clear();
        maidenHeals.clear();
        if(didAuto)
        {
            Actor drained = maidenNPC.getInteracting();
            if (drained instanceof Player)
            {
                clog.addLine(MAIDEN_AUTO, drained.getName(), String.valueOf(client.getTickCount() - roomStartTick));
                int statDrained = getDrainedStat((Player) drained);
                if (statDrained == MELEE)
                {
                    if (config.showMistakesInChat())
                    {
                        plugin.sendChatMessage("Maiden drained " + drained.getName() + "'s melee stats.");
                    }
                    clog.addLine(MAIDEN_PLAYER_DRAINED, drained.getName(), String.valueOf((client.getTickCount() - roomStartTick)));
                }
            }
            didAuto = false;
        }

        for (MaidenCrab crab : deferredCrabs)
        {
            clog.addLine(CRAB_LEAK, crab.description, String.valueOf(crab.health));
        }
        maidenCrabs.removeAll(deferredCrabs);
        deferredCrabs.clear();

        if (client.getTickCount() == deferVarbitCheck)
        {
            deferVarbitCheck = -1;
            if (client.getVarbitValue(HP_VARBIT) != FULL_HP)
            {
                accurateEntry = false;
            } else
            {
                accurateEntry = true;
                roomState = RoomState.MaidenRoomState.PHASE_1;
                clog.addLine(ACCURATE_MAIDEN_START);
            }
        }
        for (MaidenCrab crab : maidenCrabs)
        {
            int distance = crab.crab.getWorldArea().distanceTo2D(maidenNPC.getWorldArea());
            if (distance == 1 && crab.health > 0)
            {
                deferredCrabs.add(crab);
            }
        }
    }

    /**
     * Tracks crab hps
     */
    public void updateHitsplatApplied(HitsplatApplied event)
    {
        if (event.getActor() instanceof NPC) //getHealthRatio doesn't give fine enough increments so we manually track the HP
        {
            if (maidenCrabs.stream().map(x -> x.crab).collect(Collectors.toList()).contains((NPC) event.getActor()))
            {
                MaidenCrab crab = maidenCrabs.stream().filter(x -> x.crab.equals(event.getActor())).collect(Collectors.toList()).get(0);
                crab.health -= event.getHitsplat().getAmount();
            }
        }
        if (event.getActor() instanceof Player) //Heal tracking
        {
            if (hitsplatsPerPlayer.stream().noneMatch(playerHPWrapper -> playerHPWrapper.name.equals(event.getActor().getName())))
            {
                hitsplatsPerPlayer.add(new PlayerHitsWrapper(event.getActor().getName(), event.getHitsplat().getAmount()));
            } else
            {
                for (PlayerHitsWrapper playerHitsWrapper : hitsplatsPerPlayer)
                {
                    if (playerHitsWrapper.name.equals(event.getActor().getName()))
                    {
                        playerHitsWrapper.hitsplats.add(event.getHitsplat().getAmount());
                    }
                }
            }
        } else if (event.getActor().getName() != null && event.getActor().getName().contains("Maiden"))
        {
            if (event.getHitsplat().getHitsplatType() == HitsplatID.HEAL)
            {
                maidenHeals.add(event.getHitsplat().getAmount());
            }
        }
    }

    public void updateGameObjectSpawned(GameObjectSpawned event)
    {
        if (event.getGameObject().getId() == BLOOD_ON_GROUND)
        {
            spawnedBloodLocations.add(event.getGameObject().getWorldLocation());
        }
    }

    public void updateGameObjectDespawned(GameObjectDespawned event)
    {
        if (event.getGameObject().getId() == BLOOD_ON_GROUND)
        {
            spawnedBloodLocations.removeIf(worldPoint -> worldPoint.getRegionX() == event.getGameObject().getWorldLocation().getRegionX() &&
                    worldPoint.getRegionY() == event.getGameObject().getWorldLocation().getRegionY());

        }
    }

    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)
    {
        if (event.getGraphicsObject().getId() == MAIDEN_THROWN_BLOOD_GRAPHIC_OBJECT)
        {
            thrownBloodLocations.add(new BloodPositionWrapper(WorldPoint.fromLocal(client, event.getGraphicsObject().getLocation()), ((((event.getGraphicsObject().getStartCycle() - client.getGameCycle() + 1) / 30)) + client.getTickCount() - 1)));
        }
    }

    /**
     * Returns a string describing the spawn position of a maiden crab
     *
     */
    private String identifySpawn(NPC npc)
    {

        int x = npc.getWorldLocation().getRegionX();
        int y = npc.getWorldLocation().getRegionY();
        String proc = getProc();
        if (x == 21 && y == 40)
        {
            return "N1" + proc;
        }
        if (x == 22 && y == 41)
        {
            clog.addLine(MAIDEN_SCUFFED, "N1");
            return "N1" + proc;
        }
        if (x == 25 && y == 40)
        {
            return "N2" + proc;
        }
        if (x == 26 && y == 41)
        {
            clog.addLine(MAIDEN_SCUFFED, "N2");
            return "N2" + proc;
        }
        if (x == 29 && y == 40)
        {
            return "N3" + proc;
        }
        if (x == 30 && y == 41)
        {
            clog.addLine(MAIDEN_SCUFFED, "N3");
            return "N3" + proc;
        }
        if (x == 33 && y == 40)
        {
            return "N4 (1)" + proc;
        }
        if (x == 34 && y == 41)
        {
            clog.addLine(MAIDEN_SCUFFED, "N4 (1)");
            return "N4 (1)" + proc;
        }
        if (x == 33 && y == 38)
        {
            return "N4 (2)" + proc;
        }
        if (x == 34 && y == 39)
        {
            clog.addLine(MAIDEN_SCUFFED, "N4 (2)");
            return "N4 (2)" + proc;
        }
        //
        if (x == 21 && y == 20)
        {
            return "S1" + proc;
        }
        if (x == 22 && y == 19)
        {
            clog.addLine(MAIDEN_SCUFFED, "S1");
            return "S1" + proc;
        }
        if (x == 25 && y == 20)
        {
            return "S2" + proc;
        }
        if (x == 26 && y == 19)
        {
            clog.addLine(MAIDEN_SCUFFED, "S2");
            return "S2" + proc;
        }
        if (x == 29 && y == 20)
        {
            return "S3" + proc;
        }
        if (x == 30 && y == 19)
        {
            clog.addLine(MAIDEN_SCUFFED, "S3");
            return "S3" + proc;
        }
        if (x == 33 && y == 20)
        {
            return "S4 (1)" + proc;
        }
        if (x == 34 && y == 19)
        {
            clog.addLine(MAIDEN_SCUFFED, "S4 (1)");
            return "S4 (1)" + proc;
        }
        if (x == 33 && y == 22)
        {
            return "S4 (2)" + proc;
        }
        if (x == 34 && y == 21)
        {
            clog.addLine(MAIDEN_SCUFFED, "S4 (2)");
            return "S4 (2)" + proc;
        } else
        {
            return "Unknown";
        }
    }

    private String getProc()
    {
        String proc = "";
        if (maidenNPC.getId() == MAIDEN_P1 || maidenNPC.getId() == MAIDEN_P1_HM || maidenNPC.getId() == MAIDEN_P1_SM)
        {
            proc = " 70s";
        } else if (maidenNPC.getId() == MAIDEN_P2 || maidenNPC.getId() == MAIDEN_P2_HM || maidenNPC.getId() == MAIDEN_P2_SM)
        {
            proc = " 50s";
        } else if (maidenNPC.getId() == MAIDEN_P3 || maidenNPC.getId() == MAIDEN_P3_HM || maidenNPC.getId() == MAIDEN_P3_SM)
        {
            proc = " 30s";
        }
        return proc;
    }

}

package com.advancedraidtracker.rooms.tob;

import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.constants.LogID;
import com.advancedraidtracker.constants.TOBRoom;
import com.advancedraidtracker.utility.datautility.DataWriter;
import com.advancedraidtracker.utility.wrappers.PlayerDidAttack;
import com.advancedraidtracker.utility.wrappers.DawnSpec;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import com.advancedraidtracker.utility.RoomState;
import net.runelite.client.game.ItemManager;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import static com.advancedraidtracker.constants.LogID.*;
import static com.advancedraidtracker.constants.TobIDs.*;

@Slf4j
public class VerzikHandler extends RoomHandler
{
    public RoomState.VerzikRoomState roomState;
    private final AdvancedRaidTrackerPlugin plugin;
    private int healingEndTick = -1;
    private final ItemManager itemManager;

    public VerzikHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin, ItemManager itemManager)
    {
        super(client, clog, config);
        this.plugin = plugin;
        this.itemManager = itemManager;
        currentHits = new ArrayList<>();
        lastHits = new ArrayList<>();
        roomState = RoomState.VerzikRoomState.NOT_STARTED;
    }

    public boolean isActive()
    {
        return !(roomState == RoomState.VerzikRoomState.NOT_STARTED || roomState == RoomState.VerzikRoomState.FINISHED);
    }

    public String getName()
    {
        return "Verzik";
    }

    private int verzikEntryTick = -1;
    private int verzikP1EndTick = -1;
    private int verzikRedsTick = -1;
    private int verzikP2EndTick = -1;
    private int verzikP3EndTick = -1;
    private boolean redsThisTick = false;

    private boolean hasWebbed = false;
    private int webTick = -1;

    private final ArrayList<Integer> currentHits;
    private ArrayList<Integer> lastHits;
    private NPC verzNPC;
    Map<Integer, Integer> shieldActives = new HashMap<>();

    public void reset()
    {
        super.reset();
        roomState = RoomState.VerzikRoomState.NOT_STARTED;
        currentHits.clear();
        lastHits.clear();
        verzikEntryTick = -1;
        verzikP1EndTick = -1;
        verzikRedsTick = -1;
        verzikP2EndTick = -1;
        verzikP3EndTick = -1;
        redsThisTick = false;
        hasWebbed = false;
        healingEndTick = -1;
        webTick = -1;
        queuedAutoHits.clear();
        shieldActives.clear();
    }

    public void thrallAttackedShield(int tick)
    {
        //todo finish p2 heal tracking
    }

    public void updateGameTick(GameTick event)
    {
        for (Projectile projectile : client.getProjectiles())
        {
            if (projectile.getId() == VERZIK_CRAB_HEAL_PROJECTILE)
            {
                //todo finish p2 heal tracking
            }
        }
        if (client.getTickCount() == healingEndTick)
        {
            plugin.verzShieldActive = false;
        }
        int playersHit = 1;
        for (Player p : queuedAutoHits.keySet())
        {
            if (queuedAutoHits.get(p) == client.getTickCount())
            {
                for (Player p2 : client.getPlayers())
                {
                    if (p2.getWorldLocation().distanceTo(p.getWorldLocation()) <= 1)
                    {
                        playersHit++;
                        //todo finish p2 heal tracking
                    }
                }
            }
        }
        queuedAutoHits.clear();
        currentHits.clear();
        if (healingEndTick == client.getTickCount())
        {
            healingEndTick = -1;
        }
        redsThisTick = false;
        if (webTick != -1)
        {
            webTick++;
            if (webTick > 50) //non-specific large number > web length but < time before next webs could happen again
            {
                hasWebbed = false;
                webTick = -1;
            }
        }
        lastHits = currentHits;
    }

    private final Map<Player, Integer> queuedAutoHits = new HashMap<>();

    public void updateProjectileMoved(ProjectileMoved event)
    {
        if (event.getProjectile().getId() == VERZIK_CRAB_HEAL_PROJECTILE)
        {
            if (event.getProjectile().getRemainingCycles() == client.getGameCycle())
            {
                //todo finish p2 heal tracking
            }
        }
        if (event.getProjectile().getId() == VERZIK_RED_MAGE_AUTO_PROJECTILE)
        {
            if (event.getProjectile().getRemainingCycles() == 0)
            {
                if (verzNPC.getInteracting() instanceof Player)
                {
                    Player p = (Player) verzNPC;
                    queuedAutoHits.put(p, client.getTickCount() + 2);
                }
            }
        } else if (event.getProjectile().getId() == VERZIK_WEB_PROJECTILE)
        {
            if (!hasWebbed)
            {
                hasWebbed = true;
                clog.addLine(WEBS_STARTED, String.valueOf(client.getTickCount() - verzikEntryTick));
                webTick = client.getTickCount();
                if ((webTick - verzikEntryTick) % 2 == 0)
                {
                    plugin.addDelayedLine(TOBRoom.VERZIK, webTick - verzikEntryTick, "Webs");
                }
            }
        }
    }

    public void updateHitsplatApplied(HitsplatApplied event)
    {
        if (event.getActor().getName() != null)
        {
            if (event.getActor().getName().contains("Verzik") && event.getHitsplat().getHitsplatType() == HitsplatID.HEAL)
            {
                currentHits.add(event.getHitsplat().getAmount());
            }
            if (roomState == RoomState.VerzikRoomState.PHASE_1 && event.getActor().getName().contains("Verzik"))
            {
                if (event.getHitsplat().getAmount() >= DAWNBRINGER_MINIMUM_HIT)
                {
                    clog.addLine(DAWN_DAMAGE, String.valueOf(event.getHitsplat().getAmount()), String.valueOf(client.getTickCount() - roomStartTick));
                    DawnSpec dawnSpec = new DawnSpec("", client.getTickCount() - roomStartTick);
                    dawnSpec.setDamage(event.getHitsplat().getAmount());
                    plugin.liveFrame.getPanel(getName()).addDawnSpec(dawnSpec);
                }
            }
        }
    }

    public void updateGraphicChanged(GraphicChanged event)
    {
        if (event.getActor().hasSpotAnim(VERZIK_BOUNCE_SPOT_ANIMATION))
        {
            clog.addLine(LogID.VERZIK_BOUNCE, event.getActor().getName(), String.valueOf(client.getTickCount() - verzikEntryTick));
            plugin.liveFrame.addAttack(new PlayerDidAttack(itemManager, event.getActor().getName(), VERZIK_BOUNCE_ANIMATION, client.getTickCount() - verzikEntryTick, "-1", "-1", "-1", -1, -1, "", ""), "Verzik");

        }
    }

    public void updateItemSpawned(ItemSpawned event)
    {
        if (event.getItem().getId() == DAWNBRINGER_ITEM)
        {
            clog.addLine(DAWN_DROPPED, String.valueOf(client.getTickCount() - verzikEntryTick));
            plugin.liveFrame.getPanel(getName()).addRoomSpecificData(client.getTickCount() - verzikEntryTick, "X");
        }
    }


    public void updateAnimationChanged(AnimationChanged event)
    {
        int id = event.getActor().getAnimation();
        if (roomState == RoomState.VerzikRoomState.PHASE_2 || roomState == RoomState.VerzikRoomState.PHASE_2_REDS)
        {
            if (plugin.verzShieldActive)
            {
                if (event.getActor() instanceof Player)
                {
                    Player p = (Player) event.getActor();
                    if (p.getInteracting() instanceof NPC)
                    {
                        NPC interacting = (NPC) p.getInteracting();
                        if (interacting.getId() == VERZIK_P2 || interacting.getId() == VERZIK_P2_HM || interacting.getId() == VERZIK_P2_SM)
                        {
                            //TODO: P2 Healing
                        }
                    }
                }
            }
        }

        if (event.getActor().getAnimation() == VERZIK_BECOMES_SPIDER)
        {
            endP3();
        }
    }

    public void updateNpcSpawned(NpcSpawned event)
    {
        int id = event.getNpc().getId();
        if (id == VERZIK_MATOMENOS || id == VERZIK_MATOMENOS_HM || id == VERZIK_MATOMENOS_SM)
        {
            if (!redsThisTick)
            {
                clog.addLine(VERZIK_P2_REDS_PROC, String.valueOf(client.getTickCount() - verzikEntryTick));
                plugin.addDelayedLine(TOBRoom.VERZIK, client.getTickCount() - verzikEntryTick, "Reds");
                healingEndTick = client.getTickCount() + VERZIK_SHIELD_LENGTH;
                plugin.addDelayedLine(TOBRoom.VERZIK, healingEndTick - verzikEntryTick, "Shield End");
                redsThisTick = true;
                plugin.verzShieldActive = true;
            }
            if (roomState != RoomState.VerzikRoomState.PHASE_2_REDS)
            {
                procReds();
            }
        }
        switch (id)
        {
            case VERZIK_MELEE_NYLO:
            case VERZIK_RANGE_NYLO:
            case VERZIK_MAGE_NYLO:
            case VERZIK_MELEE_NYLO_HM:
            case VERZIK_RANGE_NYLO_HM:
            case VERZIK_MAGE_NYLO_HM:
            case VERZIK_MELEE_NYLO_SM:
            case VERZIK_RANGE_NYLO_SM:
            case VERZIK_MAGE_NYLO_SM:
                clog.addLine(VERZIK_CRAB_SPAWNED, String.valueOf(client.getTickCount() - roomStartTick));
                break;
            case VERZIK_P1_INACTIVE:
            case VERZIK_P1_INACTIVE_SM:
            case VERZIK_P1_INACTIVE_HM:
            case VERZIK_P1:
            case VERZIK_P2:
            case VERZIK_P3:
            case VERZIK_P1_HM:
            case VERZIK_P2_HM:
            case VERZIK_P3_HM:
            case VERZIK_P1_SM:
            case VERZIK_P2_SM:
            case VERZIK_P3_SM:
                verzNPC = event.getNpc();
                break;
        }
    }

    public void updateNpcDespawned(NpcDespawned event)
    {
        int id = event.getNpc().getId();
        if (id == VERZIK_P1 || id == VERZIK_P1_HM || id == VERZIK_P1_SM)
        {
            endP1();
        } else if (id == VERZIK_P2 || id == VERZIK_P2_HM || id == VERZIK_P2_SM)
        {
            endP2();
        }
    }

    public void handleNPCChanged(int id)
    {
        if (id == VERZIK_P1 || id == VERZIK_P1_HM || id == VERZIK_P1_SM)
        {
            if (id == VERZIK_P1_HM)
            {
                clog.addLine(IS_HARD_MODE);
            } else if (id == VERZIK_P1_SM)
            {
                clog.addLine(IS_STORY_MODE);
            }
            startVerzik();
        } else if (id == VERZIK_P2 || id == VERZIK_P2_HM || id == VERZIK_P2_SM)
        {
            endP1();
        } else if (id == VERZIK_P3 || id == VERZIK_P3_HM || id == VERZIK_P3_SM)
        {
            endP2();
        } else if (id == VERZIK_DEAD || id == VERZIK_DEAD_HM || id == VERZIK_DEAD_SM)
        {
            endP3();
        }
    }

    private void startVerzik()
    {
        roomState = RoomState.VerzikRoomState.PHASE_1;
        verzikEntryTick = client.getTickCount();
        clog.addLine(VERZIK_P1_START);
        clog.addLine(ACCURATE_VERZIK_START);
        roomStartTick = client.getTickCount();
    }

    private void endP1()
    {
        roomState = RoomState.VerzikRoomState.PHASE_2;
        verzikP1EndTick = client.getTickCount();
        sendTimeMessage("Wave 'Verzik phase 1' complete. Duration: ", verzikP1EndTick - verzikEntryTick);
        clog.addLine(VERZIK_P1_DESPAWNED, String.valueOf(verzikP1EndTick - verzikEntryTick));
        plugin.addDelayedLine(TOBRoom.VERZIK, verzikP1EndTick - verzikEntryTick, "P1 End");

    }

    private void procReds()
    {
        roomState = RoomState.VerzikRoomState.PHASE_2_REDS;
        verzikRedsTick = client.getTickCount();
        sendTimeMessage("Red Crabs Spawned. Duration: ", verzikRedsTick - verzikEntryTick);
    }

    private void endP2()
    {
        roomState = RoomState.VerzikRoomState.PHASE_3;
        verzikP2EndTick = client.getTickCount();
        sendTimeMessage("Wave 'Verzik phase 2' complete. Duration: ", verzikP2EndTick - verzikEntryTick, verzikP2EndTick - verzikP1EndTick);
        clog.addLine(VERZIK_P2_END, String.valueOf(verzikP2EndTick - verzikEntryTick));
        plugin.addDelayedLine(TOBRoom.VERZIK, verzikP2EndTick - verzikEntryTick, "P2 End");

    }

    private void endP3()
    {
        //todo incorrect doubles sometimes
        roomState = RoomState.VerzikRoomState.FINISHED;
        verzikP3EndTick = client.getTickCount() + VERZIK_DEATH_ANIMATION_LENGTH;
        clog.addLine(ACCURATE_VERZIK_END);
        sendTimeMessage("Wave 'Verzik phase 3' complete. Duration: ", verzikP3EndTick - verzikEntryTick, verzikP3EndTick - verzikP2EndTick);
        clog.addLine(VERZIK_P3_DESPAWNED, String.valueOf(verzikP3EndTick - verzikEntryTick));
        plugin.addDelayedLine(TOBRoom.VERZIK, client.getTickCount() - verzikEntryTick, "Dead");
        plugin.liveFrame.setVerzFinished(verzikP3EndTick - verzikEntryTick);

    }
}

package com.advancedraidtracker.utility.weapons;

import java.util.Arrays;
import java.util.List;

public class WeaponDecider
{
    public static WeaponAttack getWeapon(String animationS, String graphics, String projectileS, String weaponS)
    { //todo redo all of this ** magic numbers will be fixed then too
        WeaponAttack weaponUsed = WeaponAttack.UNDECIDED;
        List<String> spotAnims = Arrays.asList(graphics.split(":"));
        int projectile;
        int weapon;
        int animation;
        try
        {
            projectile = Integer.parseInt(projectileS);
            weapon = Integer.parseInt(weaponS);
            animation = Integer.parseInt(animationS);
        } catch (Exception e)
        {
            return weaponUsed;
        }
        switch (animation)
        {
            case 5061:
            case 10656:
                if (projectile == 1043 || projectile == 2599)
                {
                    weaponUsed = WeaponAttack.BLOWPIPE_SPEC;
                } else
                {
                    weaponUsed = WeaponAttack.BLOWPIPE;
                }
                break;
            case 12397:
                weaponUsed = WeaponAttack.EYE_OF_AYAK;
                break;
            case 12394:
                weaponUsed = WeaponAttack.EYE_OF_AYAK_SPEC;
                break;
            case 12342:
                weaponUsed = WeaponAttack.EARTHBOUND_TACPATL;
                break;
            case 11430:
            case 1167:
                if (spotAnims.stream().anyMatch(p -> p.equalsIgnoreCase("1540")))
                {
                    weaponUsed = WeaponAttack.SANG;
                } else
                {
                    if (weapon == 22516)
                    {
                        if (projectile == 1547)
                        {
                            weaponUsed = WeaponAttack.DAWN_SPEC;
                        } else
                        {
                            weaponUsed = WeaponAttack.DAWN_AUTO;
                        }
                    } else
                    {
                        weaponUsed = WeaponAttack.SANG;
                    }
                }
                break;
            case 1979:
            case 10092:
                weaponUsed = WeaponAttack.FREEZE; //todo add lowercase if bad weapon
                break;
            case 1978:
            case 10091:
                weaponUsed = WeaponAttack.BLITZ;
                break;
            case 8056:
                weaponUsed = WeaponAttack.SCYTHE;
                break;
            case 7511:
                weaponUsed = WeaponAttack.DINHS_SPEC;
                break;
            case 7618:
                weaponUsed = WeaponAttack.CHIN;
                break;
            case 1658:
                weaponUsed = WeaponAttack.WHIP;
                break;
            case 401:
                weaponUsed = WeaponAttack.HAMMER_BOP;
                break;
            case 1378:
                weaponUsed = WeaponAttack.HAMMER;
                break;
            case 428:
            case 419:
            case 440:
                if(weapon == 12904)
                {
                    weaponUsed = WeaponAttack.TSOTD;
                    break;
                }
                weaponUsed = WeaponAttack.CHALLY_WHACK;
                break;
            case 1203:
                weaponUsed = WeaponAttack.CHALLY_SPEC;
                break;
            case 390:
            case 9471:
                if(weapon == 26219)
                {
                    weaponUsed = WeaponAttack.FANG;
                    break;
                }
            case 8288:
            case 386:
                if(weapon == 23995 || weapon == 24551)
                {
                    weaponUsed = WeaponAttack.BLADE_OF_SAELDOR;
                    break;
                }
                weaponUsed = WeaponAttack.SWIFT_BLADE;
                break;
            case 7642:
            case 7643:
                weaponUsed = WeaponAttack.BGS_SPEC;
                break;
            case 7045:
                weaponUsed = WeaponAttack.BGS_WHACK;
                break;
            case 426:
                if (weapon == 20997)
                {
                    weaponUsed = WeaponAttack.TBOW;
                } else if (weapon == 27655)
                {
                    weaponUsed = WeaponAttack.WEB_WEAVER;
                } else
                {
                    weaponUsed = WeaponAttack.TBOW;
                }
                break;
            case 9168:
                if (projectile == 1468)
                {
                    weaponUsed = WeaponAttack.ZCB_AUTO;
                } else if (projectile == 1995)
                {
                    weaponUsed = WeaponAttack.ZCB_SPEC;
                }
                break;
            case 2068:
                weaponUsed = WeaponAttack.SULPHUR_BLADES;
                break;
            case 10989:
                weaponUsed = WeaponAttack.DUAL_MAUCUAHUITL;
                break;
            case 7516:
                weaponUsed = WeaponAttack.ELDER_MAUL;
                break;
            case 11124:
                weaponUsed = WeaponAttack.ELDER_MAUL_SPEC;
                break;
            case 10923:
                weaponUsed = WeaponAttack.GLAIVE_AUTO;
                break;
            case 10914:
                weaponUsed = WeaponAttack.GLAIVE_SPEC;
                break;
            case 393:
                weaponUsed = WeaponAttack.CLAW_SCRATCH;
                break;
            case 7514:
                weaponUsed = WeaponAttack.CLAW_SPEC;
                break;
            case 9493:
                weaponUsed = WeaponAttack.SHADOW;
                break;
            case 7554:
                weaponUsed = WeaponAttack.DART;
                break;
            case 6299:
                weaponUsed = WeaponAttack.SBS;
                break;
            case 100000:
                weaponUsed = WeaponAttack.BOUNCE;
                break;
            case 4411:
                weaponUsed = WeaponAttack.AID_OTHER;
                break;
            case 8316:
                weaponUsed = WeaponAttack.VENG_SELF;
                break;
            case 6294:
                weaponUsed = WeaponAttack.HUMIDIFY;
                break;
            case 722:
                weaponUsed = WeaponAttack.MAGIC_IMBUE;
                break;
            case 10629:
            case 836:
                weaponUsed = WeaponAttack.DEATH;
                break;
            case 8070:
            case 1816:
                weaponUsed = WeaponAttack.TELEPORT;
                break;
            case 4409:
                weaponUsed = WeaponAttack.HEAL_GROUP;
                break;
        }
        return weaponUsed;
    }
}
package com.advancedraidtracker.utility.weapons;

import net.runelite.api.ItemID;

import java.awt.*;

public enum WeaponAttack
{
    UNDECIDED("Undecided", "?", new Color(0, 0, 0), -1),
    BLOWPIPE("Blowpipe", "BP", new Color(100, 150, 200), 2),
    BLOWPIPE_SPEC("Blowpipe spec", "bp", new Color(100, 150, 200), 2),
    HAMMER("DWH Spec", "H", new Color(100, 100, 100), 6),
    HAMMER_BOP("DWH Bop", "h", new Color(50, 50, 50), 6),
    SANG("Sang/Trident", "T", new Color(30, 120, 130), 4),
    CHALLY_SPEC("Chally spec", "CH", new Color(150, 50, 50), 7),
    CHALLY_WHACK("Chally whack", "ch", new Color(150, 50, 50), 7),
    SWIFT_BLADE("Swift Blade", "SB", new Color(225, 50, 50), 3),
    BGS_WHACK("BGS whack", "bg", new Color(170, 20, 20), 6),
    BGS_SPEC("BGS spec", "BG", new Color(170, 20, 20, 0), 6),
    TBOW("Tbow", "TB", new Color(30, 120, 30), 5),
    ZCB_AUTO("ZCB Auto", "zc", new Color(10, 170, 50), 5),
    ZCB_SPEC("ZCB Spec", "ZC", new Color(10, 170, 50), 5),
    SCYTHE("Scythe", "S", new Color(230, 100, 100), 5),
    DINHS_SPEC("Dinhs Spec", "BW", new Color(20, 20, 20), 5),
    DINHS_WHACK("Dinhs Whack", "bw", new Color(20, 20, 20), 5),
    CHIN("Chinchompa", "CC", new Color(0, 130, 0), 3),
    WHIP("Tent Whip", "TW", new Color(10, 70, 80), 4),
    FREEZE("Freeze", "F", new Color(50, 50, 170), 5),
    BLITZ("Blitz/Rush", "BR", new Color(50, 50, 170), 5),
    DAWN_SPEC("Dawnbringer Spec", "DB", new Color(10, 100, 150), 4),
    DAWN_AUTO("Dawnbringer Auto", "db", new Color(10, 100, 150), 4),
    CLAW_SCRATCH("Claw Scratch", "c", new Color(76, 89, 1), 4),
    CLAW_SPEC("Claw Spec", "C", new Color(76, 89, 1), 4),
    SHADOW("Shadow", "Sh", new Color(20, 20, 60), 5),
    DART("Dart", "Da", new Color(10, 60, 60), 2),
    SBS("Spellbook Swap", "SS", new Color(10, 100, 60), -1),
    BOUNCE("Bounce", "VB", new Color(200, 10, 10), -1),
    AID_OTHER("Aid other", "AO", new Color(100, 100, 100), -1),
    VENG_SELF("Veng Self", "VS", new Color(160, 89, 13), -1),
    HUMIDIFY("Humidify", "HU", new Color(20, 20, 200), -1),
    MAGIC_IMBUE("Magic Imbue", "MI", new Color(60, 60, 150), -1),
    WEB_WEAVER("Web Weaver", "WW", new Color(240, 18, 119), 3),
    DEATH("Death", "X", new Color(0, 0, 0), -1),
    TELEPORT("Teleport", "TP", new Color(60, 70, 80), -1),
    HEAL_GROUP("Heal Group", "HG", new Color(50, 170, 100), -1),
    CONSUME("Food/Drink Consumed", "CS", new Color(110, 50, 60), -1),
    THRALL_CAST("Thrall Cast", "TC", new Color(20, 65, 187), -1),
    BLADE_OF_SAELDOR("Blade of Saeldor", "BS", new Color(67, 10, 45), 4),
    FANG("Osmumten's Fang", "OF", new Color(10, 10, 100), 5),

    SULPHUR_BLADES("Sulphur Blades", "SUL", new Color(180, 20, 40), 4),
    ELDER_MAUL_SPEC("Elder Maul Spec", "EM", new Color(100, 60, 60), 6),
    ELDER_MAUL("Elder Maul", "EM", new Color(100, 60, 60), 6),
    GLAIVE_AUTO("Glaive Auto", "g", new Color(0, 70, 0), 6),
    GLAIVE_SPEC("Glaive Spec", "G", new Color(0, 70, 0), 6),
    DUAL_MAUCUAHUITL("Dual Maucuahuitl", "DMC", new Color(180, 30, 60), 4),

    EYE_OF_AYAK("Eye of Ayak", "AY", new Color(30, 120, 130), 3),
    EYE_OF_AYAK_SPEC("Eye of Ayak Spec", "AYS", new Color(30, 120, 130), 5),
    EARTHBOUND_TACPATL("Earthbound Tacpatl", "TAC", new Color(180, 20, 40), 4),
    
    TSOTD("Toxic Staff of the Dead", "TS", new Color(70, 10, 10), 4),



    ;

    public final String name;
    public final String shorthand;
    public final Color color;
    public final int attackTicks;


    WeaponAttack(String name, String shorthand, Color color, int attackTicks)
    {
        this.attackTicks = attackTicks;
        this.name = name;
        this.shorthand = shorthand;
        this.color = color;
    }
}

package com.advancedraidtracker.utility.wrappers;

import com.advancedraidtracker.SimpleTOBData;

import java.util.ArrayList;

public class RaidsArrayWrapper
{
    public ArrayList<SimpleTOBData> data;
    public String filename;

    public RaidsArrayWrapper(ArrayList<SimpleTOBData> data, String filename)
    {
        this.data = data;
        this.filename = filename;
    }
}

package com.advancedraidtracker.utility.wrappers;

import com.advancedraidtracker.utility.PlayerWornItems;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

@Slf4j
public class PlayerDidAttack
{
    public String player;
    public String animation;
    public int tick;
    public String weapon;
    public String projectile;
    public String spotAnims;
    public int targetedIndex;
    public int targetedID;
    public String targetName;
    public String wornItems;
    public String[] wornItemNames = {};

    public ItemManager itemManager;
    public AsyncBufferedImage img = null;
    private boolean setUnkitted = false;

    private static final Set<Integer> scythe = new HashSet<>(Arrays.asList(ItemID.HOLY_SCYTHE_OF_VITUR, ItemID.SANGUINE_SCYTHE_OF_VITUR));
    private static final Set<Integer> bp = new HashSet<>(Collections.singletonList(ItemID.BLAZING_BLOWPIPE));
    private static final Set<Integer> sang = new HashSet<>(Collections.singletonList(ItemID.HOLY_SANGUINESTI_STAFF));
    private static final Set<Integer> bulwark = new HashSet<>(Collections.singletonList(ItemID.DINHS_BLAZING_BULWARK));
    private static final Set<Integer> claws = new HashSet<>(Collections.singletonList(ItemID.CORRUPTED_DRAGON_CLAWS));
    private static final Set<Integer> dwh = new HashSet<>(Arrays.asList(ItemID.DRAGON_WARHAMMER_CR, ItemID.DRAGON_WARHAMMER_OR));

    public PlayerDidAttack(ItemManager itemManager, String player, String animation, int tick, String weapon, String projectile, String spotAnims, int targetedIndex, int targetedID, String targetName, String worn)
    {
        this.itemManager = itemManager;
        this.player = player;
        this.animation = animation;
        this.tick = tick;
        this.weapon = weapon;
        this.projectile = projectile;
        this.spotAnims = spotAnims;
        this.targetedIndex = targetedIndex;
        this.targetedID = targetedID;
        this.targetName = targetName;
        this.wornItems = worn;
    }

    public void setWornNames()
    {
        wornItemNames = new PlayerWornItems(wornItems, itemManager).getAll();
    }

    public void useUnkitted()
    {
        setUnkitted = true;
    }

    private int getReplacement(int original)
    {
        if(scythe.contains(original))
        {
            return ItemID.SCYTHE_OF_VITUR;
        }
        if(sang.contains(original))
        {
            return ItemID.SANGUINESTI_STAFF;
        }
        if(bp.contains(original))
        {
            return ItemID.TOXIC_BLOWPIPE;
        }
        if(bulwark.contains(original))
        {
            return ItemID.DINHS_BULWARK;
        }
        if(claws.contains(original))
        {
            return ItemID.DRAGON_CLAWS;
        }
        if(dwh.contains(original))
        {
            return ItemID.DRAGON_WARHAMMER;
        }
        return original;
    }

    public void setIcons()
    {
        int weaponID = Integer.parseInt(this.weapon);
        if(setUnkitted)
        {
            weaponID = getReplacement(weaponID);
        }
        img = itemManager.getImage(weaponID, 1, false);
    }
}

package com.advancedraidtracker.utility.wrappers;

import lombok.Getter;
import lombok.Setter;

public class DawnSpec
{
    public String player;
    public int tick;

    public DawnSpec(String player, int tick)
    {
        this.player = player;
        this.tick = tick;
    }

    @Getter
    @Setter
    int damage = -1;

}

package com.advancedraidtracker.utility.wrappers;

import net.runelite.api.NPC;

public class MaidenCrab
{
    public NPC crab;
    public int maxHealth;
    public int health;
    public String description;

    public MaidenCrab(NPC crab, int scale, String description)
    {
        switch (scale)
        {
            case 5:
                maxHealth = 100;
                break;
            case 4:
                maxHealth = 87;
                break;
            default:
                maxHealth = 75;
                break;
        }
        this.crab = crab;
        health = maxHealth;
        this.description = description;
    }
}

package com.advancedraidtracker.utility.wrappers;

public class StringInt
{
    public int val;
    public String string;

    public StringInt(String string, int val)
    {
        this.string = string;
        this.val = val;
    }
}

package com.advancedraidtracker.utility.wrappers;

import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;

public class QueuedPlayerAttackLessProjectiles
{
    public Player player;
    public String animation;
    public int tick;
    public String spotAnims;
    public String weapon;

    public WorldPoint location;

    public QueuedPlayerAttackLessProjectiles(Player player, WorldPoint location, int tick, String spotAnims, String weapon, String animation)
    {
        this.player = player;
        this.animation = animation;
        this.tick = tick;
        this.spotAnims = spotAnims;
        this.weapon = weapon;
        this.location = location;
    }
}

package com.advancedraidtracker.utility.wrappers;

public class PlayerCorrelatedPointData
{
    public int value;
    public String player;

    public PlayerCorrelatedPointData(String player, int value)
    {
        this.value = value;
        this.player = player;
    }
}

package com.advancedraidtracker.utility.wrappers;

import com.advancedraidtracker.utility.ItemReference;
import com.advancedraidtracker.utility.weapons.WeaponAttack;

import java.awt.*;

public class OutlineBox
{
    public String player;
    public int tick;
    public String letter;
    public Color color;
    public boolean primaryTarget;
    public WeaponAttack weaponAttack;

    public String additionalText;
    public PlayerDidAttack attack;

    public OutlineBox(PlayerDidAttack attack, String letter, Color color, boolean primaryTarget, String additionalText, WeaponAttack weaponAttack)
    {
        this.weaponAttack = weaponAttack;
        this.attack = attack;
        this.player = attack.player;
        this.tick = attack.tick;
        this.letter = letter;
        this.color = color;
        this.primaryTarget = primaryTarget;
        this.additionalText = additionalText;
    }

    public final int NONE = 0;
    public final int MELEE = 1;
    public final int RANGE = 2;
    public final int MAGE = 3;
    public int style = NONE;
    public Color outlineColor = new Color(0, 0, 0, 0);

    private boolean anyMatch(String item, String[] items)
    {
        for(String s : items)
        {
            if(item.toLowerCase().contains(s))
            {
                return true;
            }
        }
        return false;
    }

    private void setStyle(String weapon)
    {
        if(anyMatch(weapon, ItemReference.ITEMS[MELEE]))
        {
            style = MELEE;
        }
        else if(anyMatch(weapon, ItemReference.ITEMS[RANGE]))
        {
            style = RANGE;
        }
        else if(anyMatch(weapon, ItemReference.ITEMS[MAGE]))
        {
            style = MAGE;
        }
    }
    public void createOutline()
    {
        if(letter.equals("VS") || letter.equals("AO") || letter.equals("HU") || letter.equals("MI") || letter.equals("DB") || letter.equals("SS"))
        {
            return;
        }
        int correctItems = 0;
        boolean voidHelmWorn = false;
        if(attack.wornItemNames.length == 9)
        {
            setStyle(attack.wornItemNames[3]);
            if(attack.wornItemNames[0].toLowerCase().contains("void"))
            {
                voidHelmWorn = true;
            }
            for(String s : attack.wornItemNames)
            {
                if(anyMatch(s, ItemReference.ITEMS[style]) || (voidHelmWorn && s.toLowerCase().contains("void")))
                {
                    correctItems++;
                }
            }
            if(attack.wornItemNames[2].toLowerCase().contains("blood fury") && style == MELEE)
            {
                correctItems++;
            }
        }
        switch(style)
        {
            case MELEE:
                if(correctItems < 8)
                {
                    int opacity = (int)((255)*((8-correctItems)/8.0));
                    opacity = Math.max(opacity, 150);
                    outlineColor = new Color(255, 255, 0, opacity);
                }
                break;
            case RANGE:
                if(correctItems < 6)
                {
                    outlineColor = new Color(255, 255, 0, (int)((255)*((6-correctItems)/6.0)));
                }
                break;
            case MAGE:
                if(correctItems < 5)
                {
                    outlineColor = new Color(255, 255, 0, (int)((255)*((5-correctItems)/5.0)));
                }
                break;
        }
    }
}

package com.advancedraidtracker.utility.wrappers;

import java.awt.*;

import static com.advancedraidtracker.constants.TobIDs.*;

public class ThrallOutlineBox
{
    public int spawnTick;
    public String owner;
    public int id;

    public ThrallOutlineBox(String owner, int spawnTick, int id)
    {
        this.spawnTick = spawnTick;
        this.owner = owner;
        this.id = id;
    }

    public Color getColor()
    {
        switch (id)
        {
            case MELEE_THRALL:
                return new Color(240, 30, 30);
            case RANGE_THRALL:
                return new Color(30, 240, 30);
            case MAGE_THRALL:
                return new Color(30, 30, 240);
            default:
                return new Color(30, 30, 30);
        }
    }
}

package com.advancedraidtracker.utility.wrappers;

public class PlayerCopy
{
    public String name;
    public int interactingIndex;
    public int interactingID;
    public String interactingName;
    public int animation;
    public String wornItems;
    public String weapon;
    public PlayerCopy(String name, int interactingIndex, int interactingID, String interactingName, int animation, String wornItems, String weapon)
    {
        this.name = name;
        this.interactingIndex = interactingIndex;
        this.interactingID = interactingID;
        this.interactingName = interactingName;
        this.animation = animation;
        this.wornItems = wornItems;
        this.weapon = weapon;
    }
}

package com.advancedraidtracker.utility.wrappers;

import java.util.ArrayList;

public class PlayerHitsWrapper
{
    public ArrayList<Integer> hitsplats;
    public String name;
    public int hits;

    public PlayerHitsWrapper(String name, int initial)
    {
        this.name = name;
        hitsplats = new ArrayList<>();
        hitsplats.add(initial);
        this.hits = 0;
    }
}

package com.advancedraidtracker.utility.wrappers;

import lombok.Getter;
import net.runelite.api.NPC;

public class NPCTimeInChunkShell
{
    @Getter
    public int timeInChunk;
    public int chunk;
    public NPC npc;
    public boolean marked;

    public int getIndex()
    {
        return npc.getIndex();
    }
    public NPCTimeInChunkShell(NPC npc, int chunk, int timeInChunk)
    {
        this.npc = npc;
        this.chunk = chunk;
        this.timeInChunk = timeInChunk;
        marked = false;
    }
}

package com.advancedraidtracker.utility;


import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class Point
{
    private int x;
    private int y;

    public Point(int x, int y)
    {
        this.x = x;
        this.y = y;
    }
}

package com.advancedraidtracker.utility;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionListener;

public class UISwingUtility
{
    public static String colorStr(Color c)
    {
        return "<html><font color='#" + Integer.toHexString(c.getRGB()).substring(2) + "'>";
    }
    public  final static String roomColor = colorStr(new Color(200, 200, 200));
    public static JLabel getDarkJLabel(String labelText)
    {
        return new JLabel(labelText);
    }

    public static JLabel getDarkJLabel(String labelText, int swingConstant)
    {
        return new JLabel(labelText, swingConstant);
    }

    public static JPanel getTitledPanel(String title)
    {
        JPanel panel = new JPanel();
        panel.setBorder(BorderFactory.createTitledBorder(title));
        return panel;
    }

    public static JCheckBox getActionListenCheckBox(String name, ActionListener actionListener)
    {
        return getActionListenCheckBox(name, false, actionListener);
    }

    public static JCheckBox getActionListenCheckBox(String name, boolean state, ActionListener actionListener)
    {
        JCheckBox darkCheckBox = new JCheckBox(name, state);
        darkCheckBox.addActionListener(actionListener);
        return darkCheckBox;
    }

    public static JComboBox<String> getActionListenCheckBox(String[] options, ActionListener actionListener)
    {
        JComboBox<String> dark = new JComboBox<>(options);
        dark.addActionListener(actionListener);
        return dark;
    }
}

package com.advancedraidtracker.utility;

import net.runelite.api.PlayerComposition;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemManager;

public class PlayerWornItems
{
    public int helmet = 0;
    public int cape = 0;
    public int amulet = 0;
    public int weapon = 0;
    public int torso = 0;
    public int shield = 0;
    public int legs = 0;
    public int gloves = 0;
    public int boots = 0;
    private final ItemManager itemManager;
    public PlayerWornItems(String s, ItemManager itemManager)
    {
        this.itemManager = itemManager;
        String[] items = s.split("~");
        if(items.length == 9)
        {
            helmet = Integer.parseInt(items[0]);
            cape = Integer.parseInt(items[1]);
            amulet = Integer.parseInt(items[2]);
            weapon = Integer.parseInt(items[3]);
            torso = Integer.parseInt(items[4]);
            shield = Integer.parseInt(items[5]);
            legs = Integer.parseInt(items[6]);
            gloves = Integer.parseInt(items[7]);
            boots = Integer.parseInt(items[8]);
        }
    }

    public static String getStringFromComposition(PlayerComposition pc)
    {
        return pc.getEquipmentId(KitType.HEAD) +"~"
                    + pc.getEquipmentId(KitType.CAPE) +"~"
                    +pc.getEquipmentId(KitType.AMULET) + "~"
                    +pc.getEquipmentId(KitType.WEAPON) +"~"
                    +pc.getEquipmentId(KitType.TORSO)+"~"
                    +pc.getEquipmentId(KitType.SHIELD)+"~"
                    +pc.getEquipmentId(KitType.LEGS)+"~"
                    +pc.getEquipmentId(KitType.HANDS)+"~"
                    +pc.getEquipmentId(KitType.BOOTS);
    }

    public String[] getAll()
    {
        if(helmet+cape+amulet+weapon+torso+shield+legs+gloves+boots == 0)
        {
            return new String[]{};
        }
        else
        {
            return new String[]
                    {
                            "Helmet: " + getItemName(helmet),
                            "Cape: " + getItemName(cape),
                            "Amulet: " + getItemName(amulet),
                            "Weapon: " + getItemName(weapon),
                            "Torso: " + getItemName(torso),
                            "Shield: " + getItemName(shield),
                            "Legs: " + getItemName(legs),
                            "Gloves: " + getItemName(gloves),
                            "Boots: " + getItemName(boots),
                    };
        }
    }

    public String getItemName(int id)
    {
        if(id == -1)
        {
            return "None";
        }
        else
        {
            return itemManager.getItemComposition(id).getName();
        }
    }
}

package com.advancedraidtracker.utility;

public class ItemReference
{

    public static String[][] ITEMS = {
            {"none", "elite void", "void knight", "blood fury"},
            {
                    "torva",
                    "defender",
                    "scythe",
                    "osmumten",
                    "blade",
                    "halberd",
                    "melee",
                    "dagger",
                    "inquisitor",
                    "claws",
                    "rapier",
                    "bulwark",
                    "hammer",
                    "primordial",
                    "ferocious",
                    "infernal",
                    "fire cape",
                    "bandos",
                    "godsword",
                    "dragon boots",
                    "whip",
                    "tentacle",
                    "salve",
                    "faceguard",
                    "torso",
                    "joint",
                    "torture",
                    "serpentine helm",
                    "barrows",
                    "rancour",
                    "oathplate",
                    "sulphur",
                    "macuahuitl",
                    "tacpatl",
                    "avernic treads"
            },
            {
                    "masori",
                    "bow",
                    "range",
                    "blowpipe",
                    "anguish",
                    "assembler",
                    "pegasian",
                    "buckler",
                    "chinchompa",
                    "vambraces",
                    "ralos",
                    "dizana",
                    "avernic treads"
            },
            {
                    "ancestral",
                    "virtus",
                    "occult",
                    "tormented",
                    "tumeken",
                    "staff",
                    "mage",
                    "eternal",
                    "imbued",
                    "trident",
                    "kodai",
                    "ice",
                    "ward",
                    "dawnbringer",
                    "ancient sceptre",
                    "ayak",
                    "confliction",
                    "avernic treads"
            }
    };

    public static final int MELEE = 1;
    public static final int RANGE = 2;
    public static final int MAGE = 3;
    public static final int NONE = 0;

}

package com.advancedraidtracker.utility.datautility;

import lombok.Getter;
import lombok.Setter;

public class DataPointIntWrapper
{
    @Setter
    @Getter
    public int value = 0;
    DataPoint dataPoint;

    public DataPointIntWrapper(DataPoint point)
    {
        dataPoint = point;
        if (point.equals(DataPoint.MAIDEN_DEFENSE))
        {
            value = 200;
        } else if (point.equals(DataPoint.BLOAT_DEFENSE))
        {
            value = 100;
        } else if (point.equals(DataPoint.NYLO_DEFENSE))
        {
            value = 50;
        } else if (point.equals(DataPoint.XARP_DEFENSE))
        {
            value = 250;
        } else if (point.equals(DataPoint.VERZIK_HP_AT_WEBS))
        {
            value = -1;
        }
    }

    public void increment(int valueAdded)
    {
        value += valueAdded;
    }

    public void increment()
    {
        value++;
    }
}

package com.advancedraidtracker.utility.datautility;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;

public enum DataPoint
{

    CHALLENGE_TIME("Challenge Time", types.TIME, rooms.ANY),
    OVERALL_TIME("Overall Time", types.TIME, rooms.ANY),
    TIME_OUTSIDE_ROOMS("Time Outside Rooms", types.TIME, rooms.ANY),
    MAIDEN_TOTAL_TIME("Maiden Time", types.TIME, rooms.MAIDEN),
    BLOAT_TOTAL_TIME("Bloat Time", types.TIME, rooms.BLOAT),
    NYLO_TOTAL_TIME("Nylocas Time", types.TIME, rooms.NYLOCAS),
    XARP_TOTAL_TIME("Xarpus Time", types.TIME, rooms.XARPUS),
    SOTE_TOTAL_TIME("Sotetseg Time", types.TIME, rooms.SOTETSEG),
    VERZIK_TOTAL_TIME("Verzik Time", types.TIME, rooms.VERZIK),
    MAIDEN_BLOOD_SPAWNED("Maiden blood spawned", types.OTHER_INT, rooms.MAIDEN),
    MAIDEN_BLOOD_THROWN("Maiden blood thrown", types.OTHER_INT, rooms.MAIDEN),
    MAIDEN_PLAYER_STOOD_IN_THROWN_BLOOD("Maiden player stood in thrown blood", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_PLAYER_STOOD_IN_SPAWNED_BLOOD("Maiden player stood in spawned blood", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_HEALS_FROM_THROWN_BLOOD("Maiden heals from thrown blood", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_HEALS_FROM_SPAWNED_BLOOD("Maiden heals from spawned blood", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_PLAYER_STOOD_IN_BLOOD("Maiden player stood in any blood", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_HEALS_FROM_ANY_BLOOD("Maiden heals from any blood", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_MELEE_DRAINS("Maiden drained melee", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_CRABS_LEAKED("Maiden crabs leaked", types.OTHER_INT, rooms.MAIDEN),
    MAIDEN_CRABS_LEAKED_FULL_HP("Maiden crabs leaked full", types.OTHER_INT, rooms.MAIDEN),
    MAIDEN_HP_HEALED("Maiden HP healed", types.OTHER_INT, rooms.MAIDEN),
    MAIDEN_DEFENSE("Maiden defense", types.OTHER_INT, rooms.MAIDEN, 200),
    MAIDEN_DEATHS("Maiden deaths", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_DINHS_SPECS("Maiden dinhs specs", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_DINHS_CRABS_HIT("Maiden dinhs crabs Hit", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_DINHS_TARGETS_HIT("Maiden dinhs targets hit", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_DINHS_AVERAGE_HP_HIT("Maiden dinhs average HP crab", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_DINHS_PERCENT_TARGETS_CRAB("Maiden dinhs % crabs targeted", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_DINHS_CRABS_UNDER_27_TARGETED("Maiden dinhs crab < 27hp targeted", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_DINHS_CRABS_UNDER_27_TARGETED_PERCENT("Maiden dinhs crabs <27hp targeted %", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_CHINS_THROWN("Maiden chins thrown", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_CHINS_THROWN_WRONG_DISTANCE("Maiden chins thrown wrong distance", types.OTHER_INT, rooms.MAIDEN, true),
    MAIDEN_CHIN_CORRECT_DISTANCE_PERCENT("Maiden chins correct distance %", types.OTHER_INT, rooms.MAIDEN, true),
    RAID_INDEX("Raid Index", types.OTHER_INT, rooms.ANY),
    PARTY_SIZE("Party Size", types.OTHER_INT, rooms.ANY),

    BLOAT_DOWNS("Bloat downs", types.OTHER_INT, rooms.BLOAT),
    BLOAT_HP_FIRST_DOWN("Bloat HP% 1st down", types.OTHER_INT, rooms.BLOAT),
    BLOAT_FIRST_WALK_SCYTHES("Bloat 1st walk scythes", types.OTHER_INT, rooms.BLOAT, true),
    BLOAT_FIRST_WALK_DEATHS("Bloat 1st walk deaths", types.OTHER_INT, rooms.BLOAT, true),
    BLOAT_DEFENSE("Bloat defense", types.OTHER_INT, rooms.BLOAT, 100),
    BLOAT_DEATHS("Bloat deaths", types.OTHER_INT, rooms.BLOAT, true),
    NYLO_STALLS_PRE_20("Nylo stalls pre 20", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_STALLS_POST_20("Nylo stalls post 20", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_STALLS_TOTAL("Nylo stalls total", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_SPLITS_RANGE("Nylo splits range", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_SPLITS_MAGE("Nylo splits mage", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_SPLITS_MELEE("Nylo splits melee", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_ROTATIONS_RANGE("Nylo rotations range", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_ROTATIONS_MAGE("Nylo rotations mage", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_ROTATIONS_MELEE("Nylo rotations melee", types.OTHER_INT, rooms.NYLOCAS),
    NYLO_DEFENSE("Nylo defense", types.OTHER_INT, rooms.NYLOCAS, 50),
    NYLO_DEATHS("Nylo deaths", types.OTHER_INT, rooms.NYLOCAS, true),
    SOTE_SPECS_P1("Sote specs p1", types.OTHER_INT, rooms.SOTETSEG),
    SOTE_SPECS_P2("Sote specs p2", types.OTHER_INT, rooms.SOTETSEG),
    SOTE_SPECS_P3("Sote specs p3", types.OTHER_INT, rooms.SOTETSEG),
    SOTE_SPECS_TOTAL("Sote specs total", types.OTHER_INT, rooms.SOTETSEG),
    SOTE_DEATHS("Sote deaths", types.OTHER_INT, rooms.SOTETSEG, true),
    XARP_HEALING("Xarp Healing", types.OTHER_INT, rooms.XARPUS),
    XARP_DEFENSE("Xarp defense", types.OTHER_INT, rooms.XARPUS, 250),
    XARP_DEATHS("Xarp deaths", types.OTHER_INT, rooms.XARPUS, true),
    VERZIK_BOUNCES("Verzik bounces", types.OTHER_INT, rooms.VERZIK, true),
    VERZIK_CRABS_SPAWNED("Verzik crabs spawned", types.OTHER_INT, rooms.VERZIK),
    VERZIK_REDS_SETS("Verzik Red Sets", types.OTHER_INT, rooms.VERZIK),
    VERZIK_REDS_PROC_PERCENT("Verzik Red Proc Percent", types.OTHER_INT, rooms.VERZIK),
    VERZIK_DEATHS("Verzik deaths", types.OTHER_INT, rooms.VERZIK, true),
    VERZIK_HP_AT_WEBS("Verzik HP% at webs", types.OTHER_INT, rooms.VERZIK),
    MAIDEN_70_SPLIT("Maiden 70s split", types.TIME, rooms.MAIDEN),
    MAIDEN_7050_SPLIT("Maiden 70-50s split", types.TIME, rooms.MAIDEN),
    MAIDEN_50_SPLIT("Maiden 50s split", types.TIME, rooms.MAIDEN),
    MAIDEN_5030_SPLIT("Maiden 50-30s split", types.TIME, rooms.MAIDEN),
    MAIDEN_30_SPLIT("Maiden 30s split", types.TIME, rooms.MAIDEN),
    MAIDEN_SKIP_SPLIT("Maiden Skip split", types.TIME, rooms.MAIDEN),
    BLOAT_FIRST_DOWN_TIME("Bloat 1st down time", types.OTHER_INT, rooms.BLOAT),
    NYLO_BOSS_SPAWN("Nylo boss spawn", types.TIME, rooms.NYLOCAS),
    NYLO_BOSS_DURATION("Nylo boss duration", types.TIME, rooms.NYLOCAS),
    NYLO_LAST_WAVE("Nylo last wave", types.TIME, rooms.NYLOCAS),
    NYLO_LAST_DEAD("Nylo last dead", types.TIME, rooms.NYLOCAS),
    NYLO_CLEANUP("Nylo cleanup", types.TIME, rooms.NYLOCAS),
    NYLOCAS_PILLAR_DESPAWN_TICK("Nylo Pillar despawn tick", types.TIME, rooms.NYLOCAS),
    SOTE_P1_SPLIT("Sote P1 split", types.TIME, rooms.SOTETSEG),
    SOTE_P2_SPLIT("Sote P2 split", types.TIME, rooms.SOTETSEG),
    SOTE_P2_DURATION("Sote P2 duration", types.TIME, rooms.SOTETSEG),

    SOTE_P3_DURATION("Sote P3 duration", types.TIME, rooms.SOTETSEG),
    SOTE_M1_SPLIT("Sote maze1 split", types.TIME, rooms.SOTETSEG),
    SOTE_M1_DURATION("Sote maze1 Duration", types.TIME, rooms.SOTETSEG),
    SOTE_M2_SPLIT("Sote maze2 split", types.TIME, rooms.SOTETSEG),
    SOTE_M2_DURATION("Sote maze2 duration", types.TIME, rooms.SOTETSEG),
    SOTE_MAZE_SUM("Sote mazes combined", types.TIME, rooms.SOTETSEG),
    XARP_SCREECH("Xarp screech", types.TIME, rooms.XARPUS),
    XARP_POST_SCREECH("Xarp post screech", types.TIME, rooms.XARPUS),
    VERZIK_P1_SPLIT("Verzik P1 split", types.TIME, rooms.VERZIK),

    VERZIK_P2_TILL_REDS("Verzik P2 until reds split", types.TIME, rooms.VERZIK),
    VERZIK_REDS_SPLIT("Verzik reds split", types.TIME, rooms.VERZIK),
    VERZIK_REDS_DURATION("Verzik reds duration", types.TIME, rooms.VERZIK),
    VERZIK_P2_SPLIT("Verzik P2 split", types.TIME, rooms.VERZIK),
    VERZIK_P2_DURATION("Verzik P2 duration", types.TIME, rooms.VERZIK),
    VERZIK_P3_DURATION("Verzik P3 duration", types.TIME, rooms.VERZIK),

    NYLO_ENTRY("Nylo Entry", types.TIME, rooms.NYLOCAS),
    SOTE_ENTRY("Sote Entry", types.TIME, rooms.SOTETSEG),
    XARP_ENTRY("Xarp Entry", types.TIME, rooms.XARPUS),
    VERZIK_ENTRY("Verzik Entry", types.TIME, rooms.VERZIK),

    ATTEMPTED_HAMMERS_MAIDEN("Maiden attempted hammers", types.OTHER_INT, rooms.MAIDEN, true),
    ATTEMPTED_HAMMERS_BLOAT("Bloat attempted hammers", types.OTHER_INT, rooms.BLOAT, true),
    ATTEMPTED_HAMMERS_NYLO("Nylo attempted hammers", types.OTHER_INT, rooms.NYLOCAS, true),
    ATTEMPTED_HAMMERS_SOTE("Sote attempted hammers", types.OTHER_INT, rooms.SOTETSEG, true),
    ATTEMPTED_HAMMERS_XARP("Xarp attempted hammers", types.OTHER_INT, rooms.XARPUS, true),
    ATTEMPTED_HAMMERS_VERZIK("Verzik attempted hammers", types.OTHER_INT, rooms.VERZIK, true),
    HIT_HAMMERS_MAIDEN("Maiden hit hammers", types.OTHER_INT, rooms.MAIDEN, true),
    HIT_HAMMERS_BLOAT("Bloat hit hammers", types.OTHER_INT, rooms.BLOAT, true),
    HIT_HAMMERS_NYLO("Nylo hit hammers", types.OTHER_INT, rooms.NYLOCAS, true),
    HIT_HAMMERS_SOTE("Sote hit hammers", types.OTHER_INT, rooms.SOTETSEG, true),
    HIT_HAMMERS_XARP("Xarp hit hammers", types.OTHER_INT, rooms.XARPUS, true),
    HIT_HAMMERS_VERZIK("Verzik hit hammers", types.OTHER_INT, rooms.VERZIK, true),

    ATTEMPTED_BGS_MAIDEN("Maiden attempted BGS", types.OTHER_INT, rooms.MAIDEN, true),
    BGS_DAMAGE_MAIDEN("Maiden BGS damage", types.OTHER_INT, rooms.MAIDEN, true),

    ATTEMPTED_BGS_BLOAT("Bloat attempted BGS", types.OTHER_INT, rooms.BLOAT, true),
    BGS_DAMAGE_BLOAT("Bloat BGS damage", types.OTHER_INT, rooms.BLOAT, true),

    ATTEMPTED_BGS_NYLO("Nylo attempted BGS", types.OTHER_INT, rooms.NYLOCAS, true),
    BGS_DAMAGE_NYLO("Nylo BGS damage", types.OTHER_INT, rooms.NYLOCAS, true),

    ATTEMPTED_BGS_SOTE("Sote attempted BGS", types.OTHER_INT, rooms.SOTETSEG, true),
    BGS_DAMAGE_SOTE("Sote BGS damage", types.OTHER_INT, rooms.SOTETSEG, true),

    ATTEMPTED_BGS_XARP("Xarp attempted BGS", types.OTHER_INT, rooms.XARPUS, true),
    BGS_DAMAGE_XARP("Xarp BGS damage", types.OTHER_INT, rooms.XARPUS, true),

    ATTEMPTED_BGS_VERZ("Verzik attempted BGS", types.OTHER_INT, rooms.VERZIK, true),
    BGS_DAMAGE_VERZ("Verzik BGS damage", types.OTHER_INT, rooms.VERZIK, true),

    THRALL_ATTACKS_TOTAL("Total thrall attacks", types.OTHER_INT, rooms.ANY, true),
    THRALL_ATTACKS_MAIDEN("Maiden thrall attacks", types.OTHER_INT, rooms.MAIDEN, true),
    THRALL_ATTACKS_BLOAT("Bloat thrall attacks", types.OTHER_INT, rooms.BLOAT, true),
    THRALL_ATTACKS_NYLO("Nylo thrall attacks", types.OTHER_INT, rooms.NYLOCAS, true),
    THRALL_ATTACKS_SOTE("Sote thrall attacks", types.OTHER_INT, rooms.SOTETSEG, true),
    THRALL_ATTACKS_XARP("Xarp thrall attacks", types.OTHER_INT, rooms.XARPUS, true),
    THRALL_ATTACKS_VERZIK("Verzik thrall attacks", types.OTHER_INT, rooms.VERZIK, true),

    THRALL_DAMAGE_TOTAL("Total thrall damage", types.OTHER_INT, rooms.ANY, true),
    THRALL_DAMAGE_MAIDEN("Maiden thrall damage", types.OTHER_INT, rooms.MAIDEN, true),
    THRALL_DAMAGE_BLOAT("Bloat thrall damage", types.OTHER_INT, rooms.BLOAT, true),
    THRALL_DAMAGE_NYLO("Nylo thrall damage", types.OTHER_INT, rooms.NYLOCAS, true),
    THRALL_DAMAGE_SOTE("Sote thrall damage", types.OTHER_INT, rooms.SOTETSEG, true),
    THRALL_DAMAGE_XARP("Xarp thrall damage", types.OTHER_INT, rooms.XARPUS, true),
    THRALL_DAMAGE_VERZIK("Verzik thrall damage", types.OTHER_INT, rooms.VERZIK, true),

    VENG_DAMAGE_TOTAL("Total veng damage", types.OTHER_INT, rooms.ANY),
    VENG_DAMAGE_MAIDEN("Maiden veng damage", types.OTHER_INT, rooms.MAIDEN),
    VENG_DAMAGE_BLOAT("Bloat veng damage", types.OTHER_INT, rooms.BLOAT),
    VENG_DAMAGE_NYLO("Nylo veng damage", types.OTHER_INT, rooms.NYLOCAS),
    VENG_DAMAGE_SOTE("Sote veng damage", types.OTHER_INT, rooms.SOTETSEG),
    VENG_DAMAGE_XARP("Xarp veng damage", types.OTHER_INT, rooms.XARPUS),
    VENG_DAMAGE_VERZIK("Verzik veng damage", types.OTHER_INT, rooms.VERZIK),

    VENG_CASTS_TOTAL("Total veng casts", types.OTHER_INT, rooms.ANY),
    VENG_CASTS_MAIDEN("Maiden veng casts", types.OTHER_INT, rooms.MAIDEN),
    VENG_CASTS_BLOAT("Bloat veng casts", types.OTHER_INT, rooms.BLOAT),
    VENG_CASTS_NYLO("Nylo veng casts", types.OTHER_INT, rooms.NYLOCAS),
    VENG_CASTS_SOTE("Sote veng casts", types.OTHER_INT, rooms.SOTETSEG),
    VENG_CASTS_XARP("Xarp veng casts", types.OTHER_INT, rooms.XARPUS),
    VENG_CASTS_VERZIK("Verzik veng casts", types.OTHER_INT, rooms.VERZIK),

    VENG_PROCS_TOTAL("Total veng procs", types.OTHER_INT, rooms.ANY),
    VENG_PROCS_MAIDEN("Maiden veng procs", types.OTHER_INT, rooms.MAIDEN),
    VENG_PROCS_BLOAT("Bloat veng procs", types.OTHER_INT, rooms.BLOAT),
    VENG_PROCS_NYLO("Nylo veng procs", types.OTHER_INT, rooms.NYLOCAS),
    VENG_PROCS_SOTE("Sote veng procs", types.OTHER_INT, rooms.SOTETSEG),
    VENG_PROCS_XARP("Xarp veng procs", types.OTHER_INT, rooms.XARPUS),
    VENG_PROCS_VERZIK("Verzik veng procs", types.OTHER_INT, rooms.VERZIK),
    KODAI_BOPS("Kodai bops", types.OTHER_INT, rooms.ANY, true),
    DWH_BOPS("DWH bops", types.OTHER_INT, rooms.ANY, true),
    CHALLY_POKE("Chally pokes", types.OTHER_INT, rooms.ANY, true),
    BGS_WHACKS("BGS whacks", types.OTHER_INT, rooms.ANY, true),
    TOTAL_DEATHS("Total deaths", types.OTHER_INT, rooms.ANY, true),
    DEATHS("Alternate Deaths", types.OTHER_INT, rooms.ALL, true),
    UNKNOWN("Unknown", types.OTHER_BOOL, rooms.ANY);



    public static DataPoint getValue(String s)
    {
        for (DataPoint point : values())
        {
            if (point.name.equals(s))
            {
                return point;
            }
        }
        return DataPoint.UNKNOWN;
    }

    public enum rooms
    {
        ANY,
        MAIDEN,
        BLOAT,
        NYLOCAS,
        SOTETSEG,
        XARPUS,
        VERZIK,
        ALL
    }

    public enum types
    {
        OTHER_INT, OTHER_BOOL, TIME
    }

    public final String name;
    public final int value;
    public final types type;
    public final rooms room;
    public final boolean playerSpecific;


    DataPoint(String name, types type, rooms room)
    {
        this.name = name;
        this.value = 0;
        this.type = type;
        this.room = room;
        this.playerSpecific = false;
    }

    DataPoint(String name, types type, rooms room, int value)
    {
        this.name = name;
        this.value = value;
        this.type = type;
        this.room = room;
        this.playerSpecific = false;
    }

    DataPoint(String name, types type, rooms room, boolean playerSpecific)
    {
        this.playerSpecific = playerSpecific;
        this.name = name;
        this.value = 0;
        this.type = type;
        this.room = room;
    }

    public static String[] getPlayerSpecific()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.playerSpecific)
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getOtherIntNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.type.equals(types.OTHER_INT))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getByNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            valuesToGather.add(point.name);
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getTimeNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.type.equals(types.TIME))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] filterTimes(String[] data)
    {
        ArrayList<String> filtered = new ArrayList<>();
        for (String s : data)
        {
            if (Objects.requireNonNull(DataPoint.getValue(s)).type == types.TIME)
            {
                filtered.add(s);
            }
        }
        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);
    }

    public static String[] filterInt(String[] data)
    {
        ArrayList<String> filtered = new ArrayList<>();
        for (String s : data)
        {
            DataPoint dp = DataPoint.getValue(s);
            if (dp != null && dp.type == types.OTHER_INT && !dp.name.contains("thrall") && !dp.name.contains("veng")
                    && !dp.name.contains("BGS") && !dp.name.contains("hammers") && !dp.name.contains("dinhs"))
            {
                filtered.add(s);
            }
        }
        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);
    }

    public static String[] filterThrall(String[] data)
    {
        ArrayList<String> filtered = new ArrayList<>();
        for (String s : data)
        {
            if (Objects.requireNonNull(DataPoint.getValue(s)).name.contains("thrall"))
            {
                filtered.add(s);
            }
        }
        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);
    }

    public static String[] filterVeng(String[] data)
    {
        ArrayList<String> filtered = new ArrayList<>();
        for (String s : data)
        {
            if (Objects.requireNonNull(DataPoint.getValue(s)).name.contains("veng"))
            {
                filtered.add(s);
            }
        }
        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);
    }

    public static String[] filterSpecs(String[] data)
    {
        ArrayList<String> filtered = new ArrayList<>();
        for (String s : data)
        {
            String name = Objects.requireNonNull(DataPoint.getValue(s)).name;
            if (name.contains("BGS") || name.contains("hammers") || name.contains("dinhs"))
            {
                filtered.add(s);
            }
        }
        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);
    }


    public static String[] getMaidenNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(rooms.MAIDEN))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getBloatNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(rooms.BLOAT))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getNyloNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(rooms.NYLOCAS))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getSoteNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(rooms.SOTETSEG))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getXarpNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(rooms.XARPUS))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getVerzikNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(rooms.VERZIK))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getAnyRoomNames()
    {
        ArrayList<String> valuesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(rooms.ANY))
            {
                valuesToGather.add(point.name);
            }
        }
        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);
    }

    public static String[] getRoomTimes()
    {
        return new String[]{"Challenge Time", "Overall Time", "Time Outside Rooms", "Maiden Time", "Bloat Time", "Nylocas Time", "Sotetseg Time", "Xarpus Time", "Verzik Time"};
    }

    public static ArrayList<String> getTimeNamesByRoom(rooms room)
    {
        ArrayList<String> timesToGather = new ArrayList<>();
        for (DataPoint point : DataPoint.values())
        {
            if (point.room.equals(room) && point.type.equals(types.TIME))
            {
                timesToGather.add(point.name);
            }
        }
        return timesToGather;
    }
}

package com.advancedraidtracker.utility.datautility;

import com.advancedraidtracker.utility.wrappers.PlayerCorrelatedPointData;
import lombok.extern.slf4j.Slf4j;
@Slf4j
public class DataManager
{

    private final DataPointIntWrapper[] data;
    private final DataPointPlayerData[] playerSpecificData;


    public DataManager()
    {
        data = new DataPointIntWrapper[DataPoint.values().length];
        for (int i = 0; i < DataPoint.values().length; i++)
        {
            data[i] = new DataPointIntWrapper(DataPoint.values()[i]);
        }

        playerSpecificData = new DataPointPlayerData[DataPoint.getPlayerSpecific().length];
        for (int i = 0; i < DataPoint.getPlayerSpecific().length; i++)
        {
            playerSpecificData[i] = new DataPointPlayerData(DataPoint.getValue(DataPoint.getPlayerSpecific()[i]));
        }
    }

    public PlayerCorrelatedPointData getHighest(DataPoint point)
    {
        int highest = 0;
        String name = "";
        int index = getPlayerSpecificIndex(point);
        for (String player : playerSpecificData[index].specificPlayerData.keySet())
        {
            if (playerSpecificData[index].specificPlayerData.get(player) > highest)
            {
                highest = playerSpecificData[index].specificPlayerData.get(player);
                name = player;
            }
        }
        return new PlayerCorrelatedPointData(name, highest);
    }

    int getPlayerSpecificIndex(DataPoint point)
    {
        int index = 0;
        for (String datapoint : DataPoint.getPlayerSpecific())
        {
            if (datapoint.equalsIgnoreCase(point.name))
            {
                return index;
            }
            index++;
        }
        return index;
    }

    public void incrementPlayerSpecific(DataPoint dataPoint, String player)
    {
        playerSpecificData[getPlayerSpecificIndex(dataPoint)].increment(player);
    }

    public void incrementPlayerSpecific(DataPoint dataPoint, String player, int valueAdded)
    {
        playerSpecificData[getPlayerSpecificIndex(dataPoint)].increment(player, valueAdded);
    }

    public void set(DataPoint point, int value)
    {
        data[point.ordinal()].setValue(value);
    }

    public int get(DataPoint point)
    {
        if(point == null)
        {
            return -1;
        }
        return data[point.ordinal()].value;
    }

    public int get(String point)
    {
        DataPoint dataPoint = DataPoint.getValue(point);
        if (dataPoint != null)
        {
            return data[dataPoint.ordinal()].value;
        }
        return 0;
    }

    public void increment(DataPoint point, int valueAdded)
    {
        data[point.ordinal()].increment(valueAdded);
    }

    public void increment(DataPoint point)
    {
        data[point.ordinal()].increment();
    }

    public void hammer(DataPoint point)
    {
        data[point.ordinal()].setValue((int) (data[point.ordinal()].value * 0.7));
    }

    public void bgs(DataPoint point, int damage)
    {
        data[point.ordinal()].setValue(Math.max(0, data[point.ordinal()].value - damage));
    }
}

package com.advancedraidtracker.utility.datautility;

import java.util.LinkedHashMap;
import java.util.Map;

public class DataPointPlayerData
{
    public Map<String, Integer> specificPlayerData;
    public DataPoint datapoint;

    public DataPointPlayerData(DataPoint datapoint)
    {
        this.datapoint = datapoint;
        specificPlayerData = new LinkedHashMap<>();
    }

    public void increment(String player)
    {
        if (specificPlayerData.containsKey(player))
        {
            specificPlayerData.put(player, specificPlayerData.get(player) + 1);
        } else
        {
            specificPlayerData.put(player, 1);
        }
    }

    public void increment(String player, int valueAdded)
    {
        if (specificPlayerData.containsKey(player))
        {
            specificPlayerData.put(player, specificPlayerData.get(player) + valueAdded);
        } else
        {
            specificPlayerData.put(player, valueAdded);
        }
    }
}

package com.advancedraidtracker.utility.datautility;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.ui.RaidTrackerSidePanel;
import com.advancedraidtracker.utility.wrappers.RaidsArrayWrapper;
import lombok.extern.slf4j.Slf4j;


import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;

import static com.advancedraidtracker.utility.datautility.DataWriter.PLUGIN_DIRECTORY;
@Slf4j
public class RaidsManager
{
    private static final String raidsFolder = PLUGIN_DIRECTORY + "/misc-dir/raids/";

    public static ArrayList<RaidsArrayWrapper> getRaidsSets()
    {
        ArrayList<RaidsArrayWrapper> raidSets = new ArrayList<>();
        File folder = new File(raidsFolder);
        if (!folder.exists()) if(!folder.mkdirs()){log.info("Couldn't make misc dir");}
        try
        {
            for (File entry : Objects.requireNonNull(folder.listFiles()))
            {
                if (entry.isDirectory())
                {
                    ArrayList<SimpleTOBData> raids = new ArrayList<>();
                    for(File raid : Objects.requireNonNull(entry.listFiles()))
                    {
                        try
                        {
                            RaidTrackerSidePanel.parseLogFile(raids, raid, raid.getAbsolutePath());
                        } catch (Exception e)
                        {
                            log.info("Failed to parse log file " + raid.getAbsolutePath());
                        }
                    }
                    raidSets.add(new RaidsArrayWrapper(raids, entry.getName()));
                }
            }
        } catch (Exception e)
        {
            log.info("Failed parsing raid sets");
        }
        return raidSets;
    }

    public static boolean doesRaidExist(String name)
    {
        File folder = new File(raidsFolder);
        try
        {
            for (File entry : Objects.requireNonNull(folder.listFiles()))
            {
                if (entry.getName().equals(name + ".raids"))
                {
                    return true;
                }
            }
        } catch (Exception e)
        {
            log.info("Could not determine if raid exists");
        }
        return false;
    }

    public static void saveOverwriteRaids(String name, ArrayList<SimpleTOBData> raids)
    {
        try
        {
            File directory = new File(raidsFolder);
            if (!directory.exists())
            {
                if(!directory.mkdirs()) {log.info("Could not make overwrite dir");}
            }
            File raidsFile = new File(raidsFolder + name+"/");

            if (raidsFile.exists())
            {
                if(!raidsFile.delete())
                {
                    log.info("Could not delete file during overwrite");
                }
            }
            if(!raidsFile.mkdirs())
            {
                log.info("Could not make directories during overwrite");
            }
            writeRaid(name, raids);
        } catch (Exception e)
        {
            log.info("Could not write overwrite raid");
        }
    }

    private static void writeRaid(String name, ArrayList<SimpleTOBData> raids) throws IOException
    {
        for (SimpleTOBData raid : raids)
        {
            File newEntry = new File(raidsFolder + name + "/" + raid.fileName);
            Files.createFile(newEntry.toPath());
            BufferedWriter fileWriter = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(newEntry.toPath())));
            File file = new File(raid.filePath);
            Scanner logReader = new Scanner(Files.newInputStream(file.toPath()));
            while (logReader.hasNextLine())
            {
                fileWriter.write(logReader.nextLine());
                fileWriter.newLine();
            }
            fileWriter.close();
        }
    }

    public static void saveRaids(String name, ArrayList<SimpleTOBData> raids)
    {
        try
        {
            File directory = new File(raidsFolder);
            if (!directory.exists())
            {
                if(!directory.mkdirs())
                {
                    log.info("Could not make directory to save raid");
                }
            }
            File raidsFile = new File(raidsFolder + name+"/");
            if (!raidsFile.exists())
            {
                if(!raidsFile.mkdirs())
                {
                    log.info("Could not make directory for specific folder for raid");
                }
            }
            writeRaid(name, raids);
        } catch (Exception e)
        {
            log.info("Could not write save file");
        }
    }
}

package com.advancedraidtracker.utility.datautility;

import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;

import static com.advancedraidtracker.constants.TobIDs.EXIT_FLAG;
import static com.advancedraidtracker.utility.datautility.DataWriter.*;

@Slf4j
public class LegacyFileUtility //Older versions of the plugin during testing used a different file structure, this class contains methods used to migrate those
{
    public static void splitLegacyFiles()
    {
        try
        {
            String path = System.getProperty("user.home").replace("\\", "/") + "/.runelite/theatretracker/primary/"; //old directory
            File logDirectory = new File(path);
            if (!logDirectory.exists())
            {
                return;
            }
            ArrayList<String> currentRaid = new ArrayList<>();
            for (File file : Objects.requireNonNull(logDirectory.listFiles()))
            {
                if (file.getName().contains("tobdata") && !file.getName().contains("archive"))
                {
                    Scanner logReader = new Scanner(Files.newInputStream(file.toPath()));
                    while (logReader.hasNextLine())
                    {
                        String line = logReader.nextLine();
                        String[] lineSplit = line.split(",");
                        currentRaid.add(line);
                        if (Objects.equals(lineSplit[3], EXIT_FLAG))
                        {
                            int highestLog = getHighestLogNumber("legacy-files");
                            writeFile(currentRaid, PLUGIN_DIRECTORY + "legacy-files/primary/" + "tobdata" + (highestLog + 1) + ".log");
                            currentRaid.clear();
                        }
                    }
                    if (!file.renameTo(new File(file.getAbsolutePath().substring(0, file.getAbsolutePath().length()-4)+"-archive.log")))
                    {
                        log.info("failed to rename old file");
                    }
                }
            }
            path = System.getProperty("user.home").replace("\\", "/") + "/.runelite/theatretracker/";
            File oldDirectory = new File(path);
            if(oldDirectory.exists())
            {
                for(File folder : Objects.requireNonNull(oldDirectory.listFiles()))
                {
                    if(folder.isDirectory() && !folder.getName().equals("primary"))
                    {
                        try
                        {
                            File newSubDirectory = new File(PLUGIN_DIRECTORY + "misc-dir/");
                            if(!newSubDirectory.exists())
                            {
                                if(!newSubDirectory.mkdirs())
                                {
                                    log.info("Failed to create folder: " + newSubDirectory.getAbsolutePath());
                                }
                            }
                            Files.move(folder.toPath(), (new File(PLUGIN_DIRECTORY + "misc-dir/" + folder.getName()).toPath()));
                        }
                        catch(Exception e)
                        {
                            log.info("Failed to move folder " + folder.getAbsolutePath());
                        }
                    }
                }
            }
        } catch (IOException e)
        {
            log.info("Failed splitting legacy file");
        }
    }
}

package com.advancedraidtracker.utility.datautility;

import com.advancedraidtracker.AdvancedRaidTrackerConfig;
import lombok.extern.slf4j.Slf4j;
import com.advancedraidtracker.constants.LogID;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Objects;

@Slf4j
public class DataWriter
{
    private final AdvancedRaidTrackerConfig config;
    private String activeUsername = "";
    private final ArrayList<String> currentBuffer;

    public final static String PLUGIN_DIRECTORY = System.getProperty("user.home").replace("\\", "/") + "/.runelite/advancedraidtracker/";

    public DataWriter(AdvancedRaidTrackerConfig config) throws IOException
    {
        this.config = config;
        currentBuffer = new ArrayList<>();
    }

    public void setName(String name) throws IOException
    {
        activeUsername = name;
        File dirMain = new File(PLUGIN_DIRECTORY + name + "/primary/");
        File dirFilters = new File(PLUGIN_DIRECTORY + "misc-dir/filters/");
        File dirRaids = new File(PLUGIN_DIRECTORY + "misc-dir/raids/");

        if (!dirRaids.exists())
        {
            if (!dirRaids.mkdirs())
            {
                log.info("Failed to create raids directory for username " + name);
            }
        }
        if (!dirMain.exists())
        {
            if (!dirMain.mkdirs())
            {
                log.info("Failed to create main directory for username " + name);
            }
        }
        if (!dirFilters.exists())
        {
            if (!dirFilters.mkdirs())
            {
                log.info("Failed to create filter directory for username " + name);
            }
        }

        File logFile = new File(PLUGIN_DIRECTORY + name + "/primary/tobdata.log");
        if (!logFile.exists())
        {
            if (!logFile.createNewFile())
            {
                log.info("Failed to create log file");
            }
        }
    }

    //If you X out client in the middle of a raid it does not record the flag that the raid ended, so this is called when you enter a tob to see
    //if an active datafile and if so it adds an exit flag to the end
    public void checkForEndFlag()
    {
        File logFile = new File(PLUGIN_DIRECTORY + activeUsername + "/primary/tobdata.log");
        if (logFile.exists())
        {
            if (logFile.length() > 0)
            {
                currentBuffer.add("," + System.currentTimeMillis() + ",1," + 4 + "," + "," + "," + "," + ",");
                writeFile();
            }
        }
    }

    public void migrateToNewRaid()
    {
        int highest = getHighestLogNumber(activeUsername);
        File logFile = new File(PLUGIN_DIRECTORY + activeUsername + "/primary/tobdata.log");
        if (!logFile.exists())
        {
            log.info("Could not migrate because file does not exist");
            return;
        }
        if (logFile.length() == 0)
        {
            return;
        } //Inject number to log file before the '.log' e.g. tobdata.log -> tobdata<number>.log
        if (!logFile.renameTo(new File(logFile.getAbsolutePath().substring(0, logFile.getAbsolutePath().length() - 4) + (highest + 1) + ".log")))
        {
            log.info("Could not rename primary log file");
        } else
        {
            logFile = new File(PLUGIN_DIRECTORY + activeUsername + "/primary/tobdata.log");
            if (!logFile.exists())
            {
                try
                {
                    if (!logFile.createNewFile())
                    {
                        log.info("Replacement file creation unsuccessful");
                    }
                } catch (Exception e)
                {
                    log.info("Exception thrown when creating replacement log file: " + logFile.getAbsolutePath());
                }
            }
        }
    }

    public static int getHighestLogNumber(String name)
    {
        String directory = PLUGIN_DIRECTORY;
        if (!name.isEmpty())
        {
            directory += name + "/primary/";
        } else
        {
            directory += "primary/";
        }
        File logDirectory = new File(directory);
        if(!logDirectory.exists())
        {
            if(!logDirectory.mkdirs())
            {
                log.info("Could not make directory to find log number");
            }
        }
        int highestLogNumber = 0;
        for (File file : Objects.requireNonNull(new File(directory).listFiles()))
        {
            if (file.getName().contains("tobdata"))
            {
                int index = file.getName().indexOf(".log");
                if (index != -1)
                {
                    try
                    {
                        int logNumber = Integer.parseInt(file.getName().substring(7, index));
                        if (logNumber > highestLogNumber)
                        {
                            highestLogNumber = logNumber;
                        }
                    } catch
                    (Exception ignored)
                    {
                    }
                }
            }
        }
        return highestLogNumber;
    }

    /**
     * Writes a message to the log with the time, message ID, and up to 5 additional parameters
     *
     * @param id LogID of message
     */
    public void addLine(LogID id, String... params)
    {
        if (params.length > 5)
            throw new IllegalArgumentException("Too many values passed to DataWriter");
        String[] values = {"", "", "", "", ""};
        System.arraycopy(params, 0, values, 0, params.length);
        addLine(id.getId(), values[0], values[1], values[2], values[3], values[4]);
    }

    public void addLine(int key, String v1, String v2, String v3, String v4, String v5)
    {
        int versionID = 1;
        currentBuffer.add(getUID() + "," + System.currentTimeMillis() + "," + versionID + "," + key + "," + v1 + "," + v2 + "," + v3 + "," + v4 + "," + v5);
    }

    public static void writeAliasFile(String aliasText)
    {
        try
        {
            File aliasFile = new File(PLUGIN_DIRECTORY + "alias/alias.log");
            if (!aliasFile.exists())
            {
                File directory = new File(PLUGIN_DIRECTORY + "alias/");
                if (!directory.exists())
                {
                    if (!directory.mkdirs())
                    {
                        log.info("Failed to create alias directory");
                    }
                }
                if (!aliasFile.createNewFile())
                {
                    log.info("Failed to create alias file");
                }
            }
            BufferedWriter logger = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(PLUGIN_DIRECTORY + "alias/alias.log", false), StandardCharsets.UTF_8));
            logger.write(aliasText);
            logger.close();
        } catch (IOException e)
        {
            log.info("Failed writing to alias file");
        }
    }

    public static ArrayList<String> readAliasFile()
    {
        ArrayList<String> lines = new ArrayList<>();
        BufferedReader reader;
        try
        {
            reader = new BufferedReader(new FileReader(PLUGIN_DIRECTORY + "alias/alias.log"));
            String line = reader.readLine();
            while (line != null)
            {
                lines.add(line);
                line = reader.readLine();
            }
        } catch (Exception e)
        {
            return lines;
        }
        return lines;
    }

    public void writeFile()
    {
        if (config.writeToLog())
        {
            try
            {
                File logFile = new File(PLUGIN_DIRECTORY + activeUsername + "/primary/tobdata.log");
                if (!logFile.exists())
                {
                    if (!logFile.createNewFile())
                    {
                        log.info("Failed to create log file");
                    }
                }
                BufferedWriter logger = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(PLUGIN_DIRECTORY + activeUsername + "/primary/tobdata.log", true), StandardCharsets.UTF_8));
                for (String msg : currentBuffer)
                {
                    logger.write(msg);
                    logger.newLine();
                }
                logger.close();
            } catch (IOException e)
            {
                log.info("Failed clearing buffered tob data to log");
            }
        }
        currentBuffer.clear();
    }

    public static void writeFile(ArrayList<String> raid, String filePath)
    {
        try
        {
            File logFile = new File(filePath);
            if (!logFile.exists())
            {
                if (!logFile.createNewFile())
                {
                    log.info("Failed to create log file");
                }
            }
            BufferedWriter logger = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath, true), StandardCharsets.UTF_8));
            for (String msg : raid)
            {
                logger.write(msg);
                logger.newLine();
            }
            logger.close();
        } catch (IOException e)
        {
            log.info("Failed clearing buffered tob data to log");
        }
    }


    private String getUID()
    {
        return "";
    } //deprecated
}

package com.advancedraidtracker.utility.nyloutility;

import lombok.Getter;

import java.util.Arrays;
import java.util.List;

public class NylocasWave
{
    @Getter
    private final int wave;
    @Getter
    private final int delay;
    private final NylocasData[] nylos;

    public static NylocasWave[] waves =
            {
                    new NylocasWave(1, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MELEE_SMALL, false)
                            }),
                    new NylocasWave(2, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_SMALL, true)
                            }),
                    new NylocasWave(3, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false)
                            }),
                    new NylocasWave(4, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false)
                            }),
                    new NylocasWave(5, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_SMALL, false)
                            }),
                    new NylocasWave(6, 16,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_BIG, false)
                            }),
                    new NylocasWave(7, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MELEE_SMALL, false)
                            }),
                    new NylocasWave(8, 12,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_SMALL, false)
                            }),
                    new NylocasWave(9, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false)
                            }),
                    new NylocasWave(10, 16,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.RANGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, true)
                            }),
                    new NylocasWave(11, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),
                            }),
                    new NylocasWave(12, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MELEE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_BIG, false),
                            }),
                    new NylocasWave(13, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_BIG, true),
                            }),
                    new NylocasWave(14, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.RANGE_BIG, true),
                            }),
                    new NylocasWave(15, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_BIG, false),
                            }),
                    new NylocasWave(16, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_MAGE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),
                            }),
                    new NylocasWave(17, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                            }),
                    new NylocasWave(18, 12,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_MAGE_RANGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.RANGE_MAGE_RANGE_BIG, false),
                            }),
                    new NylocasWave(19, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                            }),
                    new NylocasWave(20, 12,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_RANGE_MELEE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_RANGE_MELEE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_MAGE_RANGE_BIG, false),
                            }),
                    new NylocasWave(21, 16,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_RANGE_MELEE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_MAGE_MELEE_SMALL, false),
                            }),
                    new NylocasWave(22, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_MAGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_RANGE_MELEE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_RANGE_MELEE_BIG, true),
                            }),
                    new NylocasWave(23, 12,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_MAGE_MELEE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_RANGE_MELEE_BIG, false),
                            }),
                    new NylocasWave(24, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_MELEE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_BIG, true),
                            }),
                    new NylocasWave(25, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                            }),
                    new NylocasWave(26, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_MAGE_MELEE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_BIG, false),
                            }),
                    new NylocasWave(27, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_MAGE_RANGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),
                            }),
                    new NylocasWave(28, 8,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_MELEE_MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_RANGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_MAGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_MAGE_MELEE_SMALL, false),
                            }),
                    new NylocasWave(29, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_MAGE_SMALL, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_BIG, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_RANGE_MAGE_SMALL, true),
                            }),
                    new NylocasWave(30, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_RANGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_BIG, false),
                            }),

                    new NylocasWave(31, 4,
                            new NylocasData[]{
                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MAGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_MAGE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_SMALL, false),
                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_RANGE_MAGE_SMALL, false),
                            }),
            };

    public NylocasWave(int wave, int delay, NylocasData[] nylos)
    {
        this.wave = wave;
        this.delay = delay;
        this.nylos = nylos;
    }

    public int count()
    {
        return this.nylos.length;
    }

    public List<NylocasData> getNylos()
    {
        return Arrays.asList(nylos);
    }
}

package com.advancedraidtracker.utility.nyloutility;

import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.stream.Collectors;

@Slf4j
public class NylocasWaveMatcher
{
    private static boolean wave17Matched = false;
    private static boolean wave26Matched = false;
    private static boolean wave28Matched = false;
    private static NylocasWave lastWave = null;

    public static boolean isWave(ArrayList<NylocasShell> nylos)
    {
        ArrayList<NylocasWave> potentialWaves = (ArrayList<NylocasWave>) Arrays.stream(NylocasWave.waves).filter(c -> c.count() == nylos.size()).collect(Collectors.toList());
        if (!potentialWaves.isEmpty())
        {
            for (NylocasWave w : potentialWaves)
            {
                boolean waveFlag = true;
                for (NylocasData c : w.getNylos())
                {
                    if (waveFlag && !containsNylo(c, nylos))
                    {
                        waveFlag = false;
                    }
                }
                if (waveFlag) //waves 17, 26, and 28 are comprised of the exact same spawns
                {
                    if (wave17Matched && w.getWave() == 17)
                    {
                        waveFlag = false;
                    } else if (wave26Matched && w.getWave() == 26)
                    {
                        waveFlag = false;

                    } else if (wave28Matched && w.getWave() == 28)
                    {
                        waveFlag = false;
                    } else if (w.getWave() == 17)
                    {
                        wave17Matched = true;
                        wave26Matched = false;
                        wave28Matched = false;
                    } else if (w.getWave() == 26)
                    {
                        wave26Matched = true;
                        wave28Matched = false;
                    } else if (w.getWave() == 28)
                    {
                        wave28Matched = true;
                    } else if (w.getWave() < 17)
                    {
                        wave17Matched = false;
                        wave26Matched = false;
                        wave28Matched = false;
                    } else if (w.getWave() < 26)
                    {
                        wave26Matched = false;
                        wave28Matched = false;
                    } else if (w.getWave() == 27)
                    {
                        wave28Matched = false;
                    }
                }
                if (waveFlag)
                {
                    lastWave = w;
                    return true;
                }
            }
        }
        return false;
    }

    public static NylocasWave getWave()
    {
        return lastWave;
    }

    public static boolean containsNylo(NylocasData c, ArrayList<NylocasShell> ns)
    {
        boolean flag = false;
        for (NylocasShell n : ns)
        {
            if (matchesNylo(c, n))
            {
                flag = true;
            }
        }
        return flag;
    }

    public static boolean matchesNylo(NylocasData c1, NylocasShell c2)
    {
        return (c1.getSpawnStyle() == c2.style && c1.position == c2.position);
    }

}

package com.advancedraidtracker.utility.nyloutility;

public class NylocasData
{
    public enum NylocasType
    {
        MELEE_BIG,
        MELEE_SMALL,
        RANGE_BIG,
        RANGE_SMALL,
        MAGE_BIG,
        MAGE_SMALL,
        MAGE_MELEE_RANGE_SMALL,
        MELEE_MAGE_RANGE_SMALL,
        RAMGE_MAGE_RANGE_SMALL,
        MAGE_MELEE_MAGE_BIG,
        RANGE_MAGE_RANGE_BIG,
        MELEE_RANGE_MELEE_BIG,
        MAGE_RANGE_MELEE_BIG,
        RANGE_MELEE_RANGE_SMALL,
        MELEE_MAGE_MELEE_SMALL,
        MELEE_RANGE_MELEE_SMALL,
        MAGE_RANGE_MAGE_SMALL,
        RANGE_MAGE_MELEE_SMALL,
        MAGE_RANGE_MELEE_SMALL,
        RANGE_MAGE_MELEE_BIG,
        RANGE_MAGE_RANGE_SMALL,
        MELEE_MAGE_MELEE_BIG,
        MELEE_MAGE_RANGE_BIG,
        MAGE_MELEE_MAGE_SMALL,
        RANGE_MELEE_MAGE_SMALL,
        MELEE_RANGE_MAGE_SMALL,
        RANGE_MELEE_RANGE_BIG,
    }

    public enum NyloPosition
    {
        EAST_NORTH,
        EAST_SOUTH,
        SOUTH_EAST,
        SOUTH_WEST,
        WEST_SOUTH,
        WEST_NORTH,
        EAST_BIG,
        SOUTH_BIG,
        WEST_BIG,
        ROOM
    }

    public NylocasData(NyloPosition position, NylocasType type, boolean aggro)
    {
        this.position = position;
        this.type = type;
        this.aggro = aggro;
    }

    public int getSpawnStyle()
    {
        switch (type)
        {
            case MELEE_SMALL:
            case MELEE_MAGE_RANGE_SMALL:
            case MELEE_MAGE_MELEE_SMALL:
            case MELEE_RANGE_MELEE_SMALL:
            case MELEE_RANGE_MAGE_SMALL:
                return 0;
            case MELEE_MAGE_MELEE_BIG:
            case MELEE_MAGE_RANGE_BIG:
            case MELEE_RANGE_MELEE_BIG:
            case MELEE_BIG:
                return 3;
            case MAGE_BIG:
            case MAGE_RANGE_MELEE_BIG:
            case MAGE_MELEE_MAGE_BIG:
                return 5;
            case MAGE_SMALL:
            case MAGE_MELEE_MAGE_SMALL:
            case MAGE_MELEE_RANGE_SMALL:
            case MAGE_RANGE_MAGE_SMALL:
            case MAGE_RANGE_MELEE_SMALL:
                return 2;
            case RANGE_MAGE_MELEE_BIG:
            case RANGE_BIG:
            case RANGE_MAGE_RANGE_BIG:
            case RANGE_MELEE_RANGE_BIG:
                return 4;
            case RANGE_MELEE_RANGE_SMALL:
            case RANGE_MELEE_MAGE_SMALL:
            case RANGE_MAGE_RANGE_SMALL:
            case RANGE_MAGE_MELEE_SMALL:
            case RANGE_SMALL:
                return 1;
        }
        return -1;
    }

    public NyloPosition position;
    public NylocasType type;
    public boolean aggro;
}

package com.advancedraidtracker.utility.nyloutility;

import static com.advancedraidtracker.constants.TobIDs.*;
import static com.advancedraidtracker.constants.TobIDs.NYLO_MELEE_SMALL_AGRO_SM;

public class NylocasShell
{
    public int style;
    public NylocasData.NyloPosition position;

    public boolean isBig()
    {
        return (style > 2);
    }

    public static String getTypeName(int id)
    {
        switch (id)
        {
            case NYLO_MELEE_SMALL:
            case NYLO_MELEE_SMALL_AGRO:
            case NYLO_MELEE_SMALL_HM:
            case NYLO_MELEE_SMALL_AGRO_HM:
            case NYLO_MELEE_SMALL_SM:
            case NYLO_MELEE_SMALL_AGRO_SM:
                return "melee";
            case NYLO_RANGE_SMALL:
            case NYLO_RANGE_SMALL_AGRO:
            case NYLO_RANGE_SMALL_HM:
            case NYLO_RANGE_SMALL_AGRO_HM:
            case NYLO_RANGE_SMALL_SM:
            case NYLO_RANGE_SMALL_AGRO_SM:
                return "range";
            case NYLO_MAGE_SMALL:
            case NYLO_MAGE_SMALL_AGRO:
            case NYLO_MAGE_SMALL_HM:
            case NYLO_MAGE_SMALL_AGRO_HM:
            case NYLO_MAGE_SMALL_SM:
            case NYLO_MAGE_SMALL_AGRO_SM:
                return "mage";

        }
        return "";
    }

    public String getDescription()
    {
        String type = "";
        switch (style)
        {
            case 0:
            case 3:
                type = "melee";
                break;
            case 1:
            case 4:
                type = "range";
                break;
            case 2:
            case 5:
                type = "mage";
                break;
        }
        if (style > 2)
        {
            switch (position) //spawn position for bigs is shared with littles on south/west, but southwest tile of east big is in unique spot
            {
                case EAST_BIG:
                    return "east big " + type;
                case SOUTH_WEST:
                    return "south big " + type;
                case WEST_SOUTH:
                    return "west big " + type;
            }
        }
        switch (position)
        {
            case EAST_NORTH:
                return "east small " + type + " (N)";
            case EAST_SOUTH:
                return "east small " + type + " (S)";
            case SOUTH_EAST:
                return "south small " + type + " (E)";
            case SOUTH_WEST:
                return "south small " + type + " (W)";
            case WEST_NORTH:
                return "west small " + type + " (N)";
            case WEST_SOUTH:
                return "west small " + type + " (S)";
        }
        return "";
    }

    public NylocasShell(int id, int x, int y)
    {
        switch (id)
        {
            case NYLO_MELEE_SMALL_HM:
            case NYLO_MELEE_SMALL_SM:
            case NYLO_MELEE_SMALL:
            case NYLO_MELEE_SMALL_AGRO_HM:
            case NYLO_MELEE_SMALL_AGRO_SM:
                style = 0;
                break;
            case NYLO_RANGE_SMALL_HM:
            case NYLO_RANGE_SMALL_SM:
            case NYLO_RANGE_SMALL:
            case NYLO_RANGE_SMALL_AGRO_HM:
            case NYLO_RANGE_SMALL_AGRO_SM:
            case NYLO_RANGE_SMALL_AGRO:
                style = 1;
                break;
            case NYLO_MAGE_SMALL_HM:
            case NYLO_MAGE_SMALL_SM:
            case NYLO_MAGE_SMALL:
            case NYLO_MAGE_SMALL_AGRO_HM:
            case NYLO_MAGE_SMALL_AGRO_SM:
            case NYLO_MAGE_SMALL_AGRO:
                style = 2;
                break;
            case NYLO_MELEE_BIG:
            case NYLO_MELEE_BIG_HM:
            case NYLO_MELEE_BIG_SM:
            case NYLO_MELEE_BIG_AGRO:
            case NYLO_MELEE_BIG_AGRO_HM:
            case NYLO_MELEE_BIG_AGRO_SM:
                style = 3;
                break;
            case NYLO_RANGE_BIG_HM:
            case NYLO_RANGE_BIG_SM:
            case NYLO_RANGE_BIG:
            case NYLO_RANGE_BIG_AGRO_HM:
            case NYLO_RANGE_BIG_AGRO_SM:
            case NYLO_RANGE_BIG_AGRO:
                style = 4;
                break;
            case NYLO_MAGE_BIG:
            case NYLO_MAGE_BIG_HM:
            case NYLO_MAGE_BIG_SM:
            case NYLO_MAGE_BIG_AGRO:
            case NYLO_MAGE_BIG_AGRO_HM:
            case NYLO_MAGE_BIG_AGRO_SM:
                style = 5;
                break;
        }
        if (x == 9 && y == 25)
        {
            position = NylocasData.NyloPosition.WEST_NORTH;
        } else if (x == 9 && y == 24)
        {
            position = NylocasData.NyloPosition.WEST_SOUTH;
        } else if (x == 23 && y == 9)
        {
            position = NylocasData.NyloPosition.SOUTH_WEST;
        } else if (x == 24 && y == 9)
        {
            position = NylocasData.NyloPosition.SOUTH_EAST;
        } else if (x == 38 && y == 24)
        {
            position = NylocasData.NyloPosition.EAST_SOUTH;
        } else if (x == 38 && y == 25)
        {
            position = NylocasData.NyloPosition.EAST_NORTH;
        } else if (x == 37 && y == 24)
        {
            position = NylocasData.NyloPosition.EAST_BIG;
        } else
        {
            position = NylocasData.NyloPosition.ROOM;
        }
    }
}

package com.advancedraidtracker.utility;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.utility.datautility.DataPoint;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Slf4j
public class StatisticGatherer
{
    public static double getOverallTimeAverage(ArrayList<SimpleTOBData> data)
    {
        data = data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));
        if (data.isEmpty())
        {
            return -1;
        }
        double total = 0;
        double count = 0;
        for (SimpleTOBData d : data)
        {
            total += d.getTimeSum();
            count++;
        }
        return total / count;
    }

    public static double getOverallMedian(ArrayList<SimpleTOBData> data)
    {
        data = data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));
        if (data.isEmpty())
        {
            return -1;
        }
        double median;
        List<Double> values = new ArrayList<>();
        for (SimpleTOBData d : data)
        {
            values.add((double) d.getTimeSum());
        }
        Collections.sort(values);
        if (values.size() % 2 == 0)
        {
            median = ((double) values.get(values.size() / 2) + values.get(values.size() / 2 - 1)) / 2.0;
        } else
        {
            median = values.get(values.size() / 2);
        }
        return median;
    }

    public static double getOverallTimeMin(ArrayList<SimpleTOBData> data)
    {
        data = data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));
        int minValue = Integer.MAX_VALUE;
        for (SimpleTOBData d : data)
        {
            int split = d.getTimeSum();
            if (split < minValue)
            {
                minValue = split;
            }
        }
        return minValue;
    }

    public static double getOverallMax(ArrayList<SimpleTOBData> data)
    {
        data = data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));
        int maxValue = 0;
        for (SimpleTOBData d : data)
        {
            int split = d.getTimeSum();
            if (split > maxValue)
            {
                maxValue = split;
            }
        }
        return maxValue;
    }

    public static double getGenericAverage(ArrayList<Integer> data)
    {
        double total = 0;
        double count = 0;
        for (int d : data)
        {
            if (d != -1)
            {
                total += d;
                count++;
            }
        }
        return total / count;
    }

    public static double getGenericAverage(ArrayList<SimpleTOBData> data, DataPoint parameter)
    {
        if(parameter == DataPoint.CHALLENGE_TIME)
        {
            return getOverallTimeAverage(data);
        }
        double total = 0;
        double count = 0;
        for (SimpleTOBData room : data)
        {
            if (!room.getTimeAccurate(parameter))
            {
                continue;
            }
            int d = room.getValue(parameter);
            if (d != -1)
            {
                if (parameter.type != DataPoint.types.TIME || d != 0)
                {
                    total += d;
                    count++;
                }
            }
        }
        return total / count;
    }

    public static double getGenericMedian(ArrayList<Integer> data)
    {
        if (data.isEmpty())
        {
            return -1;
        }
        List<Double> values = new ArrayList<>();
        for (int d : data)
        {
            if (d != -1)
                values.add((double) d);
        }
        Collections.sort(values);
        return getMedian(values);
    }

    private static double getMedian(List<Double> values)
    {
        double median;
        if (values.size() % 2 == 0)
        {
            median = (values.get(values.size() / 2) + (double) values.get(values.size() / 2 - 1)) / 2.0;
        } else
        {
            median = values.get(values.size() / 2);
        }
        return median;
    }

    public static double getGenericMedian(ArrayList<SimpleTOBData> data, DataPoint param)
    {
        if(param == DataPoint.OVERALL_TIME)
        {
            return getOverallMedian(data);
        }
        if (data.isEmpty())
        {
            return -1;
        }
        List<Double> values = new ArrayList<>();
        for (SimpleTOBData room : data)
        {
            if (!room.getTimeAccurate(param))
            {
                continue;
            }
            int d = room.getValue(param);
            if (d != -1)
                values.add((double) d);
        }
        Collections.sort(values);
        if (!values.isEmpty())
        {
            return getMedian(values);
        }
        return -1;
    }

    public static double getGenericMin(ArrayList<Integer> data, boolean isTime)
    {
        int minValue = Integer.MAX_VALUE;
        for (int d : data)
        {
            if (d < minValue && d != -1 && (!isTime || d != 0))
            {
                minValue = d;
            }
        }
        return minValue;
    }

    public static double getGenericMin(ArrayList<Integer> data)
    {
        return getGenericMin(data, false);
    }

    public static double getGenericMin(ArrayList<SimpleTOBData> data, DataPoint parameter)
    {
        if(parameter == DataPoint.OVERALL_TIME)
        {
            return getOverallTimeMin(data);
        }
        int minValue = Integer.MAX_VALUE;
        for (SimpleTOBData room : data)
        {
            if (!room.getTimeAccurate(parameter))
            {
                continue;
            }
            int d = room.getValue(parameter);
            if (d < minValue && d != -1)
            {
                if (parameter.type != DataPoint.types.TIME || room.getValue(parameter) != 0)
                {
                    minValue = d;
                }
            }
        }
        return minValue;
    }


    public static double getGenericMax(ArrayList<Integer> data)
    {
        int maxValue = 0;
        for (int d : data)
        {
            if (d > maxValue)
            {
                maxValue = d;
            }
        }
        return maxValue;
    }

    public static double getGenericMax(ArrayList<SimpleTOBData> data, DataPoint parameter)
    {
        if(parameter == DataPoint.OVERALL_TIME)
        {
            return getOverallMax(data);
        }
        int maxValue = 0;
        for (SimpleTOBData room : data)
        {
            if (!room.getTimeAccurate(parameter))
            {
                continue;
            }
            int d = room.getValue(parameter);
            if (d > maxValue)
            {
                maxValue = d;
            }
        }
        return maxValue;
    }

    public static double getGenericMode(ArrayList<SimpleTOBData> data, DataPoint parameter)
    {
        int maxCount = 0;
        int maxValue = 0;
        for (int i = 0; i < data.size(); i++)
        {
            if (!data.get(i).getTimeAccurate(parameter))
            {
                continue;
            }
            int iv = data.get(i).getValue(parameter);
            int count = 0;
            for (SimpleTOBData datum : data)
            {
                if (!datum.getTimeAccurate(parameter))
                {
                    continue;
                }
                int jv = datum.getValue(parameter);
                if (jv != -1 && iv != -1)
                {
                    if (Objects.equals(datum, data.get(i)))
                    {
                        count++;
                    }
                }
            }
            if (count > maxCount)
            {
                maxValue = iv;
                maxCount = count;
            }
        }
        if (maxCount > 1)
        {
            return maxValue;
        } else
        {
            return -1;
        }
    }

    public static double getGenericMode(ArrayList<Integer> data)
    {
        int maxCount = 0;
        int maxValue = 0;
        for (int i = 0; i < data.size(); i++)
        {
            int count = 0;
            for (Integer datum : data)
            {
                if (datum != -1 && data.get(i) != -1)
                {
                    if (Objects.equals(datum, data.get(i)))
                    {
                        count++;
                    }
                }
            }
            if (count > maxCount)
            {
                maxValue = data.get(i);
                maxCount = count;
            }
        }
        if (maxCount > 1)
        {
            return maxValue;
        } else
        {
            return -1;
        }
    }


    public static double getGenericPercent(ArrayList<Integer> arrayForStatistics, int threshold)
    {
        double count = 0;
        double total = arrayForStatistics.size();
        for (Integer i : arrayForStatistics)
        {
            if (i <= threshold)
            {
                count++;
            }
        }
        double percent = count / total;
        int percentRounded = (int) (percent * 1000);
        percentRounded /= 10;
        return percentRounded;
    }
}

package com.advancedraidtracker.utility.maidenbloodtracking;

public class BloodDamageToBeApplied
{
    public String playerName;
    public int bloodTicksAlive;

    public BloodDamageToBeApplied(String playerName, int bloodTicksAlive)
    {
        this.playerName = playerName;
        this.bloodTicksAlive = bloodTicksAlive;
    }
}

package com.advancedraidtracker.utility.maidenbloodtracking;

import net.runelite.api.coords.WorldPoint;

public class BloodPositionWrapper
{
    public int finalTick;
    public int initialTick;
    public WorldPoint location;

    public BloodPositionWrapper(WorldPoint location, int initialTick)
    {
        this.initialTick = initialTick;
        this.location = location;
        this.finalTick = initialTick + 10;
    }
}

package com.advancedraidtracker.utility;

public class RoomState
{
    public enum MaidenRoomState
    {
        NOT_STARTED,
        PHASE_1,
        PHASE_2,
        PHASE_3,
        PHASE_4,
        FINISHED
    }

    public enum BloatRoomState
    {
        NOT_STARTED,
        WALKING,
        DOWN,
        FINISHED
    }

    public enum NyloRoomState
    {
        NOT_STARTED,
        WAVES,
        CLEANUP,
        WAITING_FOR_BOSS,
        BOSS,
        FINISHED
    }

    public enum SotetsegRoomState
    {
        NOT_STARTED,
        PHASE_1,
        MAZE_1,
        PHASE_2,
        MAZE_2,
        PHASE_3,
        FINISHED
    }

    public enum XarpusRoomState
    {
        NOT_STARTED,
        EXHUMEDS,
        PRESCREECH,
        POSTSCREECH,
        FINISHED
    }

    public enum VerzikRoomState
    {
        NOT_STARTED,
        PHASE_1,
        PHASE_2,
        PHASE_2_REDS,
        PHASE_3,
        FINISHED
    }
}

package com.advancedraidtracker.utility;

import com.advancedraidtracker.constants.TobIDs;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.StringUtils;

import java.util.Arrays;


public class RoomUtil
{
    public final static String[] MAIDEN_CRAB_NAMES = {
            "N1 70s", "N2 70s", "N3 70s", "N4 (1) 70s", "N4 (2) 70s",
            "S1 70s", "S2 70s", "S3 70s", "S4 (1) 70s", "S4 (2) 70s",
            "N1 50s", "N2 50s", "N3 50s", "N4 (1) 50s", "N4 (2) 50s",
            "S1 50s", "S2 50s", "S3 50s", "S4 (1) 50s", "S4 (2) 50s",
            "N1 30s", "N2 30s", "N3 30s", "N4 (1) 30s", "N4 (2) 30s",
            "S1 30s", "S2 30s", "S3 30s", "S4 (1) 30s", "S4 (2) 30s",
    };

    public static String time(String ticks)
    {
        try
        {
            return time(Integer.parseInt(ticks));
        } catch (Exception e)
        {
            return ticks;
        }
    }

    public static String varbitHPtoReadable(int varbitHP)
    {
        return (varbitHP / 10) + "." + (varbitHP % 10) + "%";
    }


    public static boolean isPrimaryBoss(int ID)
    {
        int[] bosses = {
                TobIDs.MAIDEN_P0,
                TobIDs.MAIDEN_P1,
                TobIDs.MAIDEN_P2,
                TobIDs.MAIDEN_P3,
                TobIDs.MAIDEN_PRE_DEAD,
                TobIDs.MAIDEN_P0_HM,
                TobIDs.MAIDEN_P1_HM,
                TobIDs.MAIDEN_P2_HM,
                TobIDs.MAIDEN_P3_HM,
                TobIDs.MAIDEN_PRE_DEAD_HM,
                TobIDs.MAIDEN_P0_SM,
                TobIDs.MAIDEN_P1_SM,
                TobIDs.MAIDEN_P2_SM,
                TobIDs.MAIDEN_P3_SM,
                TobIDs.MAIDEN_PRE_DEAD_SM,
                TobIDs.BLOAT,
                TobIDs.BLOAT_HM,
                TobIDs.BLOAT_SM,
                TobIDs.NYLO_BOSS_MELEE,
                TobIDs.NYLO_BOSS_RANGE,
                TobIDs.NYLO_BOSS_MAGE,
                TobIDs.NYLO_BOSS_MELEE_HM,
                TobIDs.NYLO_BOSS_RANGE_HM,
                TobIDs.NYLO_BOSS_MAGE_HM,
                TobIDs.NYLO_BOSS_MELEE_SM,
                TobIDs.NYLO_BOSS_RANGE_SM,
                TobIDs.NYLO_BOSS_MAGE_SM,
                TobIDs.SOTETSEG_ACTIVE,
                TobIDs.SOTETSEG_ACTIVE_HM,
                TobIDs.SOTETSEG_ACTIVE_SM,
                TobIDs.XARPUS_P23,
                TobIDs.XARPUS_P23_HM,
                TobIDs.XARPUS_P23_SM,
                TobIDs.VERZIK_P1,
                TobIDs.VERZIK_P2,
                TobIDs.VERZIK_P3,
                TobIDs.VERZIK_P1_HM,
                TobIDs.VERZIK_P2_HM,
                TobIDs.VERZIK_P3_HM,
                TobIDs.VERZIK_P1_SM,
                TobIDs.VERZIK_P2_SM,
                TobIDs.VERZIK_P3_SM,
        };
        return (Arrays.stream(bosses).anyMatch(p -> p == ID));
    }

    public static String time(int ticks)
    {
        return time((double)ticks);
    }

    public static String time(double ticks)
    {
        if (ticks == Integer.MAX_VALUE || ticks < 1)
        {
            return "-";
        }
        String timeStr = "";
        double seconds = ticks * .6;
        int minutes = ((int) seconds - ((int) seconds) % 60) / 60;
        int onlySeconds = (int) seconds - 60 * minutes;
        String secondsString = String.format("%.1f", ticks * .6);
        if (minutes != 0)
            timeStr += minutes + ":";
        if (onlySeconds < 10 && minutes != 0)
        {
            timeStr += "0";
        }
        timeStr += onlySeconds;
        if (StringUtils.split(secondsString, ".").length == 2)
        {
            String[] subStr = StringUtils.split(secondsString, ".");
            timeStr += "." + subStr[1];
        } else
        {
            timeStr += ".0";
        }
        if (minutes == 0)
        {
            timeStr += "s";
        }
        return timeStr;
    }

    public static boolean crossedLine(int region, Point start, Point end, boolean vertical, Client client)
    {
        if (inRegion(client, region))
        {
            for (Player p : client.getPlayers())
            {
                WorldPoint wp = p.getWorldLocation();
                if (vertical)
                {
                    for (int i = start.getY(); i < end.getY() + 1; i++)
                    {
                        if (wp.getRegionY() == i && wp.getRegionX() == start.getX())
                        {
                            return true;
                        }
                    }
                } else
                {
                    for (int i = start.getX(); i < end.getX() + 1; i++)
                    {
                        if (wp.getRegionX() == i && wp.getRegionY() == start.getY())
                        {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    public static boolean inRegion(Client client, int... regions)
    {
        if (client.getMapRegions() != null)
        {
            for (int i : client.getMapRegions())
            {
                for (int j : regions)
                {
                    if (i == j)
                    {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

import net.runelite.api.coords.WorldPoint;

public class PlayerShell
{
    public WorldPoint worldLocation;
    public String name;

    public PlayerShell(WorldPoint location, String name)
    {
        this.worldLocation = location;
        this.name = name;
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

public class VengDamageQueue
{
    public int appliedTick;
    public int damage;
    public String target;

    public VengDamageQueue(String target, int damage, int appliedTick)
    {
        this.appliedTick = appliedTick;
        this.damage = damage;
        this.target = target;
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

import lombok.Getter;

public class DamageQueueShell
{
    @Getter
    public int sourceIndex;
    public int offset;
    public int targetIndex;
    public int originTick;
    public String source;

    public DamageQueueShell(int targetIndex, int sourceIndex, int offset, String source, int originTick)
    {
        this.source = source;
        this.offset = offset;
        this.targetIndex = targetIndex;
        this.sourceIndex = sourceIndex;
        this.originTick = originTick;
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

public class VengPair
{
    public String player;
    public int hitsplat;

    public VengPair(String player, int hitsplat)
    {
        this.player = player;
        this.hitsplat = hitsplat;
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.constants.LogID;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Player;

import java.util.ArrayList;

@Slf4j
public class VengTracker
{
    public ArrayList<VengCastQueue> vengedPlayers;
    private final AdvancedRaidTrackerPlugin plugin;

    public VengTracker(AdvancedRaidTrackerPlugin plugin)
    {
        vengedPlayers = new ArrayList<>();
        this.plugin = plugin;
    }

    private void handleApplyVeng()
    {
        ArrayList<VengCastQueue> temp = new ArrayList<>();
        for (VengCastQueue vcq : vengedPlayers)
        {
            boolean flag = false;
            for (VengCastQueue v : temp)
            {
                if (v.target != null && v.source != null)
                {
                    if (v.target.equals(vcq.target))
                    {
                        if (!v.source.equals(vcq.source))
                        {
                            vcq.source = v.source;
                        }
                        flag = true;
                    }
                }
            }
            if (!flag)
            {
                temp.add(vcq);
            }
        }
        vengedPlayers.clear();
        for (VengCastQueue vcq : temp)
        {
            plugin.clog.addLine(LogID.VENG_WAS_CAST, vcq.target, vcq.source);
        }
    }

    public void updateTick()
    {
        handleApplyVeng();
    }

    public void vengSelfCast(Player player)
    {
        vengedPlayers.add(new VengCastQueue(player.getName(), player.getName()));
    }

    public void vengOtherCast(Player caster)
    {
        String nameTarget = "";
        String nameSource;
        nameSource = caster.getName();
        if (caster.getInteracting() != null)
        {
            nameTarget = caster.getInteracting().getName();
        }
        vengedPlayers.add(new VengCastQueue(nameTarget, nameSource));
    }

    public void vengOtherGraphicApplied(Player receiver)
    {
        vengedPlayers.add(new VengCastQueue(receiver.getName(), ".unknown"));
    }

    public void vengSelfGraphicApplied(Player self)
    {
        vengedPlayers.add(new VengCastQueue(self.getName(), self.getName()));
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

public class VengCastQueue
{
    public String target;
    public String source;

    public VengCastQueue(String target, String source)
    {
        this.target = target;
        this.source = source;
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

import net.runelite.api.Actor;
import net.runelite.api.NPC;
import java.util.ArrayList;

import static com.advancedraidtracker.constants.TobIDs.*;

public class Thrall
{
    NPC npc;
    PlayerShell player;
    ArrayList<PlayerShell> potentialPlayers;

    public Actor lastParentInteraction;
    boolean isMelee;
    public int spawnTick;

    public Thrall(NPC npc, ArrayList<PlayerShell> potentialPlayers, int spawnTick)
    {
        this.potentialPlayers = potentialPlayers;
        this.npc = npc;
        isMelee = npc.getId() == MELEE_THRALL;
        this.spawnTick = spawnTick;
    }

    public boolean matchesGraphic(int animationID)
    {
        return (animationID == THRALL_CAST_GRAPHIC_MAGE && npc.getId() == MAGE_THRALL)
                || (animationID == THRALL_CAST_GRAPHIC_RANGE && npc.getId() == RANGE_THRALL)
                || (animationID == THRALL_CAST_GRAPHIC_MELEE && npc.getId() == MELEE_THRALL);
    }

    public void setOwner(PlayerShell player)
    {
        this.player = player;
    }

    public String getOwner()
    {
        if (player != null)
        {
            return player.name;
        } else
        {
            return ".unassigned";
        }
    }
}

package com.advancedraidtracker.utility.thrallvengtracking;

import com.advancedraidtracker.AdvancedRaidTrackerPlugin;
import com.advancedraidtracker.constants.LogID;
import com.advancedraidtracker.utility.wrappers.ThrallOutlineBox;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Projectile;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.Objects;
import java.util.Optional;

import static com.advancedraidtracker.constants.TobIDs.*;

@Slf4j
public class ThrallTracker
{
    private final ArrayList<Player> queuedCastAnimation;
    private final ArrayList<Player> queuedMageCastGraphic;
    private final ArrayList<Player> queuedRangeCastGraphic;
    private final ArrayList<Player> queuedMeleeCastGraphic;
    private final ArrayList<Thrall> queuedThrallSpawn;

    private final ArrayList<Thrall> activeThralls;


    private final AdvancedRaidTrackerPlugin plugin;

    public ThrallTracker(AdvancedRaidTrackerPlugin plugin)
    {
        this.plugin = plugin;
        queuedCastAnimation = new ArrayList<>();
        queuedMageCastGraphic = new ArrayList<>();
        queuedMeleeCastGraphic = new ArrayList<>();
        queuedRangeCastGraphic = new ArrayList<>();
        queuedThrallSpawn = new ArrayList<>();

        activeThralls = new ArrayList<>();
    }

    public void removeThrall(NPC npc)
    {
        Optional<Thrall> thrall2 = activeThralls.stream().filter(thrall1 -> thrall1.npc.getIndex() == npc.getIndex()).findAny();
        if (thrall2.isPresent())
        {
            Thrall t = thrall2.get();
            plugin.removeThrallBox(t);
        }
        activeThralls.removeIf(thrall -> thrall.npc.getIndex() == npc.getIndex());
    }

    public void handleCasts()
    {
        if (queuedThrallSpawn.isEmpty())
        {
            return;
        }
        ArrayList<PlayerShell> assignedPlayers = new ArrayList<>();
        for (Thrall thrall : queuedThrallSpawn)
        {
            if (thrall.potentialPlayers.size() == 1)
            {
                thrall.setOwner(thrall.potentialPlayers.get(0));
                plugin.addThrallOutlineBox(new ThrallOutlineBox(thrall.potentialPlayers.get(0).name, thrall.spawnTick, thrall.npc.getId()));
                activeThralls.add(thrall);

                assignedPlayers.add(new PlayerShell(thrall.player.worldLocation, thrall.player.name));
            }
        }
        removeQueuedThralls(assignedPlayers);

        for (Thrall thrall : queuedThrallSpawn)
        {
            thrall.potentialPlayers.removeIf(p1 -> queuedCastAnimation.stream().noneMatch(p2 -> Objects.equals(p2.getName(), p1.name)));
            if (thrall.potentialPlayers.size() == 1)
            {
                thrall.setOwner(thrall.potentialPlayers.get(0));
                plugin.addThrallOutlineBox(new ThrallOutlineBox(thrall.potentialPlayers.get(0).name, thrall.spawnTick, thrall.npc.getId()));
                activeThralls.add(thrall);
            }
        }
        removeQueuedThralls(assignedPlayers);

        for (Thrall thrall : queuedThrallSpawn)
        {
            thrall.potentialPlayers.removeIf(p1 ->
                    queuedMageCastGraphic.stream().noneMatch(p2 -> thrall.matchesGraphic(THRALL_CAST_GRAPHIC_MAGE))
                            && queuedRangeCastGraphic.stream().noneMatch(p2 -> thrall.matchesGraphic(THRALL_CAST_GRAPHIC_RANGE))
                            && queuedMeleeCastGraphic.stream().noneMatch(p2 -> thrall.matchesGraphic(THRALL_CAST_GRAPHIC_MELEE)));
            if (thrall.potentialPlayers.size() == 1)
            {
                thrall.setOwner(thrall.potentialPlayers.get(0));
                plugin.addThrallOutlineBox(new ThrallOutlineBox(thrall.potentialPlayers.get(0).name, thrall.spawnTick, thrall.npc.getId()));
                activeThralls.add(thrall);
            }
        }
        removeQueuedThralls(assignedPlayers);

        activeThralls.addAll(queuedThrallSpawn);
        queuedThrallSpawn.clear();

    }

    private void removeQueuedThralls(ArrayList<PlayerShell> assignedPlayers)
    {
        queuedThrallSpawn.removeIf(thrall -> thrall.potentialPlayers.size() == 1);
        queuedCastAnimation.removeIf(p -> assignedPlayers.stream().anyMatch(p2 -> Objects.equals(p2.name, p.getName())));
        queuedMeleeCastGraphic.removeIf(p -> assignedPlayers.stream().anyMatch(p2 -> Objects.equals(p2.name, p.getName())));
        queuedRangeCastGraphic.removeIf(p -> assignedPlayers.stream().anyMatch(p2 -> Objects.equals(p2.name, p.getName())));
        queuedMageCastGraphic.removeIf(p -> assignedPlayers.stream().anyMatch(p2 -> Objects.equals(p2.name, p.getName())));
    }

    public void updatePlayerInteracting(String playerName, Actor interacting)
    {
        for (Thrall thrall : activeThralls)
        {
            if (thrall.getOwner().equals(playerName))
            {
                if (interacting != null)
                {
                    thrall.lastParentInteraction = interacting;
                }
            }
        }
    }

    public void updateTick()
    {
        handleCasts();
    }

    public void castThrallAnimation(Player player)
    {
        queuedCastAnimation.add(player);
    }

    public void meleeThrallAttacked(NPC npc)
    {
        for (Thrall thrall : activeThralls)
        {
            if (npc.getIndex() == thrall.npc.getIndex() && thrall.isMelee && thrall.npc.getAnimation() == MELEE_THRALL_ATTACK_ANIMATION)
            {
                if (thrall.lastParentInteraction instanceof NPC)
                {
                    if (thrall.lastParentInteraction.getWorldArea().distanceTo(thrall.npc.getWorldLocation()) < 2)
                    {
                        plugin.clog.addLine(LogID.THRALL_ATTACKED, thrall.getOwner(), "melee");
                        plugin.addQueuedThrallDamage(((((NPC) thrall.lastParentInteraction).getIndex())), thrall.npc.getIndex(), 1, thrall.getOwner());
                    }
                }
            }
        }
    }

    public void projectileCreated(Projectile projectile, WorldPoint origin)
    {
        if (projectile.getInteracting() instanceof NPC)
        {
            int hitOffset = -1;

            if (projectile.getId() == THRALL_PROJECTILE_RANGE)
            {
                hitOffset = (projectile.getRemainingCycles() > 30) ? (projectile.getRemainingCycles() > 60) ? 2 : 1 : 0;
            } else if (projectile.getId() == THRALL_PROJECTILE_MAGE)
            {
                hitOffset = (projectile.getRemainingCycles() > 40) ? 1 : 0;
            }
            for (Thrall t : activeThralls)
            {
                if (t.npc.getWorldLocation().distanceTo(origin) == 0 && hitOffset != -1)
                {
                    plugin.clog.addLine(LogID.THRALL_ATTACKED, t.getOwner(), String.valueOf(projectile.getId()));
                    plugin.addQueuedThrallDamage(((NPC) (projectile.getInteracting())).getIndex(), t.npc.getIndex(), hitOffset, t.getOwner());
                    if (plugin.isVerzP2())
                    {
                        if (plugin.verzShieldActive)
                        {
                            NPC npc = (NPC) projectile.getInteracting();
                            if (npc.getId() == VERZIK_P2 || npc.getId() == VERZIK_P2_HM || npc.getId() == VERZIK_P2_SM)
                            {
                                plugin.thrallAttackedP2VerzikShield(hitOffset);
                            }
                        }
                    }
                    break;
                }
            }
        }
    }

    public void playerHasThrallCastSpotAnim(Player player, int id)
    {
        switch (id)
        {
            case THRALL_CAST_GRAPHIC_MELEE:
                queuedMeleeCastGraphic.add(player);
                break;
            case THRALL_CAST_GRAPHIC_RANGE:
                queuedRangeCastGraphic.add(player);
                break;
            case THRALL_CAST_GRAPHIC_MAGE:
                queuedMageCastGraphic.add(player);
                break;
        }
    }

    public void thrallSpawned(NPC thrall, ArrayList<PlayerShell> adjacentPlayers)
    {
        queuedThrallSpawn.add(new Thrall(thrall, adjacentPlayers, plugin.getRoomTick()));
    }

}

package com.advancedraidtracker.utility.thrallvengtracking;

public class ProjectileQueue
{
    public int originTick;
    public int finalTick;
    public int targetIndex;

    public ProjectileQueue(int originTick, int finalTick, int targetIndex)
    {
        this.originTick = originTick;
        this.finalTick = finalTick;
        this.targetIndex = targetIndex;
    }
}

package com.advancedraidtracker.filters;

import com.advancedraidtracker.SimpleTOBData;

public abstract class FilterCondition
{
    public abstract boolean evaluate(SimpleTOBData data);

    public abstract String getFilterCSV();
}

package com.advancedraidtracker.filters;

import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;
@Slf4j
public class FilterManager
{
    private static final String filterFolder = System.getProperty("user.home").replace("\\", "/") + "/.runelite/advancedraidtracker/misc-dir/filters/";

    public static ArrayList<Filter> getFilters()
    {
        ArrayList<Filter> currentFilters = new ArrayList<>();
        File folder = new File(filterFolder);
        try
        {
            for (File entry : Objects.requireNonNull(folder.listFiles()))
            {
                ArrayList<String> activeFileFilters = new ArrayList<>();
                if (entry.isFile())
                {
                    if (entry.getAbsolutePath().endsWith(".filter"))
                    {
                        try
                        {
                            Scanner filterReader = new Scanner(Files.newInputStream(entry.toPath()));
                            while (filterReader.hasNextLine())
                            {
                                activeFileFilters.add(filterReader.nextLine());
                            }
                            filterReader.close();
                            if (!activeFileFilters.isEmpty())
                            {
                                currentFilters.add(new Filter(entry.getName(), activeFileFilters.toArray(new String[0])));
                            }
                        } catch (Exception e)
                        {
                            log.info("Failed to read filter filter");
                        }
                    }
                }
            }
        } catch (Exception e)
        {
            log.info("Failed retrieving filters");
        }
        return currentFilters;
    }

    public static boolean doesFilterExist(String name)
    {
        File folder = new File(filterFolder);
        try
        {
            for (File entry : Objects.requireNonNull(folder.listFiles()))
            {
                if (entry.getName().equals(name + ".filter"))
                {
                    return true;
                }
            }
        } catch (Exception e)
        {
            log.info("Failed to find filter");
        }
        return false;
    }

    public static void saveOverwriteFilter(String name, ArrayList<ImplicitFilter> filters)
    {
        try
        {
            File directory = new File(filterFolder);
            if (!directory.exists())
            {
                if(!directory.mkdirs())
                {
                    log.info("Could not make directories to save filter");
                }
            }
            File filterFile = new File(filterFolder + name + ".filter");

            if (filterFile.exists())
            {
                if(!filterFile.delete())
                {
                    log.info("Could not delete old filter");
                }
            }
            if(!filterFile.createNewFile())
            {
                log.info("Could not create new filter filter");
            }
            BufferedWriter filterWriter = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(Paths.get(filterFolder + name + ".filter"))));
            for (ImplicitFilter s : filters)
            {
                filterWriter.write(s.getFilterDescription());
                filterWriter.newLine();
            }
            filterWriter.close();
        } catch (Exception ignored)
        {
        }
    }

    public static void saveFilter(String name, ArrayList<ImplicitFilter> filters)
    {
        try
        {
            File directory = new File(filterFolder);
            if (!directory.exists())
            {
                if(!directory.mkdirs())
                {
                    log.info("Could not make directory to save filter");
                }
            }
            File filterFile = new File(filterFolder + name + ".filter");
            if (!filterFile.exists())
            {
                if(!filterFile.createNewFile())
                {
                    log.info("Could not create new filter file");
                }
            }
            BufferedWriter filterWriter = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(Paths.get(filterFolder + name + ".filter"))));
            for (ImplicitFilter filter : filters)
            {
                filterWriter.write(filter.getFilterCSV());
                filterWriter.newLine();
            }
            filterWriter.close();
        } catch (Exception ignored)
        {
        }
    }

    public static void saveFilter(String name, ArrayList<ImplicitFilter> filters, ArrayList<String> quickFiltersState)
    {
        try
        {
            File directory = new File(filterFolder);
            if (!directory.exists())
            {
                if(!directory.mkdirs())
                {
                    log.info("Could not make folder to save filters");
                }
            }
            File filterFile = new File(filterFolder + name + ".filter");
            if (!filterFile.exists())
            {
                if(!filterFile.createNewFile())
                {
                    log.info("Could not create new filter file");
                }
            }
            BufferedWriter filterWriter = new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(Paths.get(filterFolder + name + ".filter"))));
            for (ImplicitFilter filter : filters)
            {
                filterWriter.write(filter.getFilterCSV());
                filterWriter.newLine();
            }
            for(String s : quickFiltersState)
            {
                filterWriter.write(s);
                filterWriter.newLine();
            }
            filterWriter.close();
        } catch (Exception ignored)
        {
        }
    }

}

package com.advancedraidtracker.filters;

import com.advancedraidtracker.SimpleTOBData;

import java.util.Calendar;
import java.util.Date;

public class FilterDate extends FilterCondition
{
    private final Date date;
    private final int qualifier;
    private final String stringValue;

    public FilterDate(Date date, int qualifier, String val)
    {
        this.date = date;
        this.qualifier = qualifier;
        stringValue = val;
    }

    @Override
    public String toString()
    {
        return stringValue;
    }

    @Override
    public boolean evaluate(SimpleTOBData data)
    {
        Calendar cal = Calendar.getInstance();
        Calendar cal2 = Calendar.getInstance();
        cal.setTime(data.raidStarted);
        cal2.setTime(date);
        switch (qualifier)
        {
            case 0:
                return (cal.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&
                        cal.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&
                        cal.get(Calendar.YEAR) == cal2.get(Calendar.YEAR));
            case 1:
                return data.raidStarted.before(date);
            case 2:
                return data.raidStarted.after(date);
            default:
                throw new IllegalStateException("Unexpected value: " + qualifier);
        }
    }

    public String getFilterCSV()
    {
        return "4-" + date.getTime() + "-" + qualifier + "-" + stringValue;
    }
}

package com.advancedraidtracker.filters;

import com.advancedraidtracker.SimpleTOBData;

public class FilterOtherBool extends FilterCondition
{
    boolean value;
    int param;
    String stringValue;

    public FilterOtherBool(int param, boolean value, String val)
    {
        this.param = param;
        this.value = value;
        stringValue = val;
    }

    @Override
    public String toString()
    {
        return stringValue;
    }

    @Override
    public boolean evaluate(SimpleTOBData data)
    {
        switch (param)
        {
            case 0:
                return data.maidenSkip == value;
            case 1:
                return data.maidenReset == value;
            case 2:
                return data.maidenWipe == value;
            case 3:
                return data.bloatReset == value;
            case 4:
                return data.bloatWipe == value;
            case 5:
                return data.nyloReset == value;
            case 6:
                return data.nyloWipe == value;
            case 7:
                return data.soteReset == value;
            case 8:
                return data.soteWipe == value;
            case 9:
                return data.xarpReset == value;
            case 10:
                return data.xarpWipe == value;
            case 11:
                return data.verzikWipe == value;
            case 12:
                return data.maidenScuffed == value;
        }
        return false;
    }

    public String getFilterCSV()
    {
        return "3-" + param + "-" + ((value) ? 1 : 0) + "-" + stringValue;
    }
}

package com.advancedraidtracker.filters;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.utility.datautility.DataPoint;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;

public class ImplicitFilter
{
    private FilterCondition filter;

    public ImplicitFilter(FilterDate filterDate)
    {
        filter = filterDate;
    }

    public ImplicitFilter(FilterTime filterTime)
    {
        filter = filterTime;
    }

    public ImplicitFilter(FilterPlayers filterPlayers)
    {
        filter = filterPlayers;
    }

    public ImplicitFilter(FilterOtherBool filterBool)
    {
        filter = filterBool;
    }

    public ImplicitFilter(FilterOtherInt filterInt)
    {
        filter = filterInt;
    }

    public ImplicitFilter(String s)
    {
        filter = null;
        if (!s.isEmpty())
        {
            int filterType = Integer.parseInt(s.substring(0, 1));
            ArrayList<String> parse = new ArrayList<String>(Arrays.asList(s.split("-")));
            switch (filterType)
            {
                case 0:
                    if (parse.size() == 5)
                    {
                        filter = new FilterTime(
                                DataPoint.getValue(parse.get(1)),
                                Integer.parseInt(parse.get(2)),
                                Integer.parseInt(parse.get(3)),
                                parse.get(4));
                    }
                    break;
                case 1:
                    if (parse.size() == 5)
                    {
                        filter = new FilterOtherInt(
                                DataPoint.getValue(parse.get(1)),
                                Integer.parseInt(parse.get(2)),
                                Integer.parseInt(parse.get(3)),
                                parse.get(4));
                    }
                    break;
                case 2:
                    if (parse.size() == 4)
                    {
                        filter = new FilterPlayers(
                                parse.get(2),
                                Integer.parseInt(parse.get(1)),
                                parse.get(3));
                    }
                    break;
                case 3:
                    if (parse.size() == 4)
                    {
                        filter = new FilterOtherBool(
                                Integer.parseInt(parse.get(1)),
                                (Integer.parseInt(parse.get(2)) == 1),
                                parse.get(3));
                    }
                    break;
                case 4:
                    if (parse.size() == 4)
                    {
                        filter = new FilterDate(
                                new Date(Long.parseLong(parse.get(1))),
                                Integer.parseInt(parse.get(2)),
                                parse.get(3));
                    }
            }
        }
    }

    public String getFilterCSV()
    {
        return filter.getFilterCSV();
    }

    public String getFilterDescription()
    {
        return filter.toString();
    }

    public boolean evaluate(SimpleTOBData data)
    {
        return filter.evaluate(data);
    }
}

package com.advancedraidtracker.filters;

import com.advancedraidtracker.SimpleTOBData;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;

@Slf4j
public class FilterPlayers extends FilterCondition
{
    private final ArrayList<String> players;
    private final int operator;
    private final String stringValue;

    public FilterPlayers(String players, int operator, String val)
    {
        this.players = new ArrayList<String>();
        String[] playerNames = players.split(",");
        for (String playerName : playerNames)
        {
            this.players.add(playerName.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)).toLowerCase());
        }
        this.operator = operator;
        stringValue = val;
    }

    private boolean cleanContains(SimpleTOBData data, String player)
    {
        for (String p : data.players.keySet())
        {
            if (p.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)).toLowerCase().equals(player))
            {
                return true;
            }
        }
        return false;
    }

    @Override
    public String toString()
    {
        return stringValue;
    }

    @Override
    public boolean evaluate(SimpleTOBData data)
    {
        switch (operator)
        {
            case 0:
                if (data.players.size() == players.size())
                {
                    for (String p : players)
                    {
                        if (!cleanContains(data, p))
                        {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            case 1:
                boolean flag = true;
                for (String p : players)
                {
                    if (!cleanContains(data, p))
                    {
                        flag = false;
                    }
                }
                return flag;
            case 2:
                for (String p : players)
                {
                    if (cleanContains(data, p))
                    {
                        return true;
                    }
                }
                return false;
            case 3:
                for (String p : players)
                {
                    if (!cleanContains(data, p))
                    {
                        return true;
                    }
                }
                return false;
            case 4:
                for (String p : players)
                {
                    if (cleanContains(data, p))
                    {
                        return false;
                    }
                }
                return true;
        }
        return false;
    }

    public String getFilterCSV()
    {
        StringBuilder playerStr = new StringBuilder();
        for (String s : players)
        {
            playerStr.append(s);
            playerStr.append(",");
        }
        playerStr = new StringBuilder(StringUtils.substring(playerStr.toString(), 0, playerStr.length() - 1));
        return "2-" + operator + "-" + playerStr + "-" + stringValue;
    }
}

package com.advancedraidtracker.filters;

import com.advancedraidtracker.SimpleTOBData;
import com.advancedraidtracker.utility.datautility.DataPoint;

public class FilterOtherInt extends FilterCondition
{
    DataPoint param;
    int qualifier;
    int value;
    public String stringValue;

    public FilterOtherInt(DataPoint param, int qualifier, int value, String val)
    {
        this.param = param;
        this.qualifier = qualifier;
        this.value = value;
        stringValue = val;
    }

    @Override
    public String toString()
    {
        return stringValue;
    }

    @Override
    public boolean evaluate(SimpleTOBData data)
    {
        int checkValue = data.getValue(param);
        if (data.getTimeAccurate(param) && value != -1)
        {
            return FilterUtil.compare(qualifier, value, checkValue);

        } else
        {
            return false;
        }
    }

    public String getFilterCSV()
    {
        return "1-" + param.name + "-" + qualifier + "-" + value + "-" + stringValue;
    }
}

package com.advancedraidtracker.filters;

import com.advancedraidtracker.utility.datautility.DataPoint;
import lombok.extern.slf4j.Slf4j;
import com.advancedraidtracker.SimpleTOBData;

@Slf4j
public class FilterTime extends FilterCondition
{
    private final DataPoint split;
    private final int compare;
    private final int time;
    private final String stringValue;

    public FilterTime(DataPoint split, int compare1, int time1, String str)
    {
        this.split = split;
        this.compare = compare1;
        this.time = time1;
        stringValue = str;
    }

    @Override
    public String toString()
    {
        return stringValue;
    }

    @Override
    public boolean evaluate(SimpleTOBData data)
    {
        int checkValue = data.getValue(split);
        return FilterUtil.compare(compare, time, checkValue);
    }

    public String getFilterCSV()
    {
        return "0-" + split.name + "-" + compare + "-" + time + "-" + stringValue;
    }
}


package com.advancedraidtracker.filters;

import lombok.Getter;

@Getter
public class Filter
{
    private final String name;
    private final String[] filters;

    public Filter(String name, String[] filters)
    {
        this.filters = filters;
        this.name = name;
    }
}

package com.advancedraidtracker.filters;

public class FilterUtil
{
    public static boolean compare(int operator, int value, int compareValue)
    {
        switch (operator)
        {
            case 0:
                return compareValue == value;
            case 1:
                return compareValue < value;
            case 2:
                return compareValue > value;
            case 3:
                return compareValue <= value;
            case 4:
                return compareValue >= value;
            default:
                return false;
        }
    }
}

package com.advancedraidtracker.constants;

import lombok.Getter;

import java.util.Arrays;
import java.util.Optional;

import static com.advancedraidtracker.constants.TOBRoom.*;

/**
 * Convenience class for the possible keys used to log events. The parameters each of these events should include can be found in
 * RoomData.
 */
@Getter
public enum LogID
{
    ENTERED_TOB(0, true, ANY, "Entered TOB"),
    PARTY_MEMBERS(1, true, ANY, "Party Members"),
    DWH(2, true, ANY,"DWH Hit"),
    BGS(3, true, ANY,"BGS Hit"),
    LEFT_TOB(4, true, ANY,"Left TOB"),
    PLAYER_DIED(5, true, ANY,"Played Died"),
    ENTERED_NEW_TOB_REGION(6, true, ANY,"Entered New TOB Region"),
    HAMMER_ATTEMPTED(7, true, ANY,"DWH Attempted"),
    DAWN_DROPPED(800, false, VERZIK,"Dawnbringer appeared"),
    WEBS_STARTED(901, false, VERZIK,"Webs Thrown"),
    PLAYER_ATTACK(801, false, ANY,"Player Animation"),
    BLOOD_THROWN(9, true, MAIDEN,"Maiden blood thrown"),
    BLOOD_SPAWNED(10, true, MAIDEN, "Blood Spawned"),
    CRAB_LEAK(11, true, MAIDEN, "Crab Leaked"),
    MAIDEN_SPAWNED(12, true, MAIDEN, "Spawned"),
    MAIDEN_70S(13, true, MAIDEN, "70s"),
    MAIDEN_50S(14, true, MAIDEN, "50s"),
    MAIDEN_30S(15, true, MAIDEN, "30s"),
    MAIDEN_0HP(16, true, MAIDEN, "0 HP"),
    MAIDEN_DESPAWNED(17, true, MAIDEN, "Despawned"),
    MATOMENOS_SPAWNED(18, true, MAIDEN, "Crab Spawned"),
    MAIDEN_SCUFFED(19, true, MAIDEN, "Scuffed"),
    BLOAT_SPAWNED(20, true, BLOAT, "Spawned"),
    BLOAT_DOWN(21, true, BLOAT, "Down"),
    BLOAT_0HP(22, true, BLOAT, "0 HP"),
    BLOAT_DESPAWN(23, true, BLOAT, "Despawned"),
    BLOAT_HP_1ST_DOWN(24, true, BLOAT, "HP at First Down"),
    BLOAT_SCYTHE_1ST_WALK(25, true, BLOAT, "First Walk Scythes"),

    NYLO_PILLAR_SPAWN(30, true, NYLOCAS, "Pillar Spawn"),
    NYLO_STALL(31, true, NYLOCAS, "Stall"),
    RANGE_SPLIT(32, true, NYLOCAS, "Range Split"),
    MAGE_SPLIT(33, true, NYLOCAS, "Mage Split"),
    MELEE_SPLIT(34, true, NYLOCAS, "Melee Split"),
    LAST_WAVE(35, true, NYLOCAS, "Last Wave"),
    LAST_DEAD(36, true, NYLOCAS, "Last Dead"),
    NYLO_WAVE(37, true, NYLOCAS, "Wave"),
    BOSS_SPAWN(40, true, NYLOCAS, "Boss Spawn"),
    MELEE_PHASE(41, true, NYLOCAS, "Melee Phase"),
    MAGE_PHASE(42, true, NYLOCAS, "Mage Phase"),
    RANGE_PHASE(43, true, NYLOCAS, "Range Phase"),
    NYLO_0HP(44, true, NYLOCAS, "0 HP"),
    NYLO_DESPAWNED(45, true, NYLOCAS, "Despawn"),
    NYLO_PILLAR_DESPAWNED(46, true, NYLOCAS, "Pillar Despawn"), //tick
    SOTETSEG_STARTED(51, true, SOTETSEG, "Started"),
    SOTETSEG_FIRST_MAZE_STARTED(52, true, SOTETSEG, "First Maze Start"),
    SOTETSEG_FIRST_MAZE_ENDED(53, true, SOTETSEG, "First Maze End"),
    SOTETSEG_SECOND_MAZE_STARTED(54, true, SOTETSEG, "Second Maze Start"),
    SOTETSEG_SECOND_MAZE_ENDED(55, true, SOTETSEG, "Second Maze End"),
    SOTETSEG_ENDED(57, true, SOTETSEG, "Room End"),
    XARPUS_SPAWNED(60, true, XARPUS, "Spawned"),
    XARPUS_STARTED(61, true, XARPUS, "Started"),
    XARPUS_HEAL(62, true, XARPUS, "Heal"),
    XARPUS_SCREECH(63, true, XARPUS, "Screech"),
    XARPUS_0HP(64, true, XARPUS, "0 HP"),
    XARPUS_DESPAWNED(65, true, XARPUS, "Despawned"),
    VERZIK_SPAWNED(70, true, VERZIK, "Spawned"),
    VERZIK_P1_START(71, true, VERZIK, "P1 Start"),
    VERZIK_P1_0HP(72, true, VERZIK, "P1 0 HP"),
    VERZIK_P1_DESPAWNED(73, true, VERZIK, "P1 Despawned"),
    VERZIK_P2_END(74, true, VERZIK, "P2 End"),
    VERZIK_P3_0HP(75, true, VERZIK, "P2 0 HP"),
    VERZIK_P3_DESPAWNED(76, true, VERZIK, "P3 Despawned"),
    VERZIK_BOUNCE(77, true, VERZIK, "Bounce"),
    VERZIK_CRAB_SPAWNED(78, true, VERZIK, "Crab Spawned"),
    VERZIK_P2_REDS_PROC(80, true, VERZIK, "Reds Proc"),

    LATE_START(98, true, ANY, "Joined Raid After Start"),
    SPECTATE(99, true, ANY, "Is Spectating"),
    NOT_118(998, true, ANY, "Not 118"),
    NO_PIETY(999, true, ANY, "No Piety"),
    RANDOM_TRACKER(1000, true, ANY, "Random Tracker"),
    RANDOM_TRACKER_2(1001, true, ANY, "Random Tracker2"),
    BLOAT_HAND(975, false, BLOAT, "Bloat Hand"),
    BLOAT_DIRECTION(976, false, BLOAT, "Bloat Direction"),

    PARTY_COMPLETE(100, true, ANY, "Party Is Complete"),
    PARTY_INCOMPLETE(101, true, ANY, "Party Is Not Complete"),
    PARTY_ACCURATE_PREMAIDEN(102, true, ANY, "Party Is Complete Prior To Maiden"),

    MAIDEN_DINHS_SPEC(111, true, MAIDEN, "Dinhs Spec"), //Player, tick, primary target:primary target hp, targets~hp:,stats:stats
    MAIDEN_DINHS_TARGET(112, true, MAIDEN, "Dinhs Target"), //

    MAIDEN_CHIN_THROWN(113, true, MAIDEN, "Chin Thrown"), //player, distance

    ACCURATE_MAIDEN_START(201, true, MAIDEN, "Accurate Maiden Start"),
    ACCURATE_BLOAT_START(202, true, BLOAT, "Accurate Bloat Start"),
    ACCURATE_NYLO_START(203, true, NYLOCAS, "Accurate Nylo Start"),
    ACCURATE_SOTE_START(204, true, SOTETSEG, "Accurate Sote Start"),
    ACCURATE_XARP_START(205, true, XARPUS, "Accurate Xarpus Start"),
    ACCURATE_VERZIK_START(206, true, VERZIK, "Accurate Verzik Start"),

    ACCURATE_MAIDEN_END(301, true, MAIDEN, "Accurate Maiden End"),
    ACCURATE_BLOAT_END(302, true, BLOAT, "Accurate Bloat End"),
    ACCURATE_NYLO_END(303, true, NYLOCAS, "Accurate Nylo End"),
    ACCURATE_SOTE_END(304, true, SOTETSEG, "Accurate Sote End"),
    ACCURATE_XARP_END(305, true, XARPUS, "Accurate Xarpus End"),
    ACCURATE_VERZIK_END(306, true, VERZIK, "Accurate Verzik End"),
    IS_HARD_MODE(401, true, ANY, "Is Hard Mode"),
    IS_STORY_MODE(402, true, ANY, "Is Story Mode"),

    THRALL_ATTACKED(403, false, ANY, "Thrall Attacked"), // player, type

    THRALL_DAMAGED(404, false, ANY, "Thrall Damaged"), // player, damage

    VENG_WAS_CAST(405, false, ANY, "Veng Cast"), //target, source

    VENG_WAS_PROCCED(406, false, ANY, "Veng Procced"), //player, source of veng, damage

    PLAYER_STOOD_IN_THROWN_BLOOD(411, true, MAIDEN, "Player Stood In Thrown Blood"), //player, damage, blood tick
    PLAYER_STOOD_IN_SPAWNED_BLOOD(412, true, MAIDEN, "Player Stood In Spawned Blood"),  //player, damage
    CRAB_HEALED_MAIDEN(413, true, MAIDEN, "Crab Healed Maiden"), //damage
    VERZIK_PURPLE_HEAL(701, true, VERZIK, "Purple Heal"),
    VERZIK_RED_AUTO(702, true, VERZIK, "Red Auto"),
    VERZIK_THRALL_HEAL(703, true, VERZIK, "Thrall Heal"),
    VERZIK_PLAYER_HEAL(704, true, VERZIK, "Player Heal"),

    KODAI_BOP(501, true, ANY, "Kodai Bop"),
    DWH_BOP(502, true, ANY, "DWH Bop"),
    BGS_WHACK(503, true, ANY, "BGS Whack"),
    CHALLY_POKE(504, true, ANY, "Chally Poke"),
    THRALL_SPAWN(410, false, ANY, "Thrall Spawn"),
    THRALL_DESPAWN(498, false, ANY, "Thrall Despawn"),
    DAWN_SPEC(487, false, VERZIK, "Dawn Spec"),
    DAWN_DAMAGE(488, false, VERZIK, "Dawn Damage"),
    MAIDEN_PLAYER_DRAINED(530, true, MAIDEN, "Player Drained"),
    MAIDEN_AUTO(531, true, MAIDEN, "Maiden Auto"),

    UPDATE_HP(576, false, ANY, "Update Boss HP"),
    ADD_NPC_MAPPING(587, false, ANY, "Update NPC Mappings"),
    UNKNOWN(-1, false, ANY, "Unknown");

    final int id;
    final String commonName;
    final TOBRoom room;
    final boolean simple;

    LogID(int id, boolean simple, TOBRoom room, String commonName)
    {
        this.id = id;
        this.commonName = commonName;
        this.room = room;
        this.simple = simple;
    }
    public static LogID valueOf(int value)
    {
        Optional<LogID> o = Arrays.stream(values()).filter(logid -> logid.getId() == value).findFirst();
        return o.orElse(UNKNOWN);
    }
}

package com.advancedraidtracker.constants;

import java.util.Arrays;
import java.util.Optional;

public enum TOBRoom
{
    MAIDEN(0), BLOAT(1), NYLOCAS(2), SOTETSEG(3), XARPUS(4), VERZIK(5), UNKNOWN(-1), ANY(6);

    public final int value;
    TOBRoom(int value)
    {
        this.value = value;
    }

    public static TOBRoom valueOf(int number)
    {
        Optional<TOBRoom> o = Arrays.stream(values()).filter(room -> room.value == number).findFirst();
        return o.orElse(UNKNOWN);
    }
}

package com.advancedraidtracker.constants;

public class TobIDs
{
    public static final int ROOM_ACTIVE_VARBIT = 6447;

    public static final int HP_VARBIT = 6448;
    public static final int SCYTHE_ANIMATION = 8056;
    public final static int CHINCHOMPA_THROWN_ANIMATION = 7618;

    public final static int DINHS_BULWARK_ANIMATION = 7511;

    public final static int BLOOD_ON_GROUND = 32984;

    public final static int VERZIK_CRAB_HEAL_PROJECTILE = 1587;
    public final static int VERZIK_RED_MAGE_AUTO_PROJECTILE = 1591;
    public final static int VERZIK_WEB_PROJECTILE = 1601;
    public final static int VERZIK_DEATH_ANIMATION_LENGTH = 6;

    public final static int VERZIK_SHIELD_LENGTH = 11;
    public final static int DAWNBRINGER_ITEM = 22516;
    public final static String VERZIK_BOUNCE_ANIMATION = "100000"; //fake number used due to poor design of how attacks are presented on the chart

    public final static int DAWNBRINGER_MINIMUM_HIT = 75;

    public final static int XARPUS_DEATH_ANIMATION_LENGTH = 3;

    public final static int SOTETSEG_DEATH_ANIMATION_LENGTH = 3;
    public final static int MAIDEN_DEATH_ANIMATION_LENGTH = 7;

    public static final int FULL_HP = 1000;
    public final static int LOBBY_REGION = 14642;
    public final static int MAIDEN_REGION = 12613;
    public final static int  BLOAT_REGION = 13125;
    public final static int  NYLO_REGION = 13122;
    public final static int  SOTETSEG_REGION = 13123;
    public final static int  SOTETSEG_UNDER_REGION = 13379;
    public final static int  XARPUS_REGION = 12612;
    public final static int  VERZIK_REGION = 12611;
    public final static int MAIDEN_THROWN_BLOOD_GRAPHIC_OBJECT = 1579;
    public final static int MAIDEN_BLOOD_THROW_ANIM = 8091;
    public final static int TBOW_PROJECTILE = 1120;
    public final static int ZCB_PROJECTILE = 1468;
    public final static int ZCB_SPEC_PROJECTILE = 1995;
    public final static int VENG_CAST = 8316;
    public final static int VENG_OTHER_CAST = 4411;
    public final static int VENG_GRAPHIC = 726;
    public final static int VENG_OTHER_GRAPHIC = 725;

    public final static int DWH_SPEC = 1378;
    //veng other 725

    public final static int MELEE_THRALL = 10886;
    public final static int RANGE_THRALL = 10883;
    public final static int MAGE_THRALL = 10880;
    public static final String EXIT_FLAG = "4";
    public static final int SPECTATE_FLAG = 98;



    public final static int MELEE_THRALL_ATTACK_ANIMATION = 5568;
    public final static int THRALL_CAST_ANIMATION = 8973;
    public final static int THRALL_CAST_GRAPHIC_MAGE = 1873;
    public final static int THRALL_CAST_GRAPHIC_RANGE = 1874;
    public final static int THRALL_CAST_GRAPHIC_MELEE = 1875;

    public final static int THRALL_PROJECTILE_RANGE = 1906;
    public final static int THRALL_PROJECTILE_MAGE = 1907;

    public final static int MAIDEN_P0 = 8360; // 8362 30-50 //8363 30-end //8360 start
    public final static int MAIDEN_P0_HM = 10822;
    public final static int MAIDEN_P0_SM = 10814;
    public final static int MAIDEN_P1 = 8361;
    public final static int MAIDEN_P1_HM = 10823;
    public final static int MAIDEN_P1_SM = 10815;
    public final static int MAIDEN_P2 = 8362;
    public final static int MAIDEN_P2_HM = 10824;
    public final static int MAIDEN_P2_SM = 10816;
    public final static int MAIDEN_P3 = 8363;
    public final static int MAIDEN_P3_HM = 10825;
    public final static int MAIDEN_P3_SM = 10817;

    public final static int MAIDEN_PRE_DEAD = 8364;
    public final static int MAIDEN_PRE_DEAD_HM = 10826;
    public final static int MAIDEN_PRE_DEAD_SM = 10818;
    public final static int MAIDEN_DEAD = 8365;
    public final static int MAIDEN_DEAD_HM = 10827;
    public final static int MAIDEN_DEAD_SM = 10819;
    public final static int MAIDEN_MATOMENOS = 8366;
    public final static int MAIDEN_MATOMENOS_HM = 10828;
    public final static int MAIDEN_MATOMENOS_SM = 10820;

    public final static int MAIDEN_BLOOD = 8367;
    public final static int MAIDEN_BLOOD_HM = 10829;
    public final static int MAIDEN_BLOOD_SM = 10821;

    public final static int MAIDEN_DEATH_ANIMATION = 8093;
    public final static int BLOAT = 8359;
    public final static int BLOAT_HM = 10813;
    public final static int BLOAT_SM = 10812;
    public final static int BLOAT_DEATH_ANIMATION_LENGTH = 3;

    public final static int BLOAT_DOWN_ANIMATION = 8082;
    public final static int BLOAT_DEATH_ANIMATION = 8085;

    public final static int POWERED_STAFF_ANIMATION = 1167;
    public final static int DAWNBRINGER_AUTO_PROJECTILE = 1544;
    public final static int DAWNBRINGER_SPEC_PROJECTILE = 1547;
    public final static int NYLO_PILLAR = 8358;
    public final static int NYLO_PILLAR_HM = 10811;
    public final static int NYLO_PILLAR_SM = 10790;
    public final static int NYLO_MELEE_SMALL = 8342;
    public final static int NYLO_MELEE_SMALL_HM = 10791;
    public final static int NYLO_MELEE_SMALL_SM = 10774;
    public final static int UNCHARGED_SCYTHE = 22486;
    public final static int UNCHARGED_BLOOD_SCYTHE = 25738;
    public final static int UNCHARGED_HOLY_SCYTHE = 25741;

    public final static int SOTETSEG_RAGGED_TILE = 505;
    public final static int SOTETSEG_RED_TILE = 33035;
    public final static int MAIDEN_AUTO_ANIMATION = 8092;
    public final static int DRAGON_WARHAMMER = 13576;
    public final static int DRAGON_WARHAMMER_ALTERNATE = 20785;
    public final static int BOP_ANIMATION = 401;
    public final static int WHACK_ANIMATION = 414;
    public final static int KODAI_WAND = 21006;
    public final static int KODAI_WAND_ALTERNATE = 23626;
    public final static int STAB_ANIMATION = 440;
    public final static int CHALLY = 23987;
    public final static int TWO_HAND_SWORD_SWING = 7045;
    public final static int BANDOS_GODSWORD = 11804;
    public final static int BANDOS_GODSWORD_OR = 20370;
    public final static int CROSSBOW_ANIMATION = 9168;
    public final static int BLOWPIPE_ANIMATION = 5061;
    public final static int BLOWPIPE_ANIMATION_OR = 10656;

    public final static int NYLO_MELEE_SMALL_AGRO = 8348;
    public final static int NYLO_MELEE_SMALL_AGRO_HM = 10797;
    public final static int NYLO_MELEE_SMALL_AGRO_SM = 10780;

    public final static int NYLO_RANGE_SMALL = 8343;
    public final static int NYLO_RANGE_SMALL_HM = 10792;
    public final static int NYLO_RANGE_SMALL_SM = 10775;

    public final static int NYLO_RANGE_SMALL_AGRO = 8349;
    public final static int NYLO_RANGE_SMALL_AGRO_HM = 10798;
    public final static int NYLO_RANGE_SMALL_AGRO_SM = 10781;

    public final static int NYLO_MAGE_SMALL = 8344;
    public final static int NYLO_MAGE_SMALL_HM = 10793;
    public final static int NYLO_MAGE_SMALL_SM = 10776;

    public final static int NYLO_MAGE_SMALL_AGRO = 8350;
    public final static int NYLO_MAGE_SMALL_AGRO_HM = 10799;
    public final static int NYLO_MAGE_SMALL_AGRO_SM = 10782;

    public final static int NYLO_MELEE_BIG = 8345;
    public final static int NYLO_MELEE_BIG_HM = 10794;
    public final static int NYLO_MELEE_BIG_SM = 10777;

    public final static int NYLO_MELEE_BIG_AGRO = 8351;
    public final static int NYLO_MELEE_BIG_AGRO_HM = 10800;
    public final static int NYLO_MELEE_BIG_AGRO_SM = 10783;

    public final static int NYLO_RANGE_BIG = 8346;
    public final static int NYLO_RANGE_BIG_HM = 10795;
    public final static int NYLO_RANGE_BIG_SM = 10778;

    public final static int NYLO_RANGE_BIG_AGRO = 8352;
    public final static int NYLO_RANGE_BIG_AGRO_HM = 10801;
    public final static int NYLO_RANGE_BIG_AGRO_SM = 10784;

    public final static int NYLO_MAGE_BIG = 8347;
    public final static int NYLO_MAGE_BIG_HM = 10796;
    public final static int NYLO_MAGE_BIG_SM = 10779;

    public final static int NYLO_MAGE_BIG_AGRO = 8353;
    public final static int NYLO_MAGE_BIG_AGRO_HM = 10802;
    public final static int NYLO_MAGE_BIG_AGRO_SM = 10785;

    public final static int NYLO_BOSS_DROPPING = 8354;
    public final static int NYLO_BOSS_DROPPING_HM = 10807;
    public final static int NYLO_BOSS_DROPING_SM = 10786;

    public final static int NYLO_BOSS_MELEE = 8355;
    public final static int NYLO_BOSS_MELEE_HM = 10808;
    public final static int NYLO_BOSS_MELEE_SM = 10787;

    public final static int NYLO_BOSS_MAGE = 8356;
    public final static int NYLO_BOSS_MAGE_HM = 10809;
    public final static int NYLO_BOSS_MAGE_SM = 10788;

    public final static int NYLO_BOSS_RANGE = 8357;
    public final static int NYLO_BOSS_RANGE_HM = 10810;
    public final static int NYLO_BOSS_RANGE_SM = 10789;

    public final static int NYLO_PRINKIPAS_DROPPING = 10803;
    public final static int NYLO_PRINKIPAS_MELEE = 10804;
    public final static int NYLO_PRINKIPAS_MAGIC = 10805;
    public final static int NYLO_PRINKIPAS_RANGE = 10806;

    public final static int SOTETSEG_OVERWORLD = 13123;
    public final static int SOTETSEG_UNDERWORLD = 13379;
    public final static int SOTETSEG_DEATH_ANIMATION = 8140;

    public final static int SOTETSEG_ACTIVE = 8388;
    public final static int SOTETSEG_ACTIVE_HM = 10868;
    public final static int SOTETSEG_ACTIVE_SM = 10865;

    public final static int SOTETSEG_INACTIVE = 8387;
    public final static int SOTETSEG_INACTIVE_HM = 10867;
    public final static int SOTETSEG_INACTIVE_SM = 10864;

    public final static int XARPUS_AWAKENS = 8061;
    public final static int XARPUS_DEATH_ANIMATION = 8063;
    public final static int XARPUS_EXHUMED_PROJECTILE = 1550;

    public final static int XARPUS_INACTIVE = 8338;
    public final static int XARPUS_INACTIVE_HM = 10770;
    public final static int XARPUS_INACTIVE_SM = 10766;

    public final static int XARPUS_P1 = 8339;
    public final static int XARPUS_P1_HM = 10771;
    public final static int XARPUS_P1_SM = 10767;

    public final static int XARPUS_P23 = 8340;
    public final static int XARPUS_P23_HM = 10772;
    public final static int XARPUS_P23_SM = 10768;

    public final static int XARPUS_DEAD = 8341;
    public final static int XARPUS_DEAD_HM = 10773;
    public final static int XARPUS_DEAD_SM = 10769;

    public final static int VERZIK_MATOMENOS = 8385;
    public final static int VERZIK_MATOMENOS_HM = 10862;
    public final static int VERZIK_MATOMENOS_SM = 10845;

    public final static int VERZIK_MELEE_NYLO = 8381;
    public final static int VERZIK_MELEE_NYLO_HM = 10858;
    public final static int VERZIK_MELEE_NYLO_SM = 10841;

    public final static int VERZIK_RANGE_NYLO = 8382;
    public final static int VERZIK_RANGE_NYLO_HM = 10859;
    public final static int VERZIK_RANGE_NYLO_SM = 10842;

    public final static int VERZIK_MAGE_NYLO = 8383;
    public final static int VERZIK_MAGE_NYLO_HM = 10860;
    public final static int VERZIK_MAGE_NYLO_SM = 10843;

    public final static int VERZIK_BOUNCE_SPOT_ANIMATION = 245;
    public final static int VERZIK_BECOMES_SPIDER = 8128;

    public final static int VERZIK_P1_INACTIVE = 8369;
    public final static int VERZIK_P1_INACTIVE_HM = 10847;
    public final static int VERZIK_P1_INACTIVE_SM = 10830;

    public final static int VERZIK_P1 = 8370;
    public final static int VERZIK_P1_HM = 10848;
    public final static int VERZIK_P1_SM = 10831;

    public final static int VERZIK_P2_INACTIVE = 8371;
    public final static int VERZIK_P2_INACTIVE_HM = 10849;
    public final static int VERZIK_P2_INACTIVE_SM = 10832;

    public final static int VERZIK_P2 = 8372;
    public final static int VERZIK_P2_HM = 10850;
    public final static int VERZIK_P2_SM = 10833;

    public final static int VERZIK_P3_INACTIVE = 8373;
    public final static int VERZIK_P3_INACTIVE_HM = 10851;
    public final static int VERZIK_P3_INACTIVE_SM = 10834;

    public final static int VERZIK_P3 = 8374;
    public final static int VERZIK_P3_HM = 10852;
    public final static int VERZIK_P3_SM = 10835;
    public final static int VERZIK_DEAD = 8375;
    public final static int VERZIK_DEAD_HM = 10853;
    public final static int VERZIK_DEAD_SM = 10836;
}

package com.advancedraidtracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AdvancedRaidTrackerPluginTest
{
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(AdvancedRaidTrackerPlugin.class);
        RuneLite.main(args);
    }
}
