package com.presencechecker;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.Timer;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.plaf.basic.BasicScrollBarUI;
import net.runelite.api.FriendsChatMember;
import net.runelite.api.FriendsChatRank;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

public class PresenceCheckerPanel extends PluginPanel
{
    private final JPanel contentPanel = new JPanel();
    private final ConfigManager configManager;
    private final PresenceCheckerConfig config;
    private final JPanel tutorialContainer = new JPanel(new BorderLayout());
    private final JPanel missingListContainer = new JPanel();
    private final List<String> currentMissingText = new ArrayList<>();
    private final JButton copyMissingButton = new JButton("Copy All");
    private final JButton clearMissingButton = new JButton("Clear Names");
    private final JButton refreshButton = new JButton("Refresh");
    private final JPanel suspiciousListContainer = new JPanel();
    private final List<String> currentSuspiciousText = new ArrayList<>();
    private final JButton copySuspiciousButton = new JButton("Copy Names");
    private final JButton clearSuspiciousButton = new JButton("Clear Names");
    private final JScrollPane scrollPane;
    private Runnable refreshAction;
    private Runnable clearSuspiciousAction;

    @Inject
    public PresenceCheckerPanel(ConfigManager configManager, PresenceCheckerConfig config)
    {
        super(false);
        this.configManager = configManager;
        this.config = config;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        contentPanel.setLayout(new GridBagLayout());
        contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.insets = new Insets(0, 0, 0, 0);

        c.gridy = 0;
        c.insets = new Insets(0, 0, 15, 0);
        tutorialContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        contentPanel.add(tutorialContainer, c);
        rebuildTutorialPanel();

        c.gridy = 1;
        c.insets = new Insets(0, 0, 0, 0);
        contentPanel.add(createSuspiciousHeader(), c);

        suspiciousListContainer.setLayout(new GridBagLayout());
        suspiciousListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

        c.gridy = 2;
        c.insets = new Insets(0, 0, 15, 0);
        contentPanel.add(suspiciousListContainer, c);

        JPanel divider = new JPanel(new BorderLayout());
        divider.setBackground(ColorScheme.DARK_GRAY_COLOR);
        JPanel line = new JPanel();
        line.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        line.setPreferredSize(new Dimension(0, 1));
        divider.add(line, BorderLayout.CENTER);

        c.gridy = 3;
        c.insets = new Insets(0, 0, 15, 0);
        contentPanel.add(divider, c);

        c.gridy = 4;
        c.insets = new Insets(0, 0, 0, 0);
        contentPanel.add(createMissingHeader(), c);

        missingListContainer.setLayout(new GridBagLayout());
        missingListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

        c.gridy = 5;
        contentPanel.add(missingListContainer, c);

        JPanel filler = new JPanel();
        filler.setBackground(ColorScheme.DARK_GRAY_COLOR);

        c.gridy = 6;
        c.weighty = 1;
        c.fill = GridBagConstraints.BOTH;
        contentPanel.add(filler, c);

        scrollPane = new JScrollPane(contentPanel);
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setVerticalScrollBar(new DarkScrollBar());

        add(scrollPane, BorderLayout.CENTER);

        addDefaultMessage(suspiciousListContainer, "No recent suspicious activity.");
        addDefaultMessage(missingListContainer, "Run ::absent or Refresh.");
        updateButtonsState();
    }

    private void rebuildTutorialPanel()
    {
        tutorialContainer.removeAll();
        if (config.showPanelTutorial()) tutorialContainer.add(createExpandedTutorial());
        else tutorialContainer.add(createCollapsedTutorial());
        tutorialContainer.revalidate();
        tutorialContainer.repaint();
    }

    private JPanel createExpandedTutorial()
    {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR));

        JPanel header = new JPanel(new BorderLayout());
        header.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        header.setBorder(new EmptyBorder(5, 8, 5, 5));

        JLabel title = new JLabel("Plugin Guide");
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setForeground(Color.WHITE);

        JButton minimizeBtn = createIconButton("-", "Minimize guide");
        minimizeBtn.addActionListener(e -> {
            configManager.setConfiguration("presencechecker", "showPanelTutorial", false);
            rebuildTutorialPanel();
        });

        header.add(title, BorderLayout.CENTER);
        header.add(minimizeBtn, BorderLayout.EAST);

        JPanel body = new JPanel(new GridBagLayout());
        body.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        body.setBorder(new EmptyBorder(0, 8, 8, 8));

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(0, 0, 8, 0);

        body.add(createHelpTextHTML("<b>Welcome!</b><br>This tool helps you track Friends Chat attendance and detect potential spies."), c);

        c.gridy++;
        body.add(createHelpTextHTML("<br><b>1. Missing Members (Presence)</b><br>Identifies Friends Chat Members who are logged in but <u>not nearby</u>.<br><br>• <b>How:</b> Click 'Refresh' below or type <code>::absent</code>.<br><div style='margin-top: 4px'>• <b>Use Case:</b> Verifying everyone has arrived at a raid lobby, drop party, or boss mass.</div>"), c);

        c.gridy++;
        body.add(createHelpTextHTML("<br><b>2. Suspicious Activity (Anti-Scout)</b><br>Automatically detects players who join and leave the chat very quickly.<br><br>• <b>How:</b> It runs passively. Names appear in the list above.<br><div style='margin-top: 4px'>• <b>Use Case:</b> Spotting enemy scouts hopping in and out of friends chats to find mass worlds and disrupt events.</div>"), c);

        c.gridy++;
        body.add(createHelpTextHTML("<br><b>3. Configuration</b><br>Open the Plugin Settings, search 'presence checker', and click the gear icon to 'edit plugin configuration' to adjust:<br><div style='margin-top: 6px'>• Adjust the suspicion timer (milliseconds).</div>• Hide specific ranks you don't want showing up in the detection lists (e.g. Generals).<br>• Change highlight colors."), c);

        panel.add(header, BorderLayout.NORTH);
        panel.add(body, BorderLayout.CENTER);
        return panel;
    }

    private JPanel createCollapsedTutorial()
    {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR));

        JPanel header = new JPanel(new BorderLayout());
        header.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        header.setBorder(new EmptyBorder(5, 8, 5, 5));

        JLabel title = new JLabel("Plugin Guide");
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setForeground(Color.GRAY);

        JButton expandBtn = createIconButton("+", "Expand guide");
        expandBtn.addActionListener(e -> {
            configManager.setConfiguration("presencechecker", "showPanelTutorial", true);
            rebuildTutorialPanel();
        });

        header.add(title, BorderLayout.CENTER);
        header.add(expandBtn, BorderLayout.EAST);
        panel.add(header, BorderLayout.CENTER);
        return panel;
    }

    private JButton createIconButton(String text, String tooltip)
    {
        JButton btn = new JButton(text);
        btn.setPreferredSize(new Dimension(20, 20));
        btn.setFont(FontManager.getRunescapeSmallFont());
        btn.setForeground(Color.LIGHT_GRAY);
        btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        btn.setBorder(null);
        btn.setFocusPainted(false);
        btn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        btn.setToolTipText(tooltip);
        btn.addMouseListener(new MouseAdapter() {
            public void mouseEntered(MouseEvent e) { btn.setForeground(Color.WHITE); }
            public void mouseExited(MouseEvent e) { btn.setForeground(Color.LIGHT_GRAY); }
        });
        return btn;
    }

    private JLabel createHelpTextHTML(String htmlBody)
    {
        JLabel label = new JLabel("<html><body style='width: 150px'>" + htmlBody + "</body></html>");
        label.setFont(FontManager.getRunescapeSmallFont());
        label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        return label;
    }

    private JPanel createSuspiciousHeader()
    {
        JPanel panel = new JPanel(new BorderLayout(0, 8));
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(0, 0, 5, 0));
        JLabel title = new JLabel("Suspicious Activity");
        title.setForeground(Color.ORANGE);
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setHorizontalAlignment(JLabel.CENTER);
        JPanel btnPanel = new JPanel(new GridLayout(1, 2, 8, 0));
        btnPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        styleButton(copySuspiciousButton);
        copySuspiciousButton.addActionListener(e -> copyToClipboard(currentSuspiciousText, copySuspiciousButton));
        styleButton(clearSuspiciousButton);
        clearSuspiciousButton.addActionListener(e -> { if (clearSuspiciousAction != null) clearSuspiciousAction.run(); });
        btnPanel.add(copySuspiciousButton);
        btnPanel.add(clearSuspiciousButton);
        panel.add(title, BorderLayout.NORTH);
        panel.add(btnPanel, BorderLayout.SOUTH);
        return panel;
    }

    private JPanel createMissingHeader()
    {
        JPanel panel = new JPanel(new BorderLayout(0, 8));
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(0, 0, 5, 0));
        JLabel title = new JLabel("Missing Members");
        title.setForeground(Color.WHITE);
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setHorizontalAlignment(JLabel.CENTER);
        JPanel btnContainer = new JPanel(new BorderLayout(0, 4));
        btnContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        styleButton(refreshButton);
        refreshButton.setToolTipText("Re-check for missing members");
        refreshButton.addActionListener(e -> { if (refreshAction != null) refreshAction.run(); });
        JPanel subBtnPanel = new JPanel(new GridLayout(1, 2, 4, 0));
        subBtnPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        styleButton(copyMissingButton);
        copyMissingButton.addActionListener(e -> copyToClipboard(currentMissingText, copyMissingButton));
        styleButton(clearMissingButton);
        clearMissingButton.addActionListener(e -> clearMissingList());
        subBtnPanel.add(copyMissingButton);
        subBtnPanel.add(clearMissingButton);
        btnContainer.add(refreshButton, BorderLayout.NORTH);
        btnContainer.add(subBtnPanel, BorderLayout.CENTER);
        panel.add(title, BorderLayout.NORTH);
        panel.add(btnContainer, BorderLayout.SOUTH);
        return panel;
    }

    public void setRefreshAction(Runnable action) { this.refreshAction = action; }
    public void setClearSuspiciousAction(Runnable action) { this.clearSuspiciousAction = action; }

    private void styleButton(JButton btn)
    {
        btn.setFocusable(false);
        btn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        btn.setForeground(Color.WHITE);
        btn.setFont(FontManager.getRunescapeSmallFont());
        btn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        btn.setBorder(new EmptyBorder(6, 6, 6, 6));
    }

    private void updateButtonsState()
    {
        boolean hasMissing = !currentMissingText.isEmpty();
        copyMissingButton.setEnabled(hasMissing);
        clearMissingButton.setEnabled(hasMissing);
        copyMissingButton.setText(hasMissing ? "Copy (" + currentMissingText.size() + ")" : "Copy All");

        boolean hasSuspicious = !currentSuspiciousText.isEmpty();
        copySuspiciousButton.setEnabled(hasSuspicious);
        clearSuspiciousButton.setEnabled(hasSuspicious);
        copySuspiciousButton.setText(hasSuspicious ? "Copy (" + currentSuspiciousText.size() + ")" : "Copy Names");
    }

    private void clearMissingList()
    {
        missingListContainer.removeAll();
        currentMissingText.clear();
        addDefaultMessage(missingListContainer, "Run ::absent or Refresh.");
        updateButtonsState();
        revalidateContainer(missingListContainer);
    }

    public void updateMissingList(List<FriendsChatMember> members)
    {
        missingListContainer.removeAll();
        currentMissingText.clear();
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(0, 0, 5, 0);

        if (members.isEmpty()) addDefaultMessage(missingListContainer, "No missing members.");
        else
        {
            for (FriendsChatMember member : members)
            {
                String rankPrefix = getRankPrefix(member.getRank());
                String displayText = rankPrefix + member.getName();
                currentMissingText.add(displayText);
                missingListContainer.add(createRow(displayText, !rankPrefix.isEmpty()), c);
                c.gridy++;
            }
        }
        updateButtonsState();
        revalidateContainer(missingListContainer);
    }

    public void updateSuspiciousList(List<String> names)
    {
        suspiciousListContainer.removeAll();
        currentSuspiciousText.clear();
        currentSuspiciousText.addAll(names);
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        c.insets = new Insets(0, 0, 5, 0);

        if (names.isEmpty()) addDefaultMessage(suspiciousListContainer, "No recent suspicious activity.");
        else
        {
            for (String name : names)
            {
                suspiciousListContainer.add(createRow(name, false), c);
                c.gridy++;
            }
        }
        updateButtonsState();
        revalidateContainer(suspiciousListContainer);
    }

    private void revalidateContainer(JPanel panel) { panel.revalidate(); panel.repaint(); }

    private void copyToClipboard(List<String> textList, JButton button)
    {
        if (textList.isEmpty()) return;
        String clipboardString = String.join("\n", textList);
        StringSelection stringSelection = new StringSelection(clipboardString);
        Toolkit.getDefaultToolkit().getSystemClipboard().setContents(stringSelection, null);
        String originalText = button.getText();
        button.setText("Copied!");
        Timer timer = new Timer(2000, e -> button.setText(originalText));
        timer.setRepeats(false);
        timer.start();
    }

    private void addDefaultMessage(JPanel container, String message)
    {
        container.removeAll();
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        JLabel emptyLabel = new JLabel(message);
        emptyLabel.setForeground(Color.GRAY);
        emptyLabel.setHorizontalAlignment(JLabel.CENTER);
        emptyLabel.setBorder(new EmptyBorder(10, 0, 10, 0));
        container.add(emptyLabel, c);
    }

    private JPanel createRow(String text, boolean hasRank)
    {
        JPanel row = new JPanel(new BorderLayout());
        row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        row.setBorder(new EmptyBorder(8, 8, 8, 8));
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        label.setFont(FontManager.getRunescapeSmallFont());
        if (hasRank) label.setForeground(Color.ORANGE);
        row.add(label, BorderLayout.WEST);
        row.addMouseListener(new MouseAdapter() {
            public void mouseEntered(MouseEvent e) { row.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR); }
            public void mouseExited(MouseEvent e) { row.setBackground(ColorScheme.DARKER_GRAY_COLOR); }
        });
        return row;
    }

    private String getRankPrefix(FriendsChatRank rank)
    {
        if (rank == null) return "";
        switch (rank)
        {
            case OWNER: return "[Owner] ";
            case GENERAL: return "[Gen] ";
            case CAPTAIN: return "[Capt] ";
            case LIEUTENANT: return "[Lt] ";
            case SERGEANT: return "[Sgt] ";
            case CORPORAL: return "[Corp] ";
            case RECRUIT: return "[Rec] ";
            case FRIEND: return "[Friend] ";
            default: return "";
        }
    }

    private static class DarkScrollBar extends JScrollBar
    {
        public DarkScrollBar() { setUI(new DarkScrollBarUI()); setPreferredSize(new Dimension(8, 0)); setForeground(ColorScheme.MEDIUM_GRAY_COLOR); setBackground(ColorScheme.DARK_GRAY_COLOR); }
        public void updateUI() { setUI(new DarkScrollBarUI()); }
    }

    private static class DarkScrollBarUI extends BasicScrollBarUI
    {
        private static final Color TRACK_COLOR = ColorScheme.DARK_GRAY_COLOR;
        private static final Color THUMB_COLOR = ColorScheme.MEDIUM_GRAY_COLOR;
        private static final Color THUMB_HOVER_COLOR = ColorScheme.LIGHT_GRAY_COLOR;
        protected void configureScrollBarColors() { this.thumbColor = THUMB_COLOR; this.trackColor = TRACK_COLOR; }
        protected JButton createDecreaseButton(int orientation) { return createZeroButton(); }
        protected JButton createIncreaseButton(int orientation) { return createZeroButton(); }
        private JButton createZeroButton() { JButton btn = new JButton(); btn.setPreferredSize(new Dimension(0, 0)); return btn; }
        protected void paintTrack(Graphics g, JComponent c, Rectangle trackBounds) { g.setColor(TRACK_COLOR); g.fillRect(trackBounds.x, trackBounds.y, trackBounds.width, trackBounds.height); }
        protected void paintThumb(Graphics g, JComponent c, Rectangle thumbBounds) { if (thumbBounds.isEmpty() || !scrollbar.isEnabled()) return; Graphics2D g2 = (Graphics2D) g.create(); g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); g2.setColor(isDragging ? THUMB_HOVER_COLOR : THUMB_COLOR); g2.fillRoundRect(thumbBounds.x, thumbBounds.y, thumbBounds.width, thumbBounds.height, 8, 8); g2.dispose(); }
    }
}
package com.presencechecker;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Notification;
import net.runelite.client.config.Range;

@ConfigGroup("presencechecker")
public interface PresenceCheckerConfig extends Config
{
    // --- SECTIONS ---

    @ConfigSection(
            name = "General Settings",
            description = "General configuration for highlighting.",
            position = 0,
            closedByDefault = true
    )
    String generalSettings = "generalSettings";

    @ConfigSection(
            name = "Chat Filter",
            description = "Options to filter which members are shown in the missing list.",
            position = 1,
            closedByDefault = true
    )
    String chatFilter = "chatFilter";

    @ConfigSection(
            name = "Overlay Settings",
            description = "Configuration for the screen overlay HUD.",
            position = 2,
            closedByDefault = true
    )
    String overlaySettings = "overlaySettings";

    @ConfigSection(
            name = "Suspicious Activity",
            description = "Tracker for players quickly joining and leaving.",
            position = 3,
            closedByDefault = true
    )
    String suspiciousSettings = "suspiciousSettings";

    // --- HIDDEN CONFIGS ---

    @ConfigItem(
            keyName = "showPanelTutorial",
            name = "Show Tutorial",
            description = "Whether to show the help tutorial in the panel.",
            hidden = true
    )
    default boolean showPanelTutorial() { return true; }

    // --- GENERAL SETTINGS ---

    @ConfigItem(
            keyName = "highlightColor",
            name = "Highlight Color",
            description = "The color to highlight missing members in the clan chat list.",
            position = 1,
            section = generalSettings
    )
    default Color getHighlightColor()
    {
        return new Color(128, 0, 128); // Default Purple
    }

    @ConfigItem(
            keyName = "highlightDuration",
            name = "Highlight Duration",
            description = "How many seconds to keep names highlighted before letting them revert (0 to disable).",
            position = 2,
            section = generalSettings
    )
    default int highlightDuration()
    {
        return 10; // Default 10 seconds
    }

    // --- CHAT FILTER SECTION ---

    @ConfigItem(
            keyName = "filterSelf",
            name = "Exclude Self",
            description = "If enabled, do not list yourself in the missing members list.",
            position = 0,
            section = chatFilter
    )
    default boolean filterSelf()
    {
        return true;
    }

    @ConfigItem(
            keyName = "hideOwner",
            name = "Hide Owners",
            description = "Do not show missing Owners in the list.",
            position = 1,
            section = chatFilter
    )
    default boolean hideOwner() { return false; }

    @ConfigItem(
            keyName = "hideGeneral",
            name = "Hide Generals",
            description = "Do not show missing Generals in the list.",
            position = 2,
            section = chatFilter
    )
    default boolean hideGeneral() { return false; }

    @ConfigItem(
            keyName = "hideCaptain",
            name = "Hide Captains",
            description = "Do not show missing Captains in the list.",
            position = 3,
            section = chatFilter
    )
    default boolean hideCaptain() { return false; }

    @ConfigItem(
            keyName = "hideLieutenant",
            name = "Hide Lieutenants",
            description = "Do not show missing Lieutenants in the list.",
            position = 4,
            section = chatFilter
    )
    default boolean hideLieutenant() { return false; }

    @ConfigItem(
            keyName = "hideSergeant",
            name = "Hide Sergeants",
            description = "Do not show missing Sergeants in the list.",
            position = 5,
            section = chatFilter
    )
    default boolean hideSergeant() { return false; }

    @ConfigItem(
            keyName = "hideCorporal",
            name = "Hide Corporals",
            description = "Do not show missing Corporals in the list.",
            position = 6,
            section = chatFilter
    )
    default boolean hideCorporal() { return false; }

    @ConfigItem(
            keyName = "hideRecruit",
            name = "Hide Recruits",
            description = "Do not show missing Recruits in the list.",
            position = 7,
            section = chatFilter
    )
    default boolean hideRecruit() { return false; }

    @ConfigItem(
            keyName = "hideFriend",
            name = "Hide Friends",
            description = "Do not show missing Friends in the list.",
            position = 8,
            section = chatFilter
    )
    default boolean hideFriend() { return false; }

    @ConfigItem(
            keyName = "hideGuest",
            name = "Hide Guests",
            description = "Do not show missing Guests (Unranked) in the list.",
            position = 9,
            section = chatFilter
    )
    default boolean hideGuest() { return false; }

    // --- OVERLAY SETTINGS SECTION ---

    @ConfigItem(
            keyName = "enableOverlay",
            name = "Enable Overlay",
            description = "Show a HUD overlay on screen with the count of missing members.",
            position = 0,
            section = overlaySettings
    )
    default boolean enableOverlay()
    {
        return true;
    }

    @ConfigItem(
            keyName = "showOverlayNames",
            name = "Show Names in Overlay",
            description = "List the names of missing members in the overlay if the count is low.",
            position = 1,
            section = overlaySettings
    )
    default boolean showOverlayNames() { return true; }

    @ConfigItem(
            keyName = "overlayNamesLimit",
            name = "Overlay Names Limit",
            description = "Maximum number of names to show in the overlay before switching to count only.",
            position = 2,
            section = overlaySettings
    )
    default int overlayNamesLimit() { return 5; }

    // --- SUSPICIOUS ACTIVITY SECTION ---

    @ConfigItem(
            keyName = "enableSuspiciousTracking",
            name = "Enable Tracking",
            description = "Turn the suspicious activity tracking on or off.",
            position = 0,
            section = suspiciousSettings
    )
    default boolean enableSuspiciousTracking() { return true; }

    @Range(
            min = 100,
            max = 10000
    )
    @ConfigItem(
            keyName = "suspiciousThreshold",
            name = "Suspicious Time (ms)",
            description = "If a user joins and leaves within this many milliseconds, they are flagged.",
            position = 1,
            section = suspiciousSettings
    )
    default int suspiciousThreshold() { return 4000; }

    @ConfigItem(
            keyName = "susHideOwner",
            name = "Hide Owners",
            description = "Do not flag Owners as suspicious.",
            position = 2,
            section = suspiciousSettings
    )
    default boolean susHideOwner() { return true; }

    @ConfigItem(
            keyName = "susHideGeneral",
            name = "Hide Generals",
            description = "Do not flag Generals as suspicious.",
            position = 3,
            section = suspiciousSettings
    )
    default boolean susHideGeneral() { return true; }

    @ConfigItem(
            keyName = "susHideCaptain",
            name = "Hide Captains",
            description = "Do not flag Captains as suspicious.",
            position = 4,
            section = suspiciousSettings
    )
    default boolean susHideCaptain() { return true; }

    @ConfigItem(
            keyName = "susHideLieutenant",
            name = "Hide Lieutenants",
            description = "Do not flag Lieutenants as suspicious.",
            position = 5,
            section = suspiciousSettings
    )
    default boolean susHideLieutenant() { return true; }

    @ConfigItem(
            keyName = "susHideSergeant",
            name = "Hide Sergeants",
            description = "Do not flag Sergeants as suspicious.",
            position = 6,
            section = suspiciousSettings
    )
    default boolean susHideSergeant() { return true; }

    @ConfigItem(
            keyName = "susHideCorporal",
            name = "Hide Corporals",
            description = "Do not flag Corporals as suspicious.",
            position = 7,
            section = suspiciousSettings
    )
    default boolean susHideCorporal() { return false; }

    @ConfigItem(
            keyName = "susHideRecruit",
            name = "Hide Recruits",
            description = "Do not flag Recruits as suspicious.",
            position = 8,
            section = suspiciousSettings
    )
    default boolean susHideRecruit() { return false; }

    @ConfigItem(
            keyName = "susHideFriend",
            name = "Hide Friends",
            description = "Do not flag Friends as suspicious.",
            position = 9,
            section = suspiciousSettings
    )
    default boolean susHideFriend() { return false; }

    @ConfigItem(
            keyName = "susHideGuest",
            name = "Hide Guests",
            description = "Do not flag Guests (Unranked) as suspicious.",
            position = 10,
            section = suspiciousSettings
    )
    default boolean susHideGuest() { return false; }

    @ConfigItem(
            keyName = "suspiciousWarningThreshold",
            name = "Warning Threshold",
            description = "Number of times a user must be flagged before sending a chat warning (0 to disable).",
            position = 11,
            section = suspiciousSettings
    )
    default int suspiciousWarningThreshold() { return 3; }

    @ConfigItem(
            keyName = "suspiciousWarningColor",
            name = "Warning Message Color",
            description = "Color of the chat warning when a user hits the suspicious threshold.",
            position = 12,
            section = suspiciousSettings
    )
    default Color suspiciousWarningColor() { return Color.RED; }

    // --- NOTIFICATION OPTION ---
    @ConfigItem(
            keyName = "suspiciousNotification",
            name = "Suspicious Alert",
            description = "Customize the notification (Tray, Sound, Flash) for suspicious activity.",
            position = 13,
            section = suspiciousSettings
    )
    default Notification suspiciousNotification()
    {
        return Notification.OFF;
    }

    // --- WHITELIST ---
    @ConfigItem(
            keyName = "friendlyWhitelist",
            name = "Friendly Whitelist",
            description = "Enter names to NEVER flag as suspicious (comma or newline separated).",
            position = 14,
            section = suspiciousSettings
    )
    default String friendlyWhitelist()
    {
        return "";
    }

    // --- BLACKLIST ---
    @ConfigItem(
            keyName = "blacklistedNames",
            name = "Enemy Blacklist",
            description = "Enter names to INSTANTLY alert on join (comma or newline separated).",
            position = 15,
            section = suspiciousSettings
    )
    default String blacklistedNames()
    {
        return "";
    }
}
package com.presencechecker;

import com.google.inject.Provides;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.FriendsChatMember;
import net.runelite.api.FriendsChatRank;
import net.runelite.api.WorldView;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.FriendsChatMemberJoined;
import net.runelite.api.events.FriendsChatMemberLeft;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@PluginDescriptor(
        name = "Presence Checker",
        description = "Checks which Friends Chat members are currently in the vicinity",
        tags = {"presence", "clan", "check","pvp","scout","fc","friends chat",}
)
public class PresenceChecker extends Plugin
{
    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private PresenceCheckerConfig config;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private PresenceCheckerPanel panel;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private PresenceCheckerOverlay overlay;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private Notifier notifier;

    private NavigationButton navButton;
    private volatile List<FriendsChatMember> lastMissingMembers = Collections.emptyList();
    private ScheduledFuture<?> overlayTask;
    private long highlightStartTime = 0;
    private boolean isHighlighting = false;
    private final Map<String, Long> joinTimes = new HashMap<>();
    private final List<String> suspiciousDisplayList = new ArrayList<>();
    private final Map<String, Integer> suspiciousCounts = new HashMap<>();

    @Provides
    @SuppressWarnings("unused")
    PresenceCheckerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(PresenceCheckerConfig.class);
    }

    @Override
    @SuppressWarnings("unused")
    protected void startUp()
    {
        overlayManager.add(overlay);
        panel.setRefreshAction(this::checkPresence);
        panel.setClearSuspiciousAction(this::clearSuspiciousActivity);

        BufferedImage icon;
        try
        {
            icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
        }
        catch (Exception e)
        {
            icon = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g = icon.createGraphics();
            g.setColor(new Color(255, 120, 0));
            g.fillOval(2, 2, 28, 28);
            g.setColor(Color.WHITE);
            g.setFont(new java.awt.Font("Arial", java.awt.Font.BOLD, 14));
            g.drawString("PC", 6, 22);
            g.dispose();
        }

        navButton = NavigationButton.builder()
                .tooltip("Presence Checker")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);
        overlayTask = executor.scheduleAtFixedRate(this::backgroundScan, 5, 5, TimeUnit.SECONDS);
    }

    @Override
    protected void shutDown()
    {
        if (overlayTask != null)
        {
            overlayTask.cancel(false);
            overlayTask = null;
        }
        overlayManager.remove(overlay);
        clientToolbar.removeNavigation(navButton);
        joinTimes.clear();
        suspiciousDisplayList.clear();
        suspiciousCounts.clear();
    }

    @Subscribe
    public void onFriendsChatMemberJoined(FriendsChatMemberJoined event)
    {
        if (!config.enableSuspiciousTracking()) return;

        String name = Text.standardize(event.getMember().getName());

        // Check Blacklist
        if (isBlacklisted(name))
        {
            String msg = "BLACKLISTED PLAYER DETECTED: " + event.getMember().getName();
            sendChatMessage(ColorUtil.wrapWithColorTag(msg, Color.RED));
            notifier.notify("BLACKLISTED PLAYER: " + event.getMember().getName());
            addSuspiciousUser(event.getMember().getName(), 0);
            return;
        }

        if (shouldIgnoreSuspicious(event.getMember())) return;
        joinTimes.put(name, System.currentTimeMillis());
    }

    @Subscribe
    public void onFriendsChatMemberLeft(FriendsChatMemberLeft event)
    {
        if (!config.enableSuspiciousTracking()) return;
        if (shouldIgnoreSuspicious(event.getMember())) return;

        String name = Text.standardize(event.getMember().getName());
        Long joinTime = joinTimes.remove(name);

        if (joinTime != null)
        {
            long durationMs = System.currentTimeMillis() - joinTime;
            long thresholdMs = config.suspiciousThreshold();
            if (durationMs <= thresholdMs)
            {
                addSuspiciousUser(event.getMember().getName(), durationMs);
            }
        }
    }

    private void addSuspiciousUser(String rawName, long durationMs)
    {
        String displayText = rawName + " (" + durationMs + "ms)";
        suspiciousDisplayList.add(displayText);
        SwingUtilities.invokeLater(() -> panel.updateSuspiciousList(suspiciousDisplayList));

        String standardName = Text.standardize(rawName);
        int count = suspiciousCounts.getOrDefault(standardName, 0) + 1;
        suspiciousCounts.put(standardName, count);

        int threshold = config.suspiciousWarningThreshold();
        if (threshold > 0 && count >= threshold)
        {
            String msg = "WARNING: " + rawName + " Has been flagged Suspicious";
            sendChatMessage(ColorUtil.wrapWithColorTag(msg, config.suspiciousWarningColor()));
            notifier.notify(config.suspiciousNotification(), "Suspicious Activity Detected: " + rawName);
        }
    }

    private void clearSuspiciousActivity()
    {
        suspiciousDisplayList.clear();
        suspiciousCounts.clear();
        SwingUtilities.invokeLater(() -> panel.updateSuspiciousList(suspiciousDisplayList));
    }

    private boolean isBlacklisted(String name)
    {
        Set<String> blacklist = Text.fromCSV(config.blacklistedNames()).stream()
                .map(Text::standardize)
                .collect(Collectors.toSet());
        return blacklist.contains(name);
    }

    private boolean shouldIgnoreSuspicious(FriendsChatMember member)
    {
        String name = Text.standardize(member.getName());
        Set<String> whitelist = Text.fromCSV(config.friendlyWhitelist()).stream()
                .map(Text::standardize)
                .collect(Collectors.toSet());

        if (whitelist.contains(name)) return true;

        FriendsChatRank rank = member.getRank();
        switch (rank)
        {
            case OWNER: return config.susHideOwner();
            case GENERAL: return config.susHideGeneral();
            case CAPTAIN: return config.susHideCaptain();
            case LIEUTENANT: return config.susHideLieutenant();
            case SERGEANT: return config.susHideSergeant();
            case CORPORAL: return config.susHideCorporal();
            case RECRUIT: return config.susHideRecruit();
            case FRIEND: return config.susHideFriend();
            case UNRANKED: return config.susHideGuest();
            default: return config.susHideGuest();
        }
    }

    @Subscribe
    @SuppressWarnings("unused")
    public void onCommandExecuted(CommandExecuted commandExecuted)
    {
        if (commandExecuted.getCommand().equalsIgnoreCase("absent")) checkPresence();
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        if (lastMissingMembers == null || lastMissingMembers.isEmpty()) return;

        long durationMs = config.highlightDuration() * 1000L;
        long timeElapsed = System.currentTimeMillis() - highlightStartTime;

        if (timeElapsed < durationMs)
        {
            int highlightColor = config.getHighlightColor().getRGB() & 0xFFFFFF;
            setMemberColor(lastMissingMembers, highlightColor);
            isHighlighting = true;
        }
        else if (isHighlighting)
        {
            setMemberColor(lastMissingMembers, 0xFFFFFF);
            isHighlighting = false;
        }
    }

    private void backgroundScan()
    {
        clientThread.invokeLater(() -> lastMissingMembers = scanForMissingMembers());
    }

    public void checkPresence()
    {
        clientThread.invokeLater(() ->
        {
            FriendsChatManager friendsChatManager = client.getFriendsChatManager();
            if (friendsChatManager == null)
            {
                lastMissingMembers = Collections.emptyList();
                updatePanel(new ArrayList<>());
                return;
            }

            List<FriendsChatMember> missingMembersList = scanForMissingMembers();
            lastMissingMembers = missingMembersList;
            highlightStartTime = System.currentTimeMillis();
            isHighlighting = true;

            if (missingMembersList.isEmpty())
            {
                updatePanel(new ArrayList<>());
            }
            else
            {
                updatePanel(missingMembersList);
                int highlightColor = config.getHighlightColor().getRGB() & 0xFFFFFF;
                setMemberColor(missingMembersList, highlightColor);
            }
        });
    }

    private List<FriendsChatMember> scanForMissingMembers()
    {
        FriendsChatManager friendsChatManager = client.getFriendsChatManager();
        if (friendsChatManager == null) return Collections.emptyList();

        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null) return Collections.emptyList();

        List<String> localPlayerNames = worldView.players().stream()
                .map(p -> Text.standardize(p.getName()))
                .collect(Collectors.toList());

        String localName = client.getLocalPlayer() != null ? Text.standardize(client.getLocalPlayer().getName()) : "";
        List<FriendsChatMember> missing = new ArrayList<>();

        for (FriendsChatMember member : friendsChatManager.getMembers())
        {
            String ccMemberName = Text.standardize(member.getName());
            if (config.filterSelf() && ccMemberName.equals(localName)) continue;
            if (shouldHideRank(member.getRank())) continue;
            if (!localPlayerNames.contains(ccMemberName)) missing.add(member);
        }
        return missing;
    }

    @SuppressWarnings("unused")
    public int getMissingMembersCount() { return lastMissingMembers.size(); }

    @SuppressWarnings("unused")
    public List<FriendsChatMember> getMissingMembers() { return lastMissingMembers; }

    @SuppressWarnings("deprecation")
    private void setMemberColor(List<FriendsChatMember> members, int color)
    {
        Widget list = client.getWidget(ComponentID.FRIENDS_CHAT_LIST);
        if (list == null || list.getDynamicChildren() == null || list.isHidden()) return;

        Set<String> targetNames = members.stream()
                .map(m -> Text.standardize(m.getName()))
                .collect(Collectors.toSet());

        for (Widget child : list.getDynamicChildren())
        {
            String rawText = child.getText();
            String name = Text.standardize(Text.removeTags(rawText));
            if (targetNames.contains(name)) child.setTextColor(color);
        }
    }

    private boolean shouldHideRank(FriendsChatRank rank)
    {
        switch (rank)
        {
            case OWNER: return config.hideOwner();
            case GENERAL: return config.hideGeneral();
            case CAPTAIN: return config.hideCaptain();
            case LIEUTENANT: return config.hideLieutenant();
            case SERGEANT: return config.hideSergeant();
            case CORPORAL: return config.hideCorporal();
            case RECRUIT: return config.hideRecruit();
            case FRIEND: return config.hideFriend();
            case UNRANKED: return config.hideGuest();
            default: return config.hideGuest();
        }
    }

    private void updatePanel(List<FriendsChatMember> missingMembers)
    {
        SwingUtilities.invokeLater(() -> panel.updateMissingList(missingMembers));
    }

    private void sendChatMessage(String message)
    {
        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(message)
                        .build());
    }
}
package com.presencechecker;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.List;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.FriendsChatMember;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;

public class PresenceCheckerOverlay extends Overlay
{
    private final Client client;
    private final PresenceChecker plugin;
    private final PresenceCheckerConfig config;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    private PresenceCheckerOverlay(Client client, PresenceChecker plugin, PresenceCheckerConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.enableOverlay()) return null;
        if (client.getFriendsChatManager() == null) return null;

        List<FriendsChatMember> missingMembers = plugin.getMissingMembers();
        int missingCount = missingMembers.size();

        panelComponent.getChildren().clear();
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Missing Members:")
                .right(Integer.toString(missingCount))
                .rightColor(missingCount > 0 ? java.awt.Color.RED : java.awt.Color.WHITE)
                .build());

        if (config.showOverlayNames() && missingCount > 0 && missingCount <= config.overlayNamesLimit())
        {
            for (FriendsChatMember member : missingMembers)
            {
                panelComponent.getChildren().add(LineComponent.builder()
                        .left(member.getName())
                        .leftColor(java.awt.Color.WHITE)
                        .build());
            }
        }
        return panelComponent.render(graphics);
    }
}
package com.presencechecker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
// This import is required because your test file and main file are in different packages
import com.presencechecker.PresenceChecker;

public class PresenceCheckerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PresenceChecker.class);
		RuneLite.main(args);
	}
}
