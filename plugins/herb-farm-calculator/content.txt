package me.lucaspickering;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class HerbFarmCalculatorPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(HerbFarmCalculatorPlugin.class);
		RuneLite.main(args);
	}
}

package me.lucaspickering;

import com.google.inject.Provides;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;

@PluginDescriptor(name = "Herb Farming Calculator", tags = {"panel", "herb", "farming",
        "calculator"})
public class HerbFarmCalculatorPlugin extends Plugin {

    @Inject
    private Client client;
    @Inject
    ClientThread clientThread;
    @Inject
    private HerbFarmCalculatorConfig config;
    @Inject
    private ItemManager itemManager;
    @Inject
    private ClientToolbar clientToolbar;
    private NavigationButton uiNavigationButton;
    private HerbFarmCalculatorPanel uiPanel;
    private boolean refreshCalculator = false;

    @Override
    protected void startUp() throws Exception {
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "herb.png");
        final HerbFarmCalculator calculator = new HerbFarmCalculator(this.client, this.config, itemManager);
        this.uiPanel = new HerbFarmCalculatorPanel(this.client, this.clientThread,
                this.itemManager,
                this.config,
                calculator);

        this.uiNavigationButton = NavigationButton.builder()
                .tooltip("Herb Farming Calculator")
                .icon(icon)
                .priority(9)
                .panel(this.uiPanel)
                .build();

        clientToolbar.addNavigation(uiNavigationButton);
    }

    @Override
    protected void shutDown() throws Exception {
        this.clientToolbar.removeNavigation(this.uiNavigationButton);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
            // Refresh the panel when the player logs in, so we can grab all
            // their personal stats/buffs. We have to defer this until the first
            // game tick after login though, otherwise we don't actually get
            // full access to stats/diaries/etc.
            refreshCalculator = true;
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        // Run the calculator on first game tick after login
        if (refreshCalculator) {
            refreshCalculator = false;
            this.uiPanel.refreshPanel();
        }
    }

    @Provides
    HerbFarmCalculatorConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(HerbFarmCalculatorConfig.class);
    }
}

package me.lucaspickering;

import java.util.HashSet;
import java.util.Set;

import me.lucaspickering.utils.AnimaPlant;
import me.lucaspickering.utils.Compost;
import me.lucaspickering.utils.HerbPatch;
import me.lucaspickering.utils.SortingCriteria;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("herbFarmCalculator")
public interface HerbFarmCalculatorConfig extends Config {

  @ConfigItem(keyName = "patches", name = "Patches", description = "Which patches do you farm? Ctrl+click to select multiple")
  default Set<HerbPatch> patches() {
    return new HashSet<>();
  }

  @ConfigItem(keyName = "patches", name = "", description = "")
  void patches(Set<HerbPatch> patches);

  @ConfigItem(keyName = "useFarmingCape", name = "Farming cape", description = "Do you wear a Farming cape while harvesting herbs?")
  default boolean useFarmingCape() {
    return false;
  }

  @ConfigItem(keyName = "useMagicSecateurs", name = "Magic secateurs", description = "Do you equip Magic secateurs while harvesting herbs?")
  default boolean useMagicSecateurs() {
    return false;
  }

  @ConfigItem(keyName = "useBottomlessBucket", name = "Bottomless bucket", description = "Do you use a bottomless bucket?")
  default boolean useBottomlessBucket() {
    return false;
  }

  @ConfigItem(keyName = "useResurrectCrops", name = "Resurrect Crops", description = "Do you use the Resurrect Crops spell on dead herb patches?")
  default boolean useResurrectCrops() {
    return false;
  }

  @ConfigItem(keyName = "compost", name = "Compost", description = "What kind of compost do you use?")
  default Compost compost() {
    return Compost.NONE;
  }

  @ConfigItem(keyName = "animaPlant", name = "Anima Plant", description = "What kind of Anima plant do you have active?")
  default AnimaPlant animaPlant() {
    return AnimaPlant.NONE;
  }

  @ConfigSection(name = "Sorting", description = "Configure the order in which herbs are displayed on the panel.", position = 8)
  String sortingSection = "Sorting";

  @ConfigItem(keyName = "criteria", name = "Criteria", description = "What criteria should the output be ordered by?", section = sortingSection)
  default SortingCriteria criteria() {
    return SortingCriteria.Level;
  }

  @ConfigItem(keyName = "descending", name = "Descending", description = "Sort in descending order? (Highest first/ Z->A)", section = sortingSection)
  default boolean descending() {return false; }

}

package me.lucaspickering;

import lombok.extern.slf4j.Slf4j;
import me.lucaspickering.utils.Herb;
import me.lucaspickering.utils.HerbCalculatorResult;
import me.lucaspickering.utils.HerbPatchResult;
import me.lucaspickering.utils.HerbResult;
import me.lucaspickering.utils.SurvivalChance;
import me.lucaspickering.utils.Utils;
import me.lucaspickering.utils.HerbPatch;
import me.lucaspickering.utils.HerbPatchBuffs;
import me.lucaspickering.utils.SortingCriteria;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.api.Varbits;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.skillcalculator.skills.MagicAction;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
public class HerbFarmCalculator {

    private final Client client;
    private final HerbFarmCalculatorConfig config;
    private final ItemManager itemManager;

    public HerbFarmCalculator(Client client, HerbFarmCalculatorConfig config, ItemManager itemManager) {
        this.client = client;
        this.config = config;
        this.itemManager = itemManager;
    }

    /**
     * Run the calculator for every herb and return all the results in a nice list.
     *
     * @return The results, in a nice list
     */
    public HerbCalculatorResult calculate() {
        log.debug("Running herb calculator");

        // For each patch, figure out its patch-specific buffs. We do this up
        // front so we can render the buffs to the user clearly, separate from
        // the herb outputs
        List<HerbPatchBuffs> patches = this.config.patches().stream()
                .map(patch -> new HerbPatchBuffs(patch, patch.isDiseaseFree(this.client),
                        this.getDiaryChanceToSaveBonus(patch), this.getXpBonus(patch)))
                // Sort alphabetically, for easier reading on the UI
                .sorted(Comparator.comparing(patch -> patch.getPatch().getName()))
                .collect(Collectors.toList());

        // Sort according to criteria specified in the config
        Comparator<HerbResult> criteria = this.config.criteria().getComparator();

        // Sort in descending/Z->A order if enabled in the config
        if (this.config.descending()){
            criteria = criteria.reversed();
        }

        List<HerbResult> herbs = Arrays.stream(Herb.values()).map(herb -> this.calculateHerb(herb, patches))
                .sorted(criteria)
                .collect(Collectors.toList());
        return new HerbCalculatorResult(this.getFarmingLevel(), patches, herbs);
    }

    /**
     * Run the calculator for a single herb
     */
    private HerbResult calculateHerb(Herb herb, List<HerbPatchBuffs> patches) {
        List<HerbPatchResult> patchResults = patches.stream()
                .map(patch -> this.calculatePatch(herb, patch))
                .collect(Collectors.toList());
        HerbResult rv = new HerbResult(herb, patchResults);
        log.debug("{}", rv);
        return rv;
    }

    /**
     * Run the calculator for a single herb+patch combo
     */
    private HerbPatchResult calculatePatch(Herb herb, HerbPatchBuffs patch) {
        SurvivalChance survivalChance = this.calcSurvivalChance(patch);

        // Multiply by survival chance to account for dead plants
        double expectedYield = this.calcExpectedYield(herb, patch) * survivalChance.getSurvivalChance();

        double baseXp = this.config.compost().getXp()
                // "Plant" XP isn't granted until harvesting the final herb, which
                // means plants that die don't grant *any* XP beyond the compost
                // (and yes I checked that compost XP is granted at the beginning)
                + herb.getPlantXp() * survivalChance.getSurvivalChance()
                + herb.getHarvestXp() * expectedYield;
        double expectedXp = baseXp * (1.0 + patch.getXpBonus());

        // Calculate cost
        // Bottomless bucket doubles compost, so it halves the cost
        double compostCost = this.config.compost().getPrice(this.itemManager)
                * (this.config.useBottomlessBucket() ? 0.5 : 1.0);
        double seedCost = this.itemManager.getItemPrice(herb.getSeedItem());
        // The cost of runes for the Resurrect Crops *only*. We intentionally
        // ignore teleport costs, because it's extremely variable by
        // player/patch, and almost always insignificant.
        double runeCost = this.getResurrectRuneCost() * survivalChance.getResurrectionCastChance();
        double cost = compostCost + seedCost + runeCost;

        // Calculate revenue
        double revenue = this.itemManager.getItemPrice(herb.getGrimyHerbItem()) * expectedYield;

        return new HerbPatchResult(herb, patch.getPatch(), survivalChance.getSurvivalChance(), expectedYield,
                expectedXp, cost, revenue);
    }

    /**
     * Calculate the expected number of herbs to be harvested from a patch
     * **assuming it is already fully grown.** I.e. this does *not* take survival
     * chance into account.
     *
     * @return Expected number of herbs yielded on average
     */
    private double calcExpectedYield(Herb herb, HerbPatchBuffs patch) {
        // We're looking for the expected value of "number of trials until k failures",
        // where k is the number of harvest lives, and prob of failure (Pf) is
        // 1-chance to save. The odds of a single failure is 1/Pf, so k
        // failures is just k/Pf
        // https://math.stackexchange.com/questions/3378034/expected-number-of-coin-flips-to-see-3-heads
        return this.config.compost().getHarvestLives() / (1.0 - this.calcChanceToSave(herb, patch));
    }

    /**
     * Calculate the chance to "save a life" when picking an herb. This is
     * variable based on the herb, player's farming level, and applicable yield
     * bonuses.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Farming#Variable_crop_yield">Wiki Reference</a>
     * @param patch The patch being harvested
     * @return Odds of saving a live on each individual harvest, out of 1
     */
    private double calcChanceToSave(Herb herb, HerbPatchBuffs patch) {
        int farmingLevel = this.getFarmingLevel();
        double itemBonus = this.getItemChanceToSaveBonus();
        double attasBonus = this.config.animaPlant().getChanceToSaveBonus();

        // Yes, these chances really are supposed to be this big, they're really
        // out of 98, not 1
        double chance1 = herb.getMinChanceToSave(); // Min chance varies by herb
        double chance99 = 80.0; // Max chance is 80, for all herbs

        // This comes straight from the wiki, it's a lot easier to read in
        // their formatting (link above). The formatted formula doesn't mention
        // anything about the `floor`s though, but it's in the calculator source
        // https://oldschool.runescape.wiki/w/Calculator:Template/Farming/Herbs2?action=edit
        return Math.floor(
                Math.floor(
                        Math.floor((chance1 * (99.0 - farmingLevel) / 98.0) + (chance99 * (farmingLevel - 1.0) / 98.0))
                                * (1.0 + itemBonus)
                                // https://twitter.com/JagexAsh/status/956892754096869376
                                * (1.0 + patch.getYieldBonus())
                                // https://twitter.com/JagexAsh/status/1245644766328446976
                                // Note: This conflicts with how the wiki calculator does it,
                                // but I'm going off of Ash's tweets instead
                                * (1.0 + attasBonus)
                                + 1.0))
                / 256.0;
    }

    /**
     * Calculate the chance of a patch growing to adulthood. This takes into
     * account resurrection (when enabled), and will also return the chance of
     * the player having to cast the resurrection spell (whether or not it's
     * successful).
     *
     * @return Container holding the chance of survival, as well as change
     */
    private SurvivalChance calcSurvivalChance(HerbPatchBuffs patch) {
        if (patch.isDiseaseFree()) {
            return new SurvivalChance(1.0, 0.0);
        }

        // Here's some useful theorycrafting I did to understand this problem.
        // Each patch has 3 meaningful growth stages (really it's 4, but it's
        // impossible for the patch to die on the first cycle because it takes
        // two cycles to go alive->diseased->dead), and 4 possible outcomes on
        // each stage.
        // S = survived
        // D = died w/o resurrection attempted
        // R = resurrect successfully
        // F = resurrection attempted and failed
        //
        // We can assign a probability to each of these, using `s`, `d`, `r`,
        // and `f`. We know `s == 1-d` and `r == 1-f` which is useful.
        //
        // First, the possible outcomes *without* resurrection:
        // Good: SSS
        // Bad: SSD, SD, D
        // Here, the chance of survival is just `s^3`.
        //
        // Now when we factor in resurrection, it gets more complicated (keep in
        // mind that resurrection can only be attemped once per crop, and
        // resurrection does *not* progress the growth):
        // Good: SSS, SSRS, SRSS, RSSS
        // Bad: SSF, SF, F, SRSD, RSSD, RSD, RD
        // So the chance of survival is `s^3 + 3s^3r`, where the first term is
        // survival au naturale and the second is the chance of modern medicine
        // saving our herb and allowing it to live a fully and happy life.
        //
        // Something worth noting is that if a player resurrects a plant, they
        // likely won't be harvesting it on that same run, so *technically* we
        // should roll it over into the subsequent run, but in reality that
        // gives the same result as just harvesting it immediately, so not worth
        // trying to model that.
        //
        // To be entirely honest, I'm not 100% sure about all this math because
        // the Wiki isn't clear exactly how growth, disease, and resurrection
        // work, so this is a best guess. This needs to be confirmed
        // experimentally, but the numbers are definitely close enough to be
        // useful for now.

        // https://oldschool.runescape.wiki/w/Disease_(Farming)#Reducing_disease_risk
        // Disease chance is always out of 128 and rounded *down* to the nearest
        // 1/128, with a minimum chance of 1/128
        double baseChance = this.config.compost().getBaseDiseaseChance();
        double modifier = this.config.animaPlant().getDiseaseChanceModifier();
        double numerator = Math.max(Math.floor(baseChance * modifier), 1.0);
        double diseaseChancePerCycle = numerator / 128.0;
        double survivalChancePerCycle = 1.0 - diseaseChancePerCycle;

        // The chance of the plant surviving to adulthood on its own
        double naturalSurvivalChance = Math.pow(survivalChancePerCycle, 3.0);

        if (this.config.useResurrectCrops()) {
            // The chance that the patch (1) gets diseased, (2) is successfully
            // resurrected, and (3) successfully grows to adulthood. See the
            // essay above for why this makes sense.
            double resurrectToAdulthoodChance = 3.0 * Math.pow(survivalChancePerCycle, 3.0) * diseaseChancePerCycle
                    * this.getResurrectionChance();

            // Odds of having to cast Resurrect is just the inverse of the odds
            // surviving on its own
            double resurrectCastChance = 1.0 - naturalSurvivalChance;
            return new SurvivalChance(naturalSurvivalChance + resurrectToAdulthoodChance, resurrectCastChance);
        } else {
            return new SurvivalChance(naturalSurvivalChance, 0.0);
        }
    }

    /**
     * Get the cost of casting Resurrect Crops (assuming no staffs, since the
     * benefit of those is negligible).
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Resurrect_Crops">Wiki Reference</a>
     * @return Cost of all runes to cast Resurrect Crops
     */
    private int getResurrectRuneCost() {
        // 8 souls, 12 nats, 8 bloods, 25 earths
        return this.itemManager.getItemPrice(ItemID.SOUL_RUNE) * 8 +
                this.itemManager.getItemPrice(ItemID.NATURE_RUNE) * 12 +
                this.itemManager.getItemPrice(ItemID.BLOOD_RUNE) * 8 +
                this.itemManager.getItemPrice(ItemID.EARTH_RUNE) * 25;
    }

    /**
     * Calculate the chance of the Resurrect Crops spell succeeding, based on
     * the player's magic level. Scales from 50% at level 78 to 75% at 99.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Resurrect_Crops">Wiki Reference</a>
     * @return Chance of resurrection succeeding, out of 1
     */
    private double getResurrectionChance() {
        int magicLevel = this.client.getRealSkillLevel(Skill.MAGIC);
        int minLevel = MagicAction.RESURRECT_CROPS.getLevel();

        if (magicLevel < minLevel) {
            // Get outta here kid
            return 0.0;
        }

        // Map the value from the range [78,99] to [0.5,0.75] linearly
        return Utils.mapToRange(magicLevel, minLevel, 99, 0.5, 0.75);
    }

    /**
     * Get the player's farming level
     *
     * @return Farming level, or 0 if not logged in
     */
    private int getFarmingLevel() {
        return this.client.getRealSkillLevel(Skill.FARMING);
    }

    /**
     * Get the "chance to save" bonus due to equipped items.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Farming#Variable_crop_yield">Wiki Reference</a>
     * @return Chance to save bonus, out of 1
     */
    private double getItemChanceToSaveBonus() {
        double bonus = 0.0;
        if (this.config.useMagicSecateurs()) {
            // https://oldschool.runescape.wiki/w/Magic_secateurs
            bonus += 0.1;
        }
        if (this.config.useFarmingCape()) {
            // https://oldschool.runescape.wiki/w/Farming_cape
            bonus += 0.05;
        }
        return bonus;
    }

    /**
     * Get the "chance to save" bonus due to achievement diary bonuses. These
     * bonuses are patch-specific.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Farming#Variable_crop_yield">Wiki Reference</a>
     * @return Chance to save bonus, out of 1
     */
    private double getDiaryChanceToSaveBonus(HerbPatch patch) {
        switch (patch) {
            case CATHERBY:
                // +5% from medium, +10% from hard, +15% from elite
                // https://oldschool.runescape.wiki/w/Kandarin_Diary
                if (this.client.getVarbitValue(Varbits.DIARY_KANDARIN_ELITE) > 0) {
                    return 0.15;
                }
                if (this.client.getVarbitValue(Varbits.DIARY_KANDARIN_HARD) > 0) {
                    return 0.10;
                }
                if (this.client.getVarbitValue(Varbits.DIARY_KANDARIN_MEDIUM) > 0) {
                    return 0.05;
                }
                return 0.0;
            // +5% from Kourend hard
            // https://oldschool.runescape.wiki/w/Kourend_%26_Kebos_Diary#Rewards_3
            case FARMING_GUILD:
            case HOSIDIUS:
                if (this.client.getVarbitValue(Varbits.DIARY_KOUREND_HARD) > 0) {
                    return 0.05;
                }
                return 0.0;
            default:
                // Everyone else sucks, and should feel bad
                return 0.0;
        }
    }

    /**
     * Get the XP bonus factor to apply to this patch, from achievement diary
     * rewards.
     *
     * @param patch Herb patch being farmed
     * @return 0 for no bonus, positive number for a bonus
     */
    private double getXpBonus(HerbPatch patch) {
        switch (patch) {
            case FALADOR:
                // +10% from medium
                if (this.client.getVarbitValue(Varbits.DIARY_FALADOR_MEDIUM) > 0) {
                    return 0.10;
                }
                return 0.0;
            default:
                return 0.0;
        }
    }
}

package me.lucaspickering;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.text.DecimalFormat;
import java.awt.Dimension;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import java.awt.Color;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;

import me.lucaspickering.utils.HerbResult;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

/**
 * A visual representation for an herb's results.
 */
public class UIHerbSlot extends JPanel {

  // Ripped from hiscores plugin
  private static final Border EMPTY_BORDER = BorderFactory.createEmptyBorder(7, 7, 7, 7);

  private static final Border GREEN_BORDER = new CompoundBorder(
      BorderFactory.createMatteBorder(0, 4, 0, 0, (ColorScheme.PROGRESS_COMPLETE_COLOR).darker()),
      EMPTY_BORDER);

  private static final Border RED_BORDER = new CompoundBorder(
      BorderFactory.createMatteBorder(0, 4, 0, 0, (ColorScheme.PROGRESS_ERROR_COLOR).darker()),
      EMPTY_BORDER);

  private static final Dimension ICON_SIZE = new Dimension(32, 32);

  private static DecimalFormat GP_FORMAT = new DecimalFormat("+#,###;-#,###");

  public UIHerbSlot(int farmingLevel, ItemManager itemManager, HerbResult result) {
    // An empty border to provide some padding
    this.setBorder(BorderFactory.createEmptyBorder(5, 0, 0, 0));
    this.setLayout(new BorderLayout());

    // An inner panel that will hold all the contents
    JPanel innerPanel = new JPanel();
    innerPanel.setLayout(new BorderLayout());
    innerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    innerPanel.setBorder(farmingLevel >= result.getHerb().getLevel() ? GREEN_BORDER : RED_BORDER);
    this.add(innerPanel);

    // Add the icon
    JLabel icon = new JLabel();
    itemManager.getImage(result.getHerb().getGrimyHerbItem()).addTo(icon);
    icon.setMinimumSize(ICON_SIZE);
    icon.setMaximumSize(ICON_SIZE);
    icon.setPreferredSize(ICON_SIZE);
    innerPanel.add(icon, BorderLayout.LINE_START);

    // Create a sub-sub-panel for all the text info
    JPanel infoPanel = new JPanel(new GridLayout(2, 2));
    infoPanel.setBorder(new EmptyBorder(0, 5, 0, 0));
    infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    innerPanel.add(infoPanel, BorderLayout.CENTER);

    // Add the herb name
    JLabel nameLabel = new JLabel(result.getHerb().getName());
    nameLabel.setForeground(Color.WHITE);
    infoPanel.add(nameLabel);

    // Add profit
    JLabel profitLabel = new JLabel(GP_FORMAT.format(result.getProfit()) + " gp");
    profitLabel.setHorizontalAlignment(SwingConstants.RIGHT);
    profitLabel.setForeground(UIHerbSlot.getProfitColor(result.getProfit()));
    infoPanel.add(profitLabel);

    // Add yield
    JLabel yieldLabel = new JLabel(String.format("%.1f herbs", result.getExpectedYield()));
    yieldLabel.setFont(FontManager.getRunescapeSmallFont());
    yieldLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
    infoPanel.add(yieldLabel);

    // Add XP
    JLabel xpLabel = new JLabel(String.format("%.1f XP", result.getExpectedXp()));
    xpLabel.setHorizontalAlignment(SwingConstants.RIGHT);
    xpLabel.setFont(FontManager.getRunescapeSmallFont());
    xpLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
    infoPanel.add(xpLabel);
  }

  private static Color getProfitColor(double profit) {
    if (profit > 0.0) {
      return ColorScheme.PROGRESS_COMPLETE_COLOR;
    }
    if (profit < 0.0) {
      return ColorScheme.PROGRESS_ERROR_COLOR;
    }
    return Color.WHITE;
  }
}

package me.lucaspickering;

import java.util.StringJoiner;
import javax.swing.BoxLayout;
import java.awt.GridLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;

import lombok.extern.slf4j.Slf4j;
import me.lucaspickering.utils.HerbResult;
import me.lucaspickering.utils.HerbCalculatorResult;
import me.lucaspickering.utils.HerbPatchBuffs;

import java.awt.Color;
import java.text.DecimalFormat;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

@Slf4j
public class HerbFarmCalculatorPanel extends PluginPanel {

  private static final DecimalFormat PCT_FORMAT = new DecimalFormat("+0%");

  private final Client client;
  private final ClientThread clientThread;
  private final ItemManager itemManager;
  private final HerbFarmCalculator calculator;
  private JPanel uiPanel;

  public HerbFarmCalculatorPanel(Client client, ClientThread clientThread,
      ItemManager itemManager,
      HerbFarmCalculatorConfig config,
      HerbFarmCalculator calculator) {
    super();
    this.client = client;
    this.clientThread = clientThread;
    this.itemManager = itemManager;
    this.calculator = calculator;

    setBorder(new EmptyBorder(10, 10, 10, 10));
    setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
  }

  @Override
  public void onActivate() {
    super.onActivate();
    // Run the calculator whenever the panel is revealed
    this.refreshPanel();
  }

  /**
   * Run the calculator and update the panel to show the results. Called on
   * startup, and login.
   */
  public void refreshPanel() {
    // Defer running the calculator onto the client thread
    clientThread.invokeLater(() -> {
      HerbCalculatorResult result = this.calculator.calculate();

      // Move UI updating onto the AWT thread
      SwingUtilities.invokeLater(() -> {
        this.renderResult(result);
      });
    });
  }

  /**
   * Draw new results into the UI. This should be called *after* running the
   * calculator, in the AWT thread.
   *
   * @param result
   */
  private void renderResult(HerbCalculatorResult result) {
    log.debug("Rendering calculator result");

    // Clear previous info
    if (this.uiPanel != null) {
      this.remove(this.uiPanel);
    }
    this.uiPanel = new JPanel();
    this.uiPanel.setLayout(new BoxLayout(this.uiPanel, BoxLayout.Y_AXIS));
    this.add(uiPanel);

    // ===== Render summary panel =====
    JPanel infoPanel = new JPanel();
    infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
    infoPanel.setLayout(new GridLayout(0, 1));
    infoPanel.setBorder(new EmptyBorder(5, 5, 5, 5));
    this.uiPanel.add(infoPanel);

    // If player isn't logged in, show a warning so they know that results won't
    // be accurate
    if (this.client.getGameState() != GameState.LOGGED_IN) {
      JLabel notLoggedInWarning = new JLabel("Log in for more accurate results");
      notLoggedInWarning.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
      infoPanel.add(notLoggedInWarning);
    }

    // Farming level
    JLabel farmingLevelLabel = new JLabel(String.format("Farming level: %d", result.getFarmingLevel()));
    farmingLevelLabel.setForeground(Color.WHITE);
    infoPanel.add(farmingLevelLabel);

    // Add a label for each patch in use
    for (HerbPatchBuffs patch : result.getPatches()) {
      // Generate a label for the patch that includes name, yield buff, xp buff
      StringBuilder text = new StringBuilder(patch.getPatch().getName());
      StringJoiner buffLabels = new StringJoiner(", ");
      if (patch.isDiseaseFree()) {
        buffLabels.add("disease-free");
      }
      if (patch.getYieldBonus() != 0.0) {
        buffLabels.add(PCT_FORMAT.format(patch.getYieldBonus()) + " yield");
      }
      if (patch.getXpBonus() != 0.0) {
        buffLabels.add(PCT_FORMAT.format(patch.getXpBonus()) + " XP");
      }

      if (buffLabels.length() > 0) {
        text.append(" (");
        text.append(buffLabels);
        text.append(")");
      }

      JLabel patchLabel = new JLabel(text.toString());
      patchLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
      patchLabel.setFont(FontManager.getRunescapeSmallFont());
      infoPanel.add(patchLabel);
    }

    // ===== Render calculator results =====
    JPanel resultsPanel = new JPanel();
    resultsPanel.setLayout(new BoxLayout(resultsPanel, BoxLayout.Y_AXIS));
    this.uiPanel.add(resultsPanel);

    // Add each patch
    for (HerbResult herbResult : result.getHerbs()) {
      UIHerbSlot slot = new UIHerbSlot(result.getFarmingLevel(), this.itemManager, herbResult);
      resultsPanel.add(slot);
    }

    this.revalidate();
    this.repaint();
  }
}

package me.lucaspickering.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * A container for an herb patch, paired with its *patch-specific* buffs, e.g.
 * not including yield buffs from magic secateurs or other items.
 */
@AllArgsConstructor
@Getter
public class HerbPatchBuffs {
    private final HerbPatch patch;
    private boolean isDiseaseFree;
    private final double yieldBonus;
    private final double xpBonus;
}

package me.lucaspickering.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * A container class for calculator output. This encapsulates results for *a
 * single herb* and *a single patch*.
 */
@AllArgsConstructor
@Getter
public class HerbPatchResult {

  private final Herb herb;
  private final HerbPatch patch;
  private final double survivalChance;
  private final double expectedYield;
  private final double expectedXp;
  private final double cost;
  private final double revenue;

  public double getProfit() {
    return this.revenue - this.cost;
  }
}

package me.lucaspickering.utils;

public class Utils {
    /**
     * Map a value from one known range to another. E.g. mapping 5 from [0,10]
     * to [10,20] yields 15, and 60 from [50,100] to [0,10] yields 2.
     *
     * @param value  The value to map
     * @param inMin  The minimum value of the input range
     * @param inMax  The maximum value of the input range
     * @param outMin The minimum value of the output range
     * @param outMax The maximum value of the output range
     * @return Mapped value
     */
    public static double mapToRange(double value, double inMin, double inMax, double outMin, double outMax) {
        if (inMin >= inMax) {
            throw new IllegalArgumentException(
                    String.format("Input min must be less than max, but got: [%f, %f]", inMin, inMax));
        }
        if (outMin >= outMax) {
            throw new IllegalArgumentException(
                    String.format("Output min must be less than max, but got: [%f, %f]", outMin, outMax));
        }

        // Shift down to [0,inSpan], then scale down to [0,1]
        double normalized = (value - inMin) / (inMax - inMin);
        // Scale up to [0,outSpan], then shift up to [outMin,outMax]
        return (normalized * (outMax - outMin)) + outMin;
    }
}

package me.lucaspickering.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.Varbits;

@AllArgsConstructor
@Getter
public enum HerbPatch {
    ARDOUGNE("Ardougne"),
    CATHERBY("Catherby"),
    FALADOR("Falador"),
    FARMING_GUILD("Farming Guild"),
    HARMONY("Harmony"),
    HOSIDIUS("Hosidius"),
    PORT_PHASMATYS("Port Phasmatys"),
    TROLL_STRONGHOLD("Troll Stronghold"),
    WEISS("Weiss"),
    CIVITAS_ILLA_FORTIS("Civitas illa Fortis");

    private final String name;

    /**
     * Is this patch disease-proof?
     *
     * @param client RuneLite client, used to fetch dynamic data
     * @return True if this patch can't be diseased, false otherwise
     */
    public boolean isDiseaseFree(Client client) {
        switch (this) {
            case TROLL_STRONGHOLD:
            case WEISS:
                return true;
            case CIVITAS_ILLA_FORTIS:
                // Disease free for civitas illa is based on achieving champion rank with the fortis colosseum. 
                // https://oldschool.runescape.wiki/w/Fortis_Colosseum#Glory
                // Glory is stored in VarPlayer value 4130.
                return client.getVarpValue(4130) >= 16000;
            case HOSIDIUS:
                // Disease free is now based on the completion of the Kourend easy diary.
                return client.getVarbitValue(Varbits.DIARY_KOUREND_EASY) == 1;
            default:
                return false;
        }
    }
}

package me.lucaspickering.utils;
import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.Comparator;


@AllArgsConstructor
@Getter
public enum SortingCriteria {
    Alphabetical("Alphabetical"),
    Level("Level"),
    Profit("Profit"),
    Yield("Yield"),
    XP("XP");

    public final String name;

    public Comparator<HerbResult> getComparator(){
        switch(this){
            case Alphabetical:
                return Comparator.comparing(herbResult -> herbResult.getHerb().getName());
            case Level:
                return Comparator.comparing(herbResult -> herbResult.getHerb().getLevel());
            case Profit:
                return Comparator.comparingDouble(HerbResult::getProfit);
            case Yield:
                return Comparator.comparingDouble(HerbResult::getExpectedYield);
            case XP:
                return Comparator.comparingDouble(HerbResult::getExpectedXp);
        }
        return Comparator.comparing(herbResult -> herbResult.getHerb().getLevel());
    }



}
package me.lucaspickering.utils;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * A container class that holds the entire output of the calculator, including
 * intermediate values that were derived, which might be useful to the user.
 */
@AllArgsConstructor
@Getter
public class HerbCalculatorResult {
    /**
     * Player's farming level
     */
    private final int farmingLevel;
    /**
     * The patches that are being grown. This contains static information about
     * each patch.
     */
    private final List<HerbPatchBuffs> patches;
    /**
     * Results for each herb, aggregated across all patches. This is the real
     * data that the user cares about.
     */
    private final List<HerbResult> herbs;
}

package me.lucaspickering.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

@AllArgsConstructor
@Getter
public enum Compost {
    NONE("None", 0.0, -1, 27.0),
    NORMAL("Compost", 18.0, ItemID.COMPOST, 14.0),
    SUPERCOMPOST("Supercompost", 26.0, ItemID.SUPERCOMPOST, 6.0),
    ULTRACOMPOST("Ultracompost", 36.0, ItemID.ULTRACOMPOST, 3.0);

    private final String name;
    /**
     * The amount of XP gained for spreading this compost.
     */
    private final double xp;
    /**
     * ID of the item associated with this compost (-1 for NONE)
     */
    private final int item;
    private final double baseDiseaseChance;

    /**
     * Get the GE price of this compost item (if any)
     */
    public int getPrice(ItemManager itemManager) {
        if (this.item >= 0) {
            return itemManager.getItemPrice(this.item);
        } else {
            return 0;
        }
    }

    /**
     * Get the number of "harvest lives" that a patch starts with when this
     * compost is applied.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Farming#Variable_crop_yield">Wiki Reference</a>
     * @return Number of starting lives (default is 3)
     */
    public int getHarvestLives() {
        switch (this) {
            case NONE:
                return 3;
            case NORMAL:
                return 4;
            case SUPERCOMPOST:
                return 5;
            case ULTRACOMPOST:
                return 6;
            default:
                return 3;
        }
    }
}

package me.lucaspickering.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;

@AllArgsConstructor
@Getter
public enum Herb {
    GUAM("Guam", 9, 25.0f, 11.0, 12.5, ItemID.GUAM_SEED, ItemID.GRIMY_GUAM_LEAF),
    MARRENTILL("Marrentill", 14, 28.0, 13.5, 15.0, ItemID.MARRENTILL_SEED,
            ItemID.GRIMY_MARRENTILL),
    TARROMIN("Tarromin", 19, 31.0, 16.0, 18.0, ItemID.TARROMIN_SEED, ItemID.GRIMY_TARROMIN),
    HARRALANDER("Harralander", 26, 36.0, 21.5, 24.0, ItemID.HARRALANDER_SEED,
            ItemID.GRIMY_HARRALANDER),
    RANARR("Ranarr", 32, 39.0, 27.0, 30.5, ItemID.RANARR_SEED, ItemID.GRIMY_RANARR_WEED),
    TOADFLAX("Toadflax", 38, 43.0, 34.0, 38.5, ItemID.TOADFLAX_SEED, ItemID.GRIMY_TOADFLAX),
    IRIT("Irit", 44, 46.0, 43.0, 48.5, ItemID.IRIT_SEED, ItemID.GRIMY_IRIT_LEAF),
    AVANTOE("Avantoe", 50, 50.0, 54.5, 61.5, ItemID.AVANTOE_SEED, ItemID.GRIMY_AVANTOE),
    KWUARM("Kwuarm", 56, 54.0, 69.0, 78.0, ItemID.KWUARM_SEED, ItemID.GRIMY_KWUARM),
    SNAPDRAGON("Snapdragon", 62, 57.0, 87.5, 98.5, ItemID.SNAPDRAGON_SEED,
            ItemID.GRIMY_SNAPDRAGON),
    HUASCA("Huasca", 65, 58.0, 86.5, 110.0, ItemID.HUASCA_SEED, ItemID.GRIMY_HUASCA),
    CADANTINE("Cadantine", 67, 60.0, 106.5, 120.0, ItemID.CADANTINE_SEED, ItemID.GRIMY_CADANTINE),
    LANTADYME("Lantadyme", 73, 64.0, 134.5, 151.5, ItemID.LANTADYME_SEED, ItemID.GRIMY_LANTADYME),
    DWARF_WEED("Dwarf Weed", 79, 67.0, 170.5, 192.0, ItemID.DWARF_WEED_SEED,
            ItemID.GRIMY_DWARF_WEED),
    TORSTOL("Torstol", 85, 71.0, 199.5, 224.5, ItemID.TORSTOL_SEED, ItemID.GRIMY_TORSTOL);

    private final String name;
    private final int level;
    /**
     * The *minimum* "chance to save a life" for the herb, at level 1. Values from
     * <a href="https://oldschool.runescape.wiki/w/Module:Herb_Farming_calculator">Wiki</a>.
     */
    private final double minChanceToSave;
    private final double plantXp;
    private final double harvestXp;
    private final int seedItem;
    private final int grimyHerbItem;
}

package me.lucaspickering.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum AnimaPlant {
    NONE("None"), ATTAS("Attas"), IASOR("Iasor"), KRONOS("Kronos");

    private final String name;

    /**
     * Get the disease chance modifier for this plant. 20% for Iasor, 100% for
     * everything else.
     *
     * @return Disease chance, out of 1
     */
    public double getDiseaseChanceModifier() {
        return this == AnimaPlant.IASOR ? 0.2 : 1.0;
    }

    /**
     * Get the "chance to save" bonus provided by this plant. 5% for Attas, 0
     * for everything else.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Farming#Variable_crop_yield">Wiki Reference</a>
     * @return Chance to save bonus, out of 1
     */
    public double getChanceToSaveBonus() {
        return this == AnimaPlant.ATTAS ? 0.05 : 0.0;
    }
}

package me.lucaspickering.utils;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class SurvivalChance {
    private final double survivalChance;
    private final double resurrectionCastChance;
}

package me.lucaspickering.utils;

import java.util.List;
import lombok.Getter;

/**
 * A container class for calculator output. This encapsulates results for *a
 * single herb* but *all patches*.
 */
public class HerbResult {

  @Getter
  private final Herb herb;
  private final List<HerbPatchResult> patches;

  public HerbResult(Herb herb, List<HerbPatchResult> patches) {
    this.herb = herb;
    this.patches = patches;
  }

  /**
   * Get the *average* survival rate across all patches.
   *
   * @return Average of all patches' survival rate
   */
  public double getSurvivalChance() {
    return patches.stream().mapToDouble(HerbPatchResult::getSurvivalChance).average().orElse(0.0);
  }

  /**
   * Get the expected yield across all patches in this result
   *
   * @return Sum of each patch's expected yield
   */
  public double getExpectedYield() {
    return patches.stream().mapToDouble(HerbPatchResult::getExpectedYield).sum();
  }

  /**
   * Get the expected XP gained across all patches in this result.
   *
   * @return Sum of each patch's expected XP
   */
  public double getExpectedXp() {
    return patches.stream().mapToDouble(HerbPatchResult::getExpectedXp).sum();
  }

  /**
   * Get the expected profit across all patches in this result.
   *
   * @return Sum of each patch's profit
   */
  public double getProfit() {
    return patches.stream().mapToDouble(HerbPatchResult::getProfit).sum();
  }

  @Override
  public String toString() {
    return String.format("%f survival / %f yield / %f XP", this.getSurvivalChance() * 100.0, this.getExpectedYield(),
        this.getExpectedXp());
  }
}

