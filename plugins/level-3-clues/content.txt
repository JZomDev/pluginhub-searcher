package com.level3clues.evaluator.combat;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.cluescrolls.clues.item.AllRequirementsCollection;
import net.runelite.client.plugins.cluescrolls.clues.item.AnyRequirementCollection;
import net.runelite.client.plugins.cluescrolls.clues.item.ItemRequirement;
import net.runelite.client.plugins.cluescrolls.clues.item.RangeItemRequirement;
import net.runelite.client.plugins.cluescrolls.clues.item.SingleItemRequirement;
import com.level3clues.evaluator.util.ItemRequirementHelper;

@Singleton
public class CombatItemDetector
{
	private static final java.util.Set<String> COMBAT_CHALLENGE_KEYWORDS = java.util.Set.of(
		"kill", "slay", "defeat", "fight", "combat", "attack", "destroy", "eliminate"
	);

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ItemRequirementHelper itemRequirementHelper;

	public boolean requiresCombat(String challengeText)
	{
		if (challengeText == null)
		{
			return false;
		}
		String lowerText = challengeText.toLowerCase();
		return COMBAT_CHALLENGE_KEYWORDS.stream().anyMatch(lowerText::contains);
	}

	public boolean hasCombatRequirements(ItemRequirement[] requirements)
	{
		if (requirements == null || requirements.length == 0)
		{
			return false;
		}

		for (ItemRequirement requirement : requirements)
		{
			if (hasCombatRequirement(requirement))
			{
				return true;
			}
		}

		return false;
	}

	private boolean hasCombatRequirement(ItemRequirement requirement)
	{
		if (requirement instanceof SingleItemRequirement)
		{
			SingleItemRequirement singleReq = (SingleItemRequirement) requirement;
			String itemName = singleReq.getCollectiveName(client);
			if (itemName != null && !itemName.equals("N/A"))
			{
				return hasCombatItemName(itemName);
			}
			int itemId = itemRequirementHelper.getItemIdFromSingleRequirement(singleReq);
			if (itemId != -1)
			{
				return checkItemCombatRequirement(itemId);
			}
		}
		else if (requirement instanceof RangeItemRequirement)
		{
			RangeItemRequirement rangeReq = (RangeItemRequirement) requirement;
			String itemName = rangeReq.getCollectiveName(client);
			if (itemName != null && !itemName.equals("N/A"))
			{
				return hasCombatItemName(itemName);
			}
			int start = itemRequirementHelper.getStartItemId(rangeReq);
			int end = itemRequirementHelper.getEndItemId(rangeReq);
			return checkItemRangeCombatRequirement(start, end);
		}
		else if (requirement instanceof AnyRequirementCollection)
		{
			AnyRequirementCollection anyReq = (AnyRequirementCollection) requirement;
			String itemName = anyReq.getCollectiveName(client);
			if (itemName != null && !itemName.equals("N/A"))
			{
				return hasCombatItemName(itemName);
			}
			ItemRequirement[] subRequirements = itemRequirementHelper.getSubRequirements(anyReq);
			if (subRequirements == null || subRequirements.length == 0)
			{
				return false;
			}
			boolean allHaveCombatRequirements = true;
			for (ItemRequirement subReq : subRequirements)
			{
				if (!hasCombatRequirement(subReq))
				{
					allHaveCombatRequirements = false;
					break;
				}
			}
			return allHaveCombatRequirements;
		}
		else if (requirement instanceof AllRequirementsCollection)
		{
			AllRequirementsCollection allReq = (AllRequirementsCollection) requirement;
			String itemName = allReq.getCollectiveName(client);
			if (itemName != null && !itemName.equals("N/A"))
			{
				return hasCombatItemName(itemName);
			}
			ItemRequirement[] subRequirements = itemRequirementHelper.getSubRequirements(allReq);
			for (ItemRequirement subReq : subRequirements)
			{
				if (hasCombatRequirement(subReq))
				{
					return true;
				}
			}
		}

		return false;
	}

	private boolean hasCombatItemName(String itemName)
	{
		if (itemName == null)
		{
			return false;
		}

		String lowerName = itemName.toLowerCase();

		if (lowerName.contains("halberd") && (lowerName.contains("adamant") || lowerName.contains("rune") || 
		    lowerName.contains("dragon") || lowerName.contains("mithril") || lowerName.contains("steel")))
		{
			return true;
		}

		if (lowerName.contains("mystic") && (lowerName.contains("robe") || lowerName.contains("hat") || 
		    lowerName.contains("boots") || lowerName.contains("gloves")))
		{
			return true;
		}

		if ((lowerName.contains("rune") || lowerName.contains("adamant") || lowerName.contains("mithril") || 
		     lowerName.contains("steel") || lowerName.contains("dragon")) && 
		    (lowerName.contains("platebody") || lowerName.contains("platelegs") || lowerName.contains("plateskirt") ||
		     lowerName.contains("chainbody") || lowerName.contains("full helm") || lowerName.contains("kiteshield") ||
		     lowerName.contains("sq shield") || lowerName.contains("sword") || lowerName.contains("scimitar") ||
		     lowerName.contains("longsword") || lowerName.contains("battleaxe") || lowerName.contains("warhammer") ||
		     lowerName.contains("2h sword") || lowerName.contains("mace") || lowerName.contains("dagger")))
		{
			return true;
		}

		if (lowerName.contains("d'hide") || lowerName.contains("leather") || lowerName.contains("studded") ||
		    lowerName.contains("snakeskin") || lowerName.contains("karil") || lowerName.contains("armadyl"))
		{
			if (lowerName.contains("body") || lowerName.contains("chaps") || lowerName.contains("vambraces") ||
			    lowerName.contains("coif") || lowerName.contains("boots"))
			{
				return true;
			}
		}

		return false;
	}

	private boolean checkItemCombatRequirement(int itemId)
	{
		if (itemId == -1)
		{
			return false;
		}

		ItemComposition itemDef = itemManager.getItemComposition(itemId);
		if (itemDef == null)
		{
			return false;
		}

		return hasCombatItemName(itemDef.getName());
	}

	private boolean checkItemRangeCombatRequirement(int startItemId, int endItemId)
	{
		int maxCheck = Math.min(endItemId, startItemId + 100);
		for (int itemId = startItemId; itemId <= maxCheck; itemId++)
		{
			if (checkItemCombatRequirement(itemId))
			{
				return true;
			}
		}
		return false;
	}
}


package com.level3clues.evaluator.util;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.cluescrolls.clues.item.AllRequirementsCollection;
import net.runelite.client.plugins.cluescrolls.clues.item.AnyRequirementCollection;
import net.runelite.client.plugins.cluescrolls.clues.item.ItemRequirement;
import net.runelite.client.plugins.cluescrolls.clues.item.RangeItemRequirement;
import net.runelite.client.plugins.cluescrolls.clues.item.SingleItemRequirement;

@Singleton
public class ItemRequirementHelper
{
	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	public int getItemIdFromSingleRequirement(SingleItemRequirement requirement)
	{
		String name = requirement.getCollectiveName(client);
		if (name == null || name.equals("N/A"))
		{
			return -1;
		}

		for (int itemId = 1; itemId < 100000; itemId++)
		{
			ItemComposition def = itemManager.getItemComposition(itemId);
			if (def != null && name.equals(def.getName()) && requirement.fulfilledBy(itemId))
			{
				return itemId;
			}
		}
		return -1;
	}

	public ItemRequirement[] getSubRequirements(AnyRequirementCollection collection)
	{
		java.util.List<ItemRequirement> requirements = new java.util.ArrayList<>();
		for (int itemId = 1; itemId < 100000; itemId++)
		{
			if (collection.fulfilledBy(itemId))
			{
				ItemComposition def = itemManager.getItemComposition(itemId);
				if (def != null && def.getName() != null && !def.getName().equals("null"))
				{
					requirements.add(new SingleItemRequirement(itemId));
				}
			}
		}
		return requirements.toArray(new ItemRequirement[0]);
	}

	public ItemRequirement[] getSubRequirements(AllRequirementsCollection collection)
	{
		java.util.List<ItemRequirement> requirements = new java.util.ArrayList<>();
		for (int itemId = 1; itemId < 100000; itemId++)
		{
			if (collection.fulfilledBy(itemId))
			{
				ItemComposition def = itemManager.getItemComposition(itemId);
				if (def != null && def.getName() != null && !def.getName().equals("null"))
				{
					requirements.add(new SingleItemRequirement(itemId));
				}
			}
		}
		return requirements.toArray(new ItemRequirement[0]);
	}

	public int getStartItemId(RangeItemRequirement requirement)
	{
		for (int itemId = 1; itemId < 100000; itemId++)
		{
			if (requirement.fulfilledBy(itemId))
			{
				ItemComposition def = itemManager.getItemComposition(itemId);
				if (def != null && def.getName() != null && !def.getName().equals("null"))
				{
					return itemId;
				}
			}
		}
		return -1;
	}

	public int getEndItemId(RangeItemRequirement requirement)
	{
		int lastItemId = -1;
		for (int itemId = 1; itemId < 100000; itemId++)
		{
			if (requirement.fulfilledBy(itemId))
			{
				ItemComposition def = itemManager.getItemComposition(itemId);
				if (def != null && def.getName() != null && !def.getName().equals("null"))
				{
					lastItemId = itemId;
				}
			}
		}
		return lastItemId;
	}
}


package com.level3clues.evaluator.quest;

import java.util.Set;
import java.util.HashSet;

public class SkillerCompletableQuests
{
	public static final Set<String> COMPLETABLE_QUEST_NAMES = new HashSet<>();

	static
	{
		COMPLETABLE_QUEST_NAMES.add("Below Ice Mountain");
		COMPLETABLE_QUEST_NAMES.add("Black Knights' Fortress");
		COMPLETABLE_QUEST_NAMES.add("Cook's Assistant");
		COMPLETABLE_QUEST_NAMES.add("The Corsair Curse");
		COMPLETABLE_QUEST_NAMES.add("Demon Slayer");
		COMPLETABLE_QUEST_NAMES.add("Doric's Quest");
		COMPLETABLE_QUEST_NAMES.add("Ernest the Chicken");
		COMPLETABLE_QUEST_NAMES.add("Goblin Diplomacy");
		COMPLETABLE_QUEST_NAMES.add("The Knight's Sword");
		COMPLETABLE_QUEST_NAMES.add("Misthalin Mystery");
		COMPLETABLE_QUEST_NAMES.add("Pirate's Treasure");
		COMPLETABLE_QUEST_NAMES.add("Prince Ali Rescue");
		COMPLETABLE_QUEST_NAMES.add("Romeo & Juliet");
		COMPLETABLE_QUEST_NAMES.add("Rune Mysteries");
		COMPLETABLE_QUEST_NAMES.add("Shield of Arrav");
		COMPLETABLE_QUEST_NAMES.add("Sheep Shearer");
		COMPLETABLE_QUEST_NAMES.add("X Marks the Spot");

		COMPLETABLE_QUEST_NAMES.add("Druidic Ritual");
		COMPLETABLE_QUEST_NAMES.add("Lost City");
		COMPLETABLE_QUEST_NAMES.add("Merlin's Crystal");
		COMPLETABLE_QUEST_NAMES.add("Tribal Totem");
		COMPLETABLE_QUEST_NAMES.add("Fishing Contest");
		COMPLETABLE_QUEST_NAMES.add("Monk's Friend");
		COMPLETABLE_QUEST_NAMES.add("Clock Tower");
		COMPLETABLE_QUEST_NAMES.add("Hazeel Cult");
		COMPLETABLE_QUEST_NAMES.add("Sheep Herder");
		COMPLETABLE_QUEST_NAMES.add("Plague City");
		COMPLETABLE_QUEST_NAMES.add("Sea Slug");
		COMPLETABLE_QUEST_NAMES.add("Biohazard");
		COMPLETABLE_QUEST_NAMES.add("Jungle Potion");
		COMPLETABLE_QUEST_NAMES.add("Shilo Village");
		COMPLETABLE_QUEST_NAMES.add("Observatory Quest");
		COMPLETABLE_QUEST_NAMES.add("The Tourist Trap");
		COMPLETABLE_QUEST_NAMES.add("Dwarf Cannon");
		COMPLETABLE_QUEST_NAMES.add("Murder Mystery");
		COMPLETABLE_QUEST_NAMES.add("The Dig Site");
		COMPLETABLE_QUEST_NAMES.add("Gertrude's Cat");
		COMPLETABLE_QUEST_NAMES.add("Elemental Workshop I");
		COMPLETABLE_QUEST_NAMES.add("Tai Bwo Wannai Trio");
		COMPLETABLE_QUEST_NAMES.add("One Small Favour");
		COMPLETABLE_QUEST_NAMES.add("The Feud");
		COMPLETABLE_QUEST_NAMES.add("The Golem");
		COMPLETABLE_QUEST_NAMES.add("Icthlarin's Little Helper");
		COMPLETABLE_QUEST_NAMES.add("Tears of Guthix");
		COMPLETABLE_QUEST_NAMES.add("The Lost Tribe");
		COMPLETABLE_QUEST_NAMES.add("A Tail of Two Cats");
		COMPLETABLE_QUEST_NAMES.add("Ratcatchers");
		COMPLETABLE_QUEST_NAMES.add("The Hand in the Sand");
		COMPLETABLE_QUEST_NAMES.add("Recipe for Disaster");
		COMPLETABLE_QUEST_NAMES.add("Enlightened Journey");
		COMPLETABLE_QUEST_NAMES.add("Eagles' Peak");
		COMPLETABLE_QUEST_NAMES.add("Contact!");
		COMPLETABLE_QUEST_NAMES.add("Cold War");
		COMPLETABLE_QUEST_NAMES.add("Tower of Life");
		COMPLETABLE_QUEST_NAMES.add("Client of Kourend");
		COMPLETABLE_QUEST_NAMES.add("Bone Voyage");
		COMPLETABLE_QUEST_NAMES.add("The Queen of Thieves");
		COMPLETABLE_QUEST_NAMES.add("The Depths of Despair");
		COMPLETABLE_QUEST_NAMES.add("The Forsaken Tower");
		COMPLETABLE_QUEST_NAMES.add("The Ascent of Arceuus");
		COMPLETABLE_QUEST_NAMES.add("A Porcine of Interest");
		COMPLETABLE_QUEST_NAMES.add("Getting Ahead");
		COMPLETABLE_QUEST_NAMES.add("Temple of the Eye");
		COMPLETABLE_QUEST_NAMES.add("Sleeping Giants");
		COMPLETABLE_QUEST_NAMES.add("The Garden of Death");
		COMPLETABLE_QUEST_NAMES.add("Children of the Sun");
		COMPLETABLE_QUEST_NAMES.add("The Ribbiting Tale of a Lily Pad Labour Dispute");
		COMPLETABLE_QUEST_NAMES.add("At First Light");
		COMPLETABLE_QUEST_NAMES.add("Twilight's Promise");
		COMPLETABLE_QUEST_NAMES.add("Death on the Isle");
		COMPLETABLE_QUEST_NAMES.add("Ethically Acquired Antiquities");
		COMPLETABLE_QUEST_NAMES.add("Scrambled!");
		COMPLETABLE_QUEST_NAMES.add("Shadows of Custodia");
		COMPLETABLE_QUEST_NAMES.add("Pandemonium");
		COMPLETABLE_QUEST_NAMES.add("Prying Times");
		COMPLETABLE_QUEST_NAMES.add("Current Affairs");
		COMPLETABLE_QUEST_NAMES.add("Troubled Tortugans");

		COMPLETABLE_QUEST_NAMES.add("Watchtower");
	}

	public static boolean isSkillerCompletable(String questName)
	{
		if (questName == null)
		{
			return false;
		}
		String normalized = normalizeQuestName(questName);
		return COMPLETABLE_QUEST_NAMES.contains(normalized);
	}

	private static String normalizeQuestName(String questName)
	{
		if (questName == null)
		{
			return "";
		}
		questName = questName.trim();
		if (questName.startsWith("the ") || questName.startsWith("The "))
		{
			questName = questName.substring(4);
		}
		if (questName.endsWith("'s") || questName.endsWith("'S"))
		{
			questName = questName.substring(0, questName.length() - 2) + "s";
		}
		return questName;
	}
}


package com.level3clues.evaluator.quest;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.plugins.cluescrolls.clues.CrypticClue;
import net.runelite.client.plugins.cluescrolls.clues.EmoteClue;
import net.runelite.client.plugins.cluescrolls.clues.LocationClueScroll;
import net.runelite.client.plugins.cluescrolls.clues.SkillChallengeClue;
import net.runelite.client.plugins.cluescrolls.clues.item.SingleItemRequirement;
import com.level3clues.evaluator.util.ItemRequirementHelper;

@Singleton
public class QuestRequirementChecker
{
	private static final Set<Integer> QUEST_LOCKED_CLUE_ITEM_IDS = new HashSet<>();
	private static final Set<WorldPoint> QUEST_LOCKED_CLUE_LOCATIONS = new HashSet<>();
	private static final Set<String> QUEST_LOCKED_CLUE_TEXTS = new HashSet<>();

	static
	{
		populateQuestLockedClues();
	}

	private static void populateQuestLockedClues()
	{
		QUEST_LOCKED_CLUE_ITEM_IDS.clear();
		QUEST_LOCKED_CLUE_LOCATIONS.clear();
		QUEST_LOCKED_CLUE_TEXTS.clear();

		QUEST_LOCKED_CLUE_ITEM_IDS.addAll(Arrays.asList(
		));

		QUEST_LOCKED_CLUE_LOCATIONS.addAll(Arrays.asList(
		));

		QUEST_LOCKED_CLUE_TEXTS.addAll(Arrays.asList(
		));
	}

	@Inject
	private ItemRequirementHelper itemRequirementHelper;

	public boolean requiresInaccessibleQuest(ClueScroll clue, ClueScrollPlugin clueScrollPlugin)
	{
		if (clue instanceof LocationClueScroll)
		{
			LocationClueScroll locationClue = (LocationClueScroll) clue;
			WorldPoint location = locationClue.getLocation(clueScrollPlugin);
			if (location != null && QUEST_LOCKED_CLUE_LOCATIONS.contains(location))
			{
				return true;
			}
		}

		if (clue instanceof EmoteClue)
		{
			EmoteClue emoteClue = (EmoteClue) clue;
			var requirements = emoteClue.getItemRequirements();
			if (requirements != null)
			{
				for (var req : requirements)
				{
					if (req instanceof SingleItemRequirement)
					{
						int itemId = itemRequirementHelper.getItemIdFromSingleRequirement((SingleItemRequirement) req);
						if (itemId != -1 && QUEST_LOCKED_CLUE_ITEM_IDS.contains(itemId))
						{
							return true;
						}
					}
				}
			}
			String text = emoteClue.getText();
			if (text != null && containsQuestLockedText(text))
			{
				return true;
			}
		}

		if (clue instanceof CrypticClue)
		{
			CrypticClue crypticClue = (CrypticClue) clue;
			String text = crypticClue.getText();
			if (text != null && containsQuestLockedText(text))
			{
				return true;
			}
			String solution = crypticClue.getSolution(clueScrollPlugin);
			if (solution != null && containsQuestLockedText(solution))
			{
				return true;
			}
		}

		if (clue instanceof SkillChallengeClue)
		{
			SkillChallengeClue skillChallenge = (SkillChallengeClue) clue;
			String challenge = skillChallenge.getChallenge();
			if (challenge != null && containsQuestLockedText(challenge))
			{
				return true;
			}
		}

		return false;
	}

	private boolean containsQuestLockedText(String text)
	{
		if (text == null)
		{
			return false;
		}

		String lowerText = text.toLowerCase();
		for (String questLockedText : QUEST_LOCKED_CLUE_TEXTS)
		{
			if (lowerText.contains(questLockedText.toLowerCase()))
			{
				return true;
			}
		}

		Set<String> mentionedQuests = extractQuestNames(text);
		for (String questName : mentionedQuests)
		{
			if (!SkillerCompletableQuests.isSkillerCompletable(questName))
			{
				return true;
			}
		}

		return false;
	}

	private Set<String> extractQuestNames(String text)
	{
		Set<String> questNames = new HashSet<>();
		if (text == null)
		{
			return questNames;
		}

		Pattern questPattern = Pattern.compile("(?:after|during|from|in|requires?|completing?|finished?|done with|\\()\\s*(?:the\\s+)?([A-Z][a-zA-Z&'\\s]+?)\\s*(?:quest|Quest|\\))", Pattern.CASE_INSENSITIVE);
		Matcher matcher = questPattern.matcher(text);
		while (matcher.find())
		{
			String questName = normalizeQuestName(matcher.group(1).trim());
			if (questName.length() > 2 && !questName.equalsIgnoreCase("the"))
			{
				questNames.add(questName);
			}
		}

		Pattern questPattern2 = Pattern.compile("([A-Z][a-zA-Z&'\\s]+?)\\s+(?:quest|Quest)(?:\\s+required|\\s+needed|\\s+unlocked)?", Pattern.CASE_INSENSITIVE);
		Matcher matcher2 = questPattern2.matcher(text);
		while (matcher2.find())
		{
			String questName = normalizeQuestName(matcher2.group(1).trim());
			if (questName.length() > 2 && !questName.equalsIgnoreCase("the"))
			{
				questNames.add(questName);
			}
		}

		return questNames;
	}

	private String normalizeQuestName(String questName)
	{
		if (questName == null)
		{
			return "";
		}
		questName = questName.trim();
		if (questName.startsWith("the ") || questName.startsWith("The "))
		{
			questName = questName.substring(4);
		}
		return questName;
	}
}


package com.level3clues.evaluator.location;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import javax.inject.Singleton;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.plugins.cluescrolls.clues.LocationClueScroll;

@Singleton
public class LocationValidator
{
	private static final Set<Integer> MORYTANIA_REGION_IDS = new HashSet<>(Arrays.asList(
		14388, 14389, 14390, 14391,
		14644, 14645, 14646, 14647,
		14899, 14900, 14901, 14902,
		15155, 15156, 15157, 15158
	));

	public boolean isInMorytania(ClueScroll clue, ClueScrollPlugin clueScrollPlugin)
	{
		if (clue instanceof LocationClueScroll)
		{
			LocationClueScroll locationClue = (LocationClueScroll) clue;
			WorldPoint location = locationClue.getLocation(clueScrollPlugin);
			if (location != null)
			{
				int regionId = location.getRegionID();
				return MORYTANIA_REGION_IDS.contains(regionId);
			}
		}
		return false;
	}
}


package com.level3clues.evaluator;

import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.plugins.cluescrolls.clues.CipherClue;
import net.runelite.client.plugins.cluescrolls.clues.CrypticClue;
import net.runelite.client.plugins.cluescrolls.clues.EmoteClue;
import net.runelite.client.plugins.cluescrolls.clues.FaloTheBardClue;
import net.runelite.client.plugins.cluescrolls.clues.SkillChallengeClue;
import net.runelite.client.plugins.cluescrolls.clues.ThreeStepCrypticClue;
import com.level3clues.evaluator.combat.CombatItemDetector;
import com.level3clues.evaluator.location.LocationValidator;
import com.level3clues.evaluator.quest.QuestRequirementChecker;

@Singleton
public class SkillerClueEvaluator
{
	@Inject
	private LocationValidator locationValidator;

	@Inject
	private QuestRequirementChecker questRequirementChecker;

	@Inject
	private CombatItemDetector combatItemDetector;

	public boolean isClueGoodForSkiller(ClueScroll clue, ClueScrollPlugin clueScrollPlugin)
	{
		if (clue == null)
		{
			return true;
		}

		if (locationValidator.isInMorytania(clue, clueScrollPlugin))
		{
			return false;
		}

		if (questRequirementChecker.requiresInaccessibleQuest(clue, clueScrollPlugin))
		{
			return false;
		}

		if (clue instanceof SkillChallengeClue)
		{
			SkillChallengeClue skillChallenge = (SkillChallengeClue) clue;
			String challenge = skillChallenge.getChallenge();
			if (challenge != null && combatItemDetector.requiresCombat(challenge))
			{
				return false;
			}
			String rawChallenge = skillChallenge.getRawChallenge();
			if (rawChallenge != null && combatItemDetector.requiresCombat(rawChallenge))
			{
				return false;
			}
			var requirements = skillChallenge.getItemRequirements();
			if (combatItemDetector.hasCombatRequirements(requirements))
			{
				return false;
			}
		}

		if (clue instanceof EmoteClue)
		{
			EmoteClue emoteClue = (EmoteClue) clue;
			var requirements = emoteClue.getItemRequirements();
			if (requirements != null && requirements.length > 0 && combatItemDetector.hasCombatRequirements(requirements))
			{
				return false;
			}
		}

		String clueText = getClueText(clue, clueScrollPlugin);
		if (clueText != null && combatItemDetector.requiresCombat(clueText))
		{
			return false;
		}

		return true;
	}

	private String getClueText(ClueScroll clue, ClueScrollPlugin clueScrollPlugin)
	{
		if (clue instanceof CrypticClue)
		{
			return ((CrypticClue) clue).getText();
		}

		if (clue instanceof CipherClue)
		{
			return ((CipherClue) clue).getText();
		}

		if (clue instanceof FaloTheBardClue)
		{
			return ((FaloTheBardClue) clue).getText();
		}

		if (clue instanceof ThreeStepCrypticClue)
		{
			return ((ThreeStepCrypticClue) clue).getText();
		}

		if (clue instanceof EmoteClue)
		{
			return ((EmoteClue) clue).getText();
		}

		return null;
	}
}


package com.level3clues;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import com.level3clues.evaluator.SkillerClueEvaluator;

public class Level3CluesOverlay extends OverlayPanel
{
	private final Level3CluesPlugin plugin;
	private final SkillerClueEvaluator evaluator;

	@Inject
	private Level3CluesOverlay(Level3CluesPlugin plugin, SkillerClueEvaluator evaluator)
	{
		super(plugin);
		this.plugin = plugin;
		this.evaluator = evaluator;
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(PRIORITY_HIGH);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.getConfig().showIndicator())
		{
			return null;
		}

		ClueScrollPlugin clueScrollPlugin = plugin.getClueScrollPlugin();
		if (clueScrollPlugin == null)
		{
			return null;
		}

		ClueScroll clue = clueScrollPlugin.getClue();
		if (clue == null)
		{
			return null;
		}

		boolean isGood = evaluator.isClueGoodForSkiller(clue, clueScrollPlugin);

		panelComponent.getChildren().add(LineComponent.builder()
			.left("lvl 3: " + (isGood ? "Good" : "Skip"))
			.leftColor(isGood ? Color.GREEN : Color.RED)
			.build());

		return super.render(graphics);
	}
}



package com.level3clues;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.game.ItemManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.ClueScrollConfig;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.plugins.cluescrolls.clues.MapClue;
import net.runelite.client.plugins.cluescrolls.clues.MusicClue;
import net.runelite.client.plugins.cluescrolls.clues.CoordinateClue;
import net.runelite.client.plugins.cluescrolls.clues.AnagramClue;
import net.runelite.client.plugins.cluescrolls.clues.CipherClue;
import net.runelite.client.plugins.cluescrolls.clues.CrypticClue;
import net.runelite.client.plugins.cluescrolls.clues.EmoteClue;
import net.runelite.client.plugins.cluescrolls.clues.FairyRingClue;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@PluginDescriptor(
	name = "Level 3 Clues",
	description = "Indicates whether clues are good or bad for level 3 skillers",
	tags = {"clues", "skiller", "level3"}
)
@PluginDependency(ClueScrollPlugin.class)
@Slf4j
public class Level3CluesPlugin extends Plugin
{
	@Inject
	private ClueScrollPlugin clueScrollPlugin;

	@Inject
	private Level3CluesConfig config;

	public Level3CluesConfig getConfig()
	{
		return config;
	}

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private Level3CluesOverlay overlay;

	@Inject
	private Level3CluesWorldOverlay worldOverlay;

	@Inject
	private ItemManager itemManager;

	@Inject
	private Client client;

	@Inject
	private com.level3clues.evaluator.SkillerClueEvaluator evaluator;

	@Inject
	private ConfigManager configManager;

	@Getter
	private final Map<Integer, ClueScroll> trackedClues = new ConcurrentHashMap<>();

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!config.deprioritizeBadClues())
		{
			return;
		}

		if (!event.getOption().equals("Take"))
		{
			return;
		}

		int itemId = event.getIdentifier();
		if (itemId <= 0)
		{
			return;
		}

		ItemComposition itemComposition = itemManager.getItemComposition(itemId);
		if (itemComposition == null)
		{
			return;
		}

		String itemName = itemComposition.getName();
		if (itemName == null || (!itemName.startsWith("Clue scroll")
			&& !itemName.startsWith("Challenge scroll")
			&& !itemName.startsWith("Treasure scroll")))
		{
			return;
		}

		ClueScroll clue = findClueScroll(itemId);
		if (clue == null)
		{
			return;
		}

		if (shouldTrackOnPickup())
		{
			trackedClues.put(itemId, clue);
		}

		boolean isGood = evaluator.isClueGoodForSkiller(clue, clueScrollPlugin);
		if (!isGood)
		{
			MenuEntry[] menuEntries = client.getMenuEntries();
			int takeIndex = -1;
			int walkHereIndex = -1;

			for (int i = 0; i < menuEntries.length; i++)
			{
				MenuEntry entry = menuEntries[i];
				if (entry.getIdentifier() == itemId && entry.getOption().equals("Take"))
				{
					takeIndex = i;
				}
				else if (entry.getOption().equals("Walk here"))
				{
					walkHereIndex = i;
				}
			}

			if (takeIndex >= 0 && walkHereIndex >= 0 && takeIndex < walkHereIndex)
			{
				MenuEntry takeEntry = menuEntries[takeIndex];
				MenuEntry walkEntry = menuEntries[walkHereIndex];
				menuEntries[takeIndex] = walkEntry;
				menuEntries[walkHereIndex] = takeEntry;
				client.setMenuEntries(menuEntries);
			}
			else if (takeIndex >= 0)
			{
				menuEntries[takeIndex].setDeprioritized(true);
			}
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuOption() == null)
		{
			return;
		}

		String menuOption = event.getMenuOption();
		boolean shouldTrack = false;

		if (menuOption.equals("Take") && shouldTrackOnPickup())
		{
			shouldTrack = true;
		}
		else if (menuOption.equals("Read") && !shouldTrackOnPickup())
		{
			shouldTrack = true;
		}

		if (shouldTrack)
		{
			int itemId = event.getItemId();
			if (itemId <= 0)
			{
				return;
			}

			ItemComposition itemComposition = itemManager.getItemComposition(itemId);
			if (itemComposition != null && (itemComposition.getName().startsWith("Clue scroll")
				|| itemComposition.getName().startsWith("Challenge scroll")
				|| itemComposition.getName().startsWith("Treasure scroll")))
			{
				ClueScroll clue = findClueScroll(itemId);
				if (clue != null)
				{
					trackedClues.put(itemId, clue);
				}
			}
		}
	}


	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		overlayManager.add(worldOverlay);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		overlayManager.remove(worldOverlay);
	}

	@Provides
	Level3CluesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(Level3CluesConfig.class);
	}

	public ClueScrollPlugin getClueScrollPlugin()
	{
		return clueScrollPlugin;
	}

	private boolean shouldTrackOnPickup()
	{
		ClueScrollConfig clueScrollConfig = configManager.getConfig(ClueScrollConfig.class);
		return clueScrollConfig.identify() == ClueScrollConfig.IdentificationMode.ON_PICKUP;
	}

	private ClueScroll findClueScroll(int itemId)
	{
		if (itemId == ItemID.TRAIL_CLUE_BEGINNER || itemId == ItemID.TRAIL_CLUE_MASTER)
		{
			return null;
		}

		ClueScroll clue = MapClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		clue = MusicClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		clue = CoordinateClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		clue = AnagramClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		clue = CipherClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		clue = CrypticClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		clue = EmoteClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		clue = FairyRingClue.forItemId(itemId);
		if (clue != null)
		{
			return clue;
		}

		return null;
	}
}


package com.level3clues;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ParamID;
import net.runelite.api.Perspective;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.cluescrolls.ClueScrollPlugin;
import net.runelite.client.plugins.cluescrolls.clues.ClueScroll;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import com.level3clues.evaluator.SkillerClueEvaluator;

public class Level3CluesWorldOverlay extends Overlay
{
	private final Level3CluesPlugin plugin;
	private final SkillerClueEvaluator evaluator;
	private final Client client;

	@Inject
	private Level3CluesWorldOverlay(Level3CluesPlugin plugin, SkillerClueEvaluator evaluator, Client client)
	{
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.plugin = plugin;
		this.evaluator = evaluator;
		this.client = client;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.getConfig().clueHighlights())
		{
			return null;
		}

		Map<Integer, ClueScroll> trackedClues = plugin.getTrackedClues();
		if (trackedClues.isEmpty())
		{
			return null;
		}

		ClueScrollPlugin clueScrollPlugin = plugin.getClueScrollPlugin();
		if (clueScrollPlugin == null)
		{
			return null;
		}

		Level3CluesConfig config = plugin.getConfig();

		Scene scene = client.getScene();
		Tile[][][] tiles = scene.getTiles();
		int plane = client.getPlane();

		for (int x = 0; x < 104; x++)
		{
			for (int y = 0; y < 104; y++)
			{
				Tile tile = tiles[plane][x][y];
				if (tile == null || tile.getGroundItems() == null)
				{
					continue;
				}

				for (TileItem item : tile.getGroundItems())
				{
					if (item == null)
					{
						continue;
					}

					ClueScroll trackedClue = trackedClues.get(item.getId());
					if (trackedClue != null)
					{
						ItemComposition itemComp = client.getItemDefinition(item.getId());
						if (itemComp != null && itemComp.getIntValue(ParamID.CLUE_SCROLL) != -1)
						{
							boolean isGood = evaluator.isClueGoodForSkiller(trackedClue, clueScrollPlugin);
							Color tileColor = isGood ? config.goodClueTileColor() : config.badClueTileColor();
							Color textColor = isGood ? config.goodClueTextColor() : config.badClueTextColor();
							String text = isGood ? "Good Clue" : "Bad Clue";

							WorldPoint worldPoint = tile.getWorldLocation();
							LocalPoint localPoint = LocalPoint.fromWorld(client, worldPoint);
							
							if (localPoint != null && worldPoint.isInScene(client))
							{
								Polygon tilePoly = Perspective.getCanvasTilePoly(client, localPoint);
								if (tilePoly != null)
								{
									OverlayUtil.renderPolygon(graphics, tilePoly, tileColor);
								}

								net.runelite.api.Point textPoint = Perspective.localToCanvas(client, localPoint, client.getPlane(), 50);
								if (textPoint != null)
								{
									FontMetrics fontMetrics = graphics.getFontMetrics();
									int textWidth = fontMetrics.stringWidth(text);
									net.runelite.api.Point centeredTextPoint = new net.runelite.api.Point(
										textPoint.getX() - textWidth / 2,
										textPoint.getY()
									);
									OverlayUtil.renderTextLocation(graphics, centeredTextPoint, text, textColor);
								}
							}
						}
					}
				}
			}
		}

		return null;
	}
}


package com.level3clues;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("level3clues")
public interface Level3CluesConfig extends Config
{
	@ConfigItem(
		keyName = "showIndicator",
		name = "Show Level 3 Skiller Indicator",
		description = "Display whether clues are good or bad for level 3 skillers",
		position = 0
	)
	default boolean showIndicator()
	{
		return true;
	}

	@ConfigSection(
		name = "Clue Highlighter",
		description = "Settings for highlighting clue tiles",
		position = 10
	)
	String clueHighlighterSection = "clueHighlighterSection";

	@ConfigItem(
		keyName = "clueHighlights",
		name = "Enable Clue Highlights",
		description = "Highlight the clue tile and show good/bad text on top of it",
		section = clueHighlighterSection,
		position = 1
	)
	default boolean clueHighlights()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "goodClueTileColor",
		name = "Good Clue Tile Color",
		description = "Color for highlighting good clue tiles",
		section = clueHighlighterSection,
		position = 2
	)
	default Color goodClueTileColor()
	{
		return new Color(0, 255, 0, 100);
	}

	@Alpha
	@ConfigItem(
		keyName = "badClueTileColor",
		name = "Bad Clue Tile Color",
		description = "Color for highlighting bad clue tiles",
		section = clueHighlighterSection,
		position = 3
	)
	default Color badClueTileColor()
	{
		return new Color(255, 0, 0, 100);
	}

	@Alpha
	@ConfigItem(
		keyName = "goodClueTextColor",
		name = "Good Clue Text Color",
		description = "Color for good clue text",
		section = clueHighlighterSection,
		position = 4
	)
	default Color goodClueTextColor()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		keyName = "badClueTextColor",
		name = "Bad Clue Text Color",
		description = "Color for bad clue text",
		section = clueHighlighterSection,
		position = 5
	)
	default Color badClueTextColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "deprioritizeBadClues",
		name = "Deprioritize Bad Clues",
		description = "Makes 'Walk here' the default action for bad clues to prevent accidental pickup",
		position = 20
	)
	default boolean deprioritizeBadClues()
	{
		return true;
	}
}



package com.level3clues;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class Level3CluesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(Level3CluesPlugin.class);
		RuneLite.main(args);
	}
}
