package ca.underwateragility;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(UWAPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package ca.underwateragility.tools;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Stroke;
import java.awt.geom.Line2D;
import java.util.List;
import javax.annotation.Nonnull;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;

public class WorldLines
{
	private static final Stroke STROKE = new BasicStroke(1);

	public static void drawLinesOnWorld(
		final Graphics2D graphics,
		final Client client,
		final List<WorldPoint> linePoints,
		final Color color)
	{
		for (int i = 0; i < linePoints.size() - 1; i++)
		{
			final WorldPoint startWp = linePoints.get(i);
			final WorldPoint endWp = linePoints.get(i + 1);

			if (startWp == null || endWp == null)
			{
				continue;
			}
			if (startWp.equals(new WorldPoint(0, 0, 0)))
			{
				continue;
			}
			if (endWp.equals(new WorldPoint(0, 0, 0)))
			{
				continue;
			}
			if (startWp.getPlane() != endWp.getPlane())
			{
				continue;
			}
			LocalPoint startLp = LocalPoint.fromWorld(client.getTopLevelWorldView(), startWp);
			LocalPoint endLp = LocalPoint.fromWorld(client.getTopLevelWorldView(), endWp);
			if (startLp == null && endLp == null)
			{
				continue;
			}

			final int MAX_LP = 13056;

			if (endLp == null)
			{
				// Work out point of intersection of loaded area
				final int xDiff = endWp.getX() - startWp.getX();
				final int yDiff = endWp.getY() - startWp.getY();

				final int changeToGetXToBorder;
				if (xDiff != 0)
				{
					int goalLine = 0;
					if (xDiff > 0)
					{
						goalLine = MAX_LP;
					}
					changeToGetXToBorder = (goalLine - startLp.getX()) / xDiff;
				}
				else
				{
					changeToGetXToBorder = Integer.MAX_VALUE;
				}
				final int changeToGetYToBorder;
				if (yDiff != 0)
				{
					int goalLine = 0;
					if (yDiff > 0)
					{
						goalLine = MAX_LP;
					}
					changeToGetYToBorder = (goalLine - startLp.getY()) / yDiff;
				}
				else
				{
					changeToGetYToBorder = Integer.MAX_VALUE;
				}
				if (Math.abs(changeToGetXToBorder) < Math.abs(changeToGetYToBorder))
				{
					endLp = new LocalPoint(startLp.getX() + (xDiff * changeToGetXToBorder), startLp.getY() + (yDiff * changeToGetXToBorder), client.getTopLevelWorldView());
				}
				else
				{
					endLp = new LocalPoint(startLp.getX() + (xDiff * changeToGetYToBorder), startLp.getY() + (yDiff * changeToGetYToBorder), client.getTopLevelWorldView());
				}
			}

			if (startLp == null)
			{
				// Work out point of intersection of loaded area
				final int xDiff = startWp.getX() - endWp.getX();
				final int yDiff = startWp.getY() - endWp.getY();

				// if diff negative, go to 0?
				final int changeToGetXToBorder;
				if (xDiff != 0)
				{
					int goalLine = 0;
					if (xDiff > 0)
					{
						goalLine = MAX_LP;
					}
					changeToGetXToBorder = (goalLine - endLp.getX()) / xDiff;
				}
				else
				{
					changeToGetXToBorder = 1000000000;
				}
				final int changeToGetYToBorder;
				if (yDiff != 0)
				{
					int goalLine = 0;
					if (yDiff > 0)
					{
						goalLine = MAX_LP;
					}
					changeToGetYToBorder = (goalLine - endLp.getY()) / yDiff;
				}
				else
				{
					changeToGetYToBorder = 1000000000;
				}

				if (Math.abs(changeToGetXToBorder) < Math.abs(changeToGetYToBorder))
				{
					startLp = new LocalPoint(endLp.getX() + (xDiff * changeToGetXToBorder), endLp.getY() + (yDiff * changeToGetXToBorder), client.getTopLevelWorldView());
				}
				else
				{
					startLp = new LocalPoint(endLp.getX() + (xDiff * changeToGetYToBorder), endLp.getY() + (yDiff * changeToGetYToBorder), client.getTopLevelWorldView());
				}
			}

			// If one is in scene, find local point we intersect with

			final Line2D.Double newLine = getWorldLines(client, startLp, endLp);
			if (newLine != null)
			{
				OverlayUtil.renderPolygon(graphics, newLine, color, STROKE);
			}
		}
	}

	private static Line2D.Double getWorldLines(
		@Nonnull final Client client,
		@Nonnull final LocalPoint startLocation,
		final LocalPoint endLocation)
	{
		final int plane = client.getTopLevelWorldView().getPlane();

		final int startX = startLocation.getX();
		final int startY = startLocation.getY();
		final int endX = endLocation.getX();
		final int endY = endLocation.getY();

		final int sceneX = startLocation.getSceneX();
		final int sceneY = startLocation.getSceneY();

		if (sceneX < 0 || sceneY < 0 || sceneX >= Constants.SCENE_SIZE || sceneY >= Constants.SCENE_SIZE)
		{
			return null;
		}

		final int startHeight = Perspective.getTileHeight(client, startLocation, plane);
		final int endHeight = Perspective.getTileHeight(client, endLocation, plane);

		final Point p1 = Perspective.localToCanvas(client, startX, startY, startHeight);
		final Point p2 = Perspective.localToCanvas(client, endX, endY, endHeight);

		if (p1 == null || p2 == null)
		{
			return null;
		}

		return new Line2D.Double(p1.getX(), p1.getY(), p2.getX(), p2.getY());
	}
}

/*
 * Copyright (c) 2024, roundshoe <https://github.com/roundshoe>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.underwateragility;

import java.awt.Color;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.ModifierlessKeybind;
import net.runelite.client.util.ColorUtil;

@ConfigGroup(UWAConfig.CONFIG_GROUP)
public interface UWAConfig extends Config
{
	String CONFIG_GROUP = "underwateragility";

	int DEFAULT_ALPHA = 40;

	// Sections

	@ConfigSection(
		name = "General",
		description = "General configuration.",
		position = 0
	)
	String SECTION_GENERAL = "generalSection";

	@ConfigSection(
		name = "Color",
		description = "Color configuration.",
		position = 1
	)
	String SECTION_COLOR = "colorSection";

	// General

	@ConfigItem(
		name = "Oxygen Overlay",
		description = "Overlay oxygen on the player.",
		position = 0,
		keyName = "oxygenBar",
		section = SECTION_GENERAL
	)
	default OxygenBar oxygenBar()
	{
		return OxygenBar.OFF;
	}

	@ConfigItem(
		name = "Obstacle Overlay",
		description = "Overlay obstacle clickboxes.",
		position = 1,
		keyName = "obstaclesOverlay",
		section = SECTION_GENERAL
	)
	default OutlineStyle obstaclesOverlay()
	{
		return OutlineStyle.OFF;
	}

	@ConfigItem(
		name = "Current Overlay",
		description = "Outline currents.",
		position = 2,
		keyName = "currentOverlay",
		section = SECTION_GENERAL
	)
	default boolean currentOverlay()
	{
		return false;
	}

	@ConfigItem(
		name = "Bubble Overlay",
		description = "Overlay bubbles.",
		position = 3,
		keyName = "bubbleOverlay",
		section = SECTION_GENERAL
	)
	default OverlayStyle bubbleOverlay()
	{
		return OverlayStyle.OFF;
	}

	@ConfigItem(
		name = "Chest/Clam Overlay",
		description = "Outline active chest/clam.",
		position = 4,
		keyName = "chestClamOverlay",
		section = SECTION_GENERAL
	)
	default OverlayStyle chestClamOverlay()
	{
		return OverlayStyle.OFF;
	}

	@ConfigItem(
		name = "Hole Overlay",
		description = "Outline holes.",
		position = 5,
		keyName = "holeOverlay",
		section = SECTION_GENERAL
	)
	default OverlayStyle holeOverlay()
	{
		return OverlayStyle.OFF;
	}

	@ConfigItem(
		name = "Puffer Fish Overlay",
		description = "Overlay puffer fish.",
		position = 6,
		keyName = "pufferFishOverlay",
		section = SECTION_GENERAL
	)
	default OverlayStyle pufferFishOverlay()
	{
		return OverlayStyle.OFF;
	}

	String CONFIG_KEY_CHEST_CLAM_TIMER = "chestClamTimer";

	@ConfigItem(
		name = "Chest/Clam Timer",
		description = "Display an infobox timer when the chest/clam moves.",
		position = 7,
		keyName = CONFIG_KEY_CHEST_CLAM_TIMER,
		section = SECTION_GENERAL
	)
	default boolean chestClamTimer()
	{
		return false;
	}

	@ConfigItem(
		name = "Chest/Clam Line",
		description = "Draw a line between the player and the chest/clam.",
		position = 8,
		keyName = "chestClamLine",
		section = SECTION_GENERAL
	)
	default boolean chestClamLine()
	{
		return false;
	}

	@ConfigItem(
		name = "Hole Lines",
		description = "Draw lines between connecting holes.",
		position = 9,
		keyName = "holeLines",
		section = SECTION_GENERAL
	)
	default boolean holeLines()
	{
		return false;
	}

	@ConfigItem(
		name = "Lines Require Key Press",
		description = "Draw lines only while holding down configured key.",
		position = 10,
		keyName = "linesPressKey",
		section = SECTION_GENERAL
	)
	default boolean linesPressKey()
	{
		return false;
	}

	@ConfigItem(
		name = "Lines Key",
		description = "The key to press to draw lines.",
		position = 11,
		keyName = "linesKey",
		section = SECTION_GENERAL
	)
	default ModifierlessKeybind linesKey()
	{
		return new ModifierlessKeybind(KeyEvent.VK_SHIFT, InputEvent.SHIFT_DOWN_MASK);
	}

	@ConfigItem(
		name = "Information Panel Overlay",
		description = "Display an information panel overlay.",
		position = 12,
		keyName = "informationPanelOverlay",
		section = SECTION_GENERAL
	)
	default boolean informationPanelOverlay()
	{
		return false;
	}

	@ConfigItem(
		name = "Replace Swim Animation",
		description = "Replaces the swim animation with walking.",
		position = 13,
		keyName = "replaceSwimAniamtion",
		section = SECTION_GENERAL
	)
	default boolean replaceSwimAniamtion()
	{
		return false;
	}

	String CONFIG_KEY_HIDE_OXYGEN_WIDGET = "hideOxygenWidget";

	@ConfigItem(
		name = "Hide Oxygen Widget",
		description = "Hide the oxygen widget.",
		position = 14,
		keyName = CONFIG_KEY_HIDE_OXYGEN_WIDGET,
		section = SECTION_GENERAL
	)
	default boolean hideOxygenWidget()
	{
		return false;
	}

	String CONFIG_KEY_HIDE_WATER_WIDGET = "hideWaterWidget";

	@ConfigItem(
		name = "Hide Water Widget",
		description = "Hide the water widget.",
		position = 15,
		keyName = CONFIG_KEY_HIDE_WATER_WIDGET,
		section = SECTION_GENERAL
	)
	default boolean hideWaterWidget()
	{
		return false;
	}

	String CONFIG_KEY_HIDE_SCENERY = "hideScenery";

	@ConfigItem(
		name = "Hide Scenery",
		description = "Hide scenery.",
		position = 16,
		keyName = CONFIG_KEY_HIDE_SCENERY,
		section = SECTION_GENERAL
	)
	default boolean hideScenery()
	{
		return false;
	}

	// Color

	@Alpha
	@ConfigItem(
		name = "Obstacle Outline",
		description = "Obstacle outline color.",
		position = 0,
		keyName = "obstaclesOutlineColor",
		section = SECTION_COLOR
	)
	default Color obstaclesOutlineColor()
	{
		return Color.GREEN;
	}

	@Alpha
	@ConfigItem(
		name = "Obstacle Fill",
		description = "Obstacle fill color.",
		position = 1,
		keyName = "obstaclesFillColor",
		section = SECTION_COLOR
	)
	default Color obstaclesFillColor()
	{
		return ColorUtil.colorWithAlpha(Color.GREEN, DEFAULT_ALPHA);
	}

	@Alpha
	@ConfigItem(
		name = "Current Outline",
		description = "Current outline color.",
		position = 2,
		keyName = "currentOutlineColor",
		section = SECTION_COLOR
	)
	default Color currentOutlineColor()
	{
		return ColorUtil.colorWithAlpha(Color.RED, 0);
	}

	@Alpha
	@ConfigItem(
		name = "Current Fill",
		description = "Current fill color.",
		position = 3,
		keyName = "currentFillColor",
		section = SECTION_COLOR
	)
	default Color currentFillColor()
	{
		return ColorUtil.colorWithAlpha(Color.RED, DEFAULT_ALPHA);
	}

	@Alpha
	@ConfigItem(
		name = "Bubble Outline",
		description = "Bubbles outline color.",
		position = 4,
		keyName = "bubbleOutlineColor",
		section = SECTION_COLOR
	)
	default Color bubbleOutlineColor()
	{
		return Color.CYAN;
	}

	@Alpha
	@ConfigItem(
		name = "Bubble Fill",
		description = "Bubbles fill color.",
		position = 5,
		keyName = "bubbleFillColor",
		section = SECTION_COLOR
	)
	default Color bubbleFillColor()
	{
		return ColorUtil.colorWithAlpha(Color.CYAN, DEFAULT_ALPHA);
	}

	@Alpha
	@ConfigItem(
		name = "Chest/Clam Outline",
		description = "Chest/clam outline color.",
		position = 6,
		keyName = "chestClamOutlineColor",
		section = SECTION_COLOR
	)
	default Color chestClamOutlineColor()
	{
		return Color.MAGENTA;
	}

	@Alpha
	@ConfigItem(
		name = "Chest/Clam Fill",
		description = "Chest/clam fill color.",
		position = 7,
		keyName = "chestClamFillColor",
		section = SECTION_COLOR
	)
	default Color chestClamFillColor()
	{
		return ColorUtil.colorWithAlpha(Color.MAGENTA, DEFAULT_ALPHA);
	}

	@Alpha
	@ConfigItem(
		name = "Hole Outline",
		description = "Hole outline color.",
		position = 8,
		keyName = "holeOutlineColor",
		section = SECTION_COLOR
	)
	default Color holeOutlineColor()
	{
		return Color.YELLOW;
	}

	@Alpha
	@ConfigItem(
		name = "Hole Fill",
		description = "Hole fill color.",
		position = 9,
		keyName = "holeFillColor",
		section = SECTION_COLOR
	)
	default Color holeFillColor()
	{
		return ColorUtil.colorWithAlpha(Color.YELLOW, DEFAULT_ALPHA);
	}

	@Alpha
	@ConfigItem(
		name = "Puffer Fish Outline",
		description = "Puffer fish outline color.",
		position = 10,
		keyName = "pufferFishOutlineColor",
		section = SECTION_COLOR
	)
	default Color pufferFishOutlineColor()
	{
		return Color.BLUE;
	}

	@Alpha
	@ConfigItem(
		name = "Puffer Fish Fill",
		description = "Puffer fish fill color.",
		position = 11,
		keyName = "pufferFishFillColor",
		section = SECTION_COLOR
	)
	default Color pufferFishFillColor()
	{
		return ColorUtil.colorWithAlpha(Color.BLUE, DEFAULT_ALPHA);
	}

	// enum

	enum OxygenBar
	{
		OFF,
		PERCENT,
		TICKS
	}

	enum OverlayStyle
	{
		OFF,
		SCENE,
		MINIMAP,
		BOTH
	}

	enum OutlineStyle
	{
		OFF,
		CLICKBOX,
		TILE
	}
}

/*
 * Copyright (c) 2024, roundshoe <https://github.com/roundshoe>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.underwateragility;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Collection;
import java.util.Objects;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.TileObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Singleton
class UWAMinimapOverlay extends Overlay
{
	private final UWAPlugin plugin;
	private final UWAConfig config;

	@Inject
	UWAMinimapOverlay(final UWAPlugin plugin, final UWAConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(Overlay.PRIORITY_HIGH);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		var style = config.bubbleOverlay();

		if (style == UWAConfig.OverlayStyle.MINIMAP || style == UWAConfig.OverlayStyle.BOTH)
		{
			renderMinimapTileObject(graphics2D, plugin.getBubbles(), config.bubbleOutlineColor());
		}

		style = config.holeOverlay();

		if (style == UWAConfig.OverlayStyle.MINIMAP || style == UWAConfig.OverlayStyle.BOTH)
		{
			renderMinimapTileObject(graphics2D, plugin.getHoles(), config.holeOutlineColor());
		}

		style = config.chestClamOverlay();

		if (style == UWAConfig.OverlayStyle.MINIMAP || style == UWAConfig.OverlayStyle.BOTH)
		{
			renderMinimapTileObject(graphics2D, plugin.getChestClams(), config.chestClamOutlineColor());
		}

		style = config.pufferFishOverlay();

		if (style == UWAConfig.OverlayStyle.MINIMAP || style == UWAConfig.OverlayStyle.BOTH)
		{
			renderMinimapActor(graphics2D, plugin.getPufferFish(), config.pufferFishOutlineColor());
		}

		return null;
	}

	private void renderMinimapTileObject(final Graphics2D graphics2D, final Collection<TileObject> tileObjects, final Color color)
	{
		tileObjects.stream()
			.map(TileObject::getMinimapLocation)
			.filter(Objects::nonNull)
			.forEach(p -> OverlayUtil.renderMinimapLocation(graphics2D, p, color));
	}

	private void renderMinimapActor(final Graphics2D graphics2D, final Collection<NPC> npcs, final Color color)
	{
		npcs.stream()
			.map(Actor::getMinimapLocation)
			.filter(Objects::nonNull)
			.forEach(p -> OverlayUtil.renderMinimapLocation(graphics2D, p, color));
	}
}

/*
 * Copyright (c) 2020, R438
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.underwateragility;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
class UWAInformationOverlayPanel extends OverlayPanel
{
	private final UWAPlugin plugin;
	private final UWAConfig config;

	@Inject
	UWAInformationOverlayPanel(final UWAPlugin plugin, final UWAConfig config)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;

		setPosition(OverlayPosition.BOTTOM_RIGHT);
		setPriority(Overlay.PRIORITY_HIGH);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		if (!config.informationPanelOverlay())
		{
			return null;
		}

		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Underwater Agility")
			.color(Color.CYAN)
			.build());

		final int ticksRemaining = plugin.getTicksRemaining();

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Ticks:")
			.right(ticksRemaining >= 0 ? Integer.toString(ticksRemaining) : "?")
			.build());

		final int distance = plugin.getDistanceToTarget();

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Distance:")
			.right(distance >= 0 ? Integer.toString(distance) : "?")
			.build());

		final boolean adjacent = plugin.isBubbleAdjacent();

		final int oxygenTicks = plugin.getOxygenTicks();

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Oxygen:")
			.right(Integer.toString(oxygenTicks))
			.build());

		panelComponent.getChildren().add(LineComponent.builder()
			.left("Bubble:")
			.right(adjacent ? "Yes" : "No")
			.rightColor(adjacent ? Color.GREEN : Color.RED)
			.build());

//		final var wp = plugin.getTargetWorldPoint();
//
//		if (wp != null)
//		{
//			panelComponent.getChildren().add(LineComponent.builder()
//				.left("Debug:")
//				.right(String.format("%d, %d", wp.getX(), wp.getY()))
//				.build());
//		}

		return super.render(graphics2D);
	}
}

/*
 * Copyright (c) 2024, roundshoe <https://github.com/roundshoe>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.underwateragility;

import com.google.inject.Provides;
import java.awt.event.KeyEvent;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.GroundObject;
import net.runelite.api.HintArrowType;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.NullObjectID;
import net.runelite.api.ObjectID;
import net.runelite.api.Renderable;
import net.runelite.api.TileObject;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.callback.Hooks;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.ui.overlay.infobox.Timer;
import net.runelite.client.util.GameEventManager;

@Singleton
@PluginDescriptor(
	name = "Underwater Agility",
	description = "A plugin for Underwater Agility.",
	tags = {"under", "water", "underwater", "agility", "fossil", "island"}
)
public class UWAPlugin extends Plugin implements KeyListener
{
	private static final Set<Integer> REGION_IDS = Set.of(15008, 15264);

	private static final Set<Integer> GAME_OBJECT_IDS_IGNORE = Set.of(
		16984, 30500, 30501, 30734, 30735, 30738, 30740, 30741, 30742, 30743,
		30744, 30759, 30760, 30761, 30762, 30783, 30784, 30785, 30787, 30947,
		30948, 30957, 30958, 30959, 30962, 30963, 30964, 30965, 30966, 30969,
		30970, 30971, 30972, 30987, 31433, 31434, 31435, 31843
	);
	private static final Set<Integer> GROUND_OBJECT_IDS_IGNORE = Collections.singleton(7517);
	private static final Set<Integer> NPC_IDS_IGNORE = Set.of(7757, 7758, 7782, 7783, 7784, 7796, 8667);

	private static final Set<WorldPoint> WORLD_POINTS_BUBBLE_CHESTS = Set.of(
		new WorldPoint(3742, 10242, 1), new WorldPoint(3744, 10242, 1),
		new WorldPoint(3751, 10267, 1), new WorldPoint(3752, 10269, 1),
		new WorldPoint(3753, 10266, 1), new WorldPoint(3760, 10259, 1),
		new WorldPoint(3766, 10264, 1), new WorldPoint(3777, 10279, 1),
		new WorldPoint(3779, 10274, 1), new WorldPoint(3782, 10254, 1),
		new WorldPoint(3782, 10256, 1), new WorldPoint(3785, 10266, 1),
		new WorldPoint(3787, 10254, 1), new WorldPoint(3791, 10255, 1),
		new WorldPoint(3804, 10265, 1), new WorldPoint(3811, 10261, 1),
		new WorldPoint(3813, 10249, 1), new WorldPoint(3815, 10285, 1),
		new WorldPoint(3817, 20184, 1), new WorldPoint(3821, 10248, 1),
		new WorldPoint(3833, 10243, 1));

	private static final int SCRIPT_ID_OXYGEN = 1997;
	private static final int WIDGET_GROUP_ID_WATER1 = 169;
	private static final int WIDGET_GROUP_ID_WATER2 = 170;
	private static final int WIDGET_GROUP_ID_OXYGEN = 609;
	private static final int WATER_WIDGET_DEFAULT_OPACITY = 140;
	private static final int TICK_COUNT_CHEST = 100;

	private final Hooks.RenderableDrawListener drawListener = this::shouldDraw;

	@Getter(AccessLevel.PACKAGE)
	private final List<TileObject> bubbles = new ArrayList<>();
	@Getter(AccessLevel.PACKAGE)
	private final List<TileObject> chestClams = new ArrayList<>();
	@Getter(AccessLevel.PACKAGE)
	private final List<TileObject> obstacles = new ArrayList<>();
	@Getter(AccessLevel.PACKAGE)
	private final List<GameObject> currents = new ArrayList<>();
	@Getter(AccessLevel.PACKAGE)
	private final List<TileObject> holes = new ArrayList<>();
	@Getter(AccessLevel.PACKAGE)
	private final List<NPC> pufferFish = new ArrayList<>();
	@Getter(AccessLevel.PACKAGE)
	private final List<WorldPoint> chestClamLines = new ArrayList<>();

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private UWAConfig config;
	@Inject
	private Hooks hooks;
	@Inject
	private InfoBoxManager infoBoxManager;
	@Inject
	private ItemManager itemManager;
	@Inject
	private KeyManager keyManager;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private UWASceneOverlay uwaSceneOverlay;
	@Inject
	private UWAMinimapOverlay uwaMinimapOverlay;
	@Inject
	private UWAInformationOverlayPanel uwaInformationOverlayPanel;
	@Inject
	private GameEventManager gameEventManager;

	@Nullable
	@Getter(AccessLevel.PACKAGE)
	private WorldPoint targetWorldPoint;
	@Nullable
	private Timer timer;

	@Getter(AccessLevel.PACKAGE)
	private int distanceToTarget = -1;
	@Getter(AccessLevel.PACKAGE)
	private int ticksRemaining = -1;
	@Getter(AccessLevel.PACKAGE)
	private int oxygen;
	@Getter(AccessLevel.PACKAGE)
	private int oxygenTicks;

	@Getter(AccessLevel.PACKAGE)
	private boolean bubbleAdjacent;
	@Getter(AccessLevel.PACKAGE)
	private boolean keyPressed;
	private boolean enabled;

	@Provides
	UWAConfig provideConfig(final ConfigManager configManager)
	{
		return configManager.getConfig(UWAConfig.class);
	}

	@Override
	public void startUp()
	{
		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN && inRegion())
			{
				init();
			}
		});
	}

	private void init()
	{
		enabled = true;

		hooks.registerRenderableDrawListener(drawListener);
		keyManager.registerKeyListener(this);

		overlayManager.add(uwaSceneOverlay);
		overlayManager.add(uwaMinimapOverlay);
		overlayManager.add(uwaInformationOverlayPanel);

		hideOxygenWidget(config.hideOxygenWidget());
		hideWaterWidget(config.hideWaterWidget());

		gameEventManager.simulateGameEvents(this);
	}

	@Override
	public void shutDown()
	{
		enabled = false;

		hooks.unregisterRenderableDrawListener(drawListener);
		keyManager.unregisterKeyListener(this);

		overlayManager.remove(uwaSceneOverlay);
		overlayManager.remove(uwaMinimapOverlay);
		overlayManager.remove(uwaInformationOverlayPanel);

		clearObjects();
		pufferFish.clear();
		chestClamLines.clear();

		targetWorldPoint = null;

		bubbleAdjacent = false;
		keyPressed = false;

		distanceToTarget = -1;
		ticksRemaining = -1;
		oxygen = 0;
		oxygenTicks = 0;

		removeTimer();

		hideOxygenWidget(false);
		hideWaterWidget(false);

		setGameStateLoading();
	}

	private void clearObjects()
	{
		bubbles.clear();
		chestClams.clear();
		obstacles.clear();
		currents.clear();
		holes.clear();
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		if (!enabled || !event.getGroup().equals(UWAConfig.CONFIG_GROUP))
		{
			return;
		}

		final String key = event.getKey();

		switch (key)
		{
			case UWAConfig.CONFIG_KEY_HIDE_SCENERY:
				setGameStateLoading();
				break;
			case UWAConfig.CONFIG_KEY_HIDE_WATER_WIDGET:
				hideWaterWidget(config.hideWaterWidget());
				break;
			case UWAConfig.CONFIG_KEY_HIDE_OXYGEN_WIDGET:
				hideOxygenWidget(config.hideOxygenWidget());
				break;
			case UWAConfig.CONFIG_KEY_CHEST_CLAM_TIMER:
				removeTimer();
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event)
	{
		final GameState gameState = event.getGameState();

		switch (gameState)
		{
			case LOGGED_IN:
				if (inRegion())
				{
					if (!enabled)
					{
						init();
					}
				}
				else
				{
					if (enabled)
					{
						shutDown();
					}
				}
				break;
			case LOADING:
				if (enabled)
				{
					clearObjects();
				}
				break;
			case LOGIN_SCREEN:
			case HOPPING:
				shutDown();
				break;
		}
	}

	@Subscribe
	public void onGameTick(final GameTick event)
	{
		if (!enabled)
		{
			return;
		}

		if (oxygen < 1000 && oxygenTicks > 0)
		{
			--oxygenTicks;
		}

		if (ticksRemaining >= 0)
		{
			--ticksRemaining;
		}

		updateTargetWorldPoint();
		updateDistanceToTarget();
		updateChestClamLines();
		updatePlayerAnimations();
	}

	@Subscribe
	public void onNpcSpawned(final NpcSpawned event)
	{
		if (!enabled)
		{
			return;
		}

		final NPC npc = event.getNpc();

		if (npc.getId() == NpcID.PUFFER_FISH_8667)
		{
			pufferFish.add(npc);
		}
	}

	@Subscribe
	public void onNpcDespawned(final NpcDespawned event)
	{
		if (!enabled)
		{
			return;
		}

		final NPC npc = event.getNpc();

		if (npc.getId() == NpcID.PUFFER_FISH_8667)
		{
			pufferFish.remove(npc);
		}
	}

	@Subscribe
	public void onGameObjectSpawned(final GameObjectSpawned event)
	{
		if (!enabled)
		{
			return;
		}

		final GameObject gameObject = event.getGameObject();
		final int id = gameObject.getId();

		switch (id)
		{
			case ObjectID.CLAM_30969:
			case ObjectID.CHEST_30971:
				chestClams.add(gameObject);
				break;
			case ObjectID.TUNNEL_30959:
			case ObjectID.OBSTACLE_30962:
			case ObjectID.OBSTACLE_30964:
				obstacles.add(gameObject);
				break;
			case ObjectID.CURRENT:
				currents.add(gameObject);
				break;
			case ObjectID.HOLE_30966:
				holes.add(gameObject);
				break;
			case NullObjectID.NULL_30957:
				bubbles.add(gameObject);
				break;
			default:
				break;
		}

		if (config.hideScenery() && !GAME_OBJECT_IDS_IGNORE.contains(id))
		{
			client.getTopLevelWorldView().getScene().removeGameObject(gameObject);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(final GameObjectDespawned event)
	{
		if (!enabled)
		{
			return;
		}

		final GameObject gameObject = event.getGameObject();
		final int id = gameObject.getId();

		switch (id)
		{
			case ObjectID.CLAM_30969:
			case ObjectID.CHEST_30971:
				chestClams.remove(gameObject);
				break;
			case ObjectID.TUNNEL_30959:
			case ObjectID.OBSTACLE_30962:
			case ObjectID.OBSTACLE_30964:
				obstacles.remove(gameObject);
				break;
			case ObjectID.CURRENT:
				currents.remove(gameObject);
				break;
			case ObjectID.HOLE_30966:
				holes.remove(gameObject);
				break;
			case NullObjectID.NULL_30957:
				bubbles.remove(gameObject);
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onGroundObjectSpawned(final GroundObjectSpawned event)
	{
		if (!enabled || !config.hideScenery())
		{
			return;
		}

		final GroundObject groundObject = event.getGroundObject();
		final int id = groundObject.getId();

		if (!GROUND_OBJECT_IDS_IGNORE.contains(id))
		{
			event.getTile().setGroundObject(null);
		}
	}

	@Subscribe
	public void onScriptPreFired(final ScriptPreFired event)
	{
		if (!enabled || event.getScriptId() != SCRIPT_ID_OXYGEN)
		{
			return;
		}

		updateOxygen();
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event)
	{
		if (!enabled)
		{
			return;
		}

		final int groupId = event.getGroupId();

		switch (groupId)
		{
			case WIDGET_GROUP_ID_WATER1:
			case WIDGET_GROUP_ID_WATER2:
				hideWaterWidget(config.hideWaterWidget());
				break;
			case WIDGET_GROUP_ID_OXYGEN:
				hideOxygenWidget(config.hideOxygenWidget());
				break;
			default:
				break;
		}
	}

	private boolean inRegion()
	{
		return Arrays.stream(client.getTopLevelWorldView().getMapRegions()).anyMatch(REGION_IDS::contains);
	}

	private void setGameStateLoading()
	{
		clientThread.invokeLater(() -> {
			if (client.getGameState() == GameState.LOGGED_IN)
			{
				client.setGameState(GameState.LOADING);
			}
		});
	}

	private void updateOxygen()
	{
		oxygen = client.getVarbitValue(Varbits.OXYGEN_LEVEL);
		oxygenTicks = (oxygen * 3) / 10;
	}

	private void hideWaterWidget(final boolean hidden)
	{
		Widget widget = client.getWidget(WIDGET_GROUP_ID_WATER1, 0);

		if (widget != null)
		{
			widget.setOpacity(hidden ? 255 : WATER_WIDGET_DEFAULT_OPACITY);
		}

		widget = client.getWidget(WIDGET_GROUP_ID_WATER2, 0);

		if (widget != null)
		{
			widget.setOpacity(hidden ? 255 : WATER_WIDGET_DEFAULT_OPACITY);
		}
	}

	private void hideOxygenWidget(final boolean hidden)
	{
		for (int i = 3; i <= 6; ++i)
		{
			final Widget widget = client.getWidget(WIDGET_GROUP_ID_OXYGEN, i);

			if (widget != null)
			{
				widget.setOpacity(hidden ? 255 : 0);
			}
		}
	}

	private void updateTargetWorldPoint()
	{
		if (client.getHintArrowType() != HintArrowType.COORDINATE)
		{
			targetWorldPoint = null;
			return;
		}

		final WorldPoint worldPoint = client.getHintArrowPoint();

		if (worldPoint == null)
		{
			targetWorldPoint = null;
			return;
		}

		if (worldPoint.equals(targetWorldPoint))
		{
			return;
		}

		targetWorldPoint = worldPoint;

		updateTimer();
		updateTicksRemaining();
		updateBubbleAdjacent(worldPoint);
	}

	private void updateDistanceToTarget()
	{
		if (targetWorldPoint != null)
		{
			distanceToTarget = client.getLocalPlayer().getWorldLocation().distanceTo2D(targetWorldPoint);
		}
	}

	private void removeTimer()
	{
		infoBoxManager.removeInfoBox(timer);
		timer = null;
	}

	private void updateTimer()
	{
		removeTimer();

		if (config.chestClamTimer())
		{
			timer = new Timer((long) (TICK_COUNT_CHEST * 0.6), ChronoUnit.SECONDS, itemManager.getImage(ItemID.MERMAIDS_TEAR, 3, false), this);
			timer.setTooltip("Underwater Agility");
			infoBoxManager.addInfoBox(timer);
		}
	}

	private void updateTicksRemaining()
	{
		ticksRemaining = TICK_COUNT_CHEST;
	}

	private void updateBubbleAdjacent(final WorldPoint target)
	{
		for (final var wp : WORLD_POINTS_BUBBLE_CHESTS)
		{
			if (wp.getX() == target.getX() && wp.getY() == target.getY())
			{
				bubbleAdjacent = true;
				return;
			}
		}

		bubbleAdjacent = false;
	}

	private void updateChestClamLines()
	{
		chestClamLines.clear();

		if (targetWorldPoint == null)
		{
			return;
		}

		chestClamLines.add(client.getLocalPlayer().getWorldLocation());
		chestClamLines.add(new WorldPoint(targetWorldPoint.getX(), targetWorldPoint.getY(), 1));
	}

	private void updatePlayerAnimations()
	{
		if (!config.replaceSwimAniamtion())
		{
			return;
		}

		final var player = client.getLocalPlayer();

		if (player.getIdlePoseAnimation() != 808)
		{
			player.setIdlePoseAnimation(808);
			player.setIdleRotateLeft(823);
			player.setIdleRotateRight(823);
			player.setWalkAnimation(819);
			player.setWalkRotateLeft(821);
			player.setWalkRotateRight(822);
			player.setWalkRotate180(820);
			player.setRunAnimation(824);
		}
	}

	private boolean shouldDraw(final Renderable renderable, final boolean drawingUI)
	{
		if (config.hideScenery())
		{
			if (renderable instanceof NPC)
			{
				final NPC npc = (NPC) renderable;
				final int id = npc.getId();

				return NPC_IDS_IGNORE.contains(id);
			}
		}

		return true;
	}

	@Override
	public void keyTyped(final KeyEvent e)
	{
	}

	@Override
	public void keyPressed(final KeyEvent e)
	{
		if (enabled && config.linesKey().matches(e))
		{
			keyPressed = true;
		}
	}

	@Override
	public void keyReleased(final KeyEvent e)
	{
		if (enabled && config.linesKey().matches(e))
		{
			keyPressed = false;
		}
	}
}

/*
 * Copyright (c) 2024, roundshoe <https://github.com/roundshoe>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package ca.underwateragility;

import ca.underwateragility.UWAConfig.OutlineStyle;
import ca.underwateragility.UWAConfig.OverlayStyle;
import ca.underwateragility.UWAConfig.OxygenBar;
import ca.underwateragility.tools.WorldLines;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.TileObject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;
import net.runelite.client.util.ColorUtil;

@Singleton
class UWASceneOverlay extends Overlay
{
	private static final List<List<WorldPoint>> HOLE_WORLD_POINTS = List.of(
		List.of(new WorldPoint(3772, 10267, 1), new WorldPoint(3823, 10247, 1)),
		List.of(new WorldPoint(3772, 10280, 1), new WorldPoint(3816, 10271, 1)),
		List.of(new WorldPoint(3789, 10298, 1), new WorldPoint(3833, 10289, 1)),
		List.of(new WorldPoint(3754, 10241, 1), new WorldPoint(3779, 10241, 1)),
		List.of(new WorldPoint(3779, 10277, 1), new WorldPoint(3716, 10243, 1))
	);

	private static final Stroke STROKE = new BasicStroke(1);

	private final Client client;
	private final UWAPlugin plugin;
	private final UWAConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	UWASceneOverlay(
		final Client client,
		final UWAPlugin plugin,
		final UWAConfig config,
		final ModelOutlineRenderer modelOutlineRenderer)
	{
		super(plugin);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(Overlay.PRIORITY_HIGH);
	}

	@Override
	public Dimension render(final Graphics2D graphics2D)
	{
		if (config.currentOverlay())
		{
			renderCurrents(graphics2D);
		}

		if (!config.linesPressKey() || plugin.isKeyPressed())
		{
			if (config.holeLines())
			{
				for (final var points : HOLE_WORLD_POINTS)
				{
					WorldLines.drawLinesOnWorld(graphics2D, client, points, Color.CYAN);
				}
			}

			if (config.chestClamLine())
			{
				WorldLines.drawLinesOnWorld(graphics2D, client, plugin.getChestClamLines(), Color.MAGENTA);
			}
		}

		if (config.obstaclesOverlay() != OutlineStyle.OFF)
		{
			renderObstacles(graphics2D);
		}

		var style = config.bubbleOverlay();

		if (style == OverlayStyle.SCENE || style == OverlayStyle.BOTH)
		{
			renderBubbles(graphics2D);
		}

		style = config.holeOverlay();

		if (style == OverlayStyle.SCENE || style == OverlayStyle.BOTH)
		{
			renderHoles(graphics2D);
		}

		style = config.pufferFishOverlay();

		if (style == OverlayStyle.SCENE || style == OverlayStyle.BOTH)
		{
			renderPufferFish(graphics2D);
		}

		style = config.chestClamOverlay();

		if (style == OverlayStyle.SCENE || style == OverlayStyle.BOTH)
		{
			renderChestsClams(graphics2D);
		}

		if (config.oxygenBar() != OxygenBar.OFF)
		{
			renderOxygenBar(graphics2D);
		}

		return null;
	}

	private void renderCurrents(final Graphics2D graphics2D)
	{
		plugin.getCurrents().stream()
			.map(TileObject::getCanvasTilePoly)
			.filter(Objects::nonNull)
			.forEach(s -> {
				graphics2D.setStroke(STROKE);
				graphics2D.setColor(config.currentOutlineColor());
				graphics2D.draw(s);

				graphics2D.setColor(config.currentFillColor());
				graphics2D.fill(s);
			});
	}

	private void renderObstacles(final Graphics2D graphics2D)
	{
		final Function<TileObject, Shape> func = config.obstaclesOverlay() == OutlineStyle.CLICKBOX ?
			TileObject::getClickbox : TileObject::getCanvasTilePoly;

		plugin.getObstacles().stream()
			.map(func)
			.filter(Objects::nonNull)
			.forEach(s -> {
				graphics2D.setStroke(STROKE);
				graphics2D.setColor(config.obstaclesOutlineColor());
				graphics2D.draw(s);

				graphics2D.setColor(config.obstaclesFillColor());
				graphics2D.fill(s);
			});
	}

	private void renderBubbles(final Graphics2D graphics2D)
	{
		plugin.getBubbles().stream()
			.map(TileObject::getCanvasTilePoly)
			.filter(Objects::nonNull)
			.forEach(s -> {
				graphics2D.setStroke(STROKE);
				graphics2D.setColor(config.bubbleOutlineColor());
				graphics2D.draw(s);

				graphics2D.setColor(config.bubbleFillColor());
				graphics2D.fill(s);
			});
	}

	private void renderHoles(final Graphics2D graphics2D)
	{
		plugin.getHoles().stream()
			.map(TileObject::getClickbox)
			.filter(Objects::nonNull)
			.forEach(s -> {
				graphics2D.setStroke(STROKE);
				graphics2D.setColor(config.holeOutlineColor());
				graphics2D.draw(s);

				graphics2D.setColor(config.holeFillColor());
				graphics2D.fill(s);
			});
	}

	private void renderPufferFish(final Graphics2D graphics2D)
	{
		final var pufferFish = plugin.getPufferFish();

		if (pufferFish.isEmpty())
		{
			return;
		}

		for (final var fish : pufferFish)
		{
			modelOutlineRenderer.drawOutline(fish, 2, config.pufferFishOutlineColor(), 4);

			final Shape shape = fish.getConvexHull();

			if (shape == null)
			{
				continue;
			}

			graphics2D.setColor(config.pufferFishFillColor());
			graphics2D.fill(shape);
		}
	}

	private void renderChestsClams(final Graphics2D graphics2D)
	{
		final var chestClams = plugin.getChestClams();

		if (chestClams.isEmpty())
		{
			return;
		}

		for (final var chest : chestClams)
		{
			modelOutlineRenderer.drawOutline(chest, 3, config.chestClamOutlineColor(), 4);

			final Shape shape = chest.getClickbox();

			if (shape == null)
			{
				continue;
			}

			graphics2D.setColor(config.chestClamFillColor());
			graphics2D.fill(shape);
		}
	}

	private void renderOxygenBar(final Graphics2D graphics2D)
	{
		int oxygen = plugin.getOxygen();

		if (oxygen <= 0)
		{
			return;
		}

		final String text;

		switch (config.oxygenBar())
		{
			case PERCENT:
				oxygen = oxygen / 10;
				text = String.format("%d%%", oxygen);
				break;
			case TICKS:
				oxygen = oxygen < 1000 ? plugin.getOxygenTicks() : (oxygen * 3) / 10;
				text = Integer.toString(oxygen);
				break;
			default:
				return;
		}

		final Point point = client.getLocalPlayer().getCanvasTextLocation(graphics2D, text, 0);

		if (point == null)
		{
			return;
		}

		final Color color = ColorUtil.colorLerp(Color.RED, Color.GREEN, Math.min(1, (double) plugin.getOxygen() / 1000));
		renderTextLocation(graphics2D, point, text, color);
	}

	private static void renderTextLocation(
		final Graphics2D graphics2D,
		final Point point,
		final String text,
		final Color color)
	{
		graphics2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

		graphics2D.setFont(FontManager.getRunescapeBoldFont());
		graphics2D.setColor(Color.BLACK);

		final int x = point.getX();
		final int y = point.getY();

		renderTextBackground(graphics2D, x, y + 1, text);
		renderTextBackground(graphics2D, x, y - 1, text);
		renderTextBackground(graphics2D, x + 1, y, text);
		renderTextBackground(graphics2D, x - 1, y, text);

		graphics2D.setColor(color);
		graphics2D.drawString(text, x, y);
	}

	private static void renderTextBackground(
		final Graphics2D graphics2D,
		final int x, final int y,
		final String text)
	{
		graphics2D.drawString(text, x + 1, y + 1);
		graphics2D.drawString(text, x, y);
	}
}

