package com.locationdisplay;

import lombok.AllArgsConstructor;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("Location Text Configuration")
public interface LocationDisplayConfig extends Config
{
	@AllArgsConstructor
	enum PositionEnum {
		TOP_LEFT("Top Left"),
		TOP_CENTER("Top Center"),
		TOP_RIGHT("Top Right"),
		BOTTOM_LEFT("Bottom Left"),
		BOTTOM_RIGHT("Bottom Right");

		private final String name;

		@Override
		public String toString() {
			return name;
		}
	}

	@ConfigSection(
			name = "Position Settings",
			description = "Settings relating to position",
			position = 1,
			closedByDefault = true
	)
	String positionSettings = "positionSettings";

	@ConfigSection(
			name = "Font Settings",
			description = "Settings relating to font",
			position = 2,
			closedByDefault = true
	)
	String fontSettings = "fontSettings";

	@ConfigSection(
			name = "Fade Settings",
			description = "Settings relating to fade",
			position = 2,
			closedByDefault = true
	)
	String fadeSettings = "fadeSettings";

	@ConfigSection(
			name = "Underline Settings",
			description = "Settings relating to underline",
			position = 6,
			closedByDefault = true
	)
	String underlineSettings = "underlineSettings";

	@ConfigSection(
			name = "Sound Effect Settings",
			description = "Settings relating to sound effects",
			position = 10,
			closedByDefault = true
	)
	String soundEffectSettings = "soundEffectSettings";

	@ConfigSection(
			name = "Prefix/Suffix Settings",
			description = "Settings relating to prefix/suffix",
			position = 14,
			closedByDefault = true
	)
	String prefixSuffixSettings = "prefixSuffixSettings";

	@ConfigItem(
			position = 1,
			keyName = "position",
			name = "Position",
			description = "Set text position. You will likely have to play around with text height if changed.",
			section = positionSettings
	)
	default PositionEnum position() { return PositionEnum.TOP_CENTER; }

	@Range(min = -1000)
	@ConfigItem(
			position = 3,
			keyName = "textYOffset",
			name = "Text Y Offset",
			description = "Set the Y position of text overlay, higher number = lower on screen",
			section = positionSettings
	)
	default int textYOffset() { return 60;}

	@Range(min = -1000)
	@ConfigItem(
			position = 2,
			keyName = "textXOffset",
			name = "Text X Offset",
			description = "Set the X position of text overlay, higher number = more right on screen",
			section = positionSettings
	)
	default int textXOffset() { return 0;}

	@ConfigItem(
			position = 4,
			keyName = "fadeDuration",
			name = "Fade Duration (ms)",
			description = "Sets the duration of fading in/fading out in milliseconds",
			section = fadeSettings
	)
	default int fadeDuration() { return 1000; }

	@ConfigItem(
			position = 5,
			keyName = "holdDuration",
			name = "Hold Duration (ms)",
			description = "Sets the duration of holding after fading in in milliseconds",
			section = fadeSettings
	)
	default int holdDuration() { return 2000; }

	@ConfigItem(
			position = 1,
			keyName = "FontName",
			name = "Font Name",
			description = "Select font name, leave empty for runescape font",
			section = fontSettings
	)
	default String font() { return ""; }

	@ConfigItem(
			position = 2,
			keyName = "fontSize",
			name = "Font Size",
			description = "Sets the font size",
			section = fontSettings
	)
	default int fontSize() { return 32; }

	@ConfigItem(
			position = 3,
			keyName = "bold",
			name = "Bold",
			description = "Makes font bold",
			section = fontSettings
	)
	default boolean bold() { return true; }

	@ConfigItem(
			position = 4,
			keyName = "italic",
			name = "Italic",
			description = "Adds italic to font",
			section = fontSettings
	)
	default boolean italic() { return false; }

	@ConfigItem(
			position = 5,
			keyName = "outline",
			name = "Outline",
			description = "Outlines the text",
			section = fontSettings
	)
	default boolean outline() { return false; }


	@ConfigItem(
			position = 6,
			keyName = "Color",
			name = "Text Color",
			description = "Select the color of the text",
			section = fontSettings
	)
	default Color colorConfig() { return Color.WHITE; }

	@ConfigItem(
			position = 15,
			keyName = "underline",
			name = "Underline",
			description = "Underlines the text",
			section = underlineSettings
	)
	default boolean underline() { return false; }

	@ConfigItem(
			position = 16,
			keyName = "underlineThickness",
			name = "Underline Thickness",
			description = "Sets the underline thickness",
			section = underlineSettings
	)
	default int underlineThickness() { return 2; }

	@ConfigItem(
			position = 17,
			keyName = "underlineWidth",
			name = "Underline Width",
			description = "Adds additional width to underline",
			section = underlineSettings
	)
	default int underlineWidth() { return 5; }

	@Range(min = -1000)
	@ConfigItem(
			position = 18,
			keyName = "underlineHeight",
			name = "Underline Height",
			description = "Adjust height of underline",
			section = underlineSettings
	)
	default int underlineHeight() { return -2; }

	@ConfigItem(
			position = 32,
			keyName = "soundEffect",
			name = "Sound Effect",
			description = "Plays a sound effect aswell",
			section = soundEffectSettings
	)
	default boolean soundEffect() { return false; }

	@ConfigItem(
			position = 33,
			keyName = "effectid",
			name = "Sound Effect ID",
			description = "Change sound effect, check out: https://oldschool.runescape.wiki/w/List_of_sound_IDs",
			section = soundEffectSettings
	)
	default int soundEffectID() { return 4218; }

	@ConfigItem(
			position = 34,
			keyName = "soundCooldown",
			name = "Sound Effect Cooldown (ms)",
			description = "Set the cooldown before playing the sound effect again",
			section = soundEffectSettings
	)
	default int soundEffectCooldown() { return 5000; }

	@ConfigItem(
			position = 30,
			keyName = "Prefix",
			name = "Prefix",
			description = "Adds a prefix to the name",
			section = prefixSuffixSettings
	)
	default String prefix() { return ""; }

	@ConfigItem(
			position = 31,
			keyName = "Suffix",
			name = "Suffix",
			description = "Adds a suffix to the name",
			section = prefixSuffixSettings
	)
	default String suffix() { return ""; }

	@ConfigItem(
			position = 50,
			keyName = "suppressOnLogin",
			name = "Suppress on Login",
			description = "Prevents location name from showing immediately after login"
	)
	default boolean suppressOnLogin() { return false; }

}

package com.locationdisplay;

import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import javax.inject.Inject;
import java.awt.*;

public class LocationDisplayOverlay extends Overlay {

    private final Client client;
    private final LocationDisplayConfig config;
    private final LocationDisplayPlugin plugin;
    private final TextComponent textComponent = new TextComponent();
    private long fadeStartTime = 0;
    private float alpha = 0f;
    private String lastArea = "";
    private String displayedArea = null;
    private boolean suppressFirstLocation;
    private enum FadeState { IDLE, FADING_IN, HOLDING, FADING_OUT }
    private FadeState fadeState = FadeState.IDLE;
    private long lastSoundTime = 0;


    @Inject
    private LocationDisplayOverlay(Client client, LocationDisplayPlugin plugin, LocationDisplayConfig config) {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.suppressFirstLocation = config.suppressOnLogin();
    }

    private Font getFontFromConfig() {

        if (config.font().isEmpty()) {
            Font baseFont = FontManager.getRunescapeFont();

            if (config.bold()) {
                baseFont = FontManager.getRunescapeBoldFont();
            }

            int style = baseFont.getStyle();

            if (config.italic()) {
                style |= Font.ITALIC;
            }

            return baseFont.deriveFont(style, (float) config.fontSize());
        }

        Font baseFont = new Font(config.font(), Font.PLAIN,config.fontSize());

        int style = baseFont.getStyle();

        if (config.italic()) {
            style |= Font.ITALIC;
        }

        if (config.bold()) {
            style |= Font.BOLD;
        }

        return baseFont.deriveFont(style, (float) config.fontSize());
    }

    private OverlayPosition getPositionFromConfig() {
        switch (config.position()) {
            case TOP_LEFT:
                return OverlayPosition.TOP_LEFT;
            case TOP_RIGHT:
                return OverlayPosition.TOP_RIGHT;
            case TOP_CENTER:
                return OverlayPosition.TOP_CENTER;
            case BOTTOM_LEFT:
                return OverlayPosition.BOTTOM_LEFT;
            case BOTTOM_RIGHT:
                return OverlayPosition.BOTTOM_RIGHT;
            default:
                throw new IllegalStateException("Unexpected value: " + config.position());
        }
    }

    private Point calculateTextPosition(Graphics2D graphics, Font font, String text) {
        int y = config.textYOffset();
        int x = config.textXOffset();
        int stringWidth = graphics.getFontMetrics(font).stringWidth(text);
        OverlayPosition position = getPositionFromConfig();

        switch (position) {
            case TOP_LEFT:
            case BOTTOM_LEFT:
                return new Point(x,y);
            case TOP_CENTER:
                return new Point(x - (stringWidth / 2),y);
            default:
                return new Point(x - stringWidth, y);
        }
    }

    private void drawUnderlineIfNeeded(Graphics2D graphics, Font font, Color fadeColor, Point position){
        if (config.underline()) {
            FontMetrics metrics = graphics.getFontMetrics(font);
            int textWidth = metrics.stringWidth(displayedArea);

            graphics.setColor(fadeColor);

            Stroke originalStroke = graphics.getStroke();
            graphics.setStroke(new BasicStroke((float) config.underlineThickness()));

            graphics.drawLine(position.x - config.underlineWidth(), position.y + config.underlineHeight(), position.x + textWidth + config.underlineWidth(), position.y + config.underlineHeight());

            graphics.setStroke(originalStroke);
        }
    }

    private void playSoundEffectIfNeeded() {
        if (config.soundEffect()){
            long currentTime = System.currentTimeMillis();

            if (currentTime - lastSoundTime >= config.soundEffectCooldown()) {
                client.playSoundEffect(config.soundEffectID());
                lastSoundTime = currentTime;
            }
        }
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        String currentArea = plugin.getCurrentArea();

        if (!currentArea.equals(lastArea) && !currentArea.equals("Unknown Area")) {
            lastArea = currentArea;
            displayedArea = config.prefix() + lastArea + config.suffix();

            fadeStartTime = System.currentTimeMillis();
            fadeState = FadeState.FADING_IN;

            playSoundEffectIfNeeded();
        }

        // Skip everything if not fading
        if (fadeState == FadeState.IDLE || suppressFirstLocation || displayedArea == null)
        {
            suppressFirstLocation = false;
            return null;
        }

        long elapsed = System.currentTimeMillis() - fadeStartTime;

        switch (fadeState)
        {
            case FADING_IN:
                alpha = Math.min(1f, (float) elapsed / config.fadeDuration());
                if (elapsed >= config.fadeDuration())
                {
                    fadeState = FadeState.HOLDING;
                    fadeStartTime = System.currentTimeMillis();
                    alpha = 1f;
                }
                break;

            case HOLDING:
                alpha = 1f;
                if (elapsed >= config.holdDuration())
                {
                    fadeState = FadeState.FADING_OUT;
                    fadeStartTime = System.currentTimeMillis();
                }
                break;

            case FADING_OUT:
                alpha = Math.max(0f, 1f - ((float) elapsed / config.fadeDuration()));
                if (elapsed >= config.fadeDuration())
                {
                    fadeState = FadeState.IDLE;
                    alpha = 0f;
                }
                break;
        }

        Font font = getFontFromConfig();
        textComponent.setFont(font);

        textComponent.setOutline(config.outline());

        Color baseColor = config.colorConfig();
        Color fadeColor = new Color(baseColor.getRed() / 255f, baseColor.getGreen() / 255f, baseColor.getBlue() / 255f, alpha);
        textComponent.setColor(fadeColor);

        setPosition(getPositionFromConfig());

        Point textPosition = calculateTextPosition(graphics, font, displayedArea);
        textComponent.setPosition(textPosition);

        textComponent.setText(displayedArea);

        drawUnderlineIfNeeded(graphics, font, fadeColor, textPosition);

        // Included because runelite doesn't render 0 alpha completely, 0 alpha will still leave text
        Composite originalComposite = graphics.getComposite();
        graphics.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, alpha));
        textComponent.render(graphics);
        graphics.setComposite(originalComposite);

        return null;
    }
}

package com.locationdisplay;

import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
		name = "Location Display",
		description = "Displays name of the current location upon entering area"
)
public class LocationDisplayPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private LocationDisplayConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private LocationDisplayOverlay overlay;

	@Getter
	@Setter
	private String currentArea = "";

	@Getter
	@Setter
	private Region playerRegion = new Region(-1, -1);

	@Inject
	private RegionMap regionMap;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		regionMap.loadFromJson();
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		regionMap.clear();
	}

	private void updatePlayerRegion(WorldPoint playerPosition) {
		int currentX = playerPosition.getRegionID() >> 8;
		int currentY = playerPosition.getRegionID() & 0xFF;

		if (playerRegion.getX() != currentX || playerRegion.getY() != currentY) {
			playerRegion.setX(currentX);
			playerRegion.setY(currentY);
			setCurrentArea(regionMap.getAreaName(playerRegion));

			//log.info("Player region changed: Area: {},ID = {}, X = {}, Y = {}", currentArea, playerPosition.getRegionID(), currentX, currentY);
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick) {
		WorldPoint playerPosition = client.getLocalPlayer().getWorldLocation();
		updatePlayerRegion(playerPosition);
	}

	@Provides
	LocationDisplayConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LocationDisplayConfig.class);
	}
}

package com.locationdisplay;

import lombok.Getter;
import lombok.Setter;

import java.util.Objects;

public class Region {
    @Getter
    @Setter
    private int x;

    @Getter
    @Setter
    private int y;

    public Region(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Region region = (Region) obj;
        return x == region.x && y == region.y;
    }

    //needed this to perform equality check
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
}

package com.locationdisplay;

import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import javax.inject.Inject;
import java.io.*;
import java.util.*;

@Slf4j
public class RegionMap {

    @Inject
    private Gson gson;

    public Map<Region, String> regionToArea = new HashMap<>();

	private static class AreaData extends HashMap<String, List<List<Integer>>> {}

    public void loadFromJson() throws IOException {
        try (InputStream is = getClass().getClassLoader().getResourceAsStream("Locations.json")) {
            if (is == null) {
                throw new FileNotFoundException("Could not find Locations.json in resources folder.");
            }

            try (Reader reader = new InputStreamReader(is)) {
                AreaData areaData = gson.fromJson(reader, AreaData.class);
                for (Map.Entry<String, List<List<Integer>>> entry : areaData.entrySet()) {
                    String areaName = entry.getKey();
                    for (List<Integer> coords : entry.getValue()) {
                        if (coords.size() != 2) {
                            log.warn("Invalid coordinates for area {}: {}", areaName, coords);
                            continue;
                        }
                        Region region = new Region(coords.get(0), coords.get(1));
                        regionToArea.put(region, areaName);
                    }
                }
            }
        } catch (Exception e) {
            log.error("Error loading Locations.json", e);
            throw e; // Consider whether to rethrow or handle differently
        }
    }

    public String getAreaName(Region region) {
        return regionToArea.getOrDefault(region, "Unknown Area");
    }

    public void clear() {
        regionToArea.clear();
    }
}
package com.locationdisplay;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LocationDisplayPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LocationDisplayPlugin.class);
		RuneLite.main(args);
	}
}
