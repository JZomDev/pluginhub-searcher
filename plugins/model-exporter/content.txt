package net.bram91.modeldumper;

import net.runelite.api.Model;
import net.runelite.api.Renderable;
import net.runelite.client.RuneLite;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Exporter
{
    private final static String PATH = RuneLite.RUNELITE_DIR + "//models//";
    private static final DateFormat TIME_FORMAT = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss");

    public static void export(Renderable r, String name)
    {
        Model m;
        if (r instanceof Model)
        {
            m = (Model) r;
        }
        else
        {
            m = r.getModel();
        }

        export(m, name, false);
    }
    public static void export(Model m, String name, boolean seq)
    {
        export(m,null,name,seq);
    }
    public static void export(Model m, String path, String name, boolean seq)
    {
        if(!seq) {
            name = name + " " + TIME_FORMAT.format(new Date());
        }

        switch (ModelDumperPlugin.getConfig().exportFormat())
        {
            case OBJ:
                OBJExporter.export(m, ((seq) ? path : PATH), name, seq);
                break;
            case PLY:
                try
                {
                    PLYExporter.export(m, ((seq) ? path : PATH) + name);
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
                break;
            case STL:
                try
                {
                    STLExporter.export(m, ((seq) ? path : PATH) + name);
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            default:
                break;
        }
    }

    public static void exportSequence(Model model, int npcId, int animationId, int frame, Date dateTime)
    {
        String path = PATH + "sequences//" + TIME_FORMAT.format(dateTime) + "//";
        File folder = new File(path);
        if (!folder.exists())
        {
            folder.mkdirs();
        }
        if(npcId < 0)
        {
            export(model, path , "player-" + animationId + "-" + frame, true);
        }
        else
        {
            export(model, path , npcId + "-" + animationId + "-" + frame, true);
        }
    }
}

package net.bram91.modeldumper;

public enum ExportFormat
{
    OBJ, PLY, STL
}

package net.bram91.modeldumper;

import lombok.Builder;
import lombok.Data;
import net.runelite.api.Model;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

@Data
@Builder
class GroundItem {
    private int id;
    private TileItem item;
    private WorldPoint location;
    private int quantity;

    public Model getModel() {
        return this.item.getModel();
    }
}

/*
 * Copyright (c) 2020 Abex
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.bram91.modeldumper;


import java.awt.*;

// Originally from RuneLite cache
// Additions made for calculating average of 3 colors
public final class JagexColor
{
	public static final double BRIGHTNESS_MAX = .6;
	public static final double BRIGHTNESS_HIGH = .7;
	public static final double BRIGHTNESS_LOW = .8;
	public static final double BRIGHTNESS_MIN = .9;

	private static final double HUE_OFFSET = (.5 / 64.D);
	private static final double SATURATION_OFFSET = (.5 / 8.D);

	private JagexColor()
	{
	}

	// take 3 Jagex HSL colors and make a single RGB color to represent them
	public static Color HSLtoRGBAvg(int hsl1, int hsl2, int hsl3)
	{
		Color c1 = new Color(HSLtoRGB((short) hsl1, BRIGHTNESS_MIN));
		Color c2 = new Color(HSLtoRGB((short) hsl2, BRIGHTNESS_MIN));
		Color c3 = new Color(HSLtoRGB((short) hsl3, BRIGHTNESS_MIN));

		// compute color average using squares
		// uses squared approach from https://sighack.com/post/averaging-rgb-colors-the-right-way
		int r = c1.getRed()*c1.getRed() + c2.getRed()*c2.getRed() + c3.getRed()*c3.getRed();
		int g = c1.getGreen()*c1.getGreen() + c2.getGreen()*c2.getGreen() + c3.getGreen()*c3.getGreen();
		int b = c1.getBlue()*c1.getBlue() + c2.getBlue()*c2.getBlue() + c3.getBlue()*c3.getBlue();

		r = (int) Math.round(Math.sqrt((double) r / 3.0d));
		g = (int) Math.round(Math.sqrt((double) g / 3.0d));
		b = (int) Math.round(Math.sqrt((double) b / 3.0d));

		return new Color(r, g, b);
	}

	public static short packHSL(int hue, int saturation, int luminance)
	{
		return (short) ((short) (hue & 63) << 10
			| (short) (saturation & 7) << 7
			| (short) (luminance & 127));
	}

	public static int unpackHue(short hsl)
	{
		return hsl >> 10 & 63;
	}

	public static int unpackSaturation(short hsl)
	{
		return hsl >> 7 & 7;
	}

	public static int unpackLuminance(short hsl)
	{
		return hsl & 127;
	}

	public static String formatHSL(short hsl)
	{
		return String.format("%02Xh%Xs%02Xl", unpackHue(hsl), unpackSaturation(hsl), unpackLuminance(hsl));
	}

	public static int HSLtoRGB(short hsl, double brightness)
	{
		double hue = (double) unpackHue(hsl) / 64.D + HUE_OFFSET;
		double saturation = (double) unpackSaturation(hsl) / 8.D + SATURATION_OFFSET;
		double luminance = (double) unpackLuminance(hsl) / 128.D;

		// This is just a standard hsl to rgb transform
		// the only difference is the offsets above and the brightness transform below
		double chroma = (1.D - Math.abs((2.D * luminance) - 1.D)) * saturation;
		double x = chroma * (1 - Math.abs(((hue * 6.D) % 2.D) - 1.D));
		double lightness = luminance - (chroma / 2);

		double r = lightness, g = lightness, b = lightness;
		switch ((int) (hue * 6.D))
		{
			case 0:
				r += chroma;
				g += x;
				break;
			case 1:
				g += chroma;
				r += x;
				break;
			case 2:
				g += chroma;
				b += x;
				break;
			case 3:
				b += chroma;
				g += x;
				break;
			case 4:
				b += chroma;
				r += x;
				break;
			default:
				r += chroma;
				b += x;
				break;
		}

		int rgb = ((int) (r * 256.0D) << 16)
			| ((int) (g * 256.0D) << 8)
			| (int) (b * 256.0D);

		rgb = adjustForBrightness(rgb, brightness);

		if (rgb == 0)
		{
			rgb = 1;
		}
		return rgb;
	}

	public static int adjustForBrightness(int rgb, double brightness)
	{
		double r = (double) (rgb >> 16) / 256.0D;
		double g = (double) (rgb >> 8 & 255) / 256.0D;
		double b = (double) (rgb & 255) / 256.0D;

		r = Math.pow(r, brightness);
		g = Math.pow(g, brightness);
		b = Math.pow(b, brightness);

		return ((int) (r * 256.0D) << 16)
			| ((int) (g * 256.0D) << 8)
			| (int) (b * 256.0D);
	}

	public static int[] createPalette(double brightness)
	{
		int[] colorPalette = new int[65536];
		for (int i = 0; i < colorPalette.length; i++)
		{
			colorPalette[i] = HSLtoRGB((short) i, brightness);
		}
		return colorPalette;
	}
}

/*
 * Copyright (c) 2020, Bram91
 * Copyright (c) 2020, Unmoon <https://github.com/Unmoon>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.bram91.modeldumper;

import com.google.common.collect.HashBasedTable;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Table;
import com.google.inject.Provides;

import java.awt.Shape;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;

import lombok.Getter;
import net.bram91.modeldumper.types.ModelExporterData;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.menus.WidgetMenuOption;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@PluginDescriptor(
	name = "Model Exporter",
	description = "Allows exporting models by right clicking them.",
	tags = {"Model", "Dumper","Exporter","3d","obj"}
)
public class ModelDumperPlugin extends Plugin
{
	@Getter
	private static ModelDumperPlugin instance;
	private static final String EXPORT_MODEL = "Export Model";
	private static final String EXPORT_SEQUENCE = "Export Animation Sequence";
	private static final String MENU_TARGET = "Player";
	private static final WidgetMenuOption FIXED_EQUIPMENT_TAB_EXPORT = new WidgetMenuOption(EXPORT_MODEL,
		MENU_TARGET, ComponentID.FIXED_VIEWPORT_EQUIPMENT_TAB);
	private static final WidgetMenuOption RESIZABLE_EQUIPMENT_TAB_EXPORT = new WidgetMenuOption(EXPORT_MODEL,
		MENU_TARGET, ComponentID.RESIZABLE_VIEWPORT_EQUIPMENT_TAB);
	private static final WidgetMenuOption RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB_EXPORT = new WidgetMenuOption(EXPORT_MODEL,
		MENU_TARGET,ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB);

	private static final WidgetMenuOption FIXED_EQUIPMENT_TAB_EXPORT_SEQ = new WidgetMenuOption(EXPORT_SEQUENCE,
			MENU_TARGET, ComponentID.FIXED_VIEWPORT_EQUIPMENT_TAB);
	private static final WidgetMenuOption RESIZABLE_EQUIPMENT_TAB_EXPORT_SEQ = new WidgetMenuOption(EXPORT_SEQUENCE,
			MENU_TARGET, ComponentID.RESIZABLE_VIEWPORT_EQUIPMENT_TAB);
	private static final WidgetMenuOption RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB_EXPORT_SEQ = new WidgetMenuOption(EXPORT_SEQUENCE,
			MENU_TARGET,ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB);
	private final ImmutableList<String> set = ImmutableList.of(
		"Trade with", "Attack", "Talk-to", "Examine"
	);

	private ModelExporterData modelData;

	@Inject
	private ClientToolbar clientToolbar;

	private NavigationButton navButton;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MenuManager menuManager;

	@Inject
	private ModelDumperPluginConfig config;

	@Provides
	ModelDumperPluginConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ModelDumperPluginConfig.class);
	}

	private final Table<WorldPoint, Integer, GroundItem> groundItems = HashBasedTable.create();

	@Override
	protected void startUp() throws Exception
	{
		// We never want to start the plugin with the transmog enabled, since this is more of a config "button"
		// So we make sure its always set to false on startup
		if(config.transmogEnabled()) {
			config.setTransmog(false);
		}
		menuManager.addManagedCustomMenu(FIXED_EQUIPMENT_TAB_EXPORT,this::exportLocalPlayerModel);
		menuManager.addManagedCustomMenu(RESIZABLE_EQUIPMENT_TAB_EXPORT,this::exportLocalPlayerModel);
		menuManager.addManagedCustomMenu(RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB_EXPORT,this::exportLocalPlayerModel);

		menuManager.addManagedCustomMenu(FIXED_EQUIPMENT_TAB_EXPORT_SEQ,this::exportLocalPlayerSequence);
		menuManager.addManagedCustomMenu(RESIZABLE_EQUIPMENT_TAB_EXPORT_SEQ,this::exportLocalPlayerSequence);
		menuManager.addManagedCustomMenu(RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB_EXPORT_SEQ,this::exportLocalPlayerSequence);

		ModelDumperPlugin.instance = this;

		modelData = new ModelExporterData();

		if(config.sidepanelEnabled())
		{
			addSidepanel();
		}
	}
	public void addSidepanel()
	{
		ModelPanel panel = injector.getInstance(ModelPanel.class);
		panel.init(modelData);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
		navButton = NavigationButton.builder()
				.tooltip("Model Exporter")
				.icon(icon)
				.priority(10)
				.panel(panel)
				.build();
		clientToolbar.addNavigation(navButton);
	}
	public void removeSidepanel()
	{
		clientToolbar.removeNavigation(navButton);
	}
	@Override
	protected void shutDown()
	{
		menuManager.removeManagedCustomMenu(FIXED_EQUIPMENT_TAB_EXPORT);
		menuManager.removeManagedCustomMenu(RESIZABLE_EQUIPMENT_TAB_EXPORT);
		menuManager.removeManagedCustomMenu(RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB_EXPORT);

		menuManager.removeManagedCustomMenu(FIXED_EQUIPMENT_TAB_EXPORT_SEQ);
		menuManager.removeManagedCustomMenu(RESIZABLE_EQUIPMENT_TAB_EXPORT_SEQ);
		menuManager.removeManagedCustomMenu(RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_TAB_EXPORT_SEQ);
		if(config.sidepanelEnabled())
		{
			removeSidepanel();
		}
		groundItems.clear();
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		MenuEntry[] menuEntries = event.getMenuEntries();
		for (int i = 0; i < set.size(); i++)
		{
			boolean addMenuEntry = false;
			MenuEntry target = null;
			for (MenuEntry menuEntry : menuEntries)
			{
				if (menuEntry.getOption().toLowerCase().equals("drop") || menuEntry.getOption().toLowerCase().equals("destroy"))
				{
					return;
				}
				else if (menuEntry.getOption().equals(set.get(i)))
				{
					addMenuEntry = true;
					target = menuEntry;
				}
			}

			if (client.isKeyPressed(KeyCode.KC_SHIFT) && addMenuEntry)
			{
				String entityName = target.getTarget();

				if(target.getPlayer() != null)
				{
					client.createMenuEntry(0)
						.setOption(EXPORT_MODEL)
						.setTarget(entityName)
						.setIdentifier(target.getIdentifier())
						.onClick(this::exportPlayerModel);
				}
				else if(target.getType().equals(MenuAction.EXAMINE_ITEM_GROUND) || target.getType().equals(MenuAction.EXAMINE_OBJECT))
				{
					client.createMenuEntry(0)
						.setOption(EXPORT_MODEL)
						.setTarget(entityName)
						.setIdentifier(target.getIdentifier())
						.onClick(this::exportObjectModel);
				}
				else if(target.getNpc()!=null && !target.getNpc().getComposition().isFollower())
				{
					client.createMenuEntry(0)
						.setOption(EXPORT_MODEL)
						.setTarget(entityName)
						.setIdentifier(target.getIdentifier())
						.onClick(this::exportNpcModel);
				}
				break;

			}
		}
	}
	@Subscribe
	public void onBeforeRender(BeforeRender beforeRender)
	{
		if(config.transmogEnabled() && config.frame() != 0)
		{
			Player player = client.getLocalPlayer();
			Animation animation = client.loadAnimation(config.animationId());
			if(player != null && animation != null)
			{
				if(config.frame() < animation.getNumFrames())
				{
					player.setAnimationFrame(config.frame());
					player.setPoseAnimationFrame(config.frame());
				}
				else
				{
					player.setAnimationFrame(animation.getNumFrames() - 1);
					player.setPoseAnimationFrame(animation.getNumFrames() - 1);
				}
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if(!configChanged.getGroup().equals("modeldumper"))
		{
			return;
		}
		if(configChanged.getKey().equals("sidepanelEnabled"))
		{
			if (Boolean.parseBoolean((configChanged.getNewValue()))) {
				addSidepanel();
			} else {
				removeSidepanel();
			}
			return;
		}
		Player player = client.getLocalPlayer();
		if(player != null)
		{
			switch (configChanged.getKey())
			{
				case "npcId":
					if(config.transmogEnabled())
					{
						player.getPlayerComposition().setTransformedNpcId(Integer.parseInt(configChanged.getNewValue()));
					}
					break;
				case "animationId":
					if(config.transmogEnabled())
					{
						int newValue = Integer.parseInt(configChanged.getNewValue());
						if (newValue == 0)
						{
							player.setIdlePoseAnimation(-1);
						} else
						{
							player.setIdlePoseAnimation(newValue);
						}
					}
					break;
				case "transmogEnabled":
					if(Boolean.parseBoolean(configChanged.getNewValue()))
					{
						player.getPlayerComposition().setTransformedNpcId(config.npcId());
						player.setIdlePoseAnimation(config.animationId());
					} else
					{
						player.getPlayerComposition().setTransformedNpcId(-1);
						player.setIdlePoseAnimation(-1);
						player.setPoseAnimation(-1);
					}
					break;
			}
		}
	}

	public void exportLocalPlayerModel(MenuEntry entry)
	{
		Player localPlayer = client.getLocalPlayer();
		if (config.forceRestPose())
		{
			localPlayer.setAnimation(2566);
			localPlayer.setAnimationFrame(0);
		}
		Exporter.export(localPlayer.getModel(), "Player " + client.getLocalPlayer().getName(), false);
	}

	public void exportLocalPlayerSequence(MenuEntry entry) {
		Player localPlayer = client.getLocalPlayer();

		Date dateTime = new Date();
		Animation animation = client.loadAnimation(config.animationId());
		if(animation != null)
		{
			for (int i = 0; i < animation.getNumFrames(); i++)
			{
				if (client.loadAnimation(config.animationId()) != null)
				{
					localPlayer.setAnimation(config.animationId());
					localPlayer.setAnimationFrame(i);
					Exporter.exportSequence(localPlayer.getModel(), config.npcId(), config.animationId(), i, dateTime);
				}
			}
		}
		localPlayer.setAnimationFrame(0);
	}

	private void exportObjectModel(MenuEntry entry)
	{
		int id = entry.getIdentifier();
		String menuTarget = entry.getTarget();
		Scene scene = client.getScene();
		Tile[][][] tiles = scene.getTiles();

		int z = client.getPlane();
		for (int x = 0; x < Constants.SCENE_SIZE; ++x)
		{
			for (int y = 0; y < Constants.SCENE_SIZE; ++y)
			{
				Tile tile = tiles[z][x][y];
				if (tile != null)
				{
					GameObject[] gameObjects = tile.getGameObjects();
					WallObject wallObject = tile.getWallObject();
					Collection<GroundItem> groundItemsOnTile = groundItems.row(tile.getWorldLocation()).values();
					DecorativeObject decoration = tile.getDecorativeObject();

					if (wallObject != null && wallObject.getId() == id)
					{

						Exporter.export(wallObject.getRenderable1(), "Object " + Text.removeFormattingTags(menuTarget));
						return;
					}
					else if (decoration != null && decoration.getId() == id)
					{
						Exporter.export(decoration.getRenderable(), "Object " + Text.removeFormattingTags(menuTarget));
						return;
					}
					else
					{
						for (GameObject gameObject : gameObjects) {
							if (gameObject != null && gameObject.getId() == id) {
								if (gameObject.getRenderable() != null) {
									Exporter.export(gameObject.getRenderable(), "Object " + Text.removeFormattingTags(menuTarget));
									return;
								}
							}
						}

						for (GroundItem groundItem : groundItemsOnTile) {
							if (groundItem.getId() == id) {
								Exporter.export(groundItem.getModel(), "Item " + Text.removeFormattingTags(menuTarget), false);
								return;
							}
						}
					}
				}
			}
		}
	}

	private void exportNpcModel(MenuEntry entry)
	{
		String menuTarget = entry.getTarget();
		int identifier = entry.getIdentifier();
		NPC npc = client.getTopLevelWorldView().npcs().byIndex(identifier);
		Exporter.export(npc.getModel(), "NPC " + Text.removeFormattingTags(menuTarget), false);
	}

	private void exportPetModel(MenuEntry entry)
	{
		String menuTarget = entry.getTarget();
		int identifier = entry.getIdentifier();
		NPC npc=null;
		for(NPC npC:client.getNpcs())
		{
			if(npC.getId() == identifier)
			{
				npc = npC;
			}
		}

		if(npc!=null)
		{
			Exporter.export(npc.getModel(), "Pet " + Text.removeFormattingTags(menuTarget), false);
		}
	}

	private void exportPlayerModel(MenuEntry entry)
	{
		String menuTarget = entry.getTarget();
		Pattern REMOVE_TAGS_SECONDARY = Pattern.compile("\\(.+?\\)");
		Matcher m = REMOVE_TAGS_SECONDARY.matcher(menuTarget);
		String trgt = m.replaceAll("");
		trgt = Text.sanitize(Text.removeFormattingTags(trgt.trim()));

		for (int i = 0; i < client.getPlayers().size(); i++)
		{
			if (client.getPlayers().get(i).getName().equals(trgt))
			{
				Exporter.export(client.getPlayers().get(i).getModel(), "Player " + trgt, false);
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(final GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOADING)
		{
			groundItems.clear();
		}
	}

	// borrowed from official Ground Items plugin
	@Subscribe
	public void onItemSpawned(ItemSpawned itemSpawned)
	{
		TileItem item = itemSpawned.getItem();
		Tile tile = itemSpawned.getTile();

		final GroundItem groundItem = GroundItem.builder()
			.id(item.getId())
			.item(item)
			.location(tile.getWorldLocation())
			.quantity(item.getQuantity())
			.build();

		GroundItem existing = groundItems.get(tile.getWorldLocation(), item.getId());
		if (existing != null)
		{
			existing.setQuantity(existing.getQuantity() + groundItem.getQuantity());
		}
		else
		{
			groundItems.put(tile.getWorldLocation(), item.getId(), groundItem);
		}
	}

	// borrowed from official Ground Items plugin
	@Subscribe
	public void onItemDespawned(ItemDespawned itemDespawned)
	{
		TileItem item = itemDespawned.getItem();
		Tile tile = itemDespawned.getTile();

		GroundItem groundItem = groundItems.get(tile.getWorldLocation(), item.getId());
		if (groundItem == null)
		{
			return;
		}

		if (groundItem.getQuantity() <= item.getQuantity())
		{
			groundItems.remove(tile.getWorldLocation(), item.getId());
		}
		else
		{
			groundItem.setQuantity(groundItem.getQuantity() - item.getQuantity());
		}
	}

	// borrowed from official Ground Items plugin
	@Subscribe
	public void onItemQuantityChanged(ItemQuantityChanged itemQuantityChanged)
	{
		TileItem item = itemQuantityChanged.getItem();
		Tile tile = itemQuantityChanged.getTile();
		int oldQuantity = itemQuantityChanged.getOldQuantity();
		int newQuantity = itemQuantityChanged.getNewQuantity();

		int diff = newQuantity - oldQuantity;
		GroundItem groundItem = groundItems.get(tile.getWorldLocation(), item.getId());
		if (groundItem != null)
		{
			groundItem.setQuantity(groundItem.getQuantity() + diff);
		}
	}

	//The following code is taken from the Pet Info plugin by Micro Tavor with permission
	@Subscribe
	public void onClientTick(ClientTick clientTick)
	{
		if (client.getGameState() == GameState.LOGGED_IN && !client.isMenuOpen() && client.isKeyPressed(KeyCode.KC_SHIFT) && pets.size() < 20)
		{
			addMenus();
		}
	}

	private void addMenus()
	{
		Point mouseCanvasPosition = client.getMouseCanvasPosition();
		List<NPC> petsUnderCursor = pets.stream().filter(p -> isClickable(p, mouseCanvasPosition)).collect(Collectors.toList());
		if (!petsUnderCursor.isEmpty())
		{
			for (NPC pet : petsUnderCursor)
			{
				client.createMenuEntry(0)
						.setOption(EXPORT_MODEL)
						.setTarget(pet.getName())
						.setIdentifier(pet.getId())
						.onClick(this::exportPetModel);
			}
		}
	}

	private boolean isClickable(NPC npc, Point mouseCanvasPosition)
	{
		Shape npcHull = npc.getConvexHull();

		if (npcHull != null)
		{
			return npcHull.contains(mouseCanvasPosition.getX(), mouseCanvasPosition.getY());
		}

		return false;
	}

	private final List<NPC> pets = new ArrayList<>();

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		NPC npc = npcSpawned.getNpc();
		if(npc.getComposition().isFollower())
		{
			pets.add(npc);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		NPC npc = npcDespawned.getNpc();
		if(npc.getComposition().isFollower())
		{
			pets.remove(npc);
		}
	}

	protected static Client getClient()
	{
		return instance.client;
	}
	protected static ModelDumperPluginConfig getConfig() { return instance.config; }

}

/*
 * Copyright (c) 2021, Bram91
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.bram91.modeldumper;

import net.runelite.client.config.*;

@ConfigGroup("modeldumper")
public interface ModelDumperPluginConfig extends Config
{
	@ConfigSection(
			name = "Exporter",
			description = "Technical settings for the exporter",
			position = 0
	)
	String exporterSection = "exporterSection";

	@ConfigSection(
			name = "Transmog",
			description = "Technical settings for the transmog",
			position = 1
	)
	String transmogSection = "transmogSection";

	@ConfigSection(
			name = "Experimental",
			description = "This can break stuff",
			position = 2
	)
	String experimentalSection = "experimentalSection";

	@ConfigItem(
		keyName = "material",
		name = "Export Color",
		description = "Also export colors for the models.",
		position = 1,
		section = exporterSection
	)
	default boolean material()
	{
		return false;
	}

	@ConfigItem(
			keyName = "forceRestPose",
			name = "Force Rest Pose (Local Player)",
			description = "Forces local player to perform an animation on export. The resulting model is in a rest pose.",
			position = 2,
			section = exporterSection
	)
	default boolean forceRestPose() { return false; }

	@ConfigItem(
			keyName="exportFormat",
			name = "Export Format",
			description="Select which 3d model file format to export to. OBJ uses averaged face colors while PLY uses vertex colors.",
			position = 3,
			section = exporterSection
	)
	default ExportFormat exportFormat() { return ExportFormat.OBJ; }

	@ConfigItem(
			keyName = "writeMaterialData",
			name = "Store OBJ material data for all frames",
			description = "Store material data for each individual frame on sequence exporting, for sequence importing into eg blender, it is recommended to turn this off",
			position = 4,
			section = exporterSection
	)
	default boolean writeMaterialData() { return false; }

	@ConfigItem(
			keyName = "transmogEnabled",
			name = "",
			description = "",
			hidden = true
	)
	void setTransmog(boolean val);
	@ConfigItem(
			keyName = "transmogEnabled",
			name = "Enabled",
			description = "Possibility to transmog into a NPC to make export easier",
			position = 1,
			section = transmogSection
	)
	default boolean transmogEnabled() {
		return false;
	}

	@ConfigItem(
			keyName = "npcId",
			name = "NPC ID",
			description = "NPC ID to transmog into",
			position = 2,
			section = transmogSection
	)
	@Range(min=-1)
	default int npcId() {
		return 0;
	}

	@ConfigItem(
			keyName = "npcId",
			name = "",
			description = "",
			hidden = true
	)
	void setNpcId(int val);

	@ConfigItem(
			keyName = "animationId",
			name = "Animation ID",
			description = "Animation to perform. Use 0 to disable",
			position = 3,
			section = transmogSection
	)
	default int animationId() {
		return 0;
	}

	@ConfigItem(
			keyName = "animationId",
			name = "",
			description = "",
			hidden = true
	)
	void setAnimationId(int val);

	@ConfigItem(
			keyName = "frame",
			name = "Frame",
			description = "Specific frame for the animation. Note: it will flicker a bit, but still easier to export a certain frame. Use 0 to disable",
			position = 4,
			section = transmogSection
	)
	default int frame() {
		return 0;
	}

	@ConfigItem(
			keyName = "frame",
			name = "",
			description = "",
			hidden = true
	)
	void setFrame(int val);

	@ConfigItem(
			keyName = "sidepanelEnabled",
			name = "Sidepanel",
			description = "Allows you to search for npcs and animations",
			position = 0,
			section = transmogSection
	)
	default boolean sidepanelEnabled() {
		return false;
	}

	@ConfigItem(
			keyName = "maxDistance",
			name = "Color match % (OBJ)",
			description = "Will group up colors that are similar, low is better for color accuracy.",
			position = 0,
			section = experimentalSection
	)
	@Range(max = 100)
	default double getMaxDistance() { return 0.0;}
}

package net.bram91.modeldumper;

import com.google.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.bram91.modeldumper.types.*;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.event.*;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;
import java.awt.*;
import java.awt.event.*;

import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.LinkBrowser;
import org.apache.commons.lang3.StringUtils;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.PatternSyntaxException;

import static net.runelite.client.RuneLite.RUNELITE_DIR;
@Slf4j
public class ModelPanel extends PluginPanel {
    @Inject
    Client client;
    @Inject
    ClientThread clientThread;
    @Inject
    ModelDumperPluginConfig config;
    private JTable npcList;
    private JTable animationList;
    private final String npcFilterHint = "Search for npcs...";
    private final String animationFilterHint = "Search for animations...";
    private JTextField npcFilter = new JTextField(npcFilterHint);
    private JTextField animationFilter = new JTextField(animationFilterHint);
    public static final File MODEL_DIR = new File(RUNELITE_DIR, "models");

    public void init(ModelExporterData modelExporterData) {
        if (modelExporterData.getNpcData() == null || modelExporterData.getAnimationGroup() == null) {
            JTextArea errorDescription = new JTextArea("There was a problem loading npc information. " +
                                                        "You can still transmog in the plugin config, " +
                                                        "but searching through npc names/animations is not available.");

            errorDescription.setLineWrap(true);
            errorDescription.setWrapStyleWord(true);
            add(errorDescription);
            add(new JButton("Open Folder"){{addActionListener(e -> LinkBrowser.open(MODEL_DIR.toString()));}});
            return;
        }
        Object[] animationGroups = modelExporterData.getAnimationGroup().toArray();
        JPanel settingsPanel = new JPanel();
        JCheckBox freePick = new JCheckBox("Free animation pick");
        freePick.setToolTipText("This will allow you to apply any animation to any npc.");
        freePick.addActionListener(e -> setSelection(animationGroups, freePick, modelExporterData));
        settingsPanel.add(freePick);

        final JPanel container = new JPanel();
        container.setLayout(new GridLayout(0, 1, 3, 3));

        for (Object animationGroup : animationGroups) {
            AnimationGroup animGroup = (AnimationGroup) animationGroup;
            animGroup.getAnimationGroup().forEach((anim) -> {
                String name = modelExporterData.getAnimationNames().get(anim.getId());
                anim.setName(name);
            });
        }
        modelExporterData.getNpcData().add(new NPCData(" Player", -1, 808, 637));
        Object[] npcData = Arrays.stream(modelExporterData.getNpcData().toArray()).sorted().toArray();
        npcData = Arrays.stream(npcData).filter(x -> !StringUtils.isBlank(x.toString()) && !x.toString().equals("null")).toArray();

        AnimationTableModel model = new AnimationTableModel(npcData, "Name", modelExporterData.getAnimationNames());
        npcList = new JTable(model);
        container.add(npcFilter);
        npcFilter.addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                if (npcFilter.getText().equals(npcFilterHint)) {
                    npcFilter.setText("");
                }
            }
        });
        animationFilter.addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                if (animationFilter.getText().equals(animationFilterHint)) {
                    animationFilter.setText("");
                }
            }
        });
        addSearchBox(npcList, npcFilter);
        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {}

            @Override
            public void keyPressed(KeyEvent e) {}

            @Override
            public void keyReleased(KeyEvent e) {
                NPCData npcData = null;
                Animation animation = null;
                if (npcList.getSelectedRow() != -1) {
                    npcData = (NPCData) npcList.getValueAt(npcList.getSelectedRow(), 0);
                }
                if (animationList.getSelectedRow() != -1 && animationList.getValueAt(animationList.getSelectedRow(), 0) instanceof Animation) {
                    animation = (Animation) animationList.getValueAt(animationList.getSelectedRow(), 0);
                }
                if (npcData != null) {
                    if (animation != null) {
                        applyAnimation(npcData.getId(), animation.getId());
                    } else {
                        applyAnimation(npcData.getId(), npcData.getStandingAnimation());
                    }
                }
            }
        };
        ListSelectionListener npcListListener = e -> {
            if (npcList.getSelectedRow() == -1) {
                return;
            }
            setSelection(animationGroups, freePick, modelExporterData);
        };

        MouseListener animationListListener = new MouseAdapter() {
            public void mouseClicked(MouseEvent e) {
                int rowAtPoint = animationList.rowAtPoint(e.getPoint());
                animationList.setRowSelectionInterval(rowAtPoint, rowAtPoint);
                if (!(animationList.getValueAt(animationList.getSelectedRow(), 0) instanceof Animation)) {
                    return;
                }
                Animation animation = (Animation) animationList.getValueAt(animationList.getSelectedRow(), 0);
                if (e.getButton() == 3) {
                    String m = JOptionPane.showInputDialog("Animation name for " + animation.getId(), animation.getName());
                    if (m != null)
                        if (m.equals("")) {
                            ((Animation) animationList.getValueAt(animationList.getSelectedRow(), 0)).setName(null);
                        } else {
                            ((Animation) animationList.getValueAt(animationList.getSelectedRow(), 0)).setName(m);
                        }
                } else {
                    int npcId = ((NPCData) npcList.getValueAt(npcList.getSelectedRow(), 0)).getId();
                    applyAnimation(npcId, animation.getId());
                }
            }
        };

        container.add(freePick);
        JPanel animationPanel = new JPanel();
        animationPanel.setLayout(new GridLayout(0, 1, 3, 3));
        animationList = new JTable();
        animationPanel.add(new JScrollPane(animationList));
        JPanel exportPanel = new JPanel();
        exportPanel.setLayout(new GridLayout(2, 2, 3, 3));
        JButton configButton = new JButton("Set Config");
        configButton.addActionListener(e -> setConfig());
        JButton exportButton = new JButton("Export Sequence");
        exportButton.addActionListener(e -> exportSequence());
        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(e -> applyAnimation(-1, -1));
        JButton openButton = new JButton("Open Folder");
        JButton saveButton = new JButton("Save Animation Names");
        saveButton.addActionListener(e -> {
            try {
                new DataFetcher().saveAnimationNames(animationGroups);
            } catch (FileNotFoundException ex) {
                log.warn("Failed to write animation names to file.");
            }
        });
        openButton.addActionListener(e -> LinkBrowser.open(MODEL_DIR.toString()));
        exportPanel.add(configButton);
        exportPanel.add(exportButton);
        exportPanel.add(resetButton);
        exportPanel.add(openButton);
        npcList.getSelectionModel().addListSelectionListener(npcListListener);
        npcList.addKeyListener(keyListener);
        animationList.addMouseListener(animationListListener);
        animationList.addKeyListener(keyListener);
        JScrollPane jScrollPane = new JScrollPane(npcList);
        Dimension d = npcList.getPreferredSize();
        d.height = 200;
        jScrollPane.setPreferredSize(d);
        add(new JLabel("NPC selection:"));
        add(jScrollPane, BorderLayout.CENTER);
        add(container);
        d = animationPanel.getPreferredSize();
        d.height = 200;
        animationPanel.setPreferredSize(d);
        add(animationPanel);
        add(animationFilter);
        add(saveButton);
        add(exportPanel);
    }

    private void setSelection(Object[] animationGroups, JCheckBox freePick, ModelExporterData modelExporterData) {
        if (npcList.getSelectedRow() == -1) {
            return;
        }
        NPCData data = (NPCData) npcList.getValueAt(npcList.getSelectedRow(), 0);
        List<Animation> matchingAnimations = new ArrayList<>();
        matchingAnimations.add(new Animation(-1));
        for (Object animationGroup : animationGroups) {
            AnimationGroup anim = (AnimationGroup) animationGroup;
            if (freePick.isSelected()) {
                matchingAnimations.addAll(((AnimationGroup) animationGroup).getAnimationGroup());
            } else if (anim.getAnimationGroup().contains(new Animation(data.getStandingAnimation())) || anim.getAnimationGroup().contains(new Animation(data.getWalkingAnimation()))) {
                matchingAnimations.addAll(anim.getAnimationGroup());
                //unless this is for player animations only 1 group can match, so we break after finding it.
                if (data.getId() != -1) {
                    break;
                }
            }
        }
        animationList.setModel(new AnimationTableModel(matchingAnimations.stream().sorted().toArray(), "Animations", modelExporterData.getAnimationNames()));
        addSearchBox(animationList, animationFilter);
        applyAnimation(data.getId(), data.getStandingAnimation());
    }

    private boolean setConfig() {
        if (npcList.getSelectedRow() == -1)
            return false;
        int npcId = ((NPCData) npcList.getValueAt(npcList.getSelectedRow(), 0)).getId();
        config.setFrame(0);
        config.setNpcId(npcId);
        config.setAnimationId(getAnimationID());
        return true;
    }

    public int getAnimationID() {
        int animation;
        if (animationList.getSelectedRow() != -1)
            animation = ((Animation) animationList.getValueAt(animationList.getSelectedRow(), 0)).getId();
        else
            animation = ((NPCData) npcList.getValueAt(npcList.getSelectedRow(), 0)).getStandingAnimation();
        return animation;
    }

    private void applyAnimation(int id, int animation) {
        clientThread.invoke(() -> {
            if (client.getGameState() == GameState.LOGGED_IN && client.getLocalPlayer() != null) {
                Player player = client.getLocalPlayer();
                player.getPlayerComposition().setTransformedNpcId(id);
                player.setIdlePoseAnimation(animation);
            }
        });
    }

    private void exportSequence() {
        if (!setConfig())
            return;
        int animation = getAnimationID();
        clientThread.invoke(() -> {
            if (client.getGameState() == GameState.LOGGED_IN && client.getLocalPlayer() != null) {
                if (animation == -1) {
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Exported a normal model since no animation was selected.", "");
                    ModelDumperPlugin.getInstance().exportLocalPlayerModel(null);
                } else {
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Exported animation sequence", "");
                    ModelDumperPlugin.getInstance().exportLocalPlayerSequence(null);
                }
            }
        });
    }

    public void addSearchBox(JTable jTable, JTextField filter) {
        TableRowSorter<TableModel> rowSorter = new TableRowSorter<>(jTable.getModel());
        jTable.setRowSorter(rowSorter);
        filter.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                String text = filter.getText();

                if (text.trim().isEmpty()) {
                    rowSorter.setRowFilter(null);
                } else {
                    try {
                        rowSorter.setRowFilter(RowFilter.regexFilter("(?i)" + text));
                    } catch (PatternSyntaxException ex) {
                        rowSorter.setRowFilter(null);
                    }
                }
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                String text = filter.getText();

                if (text.trim().isEmpty()) {
                    rowSorter.setRowFilter(null);
                } else {
                    try {
                        rowSorter.setRowFilter(RowFilter.regexFilter("(?i)" + text));
                    } catch (PatternSyntaxException ex) {
                        rowSorter.setRowFilter(null);
                    }

                }
            }

            @Override
            public void changedUpdate(DocumentEvent e) {}
        });
    }
}

package net.bram91.modeldumper;

import java.io.File;
import net.runelite.api.Model;
import net.runelite.api.Renderable;
import net.runelite.client.RuneLite;

import java.awt.Color;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import static net.bram91.modeldumper.JagexColor.createPalette;

public class OBJExporter
{

    private final static int[] colorPalette = createPalette(JagexColor.BRIGHTNESS_MIN);
    private final static String PATH = RuneLite.RUNELITE_DIR + "//models//";

    public static void export(Renderable r, String name)
    {
        Model m;
        if (r instanceof Model)
        {
            m = (Model) r;
        }
        else
        {
            m = r.getModel();
        }

        export(m, name);
    }

    public static void export(Model m, String path, String name, boolean seq)
    {
        try
        {
			File folder = new File(PATH);

			if (!folder.exists())
			{
				folder.mkdir();
			}
            exportModel(m, path, name, seq);
        }
		catch (FileNotFoundException e)
        {
            e.printStackTrace();
        }
    }

    private static void exportModel(Model m, String path, String name, boolean seq) throws FileNotFoundException
    {
        if (m == null)
            return;

        String mtlName = name;
        boolean shouldWriteMaterials = ModelDumperPlugin.getConfig().material();
        if(seq)
        {
            mtlName = name.split("-")[0]+"-"+name.split("-")[1];
            if(!name.split("-")[2].equals("0") && seq && !ModelDumperPlugin.getConfig().writeMaterialData())
            {
                shouldWriteMaterials = false;
            }
        }

        // Open writers
        PrintWriter obj = new PrintWriter(path+ name + ".obj");
        PrintWriter mtl = null;
        obj.println("# Made by RuneLite Model-Dumper Plugin");
        if(shouldWriteMaterials)
        {
            mtl = new PrintWriter(path + mtlName + ".mtl");
            obj.println("mtllib " + mtlName + ".mtl");
        }
        obj.println("o " + name);

        // Write vertices
        for (int vi=0; vi < m.getVerticesCount(); ++vi)
        {
            // Y and Z axes are flipped
            int vx = (int) m.getVerticesX()[vi];
            int vy = (int) -m.getVerticesY()[vi];
            int vz = (int) -m.getVerticesZ()[vi];
            obj.println("v " + vx + " " + vy + " " + vz);
        }

        // Write faces
        List<Color> knownColors = new ArrayList<>();
        int prevMtlIndex = -1;
        for (int fi=0; fi < m.getFaceCount(); ++fi)
        {
            // determine face color (textured or colored?)
            Color c;
            int textureId = -1;
            if (m.getFaceTextures() != null)
                textureId = m.getFaceTextures()[fi];
            if (textureId != -1)
            {
                // get average color of texture
                c = TextureColor.getColor(textureId);
            }
            else
            {
                if (m.getFaceColors3()[fi] == -1)
                {
                    // face should be shaded flat
                    int colorIndex = m.getFaceColors1()[fi];
                    int rgbColor = colorPalette[colorIndex];
                    c = new Color(rgbColor);
                } else {

                    // get average color of vertices
                    int c1 = m.getFaceColors1()[fi];
                    int c2 = m.getFaceColors2()[fi];
                    int c3 = m.getFaceColors3()[fi];
                    c = JagexColor.HSLtoRGBAvg(c1, c2, c3);
                }
            }

            // see if our color already has a mtl
            int ci = knownColors.indexOf(c);
            if(shouldWriteMaterials) {
                for (int i = 0; i < knownColors.size(); i++) {
                    if (similarTo(c, knownColors.get(i), ModelDumperPlugin.getInstance().getConfig().getMaxDistance())) {
                        ci = i;
                        break;
                    }
                }
            }

            if (ci == -1 && shouldWriteMaterials)
            {
                // add to known colors
                ci = knownColors.size();
                knownColors.add(c);

                // int to float color conversion
                double r = (double) c.getRed() / 255.0d;
                double g = (double) c.getGreen() / 255.0d;
                double b = (double) c.getBlue() / 255.0d;

                // write mtl
                mtl.println("newmtl c" + ci);
                mtl.printf("Kd %.4f %.4f %.4f\n", r, g, b);
            }


            // only write usemtl if the mtl has changed
            if (shouldWriteMaterials && prevMtlIndex != ci)
            {
                obj.println("usemtl c" + ci);
            }

            // OBJ vertices are indexed by 1
            int vi1 = m.getFaceIndices1()[fi] + 1;
            int vi2 = m.getFaceIndices2()[fi] + 1;
            int vi3 = m.getFaceIndices3()[fi] + 1;
            obj.println("f " + vi1 + " " + vi2 + " " + vi3);

            prevMtlIndex = ci;

        }

        // flush output buffers
        obj.flush();
        obj.close();
        if(shouldWriteMaterials) {
            mtl.flush();
            mtl.close();
        }
    }

    private static boolean similarTo(Color c1, Color c2, double maxDistance){
        double distance = Math.sqrt((c1.getRed() - c2.getRed())*(c1.getRed() - c2.getRed()) + (c1.getGreen() - c2.getGreen())*(c1.getGreen() - c2.getGreen())+(c1.getBlue() - c2.getBlue())*(c1.getBlue() - c2.getBlue()));
        double percentage = distance/Math.sqrt(65025 + 65025 + 65025)*100;
        if(percentage < maxDistance){
            return true;
        }else{
            return false;
        }
    }
}

package net.bram91.modeldumper;

import net.runelite.api.Model;

import java.awt.Color;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.FileOutputStream;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static net.bram91.modeldumper.JagexColor.createPalette;

public class PLYExporter
{

    private final static int[] colorPalette = createPalette(JagexColor.BRIGHTNESS_MIN);

    public static void export(Model m, String name) throws IOException
    {
        List<Vertex> vertices = new ArrayList<>();
        for (int fi=0; fi < m.getFaceCount(); fi++)
        {
            // determine vertex colors (textured or colored?)
            Color vc1;
            Color vc2;
            Color vc3;
            int textureId = -1;
            if (m.getFaceTextures() != null)
                textureId = m.getFaceTextures()[fi];
            if (textureId != -1)
            {
                // get average color of texture
                vc1 = TextureColor.getColor(textureId);
                vc2 = vc1;
                vc3 = vc1;
            }
            else
            {
                if (m.getFaceColors3()[fi] == -1)
                {
                    // face should be shaded flat
                    int colorIndex = m.getFaceColors1()[fi];
                    int rgbColor = colorPalette[colorIndex];
                    vc1 = vc2 = vc3 = new Color(rgbColor);
                } else {
                    // get color for each vertex
                    vc1 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors1()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc2 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors2()[fi], JagexColor.BRIGHTNESS_MIN));
                    vc3 = new Color(JagexColor.HSLtoRGB((short) m.getFaceColors3()[fi], JagexColor.BRIGHTNESS_MIN));
                }
            }

            int vi1 = m.getFaceIndices1()[fi];
            int vi2 = m.getFaceIndices2()[fi];
            int vi3 = m.getFaceIndices3()[fi];

            int vx1 = (int) m.getVerticesX()[vi1];
            int vx2 = (int) m.getVerticesX()[vi2];
            int vx3 = (int) m.getVerticesX()[vi3];
            int vy1 = (int) -m.getVerticesY()[vi1];
            int vy2 = (int) -m.getVerticesY()[vi2];
            int vy3 = (int) -m.getVerticesY()[vi3];
            int vz1 = (int) m.getVerticesZ()[vi1];
            int vz2 = (int) m.getVerticesZ()[vi2];
            int vz3 = (int) m.getVerticesZ()[vi3];

            vertices.add(new Vertex(vx1, vy1, vz1, vc1.getRed(), vc1.getGreen(), vc1.getBlue()));
            vertices.add(new Vertex(vx2, vy2, vz2, vc2.getRed(), vc2.getGreen(), vc2.getBlue()));
            vertices.add(new Vertex(vx3, vy3, vz3, vc3.getRed(), vc3.getGreen(), vc3.getBlue()));
        }

        OutputStream ply = new FileOutputStream(name + ".ply");
        PrintWriter plyHeader = new PrintWriter(ply);
        plyHeader.println("ply");
        plyHeader.println("format binary_little_endian 1.0");
        plyHeader.println("element vertex " + vertices.size());
        plyHeader.println("property int16 x");
        plyHeader.println("property int16 y");
        plyHeader.println("property int16 z");
        plyHeader.println("property uint8 red");
        plyHeader.println("property uint8 green");
        plyHeader.println("property uint8 blue");
        plyHeader.println("element face " + m.getFaceCount());
        plyHeader.println("property list uint8 int16 vertex_indices");
        plyHeader.println("end_header");
        plyHeader.flush();

        ByteArrayOutputStream w = new ByteArrayOutputStream();

        for (Vertex v: vertices)
        {
            // Y and Z axes are flipped
            w.write(le(v.x));
            w.write(le(v.z));
            w.write(le(v.y));
            w.write((byte) v.r);
            w.write((byte) v.g);
            w.write((byte) v.b);
        }

        for (int i=0; i < m.getFaceCount(); ++i)
        {
            int vi = i*3;
            w.write((byte) 3);
            w.write(le(vi));
            w.write(le(vi+1));
            w.write(le(vi+2));
        }

        w.flush();
        ply.write(w.toByteArray());
        ply.flush();
        ply.close();

    }

    // int to little endian byte array
    private static byte[] le(int n)
    {
        byte[] b = new byte[2];
        b[0] = (byte) n;
        b[1] = (byte) (n >> 8);
        return b;
    }

    private static class Vertex
    {
        public int x, y, z;
        public int r, g, b;

        public Vertex(int x, int y, int z, int r, int g, int b)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.r = r;
            this.g = g;
            this.b = b;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Vertex vertex = (Vertex) o;
            return x == vertex.x && y == vertex.y && z == vertex.z && r == vertex.r && g == vertex.g && b == vertex.b;
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y, z, r, g, b);
        }
    }

}

package net.bram91.modeldumper;

import net.runelite.api.Model;

import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.FileOutputStream;
import java.io.ByteArrayOutputStream;

public class STLExporter {

    public static void export(Model m, String name) throws IOException {
        OutputStream os = new FileOutputStream(name + ".stl");
        PrintWriter stlHeader = new PrintWriter(os);
        // 80 byte header
        stlHeader.print("UNITS=mm STL Exported from RuneLite Model-Dumper Plugin, using non-color binary!");
        stlHeader.flush();

        ByteArrayOutputStream w = new ByteArrayOutputStream();
        w.write(le(m.getFaceCount()));

        for (int fi = 0; fi < m.getFaceCount(); ++fi) {
            int vi1 = m.getFaceIndices1()[fi];
            int vi2 = m.getFaceIndices2()[fi];
            int vi3 = m.getFaceIndices3()[fi];

            // face normal vector
            w.write(le(0.0f));
            w.write(le(0.0f));
            w.write(le(0.0f));

            // vertex 1
            w.write(le((float) m.getVerticesX()[vi1]));
            w.write(le((float) m.getVerticesZ()[vi1]));
            w.write(le((float) -m.getVerticesY()[vi1]));

            // vertex 2
            w.write(le((float) m.getVerticesX()[vi2]));
            w.write(le((float) m.getVerticesZ()[vi2]));
            w.write(le((float) -m.getVerticesY()[vi2]));

            // vertex 3
            w.write(le((float) m.getVerticesX()[vi3]));
            w.write(le((float) m.getVerticesZ()[vi3]));
            w.write(le((float) -m.getVerticesY()[vi3]));

            // "attribute byte count" unused
            w.write(0);
            w.write(0);
        }

        w.flush();
        os.write(w.toByteArray());
        os.flush();
        os.close();
    }

    // int to little endian byte array
    private static byte[] le(int n) {
        byte[] b = new byte[4];
        b[0] = (byte) n;
        b[1] = (byte) (n >> 8);
        b[2] = (byte) (n >> 16);
        b[3] = (byte) (n >> 24);
        return b;
    }

    private static byte[] le(float f)
    {
        byte[] b = new byte[4];
        int n = Float.floatToIntBits(f);
        b[0] = (byte) n;
        b[1] = (byte) (n >> 8);
        b[2] = (byte) (n >> 16);
        b[3] = (byte) (n >> 24);
        return b;
    }

}

package net.bram91.modeldumper;

import net.runelite.api.Client;

import java.awt.Color;
import java.util.HashMap;
import java.util.Map;

public class TextureColor
{

    private static final Map<Integer, Color> colorCache = new HashMap<>();

    // get single average color from Jagex texture id
    public static Color getColor(int textureId)
    {
        if (colorCache.containsKey(textureId))
            return colorCache.get(textureId);

        Client client = ModelDumperPlugin.getClient();
        if (client == null)
            return new Color(255, 255, 255);
        int[] pixels = client.getTextureProvider().load(textureId);

        int r = 0;
        int g = 0;
        int b = 0;
        int n = 0;
        for (int pixel : pixels)
        {
            // skip transparent (black)
            if (pixel == 0)
                continue;

            Color c = new Color(pixel);
            r += c.getRed();
            g += c.getGreen();
            b += c.getBlue();
            n++;
        }

        Color c = new Color(r/n, g/n, b/n);
        colorCache.put(textureId, c);
        return c;
    }

}

package net.bram91.modeldumper.types;

import lombok.Getter;
import lombok.Setter;

public class Animation implements Comparable<Animation> {
    @Getter
    private int id;

    @Getter
    @Setter
    private String name;

    public Animation(int id) {
        this.id = id;
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof Animation) {
            return id == ((Animation) o).id;
        }
        return false;
    }

    public String toString() {
        if (name == null) {
            return id + "";
        }
        return id + " - " + name;
    }

    @Override
    public int compareTo(Animation o) {
        return ((Integer) this.id).compareTo(o.getId());
    }
}

package net.bram91.modeldumper.types;

import lombok.Data;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.util.List;

@Data
@RequiredArgsConstructor
public class AnimationGroup {
    @Getter
    private final List<Animation> animationGroup;
}
package net.bram91.modeldumper.types;

import javax.swing.table.AbstractTableModel;
import java.util.HashMap;

public class AnimationTableModel extends AbstractTableModel {
    private Object[] data;
    private String name;
    private HashMap<Integer, String> modelExporterData;

    public AnimationTableModel(Object[] data, String name, HashMap<Integer, String> modelExporterData) {
        super();
        this.data = data;
        this.name = name;
        this.modelExporterData = modelExporterData;
    }

    public int getColumnCount() {
        return 1;
    }

    public int getRowCount() {
        return data.length;
    }

    // The object to render in a cell
    public Object getValueAt(int row, int col) {
        if (data[row] instanceof Animation && ((Animation) data[row]).getName() == null && modelExporterData.containsKey(((Animation) data[row]).getId())) {
            ((Animation) data[row]).setName(modelExporterData.get(((Animation) data[row]).getId()));
        }
        return data[row];
    }

    public String getColumnName(int col) {
        return name;
    }

}
package net.bram91.modeldumper.types;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import net.runelite.http.api.RuneLiteAPI;

import java.io.*;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Set;

import static net.runelite.client.RuneLite.RUNELITE_DIR;
@Slf4j
public class DataFetcher {

    private static final Gson gson = RuneLiteAPI.GSON.newBuilder().create();

    private String getRemoteJson(String path) throws IOException {
        String url = "https://bram91.github.io/" + path;
        if (System.getProperty("devmode") != null) {
            url = "http://localhost/" + path;
        }

        try (InputStream inputStream = new URL(url).openStream()) {
            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
            return readAll(reader);
        }
    }

    private static String readAll(Reader rd) throws IOException {
        StringBuilder sb = new StringBuilder();
        int cp;
        while ((cp = rd.read()) != -1) {
            sb.append((char) cp);
        }
        return sb.toString();
    }

    public Set<NPCData> getNPCData() throws IOException {
        String data = getRemoteJson("data.json");

        return gson.fromJson(data, new TypeToken<Set<NPCData>>() {
        }.getType());
    }

    public Set<NPCData> getAnimationGroups() throws IOException {
        String data = getRemoteJson("animationgroups.json");
        return gson.fromJson(data, new TypeToken<Set<AnimationGroup>>() {
        }.getType());
    }

    public HashMap<Integer, String> getAnimationNames() {
        HashMap<Integer, String> animationNames = new HashMap<>();
        File MODEL_DIR = new File(RUNELITE_DIR, "models/animationNames.txt");
        BufferedReader reader;
        try {
            reader = new BufferedReader(new FileReader(MODEL_DIR));
            String line = reader.readLine();

            while (line != null) {
                String[] lineData = line.split("=");
                animationNames.put(Integer.valueOf(lineData[0]), lineData[1]);
                line = reader.readLine();
            }

            reader.close();
        } catch (IOException e) {

        } catch (ArrayIndexOutOfBoundsException e) {
            log.warn("Invalid line in models/animationNames.txt");
        }
        return animationNames;
    }

    public void saveAnimationNames(Object[] animationNames) throws FileNotFoundException {
        PrintWriter animationName = new PrintWriter(new File(RUNELITE_DIR, "models/animationNames.txt"));
        for (Object name : animationNames) {
            AnimationGroup animationGroup = (AnimationGroup) name;
            animationGroup.getAnimationGroup().forEach((a) -> {
                if (a.getName() != null && !a.getName().equals("null"))
                    animationName.println(a.getId() + "=" + a.getName());
            });

        }
        animationName.flush();
        animationName.close();
    }
}

package net.bram91.modeldumper.types;

import lombok.Data;
import lombok.Getter;

import javax.inject.Inject;
import java.io.IOException;
import java.util.HashMap;
import java.util.Set;

@Data
public class ModelExporterData {
    @Getter
    private Set<NPCData> npcData;
    private Set<NPCData> animationGroup;
    private HashMap<Integer, String> animationNames;

    public ModelExporterData() {
        try {
            this.npcData = new DataFetcher().getNPCData();
            this.animationGroup = new DataFetcher().getAnimationGroups();
            this.animationNames = new DataFetcher().getAnimationNames();
        } catch (IOException e) {
            this.npcData = null;
            this.animationGroup = null;
        }
    }
}

package net.bram91.modeldumper.types;

import lombok.Data;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Data
@RequiredArgsConstructor
public class NPCData implements Comparable<NPCData> {
    @Getter
    private final String name;
    private final int id;
    private final int standingAnimation;
    private final int walkingAnimation;

    public String toString() {
        return name;
    }

    @Override
    public int compareTo(NPCData o) {
        return this.name.compareTo(o.toString());
    }
}

package com.example;

import net.bram91.modeldumper.ModelDumperPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ModelDumperPlugin.class);
		RuneLite.main(args);
	}
}

