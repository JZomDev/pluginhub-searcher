package com.shootingstartracking;

public enum NotifyType
{
	CHAT_MESSAGE,
	NOTIFICATION,
	BOTH
}

package com.shootingstartracking;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.Range;

@ConfigGroup(ShootingStarTrackingConfig.configGroup)
public interface ShootingStarTrackingConfig extends Config
{
	String configGroup = "Shooting Stars Tracking";

	String displayAsTime = "displayAsTime";

    @ConfigItem(
            keyName = "timeTillRemove",
            name = "Minutes till stars are removed",
            description = "The number of minutes after landing the star will remain on the list")
    default int timeTillRemoveConfig() {return 85;}

    @ConfigItem(
            keyName = displayAsTime,
            name = "Show minutes remaining",
            description = "Show the minutes remaining rather than the expected time"
    )
    default boolean displayAsMinutes() {return true;}

	@Range(
		max = 100
	)
	@ConfigItem(
		keyName = "notifyTime",
		name = "Notify percentage",
		description = "0% notifies when min time reached, 100% for max time")
	default int notifyPercentage() {return 0;}

	@ConfigItem(
		keyName = "notifyType",
		name = "Notification Type",
		description = "Notification type for a star that you've added a notification to"
	)
	default NotifyType notifyType() {return NotifyType.BOTH;}
}

package com.shootingstartracking;

import lombok.Getter;
import lombok.Setter;

public class ShootingStarTrackingData {

    @Getter
    private final int world;
    @Getter
    private final ShootingStarLocations location;
    @Getter
    private final long minTime;
	@Getter
	private final long maxTime;
	@Getter
	@Setter
	private transient boolean notify;

    public ShootingStarTrackingData(int world, ShootingStarLocations location, long minTime, long maxTime)
    {
        this.world = world;
        this.location = location;
        this.minTime = minTime;
		this.maxTime = maxTime;
	}

    @Override
    public String toString()
    {
		return "world:" + world + " location:" + location + " time:" + minTime + " - " + maxTime;
    }

    enum ShootingStarLocations {
        ASGARNIA("Asgarnia"),
        KARAMJA("Crandor or Karamja", "Crandor / Karamja"),
        FELDIP_HILLS("Feldip Hills or on the Isle of Souls", "Feldip Hills / Isle of Souls"),
        FOSSIL_ISLAND("Fossil Island or on Mos Le'Harmless", "Fossil Island / Mos Le'Harmless"),
        FREMENNIK("Fremennik Lands or on Lunar Isle", "Fremennik Lands / Lunar Isle"),
        KOUREND("Great Kourend"),
        KANDARIN("Kandarin"),
        KEBOS("Kebos Lowlands"),
        KHARIDIAN_DESERT("Kharidian Desert"),
        MISTHALIN("Misthalin"),
        MORYTANIA("Morytania"),
        PISCATORIS("Piscatoris or the Gnome Stronghold", "Piscatoris / Gnome Stronghold"),
        TIRANNWN("Tirannwn"),
        WILDERNESS("Wilderness"),
		VARLAMORE("Varlamore"),
        UNKNOWN("Unknown");

        public static final ShootingStarLocations[] values = ShootingStarLocations.values();

        @Getter
        private final String location;
		@Getter
		private final String shortLocation;

        ShootingStarLocations(String location, String shortLocation)
        {
            this.location = location;
			this.shortLocation = shortLocation;
		}

		ShootingStarLocations(String location)
		{
			this(location, location);
		}
    }
}

package com.shootingstartracking;

import com.google.common.collect.Ordering;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.border.EmptyBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import java.util.function.Function;

public class ShootingStarTrackingPanel extends PluginPanel {

	private static final ZoneId utcZoneId = ZoneId.of("UTC");
	private static final String ADD_NOTIFICATION = "Add notification";
	private static final String REMOVE_NOTIFICATION = "Remove notification";

	static final int WORLD_WIDTH = 35;
	static final int LOCATION_WIDTH = 60;
	static final int TIME_WIDTH = 47;

    private ShootingStarTrackingTableHeader worldHeader;
    private ShootingStarTrackingTableHeader locationHeader;
    private ShootingStarTrackingTableHeader minTimeHeader;
    private ShootingStarTrackingTableHeader maxTimeHeader;

    private final JPanel listContainer = new JPanel();

    private final ShootingStarTrackingPlugin plugin;
    private Order orderIndex = Order.MIN_TIME;
	private boolean ascendingOrder = false;

	ShootingStarTrackingPanel(ShootingStarTrackingPlugin plugin) {
        this.plugin = plugin;
        setBorder(null);
        setLayout(new DynamicGridLayout(0, 1));
        JPanel header = buildHeader();
        listContainer.setLayout(new GridLayout(0, 1));
        add(header);
        add(listContainer);
        JPanel buttons = new JPanel();
        buttons.setBorder(new EmptyBorder(5, 5, 5, 5));
        buttons.setLayout(new BoxLayout(buttons, BoxLayout.Y_AXIS));
        buttons.add(importPanel());
		buttons.add(Box.createRigidArea(new Dimension(0, 5)));
        buttons.add(exportPanel());
		buttons.add(Box.createRigidArea(new Dimension(0, 5)));
        buttons.add(discordPanel());
		buttons.add(Box.createRigidArea(new Dimension(0, 5)));
		buttons.add(removePanel());
        add(buttons);
    }

    private JPanel buildHeader()
    {
        JPanel header = new JPanel(new BorderLayout());

        worldHeader = new ShootingStarTrackingTableHeader("W");
        worldHeader.setPreferredSize(new Dimension(WORLD_WIDTH,20));
        worldHeader.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isRightMouseButton(e))
                {
                    return;
                }
                ascendingOrder = orderIndex != Order.WORLD || !ascendingOrder;
                orderBy(Order.WORLD);
            }
        });

        locationHeader = new ShootingStarTrackingTableHeader("Location");
        locationHeader.setPreferredSize(new Dimension(LOCATION_WIDTH,20));
        locationHeader.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isRightMouseButton(e))
                {
                    return;
                }
                ascendingOrder = orderIndex != Order.LOCATION || !ascendingOrder;
                orderBy(Order.LOCATION);
            }
        });

        JPanel timePanel = new JPanel(new BorderLayout());

        minTimeHeader = new ShootingStarTrackingTableHeader("Min");
		minTimeHeader.setPreferredSize(new Dimension(TIME_WIDTH,20));
		minTimeHeader.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isRightMouseButton(e))
                {
                    return;
                }
                ascendingOrder = orderIndex != Order.MIN_TIME || !ascendingOrder;
                orderBy(Order.MIN_TIME);
            }
        });
		minTimeHeader.highlight(true,ascendingOrder);

		maxTimeHeader = new ShootingStarTrackingTableHeader("Max");
		maxTimeHeader.setPreferredSize(new Dimension(TIME_WIDTH,20));
		maxTimeHeader.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (SwingUtilities.isRightMouseButton(e))
				{
					return;
				}
				ascendingOrder = orderIndex != Order.MAX_TIME || !ascendingOrder;
				orderBy(Order.MAX_TIME);
			}
		});

		timePanel.add(minTimeHeader, BorderLayout.WEST);
		timePanel.add(maxTimeHeader, BorderLayout.EAST);

        header.add(worldHeader,BorderLayout.WEST);
        header.add(locationHeader,BorderLayout.CENTER);
        header.add(timePanel,BorderLayout.EAST);
        return header;
    }

    void updateList(List<ShootingStarTrackingData> starData) {
        listContainer.removeAll();
        if (starData.isEmpty()) {
            JLabel noStarsLabel = new JLabel("Look through a telescope to start tracking stars");
            noStarsLabel.setFont(FontManager.getRunescapeSmallFont());
            noStarsLabel.setBorder(new EmptyBorder(5, 5, 5, 5));
            listContainer.add(noStarsLabel);
        } else {
            starData.sort((r1, r2) ->
            {
                switch (orderIndex) {
                    case WORLD:
                        return getCompareValue(r1, r2, ShootingStarTrackingData::getWorld);
                    case LOCATION:
                        return getCompareValue(r1, r2, row ->
                                row.getLocation().getLocation());
                    case MIN_TIME:
                        return getCompareValue(r1, r2, ShootingStarTrackingData::getMinTime);
					case MAX_TIME:
						return getCompareValue(r1, r2, ShootingStarTrackingData::getMaxTime);
                    default:
                        return 0;
                }
            });

            int i = 0;
            for (ShootingStarTrackingData data : starData) {
                Color backgroundColor = i % 2 == 0 ? ColorScheme.DARK_GRAY_COLOR : ColorScheme.DARKER_GRAY_COLOR;
                ShootingStarTrackingTableRow r = new ShootingStarTrackingTableRow(data, plugin.isDisplayAsMinutes(), backgroundColor, plugin.getWorldHop(), plugin.getWorld());
                r.setComponentPopupMenu(buildRemoveMenu(r, data));
                listContainer.add(r);
                i++;
            }
        }

        listContainer.revalidate();
        listContainer.repaint();
    }

	public void updateTimes(List<ShootingStarTrackingData> starData)
	{
		if (starData.isEmpty()) {
			return;
		}

		for (Component component : listContainer.getComponents()) {
			ShootingStarTrackingTableRow r = (ShootingStarTrackingTableRow) component;
			r.updateTime();
			r.updateLocationColor();
		}

		listContainer.repaint();
	}

    private JPopupMenu buildRemoveMenu(ShootingStarTrackingTableRow row, ShootingStarTrackingData star)
    {
        JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5,5,5,5));

		JMenuItem hopEntryOption = new JMenuItem();
		hopEntryOption.setText("Hop to");
		hopEntryOption.setFont(FontManager.getRunescapeSmallFont());
		hopEntryOption.addActionListener(e -> plugin.hopTo(star));
		popupMenu.add(hopEntryOption);

        JMenuItem removeEntryOption = new JMenuItem();
        removeEntryOption.setText("Remove");
        removeEntryOption.setFont(FontManager.getRunescapeSmallFont());
        removeEntryOption.addActionListener(e -> plugin.removeStar(star));
        popupMenu.add(removeEntryOption);

        if (ZonedDateTime.now(utcZoneId).toInstant().toEpochMilli() < star.getMaxTime()) {
			JMenuItem notifyOption = new JMenuItem();
			if (star.isNotify()) {
				notifyOption.setText(REMOVE_NOTIFICATION);
			} else {
				notifyOption.setText(ADD_NOTIFICATION);
			}
			notifyOption.setFont(FontManager.getRunescapeSmallFont());
			notifyOption.addActionListener(e -> {
				if (star.isNotify()) {
					notifyOption.setText(ADD_NOTIFICATION);
				} else {
					notifyOption.setText(REMOVE_NOTIFICATION);
				}
				star.setNotify(!star.isNotify());
				row.updateNotifyBorder();
				notifyOption.repaint();
			});
			popupMenu.add(notifyOption);
		}

        return popupMenu;
    }

    private int getCompareValue(ShootingStarTrackingData row1, ShootingStarTrackingData row2, Function<ShootingStarTrackingData, Comparable> compareFn)
    {
        Ordering<Comparable> ordering = Ordering.natural();
        if (!ascendingOrder)
        {
            ordering = ordering.reverse();
        }
        ordering = ordering.reverse();
        return ordering.compare(compareFn.apply(row1),compareFn.apply(row2));
    }

    private void orderBy(Order order)
    {
        worldHeader.highlight(false, ascendingOrder);
        locationHeader.highlight(false, ascendingOrder);
        minTimeHeader.highlight(false, ascendingOrder);
        maxTimeHeader.highlight(false, ascendingOrder);
        switch (order)
        {
            case WORLD:
                worldHeader.highlight(true, ascendingOrder);
                break;
            case LOCATION:
                locationHeader.highlight(true, ascendingOrder);
                break;
            case MIN_TIME:
                minTimeHeader.highlight(true, ascendingOrder);
                break;
			case MAX_TIME:
				maxTimeHeader.highlight(true, ascendingOrder);
				break;
        }
        orderIndex = order;
        updateList(plugin.getStarData());
    }

    private JPanel exportPanel()
    {
        JPanel panel = new JPanel();
        JLabel label = new JLabel("Export");
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setPreferredSize(new Dimension(60,30));
        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (!SwingUtilities.isRightMouseButton(e))
                {
                    plugin.exportData();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });
        panel.add(label);
        return panel;
    }

    private JPanel importPanel()
    {
        JPanel panel = new JPanel();
        JLabel label = new JLabel("Import");
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setPreferredSize(new Dimension(60,30));
        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (!SwingUtilities.isRightMouseButton(e))
                {
                    plugin.importData();
                }
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });
        panel.add(label);
        return panel;
    }

	private JPanel discordPanel()
	{
		JPanel panel = new JPanel();
		JLabel label = new JLabel("Copy for Discord format");
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setPreferredSize(new Dimension(60,30));
		panel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (!SwingUtilities.isRightMouseButton(e))
				{
					plugin.discordFormat();
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});
		panel.add(label);
		return panel;
	}

	private JPanel removePanel()
	{
		JPanel panel = new JPanel();
		JLabel label = new JLabel("Remove clipboard worlds");
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setPreferredSize(new Dimension(60,30));
		panel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (!SwingUtilities.isRightMouseButton(e))
				{
					plugin.removeWorldsInClipboard();
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});
		panel.add(label);
		return panel;
	}

	private enum Order
    {
        WORLD,
        LOCATION,
		MIN_TIME,
		MAX_TIME
    }
}

package com.shootingstartracking;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Provides;
import com.shootingstartracking.ShootingStarTrackingData.ShootingStarLocations;
import java.awt.Toolkit;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.HashSet;
import java.util.Set;
import javax.swing.SwingUtilities;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(
	name = "Shooting Star Tracking"
)
public class ShootingStarTrackingPlugin extends Plugin
{
	private static final File SAVE_FILE = new File(RuneLite.RUNELITE_DIR, "shooting-star-tracking.json");
	private static final int TELESCOPE_WIDGET_ID = 229;
	private static final ZoneId utcZoneId = ZoneId.of("UTC");

	private static final Pattern minutesThenHoursPattern = Pattern.compile(".* next (\\d+) minutes to (\\d+) hours? (\\d+) .*");
	private static final Pattern minutesPattern = Pattern.compile(".* (\\d+) to (\\d+) .*");
	private static final Pattern hoursPattern = Pattern.compile(".* next (\\d+) hours? (\\d+) minutes? to (\\d+) hours? (\\d+) .*");

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ShootingStarTrackingConfig config;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	@Getter
	private WorldHop worldHop;

	@Inject
	private Notifier notifier;

	@Inject
	private Gson gson;

	private ShootingStarTrackingPanel panel;

	private NavigationButton navButton;

	@Getter
	private boolean displayAsMinutes;

	@Getter
	@Setter
	private List<ShootingStarTrackingData> starData = new ArrayList<>();

	private int lastWorld;

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded) {
		if (widgetLoaded.getGroupId() == TELESCOPE_WIDGET_ID) {
			clientThread.invokeLater(this::extractStarInformation);
		}
	}

	@Subscribe
	public void onConfigChanged(final ConfigChanged event)
	{
		if (!event.getGroup().equals(ShootingStarTrackingConfig.configGroup)) {
			return;
		}

		if (event.getKey().equals(ShootingStarTrackingConfig.displayAsTime)) {
			displayAsMinutes = config.displayAsMinutes();
			panel.updateList(starData);
		}
	}

	@Provides
	ShootingStarTrackingConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(ShootingStarTrackingConfig.class);
	}

	private void extractStarInformation()
	{
		final Widget widget = client.getWidget(TELESCOPE_WIDGET_ID,3);
		if (widget == null) {
			return;
		}
		ZonedDateTime minTime = ZonedDateTime.now(utcZoneId);
		String widgetText;

		try{
			widgetText = widget.getText().replace("<br>"," ");
		} catch (NullPointerException e) {
			return;
		}
		Optional<ShootingStarLocations> locationOp = Arrays.stream(ShootingStarLocations.values)
			.filter(o -> widgetText.contains(o.getLocation()))
			.findAny();
		if (!locationOp.isPresent())
		{
			log.debug("No match found");
			return;
		}

		int[] minutesInterval = minutesInterval(widgetText);
		if (minutesInterval == null) {
			return;
		}
		ZonedDateTime maxTime = minTime.plusMinutes(minutesInterval[1]);
		minTime = minTime.plusMinutes(minutesInterval[0]);

		ShootingStarTrackingData data = new ShootingStarTrackingData(client.getWorld(), locationOp.get(), minTime.toInstant().toEpochMilli(), maxTime.toInstant().toEpochMilli());
		addToList(data);
		save();
		SwingUtilities.invokeLater(() -> panel.updateList(starData));
	}

	private int[] minutesInterval(String widgetText) {

		Matcher m = minutesThenHoursPattern.matcher(widgetText);
		if (m.find())
		{
			int minTime = Integer.parseInt(m.group(1));
			int maxTime = 60 * Integer.parseInt(m.group(2)) + Integer.parseInt(m.group(3));
			return new int[]{minTime, maxTime};
		}

		m = hoursPattern.matcher(widgetText);
		if (m.find())
		{
			int minTime = 60 * Integer.parseInt(m.group(1)) + Integer.parseInt(m.group(2));
			int maxTime = 60 * Integer.parseInt(m.group(3)) + Integer.parseInt(m.group(4));
			return new int[]{minTime, maxTime};
		}

		m = minutesPattern.matcher(widgetText);
		if (m.find())
		{
			int minTime = Integer.parseInt(m.group(1));
			int maxTime = Integer.parseInt(m.group(2));
			return new int[]{minTime, maxTime};
		}
		return null;
	}

	private void addToList(ShootingStarTrackingData data)
	{
		ShootingStarTrackingData oldStar = starData.stream()
			.filter(star -> data.getWorld() == star.getWorld())
			.findFirst()
			.orElse(null);

		if (oldStar == null) {
			starData.add(data);
			return;
		}

		if (data.getMaxTime() < oldStar.getMinTime()) {
			// data imported is an older star
			return;
		}
		starData.remove(oldStar);

		if (!data.getLocation().equals(oldStar.getLocation())) {
			starData.add(data);
			return;
		}

		long minTime = Math.max(oldStar.getMinTime(), data.getMinTime());
		long maxTime = data.getMaxTime();
		if (data.getMaxTime() >= oldStar.getMinTime()) {
			maxTime = Math.min(oldStar.getMaxTime(), data.getMaxTime());
		}
		ShootingStarTrackingData newStar = new ShootingStarTrackingData(data.getWorld(), data.getLocation(), minTime, maxTime);
		newStar.setNotify(oldStar.isNotify());
		starData.add(newStar);
	}

	private void save()
	{
		String json = gson.toJson(starData);
		try
		{
			Files.write(SAVE_FILE.toPath(), json.getBytes(StandardCharsets.UTF_8));
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}

	@Schedule(
			period = 5,
			unit = ChronoUnit.SECONDS
	)
	public void checkDepletedStars()
	{
		List<ShootingStarTrackingData> stars = new ArrayList<>(starData);
		ZonedDateTime now = ZonedDateTime.now(utcZoneId);
		int removeTime = config.timeTillRemoveConfig();
		boolean fullUpdate = false;

		for (ShootingStarTrackingData star : starData) {
			if (checkNotification(star, now)) {
				fullUpdate = true;
			}
			if (star.getMinTime() < now.minusMinutes(removeTime).toInstant().toEpochMilli()) {
				stars.remove(star);
				fullUpdate = true;
			}
		}

		if (fullUpdate) {
			starData = stars;
			SwingUtilities.invokeLater(() -> panel.updateList(starData));
		} else {
			SwingUtilities.invokeLater(() -> panel.updateTimes(starData));
		}
	}

	private boolean checkNotification(ShootingStarTrackingData star, ZonedDateTime now) {
		if (!star.isNotify()) {
			return false;
		}
		long time = star.getMinTime() + config.notifyPercentage() * (star.getMaxTime() - star.getMinTime()) / 100;
		if (time < now.toInstant().toEpochMilli()) {
			star.setNotify(false);
			String msg = "Star W" + star.getWorld() + " " + star.getLocation().getShortLocation();
			NotifyType type = config.notifyType();
			if (type == NotifyType.BOTH || type == NotifyType.NOTIFICATION) {
				notifier.notify(msg);
			}
			if (type == NotifyType.BOTH || type == NotifyType.CHAT_MESSAGE) {
				sendChatMessage(msg);
			}
			return true;
		}
		return false;
	}

	@Override
	protected void startUp() throws Exception
	{
		final BufferedImage icon = ImageUtil.loadImageResource(ShootingStarTrackingPlugin.class, "/shooting_star.png");
		panel = new ShootingStarTrackingPanel(this);
		displayAsMinutes = config.displayAsMinutes();
		navButton = NavigationButton.builder()
				.tooltip("Shooting Star Tracking")
				.icon(icon)
				.panel(panel)
				.priority(7)
				.build();
		clientToolbar.addNavigation(navButton);
		try
		{
			String data = new String(Files.readAllBytes(SAVE_FILE.toPath()));
			load(data);
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
		panel.updateList(starData);
	}

	private void load(String data)
	{
		JsonArray json = gson.fromJson(data, JsonArray.class);
		json.forEach((star) -> {
			ShootingStarTrackingData parsedStar = gson.fromJson(star, ShootingStarTrackingData.class);
			addToList(parsedStar);
		});
	}

	@Override
	protected void shutDown() throws Exception
	{
		starData.clear();
		clientToolbar.removeNavigation(navButton);
	}

	public void removeStar(ShootingStarTrackingData star)
	{
		starData.remove(star);
		panel.updateList(starData);
		save();
	}

	public void importData()
	{
		try {
			final String clipboard = Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor).toString().trim();
			load(clipboard);
		} catch (IOException | UnsupportedFlavorException | JsonSyntaxException er) {
			sendChatMessage("Error importing star data.");
			return;
		}
		sendChatMessage("Imported star data.");
		save();
		panel.updateList(starData);
	}

	public void sendChatMessage(String chatMessage)
	{
		if (client.getLocalPlayer() == null) {
			return;
		}

		final String message = new ChatMessageBuilder()
				.append(ChatColorType.NORMAL)
				.append(chatMessage)
				.build();

		chatMessageManager.queue(
				QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(message)
						.build());
	}

	public void exportData()
	{
		if (starData.isEmpty()) {
			sendChatMessage("No data to export.");
			return;
		}
		String json = gson.toJson(starData);
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(json), null);
		sendChatMessage("Star data exported to clipboard.");
	}

	public void discordFormat() {
		StringBuilder sb = new StringBuilder();
		for (ShootingStarTrackingData star : starData) {
			sb.append("`")
				.append(star.getWorld())
				.append("` - `")
				.append(star.getLocation().getShortLocation())
				.append("` earliest: ")
				.append("<t:")
				.append(star.getMinTime() / 1000)
				.append(":R>")
				.append(" latest: ")
				.append("<t:")
				.append(star.getMaxTime() / 1000)
				.append(":R>")
				.append("\n");
		}
		Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(sb.toString()), null);
		sendChatMessage("Star data exported to clipboard in discord format.");
	}

	public void hopTo(ShootingStarTrackingData star)
	{
		worldHop.hop(star.getWorld());
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		worldHop.onGameTick();
	}

	public int getWorld()
	{
		return client.getWorld();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOGGED_IN && client.getWorld() != lastWorld) {
			lastWorld = client.getWorld();
			SwingUtilities.invokeLater(() -> panel.updateList(starData));
		}
	}

	public void removeWorldsInClipboard()
	{
		try {
			final String clipboard = Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor).toString().trim();
			Matcher matcher = Pattern.compile("[wW]([3-5][0-9][0-9])").matcher(clipboard);
			Set<Integer> worlds = new HashSet<>();
			while (matcher.find()) {
				try {
					worlds.add(Integer.parseInt(matcher.group(1)));
				} catch (NumberFormatException ignored) {

				}
			}
			if (worlds.isEmpty()) {
				sendChatMessage("No worlds in format w451 found in clipboard.");
				return;
			}
			long timeNow = ZonedDateTime.now(utcZoneId).toInstant().toEpochMilli();
			// don't remove stars if it's impossible for them to have landed already.
			int sizeBefore = starData.size();
			starData.removeIf(s -> timeNow >= s.getMinTime() && worlds.contains(s.getWorld()));
			int sizeAfter = starData.size();
			sendChatMessage("Removed " + (sizeBefore - sizeAfter) + " worlds.");
		} catch (NumberFormatException | IOException | UnsupportedFlavorException | JsonSyntaxException er) {
			sendChatMessage("Error encountered.");
			return;
		}
		save();
		panel.updateList(starData);
	}
}

package com.shootingstartracking;

import java.awt.BorderLayout;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class ShootingStarTrackingTableHeader extends JPanel {

    private final JLabel textLabel = new JLabel();
    private final JLabel arrowLabel = new JLabel();
    private static final ImageIcon ARROW_UP;
    private static final ImageIcon HIGHLIGHT_ARROW_UP;
    private static final ImageIcon HIGHLIGHT_ARROW_DOWN;
    private boolean ordering = false;
    static
    {
        final BufferedImage arrowDown = ImageUtil.loadImageResource(ShootingStarTrackingPlugin.class, "/arrow.png");
        final BufferedImage arrowUp = ImageUtil.rotateImage(arrowDown,Math.PI);
        ARROW_UP = new ImageIcon(arrowUp);

        final BufferedImage highlightArrowDown = ImageUtil.fillImage(arrowDown, ColorScheme.BRAND_ORANGE);
        final BufferedImage highlightArrowUp = ImageUtil.fillImage(arrowUp, ColorScheme.BRAND_ORANGE);
        HIGHLIGHT_ARROW_DOWN = new ImageIcon(highlightArrowDown);
        HIGHLIGHT_ARROW_UP = new ImageIcon(highlightArrowUp);
    }
    ShootingStarTrackingTableHeader(String title)
    {
        setLayout(new BorderLayout(5,0));
        setBorder(new CompoundBorder(
                BorderFactory.createMatteBorder(0,0,0,1,ColorScheme.LIGHT_GRAY_COLOR),
                new EmptyBorder(0,5,0,2)
        ));
        setBackground(ColorScheme.SCROLL_TRACK_COLOR);
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                if (!ordering) textLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                if (!ordering) textLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        });
        textLabel.setText(title);
        textLabel.setFont(FontManager.getRunescapeSmallFont());
        arrowLabel.setIcon(ARROW_UP);
        add(textLabel,BorderLayout.WEST);
        add(arrowLabel,BorderLayout.EAST);
    }
    void highlight(boolean on, boolean ascending)
    {
        ordering = on;
        arrowLabel.setIcon(on ? (ascending ? HIGHLIGHT_ARROW_DOWN : HIGHLIGHT_ARROW_UP) : ARROW_UP);
        textLabel.setForeground(on ? ColorScheme.BRAND_ORANGE : ColorScheme.LIGHT_GRAY_COLOR);
    }
}

package com.shootingstartracking;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.LineBorder;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import static net.runelite.client.ui.ColorScheme.BRAND_ORANGE;
import static net.runelite.client.ui.ColorScheme.LIGHT_GRAY_COLOR;
import net.runelite.client.ui.FontManager;

import javax.swing.border.EmptyBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.TimeUnit;

public class ShootingStarTrackingTableRow extends JPanel {

	private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("HH:mm");
	private static final ZoneId utcZoneId = ZoneId.of("UTC");
	private static final Color COLOR_NEGATIVE = new Color(255, 80, 80);

    @Getter
    private final ShootingStarTrackingData starData;

    private final boolean displayAsMinutes;

    private JLabel minTimeField;
    private JLabel maxTimeField;
	private JLabel locationField;

	ShootingStarTrackingTableRow(ShootingStarTrackingData starData, boolean displayAsMinutes, Color backgroundColor, final WorldHop worldHop, int curWorld)
    {
        this.starData = starData;
        this.displayAsMinutes = displayAsMinutes;
        setLayout(new BorderLayout());
		updateNotifyBorder();
        setBackground(backgroundColor);
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setBackground(getBackground().brighter());
            }
            @Override
            public void mouseExited(MouseEvent e) {
                setBackground(backgroundColor);
            }
			@Override
			public void mouseClicked(MouseEvent e) {
				// double click row hops to world
				if (e.getClickCount() == 2 && SwingUtilities.isLeftMouseButton(e)) {
					worldHop.hop(starData.getWorld());
				}
			}
        });

        JPanel worldField = buildWorldField(curWorld);
        worldField.setPreferredSize(new Dimension(ShootingStarTrackingPanel.WORLD_WIDTH,20));
        worldField.setOpaque(false);

        JPanel locationField = buildLocationField();
        locationField.setToolTipText(starData.getLocation().getLocation());
        locationField.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setBackground(getBackground().brighter());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setBackground(backgroundColor);
            }

			@Override
			public void mouseClicked(MouseEvent e) {
				// double click row hops to world
				if (e.getClickCount() == 2 && SwingUtilities.isLeftMouseButton(e)) {
					worldHop.hop(starData.getWorld());
				}
			}
        });
        locationField.setInheritsPopupMenu(true);
        this.setInheritsPopupMenu(true);
        locationField.setPreferredSize(new Dimension(ShootingStarTrackingPanel.LOCATION_WIDTH,20));
        locationField.setOpaque(false);

        JPanel timeField = buildTimeField();
        timeField.setPreferredSize(new Dimension(ShootingStarTrackingPanel.TIME_WIDTH * 2,20));
        timeField.setOpaque(false);

        add(worldField,BorderLayout.WEST);
        add(locationField,BorderLayout.CENTER);
        add(timeField,BorderLayout.EAST);
    }

    private JPanel buildWorldField(int world)
    {
        JPanel panel = new JPanel(new BorderLayout(7,0));
        panel.setBorder(new EmptyBorder(0,5,0,5));
		JLabel worldLabel = new JLabel(Integer.toString(starData.getWorld()));
		worldLabel.setFont(FontManager.getRunescapeSmallFont());
		worldLabel.setForeground(worldColor(world));
        panel.add(worldLabel,BorderLayout.CENTER);
        return panel;
    }

	private Color worldColor(int curWorld) {
		if (starData.getWorld() == curWorld) {
			return BRAND_ORANGE;
		}
		return LIGHT_GRAY_COLOR;
	}

    private JPanel buildLocationField()
    {
        JPanel panel = new JPanel(new BorderLayout(7,0));
        panel.setBorder(new EmptyBorder(0,5,0,5));
        locationField = new JLabel(starData.getLocation().getShortLocation());
        locationField.setFont(FontManager.getRunescapeSmallFont());
		updateLocationColor();
        panel.add(locationField,BorderLayout.CENTER);
        return panel;
    }

	void updateLocationColor()
	{
		locationField.setForeground(getLocationColor());
	}

	private Color getLocationColor()
	{
		long time = ZonedDateTime.now(utcZoneId).toInstant().toEpochMilli();
		boolean minimumPassed = time > starData.getMinTime();
		boolean maximumPassed = time > starData.getMaxTime();
		if (maximumPassed && minimumPassed)
		{
			return ColorScheme.PROGRESS_COMPLETE_COLOR;
		}
		if (minimumPassed) {
			return Color.YELLOW;
		}
		return LIGHT_GRAY_COLOR;
	}

	private JPanel buildTimeField()
    {
        JPanel panel = new JPanel(new BorderLayout(7,0));
        panel.setBorder(new EmptyBorder(0,5,0,5));
        minTimeField = new JLabel();
		minTimeField.setFont(FontManager.getRunescapeSmallFont());
        panel.add(minTimeField, BorderLayout.CENTER);
		maxTimeField = new JLabel();
		maxTimeField.setFont(FontManager.getRunescapeSmallFont());
		panel.add(maxTimeField, BorderLayout.EAST);
		updateTime();
        return panel;
    }

    void updateTime() {
		String minTime;
		String maxTime;
		if (displayAsMinutes) {
			minTime = convertTime(starData.getMinTime());
			maxTime = convertTime(starData.getMaxTime());
		} else {
			Instant minInstant = Instant.ofEpochMilli(starData.getMinTime());
			minTime = LocalDateTime.ofInstant(minInstant, ZoneId.systemDefault()).format(dtf);
			Instant maxInstant = Instant.ofEpochMilli(starData.getMaxTime());
			maxTime = LocalDateTime.ofInstant(maxInstant, ZoneId.systemDefault()).format(dtf);
		}
		minTimeField.setText(minTime);
		maxTimeField.setText(maxTime);

		minTimeField.setForeground(getTimeColor(starData.getMinTime()));
		maxTimeField.setForeground(getTimeColor(starData.getMaxTime()));
	}

    public static String convertTime(long epoch) {
		long seconds = TimeUnit.MILLISECONDS.toSeconds(epoch - Instant.now().toEpochMilli());
		boolean negative = seconds < 0;
		seconds = Math.abs(seconds);
		String time = negative ? "-" : "";
		long minutes = seconds / 60;
		seconds %= 60;
		if (minutes >= 100) {
			time += minutes + "m";
		} else {
			time += String.format("%d:%02d", minutes, seconds);
		}
		return time;
	}

    private Color getTimeColor(long time) {
		if (time > ZonedDateTime.now(utcZoneId).toInstant().toEpochMilli())
		{
			return LIGHT_GRAY_COLOR;
		}
		return COLOR_NEGATIVE;
	}

	public void updateNotifyBorder()
	{
		if (starData.isNotify())
			setBorder(new LineBorder(BRAND_ORANGE, 1));
		else
			setBorder(new EmptyBorder(1,1,1,1));
	}
}

package com.shootingstartracking;

import javax.inject.Inject;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.WorldService;
import net.runelite.client.util.WorldUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;

public class WorldHop
{
	private static final int DISPLAY_SWITCHER_MAX_ATTEMPTS = 3;

	private final Client client;
	private final ClientThread clientThread;
	private final WorldService worldService;
	private final ChatMessageManager chatMessageManager;

	private net.runelite.api.World quickHopTargetWorld;
	private int displaySwitcherAttempts = 0;

	@Inject
	WorldHop(Client client, ClientThread clientThread, WorldService worldService, ChatMessageManager chatMessageManager) {
		this.client = client;
		this.clientThread = clientThread;
		this.worldService = worldService;
		this.chatMessageManager = chatMessageManager;
	}

	public void hop(int worldId)
	{
		WorldResult worldResult = worldService.getWorlds();
		if (worldResult == null) {
			return;
		}
		// Don't try to hop if the world doesn't exist
		World world = worldResult.findWorld(worldId);
		if (world == null)
		{
			return;
		}

		clientThread.invoke(() -> hop(world));
	}

	private void hop(World world)
	{
		assert client.isClientThread();

		final net.runelite.api.World rsWorld = client.createWorld();
		rsWorld.setActivity(world.getActivity());
		rsWorld.setAddress(world.getAddress());
		rsWorld.setId(world.getId());
		rsWorld.setPlayerCount(world.getPlayers());
		rsWorld.setLocation(world.getLocation());
		rsWorld.setTypes(WorldUtil.toWorldTypes(world.getTypes()));

		if (client.getGameState() == GameState.LOGIN_SCREEN)
		{
			// on the login screen we can just change the world by ourselves
			client.changeWorld(rsWorld);
			return;
		}

		quickHopTargetWorld = rsWorld;
		displaySwitcherAttempts = 0;
	}

	@Subscribe
	public void onGameTick()
	{
		if (quickHopTargetWorld == null)
		{
			return;
		}

		if (client.getWidget(InterfaceID.WORLDSWITCHER, 0) == null)
		{
			client.openWorldHopper();

			if (++displaySwitcherAttempts >= DISPLAY_SWITCHER_MAX_ATTEMPTS)
			{
				String chatMessage = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append("Failed to quick-hop after ")
					.append(ChatColorType.HIGHLIGHT)
					.append(Integer.toString(displaySwitcherAttempts))
					.append(ChatColorType.NORMAL)
					.append(" attempts.")
					.build();

				chatMessageManager
					.queue(QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(chatMessage)
						.build());

				resetQuickHopper();
			}
		}
		else
		{
			client.hopToWorld(quickHopTargetWorld);
			resetQuickHopper();
		}
	}

	private void resetQuickHopper()
	{
		displaySwitcherAttempts = 0;
		quickHopTargetWorld = null;
	}
}

package com.shootingstartracking;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ShootingStarTrackingPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ShootingStarTrackingPlugin.class);
		RuneLite.main(args);
	}
}
package com.shootingstartracking;

import java.time.Instant;
import junit.framework.TestCase;

public class ShootingStarTrackingTableRowTest extends TestCase
{
	public void testConvertTime()
	{
		assertEquals("0:00", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli()));
		assertEquals("0:15", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() + 15 * 1000));
		assertEquals("-0:15", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() - 15 * 1000));
		assertEquals("1:15", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() + 75 * 1000));
		assertEquals("-1:15", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() - 75 * 1000));
		assertEquals("-1:45", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() - 105 * 1000));
		assertEquals("60:00", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() + 60 * 60 * 1000));
		assertEquals("600m", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() + 600 * 60 * 1000 + 15 * 1000));
		assertEquals("100m", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() + 100 * 60 * 1000 + 15 * 1000));
		assertEquals("99:15", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() + 99 * 60 * 1000 + 15 * 1000));
		assertEquals("-600m", ShootingStarTrackingTableRow.convertTime(Instant.now().toEpochMilli() - 600 * 60 * 1000 - 15 * 1000));
	}
}
