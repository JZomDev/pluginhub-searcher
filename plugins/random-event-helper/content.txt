package randomeventhelper;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.DynamicObject;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import randomeventhelper.randomevents.beekeeper.BeekeeperHelper;
import randomeventhelper.randomevents.drilldemon.DrillDemonHelper;
import randomeventhelper.randomevents.freakyforester.FreakyForesterHelper;
import randomeventhelper.randomevents.gravedigger.GravediggerHelper;
import randomeventhelper.randomevents.maze.MazeHelper;
import randomeventhelper.randomevents.mime.MimeHelper;
import randomeventhelper.randomevents.pinball.PinballHelper;
import randomeventhelper.randomevents.pirate.PirateHelper;
import randomeventhelper.randomevents.sandwichlady.SandwichLadyHelper;
import randomeventhelper.randomevents.quizmaster.QuizMasterHelper;
import randomeventhelper.randomevents.surpriseexam.SurpriseExamHelper;

@Slf4j
@PluginDescriptor(
	name = "Random Event Helper"
)
public class RandomEventHelperPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private RandomEventHelperConfig config;

	@Inject
	private RandomEventHelperOverlay overlay;

	@Inject
	private RandomEventHelperItemOverlay itemOverlay;

	@Inject
	private SurpriseExamHelper surpriseExamHelper;

	@Inject
	private BeekeeperHelper beekeeperHelper;

	@Inject
	private FreakyForesterHelper freakyForesterHelper;

	@Inject
	private PinballHelper pinballHelper;

	@Inject
	private DrillDemonHelper drillDemonHelper;

	@Inject
	private GravediggerHelper gravediggerHelper;

	@Inject
	private MimeHelper mimeHelper;

	@Inject
	private MazeHelper mazeHelper;

	@Inject
	private SandwichLadyHelper sandwichLadyHelper;

	@Inject
	private QuizMasterHelper quizMasterHelper;

	@Inject
	private PirateHelper pirateHelper;

	@Override
	protected void startUp() throws Exception
	{
		this.overlayManager.add(overlay);
		this.overlayManager.add(itemOverlay);
		if (config.isSurpriseExamEnabled())
		{
			surpriseExamHelper.startUp();
		}
		if (config.isBeekeeperEnabled())
		{
			beekeeperHelper.startUp();
		}
		if (config.isFreakyForesterEnabled())
		{
			freakyForesterHelper.startUp();
		}
		if (config.isPinballEnabled())
		{
			pinballHelper.startUp();
		}
		if (config.isDrillDemonEnabled())
		{
			drillDemonHelper.startUp();
		}
		if (config.isGravediggerEnabled())
		{
			gravediggerHelper.startUp();
		}
		if (config.isMimeEnabled())
		{
			mimeHelper.startUp();
		}
		if (config.isMazeEnabled())
		{
			mazeHelper.startUp();
		}
		if (config.isSandwichLadyEnabled())
		{
			sandwichLadyHelper.startUp();
		}
		if (config.isQuizMasterEnabled())
		{
			quizMasterHelper.startUp();
		}
		if (config.isCaptArnavChestEnabled())
		{
			pirateHelper.startUp();
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		this.overlayManager.remove(overlay);
		this.overlayManager.remove(itemOverlay);
		surpriseExamHelper.shutDown();
		beekeeperHelper.shutDown();
		freakyForesterHelper.shutDown();
		pinballHelper.shutDown();
		drillDemonHelper.shutDown();
		gravediggerHelper.shutDown();
		mimeHelper.shutDown();
		mazeHelper.shutDown();
		sandwichLadyHelper.shutDown();
		quizMasterHelper.shutDown();
		pirateHelper.shutDown();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getGroup().equals("randomeventhelper"))
		{
			log.debug("Config changed: {} | New value: {}", configChanged.getKey(), configChanged.getNewValue());
			if (configChanged.getKey().equals("isSurpriseExamEnabled"))
			{
				if (config.isSurpriseExamEnabled())
				{
					surpriseExamHelper.startUp();
				}
				else
				{
					surpriseExamHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isBeekeeperEnabled"))
			{
				if (config.isBeekeeperEnabled())
				{
					beekeeperHelper.startUp();
				}
				else
				{
					beekeeperHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isFreakyForesterEnabled"))
			{
				if (config.isFreakyForesterEnabled())
				{
					freakyForesterHelper.startUp();
				}
				else
				{
					freakyForesterHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isPinballEnabled"))
			{
				if (config.isPinballEnabled())
				{
					pinballHelper.startUp();
				}
				else
				{
					pinballHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isDrillDemonEnabled"))
			{
				if (config.isDrillDemonEnabled())
				{
					drillDemonHelper.startUp();
				}
				else
				{
					drillDemonHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isGravediggerEnabled"))
			{
				if (config.isGravediggerEnabled())
				{
					gravediggerHelper.startUp();
				}
				else
				{
					gravediggerHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isMimeEnabled"))
			{
				if (config.isMimeEnabled())
				{
					mimeHelper.startUp();
				}
				else
				{
					mimeHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isMazeEnabled"))
			{
				if (config.isMazeEnabled())
				{
					mazeHelper.startUp();
				}
				else
				{
					mazeHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isSandwichLadyEnabled"))
			{
				if (config.isSandwichLadyEnabled())
				{
					sandwichLadyHelper.startUp();
				}
				else
				{
					sandwichLadyHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isQuizMasterEnabled"))
			{
				if (config.isQuizMasterEnabled())
				{
					quizMasterHelper.startUp();
				}
				else
				{
					quizMasterHelper.shutDown();
				}
			}
			else if (configChanged.getKey().equals("isCaptArnavChestEnabled"))
			{
				if (config.isCaptArnavChestEnabled())
				{
					pirateHelper.startUp();
				}
				else
				{
					pirateHelper.shutDown();
				}
			}
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged animationChanged)
	{
		Actor actor = animationChanged.getActor();
		if (actor instanceof NPC)
		{
			// log.debug("NPC Animation changed: {} - New Animation ID: {}", ((NPC) actor).getName(), actor.getAnimation());
		}
		else if (actor instanceof GameObject)
		{
			// log.debug("GameObject Animation changed: {} - New Animation ID: {}", ((GameObject) actor).getId(), actor.getAnimation());
		}
		else if (actor instanceof Player)
		{
			// log.debug("Player Animation changed: {} - New Animation ID: {}", ((Player) actor).getName(), actor.getAnimation());
		}
		else if (actor instanceof DynamicObject)
		{
			// log.debug("DynamicObject Animation changed: {} - New Animation ID: {}", ((DynamicObject) actor).getModel().getSceneId(), actor.getAnimation());
		}
		else
		{
			// log.debug("Unknown Actor Animation changed: {} - New Animation ID: {}", actor.getName(), actor.getAnimation());
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// log.debug("isInstanced: {} | WorldLocation Region ID: {} | LocalLocation Region ID: {}", this.client.getTopLevelWorldView().isInstance(), this.client.getLocalPlayer().getWorldLocation().getRegionID(), this.getRegionIDFromCurrentLocalPointInstanced());
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		// log.debug("Widget loaded with group ID: {}", widgetLoaded.getGroupId());
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed)
	{
		// log.debug("Widget closed with group ID: {}", widgetClosed.getGroupId());
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{

	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{

	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned)
	{
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		// log.debug("Chat message ({}) received: {}", chatMessage.getType(), chatMessage.getMessage());
		// String sanitizedChatMessage = Text.sanitizeMultilineText(chatMessage.getMessage());
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{

	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned groundObjectSpawned)
	{

	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged itemContainerChanged)
	{

	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded menuEntryAdded)
	{

	}

	@Provides
	RandomEventHelperConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RandomEventHelperConfig.class);
	}

	// Accounts for local instances too such as inside the pinball and gravekeeper random event
	public static int getRegionIDFromCurrentLocalPointInstanced(Client client)
	{
		return WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID();
	}

	public static boolean isInRandomEventLocalInstance(Client client)
	{
		return RandomEventHelperPlugin.getRegionIDFromCurrentLocalPointInstanced(client) == 7758;
	}
}

package randomeventhelper;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import randomeventhelper.randomevents.freakyforester.PheasantMode;

@ConfigGroup("randomeventhelper")
public interface RandomEventHelperConfig extends Config
{
	@ConfigItem(
		keyName = "isBeekeeperEnabled",
		name = "Beekeeper",
		description = "Helps highlight the correct order for the Beekeeper random event.",
		position = 0
	)
	default boolean isBeekeeperEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isCaptArnavChestEnabled",
		name = "Capt' Arnav's Chest",
		description = "Helps with aligning the chest slots to unlock Capt' Arnav's Chest random event.",
		position = 1
	)
	default boolean isCaptArnavChestEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isDrillDemonEnabled",
		name = "Drill Demon",
		description = "Helps highlight the correct exercise mat for the Drill Demon random event.",
		position = 2
	)
	default boolean isDrillDemonEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isFreakyForesterEnabled",
		name = "Freaky Forester",
		description = "Helps highlight the correct pheasant to kill for the Freaky Forester random event.",
		position = 3
	)
	default boolean isFreakyForesterEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isGravediggerEnabled",
		name = "Gravedigger",
		description = "Helps highlight where each coffin belongs to each grave for the Gravedigger random event.",
		position = 4
	)
	default boolean isGravediggerEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isMazeEnabled",
		name = "Maze",
		description = "Automatically sets path of Shortest Path plugin to the Strange Shrine in the Maze random event.",
		position = 5
	)
	default boolean isMazeEnabled()
	{
		return false;
	}

	@ConfigItem(
		keyName = "isMimeEnabled",
		name = "Mime",
		description = "Helps highlight the answers for the Mime random event.",
		position = 6
	)
	default boolean isMimeEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isPinballEnabled",
		name = "Pinball",
		description = "Helps highlight the correct pillars to touch for the Pinball random event.",
		position = 7
	)
	default boolean isPinballEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isSandwichLadyEnabled",
		name = "Sandwich Lady",
		description = "Helps highlight the correct food to take from the Sandwich Lady random event.",
		position = 8
	)
	default boolean isSandwichLadyEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isSurpriseExamEnabled",
		name = "Surprise Exam",
		description = "Helps highlight the answers for the Surprise Exam random event. Supports both matching and next item questions.",
		position = 9
	)
	default boolean isSurpriseExamEnabled()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isQuizMasterEnabled",
		name = "Quiz Master",
		description = "Helps highlight the correct odd item for the Quiz Master random event.",
		position = 10
	)
	default boolean isQuizMasterEnabled()
	{
		return true;
	}

	@ConfigSection(
		name = "Options",
		description = "Further configure various options",
		position = 11,
		closedByDefault = true
	)
	String SECTION_OPTIONS = "sectionOptions";

	@ConfigItem(
		keyName = "pheasantHighlightMode",
		name = "Pheasant Highlight Mode",
		description = "Configures how to highlight the pheasant(s) for the Freaky Forester random event.",
		section = SECTION_OPTIONS,
		position = 0
	)
	default PheasantMode pheasantHighlightMode()
	{
		return PheasantMode.SPECIFIC;
	}
}

package randomeventhelper.randomevents.gravedigger;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;

@Getter
@AllArgsConstructor
public enum GraveNumber
{
	ONE(
		ObjectID.MACRO_DIGGER_GRAVESTONE_1, ObjectID.MACRO_DIGGER_OPEN_GRAVE_EMPTY_1, ObjectID.MACRO_DIGGER_OPEN_GRAVE_COFFIN_1,
		VarbitID.MACRO_DIGGER_GRAVE_1, VarbitID.MACRO_DIGGER_COFFIN_1
	),
	TWO(
		ObjectID.MACRO_DIGGER_GRAVESTONE_2, ObjectID.MACRO_DIGGER_OPEN_GRAVE_EMPTY_2, ObjectID.MACRO_DIGGER_OPEN_GRAVE_COFFIN_2,
		VarbitID.MACRO_DIGGER_GRAVE_2, VarbitID.MACRO_DIGGER_COFFIN_2
	),
	THREE(
		ObjectID.MACRO_DIGGER_GRAVESTONE_3, ObjectID.MACRO_DIGGER_OPEN_GRAVE_EMPTY_3, ObjectID.MACRO_DIGGER_OPEN_GRAVE_COFFIN_3,
		VarbitID.MACRO_DIGGER_GRAVE_3, VarbitID.MACRO_DIGGER_COFFIN_3
	),
	FOUR(
		ObjectID.MACRO_DIGGER_GRAVESTONE_4, ObjectID.MACRO_DIGGER_OPEN_GRAVE_EMPTY_4, ObjectID.MACRO_DIGGER_OPEN_GRAVE_COFFIN_4,
		VarbitID.MACRO_DIGGER_GRAVE_4, VarbitID.MACRO_DIGGER_COFFIN_4
	),
	FIVE(
		ObjectID.MACRO_DIGGER_GRAVESTONE_5, ObjectID.MACRO_DIGGER_OPEN_GRAVE_EMPTY_5, ObjectID.MACRO_DIGGER_OPEN_GRAVE_COFFIN_5,
		VarbitID.MACRO_DIGGER_GRAVE_5, VarbitID.MACRO_DIGGER_COFFIN_5
	);

	private final int graveStoneObjectID;
	private final int emptyGraveObjectID;
	private final int filledGraveObjectID;
	private final int graveTypeVarbitID;
	private final int placedCoffinVarbitID;

	private static final Map<Integer, GraveNumber> GRAVESTONE_OBJECT_ID_GRAVENUMBER_MAP;
	private static final Map<Integer, GraveNumber> EMPTY_GRAVE_OBJECT_ID_GRAVENUMBER_MAP;
	private static final Map<Integer, GraveNumber> FILLED_GRAVE_OBJECT_ID_GRAVENUMBER_MAP;

	static
	{
		GRAVESTONE_OBJECT_ID_GRAVENUMBER_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), GraveNumber::getGraveStoneObjectID);

		EMPTY_GRAVE_OBJECT_ID_GRAVENUMBER_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), GraveNumber::getEmptyGraveObjectID);

		FILLED_GRAVE_OBJECT_ID_GRAVENUMBER_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), GraveNumber::getFilledGraveObjectID);
	}

	public static boolean isGravestoneObjectID(int objectID)
	{
		return GRAVESTONE_OBJECT_ID_GRAVENUMBER_MAP.containsKey(objectID);
	}

	public static boolean isEmptyGraveObjectID(int objectID)
	{
		return EMPTY_GRAVE_OBJECT_ID_GRAVENUMBER_MAP.containsKey(objectID);
	}

	public static boolean isFilledGraveObjectID(int objectID)
	{
		return FILLED_GRAVE_OBJECT_ID_GRAVENUMBER_MAP.containsKey(objectID);
	}

	public static GraveNumber getGraveNumberFromGravestoneObjectID(int objectID)
	{
		return GRAVESTONE_OBJECT_ID_GRAVENUMBER_MAP.get(objectID);
	}

	public static GraveNumber getGraveNumberFromEmptyGraveObjectID(int objectID)
	{
		return EMPTY_GRAVE_OBJECT_ID_GRAVENUMBER_MAP.get(objectID);
	}

	public static GraveNumber getGraveNumberFromFilledGraveObjectID(int objectID)
	{
		return FILLED_GRAVE_OBJECT_ID_GRAVENUMBER_MAP.get(objectID);
	}
}
package randomeventhelper.randomevents.gravedigger;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.game.ItemManager;

@Getter
@AllArgsConstructor
public enum Coffin
{
	CRAFTING(0, ItemID.MACRO_DIGGER_COFFIN_OBJECT_1, ItemID.POT_EMPTY, new Color(88, 58, 12)),
	MINING(1, ItemID.MACRO_DIGGER_COFFIN_OBJECT_2, ItemID.BRONZE_PICKAXE, Color.LIGHT_GRAY),
	COOKING(2, ItemID.MACRO_DIGGER_COFFIN_OBJECT_3, ItemID.CHEFS_HAT, Color.ORANGE),
	FARMING(3, ItemID.MACRO_DIGGER_COFFIN_OBJECT_4, ItemID.DIBBER, Color.BLUE),
	WOODCUTTING(4, ItemID.MACRO_DIGGER_COFFIN_OBJECT_5, ItemID.BRONZE_AXE, Color.GREEN),
	EMPTY(5, -1, -1, Color.BLACK); // No item ID for empty coffin

	private final int varbitValue; // Value for both MACRO_DIGGER_GRAVE and MACRO_DIGGER_COFFIN
	private final int itemID; // Item ID of the coffin item
	private final int associatedItemID; // An item ID associated with the coffin
	private final Color color;

	private static final Map<Integer, Coffin> VARBIT_COFFIN_MAP;
	private static final Map<Integer, Coffin> ITEMID_COFFIN_MAP;

	static
	{
		VARBIT_COFFIN_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), Coffin::getVarbitValue);

		ITEMID_COFFIN_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), Coffin::getItemID);
	}

	public static Coffin getCoffinFromVarbitValue(int varbitValue)
	{
		return VARBIT_COFFIN_MAP.get(varbitValue);
	}

	public static Coffin getCoffinFromItemID(int itemID)
	{
		return ITEMID_COFFIN_MAP.get(itemID);
	}

	public BufferedImage getItemImage(ItemManager itemManager)
	{
		if (this.associatedItemID == -1)
		{
			return null;
		}
		return itemManager.getImage(this.associatedItemID);
	}
}

package randomeventhelper.randomevents.gravedigger;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.image.BufferedImage;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class GravediggerOverlay extends Overlay
{
	private final Client client;
	private final SpriteManager spriteManager;
	private final GravediggerHelper plugin;
	private BufferedImage checkBufferedImage;
	private BufferedImage crossBufferedImage;

	@Inject
	public GravediggerOverlay(Client client, GravediggerHelper plugin, SpriteManager spriteManager)
	{
		this.client = client;
		this.spriteManager = spriteManager;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getGraveMap() != null && !plugin.getGraveMap().isEmpty())
		{
			if (checkBufferedImage == null)
			{
				this.checkBufferedImage = this.spriteManager.getSprite(SpriteID.OptionsRadioButtons.CHECK_GREEN, 0);
			}
			if (crossBufferedImage == null)
			{
				this.crossBufferedImage = this.spriteManager.getSprite(SpriteID.OptionsRadioButtons.CROSS_RED, 0);
			}
			for (Map.Entry<GraveNumber, Grave> graveEntry : plugin.getGraveMap().entrySet())
			{
				GraveNumber graveNumber = graveEntry.getKey();
				Grave grave = graveEntry.getValue();
				if (grave != null)
				{
					BufferedImage coffinImage = plugin.getCoffinItemImageMap().get(grave.getRequiredCoffin());
					Coffin requiredCoffin = grave.getRequiredCoffin();
					Coffin placedCoffin = grave.getPlacedCoffin();
					if (requiredCoffin == null || placedCoffin == null)
					{
						continue;
					}
					Color requiredCoffinColor = requiredCoffin.getColor();
					Color requiredCoffinTransparentColor = this.getTransparentColor(requiredCoffin.getColor(), 50);
					Color placedCoffinColor = placedCoffin.getColor();
					Color placedCoffinTransparentColor = this.getTransparentColor(placedCoffin.getColor(), 50);
					if (coffinImage == null)
					{
						continue;
					}
					if (grave.getGraveStone() != null)
					{
						Point location = grave.getGraveStone().getCanvasLocation();
						LocalPoint localPoint = grave.getGraveStone().getLocalLocation();
						if (location != null)
						{
							OverlayUtil.renderImageLocation(client, graphics2D, localPoint, coffinImage, 50);
						}
						// Also outline the gravestone
						Shape graveStoneHull = grave.getGraveStone().getConvexHull();
						if (graveStoneHull != null)
						{
							OverlayUtil.renderPolygon(graphics2D, graveStoneHull, requiredCoffinColor);
						}
					}
					// If the grave is empty, then highlight it according to
					if (placedCoffin == Coffin.EMPTY)
					{
						Shape emptyGraveHull = grave.getEmptyGrave().getConvexHull();
						if (emptyGraveHull != null)
						{
							OverlayUtil.renderPolygon(graphics2D, emptyGraveHull, requiredCoffinColor, requiredCoffinTransparentColor, new BasicStroke(2));
						}
					}
					else
					{
						Shape filledGraveHull = grave.getFilledGrave().getConvexHull();
						if (filledGraveHull != null)
						{
							OverlayUtil.renderPolygon(graphics2D, filledGraveHull, placedCoffinColor, placedCoffinTransparentColor, new BasicStroke(2));
							Point centeredSpritePoint = Perspective.getCanvasImageLocation(client, grave.getFilledGrave().getLocalLocation(), checkBufferedImage, 0);
							if (placedCoffin != requiredCoffin)
							{
								if (centeredSpritePoint != null)
								{
									OverlayUtil.renderImageLocation(graphics2D, centeredSpritePoint, crossBufferedImage);
								}
							}
							else
							{
								if (centeredSpritePoint != null)
								{
									OverlayUtil.renderImageLocation(graphics2D, centeredSpritePoint, checkBufferedImage);
								}
							}
						}
					}
				}
			}
		}
		return null;
	}

	private Color getTransparentColor(Color color, int alpha)
	{
		return new Color(color.getRed(), color.getGreen(), color.getBlue(), alpha);
	}
}

package randomeventhelper.randomevents.gravedigger;

import lombok.Data;
import net.runelite.api.GameObject;

@Data
public class Grave
{
	private GraveNumber graveNumber;
	private GameObject graveStone;
	private GameObject emptyGrave;
	private GameObject filledGrave;
	private Coffin requiredCoffin;
	private Coffin placedCoffin;

	public Grave(GraveNumber graveNumber)
	{
		this.graveNumber = graveNumber;
		this.graveStone = null;
		this.emptyGrave = null;
		this.filledGrave = null;
		this.requiredCoffin = null;
		this.placedCoffin = null;
	}

	public Grave(GraveNumber graveNumber, Coffin requiredCoffin)
	{
		this.graveNumber = graveNumber;
		this.graveStone = null;
		this.emptyGrave = null;
		this.filledGrave = null;
		this.requiredCoffin = requiredCoffin;
		this.placedCoffin = null;
	}
}

package randomeventhelper.randomevents.gravedigger;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.WidgetItemOverlay;

@Slf4j
@Singleton
public class GravediggerItemOverlay extends WidgetItemOverlay
{
	private final Client client;
	private final GravediggerHelper plugin;

	@Inject
	public GravediggerItemOverlay(Client client, GravediggerHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		showOnInventory();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
		if (plugin.getCoffinsInInventory() != null && !plugin.getCoffinsInInventory().isEmpty() && plugin.getCoffinsInInventory().contains(itemId))
		{
			Coffin coffin = Coffin.getCoffinFromItemID(itemId);
			Color requiredCoffinColor = coffin != null ? coffin.getColor() : Color.BLACK;
			Color requiredCoffinTransparentColor = coffin != null ? this.getTransparentColor(coffin.getColor(), 50) : Color.BLACK;
			OverlayUtil.renderPolygon(graphics, widgetItem.getCanvasBounds(), requiredCoffinColor, requiredCoffinTransparentColor, new BasicStroke(2));
		}
	}

	private Color getTransparentColor(Color color, int alpha)
	{
		return new Color(color.getRed(), color.getGreen(), color.getBlue(), alpha);
	}
}

package randomeventhelper.randomevents.gravedigger;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Maps;
import com.google.common.collect.Multiset;
import com.google.common.collect.Multisets;
import com.google.common.collect.Sets;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Item;
import net.runelite.api.NPC;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.OverlayManager;
import randomeventhelper.RandomEventHelperPlugin;

@Slf4j
@Singleton
public class GravediggerHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private ItemManager itemManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private GravediggerOverlay gravediggerOverlay;

	@Inject
	private GravediggerItemOverlay gravediggerItemOverlay;

	private boolean initiallyEnteredGraveDiggerArea;

	// <Grave Number, Grave>
	@Getter
	private Map<GraveNumber, Grave> graveMap;

	@Getter
	private Map<Coffin, BufferedImage> coffinItemImageMap;

	private Multiset<Integer> previousInventory;
	private Multiset<Integer> currentInventoryItems;

	@Getter
	private Set<Integer> coffinsInInventory;


	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(gravediggerOverlay);
		this.overlayManager.add(gravediggerItemOverlay);
		this.initiallyEnteredGraveDiggerArea = false;
		this.graveMap = Maps.newHashMapWithExpectedSize(5);
		this.coffinItemImageMap = Maps.newHashMapWithExpectedSize(5);
		this.previousInventory = HashMultiset.create();
		this.currentInventoryItems = HashMultiset.create();
		this.coffinsInInventory = Sets.newHashSetWithExpectedSize(5);
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(gravediggerOverlay);
		this.overlayManager.remove(gravediggerItemOverlay);
		this.initiallyEnteredGraveDiggerArea = false;
		this.graveMap = null;
		this.coffinItemImageMap = null;
		this.previousInventory = null;
		this.currentInventoryItems = null;
		this.coffinsInInventory = null;
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// There is an edgecase where when you're at the grave digger random event if a varb is still 0 then it won't fire.
		// So lets handle this by checking to see if a player is in the grave digger random event area via NPC Leo spawn
		// And by using a separate variable to make sure not to run this constantly every game tick
		if (this.initiallyEnteredGraveDiggerArea)
		{
			for (GraveNumber graveNumber : GraveNumber.values())
			{
				VarbitChanged graveTypeVarbitChangedEvent = new VarbitChanged();
				graveTypeVarbitChangedEvent.setVarbitId(graveNumber.getGraveTypeVarbitID());
				graveTypeVarbitChangedEvent.setValue(this.client.getVarbitValue(graveNumber.getGraveTypeVarbitID()));
				VarbitChanged placedCoffinVarbitChangedEvent = new VarbitChanged();
				placedCoffinVarbitChangedEvent.setVarbitId(graveNumber.getPlacedCoffinVarbitID());
				placedCoffinVarbitChangedEvent.setValue(this.client.getVarbitValue(graveNumber.getPlacedCoffinVarbitID()));
				this.onVarbitChanged(graveTypeVarbitChangedEvent);
				this.onVarbitChanged(placedCoffinVarbitChangedEvent);
				this.initiallyEnteredGraveDiggerArea = false;
			}
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		if (!RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client))
		{
			return;
		}
		switch (varbitChanged.getVarbitId())
		{
			case VarbitID.MACRO_DIGGER_GRAVE_1: // Grave type/Gravestone
				this.updateRequiredCoffin(GraveNumber.ONE, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_COFFIN_1: // Placed coffin into the grave
				this.updatePlacedCoffin(GraveNumber.ONE, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_GRAVE_2:
				this.updateRequiredCoffin(GraveNumber.TWO, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_COFFIN_2:
				this.updatePlacedCoffin(GraveNumber.TWO, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_GRAVE_3:
				this.updateRequiredCoffin(GraveNumber.THREE, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_COFFIN_3:
				this.updatePlacedCoffin(GraveNumber.THREE, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_GRAVE_4:
				this.updateRequiredCoffin(GraveNumber.FOUR, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_COFFIN_4:
				this.updatePlacedCoffin(GraveNumber.FOUR, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_GRAVE_5:
				this.updateRequiredCoffin(GraveNumber.FIVE, varbitChanged.getValue());
				break;
			case VarbitID.MACRO_DIGGER_COFFIN_5:
				this.updatePlacedCoffin(GraveNumber.FIVE, varbitChanged.getValue());
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned)
	{
		// Pinball and grave digger random even locations are in region 7758
		if (RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client))
		{
			GameObject gameObject = gameObjectSpawned.getGameObject();
			if (GraveNumber.isGravestoneObjectID(gameObject.getId()))
			{
				GraveNumber graveNumber = GraveNumber.getGraveNumberFromGravestoneObjectID(gameObject.getId());
				if (graveNumber != null)
				{
					log.debug("A new gravestone object ({}) spawned with ID: {}, updating grave map.", graveNumber.name(), gameObject.getId());
					Grave grave = this.graveMap.get(graveNumber);
					if (grave == null)
					{
						grave = new Grave(graveNumber);
					}
					grave.setGraveStone(gameObject);
					this.graveMap.put(graveNumber, grave);
				}
				else
				{
					log.warn("Gravestone object ID {} does not map to a known grave number.", gameObject.getId());
				}
			}
			else if (GraveNumber.isEmptyGraveObjectID(gameObject.getId()))
			{
				GraveNumber graveNumber = GraveNumber.getGraveNumberFromEmptyGraveObjectID(gameObject.getId());
				if (graveNumber != null)
				{
					log.debug("A new empty grave object ({}) spawned with ID: {}, updating grave map.", graveNumber.name(), gameObject.getId());
					Grave grave = this.graveMap.get(graveNumber);
					if (grave == null)
					{
						grave = new Grave(graveNumber);
					}
					grave.setEmptyGrave(gameObject);
					this.graveMap.put(graveNumber, grave);
				}
				else
				{
					log.warn("Empty grave object ID {} does not map to a known grave number.", gameObject.getId());
				}
			}
			else if (GraveNumber.isFilledGraveObjectID(gameObject.getId()))
			{
				GraveNumber graveNumber = GraveNumber.getGraveNumberFromFilledGraveObjectID(gameObject.getId());
				if (graveNumber != null)
				{
					log.debug("A new filled grave object ({}) spawned with ID: {}, updating grave map.", graveNumber.name(), gameObject.getId());
					Grave grave = this.graveMap.get(graveNumber);
					if (grave == null)
					{
						grave = new Grave(graveNumber);
					}
					grave.setFilledGrave(gameObject);
					this.graveMap.put(graveNumber, grave);
				}
				else
				{
					log.warn("Filled grave object ID {} does not map to a known grave number.", gameObject.getId());
				}
			}
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		NPC npc = npcSpawned.getNpc();
		if (RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client))
		{
			if (npc.getId() == NpcID.MACRO_GRAVEDIGGER)
			{
				log.debug("Grave Digger Leo NPC spawned in grave digger random event area.");
				this.initiallyEnteredGraveDiggerArea = true;
				// Take this opportunity to initialize the BufferedImage for the coffin items
				for (Coffin coffin : Coffin.values())
				{
					coffinItemImageMap.put(coffin, coffin.getItemImage(this.itemManager));
				}
			}
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.MACRO_GRAVEDIGGER)
		{
			log.debug("Grave Digger Leo NPC despawned, resetting grave digger area state.");
			this.initiallyEnteredGraveDiggerArea = false;
			this.graveMap.clear();
			this.coffinItemImageMap.clear();
			this.previousInventory.clear();
			this.currentInventoryItems.clear();
			this.coffinsInInventory.clear();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged itemContainerChanged)
	{
		// In case of unequipping an item -> INVENTORY -> EQUIPMENT changes
		if (itemContainerChanged.getContainerId() == InventoryID.INV && RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client))
		{
			this.currentInventoryItems.clear();
			List<Item> itemStream = Arrays.stream(itemContainerChanged.getItemContainer().getItems()).filter(item -> item.getId() != -1).collect(Collectors.toList());
			itemStream.forEach(item -> this.currentInventoryItems.add(item.getId(), this.itemManager.getItemComposition(item.getId()).isStackable() ? 1 : item.getQuantity()));

			Multiset<Integer> currentInventory = HashMultiset.create();
			List<Item> inventoryItems = Arrays.stream(itemContainerChanged.getItemContainer().getItems()).filter(item -> item.getId() != -1).collect(Collectors.toList());
			inventoryItems.forEach(item -> currentInventory.add(item.getId(), item.getQuantity()));

			// Remember that for set operations difference A - B != B - A
			Multiset<Integer> addedItems = Multisets.difference(currentInventory, this.previousInventory);
			Multiset<Integer> removedItems = Multisets.difference(this.previousInventory, currentInventory);
			log.debug("Added Items: {}", addedItems);
			log.debug("Removed Items: {}", removedItems);

			for (Integer itemID : addedItems.elementSet())
			{
				if (Coffin.getCoffinFromItemID(itemID) != null)
				{
					this.coffinsInInventory.add(itemID);
					log.debug("Found {} coffin in inventory", Coffin.getCoffinFromItemID(itemID).name());
				}
			}

			this.previousInventory = currentInventory;
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded menuEntryAdded)
	{
		if (RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client))
		{
			if (Coffin.getCoffinFromItemID(menuEntryAdded.getItemId()) != null && menuEntryAdded.getOption().equals("Check"))
			{
				menuEntryAdded.getMenuEntry().setDeprioritized(true);
			}
		}
	}

	private void updateRequiredCoffin(GraveNumber graveNumber, int requiredCoffinVarbitValue)
	{
		log.debug("Grave {} required coffin varbit changed to value: {}", graveNumber.name(), requiredCoffinVarbitValue);
		Coffin coffin = Coffin.getCoffinFromVarbitValue(requiredCoffinVarbitValue);
		if (coffin != null)
		{
			log.debug("Grave {} requires {} coffin", graveNumber.name(), coffin.name());
			Grave grave = this.graveMap.getOrDefault(graveNumber, new Grave(graveNumber));
			grave.setRequiredCoffin(coffin);
			this.graveMap.put(graveNumber, grave);
		}
		else
		{
			log.warn("Grave {} required coffin varbit changed to unknown coffin value: {}", graveNumber.name(), requiredCoffinVarbitValue);
		}
	}

	private void updatePlacedCoffin(GraveNumber graveNumber, int placedCoffinVarbitValue)
	{
		log.debug("Grave {} placed coffin varbit changed to value: {}", graveNumber.name(), placedCoffinVarbitValue);
		Coffin coffin = Coffin.getCoffinFromVarbitValue(placedCoffinVarbitValue);
		if (coffin != null)
		{
			log.debug("Found {} coffin placed into Grave {}", coffin.name(), graveNumber.name());
			Grave grave = this.graveMap.getOrDefault(graveNumber, new Grave(graveNumber));
			grave.setPlacedCoffin(coffin);
			this.graveMap.put(graveNumber, grave);
		}
		else
		{
			log.warn("Grave {} placed coffin varbit changed to unknown coffin value: {}", graveNumber.name(), placedCoffinVarbitValue);
		}
	}
}

package randomeventhelper.randomevents.beekeeper;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class BeekeeperOverlay extends Overlay
{
	private final Client client;
	private final BeekeeperHelper plugin;

	@Inject
	public BeekeeperOverlay(Client client, BeekeeperHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getBeehiveAnswerWidgets() != null && !plugin.getBeehiveAnswerWidgets().isEmpty())
		{
			for (int i = 0; i < plugin.getBeehiveAnswerWidgets().size(); i++)
			{
				Widget answerWidget = plugin.getBeehiveAnswerWidgets().get(i);
				if (answerWidget != null && !answerWidget.isHidden() && answerWidget.getModelId() != -1)
				{
					graphics2D.setFont(graphics2D.getFont().deriveFont(18f));
					String text = String.valueOf(i + 1);
					Point textPoint = new Point(
						answerWidget.getBounds().x + (answerWidget.getBounds().width / 2) - (graphics2D.getFontMetrics().stringWidth(text) / 2),
						answerWidget.getBounds().y + (answerWidget.getBounds().height / 2) + (graphics2D.getFontMetrics().getHeight() / 2) - graphics2D.getFontMetrics().getDescent()
					);
					OverlayUtil.renderTextLocation(graphics2D, textPoint, text, Color.YELLOW);
				}
			}
		}
		return null;
	}
}

package randomeventhelper.randomevents.beekeeper;

import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.ImmutableList;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@Singleton
public class BeekeeperHelper extends Plugin
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BeekeeperOverlay beekeeperOverlay;

	@Getter
	private ImmutableList<Widget> beehiveAnswerWidgets;

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(beekeeperOverlay);
		this.beehiveAnswerWidgets = null;
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(beekeeperOverlay);
		this.beehiveAnswerWidgets = null;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() == InterfaceID.BEEHIVE)
		{
			this.clientThread.invokeLater(() -> {
				Widget exampleHiveWidget = this.client.getWidget(InterfaceID.Beehive.EXAMPLE);
				if (exampleHiveWidget != null)
				{
					// Number the placeholder texts to help users
					Widget destination1LayerWidget = this.client.getWidget(InterfaceID.Beehive.UNIVERSE_TEXT8);
					Widget destination2LayerWidget = this.client.getWidget(InterfaceID.Beehive.UNIVERSE_TEXT10);
					Widget destination3LayerWidget = this.client.getWidget(InterfaceID.Beehive.UNIVERSE_TEXT12);
					Widget destination4LayerWidget = this.client.getWidget(InterfaceID.Beehive.UNIVERSE_TEXT14);
					if (destination1LayerWidget != null && destination2LayerWidget != null && destination3LayerWidget != null && destination4LayerWidget != null)
					{
						destination1LayerWidget.setText("1. " + destination1LayerWidget.getText());
						destination2LayerWidget.setText("2. " + destination2LayerWidget.getText());
						destination3LayerWidget.setText("3. " + destination3LayerWidget.getText());
						destination4LayerWidget.setText("4. " + destination4LayerWidget.getText());
					}
					else
					{
						log.warn("One or more beehive destination layer widgets are null.");
					}

					// Lid model ID = 28806, Body model ID = 28428, entrance layer model ID = 28803, legs layer model ID = 28808
					// The following widgets are the initial (jumbled) layers of the beehive that we have to rearrange
					Widget start1LayerWidget = this.client.getWidget(InterfaceID.Beehive.START_1);
					Widget start2LayerWidget = this.client.getWidget(InterfaceID.Beehive.START_2);
					Widget start3LayerWidget = this.client.getWidget(InterfaceID.Beehive.START_3);
					Widget start4LayerWidget = this.client.getWidget(InterfaceID.Beehive.START_4);
					if (start1LayerWidget != null && start2LayerWidget != null && start3LayerWidget != null && start4LayerWidget != null)
					{
						int start1ModelID = start1LayerWidget.getModelId();
						int start2ModelID = start2LayerWidget.getModelId();
						int start3ModelID = start3LayerWidget.getModelId();
						int start4ModelID = start4LayerWidget.getModelId();
						log.debug("Beehive start layer model IDs: {}, {}, {}, {}", start1ModelID, start2ModelID, start3ModelID, start4ModelID);
						// Use this set as the correct order of the beehive layers from top to bottom (Lid, Body, Entrance, Legs)
						BiMap<Widget, Integer> startingLayerMap = ImmutableBiMap.<Widget, Integer>builder()
							.put(start1LayerWidget, start1ModelID)
							.put(start2LayerWidget, start2ModelID)
							.put(start3LayerWidget, start3ModelID)
							.put(start4LayerWidget, start4ModelID)
							.build();
						Widget[] correctBeehiveOrderWidgets = new Widget[4];
						for (Integer modelID : startingLayerMap.values())
						{
							switch (modelID)
							{
								case 28806: // Lid
									correctBeehiveOrderWidgets[0] = startingLayerMap.inverse().get(28806);
									break;
								case 28428: // Body
									correctBeehiveOrderWidgets[1] = startingLayerMap.inverse().get(28428);
									break;
								case 28803: // Entrance
									correctBeehiveOrderWidgets[2] = startingLayerMap.inverse().get(28803);
									break;
								case 28808: // Legs
									correctBeehiveOrderWidgets[3] = startingLayerMap.inverse().get(28808);
									break;
								default:
									log.warn("Unexpected beehive layer model ID: {}", modelID);
									break;
							}
						}
						this.beehiveAnswerWidgets = ImmutableList.copyOf(correctBeehiveOrderWidgets);
						log.debug("Correct beehive order widgets: {}", this.beehiveAnswerWidgets);
					}
					else
					{
						log.warn("One or more beehive start layer widgets are null.");
						this.beehiveAnswerWidgets = null;
					}
				}
			});
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed)
	{
		if (widgetClosed.getGroupId() == InterfaceID.BEEHIVE)
		{
			log.debug("Beehive widget closed, resetting beehive answer widgets.");
			this.beehiveAnswerWidgets = null;
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.MACRO_BEEKEEPER)
		{
			log.debug("Beekeeper NPC despawned, resetting beehive answer widgets.");
			this.beehiveAnswerWidgets = null;
		}
	}
}

package randomeventhelper.randomevents.mime;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.gameval.AnimationID;
import net.runelite.api.gameval.InterfaceID;

@Getter
@AllArgsConstructor
public enum MimeEmote
{
	THINK(AnimationID.EMOTE_THINK, InterfaceID.MacroMimeEmotes.BUTTON_0),
	LAUGH(AnimationID.EMOTE_LAUGH, InterfaceID.MacroMimeEmotes.BUTTON_1),
	CLIMB_ROPE(AnimationID.EMOTE_CLIMBING_ROPE, InterfaceID.MacroMimeEmotes.BUTTON_2),
	GLASS_BOX(AnimationID.EMOTE_GLASS_BOX, InterfaceID.MacroMimeEmotes.BUTTON_3),
	CRY(AnimationID.EMOTE_CRY, InterfaceID.MacroMimeEmotes.BUTTON_4),
	DANCE(AnimationID.EMOTE_DANCE, InterfaceID.MacroMimeEmotes.BUTTON_5),
	LEAN(AnimationID.EMOTE_MIME_LEAN, InterfaceID.MacroMimeEmotes.BUTTON_6),
	GLASS_WALL(AnimationID.EMOTE_GLASS_WALL, InterfaceID.MacroMimeEmotes.BUTTON_7);

	private final int animationID;
	private final int buttonWidgetID;

	private static final Map<Integer, MimeEmote> ANIMATION_TO_MIME_EMOTE_MAP;

	static
	{
		ANIMATION_TO_MIME_EMOTE_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), MimeEmote::getAnimationID);
	}

	public static MimeEmote getMimeEmoteFromAnimationID(int animationID)
	{
		return ANIMATION_TO_MIME_EMOTE_MAP.get(animationID);
	}
}

package randomeventhelper.randomevents.mime;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import randomeventhelper.randomevents.gravedigger.GravediggerHelper;

@Slf4j
@Singleton
public class MimeOverlay extends Overlay
{
	private final Client client;
	private final MimeHelper plugin;

	@Inject
	public MimeOverlay(Client client, MimeHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}


	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getMimeEmoteAnswerWidget() != null && !plugin.getMimeEmoteAnswerWidget().isHidden())
		{
			OverlayUtil.renderPolygon(graphics2D, plugin.getMimeEmoteAnswerWidget().getBounds(), Color.GREEN);
		}
		if (plugin.getMimeNPC() != null && plugin.getCurrentMimeEmote() != null)
		{
			String mimeEmoteText = plugin.getCurrentMimeEmote().name();
			graphics2D.setFont(graphics2D.getFont().deriveFont(18f));
			int mimeHeight = plugin.getMimeNPC().getLogicalHeight();
			int mimeTextOffset = plugin.getMimeNPC().getAnimationHeightOffset();
			Point textPoint = plugin.getMimeNPC().getCanvasTextLocation(graphics2D, mimeEmoteText, mimeHeight + mimeTextOffset);
			OverlayUtil.renderTextLocation(graphics2D, textPoint, mimeEmoteText, Color.WHITE);
		}
		return null;
	}
}
package randomeventhelper.randomevents.mime;

import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import randomeventhelper.RandomEventHelperPlugin;

@Slf4j
@Singleton
public class MimeHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MimeOverlay mimeOverlay;

	@Getter
	private NPC mimeNPC;

	@Getter
	private MimeEmote currentMimeEmote;

	@Getter
	private Widget mimeEmoteAnswerWidget;

	private static final int MIME_RANDOM_EVENT_REGION_ID = 8010;

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(mimeOverlay);
		this.mimeNPC = null;
		this.currentMimeEmote = null;
		this.mimeEmoteAnswerWidget = null;
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(mimeOverlay);
		this.mimeNPC = null;
		this.currentMimeEmote = null;
		this.mimeEmoteAnswerWidget = null;
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged animationChanged)
	{
		if (this.client.getLocalPlayer() != null && RandomEventHelperPlugin.getRegionIDFromCurrentLocalPointInstanced(this.client) != MIME_RANDOM_EVENT_REGION_ID)
		{
			return;
		}
		NPC mime;
		if (animationChanged.getActor() != null && animationChanged.getActor() instanceof NPC)
		{
			mime = (NPC) animationChanged.getActor();
		}
		else
		{
			return;
		}
		if (mime.getAnimation() != -1 && mime.getAnimation() != 858)
		{
			MimeEmote mimeEmote = MimeEmote.getMimeEmoteFromAnimationID(mime.getAnimation());
			this.currentMimeEmote = mimeEmote;
			if (mimeEmote != null)
			{
				log.debug("Mime Animation Detected: {}", mimeEmote);
			}
			else
			{
				log.debug("Unknown Mime Animation Detected: Animation ID = {}", mime.getAnimation());
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (this.currentMimeEmote != null && widgetLoaded.getGroupId() == InterfaceID.MACRO_MIME_EMOTES)
		{
			this.clientThread.invokeLater(() -> {
				log.debug("Mime Emote Widget Loaded, attempting to set answer widget for emote: {}", this.currentMimeEmote);
				Widget emoteAnswerWidgetButtonContainer = this.client.getWidget(this.currentMimeEmote.getButtonWidgetID());
				if (emoteAnswerWidgetButtonContainer != null && !emoteAnswerWidgetButtonContainer.isHidden())
				{
					Widget[] emoteAnswerWidgetChildren = emoteAnswerWidgetButtonContainer.getDynamicChildren();
					if (emoteAnswerWidgetChildren != null && emoteAnswerWidgetChildren.length > 0)
					{
						this.mimeEmoteAnswerWidget = emoteAnswerWidgetChildren[emoteAnswerWidgetChildren.length - 1];
						log.debug("Mime Emote Answer Widget set to: {}", this.mimeEmoteAnswerWidget);
					}
					else
					{
						log.debug("Mime Emote Answer Widget Children is null or empty");
					}
				}
				else
				{
					log.debug("Mime Emote Answer Widget Button Container is null or hidden");
				}
			});
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		if (npcSpawned.getNpc().getId() == NpcID.MACRO_MIME)
		{
			this.mimeNPC = npcSpawned.getNpc();
			log.debug("Mime NPC Spawned, setting mimeNPC: {}", this.mimeNPC);
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.MACRO_MIME)
		{
			this.mimeNPC = null;
			this.currentMimeEmote = null;
			this.mimeEmoteAnswerWidget = null;
			log.debug("Mime NPC Despawned, clearing Mime Random Event data");
		}
	}
}

package randomeventhelper.randomevents.pirate;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum ChestLockItem
{
	COINS(0, "COINS", 7752),
	BOWL(1, "BOWL", 20104),
	BAR(2, "BAR", 7751),
	RING(3, "RING", 7753);


	private final int varbitValue;
	private final String label;
	private final int modelID;

	private static final Map<String, ChestLockItem> LABEL_CHEST_LOCK_ITEM_MAP;
	private static final Map<Integer, ChestLockItem> VARBIT_CHEST_LOCK_ITEM_MAP;

	static
	{
		LABEL_CHEST_LOCK_ITEM_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), ChestLockItem::getLabel);
	}

	static
	{
		VARBIT_CHEST_LOCK_ITEM_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), ChestLockItem::getVarbitValue);
	}

	public static ChestLockItem fromLabel(String label)
	{
		return LABEL_CHEST_LOCK_ITEM_MAP.get(label);
	}

	public static ChestLockItem fromVarbitValue(int varbitValue)
	{
		return VARBIT_CHEST_LOCK_ITEM_MAP.get(varbitValue);
	}
}

package randomeventhelper.randomevents.pirate;

import lombok.Data;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Data
public class PirateChestSolver
{
	private ChestLockItem activeLeftItem;
	private ChestLockItem activeCenterItem;
	private ChestLockItem activeRightItem;
	private ChestLockItem requiredLeftItem;
	private ChestLockItem requiredCenterItem;
	private ChestLockItem requiredRightItem;
	private boolean isSolved;

	private int leftSlotUseWidget;
	private int centerSlotUseWidget;
	private int rightSlotUseWidget;

	public PirateChestSolver()
	{
		this.activeLeftItem = null;
		this.activeCenterItem = null;
		this.activeRightItem = null;
		this.requiredLeftItem = null;
		this.requiredCenterItem = null;
		this.requiredRightItem = null;
		this.isSolved = false;
	}

	public void updateRequiredItem(ChestLockSlot chestLockSlot, ChestLockItem chestLockItem)
	{
		if (chestLockItem == null || chestLockSlot == null)
		{
			log.debug("Could not find ChestLockItem or ChestLockSlot for updateRequiredItem");
			return;
		}
		switch (chestLockSlot)
		{
			case LEFT:
				this.requiredLeftItem = chestLockItem;
				break;
			case CENTER:
				this.requiredCenterItem = chestLockItem;
				break;
			case RIGHT:
				this.requiredRightItem = chestLockItem;
				break;
			default:
				break;
		}

		log.debug("Updated required chest lock item: {} to {}", chestLockSlot, chestLockItem);
	}

	public void updateActiveItem(int varbitID, int varbitValue)
	{
		ChestLockItem chestLockItem = ChestLockItem.fromVarbitValue(varbitValue);
		ChestLockSlot chestLockSlot = ChestLockSlot.fromVarbitID(varbitID);
		if (chestLockItem == null || chestLockSlot == null)
		{
			log.debug("Could not find ChestLockItem or ChestLockSlot for varbitID: {}, varbitValue: {}", varbitID, varbitValue);
			return;
		}
		switch (chestLockSlot)
		{
			case LEFT:
				this.activeLeftItem = chestLockItem;
				break;
			case CENTER:
				this.activeCenterItem = chestLockItem;
				break;
			case RIGHT:
				this.activeRightItem = chestLockItem;
				break;
			default:
				break;
		}
		log.debug("Updated current active chest lock item: {} to {}", chestLockSlot, chestLockItem);
	}

	public boolean isChestCorrectlySet()
	{
		if (this.requiredLeftItem == null || this.requiredCenterItem == null || this.requiredRightItem == null)
		{
			log.debug("Cannot solve the pirate chest puzzle, required items are not all set.");
			return false;
		}
		if (this.activeLeftItem == null || this.activeCenterItem == null || this.activeRightItem == null)
		{
			log.debug("Cannot solve the pirate chest puzzle, active items are not all set.");
			return false;
		}
		if (this.activeLeftItem == this.requiredLeftItem &&
			this.activeCenterItem == this.requiredCenterItem &&
			this.activeRightItem == this.requiredRightItem)
		{
			this.isSolved = true;
			log.debug("Pirate chest locks are correctly set.");
			return true;
		}
		log.debug("Pirate chest locks are not correctly set.");
		return false;
	}

	public void solve()
	{
		if (this.isSolved)
		{
			log.debug("Pirate chest is already solved.");
			return;
		}
		if (this.requiredLeftItem == null || this.requiredCenterItem == null || this.requiredRightItem == null)
		{
			log.debug("Cannot solve the pirate chest puzzle, required items are not all set.");
			return;
		}
		if (this.activeLeftItem == null || this.activeCenterItem == null || this.activeRightItem == null)
		{
			log.debug("Cannot solve the pirate chest puzzle, active items are not all set.");
			return;
		}
		int size = ChestLockItem.values().length;
		if (this.activeLeftItem != this.requiredLeftItem)
		{
			int addDiff = (this.requiredLeftItem.getVarbitValue() - this.activeLeftItem.getVarbitValue() + size) % size;
			int subtractDiff = (this.activeLeftItem.getVarbitValue() - this.requiredLeftItem.getVarbitValue() + size) % size;
			if (addDiff <= subtractDiff)
			{
				this.leftSlotUseWidget = ChestLockSlot.LEFT.getAddWidgetID();
			}
			else
			{
				this.leftSlotUseWidget = ChestLockSlot.LEFT.getSubtractWidgetID();
			}
			String widgetToUse = (this.leftSlotUseWidget == ChestLockSlot.LEFT.getAddWidgetID()) ? "Add" : "Subtract";
			log.debug("Left slot: Active item {} -> Required item {}, Should use {} Widget ({})", this.activeLeftItem, this.requiredLeftItem, widgetToUse, this.leftSlotUseWidget);
		}
		else
		{
			this.leftSlotUseWidget = -1;
		}
		if (this.activeCenterItem != this.requiredCenterItem)
		{
			int addDiff = (this.requiredCenterItem.getVarbitValue() - this.activeCenterItem.getVarbitValue() + size) % size;
			int subtractDiff = (this.activeCenterItem.getVarbitValue() - this.requiredCenterItem.getVarbitValue() + size) % size;
			if (addDiff <= subtractDiff)
			{
				this.centerSlotUseWidget = ChestLockSlot.CENTER.getAddWidgetID();
			}
			else
			{
				this.centerSlotUseWidget = ChestLockSlot.CENTER.getSubtractWidgetID();
			}
			String widgetToUse = (this.centerSlotUseWidget == ChestLockSlot.CENTER.getAddWidgetID()) ? "Add" : "Subtract";
			log.debug("Center slot: Active item {} -> Required item {}, Should use {} Widget ({})", this.activeCenterItem, this.requiredCenterItem, widgetToUse, this.centerSlotUseWidget);
		}
		else
		{
			this.centerSlotUseWidget = -1;
		}
		if (this.activeRightItem != this.requiredRightItem)
		{
			int addDiff = (this.requiredRightItem.getVarbitValue() - this.activeRightItem.getVarbitValue() + size) % size;
			int subtractDiff = (this.activeRightItem.getVarbitValue() - this.requiredRightItem.getVarbitValue() + size) % size;
			if (addDiff <= subtractDiff)
			{
				this.rightSlotUseWidget = ChestLockSlot.RIGHT.getAddWidgetID();
			}
			else
			{
				this.rightSlotUseWidget = ChestLockSlot.RIGHT.getSubtractWidgetID();
			}
			String widgetToUse = (this.rightSlotUseWidget == ChestLockSlot.RIGHT.getAddWidgetID()) ? "Add" : "Subtract";
			log.debug("Right slot: Active item {} -> Required item {}, Should use {} Widget ({})", this.activeRightItem, this.requiredRightItem, widgetToUse, this.rightSlotUseWidget);
		}
		else
		{
			this.rightSlotUseWidget = -1;
		}
	}

	public void reset()
	{
		this.activeLeftItem = null;
		this.activeCenterItem = null;
		this.activeRightItem = null;
		this.requiredLeftItem = null;
		this.requiredCenterItem = null;
		this.requiredRightItem = null;
		this.isSolved = false;
	}
}

package randomeventhelper.randomevents.pirate;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;

@Getter
@AllArgsConstructor
public enum ChestLockSlot
{
	LEFT(VarbitID.PIRATE_COMBILOCK_LEFT, InterfaceID.PirateCombilock.LEFT_UP, InterfaceID.PirateCombilock.LEFT_DOWN, InterfaceID.PirateCombilock.LEFT_TEXT),
	CENTER(VarbitID.PIRATE_COMBILOCK_CENTRE, InterfaceID.PirateCombilock.CENTRE_UP, InterfaceID.PirateCombilock.CENTRE_DOWN, InterfaceID.PirateCombilock.CENTRE_TEXT),
	RIGHT(VarbitID.PIRATE_COMBILOCK_RIGHT, InterfaceID.PirateCombilock.RIGHT_UP, InterfaceID.PirateCombilock.RIGHT_DOWN, InterfaceID.PirateCombilock.RIGHT_TEXT);

	public final int varbitID;
	private final int addWidgetID;
	private final int subtractWidgetID;
	private final int requiredItemLabelWidgetID;

	private static final Map<Integer, ChestLockSlot> VARBIT_CHEST_LOCK_SLOT_MAP;

	static
	{
		VARBIT_CHEST_LOCK_SLOT_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), ChestLockSlot::getVarbitID);
	}

	public static ChestLockSlot fromVarbitID(int varbitID)
	{
		return VARBIT_CHEST_LOCK_SLOT_MAP.get(varbitID);
	}
}

package randomeventhelper.randomevents.pirate;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import randomeventhelper.randomevents.mime.MimeHelper;

@Slf4j
@Singleton
public class PirateOverlay extends Overlay
{
	private final Client client;
	private final PirateHelper plugin;

	@Inject
	public PirateOverlay(Client client, PirateHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getPirateChestSolver() == null || plugin.getWidgetMap() == null || plugin.getWidgetMap().isEmpty())
		{
			return null;
		}
		if (plugin.getPirateChestSolver().isSolved())
		{
			OverlayUtil.renderPolygon(graphics2D, plugin.getWidgetMap().get(PirateHelper.CONFIRM_BUTTON_WIDGET_ID).getBounds(), Color.GREEN);
		}
		else
		{
			Widget leftActionWidget = plugin.getWidgetMap().get(plugin.getPirateChestSolver().getLeftSlotUseWidget());
			Widget centerActionWidget = plugin.getWidgetMap().get(plugin.getPirateChestSolver().getCenterSlotUseWidget());
			Widget rightActionWidget = plugin.getWidgetMap().get(plugin.getPirateChestSolver().getRightSlotUseWidget());
			if (leftActionWidget != null)
			{
				OverlayUtil.renderPolygon(graphics2D, leftActionWidget.getBounds(), Color.GREEN);
			}
			if (centerActionWidget != null)
			{
				OverlayUtil.renderPolygon(graphics2D, centerActionWidget.getBounds(), Color.GREEN);
			}
			if (rightActionWidget != null)
			{
				OverlayUtil.renderPolygon(graphics2D, rightActionWidget.getBounds(), Color.GREEN);
			}
		}
		return null;
	}
}

package randomeventhelper.randomevents.pirate;

import com.google.common.collect.Maps;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class PirateHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PirateOverlay pirateOverlay;

	public static final int CONFIRM_BUTTON_WIDGET_ID = InterfaceID.PirateCombilock.CONFIRM;

	@Getter
	private PirateChestSolver pirateChestSolver;

	private boolean initiallyLoaded;

	@Getter
	private Map<Integer, Widget> widgetMap;

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(pirateOverlay);
		this.pirateChestSolver = new PirateChestSolver();
		this.initiallyLoaded = false;
		this.widgetMap = Maps.newHashMap();
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(pirateOverlay);
		this.pirateChestSolver = null;
		this.initiallyLoaded = false;
		this.widgetMap = null;
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		switch (varbitChanged.getVarbitId())
		{
			case VarbitID.PIRATE_COMBILOCK_LEFT:
			case VarbitID.PIRATE_COMBILOCK_CENTRE:
			case VarbitID.PIRATE_COMBILOCK_RIGHT:
				if (this.pirateChestSolver == null)
				{
					this.pirateChestSolver = new PirateChestSolver();
				}
				this.pirateChestSolver.updateActiveItem(varbitChanged.getVarbitId(), varbitChanged.getValue());
				if (!this.pirateChestSolver.isChestCorrectlySet())
				{
					log.debug("[#onVarbitChanged] Attempting to solve pirate chest lock");
					this.pirateChestSolver.solve();
				}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() == InterfaceID.PIRATE_COMBILOCK)
		{
			log.info("Pirate chest random event detected");
			if (!this.initiallyLoaded)
			{
				this.initiallyLoaded = true;
				if (this.pirateChestSolver != null)
				{
					this.pirateChestSolver.reset();
				}
				else
				{
					this.pirateChestSolver = new PirateChestSolver();
				}
				VarbitChanged tempLeft = new VarbitChanged();
				tempLeft.setVarbitId(VarbitID.PIRATE_COMBILOCK_LEFT);
				tempLeft.setValue(this.client.getVarbitValue(VarbitID.PIRATE_COMBILOCK_LEFT));
				VarbitChanged tempCenter = new VarbitChanged();
				tempCenter.setVarbitId(VarbitID.PIRATE_COMBILOCK_CENTRE);
				tempCenter.setValue(this.client.getVarbitValue(VarbitID.PIRATE_COMBILOCK_CENTRE));
				VarbitChanged tempRight = new VarbitChanged();
				tempRight.setVarbitId(VarbitID.PIRATE_COMBILOCK_RIGHT);
				tempRight.setValue(this.client.getVarbitValue(VarbitID.PIRATE_COMBILOCK_RIGHT));
				this.onVarbitChanged(tempLeft);
				this.onVarbitChanged(tempCenter);
				this.onVarbitChanged(tempRight);
			}
			this.clientThread.invokeLater(() -> {
				if (this.client.getWidget(this.CONFIRM_BUTTON_WIDGET_ID) != null)
				{
					Widget leftLabelWidget = this.client.getWidget(ChestLockSlot.LEFT.getRequiredItemLabelWidgetID());
					Widget centerLabelWidget = this.client.getWidget(ChestLockSlot.CENTER.getRequiredItemLabelWidgetID());
					Widget rightLabelWidget = this.client.getWidget(ChestLockSlot.RIGHT.getRequiredItemLabelWidgetID());
					if (leftLabelWidget != null && centerLabelWidget != null && rightLabelWidget != null)
					{
						String leftItemString = Text.sanitizeMultilineText(leftLabelWidget.getText());
						String centerItemString = Text.sanitizeMultilineText(centerLabelWidget.getText());
						String rightItemString = Text.sanitizeMultilineText(rightLabelWidget.getText());
						ChestLockItem leftChestLockItem = ChestLockItem.fromLabel(leftItemString);
						ChestLockItem centerChestLockItem = ChestLockItem.fromLabel(centerItemString);
						ChestLockItem rightChestLockItem = ChestLockItem.fromLabel(rightItemString);
						log.info("Pirate Chest Lock combination: Left: {}, Center: {}, Right: {}", leftChestLockItem, centerChestLockItem, rightChestLockItem);
						if (leftChestLockItem != null && centerChestLockItem != null && rightChestLockItem != null)
						{
							this.pirateChestSolver.updateRequiredItem(ChestLockSlot.LEFT, leftChestLockItem);
							this.pirateChestSolver.updateRequiredItem(ChestLockSlot.CENTER, centerChestLockItem);
							this.pirateChestSolver.updateRequiredItem(ChestLockSlot.RIGHT, rightChestLockItem);
							if (!this.pirateChestSolver.isChestCorrectlySet())
							{
								log.debug("[#onWidgetLoaded] Attempting to solve pirate chest lock");
								this.pirateChestSolver.solve();
							}
						}
						else
						{
							log.warn("Failed to retrieve one or more chest lock items");
							log.debug("Left item string: {}, Center item string: {}, Right item string: {}", leftItemString, centerItemString, rightItemString);
						}
					}
					this.populateWidgetsMap();
					this.widgetMap.put(this.CONFIRM_BUTTON_WIDGET_ID, this.client.getWidget(this.CONFIRM_BUTTON_WIDGET_ID));
				}
			});
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed)
	{
		if (widgetClosed.getGroupId() == InterfaceID.PIRATE_COMBILOCK)
		{
			log.info("Pirate chest random event closed");
			this.initiallyLoaded = false;
			if (this.pirateChestSolver != null)
			{
				this.pirateChestSolver.reset();
				this.pirateChestSolver = null;
			}
		}
	}

	private void populateWidgetsMap()
	{
		Widget leftAddWidget = this.client.getWidget(ChestLockSlot.LEFT.getAddWidgetID());
		Widget leftSubtractWidget = this.client.getWidget(ChestLockSlot.LEFT.getSubtractWidgetID());
		Widget centerAddWidget = this.client.getWidget(ChestLockSlot.CENTER.getAddWidgetID());
		Widget centerSubtractWidget = this.client.getWidget(ChestLockSlot.CENTER.getSubtractWidgetID());
		Widget rightAddWidget = this.client.getWidget(ChestLockSlot.RIGHT.getAddWidgetID());
		Widget rightSubtractWidget = this.client.getWidget(ChestLockSlot.RIGHT.getSubtractWidgetID());
		if (leftAddWidget != null)
		{
			this.widgetMap.put(ChestLockSlot.LEFT.getAddWidgetID(), leftAddWidget);
		}
		if (leftSubtractWidget != null)
		{
			this.widgetMap.put(ChestLockSlot.LEFT.getSubtractWidgetID(), leftSubtractWidget);
		}
		if (centerAddWidget != null)
		{
			this.widgetMap.put(ChestLockSlot.CENTER.getAddWidgetID(), centerAddWidget);
		}
		if (centerSubtractWidget != null)
		{
			this.widgetMap.put(ChestLockSlot.CENTER.getSubtractWidgetID(), centerSubtractWidget);
		}
		if (rightAddWidget != null)
		{
			this.widgetMap.put(ChestLockSlot.RIGHT.getAddWidgetID(), rightAddWidget);
		}
		if (rightSubtractWidget != null)
		{
			this.widgetMap.put(ChestLockSlot.RIGHT.getSubtractWidgetID(), rightSubtractWidget);
		}
	}
}

package randomeventhelper.randomevents.pinball;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.gameval.ObjectID;

@Getter
@AllArgsConstructor
public enum PinballPost
{
	AIR(0, ObjectID.PINBALL_POST_TREE_INACTIVE),
	EARTH(1, ObjectID.PINBALL_POST_IRON_INACTIVE),
	FIRE(2, ObjectID.PINBALL_POST_COAL_INACTIVE),
	NATURE(3, ObjectID.PINBALL_POST_FISHING_INACTIVE),
	WATER(4, ObjectID.PINBALL_POST_ESSENCE_INACTIVE);

	@Getter
	@AllArgsConstructor
	enum PinballVarbit
	{
		AIR(0),
		EARTH(1),
		FIRE(2),
		NATURE(3),
		WATER(4);

		private final int value;
	}

	private final int varbitValue;
	private final int objectID;

	private static final Map<Integer, PinballPost> VARBIT_PINBALL_POST_MAP;
	private static final Map<Integer, PinballPost> OBJECT_ID_PINBALL_POST_MAP;

	static
	{
		VARBIT_PINBALL_POST_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), PinballPost::getVarbitValue);
	}

	static
	{
		OBJECT_ID_PINBALL_POST_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), PinballPost::getObjectID);
	}

	public static PinballPost fromVarbitValue(int varbitValue)
	{
		return VARBIT_PINBALL_POST_MAP.get(varbitValue);
	}

	public static PinballPost fromObjectID(int objectID)
	{
		return OBJECT_ID_PINBALL_POST_MAP.get(objectID);
	}
}

package randomeventhelper.randomevents.pinball;

import com.google.common.collect.Maps;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import randomeventhelper.RandomEventHelperPlugin;

@Slf4j
@Singleton
public class PinballHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PinballOverlay pinballOverlay;

	@Getter
	private GameObject activePinballPost;

	// <Varbit value, Object ID>
	private Map<Integer, GameObject> pinballPostsMap;

	private boolean initial = false;

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(pinballOverlay);
		this.activePinballPost = null;
		this.pinballPostsMap = Maps.newHashMap();
		this.initial = false;
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(pinballOverlay);
		this.activePinballPost = null;
		this.pinballPostsMap = null;
		this.initial = false;
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.PINBALL_TROLL_LFT && npcDespawned.getNpc().getId() == NpcID.PINBALL_TROLL_RHT)
		{
			log.debug("A pinball troll despawned, resetting active pinball post.");
			this.activePinballPost = null;
			this.pinballPostsMap = Maps.newHashMap();
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned)
	{
		GameObject gameObject = gameObjectSpawned.getGameObject();
		// Pinball and grave digger random even locations are in region 7758
		if (RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client))
		{
			PinballPost pinballPost = PinballPost.fromObjectID(gameObject.getId());
			if (pinballPost != null)
			{
				log.debug("A pinball post has spawned: {}", pinballPost);
				this.pinballPostsMap.put(pinballPost.getVarbitValue(), gameObject);

				if (!this.initial)
				{
					int currentPostVarbitValue = this.client.getVarbitValue(VarbitID.MACRO_PINBALL_CURRENT);
					if (currentPostVarbitValue != 0)
					{
						VarbitChanged temp = new VarbitChanged();
						temp.setVarbitId(VarbitID.MACRO_PINBALL_CURRENT);
						temp.setValue(currentPostVarbitValue);
						this.onVarbitChanged(temp);
						this.initial = true;
					}
				}
			}
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		if (RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client) && varbitChanged.getVarbitId() == VarbitID.MACRO_PINBALL_CURRENT)
		{
			int value = varbitChanged.getValue();
			PinballPost pinballPost = PinballPost.fromVarbitValue(value);
			if (pinballPost != null)
			{
				log.debug("The active pinball post has changed to: {}", pinballPost);
				this.activePinballPost = this.pinballPostsMap.get(value);
			}
			else
			{
				log.debug("The active pinball post varbit changed to an invalid value: {}", value);
				this.activePinballPost = null;
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		String sanitizedChatMessage = Text.sanitizeMultilineText(chatMessage.getMessage());
		if (chatMessage.getType() == ChatMessageType.GAMEMESSAGE)
		{
			if (RandomEventHelperPlugin.isInRandomEventLocalInstance(this.client) && sanitizedChatMessage.equals("You may now leave the game area."))
			{
				log.debug("Pinball game has ended so resetting active pinball post and pinball posts set.");
				this.activePinballPost = null;
				this.pinballPostsMap = Maps.newHashMap();
				this.initial = false;
			}
		}
	}
}

package randomeventhelper.randomevents.pinball;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class PinballOverlay extends Overlay
{
	private final Client client;
	private final PinballHelper plugin;

	@Inject
	public PinballOverlay(Client client, PinballHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getActivePinballPost() != null)
		{
			OverlayUtil.renderPolygon(graphics2D, plugin.getActivePinballPost().getConvexHull(), Color.GREEN);
		}
		return null;
	}
}

package randomeventhelper.randomevents.sandwichlady;

import com.google.common.collect.ImmutableMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum SandwichTrayFood
{
	MEAT_PIE(10730, "Pie"),
	KEBAB(10729, "Kebab"),
	CHOCOLATE_BAR(10728, "Chocolate bar"),
	BAGUETTE(10726, "Baguette"),
	TRIANGLE_SANDWICH(10732, "Triangle sandwich"),
	SQUARE_SANDWICH(10731, "Square sandwich"),
	ROLL(10727, "Bread roll");

	private final int modelID;
	private final String name;

	private static final Map<Integer, SandwichTrayFood> FOOD_MODEL_ID_MAP;
	private static final Map<String, SandwichTrayFood> FOOD_NAME_MAP;

	static
	{
		ImmutableMap.Builder<Integer, SandwichTrayFood> foodModelIDBuilder = new ImmutableMap.Builder<>();

		for (SandwichTrayFood sandwichTrayFood : values())
		{
			foodModelIDBuilder.put(sandwichTrayFood.getModelID(), sandwichTrayFood);
		}

		FOOD_MODEL_ID_MAP = foodModelIDBuilder.build();
	}

	static
	{
		ImmutableMap.Builder<String, SandwichTrayFood> foodNameBuilder = new ImmutableMap.Builder<>();

		for (SandwichTrayFood sandwichTrayFood : values())
		{
			foodNameBuilder.put(sandwichTrayFood.getName().toLowerCase(), sandwichTrayFood);
		}

		FOOD_NAME_MAP = foodNameBuilder.build();
	}

	public static SandwichTrayFood fromModelID(int modelID)
	{
		return FOOD_MODEL_ID_MAP.get(modelID);
	}

	public static SandwichTrayFood fromName(String name)
	{
		return FOOD_NAME_MAP.get(name.toLowerCase());
	}
}

package randomeventhelper.randomevents.sandwichlady;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class SandwichLadyOverlay extends Overlay
{
	private final Client client;
	private final SandwichLadyHelper plugin;

	@Inject
	public SandwichLadyOverlay(Client client, SandwichLadyHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getTrayFoodAnswerWidget() != null && !plugin.getTrayFoodAnswerWidget().isHidden())
		{
			OverlayUtil.renderPolygon(graphics2D, plugin.getTrayFoodAnswerWidget().getBounds(), Color.GREEN);
		}
		return null;
	}
}

package randomeventhelper.randomevents.sandwichlady;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class SandwichLadyHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private SandwichLadyOverlay sandwichLadyOverlay;

	@Getter
	private Widget trayFoodAnswerWidget;

	private final String SANDWICH_LADY_TRAY_REGEX = "Have a (?<foodName>[\\w\\s]+) for free!";
	private final Pattern SANDWICH_LADY_PATTERN = Pattern.compile(SANDWICH_LADY_TRAY_REGEX, Pattern.CASE_INSENSITIVE);

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(sandwichLadyOverlay);
		this.trayFoodAnswerWidget = null;
		WidgetLoaded temp = new WidgetLoaded();
		temp.setGroupId(InterfaceID.SANDWICH_TRAY);
		onWidgetLoaded(temp);
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(sandwichLadyOverlay);
		this.trayFoodAnswerWidget = null;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() == InterfaceID.SANDWICH_TRAY)
		{
			log.debug("Player opened sandwich tray widget");
			this.clientThread.invokeLater(() -> {
				Widget refreshmentWidget = this.client.getWidget(InterfaceID.SandwichTray.SANDWHICH_REFRESHMENT_LAYER);
				if (refreshmentWidget != null && !refreshmentWidget.isHidden())
				{
					// First fetch the food the Sandwich Lady is offering us
					Widget trayLabelWidget = this.client.getWidget(InterfaceID.SandwichTray.SANDWICH_TRAY_LABEL);
					if (trayLabelWidget != null && !trayLabelWidget.isHidden())
					{
						String trayLabelText = Text.sanitizeMultilineText(trayLabelWidget.getText());
						Matcher sandwichTrayMatcher = SANDWICH_LADY_PATTERN.matcher(trayLabelText);
						if (!sandwichTrayMatcher.find())
						{
							log.debug("Couldn't match the given string \"{}\"", trayLabelText);
							return;
						}
						String extractedFood = sandwichTrayMatcher.group("foodName");
						if (extractedFood != null)
						{
							SandwichTrayFood requestedTrayFood = SandwichTrayFood.fromName(extractedFood);
							if (requestedTrayFood != null)
							{
								Widget[] foodOptionWidgets = refreshmentWidget.getStaticChildren();
								if (foodOptionWidgets != null)
								{
									for (Widget foodOptionWidget : foodOptionWidgets)
									{
										if (foodOptionWidget != null && !foodOptionWidget.isHidden() && foodOptionWidget.getModelId() == requestedTrayFood.getModelID())
										{
											log.debug("Found matching tray food option widget for {}", requestedTrayFood);
											this.trayFoodAnswerWidget = foodOptionWidget;
										}
										else
										{
											log.debug("Could not find matching tray food option widget for {}", requestedTrayFood);
										}
									}
								}
								else
								{
									log.debug("Sandwich tray food option widgets was null - Could not fetch refreshment widget children");
								}
							}
							else
							{
								log.debug("Didn't find SandwichTrayFood from extracted food name - {} (Extracted Food Name: {})", trayLabelText, extractedFood);
							}
						}
						else
						{
							log.debug("Could not extract the food name from the sandwich tray label text - '{}'", trayLabelText);
						}
					}
				}
			});
		}

	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed)
	{
		if (widgetClosed.getGroupId() == InterfaceID.SANDWICH_TRAY)
		{
			log.debug("Player closed sandwich tray widget");
			this.trayFoodAnswerWidget = null;
		}
	}
}

package randomeventhelper.randomevents.quizmaster;

import java.util.Arrays;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@Singleton
public class QuizMasterHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private QuizMasterOverlay quizMasterOverlay;

	@Getter
	private Widget quizAnswerWidget;

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(quizMasterOverlay);
		this.quizAnswerWidget = null;
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(quizMasterOverlay);
		this.quizAnswerWidget = null;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() == InterfaceID.MACRO_QUIZSHOW)
		{
			log.debug("Quiz Master event started");
			this.clientThread.invokeLater(() -> {
				Widget buttonContainerWidget = this.client.getWidget(InterfaceID.MacroQuizshow.BUTTONS);
				if (buttonContainerWidget != null && !buttonContainerWidget.isHidden())
				{
					Set<Widget> quizAnswerButtons = Arrays.stream(buttonContainerWidget.getDynamicChildren()).filter(Objects::nonNull).collect(Collectors.toSet());
					if (!quizAnswerButtons.isEmpty())
					{
						Map<QuizItem.Type, Set<Widget>> quizTypeButtonSetMap = quizAnswerButtons.stream().filter(Objects::nonNull).collect(Collectors.groupingBy(
							quizAnswerWidget -> QuizItem.fromModelID(quizAnswerWidget.getModelId()).getType(),
							Collectors.toSet()
						));
						boolean foundOddOneOut = false;
						for (Map.Entry<QuizItem.Type, Set<Widget>> entry : quizTypeButtonSetMap.entrySet())
						{
							QuizItem.Type quizSetType = entry.getKey();
							Set<Widget> quizSetButtons = entry.getValue();
							if (quizSetButtons.size() == 1)
							{
								Widget quizAnswerWidget = quizSetButtons.stream().findFirst().orElse(null); // Shouldn't be null ever since the set is non-empty
								QuizItem quizItemAnswer = QuizItem.fromModelID(quizAnswerWidget.getModelId());
								log.debug("Found the odd one out: {}", quizItemAnswer);
								this.quizAnswerWidget = quizAnswerWidget;
								foundOddOneOut = true;
								break;
							}
						}
						if (!foundOddOneOut)
						{
							log.warn("Could not find the odd one out in the quiz answer buttons.");
							this.quizAnswerWidget = null;
						}
					}
					else
					{
						log.warn("No quiz answer buttons found in the button container widget.");
						this.quizAnswerWidget = null;
					}
				}
			});
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed)
	{
		if (widgetClosed.getGroupId() == InterfaceID.MACRO_QUIZSHOW)
		{
			log.debug("Quiz Master widget closed - Event ended");
			this.quizAnswerWidget = null;
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.MACRO_MAGNESON)
		{
			log.debug("Quiz Master NPC despawned - Event ended");
			this.quizAnswerWidget = null;
		}
	}
}

package randomeventhelper.randomevents.quizmaster;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum QuizItem
{
	TROUT_COD_PIKE_SALMON(Type.FOOD, 8829),
	TUNA(Type.FOOD, 8830),
	LONGSWORD(Type.WEAPON, 8836),
	BATTLE_AXE(Type.WEAPON, 8828),
	MED_HELM(Type.ARMOUR, 8833),
	KITESHIELD(Type.ARMOUR, 8832),
	SECATEURS(Type.TOOL, 8835),
	SPADE(Type.TOOL, 8837),
	RING(Type.JEWELRY, 8834),
	NECKLACE(Type.JEWELRY, 8831);

	private final Type type;
	private final int modelID;

	enum Type
	{
		FOOD,
		WEAPON,
		ARMOUR,
		TOOL,
		JEWELRY,
	}

	private static final Map<Integer, QuizItem> MODEL_ID_QUIZ_ITEM_MAP;
	private static final Map<QuizItem, Type> QUIZ_ITEM_TYPE_MAP;

	static
	{
		MODEL_ID_QUIZ_ITEM_MAP = Maps.uniqueIndex(ImmutableSet.copyOf(values()), QuizItem::getModelID);
	}

	static
	{
		ImmutableMap.Builder<QuizItem, Type> quizItemTypeMap = new ImmutableMap.Builder<>();

		for (QuizItem quizItem : values())
		{
			quizItemTypeMap.put(quizItem, quizItem.getType());
		}

		QUIZ_ITEM_TYPE_MAP = quizItemTypeMap.build();
	}

	public static QuizItem fromModelID(int modelID)
	{
		return MODEL_ID_QUIZ_ITEM_MAP.get(modelID);
	}
}

package randomeventhelper.randomevents.quizmaster;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class QuizMasterOverlay extends Overlay
{
	private final Client client;
	private final QuizMasterHelper plugin;

	@Inject
	public QuizMasterOverlay(Client client, QuizMasterHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getQuizAnswerWidget() != null && !plugin.getQuizAnswerWidget().isHidden())
		{
			OverlayUtil.renderPolygon(graphics2D, plugin.getQuizAnswerWidget().getBounds(), Color.GREEN);
		}
		return null;
	}
}

package randomeventhelper.randomevents.freakyforester;

public enum PheasantMode
{
	SPECIFIC,
	NEAREST,
	ALL
}

package randomeventhelper.randomevents.freakyforester;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Sets;
import com.google.inject.Provides;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import randomeventhelper.RandomEventHelperConfig;
import randomeventhelper.RandomEventHelperPlugin;

@Slf4j
@Singleton
public class FreakyForesterHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private RandomEventHelperConfig config;

	@Inject
	private FreakyForesterOverlay freakyForesterOverlay;

	private final String FREAKY_FORESTER_REGEX = "kill (a|the) (((?<numberOfTails>\\d)-tailed pheasant)|pheasant (with|that has) (?<numberOfTailsMulti>\\w+|\\d) tails)";
	private final Pattern FREAKY_FORESTER_PATTERN = Pattern.compile(FREAKY_FORESTER_REGEX, Pattern.CASE_INSENSITIVE);

	@Getter
	private PheasantMode pheasantHighlightMode;

	@Getter
	private int pheasantTailFeathers;

	@Getter
	private Set<NPC> pheasantNPCSet;

	@Getter
	private NPC nearestPheasantNPC;

	@Getter
	private NPC specificPheasantNPC;

	@Getter
	private NPC freakyForesterNPC;

	private boolean initialRun;

	private final Map<Integer, Integer> PHEASANT_TAIL_NPCID_MAP = ImmutableMap.<Integer, Integer>builder()
		.put(1, NpcID.MACRO_PHEASANT_MODEL_1)
		.put(2, NpcID.MACRO_PHEASANT_MODEL_2)
		.put(3, NpcID.MACRO_PHEASANT_MODEL_3)
		.put(4, NpcID.MACRO_PHEASANT_MODEL_4)
		.build();

	@Provides
	RandomEventHelperConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RandomEventHelperConfig.class);
	}

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(freakyForesterOverlay);
		this.pheasantHighlightMode = config.pheasantHighlightMode();
		this.pheasantTailFeathers = 0;
		this.pheasantNPCSet = Sets.newHashSet();
		this.initialRun = true;
		this.freakyForesterNPC = null;
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(freakyForesterOverlay);
		this.pheasantTailFeathers = 0;
		this.pheasantNPCSet = null;
		this.nearestPheasantNPC = null;
		this.specificPheasantNPC = null;
		this.initialRun = true;
		this.freakyForesterNPC = null;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getGroup().equals("randomeventhelper"))
		{
			if (configChanged.getKey().equals("pheasantHighlightMode"))
			{
				this.pheasantHighlightMode = PheasantMode.valueOf(configChanged.getNewValue());
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		String sanitizedChatMessage = Text.sanitizeMultilineText(chatMessage.getMessage());
		if (chatMessage.getType() == ChatMessageType.DIALOG)
		{
			if (this.isInFreakyForesterInstance())
			{
				Matcher freakyForesterMatcher = FREAKY_FORESTER_PATTERN.matcher(sanitizedChatMessage);

				if (freakyForesterMatcher.find())
				{
					String fullMatch = freakyForesterMatcher.group(0);
					if (freakyForesterMatcher.group("numberOfTails") != null)
					{
						// Should only match 2/3/4
						this.pheasantTailFeathers = Integer.parseInt(freakyForesterMatcher.group("numberOfTails"));
					}
					else
					{
						// Could be 2/3/4 or two/three/four
						try
						{
							this.pheasantTailFeathers = Integer.parseInt(freakyForesterMatcher.group("numberOfTailsMulti"));
						}
						catch (NumberFormatException e)
						{
							this.pheasantTailFeathers = this.convertWordToInt(freakyForesterMatcher.group("numberOfTailsMulti"));
						}
					}
					log.info("Freaky Forester requested a pheasant with {} tail feathers", this.pheasantTailFeathers);
					log.debug("Full match: {}", fullMatch);
					// <1, NpcID.MACRO_PHEASANT_MODEL_1>, <2, NpcID.MACRO_PHEASANT_MODEL_2>, <3, NpcID.MACRO_PHEASANT_MODEL_3>, <4, NpcID.MACRO_PHEASANT_MODEL_4>
					this.updateSpecificPheasant();
				}
				else
				{
					this.pheasantTailFeathers = 0;
				}
			}
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		NPC npc = npcSpawned.getNpc();
		if (this.isInFreakyForesterInstance())
		{
			if (PHEASANT_TAIL_NPCID_MAP.containsValue(npc.getId()))
			{
				if (this.pheasantNPCSet != null)
				{
					log.debug("A new pheasant NPC spawned, adding to the set.");
					this.pheasantNPCSet.add(npc);
					this.updateSpecificPheasant();
				}
				else
				{
					log.warn("Pheasant NPC set is null, skipping it.");
				}
			}
			else if (npc.getId() == NpcID.MACRO_FORESTER_M)
			{
				log.debug("Freaky Forester NPC spawned");
				this.freakyForesterNPC = npc;
			}
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.MACRO_FORESTER_M && !this.isInFreakyForesterInstance())
		{
			log.debug("Freaky Forester NPC despawned, resetting pheasant NPCs.");
			this.pheasantTailFeathers = 0;
			this.pheasantNPCSet.clear();
			this.specificPheasantNPC = null;
			this.nearestPheasantNPC = null;
			this.freakyForesterNPC = null;
		}
		else if (this.PHEASANT_TAIL_NPCID_MAP.containsValue(npcDespawned.getNpc().getId()) && this.isInFreakyForesterInstance())
		{
			if (this.pheasantNPCSet != null && this.pheasantNPCSet.contains(npcDespawned.getNpc()))
			{
				log.debug("A pheasant NPC despawned, removing from the set.");
				this.pheasantNPCSet.remove(npcDespawned.getNpc());
				this.updateSpecificPheasant();
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// In case the player is already in the Freaky Forester instance when the plugin is started
		if (this.initialRun && this.isInFreakyForesterInstance() && this.pheasantNPCSet.isEmpty())
		{
			this.initialRun = false;
			this.client.getTopLevelWorldView().npcs().stream().filter(npc -> !npc.isDead()).forEach(npc -> this.onNpcSpawned(new NpcSpawned(npc)));
		}
		if (this.pheasantHighlightMode == PheasantMode.NEAREST && !this.pheasantNPCSet.isEmpty())
		{
			this.updateNearestPheasant();
		}
	}

	private boolean isInFreakyForesterInstance()
	{
		return RandomEventHelperPlugin.getRegionIDFromCurrentLocalPointInstanced(client) == 10314;
	}

	private int convertWordToInt(String word)
	{
		switch (word)
		{
			case "two":
				return 2;
			case "three":
				return 3;
			case "four":
				return 4;
			default:
				return 0;
		}
	}

	private void updateSpecificPheasant()
	{
		if (this.pheasantTailFeathers == 0)
		{
			this.specificPheasantNPC = null;
			return;
		}
		this.specificPheasantNPC = this.pheasantNPCSet.stream().filter(npc -> !npc.isDead() && npc.getId() == PHEASANT_TAIL_NPCID_MAP.getOrDefault(this.pheasantTailFeathers, -1)).min((pheasant1, pheasant2) -> {
			WorldPoint localPlayerWorldPoint = this.client.getLocalPlayer().getWorldLocation();
			return Double.compare(localPlayerWorldPoint.distanceTo2D(pheasant1.getWorldLocation()), localPlayerWorldPoint.distanceTo2D(pheasant2.getWorldLocation()));
		}).orElse(null);
	}

	private void updateNearestPheasant()
	{
		this.nearestPheasantNPC = this.pheasantNPCSet.stream().filter(npc -> !npc.isDead()).min((pheasant1, pheasant2) -> {
			WorldPoint localPlayerWorldPoint = this.client.getLocalPlayer().getWorldLocation();
			return Double.compare(localPlayerWorldPoint.distanceTo2D(pheasant1.getWorldLocation()), localPlayerWorldPoint.distanceTo2D(pheasant2.getWorldLocation()));
		}).orElse(null);
	}
}

package randomeventhelper.randomevents.freakyforester;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class FreakyForesterOverlay extends Overlay
{
	private final Client client;
	private final FreakyForesterHelper plugin;

	@Inject
	public FreakyForesterOverlay(Client client, FreakyForesterHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		switch (plugin.getPheasantHighlightMode())
		{
			case SPECIFIC:
				if (plugin.getSpecificPheasantNPC() != null && !plugin.getSpecificPheasantNPC().isDead())
				{
					OverlayUtil.renderPolygon(graphics2D, plugin.getSpecificPheasantNPC().getConvexHull(), Color.GREEN);
				}
				else if (plugin.getSpecificPheasantNPC() == null && plugin.getFreakyForesterNPC() != null)
				{
					OverlayUtil.renderActorOverlay(graphics2D, (Actor) plugin.getFreakyForesterNPC(), "Talk to Freaky Forester to determine pheasant", Color.YELLOW);
				}
				break;
			case NEAREST:
				if (plugin.getNearestPheasantNPC() != null && !plugin.getNearestPheasantNPC().isDead())
				{
					OverlayUtil.renderPolygon(graphics2D, plugin.getNearestPheasantNPC().getConvexHull(), Color.GREEN);
				}
				break;
			case ALL:
				for (NPC pheasantNPC : plugin.getPheasantNPCSet())
				{
					if (pheasantNPC != null && !pheasantNPC.isDead())
					{
						OverlayUtil.renderPolygon(graphics2D, pheasantNPC.getConvexHull(), Color.GREEN);
					}
				}
				break;
			default:
				break;
		}
		return null;
	}
}

package randomeventhelper.randomevents.drilldemon;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum DrillExercise
{
	JOG(1, "Get yourself over there and jog on that mat, private!"),
	SIT_UP(2, "Get on that mat and give me sit ups, private!"),
	PUSH_UP(3, "Drop and give me push ups on that mat, private!"),
	STAR_JUMP(4, "I want to see you on that mat doing star jumps, private!");

	private final int varbitValue;
	private final String drillSergeantText;

	public static final Map<Integer, DrillExercise> VARBIT_TO_EXERCISE_MAP = Maps.uniqueIndex(ImmutableList.copyOf(values()), DrillExercise::getVarbitValue);

	public static DrillExercise getExerciseFromText(String text)
	{
		for (DrillExercise exercise : values())
		{
			if (text.toLowerCase().endsWith(exercise.getDrillSergeantText().toLowerCase()))
			{
				return exercise;
			}
		}
		return null;
	}
}

package randomeventhelper.randomevents.drilldemon;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GroundObject;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.ObjectID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import randomeventhelper.RandomEventHelperPlugin;

@Slf4j
@Singleton
public class DrillDemonHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private DrillDemonOverlay drillDemonOverlay;

	@Getter
	private List<GroundObject> exerciseMatsAnswerList;

	// <Post Number, Mat>
	private Multimap<Integer, GroundObject> exerciseMatsMultimap;

	// <Exercise Varbit, Mat>
	private Multimap<Integer, GroundObject> exerciseVarbitMatMultimap;

	private boolean initialRun;

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(drillDemonOverlay);
		this.exerciseMatsAnswerList = Lists.newArrayListWithExpectedSize(4);
		this.exerciseMatsMultimap = HashMultimap.create(4, 2);
		this.exerciseVarbitMatMultimap = HashMultimap.create(4, 2);
		this.initialRun = true;
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(drillDemonOverlay);
		this.exerciseMatsAnswerList = null;
		this.exerciseMatsMultimap = null;
		this.exerciseVarbitMatMultimap = null;
		this.initialRun = true;
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		if (npcSpawned.getNpc().getId() == NpcID.MACRO_DRILLDEMON && this.isInDrillDemonLocalInstance())
		{
			if (this.initialRun)
			{
				log.debug("Initializing varbits for Drill Demon exercise mappings in case plugin was enabled mid-event.");
				int post1Varbit = client.getVarbitValue(VarbitID.MACRO_DRILLDEMON_POST_1);
				int post2Varbit = client.getVarbitValue(VarbitID.MACRO_DRILLDEMON_POST_2);
				int post3Varbit = client.getVarbitValue(VarbitID.MACRO_DRILLDEMON_POST_3);
				int post4Varbit = client.getVarbitValue(VarbitID.MACRO_DRILLDEMON_POST_4);
				this.updateExerciseMappings(post1Varbit, 1);
				this.updateExerciseMappings(post2Varbit, 2);
				this.updateExerciseMappings(post3Varbit, 3);
				this.updateExerciseMappings(post4Varbit, 4);
				this.initialRun = false;
			}
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.MACRO_DRILLDEMON)
		{
			log.debug("Drill Demon NPC despawned, resetting exercise mats and mappings.");
			this.exerciseMatsAnswerList.clear();
			this.exerciseMatsMultimap.clear();
			this.exerciseVarbitMatMultimap.clear();
			this.initialRun = true;
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		switch (varbitChanged.getVarbitId())
		{
			case VarbitID.MACRO_DRILLDEMON_POST_1:
				this.updateExerciseMappings(varbitChanged.getValue(), 1);
				break;
			case VarbitID.MACRO_DRILLDEMON_POST_2:
				this.updateExerciseMappings(varbitChanged.getValue(), 2);
				break;
			case VarbitID.MACRO_DRILLDEMON_POST_3:
				this.updateExerciseMappings(varbitChanged.getValue(), 3);
				break;
			case VarbitID.MACRO_DRILLDEMON_POST_4:
				this.updateExerciseMappings(varbitChanged.getValue(), 4);
				break;
			default:
				break;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		String sanitizedChatMessage = Text.sanitizeMultilineText(chatMessage.getMessage());
		if (chatMessage.getType() == ChatMessageType.DIALOG)
		{
			if (this.isInDrillDemonLocalInstance())
			{
				this.exerciseMatsAnswerList.clear();
				DrillExercise exercise = DrillExercise.getExerciseFromText(sanitizedChatMessage);
				if (exercise != null)
				{
					log.debug("Drill Demon requested exercise: {}", exercise.name());
					this.exerciseMatsAnswerList = Lists.newArrayList(this.exerciseVarbitMatMultimap.get(exercise.getVarbitValue()));
					log.debug("Drill Demon exercise mats list set to: {}", this.exerciseMatsAnswerList);
				}
				else
				{
					if (sanitizedChatMessage.endsWith("Private! Follow my orders and you may, just may, leave here in a fit state for my corps!"))
					{
						return;
					}
					log.warn("Drill Demon requested unknown exercise: {}", sanitizedChatMessage);
					this.exerciseMatsAnswerList.clear();
				}
			}
		}
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned groundObjectSpawned)
	{
		if (this.isInDrillDemonLocalInstance())
		{
			switch (groundObjectSpawned.getGroundObject().getId())
			{
				case ObjectID.BARRACK_MAT_1:
					exerciseMatsMultimap.put(1, groundObjectSpawned.getGroundObject());
					log.debug("Added exercise mat with ID {} to post 1", groundObjectSpawned.getGroundObject().getId());
					break;
				case ObjectID.BARRACK_MAT_2:
					exerciseMatsMultimap.put(2, groundObjectSpawned.getGroundObject());
					log.debug("Added exercise mat with ID {} to post 2", groundObjectSpawned.getGroundObject().getId());
					break;
				case ObjectID.BARRACK_MAT_3:
					exerciseMatsMultimap.put(3, groundObjectSpawned.getGroundObject());
					log.debug("Added exercise mat with ID {} to post 3", groundObjectSpawned.getGroundObject().getId());
					break;
				case ObjectID.BARRACK_MAT_4:
					exerciseMatsMultimap.put(4, groundObjectSpawned.getGroundObject());
					log.debug("Added exercise mat with ID {} to post 4", groundObjectSpawned.getGroundObject().getId());
					break;
				default:
					break;
			}
		}
	}

	private void updateExerciseMappings(int exerciseVarbitValue, int postNumber)
	{
		DrillExercise exercise = DrillExercise.VARBIT_TO_EXERCISE_MAP.get(exerciseVarbitValue);
		if (exercise != null)
		{
			log.debug("Drill Demon exercise of Post_{} changed to: {} ({})", postNumber, exercise.getVarbitValue(), exercise.name());
			this.exerciseVarbitMatMultimap.replaceValues(exerciseVarbitValue, this.exerciseMatsMultimap.get(postNumber));
		}
		else
		{
			log.warn("Drill Demon exercise varbit changed to unknown value: {}", exerciseVarbitValue);
			this.exerciseVarbitMatMultimap.replaceValues(exerciseVarbitValue, ImmutableSet.of());
		}
	}

	private boolean isInDrillDemonLocalInstance()
	{
		return RandomEventHelperPlugin.getRegionIDFromCurrentLocalPointInstanced(client) == 12619;
	}
}

package randomeventhelper.randomevents.drilldemon;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.geom.Area;
import java.util.Objects;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GroundObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class DrillDemonOverlay extends Overlay
{
	private final Client client;
	private final DrillDemonHelper plugin;

	@Inject
	public DrillDemonOverlay(Client client, DrillDemonHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getExerciseMatsAnswerList() != null && !plugin.getExerciseMatsAnswerList().isEmpty())
		{
			// Get the non-null ground objects, map it to their convex hulls, and then combine them into a single shape
			Area combinedMatHull = new Area();
			plugin.getExerciseMatsAnswerList().stream().filter(Objects::nonNull).map(GroundObject::getConvexHull).forEach(hull -> combinedMatHull.add(new Area(hull)));
			for (GroundObject exerciseGroundObject : plugin.getExerciseMatsAnswerList())
			{
				if (exerciseGroundObject != null)
				{
					OverlayUtil.renderPolygon(graphics2D, combinedMatHull, Color.GREEN);
				}
			}
		}
		return null;
	}
}

package randomeventhelper.randomevents.surpriseexam;

import com.google.common.collect.ImmutableMap;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum RandomEventItem
{
	AIR_RUNE(41168),
	SQUARE_SHIELD_1(41188),
	APRON(41190),
	ARROWS(41177),
	BATTLE_AXE(41176),
	BANANA(41222),
	TUNA(41209),
	BEER(41152),
	GRAPES(41207),
	RUNE_OR_ESSENCE(41182),
	BOOK(41181),
	BREAD(41172),
	CAKE(41202),
	CANDLE_ON_STAND(27102),
	CHEESE(41161),
	CHEFS_HAT(41203),
	COCKTAIL_SHAKER(27096),
	TROUT_COD_PIKE_SALMON_1(41204),
	CROSSBOW(41146),
	CUP_OF_TEA(41162),
	BOTTLE(41175),
	EARTH_RUNE(41157),
	EYE_PATCH(41165),
	FEATHER(41224),
	FIRE_RUNE(41215),
	FROG_MASK(27101),
	COCKTAIL_1(27097),
	FULL_HELM(41178),
	ONION(41226),
	GEM_WITH_CROSS(41151),
	GIN_OR_RUM(41219),
	HAMMER(41183),
	HARPOON(41158),
	AXE(41184),
	HERRING_OR_MACKEREL(41193),
	HIGHWAYMAN_MASK(41195),
	JESTER_HAT(41196),
	JUG(41225),
	KITESHIELD(41200),
	CANDLE_LANTERN(41229),
	LEDERHOSEN_HAT(41164),
	CAPE_OF_LEGENDS(41167),
	LOGS(41232),
	LONGBOW(41198),
	LONGSWORD(41150),
	MACE(41211),
	MED_HELM(41189),
	BAR(41153),
	MIME_MASK(41191),
	NECKLACE(41216),
	NEEDLE(41199),
	ORE(41170),
	PICKAXE(41194),
	PIE(41205),
	TROUT_COD_PIKE_SALMON_2(41206),
	PINEAPPLE(41214),
	PIRATE_BOOTS(41186),
	PIRATE_HAT(41187),
	PIRATE_HOOK(41228),
	PIZZA(41185),
	PLANT_POT(41208),
	PLATELEGS(41179),
	POT(41223),
	RAKE(41212),
	LEATHER_BOOTS(41220),
	RING(27091),
	WOODEN_SHIELD(41221),
	PLATEBODY(27094),
	TROUT_COD_PIKE_SALMON_3(41163),
	HOLY_SYMBOL(41159),
	FISH(41173),
	SCIMITAR(41192),
	SECATEURS(41197),
	COCKTAIL_2(28421),
	SHARK(41166),
	SHEARS(41227),
	SHORT_BOW(41171),
	SHRIMP(41147),
	INSULATED_BOOTS(27104),
	FIGHTER_BOOTS(41160),
	SPADE(41155),
	SQUARE_SHIELD_2(41169),
	STAFF(41174),
	STRAWBERRY(41230),
	KITCHEN_KNIFE(41201),
	THREAD(41218),
	TIARA(41148),
	TINDERBOX(41154),
	TROUT_COD_PIKE_SALMON_4(41217),
	GARDENING_TROWEL(41210),
	BASS(41180),
	POTION(41149),
	WATERING_CAN(41213),
	WATERMELON_SLICE(41156),
	WATER_RUNE(41231),
	BONES(2674),
	KEY(29232);

	private final int modelID;

	public static RandomEventItem fromModelID(int modelID)
	{
		return ITEM_MODEL_ID_MAP.get(modelID);
	}

	private static final Map<Integer, RandomEventItem> ITEM_MODEL_ID_MAP;

	static
	{
		ImmutableMap.Builder<Integer, RandomEventItem> itemModelIDBuilder = new ImmutableMap.Builder<>();

		for (RandomEventItem randomEventItem : values())
		{
			itemModelIDBuilder.put(randomEventItem.getModelID(), randomEventItem);
		}

		ITEM_MODEL_ID_MAP = itemModelIDBuilder.build();
	}

	@Override
	public String toString()
	{
		return this.name() + " ("+ modelID + ")";
	}
}

package randomeventhelper.randomevents.surpriseexam;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Multimap;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@Singleton
public class SurpriseExamHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private SurpriseExamOverlay overlay;

	private String patternCardHint;

	@Getter
	private ImmutableSet<RandomEventItem> patternCardAnswers;

	@Getter
	private ImmutableSet<Widget> patternCardAnswerWidgets;

	@Getter
	private RandomEventItem patternNextAnswer;

	@Getter
	private Widget patternNextAnswerWidget;

	private OSRSItemRelationshipSystem relationshipSystem;

	private static final int[] PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_MODELS = {
		InterfaceID.PatternCards.CARD_0,
		InterfaceID.PatternCards.CARD_1,
		InterfaceID.PatternCards.CARD_2,
		InterfaceID.PatternCards.CARD_3,
		InterfaceID.PatternCards.CARD_4,
		InterfaceID.PatternCards.CARD_5,
		InterfaceID.PatternCards.CARD_6,
		InterfaceID.PatternCards.CARD_7,
		InterfaceID.PatternCards.CARD_8,
		InterfaceID.PatternCards.CARD_9,
		InterfaceID.PatternCards.CARD_10,
		InterfaceID.PatternCards.CARD_11,
		InterfaceID.PatternCards.CARD_12,
		InterfaceID.PatternCards.CARD_13,
		InterfaceID.PatternCards.CARD_14
	};

	private static final int[] PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_SELECTS = {
		InterfaceID.PatternCards.SELECT_0,
		InterfaceID.PatternCards.SELECT_1,
		InterfaceID.PatternCards.SELECT_2,
		InterfaceID.PatternCards.SELECT_3,
		InterfaceID.PatternCards.SELECT_4,
		InterfaceID.PatternCards.SELECT_5,
		InterfaceID.PatternCards.SELECT_6,
		InterfaceID.PatternCards.SELECT_7,
		InterfaceID.PatternCards.SELECT_8,
		InterfaceID.PatternCards.SELECT_9,
		InterfaceID.PatternCards.SELECT_10,
		InterfaceID.PatternCards.SELECT_11,
		InterfaceID.PatternCards.SELECT_12,
		InterfaceID.PatternCards.SELECT_13,
		InterfaceID.PatternCards.SELECT_14
	};

	private static final int[] PATTERNNEXT_INTERFACEIDS_INITIAL_PATTERN = {
		InterfaceID.PatternNext._0,
		InterfaceID.PatternNext._1,
		InterfaceID.PatternNext._2
	};

	private static final int[] PATTERNNEXT_INTERFACEIDS_CHOICES = {
		InterfaceID.PatternNext.SELECT_0,
		InterfaceID.PatternNext.SELECT_1,
		InterfaceID.PatternNext.SELECT_2,
		InterfaceID.PatternNext.SELECT_3
	};

	public void startUp()
	{
		this.eventBus.register(this);
		this.overlayManager.add(overlay);
		this.patternCardHint = null;
		this.patternCardAnswers = null;
		this.patternCardAnswerWidgets = null;
		this.patternNextAnswer = null;
		this.patternNextAnswerWidget = null;
		this.relationshipSystem = new OSRSItemRelationshipSystem();
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		this.overlayManager.remove(overlay);
		this.patternCardHint = null;
		this.patternCardAnswers = null;
		this.patternCardAnswerWidgets = null;
		this.patternNextAnswer = null;
		this.patternNextAnswerWidget = null;
		this.relationshipSystem = null;
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded widgetLoaded)
	{
		if (widgetLoaded.getGroupId() == InterfaceID.PATTERN_CARDS)
		{
			this.clientThread.invokeLater(() -> {
				Widget examHintWidget = this.client.getWidget(InterfaceID.PatternCards.HINT);
				if (examHintWidget != null)
				{
					this.patternCardHint = examHintWidget.getText();
					log.debug("Exam hint widget loaded with text: {}", this.patternCardHint);
					if (this.patternCardHint != null && !this.patternCardHint.isEmpty())
					{
						log.debug("Exam available pattern card items: {}", this.getPatternCardMap().values().asList());
						List<RandomEventItem> answerItems = this.relationshipSystem.findItemsByHint(this.patternCardHint, this.getPatternCardMap().values().asList(), 3);
						log.debug("Found answer items for exam hint '{}': {}", this.patternCardHint, answerItems);
						if (answerItems.size() >= 3)
						{
							this.patternCardAnswers = ImmutableSet.copyOf(answerItems);
							this.patternCardAnswerWidgets = answerItems.subList(0, 3).stream()
								.map(item -> {
									Integer interfaceID = this.getKeyForValue(this.getPatternCardMap(), item);
									if (interfaceID == null)
									{
										log.warn("No interface ID found for item: {}", item);
										return null;
									}
									Widget interfaceWidget = this.client.getWidget(interfaceID);
									return interfaceWidget != null ? this.getPatternCardSelectionWidgetFromModel(interfaceWidget) : null;
								})
								.filter(Objects::nonNull)
								.collect(ImmutableSet.toImmutableSet());
							log.debug("Pattern card answers set to: {}", this.patternCardAnswers);
						}
						else
						{
							log.warn("Found {} items for exam hint '{}', expected 3.", answerItems.size(), this.patternCardHint);
							this.patternCardAnswers = null;
							this.patternCardAnswerWidgets = null;
						}
					}
					else
					{
						log.warn("Exam hint widget text is empty or null.");
						this.patternCardHint = null;
						this.patternCardAnswers = null;
						this.patternCardAnswerWidgets = null;
					}
				}
			});
		}

		if (widgetLoaded.getGroupId() == InterfaceID.PATTERN_NEXT)
		{
			this.clientThread.invokeLater(() -> {
				Widget whatsNextTextWidget = this.client.getWidget(InterfaceID.PatternNext.UNIVERSE_TEXT12);
				if (whatsNextTextWidget != null)
				{
					String whatsNextText = whatsNextTextWidget.getText();
					log.debug("What's next widget text loaded: {}", whatsNextText);
					if (whatsNextText != null && !whatsNextText.isEmpty())
					{
						List<RandomEventItem> initialSelectionItems = this.getPatternNextInitialSelectionMap().values().asList();
						List<RandomEventItem> choicesItems = this.getPatternNextChoicesMap().values().asList();
						log.debug("Exam next initial selection items: {}", initialSelectionItems);
						log.debug("Exam next choice items: {}", choicesItems);
						RandomEventItem answerItem = this.relationshipSystem.findMissingItem(initialSelectionItems, choicesItems);
						if (answerItem != null)
						{
							this.patternNextAnswer = answerItem;
							Integer interfaceID = getKeyForValue(this.getPatternNextChoicesMap(), answerItem);
							this.patternNextAnswerWidget = interfaceID != null ? this.client.getWidget(interfaceID) : null;
							log.debug("Pattern next answer set to: {}", this.patternNextAnswer);
						}
						else
						{
							log.warn("No valid answer found for what's next text '{}'.", whatsNextText);
							this.patternNextAnswer = null;
							this.patternNextAnswerWidget = null;
						}
					}
					else
					{
						log.warn("Next hint widget text is empty or null.");
						this.patternNextAnswer = null;
						this.patternNextAnswerWidget = null;
					}
				}
			});
		}
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed widgetClosed)
	{
		if (widgetClosed.getGroupId() == InterfaceID.PATTERN_CARDS)
		{
			log.debug("Pattern cards widget closed, resetting pattern card answers.");
			this.patternCardHint = null;
			this.patternCardAnswers = null;
			this.patternCardAnswerWidgets = null;
		}

		if (widgetClosed.getGroupId() == InterfaceID.PATTERN_NEXT)
		{
			log.debug("Pattern next widget closed, resetting pattern next answer.");
			this.patternNextAnswer = null;
			this.patternNextAnswerWidget = null;
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (npcDespawned.getNpc().getId() == NpcID.PATTERN_TEACHER)
		{
			log.debug("Mr. Mordaut NPC despawned, resetting all answers.");
			this.patternCardHint = null;
			this.patternCardAnswers = null;
			this.patternCardAnswerWidgets = null;
			this.patternNextAnswer = null;
			this.patternNextAnswerWidget = null;
		}
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted executedCommand)
	{
		if (executedCommand.getCommand().equalsIgnoreCase("exportexampuzzle"))
		{
			StringBuilder sb = new StringBuilder();
			sb.append("Pattern Card Matching Hint: ");
			sb.append(this.patternCardHint != null ? this.patternCardHint : "NULL");
			sb.append("\n");
			sb.append("Pattern Card Matching Available Items: ");
			sb.append(this.getPatternCardMap() != null ? this.getPatternCardMap().values().asList().toString() : "NULL");
			sb.append("\n");
			sb.append("Pattern Card Matching Calculated Answers: ");
			sb.append(this.patternCardAnswers != null ? this.patternCardAnswers.toString() : "NULL");
			sb.append("\n");
			sb.append("Pattern Next Item Initial Items: ");
			sb.append(this.getPatternNextInitialSelectionMap() != null ? this.getPatternNextInitialSelectionMap().values().asList().toString() : "NULL");
			sb.append("\n");
			sb.append("Pattern Next Item Choices: ");
			sb.append(this.getPatternNextChoicesMap() != null ? this.getPatternNextChoicesMap().values().asList().toString() : "NULL");
			sb.append("\n");
			sb.append("Pattern Next Item Calculated Answer: ");
			sb.append(this.patternNextAnswer != null ? this.patternNextAnswer.toString() : "NULL");
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(new StringSelection(sb.toString()), null);
			log.info(sb.toString());
		}
	}

	private ImmutableMultimap<Integer, RandomEventItem> getPatternCardMap()
	{
		ImmutableMultimap.Builder<Integer, RandomEventItem> builder = ImmutableMultimap.builder();
		for (int patternCardSelectionInterfaceID : PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_MODELS)
		{
			if (this.client.getWidget(InterfaceID.PatternCards.HINT) == null)
			{
				log.warn("Widget for matching pattern puzzle hint is null");
				return null;
			}
			int modelID = Objects.requireNonNull(this.client.getWidget(patternCardSelectionInterfaceID)).getModelId();
			RandomEventItem randomEventItem = RandomEventItem.fromModelID(modelID);
			if (randomEventItem == null)
			{
				log.warn("No RandomEventItem found for model ID: {}", modelID);
				continue;
			}
			builder.put(patternCardSelectionInterfaceID, randomEventItem);
		}
		return builder.build();
	}

	private ImmutableMap<Integer, RandomEventItem> getPatternNextInitialSelectionMap()
	{
		ImmutableMap.Builder<Integer, RandomEventItem> builder = ImmutableMap.builder();
		for (int patternNextInitialPatternInterfaceID : PATTERNNEXT_INTERFACEIDS_INITIAL_PATTERN)
		{
			if (this.client.getWidget(InterfaceID.PatternNext.UNIVERSE_TEXT12) == null)
			{
				log.warn("Widget for next missing item puzzle text is null");
				return null;
			}
			int modelID = Objects.requireNonNull(this.client.getWidget(patternNextInitialPatternInterfaceID)).getModelId();
			RandomEventItem randomEventItem = RandomEventItem.fromModelID(modelID);
			if (randomEventItem == null)
			{
				log.warn("No RandomEventItem found for model ID: {}", modelID);
				continue;
			}
			builder.put(patternNextInitialPatternInterfaceID, randomEventItem);
		}
		return builder.build();
	}

	private ImmutableMultimap<Integer, RandomEventItem> getPatternNextChoicesMap()
	{
		ImmutableMultimap.Builder<Integer, RandomEventItem> builder = ImmutableMultimap.builder();
		for (int patternNextChoiceInterfaceID : PATTERNNEXT_INTERFACEIDS_CHOICES)
		{
			if (this.client.getWidget(InterfaceID.PatternNext.UNIVERSE_TEXT12) == null)
			{
				log.warn("Widget for next missing item puzzle text is null");
				return null;
			}
			int modelID = Objects.requireNonNull(this.client.getWidget(patternNextChoiceInterfaceID)).getModelId();
			RandomEventItem randomEventItem = RandomEventItem.fromModelID(modelID);
			if (randomEventItem == null)
			{
				log.warn("No RandomEventItem found for model ID: {}", modelID);
				continue;
			}
			builder.put(patternNextChoiceInterfaceID, randomEventItem);
		}
		return builder.build();
	}

	private Integer getKeyForValue(Multimap<Integer, RandomEventItem> map, RandomEventItem value)
	{
		for (Map.Entry<Integer, RandomEventItem> entry : map.entries())
		{
			if (entry.getValue().equals(value))
			{
				return entry.getKey();
			}
		}
		return null;
	}

	public Widget getPatternCardSelectionWidgetFromModel(Widget modelWidget)
	{
		// This method retrieves the widget for the pattern card selection based on the model widget.
		// PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_MODELS[i] = PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_SELECTS[i]
		// So if modelWidget corresponds to PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_MODELS[i] then it should return PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_SELECTS[i]
		for (int i = 0; i < PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_MODELS.length; i++)
		{
			if (modelWidget.getId() == PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_MODELS[i])
			{
				return this.client.getWidget(PATTERNCARDS_INTERFACEIDS_AVAILABLE_CARD_SELECTS[i]);
			}
		}
		log.warn("No matching selection widget found for model widget ID: {}", modelWidget.getId());
		return null;
	}
}

package randomeventhelper.randomevents.surpriseexam;

public enum RelationshipType
{
	// Production chains
	COMBAT_ECOSYSTEM("combat, prayer, bones, weapons, battle, fighting"),
	FISHING_TO_COOKING("fishing, cooking, harpoon, fish, tuna, shark, food"),
	MINING_SMITHING_CRAFTING("mining, smithing, crafting, pickaxe, ore, bar, hammer"),
	WOODCUTTING_FLETCHING("woodcutting, fletching, axe, logs, bow, arrows, feather"),
	FARMING_ECOSYSTEM("farming, agriculture, rake, seeds, crops, harvest, plants"),
	COOKING_PRODUCTION("cooking, food, chef, kitchen, bread, cake, meals"),
	ALCOHOL_PRODUCTION("alcohol, brewing, cocktail, beer, rum, gin, drinks"),
	MAGIC_RUNECRAFTING("magic, runecrafting, runes, essence, spells, staff, abracadabra, hocus pocus"),
	JEWELRY_CRAFTING("jewelry, gems, necklace, ring, crafting, status"),
	LIGHT_FIRE_SYSTEM("fire, light, candle, lantern, tinderbox, illumination"),
	CONTAINER_STORAGE("container, storage, bottle, jug, pot, holding"),

	// Thematic groups
	PIRATE_THEME("pirate, sea, nautical, hook, eyepatch, boots, hat, yarr, crime, strange"),
	ENTERTAINMENT_THEME("entertainment, performance, jester, mime, mask, fun, clown, fool, mask, face, strange"),
	PROFESSIONAL_THEME("profession, work, chef, trade, job, occupation"),

	// Equipment categories
	MELEE_WEAPONS("melee, sword, axe, mace, scimitar, close, combat, sharp"),
	RANGED_WEAPONS("ranged, bow, crossbow, arrows, ammunition, distance, sharp"),
	MAGIC_RUNES("runes, elemental, air, earth, fire, water, magic, abracadabra, hocus pocus"),
	HEAD_ARMOR("head, helmet, hat, protection, headwear, skull, mask, headgear"),
	BODY_ARMOR("body, chest, torso, platebody, apron, protection"),
	LEG_ARMOR("legs, platelegs, protection, lower, body"),
	FOOT_ARMOR("feet, boots, footwear, walking, protection"),
	SHIELDS("shield, defense, blocking, protection, guard"),
	MELEE_GEAR("melee, sword, scimitar, axe, mace, combat, sharp, helmet, platebody, platelegs, shield"),
	JEWELRY_ACCESSORIES("jewelry, accessories, necklace, ring, cape, status"),
	FACE_ACCESSORIES("face, mask, eyepatch, hook, covering, facial"),

	// Skill-based groupings
	ALL_SKILLING_TOOLS("tools, skills, gathering, resources, equipment, utility"),
	MINING_TOOLS("mining, pickaxe, ore, rocks, gems, underground"),
	FISHING_TOOLS("fishing, harpoon, fish, water, catching, sea, sea food"),
	FARMING_TOOLS("farming, gardening, rake, spade, plants, agriculture"),
	CRAFTING_TOOLS("crafting, needle, thread, making, creating, tailoring"),

	// Food categories
	FISH("fish, raw, uncooked, sea, food, sea food, seafood, fishing, water"),
	FRUITS("fruits, berries, fresh, healthy, vitamins, nature"),
	BAKING_FOOD("cooked, food, meals, prepared, baked, ready"),
	ALCOHOLIC_DRINKS("alcohol, drinks, beer, spirits, intoxicating, beverages"),

	// Functional groupings
	COMBAT_CONSUMABLES("combat, consumable, potion, bones, prayer, aid"),
	LIGHT_SOURCES("light, illumination, candle, lantern, brightness, glow"),
	RESOURCE_MATERIALS("resources, materials, raw, crafting, essence, components");

	private final String keywords;

	RelationshipType(String keywords)
	{
		this.keywords = keywords;
	}

	public String getKeywords()
	{
		return keywords;
	}

	public String[] getKeywordArray()
	{
		return keywords.split(", ");
	}
}

package randomeventhelper.randomevents.surpriseexam;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.text.similarity.JaroWinklerDistance;

/**
 * Comprehensive OSRS Item Relationship System
 * Supports both hint-based selection and missing item detection
 */
@Slf4j
@Singleton
public class OSRSItemRelationshipSystem
{
	// Relationship mappings and similarity calculators
	private final Map<RelationshipType, Set<RandomEventItem>> relationships;
	private final JaroWinklerDistance jaroWinklerDistance;

	// Similarity thresholds
	private static final double EXACT_MATCH_THRESHOLD = 1.0;
	private static final double HIGH_SIMILARITY_THRESHOLD = 0.75;
	private static final double MEDIUM_SIMILARITY_THRESHOLD = 0.5;
	private static final double LOW_SIMILARITY_THRESHOLD = 0.25;

	// Riddle analysis patterns and keywords
	private final Set<String> STOP_WORDS = Set.of(
		"the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by",
		"i", "you", "he", "she", "it", "we", "they", "am", "is", "are", "was", "were", "be", "been", "being",
		"have", "has", "had", "do", "does", "did", "will", "would", "could", "should", "may", "might", "can",
		"like", "feel", "against", "than", "take", "get", "go", "come", "see", "know", "think", "say", "tell",
		"as", "pattern", "relation", "relationship", "item", "items", "match", "find", "solve", "answer", "question",
		"answers", "puzzle", "riddle", "clue", "hint"
	);

	// Context clues that might indicate certain themes (but don't hard-code specific riddles)
	private final Map<String, Set<String>> CONTEXT_CLUES = Map.ofEntries(
		Map.entry("water", Set.of("fishing", "fish", "seafood", "ocean", "sea")),
		Map.entry("sea", Set.of("fishing", "fish", "pirate", "nautical", "ocean")),
		Map.entry("dragon", Set.of("combat", "weapon", "battle", "fighting")),
		Map.entry("sword", Set.of("melee", "weapon", "combat", "blade")),
		Map.entry("bow", Set.of("range", "weapon", "arrow", "ammunition")),
		Map.entry("spell", Set.of("magic", "runes", "staff", "runecrafting")),
		Map.entry("food", Set.of("cooking", "chef", "meal", "kitchen")),
		Map.entry("grow", Set.of("farming", "plants", "crops", "agriculture")),
		Map.entry("mine", Set.of("mining", "pickaxe", "ore", "rocks")),
		Map.entry("protection", Set.of("armor", "helmet", "shield", "defense")),
		Map.entry("drink", Set.of("alcohol", "beverage", "beer", "cocktail")),
		Map.entry("light", Set.of("fire", "candle", "lantern", "tinder", "illuminate")),
		Map.entry("jewel", Set.of("jewelry", "gem", "necklace", "ring", "crafting", "amulet")),
		Map.entry("pirate", Set.of("sea", "yarr", "piracy", "treasure", "chest", "loot", "gold", "crime")),
		Map.entry("mask", Set.of("hide", "face", "disguise", "theft", "rob", "crime", "unrecognizable", "undercover", "conceal"))
	);

	// Synonym mapping for better word matching
	private final Map<String, Set<String>> SYNONYMS = Map.of(
		"weapon", Set.of("sword", "axe", "mace", "bow", "staff", "blade", "arm", "armament"),
		"fish", Set.of("seafood", "catch", "marine", "aquatic", "ocean", "sea"),
		"food", Set.of("meal", "dish", "cuisine", "edible", "consumable", "nourishment"),
		"armor", Set.of("protection", "gear", "equipment", "defense", "guard"),
		"magic", Set.of("spell", "enchantment", "sorcery", "wizardry", "mystical"),
		"pirate", Set.of("buccaneer", "seafarer", "mariner", "sailor", "nautical"),
		"drink", Set.of("beverage", "liquid", "fluid", "potion", "brew"),
		"tool", Set.of("equipment", "implement", "instrument", "utility", "gear"),
		"bow", Set.of("archery", "ranged", "range", "arrow", "archer", "crossbow")
	);

	public OSRSItemRelationshipSystem()
	{
		this.relationships = initializeRelationships();
		this.jaroWinklerDistance = new JaroWinklerDistance();
	}

	private Map<RelationshipType, Set<RandomEventItem>> initializeRelationships()
	{
		Map<RelationshipType, Set<RandomEventItem>> map = new EnumMap<>(RelationshipType.class);

		// Production chains
		map.put(RelationshipType.COMBAT_ECOSYSTEM, Set.of(
			RandomEventItem.BONES, RandomEventItem.BATTLE_AXE, RandomEventItem.LONGSWORD,
			RandomEventItem.MACE, RandomEventItem.SCIMITAR, RandomEventItem.CROSSBOW,
			RandomEventItem.LONGBOW, RandomEventItem.SHORT_BOW, RandomEventItem.ARROWS,
			RandomEventItem.STAFF, RandomEventItem.POTION
		));

		map.put(RelationshipType.FISHING_TO_COOKING, Set.of(
			RandomEventItem.HARPOON, RandomEventItem.TUNA, RandomEventItem.SHARK,
			RandomEventItem.BASS, RandomEventItem.TROUT_COD_PIKE_SALMON_1,
			RandomEventItem.TROUT_COD_PIKE_SALMON_2, RandomEventItem.TROUT_COD_PIKE_SALMON_3,
			RandomEventItem.TROUT_COD_PIKE_SALMON_4, RandomEventItem.HERRING_OR_MACKEREL,
			RandomEventItem.SHRIMP, RandomEventItem.FISH
		));

		map.put(RelationshipType.MINING_SMITHING_CRAFTING, Set.of(
			RandomEventItem.PICKAXE, RandomEventItem.ORE, RandomEventItem.BAR,
			RandomEventItem.GEM_WITH_CROSS, RandomEventItem.HAMMER
		));

		map.put(RelationshipType.WOODCUTTING_FLETCHING, Set.of(
			RandomEventItem.AXE, RandomEventItem.LOGS, RandomEventItem.LONGBOW,
			RandomEventItem.SHORT_BOW, RandomEventItem.ARROWS, RandomEventItem.FEATHER
		));

		map.put(RelationshipType.FARMING_ECOSYSTEM, Set.of(
			RandomEventItem.RAKE, RandomEventItem.GARDENING_TROWEL, RandomEventItem.WATERING_CAN,
			RandomEventItem.SECATEURS, RandomEventItem.SPADE, RandomEventItem.PLANT_POT,
			RandomEventItem.SHEARS, RandomEventItem.BANANA, RandomEventItem.GRAPES,
			RandomEventItem.PINEAPPLE, RandomEventItem.STRAWBERRY, RandomEventItem.WATERMELON_SLICE,
			RandomEventItem.ONION
		));

		map.put(RelationshipType.COOKING_PRODUCTION, Set.of(
			RandomEventItem.KITCHEN_KNIFE, RandomEventItem.POT, RandomEventItem.TUNA,
			RandomEventItem.BREAD, RandomEventItem.CAKE, RandomEventItem.CHEESE,
			RandomEventItem.PIE, RandomEventItem.PIZZA, RandomEventItem.BANANA,
			RandomEventItem.GRAPES, RandomEventItem.ONION, RandomEventItem.CHEFS_HAT,
			RandomEventItem.APRON
		));

		map.put(RelationshipType.ALCOHOL_PRODUCTION, Set.of(
			RandomEventItem.GRAPES, RandomEventItem.BEER, RandomEventItem.GIN_OR_RUM,
			RandomEventItem.COCKTAIL_1, RandomEventItem.COCKTAIL_2, RandomEventItem.COCKTAIL_SHAKER,
			RandomEventItem.BOTTLE, RandomEventItem.JUG
		));

		map.put(RelationshipType.MAGIC_RUNECRAFTING, Set.of(
			RandomEventItem.RUNE_OR_ESSENCE, RandomEventItem.AIR_RUNE, RandomEventItem.EARTH_RUNE,
			RandomEventItem.FIRE_RUNE, RandomEventItem.WATER_RUNE, RandomEventItem.STAFF,
			RandomEventItem.BOOK, RandomEventItem.TIARA
		));

		map.put(RelationshipType.JEWELRY_CRAFTING, Set.of(
			RandomEventItem.GEM_WITH_CROSS, RandomEventItem.NECKLACE, RandomEventItem.RING,
			RandomEventItem.HOLY_SYMBOL, RandomEventItem.CAPE_OF_LEGENDS, RandomEventItem.TIARA
		));

		map.put(RelationshipType.LIGHT_FIRE_SYSTEM, Set.of(
			RandomEventItem.TINDERBOX, RandomEventItem.CANDLE_ON_STAND, RandomEventItem.CANDLE_LANTERN,
			RandomEventItem.LOGS
		));

		map.put(RelationshipType.CONTAINER_STORAGE, Set.of(
			RandomEventItem.BOTTLE, RandomEventItem.JUG, RandomEventItem.POT,
			RandomEventItem.PLANT_POT, RandomEventItem.COCKTAIL_SHAKER
		));

		// Thematic groups
		map.put(RelationshipType.PIRATE_THEME, Set.of(
			RandomEventItem.PIRATE_HAT, RandomEventItem.PIRATE_BOOTS, RandomEventItem.PIRATE_HOOK,
			RandomEventItem.EYE_PATCH, RandomEventItem.KEY, RandomEventItem.HIGHWAYMAN_MASK
		));

		map.put(RelationshipType.ENTERTAINMENT_THEME, Set.of(
			RandomEventItem.JESTER_HAT, RandomEventItem.MIME_MASK, RandomEventItem.FROG_MASK, RandomEventItem.HIGHWAYMAN_MASK
		));

		map.put(RelationshipType.PROFESSIONAL_THEME, Set.of(
			RandomEventItem.CHEFS_HAT, RandomEventItem.APRON, RandomEventItem.LEDERHOSEN_HAT
		));

		// Equipment categories
		map.put(RelationshipType.MELEE_WEAPONS, Set.of(
			RandomEventItem.BATTLE_AXE, RandomEventItem.LONGSWORD, RandomEventItem.MACE,
			RandomEventItem.SCIMITAR
		));

		map.put(RelationshipType.RANGED_WEAPONS, Set.of(
			RandomEventItem.CROSSBOW, RandomEventItem.LONGBOW, RandomEventItem.SHORT_BOW,
			RandomEventItem.ARROWS
		));

		map.put(RelationshipType.MAGIC_RUNES, Set.of(
			RandomEventItem.AIR_RUNE, RandomEventItem.EARTH_RUNE, RandomEventItem.FIRE_RUNE,
			RandomEventItem.WATER_RUNE
		));

		map.put(RelationshipType.HEAD_ARMOR, Set.of(
			RandomEventItem.FULL_HELM, RandomEventItem.MED_HELM, RandomEventItem.CHEFS_HAT,
			RandomEventItem.PIRATE_HAT, RandomEventItem.JESTER_HAT, RandomEventItem.LEDERHOSEN_HAT,
			RandomEventItem.TIARA, RandomEventItem.HIGHWAYMAN_MASK, RandomEventItem.MIME_MASK, RandomEventItem.FROG_MASK
		));

		map.put(RelationshipType.BODY_ARMOR, Set.of(
			RandomEventItem.PLATEBODY, RandomEventItem.APRON
		));

		map.put(RelationshipType.LEG_ARMOR, Set.of(
			RandomEventItem.PLATELEGS
		));

		map.put(RelationshipType.FOOT_ARMOR, Set.of(
			RandomEventItem.INSULATED_BOOTS, RandomEventItem.PIRATE_BOOTS, RandomEventItem.LEATHER_BOOTS,
			RandomEventItem.FIGHTER_BOOTS
		));

		map.put(RelationshipType.SHIELDS, Set.of(
			RandomEventItem.SQUARE_SHIELD_1, RandomEventItem.SQUARE_SHIELD_2,
			RandomEventItem.KITESHIELD, RandomEventItem.WOODEN_SHIELD
		));

		map.put(RelationshipType.MELEE_GEAR, Set.of(
			RandomEventItem.BATTLE_AXE, RandomEventItem.LONGSWORD, RandomEventItem.MACE,
			RandomEventItem.SCIMITAR, RandomEventItem.FULL_HELM, RandomEventItem.MED_HELM, RandomEventItem.PLATEBODY,
			RandomEventItem.PLATELEGS, RandomEventItem.SQUARE_SHIELD_1, RandomEventItem.SQUARE_SHIELD_2,
			RandomEventItem.KITESHIELD, RandomEventItem.WOODEN_SHIELD
		));

		map.put(RelationshipType.JEWELRY_ACCESSORIES, Set.of(
			RandomEventItem.NECKLACE, RandomEventItem.RING, RandomEventItem.HOLY_SYMBOL,
			RandomEventItem.CAPE_OF_LEGENDS
		));

		map.put(RelationshipType.FACE_ACCESSORIES, Set.of(
			RandomEventItem.EYE_PATCH, RandomEventItem.FROG_MASK, RandomEventItem.HIGHWAYMAN_MASK,
			RandomEventItem.MIME_MASK, RandomEventItem.PIRATE_HOOK
		));

		// Skill-based groupings
		map.put(RelationshipType.ALL_SKILLING_TOOLS, Set.of(
			RandomEventItem.PICKAXE, RandomEventItem.AXE, RandomEventItem.HARPOON,
			RandomEventItem.NEEDLE, RandomEventItem.THREAD, RandomEventItem.HAMMER,
			RandomEventItem.TINDERBOX, RandomEventItem.RAKE, RandomEventItem.SECATEURS,
			RandomEventItem.SHEARS, RandomEventItem.GARDENING_TROWEL, RandomEventItem.SPADE,
			RandomEventItem.WATERING_CAN, RandomEventItem.KITCHEN_KNIFE
		));

		map.put(RelationshipType.MINING_TOOLS, Set.of(
			RandomEventItem.PICKAXE, RandomEventItem.ORE, RandomEventItem.BAR,
			RandomEventItem.GEM_WITH_CROSS
		));

		map.put(RelationshipType.FISHING_TOOLS, Set.of(
			RandomEventItem.HARPOON, RandomEventItem.TUNA, RandomEventItem.SHARK,
			RandomEventItem.BASS, RandomEventItem.SHRIMP
		));

		map.put(RelationshipType.FARMING_TOOLS, Set.of(
			RandomEventItem.RAKE, RandomEventItem.SECATEURS, RandomEventItem.SHEARS,
			RandomEventItem.GARDENING_TROWEL, RandomEventItem.SPADE, RandomEventItem.WATERING_CAN,
			RandomEventItem.PLANT_POT
		));

		map.put(RelationshipType.CRAFTING_TOOLS, Set.of(
			RandomEventItem.NEEDLE, RandomEventItem.THREAD, RandomEventItem.HAMMER
		));

		// Food categories
		map.put(RelationshipType.FISH, Set.of(
			RandomEventItem.TUNA, RandomEventItem.TROUT_COD_PIKE_SALMON_1,
			RandomEventItem.TROUT_COD_PIKE_SALMON_2, RandomEventItem.TROUT_COD_PIKE_SALMON_3,
			RandomEventItem.TROUT_COD_PIKE_SALMON_4, RandomEventItem.HERRING_OR_MACKEREL,
			RandomEventItem.SHARK, RandomEventItem.SHRIMP, RandomEventItem.BASS, RandomEventItem.FISH
		));

		map.put(RelationshipType.FRUITS, Set.of(
			RandomEventItem.BANANA, RandomEventItem.GRAPES, RandomEventItem.PINEAPPLE,
			RandomEventItem.STRAWBERRY, RandomEventItem.WATERMELON_SLICE
		));

		map.put(RelationshipType.BAKING_FOOD, Set.of(
			RandomEventItem.BREAD, RandomEventItem.CAKE, RandomEventItem.CHEESE,
			RandomEventItem.PIE, RandomEventItem.PIZZA
		));

		map.put(RelationshipType.ALCOHOLIC_DRINKS, Set.of(
			RandomEventItem.BEER, RandomEventItem.GIN_OR_RUM, RandomEventItem.COCKTAIL_1,
			RandomEventItem.COCKTAIL_2
		));

		// Functional groupings
		map.put(RelationshipType.COMBAT_CONSUMABLES, Set.of(
			RandomEventItem.BONES, RandomEventItem.POTION
		));

		map.put(RelationshipType.LIGHT_SOURCES, Set.of(
			RandomEventItem.CANDLE_ON_STAND, RandomEventItem.CANDLE_LANTERN
		));

		map.put(RelationshipType.RESOURCE_MATERIALS, Set.of(
			RandomEventItem.RUNE_OR_ESSENCE, RandomEventItem.ORE, RandomEventItem.LOGS,
			RandomEventItem.FEATHER, RandomEventItem.THREAD
		));

		return map;
	}

	/**
	 * Problem 1: Given a riddle/hint and list of items, find items that match the relationship
	 * Analyzes riddles using pattern matching, keyword extraction, and similarity scoring
	 *
	 * @param riddle         The relationship riddle/hint
	 * @param availableItems List of 15 items to choose from
	 * @param minItems       Minimum number of items to select (default 3)
	 * @return List of items that match the riddle, sorted by relevance
	 */
	public List<RandomEventItem> findItemsByHint(String riddle, List<RandomEventItem> availableItems, int minItems)
	{
		return analyzeRiddleAndFindItems(riddle, availableItems, minItems);
	}

	/**
	 * Problem 2: Given 3 items, find the 4th item that completes the relationship
	 *
	 * @param knownItems The 3 known items
	 * @param candidates The 4 potential answers
	 * @return The item that best completes the relationship, or null if none found
	 */
	public RandomEventItem findMissingItem(List<RandomEventItem> knownItems, List<RandomEventItem> candidates)
	{
		if (knownItems.size() != 3)
		{
			throw new IllegalArgumentException("Expected exactly 3 known items");
		}

		// Try each candidate and see which one creates the best relationship
		for (RandomEventItem candidate : candidates)
		{
			List<RandomEventItem> testGroup = new ArrayList<>(knownItems);
			testGroup.add(candidate);

			// Check if this combination matches any relationship
			for (Map.Entry<RelationshipType, Set<RandomEventItem>> entry : relationships.entrySet())
			{
				Set<RandomEventItem> relationshipItems = entry.getValue();

				// Count how many items from our test group are in this relationship
				long matches = testGroup.stream()
					.filter(relationshipItems::contains)
					.count();

				// If all 4 items are in the relationship, this is likely the answer
				if (matches == 4)
				{
					return candidate;
				}
			}
		}

		// If no perfect match, try partial matching
		return findMissingItemByPartialMatch(knownItems, candidates);
	}

	/**
	 * Get all relationships that contain a specific item
	 */
	public List<RelationshipType> getRelationshipsForItem(RandomEventItem item)
	{
		return relationships.entrySet().stream()
			.filter(entry -> entry.getValue().contains(item))
			.map(Map.Entry::getKey)
			.collect(Collectors.toList());
	}

	/**
	 * Get all items in a specific relationship
	 */
	public Set<RandomEventItem> getItemsInRelationship(RelationshipType relationshipType)
	{
		return relationships.getOrDefault(relationshipType, Set.of());
	}

	/**
	 * Find relationship types that contain all given items
	 */
	public List<RelationshipType> findSharedRelationships(List<RandomEventItem> items)
	{
		return relationships.entrySet().stream()
			.filter(entry -> entry.getValue().containsAll(items))
			.map(Map.Entry::getKey)
			.collect(Collectors.toList());
	}

	// Helper methods

	/**
	 * Main riddle analysis and item matching algorithm
	 * Uses keyword extraction, context analysis, and similarity scoring - no hard-coded patterns
	 */
	private List<RandomEventItem> analyzeRiddleAndFindItems(String riddle, List<RandomEventItem> availableItems, int minItems)
	{
		Map<RelationshipType, Double> relationshipScores = new HashMap<>();

		// Step 1: Extract all meaningful words from riddle (remove stop words)
		Set<String> riddleKeywords = extractRiddleKeywords(riddle);

		// Step 2: Expand keywords using context clues and synonyms
		Set<String> expandedKeywords = expandWithContextAndSynonyms(riddleKeywords);

		// Step 3: Score each relationship type based on keyword matches
		for (RelationshipType type : RelationshipType.values())
		{
			double score = calculateRelationshipScore(type, expandedKeywords, riddleKeywords);
			if (score > 0)
			{
				relationshipScores.put(type, score);
			}
		}

		// Step 4: Score available items based on their relationship scores
		Map<RandomEventItem, Double> itemScores = new HashMap<>();

		for (RandomEventItem item : availableItems)
		{
			double maxItemScore = 0.0;
			List<RelationshipType> itemRelationships = getRelationshipsForItem(item);

			for (RelationshipType relationship : itemRelationships)
			{
				Double relationshipScore = relationshipScores.get(relationship);
				if (relationshipScore != null)
				{
					maxItemScore = Math.max(maxItemScore, relationshipScore);
				}
			}

			if (maxItemScore > 0)
			{
				itemScores.put(item, maxItemScore);
			}
		}

		// Step 5: Return top scoring items
		List<RandomEventItem> result = itemScores.entrySet().stream()
			.sorted(Map.Entry.<RandomEventItem, Double>comparingByValue().reversed())
			.map(Map.Entry::getKey)
			.collect(Collectors.toList());

		// Ensure we return at least minItems if available
		int returnCount = Math.max(minItems, Math.min(result.size(), 8));
		return result.subList(0, Math.min(returnCount, result.size()));
	}

	/**
	 * Expand keywords using both context clues and synonyms dynamically
	 */
	private Set<String> expandWithContextAndSynonyms(Set<String> keywords)
	{
		Set<String> expandedKeywords = new HashSet<>(keywords);

		// Add context-based expansions
		for (String keyword : keywords)
		{
			Set<String> contextWords = CONTEXT_CLUES.get(keyword.toLowerCase());
			if (contextWords != null)
			{
				expandedKeywords.addAll(contextWords);
			}
		}

		// Add synonym-based expansions
		for (String keyword : new HashSet<>(expandedKeywords))
		{ // Copy to avoid concurrent modification
			Set<String> synonyms = SYNONYMS.get(keyword.toLowerCase());
			if (synonyms != null)
			{
				expandedKeywords.addAll(synonyms);
			}

			// Check reverse synonym mapping
			for (Map.Entry<String, Set<String>> entry : SYNONYMS.entrySet())
			{
				if (entry.getValue().contains(keyword.toLowerCase()))
				{
					expandedKeywords.add(entry.getKey());
					expandedKeywords.addAll(entry.getValue());
				}
			}
		}

		return expandedKeywords;
	}

	/**
	 * Calculate relationship score based on keyword matches and similarity
	 * Now focuses purely on dynamic keyword matching without hard-coded patterns
	 */
	private double calculateRelationshipScore(RelationshipType type, Set<String> expandedKeywords, Set<String> originalKeywords)
	{
		double score = 0.0;
		String[] relationshipKeywords = type.getKeywordArray();

		for (String relKeyword : relationshipKeywords)
		{
			String cleanRelKeyword = relKeyword.trim().toLowerCase();
			double bestMatchScore = 0.0;

			// Check against all expanded keywords
			for (String riddleKeyword : expandedKeywords)
			{
				String cleanRiddleKeyword = riddleKeyword.toLowerCase();

				if (cleanRelKeyword.equals(cleanRiddleKeyword))
				{
					bestMatchScore = Math.max(bestMatchScore, 5.0); // Exact match
				}
				else
				{
					// Use similarity for partial matches - convert distance to similarity
					double distance = jaroWinklerDistance.apply(cleanRiddleKeyword, cleanRelKeyword);
					double similarity = 1.0 - distance; // Convert distance to similarity
					// Log similarity for debugging
					log.debug("Similarity between '{}' and '{}': {}", cleanRiddleKeyword, cleanRelKeyword, similarity);

					if (similarity <= (1.0 - EXACT_MATCH_THRESHOLD))
					{
						bestMatchScore = Math.max(bestMatchScore, 5.0);
					}
					else if (similarity <= (1.0 - HIGH_SIMILARITY_THRESHOLD))
					{
						bestMatchScore = Math.max(bestMatchScore, 4.0 * similarity);
					}
					else if (similarity <= (1.0 - MEDIUM_SIMILARITY_THRESHOLD))
					{
						bestMatchScore = Math.max(bestMatchScore, 3.0 * similarity);
					}
					else if (similarity <= (1.0 - LOW_SIMILARITY_THRESHOLD))
					{
						bestMatchScore = Math.max(bestMatchScore, 2.0 * similarity);
					}

					// Check substring matches
					if (cleanRelKeyword.contains(cleanRiddleKeyword) || cleanRiddleKeyword.contains(cleanRelKeyword))
					{
						bestMatchScore = Math.max(bestMatchScore, 3.0);
					}
				}
			}

			// Bonus for matches with original (non-expanded) keywords
			for (String originalKeyword : originalKeywords)
			{
				String cleanOriginal = originalKeyword.toLowerCase();
				if (cleanRelKeyword.equals(cleanOriginal))
				{
					bestMatchScore *= 1.5; // 50% bonus for direct riddle word matches
				}
				else if (cleanRelKeyword.contains(cleanOriginal) || cleanOriginal.contains(cleanRelKeyword))
				{
					bestMatchScore *= 1.2; // 20% bonus for partial direct matches
				}
			}

			score += bestMatchScore;
		}

		return score;
	}

	/**
	 * Extract meaningful keywords from riddle text (removing stop words)
	 */
	private Set<String> extractRiddleKeywords(String riddle)
	{
		Set<String> keywords = new HashSet<>();

		// Clean and split the riddle
		String cleanRiddle = riddle.toLowerCase()
			.replaceAll("[^a-zA-Z\\s]", " ") // Remove punctuation
			.replaceAll("\\s+", " ") // Normalize whitespace
			.trim();

		String[] words = cleanRiddle.split("\\s+");

		for (String word : words)
		{
			if (!STOP_WORDS.contains(word) && word.length() > 2)
			{
				keywords.add(word);
			}
		}

		return keywords;
	}

	/**
	 * Expand keywords using synonym mapping
	 */
	private Set<String> expandWithSynonyms(Set<String> keywords)
	{
		Set<String> expandedKeywords = new HashSet<>(keywords);

		for (String keyword : keywords)
		{
			Set<String> synonyms = SYNONYMS.get(keyword);
			if (synonyms != null)
			{
				expandedKeywords.addAll(synonyms);
			}

			// Also check if any synonym maps match this keyword
			for (Map.Entry<String, Set<String>> entry : SYNONYMS.entrySet())
			{
				if (entry.getValue().contains(keyword))
				{
					expandedKeywords.add(entry.getKey());
					expandedKeywords.addAll(entry.getValue());
				}
			}
		}

		return expandedKeywords;
	}

	private RandomEventItem findMissingItemByPartialMatch(List<RandomEventItem> knownItems, List<RandomEventItem> candidates)
	{
		Map<RandomEventItem, Double> candidateScores = new HashMap<>();

		for (RandomEventItem candidate : candidates)
		{
			double totalScore = 0.0;
			List<RandomEventItem> testGroup = new ArrayList<>(knownItems);
			testGroup.add(candidate);

			// Check each relationship for how well the 4-item group fits
			for (Set<RandomEventItem> relationshipItems : relationships.values())
			{
				long matches = testGroup.stream()
					.filter(relationshipItems::contains)
					.count();

				// Score based on completeness and relationship strength
				double relationshipScore = 0.0;
				if (matches == 4)
				{
					relationshipScore = 10.0; // Perfect complete set
				}
				else if (matches == 3)
				{
					// Check if the candidate is the missing piece
					long knownMatches = knownItems.stream()
						.filter(relationshipItems::contains)
						.count();
					if (knownMatches == 2 && relationshipItems.contains(candidate))
					{
						relationshipScore = 8.0; // Good candidate for completion
					}
					else if (knownMatches == 3 && relationshipItems.contains(candidate))
					{
						relationshipScore = 6.0; // Candidate adds to existing strong group
					}
					else
					{
						relationshipScore = 4.0; // Some connection
					}
				}
				else if (matches == 2)
				{
					relationshipScore = 2.0; // Weak connection
				}
				else if (matches == 1)
				{
					relationshipScore = 0.5; // Very weak connection
				}

				totalScore += relationshipScore;
			}

			candidateScores.put(candidate, totalScore);
		}

		// Return the highest scoring candidate
		return candidateScores.entrySet().stream()
			.max(Map.Entry.comparingByValue())
			.map(Map.Entry::getKey)
			.orElse(null);
	}

	/**
	 * Get similarity score between a hint and relationship keywords
	 *
	 * @param hint             The input hint
	 * @param relationshipType The relationship to check
	 * @return Similarity score between 0.0 and 1.0+ (can exceed 1.0 for exact matches with bonuses)
	 */
	public double getRelationshipSimilarity(String hint, RelationshipType relationshipType)
	{
		String lowerHint = hint.toLowerCase().trim();
		String[] keywords = relationshipType.getKeywordArray();
		double maxSimilarity = 0.0;

		for (String keyword : keywords)
		{
			String cleanKeyword = keyword.trim().toLowerCase();

			// Check for exact match first
			if (cleanKeyword.equals(lowerHint))
			{
				return 2.0; // Bonus for exact match
			}

			// Calculate Jaro-Winkler similarity (convert distance to similarity)
			double distance = jaroWinklerDistance.apply(lowerHint, cleanKeyword);
			double similarity = 1.0 - distance;

			// Boost partial matches
			if (cleanKeyword.contains(lowerHint) || lowerHint.contains(cleanKeyword))
			{
				similarity = Math.max(similarity, 0.8);
			}

			maxSimilarity = Math.max(maxSimilarity, similarity);
		}

		return maxSimilarity;
	}

	/**
	 * Find the best matching relationships for a hint, sorted by similarity
	 *
	 * @param hint          The input hint
	 * @param minSimilarity Minimum similarity threshold (default 0.6)
	 * @return List of relationships sorted by similarity score
	 */
	public List<Map.Entry<RelationshipType, Double>> findBestRelationshipMatches(String hint, double minSimilarity)
	{
		Map<RelationshipType, Double> scores = new HashMap<>();

		for (RelationshipType type : RelationshipType.values())
		{
			double similarity = getRelationshipSimilarity(hint, type);
			if (similarity >= minSimilarity)
			{
				scores.put(type, similarity);
			}
		}

		return scores.entrySet().stream()
			.sorted(Map.Entry.<RelationshipType, Double>comparingByValue().reversed())
			.collect(Collectors.toList());
	}

	/**
	 * Overloaded method with default similarity threshold
	 */
	public List<Map.Entry<RelationshipType, Double>> findBestRelationshipMatches(String hint)
	{
		return findBestRelationshipMatches(hint, LOW_SIMILARITY_THRESHOLD);
	}

	/**
	 * Debug method to analyze how a riddle is processed (now pattern-agnostic)
	 */
	public void analyzeRiddle(String riddle)
	{
		log.debug("Analyzing riddle: {}", riddle);

		// Show extracted keywords
		Set<String> riddleKeywords = extractRiddleKeywords(riddle);
		log.debug("Extracted Keywords: {}", riddleKeywords);

		// Show expanded keywords
		Set<String> expandedKeywords = expandWithContextAndSynonyms(riddleKeywords);
		log.debug("Expanded Keywords: {}", expandedKeywords);

		// Show top relationship matches
		Map<RelationshipType, Double> scores = new HashMap<>();
		for (RelationshipType type : RelationshipType.values())
		{
			double score = calculateRelationshipScore(type, expandedKeywords, riddleKeywords);
			if (score > 0)
			{
				scores.put(type, score);
			}
		}

		log.debug("Top Relationship Matches:");
		scores.entrySet().stream()
			.sorted(Map.Entry.<RelationshipType, Double>comparingByValue().reversed())
			.limit(5)
			.forEach(entry ->
				log.debug("  {} - {}", String.format("%.2f", entry.getValue()), entry.getKey().name())
			);
	}

	/**
	 * Test method for any riddle (not just hard-coded examples)
	 */
	public void testRiddle(String riddle, List<RandomEventItem> availableItems)
	{
		log.debug("--- Debug Analysis ---");
		analyzeRiddle(riddle);

		List<RandomEventItem> results = findItemsByHint(riddle, availableItems, 3);
		log.debug("Recommended items: {}", results);
	}
}

package randomeventhelper.randomevents.surpriseexam;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

@Slf4j
@Singleton
public class SurpriseExamOverlay extends Overlay
{
	private final Client client;
	private final SurpriseExamHelper plugin;

	@Inject
	public SurpriseExamOverlay(Client client, SurpriseExamHelper plugin)
	{
		this.client = client;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		if (plugin.getPatternCardAnswerWidgets() != null && !plugin.getPatternCardAnswerWidgets().isEmpty())
		{
			for (Widget answerWidget : plugin.getPatternCardAnswerWidgets())
			{
				if (answerWidget != null && !answerWidget.isHidden())
				{
					OverlayUtil.renderPolygon(graphics2D, answerWidget.getBounds(), Color.GREEN);
				}
			}
		}

		if (plugin.getPatternNextAnswer() != null)
		{
			OverlayUtil.renderPolygon(graphics2D, plugin.getPatternNextAnswerWidget().getBounds(), Color.GREEN);
		}
		return null;
	}
}

package randomeventhelper.randomevents.maze;

import java.util.Map;
import java.util.Optional;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginManager;

@Slf4j
@Singleton
public class MazeHelper
{
	@Inject
	private EventBus eventBus;

	@Inject
	private Client client;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private ConfigManager configManager;

	private static final String PLUGIN_MESSAGE_SHORTEST_PATH_NAMESPACE = "shortestpath";
	private static final String PLUGIN_MESSAGE_SHORTEST_PATH_PATH_KEY = "path";
	private static final String PLUGIN_MESSAGE_SHORTEST_PATH_CLEAR_KEY = "clear";

	private boolean isInsideMaze;

	public void startUp()
	{
		Optional<Plugin> shortestPathPlugin = pluginManager.getPlugins().stream().filter(plugin -> plugin.getName().equals("Shortest Path")).findAny();

		if (shortestPathPlugin.isPresent())
		{
			if (!pluginManager.isPluginEnabled(shortestPathPlugin.get()))
			{
				log.warn("[#onStartUp] ShortestPathPlugin is not enabled. Please enable it manually to ensure maze helper's functionality.");
				this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "[Random Event Helper] You've enabled the maze helper module but have the Shortest Path plugin disabled. Please enable it manually to ensure functionality.", null);
			}
		}
		else
		{
			log.warn("[#onStartUp] Clue Path Finder requires the Shortest Path plugin found on the Plugin Hub to function properly, and so this plugin has been disabled. Please ensure Shortest Path is installed and enabled before enabling this plugin.");
			// Show a message popup dialog to the user
			SwingUtilities.invokeLater(() -> {
				JOptionPane.showMessageDialog(
					client.getCanvas(),
					"Random Event Helper's Maze Helper requires the Shortest Path plugin found on the Plugin Hub to function properly, and so this plugin has been disabled. Please ensure Shortest Path is installed and enabled before enabling Maze support.",
					"Random Event Helper - Plugin Dependency Missing",
					JOptionPane.WARNING_MESSAGE
				);
			});
			// Remember to disable Maze config option as well
			this.configManager.setConfiguration("randomeventhelper", "isMazeEnabled", false);
			return;
		}
		this.eventBus.register(this);
		this.isInsideMaze = false;
	}

	public void shutDown()
	{
		this.eventBus.unregister(this);
		Optional<Plugin> shortestPathPlugin = pluginManager.getPlugins().stream().filter(plugin -> plugin.getName().equals("Shortest Path")).findAny();
		if (shortestPathPlugin.isPresent())
		{
			if (!pluginManager.isPluginEnabled(shortestPathPlugin.get()))
			{
				if (this.isInsideMaze)
				{
					this.sendShortestPathClear();
				}
			}
		}
		this.isInsideMaze = false;
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned)
	{
		if (gameObjectSpawned.getGameObject().getId() == ObjectID.MACRO_MAZE_COMPLETE)
		{
			if (gameObjectSpawned.getGameObject() != null)
			{
				LocalPoint shrineLocalPoint = gameObjectSpawned.getGameObject().getLocalLocation();
				WorldPoint instancedShrineWorldPoint = WorldPoint.fromLocalInstance(this.client, shrineLocalPoint);
				log.debug("Detected maze exit object spawn, setting shortest path to it");
				this.isInsideMaze = true;
				this.sendShortestPathDestination(instancedShrineWorldPoint);
			}
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned gameObjectDespawned)
	{
		if (gameObjectDespawned.getGameObject().getId() == ObjectID.MACRO_MAZE_COMPLETE)
		{
			log.debug("Detected maze exit object despawn, clearing shortest path");
			this.isInsideMaze = true;
			this.sendShortestPathClear();
		}
	}

	private boolean sendShortestPathDestination(WorldPoint destinationWorldPoint)
	{
		if (destinationWorldPoint == null)
		{
			log.warn("[#sendShortestPathDestinations] The destination is null so we can't set a path");
			return false;
		}

		Map<String, Object> payload = this.generatePathPayload(destinationWorldPoint);
		if (payload.isEmpty())
		{
			log.warn("[#sendShortestPathDestinations] Failed to generate payload for path generation");
			return false;
		}

		this.sendShortestPathClear();
		this.eventBus.post(new PluginMessage(PLUGIN_MESSAGE_SHORTEST_PATH_NAMESPACE, PLUGIN_MESSAGE_SHORTEST_PATH_PATH_KEY, payload));
		return true;
	}

	private Map<String, Object> generatePathPayload(WorldPoint destinationWorldPoint)
	{
		WorldPoint startingWorldPoint = client.getLocalPlayer().getWorldLocation();
		if (startingWorldPoint == null)
		{
			log.warn("[#generatePathPayload-WorldPoint] Player's starting world point is null, cannot generate payload starting point");
			return Map.of();
		}
		return this.generatePathPayload(startingWorldPoint, destinationWorldPoint);
	}

	private Map<String, Object> generatePathPayload(WorldPoint startingWorldPoint, WorldPoint destinationWorldPoint)
	{
		return Map.of(
			"start", startingWorldPoint,
			"target", destinationWorldPoint
		);
	}

	private void sendShortestPathClear()
	{
		this.eventBus.post(new PluginMessage(PLUGIN_MESSAGE_SHORTEST_PATH_NAMESPACE, PLUGIN_MESSAGE_SHORTEST_PATH_CLEAR_KEY));
	}
}

package randomeventhelper;

import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class RandomEventHelperItemOverlay extends WidgetItemOverlay
{
	private final Client client;
	private final RandomEventHelperPlugin plugin;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	public RandomEventHelperItemOverlay(Client client, RandomEventHelperPlugin plugin, ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.plugin = plugin;
		this.modelOutlineRenderer = modelOutlineRenderer;
		showOnInventory();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)
	{
	}
}

package randomeventhelper;

import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class RandomEventHelperOverlay extends Overlay
{

	private final Client client;
	private final SpriteManager spriteManager;
	private final RandomEventHelperPlugin plugin;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	public RandomEventHelperOverlay(Client client, RandomEventHelperPlugin plugin, ModelOutlineRenderer modelOutlineRenderer, SpriteManager spriteManager)
	{
		this.client = client;
		this.plugin = plugin;
		this.modelOutlineRenderer = modelOutlineRenderer;
		this.spriteManager = spriteManager;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics2D)
	{
		return null;
	}
}

package randomeventhelper;

import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import randomeventhelper.randomevents.surpriseexam.OSRSItemRelationshipSystem;
import randomeventhelper.randomevents.surpriseexam.RandomEventItem;

public class RelationshipSystemTest
{
	OSRSItemRelationshipSystem relationshipSystem = new OSRSItemRelationshipSystem();

	@Test
	public void testPatternMatching()
	{
		RelationshipSystemTestMatchingData puzzle1 = new RelationshipSystemTestMatchingData(
			"I feel like a fish out of water!",
			"[BATTLE_AXE (41176), NECKLACE (41216), CANDLE_LANTERN (41229), CAPE_OF_LEGENDS (41167), RAKE (41212), ONION (41226), HARPOON (41158), RING (27091), FIGHTER_BOOTS (41160), HAMMER (41183), MED_HELM (41189), BEER (41152), TROUT_COD_PIKE_SALMON_4 (41217), TROUT_COD_PIKE_SALMON_3 (41163), AIR_RUNE (41168)]",
			List.of(RandomEventItem.HARPOON, RandomEventItem.TROUT_COD_PIKE_SALMON_4, RandomEventItem.TROUT_COD_PIKE_SALMON_3)
		);
		List<RandomEventItem> puzzle1ActualItems = relationshipSystem.findItemsByHint(puzzle1.getHint(), puzzle1.getGivenItems(), 3).subList(0, 3);
		Assertions.assertThat(puzzle1ActualItems).containsExactlyInAnyOrderElementsOf(puzzle1.getExpectedMatchingItems());

		RelationshipSystemTestMatchingData puzzle2 = new RelationshipSystemTestMatchingData(
			"Some professions use such strange headgear.",
			"[CAKE (41202), TROUT_COD_PIKE_SALMON_4 (41217), SHARK (41166), ARROWS (41177), TINDERBOX (41154), HERRING_OR_MACKEREL (41193), PLATELEGS (41179), ORE (41170), LEDERHOSEN_HAT (41164), LONGSWORD (41150), BONES (2674), POT (41223), PIRATE_HAT (41187), JESTER_HAT (41196), AXE (41184)]",
			List.of(RandomEventItem.LEDERHOSEN_HAT, RandomEventItem.PIRATE_HAT, RandomEventItem.JESTER_HAT)
		);
		List<RandomEventItem> puzzle2ActualItems = relationshipSystem.findItemsByHint(puzzle2.getHint(), puzzle2.getGivenItems(), 3).subList(0, 3);
		Assertions.assertThat(puzzle2ActualItems).containsExactlyInAnyOrderElementsOf(puzzle2.getExpectedMatchingItems());
	}

	@Test
	public void testNextMissingItem()
	{
		// initial sequence: BREAD, CAKE, PIE | given: PIZZA, ESSENCE, ARROW, BOOT | expected: PIZZA
		RelationshipSystemTestNextMissingItemData puzzle1 = new RelationshipSystemTestNextMissingItemData(
			"[BREAD (41172), CAKE (41202), PIE (41205)]",
			"[PIZZA (41185), RUNE_OR_ESSENCE (41182), ARROWS (41177), LEATHER_BOOTS (41220)]",
			RandomEventItem.PIZZA
		);
		RandomEventItem puzzle1ActualNextMissingItem = relationshipSystem.findMissingItem(puzzle1.getInitialSequenceItems(), puzzle1.getItemChoices());
		Assertions.assertThat(puzzle1ActualNextMissingItem).isEqualTo(puzzle1.getExpectedNextMissingItem());

		RelationshipSystemTestNextMissingItemData puzzle2 = new RelationshipSystemTestNextMissingItemData(
			"[LONGSWORD (41150), FULL_HELM (41178), KITESHIELD (41200)]",
			"[EARTH_RUNE (41157), BAR (41153), PLATEBODY (27094), CAKE (41202)]",
			RandomEventItem.PLATEBODY
		);
		RandomEventItem puzzle2ActualNextMissingItem = relationshipSystem.findMissingItem(puzzle2.getInitialSequenceItems(), puzzle2.getItemChoices());
		Assertions.assertThat(puzzle2ActualNextMissingItem).isEqualTo(puzzle2.getExpectedNextMissingItem());
	}

	@Data
	static class RelationshipSystemTestMatchingData
	{
		private String hint;
		private List<RandomEventItem> givenItems;
		private List<RandomEventItem> expectedMatchingItems;

		public RelationshipSystemTestMatchingData(String hint, String givenItemsDebugString, List<RandomEventItem> expectedMatchingItems)
		{
			this.hint = hint;
			this.givenItems = fromDebugString(givenItemsDebugString);
			this.expectedMatchingItems = expectedMatchingItems;
		}
	}

	@Data
	static class RelationshipSystemTestNextMissingItemData
	{
		private List<RandomEventItem> initialSequenceItems;
		private List<RandomEventItem> itemChoices;
		private RandomEventItem expectedNextMissingItem;

		public RelationshipSystemTestNextMissingItemData(String initialSequenceItemsDebugString, String givenItemsDebugString, RandomEventItem expectedNextMissingItem)
		{
			this.initialSequenceItems = fromDebugString(initialSequenceItemsDebugString);
			this.itemChoices = fromDebugString(givenItemsDebugString);
			this.expectedNextMissingItem = expectedNextMissingItem;
		}
	}

	/**
	 * Converts a string into a list of @{@link RandomEventItem}
	 *
	 * @param debugString A comma-separated string of @{@link RandomEventItem} names (eg. [BATTLE_AXE (41176), NECKLACE (41216), CANDLE_LANTERN (41229), CAPE_OF_LEGENDS (41167), RAKE (41212), ONION (41226), HARPOON (41158), RING (27091), FIGHTER_BOOTS (41160), HAMMER (41183), MED_HELM (41189), BEER (41152), TROUT_COD_PIKE_SALMON_4 (41217), TROUT_COD_PIKE_SALMON_3 (41163), AIR_RUNE (41168)]
	 * @return List of associated {@link RandomEventItem}s
	 */
	private static List<RandomEventItem> fromDebugString(String debugString)
	{
		// Sanitize the string to remove brackets
		debugString = debugString.replace("[", "").replace("]", "");
		List<RandomEventItem> randomEventItems = new ArrayList<>();
		String[] separatedItems = debugString.split(",");
		for (String randomEventItem : separatedItems)
		{
			String itemName = randomEventItem.trim().split(" ")[0];
			randomEventItems.add(RandomEventItem.valueOf(itemName));
		}
		return randomEventItems;
	}
}

package randomeventhelper;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RandomEventHelperPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RandomEventHelperPlugin.class);
		RuneLite.main(args);
	}
}
