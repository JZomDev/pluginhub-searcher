/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.util;

import com.catracker.model.CombatAchievement;
import com.catracker.ui.CombatAchievementsPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.callback.ClientThread;

import javax.swing.SwingUtilities;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
public class CombatAchievementsDataLoader
{
	private final Client client;
	private final ClientThread clientThread;

	private boolean needsDataLoad = false;
	private boolean dataLoadRequested = false;
	private Consumer<List<CombatAchievement>> onDataLoadComplete;

	private static final Map<Integer, String> TIER_MAP = Map.of(
		3981, "Easy",
		3982, "Medium",
		3983, "Hard",
		3984, "Elite",
		3985, "Master",
		3986, "Grandmaster"
	);

	private static final Map<Integer, String> TYPE_MAP = Map.of(
		1, "Stamina",
		2, "Perfection",
		3, "Kill Count",
		4, "Mechanical",
		5, "Restriction",
		6, "Speed"
	);

	private static final int[] VARP_IDS = new int[]{
		VarPlayerID.CA_TASK_COMPLETED_0, VarPlayerID.CA_TASK_COMPLETED_1,
		VarPlayerID.CA_TASK_COMPLETED_2, VarPlayerID.CA_TASK_COMPLETED_3,
		VarPlayerID.CA_TASK_COMPLETED_4, VarPlayerID.CA_TASK_COMPLETED_5,
		VarPlayerID.CA_TASK_COMPLETED_6, VarPlayerID.CA_TASK_COMPLETED_7,
		VarPlayerID.CA_TASK_COMPLETED_8, VarPlayerID.CA_TASK_COMPLETED_9,
		VarPlayerID.CA_TASK_COMPLETED_10, VarPlayerID.CA_TASK_COMPLETED_11,
		VarPlayerID.CA_TASK_COMPLETED_12, VarPlayerID.CA_TASK_COMPLETED_13,
		VarPlayerID.CA_TASK_COMPLETED_14, VarPlayerID.CA_TASK_COMPLETED_15,
		VarPlayerID.CA_TASK_COMPLETED_16, VarPlayerID.CA_TASK_COMPLETED_17,
		VarPlayerID.CA_TASK_COMPLETED_18, VarPlayerID.CA_TASK_COMPLETED_19
	};

	public CombatAchievementsDataLoader(Client client, ClientThread clientThread)
	{
		this.client = client;
		this.clientThread = clientThread;
	}

	public void requestDataLoad()
	{
		needsDataLoad = true;
	}

	public void requestManualRefresh()
	{
		needsDataLoad = true;
		dataLoadRequested = false;
	}

	public void requestManualRefresh(Consumer<List<CombatAchievement>> callback)
	{
		this.onDataLoadComplete = callback;
		requestManualRefresh();
	}

	public void handleGameTick(CombatAchievementsPanel panel, CompletionPercentageLoader completionLoader)
	{
		if (needsDataLoad && !dataLoadRequested)
		{
			needsDataLoad = false;
			dataLoadRequested = true;
			loadCombatAchievementsFromClient(panel, completionLoader);
		}
	}

	private void loadCombatAchievementsFromClient(CombatAchievementsPanel panel, CompletionPercentageLoader completionLoader)
	{
		if (client == null || client.getGameState() != GameState.LOGGED_IN || client.getLocalPlayer() == null)
		{
			log.warn("Client not ready for loading combat achievements");
			return;
		}

		clientThread.invokeLater(() ->
		{
			try
			{
				TierUtil.initializeTierThresholds(client);
				log.debug("Loading Combat Achievements from client data...");

				List<CombatAchievement> achievements = new ArrayList<>();

				for (Map.Entry<Integer, String> tierEntry : TIER_MAP.entrySet())
				{
					int enumId = tierEntry.getKey();
					String tierName = tierEntry.getValue();

					var enumComp = client.getEnum(enumId);
					if (enumComp == null)
					{
						log.warn("Could not find enum for tier: {} ({})", tierName, enumId);
						continue;
					}

					int[] structIds = enumComp.getIntVals();
					log.debug("Processing {} tasks for tier {}", structIds.length, tierName);

					for (int structId : structIds)
					{
						var struct = client.getStructComposition(structId);
						if (struct == null)
						{
							log.warn("Could not find struct: {}", structId);
							continue;
						}

						String name = struct.getStringValue(1308);
						String description = struct.getStringValue(1309);
						int id = struct.getIntValue(1306);
						int typeId = struct.getIntValue(1311);
						String type = TYPE_MAP.get(typeId);
						int bossId = struct.getIntValue(1312);
						String bossName = getBossName(bossId);

						boolean completed = false;
						if (id >= 0 && id < VARP_IDS.length * 32)
						{
							int varpIndex = id / 32;
							int bitIndex = id % 32;
							if (varpIndex < VARP_IDS.length)
							{
								int varpValue = client.getVarpValue(VARP_IDS[varpIndex]);
								completed = (varpValue & (1 << bitIndex)) != 0;
							}
						}

						int points = getPointsForTier(tierName);
						CombatAchievement achievement = new CombatAchievement(
							id, name, bossName, type, description, tierName, points, completed, false
						);

						achievements.add(achievement);
					}
				}

				log.debug("Finished loading {} achievements on client thread", achievements.size());

				completionLoader.loadCompletionPercentagesAsync()
					.thenRun(() ->
					{
						completionLoader.hydrateAchievements(achievements);

						SwingUtilities.invokeLater(() ->
						{
							if (panel != null)
							{
								panel.updateAchievements(achievements);
							}

							if (onDataLoadComplete != null)
							{
								onDataLoadComplete.accept(achievements);
								onDataLoadComplete = null;
							}
						});
					})
					.exceptionally(throwable ->
					{
						log.error("Completion percentage loading failed, updating panel without percentages", throwable);
						SwingUtilities.invokeLater(() ->
						{
							if (panel != null)
							{
								panel.updateAchievements(achievements);
							}

							if (onDataLoadComplete != null)
							{
								onDataLoadComplete.accept(achievements);
								onDataLoadComplete = null;
							}
						});
						return null;
					});

				dataLoadRequested = false;
			}
			catch (Exception e)
			{
				log.error("Failed to load Combat Achievements from client", e);
				dataLoadRequested = false;
				onDataLoadComplete = null;
			}
		});
	}

	private String getBossName(int bossId)
	{
		try
		{
			var bossEnum = client.getEnum(3971);
			if (bossEnum != null)
			{
				return bossEnum.getStringValue(bossId);
			}
		}
		catch (Exception e)
		{
			log.warn("Failed to get boss name for ID {}: {}", bossId, e.getMessage());
		}
		return "Unknown";
	}

	private int getPointsForTier(String tier)
	{
		switch (tier.toLowerCase())
		{
			case "easy":
				return 1;
			case "medium":
				return 2;
			case "hard":
				return 3;
			case "elite":
				return 4;
			case "master":
				return 5;
			case "grandmaster":
				return 6;
			default:
				return 1;
		}
	}
}
/*
 * Copyright (c) 2024, [Your Name] <[your-email@example.com]>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.catracker.util;

import com.catracker.config.CombatAchievementsConfig;
import com.catracker.model.CombatAchievement;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import java.awt.Color;
import java.util.List;

/**
 * Utility class for sending chat messages related to combat achievements
 */
@Slf4j
public class ChatMessageUtil
{
	private final ChatMessageManager chatMessageManager;
	private final Client client;

	public ChatMessageUtil(ChatMessageManager chatMessageManager, Client client)
	{
		this.chatMessageManager = chatMessageManager;
		this.client = client;
	}

	/**
	 * Send a progress message when a combat achievement is completed
	 */
	public void sendProgressMessage(List<CombatAchievement> allAchievements,
									CombatAchievementsConfig.TierGoal tierGoal)
	{
		int totalCompletedPoints = allAchievements.stream()
			.filter(CombatAchievement::isCompleted)
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		int pointGoal = TierUtil.getPointsFromGoal(tierGoal, totalCompletedPoints);
		String actualTierName = TierUtil.getActualTierName(tierGoal, totalCompletedPoints);

		ChatMessageBuilder message = new ChatMessageBuilder()
			.append(Color.CYAN, "[Combat Achievements] ");

		if (totalCompletedPoints >= pointGoal)
		{
			message.append(Color.GREEN, actualTierName + " tier completed! ")
				.append(Color.WHITE, "(" + totalCompletedPoints + " points)");
		}
		else
		{
			int remainingPoints = pointGoal - totalCompletedPoints;
			message.append(Color.WHITE, "Progress: " + totalCompletedPoints + "/" + pointGoal + " points ")
				.append(Color.YELLOW, "(" + remainingPoints + " points to " + actualTierName + ")");
		}

		sendChatMessage(message.build());
	}

	/**
	 * Send a custom chat message
	 */
	public void sendChatMessage(String message)
	{
		if (client == null)
		{
			return;
		}

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(message)
			.build());
	}
}
package com.catracker.util;

import com.catracker.config.CombatAchievementsConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;

import java.util.HashMap;
import java.util.Map;

@Slf4j
public class TierUtil
{
	private static final Map<Integer, String> TIER_VARBIT_MAP = Map.of(
		4132, "Easy",
		10660, "Medium",
		10661, "Hard",
		14812, "Elite",
		14813, "Master",
		14814, "Grandmaster"
	);

	private static Map<String, Integer> cachedThresholds = null;

	public static void initializeTierThresholds(Client client)
	{
		Map<String, Integer> thresholds = new HashMap<>();

		for (Map.Entry<Integer, String> entry : TIER_VARBIT_MAP.entrySet())
		{
			int varbitId = entry.getKey();
			String tierName = entry.getValue();

			try
			{
				int value = client.getVarbitValue(varbitId);
				if (value > 0)
				{
					thresholds.put(tierName, value);
					log.debug("Loaded {} tier threshold: {} from varbit {}", tierName, value, varbitId);
				}
				else
				{
					log.warn("Varbit {} ({}) returned 0", varbitId, tierName);
				}
			}
			catch (Exception e)
			{
				log.warn("Failed to read varbit {} for {} tier: {}", varbitId, tierName, e.getMessage());
			}
		}

		cachedThresholds = thresholds;
		log.debug("Initialized tier thresholds: {}", cachedThresholds);
	}

	public static int getPointsFromGoal(CombatAchievementsConfig.TierGoal tierGoal, int completedPoints)
	{
		if (cachedThresholds == null)
		{
			log.warn("Tier thresholds not initialized - call initializeTierThresholds first");
			return 0;
		}

		if (tierGoal.toString().equalsIgnoreCase("AUTO"))
		{
			String[] tierOrder = {"Easy", "Medium", "Hard", "Elite", "Master", "Grandmaster"};

			for (String tier : tierOrder)
			{
				int threshold = cachedThresholds.getOrDefault(tier, 0);
				if (threshold > 0 && completedPoints < threshold)
				{
					return threshold;
				}
			}

			return cachedThresholds.getOrDefault("Grandmaster", 0);
		}

		String tierName = tierGoal.toString().replace("TIER_", "");
		tierName = tierName.substring(0, 1).toUpperCase() + tierName.substring(1).toLowerCase();

		return cachedThresholds.getOrDefault(tierName, 0);
	}

	public static String getActualTierName(CombatAchievementsConfig.TierGoal tierGoal, int completedPoints)
	{
		if (cachedThresholds == null)
		{
			log.warn("Tier thresholds not initialized - call initializeTierThresholds first");
			return "Unknown";
		}

		if (tierGoal.toString().equalsIgnoreCase("AUTO"))
		{
			String[] tierOrder = {"Easy", "Medium", "Hard", "Elite", "Master", "Grandmaster"};

			for (String tier : tierOrder)
			{
				int threshold = cachedThresholds.getOrDefault(tier, 0);
				if (threshold > 0 && completedPoints < threshold)
				{
					return tier;
				}
			}

			return "Grandmaster";
		}

		String tierName = tierGoal.toString().replace("TIER_", "");
		return tierName.substring(0, 1).toUpperCase() + tierName.substring(1).toLowerCase();
	}

	public static Map<String, Integer> getCachedThresholds()
	{
		return cachedThresholds != null ? new HashMap<>(cachedThresholds) : new HashMap<>();
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.util;

import com.catracker.model.CombatAchievement;
import lombok.extern.slf4j.Slf4j;

import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class CompletionPercentageLoader
{
	private static final String WIKI_URL = "https://oldschool.runescape.wiki/w/Combat_Achievements/All_tasks";
	private final Map<String, Double> completionPercentages = new HashMap<>();
	private boolean isLoaded = false;

	private OkHttpClient okHttpClient;

	public CompletionPercentageLoader(OkHttpClient okHttpClient)
	{
		this.okHttpClient = okHttpClient;
	}

	public void setOkHttpClient(OkHttpClient okHttpClient)
	{
		this.okHttpClient = okHttpClient;
	}

	public CompletableFuture<Void> loadCompletionPercentagesAsync()
	{
		return CompletableFuture.runAsync(() ->
		{
			try
			{
				loadCompletionPercentages();
				isLoaded = true;
				log.debug("Completion percentage loading completed successfully");
			}
			catch (Exception e)
			{
				log.error("Failed to load completion percentages", e);
			}
		});
	}

	private void loadCompletionPercentages() throws Exception
	{
		Request request = new Request.Builder()
			.url(WIKI_URL)
			.header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
			.build();

		try (Response response = okHttpClient.newCall(request).execute())
		{
			if (!response.isSuccessful())
			{
				String unsuccessful = "Wiki request unsuccessful with status " + response.code();
				if (response.body() == null)
				{
					unsuccessful += " and body \n" + response.body().string();
				}
				log.error(unsuccessful);
				throw new Exception(unsuccessful);
			}

			if (response.body() == null)
			{
				log.error("Wiki response returned without body");
				throw new Exception("Wiki response returned without body");
			}

			String html = response.body().string();
			parseCompletionPercentages(html);
		}
		catch (IOException e)
		{
			log.error("Failed to fetch completion percentages from wiki", e);
			throw new Exception("Failed to fetch completion percentages from wiki", e);
		}
	}

	private void parseCompletionPercentages(String html)
	{
		Pattern rowPattern = Pattern.compile("<tr[^>]*data-ca-task-id=\"\\d+\"[^>]*>(.*?)</tr>", Pattern.DOTALL);
		Matcher rowMatcher = rowPattern.matcher(html);

		while (rowMatcher.find())
		{
			String row = rowMatcher.group(1);

			String[] cells = row.split("</td>");
			if (cells.length >= 6)
			{
				String taskName = extractTaskName(cells[1]);
				String percentageStr = extractPercentage(cells[5]);

				if (taskName != null && percentageStr != null)
				{
					try
					{
						double percentage = Double.parseDouble(percentageStr);
						completionPercentages.put(taskName.trim(), percentage);
					}
					catch (NumberFormatException e)
					{
						log.warn("Could not parse percentage for task: {}", taskName);
					}
				}
			}
		}

		log.debug("Loaded {} completion percentages", completionPercentages.size());
	}

	private String extractTaskName(String cell)
	{
		Pattern namePattern = Pattern.compile("<a[^>]*title=\"([^\"]+)\"[^>]*>([^<]+)</a>");
		Matcher nameMatcher = namePattern.matcher(cell);
		if (nameMatcher.find())
		{
			return nameMatcher.group(2).trim();
		}
		return null;
	}

	private String extractPercentage(String cell)
	{
		Pattern percentagePattern = Pattern.compile("([0-9.]+)%");
		Matcher percentageMatcher = percentagePattern.matcher(cell);
		if (percentageMatcher.find())
		{
			return percentageMatcher.group(1);
		}
		return null;
	}

	public void hydrateAchievements(List<CombatAchievement> achievements)
	{
		if (achievements == null)
		{
			return;
		}

		for (CombatAchievement achievement : achievements)
		{
			String name = achievement.getName();
			Double percentage = completionPercentages.get(name);

			if (percentage == null)
			{
				String normalizedName = normalizeTaskName(name);
				for (Map.Entry<String, Double> entry : completionPercentages.entrySet())
				{
					if (normalizeTaskName(entry.getKey()).equals(normalizedName))
					{
						percentage = entry.getValue();
						break;
					}
				}
			}

			achievement.setCompletionPercentage(percentage);
		}
	}

	private String normalizeTaskName(String name)
	{
		return name.toLowerCase()
			.replaceAll("[^a-z0-9\\s]", "")
			.replaceAll("\\s+", " ")
			.trim();
	}

	public boolean isDataLoaded()
	{
		return isLoaded;
	}

	public Double getCompletionPercentage(String taskName)
	{
		return completionPercentages.get(taskName);
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.model;

public class BossStats
{
	public int total = 0;
	public int completed = 0;
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.model;

import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * Represents a single Combat Achievement
 */
@Data
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class CombatAchievement
{
	@EqualsAndHashCode.Include
	private final int id;

	private final String name;
	private final String description;
	private final String tier; // Easy, Medium, Hard, Elite, Master
	private final int points;

	private boolean completed;
	private boolean tracked;
	private long completedTimestamp;

	private String bossName;
	private String type; // Kill Count, Perfection, Restriction, Mechanical, etc.
	private int userDifficulty; // 1-5 user assigned difficulty
	private Double completionPercentage; // Wiki completion percentage
	private String wikiUrl;

	public CombatAchievement(int id, String name, String bossName, String type, String description, String tier, int points, boolean completed, boolean tracked)
	{
		this.id = id;
		this.name = name;
		this.bossName = bossName;
		this.type = type;
		this.description = description;
		this.tier = tier;
		this.points = points;
		this.completed = completed;
		this.tracked = tracked;
		this.completedTimestamp = completed ? System.currentTimeMillis() : 0;

		// Set defaults
		this.userDifficulty = 0; // Medium difficulty by default
	}

	/**
	 * Mark this achievement as completed
	 */
	public void markCompleted()
	{
		this.completed = true;
		this.completedTimestamp = System.currentTimeMillis();
	}

	/**
	 * Get the tier as an enum for easier comparison
	 */
	public TierLevel getTierLevel()
	{
		return TierLevel.fromString(tier);
	}

	/**
	 * Get the improved color associated with this tier (for better readability)
	 */
	public java.awt.Color getTierColor()
	{
		switch (tier.toLowerCase())
		{
			case "easy":
				return new java.awt.Color(205, 133, 63);  // Peru/Sandy brown
			case "medium":
				return new java.awt.Color(169, 169, 169); // Dark gray
			case "hard":
				return new java.awt.Color(105, 105, 105); // Dim gray
			case "elite":
				return new java.awt.Color(100, 149, 237); // Cornflower blue
			case "master":
				return new java.awt.Color(220, 20, 60);   // Crimson
			case "grandmaster":
				return new java.awt.Color(255, 215, 0);   // Gold
			default:
				return java.awt.Color.WHITE;
		}
	}

	/**
	 * Check if this achievement matches a search term
	 */
	public boolean matchesSearch(String searchTerm)
	{
		if (searchTerm == null || searchTerm.trim().isEmpty())
		{
			return true;
		}

		String term = searchTerm.toLowerCase();
		return name.toLowerCase().contains(term) ||
			description.toLowerCase().contains(term) ||
			(bossName != null && bossName.toLowerCase().contains(term)) ||
			tier.toLowerCase().contains(term);
	}

	/**
	 * Generate wiki URL if not set
	 */
	public String getWikiUrl()
	{
		if (wikiUrl != null && !wikiUrl.isEmpty())
		{
			return wikiUrl;
		}

		// Generate default wiki URL
		String encodedName = name.replace(" ", "_").replace("'", "%27");
		return "https://oldschool.runescape.wiki/w/" + encodedName;
	}

	/**
	 * Enum for tier levels with associated colors and point ranges
	 */
	public enum TierLevel
	{
		EASY("Easy", new java.awt.Color(205, 133, 63), 1),          // Peru/Sandy brown
		MEDIUM("Medium", new java.awt.Color(169, 169, 169), 2),     // Dark gray
		HARD("Hard", new java.awt.Color(105, 105, 105), 3),         // Dim gray
		ELITE("Elite", new java.awt.Color(100, 149, 237), 4),       // Cornflower blue
		MASTER("Master", new java.awt.Color(220, 20, 60), 5),       // Crimson
		GRANDMASTER("Grandmaster", new java.awt.Color(255, 215, 0), 6); // Gold

		private final String displayName;
		private final java.awt.Color color;
		private final int basePoints;

		TierLevel(String displayName, java.awt.Color color, int basePoints)
		{
			this.displayName = displayName;
			this.color = color;
			this.basePoints = basePoints;
		}

		public java.awt.Color getColor()
		{
			return color;
		}

		public int getBasePoints()
		{
			return basePoints;
		}

		public int getOrder()
		{
			return ordinal(); // Returns 0 for Easy, 1 for Medium, etc.
		}

		public static TierLevel fromString(String tier)
		{
			for (TierLevel level : values())
			{
				if (level.displayName.equalsIgnoreCase(tier))
				{
					return level;
				}
			}
			return EASY; // Default fallback
		}
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.config;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("combatachievements")
public interface CombatAchievementsConfig extends Config
{
	String CONFIG_GROUP_NAME = "combatachievements";

	@ConfigSection(
		name = "List Settings",
		description = "Configure how achievements are displayed",
		position = 0
	)
	String listSection = "list";

	@ConfigSection(
		name = "UI Settings",
		description = "Configure the user interface",
		position = 1
	)
	String uiSection = "ui";

	@ConfigSection(
		name = "Notifications",
		description = "Configure completion notifications",
		position = 2
	)
	String notificationSection = "notifications";

	@ConfigItem(
		keyName = "tierGoal",
		name = "Set Your Current Goal",
		description = "Set a CA tier goal",
		section = listSection,
		position = 2
	)
	default TierGoal tierGoal()
	{
		return TierGoal.TIER_AUTO;
	}

	// UI Settings
	@ConfigItem(
		keyName = "preferSmallerStatsPanel",
		name = "Prefer Smaller Stats Panel",
		description = "Use a more compact stats panel that takes up less vertical space",
		section = uiSection,
		position = 0
	)
	default boolean preferSmallerStatsPanel()
	{
		return false;
	}

	// Notifications
//	@ConfigItem(
//		keyName = "showProgressNotifications",
//		name = "Show Progress Notifications",
//		description = "Show notifications when completing achievements",
//		section = notificationSection,
//		position = 0
//	)
//	default boolean showProgressNotifications()
//	{
//		return true;
//	}

//	@ConfigItem(
//		keyName = "showChatMessages",
//		name = "Show Chat Messages",
//		description = "Show progress messages in chat",
//		section = notificationSection,
//		position = 1
//	)
//	default boolean showChatMessages()
//	{
//		return true;
//	}

	@ConfigItem(
		keyName = "showGoalProgress",
		name = "Show Goal Progress",
		description = "Send chat message showing progress towards your tier goal when completing achievements",
		section = notificationSection,
		position = 2
	)
	default boolean showGoalProgress()
	{
		return true;
	}

	enum TierGoal
	{
		TIER_AUTO("Auto"),
		TIER_EASY("Easy"),
		TIER_MEDIUM("Medium"),
		TIER_HARD("Hard"),
		TIER_ELITE("Elite"),
		TIER_MASTER("Master"),
		TIER_GRANDMASTER("Grandmaster");

		private final String displayName;

		TierGoal(String displayName)
		{
			this.displayName = displayName;
		}

		@Override
		public String toString()
		{
			return displayName;
		}
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.ui.util;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.image.BufferedImage;

/**
 * Centralized icon loading utility to handle resource loading consistently
 */
@Slf4j
public class IconLoader
{

	private static final String RESOURCE_PATH = "/";

	/**
	 * Load an icon from resources with specified dimensions
	 */
	public static ImageIcon loadIcon(String iconName, int width, int height)
	{
		BufferedImage originalIcon = ImageUtil.loadImageResource(
			com.catracker.CombatAchievementsPlugin.class,
			iconName
		);
		BufferedImage resizedIcon = ImageUtil.resizeImage(originalIcon, width, height);
		return new ImageIcon(resizedIcon);
	}

	/**
	 * Load a tier icon (16x16)
	 */
	public static ImageIcon loadTierIcon(String tier)
	{
		String iconPath = tier.toLowerCase() + "_tier.png";
		return loadIcon(iconPath, 16, 16);
	}

	/**
	 * Load a tier button icon (20x20)
	 */
	public static ImageIcon loadTierButtonIcon(String tier)
	{
		String iconPath = tier.toLowerCase() + "_tier.png";
		return loadIcon(iconPath, 20, 20);
	}

	/**
	 * Load track add icon (12x12)
	 */
	public static ImageIcon loadTrackAddIcon()
	{
		return loadIcon("track_add.png", 12, 12);
	}

	/**
	 * Load track remove icon (12x12)
	 */
	public static ImageIcon loadTrackRemoveIcon()
	{
		return loadIcon("track_remove.png", 12, 12);
	}

	/**
	 * Load arrow right icon (rotated for up/down arrows)
	 */
	public static ImageIcon loadArrowRight()
	{
		return loadIcon("arrow_right.png", 16, 16);
	}

	/**
	 * Load sort up icon (24x24)
	 */
	public static ImageIcon loadSortUpIcon()
	{
		return loadIcon("sort_up.png", 16, 16);
	}

	/**
	 * Load sort down icon (24x24)
	 */
	public static ImageIcon loadSortDownIcon()
	{
		return loadIcon("sort_down.png", 16, 16);
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.ui;

import com.catracker.CombatAchievementsPlugin;
import com.catracker.model.CombatAchievement;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

@Slf4j
public class CombatAchievementPanel extends JPanel
{
	private final CombatAchievementsPlugin plugin;
	private final CombatAchievement achievement;

	private final JPanel container = new JPanel(new BorderLayout());
	private final JPanel body = new JPanel(new BorderLayout());
	private final JLabel nameLabel = new JLabel();
	private final JTextArea descriptionArea = new JTextArea();
	private final JToggleButton trackButton = new JToggleButton();
	private final JLabel tierIconLabel = new JLabel();
	private final JPanel expandedPanel = new JPanel();
	private boolean isExpanded = false;

	private final JPanel topSection = new JPanel(new BorderLayout());
	private final JPanel nameLabelPanel = new JPanel(new BorderLayout());
	private final JPanel topRightPanel = new JPanel();

	public CombatAchievementPanel(CombatAchievementsPlugin plugin, CombatAchievement achievement)
	{
		super(new BorderLayout());
		this.plugin = plugin;
		this.achievement = achievement;
		createPanel();
		setupEventHandlers();
		refresh();
	}

	private void createPanel()
	{
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(2, 2, 2, 2));
		container.setBackground(getBackgroundColor());
		body.setLayout(new BorderLayout());
		body.setBackground(getBackgroundColor());
		body.setBorder(new EmptyBorder(6, 6, 6, 6));

		topSection.setBackground(getBackgroundColor());

		nameLabelPanel.setBackground(getBackgroundColor());
		nameLabelPanel.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 60, 20));
		nameLabelPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 60, 20));

		nameLabel.setFont(FontManager.getRunescapeSmallFont());
		nameLabel.setForeground(getNameColor());
		nameLabel.setText(achievement.getName());

		setupTierIcon();

		JPanel nameWithIconPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		nameWithIconPanel.setBackground(getBackgroundColor());
		nameWithIconPanel.add(tierIconLabel);
		nameWithIconPanel.add(Box.createHorizontalStrut(6));
		nameWithIconPanel.add(nameLabel);

		nameLabelPanel.add(nameWithIconPanel, BorderLayout.WEST);

		topRightPanel.setLayout(new BoxLayout(topRightPanel, BoxLayout.X_AXIS));
		topRightPanel.setBackground(getBackgroundColor());

		trackButton.setPreferredSize(new Dimension(12, 12));
		trackButton.setMaximumSize(new Dimension(12, 12));
		trackButton.setMinimumSize(new Dimension(12, 12));
		updateTrackButton();
		SwingUtil.removeButtonDecorations(trackButton);

		topRightPanel.add(trackButton);

		topSection.add(nameLabelPanel, BorderLayout.WEST);
		topSection.add(topRightPanel, BorderLayout.EAST);

		JPanel centerPanel = new JPanel();
		centerPanel.setLayout(new BoxLayout(centerPanel, BoxLayout.Y_AXIS));
		centerPanel.setBackground(getBackgroundColor());

		String bossTypeText = getBossTypeText();
		if (bossTypeText != null && !bossTypeText.isEmpty())
		{
			JLabel bossTypeLabel = new JLabel(bossTypeText);
			bossTypeLabel.setFont(FontManager.getRunescapeSmallFont());
			bossTypeLabel.setForeground(Color.LIGHT_GRAY);
			bossTypeLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
			bossTypeLabel.setBorder(new EmptyBorder(2, 0, 4, 0));
			centerPanel.add(bossTypeLabel);
		}

		JPanel descriptionPanel = new JPanel(new BorderLayout());
		descriptionPanel.setBackground(getBackgroundColor());
		descriptionPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

		descriptionArea.setFont(FontManager.getRunescapeSmallFont());
		descriptionArea.setForeground(Color.LIGHT_GRAY);
		descriptionArea.setBackground(getBackgroundColor());
		descriptionArea.setLineWrap(true);
		descriptionArea.setWrapStyleWord(true);
		descriptionArea.setEditable(false);
		descriptionArea.setFocusable(false);
		descriptionArea.setEnabled(false);
		descriptionArea.setDisabledTextColor(Color.LIGHT_GRAY);
		descriptionArea.setBorder(null);
		descriptionArea.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		descriptionArea.setText(truncateToTwoLines(achievement.getDescription()));

		descriptionPanel.add(descriptionArea, BorderLayout.CENTER);
		centerPanel.add(descriptionPanel);

		body.add(topSection, BorderLayout.NORTH);
		body.add(centerPanel, BorderLayout.CENTER);

		setupExpandedPanel();

		container.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

		MouseAdapter clickAndHoverHandler = new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				// Check for popup trigger (right-click) - show context menu
				if (e.isPopupTrigger())
				{
					showContextMenu(e);
					return;
				}

				// Only expand on left click, not right click (right click is for context menu)
				if (!SwingUtilities.isLeftMouseButton(e))
				{
					return;
				}

				// Check if click originated from track button - if so, ignore
				Component source = (Component) e.getSource();
				if (source == trackButton || SwingUtilities.isDescendingFrom(source, trackButton))
				{
					return;
				}
				toggleExpanded();
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					showContextMenu(e);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				updateAllBackgrounds(ColorScheme.DARK_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				updateAllBackgrounds(getBackgroundColor());
			}
		};

		addMouseListenerRecursively(container, clickAndHoverHandler);

		descriptionArea.addMouseListener(clickAndHoverHandler);

		container.add(body, BorderLayout.CENTER);
		container.add(expandedPanel, BorderLayout.SOUTH);
		add(container, BorderLayout.CENTER);

		// Tooltip disabled temporarily
		// setToolTipText(createTooltip());
	}

	private void setupExpandedPanel()
	{
		expandedPanel.setLayout(new BorderLayout());
		expandedPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		expandedPanel.setVisible(false);

		JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		contentPanel.setBorder(new EmptyBorder(5, 6, 5, 6));

		contentPanel.add(createInfoRow("Tier:", achievement.getTier()));
		contentPanel.add(createInfoRow("Points:", String.valueOf(achievement.getPoints())));

		if (achievement.getBossName() != null && !achievement.getBossName().equals("Unknown"))
		{
			contentPanel.add(createInfoRow("Boss:", achievement.getBossName()));
		}

		if (achievement.getType() != null && !achievement.getType().isEmpty())
		{
			contentPanel.add(createInfoRow("Type:", achievement.getType()));
		}

		if (achievement.getCompletionPercentage() != null)
		{
			String completionText = String.format("%.1f%%", achievement.getCompletionPercentage());
			contentPanel.add(createInfoRow("Wiki Completion%:", completionText));
		}
		else
		{
			contentPanel.add(createInfoRow("Wiki Completion%:", "Unknown"));
		}

		contentPanel.add(Box.createVerticalStrut(5));

		// Status
		JLabel statusLabel = new JLabel();
		statusLabel.setFont(FontManager.getRunescapeSmallFont());
		statusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		if (achievement.isCompleted())
		{
			statusLabel.setText("Status: Completed");
			statusLabel.setForeground(Color.GREEN);
		}
		else
		{
			statusLabel.setText("Status: Incomplete");
			statusLabel.setForeground(Color.RED);
		}
		contentPanel.add(statusLabel);

		if (achievement.isTracked())
		{
			JLabel trackedLabel = new JLabel("Tracked");
			trackedLabel.setFont(FontManager.getRunescapeSmallFont());
			trackedLabel.setForeground(new Color(100, 149, 237));
			trackedLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
			contentPanel.add(trackedLabel);
		}

		expandedPanel.add(contentPanel, BorderLayout.CENTER);
	}

	private JPanel createInfoRow(String label, String value)
	{
		JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		row.setAlignmentX(Component.LEFT_ALIGNMENT);

		JLabel labelComponent = new JLabel(label + " ");
		labelComponent.setFont(FontManager.getRunescapeSmallFont());
		labelComponent.setForeground(Color.LIGHT_GRAY);

		JLabel valueComponent = new JLabel(value);
		valueComponent.setFont(FontManager.getRunescapeSmallFont());
		valueComponent.setForeground(Color.WHITE);

		row.add(labelComponent);
		row.add(valueComponent);

		return row;
	}

	private String truncateToTwoLines(String text)
	{
		if (text == null || text.isEmpty())
		{
			return "";
		}

		// Calculate approximate character limit for 2 lines
		// Average panel width is ~230px, average char width is ~7px
		// So roughly 33 chars per line * 2 lines = 66 chars
		int maxChars = 66;

		if (text.length() <= maxChars)
		{
			return text;
		}

		// Truncate and add ellipsis
		return text.substring(0, maxChars - 3) + "...";
	}

	private String getBossTypeText()
	{
		String bossName = achievement.getBossName();
		String type = achievement.getType();

		if (bossName != null && !bossName.equals("None") && !bossName.isEmpty())
		{
			if (type != null && !type.isEmpty())
			{
				return bossName + " - " + type;
			}
			else
			{
				return bossName;
			}
		}
		else if (type != null && !type.isEmpty())
		{
			return type;
		}

		return null;
	}

	private void setupTierIcon()
	{
		ImageIcon icon = com.catracker.ui.util.IconLoader.loadTierIcon(achievement.getTier());
		if (icon != null)
		{
			tierIconLabel.setIcon(icon);
			tierIconLabel.setToolTipText(achievement.getTier() + " Tier");
		}
		else
		{
			log.warn("Could not load tier icon for {}", achievement.getTier());
			tierIconLabel.setIcon(null);
		}
	}

	private Color getNameColor()
	{
		if (achievement.isCompleted())
		{
			return Color.GREEN;
		}
		else if (achievement.isTracked())
		{
			return new Color(100, 149, 237);
		}
		else
		{
			return ColorScheme.BRAND_ORANGE;
		}
	}

	private void setupEventHandlers()
	{
		trackButton.addActionListener(e ->
		{
			achievement.setTracked(!achievement.isTracked());
			updateTrackButton();
			if (achievement.isTracked())
			{
				plugin.getPanel().addToTracked(achievement);
			}
			else
			{
				plugin.getPanel().removeFromTracked(achievement);
			}
		});

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					showContextMenu(e);
				}
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					showContextMenu(e);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				// Tooltip disabled temporarily
				// setToolTipText(createTooltip());
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				// Tooltip disabled temporarily
				// setToolTipText(null);
			}
		});
	}

	private void showContextMenu(MouseEvent e)
	{
		JPopupMenu popup = new JPopupMenu();

		JMenuItem wikiItem = new JMenuItem("Open Wiki");
		wikiItem.addActionListener(event -> openWikiLink());
		popup.add(wikiItem);

		JMenuItem moreInfoItem = new JMenuItem("Show More Info");
		moreInfoItem.addActionListener(event -> plugin.getPanel().showAchievementDetail(achievement));
		popup.add(moreInfoItem);

		String bossName = achievement.getBossName();
		if (bossName != null && !bossName.equals("Unknown") && !bossName.trim().isEmpty())
		{
			JMenuItem bossTabItem = new JMenuItem("Open in Bosses Tab");
			bossTabItem.addActionListener(event -> plugin.getPanel().openInBossesTab(bossName));
			popup.add(bossTabItem);
		}

//		if (!achievement.isCompleted())
//		{
//			JMenuItem completeItem = new JMenuItem("Mark as Completed (Test)");
//			completeItem.addActionListener(event ->
//			{
//				// Simulate the actual game completion flow by calling the plugin's handler
//				// This will trigger data refresh and UI update just like a real completion
//				String testMessage = "Congratulations, you've completed a master combat task: " + achievement.getName() + ".";
//				plugin.handleCombatAchievementCompletion(testMessage);
//			});
//			popup.add(completeItem);
//		}

		popup.show(e.getComponent(), e.getX(), e.getY());
	}

	private void openWikiLink()
	{
		try
		{
			LinkBrowser.browse(achievement.getWikiUrl());
		}
		catch (Exception ex)
		{
			log.error("Failed to open wiki link: {}", achievement.getWikiUrl(), ex);
		}
	}

	private void updateTrackButton()
	{
		ImageIcon icon;
		if (achievement.isTracked())
		{
			icon = com.catracker.ui.util.IconLoader.loadTrackRemoveIcon();
			trackButton.setToolTipText("Remove from tracking");
		}
		else
		{
			icon = com.catracker.ui.util.IconLoader.loadTrackAddIcon();
			trackButton.setToolTipText("Add to tracking");
		}

		if (icon != null)
		{
			trackButton.setIcon(icon);
			trackButton.setText("");
		}
		else
		{
			if (achievement.isTracked())
			{
				trackButton.setText("X");
				trackButton.setIcon(null);
				trackButton.setBackground(new Color(120, 70, 70));
				trackButton.setForeground(Color.WHITE);
				trackButton.setToolTipText("Remove from tracking");
			}
			else
			{
				trackButton.setText("+");
				trackButton.setIcon(null);
				trackButton.setBackground(new Color(80, 120, 80));
				trackButton.setForeground(Color.WHITE);
				trackButton.setToolTipText("Add to tracking");
			}
		}
	}

	private Color getBackgroundColor()
	{
		return ColorScheme.DARKER_GRAY_COLOR;
	}

	private void updateAllBackgrounds(Color bgColor)
	{
		container.setBackground(bgColor);
		body.setBackground(bgColor);
		topSection.setBackground(bgColor);
		nameLabelPanel.setBackground(bgColor);
		topRightPanel.setBackground(bgColor);
		descriptionArea.setBackground(bgColor);

		// Update all nested panels
		updateComponentBackgrounds(body, bgColor);
		updateComponentBackgrounds(expandedPanel, bgColor);
	}

	private void updateComponentBackgrounds(Container parent, Color bgColor)
	{
		for (Component comp : parent.getComponents())
		{
			if (comp instanceof JPanel)
			{
				comp.setBackground(bgColor);
				if (comp instanceof Container)
				{
					updateComponentBackgrounds((Container) comp, bgColor);
				}
			}
			else if (comp instanceof JTextArea)
			{
				comp.setBackground(bgColor);
			}
		}
	}

	private void addMouseListenerRecursively(Container parent, MouseAdapter listener)
	{
		parent.addMouseListener(listener);
		for (Component comp : parent.getComponents())
		{
			if (comp == trackButton)
			{
				continue;
			}
			comp.addMouseListener(listener);
			if (comp instanceof Container)
			{
				addMouseListenerRecursively((Container) comp, listener);
			}
		}
	}

	private void toggleExpanded()
	{
		isExpanded = !isExpanded;
		expandedPanel.setVisible(isExpanded);

		if (isExpanded)
		{
			descriptionArea.setText(achievement.getDescription());
		}
		else
		{
			descriptionArea.setText(truncateToTwoLines(achievement.getDescription()));
		}

		revalidate();
		repaint();
	}

	private String createTooltip()
	{
		StringBuilder tooltip = new StringBuilder();
		tooltip.append("<html><div style='width: 300px;'>");
		tooltip.append("<b>").append(achievement.getName()).append("</b><br>");
		tooltip.append(achievement.getDescription()).append("<br><br>");
		tooltip.append("Tier: ").append(achievement.getTier()).append("<br>");
		tooltip.append("Points: ").append(achievement.getPoints()).append("<br>");
		if (achievement.getBossName() != null)
		{
			tooltip.append("Boss: ").append(achievement.getBossName()).append("<br>");
		}
		if (achievement.getType() != null)
		{
			tooltip.append("Type: ").append(achievement.getType()).append("<br>");
		}

		if (achievement.getCompletionPercentage() != null)
		{
			tooltip.append("Wiki Completion%: ").append(String.format("%.1f%%", achievement.getCompletionPercentage())).append("<br>");
		}
		else
		{
			tooltip.append("Wiki Completion%: Unknown<br>");
		}

		if (achievement.isCompleted())
		{
			tooltip.append("<br><font color='green'>Completed</font>");
		}
		else
		{
			tooltip.append("<br><font color='red'>Incomplete</font>");
		}
		if (achievement.isTracked())
		{
			tooltip.append("<br><font color=#6495ED>Tracked</font>");
		}
		tooltip.append("</html>");
		return tooltip.toString();
	}

	public void refresh()
	{
		SwingUtilities.invokeLater(() ->
		{
			nameLabel.setText(achievement.getName());
			nameLabel.setForeground(getNameColor());

			setupTierIcon();
			updateAllBackgrounds(getBackgroundColor());
			updateTrackButton();
			revalidate();
			repaint();
		});
	}

	@Override
	public Dimension getMaximumSize()
	{
		return new Dimension(PluginPanel.PANEL_WIDTH - 20, getPreferredSize().height);
	}

	@Override
	public Dimension getPreferredSize()
	{
		return new Dimension(PluginPanel.PANEL_WIDTH - 20, super.getPreferredSize().height);
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.ui;

import com.catracker.CombatAchievementsPlugin;
import com.catracker.config.CombatAchievementsConfig;
import com.catracker.model.BossStats;
import com.catracker.model.CombatAchievement;
import com.catracker.ui.components.BossGridPanel;
import com.catracker.ui.components.FilterPanel;
import com.catracker.ui.components.StatsPanel;
import com.catracker.ui.util.IconLoader;
import com.google.gson.reflect.TypeToken;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
public class CombatAchievementsPanel extends PluginPanel
{
	private final CombatAchievementsPlugin plugin;

	private ViewMode currentViewMode = ViewMode.ALL_TASKS;
	private String selectedBoss = null;
	private CombatAchievement selectedAchievement = null;

	@Getter
	private final IconTextField searchBar;
	private final JPanel headerPanel = new JPanel(new BorderLayout());
	private final JButton togglePanelsButton = new JButton();
	private final JPanel tabButtonsPanel = new JPanel();
	private final JButton allTasksButton = new JButton("All Tasks");
	private final JButton trackedTasksButton = new JButton("Tracked");
	private final JButton bossesButton = new JButton("Bosses");
	private final JScrollPane contentScrollPane = new JScrollPane();
	private final JPanel contentContainer = new JPanel();
	private final JPanel bossHeaderPanel = new JPanel(new BorderLayout());
	private final JButton backButton = new JButton();
	private final JLabel bossTitle = new JLabel();

	private final StatsPanel statsPanel;
	private final FilterPanel filterPanel;
	private final BossGridPanel bossGridPanel;

	private static final ImageIcon LEFT_ARROW;
	private static final ImageIcon HIDE_ICON;
	private static final ImageIcon SHOW_ICON;
	private static final ImageIcon HIDE_ICON_HOVER;
	private static final ImageIcon SHOW_ICON_HOVER;

	static
	{
		ImageIcon rightArrow = IconLoader.loadArrowRight();
		BufferedImage rightArrowImg = (BufferedImage) rightArrow.getImage();
		LEFT_ARROW = new ImageIcon(ImageUtil.rotateImage(rightArrowImg, Math.PI));

		BufferedImage hideImg = ImageUtil.loadImageResource(CombatAchievementsPlugin.class, "hide.png");
		BufferedImage showImg = ImageUtil.loadImageResource(CombatAchievementsPlugin.class, "show.png");
		HIDE_ICON = new ImageIcon(ImageUtil.resizeImage(hideImg, 16, 16));
		SHOW_ICON = new ImageIcon(ImageUtil.resizeImage(showImg, 16, 16));
		HIDE_ICON_HOVER = new ImageIcon(ImageUtil.resizeImage(ImageUtil.luminanceScale(hideImg, 1.5f), 16, 16));
		SHOW_ICON_HOVER = new ImageIcon(ImageUtil.resizeImage(ImageUtil.luminanceScale(showImg, 1.5f), 16, 16));
	}

	private List<CombatAchievement> allAchievements = new ArrayList<>();
	private List<CombatAchievement> trackedAchievements = new ArrayList<>();
	private String currentSearchText = "";
	private final Map<Integer, CombatAchievementPanel> achievementPanels = new HashMap<>();
	private boolean statsAndFiltersVisible = true;

	private enum ViewMode
	{
		ALL_TASKS,
		TRACKED_TASKS,
		BOSSES
	}

	public CombatAchievementsPanel(CombatAchievementsPlugin plugin)
	{
		super(false);
		this.plugin = plugin;

		searchBar = new IconTextField();
		statsPanel = new StatsPanel(plugin);
		filterPanel = new FilterPanel();
		bossGridPanel = new BossGridPanel();

		initializeComponents();
		layoutComponents();
		setupEventHandlers();
		loadSampleData();
		refreshContent();
	}

	private void initializeComponents()
	{
		setupTabButtons();
		setupBossHeader();
		setupSearchBar();
		setupContentContainer();

		filterPanel.setRefreshCallback((v) -> refreshContent());
		bossGridPanel.setBossClickCallback(this::selectBoss);
	}

	private void setupSearchBar()
	{
		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(0, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		searchBar.getDocument().addDocumentListener(new DocumentListener()
		{
			@Override
			public void insertUpdate(DocumentEvent e)
			{
				updateSearchText();
			}

			@Override
			public void removeUpdate(DocumentEvent e)
			{
				updateSearchText();
			}

			@Override
			public void changedUpdate(DocumentEvent e)
			{
				updateSearchText();
			}
		});
	}

	private void updateSearchText()
	{
		currentSearchText = searchBar.getText().toLowerCase();
		refreshContent();
	}

	private void setupTabButtons()
	{
		allTasksButton.setFont(FontManager.getRunescapeSmallFont());
		trackedTasksButton.setFont(FontManager.getRunescapeSmallFont());
		bossesButton.setFont(FontManager.getRunescapeSmallFont());

		styleTabButton(allTasksButton, true);
		styleTabButton(trackedTasksButton, false);
		styleTabButton(bossesButton, false);

		tabButtonsPanel.setLayout(new GridLayout(1, 3, 1, 0));
		tabButtonsPanel.setBorder(new EmptyBorder(5, 10, 8, 10));
		tabButtonsPanel.add(allTasksButton);
		tabButtonsPanel.add(trackedTasksButton);
		tabButtonsPanel.add(bossesButton);
	}

	private void styleTabButton(JButton button, boolean selected)
	{
		if (selected)
		{
			button.setBackground(ColorScheme.BRAND_ORANGE);
			button.setForeground(Color.WHITE);
			button.setBorder(BorderFactory.createCompoundBorder(
				new LineBorder(ColorScheme.BRAND_ORANGE_TRANSPARENT, 2),
				new EmptyBorder(2, 4, 2, 4)
			));
		}
		else
		{
			button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			button.setForeground(Color.LIGHT_GRAY);
			button.setBorder(BorderFactory.createCompoundBorder(
				new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
				new EmptyBorder(2, 4, 2, 4)
			));
		}
		button.setFocusPainted(false);
		button.setOpaque(true);
	}

	private void setupBossHeader()
	{
		bossHeaderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		bossHeaderPanel.setBorder(new EmptyBorder(5, 10, 5, 10));
		bossHeaderPanel.setVisible(false);

		backButton.setIcon(LEFT_ARROW);
		backButton.setFont(FontManager.getRunescapeSmallFont());
		backButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		backButton.setForeground(Color.WHITE);
		backButton.setBorder(new EmptyBorder(5, 10, 5, 10));
		backButton.setFocusPainted(false);
		backButton.addActionListener(e ->
		{
			if (selectedAchievement != null)
			{
				selectedAchievement = null;
			}
			else
			{
				selectedBoss = null;
			}
			refreshContent();
		});

		bossTitle.setFont(FontManager.getRunescapeBoldFont());
		bossTitle.setForeground(ColorScheme.BRAND_ORANGE);
		bossTitle.setHorizontalAlignment(SwingConstants.CENTER);

		bossHeaderPanel.add(backButton, BorderLayout.WEST);
		bossHeaderPanel.add(bossTitle, BorderLayout.CENTER);
	}

	private void setupContentContainer()
	{
		contentContainer.setLayout(new BoxLayout(contentContainer, BoxLayout.Y_AXIS));
		contentContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		contentContainer.setBorder(new EmptyBorder(0, 10, 0, 10));
		contentContainer.setAlignmentX(Component.LEFT_ALIGNMENT);

		contentScrollPane.setViewportView(contentContainer);
		contentScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		contentScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		contentScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		contentScrollPane.setBorder(null);
		contentScrollPane.getVerticalScrollBar().setUnitIncrement(16);
	}

	private void layoutComponents()
	{
		JLabel titleLabel = new JLabel("Combat Achievements");
		titleLabel.setFont(FontManager.getRunescapeBoldFont());
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setBorder(new EmptyBorder(10, 10, 5, 10));

		// Setup toggle button
		togglePanelsButton.setIcon(HIDE_ICON);
		togglePanelsButton.setFont(FontManager.getRunescapeSmallFont());
		togglePanelsButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
		togglePanelsButton.setForeground(Color.WHITE);
		togglePanelsButton.setBorder(new EmptyBorder(5, 10, 5, 10));
		togglePanelsButton.setFocusPainted(false);
		togglePanelsButton.setBorderPainted(false);
		togglePanelsButton.setContentAreaFilled(false);
		togglePanelsButton.setOpaque(false);
		togglePanelsButton.setToolTipText("Hide stats and filters panels");
		togglePanelsButton.addActionListener(e -> toggleStatsAndFilters());

		// Add hover effect
		togglePanelsButton.addMouseListener(new java.awt.event.MouseAdapter()
		{
			@Override
			public void mouseEntered(java.awt.event.MouseEvent e)
			{
				if (statsAndFiltersVisible)
				{
					togglePanelsButton.setIcon(HIDE_ICON_HOVER);
				}
				else
				{
					togglePanelsButton.setIcon(SHOW_ICON_HOVER);
				}
			}

			@Override
			public void mouseExited(java.awt.event.MouseEvent e)
			{
				if (statsAndFiltersVisible)
				{
					togglePanelsButton.setIcon(HIDE_ICON);
				}
				else
				{
					togglePanelsButton.setIcon(SHOW_ICON);
				}
			}
		});

		JPanel titleContainer = new JPanel(new BorderLayout());
		titleContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		titleContainer.add(titleLabel, BorderLayout.CENTER);
		titleContainer.add(togglePanelsButton, BorderLayout.EAST);

		JPanel searchBarContainer = new JPanel(new BorderLayout());
		searchBarContainer.setBorder(new EmptyBorder(6, 10, 6, 10));
		searchBarContainer.add(searchBar, BorderLayout.CENTER);

		headerPanel.add(titleContainer, BorderLayout.CENTER);

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel fixedContent = new JPanel();
		fixedContent.setLayout(new BoxLayout(fixedContent, BoxLayout.Y_AXIS));
		fixedContent.setBackground(ColorScheme.DARK_GRAY_COLOR);

		fixedContent.add(headerPanel);
		fixedContent.add(statsPanel);
		fixedContent.add(filterPanel);
		fixedContent.add(searchBarContainer);
		fixedContent.add(tabButtonsPanel);
		fixedContent.add(bossHeaderPanel);

		add(fixedContent, BorderLayout.NORTH);
		add(contentScrollPane, BorderLayout.CENTER);
	}

	private void setupEventHandlers()
	{
		allTasksButton.addActionListener(e -> switchToView(ViewMode.ALL_TASKS));
		trackedTasksButton.addActionListener(e -> switchToView(ViewMode.TRACKED_TASKS));
		bossesButton.addActionListener(e -> switchToView(ViewMode.BOSSES));
	}

	private void switchToView(ViewMode viewMode)
	{
		currentViewMode = viewMode;
		selectedBoss = null;

		styleTabButton(allTasksButton, viewMode == ViewMode.ALL_TASKS);
		styleTabButton(trackedTasksButton, viewMode == ViewMode.TRACKED_TASKS);
		styleTabButton(bossesButton, viewMode == ViewMode.BOSSES);

		refreshContent();
	}

	private void selectBoss(String bossName)
	{
		selectedBoss = bossName;
		refreshContent();
	}

	public void updateAchievements(List<CombatAchievement> newAchievements)
	{
		log.debug("updateAchievements called with {} achievements", newAchievements.size());
		SwingUtilities.invokeLater(() ->
		{
			allAchievements.clear();
			allAchievements.addAll(newAchievements);
			achievementPanels.clear();
			loadTrackedAchievements();
			refreshContent();
		});
	}

	public void refreshContent()
	{
		refreshContent(true);
	}

	private void refreshContent(boolean resetScrollPosition)
	{
		SwingUtilities.invokeLater(() ->
		{
			contentContainer.removeAll();
			achievementPanels.clear();

			if (selectedAchievement != null)
			{
				bossTitle.setText(selectedAchievement.getName());
				bossHeaderPanel.setVisible(true);
			}
			else if (currentViewMode == ViewMode.BOSSES && selectedBoss != null)
			{
				bossTitle.setText(selectedBoss);
				bossHeaderPanel.setVisible(true);
			}
			else
			{
				bossHeaderPanel.setVisible(false);
			}

			if (selectedAchievement != null)
			{
				displayAchievementDetail();
			}
			else
			{
				switch (currentViewMode)
				{
					case BOSSES:
						if (selectedBoss == null)
						{
							displayBossGrid();
						}
						else
						{
							displayBossAchievements();
						}
						break;
					case ALL_TASKS:
					case TRACKED_TASKS:
						displayAchievementsList();
						break;
				}
			}

			updateStats();
			contentContainer.revalidate();
			contentContainer.repaint();

			if (resetScrollPosition)
			{
				SwingUtilities.invokeLater(() ->
				{
					contentScrollPane.getVerticalScrollBar().setValue(0);
				});
			}
		});
	}

	private void displayBossGrid()
	{
		contentContainer.add(bossGridPanel);
		String statusFilter = filterPanel.getSelectedStatusFilter();
		String typeFilter = filterPanel.getSelectedTypeFilter();
		String sortOption = filterPanel.getSelectedSortFilter();
		boolean sortAscending = filterPanel.isSortAscending();
		Map<String, Boolean> selectedTiers = filterPanel.getSelectedTiers();
		bossGridPanel.displayBossGrid(allAchievements, currentSearchText, statusFilter, typeFilter, sortOption, sortAscending, selectedTiers);
	}

	private void displayBossAchievements()
	{
		if (selectedBoss == null)
		{
			displayBossGrid();
			return;
		}

		List<CombatAchievement> bossAchievements = allAchievements.stream()
			.filter(achievement -> selectedBoss.equals(achievement.getBossName()))
			.collect(Collectors.toList());

		List<CombatAchievement> filteredAchievements = getFilteredAchievements(bossAchievements);
		displayAchievementPanels(filteredAchievements, "No achievements found for " + selectedBoss + " given current filter settings");
	}

	private void displayAchievementDetail()
	{
		if (selectedAchievement == null)
		{
			return;
		}

		// Create outer panel with BorderLayout to anchor content to top
		JPanel outerPanel = new JPanel(new BorderLayout());
		outerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Create detail panel with achievement info
		JPanel detailPanel = new JPanel();
		detailPanel.setLayout(new BoxLayout(detailPanel, BoxLayout.Y_AXIS));
		detailPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		detailPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

		// Add tier icon and name
		JPanel nameSection = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		nameSection.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameSection.setAlignmentX(Component.LEFT_ALIGNMENT);

		ImageIcon tierIcon = com.catracker.ui.util.IconLoader.loadTierIcon(selectedAchievement.getTier());
		if (tierIcon != null)
		{
			JLabel tierIconLabel = new JLabel(tierIcon);
			nameSection.add(tierIconLabel);
		}

		JLabel nameLabel = new JLabel(selectedAchievement.getName());
		nameLabel.setFont(FontManager.getRunescapeBoldFont());
		nameLabel.setForeground(selectedAchievement.isCompleted() ? Color.GREEN :
			selectedAchievement.isTracked() ? new Color(100, 149, 237) : ColorScheme.BRAND_ORANGE);
		nameSection.add(nameLabel);

		detailPanel.add(nameSection);
		detailPanel.add(Box.createVerticalStrut(5));

		// Description
		JTextArea descriptionArea = new JTextArea(selectedAchievement.getDescription());
		descriptionArea.setFont(FontManager.getRunescapeSmallFont());
		descriptionArea.setForeground(Color.LIGHT_GRAY);
		descriptionArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		descriptionArea.setEditable(false);
		descriptionArea.setFocusable(false);
		descriptionArea.setWrapStyleWord(true);
		descriptionArea.setLineWrap(true);
		descriptionArea.setAlignmentX(Component.LEFT_ALIGNMENT);
		descriptionArea.setBorder(new EmptyBorder(0, 0, 3, 0));
		detailPanel.add(descriptionArea);

		// Info rows
		detailPanel.add(createInfoRow("Tier:", selectedAchievement.getTier()));
		detailPanel.add(createInfoRow("Points:", String.valueOf(selectedAchievement.getPoints())));

		if (selectedAchievement.getBossName() != null && !selectedAchievement.getBossName().equals("Unknown"))
		{
			detailPanel.add(createInfoRow("Boss:", selectedAchievement.getBossName()));
		}

		if (selectedAchievement.getType() != null && !selectedAchievement.getType().isEmpty())
		{
			detailPanel.add(createInfoRow("Type:", selectedAchievement.getType()));
		}

		if (selectedAchievement.getCompletionPercentage() != null)
		{
			String completionText = String.format("%.1f%%", selectedAchievement.getCompletionPercentage());
			detailPanel.add(createInfoRow("Wiki Completion%:", completionText));
		}
		else
		{
			detailPanel.add(createInfoRow("Wiki Completion%:", "Unknown"));
		}

		detailPanel.add(Box.createVerticalStrut(5));

		// Status
		JLabel statusLabel = new JLabel();
		statusLabel.setFont(FontManager.getRunescapeSmallFont());
		statusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
		if (selectedAchievement.isCompleted())
		{
			statusLabel.setText("Status: Completed");
			statusLabel.setForeground(Color.GREEN);
		}
		else
		{
			statusLabel.setText("Status: Incomplete");
			statusLabel.setForeground(Color.RED);
		}
		detailPanel.add(statusLabel);

		if (selectedAchievement.isTracked())
		{
			JLabel trackedLabel = new JLabel("Tracked");
			trackedLabel.setFont(FontManager.getRunescapeSmallFont());
			trackedLabel.setForeground(new Color(100, 149, 237));
			trackedLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
			detailPanel.add(trackedLabel);
		}

		detailPanel.add(Box.createVerticalStrut(10));

		// Open in Wiki button
		JButton wikiButton = new JButton("Open in Wiki");
		wikiButton.setFont(FontManager.getRunescapeSmallFont());
		wikiButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		wikiButton.setForeground(Color.WHITE);
		wikiButton.setBorder(BorderFactory.createCompoundBorder(
			new LineBorder(ColorScheme.BRAND_ORANGE, 1),
			new EmptyBorder(5, 10, 5, 10)
		));
		wikiButton.setFocusPainted(false);
		wikiButton.setAlignmentX(Component.LEFT_ALIGNMENT);
		wikiButton.addActionListener(e -> openWikiForAchievement(selectedAchievement));
		detailPanel.add(wikiButton);

		// Add detailPanel to the top (NORTH) of outerPanel
		outerPanel.add(detailPanel, BorderLayout.NORTH);

		contentContainer.add(outerPanel);
	}

	private void openWikiForAchievement(CombatAchievement achievement)
	{
		try
		{
			net.runelite.client.util.LinkBrowser.browse(achievement.getWikiUrl());
		}
		catch (Exception ex)
		{
			log.error("Failed to open wiki link: {}", achievement.getWikiUrl(), ex);
		}
	}

	private JPanel createInfoRow(String label, String value)
	{
		JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT, 0, 0));
		row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		row.setAlignmentX(Component.LEFT_ALIGNMENT);

		JLabel labelComponent = new JLabel(label + " ");
		labelComponent.setFont(FontManager.getRunescapeSmallFont());
		labelComponent.setForeground(Color.LIGHT_GRAY);

		JLabel valueComponent = new JLabel(value);
		valueComponent.setFont(FontManager.getRunescapeSmallFont());
		valueComponent.setForeground(Color.WHITE);

		row.add(labelComponent);
		row.add(valueComponent);

		return row;
	}

	private void displayAchievementsList()
	{
		List<CombatAchievement> baseList = currentViewMode == ViewMode.TRACKED_TASKS ? trackedAchievements : allAchievements;
		List<CombatAchievement> filteredAchievements = getFilteredAchievements(baseList);

		String emptyMessage = currentViewMode == ViewMode.TRACKED_TASKS ?
			"No tracked achievements match current filters" :
			"No achievements match current filters";

		displayAchievementPanels(filteredAchievements, emptyMessage);
	}

	private void displayAchievementPanels(List<CombatAchievement> achievements, String emptyMessage)
	{
		if (achievements.isEmpty())
		{
			JTextArea emptyLabel = new JTextArea(emptyMessage);
			emptyLabel.setFont(FontManager.getRunescapeSmallFont());
			emptyLabel.setForeground(Color.GRAY);
			emptyLabel.setBackground(ColorScheme.DARK_GRAY_COLOR);
			emptyLabel.setEditable(false);
			emptyLabel.setFocusable(false);
			emptyLabel.setWrapStyleWord(true);
			emptyLabel.setLineWrap(true);
			emptyLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
			emptyLabel.setBorder(new EmptyBorder(20, 10, 20, 10));
			contentContainer.add(emptyLabel);
		}
		else
		{
			for (CombatAchievement achievement : achievements)
			{
				try
				{
					CombatAchievementPanel panel = new CombatAchievementPanel(plugin, achievement);
					achievementPanels.put(achievement.getId(), panel);

					panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, panel.getPreferredSize().height));
					panel.setAlignmentX(Component.CENTER_ALIGNMENT);
					contentContainer.add(panel);
				}
				catch (Exception e)
				{
					log.error("Error creating panel for achievement: {}", achievement.getName(), e);
				}
			}
		}
	}

	private List<CombatAchievement> getFilteredAchievements(List<CombatAchievement> sourceList)
	{
		List<CombatAchievement> filtered = sourceList.stream()
			.filter(this::matchesFilters)
			.collect(Collectors.toList());

		String sortOption = filterPanel.getSelectedSortFilter();
		if (sortOption != null)
		{
			switch (sortOption)
			{
				case "Tier":
					if (filterPanel.isSortAscending())
					{
						filtered.sort((a, b) -> Integer.compare(a.getTierLevel().getOrder(), b.getTierLevel().getOrder()));
					}
					else
					{
						filtered.sort((a, b) -> Integer.compare(b.getTierLevel().getOrder(), a.getTierLevel().getOrder()));
					}
					break;
				case "Points":
					if (filterPanel.isSortAscending())
					{
						filtered.sort((a, b) -> Integer.compare(a.getPoints(), b.getPoints()));
					}
					else
					{
						filtered.sort((a, b) -> Integer.compare(b.getPoints(), a.getPoints()));
					}
					break;
				case "Name":
					if (filterPanel.isSortAscending())
					{
						filtered.sort((a, b) -> a.getName().compareTo(b.getName()));
					}
					else
					{
						filtered.sort((a, b) -> b.getName().compareTo(a.getName()));
					}
					break;
				case "Completion":
					if (filterPanel.isSortAscending())
					{
						filtered.sort((a, b) -> Boolean.compare(a.isCompleted(), b.isCompleted()));
					}
					else
					{
						filtered.sort((a, b) -> Boolean.compare(b.isCompleted(), a.isCompleted()));
					}
					break;
				case "Completion %":
					filtered.sort((a, b) ->
					{
						Double aComp = a.getCompletionPercentage();
						Double bComp = b.getCompletionPercentage();
						if (aComp == null && bComp == null) return 0;
						if (aComp == null) return 1;
						if (bComp == null) return -1;
						if (filterPanel.isSortAscending())
						{
							return Double.compare(bComp, aComp);
						}
						else
						{
							return Double.compare(aComp, bComp);
						}
					});
					break;
				default:
					filtered.sort((a, b) ->
					{
						int tierComparison = Integer.compare(a.getTierLevel().getOrder(), b.getTierLevel().getOrder());
						return tierComparison == 0 ? a.getName().compareTo(b.getName()) : tierComparison;
					});
			}
		}
		return filtered;
	}

	private boolean matchesFilters(CombatAchievement achievement)
	{
		if (!currentSearchText.isEmpty() &&
			!achievement.getName().toLowerCase().contains(currentSearchText) &&
			!achievement.getDescription().toLowerCase().contains(currentSearchText))
		{
			return false;
		}

		if (!filterPanel.getSelectedTiers().getOrDefault(achievement.getTier(), true))
		{
			return false;
		}

		String selectedStatus = filterPanel.getSelectedStatusFilter();
		if ("Completed".equals(selectedStatus) && !achievement.isCompleted())
		{
			return false;
		}
		if ("Incomplete".equals(selectedStatus) && achievement.isCompleted())
		{
			return false;
		}

		String selectedType = filterPanel.getSelectedTypeFilter();
		if (!"All Types".equals(selectedType))
		{
			String achievementType = achievement.getType();
			if (achievementType == null || !achievementType.equals(selectedType))
			{
				return false;
			}
		}

		return true;
	}

	private void updateStats()
	{
		if (currentViewMode == ViewMode.BOSSES && selectedBoss == null)
		{
			Map<String, BossStats> bossStatsMap = calculateBossStats();
			statsPanel.updateBossStats(bossStatsMap, allAchievements, trackedAchievements);
			return;
		}

		List<CombatAchievement> visibleAchievements;
		if (currentViewMode == ViewMode.TRACKED_TASKS)
		{
			visibleAchievements = trackedAchievements;
		}
		else if (selectedBoss != null)
		{
			visibleAchievements = allAchievements.stream()
				.filter(achievement -> selectedBoss.equals(achievement.getBossName()))
				.collect(Collectors.toList());
		}
		else
		{
			visibleAchievements = getFilteredAchievements(allAchievements);
		}

		String viewContext = getViewContext();
		statsPanel.updateStats(allAchievements, trackedAchievements, visibleAchievements, viewContext);
	}

	private Map<String, BossStats> calculateBossStats()
	{
		Map<String, BossStats> bossStatsMap = new HashMap<>();
		for (CombatAchievement achievement : allAchievements)
		{
			String bossName = achievement.getBossName();
			if (bossName == null || bossName.equals("Unknown") || bossName.trim().isEmpty())
			{
				continue;
			}
			bossStatsMap.putIfAbsent(bossName, new BossStats());
			BossStats stats = bossStatsMap.get(bossName);
			stats.total++;
			if (achievement.isCompleted())
			{
				stats.completed++;
			}
		}
		return bossStatsMap;
	}

	private String getViewContext()
	{
		if (selectedBoss != null)
		{
			return selectedBoss + " tasks";
		}
		else if (currentViewMode == ViewMode.TRACKED_TASKS)
		{
			return "tracked";
		}
		else
		{
			return "filtered";
		}
	}

	public void saveTrackedAchievements()
	{
		try
		{
			log.debug("saveTrackedAchievements called - current tracked list size: {}", trackedAchievements.size());
			List<Integer> trackedIds = trackedAchievements.stream()
				.map(CombatAchievement::getId)
				.collect(Collectors.toList());
			String trackedJson = plugin.getGson().toJson(trackedIds);
			try
			{
				if (plugin.getConfigManager().getRSProfileKey() != null)
				{
					plugin.getConfigManager().setRSProfileConfiguration(
						CombatAchievementsConfig.CONFIG_GROUP_NAME,
						"trackedAchievements",
						trackedJson
					);
					log.debug("Saved RSProfile tracked achievements");
				}
			}
			catch (Exception e)
			{
				log.error("Config save failed", e);
			}
		}
		catch (Exception e)
		{
			log.error("Failed to save tracked achievements", e);
		}
	}

	public void loadTrackedAchievements()
	{
		// Clear tracked list first to avoid duplicates when reloading
		trackedAchievements.clear();

		try
		{
			String configJson = plugin.getConfigManager().getRSProfileConfiguration(
				CombatAchievementsConfig.CONFIG_GROUP_NAME,
				"trackedAchievements"
			);
			if (configJson != null && !configJson.isEmpty())
			{
				Type listType = new TypeToken<List<Integer>>()
				{
				}.getType();
				List<Integer> configTrackedIds = plugin.getGson().fromJson(configJson, listType);
				for (CombatAchievement achievement : allAchievements)
				{
					if (configTrackedIds.contains(achievement.getId()))
					{
						achievement.setTracked(true);
						trackedAchievements.add(achievement);
					}
				}
			}
		}
		catch (Exception e)
		{
			log.debug("config not found or invalid: {}", e.getMessage());
		}
	}

	public void clearAllConfigData()
	{
		try
		{
			plugin.getConfigManager().unsetRSProfileConfiguration(
				CombatAchievementsConfig.CONFIG_GROUP_NAME,
				"trackedAchievements"
			);
		}
		catch (Exception e)
		{
			log.debug("Failed to clear");
		}
	}

	public void onAchievementCompleted(String message)
	{
		log.debug("Achievement completed notification: {}", message);
		// Reload tracked achievements to sync with updated allAchievements data
		loadTrackedAchievements();
		refreshContent();
	}

	public void addToTracked(CombatAchievement achievement)
	{
		log.debug("addToTracked called for: {} (ID: {})", achievement.getName(), achievement.getId());
		if (!trackedAchievements.contains(achievement))
		{
			trackedAchievements.add(achievement);
			achievement.setTracked(true);
			CombatAchievementPanel panel = achievementPanels.get(achievement.getId());
			if (panel != null)
			{
				panel.refresh();
			}

			updateStatsOnly();
			saveTrackedAchievements();
		}
	}

	public void removeFromTracked(CombatAchievement achievement)
	{
		log.debug("removeFromTracked called for: {} (ID: {})", achievement.getName(), achievement.getId());
		if (trackedAchievements.remove(achievement))
		{
			achievement.setTracked(false);
			CombatAchievementPanel panel = achievementPanels.get(achievement.getId());
			if (panel != null)
			{
				panel.refresh();
			}

			updateStatsOnly();
			saveTrackedAchievements();

			if (currentViewMode == ViewMode.TRACKED_TASKS)
			{
				refreshContent(false);
			}
		}
	}

	private void updateStatsOnly()
	{
		SwingUtilities.invokeLater(this::updateStats);
	}

	private void loadSampleData()
	{
	}

	public void refreshCombatAchievements()
	{
		plugin.refreshCombatAchievements();
	}

	public List<CombatAchievement> getAllAchievements()
	{
		return allAchievements;
	}

	private void toggleStatsAndFilters()
	{
		statsAndFiltersVisible = !statsAndFiltersVisible;
		statsPanel.setVisible(statsAndFiltersVisible);
		filterPanel.setVisible(statsAndFiltersVisible);

		// Update the toggle button icon and tooltip
		// Check if mouse is over the button to show hover icon
		boolean isMouseOver = togglePanelsButton.getModel().isRollover();
		if (statsAndFiltersVisible)
		{
			togglePanelsButton.setIcon(isMouseOver ? HIDE_ICON_HOVER : HIDE_ICON);
			togglePanelsButton.setToolTipText("Hide stats and filters panels");
		}
		else
		{
			togglePanelsButton.setIcon(isMouseOver ? SHOW_ICON_HOVER : SHOW_ICON);
			togglePanelsButton.setToolTipText("Show stats and filters panels");
		}

		revalidate();
		repaint();
	}

	public void onConfigChanged()
	{
		SwingUtilities.invokeLater(() ->
		{
			statsPanel.updateLayout();
			revalidate();
			repaint();
		});
	}

	public void openInBossesTab(String bossName)
	{
		SwingUtilities.invokeLater(() ->
		{
			// Switch to bosses view
			currentViewMode = ViewMode.BOSSES;
			selectedBoss = bossName;

			styleTabButton(allTasksButton, false);
			styleTabButton(trackedTasksButton, false);
			styleTabButton(bossesButton, true);

			// Refresh content to show the boss achievements
			refreshContent();
		});
	}

	public void showAchievementDetail(CombatAchievement achievement)
	{
		SwingUtilities.invokeLater(() ->
		{
			selectedAchievement = achievement;
			refreshContent();
		});
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.ui.components;

import com.catracker.model.BossStats;
import com.catracker.model.CombatAchievement;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Panel that displays the boss grid view with completion statistics
 */
public class BossGridPanel extends JPanel
{

	private Consumer<String> bossClickCallback;

	public BossGridPanel()
	{
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setAlignmentX(Component.CENTER_ALIGNMENT);
	}

	public void setBossClickCallback(Consumer<String> callback)
	{
		this.bossClickCallback = callback;
	}

	public void displayBossGrid(List<CombatAchievement> allAchievements, String currentSearchText,
								String statusFilter, String typeFilter, String sortOption, boolean sortAscending,
								Map<String, Boolean> selectedTiers)
	{
		removeAll();

		Map<String, BossStats> bossStatsMap = calculateBossStats(allAchievements);

		if (bossStatsMap.isEmpty())
		{
			JLabel emptyLabel = new JLabel("No boss data available");
			emptyLabel.setFont(FontManager.getRunescapeSmallFont());
			emptyLabel.setForeground(Color.GRAY);
			emptyLabel.setHorizontalAlignment(JLabel.CENTER);
			emptyLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
			emptyLabel.setBorder(new EmptyBorder(20, 10, 20, 10));
			add(emptyLabel);
			return;
		}

		List<String> filteredBosses = bossStatsMap.keySet().stream()
			.filter(boss -> boss != null && !boss.equals("Unknown") && !boss.trim().isEmpty())
			.filter(boss -> matchesBossSearch(boss, currentSearchText))
			.filter(boss -> matchesBossStatus(boss, bossStatsMap.get(boss), statusFilter))
			.filter(boss -> matchesBossType(boss, allAchievements, typeFilter))
			.filter(boss -> matchesBossTiers(boss, allAchievements, selectedTiers))
			.collect(Collectors.toList());

		List<String> sortedBosses = sortBosses(filteredBosses, bossStatsMap, allAchievements, sortOption, sortAscending);

		if (sortedBosses.isEmpty())
		{
			JLabel emptyLabel = new JLabel("No bosses match search criteria");
			emptyLabel.setFont(FontManager.getRunescapeSmallFont());
			emptyLabel.setForeground(Color.GRAY);
			emptyLabel.setHorizontalAlignment(JLabel.CENTER);
			emptyLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
			emptyLabel.setBorder(new EmptyBorder(20, 10, 20, 10));
			add(emptyLabel);
			return;
		}

		for (int i = 0; i < sortedBosses.size(); i += 2)
		{
			JPanel rowPanel = new JPanel(new GridLayout(1, 2, 10, 0));
			rowPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
			rowPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 80));
			rowPanel.setBorder(new EmptyBorder(5, 0, 5, 0));

			String boss1 = sortedBosses.get(i);
			BossStats stats1 = bossStatsMap.get(boss1);
			rowPanel.add(createBossCard(boss1, stats1));

			if (i + 1 < sortedBosses.size())
			{
				String boss2 = sortedBosses.get(i + 1);
				BossStats stats2 = bossStatsMap.get(boss2);
				rowPanel.add(createBossCard(boss2, stats2));
			}
			else
			{
				JPanel emptyCard = new JPanel();
				emptyCard.setBackground(ColorScheme.DARK_GRAY_COLOR);
				rowPanel.add(emptyCard);
			}

			add(rowPanel);
		}

		revalidate();
		repaint();
	}

	private JPanel createBossCard(String bossName, BossStats stats)
	{
		JPanel card = new JPanel();
		card.setLayout(new BorderLayout());
		card.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		card.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		card.setPreferredSize(new Dimension(0, 70));
		card.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

		JLabel nameLabel = new JLabel(bossName);
		nameLabel.setFont(FontManager.getRunescapeSmallFont());
		nameLabel.setForeground(ColorScheme.BRAND_ORANGE);
		nameLabel.setHorizontalAlignment(SwingConstants.CENTER);
		nameLabel.setBorder(new EmptyBorder(8, 5, 2, 5));

		JLabel progressLabel = new JLabel(stats.completed + "/" + stats.total);
		progressLabel.setFont(FontManager.getRunescapeSmallFont());
		progressLabel.setForeground(Color.WHITE);
		progressLabel.setHorizontalAlignment(SwingConstants.CENTER);

		JProgressBar progressBar = new JProgressBar(0, stats.total);
		progressBar.setValue(stats.completed);
		progressBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
		progressBar.setForeground(stats.completed == stats.total ? Color.GREEN :
			stats.completed > 0 ? Color.YELLOW : Color.GRAY);
		progressBar.setBorderPainted(false);
		progressBar.setPreferredSize(new Dimension(0, 4));

		JPanel bottomSection = new JPanel(new BorderLayout());
		bottomSection.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		bottomSection.add(progressLabel, BorderLayout.CENTER);
		bottomSection.add(progressBar, BorderLayout.SOUTH);
		bottomSection.setBorder(new EmptyBorder(0, 5, 8, 5));

		card.add(nameLabel, BorderLayout.NORTH);
		card.add(bottomSection, BorderLayout.SOUTH);

		card.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					showContextMenu(e, bossName);
				}
				else if (SwingUtilities.isLeftMouseButton(e))
				{
					if (bossClickCallback != null)
					{
						bossClickCallback.accept(bossName);
					}
				}
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				if (e.isPopupTrigger())
				{
					showContextMenu(e, bossName);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				card.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
				bottomSection.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				card.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				bottomSection.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		return card;
	}

	private void showContextMenu(MouseEvent e, String bossName)
	{
		JPopupMenu popup = new JPopupMenu();

		JMenuItem wikiItem = new JMenuItem("Open Wiki");
		wikiItem.addActionListener(event -> openBossWiki(bossName));
		popup.add(wikiItem);

		popup.show(e.getComponent(), e.getX(), e.getY());
	}

	private void openBossWiki(String bossName)
	{
		try
		{
			String wikiUrl = "https://oldschool.runescape.wiki/w/Special:Search?search=" +
				java.net.URLEncoder.encode(bossName, "UTF-8");
			net.runelite.client.util.LinkBrowser.browse(wikiUrl);
		}
		catch (Exception ex)
		{
			// Log error if needed
		}
	}

	private Map<String, BossStats> calculateBossStats(List<CombatAchievement> allAchievements)
	{
		Map<String, BossStats> bossStatsMap = new HashMap<>();
		for (CombatAchievement achievement : allAchievements)
		{
			String bossName = achievement.getBossName();
			if (bossName == null || bossName.equals("Unknown") || bossName.trim().isEmpty())
			{
				continue;
			}
			bossStatsMap.putIfAbsent(bossName, new BossStats());
			BossStats stats = bossStatsMap.get(bossName);
			stats.total++;
			if (achievement.isCompleted())
			{
				stats.completed++;
			}
		}
		return bossStatsMap;
	}

	private boolean matchesBossSearch(String bossName, String searchText)
	{
		if (searchText == null || searchText.isEmpty())
		{
			return true;
		}
		return bossName.toLowerCase().contains(searchText.toLowerCase());
	}

	private boolean matchesBossStatus(String bossName, BossStats stats, String statusFilter)
	{
		if (statusFilter == null || statusFilter.equals("All"))
		{
			return true;
		}

		boolean isFullyCompleted = stats.completed == stats.total && stats.total > 0;

		if (statusFilter.equals("Completed"))
		{
			return isFullyCompleted;
		}
		else if (statusFilter.equals("Incomplete"))
		{
			return !isFullyCompleted;
		}

		return true;
	}

	private boolean matchesBossType(String bossName, List<CombatAchievement> allAchievements, String typeFilter)
	{
		if (typeFilter == null || typeFilter.equals("All Types"))
		{
			return true;
		}

		// Check if any achievement for this boss has the specified type
		return allAchievements.stream()
			.filter(achievement -> bossName.equals(achievement.getBossName()))
			.anyMatch(achievement -> typeFilter.equals(achievement.getType()));
	}

	private boolean matchesBossTiers(String bossName, List<CombatAchievement> allAchievements, Map<String, Boolean> selectedTiers)
	{
		if (selectedTiers == null || selectedTiers.isEmpty())
		{
			return true;
		}

		// Check if any achievement for this boss has a tier that is selected
		return allAchievements.stream()
			.filter(achievement -> bossName.equals(achievement.getBossName()))
			.anyMatch(achievement -> selectedTiers.getOrDefault(achievement.getTier(), false));
	}

	private List<String> sortBosses(List<String> bosses, Map<String, BossStats> bossStatsMap,
									 List<CombatAchievement> allAchievements, String sortOption, boolean sortAscending)
	{
		if (sortOption == null || sortOption.equals("Tier"))
		{
			// Default alphabetical sort
			bosses.sort(String::compareTo);
			if (!sortAscending)
			{
				java.util.Collections.reverse(bosses);
			}
			return bosses;
		}

		switch (sortOption)
		{
			case "Name":
				bosses.sort(String::compareTo);
				if (!sortAscending)
				{
					java.util.Collections.reverse(bosses);
				}
				break;

			case "Completion":
				bosses.sort((a, b) -> {
					BossStats statsA = bossStatsMap.get(a);
					BossStats statsB = bossStatsMap.get(b);
					boolean aComplete = statsA.completed == statsA.total && statsA.total > 0;
					boolean bComplete = statsB.completed == statsB.total && statsB.total > 0;

					if (sortAscending)
					{
						// Incomplete first, then complete
						return Boolean.compare(aComplete, bComplete);
					}
					else
					{
						// Complete first, then incomplete
						return Boolean.compare(bComplete, aComplete);
					}
				});
				break;

			case "Completion %":
				bosses.sort((a, b) -> {
					double avgA = getAverageCompletionPercent(a, allAchievements);
					double avgB = getAverageCompletionPercent(b, allAchievements);

					if (sortAscending)
					{
						// Ascending: highest first
						return Double.compare(avgB, avgA);
					}
					else
					{
						// Descending: lowest first
						return Double.compare(avgA, avgB);
					}
				});
				break;

			default:
				bosses.sort(String::compareTo);
				if (!sortAscending)
				{
					java.util.Collections.reverse(bosses);
				}
				break;
		}

		return bosses;
	}

	private double getAverageCompletionPercent(String bossName, List<CombatAchievement> allAchievements)
	{
		List<CombatAchievement> bossAchievements = allAchievements.stream()
			.filter(achievement -> bossName.equals(achievement.getBossName()))
			.collect(Collectors.toList());

		if (bossAchievements.isEmpty())
		{
			return 0.0;
		}

		double sum = 0.0;
		int count = 0;

		for (CombatAchievement achievement : bossAchievements)
		{
			Double completionPercent = achievement.getCompletionPercentage();
			if (completionPercent != null)
			{
				sum += completionPercent;
				count++;
			}
		}

		return count > 0 ? sum / count : 0.0;
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.ui.components;

import com.catracker.CombatAchievementsPlugin;
import com.catracker.config.CombatAchievementsConfig;
import com.catracker.model.BossStats;
import com.catracker.model.CombatAchievement;
import com.catracker.util.TierUtil;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.util.List;
import java.util.Map;

/**
 * Panel that displays statistics about combat achievements progress
 */
public class StatsPanel extends JPanel
{

	private final CombatAchievementsPlugin plugin;

	private final JLabel totalPointsLabel = new JLabel("Total Points: 0");
	private final JLabel trackedPointsLabel = new JLabel("Tracked: 0");
	private final JLabel goalLabel = new JLabel("Progress: 0/50");

	public StatsPanel(CombatAchievementsPlugin plugin)
	{
		this.plugin = plugin;
		initializePanel();
	}

	private void initializePanel()
	{
		updateLayout();
	}

	public void updateLayout()
	{
		removeAll();

		boolean compactMode = plugin.getConfig().preferSmallerStatsPanel();

		if (compactMode)
		{
			setLayout(new BorderLayout());
			setBorder(new EmptyBorder(5, 10, 5, 10));
			add(createCompactStatsPanel(), BorderLayout.CENTER);
		}
		else
		{
			setLayout(new GridLayout(3, 1, 0, 5));
			setBorder(new EmptyBorder(8, 10, 8, 10));

			setupStatsLabels();

			JPanel totalCard = createStatCard("Total Progress", totalPointsLabel, ColorScheme.BRAND_ORANGE, false);
			JPanel trackedCard = createStatCard("Tracked Tasks", trackedPointsLabel, new Color(100, 149, 237), false);
			JPanel goalCard = createStatCard("Goal Progress", goalLabel, new Color(200, 120, 255), false);

			add(totalCard);
			add(trackedCard);
			add(goalCard);
		}

		setBackground(ColorScheme.DARK_GRAY_COLOR);
		revalidate();
		repaint();
	}

	private JPanel createCompactStatsPanel()
	{
		setupStatsLabels();

		JPanel compactPanel = new JPanel();
		compactPanel.setLayout(new BoxLayout(compactPanel, BoxLayout.Y_AXIS));
		compactPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		compactPanel.setBorder(BorderFactory.createCompoundBorder(
			new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
			new EmptyBorder(4, 6, 4, 6)
		));

		// Total Progress Row
		JPanel totalRow = createCompactRow(totalPointsLabel, ColorScheme.BRAND_ORANGE);
		compactPanel.add(totalRow);

		// Tracked Tasks Row
		JPanel trackedRow = createCompactRow(trackedPointsLabel, new Color(100, 149, 237));
		compactPanel.add(trackedRow);

		// Goal Progress Row
		JPanel goalRow = createCompactRow(goalLabel, new Color(200, 120, 255));
		compactPanel.add(goalRow);

		return compactPanel;
	}

	private JPanel createCompactRow(JLabel label, Color accentColor)
	{
		JPanel row = new JPanel(new BorderLayout());
		row.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		row.setBorder(new EmptyBorder(2, 0, 2, 0));

		JPanel accentLine = new JPanel();
		accentLine.setBackground(accentColor);
		accentLine.setPreferredSize(new Dimension(3, 0));

		label.setHorizontalAlignment(SwingConstants.LEFT);
		label.setBorder(new EmptyBorder(0, 6, 0, 0));

		row.add(accentLine, BorderLayout.WEST);
		row.add(label, BorderLayout.CENTER);

		return row;
	}

	private void setupStatsLabels()
	{
		totalPointsLabel.setFont(FontManager.getRunescapeSmallFont());
		totalPointsLabel.setForeground(Color.WHITE);

		trackedPointsLabel.setFont(FontManager.getRunescapeSmallFont());
		trackedPointsLabel.setForeground(new Color(100, 149, 237));

		goalLabel.setFont(FontManager.getRunescapeSmallFont());
		goalLabel.setForeground(new Color(200, 120, 255));
	}

	private JPanel createStatCard(String title, JLabel valueLabel, Color accentColor, boolean compactMode)
	{
		JPanel card = new JPanel(new BorderLayout());
		card.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		if (compactMode)
		{
			card.setBorder(BorderFactory.createCompoundBorder(
				new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
				new EmptyBorder(4, 6, 4, 6)
			));
		}
		else
		{
			card.setBorder(BorderFactory.createCompoundBorder(
				new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
				new EmptyBorder(6, 8, 6, 8)
			));
		}

		JLabel titleLabel = new JLabel(title);
		titleLabel.setFont(FontManager.getRunescapeSmallFont());
		titleLabel.setForeground(Color.LIGHT_GRAY);
		titleLabel.setHorizontalAlignment(SwingConstants.LEFT);

		valueLabel.setHorizontalAlignment(SwingConstants.LEFT);
		valueLabel.setFont(FontManager.getRunescapeSmallFont());
		valueLabel.setBorder(null);

		JPanel accentLine = new JPanel();
		accentLine.setBackground(accentColor);
		accentLine.setPreferredSize(new Dimension(3, 0));

		JPanel content = new JPanel(new GridLayout(2, 1, 0, compactMode ? 1 : 2));
		content.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		content.setBorder(new EmptyBorder(0, compactMode ? 6 : 8, 0, 0));
		content.add(titleLabel);
		content.add(valueLabel);

		card.add(accentLine, BorderLayout.WEST);
		card.add(content, BorderLayout.CENTER);

		return card;
	}

	/**
	 * Update stats for regular view (all tasks or tracked tasks)
	 */
	public void updateStats(List<CombatAchievement> allAchievements,
							List<CombatAchievement> trackedAchievements,
							List<CombatAchievement> visibleAchievements,
							String viewContext)
	{

		int totalCompletedPoints = allAchievements.stream()
			.filter(CombatAchievement::isCompleted)
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		int allTotalPoints = allAchievements.stream()
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		int totalTrackedPoints = trackedAchievements.stream()
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		int completedTrackedPoints = trackedAchievements.stream()
			.filter(CombatAchievement::isCompleted)
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		CombatAchievementsConfig.TierGoal tierGoal = plugin.getTierGoal();
		int pointGoal = TierUtil.getPointsFromGoal(tierGoal, totalCompletedPoints);
		String actualTierName = TierUtil.getActualTierName(tierGoal, totalCompletedPoints);

		boolean compactMode = plugin.getConfig().preferSmallerStatsPanel();

		if (compactMode)
		{
			totalPointsLabel.setText("Total: " + totalCompletedPoints + "/" + allTotalPoints + " pts" +
				" (" + allAchievements.size() + " tasks)");

			trackedPointsLabel.setText("Tracked: " + completedTrackedPoints + "/" +
				totalTrackedPoints + " pts (" + trackedAchievements.size() + " tasks)");
		}
		else
		{
			totalPointsLabel.setText(totalCompletedPoints + "/" + allTotalPoints + " pts" +
				" (" + allAchievements.size() + " tasks)");

			trackedPointsLabel.setText(completedTrackedPoints + "/" +
				totalTrackedPoints + " pts (" + trackedAchievements.size() + " tasks)");
		}

		if (totalCompletedPoints >= pointGoal)
		{
			String goalText = compactMode ? "Goal: " + actualTierName + " Completed! (" + totalCompletedPoints + " pts)" :
				actualTierName + " Completed! (" + totalCompletedPoints + " pts)";
			goalLabel.setText(goalText);
		}
		else
		{
			int remainingPoints = pointGoal - totalCompletedPoints;
			String goalText = compactMode ? "Goal: " + remainingPoints + " pts to " + actualTierName :
				remainingPoints + " pts to " + actualTierName;
			goalLabel.setText(goalText);
		}
	}

	/**
	 * Update stats for boss view
	 */
	public void updateBossStats(Map<String, BossStats> bossStatsMap,
								List<CombatAchievement> allAchievements,
								List<CombatAchievement> trackedAchievements)
	{

		int totalBosses = bossStatsMap.size();
		int completedBosses = (int) bossStatsMap.values().stream()
			.filter(stats -> stats.completed == stats.total && stats.total > 0)
			.count();

		boolean compactMode = plugin.getConfig().preferSmallerStatsPanel();

		if (compactMode)
		{
			totalPointsLabel.setText("Bosses: " + completedBosses + "/" + totalBosses + " complete");
		}
		else
		{
			totalPointsLabel.setText(completedBosses + "/" + totalBosses + " complete");
		}

		int totalTrackedPoints = trackedAchievements.stream()
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		int completedTrackedPoints = trackedAchievements.stream()
			.filter(CombatAchievement::isCompleted)
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		if (compactMode)
		{
			trackedPointsLabel.setText("Tracked: " + completedTrackedPoints + "/" +
				totalTrackedPoints + " pts (" + trackedAchievements.size() + " tasks)");
		}
		else
		{
			trackedPointsLabel.setText(completedTrackedPoints + "/" +
				totalTrackedPoints + " pts (" + trackedAchievements.size() + " tasks)");
		}

		int totalCompletedPoints = allAchievements.stream()
			.filter(CombatAchievement::isCompleted)
			.mapToInt(CombatAchievement::getPoints)
			.sum();

		CombatAchievementsConfig.TierGoal tierGoal = plugin.getTierGoal();
		int pointGoal = TierUtil.getPointsFromGoal(tierGoal, totalCompletedPoints);
		String actualTierName = TierUtil.getActualTierName(tierGoal, totalCompletedPoints);

		if (totalCompletedPoints >= pointGoal)
		{
			String goalText = compactMode ? "Goal: " + actualTierName + " Completed! (" + totalCompletedPoints + " pts)" :
				actualTierName + " Completed! (" + totalCompletedPoints + " pts)";
			goalLabel.setText(goalText);
		}
		else
		{
			int remainingPoints = pointGoal - totalCompletedPoints;
			String goalText = compactMode ? "Goal: " + remainingPoints + " pts to " + actualTierName :
				remainingPoints + " pts to " + actualTierName;
			goalLabel.setText(goalText);
		}
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker.ui.components;

import com.catracker.ui.util.IconLoader;
import java.awt.image.BufferedImage;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;
import net.runelite.client.util.ImageUtil;

/**
 * Panel containing tier toggles and filter dropdowns
 */
public class FilterPanel extends JPanel
{

	private boolean filtersExpanded = false;
	private boolean sortAscending = true;

	private final JPanel filtersSection = new JPanel();
	private final JButton filtersToggleButton = new JButton("Filters");
	private final JPanel filtersPanel = new JPanel();

	private final JComboBox<String> statusFilter = new JComboBox<>();
	private final JComboBox<String> typeFilter = new JComboBox<>();
	private final JComboBox<String> sortFilter = new JComboBox<>();
	private final JButton sortDirectionButton = new JButton();

	private final Map<String, Boolean> selectedTiers = new HashMap<>();
	private Consumer<Void> refreshCallback;

	private static final ImageIcon DOWN_ARROW;
	private static final ImageIcon UP_ARROW;
	private static final ImageIcon SORT_UP_ICON;
	private static final ImageIcon SORT_DOWN_ICON;

	static
	{
		ImageIcon rightArrow = IconLoader.loadArrowRight();
		BufferedImage rightArrowImg = (BufferedImage) rightArrow.getImage();
		DOWN_ARROW = new ImageIcon(ImageUtil.rotateImage(rightArrowImg, Math.PI / 2));
		UP_ARROW = new ImageIcon(ImageUtil.rotateImage(rightArrowImg, -Math.PI / 2));

		SORT_UP_ICON = IconLoader.loadSortUpIcon();
		SORT_DOWN_ICON = IconLoader.loadSortDownIcon();
	}

	public FilterPanel()
	{
		initializeTierFilters();
		initializeComponents();
		layoutComponents();
		setupEventHandlers();
	}

	public void setRefreshCallback(Consumer<Void> callback)
	{
		this.refreshCallback = callback;
	}

	private void initializeTierFilters()
	{
		selectedTiers.put("Easy", true);
		selectedTiers.put("Medium", true);
		selectedTiers.put("Hard", true);
		selectedTiers.put("Elite", true);
		selectedTiers.put("Master", true);
		selectedTiers.put("Grandmaster", true);
	}

	private void initializeComponents()
	{
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		setupFilterDropdowns();
		setupFiltersSection();
	}

	private void setupFilterDropdowns()
	{
		statusFilter.addItem("All");
		statusFilter.addItem("Completed");
		statusFilter.addItem("Incomplete");

		typeFilter.addItem("All Types");
		typeFilter.addItem("Stamina");
		typeFilter.addItem("Perfection");
		typeFilter.addItem("Kill Count");
		typeFilter.addItem("Mechanical");
		typeFilter.addItem("Restriction");
		typeFilter.addItem("Speed");
		typeFilter.addItem("Other");

		sortFilter.addItem("Tier");
		sortFilter.addItem("Name");
		sortFilter.addItem("Completion");
		sortFilter.addItem("Wiki Completion %");

		sortDirectionButton.setPreferredSize(new Dimension(25, 20));
		sortDirectionButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		sortDirectionButton.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		sortDirectionButton.setFocusPainted(false);
		sortDirectionButton.setIcon(SORT_UP_ICON);
	}


	private JToggleButton createTierButton(String tier)
	{
		JToggleButton button = new JToggleButton();
		button.setSelected(true);
		button.setPreferredSize(new Dimension(40, 30));
		button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		button.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		button.setFocusPainted(false);

		ImageIcon icon = IconLoader.loadTierButtonIcon(tier);
		if (icon != null)
		{
			button.setIcon(icon);
		}
		else
		{
			button.setText(tier.substring(0, 1));
			button.setFont(FontManager.getRunescapeSmallFont());
			button.setForeground(Color.WHITE);
		}

		button.setToolTipText(tier + " Tier");
		button.addActionListener(e ->
		{
			selectedTiers.put(tier, button.isSelected());
			updateTierButtonAppearance(button, tier);
			triggerRefresh();
		});

		updateTierButtonAppearance(button, tier);
		return button;
	}

	private void updateTierButtonAppearance(JToggleButton button, String tier)
	{
		if (button.isSelected())
		{
			button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			button.setBorder(new LineBorder(getTierColor(tier), 1));
		}
		else
		{
			button.setBackground(new Color(60, 60, 60));
			button.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		}
	}

	private Color getTierColor(String tier)
	{
		switch (tier.toLowerCase())
		{
			case "easy":
				return new Color(205, 133, 63);
			case "medium":
				return new Color(169, 169, 169);
			case "hard":
				return new Color(105, 105, 105);
			case "elite":
				return new Color(70, 100, 150);
			case "master":
				return new Color(120, 70, 70);
			case "grandmaster":
				return new Color(255, 215, 0);
			default:
				return Color.WHITE;
		}
	}

	private void setupFiltersSection()
	{
		filtersSection.setLayout(new BorderLayout());
		filtersSection.setBorder(new EmptyBorder(0, 10, 5, 10));
		filtersSection.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Create custom toggle button panel
		JPanel filtersTogglePanel = new JPanel(new BorderLayout());
		filtersTogglePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		filtersTogglePanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		filtersTogglePanel.setPreferredSize(new Dimension(0, 30));

		JLabel filtersLabel = new JLabel("Filters");
		filtersLabel.setFont(FontManager.getRunescapeSmallFont());
		filtersLabel.setForeground(Color.WHITE);
		filtersLabel.setBorder(new EmptyBorder(6, 8, 6, 8));

		JLabel filtersArrowLabel = new JLabel();
		filtersArrowLabel.setBorder(new EmptyBorder(6, 8, 6, 8));
		updateFiltersArrow(filtersArrowLabel);

		filtersTogglePanel.add(filtersLabel, BorderLayout.WEST);
		filtersTogglePanel.add(filtersArrowLabel, BorderLayout.EAST);

		// Make the whole panel clickable
		filtersTogglePanel.addMouseListener(new java.awt.event.MouseAdapter()
		{
			@Override
			public void mouseClicked(java.awt.event.MouseEvent e)
			{
				toggleFilters();
				updateFiltersArrow(filtersArrowLabel);
			}
		});

		filtersPanel.setLayout(new GridBagLayout());
		filtersPanel.setBorder(new EmptyBorder(8, 0, 0, 0));
		filtersPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		filtersPanel.setVisible(filtersExpanded);

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.insets = new Insets(2, 0, 2, 0);
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.weightx = 1.0;
		gbc.gridx = 0;

		// Add tiers toggle buttons
		gbc.gridy = 0;
		filtersPanel.add(createTiersRow(), gbc);

		// Add dividing line
		gbc.gridy = 1;
		filtersPanel.add(createDivider(), gbc);

		gbc.gridy = 2;
		filtersPanel.add(createFilterRow("Status", statusFilter), gbc);

		gbc.gridy = 3;
		filtersPanel.add(createFilterRow("Type", typeFilter), gbc);

		gbc.gridy = 4;
		filtersPanel.add(createSortRow(), gbc);

		filtersSection.add(filtersTogglePanel, BorderLayout.NORTH);
		filtersSection.add(filtersPanel, BorderLayout.CENTER);
	}

	private void updateFiltersArrow(JLabel arrowLabel)
	{
		arrowLabel.setIcon(filtersExpanded ? UP_ARROW : DOWN_ARROW);
	}

	private void updateFiltersToggleButton()
	{
		if (filtersExpanded)
		{
			filtersToggleButton.setText("Filters");
			filtersToggleButton.setIcon(UP_ARROW);
			filtersToggleButton.setHorizontalTextPosition(SwingConstants.LEFT);
			filtersToggleButton.setHorizontalAlignment(SwingConstants.LEFT);
			filtersToggleButton.setIconTextGap(100);
		}
		else
		{
			filtersToggleButton.setText("Filters");
			filtersToggleButton.setIcon(DOWN_ARROW);
			filtersToggleButton.setHorizontalTextPosition(SwingConstants.LEFT);
			filtersToggleButton.setHorizontalAlignment(SwingConstants.LEFT);
			filtersToggleButton.setIconTextGap(100);
		}
	}

	private JPanel createFilterRow(String labelText, JComboBox<String> comboBox)
	{
		JPanel row = new JPanel(new BorderLayout(5, 0));
		row.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JLabel label = new JLabel(labelText + ":");
		label.setFont(FontManager.getRunescapeSmallFont());
		label.setForeground(Color.LIGHT_GRAY);
		label.setPreferredSize(new Dimension(50, 20));

		row.add(label, BorderLayout.WEST);
		row.add(comboBox, BorderLayout.CENTER);

		return row;
	}

	private JPanel createTiersRow()
	{
		JPanel tiersPanel = new JPanel(new GridLayout(2, 3, 5, 5));
		tiersPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		tiersPanel.setBorder(new EmptyBorder(0, 0, 8, 0));

		String[] tiers = {"Easy", "Medium", "Hard", "Elite", "Master", "Grandmaster"};
		for (String tier : tiers)
		{
			JToggleButton tierButton = createTierButton(tier);
			tiersPanel.add(tierButton);
		}

		return tiersPanel;
	}

	private JPanel createDivider()
	{
		JPanel dividerContainer = new JPanel(new BorderLayout());
		dividerContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		dividerContainer.setBorder(new EmptyBorder(0, 0, 8, 0));

		JPanel divider = new JPanel();
		divider.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
		divider.setPreferredSize(new Dimension(0, 1));

		dividerContainer.add(divider, BorderLayout.CENTER);
		return dividerContainer;
	}

	private JPanel createSortRow()
	{
		JPanel row = new JPanel(new BorderLayout(5, 0));
		row.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JLabel label = new JLabel("Sort:");
		label.setFont(FontManager.getRunescapeSmallFont());
		label.setForeground(Color.LIGHT_GRAY);
		label.setPreferredSize(new Dimension(50, 20));

		JPanel sortControls = new JPanel(new BorderLayout(3, 0));
		sortControls.setBackground(ColorScheme.DARK_GRAY_COLOR);
		sortControls.add(sortFilter, BorderLayout.CENTER);
		sortControls.add(sortDirectionButton, BorderLayout.EAST);

		row.add(label, BorderLayout.WEST);
		row.add(sortControls, BorderLayout.CENTER);
		return row;
	}

	private void layoutComponents()
	{
		add(filtersSection);
	}

	private void setupEventHandlers()
	{
		filtersToggleButton.addActionListener(e -> toggleFilters());
		sortDirectionButton.addActionListener(e -> toggleSortDirection());

		statusFilter.addActionListener(e -> triggerRefresh());
		typeFilter.addActionListener(e -> triggerRefresh());
		sortFilter.addActionListener(e -> triggerRefresh());
	}

	private void toggleFilters()
	{
		filtersExpanded = !filtersExpanded;
		filtersPanel.setVisible(filtersExpanded);
		revalidate();
		repaint();
	}

	private void toggleSortDirection()
	{
		sortAscending = !sortAscending;
		sortDirectionButton.setIcon(sortAscending ? SORT_UP_ICON : SORT_DOWN_ICON);
		triggerRefresh();
	}

	private void triggerRefresh()
	{
		if (refreshCallback != null)
		{
			refreshCallback.accept(null);
		}
	}

	// Getters for filter values
	public Map<String, Boolean> getSelectedTiers()
	{
		return selectedTiers;
	}

	public String getSelectedStatusFilter()
	{
		return (String) statusFilter.getSelectedItem();
	}

	public String getSelectedTypeFilter()
	{
		return (String) typeFilter.getSelectedItem();
	}

	public String getSelectedSortFilter()
	{
		return (String) sortFilter.getSelectedItem();
	}

	public boolean isSortAscending()
	{
		return sortAscending;
	}
}
/*
 * Copyright (c) 2025, Ethan Hubbartt <ehubbartt@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.catracker;

import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.SwingUtilities;

import com.catracker.config.CombatAchievementsConfig;
import com.catracker.ui.CombatAchievementsPanel;
import com.catracker.util.CombatAchievementsDataLoader;
import com.catracker.util.ChatMessageUtil;
import com.catracker.util.CompletionPercentageLoader;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import okhttp3.OkHttpClient;

import java.awt.image.BufferedImage;

@Slf4j
@PluginDescriptor(
	name = "Combat Achievements Tracker",
	description = "Track and manage combat achievements with filtering, sorting, and progress tracking",
	tags = {"combat", "achievements", "tracker", "progress"}
)
public class CombatAchievementsPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Getter
	@Inject
	private CombatAchievementsConfig config;

	@Getter
	@Inject
	private ConfigManager configManager;

	@Getter
	@Inject
	private Gson gson;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private OkHttpClient okHttpClient;

	@Getter
	private CombatAchievementsPanel panel;

	@Getter
	private CombatAchievementsDataLoader dataLoader;

	@Getter
	private ChatMessageUtil chatMessageUtil;

	private CompletionPercentageLoader completionPercentageLoader;

	private NavigationButton navigationButton;
	private boolean hasLoadedThisSession = false;

	@Override
	protected void startUp() throws Exception
	{
		log.debug("Combat Achievements Tracker starting up...");

		dataLoader = new CombatAchievementsDataLoader(client, clientThread);
		chatMessageUtil = new ChatMessageUtil(chatMessageManager, client);
		completionPercentageLoader = new CompletionPercentageLoader(okHttpClient);
		panel = new CombatAchievementsPanel(this);

		BufferedImage icon = ImageUtil.loadImageResource(CombatAchievementsPlugin.class, "combat_achievements_icon.png");

		navigationButton = NavigationButton.builder()
			.tooltip("Combat Achievements Tracker")
			.icon(icon)
			.priority(6)
			.panel(panel)
			.build();

		clientToolbar.addNavigation(navigationButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		super.shutDown();
		clientToolbar.removeNavigation(navigationButton);
	}


	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		log.debug("Game state changed: {}", gameStateChanged.getGameState());

		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN ||
			gameStateChanged.getGameState() == GameState.CONNECTION_LOST)
		{
			hasLoadedThisSession = false;
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// Handle the case where the plugin is installed while already logged in
		if (client.getGameState() == GameState.LOGGED_IN && !hasLoadedThisSession)
		{
			dataLoader.requestDataLoad();
			hasLoadedThisSession = true;
		}

		dataLoader.handleGameTick(panel, completionPercentageLoader);
	}

	public CombatAchievementsConfig.TierGoal getTierGoal()
	{
		return config.tierGoal();
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		if (chatMessage.getType() == ChatMessageType.GAMEMESSAGE ||
			chatMessage.getType() == ChatMessageType.SPAM)
		{
			String message = chatMessage.getMessage();

			if (message.contains("Congratulations, you've completed") &&
				message.contains("combat task"))
			{
				handleCombatAchievementCompletion(message);
			}
		}
	}

	public void handleCombatAchievementCompletion(String message)
	{
		log.debug("Combat achievement completed: {}", message);

		SwingUtilities.invokeLater(() ->
		{
			if (panel != null)
			{
				// Always refresh data when achievement is completed to update UI
				dataLoader.requestManualRefresh(achievements ->
				{
					SwingUtilities.invokeLater(() ->
					{
						panel.onAchievementCompleted(message);

						if (config.showGoalProgress())
						{
							chatMessageUtil.sendProgressMessage(achievements, getTierGoal());
						}
					});
				});
			}
		});
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (configChanged.getGroup().equals(CombatAchievementsConfig.CONFIG_GROUP_NAME))
		{
			if (configChanged.getKey().equals("preferSmallerStatsPanel"))
			{
				if (panel != null)
				{
					panel.onConfigChanged();
				}
			}
		}
	}

	@Provides
	CombatAchievementsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CombatAchievementsConfig.class);
	}

	public void refreshCombatAchievements()
	{
		if (client != null && client.getGameState() == GameState.LOGGED_IN)
		{
			dataLoader.requestManualRefresh();
			log.debug("Manual refresh requested - will load on next game tick");
		}
		else
		{
			log.warn("Cannot refresh - not logged in");
		}
	}

	public CompletionPercentageLoader getCompletionPercentageLoader()
	{
		return completionPercentageLoader;
	}
}
package com.catracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

/**
 * Test runner for the Combat Achievements plugin
 * This allows running RuneLite with the plugin loaded directly
 */
public class CombatAchievementsPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(CombatAchievementsPlugin.class);

        RuneLite.main(args);
    }
}
