package com.flipper2.helpers;

import com.flipper2.models.Flip;
import com.flipper2.models.Transaction;

import net.runelite.client.RuneLite;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

/**
 * Read/Writes information to json file for storage
 */
public class Persistor
{
	public static Gson gson;
	public static final File PARENT_DIRECTORY = new File(RuneLite.RUNELITE_DIR, "flipper2");
	public static File directory;
	public static final String SELLS_JSON_FILE = "flipper2-sells.json";
	public static final String BUYS_JSON_FILE = "flipper2-buys.json";
	public static final String FLIPS_JSON_FILE = "flipper2-flips.json";

	public static void setUp(String directoryPath) throws IOException
	{
		directory = new File(directoryPath);
		createDirectory(directory);
		createRequiredFiles();
	}

	public static void setUp() throws IOException
	{
		directory = PARENT_DIRECTORY;
		createDirectory(PARENT_DIRECTORY);
		createRequiredFiles();
	}

	/**
	 * Creates the required json files
	 */
	private static void createRequiredFiles() throws IOException
	{
		generateFileIfDoesNotExist(SELLS_JSON_FILE);
		generateFileIfDoesNotExist(BUYS_JSON_FILE);
		generateFileIfDoesNotExist(FLIPS_JSON_FILE);
	}

	private static void generateFileIfDoesNotExist(String filename) throws IOException
	{
		File file = new File(directory, filename);
		if (!file.exists())
		{
			if (!file.createNewFile())
			{
				Log.info("Failed to generate file " + file.getPath());
			}
		}
	}

	private static void createDirectory(File directory) throws IOException
	{
		if (!directory.exists())
		{
			Log.info("Creating flipper2 directory");
			if (!directory.mkdir())
			{
				throw new IOException("unable to create parent directory!");
			}
		}
	}

	public static void saveJson(List<?> list, String filename) throws IOException
	{
		File file = new File(directory, filename);
		final String json = gson.toJson(list);
		Files.write(file.toPath(), json.getBytes());
	}

	private static String getFileContent(String filename) throws IOException
	{
		Path filePath = Paths.get(directory.getAbsolutePath(), filename);
		byte[] fileBytes = Files.readAllBytes(filePath);
		return new String(fileBytes);
	}

	public static boolean saveBuys(List<Transaction> buys)
	{
		try
		{
			saveJson(buys, BUYS_JSON_FILE);
			return true;
		}
		catch (Exception error)
		{
			Log.info("Failed to save buys " + error.toString());
			return false;
		}
	}

	public static boolean saveSells(List<Transaction> sells)
	{
		try
		{
			saveJson(sells, SELLS_JSON_FILE);
			return true;
		}
		catch (Exception error)
		{
			Log.info("Failed to save sells " + error.toString());
			return false;
		}
	}

	public static List<Transaction> loadBuys() throws IOException
	{
		String jsonString = getFileContent(BUYS_JSON_FILE);
		Type type = new TypeToken<List<Transaction>>()
		{
		}.getType();
		List<Transaction> buys = gson.fromJson(jsonString, type);
		if (buys == null)
		{
			return new ArrayList<Transaction>();
		}
		return buys;
	}

	public static List<Transaction> loadSells() throws IOException
	{
		String jsonString = getFileContent(SELLS_JSON_FILE);
		Type type = new TypeToken<List<Transaction>>()
		{
		}.getType();
		List<Transaction> sells = gson.fromJson(jsonString, type);
		if (sells == null)
		{
			return new ArrayList<Transaction>();
		}
		return sells;
	}

	public static boolean saveFlips(List<Flip> flips)
	{
		try
		{
			saveJson(flips, FLIPS_JSON_FILE);
			return true;
		}
		catch (IOException e)
		{
			Log.info("Failed to save flips: " + e.getMessage());
			return false;
		}
	}

	public static List<Flip> loadFlips() throws IOException
	{
		String jsonString = getFileContent(FLIPS_JSON_FILE);
		Type type = new TypeToken<List<Flip>>()
		{
		}.getType();
		List<Flip> flips = gson.fromJson(jsonString, type);
		if (flips == null)
		{
			return new ArrayList<>();
		}
		return flips;
	}
}
package com.flipper2.helpers;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class Timestamps
{
	public static String format(Timestamp timestamp)
	{
		LocalDateTime localDateTime = timestamp.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
		return Timestamps.format(localDateTime);
	}

	public static String format(Instant instant)
	{
		LocalDateTime localDateTime = instant.atZone(ZoneId.systemDefault()).toLocalDateTime();
		return Timestamps.format(localDateTime);
	}

	public static String format(LocalDateTime localDateTime)
	{
		return localDateTime.format(DateTimeFormatter.ofPattern("d MMM h:mm a"));
	}
}

package com.flipper2.helpers;

import lombok.extern.slf4j.Slf4j;

/**
 * Prevents plugin from logging unless in DEV_MODE = true
 * ^not accurate but original dev set this so keeping it anyways
 * modified the Log class since changing DEV_MODE here does nothing
 * Now just acts as a way to log when in debug mode
 */
@Slf4j
public class Log
{
	public static void info(String message)
	{
		log.debug("FLIPPER PLUGIN: " + message);
	}
}

package com.flipper2.helpers;

import com.flipper2.models.Transaction;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;

/**
 * Handles GrandExchange events
 */
public class GrandExchange
{
	public static boolean checkIsBuy(GrandExchangeOfferState state)
	{
		return state == GrandExchangeOfferState.BOUGHT ||
			state == GrandExchangeOfferState.CANCELLED_BUY ||
			state == GrandExchangeOfferState.BUYING;
	}

	public static boolean checkIsComplete(GrandExchangeOfferState state)
	{
		return state == GrandExchangeOfferState.BOUGHT ||
			state == GrandExchangeOfferState.SOLD ||
			state == GrandExchangeOfferState.CANCELLED_SELL ||
			state == GrandExchangeOfferState.CANCELLED_BUY;
	}

	public static boolean checkIsCancelState(GrandExchangeOfferState state)
	{
		return state == GrandExchangeOfferState.CANCELLED_BUY ||
			state == GrandExchangeOfferState.CANCELLED_SELL;
	}

	/**
	 * Potentially creates a transaction based on the GrandExchange event
	 *
	 * @param newOfferEvent
	 * @return null or newly created transaction
	 */
	public static Transaction createTransactionFromOffer(GrandExchangeOffer offer, ItemManager itemManager, int slot)
	{
		GrandExchangeOfferState state = offer.getState();
		boolean isBuy = checkIsBuy(state);
		boolean isComplete = checkIsComplete(state);

		ItemComposition itemComposition = itemManager.getItemComposition(offer.getItemId());
		return new Transaction(
			offer.getQuantitySold(),
			offer.getTotalQuantity(),
			offer.getItemId(),
			offer.getSpent() / (offer.getQuantitySold() > 0 ? offer.getQuantitySold() : 1),
			offer.getPrice(),
			slot,
			itemComposition.getName(),
			isBuy,
			isComplete
		);
	}

	public static boolean checkIsOfferPartOfTransaction(Transaction transaction, GrandExchangeOffer offer, int slot)
	{
		return
			(!transaction.isComplete() || (transaction.isComplete() && GrandExchange.checkIsComplete(offer.getState()))) &&
				transaction.getSlot() == slot &&
				transaction.getItemId() == offer.getItemId() &&
				transaction.getTotalQuantity() == offer.getTotalQuantity();
	}

	public static boolean checkIsSellAFlipOfBuy(Transaction sell, Transaction buy)
	{
		boolean isSameItem = sell.getItemId() == buy.getItemId();
		boolean hasTransactionsBeenFlipped = sell.isFlipped() && buy.isFlipped();
		return isSameItem && !hasTransactionsBeenFlipped;
	}
}
package com.flipper2.helpers;

import java.math.BigInteger;
import java.text.NumberFormat;

public class Numbers
{
	public static String numberWithCommas(int number)
	{
		return NumberFormat.getIntegerInstance().format(number);
	}

	public static String numberWithCommas(String number)
	{
		if (number == "0")
		{
			return "0";
		}

		BigInteger numberAsBigInt = new BigInteger(number);
		return String.format("%,d", numberAsBigInt);
	}

	/**
	 * Shortens a number for display, adding "K", "M", or "B" suffixes as appropriate,
	 * rounding to one decimal place, and omitting the decimal if it's .0.
	 * Correctly handles negative numbers.
	 *
	 * @param number The number to shorten.
	 * @return The shortened number string.
	 */
	public static String toShortNumber(int number)
	{
		if (number > -100000 && number < 100000)
		{

			return numberWithCommas(number);
		}


		String sign = number < 0 ? "-" : "";
		number = Math.abs(number);

		double shortNumber;
		String suffix;

		if (number < 1000000)
		{
			shortNumber = number / 1000.0;
			suffix = "K";
		}
		else if (number < 1000000000)
		{
			shortNumber = number / 1000000.0;
			suffix = "M";
		}
		else
		{
			shortNumber = number / 1000000000.0;
			suffix = "B";
		}

		shortNumber = Math.round(shortNumber * 10.0) / 10.0;

		if (shortNumber == (int) shortNumber)
		{
			return String.format("%s%d%s", sign, (int) shortNumber, suffix);
		}
		else
		{
			return String.format("%s%.1f%s", sign, shortNumber, suffix);
		}
	}
}
package com.flipper2.helpers;

import java.awt.Color;
import java.awt.Dimension;

import javax.swing.BorderFactory;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;

import net.runelite.client.ui.ColorScheme;

public class UiUtilities
{
	public static final Dimension ICON_SIZE = new Dimension(32, 32);
	public static final Border ITEM_INFO_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR),
		BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR.darker(), 4));

	public static String truncateString(String string, int length) {
		if (string.length() > length) {
			return string.substring(0, length) + "...";
		}
		return string;
	}
	public static final String flipperNavIcon = "/flipper_nav_button.png";
	public static final String deleteX = "/delete_x.png";
	public static final String refreshIcon = "/refresh.png";
	public static final String githubIcon = "/github.png";
	public static final int ITEMS_PER_PAGE = 15;


	public static final Color F2_GREEN = Color.decode("#2ea043");
	public static final Color F2_ORANGE = Color.decode("#e78709");
	public static final Color F2_BLUE = Color.decode("#388bfd");
	public static final Color F2_RED = Color.decode("#da3633");
	public static final Color F2_FONT_COLOR = Color.decode("#c9d1d9");
}
package com.flipper2.models;

import lombok.Data;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;

import java.time.Instant;
import java.util.UUID;

import com.flipper2.helpers.GrandExchange;

/**
 * Represents either a buy or sell of an item(s) on the GE
 */
@Data
public class Transaction
{
	public static final double TAX_RATE = 0.01;
	public static final int MAX_TAX = 5000000;

	public final UUID id;
	private int quantity;
	private int totalQuantity;
	private int itemId;
	private int finPricePer;
	private int initPricePer;
	private int slot;
	private String itemName;
	private boolean isBuy;
	private boolean isComplete;
	private boolean isFlipped;
	private boolean isAlched;
	private Instant completedTime;
	private Instant createdTime;
	private boolean hasCancelledOnce = false;
	private GrandExchangeOfferState currentState;

	public Transaction(
		int quantity,
		int totalQuantity,
		int itemId,
		int finPricePer,
		int initPricePer,
		int slot,
		String itemName,
		boolean isBuy,
		boolean isComplete
	)
	{
		id = UUID.randomUUID();
		this.quantity = quantity;
		this.totalQuantity = totalQuantity;
		this.itemId = itemId;
		this.finPricePer = finPricePer;
		this.initPricePer = initPricePer;
		this.slot = slot;
		this.itemName = itemName;
		this.isBuy = isBuy;
		this.isComplete = isComplete;
		this.createdTime = Instant.now();
		this.isFlipped = false;
		this.hasCancelledOnce = false;
	}

	public Transaction updateTransaction(GrandExchangeOffer offer)
	{
		this.quantity = offer.getQuantitySold();
		this.currentState = offer.getState();

		if (offer.getQuantitySold() > 0)
		{
			this.finPricePer = offer.getSpent() / offer.getQuantitySold();
		}
		else
		{
			this.finPricePer = 0;
		}

		boolean isCancelState = GrandExchange.checkIsCancelState(offer.getState());

		if (!isCancelState || (this.hasCancelledOnce && isCancelState))
		{
			this.isComplete = GrandExchange.checkIsComplete(offer.getState());
		}

		if (isCancelState)
		{
			this.hasCancelledOnce = true;
		}

		if (this.isComplete)
		{
			completedTime = Instant.now();
		}
		return this;
	}

	public String describeTransaction()
	{
		return String.valueOf(this.quantity) + " " + this.itemName + "(s)";
	}

	public void setIsFlipped(boolean isFlipped)
	{
		this.isFlipped = isFlipped;
	}


	public int getTax()
	{
		if (this.isBuy)
		{
			return 0;
		}

		int tax = (int) Math.floor(this.finPricePer * TAX_RATE);
		return Math.min(tax, MAX_TAX);
	}

	public int getTotalTax()
	{
		return getTax() * this.quantity;
	}
}
package com.flipper2.models;

import java.sql.Timestamp;
import java.util.UUID;

import lombok.Data;

/**
 * Represents a buy and sell (flip) of an item
 */
@Data
public class Flip
{
	public static final double TAX_RATE = 0.01;

	public UUID flipId;
	public UUID userId;
	public UUID buyId;
	public UUID sellId;
	public int itemId;
	String itemName;
	public int quantity;
	public int buyPrice;
	public int sellPrice;
	private Timestamp updatedAt;
	private Timestamp createdAt;

	public Flip()
	{
	}

	public Flip(Transaction buy, Transaction sell)
	{
		this.flipId = UUID.randomUUID();
		this.buyId = buy.id;
		this.sellId = sell.id;
		this.itemId = sell.getItemId();
		this.itemName = sell.getItemName();
		this.quantity = sell.getQuantity();
		this.buyPrice = buy.getFinPricePer();
		this.sellPrice = sell.getFinPricePer();

		this.updatedAt = new Timestamp(System.currentTimeMillis());
		this.createdAt = new Timestamp(System.currentTimeMillis());
	}

	/**
	 * We know a flip is a margin check when only 1 is bought and it's bought for a
	 * greater to or equal price than sold for
	 */
	public boolean isMarginCheck()
	{
		return quantity == 1 && buyPrice >= sellPrice;
	}

	public String describeFlip()
	{
		return String.valueOf(quantity) + " " + this.itemName + "(s)";
	}

	/**
	 * We only concern ourselves with the amount sold (ignore extra bought and kept)
	 *
	 * @return profit of flip
	 */
	public int getTotalProfit()
	{
		return (sellPrice - buyPrice) * quantity - getTotalTax();
	}

	/**
	 * The GE floors tax per item.
	 *
	 * @return tax per item of flip
	 */
	public int getTax()
	{
		int taxPerItem = (int) Math.floor((double) this.sellPrice * TAX_RATE);
		return Math.min(taxPerItem, Transaction.MAX_TAX);
	}

	/**
	 * Gets the total tax of the sale
	 *
	 * @return total tax of sale
	 */
	public int getTotalTax()
	{
		return getTax() * quantity;
	}
}
package com.flipper2;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("Flipper2")
public interface FlipperConfig extends Config
{
	@ConfigItem(
		keyName = "isPromptDeleteBuy",
		name = "Delete Buy Prompt",
		description = "Shows confirmation prompt before deleting buy"
	)
	default boolean isPromptDeleteBuy()
	{
		return true;
	}

	@ConfigItem(
		keyName = "isPromptDeleteSell",
		name = "Delete Sell Prompt",
		description = "Shows confirmation prompt before deleting sell"
	)
	default boolean isPromptDeleteSell()
	{
		return true;
	}


	@ConfigItem(
		keyName = "isPromptDeleteFlip",
		name = "Delete Flip Prompt",
		description = "Shows confirmation prompt before deleting flip"
	)
	default boolean isPromptDeleteFlip()
	{
		return true;
	}


}

package com.flipper2.views.transactions;

import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;

import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.Color;
import java.awt.event.*;
import java.awt.Dimension;

import com.flipper2.helpers.UiUtilities;
import com.flipper2.helpers.Numbers;
import com.flipper2.helpers.Timestamps;
import com.flipper2.models.Transaction;
import com.flipper2.views.components.DeleteButton;
import com.flipper2.views.components.ItemHeader;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;

import java.util.UUID;
import java.util.function.Consumer;

public class TransactionPanel extends JPanel {
    private Transaction transaction;
    private JPanel container;
    private JPanel itemInfoContainer;

    public TransactionPanel(
            String name,
            Transaction transaction,
            ItemManager itemManager,
            Consumer<UUID> removeTransactionConsumer,
            boolean isPrompt
    ) {
        init(
                name,
                transaction,
                itemManager,
                removeTransactionConsumer,
                isPrompt
        );
    }

    private void init(
            String name,
            Transaction transaction,
            ItemManager itemManager,
            Consumer<UUID> removeTransactionConsumer,
            boolean isPrompt
    ) {
        this.transaction = transaction;
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        DeleteButton deleteTransactionButton = new DeleteButton((ActionEvent action) -> {
            String describeTransaction = transaction.describeTransaction();
            int input = isPrompt
                    ? JOptionPane.showConfirmDialog(
                    null,
                    "Delete " + name + " of " + describeTransaction + "?"
            )
                    : 0;
            if (input == 0) {
                removeTransactionConsumer.accept(transaction.getId());
                setVisible(false);
            }
        });

        container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel itemHeader = new ItemHeader(
                transaction.getItemId(),
                transaction.getFinPricePer(),
                transaction.getItemName(),
                itemManager,
                false,
                deleteTransactionButton
        );
        container.add(itemHeader, BorderLayout.NORTH);

        JPanel centerPanel = new JPanel(new BorderLayout());
        centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel titlePanel = new JPanel(new GridLayout(1, 2, 0, 0));
        titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel initialLabel = new JLabel("Initial");
        initialLabel.setHorizontalAlignment(JLabel.CENTER);
        initialLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        titlePanel.add(initialLabel);

        JLabel finalLabel = new JLabel("Final");
        finalLabel.setHorizontalAlignment(JLabel.CENTER);
        finalLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        titlePanel.add(finalLabel);

        centerPanel.add(titlePanel, BorderLayout.NORTH);

        constructItemInfo();
        centerPanel.add(itemInfoContainer, BorderLayout.CENTER);

        container.add(centerPanel, BorderLayout.CENTER);

        JPanel datePanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        datePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        String dateString = "Date: " + Timestamps.format(transaction.getCreatedTime());
        JLabel dateLabel = new JLabel(dateString);
        dateLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
        datePanel.add(dateLabel);

        container.add(datePanel, BorderLayout.SOUTH);

        container.setBorder(UiUtilities.ITEM_INFO_BORDER);
        this.add(container, BorderLayout.NORTH);
        this.setBorder(new EmptyBorder(0, 5, 3, 5));
    }

    private JLabel newLeftLabel(String text) {
        JLabel newJLabel = new JLabel(text);
        newJLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
        newJLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
        return newJLabel;
    }

    private JLabel newRightLabel(String value, Color fontColor) {
        JLabel newRightLabel = new JLabel(value);
        newRightLabel.setHorizontalAlignment(JLabel.RIGHT);
        newRightLabel.setForeground(fontColor);
        newRightLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
        return newRightLabel;
    }

    private int calculateTax(int pricePer) {
        int tax = (int) Math.floor(pricePer * Transaction.TAX_RATE);
        return Math.min(tax, Transaction.MAX_TAX);
    }

    private void constructItemInfo() {
        itemInfoContainer = new JPanel(new GridLayout(1, 2, 0, 0));
        itemInfoContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel column1 = new JPanel(new BorderLayout());
        column1.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel contentPanel1 = new JPanel(new GridLayout(0, 1));
        contentPanel1.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel initQuantityPanel = new JPanel(new BorderLayout());
        initQuantityPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        String quantityValueTextInit = Numbers.numberWithCommas(transaction.getTotalQuantity());
        JLabel quantityLabelInit = newLeftLabel("Quantity:");
        JLabel quantityValueLabelInit = newRightLabel(quantityValueTextInit, ColorScheme.GRAND_EXCHANGE_ALCH);
        initQuantityPanel.add(quantityLabelInit, BorderLayout.WEST);
        initQuantityPanel.add(quantityValueLabelInit, BorderLayout.EAST);
        contentPanel1.add(initQuantityPanel);

        JPanel initPricePanel = new JPanel(new BorderLayout());
        initPricePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int initPricePer = transaction.getInitPricePer();
        String initPricePerText = Numbers.toShortNumber(initPricePer);
        JLabel pricePerLabelInit = newLeftLabel("Price Per:");
        JLabel pricePerValueLabelInit = newRightLabel(initPricePerText, ColorScheme.GRAND_EXCHANGE_ALCH);
        pricePerValueLabelInit.setToolTipText(Numbers.numberWithCommas(initPricePer));
        initPricePanel.add(pricePerLabelInit, BorderLayout.WEST);
        initPricePanel.add(pricePerValueLabelInit, BorderLayout.EAST);
        contentPanel1.add(initPricePanel);

        if (!transaction.isBuy()) {
            JPanel taxPanel = new JPanel(new BorderLayout());
            taxPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
            int initialTax = calculateTax(transaction.getInitPricePer());
            String initialTaxText = Numbers.toShortNumber(initialTax);
            JLabel taxLabel = newLeftLabel("Tax Per:");
            JLabel taxValueLabel = newRightLabel(initialTaxText, ColorScheme.PROGRESS_ERROR_COLOR);
            taxValueLabel.setToolTipText(Numbers.numberWithCommas(initialTax));
            taxPanel.add(taxLabel, BorderLayout.WEST);
            taxPanel.add(taxValueLabel, BorderLayout.EAST);
            contentPanel1.add(taxPanel);
        }

        JPanel initTotalPanel = new JPanel(new BorderLayout());
        initTotalPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int initTotalValue = transaction.getInitPricePer() * transaction.getQuantity();
        String initTotalValueText = Numbers.toShortNumber(initTotalValue);
        JLabel totalValueLabelInit =  newLeftLabel("Total Value:");
        JLabel totalValueValueLabelInit = newRightLabel(initTotalValueText, ColorScheme.GRAND_EXCHANGE_ALCH);
        totalValueValueLabelInit.setToolTipText(Numbers.numberWithCommas(initTotalValue));
        initTotalPanel.add(totalValueLabelInit, BorderLayout.WEST);
        initTotalPanel.add(totalValueValueLabelInit, BorderLayout.EAST);
        contentPanel1.add(initTotalPanel);

        column1.add(contentPanel1, BorderLayout.CENTER);

        JPanel column2 = new JPanel(new BorderLayout());
        column2.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel contentPanel2 = new JPanel(new GridLayout(0, 1));
        contentPanel2.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel finQuantityPanel = new JPanel(new BorderLayout());
        finQuantityPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        String quantityValueTextFin = Numbers.numberWithCommas(transaction.getQuantity());
        JLabel quantityLabelFin = newLeftLabel("Quantity:");
        JLabel quantityValueLabelFin = newRightLabel(quantityValueTextFin, ColorScheme.GRAND_EXCHANGE_ALCH);
        finQuantityPanel.add(quantityLabelFin, BorderLayout.WEST);
        finQuantityPanel.add(quantityValueLabelFin, BorderLayout.EAST);
        contentPanel2.add(finQuantityPanel);

        JPanel finPricePanel = new JPanel(new BorderLayout());
        finPricePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int finPricePer = transaction.getFinPricePer();
        String finPricePerText = Numbers.toShortNumber(finPricePer);
        JLabel pricePerLabelFin = newLeftLabel("Price Per:");
        JLabel pricePerValueLabelFin = newRightLabel(finPricePerText, ColorScheme.GRAND_EXCHANGE_ALCH);
        pricePerValueLabelFin.setToolTipText(Numbers.numberWithCommas(finPricePer));
        finPricePanel.add(pricePerLabelFin, BorderLayout.WEST);
        finPricePanel.add(pricePerValueLabelFin, BorderLayout.EAST);
        contentPanel2.add(finPricePanel);

        if (!transaction.isBuy()) {
            JPanel taxPanel = new JPanel(new BorderLayout());
            taxPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
            int finalTax = calculateTax(transaction.getFinPricePer());
            String finalTaxText = Numbers.toShortNumber(finalTax);
            JLabel taxLabel = newLeftLabel("Tax Per:");
            JLabel taxValueLabel = newRightLabel(finalTaxText, ColorScheme.PROGRESS_ERROR_COLOR);
            taxValueLabel.setToolTipText(Numbers.numberWithCommas(finalTax));
            taxPanel.add(taxLabel, BorderLayout.WEST);
            taxPanel.add(taxValueLabel, BorderLayout.EAST);
            contentPanel2.add(taxPanel);
        }

        JPanel finTotalPanel = new JPanel(new BorderLayout());
        finTotalPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        int finTotalValue = transaction.getFinPricePer() * transaction.getQuantity();
        String finTotalValueText = Numbers.toShortNumber(finTotalValue);
        JLabel totalValueLabelFin = newLeftLabel("Total Value:");
        JLabel totalValueValueLabelFin = newRightLabel(finTotalValueText, ColorScheme.GRAND_EXCHANGE_ALCH);
        totalValueValueLabelFin.setToolTipText(Numbers.numberWithCommas(finTotalValue));
        finTotalPanel.add(totalValueLabelFin, BorderLayout.WEST);
        finTotalPanel.add(totalValueValueLabelFin, BorderLayout.EAST);
        contentPanel2.add(finTotalPanel);

        column2.add(contentPanel2, BorderLayout.CENTER);

        itemInfoContainer.add(column1);
        itemInfoContainer.add(column2);
    }

    @Override
    public Dimension getPreferredSize() {
        Dimension preferredSize = super.getPreferredSize();
        return new Dimension(container.getPreferredSize().width, preferredSize.height);
    }
}
package com.flipper2.views.transactions;

import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.border.EmptyBorder;

import com.flipper2.views.components.SearchBar;

import java.awt.BorderLayout;
import java.util.function.Consumer;

import net.runelite.client.ui.ColorScheme;

public class TransactionPage extends JPanel {
    private JPanel container;

    public TransactionPage(Consumer<String> onSearchTextChanged) {
        this.setLayout(new BorderLayout());
        this.setBackground(ColorScheme.DARK_GRAY_COLOR);
        this.addSearchText(onSearchTextChanged);
        this.build();
    }

    private void addSearchText(Consumer<String> onSearchTextChanged) {
        SearchBar searchBar = new SearchBar(onSearchTextChanged);
        this.add(searchBar, BorderLayout.NORTH);
    }

    public void resetContainer() {
        container.removeAll();
    }

    public void build() {
        JPanel scrollContainer = new JPanel();
        scrollContainer.setLayout(new BorderLayout());
        container = new JPanel();
        container.setBorder(new EmptyBorder(5, 0, 0, 0));
        container.setLayout(new BoxLayout(container, BoxLayout.PAGE_AXIS));
        container.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JScrollPane scrollPane = new JScrollPane(scrollContainer);
        scrollPane.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
        scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);

        scrollContainer.add(container, BorderLayout.PAGE_START);
        this.add(scrollPane, BorderLayout.CENTER);
    }

    public void addTransactionPanel(TransactionPanel transactionPanel) {
        container.add(transactionPanel, BorderLayout.CENTER);
        this.revalidate();
    }
}
package com.flipper2.views.inprogress;

import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.border.EmptyBorder;

import java.awt.BorderLayout;

import net.runelite.client.ui.ColorScheme;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.ItemComposition;
import java.awt.image.BufferedImage;
import java.util.Arrays;


public class InProgressPage extends JPanel
{
	private JPanel container;
	private static final int MAX_OFFERS = 8;
	private InProgressPanel[] inProgressPanels = new InProgressPanel[MAX_OFFERS];

	public InProgressPage()
	{
		this.setLayout(new BorderLayout());
		this.setBackground(ColorScheme.DARK_GRAY_COLOR);
		this.build();
	}

	public void resetOffers()
	{
		container.removeAll();
		Arrays.fill(inProgressPanels, null);
		revalidate();
		repaint();
	}

	public void build()
	{
		container = new JPanel();
		container.setBorder(new EmptyBorder(5, 0, 0, 0));
		container.setLayout(new BoxLayout(container, BoxLayout.PAGE_AXIS));
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel scrollContainer = new JPanel();
		scrollContainer.setLayout(new BorderLayout());
		scrollContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollContainer.setBorder(new EmptyBorder(0, 0, 0, 0));
		scrollContainer.add(container, BorderLayout.PAGE_START);

		JScrollPane scrollPane = new JScrollPane(scrollContainer);
		scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));
		scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);

		this.add(scrollPane, BorderLayout.CENTER);
	}

	public void updateOffer(ItemComposition item, BufferedImage itemImage, GrandExchangeOffer newOffer, int slot)
	{
		/* If slot was previously filled, and is now empty, remove it from the list */
		if (newOffer == null || newOffer.getState() == net.runelite.api.GrandExchangeOfferState.EMPTY)
		{
			if (inProgressPanels[slot] != null)
			{
				container.remove(inProgressPanels[slot]);
				inProgressPanels[slot] = null;
				revalidate();
				repaint();
			}
			return;
		}
		/* If slot was empty, and is now filled, add it to the list */
		InProgressPanel offerSlot = inProgressPanels[slot];
		if (offerSlot == null)
		{
			offerSlot = new InProgressPanel(item, itemImage, newOffer);
			inProgressPanels[slot] = offerSlot;
			container.add(offerSlot);
		}

		offerSlot.updateOffer(item, itemImage, newOffer);

		revalidate();
		repaint();
	}
}
package com.flipper2.views.inprogress;

import javax.swing.*;
import javax.swing.border.EmptyBorder;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.Color;
import java.awt.image.BufferedImage;

import com.flipper2.helpers.Numbers;
import com.flipper2.helpers.UiUtilities;
import com.flipper2.views.components.InProgressHeader;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.client.ui.ColorScheme;
import net.runelite.api.ItemComposition;

import static com.flipper2.helpers.GrandExchange.checkIsBuy;

public class InProgressPanel extends JPanel
{
	private JPanel container;
	private JPanel itemInfoContainer;
	private JLabel quantityProgressLabel;
	private JProgressBar progressBar;

	public InProgressPanel(ItemComposition item, BufferedImage itemImage, GrandExchangeOffer offer)
	{
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		container = new JPanel(new BorderLayout());
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		quantityProgressLabel = new JLabel();
		quantityProgressLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		quantityProgressLabel.setHorizontalAlignment(JLabel.CENTER);

		progressBar = new JProgressBar(0, 100);
		progressBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
		progressBar.setForeground(UiUtilities.F2_GREEN);
		progressBar.setStringPainted(true);

		constructItemInfo();

		container.setBorder(UiUtilities.ITEM_INFO_BORDER);
		this.add(container, BorderLayout.NORTH);
		this.setBorder(new EmptyBorder(0, 5, 3, 5));
	}

	private JLabel newLeftLabel(String text)
	{
		JLabel newJLabel = new JLabel(text);
		newJLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		newJLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
		return newJLabel;
	}

	private JLabel newRightLabel(String value, Color fontColor)
	{
		JLabel newRightLabel = new JLabel(value);
		newRightLabel.setHorizontalAlignment(JLabel.RIGHT);
		newRightLabel.setForeground(fontColor);
		newRightLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
		return newRightLabel;
	}

	private void constructItemInfo()
	{
		itemInfoContainer = new JPanel(new GridLayout(1, 2, 0, 0));
		itemInfoContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel column1 = new JPanel(new BorderLayout());
		column1.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel contentPanel1 = new JPanel(new GridLayout(0, 1));
		contentPanel1.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel totalValuePanel = new JPanel(new BorderLayout());
		totalValuePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		totalValuePanel.add(newLeftLabel("Offer Total:"), BorderLayout.WEST);
		totalValuePanel.add(newRightLabel("0", ColorScheme.GRAND_EXCHANGE_ALCH), BorderLayout.EAST);
		contentPanel1.add(totalValuePanel);

		JPanel pricePerPanel = new JPanel(new BorderLayout());
		pricePerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		pricePerPanel.add(newLeftLabel("Price/Per:"), BorderLayout.WEST);
		pricePerPanel.add(newRightLabel("0", ColorScheme.GRAND_EXCHANGE_ALCH), BorderLayout.EAST);
		contentPanel1.add(pricePerPanel);

		column1.add(contentPanel1, BorderLayout.CENTER);

		JPanel column2 = new JPanel(new BorderLayout());
		column2.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel contentPanel2 = new JPanel(new GridLayout(0, 1));
		contentPanel2.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel spentPanel = new JPanel(new BorderLayout());
		spentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		spentPanel.add(newLeftLabel("Spent:"), BorderLayout.WEST);
		spentPanel.add(newRightLabel("0", ColorScheme.GRAND_EXCHANGE_ALCH), BorderLayout.EAST);
		contentPanel2.add(spentPanel);

		JPanel spentPerPanel = new JPanel(new BorderLayout());
		spentPerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		spentPerPanel.add(newLeftLabel("Spent/Per:"), BorderLayout.WEST);
		spentPerPanel.add(newRightLabel("0", ColorScheme.GRAND_EXCHANGE_ALCH), BorderLayout.EAST);
		contentPanel2.add(spentPerPanel);

		column2.add(contentPanel2, BorderLayout.CENTER);

		itemInfoContainer.add(column1);
		itemInfoContainer.add(column2);
	}

	public void updateOffer(ItemComposition offerItem, BufferedImage itemImage, GrandExchangeOffer offer)
	{
		GrandExchangeOfferState state = offer.getState();
		boolean isBuy = checkIsBuy(state);

		if (container.getComponentCount() == 3)
		{
			container.remove(2);
			container.remove(1);
			container.remove(0);
		}
		InProgressHeader header = new InProgressHeader(offerItem, itemImage, offer);
		container.add(header, BorderLayout.NORTH);

		JPanel titlePanel = new JPanel(new GridLayout(1, 1, 0, 0));
		titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		String offerType = (isBuy ? "Buy" : "Sell");
		JLabel offerTypeLabel = new JLabel(offerType);
		offerTypeLabel.setHorizontalAlignment(JLabel.CENTER);
		offerTypeLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		titlePanel.add(offerTypeLabel);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		centerPanel.add(titlePanel, BorderLayout.NORTH);
		constructItemInfo();
		centerPanel.add(itemInfoContainer, BorderLayout.CENTER);
		container.add(centerPanel, BorderLayout.CENTER);

		JPanel bottomPanel = new JPanel(new BorderLayout());
		bottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		bottomPanel.add(quantityProgressLabel, BorderLayout.NORTH);
		bottomPanel.add(progressBar, BorderLayout.SOUTH);
		container.add(bottomPanel, BorderLayout.SOUTH);

		int quantitySold = offer.getQuantitySold();
		int totalQuantity = offer.getTotalQuantity();
		int spent = offer.getSpent();
		int price = offer.getPrice();

		quantityProgressLabel.setText(Numbers.numberWithCommas(quantitySold) + " / " + Numbers.numberWithCommas(totalQuantity));

		int percentage = totalQuantity > 0 ? (int) (((double) quantitySold / totalQuantity) * 100) : 0;
		progressBar.setValue(percentage);
		progressBar.setString(percentage + "%");
		if (percentage >= 1 && percentage <= 24)
		{
			progressBar.setForeground(UiUtilities.F2_ORANGE.brighter());
		}
		else if (percentage >= 25 && percentage <= 49)
		{
			progressBar.setForeground(UiUtilities.F2_ORANGE);
		}
		else if (percentage >= 50 && percentage <= 74)
		{
			progressBar.setForeground(UiUtilities.F2_GREEN);
		}
		else if (percentage >= 75 && percentage <= 100)
		{
			progressBar.setForeground(UiUtilities.F2_GREEN.brighter());
		}


		JPanel contentPanel1 = (JPanel) ((JPanel) itemInfoContainer.getComponent(0)).getComponent(0);
		JPanel contentPanel2 = (JPanel) ((JPanel) itemInfoContainer.getComponent(1)).getComponent(0);

		JLabel totalValueValue = (JLabel) ((JPanel) contentPanel1.getComponent(0)).getComponent(1);
		int totalValue = totalQuantity * price;
		totalValueValue.setText(Numbers.toShortNumber(totalValue));
		totalValueValue.setToolTipText(Numbers.numberWithCommas(totalValue));


		JLabel pricePerValue = (JLabel) ((JPanel) contentPanel1.getComponent(1)).getComponent(1);
		pricePerValue.setText(Numbers.toShortNumber(price));
		pricePerValue.setToolTipText(Numbers.numberWithCommas(price));

		String spentType = (isBuy ? "Spent:" : "Rcvd:");
		JLabel spentTypeValue = (JLabel) ((JPanel) contentPanel2.getComponent(0)).getComponent(0);
		spentTypeValue.setText(spentType);

		JLabel spentValue = (JLabel) ((JPanel) contentPanel2.getComponent(0)).getComponent(1);
		spentValue.setText(Numbers.toShortNumber(spent));
		spentValue.setToolTipText(Numbers.numberWithCommas(spent));

		String spentTypePer = (isBuy ? "Spent/Per:" : "Rcvd/Per:");
		JLabel spentTypePerValue = (JLabel) ((JPanel) contentPanel2.getComponent(1)).getComponent(0);
		spentTypePerValue.setText(spentTypePer);

		int spentPer = (quantitySold > 0) ? spent / quantitySold : 0;
		JLabel spentPerValue = (JLabel) ((JPanel) contentPanel2.getComponent(1)).getComponent(1);
		spentPerValue.setText(Numbers.toShortNumber(spentPer));
		spentPerValue.setToolTipText(Numbers.numberWithCommas(spentPer));

		revalidate();
		repaint();
	}

	public void reset()
	{
		container.removeAll();
		revalidate();
		repaint();
	}
}
package com.flipper2.views;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.Desktop;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.net.URI;

import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;

import com.flipper2.helpers.UiUtilities;
import com.flipper2.views.components.Tab;
import com.flipper2.views.inprogress.InProgressPage;
import com.flipper2.views.transactions.TransactionPage;
import com.flipper2.views.flips.FlipPage;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;

public class TabManager extends PluginPanel
{

	public TabManager()
	{
		super(false);
		this.setLayout(new BorderLayout());
	}

	private JPanel constructTopBar()
	{
		JPanel container = new JPanel();
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);
		container.setLayout(new BorderLayout());
		container.setBorder(new EmptyBorder(0, 0, 5, 0));
		JPanel topBar = new JPanel();
		topBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
		int columns = 1;
		topBar.setLayout(new GridLayout(1, columns));

		JLabel github = new JLabel();
		github.setToolTipText("Flipper2 Pluggin Github");
		github.setHorizontalAlignment(JLabel.RIGHT);
		github.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				try
				{
					Desktop desktop = Desktop.getDesktop();
					URI githubUri = new URI("https://github.com/UmaLPZ/OSRS-Flipper-2");
					desktop.browse(githubUri);
				}
				catch (Exception error)
				{
				}
			}
		});
		ImageIcon githubIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), UiUtilities.githubIcon));
		github.setIcon(githubIcon);
		topBar.add(github);

		container.add(topBar);
		container.setBorder(new EmptyBorder(0, 0, 5, 5));
		return container;
	}

	public void renderLoggedInView(
		TransactionPage buyPage,
		TransactionPage sellPage,
		FlipPage flipPage,
		InProgressPage inProgressPage
	)
	{
		SwingUtilities.invokeLater(() -> {
			this.removeAll();
			JPanel topBar = this.constructTopBar();
			JPanel display = new JPanel();
			JPanel header = new JPanel(new BorderLayout());
			header.setBorder(new EmptyBorder(5, 0, 0, 0));
			MaterialTabGroup tabGroup = new MaterialTabGroup(display);
			Tab buysTab = new Tab("Buys", tabGroup, buyPage);
			Tab sellsTab = new Tab("Sells", tabGroup, sellPage);
			Tab flipsTab = new Tab("Flips", tabGroup, flipPage);
			Tab inProgressTab = new Tab("In Progress", tabGroup, inProgressPage);
			tabGroup.setBorder(new EmptyBorder(5, 0, 2, 0));
			tabGroup.addTab(buysTab);
			tabGroup.addTab(sellsTab);
			tabGroup.addTab(flipsTab);
			tabGroup.addTab(inProgressTab);
			tabGroup.select(buysTab);
			JPanel tabGroupContainer = new JPanel();
			tabGroupContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
			tabGroupContainer.add(tabGroup);
			header.add(topBar, BorderLayout.NORTH);
			header.add(tabGroupContainer, BorderLayout.CENTER);
			add(header, BorderLayout.NORTH);
			add(display, BorderLayout.CENTER);
			this.revalidate();
		});
	}
}
package com.flipper2.views.components;

import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Color;
import java.awt.Dimension;

import com.flipper2.helpers.Numbers;
import com.flipper2.helpers.UiUtilities;
import static com.flipper2.helpers.UiUtilities.truncateString;

import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.AsyncBufferedImage;

import java.awt.event.*;

/**
 * Item header: Item Icon / Item Name / Number bought/soul out of total
 */
public class ItemHeader extends JPanel
{
	private ItemManager itemManager;
	private int itemId;
	private int pricePer;
	private String itemName;
	private JPanel topRightContainer;
	private JLabel costPerLabel;

	public ItemHeader(
		int itemId,
		int pricePer,
		String itemName,
		ItemManager itemManager,
		boolean isAddCostPer,
		JButton hoverButton
	)
	{
		this.itemId = itemId;
		this.pricePer = pricePer;
		this.itemName = itemName;
		this.itemManager = itemManager;
		this.setLayout(new BorderLayout());
		topRightContainer = new JPanel();
		topRightContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		JPanel itemIconPanel = constructItemIcon();
		JLabel itemNameLabel = constructItemName();
		if (isAddCostPer)
		{
			this.costPerLabel = constructCostPerLabel();
			topRightContainer.add(costPerLabel);
		}

		hoverButton.setVisible(false);
		topRightContainer.add(hoverButton);

		add(topRightContainer, BorderLayout.EAST);
		setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		add(itemIconPanel, BorderLayout.WEST);
		add(itemNameLabel, BorderLayout.CENTER);
		setBorder(new EmptyBorder(2, 1, 2, 5));

		this.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent me)
			{
				hoverButton.setVisible(true);
				if (isAddCostPer)
				{
					costPerLabel.setVisible(false);
				}
			}

			@Override
			public void mouseExited(MouseEvent me)
			{
				if (isAddCostPer)
				{
					costPerLabel.setVisible(true);
				}
				hoverButton.setVisible(false);
			}
		});

		hoverButton.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent me)
			{
				hoverButton.setVisible(true);
				if (isAddCostPer)
				{
					costPerLabel.setVisible(false);
				}
			}

			@Override
			public void mouseExited(MouseEvent me)
			{
				if (isAddCostPer)
				{
					costPerLabel.setVisible(true);
				}
				hoverButton.setVisible(false);
			}
		});
	}

	private JPanel constructItemIcon()
	{
		AsyncBufferedImage itemImage = itemManager.getImage(this.itemId);
		JLabel itemIcon = new JLabel();
		itemIcon.setAlignmentX(Component.LEFT_ALIGNMENT);
		itemIcon.setPreferredSize(UiUtilities.ICON_SIZE);
		if (itemImage != null)
		{
			itemImage.addTo(itemIcon);
		}
		JPanel itemIconPanel = new JPanel(new BorderLayout());
		itemIconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		itemIconPanel.add(itemIcon, BorderLayout.WEST);
		return itemIconPanel;
	}

	private JLabel constructItemName()
	{
		JLabel itemName = new JLabel(truncateString(this.itemName,20), SwingConstants.CENTER);
		itemName.setForeground(Color.WHITE);
		itemName.setFont(FontManager.getRunescapeBoldFont());
		itemName.setPreferredSize(new Dimension(0, 0));
		itemName.setToolTipText(this.itemName);
		return itemName;
	}

	private JLabel constructCostPerLabel()
	{
		String costPerString = Numbers.numberWithCommas(this.pricePer);
		JLabel costPerLabel = new JLabel(costPerString + " gp");
		costPerLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		return costPerLabel;
	}
}
package com.flipper2.views.components;

import com.google.common.base.Strings;
import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.BooleanSupplier;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.SwingConstants;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;

public class Tab extends MaterialTab
{
	private static final Border SELECTED_BORDER = new CompoundBorder(
		BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.BRAND_ORANGE),
		BorderFactory.createEmptyBorder(5, 5, 4, 5));

	private static final Border UNSELECTED_BORDER = BorderFactory
		.createEmptyBorder(5, 5, 5, 5);

	/* The tab's containing group */
	private final MaterialTabGroup group;

	/* The tab's associated content display */
	@Getter
	private final JComponent content;

	/* To be executed when the tab is selected */
	@Setter
	private BooleanSupplier onSelectEvent;

	@Getter
	private boolean selected;

	public Tab(String string, MaterialTabGroup group, JComponent content)
	{
		super(string, group, content);

		this.group = group;
		this.content = content;

		if (selected)
		{
			select();
		}
		else
		{
			unselect();
		}

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mousePressed(MouseEvent mouseEvent)
			{
				group.select(Tab.this);
			}
		});

		if (!Strings.isNullOrEmpty(string))
		{
			addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseEntered(MouseEvent e)
				{
					Tab tab = (Tab) e.getSource();
					tab.setForeground(Color.WHITE);
				}

				@Override
				public void mouseExited(MouseEvent e)
				{
					Tab tab = (Tab) e.getSource();
					if (!tab.isSelected())
					{
						tab.setForeground(Color.GRAY);
					}
				}
			});
		}
	}

	public Tab(ImageIcon icon, MaterialTabGroup group, JComponent content)
	{
		this("", group, content);
		setIcon(icon);
		setOpaque(true);
		setVerticalAlignment(SwingConstants.CENTER);
		setHorizontalAlignment(SwingConstants.CENTER);
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				Tab tab = (Tab) e.getSource();
				tab.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				Tab tab = (Tab) e.getSource();
				tab.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

	}

	@Override
	public boolean select()
	{
		if (onSelectEvent != null)
		{
			if (!onSelectEvent.getAsBoolean())
			{
				return false;
			}
		}

		setBorder(SELECTED_BORDER);
		setForeground(Color.WHITE);
		return selected = true;
	}

	@Override
	public void unselect()
	{
		setBorder(UNSELECTED_BORDER);
		setForeground(Color.GRAY);
		selected = false;
	}
}
package com.flipper2.views.components;

import javax.swing.ImageIcon;
import javax.swing.JButton;

import com.flipper2.helpers.UiUtilities;

import net.runelite.client.util.ImageUtil;
import java.awt.event.*;

public class DeleteButton extends JButton
{
	public DeleteButton(ActionListener onClick)
	{
		ImageIcon deleteIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), UiUtilities.deleteX));
		setIcon(deleteIcon);
		setBorderPainted(false);
		setContentAreaFilled(false);
		setFocusPainted(true);
		setOpaque(false);
		addActionListener(onClick);
	}
}

package com.flipper2.views.components;

import java.util.function.Consumer;

import javax.swing.JTextField;

import net.runelite.client.input.KeyListener;

import javax.swing.Timer;

import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;

public class SearchBar extends JTextField
{
	private Timer timer;
	private final String ph = "Search";

	public SearchBar(Consumer<String> onSearchTextChanged)
	{
		super();
		this.addKeyListener(new KeyListener()
		{
			@Override
			public void keyTyped(KeyEvent event)
			{
			}

			@Override
			public void keyReleased(KeyEvent event)
			{
				if (timer == null)
				{
					timer = new Timer(500, (ActionEvent action) -> {
						String text = getText();
						onSearchTextChanged.accept(text);
					});
					timer.setRepeats(false);
				}
				else
				{
					timer.restart();
				}
			}

			@Override
			public void keyPressed(KeyEvent event)
			{
			}
		});
	}

	@Override
	public void paintComponent(Graphics g)
	{
		super.paintComponent(g);

		if (super.getText().length() > 0 || ph == null)
		{
			return;
		}

		Graphics2D g2 = (Graphics2D) g;

		g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		g2.setColor(super.getDisabledTextColor());
		g2.drawString(ph, getInsets().left, g.getFontMetrics().getMaxAscent() + getInsets().top);
	}
}

package com.flipper2.views.components;

import javax.swing.JCheckBox;
import java.awt.event.*;

public class Toggle extends JCheckBox
{
	public Toggle(String label, Boolean isToggled, Runnable onToggleRunnable)
	{
		super(label, isToggled);
		setBounds(100, 100, 50, 50);

		addItemListener(new ItemListener()
		{
			public void itemStateChanged(ItemEvent event)
			{
				onToggleRunnable.run();
			}
		});
	}
}

package com.flipper2.views.components;

import java.awt.event.MouseEvent;
import java.awt.event.MouseAdapter;
import java.awt.BorderLayout;

import java.util.List;
import java.util.function.Consumer;

import javax.swing.JLabel;
import javax.swing.JPanel;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

public class Pagination
{
	private Consumer<Object> renderItemCallback;
	private Runnable buildViewCallback;
	private int itemsPerPage;
	private int page;

	public Pagination(
		Consumer<Object> renderItemCallback,
		int itemsPerPage,
		Runnable buildViewCallback
	)
	{
		this.itemsPerPage = itemsPerPage;
		this.renderItemCallback = renderItemCallback;
		this.page = 1;
		this.buildViewCallback = buildViewCallback;
	}

	public void resetPage()
	{
		this.page = 1;
	}

	public <T> void renderList(List<T> items)
	{
		int endIndex = items.size() - (page * itemsPerPage) - 1;
		if (endIndex < 0)
		{
			endIndex = -1;
		}
		int startIndex = items.size() - ((page - 1) * itemsPerPage) - 1;
		for (int i = startIndex; i > endIndex; i--)
		{
			this.renderItemCallback.accept(items.get(i));
		}
	}

	public <T> void renderFromBeginning(List<T> items)
	{
		int startIndex = (page - 1) * itemsPerPage;
		int endIndex = (page * itemsPerPage) - 1;

		if (endIndex > items.size())
		{
			endIndex = items.size();
		}

		for (int i = startIndex; i < endIndex; i++)
		{
			this.renderItemCallback.accept(items.get(i));
		}
	}

	public <T> JPanel getComponent(List<T> items)
	{
		JPanel container = new JPanel(new BorderLayout());

		int numberOfPages = (int) Math.round(
			Math.ceil(
				items.size() * 1.0 / this.itemsPerPage
			)
		);

		JLabel previous = new JLabel("<");
		previous.setFont(FontManager.getRunescapeBoldFont());
		previous.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		previous.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (page != 1)
				{
					page--;
					buildViewCallback.run();
				}
				else
				{
					page = numberOfPages;
					buildViewCallback.run();
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				previous.setForeground(ColorScheme.BRAND_ORANGE);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				previous.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			}
		});

		JLabel pageLabel = new JLabel(page + " of " + numberOfPages);
		pageLabel.setHorizontalAlignment(JLabel.CENTER);

		JLabel next = new JLabel(">");
		next.setFont(FontManager.getRunescapeBoldFont());
		next.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		next.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (page < numberOfPages)
				{
					page++;
					buildViewCallback.run();
				}
				else
				{
					page = 1;
					buildViewCallback.run();
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				next.setForeground(ColorScheme.BRAND_ORANGE);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				next.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
			}
		});

		container.add(previous, BorderLayout.WEST);
		container.add(pageLabel, BorderLayout.CENTER);
		container.add(next, BorderLayout.EAST);
		container.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		return container;
	}
}
package com.flipper2.views.components;

import javax.swing.*;
import javax.swing.border.EmptyBorder;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Color;
import java.awt.image.BufferedImage;

import com.flipper2.helpers.UiUtilities;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.api.ItemComposition;

import static com.flipper2.helpers.GrandExchange.checkIsBuy;
import static com.flipper2.helpers.UiUtilities.truncateString;

public class InProgressHeader extends JPanel
{

	public InProgressHeader(ItemComposition item, BufferedImage itemImage, GrandExchangeOffer offer)
	{
		this.setLayout(new BorderLayout());
		this.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());

		JPanel itemIconPanel = constructItemIcon(itemImage);
		JLabel itemNameLabel = constructItemName(item.getName());
		JLabel offerTypeLabel = constructOfferTypeLabel(offer);


		this.add(itemIconPanel, BorderLayout.WEST);
		this.add(itemNameLabel, BorderLayout.CENTER);
		this.add(offerTypeLabel, BorderLayout.EAST);

		this.setBorder(new EmptyBorder(2, 1, 2, 5));
	}

	private JPanel constructItemIcon(BufferedImage itemImage)
	{
		JLabel itemIcon = new JLabel();
		itemIcon.setAlignmentX(Component.LEFT_ALIGNMENT);
		itemIcon.setPreferredSize(UiUtilities.ICON_SIZE);
		itemIcon.setIcon(new ImageIcon(itemImage));
		JPanel itemIconPanel = new JPanel(new BorderLayout());
		itemIconPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		itemIconPanel.add(itemIcon, BorderLayout.WEST);
		return itemIconPanel;
	}

	private JLabel constructItemName(String itemName)
	{
		JLabel itemNameLabel = new JLabel(truncateString(itemName,20), SwingConstants.CENTER);
		itemNameLabel.setForeground(Color.WHITE);
		itemNameLabel.setFont(FontManager.getRunescapeBoldFont());
		itemNameLabel.setToolTipText(itemName);
		return itemNameLabel;
	}

	private JLabel constructOfferTypeLabel(GrandExchangeOffer offer)
	{
		GrandExchangeOfferState state = offer.getState();
		boolean isBuy = checkIsBuy(state);
		String offerType = (isBuy ? "Buy" : "Sell");
		JLabel offerTypeLabel = new JLabel(offerType);
		offerTypeLabel.setHorizontalAlignment(JLabel.RIGHT);

		if (isBuy)
		{
			offerTypeLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		}
		else
		{
			offerTypeLabel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}
		return offerTypeLabel;
	}
}
package com.flipper2.views.flips;

import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.border.EmptyBorder;
import javax.swing.*;
import javax.swing.SwingConstants;

import java.awt.*;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;

import com.flipper2.helpers.Numbers;
import com.flipper2.helpers.UiUtilities;
import com.flipper2.views.components.SearchBar;
import com.flipper2.views.components.Toggle;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

public class FlipPage extends JPanel
{
	private JPanel container;
	private JLabel totalProfitValueLabel;
	private JCheckBox shortenProfitCheckbox;

	private Consumer<String> onSearchTextChanged;
	private Runnable refreshFlipsRunnable;
	private Runnable toggleIsTrackingFlipsRunnable;
	private Toggle trackFlipsToggle;

	public FlipPage(
		Runnable refreshFlipsRunnable,
		Consumer<String> onSearchTextChanged,
		Runnable toggleIsTrackingFlipsRunnable,
		Boolean isTrackingFlips
	)
	{
		this.refreshFlipsRunnable = refreshFlipsRunnable;
		this.onSearchTextChanged = onSearchTextChanged;
		this.toggleIsTrackingFlipsRunnable = toggleIsTrackingFlipsRunnable;
		this.setLayout(new BorderLayout());
		this.setBackground(ColorScheme.DARK_GRAY_COLOR);
		constructTotalProfitContainer();
		this.build(isTrackingFlips);
		setTotalProfit("0", true);
	}

	public void addFlipPanel(FlipPanel flipPanel)
	{
		container.add(flipPanel, BorderLayout.CENTER);
		this.revalidate();
	}

	public void resetContainer(boolean isTrackingFlips)
	{
		trackFlipsToggle.setSelected(isTrackingFlips);
		trackFlipsToggle.revalidate();
		container.removeAll();
	}

	private void constructTotalProfitContainer()
	{
		JPanel container = new JPanel();
		container.setLayout(new BorderLayout());
		JPanel totalProfitContainer = new JPanel(new BorderLayout());
		totalProfitContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);


		JPanel totalProfitHeader = new JPanel(new BorderLayout());
		totalProfitHeader.setBackground(ColorScheme.DARK_GRAY_COLOR);
		totalProfitHeader.setBorder(new EmptyBorder(2, 2, 0, 2));

		JLabel totalProfitLabel = new JLabel("Flip Profit");
		totalProfitLabel.setFont(FontManager.getRunescapeBoldFont());
		totalProfitLabel.setHorizontalAlignment(JLabel.CENTER);
		totalProfitLabel.setForeground(Color.WHITE);

		ImageIcon refreshIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), UiUtilities.refreshIcon));
		JLabel refreshFlips = new JLabel();
		refreshFlips.setToolTipText("Refresh flips");
		refreshFlips.setIcon(refreshIcon);
		refreshFlips.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				try
				{
					refreshFlipsRunnable.run();
				}
				catch (Exception error)
				{
				}
			}
		});

		totalProfitHeader.add(totalProfitLabel, BorderLayout.CENTER);
		totalProfitContainer.add(totalProfitHeader, BorderLayout.NORTH);

		totalProfitValueLabel = new JLabel();
		totalProfitValueLabel.setFont(FontManager.getRunescapeFont());
		totalProfitValueLabel.setHorizontalAlignment(JLabel.CENTER);
		totalProfitValueLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		totalProfitValueLabel.setBorder(new EmptyBorder(2, 0, 0, 0));
		totalProfitContainer.add(totalProfitValueLabel, BorderLayout.CENTER);

		JPanel checkboxPanel = new JPanel(new BorderLayout());
		checkboxPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		checkboxPanel.setBorder(new EmptyBorder(0, 2, 0, 2));
		shortenProfitCheckbox = new JCheckBox("Use ShortHand");
		shortenProfitCheckbox.setSelected(true);
		shortenProfitCheckbox.setBackground(ColorScheme.DARK_GRAY_COLOR);
		shortenProfitCheckbox.setForeground(Color.WHITE);

		shortenProfitCheckbox.setHorizontalTextPosition(SwingConstants.LEFT);

		shortenProfitCheckbox.addActionListener(e -> {
			String currentTotalProfit = totalProfitValueLabel.getToolTipText();
			if (currentTotalProfit != null)
			{
				setTotalProfit(currentTotalProfit, shortenProfitCheckbox.isSelected());
			}
			else
			{
				setTotalProfit("0", shortenProfitCheckbox.isSelected());
			}
		});
		checkboxPanel.add(shortenProfitCheckbox, BorderLayout.EAST);
		checkboxPanel.add(refreshFlips, BorderLayout.WEST);
		totalProfitContainer.add(checkboxPanel, BorderLayout.SOUTH);
		totalProfitContainer.setBorder(UiUtilities.ITEM_INFO_BORDER);
		container.add(totalProfitContainer, BorderLayout.NORTH);

		SearchBar searchBar = new SearchBar(this.onSearchTextChanged);
		container.add(searchBar, BorderLayout.CENTER);

		this.trackFlipsToggle = new Toggle("Track Flips", true, this.toggleIsTrackingFlipsRunnable);
		container.add(trackFlipsToggle, BorderLayout.SOUTH);

		container.setBorder(new EmptyBorder(0, 0, 3, 0));
		this.add(container, BorderLayout.NORTH);

	}

	/**
	 * Sets the total profit label, formatting it according to the useShortFormat flag.
	 *
	 * @param totalProfitStr The total profit value (as a String).
	 * @param useShortFormat Whether to use the shortened number format.
	 */
	public void setTotalProfit(String totalProfitStr, boolean useShortFormat)
	{
		try
		{
			int totalProfit = Integer.parseInt(totalProfitStr.replace(",", ""));
			String formattedProfit = useShortFormat
				? Numbers.toShortNumber(totalProfit)
				: Numbers.numberWithCommas(totalProfit);
			totalProfitValueLabel.setText(formattedProfit);
			totalProfitValueLabel.setToolTipText(Numbers.numberWithCommas(totalProfit));

			if (totalProfit >= 0)
			{
				totalProfitValueLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
			}
			else
			{
				totalProfitValueLabel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		}
		catch (NumberFormatException e)
		{
			totalProfitValueLabel.setText("Error");
			totalProfitValueLabel.setToolTipText(null);
		}
	}

	/**
	 * Overload setTotalProfit to use existing checkbox
	 *
	 * @param totalProfitStr The total profit value (as a String).
	 */
	public void setTotalProfit(String totalProfitStr)
	{
		setTotalProfit(totalProfitStr, this.shortenProfitCheckbox.isSelected());
	}

	public void build(Boolean isTrackingFlips)
	{
		JPanel scrollContainer = new JPanel();
		scrollContainer.setLayout(new BorderLayout());
		container = new JPanel();
		container.setLayout(new BoxLayout(container, BoxLayout.PAGE_AXIS));
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JScrollPane scrollPane = new JScrollPane(scrollContainer);
		scrollPane.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
		scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);

		scrollContainer.add(container, BorderLayout.PAGE_START);
		this.add(scrollPane, BorderLayout.CENTER);

		this.trackFlipsToggle.setSelected(isTrackingFlips);
	}
}
package com.flipper2.views.flips;

import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.util.UUID;
import java.util.function.Consumer;
import java.awt.Color;
import java.awt.event.*;
import java.awt.FlowLayout;

import com.flipper2.helpers.Numbers;
import com.flipper2.helpers.Timestamps;
import com.flipper2.helpers.UiUtilities;
import com.flipper2.models.Flip;
import com.flipper2.views.components.DeleteButton;
import com.flipper2.views.components.ItemHeader;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.game.ItemManager;

public class FlipPanel extends JPanel
{
	private Flip flip;
	private JPanel container;
	private JPanel itemInfoContainer;

	public FlipPanel(
		Flip flip,
		ItemManager itemManager,
		Consumer<UUID> removeFlipConsumer,
		boolean isPrompt
	)
	{
		this.flip = flip;
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		container = new JPanel(new BorderLayout());
		container.setBackground(ColorScheme.DARK_GRAY_COLOR);

		DeleteButton deleteFlipButton = new DeleteButton((ActionEvent action) -> {
			String describedBuy = flip.describeFlip();
			int input = isPrompt
				? JOptionPane.showConfirmDialog(null, "Delete flip of " + describedBuy + "?")
				: 0;
			if (input == 0)
			{
				removeFlipConsumer.accept(flip.getFlipId());
				setVisible(false);
			}
		});

		JPanel itemHeader = new ItemHeader(
			flip.getItemId(),
			flip.getSellPrice(),
			flip.getItemName(),
			itemManager,
			false,
			deleteFlipButton
		);
		container.add(itemHeader, BorderLayout.NORTH);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel titlePanel = new JPanel(new GridLayout(1, 1, 0, 0));
		titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		String amountFlippedText = Integer.toString(this.flip.getQuantity());
		JLabel amountFlippedLabel = new JLabel("Amount Flipped: " + Numbers.toShortNumber(Integer.parseInt(amountFlippedText)));
		amountFlippedLabel.setToolTipText(Numbers.numberWithCommas(amountFlippedText));
		amountFlippedLabel.setHorizontalAlignment(JLabel.CENTER);
		amountFlippedLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		titlePanel.add(amountFlippedLabel);

		centerPanel.add(titlePanel, BorderLayout.NORTH);

		constructItemInfo();
		centerPanel.add(itemInfoContainer, BorderLayout.CENTER);

		container.add(centerPanel, BorderLayout.CENTER);

		JPanel datePanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
		datePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		String dateString = "Date: " + Timestamps.format(flip.getCreatedAt());
		JLabel dateLabel = new JLabel(dateString);
		dateLabel.setForeground(ColorScheme.GRAND_EXCHANGE_ALCH);
		datePanel.add(dateLabel);

		container.add(datePanel, BorderLayout.SOUTH);

		container.setBorder(UiUtilities.ITEM_INFO_BORDER);
		this.add(container, BorderLayout.NORTH);
		this.setBorder(new EmptyBorder(0, 5, 3, 5));
	}

	private JLabel newLeftLabel(String text)
	{
		JLabel newJLabel = new JLabel(text);
		newJLabel.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		newJLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
		return newJLabel;
	}

	private JLabel newRightLabel(String value, Color fontColor)
	{
		JLabel newRightLabel = new JLabel(value);
		newRightLabel.setHorizontalAlignment(JLabel.RIGHT);
		newRightLabel.setForeground(fontColor);
		newRightLabel.setBorder(new EmptyBorder(2, 2, 2, 2));
		return newRightLabel;
	}

	private void constructItemInfo()
	{
		itemInfoContainer = new JPanel(new GridLayout(1, 2, 0, 0));
		itemInfoContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel column1 = new JPanel(new BorderLayout());
		column1.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel contentPanel1 = new JPanel(new GridLayout(0, 1));
		contentPanel1.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel buyPricePanel = new JPanel(new BorderLayout());
		buyPricePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		int buyPrice = flip.getBuyPrice();
		JLabel buyPriceLabel = newLeftLabel("Buy Price:");
		JLabel buyPriceValue = newRightLabel(Numbers.toShortNumber(buyPrice), ColorScheme.GRAND_EXCHANGE_ALCH);
		buyPriceValue.setToolTipText(Numbers.numberWithCommas(buyPrice));
		buyPricePanel.add(buyPriceLabel, BorderLayout.WEST);
		buyPricePanel.add(buyPriceValue, BorderLayout.EAST);
		contentPanel1.add(buyPricePanel);

		JPanel profitPerPanel = new JPanel(new BorderLayout());
		profitPerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		int profitEach = flip.getSellPrice() - flip.getBuyPrice() - flip.getTax();
		String profitEachText = Numbers.toShortNumber(profitEach);
		Color profitEachColor = profitEach > 0 ? ColorScheme.GRAND_EXCHANGE_ALCH : ColorScheme.PROGRESS_ERROR_COLOR;
		JLabel profitPerLabel = newLeftLabel("Profit Per:");
		JLabel profitPerValue = newRightLabel(profitEachText, profitEachColor);
		profitPerValue.setToolTipText(Numbers.numberWithCommas(profitEach));
		profitPerPanel.add(profitPerLabel, BorderLayout.WEST);
		profitPerPanel.add(profitPerValue, BorderLayout.EAST);
		contentPanel1.add(profitPerPanel);

		JPanel taxPerPanel = new JPanel(new BorderLayout());
		taxPerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		int taxPer = flip.getTax();
		String taxPerText = Numbers.toShortNumber(taxPer);
		JLabel taxPerLabel = newLeftLabel("Tax Per:");
		JLabel taxPerValue = newRightLabel(taxPerText, ColorScheme.PROGRESS_ERROR_COLOR);
		taxPerValue.setToolTipText(Numbers.numberWithCommas(taxPer));
		taxPerPanel.add(taxPerLabel, BorderLayout.WEST);
		taxPerPanel.add(taxPerValue, BorderLayout.EAST);
		contentPanel1.add(taxPerPanel);

		column1.add(contentPanel1, BorderLayout.CENTER);

		JPanel column2 = new JPanel(new BorderLayout());
		column2.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel contentPanel2 = new JPanel(new GridLayout(0, 1));
		contentPanel2.setBackground(ColorScheme.DARK_GRAY_COLOR);

		JPanel sellPricePanel = new JPanel(new BorderLayout());
		sellPricePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		int sellPrice = flip.getSellPrice();
		String sellPriceText = Numbers.toShortNumber(sellPrice);
		JLabel sellPriceLabel = newLeftLabel("Sell Price:");
		JLabel sellPriceValue = newRightLabel(sellPriceText, ColorScheme.GRAND_EXCHANGE_ALCH);
		sellPriceValue.setToolTipText(Numbers.numberWithCommas(sellPrice));

		sellPricePanel.add(sellPriceLabel, BorderLayout.WEST);
		sellPricePanel.add(sellPriceValue, BorderLayout.EAST);
		contentPanel2.add(sellPricePanel);

		JPanel totalProfitPanel = new JPanel(new BorderLayout());
		totalProfitPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		int totalProfit = flip.getTotalProfit();
		String totalProfitText = Numbers.toShortNumber(totalProfit);
		Color profitColor = totalProfit > 0 ? ColorScheme.GRAND_EXCHANGE_ALCH : ColorScheme.PROGRESS_ERROR_COLOR;
		JLabel totalProfitLabel = newLeftLabel("Total Profit:");
		JLabel totalProfitValue = newRightLabel(totalProfitText, profitColor);
		totalProfitValue.setToolTipText(Numbers.numberWithCommas(totalProfit));
		totalProfitPanel.add(totalProfitLabel, BorderLayout.WEST);
		totalProfitPanel.add(totalProfitValue, BorderLayout.EAST);
		contentPanel2.add(totalProfitPanel);

		JPanel totalTaxPanel = new JPanel(new BorderLayout());
		totalTaxPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		int totalTax = flip.getTotalTax();
		String totalTaxText = Numbers.toShortNumber(totalTax);
		JLabel totalTaxLabel = newLeftLabel("Total Tax:");
		JLabel totalTaxValue = newRightLabel(totalTaxText, ColorScheme.PROGRESS_ERROR_COLOR);
		totalTaxValue.setToolTipText(Numbers.numberWithCommas(totalTax));
		totalTaxPanel.add(totalTaxLabel, BorderLayout.WEST);
		totalTaxPanel.add(totalTaxValue, BorderLayout.EAST);
		contentPanel2.add(totalTaxPanel);

		column2.add(contentPanel2, BorderLayout.CENTER);

		itemInfoContainer.add(column1);
		itemInfoContainer.add(column2);
	}
}

package com.flipper2.controllers;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.UUID;
import java.util.function.Consumer;
import java.awt.BorderLayout;

import javax.swing.JButton;
import javax.swing.SwingUtilities;

import com.flipper2.helpers.GrandExchange;
import com.flipper2.helpers.UiUtilities;
import com.flipper2.models.Transaction;
import com.flipper2.views.transactions.TransactionPanel;
import com.google.common.base.Supplier;
import com.flipper2.views.transactions.TransactionPage;
import com.flipper2.views.components.Pagination;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.client.game.ItemManager;
import net.runelite.client.callback.ClientThread;

public class TransactionController
{
	@Getter
	@Setter
	protected List<Transaction> transactions = new ArrayList<Transaction>();
	protected List<Transaction> filteredTransactions = new ArrayList<Transaction>();
	protected TransactionPage transactionPage;
	protected ItemManager itemManager;
	protected Pagination pagination;
	protected Consumer<UUID> removeTransactionConsumer;
	protected JButton extraComponent;
	protected boolean isPrompt;
	protected String searchText;
	protected Consumer<String> onSearchTextChangedCallback;
	protected ClientThread clientThread;

	public TransactionController(String name, ItemManager itemManager, boolean isPrompt, ClientThread clientThread) throws IOException
	{
		this.isPrompt = isPrompt;
		this.itemManager = itemManager;
		this.clientThread = clientThread;
		this.removeTransactionConsumer = id -> this.removeTransaction(id);

		Supplier<JButton> renderExtraComponentSupplier = () -> {
			return renderExtraComponent();
		};
		Consumer<Transaction> extraComponentPressedConsumer = (transaction) -> {
			this.extraComponentPressed(transaction);
		};
		Consumer<Object> renderItemCallback = (Object sell) -> {
			TransactionPanel transactionPanel = new TransactionPanel(
				name,
				(Transaction) sell,
				itemManager,
				this.removeTransactionConsumer,
				isPrompt
			);
			this.transactionPage.addTransactionPanel(transactionPanel);
		};
		Runnable buildViewCallback = () -> this.buildView();
		this.pagination = new Pagination(
			renderItemCallback,
			UiUtilities.ITEMS_PER_PAGE,
			buildViewCallback
		);
		this.onSearchTextChangedCallback = (searchText) -> this.onSearchTextChanged(searchText);
		this.transactionPage = new TransactionPage(this.onSearchTextChangedCallback);
		this.loadTransactions();
	}

	public void onSearchTextChanged(String searchText)
	{
		this.searchText = searchText;
		this.pagination.resetPage();
		this.buildView();
	}

	public void addTransaction(Transaction transaction)
	{
		this.transactions.add(transaction);
		this.buildView();
	}

	public Transaction upsertTransaction(GrandExchangeOffer offer, int slot)
	{

		ListIterator<Transaction> transactionsIter = transactions.listIterator(transactions.size());
		while (transactionsIter.hasPrevious())
		{
			Transaction transaction = transactionsIter.previous();

			if (GrandExchange.checkIsOfferPartOfTransaction(transaction, offer, slot))
			{
				Transaction updatedTransaction = transaction.updateTransaction(offer);
				transactionsIter.set(updatedTransaction);
				this.buildView();
				return updatedTransaction;
			}
		}


		Transaction newTransaction = GrandExchange.createTransactionFromOffer(offer, itemManager, slot);
		this.addTransaction(newTransaction);
		return newTransaction;
	}


	public void removeTransaction(UUID id)
	{
		ListIterator<Transaction> transactionIter = this.transactions.listIterator(this.transactions.size());
		while (transactionIter.hasPrevious())
		{
			Transaction transaction = transactionIter.previous();
			if (transaction.id.equals(id))
			{
				transactionIter.remove();
				this.buildView();
				return;
			}
		}
	}

	public void extraComponentPressed(Transaction transaction)
	{
	}

	;

	public JButton renderExtraComponent()
	{
		return null;
	}

	public void loadTransactions() throws IOException
	{
	}

	;

	public void saveTransactions()
	{
	}

	;

	public TransactionPage getPage()
	{
		return this.transactionPage;
	}

	private boolean isRender(Transaction transaction)
	{
		String itemName = transaction.getItemName();

		if (
			this.searchText != null &&
				itemName.toLowerCase().contains(this.searchText.toLowerCase())
		)
		{
			return true;
		}
		else if (this.searchText != null && this.searchText != "")
		{
			return false;
		}

		return true;
	}

	public void filterList()
	{
		if (this.searchText == "" || this.searchText == null)
		{
			this.filteredTransactions = this.transactions;
		}
		else
		{

			Iterator<Transaction> transactionIter = this.transactions.iterator();
			this.filteredTransactions = new ArrayList<Transaction>();
			while (transactionIter.hasNext())
			{
				Transaction currentTransaction = transactionIter.next();
				if (this.isRender(currentTransaction))
				{
					filteredTransactions.add(currentTransaction);
				}
			}
		}
	}

	public void buildView()
	{
		SwingUtilities.invokeLater(() -> {
			this.filterList();
			this.transactionPage.resetContainer();
			this.transactionPage.add(
				this.pagination.getComponent(this.filteredTransactions),
				BorderLayout.SOUTH
			);
			this.pagination.renderList(this.filteredTransactions);
		});
	}
}
package com.flipper2.controllers;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.UUID;
import java.util.function.Consumer;

import javax.swing.SwingUtilities;

import com.flipper2.helpers.GrandExchange;
import com.flipper2.helpers.Log;
import com.flipper2.helpers.Persistor;
import com.flipper2.helpers.UiUtilities;
import com.flipper2.models.Flip;
import com.flipper2.models.Transaction;
import com.flipper2.views.components.Pagination;
import com.flipper2.views.flips.FlipPage;
import com.flipper2.views.flips.FlipPanel;
import com.flipper2.FlipperConfig;

import lombok.Getter;
import lombok.Setter;

import java.awt.BorderLayout;

import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;

public class FlipsController
{
	@Getter
	@Setter
	private List<Flip> flips = new ArrayList<Flip>();
	private List<Flip> filteredFlips = new ArrayList<Flip>();
	private FlipPage flipPage;
	private Consumer<UUID> removeFlipConsumer;
	private Runnable refreshFlipsRunnable;
	private String totalProfit = "0";
	private Pagination pagination;
	private String searchText;
	private ItemManager itemManager;
	private Consumer<String> onSearchTextChangedCallback;
	private boolean isTrackingFlips = true;
	private ClientThread cThread;

	public FlipsController(ItemManager itemManager, FlipperConfig config, ClientThread cThread) throws IOException
	{
		this.itemManager = itemManager;
		this.cThread = cThread;
		this.removeFlipConsumer = id -> this.removeFlip(id);
		this.refreshFlipsRunnable = () -> this.loadFlips();
		this.onSearchTextChangedCallback = (searchText) -> this.onSearchTextChanged(searchText);


		this.flipPage = new FlipPage(
			refreshFlipsRunnable,
			this.onSearchTextChangedCallback,
			this::toggleIsTrackingFlips,
			this.isTrackingFlips
		);


		Consumer<Object> renderItemCallback = (Object flip) -> {
			FlipPanel flipPanel = new FlipPanel(
				(Flip) flip,
				itemManager,
				this.removeFlipConsumer,
				config.isPromptDeleteFlip()
			);
			this.flipPage.addFlipPanel(flipPanel);
		};

		Runnable buildViewCallback = () -> this.buildView();

		this.pagination = new Pagination(renderItemCallback, UiUtilities.ITEMS_PER_PAGE, buildViewCallback);
		this.loadFlips();
	}

	private void toggleIsTrackingFlips()
	{
		this.isTrackingFlips = !this.isTrackingFlips;
	}

	public void onSearchTextChanged(String searchText)
	{
		this.searchText = searchText;
		this.pagination.resetPage();
		this.buildView();
	}

	public void addFlip(Flip flip)
	{
		if (this.isTrackingFlips)
		{
			this.flips.add(0, flip);
			this.totalProfit = calculateTotalProfit(flips);
			Persistor.saveFlips(this.flips);
			getFlipNamesAndBuild();
		}
	}


	public void removeFlip(UUID flipId)
	{
		Iterator<Flip> flipsIter = this.flips.iterator();
		while (flipsIter.hasNext())
		{
			Flip flip = flipsIter.next();
			if (flip.getFlipId().equals(flipId))
			{
				flipsIter.remove();
				this.totalProfit = calculateTotalProfit(flips);
				Persistor.saveFlips(this.flips);
				this.buildView();
				return;
			}
		}
	}

	public FlipPage getPage()
	{
		return this.flipPage;
	}

	public void loadFlips()
	{
		try
		{
			this.flips = Persistor.loadFlips();
			this.totalProfit = calculateTotalProfit(flips);
			this.filteredFlips = new ArrayList<>(this.flips);
			getFlipNamesAndBuild();
		}
		catch (IOException e)
		{
			Log.info("Failed to load flips from file: " + e.getMessage());
			this.flips = new ArrayList<>();
			this.filteredFlips = new ArrayList<>();
		}
	}

	public void getFlipNamesAndBuild()
	{
		cThread.invoke(() -> {
			for (Flip flip : flips)
			{
				if (flip.getItemName() == null)
				{
					flip.setItemName(itemManager.getItemComposition(flip.getItemId()).getName());
				}
			}
			this.buildView();
		});
	}


	private String calculateTotalProfit(List<Flip> flipList)
	{
		int total = 0;
		for (Flip flip : flipList)
		{
			total += flip.getTotalProfit();
		}
		return String.valueOf(total);
	}

	private void updateFlip(Transaction sell, Transaction buy, Flip flip)
	{
		flip.setSellPrice(sell.getFinPricePer());
		flip.setBuyPrice(buy.getFinPricePer());
		flip.setQuantity(sell.getQuantity());
		flip.setItemId(sell.getItemId());
		flip.setItemName(sell.getItemName());
		this.totalProfit = calculateTotalProfit(flips);
		Persistor.saveFlips(this.flips);
		getFlipNamesAndBuild();
	}

	private boolean isRender(Flip flip)
	{

		if (flip.getItemName() == null)
		{
			ItemComposition itemComp = itemManager.getItemComposition(flip.getItemId());
			flip.setItemName(itemComp.getName());
		}
		String itemName = flip.getItemName();

		if (this.searchText != null &&
			itemName.toLowerCase().contains(this.searchText.toLowerCase()))
		{
			return true;
		}
		else if (this.searchText != null && !this.searchText.isEmpty())
		{
			return false;
		}

		return true;
	}

	/**
	 * Potentially creates a flip if the sell is complete and has a corresponding
	 * buy. This logic remains largely the same, but it now interacts with the local
	 * lists instead of the API.
	 */
	public Flip upsertFlip(Transaction sell, List<Transaction> buys)
	{
		ListIterator<Transaction> buysIterator = buys.listIterator(buys.size());


		if (sell.isFlipped())
		{
			ListIterator<Flip> flipsIterator = flips.listIterator();
			while (flipsIterator.hasNext())
			{
				Flip flip = flipsIterator.next();
				if (flip.getSellId().equals(sell.getId()))
				{

					while (buysIterator.hasPrevious())
					{
						Transaction buy = buysIterator.previous();
						if (buy.getId().equals(flip.getBuyId()))
						{
							updateFlip(sell, buy, flip);
							return flip;
						}
					}
				}
			}
		}
		else
		{

			if (this.isTrackingFlips)
			{
				while (buysIterator.hasPrevious())
				{
					Transaction buy = buysIterator.previous();
					if (GrandExchange.checkIsSellAFlipOfBuy(sell, buy))
					{
						Flip flip = new Flip(buy, sell);
						if (!flip.isMarginCheck())
						{
							this.addFlip(flip);
							buy.setIsFlipped(true);
							sell.setIsFlipped(true);
						}
						return flip;
					}
				}
			}
		}

		return null;
	}

	public void filterList()
	{
		if (this.searchText == null || this.searchText.isEmpty())
		{
			this.filteredFlips = new ArrayList<>(this.flips);
		}
		else
		{

			this.filteredFlips = new ArrayList<>();
			for (Flip flip : this.flips)
			{
				if (isRender(flip))
				{
					filteredFlips.add(flip);
				}
			}
		}
	}

	public void buildView()
	{

		SwingUtilities.invokeLater(() -> {
			this.filterList();
			this.flipPage.resetContainer(isTrackingFlips);
			this.flipPage.add(
				this.pagination.getComponent(this.filteredFlips),
				BorderLayout.SOUTH
			);
			this.pagination.renderFromBeginning(this.filteredFlips);
			this.flipPage.setTotalProfit(totalProfit);
			this.flipPage.revalidate();
			this.flipPage.repaint();
		});
	}

	public void saveTransactions()
	{
		Persistor.saveFlips(this.flips);
	}
}
package com.flipper2.controllers;

import java.io.IOException;

import com.flipper2.FlipperConfig;
import com.flipper2.helpers.Persistor;

import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;

public class BuysController extends TransactionController
{


	public BuysController(ItemManager itemManager, FlipperConfig config, ClientThread clientThread) throws IOException
	{
		super("Buy", itemManager, config.isPromptDeleteBuy(), clientThread);
	}


	@Override
	public void loadTransactions() throws IOException
	{
		this.transactions = Persistor.loadBuys();
		this.filteredTransactions = this.transactions;
		this.buildView();
	}

	@Override
	public void saveTransactions()
	{
		Persistor.saveBuys(this.transactions);
	}
}
package com.flipper2.controllers;

import java.io.IOException;

import com.flipper2.FlipperConfig;
import com.flipper2.helpers.Persistor;
import net.runelite.client.game.ItemManager;
import net.runelite.client.callback.ClientThread;

public class SellsController extends TransactionController
{
	public SellsController(ItemManager itemManager, FlipperConfig config, ClientThread clientThread) throws IOException
	{
		super("Sell", itemManager, config.isPromptDeleteSell(), clientThread);
	}

	@Override
	public void loadTransactions() throws IOException
	{
		this.transactions = Persistor.loadSells();
		this.filteredTransactions = this.transactions;
		this.buildView();
	}

	@Override
	public void saveTransactions()
	{
		Persistor.saveSells(this.transactions);
	}
}
/*
 * Copyright (c) 2020, Kyle Richardson <https://github.com/Sir-Kyle-Richardson>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.flipper2;

import com.flipper2.controllers.BuysController;
import com.flipper2.controllers.FlipsController;
import com.flipper2.controllers.SellsController;
import com.flipper2.helpers.GrandExchange;
import com.flipper2.helpers.Log;
import com.flipper2.helpers.Persistor;
import com.flipper2.helpers.UiUtilities;
import com.flipper2.models.Transaction;
import com.flipper2.views.TabManager;
import com.flipper2.views.inprogress.InProgressPage;
import com.google.gson.Gson;
import com.google.inject.Provides;

import java.io.IOException;
import java.util.List;

import javax.inject.Inject;
import javax.swing.SwingUtilities;

import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.api.GameState;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import java.awt.image.BufferedImage;

@PluginDescriptor(name = "Flipper2")
public class FlipperPlugin extends Plugin
{
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private ItemManager itemManager;
	@Inject
	private FlipperConfig config;
	@Inject
	private ClientThread cThread;
	@Inject
	private Client client;
	private BuysController buysController;
	private SellsController sellsController;
	private FlipsController flipsController;

	private NavigationButton navButton;
	private TabManager tabManager;
	@Inject
	private InProgressPage inProgressPage;
	@Inject
	private Gson gson;

	@Override
	protected void startUp() throws Exception
	{
		try
		{
			Persistor.setUp();
			Persistor.gson = this.gson;
			this.tabManager = new TabManager();
			this.setUpNavigationButton();
			this.buysController = new BuysController(itemManager, config, cThread);
			this.sellsController = new SellsController(itemManager, config, cThread);
			this.flipsController = new FlipsController(itemManager, config, cThread);
			this.changeToLoggedInView();

		}
		catch (Exception e)
		{
			Log.info("Flipper2 failed to start: " + e.getMessage());
		}
	}

	private void setUpNavigationButton()
	{
		navButton = NavigationButton
			.builder()
			.tooltip("Flipper2")
			.icon(
				ImageUtil.loadImageResource(
					getClass(),
					UiUtilities.flipperNavIcon
				)
			)
			.priority(4)
			.panel(tabManager).build();
		clientToolbar.addNavigation(navButton);
	}

	private void changeToLoggedInView()
	{
		SwingUtilities.invokeLater(() -> {
			this.tabManager.renderLoggedInView(
				buysController.getPage(),
				sellsController.getPage(),
				flipsController.getPage(),
				inProgressPage
			);
		});
	}

	private void saveAll()
	{
		try
		{
			buysController.saveTransactions();
			sellsController.saveTransactions();
			flipsController.saveTransactions();
		}
		catch (Exception error)
		{
			Log.info("Failed to save Flipper2 files");
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(navButton);
		this.saveAll();
	}

	@Subscribe
	public void onClientShutdown(ClientShutdown clientShutdownEvent) throws IOException
	{
		this.saveAll();
	}

	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged newOfferEvent)
	{
		int slot = newOfferEvent.getSlot();
		GrandExchangeOffer offer = newOfferEvent.getOffer();
		GrandExchangeOfferState offerState = offer.getState();

		if (offerState == GrandExchangeOfferState.EMPTY && client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if (GrandExchange.checkIsBuy(offerState))
		{
			if (offerState == GrandExchangeOfferState.BOUGHT ||
				(offerState == GrandExchangeOfferState.CANCELLED_BUY && offer.getQuantitySold() > 0))
			{
				Transaction buy = buysController.upsertTransaction(offer, slot);
				if (buy != null)
				{
					buysController.saveTransactions();
					List<Transaction> sells = sellsController.getTransactions();
					flipsController.upsertFlip(buy, sells);
				}
			}
		}
		else
		{
			if (offerState == GrandExchangeOfferState.SOLD ||
				(offerState == GrandExchangeOfferState.CANCELLED_SELL && offer.getQuantitySold() > 0))
			{
				Transaction sell = sellsController.upsertTransaction(offer, slot);
				if (sell != null)
				{
					sellsController.saveTransactions();
					List<Transaction> buys = buysController.getTransactions();
					flipsController.upsertFlip(sell, buys);
				}
			}
		}

		updatePanel(slot, offer);
	}

	private void updatePanel(int slot, GrandExchangeOffer offer)
	{
		cThread.invoke(() -> {
			ItemComposition offerItem = itemManager.getItemComposition(offer.getItemId());
			BufferedImage itemImage = itemManager.getImage(offer.getItemId(), 1, false);
			SwingUtilities.invokeLater(() -> inProgressPage.updateOffer(offerItem, itemImage, offer, slot));
		});
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN)
		{
			inProgressPage.resetOffers();
		}
	}

	@Provides
	FlipperConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FlipperConfig.class);
	}
}
//package com.flipper2;
//
//import java.io.File;
//import java.nio.file.Path;
//import java.nio.file.Paths;
//
//import com.flipper2.helpers.Persistor;
//
//public class TestUtilities {
//    public static void cleanTestResultFiles() {
//        Path currentRelativePath = Paths.get("");
//        String testFilePath = currentRelativePath.toAbsolutePath().toString()
//                + "\\src\\test\\java\\com\\flipper2\\test-result-files";
//        // Delete any generated test-result-files
//        File deleteBuys = new File(testFilePath + "\\" + Persistor.BUYS_JSON_FILE);
//        File deleteSells = new File(testFilePath + "\\" + Persistor.SELLS_JSON_FILE);
//        deleteBuys.delete();
//        deleteSells.delete();
//
//    }
//
//}
package com.flipper2;

import java.io.IOException;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FlipperPluginTest
{
	/**
	 * Loads plugin with mock data from mocks/*.json
	 *
	 * @param args
	 * @throws Exception
	 */
	public static void main(String[] args) throws Exception, IOException
	{
		ExternalPluginManager.loadBuiltin(FlipperPlugin.class);
		RuneLite.main(args);
	}
}
