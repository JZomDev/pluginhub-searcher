package com.afkoverlay;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;
import java.awt.*;

public class AFKOverlay extends Overlay {
    private final Client client;
    private final PlayerInfo playerInfo;

    @Inject
    public AFKOverlay(Client client, PlayerInfo playerInfo) {
        this.client = client;
        this.playerInfo = playerInfo;
        
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (client.getGameState() != net.runelite.api.GameState.LOGGED_IN) {
            return null;
        }

        // This overlay is currently not used since we're using a floating window
        // but it's here for potential future use or as a fallback
        return null;
    }
} 
package com.afkoverlay;

import net.runelite.client.config.*;

import java.awt.Color;

@ConfigGroup("afkoverlay")
public interface AFKOverlayConfig extends Config {

    // --- Hitpoints Section ---
    @ConfigSection(
        name = "Hitpoints",
        description = "Highlight background when hitpoints are low.",
        position = 20
    )
    String hitpointsSection = "hitpointsSection";

    @ConfigItem(
        keyName = "showHp",
        name = "Show Hitpoints",
        description = "Display hitpoints in the overlay.",
        section = hitpointsSection,
        position = 1
    )
default boolean showHp() { return true; }

    @ConfigItem(
        keyName = "highlightHpBackground",
        name = "Highlight background when low",
        description = "Highlight background when hitpoints are low.",
        section = hitpointsSection,
        position = 2
    )
    default boolean highlightHpBackground() { return false; }

    @ConfigItem(
        keyName = "lowHpThresholdValue",
        name = "Threshold value",
        description = "Show highlight when HP is at or below this value.",
        section = hitpointsSection,
        position = 3
    )
    @Range(min = 1, max = 99)
    default int lowHpThresholdValue() { return 10; }

    @Alpha
    @ConfigItem(
        keyName = "lowHpOverlayColor",
        name = "Threshold color",
        description = "Background color when HP is low.",
        section = hitpointsSection,
        position = 4
    )
    default Color lowHpOverlayColor() { return new Color(0xFF020421); }

    @ConfigItem(
        keyName = "playHpSound",
        name = "Play sound",
        description = "Play a sound when HP is at or below the threshold.",
        section = hitpointsSection,
        position = 5
    )
    default boolean playHpSound() { return false; }

    // --- Prayer Section ---
    @ConfigSection(
        name = "Prayer",
        description = "Highlight background when prayer is low.",
        position = 30
    )
    String prayerSection = "prayerSection";

    @ConfigItem(
        keyName = "showPrayer",
        name = "Show Prayer",
        description = "Display prayer points in the overlay.",
        section = prayerSection,
        position = 1
    )
    default boolean showPrayer() { return true; }

    @ConfigItem(
        keyName = "highlightPrayerBackground",
        name = "Highlight background when low",
        description = "Highlight background when prayer is low.",
        section = prayerSection,
        position = 2
    )
    default boolean highlightPrayerBackground() { return false; }

    @ConfigItem(
        keyName = "lowPrayerThresholdValue",
        name = "Threshold value",
        description = "Show highlight when prayer is at or below this value.",
        section = prayerSection,
        position = 3
    )
    @Range(min = 1, max = 99)
    default int lowPrayerThresholdValue() { return 10; }

    @Alpha
    @ConfigItem(
        keyName = "lowPrayerOverlayColor",
        name = "Threshold color",
        description = "Background color when prayer is low.",
        section = prayerSection,
        position = 4
    )
    default Color lowPrayerOverlayColor() { return new Color(0xFF020421); }

    @ConfigItem(
        keyName = "playPrayerSound",
        name = "Play sound",
        description = "Play a sound when prayer is at or below the threshold.",
        section = prayerSection,
        position = 5
    )
    default boolean playPrayerSound() { return false; }

    // --- Inventory Section ---
    @ConfigSection(
        name = "Inventory",
        description = "Highlight background based on inventory items.",
        position = 40
    )
    String inventorySection = "inventorySection";

    // --- Special Attack Section ---
    @ConfigSection(
        name = "Special Attack",
        description = "Highlight background when special attack is high.",
        position = 45
    )
    String specialAttackSection = "specialAttackSection";

    @ConfigItem(
        keyName = "showSpecialAttack",
        name = "Show Special Attack",
        description = "Display special attack energy in the overlay.",
        section = specialAttackSection,
        position = 1
    )
    default boolean showSpecialAttack() { return true; }

    @ConfigItem(
        keyName = "highlightSpecialAttackBackground",
        name = "Highlight background when high",
        description = "Highlight background when special attack is high.",
        section = specialAttackSection,
        position = 2
    )
    default boolean highlightSpecialAttackBackground() { return false; }

    @ConfigItem(
        keyName = "highSpecialAttackThresholdValue",
        name = "Threshold value",
        description = "Show highlight when Special Attack is at or above this value.",
        section = specialAttackSection,
        position = 3
    )
    @Range(min = 1, max = 100)
    default int highSpecialAttackThresholdValue() { return 50; }

    @Alpha
    @ConfigItem(
        keyName = "highSpecialAttackOverlayColor",
        name = "Threshold color",
        description = "Background color when Special Attack is high.",
        section = specialAttackSection,
        position = 4
    )
    default Color highSpecialAttackOverlayColor() { return new Color(0xFF020421); }

    @ConfigItem(
        keyName = "playSpecialAttackSound",
        name = "Play sound",
        description = "Play a sound when Special Attack is at or above the threshold.",
        section = specialAttackSection,
        position = 5
    )
    default boolean playSpecialAttackSound() { return false; }

    @ConfigItem(
        keyName = "showInventory",
        name = "Show Inventory",
        description = "Display inventory usage in the overlay.",
        section = inventorySection,
        position = 1
    )
    default boolean showInventory() { return true; }

    @ConfigItem(
        keyName = "highlightInvBackground",
        name = "Highlight background",
        description = "Highlight background based on inventory items.",
        section = inventorySection,
        position = 2
    )
    default boolean highlightInvBackground() { return false; }

    enum InventoryHighlightMode {
        ABOVE,
        BELOW,
        EQUALS
    }

    @ConfigItem(
        keyName = "invHighlightMode",
        name = "Highlight when",
        description = "Highlight when inventory items are above, below, or equal to the threshold.",
        section = inventorySection,
        position = 3
    )
    default InventoryHighlightMode invHighlightMode() { return InventoryHighlightMode.ABOVE; }

    @ConfigItem(
        keyName = "invThresholdValue",
        name = "Threshold value",
        description = "Number of inventory items to trigger highlight.",
        section = inventorySection,
        position = 4
    )
    @Range(min = 1, max = 28)
    default int invThresholdValue() { return 28; }

    @Alpha
    @ConfigItem(
        keyName = "invOverlayColor",
        name = "Threshold color",
        description = "Background color when inventory highlight is triggered.",
        section = inventorySection,
        position = 5
    )
    default Color invOverlayColor() { return new Color(0xFF020421); }

    @ConfigItem(
        keyName = "playInvSound",
        name = "Play sound",
        description = "Play a sound when inventory highlight is triggered.",
        section = inventorySection,
        position = 6
    )
    default boolean playInvSound() { return false; }

    // --- Status Section ---
    @ConfigSection(
        name = "Status",
        description = "Highlight background when idle.",
        position = 50
    )
    String statusSection = "statusSection";

    @ConfigItem(
        keyName = "showStatus",
        name = "Show Status",
        description = "Display status (active/idle) in the overlay.",
        section = statusSection,
        position = 1
    )
    default boolean showStatus() { return true; }

    @ConfigItem(
        keyName = "highlightIdleBackground",
        name = "Highlight background when idle",
        description = "Highlight background when status is idle.",
        section = statusSection,
        position = 2
    )
    default boolean highlightIdleBackground() { return false; }

    @Alpha
    @ConfigItem(
        keyName = "idleOverlayColor",
        name = "Threshold color",
        description = "Background color when idle status is triggered.",
        section = statusSection,
        position = 3
    )
    default Color idleOverlayColor() { return new Color(0xFF020421); }

    @ConfigItem(
        keyName = "idleThresholdMs",
        name = "Idle threshold (ms)",
        description = "Time in milliseconds before player is considered idle.",
        section = statusSection,
        position = 4
    )
    @Range(min = 500, max = 10000)
    default int idleThresholdMs() { return 1200; }

    @ConfigItem(
        keyName = "playIdleSound",
        name = "Play sound when idle",
        description = "Play a sound when the player is idle.",
        section = statusSection,
        position = 5
    )
    default boolean playIdleSound() { return false; }

    // --- Window Settings Section ---
    @ConfigSection(
        name = "General Settings",
        description = "Configure general settings.",
        position = 60
    )
    String windowSection = "windowSection";

    @ConfigItem(
        keyName = "opacity",
        name = "Opacity",
        description = "Set the opacity level of the overlay (0 = fully transparent, 255 = fully opaque)",
        section = windowSection,
        position = 1
    )
    @Range(min = 0, max = 255)
    default int opacity() {
        return 200;
    }

    @ConfigItem(
        keyName = "showCloseButton",
        name = "Show Close Button",
        description = "Show a close button on the overlay",
        section = windowSection,
        position = 2
    )
    default boolean showCloseButton() {
        return true;
    }

    @ConfigItem(
        keyName = "showMinimizeButton",
        name = "Show Minimize Button",
        description = "Show a minimize button on the overlay",
        section = windowSection,
        position = 3
    )
    default boolean showMinimizeButton() {
        return true;
    }


    @ConfigItem(
        keyName = "showCharacterName",
        name = "Show Character Name",
        description = "Show the character name in the overlay.",
        section = windowSection,
        position = 4
    )
    default boolean showCharacterName() { return true; }

    @ConfigItem(
        keyName = "showWindowBorder",
        name = "Show Window Border",
        description = "Show the window border.",
        section = windowSection,
        position = 5
    )
    default boolean showWindowBorder() { return true; }

    @ConfigItem(
        keyName = "soundVolume",
        name = "Sound Volume",
        description = "Volume for the threshold sounds.",
        section = windowSection,
        position = 6
    )
    @Range(min = 0, max = 100)
    default int soundVolume() { return 50; }

        @ConfigItem(
            keyName = "resetPosition",
            name = "Reset Position",
            description = "Click to reset the overlay window position to default (100, 100). (Check box on and off)",
            section = windowSection,
            position = 7
        )
        default boolean resetPosition() { return false; }

    @ConfigItem(
        keyName = "showOverlay",
        name = "Restore Overlay",
        description = "Click to restore the overlay window if it was closed or hidden. (Check box on and off)",
        section = windowSection,
        position = 8
    )
    default boolean showOverlay() { return false; }

}

package com.afkoverlay;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.config.ConfigManager;

public class FloatingOverlayWindow extends JFrame {
    // Constants
    private static class Constants {
        // Window sizing
        static final int RESIZE_BORDER = 5;
        static final int MIN_WIDTH = 50;
        static final int MIN_HEIGHT = 50;
        static final int MAX_WIDTH = 400;
        static final int MAX_HEIGHT = 250;
        
        // Content sizing
        static final int MIN_ICON_SIZE = 18;
        static final int MAX_ICON_SIZE = 36;
        static final int MIN_FONT_SIZE = 14;
        static final int MAX_FONT_SIZE = 22;
        static final int SCALING_BUFFER = 20;
        static final double SCALING_FACTOR = 0.5;
        static final double MAX_SCALING = 1.8;
        
        // Layout
        static final int TITLE_BAR_HEIGHT = 20;
        static final int PADDING = 12;
        static final int COMPONENT_SPACING = 8;
        static final int ICON_TEXT_GAP = 6;
        static final int BUTTON_SIZE = 20;
        static final int BUTTON_SPACING = 4;
        static final int DRAG_AREA_HEIGHT = 30;
        
        // Colors
        static final Color DARK_BORDER_COLOR = new Color(60, 60, 60, 200);
        static final Color DARK_TEXT_COLOR = new Color(220, 220, 220);
        static final Color HP_COLOR = new Color(255, 120, 120);
        static final Color PRAYER_COLOR = new Color(100, 150, 255);
        static final Color IDLE_COLOR = new Color(255, 180, 100);
        static final Color ACTIVE_COLOR = new Color(120, 255, 120);
        static final Color WARNING_COLOR = new Color(255, 200, 100);
        static final Color DANGER_COLOR = new Color(255, 100, 100);
        static final Color WHITE = Color.WHITE;
    }

    // Instance variables
    private final PlayerInfo playerInfo;
    private final AFKOverlayConfig config;
    private final ConfigManager configManager;
    private JPanel contentPanel;
    private JPanel infoPanel;
    private JLabel hpLabel;
    private JLabel prayerLabel;
    private JLabel statusLabel;
    private JLabel inventoryLabel;
    private JLabel specialAttackLabel;
    private JPanel titleBar;
    private JLabel characterNameLabel;
    private Window runeliteWindow;
    
    // Icons
    private BufferedImage hpIcon;
    private BufferedImage prayerIcon;
    private BufferedImage inventoryIcon;
    private BufferedImage specialAttackIcon;
    private BufferedImage protectMeleeIcon;
    private BufferedImage protectMagicIcon;
    private BufferedImage protectRangedIcon;
    
    // Interaction state
    private Point dragPoint;
    private boolean isDragging = false;
    private boolean isResizing = false;
    private int resizeEdge = 0; // 0=none, 1=right, 2=bottom, 3=corner

    public FloatingOverlayWindow(PlayerInfo playerInfo, AFKOverlayConfig config, ConfigManager configManager) {
        this.playerInfo = playerInfo;
        this.config = config;
        this.configManager = configManager;
        
        initializeWindow();
        loadIcons();
        setupContentPanel();
        setupLabels();
        setupLayout();
        setupEventListeners();
        
        // Load saved position and size, or use defaults
        if (!loadPositionAndSize()) {
            setSize(250, 150);
        }
        
        validatePosition();
        updateComponentSizes();
        updateDisplay();
    }
    
    private void initializeWindow() {
        setTitle("AFK Overlay");
        setUndecorated(true);
        setAlwaysOnTop(true);
        setType(Type.NORMAL);
        setResizable(false);
        setBackground(new Color(0, 0, 0, 0));
        
        // Try to find the RuneLite window
        try {
            this.runeliteWindow = findRuneLiteWindow();
        } catch (Exception e) {
            // Ignore if we can't find it
        }
    }
    
    private void setupContentPanel() {
        contentPanel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g.create();
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
                
                // Create rounded rectangle background
                RoundRectangle2D roundedRectangle = new RoundRectangle2D.Float(
                    0, 0, getWidth(), getHeight(), 12, 12);
                
                // Fill background with appropriate color
                g2d.setColor(getBackgroundColor());
                g2d.fill(roundedRectangle);
                
                // Draw border
                if (config.showWindowBorder()) {
                    g2d.setColor(Constants.DARK_BORDER_COLOR);
                    g2d.setStroke(new BasicStroke(1.5f));
                    g2d.draw(roundedRectangle);
                }
                
                g2d.dispose();
            }
        };
        
        contentPanel.setLayout(new BorderLayout(Constants.COMPONENT_SPACING, Constants.COMPONENT_SPACING));
        contentPanel.setBorder(BorderFactory.createEmptyBorder(Constants.PADDING, Constants.PADDING, Constants.PADDING, Constants.PADDING));
        contentPanel.setOpaque(false);
    }
    
    private Color getBackgroundColor() {
        // Default background
        Color backgroundColor = new Color(30, 30, 30, config.opacity());
        
        // Priority: HP > Prayer > Status > Inventory
        int hpValue = playerInfo.getCurrentHp();
        int prayerValue = playerInfo.getCurrentPrayer();
        int invCount = playerInfo.getInventoryUsedSlots();
        
        if (config.highlightHpBackground() && hpValue <= config.lowHpThresholdValue()) {
            backgroundColor = config.lowHpOverlayColor();
        } else if (config.highlightPrayerBackground() && prayerValue <= config.lowPrayerThresholdValue()) {
            backgroundColor = config.lowPrayerOverlayColor();
        } else if (config.highlightIdleBackground() && playerInfo.isIdle()) {
            backgroundColor = config.idleOverlayColor();
        } else if (config.highlightSpecialAttackBackground() && playerInfo.getSpecialAttackEnergyPercentage() >= config.highSpecialAttackThresholdValue()) {
            backgroundColor = config.highSpecialAttackOverlayColor();
        } else if (config.highlightInvBackground()) {
            boolean highlight = false;
            switch (config.invHighlightMode()) {
                case ABOVE:
                    highlight = invCount > config.invThresholdValue();
                    break;
                case BELOW:
                    highlight = invCount < config.invThresholdValue();
                    break;
                case EQUALS:
                    highlight = invCount == config.invThresholdValue();
            }
            if (highlight) {
                backgroundColor = config.invOverlayColor();
            }
        }
        
        return backgroundColor;
    }
    
    private void setupLabels() {
        hpLabel = createLabel("", hpIcon);
        prayerLabel = createLabel("", prayerIcon);
        statusLabel = createLabel("Status: ACTIVE", null);
        inventoryLabel = createLabel("", inventoryIcon);
        specialAttackLabel = createLabel("", specialAttackIcon);
    }
    
    private void setupLayout() {
        // Create info panel
        infoPanel = new JPanel();
        infoPanel.setLayout(new BoxLayout(infoPanel, BoxLayout.Y_AXIS));
        infoPanel.setOpaque(false);
        
        // Conditionally add components based on config
        addComponentIfVisible(config.showHp(), hpLabel);
        addComponentIfVisible(config.showPrayer(), prayerLabel);
        addComponentIfVisible(config.showInventory(), inventoryLabel);
        addComponentIfVisible(config.showSpecialAttack(), specialAttackLabel);
        addComponentIfVisible(config.showStatus(), statusLabel);
        
        contentPanel.add(infoPanel, BorderLayout.CENTER);
        
        // Create title bar
        titleBar = createTitleBar();
        contentPanel.add(titleBar, BorderLayout.NORTH);
        
        // Add content panel to frame
        setContentPane(contentPanel);
    }
    
    private void addComponentIfVisible(boolean isVisible, JComponent component) {
        if (isVisible) {
            infoPanel.add(component);
            infoPanel.add(Box.createVerticalStrut(Constants.COMPONENT_SPACING));
        }
    }
    
    private JPanel createTitleBar() {
        JPanel titleBar = new JPanel(new BorderLayout());
        titleBar.setOpaque(false);
        titleBar.setPreferredSize(new Dimension(0, Constants.TITLE_BAR_HEIGHT));
        
        // Create character name label
        characterNameLabel = new JLabel("");
        characterNameLabel.setFont(new Font("Arial", Font.BOLD, Constants.MIN_FONT_SIZE));
        characterNameLabel.setForeground(Constants.DARK_TEXT_COLOR);
        characterNameLabel.setBorder(BorderFactory.createEmptyBorder(0, Constants.PADDING, 0, 0));
        
        // Add character name on the left
        if (config.showCharacterName()) {
            titleBar.add(characterNameLabel, BorderLayout.WEST);
        }
        
        // Add buttons on the right
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, Constants.BUTTON_SPACING, 0));
        buttonPanel.setOpaque(false);
        
        if (config.showMinimizeButton()) {
            buttonPanel.add(createCustomButton("−"));
        }
        
        if (config.showCloseButton()) {
            buttonPanel.add(createCustomButton("×"));
        }
        
        titleBar.add(buttonPanel, BorderLayout.EAST);
        return titleBar;
    }
    
    private JButton createCustomButton(String text) {
        JButton button = new JButton(text) {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g.create();
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                
                // Only show background on hover
                if (getModel().isRollover()) {
                    g2d.setColor(new Color(0, 0, 0, 120)); // Semi-transparent black
                    g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 4, 4);
                }
                
                // Draw text in dark theme color
                g2d.setColor(Constants.DARK_TEXT_COLOR);
                g2d.setFont(new Font("Segoe UI", Font.PLAIN, 10)); // Better font
                
                FontMetrics fm = g2d.getFontMetrics();
                int textX = (getWidth() - fm.stringWidth(text)) / 2;
                int textY = (getHeight() + fm.getAscent()) / 2 - 1; // Better centering
                g2d.drawString(text, textX, textY);
                
                g2d.dispose();
            }
        };
        
        button.setPreferredSize(new Dimension(Constants.BUTTON_SIZE, Constants.BUTTON_SIZE));
        button.setFocusPainted(false);
        button.setBorderPainted(false);
        button.setContentAreaFilled(false);
        button.setOpaque(false);
        
        // Add action listeners based on button type
        if ("−".equals(text)) {
            button.addActionListener(e -> {
                setState(Frame.ICONIFIED);
                setAlwaysOnTop(false);
            });
        } else if ("×".equals(text)) {
            button.addActionListener(e -> setVisible(false));
        }
        
        return button;
    }
    
    private JLabel createLabel(String text, BufferedImage icon) {
        JLabel label = new JLabel(text);
        label.setFont(new Font("Arial", Font.BOLD, Constants.MIN_FONT_SIZE));
        label.setForeground(Constants.DARK_TEXT_COLOR);
        
        // Set icon if available
        if (icon != null) {
            label.setIcon(new ImageIcon(icon));
            label.setIconTextGap(Constants.ICON_TEXT_GAP);
        }
        
        return label;
    }
    
    private void setupEventListeners() {
        // Window listeners
        addWindowListener(new WindowAdapter() {
            @Override
            public void windowDeiconified(WindowEvent e) {
                setAlwaysOnTop(true);
            }
            
            @Override
            public void windowClosing(WindowEvent e) {
                savePositionAndSize();
            }
            
            @Override
            public void windowClosed(WindowEvent e) {
                savePositionAndSize();
            }
        });
        
        // Component listeners
        addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                savePositionAndSize();
            }
            
            @Override
            public void componentMoved(ComponentEvent e) {
                savePositionAndSize();
            }
        });
        
        // Mouse listeners for dragging and resizing
        addMouseListeners();
    }
    
    private void addMouseListeners() {
        addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                Point p = e.getPoint();
                int width = getWidth();
                int height = getHeight();
                
                // Check if clicking on resize areas
                if (p.x > width - Constants.RESIZE_BORDER && p.y > height - Constants.RESIZE_BORDER) {
                    isResizing = true;
                    resizeEdge = 3; // corner
                    setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR));
                } else if (p.x > width - Constants.RESIZE_BORDER) {
                    isResizing = true;
                    resizeEdge = 1; // right edge
                    setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR));
                } else if (p.y > height - Constants.RESIZE_BORDER) {
                    isResizing = true;
                    resizeEdge = 2; // bottom edge
                    setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR));
                } else if (p.y < Constants.DRAG_AREA_HEIGHT) { // Top area for dragging
                    isDragging = true;
                    dragPoint = p;
                    setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
                }
            }
            
            @Override
            public void mouseReleased(MouseEvent e) {
                if (isDragging || isResizing) {
                    savePositionAndSize();
                    validatePosition();
                    updateComponentSizes();
                }
                
                isDragging = false;
                isResizing = false;
                resizeEdge = 0;
                setCursor(Cursor.getDefaultCursor());
            }
            
            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getButton() == MouseEvent.BUTTON1 && !isResizing && !isDragging) {
                    focusRuneLiteWindow();
                }
            }
        });
        
        addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseDragged(MouseEvent e) {
                if (isDragging) {
                    Point p = getLocation();
                    setLocation(p.x + e.getX() - dragPoint.x, p.y + e.getY() - dragPoint.y);
                } else if (isResizing) {
                    Point p = e.getPoint();
                    int newWidth = getWidth();
                    int newHeight = getHeight();
                    
                    if (resizeEdge == 1 || resizeEdge == 3) { // right edge or corner
                        newWidth = Math.max(Constants.MIN_WIDTH, Math.min(Constants.MAX_WIDTH, p.x));
                    }
                    if (resizeEdge == 2 || resizeEdge == 3) { // bottom edge or corner
                        newHeight = Math.max(Constants.MIN_HEIGHT, Math.min(Constants.MAX_HEIGHT, p.y));
                    }
                    
                    setSize(newWidth, newHeight);
                }
            }
            
            @Override
            public void mouseMoved(MouseEvent e) {
                Point p = e.getPoint();
                int width = getWidth();
                int height = getHeight();
                
                if (p.x > width - Constants.RESIZE_BORDER && p.y > height - Constants.RESIZE_BORDER) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR));
                } else if (p.x > width - Constants.RESIZE_BORDER) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR));
                } else if (p.y > height - Constants.RESIZE_BORDER) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR));
                } else if (p.y < Constants.DRAG_AREA_HEIGHT) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
                } else {
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                }
            }
        });
    }
    
    private boolean loadPositionAndSize() {
        int x = 100;
        int y = 100;
        int width = 250;
        int height = 150;
        
        boolean loadedFromConfig = false;
        
        if (configManager != null) {
            try {
                String xStr = configManager.getConfiguration("afkoverlay", "windowX", String.class);
                String yStr = configManager.getConfiguration("afkoverlay", "windowY", String.class);
                String widthStr = configManager.getConfiguration("afkoverlay", "windowWidth", String.class);
                String heightStr = configManager.getConfiguration("afkoverlay", "windowHeight", String.class);
                
                if (xStr != null && yStr != null && widthStr != null && heightStr != null) {
                    x = Integer.parseInt(xStr);
                    y = Integer.parseInt(yStr);
                    width = Integer.parseInt(widthStr);
                    height = Integer.parseInt(heightStr);
                    
                    // Ensure minimum dimensions
                    width = Math.max(width, Constants.MIN_WIDTH);
                    height = Math.max(height, Constants.MIN_HEIGHT);
                    
                    setBounds(x, y, width, height);
                    
                    loadedFromConfig = true;
                } else {
                    setBounds(x, y, width, height);
                }
            } catch (Exception e) {
                setBounds(x, y, width, height);
            }
        } else {
            setBounds(x, y, width, height);
        }
        
        return loadedFromConfig;
    }
    
    public void savePositionAndSize() {
        if (configManager != null) {
            int x = getX();
            int y = getY();
            int width = getWidth();
            int height = getHeight();
            
            configManager.setConfiguration("afkoverlay", "windowX", String.valueOf(x));
            configManager.setConfiguration("afkoverlay", "windowY", String.valueOf(y));
            configManager.setConfiguration("afkoverlay", "windowWidth", String.valueOf(width));
            configManager.setConfiguration("afkoverlay", "windowHeight", String.valueOf(height));
        }
    }
    
    private void validatePosition() {
        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice[] devices = ge.getScreenDevices();
        
        // Find the screen that contains the window
        Rectangle windowBounds = getBounds();
        Rectangle screenBounds = null;
        
        for (GraphicsDevice device : devices) {
            Rectangle deviceBounds = device.getDefaultConfiguration().getBounds();
            if (deviceBounds.intersects(windowBounds)) {
                screenBounds = deviceBounds;
                break;
            }
        }
        
        // If no screen contains the window, use the primary screen
        if (screenBounds == null) {
            screenBounds = ge.getDefaultScreenDevice().getDefaultConfiguration().getBounds();
        }
        
        // Ensure window is within screen bounds
        int x = windowBounds.x;
        int y = windowBounds.y;
        int width = windowBounds.width;
        int height = windowBounds.height;
        
        // Adjust if window is outside screen bounds
        if (x + width > screenBounds.x + screenBounds.width) {
            x = screenBounds.x + screenBounds.width - width;
        }
        if (y + height > screenBounds.y + screenBounds.height) {
            y = screenBounds.y + screenBounds.height - height;
        }
        if (x < screenBounds.x) {
            x = screenBounds.x;
        }
        if (y < screenBounds.y) {
            y = screenBounds.y;
        }
        
        // Ensure minimum size
        if (width < Constants.MIN_WIDTH) width = Constants.MIN_WIDTH;
        if (height < Constants.MIN_HEIGHT) height = Constants.MIN_HEIGHT;
        
        setBounds(x, y, width, height);
    }
    
    public void resetPosition() {
        setLocation(100, 100);
        validatePosition();
        savePositionAndSize();
    }
    
    public void updateConfig() {
        if (config.resetPosition()) {
            resetPosition();
            if (configManager != null) {
                configManager.setConfiguration("afkoverlay", "resetPosition", false);
            }
        }
        
        // Update title bar
        contentPanel.remove(titleBar);
        titleBar = createTitleBar();
        contentPanel.add(titleBar, BorderLayout.NORTH);
        
        // Update component visibility
        hpLabel.setVisible(config.showHp());
        prayerLabel.setVisible(config.showPrayer());
        statusLabel.setVisible(config.showStatus());
        inventoryLabel.setVisible(config.showInventory());
        specialAttackLabel.setVisible(config.showSpecialAttack());
        
        // Rebuild info panel
        rebuildInfoPanel();
        
        // Update colors
        updateLabelColors();
        
        // Ensure minimum dimensions
        ensureMinimumDimensions();
        
        // Update component sizes
        updateComponentSizes();
    }
    
    private void rebuildInfoPanel() {
        contentPanel.remove(infoPanel);
        infoPanel.removeAll();
        
        // Re-add components conditionally
        addComponentIfVisible(config.showHp(), hpLabel);
        addComponentIfVisible(config.showPrayer(), prayerLabel);
        addComponentIfVisible(config.showInventory(), inventoryLabel);
        addComponentIfVisible(config.showSpecialAttack(), specialAttackLabel);
        addComponentIfVisible(config.showStatus(), statusLabel);
        
        contentPanel.add(infoPanel, BorderLayout.CENTER);
    }
    
    private void updateLabelColors() {
        hpLabel.setForeground(Constants.DARK_TEXT_COLOR);
        prayerLabel.setForeground(Constants.DARK_TEXT_COLOR);
        statusLabel.setForeground(Constants.DARK_TEXT_COLOR);
        inventoryLabel.setForeground(Constants.DARK_TEXT_COLOR);
        specialAttackLabel.setForeground(Constants.DARK_TEXT_COLOR);
        characterNameLabel.setForeground(Constants.DARK_TEXT_COLOR);
    }
    
    private void ensureMinimumDimensions() {
        int currentWidth = getWidth();
        int currentHeight = getHeight();
        
        if (currentWidth < Constants.MIN_WIDTH || currentHeight < Constants.MIN_HEIGHT) {
            int newWidth = Math.max(currentWidth, Constants.MIN_WIDTH);
            int newHeight = Math.max(currentHeight, Constants.MIN_HEIGHT);
            setSize(newWidth, newHeight);
            validatePosition();
            savePositionAndSize();
        }
    }
    
    public void updateCharacterName(String name) {
        if (characterNameLabel != null) {
            SwingUtilities.invokeLater(() -> {
                characterNameLabel.setText(name != null ? name : "");
            });
        }
    }
    
    private Window findRuneLiteWindow() {
        try {
            // Try to get parent window first (most reliable)
            Window parent = SwingUtilities.getWindowAncestor(this);
            if (parent instanceof JFrame && parent.isVisible()) {
                String title = ((JFrame) parent).getTitle();
                if (title != null && title.toLowerCase().contains("runelite")
                        && !title.toLowerCase().contains("starting")
                        && !title.toLowerCase().contains("plugin")
                        && parent.getWidth() > 400 && parent.getHeight() > 400) {
                    return parent;
                }
            }
            
            // Fallback: search all windows
            for (Window window : Window.getWindows()) {
                if (window instanceof JFrame && window.isVisible()) {
                    String title = ((JFrame) window).getTitle();
                    if (title != null && title.toLowerCase().contains("runelite")
                            && !title.toLowerCase().contains("starting")
                            && !title.toLowerCase().contains("plugin")
                            && window.getWidth() > 400 && window.getHeight() > 400) {
                        return window;
                    }
                }
            }
        } catch (Exception e) {
            // Ignore any errors
        }
        return null;
    }
    
    private void focusRuneLiteWindow() {
        try {
            Window targetWindow = runeliteWindow;
            if (targetWindow == null) {
                targetWindow = findRuneLiteWindow();
            }
            
            if (targetWindow != null) {
                // Unminimize if needed
                if (targetWindow instanceof Frame) {
                    Frame frame = (Frame) targetWindow;
                    if (frame.getState() == Frame.ICONIFIED) {
                        frame.setState(Frame.NORMAL);
                    }
                }
                
                // Bring to front and focus
                targetWindow.setVisible(true);
                targetWindow.toFront();
                targetWindow.requestFocus();
                targetWindow.requestFocusInWindow();
                targetWindow.requestFocus();
            }
        } catch (Exception e) {
            // Ignore any errors
        }
    }
    
private void loadIcons() {
    // Load main icons
    hpIcon = loadIcon("/com/icons/Hitpoints_icon.png", Constants.HP_COLOR);
    prayerIcon = loadIcon("/com/icons/Prayer_icon.png", Constants.PRAYER_COLOR);
    inventoryIcon = loadIcon("/com/icons/Inventory.png", new Color(150, 150, 150));
    specialAttackIcon = loadIcon("/com/icons/Special_attack_orb.png", new Color(150, 150, 150));
        
        // Load protection prayer icons
        protectMeleeIcon = loadIcon("/com/icons/prayers/Protect_from_Melee.png", new Color(255, 100, 100));
        protectMagicIcon = loadIcon("/com/icons/prayers/Protect_from_Magic.png", new Color(100, 100, 255));
        protectRangedIcon = loadIcon("/com/icons/prayers/Protect_from_Missiles.png", new Color(100, 255, 100));
    }
    
    private BufferedImage loadIcon(String path, Color fallbackColor) {
        try {
            return ImageUtil.loadImageResource(getClass(), path);
        } catch (IllegalArgumentException e) {
            return createPlaceholderIcon(16, 16, fallbackColor);
        }
    }
    
    private BufferedImage createPlaceholderIcon(int width, int height, Color color) {
        BufferedImage icon = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = icon.createGraphics();
        g2d.setColor(color);
        g2d.fillRect(0, 0, width, height);
        g2d.dispose();
        return icon;
    }
    
    public void updateDisplay() {
        SwingUtilities.invokeLater(() -> {
            updateHpDisplay();
    updatePrayerDisplay();
    updateStatusDisplay();
    updateInventoryDisplay();
    updateSpecialAttackDisplay();
    contentPanel.repaint();
        });
    }
    
    private void updateHpDisplay() {
        if (config.showHp()) {
            hpLabel.setText(playerInfo.getHpText());
            int hpPercent = playerInfo.getHpPercentage();
            hpLabel.setForeground(getColorForPercentage(hpPercent, Constants.DARK_TEXT_COLOR));
        }
    }
    
    private void updatePrayerDisplay() {
        if (config.showPrayer()) {
            prayerLabel.setText(playerInfo.getPrayerText());
            
            // Check if protection prayer is active
            String activePrayer = playerInfo.getActiveProtectionPrayer();
            boolean hasProtectionPrayer = !activePrayer.isEmpty();
            
            int prayerPercent = playerInfo.getPrayerPercentage();
            if (prayerPercent <= 10) {
                prayerLabel.setForeground(Constants.DANGER_COLOR);
            } else if (prayerPercent <= 50) {
                prayerLabel.setForeground(Constants.WARNING_COLOR);
            } else {
                // Normal prayer level - check if protection prayer is active
                prayerLabel.setForeground(hasProtectionPrayer ? Constants.PRAYER_COLOR : Constants.WHITE);
            }
            
            updatePrayerIcon();
        }
    }
    
    private void updateStatusDisplay() {
        if (config.showStatus()) {
            statusLabel.setText("Status: " + playerInfo.getStatusText());
            statusLabel.setForeground(playerInfo.isIdle() ? Constants.IDLE_COLOR : Constants.ACTIVE_COLOR);
        }
    }
    
    private void updateInventoryDisplay() {
        if (config.showInventory()) {
            inventoryLabel.setText(playerInfo.getInventoryText());
            int invPercent = (playerInfo.getInventoryUsedSlots() * 100) / 28;
            inventoryLabel.setForeground(getColorForPercentage(invPercent, Constants.DARK_TEXT_COLOR));
        }
    }

    private void updateSpecialAttackDisplay() {
        if (config.showSpecialAttack()) {
            specialAttackLabel.setText(playerInfo.getSpecialAttackText());
            int specPercent = playerInfo.getSpecialAttackEnergyPercentage();
            specialAttackLabel.setForeground(getColorForPercentage(specPercent, Constants.DARK_TEXT_COLOR));
        }
    }
    
    private Color getColorForPercentage(int percentage, Color defaultColor) {
        if (percentage <= 10) {
            return Constants.DANGER_COLOR;
        } else if (percentage <= 50) {
            return Constants.WARNING_COLOR;
        } else {
            return defaultColor;
        }
    }
    
    private void updatePrayerIcon() {
        String activePrayer = playerInfo.getActiveProtectionPrayer();
        BufferedImage originalIcon = prayerIcon; // Default prayer icon
        
        switch (activePrayer) {
            case "melee":
                originalIcon = protectMeleeIcon;
                break;
            case "magic":
                originalIcon = protectMagicIcon;
                break;
            case "ranged":
                originalIcon = protectRangedIcon;
                break;
            default:
                originalIcon = prayerIcon;
                break;
        }
        
        // Resize the icon to the current icon size
        int iconSize = getScaledIconSize();
        prayerLabel.setIcon(resizeIcon(originalIcon, iconSize, iconSize));
    }
    
    private ImageIcon resizeIcon(BufferedImage originalIcon, int width, int height) {
        if (originalIcon == null) {
            return null;
        }
        Image scaledImage = originalIcon.getScaledInstance(width, height, Image.SCALE_SMOOTH);
        return new ImageIcon(scaledImage);
    }
    
    private void updateComponentSizes() {
        int currentHeight = getHeight();
        int minRequiredHeight = calculateMinimumRequiredHeight();
        
        // Calculate scaling factor
        double scalingFactor = 1.0; // Default to no scaling
        if (currentHeight > minRequiredHeight + Constants.SCALING_BUFFER) {
            double extraHeight = currentHeight - minRequiredHeight;
            scalingFactor = 1.0 + (extraHeight / 100.0) * Constants.SCALING_FACTOR;
            scalingFactor = Math.min(Constants.MAX_SCALING, scalingFactor);
        }
        
        // Calculate new sizes
        int iconSize = getScaledIconSize(scalingFactor);
        int fontSize = getScaledFontSize(scalingFactor);
        Font newFont = new Font("Arial", Font.BOLD, fontSize);
        
        // Update each label's font and icon (if visible)
        updateLabelSize(config.showHp(), hpLabel, newFont, hpIcon, iconSize);
        updateLabelSize(config.showPrayer(), prayerLabel, newFont, null, iconSize); // Icon updated separately
        updateLabelSize(config.showStatus(), statusLabel, newFont, null, iconSize);
        updateLabelSize(config.showInventory(), inventoryLabel, newFont, inventoryIcon, iconSize);
        updateLabelSize(config.showSpecialAttack(), specialAttackLabel, newFont, specialAttackIcon, iconSize);
        
        // Update character name label
        characterNameLabel.setFont(new Font("Arial", Font.BOLD, fontSize));
        
        // Update the layout
        infoPanel.revalidate();
    }
    
    private int getScaledIconSize() {
        int currentHeight = getHeight();
        int minRequiredHeight = calculateMinimumRequiredHeight();
        
        double scalingFactor = 1.0; // Default to no scaling
        if (currentHeight > minRequiredHeight + Constants.SCALING_BUFFER) {
            double extraHeight = currentHeight - minRequiredHeight;
            scalingFactor = 1.0 + (extraHeight / 100.0) * Constants.SCALING_FACTOR;
            scalingFactor = Math.min(Constants.MAX_SCALING, scalingFactor);
        }
        
        int iconSize = (int) (Constants.MIN_ICON_SIZE * scalingFactor);
        return Math.max(Constants.MIN_ICON_SIZE, Math.min(Constants.MAX_ICON_SIZE, iconSize));
    }
    
    private int getScaledIconSize(double scalingFactor) {
        int iconSize = (int) (Constants.MIN_ICON_SIZE * scalingFactor);
        return Math.max(Constants.MIN_ICON_SIZE, Math.min(Constants.MAX_ICON_SIZE, iconSize));
    }
    
    private int getScaledFontSize(double scalingFactor) {
        int fontSize = (int) (Constants.MIN_FONT_SIZE * scalingFactor);
        return Math.max(Constants.MIN_FONT_SIZE, Math.min(Constants.MAX_FONT_SIZE, fontSize));
    }
    
    private void updateLabelSize(boolean isVisible, JLabel label, Font font, BufferedImage icon, int iconSize) {
        if (isVisible) {
            label.setFont(font);
            if (icon != null) {
                label.setIcon(resizeIcon(icon, iconSize, iconSize));
            }
        }
    }
    
    private int calculateMinimumRequiredHeight() {
        // Start with the title bar height
        int minHeight = Constants.TITLE_BAR_HEIGHT;
        
        // Add the height of each visible component
        int componentCount = 0;
        if (config.showHp()) componentCount++;
        if (config.showPrayer()) componentCount++;
        if (config.showInventory()) componentCount++;
        if (config.showSpecialAttack()) componentCount++;
        if (config.showStatus()) componentCount++;
        
        // Each component needs space for itself plus spacing
        Font minFont = new Font("Arial", Font.BOLD, Constants.MIN_FONT_SIZE);
        FontMetrics fm = hpLabel.getFontMetrics(minFont);
        int componentHeight = fm.getHeight();
        
        // Total height = (component height + spacing) for each component
        minHeight += componentCount * (componentHeight + Constants.COMPONENT_SPACING);
        
        // Add padding
        minHeight += Constants.PADDING * 2;
        
        return minHeight;
    }
}

package com.afkoverlay;

import lombok.Data;

@Data
public class PlayerInfo {
    public PlayerInfo() {
    }

    public PlayerInfo(PlayerInfo other) {
        this.currentHp = other.currentHp;
        this.maxHp = other.maxHp;
        this.currentPrayer = other.currentPrayer;
        this.maxPrayer = other.maxPrayer;
        this.idle = other.idle;
        this.inventoryUsedSlots = other.inventoryUsedSlots;
        this.specialAttackEnergy = other.specialAttackEnergy;
        this.characterName = other.characterName;
        this.activeProtectionPrayer = other.activeProtectionPrayer;
    }

    private int currentHp = 0;
    private int maxHp = 0;
    private int currentPrayer = 0;
    private int maxPrayer = 0;
    private boolean idle = false;
    private int inventoryUsedSlots = 0;
    private int specialAttackEnergy = 0;
    private String characterName = "";
    private String activeProtectionPrayer = ""; // "melee", "magic", "ranged", or empty string

    public int getHpPercentage() {
        if (maxHp == 0) return 0;
        return (currentHp * 100) / maxHp;
    }

    public int getPrayerPercentage() {
        if (maxPrayer == 0) return 0;
        return (currentPrayer * 100) / maxPrayer;
    }

    public String getStatusText() {
        return idle ? "IDLE" : "ACTIVE";
    }

    public String getHpText() {
        return String.format("%d/%d (%d%%)", currentHp, maxHp, getHpPercentage());
    }

    public String getPrayerText() {
        return String.format("%d/%d (%d%%)", currentPrayer, maxPrayer, getPrayerPercentage());
    }

public String getInventoryText() {
    int totalSlots = 28;
    int usagePercentage = (inventoryUsedSlots * 100) / totalSlots;
    return String.format("%d/28 (%d%%)", inventoryUsedSlots, usagePercentage);
}

public int getSpecialAttackEnergyPercentage() {
    return specialAttackEnergy;
}

public String getSpecialAttackText() {
    return String.format("%d%%", specialAttackEnergy);
}
    
    public String getActiveProtectionPrayer() {
        return activeProtectionPrayer;
    }
    
    public void setActiveProtectionPrayer(String prayer) {
        this.activeProtectionPrayer = prayer;
    }
}

package com.afkoverlay;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.PlayerChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.SwingUtilities;
import java.awt.Image;
import java.time.Instant;

@Slf4j
@PluginDescriptor(
    name = "AFK Overlay",
    description = "Displays player information in a floating overlay window",
    tags = {"overlay", "player", "stats", "afk"}
)
public class AFKOverlayPlugin extends Plugin {

    @Inject
    private Client client;

    @Inject
    private AFKOverlayConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private AFKOverlay overlay;

    @Inject
    private ConfigManager configManager;

    private FloatingOverlayWindow floatingWindow;
    private PlayerInfo playerInfo;
    private PlayerInfo previousPlayerInfo;
    // Track the last time the player was active
    private Instant lastActive = Instant.now();
    // Track if window was closed by user
    private boolean windowClosedByUser = false;
    private Instant lastSoundPlayed = Instant.now();
    private static final int SOUND_ID = 3817;

    @Override
    protected void startUp() throws Exception {
        log.info("AFK Overlay plugin started!");
        
        // Initialize player info
        playerInfo = new PlayerInfo();        
        // Create and show floating overlay window
        createAndShowWindow();
        
        // Add overlay to overlay manager (for potential future use)
        overlayManager.add(overlay);
    }

    private void createAndShowWindow() {
        SwingUtilities.invokeLater(() -> {
            floatingWindow = new FloatingOverlayWindow(playerInfo, config, configManager);
            
            // Set custom icon for the window (using the plugin hub icon)
            try {
                Image icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
                if (icon != null) {
                    floatingWindow.setIconImage(icon);
                    // Also try setting it as a list for better compatibility
                    floatingWindow.setIconImages(java.util.Arrays.asList(icon));
                }
            } catch ( IllegalArgumentException e) {
                // Silently fall back to default icon
            }
            
            // Add window listener to track when it's closed
            floatingWindow.addWindowListener(new java.awt.event.WindowAdapter() {
                @Override
                public void windowClosing(java.awt.event.WindowEvent e) {
                    windowClosedByUser = true;
                }
            });
            
            floatingWindow.setVisible(true);
            windowClosedByUser = false;
        });
    }

    @Override
    protected void shutDown() throws Exception {
        log.info("AFK Overlay plugin stopped!");
        
        // Remove overlay from overlay manager
        overlayManager.remove(overlay);
        
        // Save window position and size before disposing
        if (floatingWindow != null) {
            SwingUtilities.invokeLater(() -> {
                floatingWindow.savePositionAndSize();
                floatingWindow.dispose();
                floatingWindow = null;
            });
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        updatePlayerInfo();
        checkThresholdsAndPlaySounds();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGED_IN) {
            updatePlayerInfo();
        }
    }

    @Subscribe
    public void onPlayerChanged(PlayerChanged event) {
        updatePlayerInfo();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (event.getGroup().equals("afkoverlay")) {
            // Handle show overlay button
            if (event.getKey().equals("showOverlay") && config.showOverlay()) {
                if (floatingWindow == null) {
                    createAndShowWindow();
                } else if (!floatingWindow.isVisible()) {
                    floatingWindow.setVisible(true);
                }
                configManager.setConfiguration("afkoverlay", "showOverlay", false);
            }
            
            // Handle display options changes
            if (event.getKey().startsWith("show") && 
                (event.getKey().equals("showHp") || 
                event.getKey().equals("showPrayer") || 
                event.getKey().equals("showStatus") || 
                event.getKey().equals("showInventory"))) {
                if (floatingWindow != null) {
                    SwingUtilities.invokeLater(() -> floatingWindow.updateConfig());
                }
            }
            
            // Update the floating window when other config changes
            if (floatingWindow != null) {
                previousPlayerInfo = null;
                SwingUtilities.invokeLater(() -> floatingWindow.updateConfig());
            }
        }
    }

    private void updatePlayerInfo() {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        Player player = client.getLocalPlayer();
        if (player == null) {
            return;
        }

        // Update HP using skill levels
        int currentHp = client.getBoostedSkillLevel(Skill.HITPOINTS);
        int maxHp = client.getRealSkillLevel(Skill.HITPOINTS);
        if (currentHp > 0 && maxHp > 0) {
            playerInfo.setCurrentHp(currentHp);
            playerInfo.setMaxHp(maxHp);
        }

        // Update Prayer
        int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
        int maxPrayer = client.getRealSkillLevel(Skill.PRAYER);
        if (currentPrayer > 0 && maxPrayer > 0) {
            playerInfo.setCurrentPrayer(currentPrayer);
            playerInfo.setMaxPrayer(maxPrayer);
        }

        // Idle detection using Instant.now()
        boolean isIdleNow = isPlayerIdle(player);
        Instant now = Instant.now();
        if (!isIdleNow) {
            lastActive = now;
            playerInfo.setIdle(false);
        } else {
            long millisSinceActive = java.time.Duration.between(lastActive, now).toMillis();
            int idleThreshold = config.idleThresholdMs();
            if (millisSinceActive >= idleThreshold) {
                playerInfo.setIdle(true);
            } else {
                playerInfo.setIdle(false);
            }
        }

        // Update inventory usage
        updateInventoryUsage();

        // Update special attack energy
        int specialAttackEnergy = client.getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT) / 10;
        playerInfo.setSpecialAttackEnergy(specialAttackEnergy);

        // Update character name
        updateCharacterName(player);
        
        // Update protection prayer
        updateProtectionPrayer(player);

        // Update the floating window
        if (floatingWindow != null && (previousPlayerInfo == null || !previousPlayerInfo.equals(playerInfo))) {
            previousPlayerInfo = new PlayerInfo(playerInfo);
            SwingUtilities.invokeLater(() -> {
                floatingWindow.updateDisplay();
                floatingWindow.updateCharacterName(playerInfo.getCharacterName());
            });
        }
    }

    private boolean isPlayerIdle(Player player) {
        // Get the player's current animation, pose, and idle pose
        int animation = player.getAnimation();
        int pose = player.getPoseAnimation();
        int idlePose = player.getIdlePoseAnimation();

        // If the player is performing any animation (e.g., skilling, combat), they are active
        if (animation != -1) {
            return false;
        }

        // If the player's pose is not the idle pose, they are moving (walking/running), so they are active
        if (pose != idlePose) {
            return false;
        }

        // Use isInteracting() method from Actor class for more accurate interaction detection
        if (player.isInteracting()) {
            return false;
        }

        // If no animation, pose is idle, and not interacting, player is idle
        return true;
    }

    private void updateInventoryUsage() {
        try {
            ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
            if (inventory != null && inventory.getItems() != null) {
                Item[] items = inventory.getItems();
                int usedSlots = 0;
                for (Item item : items) {
                    if (item != null && item.getId() != -1) {
                        usedSlots++;
                    }
                }
                // Fix: Calculate percentage based on used slots, not total slots
                int totalSlots = 28; // RuneScape inventory has 28 slots
                playerInfo.setInventoryUsedSlots(usedSlots);
                log.debug("Inventory: {} used slots out of {}", usedSlots, totalSlots);
            } else {
                playerInfo.setInventoryUsedSlots(0);
                log.debug("Inventory container is null or has no items");
            }
        } catch (Exception e) {
            // If there's any error, set to 0
            playerInfo.setInventoryUsedSlots(0);
            log.debug("Error getting inventory: {}", e.getMessage());
        }
    }

    private void updateCharacterName(Player player) {
        String name = player.getName();
        if (name != null && !name.equals(playerInfo.getCharacterName())) {
            playerInfo.setCharacterName(name);
            log.debug("Character name updated: {}", name);
        }
    }
    
    private void updateProtectionPrayer(Player player) {
        // Check player's overhead icon to determine active protection prayer
        HeadIcon overheadIcon = player.getOverheadIcon();
        String activePrayer = "";
        
        // Check the HeadIcon enum to determine active protection prayer
        if (overheadIcon != null) {
            String iconName = overheadIcon.name();
            
            if (iconName.contains("MELEE")) {
                activePrayer = "melee";
            } else if (iconName.contains("MISSILES") || iconName.contains("RANGED")) {
                activePrayer = "ranged";
            } else if (iconName.contains("MAGIC")) {
                activePrayer = "magic";
            } else {
                activePrayer = ""; // No protection prayer active
            }
        } else {
            activePrayer = ""; // No protection prayer active
        }
        
        playerInfo.setActiveProtectionPrayer(activePrayer);
        log.debug("Protection prayer: {}", activePrayer);
    }

    @Provides
    AFKOverlayConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(AFKOverlayConfig.class);
    }

    private void checkThresholdsAndPlaySounds() {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        Instant now = Instant.now();
        if (java.time.Duration.between(lastSoundPlayed, now).toMillis() < 2000) {
            return;
        }

        boolean playSound = false;

        // Check HP
        if (config.playHpSound() && playerInfo.getCurrentHp() > 0 && playerInfo.getCurrentHp() <= config.lowHpThresholdValue()) {
            playSound = true;
        }

        // Check Prayer
        if (config.playPrayerSound() && playerInfo.getCurrentPrayer() > 0 && playerInfo.getCurrentPrayer() <= config.lowPrayerThresholdValue()) {
            playSound = true;
        }

        // Check Special Attack
        if (config.playSpecialAttackSound() && playerInfo.getSpecialAttackEnergyPercentage() >= config.highSpecialAttackThresholdValue()) {
            playSound = true;
        }

        // Check Inventory
        if (config.playInvSound()) {
            int invCount = playerInfo.getInventoryUsedSlots();
            boolean invThresholdMet = false;
            switch (config.invHighlightMode()) {
                case ABOVE:
                    if (invCount > config.invThresholdValue()) invThresholdMet = true;
                    break;
                case BELOW:
                    if (invCount < config.invThresholdValue()) invThresholdMet = true;
                    break;
                case EQUALS:
                    if (invCount == config.invThresholdValue()) invThresholdMet = true;
                    break;
            }
            if (invThresholdMet) {
                playSound = true;
            }
        }

        // Check Idle Status
        if (config.playIdleSound() && playerInfo.isIdle()) {
            playSound = true;
        }

        if (playSound) {
            lastSoundPlayed = now;
            Preferences preferences = client.getPreferences();
            int previousVolume = preferences.getSoundEffectVolume();
            preferences.setSoundEffectVolume(config.soundVolume());
            client.playSoundEffect(SOUND_ID, config.soundVolume());
            preferences.setSoundEffectVolume(previousVolume);
        }
    }
}

package com.afkoverlay;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AFKOverlayPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AFKOverlayPlugin.class);
		RuneLite.main(args);
	}
}
