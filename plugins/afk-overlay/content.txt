package com.afkoverlay;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

import javax.inject.Inject;
import java.awt.*;

public class AFKOverlay extends Overlay {
    private final Client client;
    private final PlayerInfo playerInfo;

    @Inject
    public AFKOverlay(Client client, PlayerInfo playerInfo) {
        this.client = client;
        this.playerInfo = playerInfo;
        
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (client.getGameState() != net.runelite.api.GameState.LOGGED_IN) {
            return null;
        }

        // This overlay is currently not used since we're using a floating window
        // but it's here for potential future use or as a fallback
        return null;
    }
} 
package com.afkoverlay;

import net.runelite.client.config.*;

import java.awt.Color;

@ConfigGroup("afkoverlay")
public interface AFKOverlayConfig extends Config {

    @ConfigSection(
        name = "Appearance",
        description = "Appearance settings for the overlay",
        position = 1
    )
    String appearanceSection = "appearance";



    @ConfigItem(
        keyName = "showCloseButton",
        name = "Show Close Button",
        description = "Show a close button on the overlay",
        section = appearanceSection,
        position = 1
    )
    default boolean showCloseButton() {
        return true;
    }

    @ConfigItem(
        keyName = "showMinimizeButton",
        name = "Show Minimize Button",
        description = "Show a minimize button on the overlay",
        section = appearanceSection,
        position = 2
    )
    default boolean showMinimizeButton() {
        return true;
    }

    @ConfigItem(
        keyName = "opacity",
        name = "Opacity",
        description = "Set the opacity level of the overlay (0 = fully transparent, 255 = fully opaque)",
        section = appearanceSection,
        position = 3
    )
    @Range(min = 0, max = 255)
    default int opacity() {
        return 200;
    }

    // --- Hitpoints Section ---
    @ConfigSection(
        name = "Hitpoints",
        description = "Highlight background when hitpoints are low.",
        position = 20
    )
    String hitpointsSection = "hitpointsSection";

    @ConfigItem(
        keyName = "highlightHpBackground",
        name = "Highlight background when low",
        description = "Highlight background when hitpoints are low.",
        section = hitpointsSection,
        position = 1
    )
    default boolean highlightHpBackground() { return false; }

    @ConfigItem(
        keyName = "lowHpThresholdValue",
        name = "Threshold value",
        description = "Show highlight when HP is at or below this value.",
        section = hitpointsSection,
        position = 2
    )
    @Range(min = 1, max = 99)
    default int lowHpThresholdValue() { return 10; }

    @Alpha
    @ConfigItem(
        keyName = "lowHpOverlayColor",
        name = "Threshold color",
        description = "Background color when HP is low.",
        section = hitpointsSection,
        position = 3
    )
    default Color lowHpOverlayColor() { return new Color(0xFF020421); }

    // --- Prayer Section ---
    @ConfigSection(
        name = "Prayer",
        description = "Highlight background when prayer is low.",
        position = 30
    )
    String prayerSection = "prayerSection";

    @ConfigItem(
        keyName = "highlightPrayerBackground",
        name = "Highlight background when low",
        description = "Highlight background when prayer is low.",
        section = prayerSection,
        position = 1
    )
    default boolean highlightPrayerBackground() { return false; }

    @ConfigItem(
        keyName = "lowPrayerThresholdValue",
        name = "Threshold value",
        description = "Show highlight when prayer is at or below this value.",
        section = prayerSection,
        position = 2
    )
    @Range(min = 1, max = 99)
    default int lowPrayerThresholdValue() { return 10; }

    @Alpha
    @ConfigItem(
        keyName = "lowPrayerOverlayColor",
        name = "Threshold color",
        description = "Background color when prayer is low.",
        section = prayerSection,
        position = 3
    )
    default Color lowPrayerOverlayColor() { return new Color(0xFF020421); }

    // --- Status Section ---
    @ConfigSection(
        name = "Status",
        description = "Highlight background when idle.",
        position = 50
    )
    String statusSection = "statusSection";

    @ConfigItem(
        keyName = "highlightIdleBackground",
        name = "Highlight background when idle",
        description = "Highlight background when status is idle.",
        section = statusSection,
        position = 1
    )
    default boolean highlightIdleBackground() { return false; }

    @Alpha
    @ConfigItem(
        keyName = "idleOverlayColor",
        name = "Threshold color",
        description = "Background color when idle.",
        section = statusSection,
        position = 2
    )
    default Color idleOverlayColor() { return new Color(0xFF020421); }

    @ConfigItem(
        keyName = "idleThresholdMs",
        name = "Idle threshold (ms)",
        description = "How long (in milliseconds) the player must be idle before the overlay shows IDLE. Set to 0 for instant.",
        section = statusSection,
        position = 3
    )
    @Range(
        min = 0,
        max = 5000
    )
    default int idleThresholdMs() {
        return 1200;
    }

    // --- Inventory Section ---
    @ConfigSection(
        name = "Inventory",
        description = "Highlight background based on inventory items.",
        position = 40
    )
    String inventorySection = "inventorySection";

    @ConfigItem(
        keyName = "highlightInvBackground",
        name = "Highlight background",
        description = "Highlight background based on inventory items.",
        section = inventorySection,
        position = 1
    )
    default boolean highlightInvBackground() { return false; }

    enum InventoryHighlightMode {
        ABOVE,
        BELOW
    }

    @ConfigItem(
        keyName = "invHighlightMode",
        name = "Highlight when:",
        description = "Highlight when inventory items are above or below the threshold.",
        section = inventorySection,
        position = 2
    )
    default InventoryHighlightMode invHighlightMode() { return InventoryHighlightMode.ABOVE; }

    @ConfigItem(
        keyName = "invThresholdValue",
        name = "Threshold value",
        description = "Number of inventory items to trigger highlight.",
        section = inventorySection,
        position = 3
    )
    @Range(min = 1, max = 28)
    default int invThresholdValue() { return 28; }

    @Alpha
    @ConfigItem(
        keyName = "invOverlayColor",
        name = "Threshold color",
        description = "Background color when inventory highlight is triggered.",
        section = inventorySection,
        position = 4
    )
    default Color invOverlayColor() { return new Color(0xFF020421); }


}

package com.afkoverlay;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import net.runelite.client.util.ImageUtil;

public class FloatingOverlayWindow extends JFrame {
    private final PlayerInfo playerInfo;
    private AFKOverlayConfig config;
    private final JPanel contentPanel;
    private final JLabel hpLabel;
    private final JLabel prayerLabel;
    private final JLabel statusLabel;
    private final JLabel inventoryLabel;
    private JPanel titleBar;
    private JLabel characterNameLabel;
    private Window runeliteWindow; // Reference to RuneLite window
    
    // Icons
    private BufferedImage hpIcon;
    private BufferedImage prayerIcon;
    private BufferedImage inventoryIcon;
    private BufferedImage protectMeleeIcon;
    private BufferedImage protectMagicIcon;
    private BufferedImage protectRangedIcon;
    
    private Point dragPoint;
    private boolean isDragging = false;
    private boolean isResizing = false;
    private int resizeEdge = 0; // 0=none, 1=right, 2=bottom, 3=corner
    
         private static final int RESIZE_BORDER = 5;
     private static final int MIN_WIDTH = 50; // Allow very thin windows
     private static final int MIN_HEIGHT = 80; // Reduced height too
     private static final int MAX_WIDTH = 400; // Maximum width
     private static final int MAX_HEIGHT = 250; // Maximum height
    
    // Colors for themes
    private static final Color DARK_BORDER_COLOR = new Color(60, 60, 60, 200);
    private static final Color DARK_TEXT_COLOR = new Color(220, 220, 220);
    private static final Color HP_COLOR = new Color(255, 120, 120); // Softer red
    private static final Color PRAYER_COLOR = new Color(100, 150, 255);
    private static final Color IDLE_COLOR = new Color(255, 180, 100); // Softer orange
    private static final Color ACTIVE_COLOR = new Color(120, 255, 120); // Softer green
    private static final Color WARNING_COLOR = new Color(255, 200, 100); // Yellow for 50% or below
    private static final Color DANGER_COLOR = new Color(255, 100, 100); // Red for 10% or below

    public FloatingOverlayWindow(PlayerInfo playerInfo, AFKOverlayConfig config) {
        this.playerInfo = playerInfo;
        this.config = config;
        
        // Load icons
        loadIcons();
        
        // Set window properties
        setAlwaysOnTop(true);
        setUndecorated(true);
        setBackground(new Color(0, 0, 0, 0));
        
        // Try to find the RuneLite window
        try {
            this.runeliteWindow = findRuneLiteWindow();
        } catch (Exception e) {
            // Ignore if we can't find it
        }
        
        // Create content panel with custom painting
        contentPanel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                Graphics2D g2d = (Graphics2D) g.create();
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
                
                // Create rounded rectangle background
                RoundRectangle2D roundedRectangle = new RoundRectangle2D.Float(
                    0, 0, getWidth(), getHeight(), 12, 12);
                
                // Fill background with dark theme and opacity
                Color backgroundColor = new Color(30, 30, 30, config.opacity()); // Default
                // Priority: HP > Prayer > Status > Inventory
                int hpValue = playerInfo.getCurrentHp();
                int prayerValue = playerInfo.getCurrentPrayer();
                int invCount = playerInfo.getInventoryUsedSlots();

                if (config.highlightHpBackground() && hpValue <= config.lowHpThresholdValue()) {
                    backgroundColor = config.lowHpOverlayColor();
                } else if (config.highlightPrayerBackground() && prayerValue <= config.lowPrayerThresholdValue()) {
                    backgroundColor = config.lowPrayerOverlayColor();
                } else if (config.highlightIdleBackground() && playerInfo.isIdle()) {
                    backgroundColor = config.idleOverlayColor();
                } else if (config.highlightInvBackground()) {
                    boolean highlight = false;
                    switch (config.invHighlightMode()) {
                        case ABOVE:
                            highlight = invCount > config.invThresholdValue();
                            break;
                        case BELOW:
                            highlight = invCount < config.invThresholdValue();
                            break;
                    }
                    if (highlight) {
                        backgroundColor = config.invOverlayColor();
                    }
                }
                g2d.setColor(backgroundColor);
                g2d.fill(roundedRectangle);
                
                // Draw border
                Color borderColor = DARK_BORDER_COLOR;
                g2d.setColor(borderColor);
                g2d.setStroke(new BasicStroke(1.5f));
                g2d.draw(roundedRectangle);
                
                g2d.dispose();
            }
        };
        
        // Set layout
        contentPanel.setLayout(new BorderLayout(8, 8));
        contentPanel.setBorder(BorderFactory.createEmptyBorder(12, 12, 12, 12));
        contentPanel.setOpaque(false);
        
                 // Create labels with icons (no text labels)
         hpLabel = createLabel("", hpIcon);
         prayerLabel = createLabel("", prayerIcon);
         statusLabel = createLabel("Status: ACTIVE", null);
         inventoryLabel = createLabel("", inventoryIcon);
        
        // Create info panel
        JPanel infoPanel = new JPanel();
        infoPanel.setLayout(new BoxLayout(infoPanel, BoxLayout.Y_AXIS));
        infoPanel.setOpaque(false);
        
        infoPanel.add(hpLabel);
        infoPanel.add(Box.createVerticalStrut(8));
        infoPanel.add(prayerLabel);
        infoPanel.add(Box.createVerticalStrut(8));
        infoPanel.add(inventoryLabel);
        infoPanel.add(Box.createVerticalStrut(8));
        infoPanel.add(statusLabel);
        
        contentPanel.add(infoPanel, BorderLayout.CENTER);
        
        // Create custom title bar with buttons
        titleBar = createTitleBar();
        contentPanel.add(titleBar, BorderLayout.NORTH);
        
        setContentPane(contentPanel);
        
        // Set initial size and position
        setSize(300, 180);
        setLocation(100, 100);
        
        // Add mouse listeners for dragging and resizing
        addMouseListeners();
        
        // Update display
        updateDisplay();
    }
    
    public void updateConfig() {
        // Update title bar (buttons)
        contentPanel.remove(titleBar);
        titleBar = createTitleBar();
        contentPanel.add(titleBar, BorderLayout.NORTH);
        
        // Update label colors for dark theme
        hpLabel.setForeground(DARK_TEXT_COLOR);
        prayerLabel.setForeground(DARK_TEXT_COLOR);
        statusLabel.setForeground(DARK_TEXT_COLOR);
        inventoryLabel.setForeground(DARK_TEXT_COLOR);
        characterNameLabel.setForeground(DARK_TEXT_COLOR);
        
        // Repaint to update transparency and theme
        contentPanel.revalidate();
        contentPanel.repaint();
    }
    
    public void updateCharacterName(String name) {
        SwingUtilities.invokeLater(() -> {
            characterNameLabel.setText(name != null ? name : "");
        });
    }
    
    private Window findRuneLiteWindow() {
        try {
            // Try to get parent window first (most reliable)
            Window parent = SwingUtilities.getWindowAncestor(this);
            if (parent instanceof JFrame && parent.isVisible()) {
                String title = ((JFrame) parent).getTitle();
                if (title != null && title.toLowerCase().contains("runelite")
                        && !title.toLowerCase().contains("starting")
                        && !title.toLowerCase().contains("plugin")
                        && parent.getWidth() > 400 && parent.getHeight() > 400) {
                    return parent;
                }
            }

            // Fallback: search all windows
            for (Window window : Window.getWindows()) {
                if (window instanceof JFrame && window.isVisible()) {
                    String title = ((JFrame) window).getTitle();
                    if (title != null && title.toLowerCase().contains("runelite")
                            && !title.toLowerCase().contains("starting")
                            && !title.toLowerCase().contains("plugin")
                            && window.getWidth() > 400 && window.getHeight() > 400) {
                        return window;
                    }
                }
            }
        } catch (Exception e) {
            // Ignore any errors
        }
        return null;
    }
    
    private void focusRuneLiteWindow() {
        try {
            Window targetWindow = runeliteWindow;
            if (targetWindow == null) {
                targetWindow = findRuneLiteWindow();
            }
            
            if (targetWindow != null) {
                // Unminimize if needed
                if (targetWindow instanceof Frame) {
                    Frame frame = (Frame) targetWindow;
                    if (frame.getState() == Frame.ICONIFIED) {
                        frame.setState(Frame.NORMAL);
                    }
                }
                
                // Bring to front and focus
                targetWindow.setVisible(true);
                targetWindow.toFront();
                targetWindow.requestFocus();
                targetWindow.requestFocusInWindow();
                
                // Force focus using multiple methods
                targetWindow.requestFocus();
                
                // Additional focus attempts
                try {
                    // Try to force focus again
                    targetWindow.requestFocus();
                } catch (Exception e) {
                    // Ignore any errors
                }
            }
        } catch (Exception e) {
            // Ignore any errors
        }
    }
    
    private void loadIcons() {
        // Load main icons
        try {
            hpIcon = ImageUtil.loadImageResource(getClass(), "/com/icons/Hitpoints_icon.png");
        } catch (IllegalArgumentException e) {
            hpIcon = createPlaceholderIcon(16, 16, HP_COLOR);
        }
        
        try {
            prayerIcon = ImageUtil.loadImageResource(getClass(), "/com/icons/Prayer_icon.png");
        } catch (IllegalArgumentException e) {
            prayerIcon = createPlaceholderIcon(16, 16, PRAYER_COLOR);
        }
        
        try {
            inventoryIcon = ImageUtil.loadImageResource(getClass(), "/com/icons/Inventory.png");
        } catch (IllegalArgumentException e) {
            inventoryIcon = createPlaceholderIcon(16, 16, new Color(150, 150, 150));
        }
        
        // Load protection prayer icons - if they fail, create colored versions
        try {
            protectMeleeIcon = ImageUtil.loadImageResource(getClass(), "/com/icons/prayers/Protect_from_Melee.png");
        } catch (IllegalArgumentException e) {
            protectMeleeIcon = createPlaceholderIcon(16, 16, new Color(255, 100, 100)); // Red for melee
        }
        
        try {
            protectMagicIcon = ImageUtil.loadImageResource(getClass(), "/com/icons/prayers/Protect_from_Magic.png");
        } catch (IllegalArgumentException e) {
            protectMagicIcon = createPlaceholderIcon(16, 16, new Color(100, 100, 255)); // Blue for magic
        }
        
        try {
            protectRangedIcon = ImageUtil.loadImageResource(getClass(), "/com/icons/prayers/Protect_from_Missiles.png");
        } catch (IllegalArgumentException e) {
            protectRangedIcon = createPlaceholderIcon(16, 16, new Color(100, 255, 100)); // Green for ranged
        }
    }
    
    private BufferedImage createPlaceholderIcon(int width, int height, Color color) {
        BufferedImage icon = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        Graphics2D g2d = icon.createGraphics();
        g2d.setColor(color);
        g2d.fillRect(0, 0, width, height);
        g2d.dispose();
        return icon;
    }
    
    private JPanel createTitleBar() {
        JPanel titleBar = new JPanel(new BorderLayout());
        titleBar.setOpaque(false);
        titleBar.setPreferredSize(new Dimension(0, 20));
        
        // Create character name label
        characterNameLabel = new JLabel("");
        characterNameLabel.setFont(new Font("Arial", Font.BOLD, 13));
        characterNameLabel.setForeground(DARK_TEXT_COLOR);
        characterNameLabel.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 0));
        
        // Add character name on the left
        titleBar.add(characterNameLabel, BorderLayout.WEST);
        
        // Add buttons on the right
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 4, 0));
        buttonPanel.setOpaque(false);
        
                 if (config.showMinimizeButton()) {
             JButton minimizeButton = createCustomButton("−", null);
             minimizeButton.addActionListener(e -> setState(Frame.ICONIFIED));
             buttonPanel.add(minimizeButton);
         }
         
         if (config.showCloseButton()) {
             JButton closeButton = createCustomButton("×", null);
             closeButton.addActionListener(e -> dispose());
             buttonPanel.add(closeButton);
         }
        
        titleBar.add(buttonPanel, BorderLayout.EAST);
        return titleBar;
    }
    
         private JButton createCustomButton(String text, Color color) {
         JButton button = new JButton(text) {
             @Override
             protected void paintComponent(Graphics g) {
                 Graphics2D g2d = (Graphics2D) g.create();
                 g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                 
                 // Only show background on hover
                 if (getModel().isRollover()) {
                     g2d.setColor(new Color(0, 0, 0, 120)); // Semi-transparent black
                     g2d.fillRoundRect(0, 0, getWidth(), getHeight(), 4, 4);
                 }
                 
                 // Draw text in dark theme color
                 g2d.setColor(DARK_TEXT_COLOR);
                 g2d.setFont(new Font("Segoe UI", Font.PLAIN, 10)); // Better font
                 
                 FontMetrics fm = g2d.getFontMetrics();
                 int textX = (getWidth() - fm.stringWidth(text)) / 2;
                 int textY = (getHeight() + fm.getAscent()) / 2 - 1; // Better centering
                 g2d.drawString(text, textX, textY);
                 
                 g2d.dispose();
             }
         };
         
         button.setPreferredSize(new Dimension(20, 20)); // Slightly larger
         button.setFocusPainted(false);
         button.setBorderPainted(false);
         button.setContentAreaFilled(false);
         button.setOpaque(false);
         
         return button;
     }
    
    private JLabel createLabel(String text, BufferedImage icon) {
        JLabel label = new JLabel(text);
        label.setFont(new Font("Arial", Font.BOLD, 13));
        label.setForeground(DARK_TEXT_COLOR);
        label.setPreferredSize(new Dimension(0, 20));
        label.setMinimumSize(new Dimension(0, 20)); // Allow horizontal shrinking
        
        // Set icon if available
        if (icon != null) {
            label.setIcon(new ImageIcon(icon));
            label.setIconTextGap(6); // Space between icon and text
        }
        
        return label;
    }
    
    private void addMouseListeners() {
        addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                Point p = e.getPoint();
                int width = getWidth();
                int height = getHeight();
                
                // Check if clicking on resize areas
                if (p.x > width - RESIZE_BORDER && p.y > height - RESIZE_BORDER) {
                    isResizing = true;
                    resizeEdge = 3; // corner
                    setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR));
                } else if (p.x > width - RESIZE_BORDER) {
                    isResizing = true;
                    resizeEdge = 1; // right edge
                    setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR));
                } else if (p.y > height - RESIZE_BORDER) {
                    isResizing = true;
                    resizeEdge = 2; // bottom edge
                    setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR));
                } else if (p.y < 30) { // Top area for dragging (like browser tab)
                    isDragging = true;
                    dragPoint = p;
                    setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
                }
                // If not in top area, don't start dragging - allow clicking
            }
            
            @Override
            public void mouseReleased(MouseEvent e) {
                isDragging = false;
                isResizing = false;
                resizeEdge = 0;
                setCursor(Cursor.getDefaultCursor());
            }
            
            @Override
            public void mouseClicked(MouseEvent e) {
                // Only focus if it's a left click and not on resize areas and not dragging
                if (e.getButton() == MouseEvent.BUTTON1 && !isResizing && !isDragging) {
                    // Try to focus the RuneLite window
                    try {
                        focusRuneLiteWindow();
                    } catch (Exception ex) {
                        // Ignore any errors
                    }
                }
            }
        });
        
        addMouseMotionListener(new MouseMotionAdapter() {
            @Override
            public void mouseDragged(MouseEvent e) {
                if (isDragging) {
                    Point p = getLocation();
                    setLocation(p.x + e.getX() - dragPoint.x, p.y + e.getY() - dragPoint.y);
                } else if (isResizing) {
                    Point p = e.getPoint();
                    int newWidth = getWidth();
                    int newHeight = getHeight();
                    
                                         if (resizeEdge == 1 || resizeEdge == 3) { // right edge or corner
                         newWidth = Math.max(MIN_WIDTH, Math.min(MAX_WIDTH, p.x));
                     }
                     if (resizeEdge == 2 || resizeEdge == 3) { // bottom edge or corner
                         newHeight = Math.max(MIN_HEIGHT, Math.min(MAX_HEIGHT, p.y));
                     }
                    
                    setSize(newWidth, newHeight);
                }
            }
            
            @Override
            public void mouseMoved(MouseEvent e) {
                Point p = e.getPoint();
                int width = getWidth();
                int height = getHeight();
                
                if (p.x > width - RESIZE_BORDER && p.y > height - RESIZE_BORDER) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.SE_RESIZE_CURSOR));
                } else if (p.x > width - RESIZE_BORDER) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.E_RESIZE_CURSOR));
                } else if (p.y > height - RESIZE_BORDER) {
                    setCursor(Cursor.getPredefinedCursor(Cursor.S_RESIZE_CURSOR));
                } else if (p.y < 30) { // Top area shows move cursor
                    setCursor(Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));
                } else {
                    setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
                }
            }
        });
    }
    
    public void updateDisplay() {
        SwingUtilities.invokeLater(() -> {
            hpLabel.setText(playerInfo.getHpText());
            prayerLabel.setText(playerInfo.getPrayerText());
            statusLabel.setText("Status: " + playerInfo.getStatusText());
            inventoryLabel.setText(playerInfo.getInventoryText());
            
            // Update prayer icon based on active protection prayer
            updatePrayerIcon();
            
            // Update colors based on status
            if (playerInfo.isIdle()) {
                statusLabel.setForeground(IDLE_COLOR);
            } else {
                statusLabel.setForeground(ACTIVE_COLOR);
            }
            
            // Update HP color based on percentage
             int hpPercent = playerInfo.getHpPercentage();
             if (hpPercent <= 10) {
                 hpLabel.setForeground(DANGER_COLOR);
             } else if (hpPercent <= 50) {
                 hpLabel.setForeground(WARNING_COLOR);
             } else {
                 hpLabel.setForeground(DARK_TEXT_COLOR);
             }
             
             // Update prayer color based on percentage
             int prayerPercent = playerInfo.getPrayerPercentage();
             if (prayerPercent <= 10) {
                 prayerLabel.setForeground(DANGER_COLOR);
             } else if (prayerPercent <= 50) {
                 prayerLabel.setForeground(WARNING_COLOR);
             } else {
                 prayerLabel.setForeground(PRAYER_COLOR); // Soft blue for normal prayer levels
             }
             
             // Update inventory color based on percentage (reversed logic)
             int invPercent = (playerInfo.getInventoryUsedSlots() * 100) / 28;
             if (invPercent <= 10) { // 10% or less is red (danger - almost empty)
                 inventoryLabel.setForeground(DANGER_COLOR);
             } else if (invPercent <= 50) {
                 inventoryLabel.setForeground(WARNING_COLOR);
             } else {
                 inventoryLabel.setForeground(DARK_TEXT_COLOR); // Green for 50%+ (good amount of items)
             }
             // Repaint background if idle status changed
            contentPanel.repaint();
        });
    }
     
         private void updatePrayerIcon() {
        String activePrayer = playerInfo.getActiveProtectionPrayer();
        BufferedImage iconToUse = prayerIcon; // Default prayer icon
        
        switch (activePrayer) {
            case "melee":
                iconToUse = protectMeleeIcon;
                break;
            case "magic":
                iconToUse = protectMagicIcon;
                break;
            case "ranged":
                iconToUse = protectRangedIcon;
                break;
            default:
                iconToUse = prayerIcon; // Default prayer icon when no protection prayer is active
                break;
        }
        
        prayerLabel.setIcon(new ImageIcon(iconToUse));
    }
} 
package com.afkoverlay;

import lombok.Data;

@Data
public class PlayerInfo {
    private int currentHp = 0;
    private int maxHp = 0;
    private int currentPrayer = 0;
    private int maxPrayer = 0;
    private boolean idle = false;
    private int inventoryUsedSlots = 0;
    private String characterName = "";
    private String activeProtectionPrayer = ""; // "melee", "magic", "ranged", or empty string

    public int getHpPercentage() {
        if (maxHp == 0) return 0;
        return (currentHp * 100) / maxHp;
    }

    public int getPrayerPercentage() {
        if (maxPrayer == 0) return 0;
        return (currentPrayer * 100) / maxPrayer;
    }

    public String getStatusText() {
        return idle ? "IDLE" : "ACTIVE";
    }

    public String getHpText() {
        return String.format("%d/%d (%d%%)", currentHp, maxHp, getHpPercentage());
    }

    public String getPrayerText() {
        return String.format("%d/%d (%d%%)", currentPrayer, maxPrayer, getPrayerPercentage());
    }

    public String getInventoryText() {
        int totalSlots = 28;
        int usagePercentage = (inventoryUsedSlots * 100) / totalSlots;
        return String.format("%d/28 (%d%%)", inventoryUsedSlots, usagePercentage);
    }
    
    public String getActiveProtectionPrayer() {
        return activeProtectionPrayer;
    }
    
    public void setActiveProtectionPrayer(String prayer) {
        this.activeProtectionPrayer = prayer;
    }
} 
package com.afkoverlay;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.PlayerChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.SwingUtilities;
import java.awt.Image;
import java.time.Instant;

@Slf4j
@PluginDescriptor(
    name = "AFK Overlay",
    description = "Displays player information in a floating overlay window",
    tags = {"overlay", "player", "stats", "afk"}
)
public class AFKOverlayPlugin extends Plugin {

    @Inject
    private Client client;

    @Inject
    private AFKOverlayConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private AFKOverlay overlay;

    private FloatingOverlayWindow floatingWindow;
    private PlayerInfo playerInfo;
    // Track the last time the player was active
    private Instant lastActive = Instant.now();

    @Override
    protected void startUp() throws Exception {
        log.info("AFK Overlay plugin started!");
        
        // Initialize player info
        playerInfo = new PlayerInfo();        
        // Create and show floating overlay window
        SwingUtilities.invokeLater(() -> {
            floatingWindow = new FloatingOverlayWindow(playerInfo, config);
            
            // Set custom icon for the window (using the plugin hub icon)
            try {
                Image icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
                if (icon != null) {
                    floatingWindow.setIconImage(icon);
                    // Also try setting it as a list for better compatibility
                    floatingWindow.setIconImages(java.util.Arrays.asList(icon));
                }
            } catch ( IllegalArgumentException e) {
                // Silently fall back to default icon
            }
            
            floatingWindow.setVisible(true);
        });
        
        // Add overlay to overlay manager (for potential future use)
        overlayManager.add(overlay);
    }

    @Override
    protected void shutDown() throws Exception {
        log.info("AFK Overlay plugin stopped!");
        
        // Remove overlay from overlay manager
        overlayManager.remove(overlay);
        
        // Dispose of floating window
        if (floatingWindow != null) {
            SwingUtilities.invokeLater(() -> {
                floatingWindow.dispose();
                floatingWindow = null;
            });
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        updatePlayerInfo();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGED_IN) {
            updatePlayerInfo();
        }
    }

    @Subscribe
    public void onPlayerChanged(PlayerChanged event) {
        updatePlayerInfo();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (event.getGroup().equals("afkoverlay")) {
            // Update the floating window when config changes
            if (floatingWindow != null) {
                SwingUtilities.invokeLater(() -> floatingWindow.updateConfig());
            }
        }
    }

    private void updatePlayerInfo() {
        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        Player player = client.getLocalPlayer();
        if (player == null) {
            return;
        }

        // Update HP using skill levels
        int currentHp = client.getBoostedSkillLevel(Skill.HITPOINTS);
        int maxHp = client.getRealSkillLevel(Skill.HITPOINTS);
        if (currentHp > 0 && maxHp > 0) {
            playerInfo.setCurrentHp(currentHp);
            playerInfo.setMaxHp(maxHp);
        }

        // Update Prayer
        int currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
        int maxPrayer = client.getRealSkillLevel(Skill.PRAYER);
        if (currentPrayer > 0 && maxPrayer > 0) {
            playerInfo.setCurrentPrayer(currentPrayer);
            playerInfo.setMaxPrayer(maxPrayer);
        }

        // Idle detection using Instant.now()
        boolean isIdleNow = isPlayerIdle(player);
        Instant now = Instant.now();
        if (!isIdleNow) {
            lastActive = now;
            playerInfo.setIdle(false);
        } else {
            long millisSinceActive = java.time.Duration.between(lastActive, now).toMillis();
            int idleThreshold = config.idleThresholdMs();
            if (millisSinceActive >= idleThreshold) {
                playerInfo.setIdle(true);
            } else {
                playerInfo.setIdle(false);
            }
        }

        // Update inventory usage
        updateInventoryUsage();

        // Update character name
        updateCharacterName(player);
        
        // Update protection prayer
        updateProtectionPrayer(player);

        // Update the floating window
        if (floatingWindow != null) {
            SwingUtilities.invokeLater(() -> {
                floatingWindow.updateDisplay();
                floatingWindow.updateCharacterName(playerInfo.getCharacterName());
            });
        }
    }

    private boolean isPlayerIdle(Player player) {
        // Get the player's current animation, pose, and idle pose
        int animation = player.getAnimation();
        int pose = player.getPoseAnimation();
        int idlePose = player.getIdlePoseAnimation();

        // If the player is performing any animation (e.g., skilling, combat), they are active
        if (animation != -1) {
            return false;
        }

        // If the player's pose is not the idle pose, they are moving (walking/running), so they are active
        if (pose != idlePose) {
            return false;
        }

        // If the player is interacting with something (combat, etc.), they are active
        if (player.getInteracting() != null) {
            return false;
        }

        // If no animation, pose is idle, and not interacting, player is idle
        return true;
    }

    private void updateInventoryUsage() {
        try {
            ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
            if (inventory != null && inventory.getItems() != null) {
                Item[] items = inventory.getItems();
                int usedSlots = 0;
                for (Item item : items) {
                    if (item != null && item.getId() != -1) {
                        usedSlots++;
                    }
                }
                // Fix: Calculate percentage based on used slots, not total slots
                int totalSlots = 28; // RuneScape inventory has 28 slots
                playerInfo.setInventoryUsedSlots(usedSlots);
                log.debug("Inventory: {} used slots out of {}", usedSlots, totalSlots);
            } else {
                playerInfo.setInventoryUsedSlots(0);
                log.debug("Inventory container is null or has no items");
            }
        } catch (Exception e) {
            // If there's any error, set to 0
            playerInfo.setInventoryUsedSlots(0);
            log.debug("Error getting inventory: {}", e.getMessage());
        }
    }

    private void updateCharacterName(Player player) {
        String name = player.getName();
        if (name != null && !name.equals(playerInfo.getCharacterName())) {
            playerInfo.setCharacterName(name);
            log.debug("Character name updated: {}", name);
        }
    }
    
    private void updateProtectionPrayer(Player player) {
        // Check player's overhead icon to determine active protection prayer
        HeadIcon overheadIcon = player.getOverheadIcon();
        String activePrayer = "";
        
        // Check the HeadIcon enum to determine active protection prayer
        if (overheadIcon != null) {
            String iconName = overheadIcon.name();
            
            if (iconName.contains("MELEE")) {
                activePrayer = "melee";
            } else if (iconName.contains("MISSILES") || iconName.contains("RANGED")) {
                activePrayer = "ranged";
            } else if (iconName.contains("MAGIC")) {
                activePrayer = "magic";
            } else {
                activePrayer = ""; // No protection prayer active
            }
        } else {
            activePrayer = ""; // No protection prayer active
        }
        
        playerInfo.setActiveProtectionPrayer(activePrayer);
        log.debug("Protection prayer: {}", activePrayer);
    }

    @Provides
    AFKOverlayConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(AFKOverlayConfig.class);
    }
} 
package com.afkoverlay;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AFKOverlayPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AFKOverlayPlugin.class);
		RuneLite.main(args);
	}
}
