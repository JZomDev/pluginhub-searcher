package com.bankmemory;

import com.bankmemory.data.BankSave;
import lombok.ToString;
import lombok.Value;

@Value
public class BankDiffListOption {
    enum Type {
        CURRENT, SNAPSHOT
    }

    String listText;
    Type bankType;
    @ToString.Exclude BankSave save;
}

package com.bankmemory;

import com.bankmemory.bankview.BankViewPanel;
import com.bankmemory.bankview.ItemListEntry;
import com.bankmemory.data.BankWorldType;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ListMultimap;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.swing.DefaultComboBoxModel;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.ListCellRenderer;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

public class BankDiffPanel extends JPanel {
    static {
        BufferedImage backIcon = ImageUtil.getResourceStreamFromClass(BankDiffPanel.class, "reverse_icon.png");
        REVERSE_ICON = new ImageIcon(backIcon);
        REVERSE_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(backIcon, -100));
    }

    private static final Icon REVERSE_ICON;
    private static final Icon REVERSE_ICON_HOVER;
    private static final String CURRENT_BANKS = "- Current banks -";
    private static final String SNAPSHOT_BANKS = "- Snapshots -";

    private final BankViewPanel itemsList = new BankViewPanel();
    private final OptionsListModel beforeOptionsModel = new OptionsListModel();
    private final OptionsListModel afterOptionsModel = new OptionsListModel();
    private BankDiffPanelInteractionListener interactionListener;
    private boolean disableSelectionListener = false;

    BankDiffPanel() {
        super();
        setLayout(new BorderLayout());
        add(itemsList, BorderLayout.CENTER);
        itemsList.setItemsListRenderer(new DiffItemListRenderer());
        itemsList.setStyliseTotalValuesForDiffs(true);
        itemsList.reset();

        JPanel topPanel = new JPanel(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.anchor = GridBagConstraints.WEST;
        c.weightx = 0;
        c.gridx = 0;
        c.gridy = 0;
        topPanel.add(new JLabel("Before"), c);
        c.gridy = 1;
        topPanel.add(new JLabel("After"), c);
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 1;
        c.gridy = 0;
        topPanel.add(createComboBox(beforeOptionsModel), c);
        c.gridy = 1;
        topPanel.add(createComboBox(afterOptionsModel), c);
        c.fill = GridBagConstraints.NONE;
        c.weightx = 0;
        c.gridx = 2;
        c.gridy = 0;
        c.gridheight = 2;
        JButton reverseButton = new JButton(REVERSE_ICON);
        reverseButton.setRolloverIcon(REVERSE_ICON_HOVER);
        SwingUtil.removeButtonDecorations(reverseButton);
        reverseButton.addActionListener(a -> reverseBankChoices());
        topPanel.add(reverseButton, c);

        add(topPanel, BorderLayout.NORTH);
    }

    private JComboBox<Object> createComboBox(OptionsListModel listModel) {
        JComboBox<Object> comboBox = new JComboBox<>(listModel);
        comboBox.setRenderer(new OptionsListRenderer());
        comboBox.addActionListener(a -> comboBoxSelectionChanged());
        return comboBox;
    }

    void setInteractionListener(BankDiffPanelInteractionListener listener) {
        interactionListener = listener;
    }

    private void comboBoxSelectionChanged() {
        if (disableSelectionListener) {
            return;
        }
        BankDiffListOption before = beforeOptionsModel.getSelectedItem();
        BankDiffListOption after = afterOptionsModel.getSelectedItem();
        if (before != null && after != null) {
            interactionListener.userSelectedSavesToDiff(before, after);
        }
    }

    private void reverseBankChoices() {
        disableSelectionListener = true;
        BankDiffListOption swap = beforeOptionsModel.getSelectedItem();
        beforeOptionsModel.setSelectedItem(afterOptionsModel.getSelectedItem());
        afterOptionsModel.setSelectedItem(swap);
        disableSelectionListener = false;
        comboBoxSelectionChanged();
    }

    void displayBankOptions(List<BankDiffListOption> currentBanks, List<BankDiffListOption> snapshotBanks) {
        List<Object> options = new ArrayList<>();
        if (!currentBanks.isEmpty()) {
            options.add(CURRENT_BANKS);
            options.addAll(listWithWorldSeparators(currentBanks));
        }
        if (!snapshotBanks.isEmpty()) {
            options.add(SNAPSHOT_BANKS);
            options.addAll(listWithWorldSeparators(snapshotBanks));
        }
        disableSelectionListener = true;
        beforeOptionsModel.removeAllElements();
        afterOptionsModel.removeAllElements();
        options.forEach(o -> {
            beforeOptionsModel.addElement(o);
            afterOptionsModel.addElement(o);
        });
        disableSelectionListener = false;
    }

    private List<Object> listWithWorldSeparators(List<BankDiffListOption> options) {
        ListMultimap<BankWorldType, BankDiffListOption> optionsByWorldType = ArrayListMultimap.create();
        options.forEach(o -> optionsByWorldType.put(o.getSave().getWorldType(), o));
        List<Object> resultList = new ArrayList<>();
        for (BankWorldType type : BankWorldType.values()) {
            if (optionsByWorldType.containsKey(type)) {
                if (type != BankWorldType.DEFAULT) {
                    resultList.add(type.getDisplayString());
                }
                resultList.addAll(optionsByWorldType.get(type));
            }
        }
        return resultList;
    }

    void setSelections(BankDiffListOption before, BankDiffListOption after) {
        disableSelectionListener = true;
        beforeOptionsModel.setSelectedItem(before);
        afterOptionsModel.setSelectedItem(after);
        disableSelectionListener = false;
    }

    void displayItems(List<ItemListEntry> items, boolean keepListPosition) {
        itemsList.displayItemListings(items, keepListPosition);
    }

    public void resetSelectionsAndItemList() {
        beforeOptionsModel.setSelectedItem(null);
        afterOptionsModel.setSelectedItem(null);
        itemsList.reset();
        revalidate();
        repaint();
    }

    private static class OptionsListModel extends DefaultComboBoxModel<Object> {
        @Override
        public void setSelectedItem(Object anObject) {
            if (anObject instanceof BankDiffListOption || anObject == null) {
                super.setSelectedItem(anObject);
            }
        }

        @Override
        public BankDiffListOption getSelectedItem() {
            Object selected = super.getSelectedItem();
            return selected instanceof BankDiffListOption ? (BankDiffListOption) selected : null;
        }
    }

    private static class OptionsListRenderer implements ListCellRenderer<Object> {
        private final TitleCaseListCellRenderer wrapped = new TitleCaseListCellRenderer();

        @Override
        public Component getListCellRendererComponent(
                JList<?> list,
                Object value,
                int index,
                boolean isSelected,
                boolean cellHasFocus) {
            Object valToRender = value == null ? "" : value; // else ComboBoxListRenderer breaks
            if (value instanceof BankDiffListOption) {
                valToRender = ((BankDiffListOption) value).getListText();
            }

            Component comp = wrapped.getListCellRendererComponent(list, valToRender, index, isSelected, cellHasFocus);

            Font font = FontManager.getRunescapeFont();
            Color fgColour = comp.getForeground();
            if (!(value instanceof BankDiffListOption)) {
                if (value == CURRENT_BANKS || value == SNAPSHOT_BANKS) {
                    font = FontManager.getRunescapeBoldFont();
                } else {
                    font = FontManager.getRunescapeSmallFont().deriveFont(Font.ITALIC);
                }
                fgColour = ColorScheme.BRAND_ORANGE;
            }
            comp.setFont(font);
            comp.setForeground(fgColour);
            return comp;
        }
    }
}

package com.bankmemory;

import com.bankmemory.BankDiffListOption.Type;
import com.bankmemory.bankview.ItemListEntry;
import com.bankmemory.data.AbstractDataStoreUpdateListener;
import com.bankmemory.data.BankItem;
import com.bankmemory.data.BankSave;
import com.bankmemory.data.DataStoreUpdateListener;
import com.bankmemory.data.DisplayNameMapper;
import com.bankmemory.data.PluginDataStore;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

@Slf4j
public class BankDiffPanelController {

    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private ItemManager itemManager;
    @Inject private PluginDataStore dataStore;
    @Inject private ItemListDiffGenerator diffGenerator;

    private BankDiffPanel diffPanel;
    private DataUpdateListener dataListener;
    private BankDiffListOption lastBeforeSelection;
    private BankDiffListOption lastAfterSelection;

    public void startUp(BankDiffPanel diffPanel) {
        this.diffPanel = diffPanel;
        dataListener = new DataUpdateListener();
        diffPanel.setInteractionListener(this::userSelectedBankSaves);
        diffPanel.addHierarchyListener(e -> diffPanel.resetSelectionsAndItemList());
        dataStore.addListener(dataListener);
        updateForLatestBankData(true);
    }

    private void updateForLatestBankData(boolean currentBanksChanged) {
        assert SwingUtilities.isEventDispatchThread();

        List<BankDiffListOption> currentBanks = new ArrayList<>();
        List<BankDiffListOption> snapshotBanks = new ArrayList<>();
        DisplayNameMapper nameMapper = dataStore.getDisplayNameMapper();

        for (BankSave save : dataStore.getCurrentBanksList()) {
            String displayName = nameMapper.map(save.getAccountIdentifier());
            currentBanks.add(new BankDiffListOption(displayName, Type.CURRENT, save));
        }
        for (BankSave save : dataStore.getSnapshotBanksList()) {
            snapshotBanks.add(new BankDiffListOption(save.getSaveName(), Type.SNAPSHOT, save));
        }

        // Always need to update the options list as even if the banks are the same then that means it's a display name change
        diffPanel.displayBankOptions(currentBanks, snapshotBanks);

        BankDiffListOption equivalentBefore = findEquivalent(lastBeforeSelection, currentBanks, snapshotBanks);
        BankDiffListOption equivalentAfter = findEquivalent(lastAfterSelection, currentBanks, snapshotBanks);
        if (equivalentBefore != null && equivalentAfter != null) {
            diffPanel.setSelections(equivalentBefore, equivalentAfter);

            // NB: should only need to redo diff if current banks list change, not for snapshot banks list changing
            // (since if a snapshot save can be found again by its ID then it hasn't changed)
            if (currentBanksChanged && (
                    equivalentBefore.getBankType() == Type.CURRENT || equivalentAfter.getBankType() == Type.CURRENT)) {
                displayDiffOfSaves(equivalentBefore, equivalentAfter, true);
            }
        }
    }

    private BankDiffListOption findEquivalent(
            BankDiffListOption old,
            List<BankDiffListOption> currentBanks,
            List<BankDiffListOption> snapshots) {
        if (old == null) {
            return null;
        }
        switch (old.getBankType()) {
            case CURRENT:
                return currentBanks.stream()
                        .filter(b -> old.getSave().getAccountIdentifier().equalsIgnoreCase(b.getSave().getAccountIdentifier()))
                        .findAny().orElse(null);
            case SNAPSHOT:
                return snapshots.stream()
                        .filter(b -> old.getSave().getId() == b.getSave().getId())
                        .findAny().orElse(null);
        }
        throw new AssertionError();
    }

    private void userSelectedBankSaves(BankDiffListOption before, BankDiffListOption after) {
        assert SwingUtilities.isEventDispatchThread();
        lastBeforeSelection = before;
        lastAfterSelection = after;
        displayDiffOfSaves(before, after, false);
    }

    private void displayDiffOfSaves(BankDiffListOption before, BankDiffListOption after, boolean keepListPosition) {
        assert SwingUtilities.isEventDispatchThread();

        List<BankItem> differences = diffGenerator.findDifferencesBetween(
                before.getSave().getItemData(), after.getSave().getItemData());
        clientThread.invokeLater(() -> gatherItemDataToDisplay(differences, keepListPosition));
    }

    private void gatherItemDataToDisplay(List<BankItem> differences, boolean keepListPosition) {
        assert client.isClientThread();

        List<ItemListEntry> items = new ArrayList<>();

        for (BankItem i : differences) {
            ItemComposition ic = itemManager.getItemComposition(i.getItemId());
            // Quantity num is painted by renderer, but still give quantity so item stacks show nicely
            AsyncBufferedImage icon = itemManager.getImage(i.getItemId(), i.getQuantity(), false);
            int geValue = itemManager.getItemPrice(i.getItemId()) * i.getQuantity();
            int haValue = ic.getHaPrice() * i.getQuantity();
            items.add(new ItemListEntry(ic.getName(), i.getQuantity(), icon, geValue, haValue));
        }

        SwingUtilities.invokeLater(() -> diffPanel.displayItems(items, keepListPosition));
    }

    public void shutDown() {
        dataStore.removeListener(dataListener);
        lastBeforeSelection = null;
        lastAfterSelection = null;
    }

    private class DataUpdateListener extends AbstractDataStoreUpdateListener {
        @Override
        public void currentBanksListChanged() {
            SwingUtilities.invokeLater(() -> updateForLatestBankData(true));
        }

        @Override
        public void snapshotBanksListChanged() {
            SwingUtilities.invokeLater(() -> updateForLatestBankData(false));
        }

        @Override
        public void displayNameMapUpdated() {
            SwingUtilities.invokeLater(() -> updateForLatestBankData(false));
        }
    }
}

package com.bankmemory;

public interface BankDiffPanelInteractionListener {
    void userSelectedSavesToDiff(BankDiffListOption before, BankDiffListOption after);
}

package com.bankmemory;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(BankMemoryPlugin.CONFIG_GROUP)
public interface BankMemoryConfig extends Config {
    @ConfigItem(
            position = 1,
            keyName = "itemCountTooltips",
            name = "Show tooltips",
            description = "Show count of items in bank on item tooltips"
    )
    default boolean showTooltips() {
        return true;
    }

    void setTooltips(boolean tooltips);
}

package com.bankmemory;

import java.awt.Dimension;
import java.awt.Graphics2D;

import com.bankmemory.data.AccountIdentifier;
import com.bankmemory.data.BankItem;
import com.bankmemory.data.BankSave;
import com.bankmemory.data.BankWorldType;
import com.bankmemory.data.PluginDataStore;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.MenuEntry;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import java.util.Optional;

public class BankMemoryItemOverlay extends Overlay {
    private final Client client;
    private final BankMemoryConfig config;
    private final TooltipManager tooltipManager;
    private final PluginDataStore dataStore;

    @Inject
    BankMemoryItemOverlay(Client client, BankMemoryConfig config, TooltipManager tooltipManager, PluginDataStore dataStore) {
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.HIGHEST);
        this.client = client;
        this.config = config;
        this.tooltipManager = tooltipManager;
        this.dataStore = dataStore;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!config.showTooltips()) {
            return null;
        }

        MenuEntry[] menuEntries = client.getMenuEntries();

        if (menuEntries.length < 1) {
            return null;
        }

        MenuEntry menuEntry = menuEntries[menuEntries.length - 1];
        int widgetId = menuEntry.getParam1();

        if (widgetId != ComponentID.INVENTORY_CONTAINER) {
            return null;
        }

        int index = menuEntry.getParam0();


        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        Item item = inventory.getItem(index);
        if (item == null) {
            return null;
        }

        String itemCountTooltipText = null;

        BankWorldType worldType = BankWorldType.forWorld(client.getWorldType());
        String accountIdentifier = AccountIdentifier.fromAccountHash(client.getAccountHash());
        Optional<BankSave> existingSave = dataStore.getDataForCurrentBank(worldType, accountIdentifier);

        if (existingSave.isPresent()) {
            for (BankItem bankItem : existingSave.get().getItemData()) {
                if (bankItem.getItemId() == item.getId()) {
                    itemCountTooltipText = "Banked: " + bankItem.getQuantity();
                    break;
                }
            }
        }

        if (itemCountTooltipText != null) {
            tooltipManager.add(new Tooltip(itemCountTooltipText));
        }
        return null;
    }
}

package com.bankmemory;

import com.bankmemory.bankview.BankViewPanel;
import com.bankmemory.data.AccountIdentifier;
import com.bankmemory.data.BankSave;
import com.bankmemory.data.BankWorldType;
import com.bankmemory.data.PluginDataStore;
import com.bankmemory.util.Constants;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.Player;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

@PluginDescriptor(
        name = Constants.BANK_MEMORY,
        description = "A searchable record of what's in your bank"
)
public class BankMemoryPlugin extends Plugin {
    private static final String ICON = "bank_memory_icon.png";

    public static final String CONFIG_GROUP = "bankmemory";

    @Inject private ClientToolbar clientToolbar;
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private ItemManager itemManager;
    @Inject private PluginDataStore dataStore;

    @Inject private BankMemoryConfig config;

    @Inject private BankMemoryItemOverlay itemOverlay;

    @Inject private OverlayManager overlayManager;

    private CurrentBankPanelController currentBankPanelController;
    private SavedBanksPanelController savedBanksPanelController;
    private BankDiffPanelController diffPanelController;
    private NavigationButton navButton;
    private boolean displayNameRegistered = false;

    @Provides
    BankMemoryConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(BankMemoryConfig.class);
    }

    @Override
    protected void startUp() throws Exception {
        assert SwingUtilities.isEventDispatchThread();

        // Doing it here ensures it's created on the EDT + the instance is created after the client is all set up
        // (The latter is important because otherwise lots of L&F values won't be set right and it'll look weird)
        BankMemoryPluginPanel pluginPanel = injector.getInstance(BankMemoryPluginPanel.class);

        BufferedImage icon = ImageUtil.getResourceStreamFromClass(getClass(), ICON);
        navButton = NavigationButton.builder()
                .tooltip(Constants.BANK_MEMORY)
                .icon(icon)
                .priority(7)
                .panel(pluginPanel)
                .build();

        clientToolbar.addNavigation(navButton);

        currentBankPanelController = injector.getInstance(CurrentBankPanelController.class);
        BankViewPanel currentBankView = pluginPanel.getCurrentBankViewPanel();
        clientThread.invokeLater(() -> currentBankPanelController.startUp(currentBankView));

        savedBanksPanelController = injector.getInstance(SavedBanksPanelController.class);
        savedBanksPanelController.startUp(pluginPanel.getSavedBanksTopPanel());
        diffPanelController = injector.getInstance(BankDiffPanelController.class);
        diffPanelController.startUp(pluginPanel.getSavedBanksTopPanel().getDiffPanel());

        overlayManager.add(itemOverlay);
    }

    @Override
    protected void shutDown() {
        clientToolbar.removeNavigation(navButton);
        savedBanksPanelController.shutDown();
        diffPanelController.shutDown();
        currentBankPanelController = null;
        savedBanksPanelController = null;
        diffPanelController = null;
        overlayManager.remove(itemOverlay);
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        currentBankPanelController.onGameStateChanged(gameStateChanged);
        if (gameStateChanged.getGameState() != GameState.LOGGED_IN) {
            displayNameRegistered = false;
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (!displayNameRegistered) {
            String accountIdentifier = AccountIdentifier.fromAccountHash(client.getAccountHash());
            Player player = client.getLocalPlayer();
            String charName = player == null ? null : player.getName();
            if (accountIdentifier != null && charName != null) {
                displayNameRegistered = true;
                dataStore.registerDisplayNameForAccountId(accountIdentifier, charName);
            }
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (event.getContainerId() != InventoryID.BANK.getId()) {
            return;
        }
        BankWorldType worldType = BankWorldType.forWorld(client.getWorldType());
        ItemContainer bank = event.getItemContainer();
        String accountIdentifier = AccountIdentifier.fromAccountHash(client.getAccountHash());
        dataStore.saveAsCurrentBank(BankSave.fromCurrentBank(worldType, accountIdentifier, bank, itemManager));
    }
}

package com.bankmemory;

import com.bankmemory.bankview.BankViewPanel;
import java.awt.BorderLayout;
import javax.swing.BorderFactory;
import javax.swing.JPanel;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;


import static com.bankmemory.util.Constants.PAD;

class BankMemoryPluginPanel extends PluginPanel {

    private final BankViewPanel currentBankViewPanel = new BankViewPanel();
    private final BankSavesTopPanel savedBanksTopPanel = new BankSavesTopPanel();

    protected BankMemoryPluginPanel() {
        super(false);
        setBorder(BorderFactory.createEmptyBorder(PAD, PAD, PAD, PAD));

        JPanel displayPanel = new JPanel();
        MaterialTabGroup tabGroup = new MaterialTabGroup(displayPanel);
        MaterialTab currentBankTab = new MaterialTab("Current bank", tabGroup, currentBankViewPanel);
        MaterialTab savesListTab = new MaterialTab("Saved banks", tabGroup, savedBanksTopPanel);
        tabGroup.addTab(currentBankTab);
        tabGroup.addTab(savesListTab);
        tabGroup.select(currentBankTab);

        setLayout(new BorderLayout());
        add(tabGroup, BorderLayout.NORTH);
        add(displayPanel, BorderLayout.CENTER);
    }

    BankViewPanel getCurrentBankViewPanel() {
        return currentBankViewPanel;
    }

    BankSavesTopPanel getSavedBanksTopPanel() {
        return savedBanksTopPanel;
    }
}

package com.bankmemory;

import com.bankmemory.bankview.BankViewPanel;
import com.bankmemory.bankview.ItemListEntry;
import java.awt.BorderLayout;
import java.awt.image.BufferedImage;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

public class BankSavesTopPanel extends JPanel {
    static {
        BufferedImage backIcon = ImageUtil.getResourceStreamFromClass(BankSavesTopPanel.class, "back_icon.png");
        BACK_ICON = new ImageIcon(backIcon);
        BACK_ICON_HOVER = new ImageIcon(ImageUtil.alphaOffset(backIcon, -100));
    }

    private static final Icon BACK_ICON;
    private static final Icon BACK_ICON_HOVER;

    private final BanksListPanel banksListPanel = new BanksListPanel();
    private final BankViewPanel bankViewPanel = new BankViewPanel();
    private final BankDiffPanel bankDiffPanel = new BankDiffPanel();
    private final JPanel backButtonAndTitle = new JPanel();
    private final JLabel subUiTitle = new JLabel();

    public BankSavesTopPanel() {
        super();
        setLayout(new BorderLayout());

        backButtonAndTitle.setLayout(new BoxLayout(backButtonAndTitle, BoxLayout.LINE_AXIS));
        JButton backButton = new JButton(BACK_ICON);
        SwingUtil.removeButtonDecorations(backButton);
        backButton.setRolloverIcon(BACK_ICON_HOVER);
        backButton.addActionListener(e -> displayBanksListPanel());
        backButtonAndTitle.add(backButton);
        backButtonAndTitle.add(subUiTitle);
    }

    void setBanksListInteractionListener(BanksListInteractionListener listener) {
        banksListPanel.setInteractionListener(listener);
    }

    void displayBanksListPanel() {
        bankViewPanel.reset();
        removeAll();
        add(banksListPanel, BorderLayout.CENTER);
        revalidate();
        repaint();
    }

    void updateBanksList(List<BanksListEntry> entries) {
        banksListPanel.updateBanksList(entries);
    }

    void displaySavedBankData(String saveName, List<ItemListEntry> items, String timeString) {
        removeAll();
        subUiTitle.setText(saveName);
        add(backButtonAndTitle, BorderLayout.NORTH);
        add(bankViewPanel, BorderLayout.CENTER);
        bankViewPanel.updateTimeDisplay(timeString);
        bankViewPanel.displayItemListings(items, false);
        revalidate();
        repaint();
    }

    public BankViewPanel getBankViewPanel() {
        return bankViewPanel;
    }

    public BankDiffPanel getDiffPanel() {
        return bankDiffPanel;
    }

    void showBankDiffPanel() {
        removeAll();
        subUiTitle.setText("Bank comparison");
        add(backButtonAndTitle, BorderLayout.NORTH);
        add(bankDiffPanel, BorderLayout.CENTER);
        revalidate();
        repaint();
    }
}

package com.bankmemory;

import com.bankmemory.data.BankWorldType;
import javax.swing.ImageIcon;
import lombok.Value;

@Value
public class BanksListEntry {
    long saveId;
    ImageIcon icon;
    BankWorldType worldType;
    String saveName;
    String accountDisplayName;
    String dateTime;
}

package com.bankmemory;

public interface BanksListInteractionListener {
    void selectedToOpen(BanksListEntry save);

    void selectedToDelete(BanksListEntry save);

    void saveBankAs(BanksListEntry save, String saveName);

    void copyBankSaveItemDataToClipboard(BanksListEntry save);

    void openBanksDiffPanel();
}

package com.bankmemory;

import com.bankmemory.data.BankWorldType;
import com.bankmemory.util.Constants;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.MouseInfo;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.List;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.PluginErrorPanel;


public class BanksListPanel extends JPanel {

    private static final String DELETE_SAVE = "Delete save...";
    private static final String SAVE_SNAPSHOT = "Save snapshot...";

    private final PluginErrorPanel noDataMessage;
    private final JPanel listPanel;
    private final JPopupMenu bankEntryContextMenu;
    private final ListEntryMouseListener mouseListener;
    private BanksListInteractionListener interactionListener;

    public BanksListPanel() {
        super();
        mouseListener = new ListEntryMouseListener();
        bankEntryContextMenu = createContextMenu();

        setLayout(new BorderLayout());
        setBorder(BorderFactory.createEmptyBorder(Constants.PAD, 0, Constants.PAD, 0));

        noDataMessage = new PluginErrorPanel();
        noDataMessage.setContent("No bank saves", "You currently do not have any bank saves.");
        add(noDataMessage, BorderLayout.NORTH);

        listPanel = new JPanel(new GridBagLayout());
        JPanel listWrapper = new JPanel(new BorderLayout());
        listWrapper.add(listPanel, BorderLayout.NORTH);
        JScrollPane scrollPane = new JScrollPane(listWrapper);
        add(scrollPane, BorderLayout.CENTER);

        JButton compareBanks = new JButton("Compare bank saves");
        compareBanks.addActionListener(a -> interactionListener.openBanksDiffPanel());
        add(compareBanks, BorderLayout.SOUTH);
    }

    private JPopupMenu createContextMenu() {
        JPopupMenu menu = new JPopupMenu();
        menu.add(createMenuSaveAsAction(menu));
        menu.add(createMenuCopyItemDataToClipboardAction(menu));
        menu.add(createMenuDeleteAction(menu));
        return menu;
    }

    private Action createMenuSaveAsAction(JPopupMenu menu) {
        return new AbstractAction(SAVE_SNAPSHOT) {
            @Override
            public void actionPerformed(ActionEvent e) {
                String inputName;
                do {
                    inputName = JOptionPane.showInputDialog(
                            BanksListPanel.this, "Enter name for new bank snapshot:", "Save Snapshot As", JOptionPane.PLAIN_MESSAGE);
                    if (inputName == null) {
                        return;
                    }
                    inputName = inputName.trim();
                } while (inputName.isEmpty());

                BanksListEntry save = ((EntryPanel) menu.getInvoker()).entry;
                interactionListener.saveBankAs(save, inputName);
            }
        };
    }

    private Action createMenuCopyItemDataToClipboardAction(JPopupMenu menu) {
        return new AbstractAction(Constants.ACTION_COPY_ITEM_DATA_TO_CLIPBOARD) {
            @Override
            public void actionPerformed(ActionEvent e) {
                BanksListEntry save = ((EntryPanel) menu.getInvoker()).entry;
                interactionListener.copyBankSaveItemDataToClipboard(save);
            }
        };
    }

    private Action createMenuDeleteAction(JPopupMenu menu) {
        return new AbstractAction(DELETE_SAVE) {
            @Override
            public void actionPerformed(ActionEvent e) {
                String message = "Are you sure you want to delete this save?";
                int result = JOptionPane.showConfirmDialog(
                        BanksListPanel.this, message, Constants.BANK_MEMORY, JOptionPane.YES_NO_OPTION);
                if (result == JOptionPane.YES_OPTION) {
                    BanksListEntry save = ((EntryPanel) menu.getInvoker()).entry;
                    interactionListener.selectedToDelete(save);
                }
            }
        };
    }

    public void setInteractionListener(BanksListInteractionListener listener) {
        interactionListener = listener;
    }

    public void updateBanksList(List<BanksListEntry> entries) {
        listPanel.removeAll();

        noDataMessage.setVisible(entries.isEmpty());
        if (!entries.isEmpty()) {
            displayListOfBanks(entries);
        }

        revalidate();
        repaint();
    }

    private void displayListOfBanks(List<BanksListEntry> entries) {
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;
        for (BanksListEntry entry : entries) {
            JPanel entriesGapPad = new JPanel(new BorderLayout());
            entriesGapPad.setBorder(BorderFactory.createEmptyBorder(Constants.PAD / 2, 0, Constants.PAD / 2, 0));
            entriesGapPad.add(new EntryPanel(entry), BorderLayout.NORTH);
            listPanel.add(entriesGapPad, c);
            c.gridy++;
        }
    }

    private class EntryPanel extends JPanel {
        final BanksListEntry entry;

        public EntryPanel(BanksListEntry entry) {
            this.entry = entry;

            setLayout(new GridBagLayout());
            setBorder(BorderFactory.createEmptyBorder(Constants.PAD, Constants.PAD, Constants.PAD, Constants.PAD));
            setBackground(ColorScheme.DARKER_GRAY_COLOR);
            setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            setToolTipText(entry.getDateTime());
            setComponentPopupMenu(bankEntryContextMenu);

            GridBagConstraints c = new GridBagConstraints();
            c.gridx = 0;
            c.gridy = 0;
            c.weightx = 0;
            c.gridheight = 2;
            add(new JLabel(entry.getIcon()), c);

            c.fill = GridBagConstraints.HORIZONTAL;
            c.gridx = 1;
            c.weightx = 1;
            c.gridheight = 1;
            add(new JLabel(entry.getSaveName()), c);

            c.gridy = 1;
            String subText = entry.getAccountDisplayName();
            if (entry.getWorldType() != BankWorldType.DEFAULT) {
                subText += " (" + entry.getWorldType().getDisplayString() + ")";
            }
            JLabel subLabel = new JLabel(subText);
            subLabel.setFont(FontManager.getRunescapeSmallFont());
            add(subLabel, c);

            addMouseListener(mouseListener);
        }
    }

    private class ListEntryMouseListener extends MouseAdapter {
        private final Color normalBgColour = ColorScheme.DARKER_GRAY_COLOR;
        private final Color hoverBgColour = ColorScheme.DARKER_GRAY_HOVER_COLOR;

        @Override
        public void mouseEntered(MouseEvent e) {
            e.getComponent().setBackground(hoverBgColour);
        }

        @Override
        public void mouseExited(MouseEvent e) {
            e.getComponent().setBackground(normalBgColour);
        }

        @Override
        public void mouseClicked(MouseEvent e) {
            if (SwingUtilities.isLeftMouseButton(e)) {
                BanksListEntry entryClicked = ((EntryPanel) e.getComponent()).entry;
                interactionListener.selectedToOpen(entryClicked);

                // mouseExited won't trigger if the interaction listener changes the view entirely,
                // so trigger manually if needed
                if (!e.getComponent().contains(MouseInfo.getPointerInfo().getLocation())) {
                    mouseExited(e);
                }
            }
        }
    }
}

package com.bankmemory.bankview;

import com.bankmemory.util.Constants;
import com.bankmemory.util.OnAnyChangeDocumentListener;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.Point;
import java.util.List;
import javax.swing.Action;
import javax.swing.BorderFactory;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.ListCellRenderer;
import javax.swing.ListModel;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.AsyncBufferedImage;


import static com.bankmemory.util.Constants.PAD;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

public class BankViewPanel extends JPanel {

    private enum DisplayState {
        RESET, SHOWING_NO_DATA, SHOWING_ITEM_LIST
    }

    private DisplayState state;

    private final JLabel syncTimeLabel;
    private final JPanel northPanel;
    private final IconTextField filterField;
    private final ValueDisplayPanel valueDisplay;
    private final ItemList itemsList;
    private final JScrollPane itemsScrollPane;
    private final PluginErrorPanel errorPanel;

    public BankViewPanel() {
        super(false);
        setLayout(new BorderLayout(0, PAD));
        setBorder(BorderFactory.createEmptyBorder(PAD, 0, PAD, 0));

        northPanel = new JPanel(new BorderLayout(0, PAD / 2));
        valueDisplay = new ValueDisplayPanel();
        northPanel.add(valueDisplay, BorderLayout.NORTH);
        filterField = new IconTextField();
        northPanel.add(filterField, BorderLayout.SOUTH);

        itemsList = new ItemList();
        itemsList.setCellRenderer(new ItemListRenderer());
        itemsScrollPane = new JScrollPane(itemsList);

        filterField.setIcon(IconTextField.Icon.SEARCH);
        filterField.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        filterField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        filterField.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        filterField.getDocument().addDocumentListener(new OnAnyChangeDocumentListener() {
            @Override
            public void onChange(DocumentEvent e) {
                itemsScrollPane.getViewport().setViewPosition(new Point(0, 0));
                itemsList.getModel().applyFilter(filterField.getText());
            }
        });

        syncTimeLabel = new JLabel();
        syncTimeLabel.setFont(FontManager.getRunescapeSmallFont());

        errorPanel = new PluginErrorPanel();
        errorPanel.setContent(Constants.BANK_MEMORY,
                "Log in to a character and open a bank window to populate bank data for that character.");
        displayNoDataMessage();
    }

    public void displayNoDataMessage() {
        checkState(SwingUtilities.isEventDispatchThread());
        reset();
        add(errorPanel, BorderLayout.NORTH);
        state = DisplayState.SHOWING_NO_DATA;
        repaint();
    }

    /**
     * Resets filter, resets list data, resets scroll position and removes UI components.
     * Indirectly: releases some held objects (by resetting the list).
     */
    public void reset() {
        checkState(SwingUtilities.isEventDispatchThread());
        itemsList.getModel().clearList();
        itemsList.getModel().clearFilter();
        filterField.setText("");
        resetScrolling();
        removeAll();
        state = DisplayState.RESET;
    }

    private void resetScrolling() {
        itemsScrollPane.getViewport().setViewPosition(new Point(0, 0));
    }

    public void updateTimeDisplay(String timeString) {
        checkState(SwingUtilities.isEventDispatchThread());
        syncTimeLabel.setText("Data from: " + timeString);
    }

    public void displayItemListings(List<ItemListEntry> items, boolean preserveScrollPos) {
        checkState(SwingUtilities.isEventDispatchThread());

        ensureDisplayIsInItemListState();
        Point scrollPosition = itemsScrollPane.getViewport().getViewPosition();

        long geValue = 0;
        long haValue = 0;
        for (int i = 0; i < items.size(); i++) {
            AsyncBufferedImage img = items.get(i).getImage();
            int unfilteredRow = i;
            img.onLoaded(() -> repaintItemEntryIfRowVisible(unfilteredRow));
            geValue += items.get(i).getGeValue();
            haValue += items.get(i).getHaValue();
        }
        valueDisplay.setValues(geValue, haValue);
        FilterableItemListModel listModel = itemsList.getModel();
        listModel.setListContents(items);

        if (preserveScrollPos) {
            itemsScrollPane.getViewport().setViewPosition(scrollPosition);
        } else {
            itemsScrollPane.getViewport().setViewPosition(new Point(0, 0));
        }
        validate();
        repaint();
    }

    private void ensureDisplayIsInItemListState() {
        if (state == DisplayState.SHOWING_ITEM_LIST) {
            return;
        }
        removeAll();
        add(northPanel, BorderLayout.NORTH);
        add(itemsScrollPane, BorderLayout.CENTER);
        add(syncTimeLabel, BorderLayout.SOUTH);
        state = DisplayState.SHOWING_ITEM_LIST;
    }

    private void repaintItemEntryIfRowVisible(int unfilteredIndex) {
        int adjustedIndex = itemsList.getModel().getAdjustedIndex(unfilteredIndex);
        if (adjustedIndex < 0) {
            // Filtered out!
            return;
        }
        if (itemsList.getFirstVisibleIndex() <= unfilteredIndex && unfilteredIndex <= itemsList.getLastVisibleIndex()) {
            itemsList.repaint(itemsList.getCellBounds(adjustedIndex, adjustedIndex));
        }
    }

    public void setItemsListRenderer(ListCellRenderer<ItemListEntry> renderer) {
        itemsList.setCellRenderer(renderer);
    }

    public void setStyliseTotalValuesForDiffs(boolean show) {
        valueDisplay.setStylisedForDiffs(show);
    }

    public void setItemListPopupMenuAction(Action action) {
        JPopupMenu menu = new JPopupMenu();
        menu.add(action);
        itemsList.setComponentPopupMenu(menu);
    }

    private static class ItemList extends JList<ItemListEntry> {
        ItemList() {
            super(new FilterableItemListModel());
        }

        @Override
        public void setModel(ListModel<ItemListEntry> model) {
            checkNotNull(model);
            checkArgument(model instanceof FilterableItemListModel, "Incorrect class: " + model.getClass());
            super.setModel(model);
        }

        @Override
        public FilterableItemListModel getModel() {
            return (FilterableItemListModel) super.getModel();
        }
    }
}

package com.bankmemory.bankview;

import com.google.common.collect.ImmutableList;
import java.util.ArrayList;
import java.util.List;
import javax.swing.ListModel;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;


import static com.google.common.base.Preconditions.checkElementIndex;

class FilterableItemListModel implements ListModel<ItemListEntry> {

    private List<ItemListEntry> rawListContents = new ArrayList<>();
    private String lcFilterString = "";
    private List<Integer> postFilterIndexes = new ArrayList<>();
    private final List<ListDataListener> listeners = new ArrayList<>();

    public void setListContents(List<ItemListEntry> contents) {
        rawListContents = ImmutableList.copyOf(contents);
        applyFilterSilently(lcFilterString);
        fireListeners();
    }

    private static List<Integer> unfilteredIndexList(int numElements) {
        List<Integer> indexes = new ArrayList<>();
        for (int i = 0; i < numElements; i++) {
            indexes.add(i);
        }
        return indexes;
    }

    private void fireListeners() {
        ListDataEvent evt = new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, 0, getSize() - 1);
        listeners.forEach(l -> l.contentsChanged(evt));
    }

    public void clearList() {
        setListContents(new ArrayList<>());
    }

    @Override
    public int getSize() {
        return postFilterIndexes.size();
    }

    @Override
    public ItemListEntry getElementAt(int index) {
        return rawListContents.get(postFilterIndexes.get(index));
    }

    @Override
    public void addListDataListener(ListDataListener l) {
        listeners.add(l);
    }

    @Override
    public void removeListDataListener(ListDataListener l) {
        listeners.remove(l);
    }

    public void applyFilter(String filterString) {
        List<Integer> oldIndexes = postFilterIndexes;
        applyFilterSilently(filterString);
        if (!oldIndexes.equals(postFilterIndexes)) {
            fireListeners();
        }
    }

    private void applyFilterSilently(String filterString) {
        lcFilterString = filterString.toLowerCase();
        if (filterString.isEmpty()) {
            postFilterIndexes = unfilteredIndexList(rawListContents.size());
            return;
        }
        List<Integer> indexes = new ArrayList<>();
        for (int i = 0; i < rawListContents.size(); i++) {
            if (rawListContents.get(i).getItemName().toLowerCase().contains(lcFilterString)) {
                indexes.add(i);
            }
        }
        postFilterIndexes = indexes;
    }

    public void clearFilter() {
        applyFilter("");
    }

    /**
     * @return -1 if the rawIndex has been filtered out, else the index's adjusted position with any filter applied.
     */
    public int getAdjustedIndex(int rawIndex) {
        checkElementIndex(rawIndex, rawListContents.size());
        return postFilterIndexes.indexOf(rawIndex);
    }
}

package com.bankmemory.bankview;

import lombok.Value;
import net.runelite.client.util.AsyncBufferedImage;

@Value
public class ItemListEntry {
    String itemName;
    int quantity;
    AsyncBufferedImage image;
    int geValue;
    int haValue;
}

package com.bankmemory.bankview;

import java.awt.Component;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;

class ItemListRenderer extends JLabel implements ListCellRenderer<ItemListEntry> {
    @Override
    public Component getListCellRendererComponent(JList<? extends ItemListEntry> list,
                                                  ItemListEntry value,
                                                  int index,
                                                  boolean isSelected,
                                                  boolean cellHasFocus) {
        setText(value.getItemName());
        setIcon(new ImageIcon(value.getImage()));
        return this;
    }
}

package com.bankmemory.bankview;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Rectangle;
import java.awt.geom.Rectangle2D;
import javax.swing.JComponent;

class ValueDisplayPanel extends JComponent {
    private static final String GE = "GE: ";
    private static final String HA = "HA: ";

    private final ValueFormatter formatter = new ValueFormatter();
    private long geValue;
    private long haValue;
    private boolean styliseForDiffs;

    void setValues(long geValue, long haValue) { ;
        this.geValue = geValue;
        this.haValue = haValue;
        updateToolTip();
        repaint();
    }

    private void updateToolTip() {
        setToolTipText("" +
                "<html>" +
                "<p> Grand Exchange value: "+ formatter.format(geValue) + "gp</p>" +
                "</br>" +
                "<p>High Alchemy value: "+ formatter.format(haValue) + "gp</p>" +
                "</html>"
        );
    }

    void setStylisedForDiffs(boolean stylise) {
        formatter.setShowPositiveSign(stylise);
        styliseForDiffs = stylise;
        updateToolTip();
        repaint();
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Insets i = getInsets();
        Graphics gInset = g.create(i.left, i.top, getWidth() - i.left - i.right, getHeight() - i.top - i.bottom);
        Rectangle b = gInset.getClipBounds();
        paintValue(gInset.create(0, 0, b.width / 2, b.height), GE, geValue);
        paintValue(gInset.create(b.width / 2, 0, b.width / 2, b.height), HA, haValue);
        gInset.dispose();
    }

    private void paintValue(Graphics g, String name, long value) {
        FontMetrics fm = g.getFontMetrics();
        int fontH = fm.getHeight();
        int nameW = fm.stringWidth(name);
        String numText = formatter.formatAbbreviated(value);
        int start = g.getClipBounds().width / 2 - fm.stringWidth(name + numText) / 2;

        g.setColor(getForeground());
        g.drawString(name, start, fontH);

        if (styliseForDiffs) {
            g.setColor(Color.BLACK);
            g.drawString(numText, start + nameW + 1, fontH + 1);
            g.setColor(value == 0 ? getForeground() : value > 0 ? Color.GREEN : Color.RED);
        }
        g.drawString(numText, start + nameW, fontH);

        g.dispose();
    }

    @Override
    public Dimension getMinimumSize() {
        return getPreferredSize();
    }

    @Override
    public Dimension getPreferredSize() {
        Graphics g = getGraphics();
        FontMetrics fm = g.getFontMetrics();
        Rectangle2D strB = fm.getStringBounds(
                GE + formatter.formatAbbreviated(geValue) + " " + HA + formatter.formatAbbreviated(haValue), g);
        return new Dimension((int) Math.ceil(strB.getWidth()), (int) Math.ceil(strB.getHeight()));
    }
}

package com.bankmemory.bankview;

import java.math.RoundingMode;
import java.text.DecimalFormat;

class ValueFormatter {
    private final DecimalFormat formatter;

    ValueFormatter() {
        formatter = new DecimalFormat();
        formatter.setMaximumFractionDigits(2);
        formatter.setRoundingMode(RoundingMode.DOWN);
    }

    String format(long value) {
        return formatter.format(value);
    }

    String formatAbbreviated(long value) {
        long absolute = Math.abs(value);
        double divisor;
        String suffix;
        if (absolute < 10000) {
            divisor = 1;
            suffix = "";
        } else if (absolute < 1000000) {
            divisor = 1000;
            suffix = "K";
        } else if (absolute < 1000000000) {
            divisor = 1000000;
            suffix = "M";
        } else {
            divisor = 1000000000;
            suffix = "B";
        }

        StringBuilder str = new StringBuilder();
        String numStr = formatter.format(value / divisor);
        return  str.append(numStr).append(suffix).toString();
    }

    void setShowPositiveSign(boolean show) {
        formatter.setPositivePrefix(show ? "+" : "");
    }
}

package com.bankmemory;

import com.bankmemory.data.BankSave;
import com.bankmemory.util.ClipboardActions;
import com.bankmemory.util.Constants;
import java.awt.event.ActionEvent;
import java.util.Objects;
import javax.annotation.Nullable;
import javax.swing.AbstractAction;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;

public abstract class CopyItemsToClipboardAction extends AbstractAction {

    private final ClientThread clientThread;
    private final ItemManager itemManager;

    CopyItemsToClipboardAction(ClientThread clientThread, ItemManager itemManager) {
        super(Constants.ACTION_COPY_ITEM_DATA_TO_CLIPBOARD);
        this.clientThread = Objects.requireNonNull(clientThread);
        this.itemManager = Objects.requireNonNull(itemManager);
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        BankSave data = getBankItemData();
        if (data == null) {
            return;
        }

        ClipboardActions.copyItemDataAsTsvToClipboardOnClientThread(clientThread, itemManager, data.getItemData());
    }

    @Nullable
    public abstract BankSave getBankItemData();
}

package com.bankmemory;

import com.bankmemory.bankview.BankViewPanel;
import com.bankmemory.bankview.ItemListEntry;
import com.bankmemory.data.AbstractDataStoreUpdateListener;
import com.bankmemory.data.AccountIdentifier;
import com.bankmemory.data.BankItem;
import com.bankmemory.data.BankSave;
import com.bankmemory.data.BankWorldType;
import com.bankmemory.data.PluginDataStore;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

@Slf4j
public class CurrentBankPanelController {
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private ItemManager itemManager;
    @Inject private PluginDataStore dataStore;

    private BankViewPanel panel;

    @Nullable private BankSave latestDisplayedData = null;

    public void startUp(BankViewPanel panel) {
        assert client.isClientThread();

        this.panel = panel;
        SwingUtilities.invokeLater(this::setPopupMenuActionOnBankView);

        DataStoreListener dataStoreListener = new DataStoreListener();
        dataStore.addListener(dataStoreListener);

        if (client.getGameState() == GameState.LOGGED_IN) {
            updateDisplayForCurrentAccount();
        } else {
            SwingUtilities.invokeLater(panel::displayNoDataMessage);
        }
    }

    private void setPopupMenuActionOnBankView() {
        this.panel.setItemListPopupMenuAction(new CopyItemsToClipboardAction(clientThread, itemManager) {
            @Nullable
            @Override
            public BankSave getBankItemData() {
                if (latestDisplayedData == null) {
                    log.error("Tried to copy CSV data to clipboard before any current bank shown");
                }
                return latestDisplayedData;
            }
        });
    }

    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        assert client.isClientThread();

        if (gameStateChanged.getGameState() != GameState.LOGGED_IN) {
            return;
        }
        updateDisplayForCurrentAccount();
    }

    private void updateDisplayForCurrentAccount() {
        BankWorldType worldType = BankWorldType.forWorld(client.getWorldType());
        String accountIdentifier = AccountIdentifier.fromAccountHash(client.getAccountHash());
        Optional<BankSave> existingSave = dataStore.getDataForCurrentBank(worldType, accountIdentifier);
        if (existingSave.isPresent()) {
            viewBankSave(existingSave.get());
        } else {
            latestDisplayedData = null;
            SwingUtilities.invokeLater(panel::displayNoDataMessage);
        }
    }

    private void viewBankSave(BankSave bankSave) {
        assert client.isClientThread();

        dataStore.currentBankViewed(bankSave.getId());

        boolean shouldReset = isBankIdentityDifferentToLastDisplayed(bankSave);
        boolean shouldUpdateItemsDisplay = shouldReset || isItemDataNew(bankSave);
        List<ItemListEntry> items = new ArrayList<>();
        if (shouldUpdateItemsDisplay) {
            // Get all the data we need for the UI on this thread (the game thread)
            // Doing it on the EDT seems to cause random crashes & NPEs
            for (BankItem i : bankSave.getItemData()) {
                ItemComposition ic = itemManager.getItemComposition(i.getItemId());
                AsyncBufferedImage icon = itemManager.getImage(i.getItemId(), i.getQuantity(), i.getQuantity() > 1);
                int geValue = itemManager.getItemPrice(i.getItemId()) * i.getQuantity();
                int haValue = ic.getHaPrice() * i.getQuantity();
                items.add(new ItemListEntry(ic.getName(), i.getQuantity(), icon, geValue, haValue));
            }
        }
        SwingUtilities.invokeLater(() -> {
            if (shouldReset) {
                panel.reset();
            }
            panel.updateTimeDisplay(bankSave.getDateTimeString());
            if (shouldUpdateItemsDisplay) {
                panel.displayItemListings(items, true);
            }
        });
        latestDisplayedData = bankSave;
    }

    private boolean isBankIdentityDifferentToLastDisplayed(BankSave newSave) {
        if (latestDisplayedData == null) {
            return true;
        }
        boolean accountIdentifiersSame = latestDisplayedData.getAccountIdentifier().equalsIgnoreCase(newSave.getAccountIdentifier());
        boolean worldTypesSame = latestDisplayedData.getWorldType() == newSave.getWorldType();
        return !accountIdentifiersSame || !worldTypesSame;
    }

    private boolean isItemDataNew(BankSave newSave) {
        return latestDisplayedData == null || !latestDisplayedData.getItemData().equals(newSave.getItemData());
    }

    private class DataStoreListener extends AbstractDataStoreUpdateListener {
        @Override
        public void currentBanksListChanged() {
            updateDisplayForCurrentAccount();
        }
    }
}

package com.bankmemory.data;

public abstract class AbstractDataStoreUpdateListener implements DataStoreUpdateListener {
    @Override
    public void currentBanksListChanged() {
        // NO OP
    }

    @Override
    public void currentBanksListOrderChanged() {
        // NO OP
    }

    @Override
    public void snapshotBanksListChanged() {
        // NO OP
    }

    @Override
    public void displayNameMapUpdated() {
        // NO OP
    }
}

package com.bankmemory.data;

import javax.annotation.Nullable;

public class AccountIdentifier {

    public static final String ACCOUNT_HASH_ID_PREFIX = "accId#hash1#";

    private AccountIdentifier() {}

    @Nullable
    public static String fromAccountHash(long accountHash) {
        if (accountHash == -1) {
            return null;
        }
        return ACCOUNT_HASH_ID_PREFIX + accountHash;
    }
}

package com.bankmemory.data;

import lombok.Value;

@Value
public class BankItem {
    int itemId;
    int quantity;
}

package com.bankmemory.data;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.MoreObjects;
import com.google.common.collect.ImmutableList;
import com.google.gson.annotations.SerializedName;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicInteger;
import javax.annotation.Nullable;
import lombok.Value;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

@Value
public class BankSave {
    private static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern("HH:mm:ss, d MMM uuuu");
    private static final SaferUsernameFunction SAFER_USERNAME = new SaferUsernameFunction();
    private static final long ID_BASE = System.currentTimeMillis();
    private static final AtomicInteger idIncrementer = new AtomicInteger();

    private static final int NULL_ITEM_ID = -1;

    long id;
    BankWorldType worldType;
    String dateTimeString;
    @SerializedName(value = "accountIdentifier", alternate = {"userName"}) String accountIdentifier;
    @Nullable String saveName;
    ImmutableList<BankItem> itemData;

    @VisibleForTesting
    public BankSave(
            BankWorldType worldType,
            String accountIdentifier,
            @Nullable String saveName,
            String dateTimeString,
            ImmutableList<BankItem> itemData) {
        id = ID_BASE + idIncrementer.incrementAndGet();
        this.worldType = worldType;
        this.accountIdentifier = accountIdentifier;
        this.saveName = saveName;
        this.dateTimeString = dateTimeString;
        this.itemData = itemData;
    }

    // TODO: when I create a proper data upgrader/transitioner thing, remove this and put relevant logic there
    public BankWorldType getWorldType() {
        return worldType == null ? BankWorldType.DEFAULT : worldType;
    }

    public static BankSave fromCurrentBank(
            BankWorldType worldType,
            String accountIdentifier,
            ItemContainer bank,
            ItemManager itemManager) {
        Objects.requireNonNull(accountIdentifier);
        Objects.requireNonNull(bank);
        net.runelite.api.Item[] contents = bank.getItems();
        ImmutableList.Builder<BankItem> itemData = ImmutableList.builder();

        for (net.runelite.api.Item item : contents) {
            int idInBank = item.getId();
            int canonId = itemManager.canonicalize(idInBank);
            if (idInBank != canonId) {
                // It's just a placeholder
                continue;
            } else if (isItemToClean(idInBank)) {
                continue;
            }

            itemData.add(new BankItem(canonId, item.getQuantity()));
        }
        String timeString = DATE_FORMATTER.format(ZonedDateTime.now());
        return new BankSave(worldType, accountIdentifier, null, timeString, itemData.build());
    }

    private static boolean isItemToClean(int itemId) {
        return itemId == NULL_ITEM_ID || itemId == ItemID.BANK_FILLER;
    }

    public static BankSave snapshotFromExistingBank(String newName, BankSave existingBank) {
        Objects.requireNonNull(newName);
        return new BankSave(
                existingBank.worldType,
                existingBank.accountIdentifier,
                newName,
                existingBank.dateTimeString,
                existingBank.itemData);
    }

    public static BankSave cleanItemData(BankSave existingBank) {
        Objects.requireNonNull(existingBank);

        ImmutableList<BankItem> cleanItemData = existingBank.itemData.stream()
                .filter(i -> !isItemToClean(i.getItemId()))
                .collect(ImmutableList.toImmutableList());

        return new BankSave(
                existingBank.worldType,
                existingBank.accountIdentifier,
                existingBank.saveName,
                existingBank.dateTimeString,
                cleanItemData);
    }

    public static BankSave withNewAccountId(String newAccountId, BankSave existingBank) {
        Objects.requireNonNull(newAccountId);
        return new BankSave(
                existingBank.worldType,
                newAccountId,
                existingBank.saveName,
                existingBank.dateTimeString,
                existingBank.itemData);
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("id", id)
                .add("accountIdentifier", SAFER_USERNAME.from(accountIdentifier))
                .add("dateTimeString", dateTimeString)
                .add("saveName", saveName)
                .add("itemData", itemData)
                .toString();
    }
}

package com.bankmemory.data;

import java.util.EnumSet;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.WorldType;

@AllArgsConstructor
@Getter
public enum BankWorldType {
    // NB: changing these name will break automatic JSON deserialisation of existing saves
    DEFAULT(""),
    LEAGUE("League"),
    TOURNAMENT("Tournament"),
    DEADMAN("DMM"),
    DEADMAN_TOURNAMENT("DMM Tournament");

    String displayString;

    public static BankWorldType forWorld(EnumSet<WorldType> worldTypes) {
        if (worldTypes.contains(WorldType.SEASONAL)) {
            return worldTypes.contains(WorldType.DEADMAN) ? BankWorldType.DEADMAN_TOURNAMENT : BankWorldType.LEAGUE;
        }
        if (worldTypes.contains(WorldType.TOURNAMENT_WORLD)) {
            return BankWorldType.TOURNAMENT;
        }
        if (worldTypes.contains(WorldType.DEADMAN)) {
            return BankWorldType.DEADMAN;
        }
        return BankWorldType.DEFAULT;
    }
}

package com.bankmemory.data;

import com.google.common.collect.ImmutableList;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

@Slf4j
class ConfigReaderWriter {
    private static final String PLUGIN_BASE_GROUP = "bankMemory";
    private static final String CURRENT_LIST_KEY = "currentList";
    private static final String SNAPSHOT_LIST_KEY = "snapshotList";
    private static final String NAME_MAP_KEY = "nameMap";

    private final Gson gson;
    private final ConfigManager configManager;

    private final BlockingQueue<ConfigWrite> configWritesQueue = new LinkedBlockingQueue<>();

    @Inject
    ConfigReaderWriter(Gson gson, ConfigManager configManager) {
        Type itemDataListType = new TypeToken<ImmutableList<BankItem>>() {}.getType();
        this.gson = gson.newBuilder().registerTypeAdapter(itemDataListType, new ItemDataParser()).create();
        this.configManager = configManager;

        Thread configWriter = new Thread(new ConfigWriter(), "Bank Memory config writer");
        configWriter.setDaemon(true);
        configWriter.start();
    }

    List<BankSave> readCurrentBanks() {
        Type deserialiseType = new TypeToken<List<BankSave>>() {}.getType();
        List<BankSave> fromDataStore = loadDataFromConfig(CURRENT_LIST_KEY, deserialiseType, new ArrayList<>(), "Current bank list");
        return upgradeBankSaves(fromDataStore);
    }

    private List<BankSave> upgradeBankSaves(List<BankSave> bankSaves) {
        return bankSaves.stream().map(BankSave::cleanItemData).collect(Collectors.toList());
    }

    void writeCurrentBanks(List<BankSave> banks) {
        ConfigWrite configWrite = new ConfigWrite(PLUGIN_BASE_GROUP, CURRENT_LIST_KEY, new ArrayList<>(banks));
        scheduleConfigWrite(configWrite);
    }

    List<BankSave> readBankSnapshots() {
        Type deserialiseType = new TypeToken<List<BankSave>>() {}.getType();
        List<BankSave> fromDataStore = loadDataFromConfig(SNAPSHOT_LIST_KEY, deserialiseType, new ArrayList<>(), "Snapshot bank list");
        return upgradeBankSaves(fromDataStore);
    }

    void writeBankSnapshots(List<BankSave> banks) {
        ConfigWrite configWrite = new ConfigWrite(PLUGIN_BASE_GROUP, SNAPSHOT_LIST_KEY, new ArrayList<>(banks));
        scheduleConfigWrite(configWrite);
    }

    Map<String, String> readNameMap() {
        Type deserialiseType = new TypeToken<HashMap<String, String>>() {}.getType();
        return loadDataFromConfig(NAME_MAP_KEY, deserialiseType, new HashMap<>(), "Display name map");
    }

    void writeNameMap(Map<String, String> map) {
        ConfigWrite write = new ConfigWrite(PLUGIN_BASE_GROUP, NAME_MAP_KEY, new HashMap<>(map));
        scheduleConfigWrite(write);
    }

    private <T> T loadDataFromConfig(String configKey, Type deserialiseType, T defaultInstance, String dataName) {
        String jsonString = configManager.getConfiguration(PLUGIN_BASE_GROUP, configKey);
        if (jsonString == null) {
            // Never set before
            return defaultInstance;
        }

        try {
            T loadedData = gson.fromJson(jsonString, deserialiseType);
            return loadedData == null ? defaultInstance : loadedData;
        } catch (JsonParseException ex) {
            log.error("{} json invalid. All is lost", dataName, ex);
            configManager.unsetConfiguration(PLUGIN_BASE_GROUP, configKey);
            return defaultInstance;
        }
    }

    private void scheduleConfigWrite(ConfigWrite configWrite) {
        try {
            log.debug("Scheduling write for {}.{}", configWrite.configGroup, configWrite.configKey);
            configWritesQueue.put(configWrite);
        } catch (InterruptedException ex) {
            log.error("Unexpected interrupt whilst schedule config write. Data not being written", ex);
        }
    }

    @AllArgsConstructor
    private static class ConfigWrite {
        final String configGroup;
        final String configKey;
        final Object data;
    }

    // NB: technically there's a race condition because it's possible that the client could shut down before the call
    // to the ConfigManager is made. However, us trying to react to a client shutdown by writing all the remaining
    // writes won't work since the ConfigManager is the first thing to react to a client shutdown and won't perform any
    // new writes once it has.
    // Not very likely to happen anyway since it basically requires user to do something in game (to trigger plugin) and
    // then super quickly (like <10ms) close the client.
    private class ConfigWriter implements Runnable {
        @Override
        public void run() {
            while (!Thread.interrupted()) {
                ConfigWrite write;
                try {
                    write = configWritesQueue.take();
                    log.debug("Got write for {}.{}", write.configGroup, write.configKey);
                } catch (InterruptedException ex) {
                    log.warn("ConfigWriter thread interrupted", ex);
                    break;
                }
                configManager.setConfiguration(write.configGroup, write.configKey, gson.toJson(write.data));
            }
        }
    }
}

package com.bankmemory.data;

public interface DataStoreUpdateListener {
    void currentBanksListChanged();

    void currentBanksListOrderChanged();

    void snapshotBanksListChanged();

    void displayNameMapUpdated();
}

package com.bankmemory.data;

import java.util.Map;
import java.util.TreeMap;

public class DisplayNameMapper {
    private static final SaferUsernameFunction SAFER_USERNAME = new SaferUsernameFunction();

    private final TreeMap<String, String> displayNamesByLogin = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);

    DisplayNameMapper(Map<String, String> map) {
        displayNamesByLogin.putAll(map);
    }

    public String map(String accountIdentifier) {
        String displayName = displayNamesByLogin.get(accountIdentifier);
        if (displayName != null) {
            return displayName;
        }
        return SAFER_USERNAME.from(accountIdentifier);
    }
}

package com.bankmemory.data;

import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

class ItemDataParser implements JsonSerializer<ImmutableList<BankItem>>, JsonDeserializer<ImmutableList<BankItem>> {

    private static final String PARSE_EXCEPTION_MESSAGE = "Item data section format invalid";

    @Override
    public JsonElement serialize(ImmutableList<BankItem> src, Type typeOfSrc, JsonSerializationContext context) {
        String saveString = toSaveString(src);
        return context.serialize(saveString);
    }

    String toSaveString(List<BankItem> items) {
        StringBuilder sb = new StringBuilder();
        for (BankItem item : items) {
            sb.append(item.getItemId()).append(",").append(item.getQuantity()).append(",");
        }
        return sb.toString();
    }

    @Override
    public ImmutableList<BankItem> deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
        String saveString = json.getAsString();
        return parseSaveString(saveString);
    }

    ImmutableList<BankItem> parseSaveString(String saveString) throws JsonParseException {
        if (Strings.isNullOrEmpty(saveString)) {
            return ImmutableList.of();
        }

        List<Integer> numbers = new ArrayList<>();
        for (String num : saveString.split(",")) {
            try {
                numbers.add(Integer.parseInt(num));
            } catch (NumberFormatException ex) {
                throw new JsonParseException(PARSE_EXCEPTION_MESSAGE, ex);
            }
        }

        if (!(numbers.size() % 2 == 0)) {
            throw new JsonParseException(PARSE_EXCEPTION_MESSAGE);
        }
        ImmutableList.Builder<BankItem> items = ImmutableList.builder();
        for (int i = 0; i < numbers.size(); i += 2) {
            items.add(new BankItem(numbers.get(i), numbers.get(i + 1)));
        }
        return items.build();
    }
}

package com.bankmemory.data;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Stream;

@Slf4j
@Singleton
public class PluginDataStore {

    private final Object dataLock = new Object();
    private final Map<String, String> nameMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
    private final List<BankSave> currentBankList;
    private final List<BankSave> snapshotBanksList;
    private final ConfigReaderWriter configReaderWriter;
    private final List<DataStoreUpdateListener> listeners = new ArrayList<>();

    @Inject
    @VisibleForTesting
    PluginDataStore(ConfigReaderWriter configReaderWriter) {
        this.configReaderWriter = configReaderWriter;
        currentBankList = this.configReaderWriter.readCurrentBanks();
        snapshotBanksList = this.configReaderWriter.readBankSnapshots();
        nameMap.putAll(this.configReaderWriter.readNameMap());
    }

    public void registerDisplayNameForAccountId(String accountIdentifier, String displayName) {
        List<DataStoreUpdateListener> listenersCopy;
        boolean nameMapChanged;
        boolean savesChanged = false;
        synchronized (dataLock) {
            listenersCopy = new ArrayList<>(listeners);
            Set<Map.Entry<String, String>> oldNameMapEntries = nameMap.entrySet();

            // Registering new display name for account ID
            String oldValue = nameMap.put(accountIdentifier, displayName);
            nameMapChanged = !Objects.equals(oldValue, displayName);
            if (nameMapChanged) {
                configReaderWriter.writeNameMap(nameMap);
            }

            // Claim existing bank saves for new style account ID if necessary
            if (nameMapChanged) {
                Optional<String> oldStyleIdRegisteredForDisplayName = oldNameMapEntries.stream()
                        .filter(e -> !e.getKey().startsWith(AccountIdentifier.ACCOUNT_HASH_ID_PREFIX))
                        .filter(e -> e.getValue().equals(displayName))
                        .findFirst()
                        .map(Map.Entry::getKey);
                if (oldStyleIdRegisteredForDisplayName.isPresent()) {
                    savesChanged = this.claimExistingSavesForNewAccountId(oldStyleIdRegisteredForDisplayName.get(), accountIdentifier);
                }
            }
        }
        if (nameMapChanged) {
            listenersCopy.forEach(DataStoreUpdateListener::displayNameMapUpdated);
        }
        if (savesChanged) {
            listenersCopy.forEach(DataStoreUpdateListener::currentBanksListChanged);
            listenersCopy.forEach(DataStoreUpdateListener::snapshotBanksListChanged);
        }
    }

    private boolean claimExistingSavesForNewAccountId(String oldAccountId, String newAccountId) {
        boolean currentBankSavesChanged = false;
        boolean snapshotBankSavesChanged = false;

        synchronized (dataLock) {
            for (int i = 0; i < this.currentBankList.size(); i++) {
                BankSave existingSave = this.currentBankList.get(i);
                if (existingSave.getAccountIdentifier().equals(oldAccountId)) {
                    BankSave reclaimedSave = BankSave.withNewAccountId(newAccountId, existingSave);
                    this.currentBankList.set(i, reclaimedSave);
                    currentBankSavesChanged = true;
                }
            }
            for (int i = 0; i < this.snapshotBanksList.size(); i++) {
                BankSave existingSave = this.snapshotBanksList.get(i);
                if (existingSave.getAccountIdentifier().equals(oldAccountId)) {
                    BankSave reclaimedSave = BankSave.withNewAccountId(newAccountId, existingSave);
                    this.snapshotBanksList.set(i, reclaimedSave);
                    snapshotBankSavesChanged = true;
                }
            }

            if (currentBankSavesChanged) {
                this.configReaderWriter.writeCurrentBanks(this.currentBankList);
            }
            if (snapshotBankSavesChanged) {
                this.configReaderWriter.writeBankSnapshots(this.snapshotBanksList);
            }
        }

        return currentBankSavesChanged || snapshotBankSavesChanged;
    }

    public DisplayNameMapper getDisplayNameMapper() {
        synchronized (dataLock) {
            return new DisplayNameMapper(nameMap);
        }
    }

    public void addListener(DataStoreUpdateListener listener) {
        synchronized (dataLock) {
            listeners.add(listener);
        }
    }

    public void removeListener(DataStoreUpdateListener listener) {
        synchronized (dataLock) {
            listeners.remove(listener);
        }
    }

    public Optional<BankSave> getDataForCurrentBank(BankWorldType worldType, String accountIdentifier) {
        if (Strings.isNullOrEmpty(accountIdentifier)) {
            return Optional.empty();
        }
        synchronized (dataLock) {
            return currentBankList.stream()
                    .filter(s -> s.getWorldType() == worldType && s.getAccountIdentifier().equalsIgnoreCase(accountIdentifier))
                    .findAny();
        }
    }

    public List<BankSave> getCurrentBanksList() {
        synchronized (dataLock) {
            return new ArrayList<>(currentBankList);
        }
    }

    public List<BankSave> getSnapshotBanksList() {
        synchronized (dataLock) {
            return new ArrayList<>(snapshotBanksList);
        }
    }

    public Optional<BankSave> getBankSaveWithId(long id) {
        synchronized (dataLock) {
            return Stream.concat(currentBankList.stream(), snapshotBanksList.stream())
                    .filter(s -> s.getId() == id)
                    .findFirst();
        }
    }

    public void currentBankViewed(long saveId) {
        List<DataStoreUpdateListener> listenersCopy;
        boolean changed = false;
        synchronized (dataLock) {
            listenersCopy = new ArrayList<>(listeners);

            Optional<BankSave> save = this.currentBankList.stream().filter(s -> s.getId() == saveId).findFirst();
            if (save.isPresent()) {
                BankSave foundSave = save.get();
                this.currentBankList.remove(foundSave);
                this.currentBankList.add(0, foundSave);
                configReaderWriter.writeCurrentBanks(currentBankList);
                changed = true;
            } else {
                log.error("Claimed to view current bank with id " + saveId + " which wasn't found in list");
            }
        }
        if (changed) {
            listenersCopy.forEach(DataStoreUpdateListener::currentBanksListOrderChanged);
        }
    }

    public void saveAsCurrentBank(BankSave newSave) {
        List<DataStoreUpdateListener> listenersCopy;
        synchronized (dataLock) {
            listenersCopy = new ArrayList<>(listeners);
            saveAsCurrentBankImpl(newSave);
        }
        listenersCopy.forEach(DataStoreUpdateListener::currentBanksListChanged);
    }

    private void saveAsCurrentBankImpl(BankSave newSave) {
        // Check if there is a current bank for existing login and remove it
        currentBankList.stream()
                .filter(s -> s.getAccountIdentifier().equalsIgnoreCase(newSave.getAccountIdentifier() )
                        && s.getWorldType() == newSave.getWorldType())
                .findAny()
                .ifPresent(currentBankList::remove);

        // Save new current bank at top of list
        currentBankList.add(0, newSave);
        configReaderWriter.writeCurrentBanks(currentBankList);
    }

    public void saveAsSnapshotBank(String newName, BankSave existingSave) {
        List<DataStoreUpdateListener> listenersCopy;
        synchronized (dataLock) {
            listenersCopy = new ArrayList<>(listeners);
            snapshotBanksList.add(0, BankSave.snapshotFromExistingBank(newName, existingSave));
            configReaderWriter.writeBankSnapshots(snapshotBanksList);
        }
        listenersCopy.forEach(DataStoreUpdateListener::snapshotBanksListChanged);
    }

    public void deleteBankSaveWithId(long saveId) {
        List<DataStoreUpdateListener> listenersCopy;
        boolean currentBanksChanged = false;
        boolean snapshotBanksChanged = false;
        synchronized (dataLock) {
            listenersCopy = new ArrayList<>(listeners);

            if (PluginDataStore.removeBankSaveWithIdFromList(saveId, currentBankList)) {
                configReaderWriter.writeCurrentBanks(currentBankList);
                currentBanksChanged = true;
            }
            if (PluginDataStore.removeBankSaveWithIdFromList(saveId, snapshotBanksList)) {
                configReaderWriter.writeBankSnapshots(snapshotBanksList);
                snapshotBanksChanged = true;
            }
        }
        if (currentBanksChanged) {
            listenersCopy.forEach(DataStoreUpdateListener::currentBanksListChanged);
        } else if (snapshotBanksChanged) {
            listenersCopy.forEach(DataStoreUpdateListener::snapshotBanksListChanged);
        } else {
            log.error("Tried deleting missing bank save: {}", saveId);
        }
    }

    private static boolean removeBankSaveWithIdFromList(long id, List<BankSave> saveList) {
        Optional<BankSave> save = saveList.stream()
                .filter(s -> s.getId() == id)
                .findFirst();
        if (save.isPresent()) {
            saveList.remove(save.get());
            return true;
        }
        return false;
    }
}

package com.bankmemory.data;

import com.google.common.base.Strings;

/**
 * Obscures the login name so other people don't know what it is (e.g. if the user has to share their logs, or if
 * they're a streamer), whilst leaving the first 3 characters (or less) visible so hopefully the user can still
 * understand things.
 */
class SaferUsernameFunction {
    String from(String username) {
        int start = Math.min(3, username.length() / 3);
        return username.substring(0, start) + Strings.repeat("-", username.length() - start);
    }
}

package com.bankmemory;

import com.bankmemory.bankview.ItemListEntry;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.font.LineMetrics;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import net.runelite.client.ui.FontManager;

/**
 * Special renderer needed for reasons:
 * - The icons returned by the item manager won't paint on "-1"s to the icons for some reason. It will do positive 1s
 *   and other negative numbers, but not -1.
 * - Actually paint '+' symbol with positive numbers.
 * - Green/red colouring of numbers!
 * - Display numbers left of item icon so a mix of icon colour/text colour isn't unreadable, and reduce overlapping.
 *   The UI doesn't give us much width though, so we're fine with some overlapping on long numbers.
 */
public class DiffItemListRenderer extends JLabel implements ListCellRenderer<ItemListEntry> {

    @Override
    public Component getListCellRendererComponent(JList<? extends ItemListEntry> list,
                                                  ItemListEntry value,
                                                  int index,
                                                  boolean isSelected,
                                                  boolean cellHasFocus) {
        setText(value.getItemName());
        setIcon(new IconWithQuantity(value.getImage(), value.getQuantity()));
        return this;
    }

    private static class IconWithQuantity extends ImageIcon {
        // A roughly worked out gap that seems fine
        private static final int LEFT_PAD = (int) (net.runelite.api.Constants.ITEM_SPRITE_WIDTH * 1.2);

        private final int quantity;

        public IconWithQuantity(Image image, int quantity) {
            super(image);
            this.quantity = quantity;
        }

        @Override
        public synchronized void paintIcon(Component c, Graphics g, int x, int y) {
            super.paintIcon(c, g, x + LEFT_PAD, y);

            String displayNum;
            Color numColour;
            if (quantity < 0) {
                numColour = Color.RED;
                displayNum = Integer.toString(quantity);
            } else {
                numColour = Color.GREEN;
                displayNum = "+" + quantity;
            }

            Graphics g2 = g.create();
            Font font = FontManager.getRunescapeFont();
            g2.setFont(font);
            LineMetrics lm = font.getLineMetrics(displayNum, g2.getFontMetrics().getFontRenderContext());
            int height = (int) Math.ceil(lm.getHeight());
            g2.setColor(Color.BLACK);
            g2.drawString(displayNum, 1, height + 1);
            g2.setColor(numColour);
            g2.drawString(displayNum, 0, height);
            g2.dispose();
        }

        @Override
        public int getIconWidth() {
            return super.getIconWidth() + LEFT_PAD;
        }
    }
}
package com.bankmemory;

import com.bankmemory.data.BankItem;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ItemListDiffGenerator {
    /**
     * Generates a list of differences between the two given item lists. The result list's items are in the order they
     * appear in the 'before' list, or if they don't appear in that then the order they're in in the 'after' list.
     */
    List<BankItem> findDifferencesBetween(List<BankItem> before, List<BankItem> after) {
        Map<Integer, Integer> beforeItems = new HashMap<>();
        Map<Integer, Integer> afterItems = new HashMap<>();
        after.forEach(i -> afterItems.put(i.getItemId(), i.getQuantity()));
        List<BankItem> results = new ArrayList<>();
        for (BankItem i : before) {
            beforeItems.put(i.getItemId(), i.getQuantity());
            int diff = afterItems.getOrDefault(i.getItemId(), 0) - i.getQuantity();
            if (diff != 0) {
                results.add(new BankItem(i.getItemId(), diff));
            }
        }
        for (BankItem i : after) {
            if (!beforeItems.containsKey(i.getItemId())) {
                results.add(i);
            }
        }
        return results;
    }
}

package com.bankmemory;

import com.bankmemory.bankview.ItemListEntry;
import com.bankmemory.data.BankItem;
import com.bankmemory.data.BankSave;
import com.bankmemory.data.DataStoreUpdateListener;
import com.bankmemory.data.DisplayNameMapper;
import com.bankmemory.data.PluginDataStore;
import com.bankmemory.util.ClipboardActions;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.ImageIcon;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

@Slf4j
public class SavedBanksPanelController {

    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private ItemManager itemManager;
    @Inject private PluginDataStore dataStore;

    private BankSavesTopPanel topPanel;
    private ImageIcon casketIcon;
    private ImageIcon notedCasketIcon;
    private final AtomicBoolean workingToOpenBank = new AtomicBoolean();
    private DataStoreListener dataStoreListener;
    @Nullable BankSave bankForClipboardAction;

    public void startUp(BankSavesTopPanel topPanel) {
        assert SwingUtilities.isEventDispatchThread();

        this.topPanel = topPanel;
        topPanel.setBanksListInteractionListener(new BanksListInteractionListenerImpl());
        casketIcon = new ImageIcon(itemManager.getImage(405));
        notedCasketIcon = new ImageIcon(itemManager.getImage(406));

        topPanel.displayBanksListPanel();
        updateCurrentBanksList();

        setPopupMenuActionOnBankView();

        dataStoreListener = new DataStoreListener();
        dataStore.addListener(dataStoreListener);
    }

    // Gets called on EDT and on game client thread
    private void updateCurrentBanksList() {
        List<BanksListEntry> saves = new ArrayList<>();
        DisplayNameMapper nameMapper = dataStore.getDisplayNameMapper();

        for (BankSave save : dataStore.getCurrentBanksList()) {
            String displayName = nameMapper.map(save.getAccountIdentifier());
            saves.add(new BanksListEntry(
                    save.getId(), casketIcon, save.getWorldType(), "Current bank", displayName, save.getDateTimeString()));
        }
        for (BankSave save : dataStore.getSnapshotBanksList()) {
            String displayName = nameMapper.map(save.getAccountIdentifier());
            saves.add(new BanksListEntry(
                    save.getId(), notedCasketIcon, save.getWorldType(), save.getSaveName(), displayName, save.getDateTimeString()));
        }

        Runnable updateList = () -> topPanel.updateBanksList(saves);
        if (SwingUtilities.isEventDispatchThread()) {
            updateList.run();
        } else {
            SwingUtilities.invokeLater(updateList);
        }
    }

    private void setPopupMenuActionOnBankView() {
        topPanel.getBankViewPanel().setItemListPopupMenuAction(new CopyItemsToClipboardAction(clientThread, itemManager) {
            @Nullable
            @Override
            public BankSave getBankItemData() {
                if (bankForClipboardAction == null) {
                    log.error("Tried to copy CSV data to clipboard before any bank save has been opened");
                }
                return bankForClipboardAction;
            }
        });
    }

    private void openSavedBank(BanksListEntry selected) {
        assert client.isClientThread();

        Optional<BankSave> save = dataStore.getBankSaveWithId(selected.getSaveId());
        if (!save.isPresent()) {
            log.error("Selected missing bank save: {}", selected);
            workingToOpenBank.set(false);
            return;
        }
        BankSave foundSave = save.get();

        List<ItemListEntry> items = new ArrayList<>();

        for (BankItem i : foundSave.getItemData()) {
            ItemComposition ic = itemManager.getItemComposition(i.getItemId());
            AsyncBufferedImage icon = itemManager.getImage(i.getItemId(), i.getQuantity(), i.getQuantity() > 1);
            int geValue = itemManager.getItemPrice(i.getItemId()) * i.getQuantity();
            int haValue = ic.getHaPrice() * i.getQuantity();
            items.add(new ItemListEntry(ic.getName(), i.getQuantity(), icon, geValue, haValue));
        }
        SwingUtilities.invokeLater(() -> {
            workingToOpenBank.set(false);
            bankForClipboardAction = foundSave;
            topPanel.displaySavedBankData(selected.getSaveName(), items, foundSave.getDateTimeString());
        });
    }

    public void shutDown() {
        dataStore.removeListener(dataStoreListener);
    }

    private class BanksListInteractionListenerImpl implements BanksListInteractionListener {
        @Override
        public void selectedToOpen(BanksListEntry save) {
            if (workingToOpenBank.get()) {
                return;
            }
            workingToOpenBank.set(true);
            clientThread.invokeLater(() -> openSavedBank(save));
        }

        @Override
        public void selectedToDelete(BanksListEntry save) {
            dataStore.deleteBankSaveWithId(save.getSaveId());
        }

        @Override
        public void saveBankAs(BanksListEntry save, String saveName) {
            Optional<BankSave> existingSave = dataStore.getBankSaveWithId(save.getSaveId());
            if (existingSave.isPresent()) {
                dataStore.saveAsSnapshotBank(saveName, existingSave.get());
            } else {
                log.error("Tried to 'Save As' missing bank save: {}", save);
            }
        }

        @Override
        public void copyBankSaveItemDataToClipboard(BanksListEntry save) {
            Optional<BankSave> existingSave = dataStore.getBankSaveWithId(save.getSaveId());
            if (existingSave.isPresent()) {
                ClipboardActions.copyItemDataAsTsvToClipboardOnClientThread(clientThread, itemManager, existingSave.get().getItemData());
            } else {
                log.error("Tried to copy CSV data to clipboard for missing bank save: {}", save);
            }
        }

        @Override
        public void openBanksDiffPanel() {
            topPanel.showBankDiffPanel();
        }
    }

    private class DataStoreListener implements DataStoreUpdateListener {
        @Override
        public void currentBanksListChanged() {
            updateCurrentBanksList();
        }

        @Override
        public void currentBanksListOrderChanged() {
            updateCurrentBanksList();
        }

        @Override
        public void snapshotBanksListChanged() {
            updateCurrentBanksList();
        }

        @Override
        public void displayNameMapUpdated() {
            updateCurrentBanksList();
        }
    }
}

package com.bankmemory.util;

import com.bankmemory.data.BankItem;
import java.awt.Toolkit;
import java.awt.datatransfer.StringSelection;
import java.util.List;
import java.util.Objects;
import javax.swing.SwingUtilities;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;

public class ClipboardActions {
    private ClipboardActions() {}

    public static void copyItemDataAsTsvToClipboardOnClientThread(ClientThread clientThread, ItemManager itemManager, List<BankItem> itemData) {
        Objects.requireNonNull(clientThread);
        Objects.requireNonNull(itemManager);
        Objects.requireNonNull(itemData);
        assert SwingUtilities.isEventDispatchThread();

        clientThread.invokeLater(() -> {
            StringBuilder sb = new StringBuilder();

            sb.append("Item id\tItem name\tItem quantity").append(System.lineSeparator());

            itemData.forEach(i -> sb
                    .append(i.getItemId()).append('\t')
                    .append(itemManager.getItemComposition(i.getItemId()).getName()).append('\t')
                    .append(i.getQuantity()).append(System.lineSeparator()));

            StringSelection stringSelection = new StringSelection(sb.toString());

            // Bad to pass in the StringSelection as the ClipboardOwner?
            // Idk, maybe! But its implementation of that interface is NOOP and that's good with me
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(stringSelection, stringSelection);
        });
    }
}

package com.bankmemory.util;

public class Constants {
    public static final String BANK_MEMORY = "Bank Memory";
    public static final int PAD = 8;

    public static final String ACTION_COPY_ITEM_DATA_TO_CLIPBOARD= "Copy item data to clipboard";
}

package com.bankmemory.util;

import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

public abstract class OnAnyChangeDocumentListener implements DocumentListener {
    @Override
    public void insertUpdate(DocumentEvent e) {
        onChange(e);
    }

    @Override
    public void removeUpdate(DocumentEvent e) {
        onChange(e);
    }

    @Override
    public void changedUpdate(DocumentEvent e) {
        onChange(e);
    }

    public abstract void onChange(DocumentEvent e);
}

package com.bankmemory;

import com.bankmemory.data.PluginDataStore;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import javax.swing.SwingUtilities;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;


import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class BankMemoryPluginTest {
    @Mock @Bind private ClientToolbar clientToolbar;
    @Mock @Bind private Client client;
    @Mock @Bind private ClientThread clientThread;
    @Mock @Bind private ItemManager itemManager;
    @Mock @Bind private PluginDataStore pluginDataStore;
    @Mock @Bind private BankMemoryConfig bankMemoryConfig;
    @Mock @Bind private OverlayManager overlayManager;
    @Mock private CurrentBankPanelController currentBankPanelController;
    @Mock private SavedBanksPanelController savedBanksPanelController;
    @Mock private BankDiffPanelController bankDiffPanelController;
    @Mock private BankMemoryPluginPanel pluginPanel;
    @Mock private Injector pluginInjector;

    @Inject private TestBankMemoryPlugin bankMemoryPlugin;

    @Before
    public void before() {
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
        bankMemoryPlugin.setInjector(pluginInjector);
        when(pluginInjector.getInstance(BankMemoryPluginPanel.class)).thenReturn(pluginPanel);
        when(pluginInjector.getInstance(CurrentBankPanelController.class)).thenReturn(currentBankPanelController);
        when(pluginInjector.getInstance(SavedBanksPanelController.class)).thenReturn(savedBanksPanelController);
        when(pluginInjector.getInstance(BankDiffPanelController.class)).thenReturn(bankDiffPanelController);
        when(pluginPanel.getSavedBanksTopPanel()).thenReturn(mock(BankSavesTopPanel.class));
    }

    @Test
    public void testStartup_startsCurrentBankControllerOnClientThread() throws Exception {
        ArgumentCaptor<Runnable> ac = ArgumentCaptor.forClass(Runnable.class);

        SwingUtilities.invokeAndWait(noCatch(bankMemoryPlugin::startUp));

        verify(clientThread).invokeLater(ac.capture());
        verify(currentBankPanelController, never()).startUp(any());
        ac.getValue().run();
        verify(currentBankPanelController).startUp(pluginPanel.getCurrentBankViewPanel());
    }

    private static Runnable noCatch(ThrowingRunnable throwingRunnable) {
        return () -> {
            try {
                throwingRunnable.run();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }

    private static class TestBankMemoryPlugin extends BankMemoryPlugin {
        void setInjector(Injector injector) {
            this.injector = injector;
        }
    }

    private interface ThrowingRunnable {
        void run() throws Exception;
    }
}
package com.bankmemory.bankview;

import com.google.common.collect.Lists;
import java.awt.image.BufferedImage;
import java.util.List;
import javax.swing.event.ListDataListener;
import com.google.inject.testing.fieldbinder.*;
import net.runelite.client.callback.*;
import net.runelite.client.util.AsyncBufferedImage;
import org.junit.Test;
import org.mockito.*;


import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.verifyNoMoreInteractions;

public class FilterableItemListModelTest {

    private static final ItemListEntry dragonScimitar = item("Dragon Scimitar");
    private static final ItemListEntry runeAxe = item("Rune axe");
    private static final ItemListEntry runeDagger = item("Rune dagger");
    private static final ItemListEntry magicStaff = item("Magic staff");
    private static final ItemListEntry airRune = item("Air rune");

    private static final ItemListEntry dragonstone = item("Dragonstone");
    private static final ItemListEntry amuletOfGlory = item("Amulet of Glory");
    private static final ItemListEntry antiDragonShield = item("Anti-dragon shield");
    private static final ItemListEntry petKitten = item("Pet kitten");

    @Mock
    @Bind
    private static ClientThread clientThread;

    @Test
    public void testGetElementAt_givenNoFilter() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));

        assertThat(model.getSize(), is(5));
        assertThat(model.getElementAt(0), is(dragonScimitar));
        assertThat(model.getElementAt(1), is(runeAxe));
        assertThat(model.getElementAt(2), is(runeDagger));
        assertThat(model.getElementAt(3), is(magicStaff));
        assertThat(model.getElementAt(4), is(airRune));

        model.setListContents(list(dragonstone, amuletOfGlory, antiDragonShield, petKitten));

        assertThat(model.getSize(), is(4));
        assertThat(model.getElementAt(0), is(dragonstone));
        assertThat(model.getElementAt(1), is(amuletOfGlory));
        assertThat(model.getElementAt(2), is(antiDragonShield));
        assertThat(model.getElementAt(3), is(petKitten));
    }

    @Test
    public void testGetElementAt_givenFilterApplied() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));
        model.applyFilter("RuNe");

        assertThat(model.getSize(), is(3));
        assertThat(model.getElementAt(0), is(runeAxe));
        assertThat(model.getElementAt(1), is(runeDagger));
        assertThat(model.getElementAt(2), is(airRune));
    }

    @Test
    public void testGetElementAt_givenFilterRemoved() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));
        model.applyFilter("rUnE");

        assertThat(model.getSize(), is(3));
        assertThat(model.getElementAt(0), is(runeAxe));
        assertThat(model.getElementAt(1), is(runeDagger));
        assertThat(model.getElementAt(2), is(airRune));

        model.applyFilter("");

        assertThat(model.getSize(), is(5));
        assertThat(model.getElementAt(0), is(dragonScimitar));
        assertThat(model.getElementAt(1), is(runeAxe));
        assertThat(model.getElementAt(2), is(runeDagger));
        assertThat(model.getElementAt(3), is(magicStaff));
        assertThat(model.getElementAt(4), is(airRune));
    }

    @Test
    public void testGetElementAt_givenFilterAppliedAndNewContentsSet() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));
        model.applyFilter("dRaGOn");

        assertThat(model.getSize(), is(1));
        assertThat(model.getElementAt(0), is(dragonScimitar));

        model.setListContents(list(dragonstone, amuletOfGlory, antiDragonShield, petKitten));

        assertThat(model.getSize(), is(2));
        assertThat(model.getElementAt(0), is(dragonstone));
        assertThat(model.getElementAt(1), is(antiDragonShield));
    }

    @Test
    public void testGetAdjustedIndex() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));
        assertThat(model.getSize(), is(5));
        assertThat(model.getAdjustedIndex(0), is(0));
        assertThat(model.getAdjustedIndex(1), is(1));
        assertThat(model.getAdjustedIndex(2), is(2));
        assertThat(model.getAdjustedIndex(3), is(3));
        assertThat(model.getAdjustedIndex(4), is(4));

        model.applyFilter("RuNe");

        assertThat(model.getSize(), is(3));
        assertThat(model.getAdjustedIndex(0), is(-1));
        assertThat(model.getAdjustedIndex(1), is(0));
        assertThat(model.getAdjustedIndex(2), is(1));
        assertThat(model.getAdjustedIndex(3), is(-1));
        assertThat(model.getAdjustedIndex(4), is(2));

        model.applyFilter("Karil's crossbow"); // Which, of course, my BTW doesn't have

        assertThat(model.getSize(), is(0));
        assertThat(model.getAdjustedIndex(0), is(-1));
        assertThat(model.getAdjustedIndex(1), is(-1));
        assertThat(model.getAdjustedIndex(2), is(-1));
        assertThat(model.getAdjustedIndex(3), is(-1));
        assertThat(model.getAdjustedIndex(4), is(-1));
    }

    @Test
    public void testGetAdjustedIndex_givenIndexBelowZero() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));

        try {
            model.getAdjustedIndex(-1);
            fail();
        } catch (IndexOutOfBoundsException ex) {
            assertThat(ex.getMessage(), is("index (-1) must not be negative"));
        }
    }

    @Test
    public void testGetAdjustedIndex_givenIndexAboveRawContentsMaxIndex() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));

        try {
            model.getAdjustedIndex(100000);
            fail();
        } catch (IndexOutOfBoundsException ex) {
            assertThat(ex.getMessage(), is("index (100000) must be less than size (5)"));
        }
    }

    @Test
    public void testSetListContents_notifiesOffListeners() {
        FilterableItemListModel model = new FilterableItemListModel();
        ListDataListener listener1 = mock(ListDataListener.class);
        ListDataListener listener2 = mock(ListDataListener.class);
        model.addListDataListener(listener1);
        model.addListDataListener(listener2);

        verifyNoInteractions(listener1, listener2);

        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));

        verify(listener1).contentsChanged(any());
        verify(listener2).contentsChanged(any());
        verifyNoMoreInteractions(listener1, listener2);
    }

    @Test
    public void testApplyFilter_notifiesListenersOnlyIfEffectIsDifferent() {
        FilterableItemListModel model = new FilterableItemListModel();
        model.setListContents(list(dragonScimitar, runeAxe, runeDagger, magicStaff, airRune));
        ListDataListener listener1 = mock(ListDataListener.class);
        ListDataListener listener2 = mock(ListDataListener.class);
        model.addListDataListener(listener1);
        model.addListDataListener(listener2);

        verifyNoInteractions(listener1, listener2);

        model.applyFilter("");

        verifyNoInteractions(listener1, listener2);

        model.applyFilter("RUN");

        verify(listener1).contentsChanged(any());
        verify(listener2).contentsChanged(any());

        model.applyFilter("ruNE");

        verifyNoMoreInteractions(listener1, listener2);
    }

    private static ItemListEntry item(String name) {
        return new ItemListEntry(name, 1, new AsyncBufferedImage(clientThread, 1, 1, BufferedImage.TYPE_INT_ARGB), 1, 1);
    }

    private static List<ItemListEntry> list(ItemListEntry... items) {
        return Lists.newArrayList(items);
    }
}
package com.bankmemory.bankview;

import junit.framework.TestCase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

@RunWith(Parameterized.class)
public class ValueFormatterTest extends TestCase {

    @Parameter(0) public long value;
    @Parameter(1) public String formatted;
    @Parameter(2) public String formattedAbbreviated;

    @Parameters
    public static Object[][] parameterData() {
        return new Object[][]{
                {1, "1", "1"},
                {9999, "9,999", "9,999"},
                {10000, "10,000", "10K"},
                {10001, "10,001", "10K"},
                {10101, "10,101", "10.1K"},
                {123000, "123,000", "123K"},
                {999999, "999,999", "999.99K"},
                {1000001, "1,000,001", "1M"},
                {1020000, "1,020,000", "1.02M"},
                {999999999, "999,999,999", "999.99M"},
                {808019000000L, "808,019,000,000", "808.01B"}
        };
    }

    @Test
    public void testFormat() {
        ValueFormatter formatter = new ValueFormatter();

        assertEquals(formatted, formatter.format(value));

        assertEquals("-" + formatted, formatter.format(-value));

        formatter.setShowPositiveSign(true);

        assertEquals("+" + formatted, formatter.format(value));
    }

    @Test
    public void testFormatAbbreviated() {
        ValueFormatter formatter = new ValueFormatter();

        assertEquals(formattedAbbreviated, formatter.formatAbbreviated(value));

        assertEquals("-" + formattedAbbreviated, formatter.formatAbbreviated(-value));

        formatter.setShowPositiveSign(true);

        assertEquals("+" + formattedAbbreviated, formatter.formatAbbreviated(value));
    }
}

package com.bankmemory;

import com.bankmemory.bankview.BankViewPanel;
import com.bankmemory.bankview.ItemListEntry;
import com.bankmemory.data.AccountIdentifier;
import com.bankmemory.data.BankItem;
import com.bankmemory.data.BankSave;
import com.bankmemory.data.BankWorldType;
import com.bankmemory.data.DataStoreUpdateListener;
import com.bankmemory.data.PluginDataStore;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.inject.Guice;
import com.google.inject.Inject;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import java.util.EnumSet;
import java.util.List;
import java.util.Optional;
import javax.swing.SwingUtilities;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ItemComposition;
import net.runelite.api.WorldType;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;


import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class CurrentBankPanelControllerTest {
    @Mock @Bind private Client client;
    @Mock @Bind private ItemManager itemManager;
    @Mock @Bind private PluginDataStore dataStore;
    @Mock private BankViewPanel panel;

    @Inject private CurrentBankPanelController currentBankPanelController;

    @Captor private ArgumentCaptor<DataStoreUpdateListener> dataStoreUpdateListenerArgumentCaptor;

    @Mock private AsyncBufferedImage coinsIcon;
    @Mock private AsyncBufferedImage burntLobsterIcon;

    @Before
    public void before() {
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
        when(client.isClientThread()).thenReturn(true);
        when(client.getWorldType()).thenReturn(EnumSet.of(WorldType.MEMBERS));
        ItemComposition coins = mockItemComposition("Coins", 1);
        ItemComposition burntLobster = mockItemComposition("Burnt lobster", 10);
        when(itemManager.getItemComposition(0)).thenReturn(coins);
        when(itemManager.getItemComposition(2)).thenReturn(burntLobster);
        when(itemManager.getImage(eq(0), anyInt(), anyBoolean())).thenReturn(coinsIcon);
        when(itemManager.getImage(eq(2), anyInt(), anyBoolean())).thenReturn(burntLobsterIcon);
        when(itemManager.getItemPrice(0)).thenReturn(1);
        when(itemManager.getItemPrice(2)).thenReturn(100);
    }

    @Test
    public void testStartup_ifNotLoggedIn_displayNoData() throws Exception {
        when(client.getGameState()).thenReturn(GameState.LOGIN_SCREEN);

        currentBankPanelController.startUp(panel);

        waitForEdtQueueToEmpty();
        verify(panel).displayNoDataMessage();
    }

    @Test
    public void testStartup_ifLoggedInButNoDataForAccount_displayNoData() throws Exception {
        String newStyleAccountId = AccountIdentifier.fromAccountHash(1337);
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getAccountHash()).thenReturn(1337L);
        when(dataStore.getDataForCurrentBank(BankWorldType.DEFAULT, newStyleAccountId)).thenReturn(Optional.empty());

        currentBankPanelController.startUp(panel);

        waitForEdtQueueToEmpty();
        verify(panel).displayNoDataMessage();
    }

    @Test
    public void testStartup_ifLoggedInAndDataAvailable_displayAccountData() throws Exception {
        String newStyleAccountId = AccountIdentifier.fromAccountHash(1337);
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getAccountHash()).thenReturn(1337L);
        when(dataStore.getDataForCurrentBank(BankWorldType.DEFAULT, newStyleAccountId)).thenReturn(Optional.of(
                new BankSave(BankWorldType.DEFAULT, newStyleAccountId, "My Bank", "Tuesday",
                        ImmutableList.of(new BankItem(0, 100), new BankItem(2, 666)))));

        currentBankPanelController.startUp(panel);

        waitForEdtQueueToEmpty();
        verify(panel).updateTimeDisplay("Tuesday");
        verify(panel).displayItemListings(eq(list(
                new ItemListEntry("Coins", 100, coinsIcon, 100, 100),
                new ItemListEntry("Burnt lobster", 666, burntLobsterIcon, 66600, 6660))),
                eq(true));
    }

    @Test
    public void testDataStoreUpdateListener_whenCurrentBankListChanges_ifItemDataHasNotChangedThenOnlyUpdateTime() throws Exception {
        String newStyleAccountId = AccountIdentifier.fromAccountHash(1337);
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getAccountHash()).thenReturn(1337L);
        BankSave mondaySave = new BankSave(BankWorldType.DEFAULT, newStyleAccountId, "My Bank", "Monday",
                ImmutableList.of(new BankItem(0, 100), new BankItem(2, 666)));
        BankSave tuesdaySave = new BankSave(BankWorldType.DEFAULT, newStyleAccountId, "My Bank", "Tuesday", mondaySave.getItemData());
        currentBankPanelController.startUp(panel);

        verify(panel, never()).updateTimeDisplay(any());
        verify(panel, never()).displayItemListings(any(), anyBoolean());
        verify(dataStore).addListener(dataStoreUpdateListenerArgumentCaptor.capture());

        DataStoreUpdateListener listener = dataStoreUpdateListenerArgumentCaptor.getValue();
        when(dataStore.getDataForCurrentBank(BankWorldType.DEFAULT, newStyleAccountId)).thenReturn(Optional.of(mondaySave));
        listener.currentBanksListChanged();

        waitForEdtQueueToEmpty();
        verify(panel).updateTimeDisplay("Monday");
        verify(panel, times(1)).displayItemListings(eq(list(
                new ItemListEntry("Coins", 100, coinsIcon, 100, 100),
                new ItemListEntry("Burnt lobster", 666, burntLobsterIcon, 66600, 6660))),
                eq(true));

        when(dataStore.getDataForCurrentBank(BankWorldType.DEFAULT, newStyleAccountId)).thenReturn(Optional.of(tuesdaySave));
        listener.currentBanksListChanged();

        waitForEdtQueueToEmpty();
        verify(panel).updateTimeDisplay("Tuesday");
        verify(panel, times(1)).displayItemListings(any(), anyBoolean());
    }

    private static ItemComposition mockItemComposition(String name, int haValue) {
        ItemComposition item = mock(ItemComposition.class);
        when(item.getName()).thenReturn(name);
        when(item.getHaPrice()).thenReturn(haValue);
        return item;
    }

    private static void waitForEdtQueueToEmpty() throws Exception {
        SwingUtilities.invokeAndWait(() -> { /* Do nothing */ });
    }

    private static List<ItemListEntry> list(ItemListEntry... items) {
        return Lists.newArrayList(items);
    }
}
package com.bankmemory.data;

import com.google.common.collect.ImmutableList;
import com.google.gson.JsonParseException;
import java.util.ArrayList;
import java.util.List;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;


import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.fail;

@RunWith(Parameterized.class)
public class ItemDataParserTest {
    @Parameter
    public String invalidSaveString;

    @Parameters
    public static Object[][] invalidData() {
        String tooFewNumbers = "301,";
        String extraNumber = "10,10,5,5,666,";
        String nonNumericCharacters = "10,10,spade,5,";
        return new Object[][] {
                { tooFewNumbers },
                { extraNumber },
                { nonNumericCharacters },
        };
    }

    @Test
    public void testParseSaveString_givenInvalidData() {
        ItemDataParser parser = new ItemDataParser();

        try {
            parser.parseSaveString(invalidSaveString);
            fail();
        } catch (JsonParseException ex) {
            // Good!
        }
    }

    @Test
    public void testParseSaveStringAndToSaveStringMethods_givenNullString() {
        ItemDataParser parser = new ItemDataParser();

        assertThat(parser.parseSaveString(null), is(new ArrayList<>()));
    }

    @Test
    public void testParseSaveStringAndToSaveStringMethods_givenEmptyBank() {
        String emptyBankSaveString = "";
        assertEqualsAllWays(emptyBankSaveString, new ArrayList<>());
    }

    @Test
    public void testParseSaveStringAndToSaveStringMethods_givenBankWithItems() {
        String nonEmptyBankSaveString = "301,1,302,10,303,5,304,3,";
        List<BankItem> bankItems = ImmutableList.of(
                new BankItem(301, 1), new BankItem(302, 10), new BankItem(303, 5), new BankItem(304, 3));
        assertEqualsAllWays(nonEmptyBankSaveString, bankItems);
    }

    private void assertEqualsAllWays(String saveString, List<BankItem> bankItemList) {
        ItemDataParser parser = new ItemDataParser();

        assertThat(parser.parseSaveString(saveString), is(bankItemList));
        assertThat(parser.toSaveString(bankItemList), is(saveString));
        assertThat(parser.toSaveString(parser.parseSaveString(saveString)), is(saveString));
        assertThat(parser.parseSaveString(parser.toSaveString(bankItemList)), is(bankItemList));
    }
}
package com.bankmemory.data;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.Bind;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class PluginDataStoreTest {

    @Mock @Bind private ConfigReaderWriter configReaderWriter;

    @Mock private DataStoreUpdateListener listener;

    @Captor ArgumentCaptor<List<BankSave>> bankSaveListCaptor;

    @Before
    public void before() {
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);

        when(configReaderWriter.readCurrentBanks()).thenReturn(new ArrayList<>());
        when(configReaderWriter.readBankSnapshots()).thenReturn(new ArrayList<>());
        when(configReaderWriter.readNameMap()).thenReturn(new HashMap<>());
    }

    @Test
    public void testRegisterDisplayNameForAccountId_ifAccountIdIsNew_savesNewNameMapAndCallsListeners() {
        String accountId = AccountIdentifier.ACCOUNT_HASH_ID_PREFIX + "123";
        PluginDataStore pluginDataStore = createPluginDataStore();

        pluginDataStore.registerDisplayNameForAccountId(accountId, "CoolUsername");

        verify(configReaderWriter).writeNameMap(Map.of(accountId, "CoolUsername"));
        verify(listener).displayNameMapUpdated();
        verifyNoMoreInteractions(listener);
    }

    @Test
    public void testRegisterDisplayNameForAccountId_ifUsernameRegisteredForAccountIdAlready_doesNothing() {
        String accountId = AccountIdentifier.ACCOUNT_HASH_ID_PREFIX + "123";
        when(configReaderWriter.readNameMap()).thenReturn(Map.of(accountId, "CoolUsername"));
        PluginDataStore pluginDataStore = createPluginDataStore();

        pluginDataStore.registerDisplayNameForAccountId(accountId, "CoolUsername");

        verify(configReaderWriter, never()).writeNameMap(any());
        verifyNoInteractions(listener);
    }

    @Test
    public void testRegisterDisplayNameForAccountId_ifGivenUsernameIsDifferentToRegisteredOne_savesNewNameMapAndCallsListeners() {
        String accountId = AccountIdentifier.ACCOUNT_HASH_ID_PREFIX + "123";
        when(configReaderWriter.readNameMap()).thenReturn(Map.of(accountId, "OldUsername"));
        PluginDataStore pluginDataStore = createPluginDataStore();

        pluginDataStore.registerDisplayNameForAccountId(accountId, "NewUsername");

        verify(configReaderWriter).writeNameMap(Map.of(accountId, "NewUsername"));
        verify(listener).displayNameMapUpdated();
        verifyNoMoreInteractions(listener);
    }

    @Test
    public void testRegisterDisplayNameForLogin_ifRegisteringUsernameWithNewAccountIdentifierWhenOldStyleIdentifierIsRegistered_updateNameMapAndBankSavesAndCallsListeners() {
        String oldStyleAccountId = "mylogin@whatever.com";
        String newStyleAccountId = AccountIdentifier.fromAccountHash(123);
        String sameUsername = "SameUsername";
        String anotherOldStyleAccountId = "another.old.id@x.com";
        BankSave existingSave1 = new BankSave(BankWorldType.DEFAULT, oldStyleAccountId, null, "111", ImmutableList.of());
        BankSave existingSave2 = new BankSave(BankWorldType.DEFAULT, anotherOldStyleAccountId, null, "222", ImmutableList.of());
        when(configReaderWriter.readNameMap()).thenReturn(Map.of(oldStyleAccountId, "SameUsername", anotherOldStyleAccountId, "DifferentUsername"));
        when(configReaderWriter.readCurrentBanks()).thenReturn(list(existingSave1, existingSave2));
        PluginDataStore pluginDataStore = createPluginDataStore();

        pluginDataStore.registerDisplayNameForAccountId(newStyleAccountId, sameUsername);

        BankSave expectedModifiedSave = BankSave.withNewAccountId(newStyleAccountId, existingSave1);
        verify(configReaderWriter).writeNameMap(Map.of(oldStyleAccountId, sameUsername, anotherOldStyleAccountId, "DifferentUsername", newStyleAccountId, sameUsername));
        verify(configReaderWriter).writeCurrentBanks(bankSaveListCaptor.capture());
        List<BankSave> savedCurrentBankList = bankSaveListCaptor.getValue();
        assertThat(savedCurrentBankList.size(), is(2));
        assertThatBankSavesAreEqualExceptForSaveId(savedCurrentBankList.get(0), expectedModifiedSave);
        assertThat(savedCurrentBankList.get(1), is(existingSave2));

        verify(listener).displayNameMapUpdated();
        verify(listener).currentBanksListChanged();
        verify(listener).snapshotBanksListChanged();
    }

    @Test
    public void testRegisterDisplayNameForLogin_ifExistingSavesAreForExistingNewStyleAccountId_doesNotChangeSaves() {
        String newStyleAccountId = AccountIdentifier.fromAccountHash(123);
        String sameUsername = "SameUsername";
        BankSave existingSave1 = new BankSave(BankWorldType.DEFAULT, newStyleAccountId, null, "111", ImmutableList.of());
        BankSave existingSave2 = new BankSave(BankWorldType.DEFAULT, newStyleAccountId, null, "222", ImmutableList.of());
        when(configReaderWriter.readNameMap()).thenReturn(Map.of(newStyleAccountId, "SameUsername"));
        when(configReaderWriter.readCurrentBanks()).thenReturn(list(existingSave1, existingSave2));
        PluginDataStore pluginDataStore = createPluginDataStore();

        pluginDataStore.registerDisplayNameForAccountId(newStyleAccountId, sameUsername);

        verify(configReaderWriter, never()).writeNameMap(any());
        verify(configReaderWriter, never()).writeCurrentBanks(any());
        verify(configReaderWriter, never()).writeBankSnapshots(any());
        verifyNoInteractions(listener);
    }

    private PluginDataStore createPluginDataStore() {
        PluginDataStore pluginDataStore = new PluginDataStore(configReaderWriter);
        pluginDataStore.addListener(listener);
        return pluginDataStore;
    }

    private static List<BankSave> list(BankSave... bankSaves) {
        return Lists.newArrayList(bankSaves);
    }

    private static void assertThatBankSavesAreEqualExceptForSaveId(BankSave given, BankSave expected) {
        assertThat(given.getAccountIdentifier(), is(expected.getAccountIdentifier()));
        assertThat(given.getSaveName(), is(expected.getSaveName()));
        assertThat(given.getItemData(), is(expected.getItemData()));
        assertThat(given.getDateTimeString(), is(expected.getDateTimeString()));
        assertThat(given.getWorldType(), is(expected.getWorldType()));
    }
}
package com.bankmemory;

import com.bankmemory.data.BankItem;
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.List;
import junit.framework.TestCase;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;


import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.MatcherAssert.assertThat;

@RunWith(Parameterized.class)
public class ItemListDiffGeneratorTest extends TestCase {
    @Parameter(0)
    public List<BankItem> beforeItems;
    @Parameter(1)
    public List<BankItem> afterItems;
    @Parameter(2)
    public List<BankItem> expectedResult;

    @Parameters
    public static Object[][] data() {
        List<BankItem> empty = new ArrayList<>();
        List<BankItem> data = Lists.newArrayList(
                i(1, 5), i(7, 2), i(3, 20), i(10, 10000), i(66, 4));
        List<BankItem> sameDataDifferentOrder = Lists.newArrayList(
                i(10, 10000), i(66, 4), i(7, 2), i(3, 20), i(1, 5));
        List<BankItem> different = Lists.newArrayList(
                i(1, 6), i(22, 67), i(7, 1), i(10, 5000), i(4, 66));
        return new Object[][] {
                { empty, empty, empty },
                { data, data, empty },
                { data, sameDataDifferentOrder, empty },
                { data, different, Lists.newArrayList(
                        i(1, 1), i(7, -1), i(3, -20), i(10, -5000), i(66, -4), i(22, 67), i(4, 66)) },
                { different, data, Lists.newArrayList(
                        i(1, -1), i(22, -67), i(7, 1), i(10, 5000), i(4, -66), i(3, 20), i(66, 4)) }
        };
    }

    private static BankItem i(int id, int quantity) {
        return new BankItem(id, quantity);
    }

    @Test
    public void testFindDifferencesBetween() {
        ItemListDiffGenerator diffGenerator = new ItemListDiffGenerator();

        List<BankItem> result = diffGenerator.findDifferencesBetween(beforeItems, afterItems);

        assertThat(result, is(expectedResult));
    }
}
package com.bankmemory;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RuneLiteRunner {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(BankMemoryPlugin.class);
        RuneLite.main(args);
    }
}

