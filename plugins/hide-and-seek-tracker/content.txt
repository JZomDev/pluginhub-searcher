package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class HideAndSeekTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(HideAndSeekTrackerPlugin.class);
		RuneLite.main(args);
	}
}
package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class ExistingCaptureAreaPanel extends CaptureAreaPanel
{
    private final JLabel colorIndicator = new JLabel();
    //private final JLabel fillColorIndicator = new JLabel();
    private final JLabel labelIndicator = new JLabel();
    private final JLabel statusLabel = new JLabel();
    private final JLabel shareLabel = new JLabel();
    private final JLabel visibilityLabel = new JLabel();
    private final JLabel deleteLabel = new JLabel();

    private final FlatTextField nameInput = new FlatTextField();
    private final JLabel save = new JLabel("Save");
    private final JLabel cancel = new JLabel("Cancel");
    private final JLabel rename = new JLabel("Rename");

    private final HideAndSeekTrackerPlugin plugin;
    private final CaptureArea captureArea;

    private boolean visible;
    private boolean showLabel;

    public ExistingCaptureAreaPanel(HideAndSeekTrackerPlugin plugin, CaptureArea captureArea)
    {
        this.plugin = plugin;
        this.captureArea = captureArea;
        this.visible = captureArea.isAreaVisible();
        this.showLabel = captureArea.isLabelVisible();

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);

        JPanel nameActions = new JPanel(new BorderLayout(3,0));
        nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        save.setVisible(false);
        save.setFont(FontManager.getRunescapeSmallFont());
        save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        save.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                save();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
            }
        });

        cancel.setVisible(false);
        cancel.setFont(FontManager.getRunescapeSmallFont());
        cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
        cancel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                cancel();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
            }
        });

        rename.setFont(FontManager.getRunescapeSmallFont());
        rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
        rename.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                nameInput.setEditable(true);
                updateNameActions(true);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
            }
        });

        nameActions.add(save, BorderLayout.EAST);
        nameActions.add(cancel, BorderLayout.WEST);
        nameActions.add(rename, BorderLayout.CENTER);

        nameInput.setText(captureArea.getLabel());
        nameInput.setBorder(null);
        nameInput.setEditable(false);
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setPreferredSize(new Dimension(0, 24));
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));
        nameInput.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ENTER)
                {
                    save();
                }
                else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                {
                    cancel();
                }
            }
        });
        nameInput.getTextField().addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                preview(true);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                preview(false);
            }
        });

        nameWrapper.add(nameInput, BorderLayout.CENTER);
        nameWrapper.add(nameActions, BorderLayout.EAST);

        JPanel bottomContainer = new JPanel(new BorderLayout());
        bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        colorIndicator.setToolTipText("Edit area color");
        colorIndicator.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                openBorderColorPicker();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                colorIndicator.setIcon(COLOR_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                colorIndicator.setIcon(COLOR_ICON);
            }
        });

        labelIndicator.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                toggleLabelling(!showLabel);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_HOVER_ICON : NO_LABEL_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
            }
        });

        leftActions.add(colorIndicator);
        leftActions.add(labelIndicator);

        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        statusLabel.setText("Copied!");
        statusLabel.setVisible(false);

        shareLabel.setIcon(COPY_AREA_ICON);
        shareLabel.setToolTipText("Copy area to clipboard");
        shareLabel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                plugin.copyCaptureAreaToClip(captureArea);
                showCopiedStatus();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                shareLabel.setIcon(COPY_AREA_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                shareLabel.setIcon(COPY_AREA_ICON);
            }
        });

        visibilityLabel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                toggle(!visible);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                visibilityLabel.setIcon(visible ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                updateVisibility();
            }
        });

        deleteLabel.setIcon(DELETE_ICON);
        deleteLabel.setToolTipText("Delete capture area");
        deleteLabel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                int confirm = JOptionPane.showConfirmDialog(ExistingCaptureAreaPanel.this,
                        "Are you sure you want to permanently delete this capture area?",
                        "Warning", JOptionPane.OK_CANCEL_OPTION);

                if (confirm == 0)
                {
                    plugin.deleteCaptureArea(captureArea);
                }
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                deleteLabel.setIcon(DELETE_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                deleteLabel.setIcon(DELETE_ICON);
            }
        });

        rightActions.add(statusLabel);
        rightActions.add(shareLabel);
        rightActions.add(visibilityLabel);
        rightActions.add(deleteLabel);

        bottomContainer.add(leftActions, BorderLayout.WEST);
        bottomContainer.add(rightActions, BorderLayout.EAST);
        bottomContainer.setPreferredSize(new Dimension(0, 37));

        add(nameWrapper, BorderLayout.NORTH);
        add(bottomContainer, BorderLayout.CENTER);

        updateVisibility();
        updateBorder();
        updateLabelling();
    }

    private void preview(boolean on)
    {
        if(visible) {
            return;
        }
        captureArea.setAreaVisible(on);
    }

    private void toggle(boolean on)
    {
        visible = on;
        captureArea.setAreaVisible(on);
        captureArea.setAreaActive(on);
        plugin.updateCaptureAreas();
        updateVisibility();
    }

    private void toggleLabelling(boolean on)
    {
        showLabel = on;
        captureArea.setLabelVisible(on);
        plugin.updateCaptureAreas();
        updateLabelling();
    }

    private void save()
    {
        captureArea.setLabel(nameInput.getText());
        plugin.updateCaptureAreas();

        nameInput.setEditable(false);
        updateNameActions(false);
        requestFocusInWindow();
    }

    private void cancel()
    {
        nameInput.setEditable(false);
        nameInput.setText(captureArea.getLabel());
        updateNameActions(false);
        requestFocusInWindow();
    }

    private void updateNameActions(boolean saveAndCancel)
    {
        save.setVisible(saveAndCancel);
        cancel.setVisible(saveAndCancel);
        rename.setVisible(!saveAndCancel);

        if (saveAndCancel)
        {
            nameInput.getTextField().requestFocusInWindow();
            nameInput.getTextField().selectAll();
        }
    }

    private void updateVisibility()
    {
        visibilityLabel.setIcon(visible ? VISIBLE_ICON : INVISIBLE_ICON);
        visibilityLabel.setToolTipText(visible ? "Hide capture area" : "Show capture area");
    }

    private void updateLabelling()
    {
        labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
        labelIndicator.setToolTipText(showLabel ? "Hide label" : "Show label");
    }

    private void updateBorder()
    {
        Color color = captureArea.getColor();
        colorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, ColorUtil.colorWithAlpha(color, MAX_ALPHA)));

        colorIndicator.setIcon(COLOR_ICON);
    }

    private void openBorderColorPicker()
    {
        final Color color = captureArea.getColor();
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                color,
                captureArea.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnColorChange(c ->
        {
            captureArea.setColor(c);
            updateBorder();
        });
        colorPicker.setOnClose(c -> plugin.updateCaptureAreas());
        colorPicker.setVisible(true);
    }

    private void showCopiedStatus()
    {
        statusLabel.setVisible(true);
        Timer hideTimer = new Timer(1000, e -> hideCopiedStatus());
        hideTimer.setRepeats(false);
        hideTimer.start();
    }

    private void hideCopiedStatus()
    {
        statusLabel.setVisible(false);
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.awt.*;
import java.time.Instant;
import java.util.Objects;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CaptureArea {
    private static final int MAX_RENDER_DISTANCE = 50;

    private long id;
    private WorldPoint worldPoint;
    private int width;
    private int height;
    private String label;
    private Color color;
    private boolean areaVisible;
    private boolean areaActive;
    private boolean labelVisible;

    public CaptureArea(WorldPoint worldPoint, int width, int height, Color color, @Nullable String label, boolean labelVisible) {
        this.id = Instant.now().toEpochMilli();
        this.worldPoint = worldPoint;
        this.width = width;
        this.height = height;
        this.label = Objects.requireNonNullElse(label, "");
        this.color = color;
        this.areaVisible = true;
        this.areaActive = true;
        this.labelVisible = labelVisible;
    }

    public boolean notWorthChecking(WorldPoint playerLoc)
    {
        boolean notWorth = false;
        notWorth |= !areaActive;
        notWorth |= playerLoc.getPlane() != worldPoint.getPlane();
        notWorth |= playerLoc.distanceTo(worldPoint) > MAX_RENDER_DISTANCE;
        return notWorth;
    }

    public boolean notWorthPainting(WorldPoint playerLoc)
    {
        boolean notWorth = false;
        notWorth |= !areaVisible;
        notWorth |= playerLoc.getPlane() != worldPoint.getPlane();
        notWorth |= playerLoc.distanceTo(worldPoint) > MAX_RENDER_DISTANCE;
        return notWorth;
    }

    public boolean playerInArea(WorldPoint playerLoc)
    {
        final int playerX = playerLoc.getX();
        final int playerY = playerLoc.getY();
        final int areaX = worldPoint.getX();
        final int areaY = worldPoint.getY();
        return ((playerX >= areaX) && (playerX < areaX + width))
                && ((playerY >= areaY) && (playerY < areaY + height));
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import joptsimple.internal.Strings;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

public class HideAndSeekSettings {

    public static final String CONFIG_GROUP = "hideAndSeekTracker";
    public static final String CAPTURE_AREA_KEY = "captureAreas";
    public static final String TICK_LENIENCY_KEY = "HaS_TickLeniency";
    public static final String PLAYER_NAMES_KEY = "HaS_PlayerNames";
    public static final String SHOW_RENDER_DIST = "HaS_ShowRenderDist";

    @Inject
    private ConfigManager configManager;
    @Inject
    private Gson gson;

    private void setValue(String key, Object value)
    {
        boolean isEmpty = false;
        if(value instanceof Collection)
        {
            isEmpty = ((Collection<?>) value).isEmpty();
        }
        else if (value instanceof Map)
        {
            isEmpty = ((Map<?, ?>) value).isEmpty();
        }

        if(isEmpty)
        {
            configManager.unsetConfiguration(CONFIG_GROUP, key);
            return;
        }

        final String json = gson.toJson(value);
        configManager.setConfiguration(CONFIG_GROUP, key, json);
    }

    public int getTickLenience() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, TICK_LENIENCY_KEY);
        if(Strings.isNullOrEmpty(json)){
            return 2;
        }
        return gson.fromJson(json, new TypeToken<Integer>(){}.getType());
    }

    public void setTickLenience(int ticks) {
        setValue(TICK_LENIENCY_KEY, ticks);
    }

    public List<String> getPlayerNames() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, PLAYER_NAMES_KEY);
        if(Strings.isNullOrEmpty(json)){
            return new ArrayList<>();
        }
        return gson.fromJson(json, new TypeToken<ArrayList<String>>(){}.getType());
    }

    public void setPlayerNames(List<String> playerNames) {
        setValue(PLAYER_NAMES_KEY, playerNames);
    }

    public List<CaptureArea> getCaptureAreas() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, CAPTURE_AREA_KEY);
        if(Strings.isNullOrEmpty(json)){
            return new ArrayList<>();
        }
        return gson.fromJson(json, new TypeToken<ArrayList<CaptureArea>>(){}.getType());
    }

    public void setCaptureAreas(List<CaptureArea> captureAreas) {
        setValue(CAPTURE_AREA_KEY, captureAreas);
    }

    public boolean getShowRenderDist() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, SHOW_RENDER_DIST);
        if(Strings.isNullOrEmpty(json)){
            return false;
        }
        return gson.fromJson(json, new TypeToken<Boolean>(){}.getType());
    }

    public void setShowRenderDist(boolean show) {
        setValue(SHOW_RENDER_DIST, show);
    }

}

package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.PluginErrorPanel;

import javax.swing.*;
import java.awt.*;

public class CaptureAreaManagementPanel extends JPanel {

    private final PluginErrorPanel noAreasPanel = new PluginErrorPanel();
    private final JPanel areaView = new JPanel(new GridBagLayout());
    private final JButton newArea = new JButton("New Area");
    private final JButton importArea = new JButton("Import from clipboard");
    private final JButton exportVisibleAreas = new JButton("Export visible to clipboard");
    private final JLabel copyStatusLabel = new JLabel("Copied!");

    private final HideAndSeekTrackerPlugin plugin;

    CaptureAreaManagementPanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;

        setLayout(new BorderLayout());

        areaView.setBackground(ColorScheme.DARK_GRAY_COLOR);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        noAreasPanel.setContent("No Capture areas set", "Add a capture area for people to finnish in");
        noAreasPanel.setVisible(false);

        newArea.addActionListener(e -> plugin.startCaptureAreaCreation());
        importArea.addActionListener(e -> plugin.importCaptureAreaFromClip());
        exportVisibleAreas.addActionListener(e -> exportVisibleAreas());

        areaView.add(noAreasPanel, constraints);
        constraints.gridy++;

        //centerPanel.add(areaView, BorderLayout.CENTER);
        add(areaView, BorderLayout.NORTH);
    }

    public void rebuild()
    {
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        areaView.removeAll();

        for(final CaptureArea captureArea : plugin.getCaptureAreas())
        {
            areaView.add(new ExistingCaptureAreaPanel(plugin, captureArea), constraints);
            constraints.gridy++;

            addSpacer(constraints);
        }

        final boolean empty = constraints.gridy == 0;
        noAreasPanel.setVisible(empty);

        areaView.add(noAreasPanel, constraints);
        constraints.gridy++;

        if(plugin.getCaptureCreationOptions().isCurrentlyCreating())
        {
            areaView.add(new CaptureCreationPanel(plugin), constraints);
        }
        else
        {
            areaView.add(newArea, constraints);
        }
        constraints.gridy++;
        addSpacer(constraints);

        areaView.add(importArea, constraints);
        constraints.gridy++;

        addSpacer(constraints);

        areaView.add(exportVisibleAreas, constraints);
        constraints.gridy++;

        copyStatusLabel.setVisible(false);
        areaView.add(copyStatusLabel, constraints);
        constraints.gridy++;

        repaint();
        revalidate();
    }

    private void addSpacer(GridBagConstraints constraints)
    {
        areaView.add(Box.createRigidArea(new Dimension(0, 5)), constraints);
        constraints.gridy++;
    }

    private void exportVisibleAreas()
    {
        plugin.copyVisibleCaptureAreasToClip();
        copyStatusLabel.setVisible(true);
        Timer hideStatusTimer = new Timer(1000, e -> copyStatusLabel.setVisible(false));
        hideStatusTimer.setRepeats(false);
        hideStatusTimer.start();
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;

public class GamePanel extends JPanel {
    private final HideAndSeekTrackerPlugin plugin;

    private final JSpinner hintCount;
    private final HideAndSeekTable resultTable;
    private final JLabel numFinished = new JLabel("999/999 Finished");

    GamePanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 10, 0));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.anchor = GridBagConstraints.NORTHWEST;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        JButton exportDirect = new JButton("Export Direct");
        exportDirect.addActionListener(e -> export(false));
        contents.add(exportDirect, constraints);

        constraints.gridx = 1;
        JButton exportDiscord = new JButton("Export Discord");
        exportDiscord.addActionListener(e -> export(true));
        contents.add(exportDiscord, constraints);
        constraints.gridy++;

        constraints.gridx = 0;
        JLabel txt_hints = new JLabel("Hints Given:");
        txt_hints.setFont(FontManager.getRunescapeFont());
        txt_hints.setHorizontalAlignment(SwingConstants.LEFT);
        contents.add(txt_hints, constraints);

        constraints.gridx = 1;
        hintCount = new JSpinner(new SpinnerNumberModel(1, 1, 100, 1));
        hintCount.addChangeListener(e -> updateHintCount());
        contents.add(hintCount, constraints);
        constraints.gridy++;
        constraints.gridx = 0;

        resultTable = new HideAndSeekTable(plugin.getParticipants());
        resultTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
        constraints.gridwidth = 2;
        constraints.fill = GridBagConstraints.BOTH;
        constraints.weighty = 1;
        JScrollPane scrollPane = new JScrollPane(resultTable);
        contents.add(scrollPane, constraints);
        constraints.gridwidth = 1;
        constraints.gridy++;
        constraints.weighty = 0;

        contents.add(numFinished, constraints);

        constraints.gridx = 1;
        JButton resetGame = new JButton("Reset");
        resetGame.addActionListener(e -> reset());
        contents.add(resetGame, constraints);
        constraints.gridx = 0;
        constraints.gridy++;

        add(contents, BorderLayout.NORTH);
    }

    private void export(boolean discordExport)
    {
        final String exportString = plugin.game.export(discordExport);
        final StringSelection selection = new StringSelection(exportString);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(selection, selection);
    }

    private void reset()
    {
        plugin.game.newRound();
        hintCount.setValue(1);
    }

    private void updateHintCount()
    {
        plugin.game.setHintsGiven((Integer) hintCount.getValue());
    }

    public void updatePlacements()
    {
        SwingUtilities.invokeLater(() -> {
            resultTable.update();
            updateNumFinished();
        });
    }

    private void updateNumFinished()
    {
        String numPlaced = plugin.game.getNumPlaced() +
                " / " +
                plugin.game.getNumParticipants() +
                " Finished";
        numFinished.setText(numPlaced);
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class CaptureCreationPanel extends CaptureAreaPanel
{
    protected static final ImageIcon CREATE_ICON;
    protected static final ImageIcon CREATE_HOVER_ICON;
    protected static final ImageIcon CANCEL_ICON;
    protected static final ImageIcon CANCEL_HOVER_ICON;
    protected static final ImageIcon COMPASS_ICON;

    private final JLabel colorIndicator = new JLabel();
    private final JLabel labelIndicator = new JLabel();
    private final FlatTextField nameInput = new FlatTextField();
    private final JSpinner northSpinner = new JSpinner();
    private final JSpinner eastSpinner = new JSpinner();
    private final JSpinner southSpinner = new JSpinner();
    private final JSpinner westSpinner = new JSpinner();
    private final JLabel saveArea = new JLabel();
    private final JLabel cancelArea = new JLabel();
    private final JLabel warnLabel = new JLabel("⚠ Area can be skipped over");

    private final CaptureCreationOptions captureOptions;
    private final HideAndSeekTrackerPlugin plugin;
    private boolean showLabel;

    static
    {
        final BufferedImage createImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "confirm_icon.png");
        final BufferedImage createImgHover = ImageUtil.alphaOffset(createImg, 0.5f);
        CREATE_ICON = new ImageIcon(createImg);
        CREATE_HOVER_ICON = new ImageIcon(createImgHover);

        final BufferedImage cancelImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "cancel_icon.png");
        final BufferedImage cancelImgHover = ImageUtil.alphaOffset(cancelImg, 0.5f);
        CANCEL_ICON = new ImageIcon(cancelImg);
        CANCEL_HOVER_ICON = new ImageIcon(cancelImgHover);

        final BufferedImage compassImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "compass.png");
        COMPASS_ICON = new ImageIcon(compassImg);
    }

    public CaptureCreationPanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.captureOptions = plugin.getCaptureCreationOptions();
        this.showLabel = captureOptions.isLabelVisible();

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);

        JPanel nameActions = new JPanel(new BorderLayout(3,0));
        nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        nameInput.setText(captureOptions.getLabel());
        nameInput.setBorder(null);
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setPreferredSize(new Dimension(0, 24));
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));

        nameWrapper.add(nameInput, BorderLayout.CENTER);
        nameWrapper.add(nameActions, BorderLayout.EAST);

        JPanel centerContainer = new JPanel(new BorderLayout());
        centerContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        centerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        centerContainer.setLayout(new GridBagLayout());
        GridBagConstraints centerConstraints = new GridBagConstraints();

        final int MAX_VALUE = CaptureCreationOptions.MAX_AREA_SIZE;
        final int MIN_VALUE = 0;
        northSpinner.setModel(new SpinnerNumberModel(captureOptions.getNorth(), MIN_VALUE, MAX_VALUE, 1));
        northSpinner.addChangeListener(e -> {
            final int val = (int) northSpinner.getValue();
            captureOptions.setNorth(val);
            validateArea();
        }
        );
        southSpinner.setModel(new SpinnerNumberModel(captureOptions.getSouth(), MIN_VALUE, MAX_VALUE, 1));
        southSpinner.addChangeListener(e -> {
                final int val = (int) southSpinner.getValue();
                captureOptions.setSouth(val);
                validateArea();
        });
        eastSpinner.setModel(new SpinnerNumberModel(captureOptions.getEast(), MIN_VALUE, MAX_VALUE, 1));
        eastSpinner.addChangeListener(e -> {
                final int val = (int) eastSpinner.getValue();
                captureOptions.setEast(val);
                validateArea();
        });
        westSpinner.setModel(new SpinnerNumberModel(captureOptions.getWest(), MIN_VALUE, MAX_VALUE, 1));
        westSpinner.addChangeListener(e -> {
                final int val = (int) westSpinner.getValue();
                captureOptions.setWest(val);
                validateArea();
        });
        JLabel compass = new JLabel();
        compass.setIcon(COMPASS_ICON);
        centerConstraints.gridx = 1;
        centerConstraints.gridy = 0;
        centerContainer.add(northSpinner, centerConstraints);
        centerConstraints.gridx = 0;
        centerConstraints.gridy = 1;
        centerContainer.add(westSpinner, centerConstraints);
        centerConstraints.gridx = 1;
        centerContainer.add(compass, centerConstraints);
        centerConstraints.gridx = 2;
        centerContainer.add(eastSpinner, centerConstraints);
        centerConstraints.gridx = 1;
        centerConstraints.gridy = 2;
        centerContainer.add(southSpinner, centerConstraints);
        centerConstraints.gridy = 3;
        centerConstraints.gridx = 0;
        centerConstraints.gridwidth = 3;
        warnLabel.setVisible(false);
        centerContainer.add(warnLabel, centerConstraints);

        JPanel bottomContainer = new JPanel(new BorderLayout());
        bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        colorIndicator.setToolTipText("Edit area color");
        colorIndicator.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                openBorderColorPicker();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                colorIndicator.setIcon(COLOR_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                colorIndicator.setIcon(COLOR_ICON);
            }
        });

        labelIndicator.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                toggleLabelling(!showLabel);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_HOVER_ICON : NO_LABEL_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
            }
        });

        leftActions.add(colorIndicator);
        leftActions.add(labelIndicator);

        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        saveArea.setIcon(CREATE_ICON);
        saveArea.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                captureOptions.setLabel(nameInput.getText());
                plugin.finishCaptureAreaCreation();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                saveArea.setIcon(CREATE_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                saveArea.setIcon(CREATE_ICON);
            }
        });

        cancelArea.setIcon(CANCEL_ICON);
        cancelArea.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e) {
                plugin.cancelCaptureAreaCreation();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                cancelArea.setIcon(CANCEL_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                cancelArea.setIcon(CANCEL_ICON);
            }
        });

        rightActions.add(saveArea);
        rightActions.add(cancelArea);

        bottomContainer.add(leftActions, BorderLayout.WEST);
        bottomContainer.add(rightActions, BorderLayout.EAST);
        bottomContainer.setPreferredSize(new Dimension(0, 37));

        add(nameWrapper, BorderLayout.NORTH);
        add(centerContainer, BorderLayout.CENTER);
        add(bottomContainer, BorderLayout.SOUTH);

        updateBorder();
        updateLabelling();
    }

    private void toggleLabelling(boolean on)
    {
        showLabel = on;
        captureOptions.setLabelVisible(on);
        plugin.updateCaptureAreas();
        updateLabelling();
    }

    private void updateLabelling()
    {
        labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
        labelIndicator.setToolTipText(showLabel ? "Hide label" : "Show label");
    }

    private void updateBorder()
    {
        Color color = captureOptions.getColor();
        colorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, ColorUtil.colorWithAlpha(color, MAX_ALPHA)));

        colorIndicator.setIcon(COLOR_ICON);
    }

    private void openBorderColorPicker()
    {
        final Color color = captureOptions.getColor();
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                color,
                captureOptions.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnColorChange(c ->
        {
            captureOptions.setColor(c);
            updateBorder();
        });
        colorPicker.setOnClose(c -> plugin.updateCaptureAreas());
        colorPicker.setVisible(true);
    }

    private void validateArea()
    {
        final int width = captureOptions.getWest() + captureOptions.getEast() + 1;
        final int height = captureOptions.getNorth() + captureOptions.getSouth() + 1;
        final boolean tooSmall = (width == 1 || height == 1);
        warnLabel.setVisible(tooSmall);
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import lombok.Getter;

public class HideAndSeekPlayer {

    public enum Placement {
        DNF("DNF", 0),    // no points
        FIRST("First", 1),  // all the points
        SECOND("Second", 2), // 2 points
        THIRD("Third", 3),  // 1 point
        OTHER("Other", 4);   // no points

        final String name;
        final int val;

        Placement(String name, int placementVal)
        {
            this.name = name;
            this.val = placementVal;
        }

        public String toString()
        {
            return this.name;
        }

        public int getValue()
        {
            return this.val;
        }

        public static Placement fromValue(Integer value)
        {
            if (value == null)
            {
                return Placement.DNF;
            }
            switch (value)
            {
                case 0: return Placement.DNF;
                case 1: return Placement.FIRST;
                case 2: return Placement.SECOND;
                case 3: return Placement.THIRD;
                default: return Placement.OTHER;
            }
        }
    }

    @Getter
    private final String  name;
    @Getter
    private int internalPlacement;
    private Placement placement;
    @Getter
    private int hints;

    public HideAndSeekPlayer(String name) {
        this.name = name;
        this.internalPlacement = 0;
        this.placement = Placement.DNF;
        this.hints = 0;
    }

    public String getPlacementExportString()
    {
        return placement.toString();
    }

    public Placement getPlacementTableString()
    {
        return placement;
    }

    public void setStats(int internal_placement, int placement, int hints)
    {
        this.internalPlacement = internal_placement;
        this.placement = Placement.fromValue(placement);
        this.hints = hints;
    }

    public boolean hasPlaced()
    {
        return internalPlacement > 0;
    }

    public void reset()
    {
        internalPlacement = 0;
        placement = Placement.DNF;
        hints = 0;
    }

    public Object getValue(int index)
    {
        switch (index)
        {
            case 0:
                return getInternalPlacement();
            case 1:
                return getName();
            case 2:
                return getPlacementTableString();
            case 3:
                return getHints();
            case 4:
                return "+" + getScore();
        }
        return null;
    }

    private int getScore()
    {
        if (hints == 0 || placement == Placement.DNF)
            return 0;

        int placementValue = placement.getValue();

        int hintScore = 4 - hints;
        int placementScore = 1;
        if (placementValue <= 3)
        {
            placementScore = 5 - placementValue;
        }
        return hintScore + placementScore;

    }
}

//== Hints ==
//DNF
//DNF
//DNF
//DNF
//DNF
//DNF
//DNF
//DNF
//1
//DNF
//DNF
//DNF
//DNF
//DNF
//1
//1
//== placement ==
//DNF
//DNF
//DNF
//DNF
//DNF
//DNF
//DNF
//DNF
//FIRST
//DNF
//DNF
//DNF
//DNF
//DNF
//SECOND
//SECOND
//== END ==


package com.github.jeromkiller.HideAndSeekTracker;

import lombok.Getter;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;

@Getter
public class HideAndSeekTrackerPanel extends PluginPanel {

    private final CaptureAreaManagementPanel areaPanel;
    private final GameSetupPanel setupPanel;
    private final GamePanel gamePanel;

    public HideAndSeekTrackerPanel(HideAndSeekTrackerPlugin plugin)
    {
        JTabbedPane tabPane = new JTabbedPane();

        areaPanel = new CaptureAreaManagementPanel(plugin);
        tabPane.add("Areas", areaPanel);

        setupPanel = new GameSetupPanel(plugin);
        tabPane.add("Setup", setupPanel);

        gamePanel = new GamePanel(plugin);
        tabPane.add("Game", gamePanel);

        add(tabPane);
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import java.awt.image.BufferedImage;

public class CaptureAreaPanel extends JPanel{
    protected static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));
    protected static final int MAX_ALPHA = 255;

    protected static final ImageIcon COLOR_ICON;
    protected static final ImageIcon COLOR_HOVER_ICON;

    protected static final ImageIcon COPY_AREA_ICON;
    protected static final ImageIcon COPY_AREA_HOVER_ICON;

    protected static final ImageIcon LABEL_ICON;
    protected static final ImageIcon LABEL_HOVER_ICON;
    protected static final ImageIcon NO_LABEL_ICON;
    protected static final ImageIcon NO_LABEL_HOVER_ICON;

    protected static final ImageIcon VISIBLE_ICON;
    protected static final ImageIcon VISIBLE_HOVER_ICON;
    protected static final ImageIcon INVISIBLE_ICON;
    protected static final ImageIcon INVISIBLE_HOVER_ICON;

    protected static final ImageIcon DELETE_ICON;
    protected static final ImageIcon DELETE_HOVER_ICON;

    static
    {
        final BufferedImage pencilImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "pencil_color_icon.png");
        final BufferedImage pencilImgHover = ImageUtil.luminanceOffset(pencilImg, -150);
        COLOR_ICON = new ImageIcon(pencilImg);
        COLOR_HOVER_ICON = new ImageIcon(pencilImgHover);

        final BufferedImage copyImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "copy_icon.png");
        final BufferedImage copyImgHover = ImageUtil.luminanceOffset(copyImg, -100);
        COPY_AREA_ICON = new ImageIcon(copyImg);
        COPY_AREA_HOVER_ICON = new ImageIcon(copyImgHover);

        final BufferedImage labelImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "label_icon.png");
        final BufferedImage labelImgHover = ImageUtil.luminanceOffset(labelImg, -150);
        LABEL_ICON = new ImageIcon(labelImg);
        LABEL_HOVER_ICON = new ImageIcon(labelImgHover);

        NO_LABEL_ICON = new ImageIcon(labelImgHover);
        NO_LABEL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(labelImgHover, -100));

        final BufferedImage visibleImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "visible_icon.png");
        VISIBLE_ICON = new ImageIcon(visibleImg);
        VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

        final BufferedImage invisibleImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "invisible_icon.png");
        INVISIBLE_ICON = new ImageIcon(invisibleImg);
        INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));

        final BufferedImage deleteImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteImg);
        DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.Perspective;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;


public class HideAndSeekTrackerSceneOverlay extends Overlay
{
    private static final int LOCAL_TILE_SIZE = Perspective.LOCAL_TILE_SIZE;
    private static final int ENTITY_RENDER_LIMIT = 15;

    private final Client client;
    private final HideAndSeekTrackerPlugin plugin;

    private boolean pointDrawn;

    @Inject
    private HideAndSeekTrackerSceneOverlay(Client client, HideAndSeekTrackerPlugin plugin)
    {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        WorldPoint playerLoc = client.getLocalPlayer().getWorldLocation();

        drawCreationArea(graphics, plugin.getCaptureCreationOptions(), playerLoc);

        if(plugin.getSettings().getShowRenderDist()) {
            drawRenderDist(graphics, playerLoc);
        }

        for(CaptureArea area : plugin.getCaptureAreas()) {
            if(area.notWorthPainting(playerLoc)) {
                continue;
            }
            drawBox(graphics, area, playerLoc);
        }

        return null;
    }

    private void drawRenderDist(Graphics2D graphics, WorldPoint PlayerLocation) {
        Canvas screen = client.getCanvas();
        final Rectangle2D fullScreen = new Rectangle2D.Float(0, 0, screen.getWidth(), screen.getHeight());
        WorldPoint entityRenderOrigin = PlayerLocation.dx(-ENTITY_RENDER_LIMIT).dy(-ENTITY_RENDER_LIMIT);
        GeneralPath clippingSquare = createFloorBox(entityRenderOrigin, ENTITY_RENDER_LIMIT * 2 + 1, ENTITY_RENDER_LIMIT * 2+ 1);  // simple clipping area

        // draw the clipping area
        graphics.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5, 2}, 0));
        graphics.setColor(Color.blue);
        graphics.setClip(fullScreen);
        graphics.draw(clippingSquare);

    }

    private void drawCreationArea(Graphics2D graphics2D, CaptureCreationOptions options, WorldPoint PlayerLocation)
    {
        if(!options.isCurrentlyCreating())
            return;

        final int width = (options.getEast() + options.getWest() + 1);
        final int height = (options.getNorth() + options.getSouth() + 1);
        final int xOffset = -options.getWest();
        final int yOffset = -options.getSouth();

        WorldPoint swTile = PlayerLocation.dx(xOffset).dy(yOffset);
        CaptureArea setupArea = new CaptureArea(swTile, width, height, options.getColor(), options.getLabel(), options.isLabelVisible());
        drawBox(graphics2D, setupArea, PlayerLocation);
    }

    private void drawBox(Graphics2D graphics, CaptureArea captureArea, WorldPoint PlayerLocation)
    {
        //capture area tile
        GeneralPath outerSquare = createFloorBox(captureArea.getWorldPoint(), captureArea.getWidth(), captureArea.getHeight());
        WorldPoint entityRenderOrigin = PlayerLocation.dx(-ENTITY_RENDER_LIMIT).dy(-ENTITY_RENDER_LIMIT);
        GeneralPath clippingSquare = createFloorBox(entityRenderOrigin, ENTITY_RENDER_LIMIT * 2 + 1, ENTITY_RENDER_LIMIT * 2+ 1);  // simple clipping area

        Canvas screen = client.getCanvas();
        final Rectangle2D fullScreen = new Rectangle2D.Float(0, 0, screen.getWidth(), screen.getHeight());

        // draw inside square
        Stroke stroke = new BasicStroke(2);
        Color inside_border = captureArea.getColor();
        Color inside_fillColor = ColorUtil.colorWithAlpha(inside_border, 255);
        graphics.setClip(clippingSquare);
        graphics.setStroke(stroke);
        graphics.setColor(inside_border);
        graphics.fill(outerSquare);
        graphics.setColor(inside_fillColor);
        graphics.draw(outerSquare);

        //draw the outside square
        Area insideClip = new Area(fullScreen);
        Color outside_border = negateColor(captureArea.getColor());
        Color outside_fillColor = ColorUtil.colorWithAlpha(outside_border, 255);

        insideClip.subtract(new Area(clippingSquare));
        graphics.setClip(insideClip);
        graphics.setStroke(stroke);
        graphics.setColor(outside_border);
        graphics.fill(outerSquare);
        graphics.setColor(outside_fillColor);
        graphics.draw(outerSquare);

        graphics.setClip(fullScreen);
        paintText(graphics, captureArea, inside_border);
    }

    private GeneralPath createFloorBox(WorldPoint origin, int width, int height)
    {
        GeneralPath path = new GeneralPath();

        pointDrawn = false;
        drawWestLine(path, height, origin);
        drawNorthLine(path, width, origin.dy(height));
        drawEastLine(path, height, origin.dx(width).dy(height));
        drawSouthLine(path, width, origin.dx(width));

        if(pointDrawn) {
            path.closePath();
        }
        return path;
    }

    private void drawWestLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int y_offset = 0; y_offset < length; y_offset++) {
            LocalPoint startPoint = toLocalPoint( x, y + y_offset);
            if(startPoint == null) {
                continue;
            }
            LocalPoint endPoint = startPoint.dy(LOCAL_TILE_SIZE -1);
            if(y_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawNorthLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int x_offset = 0; x_offset < length; x_offset++) {
            LocalPoint startPoint = toLocalPoint(x + x_offset, y);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dy(-1);
            LocalPoint endPoint = startPoint.dx(LOCAL_TILE_SIZE -1);
            if(x_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawEastLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int y_offset = 0; y_offset < length; y_offset++) {
            LocalPoint startPoint = toLocalPoint(x, y - y_offset);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dy(-1);
            startPoint = startPoint.dx(-1);
            LocalPoint endPoint = startPoint.dy(-(LOCAL_TILE_SIZE -1));
            if(y_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawSouthLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int x_offset = 0; x_offset < length; x_offset++) {
            LocalPoint startPoint = toLocalPoint(x - x_offset, y);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dx(-1);
            LocalPoint endPoint = startPoint.dx(-(LOCAL_TILE_SIZE -1));
            if(x_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void paintText(Graphics2D graphics, CaptureArea captureArea, Color color) {
        if(captureArea.isLabelVisible()) {
            //draw the label in the middle of the capture area
            WorldPoint areaCenter = captureArea.getWorldPoint().dx(captureArea.getWidth() / 2).dy(captureArea.getHeight() / 2);
            LocalPoint localPoint = toLocalPoint(areaCenter.getX(), areaCenter.getY(), true);
            if (localPoint != null) {
                if (captureArea.getWidth() % 2 == 0) {
                    localPoint = localPoint.dx(-LOCAL_TILE_SIZE / 2);
                }
                if (captureArea.getHeight() % 2 == 0) {
                    localPoint = localPoint.dy(-LOCAL_TILE_SIZE / 2);
                }

                graphics.setColor(ColorUtil.colorWithAlpha(color, 255));
                graphics.setFont(FontManager.getRunescapeFont());
                Point textLoc = Perspective.getCanvasTextLocation(client, graphics, localPoint, captureArea.getLabel(), 0);
                if (textLoc != null) {
                    graphics.drawString(captureArea.getLabel(), textLoc.getX(), textLoc.getY());
                }
            }
        }
    }

    private void paintPoint(GeneralPath path, LocalPoint localPoint, int z){
        if (localPoint == null)
            return;

        Point canvasPoint = toCanvasPoint(localPoint, z);
        if(canvasPoint == null)
            return;

        if (pointDrawn) {
            path.lineTo(canvasPoint.getX(), canvasPoint.getY());
        } else {
            path.moveTo(canvasPoint.getX(), canvasPoint.getY());
            pointDrawn = true;
        }
    }

    private LocalPoint toLocalPoint(int x, int y)
    {
        return toLocalPoint(x, y, false);
    }

    private LocalPoint toLocalPoint(int x, int y, boolean getCenter)
    {
        LocalPoint localPointCenter = LocalPoint.fromWorld(client.getTopLevelWorldView(), x, y);
        if(localPointCenter == null) {
            return null;
        }
        if (getCenter) {
            return localPointCenter;
        }
        return localPointCenter.plus(- LOCAL_TILE_SIZE / 2, - LOCAL_TILE_SIZE / 2);
    }

    private Point toCanvasPoint(LocalPoint localPoint, int z) {
        return Perspective.localToCanvas(
                client,
                localPoint,
                //new LocalPoint(localPoint.getX() - LOCAL_TILE_SIZE / 2, localPoint.getY() - LOCAL_TILE_SIZE / 2),
                z);
    }

    private Color negateColor(Color color) {
        final int maxColor = ColorUtil.MAX_RGB_VALUE;
        return new Color(maxColor - color.getRed(),
                    maxColor - color.getGreen(),
                    maxColor - color.getBlue(),
                    color.getAlpha()
                );
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import joptsimple.internal.Strings;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

public class GameSetupPanel extends JPanel {
    private final JSpinner tickLeniency = new JSpinner(new SpinnerNumberModel(2, 0, 100, 1));
    private final JTextArea playerNames = new JTextArea();
    private final JToggleButton showRenderDist = new JToggleButton(OFF_SWITCHER);
    private final JToggleButton autoFillButton = new JToggleButton(OFF_SWITCHER);
    private final JLabel notSavedWarning = new JLabel("Names not saved!");
    private final JLabel statusLabel = new JLabel();

    private final HideAndSeekTrackerPlugin plugin;
    private final HideAndSeekSettings settings;
    private boolean automaticUpdate;

    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    GameSetupPanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.settings = plugin.getSettings();
        this.automaticUpdate = true;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 10, 0));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);

        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.weightx = 1;
        final JLabel leniencyLabel = new JLabel("Placement Leniency Ticks");
        constraints.anchor = GridBagConstraints.WEST;
        constraints.gridwidth = 1;
        contents.add(leniencyLabel, constraints);

        constraints.anchor = GridBagConstraints.EAST;
        constraints.gridx = 1;
        tickLeniency.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                changeTickLeniency();
            }
        });
        contents.add(tickLeniency, constraints);
        constraints.gridy++;

        constraints.anchor = GridBagConstraints.WEST;
        constraints.gridx = 0;
        final JLabel showRenderDistLabel = new JLabel("Show Render Distance");
        contents.add(showRenderDistLabel, constraints);

        constraints.anchor = GridBagConstraints.EAST;
        constraints.gridx = 1;
        showRenderDist.setSelected(settings.getShowRenderDist());
        showRenderDist.setSelectedIcon(ON_SWITCHER);
        showRenderDist.addItemListener(e -> changeShowRenderDist());
        SwingUtil.removeButtonDecorations(showRenderDist);
        contents.add(showRenderDist, constraints);
        constraints.gridy++;
        constraints.anchor = GridBagConstraints.WEST;
        constraints.gridx = 0;
        constraints.gridwidth = 2;

        final JLabel playerNameLabel = new JLabel("Participant Names:");
        contents.add(playerNameLabel, constraints);
        constraints.gridy++;

        constraints.fill = GridBagConstraints.BOTH;
        constraints.weighty = 1;
        playerNames.setRows(10);
        Border border = BorderFactory.createLineBorder(ColorScheme.BORDER_COLOR );
        playerNames.setBorder(BorderFactory.createCompoundBorder(border,
                BorderFactory.createEmptyBorder(3, 5, 3, 5)));

        playerNames.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                enableNotSavedWarning();
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                enableNotSavedWarning();
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                // nothing
            }
        });
        contents.add(playerNames, constraints);
        constraints.gridy++;
        constraints.weighty = 0;
        constraints.fill = GridBagConstraints.HORIZONTAL;

        final JButton saveNamesButton = new JButton("Save Participant Names");
        saveNamesButton.addActionListener(e -> changePlayerNames());
        contents.add(saveNamesButton, constraints);
        constraints.gridy++;

        //contents.add(copyPlayerNames, constraints);
        constraints.gridwidth = 1;
        constraints.anchor = GridBagConstraints.WEST;
        final JLabel autoFillLabel = new JLabel("Automatically Fill Names");
        contents.add(autoFillLabel, constraints);

        constraints.gridx = 1;
        constraints.anchor = GridBagConstraints.EAST;
        constraints.fill = GridBagConstraints.NONE;
        autoFillButton.setSelectedIcon(ON_SWITCHER);
        autoFillButton.addItemListener(e -> changeAutoFill());
        SwingUtil.removeButtonDecorations(autoFillButton);
        contents.add(autoFillButton, constraints);
        constraints.gridwidth = 2;
        constraints.gridx = 0;
        constraints.gridy++;

        constraints.anchor = GridBagConstraints.WEST;
        statusLabel.setVisible(false);
        contents.add(statusLabel, constraints);
        constraints.gridy++;

        notSavedWarning.setVisible(false);
        contents.add(notSavedWarning, constraints);
        constraints.gridy++;

        add(contents, BorderLayout.NORTH);
        loadSettings();

        automaticUpdate = false;
    }

    private void changePlayerNames() {
        ArrayList<String> nameList = new ArrayList<>(List.of(
                playerNames.getText()
                .replaceAll("\\r", "")
                .split("\\n")));
        // we don't need empty namelists
        if(!nameList.isEmpty()) {
            if(Strings.isNullOrEmpty(nameList.get(nameList.size() -1))) {
                nameList.clear();
            }
        }

        final List<String> setNames = plugin.setPlayerNames(nameList);
        final int numRemoved = nameList.size() - setNames.size();
        if(numRemoved > 0) {
            setStatusLabel(String.format("Removed %d duplicates", numRemoved));
        }

        notSavedWarning.setVisible(false);
    }

    private void changeTickLeniency() {
        final int tickLeniencySetting = (int) tickLeniency.getValue();
        settings.setTickLenience(tickLeniencySetting);
    }

    private void changeShowRenderDist() {
        final boolean show = showRenderDist.isSelected();
        settings.setShowRenderDist(show);
    }

    private void changeAutoFill() {
        if(notSavedWarning.isVisible())
        {
            changePlayerNames();
        }
        final boolean autofill = autoFillButton.isSelected();
        plugin.setAutofillNames(autofill);
        playerNames.setEditable(!autofill);
    }

    public void loadSettings() {
        final int tickLeniencySetting = settings.getTickLenience();
        tickLeniency.setValue(tickLeniencySetting);

        final boolean showRenderDistSetting = settings.getShowRenderDist();
        showRenderDist.setSelected(showRenderDistSetting);

        loadPlayerNames(settings.getPlayerNames());
    }

    private void getInAreaPlayers()
    {
        final List<String> inAreaPlayers = plugin.getInRangePlayers();
        final int numPlayers = inAreaPlayers.size();
        if(numPlayers == 0) {
            setStatusLabel("No players found in area(s)");
        } else {
            exportPlayerNames(inAreaPlayers);
            setStatusLabel(String.format("Copied %d names to clipboard", numPlayers));
        }
    }

    private void enableNotSavedWarning()
    {
        if(!automaticUpdate) {
            notSavedWarning.setVisible(true);
        }
    }

    private void setStatusLabel(String statusText)
    {
        statusLabel.setText(statusText);
        statusLabel.setVisible(true);
        Timer hideTimer = new Timer(1000, e -> {
            statusLabel.setVisible(false);});
        hideTimer.setRepeats(false);
        hideTimer.start();
    }

    public void loadPlayerNames(List<String> names)
    {
        automaticUpdate = true;
        final String playerNameString = String.join(System.lineSeparator(), names);
        playerNames.setText(playerNameString);
        automaticUpdate = false;
    }

    private void exportPlayerNames(List<String> playerNames)
    {
        List<String> inRangePlayers = playerNames;
        String exportString = String.join("\n", inRangePlayers);
        final StringSelection selection = new StringSelection(exportString);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(selection, selection);
    }

}

package com.github.jeromkiller.HideAndSeekTracker;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;

import javax.inject.Inject;
import javax.swing.*;

import lombok.Data;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;

@Slf4j
@PluginDescriptor(
	name = "HideAndSeekTracker"
)
public class HideAndSeekTrackerPlugin extends Plugin
{
	private static final String PLUGIN_NAME = "Hide And Seek Tracker";

	@Inject
	private Client client;

	@Inject
	private HideAndSeekTrackerSceneOverlay sceneOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Gson gson;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter
	@Inject
	private ColorPickerManager colorPickerManager;

	@Getter
	@Inject
	private HideAndSeekSettings settings;

	@Getter
	private HideAndSeekTrackerPanel panel;
    private NavigationButton navButton;

	public HideAndSeekGame game;
	@Getter
	private final LinkedHashMap<String, HideAndSeekPlayer> participants = new LinkedHashMap<>();

	@Getter
	private final List<CaptureArea> captureAreas = new ArrayList<>();

	@Getter
	private final CaptureCreationOptions captureCreationOptions = new CaptureCreationOptions();

	@Getter
	@Setter
	public boolean autofillNames = false;

	@Override
	protected void startUp()
	{
		overlayManager.add(sceneOverlay);
        panel = new HideAndSeekTrackerPanel(this);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "HnS_icon.png");
		navButton = NavigationButton.builder()
				.tooltip(PLUGIN_NAME)
				.priority(5)
				.panel(panel)
				.icon(icon)
				.build();
		clientToolbar.addNavigation(navButton);

		loadCaptureAreas(settings.getCaptureAreas());
		game = new HideAndSeekGame(this);
		loadStartingPlayers();
		panel.getAreaPanel().rebuild();
		//panel.reset();
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(sceneOverlay);
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		final List<String> inRangePlayers = findPlayersInRange();
		if(autofillNames && !inRangePlayers.isEmpty()) {
			final List<String> setNames = addPlayerNames(inRangePlayers);
		}

		for(String playerName : inRangePlayers) {
			game.playerFound(playerName);
		}
		game.tick();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		//if(Objects.equals(event.getKey(), HideAndSeekSettings.PLAYER_NAMES_KEY))
		//{
		//	loadStartingPlayers();
		//}
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged)
	{
		loadCaptureAreas(settings.getCaptureAreas());
		SwingUtilities.invokeLater(panel.getAreaPanel()::rebuild);
		SwingUtilities.invokeLater(panel.getSetupPanel()::loadSettings);
	}

	private List<String> findPlayersInRange()
	{
		List<String> playerNames = new ArrayList<>();
		List<? extends  Player> playersList = client.getPlayers();	// is there a non deprecated method of getting this information?
		Player localPlayer = client.getLocalPlayer();
		if(localPlayer == null) {
			return new ArrayList<>();
		}

		for(CaptureArea area : captureAreas)
		{
			WorldPoint playerLoc = localPlayer.getWorldLocation();
			if(playerLoc == null) {
				return new ArrayList<>();
			}

			if(area.notWorthChecking(playerLoc)) {
				continue;
			}
			for(Player player : playersList)
			{
				if(player == localPlayer)
				{
					continue;
				}

				final String playerName = player.getName();
				if(area.playerInArea(player.getWorldLocation()))
				{
					playerNames.add(playerName);
				}
			}
		}
		return playerNames;
	}

	public List<String> setPlayerNames(List<String> nameList)
	{
		final List<String> setNames = game.setPlayers(nameList);
		settings.setPlayerNames(setNames);
		panel.getSetupPanel().loadPlayerNames(setNames);
		return setNames;
	}

	public List<String> addPlayerNames(List<String> nameList)
	{
		final List<String> setNames = game.addPlayerNames(nameList);
		settings.setPlayerNames(setNames);
		panel.getSetupPanel().loadPlayerNames(setNames);
		return setNames;
	}

	public void loadStartingPlayers()
	{
		List<String> playerNames = settings.getPlayerNames();
        game.setPlayers(playerNames);
	}

	public List<String> getInRangePlayers()
	{
        return findPlayersInRange();
	}

	public void startCaptureAreaCreation()
	{
		captureCreationOptions.setCurrentlyCreating(true);
		panel.getAreaPanel().rebuild();
	}

	public void finishCaptureAreaCreation()
	{
		final int width = (captureCreationOptions.getEast() + captureCreationOptions.getWest() + 1);
		final int height = (captureCreationOptions.getNorth() + captureCreationOptions.getSouth() + 1);
		final int xOffset = -captureCreationOptions.getWest();
		final int yOffset = -captureCreationOptions.getSouth();

		Player localPlayer = client.getLocalPlayer();
		if(null == localPlayer)
			return;
		WorldPoint playerLocation = localPlayer.getWorldLocation();
		WorldPoint swTile = playerLocation.dx(xOffset).dy(yOffset);
		CaptureArea setupArea = new CaptureArea(swTile, width, height,
				captureCreationOptions.getColor(),
				captureCreationOptions.getLabel(),
				captureCreationOptions.isLabelVisible());
		captureCreationOptions.resetOptions();

		addCaptureArea(setupArea);
		panel.getAreaPanel().rebuild();
	}

	public void cancelCaptureAreaCreation()
	{
		captureCreationOptions.resetOptions();
		panel.getAreaPanel().rebuild();
	}

	public void addCaptureArea(final CaptureArea captureArea)
	{
		captureAreas.add(captureArea);
		updateCaptureAreas();
	}

	public void deleteCaptureArea(final CaptureArea captureArea)
	{
		captureAreas.remove(captureArea);
		panel.getAreaPanel().rebuild();
		updateCaptureAreas();
	}

	public void updateCaptureAreas()
	{
		settings.setCaptureAreas(captureAreas);
	}

	public void loadCaptureAreas(List<CaptureArea> areas)
	{
		captureAreas.clear();
		captureAreas.addAll(areas);
	}

	public void copyCaptureAreaToClip(CaptureArea area)
	{
		final ArrayList<CaptureArea> exportAreas = new ArrayList<>();
		exportAreas.add(area);
		final String json = gson.toJson(exportAreas);
		final StringSelection selection = new StringSelection(json);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(selection, selection);
	}

	public void copyVisibleCaptureAreasToClip()
	{
		ArrayList<CaptureArea> exportAreas = new ArrayList<>(captureAreas);
		exportAreas.removeIf(area -> !area.isAreaVisible());
		final String json = gson.toJson(exportAreas);
		final StringSelection selection = new StringSelection(json);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(selection, selection);
	}

	public void importCaptureAreaFromClip() {
		String clipboardText;
		try {
			clipboardText = Toolkit.getDefaultToolkit()
					.getSystemClipboard()
					.getData(DataFlavor.stringFlavor)
					.toString();
		} catch (IOException | UnsupportedFlavorException ex) {
			sendChatMessage("Unable to read system clipboard.");
			log.warn("error reading clipboard", ex);
			return;
		}

		if (clipboardText.isEmpty())
			return;

		ArrayList<CaptureArea> importAreas;
		try {
			importAreas = gson.fromJson(clipboardText, new TypeToken<ArrayList<CaptureArea>>(){}.getType());
		}
		catch (JsonSyntaxException e) {
			sendChatMessage("You do not have any capture areas saved to the clipboard");
			return;
		}

		if(importAreas.isEmpty()) {
			sendChatMessage("You do not have any capture areas saved to the clipboard");
			return;
		}

		importAreas.removeIf(captureAreas::contains);
		captureAreas.addAll(importAreas);
		sendChatMessage("Imported " + importAreas.size() + " area(s) from clipboard");

		panel.getAreaPanel().rebuild();
		updateCaptureAreas();
	}

	private void sendChatMessage(final String message)
	{
		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
	}
}

package com.github.jeromkiller.HideAndSeekTracker;

import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

public class HideAndSeekPlacementRenderer extends DefaultTableCellRenderer {
    Color defaultColor;

    HideAndSeekPlacementRenderer() {
        super();
        defaultColor = getForeground();
    }

    public void setValue(Object value) {
        final String printString;
        Color printColor = defaultColor;
        switch ((HideAndSeekPlayer.Placement) value)
        {
            case DNF: {
                printString = "DNF";
                break;
            }
            case FIRST: {
                printString = "🥇";
                printColor = Color.ORANGE;
                break;
            }
            case SECOND: {
                printString = "🥈";
                printColor = Color.LIGHT_GRAY;
                break;
            }
            case THIRD: {
                printString = "🥉";
                printColor = new Color(205, 127, 50);
                break;
            }
            case OTHER: {
                printString = "🏁";
                break;
            }
            default: {
                printString = "";
            }
        }

        setForeground(printColor);
        setText(printString);
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import javax.swing.*;
import javax.swing.table.TableRowSorter;
import java.util.LinkedHashMap;

public class HideAndSeekTable extends JTable {
    HideAndSeekTable(LinkedHashMap<String, HideAndSeekPlayer> data)
    {
        super(new HideAndSeekTableModel(data));
        RowFilter<HideAndSeekTableModel, Object> filter = RowFilter.numberFilter(RowFilter.ComparisonType.NOT_EQUAL, 0,0, 1);
        TableRowSorter<HideAndSeekTableModel> sorter = new TableRowSorter<>(model());
        setRowSorter(sorter);
        sorter.setRowFilter(filter);
        setDefaultRenderer(HideAndSeekPlayer.Placement.class, new HideAndSeekPlacementRenderer() );
    }

    public void update()
    {
        HideAndSeekTableModel model = model();
        model.update();
        getColumnModel().getColumn(0).setMinWidth(20);
        getColumnModel().getColumn(0).setMaxWidth(20);
        getColumnModel().getColumn(1).setMinWidth(90);
        this.getRowSorter().toggleSortOrder(0);
    }

    public HideAndSeekTableModel model()
    {
        return (HideAndSeekTableModel) getModel();
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

@Data
@NoArgsConstructor
public class CaptureCreationOptions {
    private static final String DEFAULT_AREA_NAME = "Capture Area";
    public static int MAX_AREA_SIZE = 15;

    private boolean currentlyCreating = false;
    private int north = 1;
    private int east = 1;
    private int south = 1;
    private int west = 1;
    private String label = DEFAULT_AREA_NAME;
    Color color = ColorUtil.colorWithAlpha(Color.GREEN, 50);
    private boolean labelVisible = true;

    public void resetOptions() {
        currentlyCreating = false;
        north = 1;
        east = 1;
        south = 1;
        west = 1;
        label = DEFAULT_AREA_NAME;
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import javax.swing.table.AbstractTableModel;
import java.util.ArrayList;
import java.util.LinkedHashMap;

public class HideAndSeekTableModel extends AbstractTableModel {
    private final String[] columnNames = {"#", "Name", "Place", "Hints"};
    private final LinkedHashMap<String, HideAndSeekPlayer> data;

    HideAndSeekTableModel(LinkedHashMap<String, HideAndSeekPlayer> data)
    {
        this.data = data;
    }

    @Override
    public int getRowCount()
    {
        return data.size();
    }

    @Override
    public int getColumnCount()
    {
        return columnNames.length;
    }

    public String getColumnName(int col)
    {
        return columnNames[col];
    }

    public Object getValueAt(int row, int col)
    {
        ArrayList<HideAndSeekPlayer> list = new ArrayList<>(data.values());
        if(row >= list.size())
        {
            return 0;
        }
        return list.get(row).getValue(col);
    }

    public Class<?> getColumnClass(int c)
    {
        return getValueAt(0, c).getClass();
    }

    public void update()
    {
        fireTableStructureChanged();
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import lombok.Setter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.util.*;

public class HideAndSeekGame {
    private static final Logger log = LoggerFactory.getLogger(HideAndSeekGame.class);
    private final LinkedHashMap<String, HideAndSeekPlayer> participants;

    private int hintsGiven;
    private int placementIndex;
    private int leniencyCounter;
    private int sharedPlacementSpot;

    private final HideAndSeekTrackerPlugin plugin;

    HideAndSeekGame(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.participants = plugin.getParticipants();
        this.hintsGiven = 1;
        this.placementIndex = 0;
        this.leniencyCounter = 0;
        this.sharedPlacementSpot = 0;
    }

    public void newRound()
    {
        hintsGiven = 1;
        placementIndex = 0;
        leniencyCounter = 0;
        sharedPlacementSpot = 0;

        for(HideAndSeekPlayer player : participants.values())
        {
            player.reset();
        }
        plugin.getPanel().getGamePanel().updatePlacements();
    }

    public void setHintsGiven(int hint)
    {
        hintsGiven = hint;
    }

    public List<String> setPlayers(List<String> playerNames)
    {
        LinkedHashMap<String, HideAndSeekPlayer> newParticipants = buildParticipantMap(playerNames);
        participants.clear();
        participants.putAll(newParticipants);
        plugin.getPanel().getGamePanel().updatePlacements();
        return new ArrayList<>(participants.keySet());
    }

    public List<String> addPlayerNames(List<String> playerNames)
    {
        LinkedHashMap<String, HideAndSeekPlayer> newParticipants = buildParticipantMap(playerNames);
        participants.putAll(newParticipants);
        plugin.getPanel().getGamePanel().updatePlacements();
        return new ArrayList<>(participants.keySet());
    }

    private LinkedHashMap<String, HideAndSeekPlayer> buildParticipantMap(List<String> playerNames)
    {
        LinkedHashMap<String, HideAndSeekPlayer> newParticipants = new LinkedHashMap<>();
        for(String playerName : playerNames)
        {
            playerName = playerName.toLowerCase();

            if(participants.containsKey(playerName)) {
                // copy already existing players over
                newParticipants.put(playerName, participants.get(playerName));
            }
            else {
                // create new players if they don't exist yet
                newParticipants.put(playerName, new HideAndSeekPlayer(playerName));
            }
        }
        return newParticipants;
    }

    public void tick()
    {
        if(leniencyCounter > 0)
        {
            leniencyCounter -= 1;
        }
    }

    public void playerFound(String playerName)
    {
        playerName = playerName.toLowerCase();

        HideAndSeekPlayer player = participants.get(playerName);
        if(player == null) {
            return;
        }

        if(player.hasPlaced()) {
            return;
        }

        if(leniencyCounter == 0)
        {
            sharedPlacementSpot += 1;
            leniencyCounter = plugin.getSettings().getTickLenience();
        }

        placementIndex += 1;
        participants.get(playerName).setStats(placementIndex, sharedPlacementSpot, hintsGiven);
        plugin.getPanel().getGamePanel().updatePlacements();
    }

    public String export(boolean discordExport)
    {
        List<String> exportLines = new ArrayList<>();
        final String seperator = discordExport ? ", " : "\t";


        for(HideAndSeekPlayer player :  participants.values())
        {
            String hints = player.getHints() > 0 ? Integer.toString(player.getHints()) : "DNF";
            String placement = player.getPlacementExportString();
            String newLine = hints + seperator + placement;
            exportLines.add(newLine);
        }
        String exportString = String.join("\n", exportLines);
        if(discordExport)
        {
            exportString = "```\n" + exportString + "\n```";
        }
        return exportString;
    }

    public int getNumPlaced()
    {
        int num = 0;
        for(HideAndSeekPlayer player : participants.values())
        {
            num += player.getInternalPlacement() > 0 ? 1 : 0;
        }
        return num;
    }

    public int getNumParticipants()
    {
        return participants.size();
    }
}

