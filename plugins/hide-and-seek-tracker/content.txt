package com.github.jeromkiller.HideAndSeekTracker.Util;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

@Data
@AllArgsConstructor
public class roundExport {
    private long id;
    private int hintsGiven;
    private String host;
    private int roundNumber;
    private int gameTime;
    private final List<playerExport> participants;

    public roundExport(HideAndSeekRound round) {
        this.id = round.getId();
        this.hintsGiven = round.getHintsGiven();
        this.host = round.getHost();
        this.roundNumber = round.getRoundNumber();
        this.participants = new ArrayList<>();
        for(HideAndSeekPlayer player : round.getParticipants().values()) {
            this.participants.add(new playerExport(player));
        }
        this.gameTime = round.getGameTime();
    }

    public HideAndSeekRound toHideAndSeekRound(HideAndSeekTrackerPlugin plugin) {
        HashMap<String, HideAndSeekPlayer> players = new HashMap<>();
        for(playerExport player : participants) {
            players.put(player.getName(), player.toHideAndSeekPlayer());
        }

        HideAndSeekRound round = new HideAndSeekRound(id, hintsGiven, 0, 0,
            0, host, roundNumber, true, gameTime, players, plugin);

        round.recalculatePlacements();
        return round;
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Util;

import java.time.LocalTime;

public class TimeUtil {
    static public LocalTime tickToTime(int ticks) {
        int seconds = (int) (ticks / 0.6);
        return LocalTime.ofSecondOfDay(seconds);
    }

    static public int timeToTick(LocalTime time) {
        int seconds = (time.toSecondOfDay());
        return (int) (seconds * 0.6);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Util;

import com.github.jeromkiller.HideAndSeekTracker.Scoring.*;
import com.github.jeromkiller.HideAndSeekTracker.game.CaptureArea;
import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import com.google.gson.reflect.TypeToken;
import joptsimple.internal.Strings;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.RuntimeTypeAdapterFactory;

import javax.inject.Inject;
import java.time.LocalTime;
import java.util.*;

public class HideAndSeekSettings {

    public static final String CONFIG_GROUP = "hideAndSeekTracker";
    public static final String CAPTURE_AREA_KEY = "captureAreas";
    public static final String TICK_LENIENCY_KEY = "HaS_TickLeniency";
    public static final String PLAYER_NAMES_KEY = "HaS_PlayerNames";
    public static final String SHOW_RENDER_DIST = "HaS_ShowRenderDist";
    public static final String HIDE_OVERLAY = "HaS_HideOverlay";
    public static final String SCORERULES_KEY = "HaS_ScoreRules";
    public static final String HIDE_UNFINISHED_KEY = "HaS_HideUnfinishedPlayers";
    public static final String DEV_MODE_KEY = "HaS_DevMode";

    public static final RuntimeTypeAdapterFactory<PointSystem> pointsystemTypeFactory;

    @Inject
    private ConfigManager configManager;
    @Inject
    private Gson gson;

    static {
        pointsystemTypeFactory = RuntimeTypeAdapterFactory
                .of(PointSystem.class)
                .registerSubtype(PositionScoring.class)
                .registerSubtype(HintScoring.class)
                .registerSubtype(NameScoring.class)
                .registerSubtype(TimeScoring.class)
                .registerSubtype(PercentileScoring.class);
    }

    private void setValue(String key, Object value)
    {
        boolean isEmpty = false;
        if(value instanceof Collection)
        {
            isEmpty = ((Collection<?>) value).isEmpty();
        }
        else if (value instanceof Map)
        {
            isEmpty = ((Map<?, ?>) value).isEmpty();
        }

        if(isEmpty)
        {
            configManager.unsetConfiguration(CONFIG_GROUP, key);
            return;
        }

        final String json = gson.toJson(value);
        configManager.setConfiguration(CONFIG_GROUP, key, json);
    }

    public int getTickLenience() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, TICK_LENIENCY_KEY);
        if(Strings.isNullOrEmpty(json)){
            return 2;
        }
        return gson.fromJson(json, new TypeToken<Integer>(){}.getType());
    }

    public void setTickLenience(int ticks) {
        setValue(TICK_LENIENCY_KEY, ticks);
    }

    public LinkedHashSet<String> getPlayerNames() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, PLAYER_NAMES_KEY);
        if(Strings.isNullOrEmpty(json)){
            return new LinkedHashSet<>();
        }
        return gson.fromJson(json, new TypeToken<LinkedHashSet<String>>(){}.getType());
    }

    public void setPlayerNames(LinkedHashSet<String> playerNames) {
        setValue(PLAYER_NAMES_KEY, playerNames);
    }

    public List<CaptureArea> getCaptureAreas() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, CAPTURE_AREA_KEY);
        if(Strings.isNullOrEmpty(json)){
            return new ArrayList<>();
        }
        return gson.fromJson(json, new TypeToken<ArrayList<CaptureArea>>(){}.getType());
    }

    public void setCaptureAreas(List<CaptureArea> captureAreas) {
        setValue(CAPTURE_AREA_KEY, captureAreas);
    }

    public boolean getShowRenderDist() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, SHOW_RENDER_DIST);
        if(Strings.isNullOrEmpty(json)){
            return false;
        }
        return gson.fromJson(json, new TypeToken<Boolean>(){}.getType());
    }

    public void setShowRenderDist(boolean show) {
        setValue(SHOW_RENDER_DIST, show);
    }

    public boolean getHideOverlay() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, HIDE_OVERLAY);
        if(Strings.isNullOrEmpty(json)) {
            return false;
        }
        return gson.fromJson(json, new TypeToken<Boolean>(){}.getType());
    }

    public void setHideOverlay(boolean hide) {
        setValue(HIDE_OVERLAY, hide);
    }

    public ScoreRules getScoreRules() {
        final Gson scoreRulesGson = gson.newBuilder().registerTypeAdapterFactory(
                pointsystemTypeFactory).registerTypeAdapter(LocalTime.class, new LocalTimeConverter()).create();

        final String json = configManager.getConfiguration(CONFIG_GROUP, SCORERULES_KEY);
        if(Strings.isNullOrEmpty(json)){
            return ScoreRules.getDefaultRules();
        }

        ScoreRules newRules = ScoreRules.getDefaultRules();;
        try {
            newRules = scoreRulesGson.fromJson(json, new TypeToken<ScoreRules>() {
            }.getType());
        } catch (JsonParseException e) {
            return ScoreRules.getDefaultRules();
        }
        return newRules;
    }

    public void setScoreRules(ScoreRules rules) {
        final Gson scoreRulesGson = gson.newBuilder().registerTypeAdapterFactory(
                pointsystemTypeFactory).registerTypeAdapter(LocalTime.class, new LocalTimeConverter()).create();


        final String json = scoreRulesGson.toJson(rules);
        configManager.setConfiguration(CONFIG_GROUP, SCORERULES_KEY, json);
    }

    public void setHideUnfinished(boolean show) {
        setValue(HIDE_UNFINISHED_KEY, show);
    }

    public boolean getHideUnfinished() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, HIDE_UNFINISHED_KEY);
        if(Strings.isNullOrEmpty(json)){
            return false;
        }
        return gson.fromJson(json, new TypeToken<Boolean>(){}.getType());
    }

}

package com.github.jeromkiller.HideAndSeekTracker.Util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.time.LocalTime;
import java.util.Objects;

public class LocalTimeConverter extends TypeAdapter<LocalTime> {

    @Override
    public void write(JsonWriter jsonWriter, LocalTime localTime) throws IOException {
        if (Objects.isNull(localTime)) {
            jsonWriter.nullValue();
            return;
        }
        jsonWriter.value(localTime.toString());
    }

    @Override
    public LocalTime read(JsonReader jsonReader) throws IOException {
        String dateTimeString = jsonReader.nextString();
        return LocalTime.parse(dateTimeString);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Util;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class playerExport {
    private final String name;
    private final int tickCount;
    private final int hints;

    public playerExport(HideAndSeekPlayer player) {
        this.name = player.getName();
        this.tickCount = player.getTickCount();
        this.hints = player.getHints();
    }

    public HideAndSeekPlayer toHideAndSeekPlayer() {
        return new HideAndSeekPlayer(name, tickCount, hints);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.game;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.time.Instant;
import java.util.*;

@Data
@AllArgsConstructor
public class HideAndSeekRound {
    private long id;

    private int hintsGiven;
    private int placementIndex;
    private int leniencyCounter;
    private int sharedPlacementSpot;
    private String host;
    private int roundNumber;
    private boolean roundStarted;
    private int gameTime;
    private final HashMap<String, HideAndSeekPlayer> participants;

    private final HideAndSeekTrackerPlugin plugin;

    HideAndSeekRound(HideAndSeekTrackerPlugin plugin, int roundNumber) {
        this.id = Instant.now().toEpochMilli();
        this.hintsGiven = 1;
        this.placementIndex = 0;
        this.leniencyCounter = 0;
        this.sharedPlacementSpot = 0;
        this.roundNumber = roundNumber;
        this.host = plugin.getLocalPlayerName();
        this.participants = new HashMap<>();
        this.plugin = plugin;
        this.roundStarted = false;
        this.gameTime = 0;
    }

    public String addPlayer(String playerName)
    {
        // list of lowercase names to return without duplicates
        playerName = playerName.toLowerCase();
        if(!participants.containsKey(playerName)) {
            participants.put(playerName, new HideAndSeekPlayer(playerName));
        }
        return playerName;
    }

    public LinkedHashSet<String> setPlayers(List<String> playerNames)
    {
        // add missing players to the list
        LinkedHashSet<String> parsedNames = new LinkedHashSet<>();
        for(String playerName : playerNames) {
            String parsedName = addPlayer(playerName);
            parsedNames.add(parsedName);
        }

        // remove players who's names have been erased
        Set<String> removeNames = new HashSet<>(participants.keySet());
        removeNames.removeAll(parsedNames);
        for(final String removedPlayer : removeNames) {
            participants.remove(removedPlayer);
        }

        return parsedNames;
    }

    public void tick()
    {
        if(leniencyCounter > 0)
        {
            leniencyCounter -= 1;
        }
        if(roundStarted) {
            gameTime++;
        }
        plugin.getPanel().getGamePanel().updateTimer(gameTime);
    }

    public void playerFound(String playerName)
    {
        if(!roundStarted) {
            return;
        }
        playerName = playerName.toLowerCase();

        HideAndSeekPlayer player = participants.get(playerName);
        if(player == null) {
            return;
        }

        if(player.hasPlaced()) {
            return;
        }

        if(leniencyCounter == 0)
        {
            sharedPlacementSpot += 1;
            leniencyCounter = plugin.getSettings().getTickLenience();
        }

        participants.get(playerName).setStats(placementIndex, sharedPlacementSpot, hintsGiven, gameTime);
        final int points = plugin.getScoreRules().scorePlayer(player, this);
        participants.get(playerName).setScore(points);
        placementIndex += 1;
        recalculateScores();
        plugin.getPanel().getGamePanel().updatePlacements();
    }

    public void startRound() {
        roundStarted = true;
    }

    public void endRound() {
        roundStarted = false;
    }

    public String plainTextExport() {
        List<HideAndSeekPlayer> playerList = new ArrayList<>(participants.values());
        playerList.sort(Comparator.comparingInt(HideAndSeekPlayer::getInternalPlacement));

        StringBuilder exportString = new StringBuilder();
        exportString.append("Host: ").append(getHost()).append("\n");
        exportString.append("Round ").append(getRoundNumber()).append(": ");

        for(final HideAndSeekPlayer player: playerList) {
            StringBuilder exportLine = new StringBuilder();
            final String placementText = player.getPlacementText();
            exportLine.append(placementText);
            if(!Objects.equals(placementText, "DNF")) {
                exportLine.append(" Place");
            }
            int spacing = 12 - exportLine.length();
            if(spacing > 0) {
                exportLine.append(" ".repeat(spacing));
            } else {
                exportLine.append(" ");
            }
            exportLine.append(" - ");
            exportLine.append(player.getName());

            spacing = 32 - exportLine.length();
            if(spacing > 0) {
                exportLine.append(" ".repeat(spacing));
            } else {
                exportLine.append(" ");
            }
            exportLine.append(player.getScore());
            exportLine.append(" points");

            exportString.append("\n");
            exportString.append(exportLine);
        }
        return exportString.toString();
    }

    public String devExport(boolean discordExport)
    {
        List<String> exportLines = new ArrayList<>();
        final String seperator = discordExport ? ", " : "\t";

        // get export order from the user list
        LinkedHashSet<String> participantNames = plugin.getPanel().getSetupPanel().getPlayerNameList();

        for(final String playerName :  participantNames)
        {
            HideAndSeekPlayer player = participants.getOrDefault(playerName, new HideAndSeekPlayer(playerName));
            String hints = player.getHints() > 0 ? Integer.toString(player.getHints()) : "DNF";
            String placement = player.getPlacementExportString();
            String newLine = hints + seperator + placement;
            exportLines.add(newLine);
        }
        String exportString = String.join("\n", exportLines);
        if(discordExport)
        {
            exportString = "```\n" + exportString + "\n```";
        }
        return exportString;
    }

    public int getNumPlaced()
    {
        int num = 0;
        for(final HideAndSeekPlayer player : participants.values())
        {
            num += player.getInternalPlacement() < Integer.MAX_VALUE ? 1 : 0;
        }
        return num;
    }

    public int getNumParticipants()
    {
        return participants.size();
    }

    public void recalculatePlacements()
    {
        // sort the players in the order they finished
        List<HideAndSeekPlayer> players = new ArrayList<>(participants.values());
        players.sort(Comparator.comparingInt(HideAndSeekPlayer::getTickCount));

        int leniencyTime = 0;
        int newInternalPlacement = 1;
        int newPlacement = 1;
        for(HideAndSeekPlayer player : players) {
            int hintsUsed = player.getHints();
            int time = player.getTickCount();
            if(time < 0) {
                continue;
            }
            participants.get(player.getName()).setStats(newInternalPlacement, newPlacement, hintsUsed, time);
            if(time > leniencyTime) {
                leniencyTime = time + plugin.getSettings().getTickLenience();
                newPlacement++;
            }
            newInternalPlacement++;
        }

        sharedPlacementSpot = newPlacement;
        placementIndex = newInternalPlacement;

        recalculateScores();
    }

    public void recalculateScores()
    {
        for(final HideAndSeekPlayer player : participants.values()) {
            final int score = plugin.getScoreRules().scorePlayer(player, this);
            player.setScore(score);
        }
    }
}

package com.github.jeromkiller.HideAndSeekTracker.game;

import lombok.Getter;
import lombok.Setter;

public class HideAndSeekPlayer {

    public enum Placement {
        DNF("DNF", 0),
        FIRST("First", 1),
        SECOND("Second", 2),
        THIRD("Third", 3),
        OTHER("Other", 4);

        final String name;
        final int val;

        Placement(String name, int placementVal)
        {
            this.name = name;
            this.val = placementVal;
        }

        public String toString()
        {
            return this.name;
        }

        public int getValue()
        {
            return this.val;
        }

        public static Placement fromValue(Integer value)
        {
            if (value == null)
            {
                return Placement.DNF;
            }
            switch (value)
            {
                case 0: return Placement.DNF;
                case 1: return Placement.FIRST;
                case 2: return Placement.SECOND;
                case 3: return Placement.THIRD;
                default: return Placement.OTHER;
            }
        }
    }

    @Getter
    private final String name;
    @Getter
    private int tickCount;
    @Getter
    private int internalPlacement;
    @Getter
    private int placementValue;
    private Placement placement;
    @Getter
    private int hints;
    @Getter
    @Setter
    private int score;

    public HideAndSeekPlayer(String name) {
        this.name = name;
        this.internalPlacement = Integer.MAX_VALUE; // used for sorting order
        this.placementValue = 0;
        this.placement = Placement.DNF;
        this.hints = 0;
        this.tickCount = -1;
    }

    public HideAndSeekPlayer(String name, int tickCount, int hints) {
        this.name = name;
        this.internalPlacement = Integer.MAX_VALUE;
        this.placementValue = 0;
        this.placement = Placement.DNF;
        this.hints = hints;
        this.tickCount = tickCount;
    }

    public String getPlacementExportString()
    {
        return placement.toString();
    }

    public String getPlacementTableString()
    {
        String printString;

        switch (placement) {
            case FIRST: {
                printString = "ü•á";
                break;
            }
            case SECOND: {
                printString = "ü•à";
                break;
            }
            case THIRD: {
                printString = "ü•â";
                break;
            }
            case OTHER: {
                printString = "üèÅ";
                break;
            }
            default: {
                printString = "";
            }
        }
        printString += " " + getPlacementText();
        return printString;
    }

    public void setStats(int internal_placement, int placement, int hints, int tickCount)
    {
        this.internalPlacement = internal_placement;
        this.tickCount = tickCount;
        this.placementValue = placement;
        this.placement = Placement.fromValue(placement);
        this.hints = hints;
    }

    public boolean hasPlaced()
    {
        return internalPlacement < Integer.MAX_VALUE;
    }

    public void reset()
    {
        internalPlacement = 0;
        placement = Placement.DNF;
        hints = 0;
    }

    public Object getValue(int index)
    {
        switch (index)
        {
            case 0:
                return getInternalPlacement();
            case 1:
                return getName();
            case 2:
                return getPlacementTableString();
            case 3:
                return getScore();
            case 4:
                return "+" + getScore();
        }
        return null;
    }

    public String getPlacementText() {
        // special cases
        switch(placementValue) {
            case 0:
                return "DNF";
            case 11:
            case 12:
            case 13:
                return placementValue + "th";
        }

        // follow the pattern
        int lastDigit = placementValue % 10;
        switch (lastDigit) {
            case 1:
                return placementValue + "st";
            case 2:
                return placementValue + "nd";
            case 3:
                return placementValue + "rd";
        }
        return placementValue + "th";
    }
}

package com.github.jeromkiller.HideAndSeekTracker.game;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.awt.*;
import java.time.Instant;
import java.util.Objects;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CaptureArea {
    private static final int MAX_RENDER_DISTANCE = 50;

    private long id;
    private WorldPoint worldPoint;
    private int width;
    private int height;
    private String label;
    private Color color;
    private boolean areaVisible;
    private boolean areaActive;
    private boolean labelVisible;

    public CaptureArea(WorldPoint worldPoint, int width, int height, Color color, @Nullable String label, boolean labelVisible) {
        this.id = Instant.now().toEpochMilli();
        this.worldPoint = worldPoint;
        this.width = width;
        this.height = height;
        this.label = Objects.requireNonNullElse(label, "");
        this.color = color;
        this.areaVisible = true;
        this.areaActive = true;
        this.labelVisible = labelVisible;
    }

    public boolean notWorthChecking(WorldPoint playerLoc)
    {
        boolean notWorth = false;
        notWorth |= !areaActive;
        notWorth |= playerLoc.getPlane() != worldPoint.getPlane();
        notWorth |= playerLoc.distanceTo(worldPoint) > MAX_RENDER_DISTANCE;
        return notWorth;
    }

    public boolean notWorthPainting(WorldPoint playerLoc)
    {
        boolean notWorth = false;
        notWorth |= !areaVisible;
        notWorth |= playerLoc.getPlane() != worldPoint.getPlane();
        notWorth |= playerLoc.distanceTo(worldPoint) > MAX_RENDER_DISTANCE;
        return notWorth;
    }

    public boolean playerInArea(WorldPoint playerLoc)
    {
        final int playerX = playerLoc.getX();
        final int playerY = playerLoc.getY();
        final int areaX = worldPoint.getX();
        final int areaY = worldPoint.getY();
        return ((playerX >= areaX) && (playerX < areaX + width))
                && ((playerY >= areaY) && (playerY < areaY + height));
    }
}

package com.github.jeromkiller.HideAndSeekTracker.game;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import lombok.Data;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.stream.Collectors;

@Data
public class HideAndSeekGame {
    private static final Logger log = LoggerFactory.getLogger(HideAndSeekGame.class);

    private HideAndSeekRound activeRound;
    private ArrayList<HideAndSeekRound> pastRounds;
    private final HideAndSeekTrackerPlugin plugin;
    private final HashMap<String, HideAndSeekPlayer> scoreTotals;

    public HideAndSeekGame(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.activeRound = new HideAndSeekRound(plugin, 1);
        this.pastRounds = new ArrayList<>();
        this.scoreTotals = new HashMap<>();
    }

    public void newRound()
    {
        activeRound.endRound();
        pastRounds.add(activeRound);
        ArrayList<String> previousPlayers = new ArrayList<>(activeRound.getParticipants().keySet());
        activeRound = new HideAndSeekRound(plugin, activeRound.getRoundNumber() + 1);
        activeRound.setPlayers(previousPlayers);
    }

    public void startRound() {
        activeRound.startRound();
    }

    public void setLocalHostNames(String localHostName)
    {
        for(HideAndSeekRound round : pastRounds) {
            if(round.getHost() == null) {
                round.setHost(localHostName);
            }
        }

        if(activeRound.getHost() == null) {
            activeRound.setHost(localHostName);
        }
    }

    public LinkedHashSet<String> setPlayers(List<String> playerNames)
    {
        final LinkedHashSet<String> parsedNames = activeRound.setPlayers(playerNames);
        plugin.getPanel().getGamePanel().updatePlacements();
        return parsedNames;
    }

    public void addPlayerName(String playerNames)
    {
        activeRound.addPlayer(playerNames);
        plugin.getPanel().getGamePanel().updatePlacements();
    }

    public void tick()
    {
        activeRound.tick();
    }

    public void playerFound(String playerName)
    {
        activeRound.playerFound(playerName);
    }

    public int calculatePlayerScore(String playerName) {
        int total = 0;
        HideAndSeekPlayer player = null;
        for(final HideAndSeekRound round : pastRounds) {
            if(!round.getParticipants().containsKey(playerName)) {
                continue;
            }
            player = round.getParticipants().get(playerName);
            total += player.getScore();
        }

        if(activeRound.getParticipants().containsKey(playerName)) {
            player = activeRound.getParticipants().get(playerName);
            total += player.getScore();
        }

        if(player != null) {
            total += plugin.getScoreRules().scorePlayerOnce(player);
        }

        return total;
    }

    public void recalculateAllScores() {
        for(HideAndSeekRound round : pastRounds) {
            round.recalculateScores();
        }
        activeRound.recalculateScores();

        recalculateTotalScores();
    }

    public void recalculateTotalScores() {
        HashSet<String> allPlayers = new HashSet<>(activeRound.getParticipants().keySet());
        for(final HideAndSeekRound round : pastRounds) {
            allPlayers.addAll(round.getParticipants().keySet());
        }

        List<HideAndSeekPlayer> playerScores = new ArrayList<>();
        for(final String playerName : allPlayers) {
            HideAndSeekPlayer playerScore = new HideAndSeekPlayer(playerName);
            playerScore.setScore(calculatePlayerScore(playerName));
            playerScores.add(playerScore);
        }
        playerScores.sort(Comparator.comparingInt(HideAndSeekPlayer::getScore).reversed());

        int internalPlacement = 1;
        int position = 1;
        int prevScore = Integer.MAX_VALUE;
        if(!playerScores.isEmpty()) {
            prevScore = playerScores.get(0).getScore();
        }

        for(final HideAndSeekPlayer player : playerScores) {
            final int score = player.getScore();
            if(score < prevScore) {
                position++;
                prevScore = score;
            }
            final int prevHints = player.getHints();
            final int prevTicks = player.getTickCount();
            player.setStats(internalPlacement, position, prevHints, prevTicks);
            internalPlacement++;
            scoreTotals.put(player.getName(), player);
        }

        // remove inactive players from the total list
        Set<String> activeNames = playerScores.stream().map(p -> p.getName()).collect(Collectors.toSet());
        Set<String> removeNames = new HashSet<>(scoreTotals.keySet());
        removeNames.removeAll(activeNames);
        for(final String removeName : removeNames) {
            scoreTotals.remove(removeName);
        }
    }

    public String totalScoreExport() {
        List<HideAndSeekPlayer> playerList = new ArrayList<>(scoreTotals.values());
        playerList.sort(Comparator.comparingInt(HideAndSeekPlayer::getInternalPlacement));

        StringBuilder exportString = new StringBuilder();
        exportString.append("Point Total:");

        for(final HideAndSeekPlayer player: playerList) {
            StringBuilder exportLine = new StringBuilder();
            final String placementText = player.getPlacementText();
            exportLine.append(placementText);
            if(!Objects.equals(placementText, "DNF")) {
                exportLine.append(" Place");
            }
            int spacing = 12 - exportLine.length();
            if(spacing > 0) {
                exportLine.append(" ".repeat(spacing));
            } else {
                exportLine.append(" ");
            }
            exportLine.append(" - ");
            exportLine.append(player.getName());

            spacing = 32 - exportLine.length();
            if(spacing > 0) {
                exportLine.append(" ".repeat(spacing));
            } else {
                exportLine.append(" ");
            }
            exportLine.append(player.getScore());
            exportLine.append(" points");

            exportString.append("\n");
            exportString.append(exportLine);
        }
        return exportString.toString();
    }

    public void deleteRound(int index) {
        if(index >= pastRounds.size()) {
            return;
        }
        pastRounds.remove(index);

        // renumber the other rounds
        int roundNumber = 1;
        for(HideAndSeekRound round : pastRounds) {
            round.setRoundNumber(roundNumber);
            roundNumber++;
        }
        activeRound.setRoundNumber(roundNumber);
    }

    public void importRounds(List<HideAndSeekRound> rounds) {
        // renumber the incoming rounds
        int newRoundNumber = activeRound.getRoundNumber();
        for(HideAndSeekRound round : rounds) {
            round.setRoundNumber(newRoundNumber);
            plugin.getPanel().getGamePanel().importRound(round);
            newRoundNumber++;
        }
        pastRounds.addAll(rounds);
        activeRound.setRoundNumber(newRoundNumber);

        plugin.getPanel().getGamePanel().getActiveRoundPanel().updateRoundLabel();
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import com.github.jeromkiller.HideAndSeekTracker.Panels.CaptureArea.CaptureAreaManagementPanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.GamePanel.GamePanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.GameSetupPanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.PointsPanel.ScoringPanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.SettingsPanel;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;

@Getter
public class HideAndSeekTrackerPanel extends PluginPanel {

    private final CaptureAreaManagementPanel areaPanel;
    private final GameSetupPanel setupPanel;
    private final GamePanel gamePanel;
    private final ScoringPanel scorePanel;
    private final SettingsPanel settingsPanel;

    private static final ImageIcon COG_ICON;

    static {
        BufferedImage cogIcon = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "config_edit_icon.png");
        COG_ICON = new ImageIcon(cogIcon);
    }

    public HideAndSeekTrackerPanel(HideAndSeekTrackerPlugin plugin)
    {
        super(false);

        final int borderWidth = PluginPanel.BORDER_OFFSET;
        setBorder(new EmptyBorder(0, borderWidth, borderWidth, borderWidth));
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JTabbedPane tabPane = new JTabbedPane(JTabbedPane.TOP, JTabbedPane.SCROLL_TAB_LAYOUT);

        // maybe replace the text with icons
        areaPanel = new CaptureAreaManagementPanel(plugin);
        tabPane.addTab("Areas", new JScrollPane(areaPanel));

        scorePanel = new ScoringPanel(plugin);
        tabPane.add("Points", new JScrollPane(scorePanel));

        setupPanel = new GameSetupPanel(plugin);
        tabPane.addTab("Players", new JScrollPane(setupPanel));

        gamePanel = new GamePanel(plugin);
        tabPane.addTab("Game", gamePanel);

        settingsPanel = new SettingsPanel(plugin);
        tabPane.addTab("Settings", COG_ICON, settingsPanel, "Change Plugin Settings");
        tabPane.setTabComponentAt(4, new JLabel(COG_ICON));

        add(tabPane);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;

import javax.annotation.Nullable;

public class PercentileScoring extends PointSystem<Integer> {
    PercentileScoring() {
        super(ScoreType.PERCENTILE, false);
    }

    @Override
    public int scorePlayer(HideAndSeekPlayer player, @Nullable HideAndSeekRound round) {
        if(round == null) {
            return 0;
        }

        final double totalPlacedPlayers = round.getSharedPlacementSpot();
        double percentilePlacement = (double) (player.getPlacementValue() - 1) / totalPlacedPlayers;
        percentilePlacement = (1 - percentilePlacement) * 100;
        for(final ScoringPair<Integer> pair : scoreTiers) {
            if(percentilePlacement >= pair.getSetting()) {
                return pair.getPoints();
            }
        }
        return fallThroughScore;
    }

    @Override
    public void addSetting() {
        if(scoreTiers.isEmpty()) {
            scoreTiers.add(new ScoringPair<>(99, 0));
            return;
        }
        ScoringPair<Integer> lastPair = scoreTiers.get(scoreTiers.size() -1);
        ScoringPair<Integer> newLast = new ScoringPair<>(lastPair.getSetting() - 1, fallThroughScore);
        scoreTiers.add(newLast);
    }

    @Override
    public void updateSetting(int index, Integer value) {
        if(index >= scoreTiers.size()) {
            return;
        }
        scoreTiers.get(index).setSetting(value);

        // if you change the setting to something lower than the ones after this,
        // they should all go up, since they have to follow a set order
        if(scoreTiers.size() == index + 1) {
            return; // don't have to update
        }

        if(scoreTiers.get(index + 1).getSetting() < value) {
            return;
        }

        int newSetting = value - 1;
        for(int i = index + 1; i < scoreTiers.size(); i++) {
            scoreTiers.get(i).setSetting(newSetting);
            newSetting--;
        }
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;
import lombok.Data;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

@Data
public abstract class PointSystem <T> {
    final ScoreType scoreType;
    final boolean canBeCalculatedOnce;
    List<ScoringPair<T>> scoreTiers;
    int fallThroughScore;
    boolean calcEveryRound;

    public enum ScoreType {
        POSITION("Position"),
        HINTS("Hints"),
        TIME("Time"),
        NAME("Players"),
        PERCENTILE("Percentile");

        final String name;

        ScoreType(String name) {
            this.name = name;
        }

        public String toString() {
            return this.name;
        }

        public static ScoreType fromString(String str) {
            switch(str) {
                case "Position":
                    return POSITION;
                case "Hints":
                    return HINTS;
                case "Time":
                    return TIME;
                case "Players":
                    return NAME;
                case "Percentile":
                    return PERCENTILE;
            }
            return null;
        }
    };

    PointSystem(ScoreType type, boolean canCalcOnce) {
        this.scoreType = type;
        this.canBeCalculatedOnce = canCalcOnce;
        scoreTiers = new ArrayList<>();
        this.fallThroughScore = 0;
        this.calcEveryRound = true;
    }

    public abstract int scorePlayer(HideAndSeekPlayer player, @Nullable HideAndSeekRound round);
    public abstract void addSetting();
    public abstract void updateSetting(int index, T value);

    public void addScorePair(T setting, int points) {
        scoreTiers.add(new ScoringPair<>(setting, points));
    }

    public void deleteSetting(int index) {
        if(index >= scoreTiers.size()) {
            return;
        }
        scoreTiers.remove(index);
    }
    public void updatePoints(int index, int value) {
        if(index >= scoreTiers.size()) {
            return;
        }
        scoreTiers.get(index).setPoints(value);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class ScoringPair<T> {
    private T setting;
    private int points;
}

package com.github.jeromkiller.HideAndSeekTracker.Scoring;

public abstract class NumberScoring extends PointSystem<Integer> {

    public NumberScoring(ScoreType type, boolean canCalcOnce) {
        super(type, canCalcOnce);
    }

    @Override
    public void addSetting() {
        if(scoreTiers.isEmpty()) {
            scoreTiers.add(new ScoringPair<>(1, 0));
            return;
        }
        ScoringPair<Integer> lastPair = scoreTiers.get(scoreTiers.size() -1);
        ScoringPair<Integer> newLast = new ScoringPair<>(lastPair.getSetting() + 1, fallThroughScore);
        scoreTiers.add(newLast);
    }

    @Override
    public void updateSetting(int index, Integer value) {
        if(index >= scoreTiers.size()) {
            return;
        }
        scoreTiers.get(index).setSetting(value);

        // if you change the setting to something higher than the ones after this,
        // they should all go up, since they have to follow a set order
        if(scoreTiers.size() == index + 1) {
            return; // don't have to update
        }

        if(scoreTiers.get(index + 1).getSetting() > value) {
            return; // next setting is still smaller higher than current value
        }

        int newSetting = value + 1;
        for(int i = index + 1; i < scoreTiers.size(); i++) {
            scoreTiers.get(i).setSetting(newSetting);
            newSetting++;
        }
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;
import com.github.jeromkiller.HideAndSeekTracker.Util.TimeUtil;

import java.time.*;

public class TimeScoring extends PointSystem<LocalTime> {
    TimeScoring() {
        super(ScoreType.TIME, false);
    }

    @Override
    public int scorePlayer(HideAndSeekPlayer player, HideAndSeekRound round) {
        final int ticks = player.getTickCount();
        for(final ScoringPair<LocalTime> pair: scoreTiers) {
            final long time_ticks = TimeUtil.timeToTick(pair.getSetting());
            if(ticks < time_ticks) {
                return pair.getPoints();
            }
        }
        return fallThroughScore;
    }

    @Override
    public void addSetting() {
        if(scoreTiers.isEmpty()) {
            scoreTiers.add(new ScoringPair<>(LocalTime.ofSecondOfDay(1), fallThroughScore));
            return;
        }
        ScoringPair<LocalTime> lastPair = scoreTiers.get(scoreTiers.size() - 1);
        ScoringPair<LocalTime> newLast = new ScoringPair<>(lastPair.getSetting().plusSeconds(1), fallThroughScore);
        scoreTiers.add(newLast);
    }

    @Override
    public void updateSetting(int index, LocalTime value) {
        if(index >= scoreTiers.size()) {
            return;
        }
        scoreTiers.get(index).setSetting(value);

        // if you change the setting to something higher than the ones after this,
        // they should all go up, since they have to follow a set order
        if(scoreTiers.size() == index + 1) {
            return; // don't have to update
        }

        final LocalTime nextSetting = scoreTiers.get(index + 1).getSetting();
        if(nextSetting.compareTo(value) > 0) {
            return; // next setting is still smaller higher than current value
        }
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;

import java.util.Locale;
import java.util.Optional;

public class NameScoring extends PointSystem<String> {
    NameScoring() {
        super(ScoreType.NAME, true);
    }

    @Override
    public int scorePlayer(HideAndSeekPlayer player, HideAndSeekRound round) {
        Optional<ScoringPair<String>> foundPair = scoreTiers.stream().filter(
                s -> {return s.getSetting().equals(player.getName());}).findFirst();

        return foundPair.map(ScoringPair::getPoints).orElse(0);
    }

    @Override
    public void addSetting() {
        scoreTiers.add(new ScoringPair<>("new_name", 1));
    }

    @Override
    public void updateSetting(int index, String value) {
        if(index >= scoreTiers.size()) {
            return;
        }

        String name = value.toLowerCase(Locale.ROOT);
        if(scoreTiers.stream().anyMatch(s -> {return s.getSetting().equals(name);})) {
            return; // don't save duplicates
        }

        scoreTiers.get(index).setSetting(name);
    }
}
package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;

public class PositionScoring extends NumberScoring {
    public PositionScoring() {
        super(ScoreType.POSITION, false);
    }

    @Override
    public int scorePlayer(HideAndSeekPlayer player, HideAndSeekRound round) {
        final int position = player.getPlacementValue();
        if(position == 0) {
            return 0;
        }
        for(final ScoringPair<Integer> pair: scoreTiers) {
            if(position <= pair.getSetting()) {
                return pair.getPoints();
            }
        }
        return fallThroughScore;
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;

public class HintScoring extends NumberScoring {

    HintScoring() {
        super(ScoreType.HINTS, false);
    }

    @Override
    public int scorePlayer(HideAndSeekPlayer player, HideAndSeekRound round) {
        final int hints = player.getHints();
        for(final ScoringPair<Integer> pair: scoreTiers) {
            if(hints <= pair.getSetting()) {
                return pair.getPoints();
            }
        }
        return fallThroughScore;
    }

}
package com.github.jeromkiller.HideAndSeekTracker.Scoring;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;
import lombok.Getter;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Getter
@NoArgsConstructor
public class ScoreRules {
    private final List<PointSystem<?>> pointSystems = new ArrayList<>();
    public int scorePlayer(HideAndSeekPlayer player, HideAndSeekRound round) {
        if(!player.hasPlaced()) {
            return 0;
        }
        final int sum = pointSystems.stream().filter(PointSystem::isCalcEveryRound)
                .mapToInt(system -> system.scorePlayer(player, round)).sum();
        return Integer.max(sum, 0);
    }

    public int scorePlayerOnce(HideAndSeekPlayer player) {
        final int sum = pointSystems.stream().filter(system -> {return !system.isCalcEveryRound();})
                .mapToInt(system -> system.scorePlayer(player, null)).sum();
        return sum;
    }

    public void addSystem(PointSystem.ScoreType type) {
        switch (type) {
            case POSITION:
                pointSystems.add(new PositionScoring());
                return;
            case HINTS:
                pointSystems.add(new HintScoring());
                return;
            case NAME:
                pointSystems.add(new NameScoring());
                return;
            case TIME:
                pointSystems.add(new TimeScoring());
                return;
            case PERCENTILE:
                pointSystems.add(new PercentileScoring());
                return;
            default:
                return;
        }
    }

    public void deleteSystem(PointSystem<?> system) {
        pointSystems.remove(system);
    }

    public void load(ScoreRules rules) {
        pointSystems.clear();
        pointSystems.addAll(rules.getPointSystems());
    }

    public void changePointSystemCatagory(PointSystem<?> system, PointSystem.ScoreType catagory) {
        PointSystem<?> newSystem = null;
        switch (catagory) {
            case POSITION:
                newSystem = new PositionScoring();
                break;
            case HINTS:
                newSystem = new HintScoring();
                break;
            case NAME:
                newSystem = new NameScoring();
        }
        final int index = pointSystems.indexOf(system);
        pointSystems.set(index, newSystem);
    }

    public static ScoreRules getDefaultRules() {
        ScoreRules scoreRules = new ScoreRules();

        PositionScoring posScore = new PositionScoring();
        posScore.addScorePair(1, 6);
        posScore.addScorePair(2, 5);
        posScore.addScorePair(3, 4);
        posScore.setFallThroughScore(3);
        scoreRules.getPointSystems().add(posScore);

        HintScoring hintScore = new HintScoring();
        hintScore.addScorePair(1, 0);
        hintScore.addScorePair(2, -1);
        hintScore.setFallThroughScore(-2);
        scoreRules.getPointSystems().add(hintScore);

        return scoreRules;
    }
}

package com.github.jeromkiller.HideAndSeekTracker;

import com.github.jeromkiller.HideAndSeekTracker.Panels.CaptureArea.CaptureCreationOptions;
import com.github.jeromkiller.HideAndSeekTracker.game.CaptureArea;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.Perspective;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;


public class HideAndSeekTrackerSceneOverlay extends Overlay
{
    private static final int LOCAL_TILE_SIZE = Perspective.LOCAL_TILE_SIZE;
    private static final int ENTITY_RENDER_LIMIT = 15;

    private final Client client;
    private final HideAndSeekTrackerPlugin plugin;

    private boolean pointDrawn;

    @Inject
    private HideAndSeekTrackerSceneOverlay(Client client, HideAndSeekTrackerPlugin plugin)
    {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if(plugin.getSettings().getHideOverlay()) {
            return null;
        }

        WorldPoint playerLoc = client.getLocalPlayer().getWorldLocation();

        drawCreationArea(graphics, plugin.getCaptureCreationOptions(), playerLoc);

        if(plugin.getSettings().getShowRenderDist()) {
            drawRenderDist(graphics, playerLoc);
        }

        for(CaptureArea area : plugin.getCaptureAreas()) {
            if(area.notWorthPainting(playerLoc)) {
                continue;
            }
            drawBox(graphics, area, playerLoc);
        }

        return null;
    }

    private void drawRenderDist(Graphics2D graphics, WorldPoint PlayerLocation) {
        Canvas screen = client.getCanvas();
        final Rectangle2D fullScreen = new Rectangle2D.Float(0, 0, screen.getWidth(), screen.getHeight());
        WorldPoint entityRenderOrigin = PlayerLocation.dx(-ENTITY_RENDER_LIMIT).dy(-ENTITY_RENDER_LIMIT);
        GeneralPath clippingSquare = createFloorBox(entityRenderOrigin, ENTITY_RENDER_LIMIT * 2 + 1, ENTITY_RENDER_LIMIT * 2+ 1);  // simple clipping area

        // draw the clipping area
        graphics.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5, 2}, 0));
        graphics.setColor(Color.blue);
        graphics.setClip(fullScreen);
        graphics.draw(clippingSquare);

    }

    private void drawCreationArea(Graphics2D graphics2D, CaptureCreationOptions options, WorldPoint PlayerLocation)
    {
        if(!options.isCurrentlyCreating())
            return;

        final int width = (options.getEast() + options.getWest() + 1);
        final int height = (options.getNorth() + options.getSouth() + 1);
        final int xOffset = -options.getWest();
        final int yOffset = -options.getSouth();

        WorldPoint swTile = PlayerLocation.dx(xOffset).dy(yOffset);
        CaptureArea setupArea = new CaptureArea(swTile, width, height, options.getColor(), options.getLabel(), options.isLabelVisible());
        drawBox(graphics2D, setupArea, PlayerLocation);
    }

    private void drawBox(Graphics2D graphics, CaptureArea captureArea, WorldPoint PlayerLocation)
    {
        //capture area tile
        GeneralPath outerSquare = createFloorBox(captureArea.getWorldPoint(), captureArea.getWidth(), captureArea.getHeight());
        WorldPoint entityRenderOrigin = PlayerLocation.dx(-ENTITY_RENDER_LIMIT).dy(-ENTITY_RENDER_LIMIT);
        GeneralPath clippingSquare = createFloorBox(entityRenderOrigin, ENTITY_RENDER_LIMIT * 2 + 1, ENTITY_RENDER_LIMIT * 2+ 1);  // simple clipping area

        Canvas screen = client.getCanvas();
        final Rectangle2D fullScreen = new Rectangle2D.Float(0, 0, screen.getWidth(), screen.getHeight());

        // draw inside square
        Stroke stroke = new BasicStroke(2);
        Color inside_border = captureArea.getColor();
        Color inside_fillColor = ColorUtil.colorWithAlpha(inside_border, 255);
        graphics.setClip(clippingSquare);
        graphics.setStroke(stroke);
        graphics.setColor(inside_border);
        graphics.fill(outerSquare);
        graphics.setColor(inside_fillColor);
        graphics.draw(outerSquare);

        //draw the outside square
        Area insideClip = new Area(fullScreen);
        Color outside_border = negateColor(captureArea.getColor());
        Color outside_fillColor = ColorUtil.colorWithAlpha(outside_border, 255);

        insideClip.subtract(new Area(clippingSquare));
        graphics.setClip(insideClip);
        graphics.setStroke(stroke);
        graphics.setColor(outside_border);
        graphics.fill(outerSquare);
        graphics.setColor(outside_fillColor);
        graphics.draw(outerSquare);

        graphics.setClip(fullScreen);
        paintText(graphics, captureArea, inside_border);
    }

    private GeneralPath createFloorBox(WorldPoint origin, int width, int height)
    {
        GeneralPath path = new GeneralPath();

        pointDrawn = false;
        drawWestLine(path, height, origin);
        drawNorthLine(path, width, origin.dy(height));
        drawEastLine(path, height, origin.dx(width).dy(height));
        drawSouthLine(path, width, origin.dx(width));

        if(pointDrawn) {
            path.closePath();
        }
        return path;
    }

    private void drawWestLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int y_offset = 0; y_offset < length; y_offset++) {
            LocalPoint startPoint = toLocalPoint( x, y + y_offset);
            if(startPoint == null) {
                continue;
            }
            LocalPoint endPoint = startPoint.dy(LOCAL_TILE_SIZE -1);
            if(y_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawNorthLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int x_offset = 0; x_offset < length; x_offset++) {
            LocalPoint startPoint = toLocalPoint(x + x_offset, y);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dy(-1);
            LocalPoint endPoint = startPoint.dx(LOCAL_TILE_SIZE -1);
            if(x_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawEastLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int y_offset = 0; y_offset < length; y_offset++) {
            LocalPoint startPoint = toLocalPoint(x, y - y_offset);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dy(-1);
            startPoint = startPoint.dx(-1);
            LocalPoint endPoint = startPoint.dy(-(LOCAL_TILE_SIZE -1));
            if(y_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawSouthLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int x_offset = 0; x_offset < length; x_offset++) {
            LocalPoint startPoint = toLocalPoint(x - x_offset, y);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dx(-1);
            LocalPoint endPoint = startPoint.dx(-(LOCAL_TILE_SIZE -1));
            if(x_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void paintText(Graphics2D graphics, CaptureArea captureArea, Color color) {
        if(captureArea.isLabelVisible()) {
            //draw the label in the middle of the capture area
            WorldPoint areaCenter = captureArea.getWorldPoint().dx(captureArea.getWidth() / 2).dy(captureArea.getHeight() / 2);
            LocalPoint localPoint = toLocalPoint(areaCenter.getX(), areaCenter.getY(), true);
            if (localPoint != null) {
                if (captureArea.getWidth() % 2 == 0) {
                    localPoint = localPoint.dx(-LOCAL_TILE_SIZE / 2);
                }
                if (captureArea.getHeight() % 2 == 0) {
                    localPoint = localPoint.dy(-LOCAL_TILE_SIZE / 2);
                }

                graphics.setColor(ColorUtil.colorWithAlpha(color, 255));
                graphics.setFont(FontManager.getRunescapeFont());
                Point textLoc = Perspective.getCanvasTextLocation(client, graphics, localPoint, captureArea.getLabel(), 0);
                if (textLoc != null) {
                    graphics.drawString(captureArea.getLabel(), textLoc.getX(), textLoc.getY());
                }
            }
        }
    }

    private void paintPoint(GeneralPath path, LocalPoint localPoint, int z){
        if (localPoint == null)
            return;

        Point canvasPoint = toCanvasPoint(localPoint, z);
        if(canvasPoint == null)
            return;

        if (pointDrawn) {
            path.lineTo(canvasPoint.getX(), canvasPoint.getY());
        } else {
            path.moveTo(canvasPoint.getX(), canvasPoint.getY());
            pointDrawn = true;
        }
    }

    private LocalPoint toLocalPoint(int x, int y)
    {
        return toLocalPoint(x, y, false);
    }

    private LocalPoint toLocalPoint(int x, int y, boolean getCenter)
    {
        LocalPoint localPointCenter = LocalPoint.fromWorld(client.getTopLevelWorldView(), x, y);
        if(localPointCenter == null) {
            return null;
        }
        if (getCenter) {
            return localPointCenter;
        }
        return localPointCenter.plus(- LOCAL_TILE_SIZE / 2, - LOCAL_TILE_SIZE / 2);
    }

    private Point toCanvasPoint(LocalPoint localPoint, int z) {
        return Perspective.localToCanvas(
                client,
                localPoint,
                //new LocalPoint(localPoint.getX() - LOCAL_TILE_SIZE / 2, localPoint.getY() - LOCAL_TILE_SIZE / 2),
                z);
    }

    private Color negateColor(Color color) {
        final int maxColor = ColorUtil.MAX_RGB_VALUE;
        return new Color(maxColor - color.getRed(),
                    maxColor - color.getGreen(),
                    maxColor - color.getBlue(),
                    color.getAlpha()
                );
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.GamePanel;

import com.github.jeromkiller.HideAndSeekTracker.Util.HideAndSeekSettings;
import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.HideAndSeekTable;
import lombok.Getter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;
import java.util.List;

public class GameTotalPanel extends BasePanel {
    private final JLabel roundTitle;
    private final HideAndSeekTable resultTable;
    private final JLabel copyResultButton = new JLabel();
    private final JLabel importResultButton = new JLabel();
    private final JLabel exportResultButton = new JLabel();
    private final JLabel statusLabel = new JLabel(" ");

    @Getter
    private final HideAndSeekTrackerPlugin plugin;
    private final HideAndSeekSettings settings;
    private final GamePanel parentPanel;

    GameTotalPanel(HideAndSeekTrackerPlugin plugin, GamePanel parentPanel) {
        this.plugin = plugin;
        this.settings = plugin.getSettings();
        this.parentPanel = parentPanel;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 0, 0));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.anchor = GridBagConstraints.WEST;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.gridwidth = 1;

        roundTitle = new JLabel("Score Totals");
        contents.add(roundTitle, constraints);
        constraints.gridy++;

        resultTable = new HideAndSeekTable(plugin.game.getScoreTotals());
        resultTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.fill = GridBagConstraints.BOTH;
        constraints.weighty = 1;
        JScrollPane scrollPane = new JScrollPane(resultTable);
        contents.add(scrollPane, constraints);
        constraints.gridwidth = 1;
        constraints.gridy++;
        constraints.weighty = 0;

        JPanel bottomButtonPanel = new JPanel(new GridBagLayout());
        GridBagConstraints bottomConstraints = new GridBagConstraints();

        setupImageIcon(copyResultButton, "Copy score totals to clipboard", COPY_ICON, COPY_ICON_HOVER, this::plainTextExport);
        setupImageIcon(exportResultButton, "Export all round data to clipboard", EXPORT_ICON, EXPORT_ICON_HOVER, this::exportRounds);
        setupImageIcon(importResultButton, "Import round data from clipboard", IMPORT_ICON, IMPORT_ICON_HOVER, plugin::importRoundFromClip);

        bottomConstraints.gridx = 0;
        bottomConstraints.ipadx = 4;
        bottomButtonPanel.add(copyResultButton, bottomConstraints);
        bottomConstraints.gridx = 1;
        bottomButtonPanel.add(exportResultButton, bottomConstraints);
        bottomConstraints.gridx = 2;
        bottomButtonPanel.add(importResultButton, bottomConstraints);

        JPanel bottomButtonWrapper = new JPanel(new BorderLayout());
        bottomButtonWrapper.add(bottomButtonPanel, BorderLayout.LINE_END);
        constraints.gridx = 1;
        contents.add(bottomButtonWrapper, constraints);
        constraints.gridy++;

        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.insets = new Insets(0, 2, 0, 2);
        contents.add(statusLabel, constraints);
        statusLabel.setHorizontalAlignment(JLabel.RIGHT);

        add(contents);
        updateHidePlayers();
        updatePlacements();
    }

    private void plainTextExport() {
        final String exportString = plugin.game.totalScoreExport();
        final StringSelection selection = new StringSelection(exportString);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(selection, selection);
        setCopiedText("Copied to clipboard!");
    }

    private void setCopiedText(String text) {
        statusLabel.setText(text);
        Timer hideStatusTimer = new Timer(1000, e -> statusLabel.setText(" "));
        hideStatusTimer.setRepeats(false);
        hideStatusTimer.start();
    }

    public void updatePlacements()
    {
        plugin.game.recalculateTotalScores();
        SwingUtilities.invokeLater(resultTable::update);
    }

    public void updateHidePlayers() {
        final boolean hide = settings.getHideUnfinished();
        resultTable.enableHidenPlayerFilter(hide);
    }

    public void exportRounds() {
        int num_rounds = plugin.game.getPastRounds().size();
        List<Integer> exportRounds = new ArrayList<>(num_rounds);
        for(int i = 0; i < num_rounds; i++) {
            exportRounds.add(i);
        }
        if(plugin.game.getActiveRound().isRoundStarted()) {
            exportRounds.add(num_rounds);
        }

        plugin.exportRoundToClip(exportRounds);
        setCopiedText("Exported All rounds to clipboard!");
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.GamePanel;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;
import com.github.jeromkiller.HideAndSeekTracker.Util.HideAndSeekSettings;
import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.HideAndSeekTable;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.util.ArrayList;

public class GameRoundPanel extends BasePanel {
    private final JLabel roundTitle;
    private final JSpinner hintCount;
    private final HideAndSeekTable resultTable;
    private final JLabel numFinished = new JLabel("999/999 Finished");
    private final JLabel copyResultButton = new JLabel();
    private final JLabel importResultButton = new JLabel();
    private final JLabel exportResultButton = new JLabel();
    private final JLabel newRoundButton = new JLabel();
    private final JLabel deleteRoundButton = new JLabel();
    private final JLabel statusLabel = new JLabel(" ");
    private final JButton btnStartRound;
    private final JLabel roundTimeLabel = new JLabel();

    @Getter
    private final HideAndSeekRound gameRound;
    private final HideAndSeekTrackerPlugin plugin;
    private final GamePanel parentPanel;
    private final HideAndSeekSettings settings;

    @Getter
    private boolean roundFinished = false;

    GameRoundPanel(HideAndSeekTrackerPlugin plugin, GamePanel parentPanel, HideAndSeekRound round) {
        this.plugin = plugin;
        this.gameRound = round;
        this.parentPanel = parentPanel;
        this.settings = plugin.getSettings();

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 0, 1));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.anchor = GridBagConstraints.WEST;
        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.gridwidth = 1;

        roundTitle = new JLabel();
        contents.add(roundTitle, constraints);

        JPanel roundButtonPanel = new JPanel(new GridBagLayout());
        GridBagConstraints roundButtonConstraints = new GridBagConstraints();

        setupImageIcon(deleteRoundButton, "Delete this round", DELETE_ROUND_ICON, DELETE_ROUND_ICON_HOVER, this::deleteRound);
        setupImageIcon(newRoundButton, "Start new round",NEW_ROUND_ICON, NEW_ROUND_ICON_HOVER, parentPanel::newRound);
        roundButtonConstraints.anchor = GridBagConstraints.EAST;
        roundButtonConstraints.gridx = 0;
        roundButtonPanel.add(deleteRoundButton, roundButtonConstraints);
        roundButtonConstraints.gridx = 1;
        roundButtonPanel.add(newRoundButton, roundButtonConstraints);

        deleteRoundButton.setVisible(false);

        constraints.gridx = 1;
        constraints.anchor = GridBagConstraints.EAST;
        JPanel roundButtonPanelContainer = new JPanel(new BorderLayout());
        roundButtonPanelContainer.add(roundButtonPanel, BorderLayout.LINE_END);
        contents.add(roundButtonPanelContainer, constraints);

        constraints.anchor = GridBagConstraints.WEST;
        constraints.gridx = 0;
        constraints.gridy++;

        constraints.gridx = 0;
        contents.add(new JLabel("Round Time:"), constraints);
        constraints.gridx = 1;
        btnStartRound = new JButton("Start Round");
        btnStartRound.addActionListener(e -> startRound());
        contents.add(btnStartRound, constraints);
        roundTimeLabel.setFont(FontManager.getDefaultFont());
        roundTimeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        roundTimeLabel.setVisible(false);
        roundTimeLabel.setBorder(new CompoundBorder(new LineBorder(ColorScheme.BORDER_COLOR), new EmptyBorder(1,0,0,0)));
        contents.add(roundTimeLabel, constraints);
        updateRoundTimer(0);
        constraints.gridy++;
        constraints.gridx = 0;

        JLabel txt_hints = new JLabel("Hints Given:");
        txt_hints.setFont(FontManager.getRunescapeFont());
        txt_hints.setHorizontalAlignment(SwingConstants.LEFT);
        contents.add(txt_hints, constraints);

        constraints.gridx = 1;
        hintCount = new JSpinner(new SpinnerNumberModel(1, 1, 100, 1));
        hintCount.addChangeListener(e -> updateHintCount());
        contents.add(hintCount, constraints);
        constraints.gridy++;
        constraints.gridx = 0;

        resultTable = new HideAndSeekTable(gameRound.getParticipants());
        resultTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
        constraints.gridwidth = 2;
        constraints.fill = GridBagConstraints.BOTH;
        constraints.weightx = 1;
        constraints.weighty = 1;
        JScrollPane scrollPane = new JScrollPane(resultTable);
        contents.add(scrollPane, constraints);
        constraints.gridwidth = 1;
        constraints.gridy++;
        constraints.weighty = 0;
        constraints.weightx = 0;

        contents.add(numFinished, constraints);

        JPanel bottomButtonPanel = new JPanel(new GridBagLayout());
        GridBagConstraints bottomConstraints = new GridBagConstraints();

        setupImageIcon(copyResultButton, "Copy results to clipboard", COPY_ICON, COPY_ICON_HOVER, this::plainTextExport);
        setupImageIcon(exportResultButton, "Export round data to clipboard", EXPORT_ICON, EXPORT_ICON_HOVER, this::exportRound);
        setupImageIcon(importResultButton, "Import round data from clipboard", IMPORT_ICON, IMPORT_ICON_HOVER, plugin::importRoundFromClip);

        bottomConstraints.gridx = 0;
        bottomConstraints.ipadx = 4;
        bottomButtonPanel.add(copyResultButton, bottomConstraints);
        bottomConstraints.gridx = 1;
        bottomButtonPanel.add(exportResultButton, bottomConstraints);
        bottomConstraints.gridx = 2;
        bottomButtonPanel.add(importResultButton, bottomConstraints);

        JPanel bottomButtonWrapper = new JPanel(new BorderLayout());
        bottomButtonWrapper.add(bottomButtonPanel, BorderLayout.LINE_END);
        constraints.gridx = 1;
        contents.add(bottomButtonWrapper, constraints);
        constraints.gridy++;

        constraints.gridx = 0;
        constraints.gridwidth = 2;
        constraints.insets = new Insets(0, 2, 0, 2);
        contents.add(statusLabel, constraints);
        statusLabel.setHorizontalAlignment(JLabel.RIGHT);

        add(contents);
        updateHidePlayers();
        updatePlacements();
        updateRoundLabel();
    }

    private void plainTextExport() {
        final String exportString = gameRound.plainTextExport();
        final StringSelection selection = new StringSelection(exportString);
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(selection, selection);
        setCopiedText("Copied to clipboard");
    }

    private void setCopiedText(String text) {
        statusLabel.setText(text);
        Timer hideStatusTimer = new Timer(1000, e -> statusLabel.setText(" "));
        hideStatusTimer.setRepeats(false);
        hideStatusTimer.start();
    }

    private void updateHintCount()
    {
        gameRound.setHintsGiven((Integer) hintCount.getValue());
    }

    public void updatePlacements()
    {
        SwingUtilities.invokeLater(() -> {
            resultTable.update();
            updateNumFinished();
        });
    }

    private void updateNumFinished()
    {
        final int numPlaced = gameRound.getNumPlaced();
        final int numPlayers = gameRound.getNumParticipants();

        int roundFinishedPercentage = 0;
        if(numPlayers > 0) {
            roundFinishedPercentage = (int) (((double)numPlaced / (double)numPlayers) * 100);
        }
        String placedString = gameRound.getNumPlaced() +
                " / " +
                gameRound.getNumParticipants() +
                " Finished (" +
                roundFinishedPercentage +
                "%)";
        numFinished.setText(placedString);
    }

    public void updateRoundLabel() {
        String roundText = "Round: " + gameRound.getRoundNumber();
        if(!roundFinished) {
            roundText += " (Active)";
        }
        roundTitle.setText(roundText);
    }

    public void roundFinished() {
        roundFinished = true;
        updateRoundLabel();
        hintCount.setEnabled(false);
        deleteRoundButton.setVisible(true);
        newRoundButton.setVisible(false);
        btnStartRound.setVisible(false);
        roundTimeLabel.setVisible(true);
    }

    public void updateHidePlayers() {
        final boolean hide = settings.getHideUnfinished();
        resultTable.enableHidenPlayerFilter(hide);
    }

    public void deleteRound() {
        int confirm = JOptionPane.showConfirmDialog(GameRoundPanel.this,
                "Are you sure you want to permanently delete this round?",
                "Warning", JOptionPane.OK_CANCEL_OPTION);

        if(confirm != 0) {
            return;
        }

        final int roundNumber = gameRound.getRoundNumber() - 1;
        plugin.game.deleteRound(roundNumber);
        parentPanel.deleteRound(roundNumber);
        parentPanel.relabelRounds();
    }

    public void startRound() {
        plugin.game.startRound();
        btnStartRound.setVisible(false);
        roundTimeLabel.setVisible(true);
    }

    public void updateRoundTimer(int ticks) {
        SwingUtilities.invokeLater(() -> {
            roundTimeLabel.setText(ticksToTime(ticks));
        });
    }

    public void updateHints(int hints) {
        SwingUtilities.invokeLater(() -> {
            hintCount.setValue(hints);
        });
    }

    public String ticksToTime(int ticks) {
        int hours = ticks / 6000;
        ticks = ticks % 6000;
        int minutes = ticks / 100;
        ticks = ticks % 100;
        double rest = ticks * 0.6;
        return String.format("%02d:%02d:%04.1f ", hours, minutes, rest);
    }

    public void exportRound() {
        String[] options = {"Yes", "No, only this round", "Cancel"};
        int confirm = JOptionPane.showOptionDialog(GameRoundPanel.this,
                "Do you want to export all rounds to your clipboard?",
                "Confirm", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, options, options[0]);

        switch (confirm) {
            case 0: {
                int num_rounds = plugin.game.getPastRounds().size();
                java.util.List<Integer> exportRounds = new ArrayList<>(num_rounds);
                for(int i = 0; i < num_rounds; i++) {
                    exportRounds.add(i);
                }
                if(plugin.game.getActiveRound().isRoundStarted()) {
                    exportRounds.add(num_rounds);
                }
                plugin.exportRoundToClip(exportRounds);
                setCopiedText("Exported All rounds to Clipboard!");
                break;
            }
            case 1: {
                plugin.exportRoundToClip(java.util.List.of(gameRound.getRoundNumber() -1));
                setCopiedText("Exported this round to Clipboard!");
                break;
            }
        }


    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.GamePanel;


import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;
import lombok.Getter;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.LinkedList;

public class GamePanel extends BasePanel {
    private final HideAndSeekTrackerPlugin plugin;

    private int currentCardIndex;

    private final JPanel cardsPanel;
    private final CardLayout roundCards;
    private final LinkedList<GameRoundPanel> roundPanels;
    private final JLabel prevTableButton = new JLabel();
    private final JLabel nextTableButton = new JLabel();
    private final JButton activeRoundButton;
    private final JButton scoreTotalButton;

    @Getter
    private GameRoundPanel activeRoundPanel;
    private final GameTotalPanel scoreTotalPanel;

    public GamePanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.currentCardIndex = 0;
        this.roundPanels = new LinkedList<>();

        setLayout(new GridBagLayout());
        setBorder(new EmptyBorder(5, 0, 0, 0));

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        JPanel topButtons = new JPanel();
        topButtons.setLayout(new GridBagLayout());
        GridBagConstraints topButtonConstraints = new GridBagConstraints();
        topButtonConstraints.fill = GridBagConstraints.NONE;

        setupImageIcon(prevTableButton, "View previous round", ARROW_LEFT_ICON, ARROW_LEFT_HOVER_ICON, () -> {
            if(prevTableButton.isEnabled()) {
                prevRound();
            }
        });

        activeRoundButton = new JButton("Active Round");
        activeRoundButton.addActionListener(e -> activeRound());

        scoreTotalButton = new JButton("Score Total");
        scoreTotalButton.addActionListener(e -> scoreTotal());

        setupImageIcon(nextTableButton, "View next round", ARROW_RIGHT_ICON, ARROW_RIGHT_HOVER_ICON, () -> {
            if(nextTableButton.isEnabled()) {
                nextRound();
            }
        });

        topButtonConstraints.fill = GridBagConstraints.NONE;
        topButtonConstraints.weightx = 0;
        topButtons.add(prevTableButton, topButtonConstraints);
        topButtonConstraints.gridx = 1;
        topButtonConstraints.fill = GridBagConstraints.HORIZONTAL;
        topButtonConstraints.weightx = 1;
        topButtons.add(activeRoundButton, topButtonConstraints);
        topButtonConstraints.gridx = 2;
        topButtons.add(scoreTotalButton, topButtonConstraints);
        topButtonConstraints.gridx = 3;
        topButtonConstraints.weightx = 0;
        topButtonConstraints.fill = GridBagConstraints.NONE;
        topButtons.add(nextTableButton, topButtonConstraints);
        this.add(topButtons, constraints);
        constraints.gridy++;

        roundCards = new CardLayout();
        cardsPanel = new JPanel(roundCards);

        scoreTotalPanel = new GameTotalPanel(plugin, this);
        cardsPanel.add(scoreTotalPanel);

        activeRoundPanel = new GameRoundPanel(plugin, this, plugin.game.getActiveRound());
        addRoundPanel(activeRoundPanel);

        constraints.fill = GridBagConstraints.BOTH;
        constraints.weighty = 1;
        this.add(cardsPanel, constraints);

        activeRound();
    }

    private void addRoundPanel(JPanel panel) {
        cardsPanel.add(activeRoundPanel, cardsPanel.getComponentCount() - 1);
        roundPanels.add(activeRoundPanel);
    }

    public void importRound(HideAndSeekRound round) {
        GameRoundPanel importedPanel = new GameRoundPanel(plugin, this, round);
        importedPanel.roundFinished();
        importedPanel.updateRoundTimer(round.getGameTime());
        importedPanel.updateHints(round.getHintsGiven());

        // add before active round
        cardsPanel.add(importedPanel, cardsPanel.getComponentCount() - 2);
        roundPanels.add(roundPanels.size() - 1, importedPanel);

        activeRound();
    }

    private void firstRound() {
        roundCards.first(cardsPanel);
        currentCardIndex = 0;
        updateCardFlipButtons();
    }

    private void navTo(int index) {
        if(index >= cardsPanel.getComponentCount()) {
            return;
        }

        firstRound();
        for(int i = 0; i < index; i++) {
            roundCards.next(cardsPanel);
            currentCardIndex++;
        }
        updateCardFlipButtons();
    }

    private void prevRound() {
        roundCards.previous(cardsPanel);
        currentCardIndex -= 1;
        updateCardFlipButtons();
    }

    private void activeRound() {
        roundCards.last(cardsPanel);
        roundCards.previous(cardsPanel);
        currentCardIndex = cardsPanel.getComponentCount() - 2;
        updateCardFlipButtons();
    }

    private void scoreTotal() {
        roundCards.last(cardsPanel);
        currentCardIndex = cardsPanel.getComponentCount() - 1;
        updateCardFlipButtons();
    }

    private void nextRound() {
        roundCards.next(cardsPanel);
        currentCardIndex += 1;
        updateCardFlipButtons();
    }

    public void newRound() {
        plugin.game.newRound();
        activeRoundPanel.roundFinished();
        activeRoundPanel = new GameRoundPanel(plugin, this, plugin.game.getActiveRound());
        addRoundPanel(activeRoundPanel);
        activeRound();
    }

    private void updateCardFlipButtons(){
        final boolean notAtFirst = currentCardIndex > 0;
        final boolean notAtLast = currentCardIndex < cardsPanel.getComponentCount() - 1;
        final boolean notAtSecondToLast = currentCardIndex != cardsPanel.getComponentCount() - 2;
        prevTableButton.setEnabled(notAtFirst);
        nextTableButton.setEnabled(notAtLast);
        activeRoundButton.setEnabled(notAtSecondToLast);
        scoreTotalButton.setEnabled(notAtLast);
    }

    public void updatePlacements() {
        activeRoundPanel.updatePlacements();
        scoreTotalPanel.updatePlacements();
    }

    public void updateAllPlacements() {
        updatePlacements();
        for(GameRoundPanel panel : roundPanels) {
            panel.updatePlacements();
        }
    }

    public void updateHidePlayerSetting() {
        for(GameRoundPanel panel : roundPanels){
            panel.updateHidePlayers();
        }
    }

    public void deleteRound(int index) {
        roundPanels.remove(index);
        cardsPanel.remove(index);
        navTo(index);
        invalidate();
        repaint();
    }

    public void relabelRounds() {
        for(GameRoundPanel panel : roundPanels) {
            panel.updateRoundLabel();
        }
    }

    public void updateTimer(int tick) {
        activeRoundPanel.updateRoundTimer(tick);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import javax.swing.*;
import javax.swing.text.DefaultFormatter;
import javax.swing.text.DefaultFormatterFactory;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;

public class NameScoreTextEntry extends JFormattedTextField implements FocusListener {
    public NameScoreTextEntry(String value) {
        DefaultFormatter formatter = new DefaultFormatter();
        formatter.setAllowsInvalid(true);
        formatter.setCommitsOnValidEdit(true);

        AbstractFormatterFactory formatterFactory = new DefaultFormatterFactory(formatter);
        setFormatterFactory(formatterFactory);

        setValue(value);
    }

    @Override
    public void focusGained(FocusEvent e) {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                selectAll();
            }
        });
    }

    @Override
    public void focusLost(FocusEvent e) {

    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import lombok.Getter;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class BlinklessToggleButton extends JLabel {
    final ImageIcon selectedIcon;
    final ImageIcon selectedIconHover;
    final ImageIcon deselectedIcon;
    final ImageIcon deselectedIconHover;
    final String selectedTooltipText;
    final String deselectedTooltipText;

    @Getter
    boolean selected = false;

    public BlinklessToggleButton(ImageIcon selectedIcon, ImageIcon selectedIconHover,
                                 ImageIcon deselectedIcon, ImageIcon deselectedIconHover,
                                 String selectedTooltipText, String deselectedTooltipText) {
        this.selectedIcon = selectedIcon;
        this.selectedIconHover = selectedIconHover;
        this.deselectedIcon = deselectedIcon;
        this.deselectedIconHover = deselectedIconHover;
        this.selectedTooltipText = selectedTooltipText;
        this.deselectedTooltipText = deselectedTooltipText;

        updateSelected();

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(selected ? selectedIconHover : deselectedIconHover);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(selected ? selectedIcon : deselectedIcon);
            }
        });
    }

    public BlinklessToggleButton(String selectedTooltipText) {
        this.selectedIcon = BasePanel.ON_SWITCHER;
        this.selectedIconHover = BasePanel.ON_SWITCHER_HOVER;
        this.deselectedIcon = BasePanel.OFF_SWITCHER;
        this.deselectedIconHover = BasePanel.OFF_SWITCHER_HOVER;
        this.selectedTooltipText = selectedTooltipText;
        this.deselectedTooltipText = selectedTooltipText;

        updateSelected();

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(selected ? selectedIconHover : deselectedIconHover);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(selected ? selectedIcon : deselectedIcon);
            }
        });
    }

    public void setSelected(boolean selected) {
        this.selected = selected;
        updateSelected();
    }

    public void addItemListener(Runnable runnable) {
        addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                selected = !selected;
                updateSelected();
                runnable.run();
            }
        });
    }

    private void updateSelected() {
        setIcon(selected ? selectedIcon : deselectedIcon);
        setToolTipText(selected ? selectedTooltipText : deselectedTooltipText);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import javax.swing.table.DefaultTableCellRenderer;
import java.awt.*;

public class HideAndSeekPlacementRenderer extends DefaultTableCellRenderer {
    Color defaultColor;

    public HideAndSeekPlacementRenderer() {
        super();
        defaultColor = getForeground();
    }

    public void setValue(Object value) {
        String text = (String)value;
        Color printColor = defaultColor;

        if(text.contains("ü•á")) {
            printColor = Color.ORANGE;
        } else if (text.contains("ü•à")) {
            printColor = Color.LIGHT_GRAY;
        } else if (text.contains("ü•â")) {
            printColor = new Color(205, 127, 50);
        }

        setForeground(printColor);
        setText(text);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;

import javax.swing.*;
import javax.swing.table.TableRowSorter;
import java.util.HashMap;

public class HideAndSeekTable extends JTable {
    final TableRowSorter<HideAndSeekTableModel> sorter;

    public HideAndSeekTable(HashMap<String, HideAndSeekPlayer> data)
    {
        super(new HideAndSeekTableModel(data));
        sorter = new TableRowSorter<>(model());
        setRowSorter(sorter);
        setDefaultRenderer(String.class, new HideAndSeekPlacementRenderer() );
        setFillsViewportHeight(true);
    }

    public void update()
    {
        HideAndSeekTableModel model = model();
        model.update();
        getColumnModel().getColumn(0).setMinWidth(1);
        getColumnModel().getColumn(0).setMaxWidth(1);
        getColumnModel().getColumn(1).setMinWidth(90);
        this.getRowSorter().toggleSortOrder(0);
    }

    public HideAndSeekTableModel model()
    {
        return (HideAndSeekTableModel) getModel();
    }

    public void enableHidenPlayerFilter(boolean enable) {
        if(enable) {
            RowFilter<HideAndSeekTableModel, Object> filter = RowFilter.numberFilter(RowFilter.ComparisonType.NOT_EQUAL, Integer.MAX_VALUE, 0, 1);
            sorter.setRowFilter(filter);
        } else {
            sorter.setRowFilter(null);
        }
        update();
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import javax.swing.*;
import javax.swing.text.DefaultFormatterFactory;
import javax.swing.text.NumberFormatter;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.text.NumberFormat;

public class PercentileScoreTextEntry extends JFormattedTextField implements FocusListener {
    private final int maxValue;
    private final JFormattedTextField.AbstractFormatterFactory formatterFactory;

    public PercentileScoreTextEntry(int value, int maxValue) {
        this.maxValue = maxValue;
        setValue(value);
        setText(toPresentation());

        // formating rules for the setting box
        NumberFormatter formatter = new NumberFormatter(NumberFormat.getInstance());
        formatter.setValueClass(Integer.class);
        formatter.setMinimum(0);
        formatter.setMaximum(maxValue);
        formatter.setAllowsInvalid(true);
        formatter.setCommitsOnValidEdit(true);

        formatterFactory = new DefaultFormatterFactory(formatter);

        super.addFocusListener(this);
    }

    private String toPresentation() {
        StringBuilder presentation = new StringBuilder();
        final int value = (int)getValue();
        if (value == maxValue) {
            presentation.append(value);
        } else {
            presentation.append(maxValue);
            presentation.append(" - ");
            presentation.append(value);
        }
        presentation.append("%");
        return presentation.toString();
    }

    @Override
    public void focusGained(FocusEvent e) {
        setFormatterFactory(formatterFactory);
        setText(String.valueOf(getValue()));
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                selectAll();
            }
        });
    }

    @Override
    public void focusLost(FocusEvent e) {
        setFormatterFactory(null);
        setText(toPresentation());
    }

}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekPlayer;

import javax.swing.table.AbstractTableModel;
import java.util.ArrayList;
import java.util.HashMap;

public class HideAndSeekTableModel extends AbstractTableModel {
    private final String[] columnNames = {"#", "Name", "Place", "Points"};
    private final HashMap<String, HideAndSeekPlayer> data;

    HideAndSeekTableModel(HashMap<String, HideAndSeekPlayer> data)
    {
        this.data = data;
    }

    @Override
    public int getRowCount()
    {
        return data.size();
    }

    @Override
    public int getColumnCount()
    {
        return columnNames.length;
    }

    public String getColumnName(int col)
    {
        return columnNames[col];
    }

    public Object getValueAt(int row, int col)
    {
        ArrayList<HideAndSeekPlayer> list = new ArrayList<>(data.values());
        if(row >= list.size())
        {
            return 0;
        }
        return list.get(row).getValue(col);
    }

    public Class<?> getColumnClass(int c)
    {
        return getValueAt(0, c).getClass();
    }

    public void update()
    {
        fireTableStructureChanged();
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import javax.swing.*;
import javax.swing.text.DefaultFormatterFactory;
import javax.swing.text.NumberFormatter;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.text.NumberFormat;

public class NumberScoreTextEntry extends JFormattedTextField implements FocusListener {
    private final int minValue;
    private final AbstractFormatterFactory formatterFactory;

    public NumberScoreTextEntry(int value, int minValue) {
        this.minValue = minValue;
        setValue(value);
        setText(toPresentation());

        // formating rules for the setting box
        NumberFormatter formatter = new NumberFormatter(NumberFormat.getInstance());
        formatter.setValueClass(Integer.class);
        formatter.setMinimum(minValue);
        formatter.setMaximum(Integer.MAX_VALUE);
        formatter.setAllowsInvalid(true);
        formatter.setCommitsOnValidEdit(true);

        formatterFactory = new DefaultFormatterFactory(formatter);
        
        super.addFocusListener(this);
    }

    private String toPresentation() {
        StringBuilder presentation = new StringBuilder();
        final int value = (int)getValue();
        if (value == minValue) {
            presentation.append(value);
        } else {
            presentation.append(minValue);
            presentation.append(" - ");
            presentation.append(value);
        }
        return presentation.toString();
    }

    @Override
    public void focusGained(FocusEvent e) {
        setFormatterFactory(formatterFactory);
        setText(String.valueOf(getValue()));
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                selectAll();
            }
        });
    }

    @Override
    public void focusLost(FocusEvent e) {
        setFormatterFactory(null);
        setText(toPresentation());
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets;

import javax.swing.*;
import javax.swing.text.DateFormatter;
import javax.swing.text.DefaultFormatterFactory;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.text.SimpleDateFormat;
import java.time.*;
import java.time.format.DateTimeFormatter;

public class TimeScoreTextEntry extends JFormattedTextField implements FocusListener {
    private final AbstractFormatterFactory formatterFactory;

    public TimeScoreTextEntry(LocalTime value, LocalTime minValue) {
        super.setValue(value);
        super.setText("< " + toPresentation());

        DateFormatter formatter = new DateFormatter(new SimpleDateFormat("HH:mm:ss"));
        formatter.setMinimum(minValue);
        formatter.setMaximum(LocalTime.of(5, 59, 59));
        formatter.setFormat(DateTimeFormatter.ofPattern("HH:mm:ss").toFormat(LocalTime::from));
        formatter.setAllowsInvalid(true);
        formatter.setCommitsOnValidEdit(true);

        formatterFactory = new DefaultFormatterFactory(formatter);

        super.addFocusListener(this);
    }

    private String toPresentation() {
        return getValue().format(DateTimeFormatter.ofPattern("HH:mm:ss"));
    }

    @Override
    public void focusGained(FocusEvent e) {
        setFormatterFactory(formatterFactory);
        setText(toPresentation());
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                selectAll();
            }
        });
    }

    @Override
    public void focusLost(FocusEvent e) {
        setFormatterFactory(null);
        setText(toPresentation());
    }

    @Override
    public LocalTime getValue() {
        return (LocalTime) super.getValue();
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.BlinklessToggleButton;
import com.github.jeromkiller.HideAndSeekTracker.Util.HideAndSeekSettings;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class SettingsPanel extends BasePanel {
    private final JSpinner tickLeniency = new JSpinner(new SpinnerNumberModel(2, 0, 100, 1));
    private final BlinklessToggleButton showRenderDist;
    private final BlinklessToggleButton hideOverlay;
    private final BlinklessToggleButton hideUnfinishedPlayers;

    private final HideAndSeekTrackerPlugin plugin;
    private final HideAndSeekSettings settings;

    public SettingsPanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.settings = plugin.getSettings();

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 10, 0));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);

        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.weightx = 1;

        tickLeniency.addChangeListener(e -> settings.setTickLenience((int) tickLeniency.getValue()));
        addSettingRow("Placement Leniency Ticks", tickLeniency, contents, constraints);

        hideUnfinishedPlayers = new BlinklessToggleButton("Show Render Distance");
        hideUnfinishedPlayers.setSelected(settings.getHideUnfinished());
        hideUnfinishedPlayers.addItemListener(() -> settings.setHideUnfinished(hideUnfinishedPlayers.isSelected()));
        addSettingRow("Hide Unfinished Players", hideUnfinishedPlayers, contents, constraints);

        hideOverlay = new BlinklessToggleButton("Hide the in game overlay. \nCapture areas previously set to 'visible' are still enabled");
        hideOverlay.setSelected(settings.getHideOverlay());
        hideOverlay.addItemListener(() -> {
            settings.setHideOverlay(hideOverlay.isSelected());
            updateDisabledButtons();
        });
        addSettingRow("Hide Overlay", hideOverlay, contents, constraints);

        showRenderDist = new BlinklessToggleButton("Show Render Distance");
        showRenderDist.setSelected(settings.getShowRenderDist());
        showRenderDist.addItemListener(() -> settings.setShowRenderDist(showRenderDist.isSelected()));
        addSettingRow("Show Render Distance", showRenderDist, contents, constraints);

        add(contents, BorderLayout.NORTH);
        loadSettings();
    }

    private void addSettingRow(String text, JComponent component, JPanel container, GridBagConstraints constraints) {
        constraints.gridx = 0;
        constraints.anchor = GridBagConstraints.WEST;
        container.add(new JLabel(text), constraints);
        constraints.gridx = 1;
        constraints.anchor = GridBagConstraints.EAST;
        container.add(component, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
    }

    public void loadSettings() {
        final int tickLeniencySetting = settings.getTickLenience();
        tickLeniency.setValue(tickLeniencySetting);

        final boolean showRenderDistSetting = settings.getShowRenderDist();
        showRenderDist.setSelected(showRenderDistSetting);

        final boolean hideUnfinishedPlayersSetting = settings.getHideUnfinished();
        hideUnfinishedPlayers.setSelected(hideUnfinishedPlayersSetting);

        updateDisabledButtons();
    }

    public void updateDisabledButtons() {
        showRenderDist.setEnabled(!settings.getHideOverlay());
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.CaptureArea;

import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

@Data
@NoArgsConstructor
public class CaptureCreationOptions {
    private static final String DEFAULT_AREA_NAME = "Capture Area";
    public static int MAX_AREA_SIZE = 15;

    private boolean currentlyCreating = false;
    private int north = 1;
    private int east = 1;
    private int south = 1;
    private int west = 1;
    private String label = DEFAULT_AREA_NAME;
    Color color = ColorUtil.colorWithAlpha(Color.GREEN, 50);
    private boolean labelVisible = true;

    public void resetOptions() {
        currentlyCreating = false;
        north = 1;
        east = 1;
        south = 1;
        west = 1;
        label = DEFAULT_AREA_NAME;
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.CaptureArea;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class CaptureCreationPanel extends BasePanel {
    protected static final ImageIcon CREATE_ICON;
    protected static final ImageIcon CREATE_HOVER_ICON;
    protected static final ImageIcon CANCEL_ICON;
    protected static final ImageIcon CANCEL_HOVER_ICON;
    protected static final ImageIcon COMPASS_ICON;

    private final JLabel colorIndicator = new JLabel();
    private final JLabel labelIndicator = new JLabel();
    private final FlatTextField nameInput = new FlatTextField();
    private final JSpinner northSpinner = new JSpinner();
    private final JSpinner eastSpinner = new JSpinner();
    private final JSpinner southSpinner = new JSpinner();
    private final JSpinner westSpinner = new JSpinner();
    private final JLabel saveArea = new JLabel();
    private final JLabel cancelArea = new JLabel();
    private final JLabel warnLabel = new JLabel("‚ö† Area can be skipped over");

    private final CaptureCreationOptions captureOptions;
    private final HideAndSeekTrackerPlugin plugin;
    private boolean showLabel;

    static
    {
        final BufferedImage createImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "confirm_icon.png");
        final BufferedImage createImgHover = ImageUtil.alphaOffset(createImg, 0.5f);
        CREATE_ICON = new ImageIcon(createImg);
        CREATE_HOVER_ICON = new ImageIcon(createImgHover);

        final BufferedImage cancelImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "cancel_icon.png");
        final BufferedImage cancelImgHover = ImageUtil.alphaOffset(cancelImg, 0.5f);
        CANCEL_ICON = new ImageIcon(cancelImg);
        CANCEL_HOVER_ICON = new ImageIcon(cancelImgHover);

        final BufferedImage compassImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "compass.png");
        COMPASS_ICON = new ImageIcon(compassImg);
    }

    public CaptureCreationPanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.captureOptions = plugin.getCaptureCreationOptions();
        this.showLabel = captureOptions.isLabelVisible();

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);

        JPanel nameActions = new JPanel(new BorderLayout(3,0));
        nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        nameInput.setText(captureOptions.getLabel());
        nameInput.setBorder(null);
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setPreferredSize(new Dimension(0, 24));
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));

        nameWrapper.add(nameInput, BorderLayout.CENTER);
        nameWrapper.add(nameActions, BorderLayout.EAST);

        JPanel centerContainer = new JPanel(new BorderLayout());
        centerContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        centerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        centerContainer.setLayout(new GridBagLayout());
        GridBagConstraints centerConstraints = new GridBagConstraints();

        final int MAX_VALUE = CaptureCreationOptions.MAX_AREA_SIZE;
        final int MIN_VALUE = 0;
        northSpinner.setModel(new SpinnerNumberModel(captureOptions.getNorth(), MIN_VALUE, MAX_VALUE, 1));
        northSpinner.addChangeListener(e -> {
            final int val = (int) northSpinner.getValue();
            captureOptions.setNorth(val);
            validateArea();
        }
        );
        southSpinner.setModel(new SpinnerNumberModel(captureOptions.getSouth(), MIN_VALUE, MAX_VALUE, 1));
        southSpinner.addChangeListener(e -> {
                final int val = (int) southSpinner.getValue();
                captureOptions.setSouth(val);
                validateArea();
        });
        eastSpinner.setModel(new SpinnerNumberModel(captureOptions.getEast(), MIN_VALUE, MAX_VALUE, 1));
        eastSpinner.addChangeListener(e -> {
                final int val = (int) eastSpinner.getValue();
                captureOptions.setEast(val);
                validateArea();
        });
        westSpinner.setModel(new SpinnerNumberModel(captureOptions.getWest(), MIN_VALUE, MAX_VALUE, 1));
        westSpinner.addChangeListener(e -> {
                final int val = (int) westSpinner.getValue();
                captureOptions.setWest(val);
                validateArea();
        });
        JLabel compass = new JLabel();
        compass.setIcon(COMPASS_ICON);
        centerConstraints.gridx = 1;
        centerConstraints.gridy = 0;
        centerContainer.add(northSpinner, centerConstraints);
        centerConstraints.gridx = 0;
        centerConstraints.gridy = 1;
        centerContainer.add(westSpinner, centerConstraints);
        centerConstraints.gridx = 1;
        centerContainer.add(compass, centerConstraints);
        centerConstraints.gridx = 2;
        centerContainer.add(eastSpinner, centerConstraints);
        centerConstraints.gridx = 1;
        centerConstraints.gridy = 2;
        centerContainer.add(southSpinner, centerConstraints);
        centerConstraints.gridy = 3;
        centerConstraints.gridx = 0;
        centerConstraints.gridwidth = 3;
        warnLabel.setVisible(false);
        centerContainer.add(warnLabel, centerConstraints);

        JPanel bottomContainer = new JPanel(new BorderLayout());
        bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        setupImageIcon(colorIndicator, "Edit area color", COLOR_ICON, COLOR_HOVER_ICON, this::openBorderColorPicker);


        labelIndicator.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                toggleLabelling(!showLabel);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_HOVER_ICON : NO_LABEL_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
            }
        });

        leftActions.add(colorIndicator);
        leftActions.add(labelIndicator);

        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setupImageIcon(saveArea, "Save Area", CREATE_ICON, CREATE_HOVER_ICON, () -> {
            captureOptions.setLabel(nameInput.getText());
            plugin.finishCaptureAreaCreation();
        });

        setupImageIcon(cancelArea, "Cancel Area creation", CANCEL_ICON, CANCEL_HOVER_ICON, plugin::cancelCaptureAreaCreation);

        rightActions.add(saveArea);
        rightActions.add(cancelArea);

        bottomContainer.add(leftActions, BorderLayout.WEST);
        bottomContainer.add(rightActions, BorderLayout.EAST);
        bottomContainer.setPreferredSize(new Dimension(0, 37));

        add(nameWrapper, BorderLayout.NORTH);
        add(centerContainer, BorderLayout.CENTER);
        add(bottomContainer, BorderLayout.SOUTH);

        updateBorder();
        updateLabelling();
    }

    private void toggleLabelling(boolean on)
    {
        showLabel = on;
        captureOptions.setLabelVisible(on);
        plugin.updateCaptureAreas();
        updateLabelling();
    }

    private void updateLabelling()
    {
        labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
        labelIndicator.setToolTipText(showLabel ? "Hide label" : "Show label");
    }

    private void updateBorder()
    {
        Color color = captureOptions.getColor();
        colorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, ColorUtil.colorWithAlpha(color, MAX_ALPHA)));

        colorIndicator.setIcon(COLOR_ICON);
    }

    private void openBorderColorPicker()
    {
        final Color color = captureOptions.getColor();
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                color,
                captureOptions.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnColorChange(c ->
        {
            captureOptions.setColor(c);
            updateBorder();
        });
        colorPicker.setOnClose(c -> plugin.updateCaptureAreas());
        colorPicker.setVisible(true);
    }

    private void validateArea()
    {
        final int width = captureOptions.getWest() + captureOptions.getEast() + 1;
        final int height = captureOptions.getNorth() + captureOptions.getSouth() + 1;
        final boolean tooSmall = (width == 1 || height == 1);
        warnLabel.setVisible(tooSmall);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.CaptureArea;

import com.github.jeromkiller.HideAndSeekTracker.game.CaptureArea;
import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.BlinklessToggleButton;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class ExistingCaptureAreaPanel extends BasePanel {
    private final JLabel colorIndicator = new JLabel();
    private final JLabel statusLabel = new JLabel();
    private final JLabel shareLabel = new JLabel();
    private final JLabel deleteLabel = new JLabel();
    private final BlinklessToggleButton visibilityToggle;// = new JToggleButton(INVISIBLE_ICON);
    private final BlinklessToggleButton labelToggle;// = new JToggleButton(NO_LABEL_ICON);

    private final FlatTextField nameInput = new FlatTextField();
    private final JLabel save = new JLabel("Save");
    private final JLabel cancel = new JLabel("Cancel");
    private final JLabel rename = new JLabel("Rename");

    private final HideAndSeekTrackerPlugin plugin;
    private final CaptureArea captureArea;

    public ExistingCaptureAreaPanel(HideAndSeekTrackerPlugin plugin, CaptureArea captureArea)
    {
        this.plugin = plugin;
        this.captureArea = captureArea;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);

        JPanel nameActions = new JPanel(new BorderLayout(3,0));
        nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        save.setVisible(false);
        save.setFont(FontManager.getRunescapeSmallFont());
        save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        save.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                save();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
            }
        });

        cancel.setVisible(false);
        cancel.setFont(FontManager.getRunescapeSmallFont());
        cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
        cancel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                cancel();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
            }
        });

        rename.setFont(FontManager.getRunescapeSmallFont());
        rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
        rename.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                nameInput.setEditable(true);
                updateNameActions(true);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
            }
        });

        nameActions.add(save, BorderLayout.EAST);
        nameActions.add(cancel, BorderLayout.WEST);
        nameActions.add(rename, BorderLayout.CENTER);

        nameInput.setText(captureArea.getLabel());
        nameInput.setBorder(null);
        nameInput.setEditable(false);
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setPreferredSize(new Dimension(0, 24));
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));
        nameInput.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ENTER)
                {
                    save();
                }
                else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                {
                    cancel();
                }
            }
        });
        nameInput.getTextField().addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                preview(true);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                preview(false);
            }
        });

        nameWrapper.add(nameInput, BorderLayout.CENTER);
        nameWrapper.add(nameActions, BorderLayout.EAST);

        JPanel bottomContainer = new JPanel(new BorderLayout());
        bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        setupImageIcon(colorIndicator, "Edit area color", COLOR_ICON, COLOR_HOVER_ICON, this::openBorderColorPicker);

        labelToggle = new BlinklessToggleButton(LABEL_ICON, LABEL_HOVER_ICON,
                NO_LABEL_ICON, NO_LABEL_HOVER_ICON,
                "Hide Area Label", "Show Area Label");
        labelToggle.setSelected(captureArea.isLabelVisible());
        labelToggle.addItemListener(this::toggleLabelling);

        leftActions.add(colorIndicator);
        leftActions.add(labelToggle);

        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        statusLabel.setText("Copied!");
        statusLabel.setVisible(false);

        setupImageIcon(shareLabel, "Copy area to clipboard", COPY_ICON, COPY_ICON_HOVER, () -> {
            plugin.copyCaptureAreaToClip(captureArea);
            showCopiedStatus();
        });

        visibilityToggle = new BlinklessToggleButton(VISIBLE_ICON, VISIBLE_HOVER_ICON,
                INVISIBLE_ICON, INVISIBLE_HOVER_ICON, "Hide Area", "Show Area");
        visibilityToggle.setSelected(captureArea.isAreaActive());
        visibilityToggle.addItemListener(this::toggleVisibility);

        setupImageIcon(deleteLabel, "Delete capture area", DELETE_ICON, DELETE_HOVER_ICON, () -> {
            int confirm = JOptionPane.showConfirmDialog(ExistingCaptureAreaPanel.this,
                    "Are you sure you want to permanently delete this capture area?",
                    "Warning", JOptionPane.OK_CANCEL_OPTION);

            if (confirm == 0)
            {
                plugin.deleteCaptureArea(captureArea);
            }
        });

        rightActions.add(statusLabel);
        rightActions.add(shareLabel);
        rightActions.add(visibilityToggle);
        rightActions.add(deleteLabel);

        bottomContainer.add(leftActions, BorderLayout.WEST);
        bottomContainer.add(rightActions, BorderLayout.EAST);
        bottomContainer.setPreferredSize(new Dimension(0, 37));

        add(nameWrapper, BorderLayout.NORTH);
        add(bottomContainer, BorderLayout.CENTER);

        updateBorder();
    }

    private void preview(boolean on)
    {
        if(visibilityToggle.isSelected()) {
            return;
        }
        captureArea.setAreaVisible(on);
    }

    private void toggleVisibility()
    {
        final boolean isVisible = visibilityToggle.isSelected();
        captureArea.setAreaVisible(isVisible);
        captureArea.setAreaActive(isVisible);
        plugin.updateCaptureAreas();
    }

    private void toggleLabelling()
    {
        final boolean showLabel = labelToggle.isSelected();
        captureArea.setLabelVisible(showLabel);
        plugin.updateCaptureAreas();
    }

    private void save()
    {
        captureArea.setLabel(nameInput.getText());
        plugin.updateCaptureAreas();

        nameInput.setEditable(false);
        updateNameActions(false);
        requestFocusInWindow();
    }

    private void cancel()
    {
        nameInput.setEditable(false);
        nameInput.setText(captureArea.getLabel());
        updateNameActions(false);
        requestFocusInWindow();
    }

    private void updateNameActions(boolean saveAndCancel)
    {
        save.setVisible(saveAndCancel);
        cancel.setVisible(saveAndCancel);
        rename.setVisible(!saveAndCancel);

        if (saveAndCancel)
        {
            nameInput.getTextField().requestFocusInWindow();
            nameInput.getTextField().selectAll();
        }
    }

    private void updateBorder()
    {
        Color color = captureArea.getColor();
        colorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, ColorUtil.colorWithAlpha(color, MAX_ALPHA)));

        colorIndicator.setIcon(COLOR_ICON);
    }

    private void openBorderColorPicker()
    {
        final Color color = captureArea.getColor();
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                color,
                captureArea.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnColorChange(c ->
        {
            captureArea.setColor(c);
            updateBorder();
        });
        colorPicker.setOnClose(c -> plugin.updateCaptureAreas());
        colorPicker.setVisible(true);
    }

    private void showCopiedStatus()
    {
        statusLabel.setVisible(true);
        Timer hideTimer = new Timer(1000, e -> hideCopiedStatus());
        hideTimer.setRepeats(false);
        hideTimer.start();
    }

    private void hideCopiedStatus()
    {
        statusLabel.setVisible(false);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.CaptureArea;

import com.github.jeromkiller.HideAndSeekTracker.game.CaptureArea;
import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.PluginErrorPanel;

import javax.swing.*;
import java.awt.*;

public class CaptureAreaManagementPanel extends BasePanel {

    private final PluginErrorPanel noAreasPanel = new PluginErrorPanel();
    private final JPanel areaView = new JPanel(new GridBagLayout());
    private final JButton newArea = new JButton("New Area");
    private final JButton importArea = new JButton("Import from clipboard");
    private final JButton exportVisibleAreas = new JButton("Export visible to clipboard");
    private final JLabel copyStatusLabel = new JLabel("Copied!");

    private final HideAndSeekTrackerPlugin plugin;

    public CaptureAreaManagementPanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;

        setLayout(new BorderLayout());

        areaView.setBackground(ColorScheme.DARK_GRAY_COLOR);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        noAreasPanel.setContent("No Capture areas set", "Add a capture area for people to finnish in");
        noAreasPanel.setVisible(false);

        newArea.addActionListener(e -> plugin.startCaptureAreaCreation());
        importArea.addActionListener(e -> plugin.importCaptureAreaFromClip());
        exportVisibleAreas.addActionListener(e -> exportVisibleAreas());

        areaView.add(noAreasPanel, constraints);
        constraints.gridy++;

        //centerPanel.add(areaView, BorderLayout.CENTER);
        add(areaView, BorderLayout.NORTH);
    }

    public void rebuild()
    {
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        areaView.removeAll();

        for(final CaptureArea captureArea : plugin.getCaptureAreas())
        {
            areaView.add(new ExistingCaptureAreaPanel(plugin, captureArea), constraints);
            constraints.gridy++;

            addSpacer(constraints);
        }

        final boolean empty = constraints.gridy == 0;
        noAreasPanel.setVisible(empty);

        areaView.add(noAreasPanel, constraints);
        constraints.gridy++;

        if(plugin.getCaptureCreationOptions().isCurrentlyCreating())
        {
            areaView.add(new CaptureCreationPanel(plugin), constraints);
        }
        else
        {
            areaView.add(newArea, constraints);
        }
        constraints.gridy++;
        addSpacer(constraints);

        areaView.add(importArea, constraints);
        constraints.gridy++;

        addSpacer(constraints);

        areaView.add(exportVisibleAreas, constraints);
        constraints.gridy++;

        copyStatusLabel.setVisible(false);
        areaView.add(copyStatusLabel, constraints);
        constraints.gridy++;

        repaint();
        revalidate();
    }

    private void addSpacer(GridBagConstraints constraints)
    {
        areaView.add(Box.createRigidArea(new Dimension(0, 5)), constraints);
        constraints.gridy++;
    }

    private void exportVisibleAreas()
    {
        plugin.copyVisibleCaptureAreasToClip();
        copyStatusLabel.setVisible(true);
        Timer hideStatusTimer = new Timer(1000, e -> copyStatusLabel.setVisible(false));
        hideStatusTimer.setRepeats(false);
        hideStatusTimer.start();
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class BasePanel extends JPanel {
    public static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));
    public static final int MAX_ALPHA = 255;

    public static final ImageIcon COLOR_ICON;
    public static final ImageIcon COLOR_HOVER_ICON;

    public static final ImageIcon LABEL_ICON;
    public static final ImageIcon LABEL_HOVER_ICON;
    public static final ImageIcon NO_LABEL_ICON;
    public static final ImageIcon NO_LABEL_HOVER_ICON;

    public static final ImageIcon VISIBLE_ICON;
    public static final ImageIcon VISIBLE_HOVER_ICON;
    public static final ImageIcon INVISIBLE_ICON;
    public static final ImageIcon INVISIBLE_HOVER_ICON;

    public static final ImageIcon DELETE_ICON;
    public static final ImageIcon DELETE_HOVER_ICON;

    public static final ImageIcon COPY_ICON;
    public static final ImageIcon COPY_ICON_HOVER;
    public static final ImageIcon IMPORT_ICON;
    public static final ImageIcon IMPORT_ICON_HOVER;
    public static final ImageIcon EXPORT_ICON;
    public static final ImageIcon EXPORT_ICON_HOVER;
    public static final ImageIcon NEW_ROUND_ICON;
    public static final ImageIcon NEW_ROUND_ICON_HOVER;
    public static final ImageIcon DELETE_ROUND_ICON;
    public static final ImageIcon DELETE_ROUND_ICON_HOVER;

    public static final ImageIcon ARROW_LEFT_ICON;
    public static final ImageIcon ARROW_LEFT_HOVER_ICON;
    public static final ImageIcon ARROW_RIGHT_ICON;
    public static final ImageIcon ARROW_RIGHT_HOVER_ICON;

    public static final ImageIcon MINUS_ICON;
    public static final ImageIcon MINUS_HOVER_ICON;

    public static final ImageIcon ON_SWITCHER;
    public static final ImageIcon ON_SWITCHER_HOVER;
    public static final ImageIcon OFF_SWITCHER;
    public static final ImageIcon OFF_SWITCHER_HOVER;

    static {
        final BufferedImage copyImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "copy_icon.png");
        final BufferedImage copyImgHover = ImageUtil.luminanceOffset(copyImg, -100);
        COPY_ICON = new ImageIcon(copyImg);
        COPY_ICON_HOVER = new ImageIcon(copyImgHover);

        final BufferedImage importImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "import_icon.png");
        final BufferedImage importImgHover = ImageUtil.luminanceOffset(importImg, -100);
        IMPORT_ICON = new ImageIcon(importImg);
        IMPORT_ICON_HOVER = new ImageIcon(importImgHover);

        final BufferedImage exportImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "export_icon.png");
        final BufferedImage exportImgHover = ImageUtil.luminanceOffset(exportImg, -100);
        EXPORT_ICON = new ImageIcon(exportImg);
        EXPORT_ICON_HOVER = new ImageIcon(exportImgHover);

        final BufferedImage newRoundImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "new_round.png");
        final BufferedImage newRoundImgHover = ImageUtil.luminanceOffset(newRoundImg, -100);
        NEW_ROUND_ICON = new ImageIcon(newRoundImg);
        NEW_ROUND_ICON_HOVER = new ImageIcon(newRoundImgHover);

        final BufferedImage deleteRoundImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "delete_round.png");
        final BufferedImage deleteRoundImgHover = ImageUtil.luminanceOffset(deleteRoundImg, -100);
        DELETE_ROUND_ICON = new ImageIcon(deleteRoundImg);
        DELETE_ROUND_ICON_HOVER = new ImageIcon(deleteRoundImgHover);

        final BufferedImage pencilImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "pencil_color_icon.png");
        final BufferedImage pencilImgHover = ImageUtil.luminanceOffset(pencilImg, -150);
        COLOR_ICON = new ImageIcon(pencilImg);
        COLOR_HOVER_ICON = new ImageIcon(pencilImgHover);

        final BufferedImage labelImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "label_icon.png");
        final BufferedImage labelImgHover = ImageUtil.luminanceOffset(labelImg, -150);
        LABEL_ICON = new ImageIcon(labelImg);
        LABEL_HOVER_ICON = new ImageIcon(labelImgHover);

        NO_LABEL_ICON = new ImageIcon(labelImgHover);
        NO_LABEL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(labelImgHover, -100));

        final BufferedImage visibleImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "visible_icon.png");
        VISIBLE_ICON = new ImageIcon(visibleImg);
        VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

        final BufferedImage invisibleImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "invisible_icon.png");
        INVISIBLE_ICON = new ImageIcon(invisibleImg);
        INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));

        final BufferedImage deleteImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteImg);
        DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));

        final BufferedImage arrowLeftImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "config_back_icon.png");
        final BufferedImage arrowLeftImgHover = ImageUtil.luminanceOffset(arrowLeftImg, -150);
        ARROW_LEFT_ICON = new ImageIcon(arrowLeftImg);
        ARROW_LEFT_HOVER_ICON = new ImageIcon(arrowLeftImgHover);

        final BufferedImage arrowRightImg = ImageUtil.flipImage(arrowLeftImg, true, false);
        final BufferedImage arrowRightImgHover = ImageUtil.flipImage(arrowLeftImgHover, true, false);
        ARROW_RIGHT_ICON = new ImageIcon(arrowRightImg);
        ARROW_RIGHT_HOVER_ICON = new ImageIcon(arrowRightImgHover);

        final BufferedImage removeImg = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "minus_icon.png");
        MINUS_ICON = new ImageIcon(removeImg);
        MINUS_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(removeImg, -50));

        BufferedImage onSwitcher = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        ON_SWITCHER_HOVER = new ImageIcon(ImageUtil.alphaOffset(onSwitcher, -50));
        BufferedImage offSwitcher = ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        );
        OFF_SWITCHER = new ImageIcon(offSwitcher);
        OFF_SWITCHER_HOVER = new ImageIcon(ImageUtil.alphaOffset(offSwitcher, -100));
    }

    protected void setupImageIcon(JLabel iconButton, String toolTip, ImageIcon icon, ImageIcon hover_icon, Runnable function) {
        iconButton.setIcon(icon);
        iconButton.setToolTipText(toolTip);
        iconButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                function.run();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                iconButton.setIcon(hover_icon);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                iconButton.setIcon(icon);
            }
        });
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.PointsPanel;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import com.github.jeromkiller.HideAndSeekTracker.Scoring.PointSystem;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.util.ArrayList;
import java.util.List;

public class NewScoreSettingPanel extends BasePanel {
    HideAndSeekTrackerPlugin plugin;
    ScoringPanel parent;

    private final JComboBox<String> scoreTypes;

    NewScoreSettingPanel(HideAndSeekTrackerPlugin plugin, ScoringPanel parent) {
        this.plugin = plugin;
        this.parent = parent;

        setLayout(new BorderLayout());
        setBorder(new CompoundBorder(new EmptyBorder(2, 2, 2, 2),
                new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1)));

        List<String> scoreTypeNames = new ArrayList<>();
        for(PointSystem.ScoreType st : PointSystem.ScoreType.values()) {
            scoreTypeNames.add(st.toString());
        }

        JPanel content = new JPanel(new GridBagLayout());
        this.add(content);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.anchor = GridBagConstraints.CENTER;
        constraints.weightx = 1;
        constraints.gridwidth = 2;
        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.insets = new Insets(2, 2, 2, 2);

        scoreTypes = new JComboBox<>(scoreTypeNames.toArray(new String[0]));
        scoreTypes.getModel().setSelectedItem("Select Rule");
        scoreTypes.addActionListener(this::comboBoxChanged);
        content.add(scoreTypes, constraints);

        JLabel deleteSystem = new JLabel();
        setupImageIcon(deleteSystem, "Delete Rule", DELETE_ICON, DELETE_HOVER_ICON, parent::cancelNewRuleCreation);
        constraints.gridx = 2;
        constraints.gridwidth = 1;
        content.add(deleteSystem, constraints);
        constraints.gridy++;

        constraints.gridx = 0;
        content.add(new JLabel("Setting", SwingConstants.CENTER), constraints);
        constraints.gridx = 1;
        content.add(new JLabel("Points", SwingConstants.CENTER), constraints);

        constraints.gridx = 0;
        constraints.gridy++;

        JTextField settingsField = new JTextField("1+");
        settingsField.setEnabled(false);
        content.add(settingsField, constraints);
        constraints.gridx = 1;

        JTextField pointsField = new JTextField("0");
        pointsField.setEnabled(false);
        content.add(pointsField, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
    }

    private void comboBoxChanged(ActionEvent e) {
        final String pickedOption = (String)scoreTypes.getSelectedItem();
        PointSystem.ScoreType scoreType = PointSystem.ScoreType.fromString(pickedOption);
        parent.addNewRule(scoreType);
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.PointsPanel;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import com.github.jeromkiller.HideAndSeekTracker.Scoring.PointSystem;
import com.github.jeromkiller.HideAndSeekTracker.Scoring.ScoreRules;

import javax.swing.*;
import java.awt.*;

public class ScoringPanel extends BasePanel {

    public final HideAndSeekTrackerPlugin plugin;
    public final ScoreRules scoreRules;
    public final JPanel rulesView = new JPanel(new GridBagLayout());
    public boolean creatingSetting;

    public ScoringPanel(HideAndSeekTrackerPlugin plugin) {
        this.plugin = plugin;
        this.scoreRules = plugin.getScoreRules();
        this.creatingSetting = false;

        setLayout(new BorderLayout());

        JPanel content = new JPanel();
        content.setLayout(new GridBagLayout());

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        content.add(rulesView, constraints);
        constraints.gridy++;

        add(content, BorderLayout.NORTH);
    }

    public void rebuild() {
        rulesView.removeAll();

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        for(PointSystem<?> system : scoreRules.getPointSystems()) {
            ScoringSettingPanel panel = new ScoringSettingPanel(plugin, system);
            rulesView.add(panel, constraints);
            constraints.gridy++;
        }

        JButton newRulesButton = new JButton("New points/penalty");
        newRulesButton.addActionListener(e -> startNewRuleCreation());
        rulesView.add(newRulesButton, constraints);
        constraints.gridy++;

        NewScoreSettingPanel creationPanel = new NewScoreSettingPanel(plugin, this);
        rulesView.add(creationPanel, constraints);
        constraints.gridy++;

        newRulesButton.setVisible(!creatingSetting);
        creationPanel.setVisible(creatingSetting);

        repaint();
        revalidate();
    }

    private void startNewRuleCreation() {
        creatingSetting = true;
        rebuild();
    }

    public void cancelNewRuleCreation() {
        creatingSetting = false;
        rebuild();
    }

    public void addNewRule(PointSystem.ScoreType scoreType) {
        creatingSetting = false;
        scoreRules.addSystem(scoreType);
        rebuild();
        plugin.updateScoreRules();
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels.PointsPanel;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.BasePanel;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.PercentileScoreTextEntry;
import com.github.jeromkiller.HideAndSeekTracker.Scoring.PointSystem;
import com.github.jeromkiller.HideAndSeekTracker.Scoring.ScoringPair;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.NameScoreTextEntry;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.NumberScoreTextEntry;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.TimeScoreTextEntry;
import lombok.Data;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.text.NumberFormatter;
import java.awt.*;
import java.awt.event.*;
import java.text.NumberFormat;
import java.time.*;
import java.util.ArrayList;
import java.util.List;

public class ScoringSettingPanel<T> extends BasePanel {

    private static final NumberFormatter pointsFormatter;

    static {
        pointsFormatter = new NumberFormatter(NumberFormat.getInstance());
        pointsFormatter.setValueClass(Integer.class);
        pointsFormatter.setMinimum(-100);
        pointsFormatter.setMaximum(100);
        pointsFormatter.setAllowsInvalid(true);
        pointsFormatter.setCommitsOnValidEdit(true);
    }

    private static void selectText(FocusEvent e) {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                ((JFormattedTextField)e.getSource()).selectAll();
            }
        });
    }

    // maybe consider moving this class to a separate file
    // if I'm in the mood to refactor this
    // but not right now, figuring out the formatters for this gave me a headache for 2 days straight
    @Data
    public class SettingsRow<T> {
        private final HideAndSeekTrackerPlugin plugin;
        private final int index;
        private final ScoringPair<T> scoringPair;
        private final JFormattedTextField settingBox;
        private final JFormattedTextField pointsBox;
        private final JLabel deleteLabel = new JLabel();

        SettingsRow(HideAndSeekTrackerPlugin plugin, PointSystem<T> pointSystem, ScoringPair<T> scoringPair, int index, T prevValue, JPanel container, GridBagConstraints constraints) {
            this.plugin = plugin;
            this.index = index;
            this.scoringPair = scoringPair;

            switch(pointSystem.getScoreType()) {
                case POSITION:
                case HINTS:
                    settingBox = new NumberScoreTextEntry((int) scoringPair.getSetting(), (int)prevValue + 1);
                    break;
                case PERCENTILE:
                    settingBox = new PercentileScoreTextEntry((int) scoringPair.getSetting(), (int)prevValue - 1);
                    break;
                case TIME:
                    settingBox = new TimeScoreTextEntry((LocalTime) scoringPair.getSetting(), ((LocalTime) prevValue).plusSeconds(1));
                    break;
                case NAME:
                    settingBox = new NameScoreTextEntry((String) scoringPair.getSetting());
                    break;
                default:
                    settingBox = new JFormattedTextField();
            }

            settingBox.addFocusListener(new FocusAdapter() {
                @Override
                public void focusLost(FocusEvent e) {
                    pointSystem.updateSetting(index, (T) settingBox.getValue());
                    rebuild();
                    plugin.updateScoreRules();
                }
            });

            pointsBox = new JFormattedTextField(pointsFormatter);
            pointsBox.setValue(scoringPair.getPoints());
            pointsBox.addFocusListener(new FocusAdapter() {
                @Override
                public void focusGained(FocusEvent e) {
                    selectText(e);
                }
                @Override
                public void focusLost(FocusEvent e) {
                    scoringPair.setPoints((Integer) pointsBox.getValue());
                    rebuild();
                    plugin.updateScoreRules();
                }
            });

            setupImageIcon(deleteLabel, "Remove Line", MINUS_ICON, MINUS_HOVER_ICON, () -> {
                pointSystem.deleteSetting(index);
                rebuild();
                plugin.updateScoreRules();
            });

            constraints.gridx = 0;
            container.add(settingBox, constraints);
            constraints.gridx = 1;
            container.add(pointsBox, constraints);
            constraints.gridx = 2;
            container.add(deleteLabel, constraints);
        }
    }

    private final JComboBox<String> scoreTypes;

    private final HideAndSeekTrackerPlugin plugin;
    private final PointSystem<T> pointSystem;
    private final JPanel content = new JPanel(new GridBagLayout());
    private final List<JTextField> settingsRows = new ArrayList<>();

    public ScoringSettingPanel(HideAndSeekTrackerPlugin plugin, PointSystem<T> pointSystem) {
        this.plugin = plugin;
        this.pointSystem = pointSystem;

        setLayout(new BorderLayout());
        setBorder(new CompoundBorder(new EmptyBorder(2, 2, 2, 2),
                new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1)));

        scoreTypes = new JComboBox<>();
        scoreTypes.getModel().setSelectedItem(pointSystem.getScoreType().toString());

        this.add(content);

        rebuild();
    }

    public void rebuild() {
        content.removeAll();
        settingsRows.clear();

        this.add(content);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.anchor = GridBagConstraints.CENTER;
        constraints.weightx = 1;
        constraints.gridwidth = 2;
        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.insets = new Insets(2, 2, 2, 2);
        content.add(scoreTypes, constraints);
        scoreTypes.setEnabled(false); // Disabled until more rule types are implemented

        JLabel deleteSystem = new JLabel();
        setupImageIcon(deleteSystem, "Delete Rule", DELETE_ICON, DELETE_HOVER_ICON, () -> {
            int confirm = JOptionPane.showConfirmDialog(ScoringSettingPanel.this,
                    "Are you sure you want to permanently delete this scoring rule?",
                    "Warning", JOptionPane.OK_CANCEL_OPTION);

            if(confirm == 0) {
                plugin.getScoreRules().deleteSystem(pointSystem);
                plugin.getPanel().getScorePanel().rebuild();
                plugin.updateScoreRules();
            }
        });
        constraints.gridx = 2;
        constraints.gridwidth = 1;
        content.add(deleteSystem, constraints);
        constraints.gridy++;

        constraints.gridx = 0;
        constraints.gridwidth = 3;
        JCheckBox calcEveryRoundCheckbox = new JCheckBox(" Calculate Every Round", pointSystem.isCalcEveryRound());
        calcEveryRoundCheckbox.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                pointSystem.setCalcEveryRound(calcEveryRoundCheckbox.isSelected());
                plugin.updateScoreRules();
            }
        });
        calcEveryRoundCheckbox.setVisible(pointSystem.isCanBeCalculatedOnce());
        content.add(calcEveryRoundCheckbox, constraints);
        constraints.gridy++;
        constraints.gridwidth = 1;


        constraints.gridx = 0;
        content.add(new JLabel("Setting", SwingConstants.CENTER), constraints);
        constraints.gridx = 1;
        content.add(new JLabel("Points", SwingConstants.CENTER), constraints);

        constraints.gridx = 0;
        constraints.gridy++;

        addTextBoxes(pointSystem, constraints);

        repaint();
        revalidate();
    }

    public void addTextBoxes(PointSystem<T> pointSystem, GridBagConstraints constraints) {
        int index = 0;
        T prev_value = null;

        switch(pointSystem.getScoreType()) {
            case POSITION:
            case HINTS: {
                Integer val = 0;
                prev_value = (T) val;
                break;
            }
            case PERCENTILE:
                Integer val = 100;
                prev_value = (T) val;
                break;
            case NAME: {
                prev_value = (T) "";
                break;
            }
            case TIME: {
                prev_value = (T) LocalTime.ofSecondOfDay(0);
                break;
            }
        }

        for(ScoringPair<T> pair : pointSystem.getScoreTiers()) {
            SettingsRow<T> row = new SettingsRow<>(plugin, pointSystem, pair, index, prev_value, content, constraints);
            settingsRows.add(row.settingBox);

            prev_value = pair.getSetting();
            constraints.gridy++;
            index++;
        }

        String fallThroughValue = "Others";
        boolean showFallThrough = true;
        switch(pointSystem.getScoreType()) {
            case HINTS:
            case POSITION: {
                fallThroughValue = ((int)prev_value + 1) + "+";
                break;
            }
            case TIME:{
               final LocalTime new_value = ((LocalTime) prev_value).plusSeconds(1);
               fallThroughValue = new_value + "+";
               break;
            }
            case NAME: {
                fallThroughValue = "Others";
                break;
            }
            case PERCENTILE: {
                showFallThrough = (int)prev_value != 0;
                break;
            }
        }
        JTextField fallThroughSetting = new JTextField(fallThroughValue);
        fallThroughSetting.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
        fallThroughSetting.addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                fallThroughSettingSelected();
            }
        });

        JFormattedTextField fallThroughPoints = new JFormattedTextField(pointsFormatter);
        fallThroughPoints.setValue(pointSystem.getFallThroughScore());
        fallThroughPoints.addFocusListener(new FocusAdapter() {
            @Override
            public void focusGained(FocusEvent e) {
                selectText(e);
            }
            @Override
            public void focusLost(FocusEvent e) {
                pointSystem.setFallThroughScore((int)fallThroughPoints.getValue());
                rebuild();
                plugin.updateScoreRules();
            }
        });

        constraints.gridx = 0;
        content.add(fallThroughSetting, constraints);
        fallThroughSetting.setVisible(showFallThrough);
        constraints.gridx = 1;
        content.add(fallThroughPoints, constraints);
        fallThroughPoints.setVisible(showFallThrough);
    }

    public void fallThroughSettingSelected() {
        pointSystem.addSetting();
        plugin.updateScoreRules();
        this.rebuild();
        settingsRows.get(settingsRows.size() - 1).requestFocus();
    }
}

package com.github.jeromkiller.HideAndSeekTracker.Panels;

import com.github.jeromkiller.HideAndSeekTracker.HideAndSeekTrackerPlugin;
import com.github.jeromkiller.HideAndSeekTracker.Panels.Widgets.BlinklessToggleButton;
import com.github.jeromkiller.HideAndSeekTracker.Util.HideAndSeekSettings;
import joptsimple.internal.Strings;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;

public class GameSetupPanel extends JPanel {
    private final BlinklessToggleButton autoFillButton;
    private final JTextArea playerNames = new JTextArea();
    private final JLabel notSavedWarning = new JLabel("Names not saved!");
    private final JLabel statusLabel = new JLabel();

    @Getter
    private final LinkedHashSet<String> playerNameList = new LinkedHashSet<>();

    private final HideAndSeekTrackerPlugin plugin;
    private final HideAndSeekSettings settings;
    private boolean isAutomaticUpdate;

    private static final ImageIcon ON_SWITCHER;
    private static final ImageIcon OFF_SWITCHER;

    static
    {
        BufferedImage onSwitcher = ImageUtil.loadImageResource(HideAndSeekTrackerPlugin.class, "switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        ));
    }

    public GameSetupPanel(HideAndSeekTrackerPlugin plugin)
    {
        this.plugin = plugin;
        this.settings = plugin.getSettings();
        this.isAutomaticUpdate = true;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 10, 0));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);
        constraints.gridy = 0;
        constraints.weightx = 1;
        constraints.anchor = GridBagConstraints.WEST;
        constraints.gridx = 0;
        constraints.gridwidth = 2;

        final JLabel playerNameLabel = new JLabel("Participant Names:");
        contents.add(playerNameLabel, constraints);
        constraints.gridy++;

        constraints.fill = GridBagConstraints.BOTH;
        constraints.weighty = 1;
        playerNames.setRows(10);
        Border border = BorderFactory.createLineBorder(ColorScheme.BORDER_COLOR );
        playerNames.setBorder(BorderFactory.createCompoundBorder(border,
                BorderFactory.createEmptyBorder(3, 5, 3, 5)));

        playerNames.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                enableNotSavedWarning();
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                enableNotSavedWarning();
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                // nothing
            }
        });
        contents.add(playerNames, constraints);
        constraints.gridy++;
        constraints.weighty = 0;
        constraints.fill = GridBagConstraints.HORIZONTAL;

        final JButton saveNamesButton = new JButton("Save Participant Names");
        saveNamesButton.addActionListener(e -> changePlayerNames());
        contents.add(saveNamesButton, constraints);
        constraints.gridy++;

        //contents.add(copyPlayerNames, constraints);
        constraints.gridwidth = 1;
        constraints.anchor = GridBagConstraints.WEST;
        final JLabel autoFillLabel = new JLabel("Automatically Fill Names");
        contents.add(autoFillLabel, constraints);

        constraints.gridx = 1;
        constraints.anchor = GridBagConstraints.EAST;
        constraints.fill = GridBagConstraints.NONE;
        autoFillButton = new BlinklessToggleButton("Automatically add players to the participant list");
        autoFillButton.addItemListener(this::changeAutoFill);
        contents.add(autoFillButton, constraints);
        constraints.gridwidth = 2;
        constraints.gridx = 0;
        constraints.gridy++;

        constraints.anchor = GridBagConstraints.WEST;
        statusLabel.setVisible(false);
        contents.add(statusLabel, constraints);
        constraints.gridy++;

        notSavedWarning.setVisible(false);
        contents.add(notSavedWarning, constraints);
        constraints.gridy++;

        add(contents, BorderLayout.NORTH);
        loadSettings();

        isAutomaticUpdate = false;
    }

    private void changePlayerNames() {
        ArrayList<String> nameList = new ArrayList<>(List.of(
                playerNames.getText()
                .replaceAll("\\r", "")
                .split("\\n")));
        // we don't need empty namelists
        if(!nameList.isEmpty()) {
            if(Strings.isNullOrEmpty(nameList.get(nameList.size() -1))) {
                nameList.clear();
            }
        }

        final LinkedHashSet<String> setNames = plugin.setPlayerNames(nameList);
        final int numRemoved = nameList.size() - setNames.size();
        if(numRemoved > 0) {
            setStatusLabel(String.format("Removed %d duplicates", numRemoved));
        }

        notSavedWarning.setVisible(false);
    }


    private void changeAutoFill() {
        if(notSavedWarning.isVisible())
        {
            changePlayerNames();
        }
        final boolean autofill = autoFillButton.isSelected();
        plugin.setAutofillNames(autofill);
        playerNames.setEditable(!autofill);
    }

    public void loadSettings() {
        loadPlayerNames(settings.getPlayerNames());
    }

    private void enableNotSavedWarning()
    {
        if(!isAutomaticUpdate) {
            notSavedWarning.setVisible(true);
        }
    }

    private void setStatusLabel(String statusText)
    {
        statusLabel.setText(statusText);
        statusLabel.setVisible(true);
        Timer hideTimer = new Timer(1000, e -> {
            statusLabel.setVisible(false);});
        hideTimer.setRepeats(false);
        hideTimer.start();
    }

    public void loadPlayerNames(LinkedHashSet<String> names)
    {
        isAutomaticUpdate = true;
        playerNameList.clear();
        playerNameList.addAll(names);
        final String playerNameString = String.join(System.lineSeparator(), playerNameList);
        playerNames.setText(playerNameString);
        isAutomaticUpdate = false;

        settings.setPlayerNames(playerNameList);
    }

    public void addPlayerName(String name)
    {
        isAutomaticUpdate = true;
        playerNameList.add(name);
        final String playerNameString = String.join(System.lineSeparator(), playerNameList);
        playerNames.setText(playerNameString);
        isAutomaticUpdate = false;

        settings.setPlayerNames(playerNameList);
    }

}

package com.github.jeromkiller.HideAndSeekTracker;

import com.github.jeromkiller.HideAndSeekTracker.Panels.CaptureArea.CaptureCreationOptions;
import com.github.jeromkiller.HideAndSeekTracker.Util.HideAndSeekSettings;
import com.github.jeromkiller.HideAndSeekTracker.Scoring.ScoreRules;
import com.github.jeromkiller.HideAndSeekTracker.Util.roundExport;
import com.github.jeromkiller.HideAndSeekTracker.game.CaptureArea;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekGame;
import com.github.jeromkiller.HideAndSeekTracker.game.HideAndSeekRound;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;

import javax.inject.Inject;
import javax.swing.*;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "E.T. - Racing & Hide and Seek"
)
public class HideAndSeekTrackerPlugin extends Plugin
{
	private static final String PLUGIN_NAME = "Event Tools - Racing & Hide and Seek";

	@Inject
	private Client client;

	@Inject
	private HideAndSeekTrackerSceneOverlay sceneOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Gson gson;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter
	@Inject
	private ColorPickerManager colorPickerManager;

	@Getter
	@Inject
	private HideAndSeekSettings settings;

	@Getter
	private HideAndSeekTrackerPanel panel;
    private NavigationButton navButton;

	public HideAndSeekGame game;

	@Getter
	private String localPlayerName = null;

	@Getter
	private final List<CaptureArea> captureAreas = new ArrayList<>();

	@Getter
	private final ScoreRules scoreRules = new ScoreRules();

	@Getter
	private final CaptureCreationOptions captureCreationOptions = new CaptureCreationOptions();

	@Getter
	@Setter
	public boolean autofillNames = false;

	@Override
	protected void startUp()
	{
		overlayManager.add(sceneOverlay);
		game = new HideAndSeekGame(this);
        panel = new HideAndSeekTrackerPanel(this);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "racing.png");
		navButton = NavigationButton.builder()
				.tooltip(PLUGIN_NAME)
				.priority(5)
				.panel(panel)
				.icon(icon)
				.build();
		clientToolbar.addNavigation(navButton);

		loadSettings();

		panel.getAreaPanel().rebuild();
		panel.getScorePanel().rebuild();
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(sceneOverlay);
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		SetLocalPlayerName();
		checkPlayersInRange();
		game.tick();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if(Objects.equals(event.getKey(), HideAndSeekSettings.HIDE_UNFINISHED_KEY)) {
			panel.getGamePanel().updateHidePlayerSetting();
		}
	}

	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged)
	{
		loadSettings();
		SwingUtilities.invokeLater(panel.getAreaPanel()::rebuild);
		SwingUtilities.invokeLater(panel.getSetupPanel()::loadSettings);
		SwingUtilities.invokeLater(panel.getScorePanel()::rebuild);
	}

	private void checkPlayersInRange()
	{
		List<? extends  Player> playersList = client.getPlayers();
		Player localPlayer = client.getLocalPlayer();
		if(localPlayer == null) {
			return;
		}

		for(CaptureArea area : captureAreas)
		{
			WorldPoint playerLoc = localPlayer.getWorldLocation();
			if(playerLoc == null) {
				return;
			}

			if(area.notWorthChecking(playerLoc)) {
				continue;
			}
			for(Player player : playersList)
			{
				if(player == localPlayer)
				{
					continue;
				}

				final String playerName = player.getName();

				if(area.playerInArea(player.getWorldLocation()))
				{
					if(autofillNames) {
						game.addPlayerName(playerName);
						panel.getSetupPanel().addPlayerName(playerName);
					}
					game.playerFound(playerName);
				}
			}
		}
	}

	public LinkedHashSet<String> setPlayerNames(List<String> nameList)
	{
		final LinkedHashSet<String> setNames = game.setPlayers(nameList);
		panel.getSetupPanel().loadPlayerNames(setNames);
		return setNames;
	}

	public void SetLocalPlayerName()
	{
		Player localPlayer = client.getLocalPlayer();
		if(localPlayer == null) {
			return;
		}

		String name = localPlayer.getName();
		if(Objects.equals(localPlayerName, name)) {
			return;
		}

		localPlayerName = name;
		game.setLocalHostNames(localPlayerName);
	}

	public void startCaptureAreaCreation()
	{
		captureCreationOptions.setCurrentlyCreating(true);
		panel.getAreaPanel().rebuild();
	}

	public void finishCaptureAreaCreation()
	{
		final int width = (captureCreationOptions.getEast() + captureCreationOptions.getWest() + 1);
		final int height = (captureCreationOptions.getNorth() + captureCreationOptions.getSouth() + 1);
		final int xOffset = -captureCreationOptions.getWest();
		final int yOffset = -captureCreationOptions.getSouth();

		Player localPlayer = client.getLocalPlayer();
		if(null == localPlayer)
			return;
		WorldPoint playerLocation = localPlayer.getWorldLocation();
		WorldPoint swTile = playerLocation.dx(xOffset).dy(yOffset);
		CaptureArea setupArea = new CaptureArea(swTile, width, height,
				captureCreationOptions.getColor(),
				captureCreationOptions.getLabel(),
				captureCreationOptions.isLabelVisible());
		captureCreationOptions.resetOptions();

		addCaptureArea(setupArea);
		panel.getAreaPanel().rebuild();
	}

	public void cancelCaptureAreaCreation()
	{
		captureCreationOptions.resetOptions();
		panel.getAreaPanel().rebuild();
	}

	public void addCaptureArea(final CaptureArea captureArea)
	{
		captureAreas.add(captureArea);
		updateCaptureAreas();
	}

	public void deleteCaptureArea(final CaptureArea captureArea)
	{
		captureAreas.remove(captureArea);
		panel.getAreaPanel().rebuild();
		updateCaptureAreas();
	}

	public void updateCaptureAreas()
	{
		settings.setCaptureAreas(captureAreas);
	}

	public void updateScoreRules()
	{
		settings.setScoreRules(scoreRules);
		game.recalculateAllScores();
		panel.getGamePanel().updateAllPlacements();
	}

	public void loadSettings()
	{
		List<CaptureArea> areas = settings.getCaptureAreas();
		captureAreas.clear();
		captureAreas.addAll(areas);

		List<String> playerNames = new ArrayList<>(settings.getPlayerNames());
		game.setPlayers(playerNames);

		ScoreRules loadedRules = settings.getScoreRules();
		scoreRules.load(loadedRules);
	}

	public void copyCaptureAreaToClip(CaptureArea area)
	{
		final ArrayList<CaptureArea> exportAreas = new ArrayList<>();
		exportAreas.add(area);
		final String json = gson.toJson(exportAreas);
		final StringSelection selection = new StringSelection(json);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(selection, selection);
	}

	public void copyVisibleCaptureAreasToClip()
	{
		ArrayList<CaptureArea> exportAreas = new ArrayList<>(captureAreas);
		exportAreas.removeIf(area -> !area.isAreaVisible());
		final String json = gson.toJson(exportAreas);
		final StringSelection selection = new StringSelection(json);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(selection, selection);
	}

	public void importCaptureAreaFromClip() {
		String clipboardText;
		try {
			clipboardText = Toolkit.getDefaultToolkit()
					.getSystemClipboard()
					.getData(DataFlavor.stringFlavor)
					.toString();
		} catch (IOException | UnsupportedFlavorException ex) {
			sendChatMessage("Unable to read system clipboard.");
			log.warn("error reading clipboard", ex);
			return;
		}

		if (clipboardText.isEmpty())
			return;

		ArrayList<CaptureArea> importAreas;
		try {
			importAreas = gson.fromJson(clipboardText, new TypeToken<ArrayList<CaptureArea>>(){}.getType());
		}
		catch (JsonSyntaxException e) {
			sendChatMessage("You do not have any capture areas saved to the clipboard");
			return;
		}

		if(importAreas.isEmpty()) {
			sendChatMessage("You do not have any capture areas saved to the clipboard");
			return;
		}

		importAreas.removeIf(captureAreas::contains);
		captureAreas.addAll(importAreas);
		sendChatMessage("Imported " + importAreas.size() + " area(s) from clipboard");

		panel.getAreaPanel().rebuild();
		updateCaptureAreas();
	}

	private void sendChatMessage(final String message)
	{
		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
	}

	public void exportRoundToClip(final List<Integer> rounds)
	{
		LinkedHashSet<roundExport> roundsToExport = new LinkedHashSet<>();
		for(final int round_number : rounds) {
			int numRounds = game.getPastRounds().size();
			if(round_number < numRounds) {
				if(round_number >= 0) {
					HideAndSeekRound round = game.getPastRounds().get(round_number);
					roundExport exportObject = new roundExport(round);
					roundsToExport.add(exportObject);
				}
			} else {
				HideAndSeekRound round = game.getActiveRound();
				if(!round.isRoundStarted()) {
					continue;
				}
				roundExport exportObject = new roundExport(round);
				roundsToExport.add(exportObject);
			}
		}

		String json = gson.toJson(roundsToExport);
		final StringSelection selection = new StringSelection(json);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(selection, selection);
	}

	public void importRoundFromClip() {
		String clipboardText;
		try {
			clipboardText = Toolkit.getDefaultToolkit()
					.getSystemClipboard()
					.getData(DataFlavor.stringFlavor)
					.toString();
		} catch (IOException | UnsupportedFlavorException ex) {
			sendChatMessage("Unable to read system clipboard.");
			log.warn("error reading clipboard", ex);
			return;
		}

		if (clipboardText.isEmpty())
			return;

		ArrayList<roundExport> importRounds;
		try {
			importRounds = gson.fromJson(clipboardText, new TypeToken<ArrayList<roundExport>>(){}.getType());
		}
		catch (JsonSyntaxException e) {
			sendChatMessage("You do not have any rounds saved to the clipboard");
			return;
		}

		if(importRounds.isEmpty()) {
			sendChatMessage("You do not have any rounds saved to the clipboard");
			return;
		}

		List<Long> roundIds = game.getPastRounds().stream().mapToLong(HideAndSeekRound::getId).boxed().collect(Collectors.toList());
		roundIds.add(game.getActiveRound().getId());

		importRounds.removeIf(r -> roundIds.contains(r.getId()));

		List<HideAndSeekRound> newRounds = importRounds.stream().map(r -> r.toHideAndSeekRound(this)).collect(Collectors.toList());
		game.importRounds(newRounds);

		sendChatMessage("Imported " + importRounds.size() + " round(s) from clipboard");

		panel.getAreaPanel().rebuild();
		updateCaptureAreas();
	}
}

package com.github.jeromkiller.HideAndSeekTracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class HideAndSeekTrackerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(HideAndSeekTrackerPlugin.class);
		RuneLite.main(args);
	}
}
