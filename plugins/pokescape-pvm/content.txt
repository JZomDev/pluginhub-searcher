package com.pokescape;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PokeScapePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(PokescapePlugin.class);
		RuneLite.main(args);
	}
}
package com.pokescape.util;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.pokescape.PokescapePlugin;
import net.runelite.client.callback.ClientThread;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Map;
import java.util.Collections;
import java.util.List;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import static net.runelite.http.api.RuneLiteAPI.GSON;

@Slf4j
public class goalUtils {
    private @Inject ClientThread clientThread;
    private @Inject PokescapePlugin plugin;
    private @Inject Utils utils;


    public String retrieveStateValue(JsonObject conditionParams, String searchCondition, JsonObject playerState) {
        String receivedValue = "null";
        // If a tracked value is saved in an array, retrieve the value using an index key
        if ((conditionParams.has("arrayKey") && !conditionParams.get("arrayKey").isJsonNull()) && conditionParams.has("indexKey") && !conditionParams.get("indexKey").isJsonNull()) {
            String arrayKey = conditionParams.get("arrayKey").getAsString();
            String indexKey = conditionParams.get("indexKey").getAsString();
            if (playerState.has(arrayKey) && playerState.get(arrayKey).isJsonArray()) {
                JsonArray searchArray = playerState.get(arrayKey).getAsJsonArray();
                for (int i = 0; i < searchArray.size(); i++) {
                    String element = searchArray.get(i).getAsString();
                    if (element.equals(indexKey)) {
                        receivedValue = playerState.get(searchCondition).getAsJsonArray().get(i).getAsString();
                        break;
                    }
                }
            }
            // If a tracked value is saved in an object, retrieve the value by traversing the path structure
        } else if (conditionParams.has("pathKey") && !conditionParams.get("pathKey").isJsonNull()) {
            String jsonPath = conditionParams.get("pathKey").getAsString();
            if (playerState.has(searchCondition) && playerState.get(searchCondition).isJsonObject()) {
                JsonObject playerStateObj = playerState.get(searchCondition).getAsJsonObject();
                JsonElement objValue = getObjectValue(playerStateObj, jsonPath);
                if (objValue != null) receivedValue = GSON.toJson(objValue);
            }
            // Otherwise retrieve the value as a string
        } else {
            receivedValue = (playerState.has(searchCondition) && !playerState.get(searchCondition).isJsonNull()) ? playerState.get(searchCondition).getAsString() : "null";
        }
        return receivedValue;
    }

    private JsonElement getObjectValue(JsonObject searchObject, String jsonPath) {
        String[] pathSegments = jsonPath.split("\\.");
        JsonElement traversedElement = searchObject;
        for (String segment : pathSegments) {
            if (segment.contains("[")) {
                String key = segment.substring(0, segment.indexOf("["));
                int segmentIndex = Integer.parseInt(segment.substring(segment.indexOf("[") + 1, segment.indexOf("]")));
                traversedElement = traversedElement.getAsJsonObject().get(key).getAsJsonArray().get(segmentIndex);
            } else {
                traversedElement = traversedElement.getAsJsonObject().get(segment);
            }
        }
        if (traversedElement != null && !traversedElement.isJsonNull()) return traversedElement;
        else return null;
    }

    public boolean compareValues(String op, String receivedValue, JsonArray receivedValues, String targetValue, JsonArray targetValues) {
        boolean valuesMatch = false;
        if (op != null) {
            switch (op) {
                case ("=="): valuesMatch = receivedValue.equals(targetValue); break;
                case ("!="): valuesMatch = !receivedValue.equals(targetValue); break;
                case ("startsWith"): valuesMatch = receivedValue.startsWith(targetValue); break;
                case ("matches"): valuesMatch = receivedValue.matches(targetValue); break;
                case (">"):
                    try { Integer.parseInt(receivedValue); } catch (NumberFormatException e) { break; }
                    valuesMatch = Integer.parseInt(receivedValue) > Integer.parseInt(targetValue); break;
                case ("<"):
                    try { Integer.parseInt(receivedValue); } catch (NumberFormatException e) { break; }
                    valuesMatch = Integer.parseInt(receivedValue) < Integer.parseInt(targetValue); break;
                case (">="):
                    try { Integer.parseInt(receivedValue); } catch (NumberFormatException e) { break; }
                    valuesMatch = Integer.parseInt(receivedValue) >= Integer.parseInt(targetValue); break;
                case ("<="):
                    try { Integer.parseInt(receivedValue); } catch (NumberFormatException e) { break; }
                    valuesMatch = Integer.parseInt(receivedValue) <= Integer.parseInt(targetValue); break;
                case ("contains"):
                    // Process the comparison as an array or string depending on the received and target gamestates
                    if (targetValues != null && targetValues.isJsonArray()) {
                        for (JsonElement arrayValue : targetValues) {
                            if (receivedValue.equals(arrayValue.getAsString())) { valuesMatch = true; break; }
                        }
                    } else if (receivedValues != null && receivedValues.isJsonArray()) {
                        for (JsonElement arrayValue : receivedValues) {
                            if (arrayValue.getAsString().equals(targetValue)) { valuesMatch = true; break; }
                        }
                    } else {
                        valuesMatch = receivedValue.contains(targetValue);
                    }
                    break;
                case ("doesNotContain"):
                    // Process the comparison as an array or string depending on the received and target gamestates
                    if (targetValues != null && targetValues.isJsonArray()) {
                        for (JsonElement arrayValue : targetValues) {
                            valuesMatch = true;
                            if (receivedValue.equals(arrayValue.getAsString())) { valuesMatch = false; break; }
                        }
                    } else if (receivedValues != null && receivedValues.isJsonArray()) {
                        for (JsonElement arrayValue : receivedValues) {
                            valuesMatch = true;
                            if (arrayValue.getAsString().equals(targetValue)) { valuesMatch = false; break; }
                        }
                    } else {
                        valuesMatch = !receivedValue.contains(targetValue);
                    }
                    break;
            }
        }
        return valuesMatch;
    }

    public String distanceFromLocation(String baseCoordHint, String baseCoordFound, Integer playerX, Integer playerY, int x1, int y1, int x2, int y2) {
        // Return if the player is within the target region
        if (playerX >= x1 && playerX <= x2 && playerY <= y1 && playerY >= y2) return baseCoordFound;

        // Get the player's distance and vector from the target
        int xCenter = (x1 + x2) / 2; int yCenter = (y1 + y2) / 2;
        double distance = Math.sqrt(Math.pow(playerX - xCenter, 2) + Math.pow(playerY - yCenter, 2));
        double vector = Math.toDegrees(Math.atan2(playerY - yCenter, playerX - xCenter));

        // Calculate the distance and location and return the hint
        String distanceText = getDistanceText(distance);
        String direction = getDirection(vector);
        return baseCoordHint + direction + ". " + distanceText;
    }

    private static String getDistanceText(double distance) {
        if (distance >= 500) return "The signal is incredibly faint";
        if (distance >= 350) return "The signal is faint";
        if (distance >= 250) return "The signal is weak";
        if (distance >= 150) return "The signal is moderate";
        if (distance >= 100) return "The signal is strong";
        if (distance >= 50) return "The signal is intense";
        return "The signal is incredibly intense";
    }

    private static String getDirection(double vector) {
        List<String> direction = new ArrayList<>();
        if (vector >= 30 && vector <= 150) direction.add("south"); // North of target
        if (vector >= -150 && vector <= -30) direction.add("north"); // South of target
        if ((vector >= -180 && vector <= -120) || (vector >= 120 && vector <= 180)) direction.add("east"); // West of target
        if (vector >= -60 && vector <= 60) direction.add("west"); // East of target
        return String.join("", direction).toLowerCase();
    }

    public void processContainerDeltas(JsonObject playerState) {
        JsonObject lastGearAndItems = playerState.getAsJsonObject("lastGearAndItems");
        // Set the state of the containers pre-update tick
        JsonArray invPreUpdate = lastGearAndItems.get("inventory").getAsJsonObject().get("itemID").getAsJsonArray();
        JsonArray invQtsPreUpdate = lastGearAndItems.get("inventory").getAsJsonObject().get("itemQuantity").getAsJsonArray();
        JsonArray eqpPreUpdate = lastGearAndItems.get("equipment").getAsJsonObject().get("itemID").getAsJsonArray();
        JsonArray eqpQtsPreUpdate = lastGearAndItems.get("equipment").getAsJsonObject().get("itemQuantity").getAsJsonArray();
        clientThread.invokeLater(() -> {
            // Set the state of the containers post-update tick
            JsonObject postGearAndItems = utils.getPlayerItems();
            JsonArray invPostUpdate = postGearAndItems.get("inventory").getAsJsonObject().get("itemID").getAsJsonArray();
            JsonArray invQtsPostUpdate = postGearAndItems.get("inventory").getAsJsonObject().get("itemQuantity").getAsJsonArray();
            JsonArray eqpPostUpdate = postGearAndItems.get("equipment").getAsJsonObject().get("itemID").getAsJsonArray();
            JsonArray eqpQtsPostUpdate = postGearAndItems.get("equipment").getAsJsonObject().get("itemQuantity").getAsJsonArray();

            // Return an object for each container that details items, added/removed, and quantities after update
            JsonObject invUpdate = containerDelta("inventory", invPreUpdate, invPostUpdate, invQtsPreUpdate, invQtsPostUpdate);
            JsonObject eqpUpdate = containerDelta("equipment", eqpPreUpdate, eqpPostUpdate, eqpQtsPreUpdate, eqpQtsPostUpdate);

            // Process each container event
            JsonObject containerEvents = plugin.getContainerEvents();
            containerEvents.keySet().forEach(keyName -> {
                // Get the arguments for the container event
                JsonObject containerObj = containerEvents.get(keyName).getAsJsonObject();
                JsonArray eventItems = containerObj.has("items") && !containerObj.get("items").isJsonNull() ? containerObj.get("items").getAsJsonArray() : new JsonArray();
                JsonObject eventDetails; try { eventDetails = containerObj.get("param").getAsJsonArray().get(0).getAsJsonObject(); } catch (Exception e) { eventDetails = new JsonObject(); }
                String container = eventDetails.has("container") && !eventDetails.get("container").isJsonNull() ? eventDetails.get("container").getAsString() : null;
                String containerAction = eventDetails.has("containerAction") && !eventDetails.get("containerAction").isJsonNull() ? eventDetails.get("containerAction").getAsString() : null;
                JsonArray containerConditions = eventDetails.has("containerConditions") && eventDetails.get("containerConditions").isJsonArray() ? eventDetails.get("containerConditions").getAsJsonArray() : new JsonArray();
                if (container == null || containerAction == null) return;

                // Fetch the container (inventory or equipment) being evaluated by the event
                JsonObject updatedContainer;
                if ("equipment".equals(container)) updatedContainer = eqpUpdate;
                else updatedContainer = invUpdate;

                // Determine if the container has been updated with any event items
                HashSet<Integer> updateSet = jsonArrayToHashSet(updatedContainer.get(containerAction).getAsJsonArray());
                HashSet<Integer> eventSet = jsonArrayToHashSet(eventItems);

                // Test for other event conditions if the event item(s) match the updated item(s)
                if (!Collections.disjoint(updateSet, eventSet)) {
                    int conditionMetCount = 0;
                    for (int i = 0; i < containerConditions.size(); i++) {
                        // Get the parameters to test the condition match
                        String conKey = containerConditions.get(i).getAsJsonObject().get("key").getAsString();
                        String conOp = containerConditions.get(i).getAsJsonObject().get("op").getAsString();
                        String conTarget = containerConditions.get(i).getAsJsonObject().get("target").getAsString();
                        // Test the condition and increment conditionMetCount if the condition passes
                        JsonElement objValue = getObjectValue(playerState, conKey);
                        String conReceived = (objValue != null && objValue.isJsonPrimitive()) ? objValue.getAsString() : null;
                        if (conReceived != null) conReceived = conReceived.replaceAll("\"", "");
                        if (conReceived == null) conReceived = "null";
                        boolean conMatch = compareValues(conOp, conReceived, new JsonArray(), conTarget, new JsonArray());
                        if (conMatch) conditionMetCount += 1;
                    }
                    // Process the event if all event conditions are met
                    if (containerConditions.size() == conditionMetCount) utils.processEvent(keyName, "gameEvent", new JsonArray(), -1, new ArrayList<>(), playerState, -1);
                }
            });
        });
    }

    private JsonObject containerDelta(String containerName, JsonArray preItems, JsonArray postItems, JsonArray preQtys, JsonArray postQtys) {
        JsonObject conUpdate = new JsonObject();
        Map<Integer, Integer> preItemQtyMap = utils.consolidateStacks(preItems, preQtys);
        Map<Integer, Integer> postItemQtyMap = utils.consolidateStacks(postItems, postQtys);
        JsonArray itemsAdded = new JsonArray();
        JsonArray itemsRemoved = new JsonArray();
        JsonArray qtyAdded = new JsonArray();
        JsonArray qtyRemoved = new JsonArray();
        JsonArray totalQty = new JsonArray();

        // Find items added and removed
        for (int postItem : postItemQtyMap.keySet()) {
            if (!preItemQtyMap.containsKey(postItem)) {
                itemsAdded.add(postItem);
                qtyAdded.add(postItemQtyMap.get(postItem));
                totalQty.add(postItemQtyMap.get(postItem));
            }
        }
        for (int preItem : preItemQtyMap.keySet()) {
            if (!postItemQtyMap.containsKey(preItem)) {
                itemsRemoved.add(preItem);
                qtyRemoved.add(preItemQtyMap.get(preItem));
                totalQty.add(0);
            }
        }

        // Find quantity changes for existing items
        for (int preItem : preItemQtyMap.keySet()) {
            if (postItemQtyMap.containsKey(preItem)) {
                int preQty = preItemQtyMap.get(preItem);
                int postQty = postItemQtyMap.get(preItem);
                int quantityChange = postQty - preQty;
                if (quantityChange > 0) {
                    itemsAdded.add(preItem);
                    qtyAdded.add(Math.abs(quantityChange));
                    totalQty.add(postQty);
                } else if (quantityChange < 0) {
                    itemsRemoved.add(preItem);
                    qtyRemoved.add(Math.abs(quantityChange));
                    totalQty.add(postQty);
                }
            }
        }

        conUpdate.addProperty("container", containerName);
        conUpdate.add("added", itemsAdded);
        conUpdate.add("addedQty", qtyAdded);
        conUpdate.add("removed", itemsRemoved);
        conUpdate.add("removedQty", qtyRemoved);
        conUpdate.add("totalQty", totalQty);
        return conUpdate;
    }

    private static HashSet<Integer> jsonArrayToHashSet(JsonArray jsonArray) {
        HashSet<Integer> hashSet = new HashSet<>();
        for (int i = 0; i < jsonArray.size(); i++) {
            int element = jsonArray.get(i).getAsInt();
            hashSet.add(element);
        }
        return hashSet;
    }
}
/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.util;

import com.pokescape.PokescapePlugin;
import com.pokescape.web.PokescapeClient;
import com.pokescape.ui.PokescapePanel;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonObject;
import net.runelite.api.Client;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Actor;
import net.runelite.api.Varbits;
import net.runelite.api.Player;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.InventoryID;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.Text;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Stream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.awt.Color;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class Utils {
    private @Inject Client client;
    private @Inject ClientThread clientThread;
    private @Inject PokescapePlugin plugin;
    private @Inject PokescapeClient sendRequest;
    private @Inject ChatMessageManager chatMessageManager;
    private @Inject PokescapePanel panel;

    private static final Pattern CHECKRIFT_REGEX = Pattern.compile("You have ([0-9.,]+) catalytic energy and ([0-9.,]+) elemental energy. You can use them to search the rift ([0-9.,]+) times. You have searched the rift ([0-9.,]+) times.");
    private static final Pattern CHECKTEMPO_REGEX = Pattern.compile("There is a reward for you to find in the reward pool.|There are ([0-9.,]+) rewards for you to find in the reward pool.");
    private static final Pattern EMPTYTEMPO_REGEX = Pattern.compile("There doesn't seem to be anything here for you. Maybe you could work with the Spirit Anglers...");

    private static final int COX_WIDGET = 32768010;
    private static final int TOA_WIDGET = 31522858;
    private static final int TOB_RAIDERS_VARC = 330;
    private static final int TOA_RAIDERS_VARC = 1099;

    public List<eventObject> matchEvent(JsonObject object, String event, String eventType, String filterKey, String filterValue) {
        List<eventObject> matchedEvent = new ArrayList<>();
        object.keySet().forEach(keyName -> {
            JsonObject keyObj = object.get(keyName).getAsJsonObject();
            String filterKeyValue = keyObj.get(filterKey).getAsString();
            String eventKey = (keyObj.has("event") && !keyObj.get("event").isJsonNull()) ? keyObj.get("event").getAsString() : null;
            if (eventKey != null && (event.startsWith(eventKey) || event.matches(eventKey)) && filterKeyValue.equals(filterValue)) {
                JsonArray eventParameters = new JsonArray();
                if (keyObj.has("param")) eventParameters = keyObj.get("param").getAsJsonArray();
                matchedEvent.add(new eventObject(keyName, eventType, eventParameters));
            }
        });
        return matchedEvent;
    }

    public JsonObject matchActivity(JsonObject recentActivities, JsonObject object, String menuAction, String menuTarget, int animAction) {
        object.keySet().forEach(keyName -> {
            String keyCategory = object.get(keyName).getAsJsonObject().get("category").getAsString();
            if (!recentActivities.has(keyCategory)) recentActivities.add(keyCategory, null);
        });
        object.keySet().forEach(keyName -> {
            JsonObject keyActivity = object.get(keyName).getAsJsonObject();
            String keyCategory = object.get(keyName).getAsJsonObject().get("category").getAsString();
            boolean setToTarget = keyActivity.has("setToTarget") && !keyActivity.get("setToTarget").isJsonNull();
            JsonArray clearCategories = (keyActivity.has("clearCategories") && !keyActivity.get("clearCategories").isJsonNull()) ? keyActivity.get("clearCategories").getAsJsonArray() : null;
            JsonArray actionFilters = (keyActivity.has("menuActions") && !keyActivity.get("menuActions").isJsonNull()) ? keyActivity.get("menuActions").getAsJsonArray() : null;
            JsonArray targetFilters = (keyActivity.has("menuTargets") && !keyActivity.get("menuTargets").isJsonNull()) ? keyActivity.get("menuTargets").getAsJsonArray() : null;
            boolean actionMatch, targetMatch;
            if (actionFilters != null && targetFilters != null) {
                for (int i = 0; i < actionFilters.size(); i++) {
                    actionMatch = (menuAction.matches(actionFilters.get(i).getAsString()));
                    targetMatch = (menuTarget.matches(targetFilters.get(i).getAsString()));
                    if (actionMatch && targetMatch) {
                        if (clearCategories != null) for (JsonElement category : clearCategories)
                            recentActivities.add(category.toString().replaceAll("\"", ""), null);
                        if (setToTarget) recentActivities.addProperty(keyCategory, menuTarget);
                        else recentActivities.addProperty(keyCategory, keyName);
                    }
                }
            }
            if (animAction > -1) {
                JsonArray animFilters = (keyActivity.has("animActions") && !keyActivity.get("animActions").isJsonNull()) ? keyActivity.get("animActions").getAsJsonArray() : null;
                if (animFilters != null) {
                    for (int i = 0; i < animFilters.size(); i++) {
                        boolean animMatch = (animAction == animFilters.get(i).getAsInt());
                        if (animMatch) {
                            if (clearCategories != null) for (JsonElement category : clearCategories)
                                recentActivities.add(category.toString().replaceAll("\"", ""), null);
                            recentActivities.addProperty(keyCategory, keyName);
                        }
                    }
                }
            }
        });
        return recentActivities;
    }

    public Boolean processAllowBlock(JsonObject allowBlockList, String lootName, String lootType) {
        // Return null if the list cannot be found
        if (allowBlockList == null) return null;
        final Boolean[] matchAction = { null };
        allowBlockList.keySet().forEach(keyName -> {
            // Parse the values of each entry in the allowblock list
            String name = "", type = "", action = "";
            JsonObject listEntry = (allowBlockList.has(keyName)) ? allowBlockList.get(keyName).getAsJsonObject() : new JsonObject();
            if (listEntry.has("name") && !listEntry.get("name").isJsonNull())
                name = listEntry.get("name").getAsString();
            if (listEntry.has("type") && !listEntry.get("type").isJsonNull())
                type = listEntry.get("type").getAsString();
            if (listEntry.has("action") && !listEntry.get("action").isJsonNull())
                action = listEntry.get("action").getAsString();
            // If a matching entry is found, return true or false depending on whether the action is allow or block
            boolean nameMatch = lootName.matches(name), typeMatch = lootType.matches(type);
            if (nameMatch && typeMatch) {
                if (action.equals("allow")) matchAction[0] = true;
                if (action.equals("block")) matchAction[0] = false;
            }
        });
        // Returns true or false if matches were found. Return null otherwise
        return matchAction[0];
    }

    public void processEvent(String eventName, String eventType, JsonArray eventParameters, int eventWidget, List<String> messageCollector, JsonObject recentActivities, Integer spriteID) {
        JsonObject eventInfo = new JsonObject();
        boolean suppressRequest = false;
        for (JsonElement param : eventParameters) {
            String eventParam = param.getAsString();
            switch(eventParam) {
                case "widgetInfo":
                    eventInfo.add("widgetInfo", getWidgetInfo(eventWidget, eventParameters));
                    break;
                case "suppressRequest":
                    suppressRequest = true;
                    break;
                case "suppressNullWidget":
                    if (eventInfo.has("widgetInfo") && eventInfo.get("widgetInfo").isJsonNull()) suppressRequest = true;
                    break;
                case "raidInfo":
                    eventInfo.add("raidInfo", getRaidInfo());
                    break;
                case "visiblePlayers":
                    eventInfo.add("visiblePlayers", getVisiblePlayers());
                    break;
                case "playerLocation":
                    eventInfo.add("playerLocation", getPlayerLocation());
                    break;
                case "playerItems":
                    eventInfo.add("playerItems", getPlayerItems());
                    break;
                default:
            }
        }
        if (!suppressRequest) sendRequest.gameEvent(eventName, eventType, messageCollector, eventInfo, recentActivities, spriteID);
    }

    public void matchValidation(PokescapePanel panel, ChatMessage event, String message) {
        // Check stored permits in a populated Tempoross reward pool.
        Matcher matcher = CHECKTEMPO_REGEX.matcher(message);
        if (matcher.find()) {
            int rewardPermits = 0;
            try {
                rewardPermits = Integer.parseInt(matcher.group(1).replaceAll("[.,]", ""));
            } catch (Exception e) {
                rewardPermits = 1;
            }
            if (!panel.getTemporossVerification())
                sendRequest.validateMinigame(panel, "{\"activity\":\"tempoross\",\"rewardPermits\":"+rewardPermits+"}");
        }

        if (event.getType() == ChatMessageType.MESBOX) {
            // Check stored catalytic and elemental energy at the reward guardian.
            matcher = CHECKRIFT_REGEX.matcher(message);
            if (matcher.find()) {
                int catalyticEnergy = Integer.parseInt(matcher.group(1).replaceAll("[.,]",""));
                int elementalEnergy = Integer.parseInt(matcher.group(2).replaceAll("[.,]",""));
                if (!panel.getGotrVerification())
                    sendRequest.validateMinigame(panel, "{\"activity\":\"gotr\",\"catalyticEnergy\":"+catalyticEnergy+",\"elementalEnergy\":"+elementalEnergy+"}");
            }
            // Check stored permits in an empty Tempoross reward pool.
            matcher = EMPTYTEMPO_REGEX.matcher(message);
            if (matcher.find()) {
                int rewardPermits = 0;
                if (!panel.getTemporossVerification())
                    sendRequest.validateMinigame(panel, "{\"activity\":\"tempoross\",\"rewardPermits\":"+rewardPermits+"}");
            }
        }
    }

    public void matchOverhead(OverheadTextChanged event, String eventName, String eventType, JsonArray eventParameters, JsonObject recentActivities) {
        List<String> messageCollector = new ArrayList<>();
        Actor overheadActor = event.getActor();
        Actor followerActor = client.getFollower();
        Actor playerActor = client.getLocalPlayer();
        String overheadActorName = event.getActor().getName();
        String matchOp = eventParameters.get(0).getAsString();
        String actorName = (matchOp.startsWith("Actor=")) ? matchOp.substring(matchOp.indexOf("=")+1) : "";
        if (matchOp.startsWith("Actor=")) matchOp = "matchName";
        switch(matchOp) {
            case "matchFollower":
                if (overheadActor == followerActor)
                    sendRequest.gameEvent(eventName, eventType, messageCollector, null, recentActivities, -1);
                break;
            case "matchSelf":
                if (overheadActor == playerActor)
                    sendRequest.gameEvent(eventName, eventType, messageCollector, null, recentActivities, -1);
                break;
            case "matchName":
                if (Objects.equals(overheadActorName, actorName))
                    sendRequest.gameEvent(eventName, eventType, messageCollector, null, recentActivities, -1);
                break;
            default:
                sendRequest.gameEvent(eventName, eventType, messageCollector, null, recentActivities, -1);
        }
    }

    private JsonObject getWidgetInfo(int targetWidgetID, JsonArray eventParameters) {
        JsonObject widgetInfo = new JsonObject();
        // Go up one level and get the parent of the initial target
        int rootWidgetID = -1;
        for (int i = 0; i < 12; i++) {
            try {
                rootWidgetID = client.getWidget(targetWidgetID, i).getParentId();
            } catch (Exception e) {
            }
            if (rootWidgetID != -1) break;
        }
        // Processes all the childen of the root widget to generate a json object of all available text and sprites
        if (rootWidgetID != -1) processWidgetNodes(rootWidgetID, widgetInfo, 0, new int[]{0,0});

        // If filters are included with the event, apply them to the generated json object
        // This reduces the size of the request payload and restructures the widget data to have meaningful key-value pairs
        List<String> filterKeys = new ArrayList<>();
        List<String> renameKeys = new ArrayList<>();
        List<String> filterEVKeys = new ArrayList<>();
        String bitArrayKey = null;
        String playerStateKey = null;
        int delayDupeWidget = 0;
        for (JsonElement param : eventParameters) {
            String eventParam = param.getAsString();
            if (eventParam.startsWith("filterKeys="))
                filterKeys = Arrays.asList(eventParam.substring(eventParam.indexOf("=") + 1).split(","));
            if (eventParam.startsWith("renameKeys="))
                renameKeys = Arrays.asList(eventParam.substring(eventParam.indexOf("=") + 1).split(","));
            if (eventParam.startsWith("filterEVKeys="))
                filterEVKeys = Arrays.asList(eventParam.substring(eventParam.indexOf("=") + 1).split(","));
            if (eventParam.startsWith("makeBitArray=")) bitArrayKey = eventParam.substring(eventParam.indexOf("=") + 1);
            if (eventParam.startsWith("setPlayerState="))
                playerStateKey = eventParam.substring(eventParam.indexOf("=") + 1);
            if (eventParam.startsWith("delayDupeWidget")) {
                try {
                    delayDupeWidget = Integer.parseInt(eventParam.split("delayDupeWidget=")[1]);
                } catch (Exception e) {
                    delayDupeWidget = 2;
                }
            }
        }
        if (rootWidgetID != -1 && (filterKeys.size() > 0 || renameKeys.size() > 0))
            widgetInfo = filterWidgetInfo(widgetInfo, filterKeys, renameKeys, bitArrayKey, filterEVKeys, delayDupeWidget);

        // If requested, set the playerState to the processed widget data
        if (playerStateKey != null && widgetInfo != null && widgetInfo.has(playerStateKey)) {
            JsonObject playerState = plugin.getPlayerState();
            playerState.add(playerStateKey, widgetInfo.get(playerStateKey));
            plugin.setPlayerState(playerState);
        }
        return widgetInfo;
    }

    private void processWidgetNodes(int widgetID, JsonObject widgetStructure, int searchIteration, int[] childIteration) {
        // Grab all possible children of the target widget and concatenate them into a single array
        Widget[] sChildren = Objects.requireNonNull(client.getWidget(widgetID)).getStaticChildren();
        Widget[] nChildren = Objects.requireNonNull(client.getWidget(widgetID)).getNestedChildren();
        Widget[] dChildren = Objects.requireNonNull(client.getWidget(widgetID)).getDynamicChildren();
        Widget[] allChildren = Stream.concat(Stream.concat(Arrays.stream(sChildren), Arrays.stream(nChildren)), Arrays.stream(dChildren)).toArray(Widget[]::new);
        // For every child widget, search for text/sprite values, generate a unique key and add it the key-value to the json object
        for (int i = 0; i < allChildren.length; i++) {
            if (!allChildren[i].getText().equals("")) {
                String key = "Text_"+searchIteration+i;
                key = genUniqueStaticKey(widgetStructure, childIteration[0], key);
                widgetStructure.addProperty(key, Text.removeTags(allChildren[i].getText()));
            }
            if (allChildren[i].getSpriteId() > -1) {
                String key = "SpriteID_"+searchIteration+i;
                key = genUniqueStaticKey(widgetStructure, childIteration[1], key);
                widgetStructure.addProperty(key, allChildren[i].getSpriteId());
            }
            // Repeat the process for each node that has its own children
            // Most widgets won't have more than 50 total nodes, but for safety we cap this at 200 iterations
            if (allChildren[i].getId() != allChildren[i].getParentId() && allChildren[i].getParentId() != -1 && searchIteration < 200) {
                searchIteration += 1;
                processWidgetNodes(allChildren[i].getId(), widgetStructure, searchIteration, new int[]{0,0});
            }
        }
    }

    private String genUniqueStaticKey(JsonObject widgetStructure, int childIteration, String key) {
        if (widgetStructure.has(key)) {
            childIteration += 1;
            key = key+childIteration;
        }
        if (widgetStructure.has(key)) return genUniqueStaticKey(widgetStructure, childIteration, key);
        else return key;
    }

    private JsonObject filterWidgetInfo(JsonObject widgetStructure, List<String> filterKeys, List<String> renameKeys, String bitArrayKey, List<String> filterEVKeys, int delayDupeWidget) {
        JsonObject filteredStructure = new JsonObject();
        // Only add keys that are included in the filterkeys list
        for (String key : filterKeys) if (widgetStructure.has(key)) filteredStructure.add(key, widgetStructure.get(key));
        // Rename generated keys to the provided rename keys
        for (String key : renameKeys) {
            List<String> rename = Arrays.asList(key.split("::"));
            String oldName = rename.get(0);
            String newName = rename.get(1);
            // Return the key value as a boolean if there are mapped values provided
            List<String> boolValues = new ArrayList<>();
            if (newName.contains("!!")) {
                List<String> boolOp = Arrays.asList(newName.split("!!"));
                newName = boolOp.get(0);
                boolValues = Arrays.asList(boolOp.get(1).split(":"));
            }
            JsonElement returnValue = widgetStructure.get(oldName);
            if (boolValues.size() == 2) {
                if (returnValue.toString().equals(boolValues.get(0))) returnValue = new JsonPrimitive(true);
                if (returnValue.toString().equals(boolValues.get(1))) returnValue = new JsonPrimitive(false);
            }
            if (filteredStructure.has(oldName)) {
                filteredStructure.remove(oldName);
                filteredStructure.add(newName, returnValue);
            }
        }
        // Filter the result based on a target keyword
        if (filterEVKeys.size() > 0) {
            boolean eventValueFound = false;
            for (String eventValue : filterEVKeys) {
                // If the filter key is looking for the player's name replace the tag
                if (eventValue.contains("@localPlayerName") && client.getLocalPlayer().getName() != null) {
                    eventValue = eventValue.replace("@localPlayerName", client.getLocalPlayer().getName());
                }
                for (String key : filteredStructure.keySet()) {
                    JsonElement value = filteredStructure.get(key);
                    if (value.isJsonPrimitive() && value.getAsJsonPrimitive().isString()) {
                        String strValue = value.getAsString();
                        if (strValue.matches(eventValue)) {
                            eventValueFound = true;
                            break;
                        }
                    }
                }
                if (eventValueFound) break;
            }
            if (eventValueFound && delayDupeWidget != 0) plugin.setDelayDupeWidget(delayDupeWidget);
            if (!eventValueFound) return null;
        }
        // Optional argument to pack booleans into an array to reduce transmission size. filterKeys sets the index order
        // Could use an int/long bitfield, but an array is more flexible if more than 64 bits need to be represented
        if (bitArrayKey != null) {
            JsonArray bitArray = new JsonArray();
            List<String> keyList = new ArrayList<>(filteredStructure.keySet());
            for (String key : keyList) {
                // We test for literal "true" or "false" strings so non-boolean values are filtered out from the array
                String value = filteredStructure.get(key).getAsString();
                if (value.equals("true")) bitArray.add(1);
                if (value.equals("false")) bitArray.add(0);
            }
            filteredStructure = new JsonObject();
            filteredStructure.add(bitArrayKey, bitArray);
        }
        return filteredStructure;
    }

    public void updateLootInfo(JsonObject recentActivities, String npcName, List<String> lootName, List<Integer> lootID, List<Integer> lootQuantity) {
        try {
            if (recentActivities.has("lastLootNPCName")) recentActivities.addProperty("lastLootNPCName", npcName);
            if (recentActivities.has("lastLootItems")) {
                JsonObject lootObject = new JsonObject();
                lootObject.add("lootName", new JsonArray());
                lootObject.add("lootID", new JsonArray());
                lootObject.add("lootQuantity", new JsonArray());
                for (String itemName : lootName) lootObject.get("lootName").getAsJsonArray().add(itemName);
                for (Integer itemID : lootID) lootObject.get("lootID").getAsJsonArray().add(itemID);
                for (Integer itemQuantity : lootQuantity) lootObject.get("lootQuantity").getAsJsonArray().add(itemQuantity);
                recentActivities.add("lastLootItems", lootObject);
            }
        } catch (Exception ignored) {}
    }

    public void sendLocalChatMsg(JsonArray messageStructure) {
        // Initialize the chat message builder
        ChatMessageBuilder messageBuilder = new ChatMessageBuilder();
        // Iterate through the color and message keys to build the message. This allows for multicolored messages
        for (JsonElement msgElem : messageStructure) {
            JsonObject msgObj; Color chatColor = Color.WHITE; String message = "";
            try {
                msgObj = msgElem.getAsJsonObject();
                if (msgObj != null && msgObj.has("color") && !msgObj.get("color").isJsonNull()) {
                    String hexColor = msgObj.get("color").getAsString();
                    try { chatColor = Color.decode(hexColor); }
                    catch(Exception e) { log.debug("Color could not be parsed"); }
                }
                if (msgObj != null && msgObj.has("message") && !msgObj.get("message").isJsonNull()) {
                    message = msgObj.get("message").getAsString();
                }
                messageBuilder.append(chatColor, message);
            } catch (Exception e) {
                log.debug("Message could not be parsed");
                break;
            }
        }
        // Send the message
        final String chatMessage = messageBuilder.build();
        if (!chatMessage.isEmpty()) chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.CONSOLE).runeLiteFormattedMessage(chatMessage).build());
    }

    private JsonObject getRaidInfo() {
        int raidersVarc, totalPoints = 0, personalPoints = 0, coxSize = 0, toaLevel;
        String raidName = "";
        JsonArray raidParty = new JsonArray();
        JsonArray toaInvosActive = new JsonArray();

        // Get CoX party members if the raid varbit is set
        int coxState = client.getVarbitValue(Varbits.IN_RAID);
        if (coxState > 0) {
            Widget coxWidget = client.getWidget(COX_WIDGET);
            if (coxWidget != null) {
                Widget[] coxParty = coxWidget.getChildren();
                if (coxParty != null) {
                    for (Widget widget : coxParty) {
                        String partyEntry = widget.getText();
                        if (partyEntry.startsWith("<col=ffffff>")) {
                            String playerName = Text.removeTags(partyEntry);
                            raidParty.add(playerName);
                        }
                    }
                }
            }
            totalPoints = client.getVarbitValue(Varbits.TOTAL_POINTS);
            personalPoints = client.getVarbitValue(Varbits.PERSONAL_POINTS);
            coxSize = client.getVarbitValue(Varbits.RAID_PARTY_SIZE);
            raidName = "cox";
        }

        // Get ToB party members if the tob state is set to "inside"
        int tobState = client.getVarbitValue(Varbits.THEATRE_OF_BLOOD);
        if (tobState > 1) {
            raidersVarc = TOB_RAIDERS_VARC;
            int maxPartySize = 5;
            processRaidVarcs(raidersVarc, maxPartySize, raidParty);
            raidName = "tob";
        }

        // Get ToA party members if the invocation level is being displayed
        Widget toaWidget = client.getWidget(TOA_WIDGET);
        if (toaWidget != null) {
            raidersVarc = TOA_RAIDERS_VARC;
            int maxPartySize = 8;
            JsonObject playerState = plugin.getPlayerState();
            if (playerState.has("toaInvos") && playerState.get("toaInvos").isJsonArray()) {
                toaInvosActive = playerState.get("toaInvos").getAsJsonArray();
            }
            processRaidVarcs(raidersVarc, maxPartySize, raidParty);
            raidName = "toa";
        }

        // Return json object containing raid info
        JsonObject raidInfo = new JsonObject();
        int raidSize = raidParty.size();
        raidInfo.add("members", raidParty);
        switch (raidName) {
            case "cox":
                raidInfo.addProperty("totalPts", totalPoints);
                raidInfo.addProperty("personalPts", personalPoints);
                raidInfo.addProperty("size", coxSize);
                break;
            case "tob":
                raidInfo.addProperty("size", raidSize);
                break;
            case "toa":
                raidInfo.addProperty("size", raidSize);
                try {toaLevel = Integer.parseInt(toaWidget.getText().replace("Level: ", ""));
                } catch (Exception e) { toaLevel = 0; }
                raidInfo.addProperty("invo", toaLevel);
                raidInfo.add("invosActive", toaInvosActive);
                break;
        }

        return raidInfo;
    }

    private void processRaidVarcs(int raidersVarc, int maxPartySize, JsonArray raidParty) {
        for (int i = 0; i < maxPartySize; i++) {
            String playerName = client.getVarcStrValue(raidersVarc + i);
            playerName = playerName.replaceAll("[^a-zA-Z0-9]", " ");
            if (!playerName.isEmpty()) raidParty.add(playerName);
        }
    }

    private JsonArray getVisiblePlayers() {
        // Returns the names of the first 25 players visible to the player
        JsonArray renderedPlayers = new JsonArray();
        List<Player> players = client.getPlayers();
        for (Player player : players) {
            String playerName = player.getName();
            renderedPlayers.add(playerName);
            if (renderedPlayers.size() >= 25) break;
        }
        return renderedPlayers;
    }

    public JsonObject getPlayerLocation() {
        // Returns coordinates and regions of the player
        JsonObject locationInfo = new JsonObject();
        locationInfo.addProperty("worldX", client.getLocalPlayer().getWorldLocation().getX());
        locationInfo.addProperty("worldY", client.getLocalPlayer().getWorldLocation().getY());
        locationInfo.addProperty("region", client.getLocalPlayer().getWorldLocation().getRegionID());
        locationInfo.addProperty("regionX", client.getLocalPlayer().getWorldLocation().getRegionX());
        locationInfo.addProperty("regionY", client.getLocalPlayer().getWorldLocation().getRegionY());
        locationInfo.addProperty("plane", client.getLocalPlayer().getWorldLocation().getPlane());
        JsonArray regions = new JsonArray();
        int[] regionIDs = client.getMapRegions();
        for (int regionID : regionIDs) regions.add(regionID);
        locationInfo.add("regions", regions);
        return locationInfo;
    }

    public JsonObject getPlayerItems() {
        // Fetch the player's inventory and gear containers
        ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);

        // Map gear to named slots. Set to null if nothing is equipped in the slot
        HashMap<String, Integer> equipmentSlots = new HashMap<>();
        if (equipment != null) {
            equipmentSlots.put("head", equipment.getItem(0) != null ? Objects.requireNonNull(equipment.getItem(0)).getId() : null);
            equipmentSlots.put("cape", equipment.getItem(1) != null ? Objects.requireNonNull(equipment.getItem(1)).getId() : null);
            equipmentSlots.put("neck", equipment.getItem(2) != null ? Objects.requireNonNull(equipment.getItem(2)).getId() : null);
            equipmentSlots.put("weapon", equipment.getItem(3) != null ? Objects.requireNonNull(equipment.getItem(3)).getId() : null);
            equipmentSlots.put("body", equipment.getItem(4) != null ? Objects.requireNonNull(equipment.getItem(4)).getId() : null);
            equipmentSlots.put("shield", equipment.getItem(5) != null ? Objects.requireNonNull(equipment.getItem(5)).getId() : null);
            equipmentSlots.put("legs", equipment.getItem(7) != null ? Objects.requireNonNull(equipment.getItem(7)).getId() : null);
            equipmentSlots.put("hands", equipment.getItem(9) != null ? Objects.requireNonNull(equipment.getItem(9)).getId() : null);
            equipmentSlots.put("feet", equipment.getItem(10) != null ? Objects.requireNonNull(equipment.getItem(10)).getId() : null);
            equipmentSlots.put("jaw", equipment.getItem(11) != null ? Objects.requireNonNull(equipment.getItem(11)).getId() : null);
            equipmentSlots.put("ring", equipment.getItem(12) != null ? Objects.requireNonNull(equipment.getItem(12)).getId() : null);
            equipmentSlots.put("ammo", equipment.getItem(13) != null ? Objects.requireNonNull(equipment.getItem(13)).getId() : null);
        }

        // Map all items to their respective containers
        Item[] itemsInventory = inventory != null ? inventory.getItems() : new Item[0];
        Item[] itemsEquipped = equipment != null ? equipment.getItems() : new Item[0];
        HashMap<String, Item[]> allItems = new HashMap<>();
        allItems.put("inventory", itemsInventory);
        allItems.put("equipment", itemsEquipped);

        // Convert mapped containers and return json object containing gear+inventory info
        JsonObject inventoryInfo = new JsonObject();
        for (String containerName : allItems.keySet()) {
            JsonObject containerItems = new JsonObject();
            JsonArray itemIDs = new JsonArray();
            JsonArray itemQuantities = new JsonArray();
            for (Item item : allItems.get(containerName)) {
                if (item.getId() != -1) itemIDs.add(item.getId());
                if (item.getId() > 0) itemQuantities.add(item.getQuantity());
            }
            containerItems.add("itemID", itemIDs);
            containerItems.add("itemQuantity", itemQuantities);
            // Create key-values for all inv items and their quantities
            if (containerName.equals("inventory")) {
                Map<Integer, Integer> itemQtyHashMap = consolidateStacks(itemIDs, itemQuantities);
                JsonObject itemQtyMap = mapToJsonObject(itemQtyHashMap);
                containerItems.add("itemQtyMap", itemQtyMap);
            }
            if (containerName.equals("equipment")) {
                JsonObject gearSlots = new JsonObject();
                for (String slot : equipmentSlots.keySet()) {
                    gearSlots.addProperty(slot, equipmentSlots.get(slot));
                }
                containerItems.add("slot", gearSlots);
            }
            inventoryInfo.add(containerName, containerItems);
        }
        return inventoryInfo;
    }

    public Map<Integer, Integer> consolidateStacks(JsonArray items, JsonArray qtys) {
        Map<Integer, Integer> itemQtyMap = new HashMap<>();
        Iterator<JsonElement> itemsIterator = items.iterator();
        Iterator<JsonElement> qtysIterator = qtys.iterator();
        while (itemsIterator.hasNext() && qtysIterator.hasNext()) {
            int item = itemsIterator.next().getAsInt();
            int qty = qtysIterator.next().getAsInt();
            itemQtyMap.put(item, itemQtyMap.getOrDefault(item, 0) + qty);
        }
        return itemQtyMap;
    }

    private JsonObject mapToJsonObject(Map<Integer, Integer> map) {
        JsonObject jsonObject = new JsonObject();
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            jsonObject.addProperty(entry.getKey().toString(), entry.getValue());
        }
        return jsonObject;
    }
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.util;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.pokescape.PokescapePlugin;
import net.runelite.api.InventoryID;
import net.runelite.api.Player;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.VarPlayer;
import static net.runelite.api.ChatMessageType.ENGINE;
import static net.runelite.api.ChatMessageType.GAMEMESSAGE;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.ComponentID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.NPCManager;
import net.runelite.client.util.Text;
import static net.runelite.http.api.RuneLiteAPI.GSON;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.Map;
import java.util.List;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class PokeScapeGoals {
    private @Inject Client client;
    private @Inject ClientThread clientThread;
    private @Inject EventBus eventBus;
    private @Inject Utils utils;
    private @Inject goalUtils goalUtils;
    private @Inject PokescapePlugin plugin;
    private @Inject NPCManager npcManager;

    private static JsonObject gameActivities;
    private static JsonObject playerState;
    private static JsonArray activeGoals;
    private static JsonArray evaluateConditions;
    private final LinkedHashMap<String, String> goalTypes = new LinkedHashMap<>();
    private final LinkedHashMap<Integer, String> damageMap = new LinkedHashMap<>();
    private final List<Integer> varbitFilter = new ArrayList<>();
    private final List<Integer> scriptFilter = new ArrayList<>();
    private final List<Integer> attackFilter = new ArrayList<>();
    private boolean varbsInitialized;
    private int hitsplatCount;
    private int totalDamage;

    public void startUp() {
        clearState();
        eventBus.register(this);
    }

    public void shutDown() {
        eventBus.unregister(this);
        clearState();
    }

    private void clearState() {
        activeGoals = null;
        playerState = null;
    }

    public void setGoals(JsonArray goals) {
        // Add goals if there are no active goals
        if (activeGoals == null || activeGoals.size() < 1) activeGoals = goals;

        // Sync goals: Add new goals and remove completed goals without overwriting active goals
        JsonArray syncedGoals = new JsonArray();
        for (int i = 0; i < goals.size(); i++) {
            JsonObject goal = goals.get(i).getAsJsonObject();
            if (goal.has("goalName") && !goal.get("goalName").isJsonNull()) {
                String receivedGoalName = goal.get("goalName").getAsString();
                boolean matchFound = false;
                for (int j = 0; j < activeGoals.size(); j++) {
                    JsonObject activeGoal = activeGoals.get(j).getAsJsonObject();
                    String activeGoalName = "";
                    if (activeGoal.has("goalName") && !activeGoal.get("goalName").isJsonNull()) {
                        activeGoalName = activeGoal.get("goalName").getAsString();
                    }
                    if (activeGoalName.equals(receivedGoalName)) {
                        matchFound = true;
                        syncedGoals.add(activeGoal);
                    }
                }
                if (!matchFound) syncedGoals.add(goal);
            }
        }
        activeGoals = syncedGoals;

        // Notify the player for each new goal they have. Only notifies once per session or when assigned a new goal
        for (int i = 0; i < activeGoals.size(); i++) {
            JsonObject goal = activeGoals.get(i).getAsJsonObject();
            boolean playerNotified = true;
            if (goal.has("playerNotified") && !goal.get("playerNotified").isJsonNull()) {
                playerNotified = goal.get("playerNotified").getAsBoolean();
            }
            if (!playerNotified && goal.has("goalNotify") && !goal.get("goalNotify").isJsonNull()) {
                activeGoals.get(i).getAsJsonObject().addProperty("playerNotified", true);
                JsonArray goalNotification = goal.get("goalNotify").getAsJsonArray();
                if (goalNotification.isJsonArray()) utils.sendLocalChatMsg(goalNotification);
            }
        }

        // Initialize the activities and the playerstate
        if (gameActivities == null) gameActivities = plugin.getGameActivities();
        if (gameActivities != null && playerState == null) setPlayerState();
    }

    public void setPlayerState() {
        gameActivities = plugin.getGameActivities();
        if (gameActivities != null && gameActivities.isJsonObject()) {
            playerState = plugin.getPlayerState();
            if (gameActivities.has("goalTypes") && gameActivities.get("goalTypes").getAsJsonObject().get("types").isJsonArray() &&
                gameActivities.get("goalTypes").getAsJsonObject().get("states").isJsonArray()) {
                JsonArray types = gameActivities.get("goalTypes").getAsJsonObject().get("types").getAsJsonArray();
                JsonArray states = gameActivities.get("goalTypes").getAsJsonObject().get("states").getAsJsonArray();
                for (int i = 0; i < types.size(); i++) goalTypes.put(types.get(i).getAsString(), states.get(i).getAsString());
            }
            if (gameActivities.has("evaluateConditions") && gameActivities.get("evaluateConditions").getAsJsonObject().get("conditions").isJsonArray()) {
                evaluateConditions = gameActivities.get("evaluateConditions").getAsJsonObject().get("conditions").getAsJsonArray();
            }
            if (gameActivities.has("filterActivities") && gameActivities.get("filterActivities").getAsJsonObject().get("filter").isJsonArray()) {
                playerState.add("filterActivities", gameActivities.get("filterActivities").getAsJsonObject().get("filter").getAsJsonArray());
            }
            if (gameActivities.has("nullOnLoot") && gameActivities.get("nullOnLoot").getAsJsonObject().get("null").isJsonArray()) {
                playerState.add("nullOnLoot", gameActivities.get("nullOnLoot").getAsJsonObject().get("null").getAsJsonArray());
            }
            if (gameActivities.has("trackedSkills") && gameActivities.get("trackedSkills").getAsJsonObject().get("skills").isJsonArray()) {
                playerState.add("trackedSkills", gameActivities.get("trackedSkills").getAsJsonObject().get("skills").getAsJsonArray());
            }
            if (gameActivities.has("damageMap") && gameActivities.get("damageMap").getAsJsonObject().get("damage").isJsonArray() &&
                    gameActivities.get("damageMap").getAsJsonObject().get("source").isJsonArray()) {
                JsonArray dmg = gameActivities.get("damageMap").getAsJsonObject().get("damage").getAsJsonArray();
                JsonArray source = gameActivities.get("damageMap").getAsJsonObject().get("source").getAsJsonArray();
                for (int i = 0; i < dmg.size(); i++) damageMap.put(dmg.get(i).getAsInt(), source.get(i).getAsString());
            }
            if (gameActivities.has("trackedVarbits") && gameActivities.get("trackedVarbits").getAsJsonObject().get("varbits").isJsonArray() &&
                gameActivities.get("trackedVarbits").getAsJsonObject().get("varTypes").isJsonArray()  &&
                gameActivities.get("trackedVarbits").getAsJsonObject().get("initValues").isJsonArray()) {
                JsonArray varbits = gameActivities.get("trackedVarbits").getAsJsonObject().get("varbits").getAsJsonArray();
                JsonArray varTypes = gameActivities.get("trackedVarbits").getAsJsonObject().get("varTypes").getAsJsonArray();
                JsonArray initValues = gameActivities.get("trackedVarbits").getAsJsonObject().get("initValues").getAsJsonArray();
                for (int i = 0; i < varbits.size(); i++) varbitFilter.add(varbits.get(i).getAsInt());
                playerState.add("trackedVarbits", varbits);
                playerState.add("varTypes", varTypes);
                playerState.add("lastVarbitValues", initValues);
                varbsInitialized = false;
            }
            if (gameActivities.has("trackedScripts") && gameActivities.get("trackedScripts").getAsJsonObject().get("scripts").isJsonArray()) {
                JsonArray scripts = gameActivities.get("trackedScripts").getAsJsonObject().get("scripts").getAsJsonArray();
                for (int i = 0; i < scripts.size(); i++) scriptFilter.add(i,scripts.get(i).getAsInt());
            }
            if (gameActivities.has("Melee") && gameActivities.get("Melee").getAsJsonObject().get("animActions").isJsonArray()) {
                JsonArray attacks = gameActivities.get("Melee").getAsJsonObject().get("animActions").getAsJsonArray();
                for (int i = 0; i < attacks.size(); i++) attackFilter.add(i,attacks.get(i).getAsInt());
            }
            if (gameActivities.has("Ranged") && gameActivities.get("Ranged").getAsJsonObject().get("animActions").isJsonArray()) {
                JsonArray attacks = gameActivities.get("Ranged").getAsJsonObject().get("animActions").getAsJsonArray();
                for (int i = 0; i < attacks.size(); i++) attackFilter.add(i,attacks.get(i).getAsInt());
            }
            if (gameActivities.has("Magic") && gameActivities.get("Magic").getAsJsonObject().get("animActions").isJsonArray()) {
                JsonArray attacks = gameActivities.get("Magic").getAsJsonObject().get("animActions").getAsJsonArray();
                for (int i = 0; i < attacks.size(); i++) attackFilter.add(i,attacks.get(i).getAsInt());
            }
            if (gameActivities.has("lastGearAndItems")) playerState.add("lastGearAndItems", utils.getPlayerItems());
            if (gameActivities.has("lastLocation")) playerState.add("lastLocation", utils.getPlayerLocation());
        }
    }

    @Subscribe
    public void onGameTick(GameTick tick) {
        if (playerState == null || gameActivities == null) return;
        // Initialize varbit values
        if (!varbsInitialized) { varbsInitialized = true; trackVarbitChanges(); }

        // If the goal has started and has timers, run the evaluation every tick
        boolean evalEveryTick = false;
        for (int i = 0; i < activeGoals.size(); i++) {
            JsonObject goal = activeGoals.get(i).getAsJsonObject();
            if (goal.has("goalState") && !goal.get("goalState").isJsonNull() && goal.get("goalState").getAsString().equals("open") && goal.has("openTimer")) {
                evalEveryTick = true;
            }
            if (goal.has("goalState") && !goal.get("goalState").isJsonNull() && goal.get("goalState").getAsString().equals("started") && goal.has("startTimer")) {
                evalEveryTick = true;
            }
            if (goal.has("timerInRegion") && !goal.get("timerInRegion").isJsonNull() && playerState.has("lastLocation") && !playerState.get("lastLocation").isJsonNull()
            && playerState.get("lastLocation").getAsJsonObject().has("region") && !playerState.get("lastLocation").getAsJsonObject().get("region").isJsonNull()) {
                int lastRegion = playerState.get("lastLocation").getAsJsonObject().get("region").getAsInt();
                int targetRegion = goal.get("timerInRegion").getAsInt();
                if (lastRegion == targetRegion) evalEveryTick = true;
            }
        }
        if (evalEveryTick) evaluateGoal(true);
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (playerState == null || gameActivities == null) return;
        if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM &&
            event.getType() != ChatMessageType.FRIENDSCHATNOTIFICATION && event.getType() != ChatMessageType.MESBOX &&
            event.getType() != ChatMessageType.DIALOG) return;
        // Evaluate the goal requirements on each message
        if (playerState.has("lastChatMessage")) {
            String chatMessage = Text.removeTags(event.getMessage());
            playerState.addProperty("lastChatMessage", chatMessage);
            evaluateGoal(false);
        }
    }

    @Subscribe
    public void onScriptCallbackEvent(ScriptCallbackEvent event) {
        if (!"chatFilterCheck".equals(event.getEventName()) || playerState == null || gameActivities == null) return;

        // Get the game messages to filter out
        Set<String> filteredMessages = new HashSet<>();
        for (int i = 0; i < activeGoals.size(); i++) {
            JsonObject goal = activeGoals.get(i).getAsJsonObject();
            if (goal.has("filteredGameMessages") && goal.get("filteredGameMessages").isJsonArray()) {
                JsonArray filteredGameMessages = goal.get("filteredGameMessages").getAsJsonArray();
                for (JsonElement element : filteredGameMessages) filteredMessages.add(element.getAsString());
            } else {
                return;
            }
        }

        // Get the buffered messages
        int[] intStack = client.getIntStack();
        int intStackSize = client.getIntStackSize();
        String[] stringStack = client.getStringStack();
        int stringStackSize = client.getStringStackSize();

        // Get the content and type of the buffered messages
        final int messageType = intStack[intStackSize - 2];
        String message = stringStack[stringStackSize - 1];
        ChatMessageType chatMessageType = ChatMessageType.of(messageType);

        // Block game messages on the filtered list
        if ((chatMessageType == GAMEMESSAGE || chatMessageType == ENGINE) && filteredMessages.contains(message)) {
            intStack[intStackSize - 3] = 0;
        }
    }

    @Subscribe
    private void onStatChanged(StatChanged event) {
        if (playerState == null || gameActivities == null) return;
        // Track changes to skills and evaluate the goal requirements each time a tracked stat updates
        boolean restartTracking = false;
        trackStatChanges(restartTracking);
        evaluateGoal(false);
    }

    @Subscribe
    private void onVarbitChanged(VarbitChanged event) {
        if (playerState == null || gameActivities == null || (!varbitFilter.contains(event.getVarbitId()) && !varbitFilter.contains(event.getVarpId()))) return;
        // Track varbits and evaluate the goal requirements each time a tracked varbit updates
        trackVarbitChanges();
        evaluateGoal(false);
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (playerState == null || gameActivities == null || !scriptFilter.contains(event.getScriptId())) return;
        // Evaluate the goal requirements each time a script fires
        // Upstream can be very spammy even after filtering. We gate this so downstream only evaluates at most once a tick
        if (playerState.has("lastScriptPostFired") && playerState.get("lastScriptPostFired").isJsonNull()) {
            playerState.addProperty("lastScriptPostFired", event.getScriptId());
            clientThread.invokeLater(() -> evaluateGoal(false));
        }
    }

    @Subscribe
    private void onGameStateChanged(GameStateChanged event) {
        if (playerState == null || gameActivities == null) return;
        GameState areaLoaded = event.getGameState();
        if (areaLoaded != GameState.LOGGED_IN && areaLoaded != GameState.LOGIN_SCREEN && areaLoaded != GameState.HOPPING) return;
        // Evaluate the goal requirements each time a map region is loaded
        int loadedRegion = client.getLocalPlayer().getWorldLocation().getRegionID();
        trackRegionChanges(loadedRegion);
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event) {
        if (playerState == null || gameActivities == null) return;
        // Evaluate the goal requirements each time gear or inventory changes
        if (event.getContainerId() == InventoryID.EQUIPMENT.getId() || event.getContainerId() == InventoryID.INVENTORY.getId()) {
            if (playerState.has("lastGearAndItems")) {
                if (event.getContainerId() == InventoryID.INVENTORY.getId()) goalUtils.processContainerDeltas(playerState);
                playerState.add("lastGearAndItems", utils.getPlayerItems());
            }
            evaluateGoal(false);
        }
    }

    @Subscribe
    public void onItemDespawned(ItemDespawned event) {
        if (playerState == null || gameActivities == null) return;
        // Detect the last item the player has picked an item from the ground, tables or adjacent tiles
        trackLastItemPickup(event);
    }

    @Subscribe
    private void onAnimationChanged(AnimationChanged event) {
        if (playerState == null || gameActivities == null) return;
        if (event.getActor() == client.getLocalPlayer()) {
            int lastPlayerAnim = event.getActor().getAnimation();
            playerState = plugin.getPlayerState();
            gameActivities = plugin.getGameActivities();
            // Record changes to tracked animations to the playerstate
            playerState = utils.matchActivity(playerState, gameActivities, "", "", lastPlayerAnim);
            if (playerState.has("lastPlayerAnim")) playerState.addProperty("lastPlayerAnim", lastPlayerAnim);
            if (attackFilter.contains(lastPlayerAnim)) {
                if (playerState.has("lastAttackAnim")) playerState.addProperty("lastAttackAnim", lastPlayerAnim);
                if (playerState.has("lastItemsOnAttack")) playerState.add("lastItemsOnAttack", utils.getPlayerItems());
            }
            clientThread.invokeLater(() -> evaluateGoal(false));
        }
    }

    @Subscribe
    private void onHitsplatApplied(HitsplatApplied event) {
        if (playerState == null || gameActivities == null) return;
        // Track the last damage dealt and taken.
        String lastTargetInstance = (playerState.has("lastTargetInstance") && !playerState.get("lastTargetInstance").isJsonNull()) ?
                playerState.get("lastTargetInstance").getAsString() : "";
        // Evaluate the goal requirements each time damage is dealt (on the next tick) or taken
        if (event.getActor().toString().equals(lastTargetInstance) && playerState.has("lastDmgDealt")) {
            playerState.addProperty("lastDmgDealt", event.getHitsplat().getAmount());
            // We sum of all damage dealt to the NPC this tick so we have the total damage available to process the next tick
            // This is needed to get the correct damage output from scythe, claw/hally specs, damage stacked with venge/thralls, etc.
            hitsplatCount += 1;
            totalDamage += event.getHitsplat().getAmount();
            clientThread.invokeLater(() -> attackedFromFullHP(event, totalDamage, hitsplatCount));
        }
        if (event.getActor().toString().equals(client.getLocalPlayer().toString()) && playerState.has("lastDmgTaken"))
            playerState.addProperty("lastDmgTaken", event.getHitsplat().getAmount());
    }

    @Subscribe
    private void onInteractingChanged(InteractingChanged event) {
        if (playerState == null || gameActivities == null) return;
        // Track the last NPC the player interacted with
        if (event.getTarget() != null && (event.getTarget() instanceof Player || event.getTarget() instanceof NPC)) {
            if (Objects.equals(event.getSource(), client.getLocalPlayer())) {
                if (playerState.has("lastTargetName")) playerState.addProperty("lastTargetName", event.getTarget().getName());
                if (playerState.has("lastTargetInstance")) playerState.addProperty("lastTargetInstance", event.getTarget().toString());
            }
        }
    }

    @Subscribe
    private void onActorDeath(ActorDeath event) {
        if (playerState == null || gameActivities == null) return;
        clientThread.invokeLater(() -> {
            for (int i = 0; i < activeGoals.size(); i++) {
                JsonObject goal = activeGoals.get(i).getAsJsonObject();
                String npcInst = goal.has("trackName") ? event.getActor().getName() : event.getActor().toString();
                if (goal.has("validTargets") && goal.get("validTargets").isJsonArray()) {
                    JsonArray validTargets = goal.getAsJsonArray("validTargets");
                    JsonArray validTargetsDmg = goal.has("validTargetsDmg") ? goal.getAsJsonArray("validTargetsDmg") : new JsonArray();
                    boolean validExists = false;
                    for (int x = 0; x < validTargets.size(); x++) {
                        if (validTargets.get(x).getAsString().equals(npcInst)) { validExists = true; break; }
                    }
                    if (validExists) {
                        // Evaluate the goal requirements each time an NPC dies
                        if (playerState.has("npcValidDeath")) playerState.addProperty("npcValidDeath", event.getActor().getName());
                        if (playerState.has("itemsOnNPCDeath")) playerState.add("itemsOnNPCDeath", utils.getPlayerItems());
                        if (playerState.has("attackItemsOnNPCDeath") && playerState.has("lastItemsOnAttack")) playerState.add("attackItemsOnNPCDeath", playerState.get("lastItemsOnAttack"));
                        if (playerState.has("attackAnimOnNPCDeath") && playerState.has("lastAttackAnim")) playerState.add("attackAnimOnNPCDeath", playerState.get("lastAttackAnim"));
                        evaluateGoal(false);
                        // Remove the npc from the list of targets after evaluation
                        if (playerState.has("npcValidDeath")) playerState.add("npcValidDeath", null);
                        if (playerState.has("itemsOnNPCDeath")) playerState.add("itemsOnNPCDeath", null);
                        if (playerState.has("attackItemsOnNPCDeath")) playerState.add("attackItemsOnNPCDeath", null);
                        if (playerState.has("attackAnimOnNPCDeath")) playerState.add("attackAnimOnNPCDeath", null);
                        for (int x = 0; x < validTargets.size(); x++) {
                            if (validTargets.get(x).getAsString().equals(npcInst)) {
                                validTargets.remove(x);
                                if (goal.has("validTargetsDmg")) validTargetsDmg.remove(x);
                                break;
                            }
                        }
                    }
                }
            }
        });
    }

    private void trackStatChanges(boolean restartTracking) {
        // Get each skill that is being tracked
        JsonArray trackedSkills = new JsonArray();
        if (gameActivities.has("trackedSkills") && !gameActivities.get("trackedSkills").getAsJsonObject().isJsonNull()) {
            trackedSkills = gameActivities.get("trackedSkills").getAsJsonObject().get("skills").getAsJsonArray();
        }

        // Get the current level of each tracked skill and initialize losses and gains at 0
        JsonArray skillLevels = new JsonArray();
        JsonArray lastGoalSkillLosses = new JsonArray();
        JsonArray lastGoalSkillGains = new JsonArray();
        for (int i = 0; i < trackedSkills.size(); i++) {
            skillLevels.add(client.getBoostedSkillLevel(Skill.valueOf(trackedSkills.get(i).getAsString())));
            lastGoalSkillLosses.add(0);
            lastGoalSkillGains.add(0);
        }

        // Get the previous level of each tracked skill
        JsonArray prevSkillLevels = (playerState.has("lastSkillLevels") && playerState.get("lastSkillLevels").isJsonArray()) ?
                playerState.get("lastSkillLevels").getAsJsonArray() : skillLevels;

        // Calculate the deltas of each tracked skill
        JsonArray skillLevelDeltas = new JsonArray();
        if (playerState.has("lastSkillDeltas")) {
            for (int i = 0; i < trackedSkills.size(); i++) {
                skillLevelDeltas.add(skillLevels.get(i).getAsInt() - prevSkillLevels.get(i).getAsInt());
            }
        }

        // Get the last known losses and gains of each tracked skill
        if (playerState.has("lastGoalSkillLosses") && playerState.get("lastGoalSkillLosses").isJsonArray()) {
            lastGoalSkillLosses = playerState.get("lastGoalSkillLosses").getAsJsonArray();
        }
        if (playerState.has("lastGoalSkillGains") && playerState.get("lastGoalSkillGains").isJsonArray()) {
            lastGoalSkillGains = playerState.get("lastGoalSkillGains").getAsJsonArray();
        }

        // Use the calculated deltas to set the new losses and gains of each tracked skill
        // If restartTracking is passed in, we reset the losses and gains instead
        JsonArray newGoalSkillLosses = new JsonArray();
        JsonArray newGoalSkillGains = new JsonArray();
        for (int i = 0; i < trackedSkills.size(); i++) {
            if (restartTracking) { newGoalSkillLosses.add(0); newGoalSkillGains.add(0); }
            else {
                if (skillLevelDeltas.get(i).getAsInt() < 0) {
                    newGoalSkillLosses.add(lastGoalSkillLosses.get(i).getAsInt() + skillLevelDeltas.get(i).getAsInt());
                    newGoalSkillGains.add(lastGoalSkillGains.get(i).getAsInt());
                }
                if (skillLevelDeltas.get(i).getAsInt() > 0) {
                    newGoalSkillGains.add(lastGoalSkillGains.get(i).getAsInt() + skillLevelDeltas.get(i).getAsInt());
                    newGoalSkillLosses.add(lastGoalSkillLosses.get(i).getAsInt());
                }
                if (skillLevelDeltas.get(i).getAsInt() == 0) {
                    newGoalSkillLosses.add(lastGoalSkillLosses.get(i).getAsInt());
                    newGoalSkillGains.add(lastGoalSkillGains.get(i).getAsInt());
                }
            }
        }

        // Update the playerstate with the new skill levels, deltas and accumulated losses and gains
        playerState.add("lastSkillLevels", skillLevels);
        playerState.add("lastSkillDeltas", skillLevelDeltas);
        playerState.add("lastGoalSkillLosses", newGoalSkillLosses);
        playerState.add("lastGoalSkillGains", newGoalSkillGains);
    }

    private void trackVarbitChanges() {
        if (playerState.has("trackedVarbits") && playerState.get("trackedVarbits").isJsonArray() &&
                playerState.has("varTypes") && playerState.get("varTypes").isJsonArray()) {
            JsonArray trackedVarbits = playerState.get("trackedVarbits").getAsJsonArray();
            JsonArray trackedVarbTypes = playerState.get("varTypes").getAsJsonArray();
            JsonArray trackedVarbitValues = new JsonArray();
            for (int i = 0; i < trackedVarbits.size(); i++) {
                if (trackedVarbTypes.get(i).getAsInt() == 1) {
                    int lastVarpValue = client.getVarpValue(trackedVarbits.get(i).getAsInt());
                    trackedVarbitValues.add(lastVarpValue);
                } else {
                    int lastVarbitValue = client.getVarbitValue(trackedVarbits.get(i).getAsInt());
                    trackedVarbitValues.add(lastVarbitValue);
                }
            }
            playerState.add("lastVarbitValues", trackedVarbitValues);
        }
    }

    private void trackLastItemPickup(ItemDespawned event) {
        // Get the coordinates of the despawned item and the player
        int despawnX = event.getTile().getWorldLocation().getX();
        int despawnY = event.getTile().getWorldLocation().getY();
        int playerX = client.getLocalPlayer().getWorldLocation().getX();
        int playerY = client.getLocalPlayer().getWorldLocation().getY();

        // Determine if the "Take" option has not been cancelled and the item has despawned under or next to the player
        boolean takeOpActive = playerState.has("takeOpActive") && !playerState.get("takeOpActive").isJsonNull();
        if (takeOpActive && (Math.abs(despawnX-playerX) <= 1) && (Math.abs(despawnY-playerY) <= 1)) {
            String quantitiesPreUpdate = utils.getPlayerItems().get("inventory").getAsJsonObject().get("itemQuantity").getAsJsonArray().toString();
            // It's still possible that the item could have despawned naturally or another player took the item
            // On the next tick check if the player's inventory has been updated with the item that just despawned
            clientThread.invokeLater(() -> {
                JsonArray invPostUpdate = utils.getPlayerItems().get("inventory").getAsJsonObject().get("itemID").getAsJsonArray();
                boolean itemFound = false;
                for (JsonElement item : invPostUpdate) {
                    int itemID = item.getAsInt();
                    if (itemID == event.getItem().getId()) { itemFound = true; break; }
                }
                // If the despawned item is in the player's inv, also check that the item quantities have updated
                String quantitiesPostUpdate = utils.getPlayerItems().get("inventory").getAsJsonObject().get("itemQuantity").getAsJsonArray().toString();
                if (itemFound && !quantitiesPreUpdate.equals(quantitiesPostUpdate) && playerState.has("lastItemPickup") && playerState.has("lastPickupOwnership")) {
                    playerState.addProperty("lastItemPickup", event.getItem().getId());
                    playerState.addProperty("lastPickupOwnership", event.getItem().getOwnership());
                    playerState.add("takeOpActive", null);
                    // Evaluate the goal requirements each time an item is picked up
                    evaluateGoal(false);
                }
            });
        }
    }

    private void trackRegionChanges(int newRegion) {
        // Get the last region saved in the playerState
        JsonObject lastLocation = (playerState.has("lastLocation") && playerState.get("lastLocation").isJsonObject()) ?
                playerState.get("lastLocation").getAsJsonObject() : new JsonObject();
        int prevRegion = (lastLocation.has("region") && !lastLocation.get("region").isJsonNull()) ? lastLocation.get("region").getAsInt() : newRegion;

        // The region transition is tracked as a string with a comma seperating the two regions
        String regionTransition = prevRegion+","+newRegion;
        if (playerState.has("lastRegionTransition")) playerState.addProperty("lastRegionTransition", regionTransition);

        // Evaluate the research requirements each time a new region is loaded
        evaluateGoal(false);

        // Flag used for detecting non-standard teleports, resets when a new region is loaded
        if (playerState.has("teleportQueued") && !playerState.get("teleportQueued").isJsonNull()) {
            playerState.add("teleportQueued", null);
        }

        // Update the playerstate with the last location
        if (playerState.has("lastLocation")) playerState.add("lastLocation", utils.getPlayerLocation());
    }

    private void attackedFromFullHP(HitsplatApplied event, int damageDealt, int hitsplatCount) {
        // We're only interested in the total damage dealt on the npc in a single tick
        // This returns all except the first hitsplat event (which includes damage from other hitsplats)
        if (hitsplatCount < 1) return;

        // Get the health ratios, damage dealt and max HP of the attacked NPC
        String npcName = Text.removeTags(event.getActor().getName());
        int[] npcHP; int npcCurrentHP = 0; int npcMaxHP = 0;

        // If there's an HP overlay: Retrieve the current and max HP values directly from the overlay
        // If there's no HP overlay: Calculate the current and max HP values from ratios
        boolean npcHPOverlay = client.getVarbitValue(Varbits.BOSS_HEALTH_OVERLAY) == 0;
        boolean npcIDOverlay = client.getVarpValue(VarPlayer.HP_HUD_NPC_ID) != -1;
        if (npcHPOverlay && npcIDOverlay && event.getActor() instanceof NPC) npcHP = hpFromOverlay();
        else npcHP = hpFromRatios(npcName, event);
        if (npcHP[0] != -1) npcCurrentHP = npcHP[0];
        if (npcHP[1] != -1) npcMaxHP = npcHP[1];

        // Determine if the player initiated combat with a NPC at full health by comparing the NPC's max+current HP against the last hitsplat
        // Calculating the hp from ratios is not perfect, so a threshold is also calculated that scales with the HP of the target (+1 for every 100 hp)
        if (activeGoals != null) {
            for (int i = 0; i < activeGoals.size(); i++) {
                JsonObject goal = activeGoals.get(i).getAsJsonObject();
                String npcInst = goal.has("trackName") ? event.getActor().getName() : event.getActor().toString();
                boolean ignoreHPCheck = goal.has("ignoreHPCheck");
                boolean invalidTarget = false;

                // If max HP is provided, use that value instead
                npcMaxHP = (goal.has("npcMaxHP") && !goal.get("npcMaxHP").isJsonNull()) ? goal.get("npcMaxHP").getAsInt() : npcMaxHP;
                int hpThreshold = (int) Math.ceil((double) npcMaxHP / 100) + 1;
                if ((Math.abs((npcMaxHP - damageDealt) - npcCurrentHP) <= hpThreshold) || ignoreHPCheck) {
                    // Check if the attacked npc has been marked as invalid (from a previous failed goal attempt)
                    if (goal.has("invalidTargets") && goal.get("invalidTargets").isJsonArray()) {
                        JsonArray invalidTargets = goal.get("invalidTargets").getAsJsonArray();
                        for (JsonElement target : invalidTargets) {
                            if (Objects.equals(target.getAsString(), event.getActor().toString())) {
                                invalidTarget = true;
                                break;
                            }
                        }
                    }
                    // Add the npc as a valid target if it isn't invalid and isn't already marked as valid
                    if (!invalidTarget) {
                        if (playerState.has("npcAttackedAtFullHP")) playerState.addProperty("npcAttackedAtFullHP", npcName);
                        if (goal.has("validTargets") && goal.get("validTargets").isJsonArray()) {
                            JsonArray validTargets = goal.get("validTargets").getAsJsonArray();
                            boolean validExists = false;
                            for (JsonElement target : validTargets) {
                                if (Objects.equals(target.getAsString(), npcInst)) {
                                    validExists = true;
                                    break;
                                }
                            }
                            if (!validExists) {
                                validTargets.add(npcInst);
                                goal.add("validTargets", validTargets);
                                if (goal.has("validTargetsDmg") && goal.get("validTargetsDmg").isJsonArray()) {
                                    JsonArray validTargetsDmg = goal.get("validTargetsDmg").getAsJsonArray();
                                    validTargetsDmg.add(0);
                                    goal.add("validTargetsDmg", validTargetsDmg);
                                }
                            }
                        }
                        // Evaluate the goal requirements before setting npcAttackedAtFullHP back to null
                        evaluateGoal(false);
                        if (playerState.has("npcAttackedAtFullHP")) playerState.add("npcAttackedAtFullHP", null);
                    }
                }
                String dmgSource = damageMap.get(event.getHitsplat().getHitsplatType());
                if (!invalidTarget && dmgSource != null && dmgSource.equals("self")) {
                    if (goal.has("validTargets") && goal.get("validTargets").isJsonArray()) {
                        JsonArray validTargets = goal.get("validTargets").getAsJsonArray();
                        if (goal.has("validTargetsDmg") && goal.get("validTargetsDmg").isJsonArray()) {
                            JsonArray validTargetsDmg = goal.get("validTargetsDmg").getAsJsonArray();
                            for (int x = 0; x < validTargets.size(); x++) {
                                if (validTargets.get(x).getAsString().equals(npcInst)) {
                                    int addedDmg = validTargetsDmg.get(x).getAsInt()+damageDealt;
                                    validTargetsDmg.set(x, new JsonPrimitive(addedDmg));
                                }
                            }
                        }
                    }
                }
            }
        }
        this.totalDamage = 0;
        this.hitsplatCount = 0;
        evaluateGoal(false);
    }

    private int[] hpFromOverlay() {
        int currentHP = -1; int maxHP = -1;
        Widget hpWidget = client.getWidget(ComponentID.HEALTH_HEALTHBAR_TEXT);
        if (hpWidget != null) {
            Pattern HP_REGEX = Pattern.compile("(\\d+) / (\\d+) \\(.*");
            Matcher matcher = HP_REGEX.matcher(hpWidget.getText());
            if (matcher.find()) {
                currentHP = Integer.parseInt(matcher.group(1));
                maxHP = Integer.parseInt(matcher.group(2));
            }
        }
        return new int[] {currentHP, maxHP};
    }

    private int[] hpFromRatios(String npcName, HitsplatApplied event) {
        int currentHP = -1;
        int lastRatio = event.getActor().getHealthRatio();
        int lastHealthScale = event.getActor().getHealthScale();
        int npcID = getNpcIdByName(npcName);
        Integer maxHP = npcManager.getHealth(npcID);
        // If npcManager cannot return info, fallback to using the hp scale as the max hp
        // We also have the option to override the maxHP if it's incorrect or missing
        if (maxHP == null) maxHP = lastHealthScale;

        // Calculate the current HP from the known max hp and hp scale ratios
        if (maxHP > 0 && lastRatio > 0 && lastHealthScale > 1) {
            int minHealth = (maxHP * (lastRatio - 1) + lastHealthScale - 2) / (lastHealthScale - 1);
            int maxHealth = Math.min((maxHP * lastRatio - 1) / (lastHealthScale - 1), maxHP);
            currentHP = (minHealth + maxHealth + 1) / 2;
        }
        return new int[] {currentHP, maxHP};
    }

    private int getNpcIdByName(String name) {
        for (NPC npc : client.getCachedNPCs()) {
            if (npc != null && npc.getName() != null && npc.getName().equalsIgnoreCase(name)) return npc.getId();
        }
        return -1;
    }

    private void evaluateGoal(boolean onTick) {
        if (activeGoals == null || evaluateConditions == null) return;
        // Here we check if the player's research needs to be started, failed, updated or completed
        for (Map.Entry<String, String> entry : goalTypes.entrySet()) {
            String goalType = entry.getKey();
            String targetState = entry.getValue();
            for (int i = 0; i < activeGoals.size(); i++) {
                JsonObject goal = activeGoals.get(i).getAsJsonObject();
                String goalState = goal.has("goalState") ? goal.get("goalState").getAsString() : "";
                if (goalState.equals(targetState) && goal.has(goalType)) {
                    JsonObject goalDetails = goal.getAsJsonObject(goalType);
                    for (JsonElement conditionElement : evaluateConditions) {
                        String searchCondition = conditionElement.getAsString();
                        if (goalDetails.has(searchCondition)) {
                            JsonElement conditionValue = goalDetails.get(searchCondition);
                            if (!conditionValue.isJsonNull()) {
                                JsonArray goalConditions = conditionValue.getAsJsonArray();
                                matchConditions(goal, goalType, searchCondition, goalConditions, onTick);
                            }
                        }
                    }
                }
            }
        }
    }

    private void matchConditions(JsonObject goal, String goalType, String searchCondition, JsonArray goalConditions, boolean onTick) {
        // Determine if the playerState matches any conditions that would make the player fail their research
        for (int gc = 0; gc < goalConditions.size(); gc++) {
            JsonObject conditionParams = goalConditions.get(gc).getAsJsonObject();

            // If a tracked value is saved in an array, retrieve the value using an index key
            String receivedValue = goalUtils.retrieveStateValue(conditionParams, searchCondition, playerState);

            // Decrement any timers
            if (searchCondition.equals("timeOut")) {
                String checkpointRef = (conditionParams.has("cpRef") && !conditionParams.get("cpRef").isJsonNull()) ? conditionParams.get("cpRef").getAsString() : null;
                // If a tick has passed and timers have not been decremented yet, decrement them
                if (onTick && checkpointRef != null && goal.has("goalState") && !goal.get("goalState").isJsonNull() && goal.get("goalState").getAsString().equals("started")) {
                    int time = goal.get(checkpointRef).getAsInt();
                    goal.addProperty(checkpointRef, time-1);
                }
                // Set the received value to the current timer time
                if (checkpointRef != null && goal.has(checkpointRef)) receivedValue = goal.get(checkpointRef).getAsString();
            }

            // If we're comparing arrays, set flags as needed so values can be matched safely
            JsonArray targetValues = null;
            JsonArray receivedValues = null;
            boolean receivedisArray = false;
            boolean targetIsArray = conditionParams.has("match") && conditionParams.get("match").isJsonArray();
            if (targetIsArray) targetValues = conditionParams.get("match").getAsJsonArray();

            String targetValue = (targetIsArray) ? "null" : conditionParams.get("match").getAsString();
            try { receivedisArray = GSON.fromJson(receivedValue, JsonArray.class).isJsonArray(); } catch (Exception e) {}
            if (receivedisArray) receivedValues = GSON.fromJson(receivedValue, JsonArray.class).getAsJsonArray();

            // Compare the received and target values to determine if the player failed their goal
            String op = (conditionParams.has("op") && !conditionParams.get("op").isJsonNull()) ? conditionParams.get("op").getAsString() : null;
            boolean goalMatched = goalUtils.compareValues(op, receivedValue, receivedValues, targetValue, targetValues);

            // Optionally update the players location
            if (conditionParams.has("updateLocation") && !conditionParams.get("updateLocation").isJsonNull()) {
                if (playerState.has("lastLocation")) playerState.add("lastLocation", utils.getPlayerLocation());
            }

            // Optionally check if the player is within a target boundary
            boolean boundsReq = conditionParams.has("regionBounds") || conditionParams.has("coordBounds");
            boolean failInBounds = boundsReq && conditionParams.has("failInBounds");
            if (boundsReq && goalMatched && !playerInBounds(goal, conditionParams) && !failInBounds) goalMatched = false;
            if (boundsReq && goalMatched && playerInBounds(goal, conditionParams) && failInBounds) goalMatched = false;

            // Optionally reset a tracked condition
            if (conditionParams.has("resetCondition") && !conditionParams.get("resetCondition").isJsonNull()) {
                boolean resetCondition = conditionParams.get("resetCondition").getAsBoolean();
                if (resetCondition) playerState.add(searchCondition, null);
            }

            // Advance the goal if any matching conditions are found
            if (goalMatched && primaryEngaged(goal, conditionParams)) {
                if (goalType.equals("goalStart")) { goalStart(goal, conditionParams); break; }
                if (goalType.equals("goalCheckpoint")) goalCheckpoint(goal, conditionParams, onTick, false);
                if (goalType.equals("goalLost")) goalLost(goal, conditionParams);
                if (goalType.equals("goalComplete")) { goalComplete(goal, conditionParams); break; }
            }

            // If the checkpoint acts as a flip-flop, flip the checkpoint if the goal isn't matched
            if (!goalMatched && conditionParams.has("flipFlop") && goalType.equals("goalCheckpoint")) {
                goalCheckpoint(goal, conditionParams, onTick, true);
            }
        }
    }

    private void goalStart(JsonObject goal, JsonObject conditionParams) {
        // Set the goal state to "started"
        String goalState = (goal.has("goalState") && !goal.get("goalState").isJsonNull()) ? goal.get("goalState").getAsString() : "";
        goal.addProperty("goalState", "started");

        // Reset the playerState and tracked stats
        resetPlayerState(conditionParams);
        boolean restartTracking = true;
        trackStatChanges(restartTracking);

        // Notify the player they've started the research task
        if (npcRequiredAndValid(goal) && conditionParams.has("notify") && conditionParams.get("notify").isJsonArray() && !goalState.equals("started")) {
            JsonArray startNotify = conditionParams.get("notify").getAsJsonArray();
            if (startNotify.isJsonArray()) utils.sendLocalChatMsg(startNotify);
        }
    }

    private void goalLost(JsonObject goal, JsonObject conditionParams) {
        // Return if there are goal lost checkpoints and they are not completed
        if (conditionParams.has("cpGoal") && !conditionParams.get("cpGoal").isJsonNull() && checkpointsPresent(goal, conditionParams)) return;

        // Set the goal back to open and reset all checkpoints
        goal.addProperty("goalState", "open");
        resetCheckpoints(goal, conditionParams);

        // Reset the playerState and tracked stats
        resetPlayerState(conditionParams);
        boolean restartTracking = true;
        trackStatChanges(restartTracking);

        // Notify the player they've failed the research task
        if (npcRequiredAndValid(goal) && conditionParams.has("notify") && conditionParams.get("notify").isJsonArray()) {
            JsonArray lostNotify = conditionParams.get("notify").getAsJsonArray();
            if (lostNotify.isJsonArray()) utils.sendLocalChatMsg(lostNotify);
        }

        // Clear and invalidate all targets
        String npcInst = (playerState.has("lastTargetInstance") && !playerState.get("lastTargetInstance").isJsonNull()) ? playerState.get("lastTargetInstance").getAsString() : "";
        if (goal.has("invalidTargets") && goal.get("invalidTargets").isJsonArray()) {
            JsonArray invalidTargets = goal.get("invalidTargets").getAsJsonArray();
            invalidTargets.add(new JsonPrimitive(npcInst));
            goal.add("invalidTargets", invalidTargets);
            // Clear the last target from the playerState
            playerState.add("lastTargetName", null);
            playerState.add("lastTargetInstance", null);
        }
        if (goal.has("validTargets")) goal.add("validTargets", new JsonArray());
        if (goal.has("validTargetsDmg")) goal.add("validTargetsDmg", new JsonArray());
    }

    private void goalCheckpoint(JsonObject goal, JsonObject conditionParams, boolean onTick, boolean flipFlop) {
        // Return if this checkpoint is contingent on other checkpoints being completed
        if (conditionParams.has("cpGoal") && !conditionParams.get("cpGoal").isJsonNull() && checkpointsPresent(goal, conditionParams)) return;

        // Return if the target requires minimum damage and the player dealt less than required
        if (invalidDamage(goal, conditionParams)) return;

        // If the checkpoint can only be updated once, do not update it again
        if (conditionParams.has("updateOnce") && !conditionParams.get("updateOnce").isJsonNull() && !flipFlop) return;
        if (conditionParams.has("updateOnceFF") && !conditionParams.get("updateOnceFF").isJsonNull() && flipFlop) return;

        // If the checkpoint only updates once per tick, check that at least 1 tick has elapsed
        if (conditionParams.has("onTick") && !conditionParams.get("onTick").isJsonNull() && !onTick) return;

        // Determine how the checkpoint will be updated and update it
        String checkpointRef = (conditionParams.has("cpRef") && !conditionParams.get("cpRef").isJsonNull()) ? conditionParams.get("cpRef").getAsString() : null;
        String checkpointOp = (conditionParams.has("cpOp") && !conditionParams.get("cpOp").isJsonNull()) ? conditionParams.get("cpOp").getAsString() : null;
        String valueType = (conditionParams.has("valueType") && !conditionParams.get("valueType").isJsonNull()) ? conditionParams.get("valueType").getAsString() : null;
        String baseType = (conditionParams.has("baseType") && !conditionParams.get("baseType").isJsonNull()) ? conditionParams.get("baseType").getAsString() : null;
        int setIndex = (conditionParams.has("cpIndex") && !conditionParams.get("cpIndex").isJsonNull()) ? conditionParams.get("cpIndex").getAsInt() : -1;
        int valueInt = 0; String valueString = ""; int baseInt = 0; JsonArray baseArray = new JsonArray();
        if (valueType != null && baseType != null && checkpointOp != null && checkpointRef != null && goal.has(checkpointRef)) {
            String valueKey = (flipFlop) ? "flipFlop" : "cpValue";
            switch (valueType) {
                case ("int"): valueInt = conditionParams.get(valueKey).getAsInt(); break;
                case ("string"): valueString = conditionParams.get(valueKey).getAsString(); break;
            }
            switch (baseType) {
                case ("int"): baseInt = goal.get(checkpointRef).getAsInt(); break;
                case ("array"): baseArray = goal.get(checkpointRef).getAsJsonArray(); break;
            }
            if (setIndex == -1) {
                switch (checkpointOp) {
                    case ("+"): goal.addProperty(checkpointRef, baseInt+valueInt); break;
                    case ("-"): goal.addProperty(checkpointRef, baseInt-valueInt); break;
                    case ("setInt"): goal.addProperty(checkpointRef, valueInt); break;
                    case ("setStr"): goal.addProperty(checkpointRef, valueString); break;
                    case ("pushInt"): baseArray.add(valueInt); goal.add(checkpointRef, baseArray); break;
                    case ("pushStr"): baseArray.add(valueString); goal.add(checkpointRef, baseArray); break;
                }
            }
            if (setIndex > -1) {
                switch (checkpointOp) {
                    case ("+"): baseArray.set(setIndex, new JsonPrimitive(baseArray.get(setIndex).getAsInt()+valueInt)); goal.add(checkpointRef, baseArray); break;
                    case ("-"): baseArray.set(setIndex, new JsonPrimitive(baseArray.get(setIndex).getAsInt()-valueInt)); goal.add(checkpointRef, baseArray); break;
                    case ("set"): baseArray.set(setIndex, new JsonPrimitive(valueInt)); goal.add(checkpointRef, baseArray); break;
                }
            }
        }

        // Set a flag if the checkpoint should only update once, and it hasn't been updated yet
        if (conditionParams.has("updateOnce") && conditionParams.get("updateOnce").isJsonNull() && !flipFlop) {
            conditionParams.addProperty("updateOnce", true);
            if (conditionParams.has("updateOnceFF")) conditionParams.add("updateOnceFF", null);
        }
        if (conditionParams.has("updateOnceFF") && conditionParams.get("updateOnceFF").isJsonNull() && flipFlop) {
            conditionParams.addProperty("updateOnceFF", true);
            if (conditionParams.has("updateOnce")) conditionParams.add("updateOnce", null);
        }

        // Optionally set a condition on the notification
        String notifyKey = (conditionParams.has("notifyOn") && !conditionParams.get("notifyOn").isJsonNull()) ? conditionParams.get("notifyOn").getAsString() : null;
        boolean notifyOn = notifyKey == null || conditionParams.has(notifyKey) && !conditionParams.get(notifyKey).isJsonNull();

        // Notify the player that they've made progress on their research task
        if (notifyOn && checkpointRef != null && conditionParams.has("notify") && conditionParams.get("notify").isJsonArray()) {
            String updatedValue = goal.get(checkpointRef).toString();
            String miscRef = (conditionParams.has("miscRef") && !conditionParams.get("miscRef").isJsonNull()) ? conditionParams.get("miscRef").getAsString() : null;
            String miscValue = (goal.has(miscRef) && !goal.get(miscRef).isJsonNull()) ? goal.get(miscRef).toString() : null;
            JsonArray updatedArray = (goal.get(checkpointRef).isJsonArray()) ? goal.get(checkpointRef).getAsJsonArray() : null;
            JsonArray lostNotify = conditionParams.get("notify").getAsJsonArray();
            // $cpRef is a control word that is replaced with the saved checkpoint value
            // $plural is a control word that picks the singular or plural form of a word if $cpRef is = 1 or != 1
            JsonArray updatedNotify = new JsonArray();
            for (int i = 0; i < lostNotify.size(); i++) {
                String message;
                JsonObject msgObj = new JsonObject();
                lostNotify.get(i).getAsJsonObject().entrySet().forEach(entry -> msgObj.add(entry.getKey(), entry.getValue()));
                if (msgObj.has("message") && !msgObj.get("message").isJsonNull()) {
                    message = msgObj.get("message").getAsString();
                    if (updatedArray != null && setIndex != -1) updatedValue = updatedArray.get(setIndex).getAsString();
                    if (isParsableAsInt(updatedValue)) {
                        message = message.replace("$cpRef", updatedValue);
                        String pluralKey = (Integer.parseInt(updatedValue) == 1) ? "$1" : "$2";
                        message = message.replaceFirst("\\$plural\\[(.*):(.*)]", pluralKey);
                    }
                    if (miscValue != null) {
                        message = message.replace("$miscRef", miscValue.replace("\"", ""));
                    }
                    msgObj.addProperty("message", message);
                    updatedNotify.add(msgObj);
                }
            }
            if (lostNotify.isJsonArray()) utils.sendLocalChatMsg(updatedNotify);
        }
    }

    private void goalComplete(JsonObject goal, JsonObject conditionParams) {
        // Return if the target requires minimum damage and the player dealt less than required
        if (invalidDamage(goal, conditionParams)) return;

        // Return if there are goal complete checkpoints and they are not completed
        if (conditionParams.has("cpGoal") && !conditionParams.get("cpGoal").isJsonNull() && checkpointsPresent(goal, conditionParams)) return;

        // Set the goal to completed and reset all checkpoints
        goal.addProperty("goalState", "completed");
        resetCheckpoints(goal, conditionParams);

        // Send a notification in the chatbox that the player completed their goal
        if (conditionParams.has("notify") && conditionParams.get("notify").isJsonArray()) {
            JsonArray completeNotify = conditionParams.get("notify").getAsJsonArray();
            utils.sendLocalChatMsg(completeNotify);
        }

        // Process any post-completion events
        int eventWidget = -1;
        List<String> messageCollector = plugin.getMessageCollector();
        JsonObject completeRequest = (conditionParams.has("request") && !conditionParams.get("request").isJsonNull()) ?
                conditionParams.get("request").getAsJsonObject() : new JsonObject();
        JsonArray eventParameters = (completeRequest.has("param") && !completeRequest.get("param").isJsonNull()) ?
                completeRequest.get("param").getAsJsonArray() : new JsonArray();
        if (eventParameters.size() > 0) {
            for (JsonElement param : eventParameters) {
                if (param.getAsString().startsWith("widgetInfo")) eventWidget = Integer.parseInt(completeRequest.get("event").getAsString());
            }
        }
        String goalName = (goal.has("goalName")) ? goal.get("goalName").getAsString() : "";
        String eventType = (goal.has("eventType")) ? goal.get("eventType").getAsString() : "";
        utils.processEvent(goalName, eventType, eventParameters, eventWidget, messageCollector, playerState, -1);
    }

    private boolean checkpointsPresent(JsonObject goal, JsonObject conditionParams) {
        boolean checkpointsComplete = false;
        String checkpointRef = (conditionParams.has("cpRef") && !conditionParams.get("cpRef").isJsonNull()) ? conditionParams.get("cpRef").getAsString() : null;
        checkpointRef = (conditionParams.has("cpGateRef") && !conditionParams.get("cpGateRef").isJsonNull()) ? conditionParams.get("cpGateRef").getAsString() : checkpointRef;
        String checkpointOp = (conditionParams.has("cpOp") && !conditionParams.get("cpOp").isJsonNull()) ? conditionParams.get("cpOp").getAsString() : null;
        checkpointOp = (conditionParams.has("cpGateOp") && !conditionParams.get("cpGateOp").isJsonNull()) ? conditionParams.get("cpGateOp").getAsString() : checkpointOp;
        String goalType = (conditionParams.has("goalType") && !conditionParams.get("goalType").isJsonNull()) ? conditionParams.get("goalType").getAsString() : null;
        goalType = (conditionParams.has("goalGateType") && !conditionParams.get("goalGateType").isJsonNull()) ? conditionParams.get("goalGateType").getAsString() : goalType;
        String baseType = (conditionParams.has("baseType") && !conditionParams.get("baseType").isJsonNull()) ? conditionParams.get("baseType").getAsString() : null;
        baseType = (conditionParams.has("baseGateType") && !conditionParams.get("baseGateType").isJsonNull()) ? conditionParams.get("baseGateType").getAsString() : baseType;
        int baseInt = 0; JsonArray baseArray = new JsonArray(); int goalInt = 0; String goalString = ""; JsonArray goalArray = new JsonArray();
        if (goal.has(checkpointRef) && goalType != null && baseType != null && checkpointOp != null && checkpointRef != null) {
            switch (baseType) {
                case ("int"): baseInt = goal.get(checkpointRef).getAsInt(); break;
                case ("array"): baseArray = goal.get(checkpointRef).getAsJsonArray(); break;
            }
            switch (goalType) {
                case ("int"): goalInt = conditionParams.get("cpGoal").getAsInt(); break;
                case ("string"): goalString = conditionParams.get("cpGoal").getAsString(); break;
                case ("array"): goalArray = conditionParams.get("cpGoal").getAsJsonArray(); break;
            }
            if (baseType.equals("int") && goalType.equals("int")) {
                switch (checkpointOp) {
                    case ("=="): checkpointsComplete = baseInt == goalInt; break;
                    case ("!="): checkpointsComplete = baseInt != goalInt; break;
                    case (">"): checkpointsComplete = baseInt > goalInt; break;
                    case ("<"): checkpointsComplete = baseInt < goalInt; break;
                    case (">="): checkpointsComplete = baseInt >= goalInt; break;
                    case ("<="): checkpointsComplete = baseInt <= goalInt; break;
                }
            }
            // Process array logic
            Set<String> baseSet = new HashSet<>();
            Set<String> goalSet = new HashSet<>();
            for (JsonElement element : baseArray) baseSet.add(element.getAsString());
            for (JsonElement element : goalArray) goalSet.add(element.getAsString());
            if (baseType.equals("array") && goalType.equals("string")) {
                switch (checkpointOp) {
                    case ("contains"): checkpointsComplete = baseSet.contains(goalString); break;
                    case ("doesNotContain"): checkpointsComplete = !baseSet.contains(goalString); break;
                }
            }
            if (baseType.equals("array") && goalType.equals("array")) {
                boolean matchEachIndex = conditionParams.has("matchEachIndex");
                boolean sumIndexes = conditionParams.has("sumIndexes");
                if (sumIndexes) {
                    int sum = 0;
                    for (JsonElement element : baseArray) sum += element.getAsInt();
                    baseSet.clear();
                    baseSet.add(String.valueOf(sum));
                }
                if (!matchEachIndex) {
                    switch (checkpointOp) {
                        case ("containsAll"): checkpointsComplete = baseSet.containsAll(goalSet); break;
                        case ("doesNotContainAll"): checkpointsComplete = !baseSet.containsAll(goalSet); break;
                    }
                }
                if (matchEachIndex) {
                    if (baseArray.size() == goalArray.size()) {
                        boolean indexesMatch = true;
                        comparator:
                        for (int i = 0; i < goalArray.size(); i++) {
                            switch (checkpointOp) {
                                case ("=="): if (baseArray.get(i).getAsInt() != goalArray.get(i).getAsInt()) { indexesMatch = false; break comparator; } break;
                                case ("!="): if (baseArray.get(i).getAsInt() == goalArray.get(i).getAsInt()) { indexesMatch = false; break comparator; } break;
                                case (">"): if (baseArray.get(i).getAsInt() <= goalArray.get(i).getAsInt()) { indexesMatch = false; break comparator; } break;
                                case ("<"): if (baseArray.get(i).getAsInt() >= goalArray.get(i).getAsInt()) { indexesMatch = false; break comparator; } break;
                                case (">="): if (baseArray.get(i).getAsInt() < goalArray.get(i).getAsInt()) { indexesMatch = false; break comparator; } break;
                                case ("<="): if (baseArray.get(i).getAsInt() > goalArray.get(i).getAsInt()) { indexesMatch = false; break comparator; } break;
                            }
                        }
                        checkpointsComplete = indexesMatch;
                    }
                }
            }
        }
        return (!checkpointsComplete && checkpointOp != null);
    }

    private boolean primaryEngaged(JsonObject goal, JsonObject conditionParams) {
        // Return true if the goal condition is indepedent of the primary target
        boolean engagedWithPrimary = conditionParams.has("engagedWithPrimary");
        if (!engagedWithPrimary) return true;

        // Return true/false if the goal condition is dependent on the primary target(s)
        String lastTargetName = (playerState.has("lastTargetName") && !playerState.get("lastTargetName").isJsonNull()) ? playerState.get("lastTargetName").getAsString() : "";
        JsonArray primaryTargets = (goal.has("primaryTargets") && goal.get("primaryTargets").isJsonArray()) ? goal.get("primaryTargets").getAsJsonArray() : new JsonArray();
        boolean primaryEngaged = false;
        for (JsonElement target : primaryTargets) {
            if (target.getAsString().equals(lastTargetName)) { primaryEngaged = true; break; }
        }
        return primaryEngaged;
    }

    private boolean invalidDamage(JsonObject goal, JsonObject conditionParams) {
        boolean validTargetInvalidDamage = false;
        if (conditionParams.has("enforceMinDmg") && !conditionParams.get("enforceMinDmg").isJsonNull()) {
            String npcInst = (playerState.has("lastTargetInstance") && !playerState.get("lastTargetInstance").isJsonNull()) ? playerState.get("lastTargetInstance").getAsString() : "";
            if (goal.has("trackName")) npcInst = (playerState.has("lastTargetName") && !playerState.get("lastTargetName").isJsonNull()) ? playerState.get("lastTargetName").getAsString() : "";
            if (goal.has("validTargets") && goal.get("validTargets").isJsonArray()) {
                JsonArray validTargets = goal.getAsJsonArray("validTargets");
                JsonArray validTargetsDmg = goal.has("validTargetsDmg") ? goal.getAsJsonArray("validTargetsDmg") : null;
                int damageRequired = conditionParams.get("enforceMinDmg").getAsInt();
                if (validTargetsDmg != null) {
                    for (int i = 0; i < validTargets.size(); i++) {
                        if (validTargets.get(i).getAsString().equals(npcInst)) {
                            int damageOnTarget = validTargetsDmg.get(i).getAsInt();
                            if (damageOnTarget < damageRequired) {
                                validTargetInvalidDamage = true;
                                break;
                            }
                        }
                    }
                }
                if (validTargetInvalidDamage && conditionParams.has("minDmgNotify") && conditionParams.get("minDmgNotify").isJsonArray()) {
                    JsonArray minDmgNotifyNotify = conditionParams.get("minDmgNotify").getAsJsonArray();
                    utils.sendLocalChatMsg(minDmgNotifyNotify);
                }
            }
        }
        return validTargetInvalidDamage;
    }

    private void resetPlayerState(JsonObject conditionParams) {
        JsonObject exemptReset = (conditionParams.has("exemptReset") && conditionParams.get("exemptReset").isJsonObject()) ? conditionParams.get("exemptReset").getAsJsonObject() : new JsonObject();
        if (playerState.has("lastGearAndItems") && !exemptReset.has("lastGearAndItems")) playerState.add("lastGearAndItems", utils.getPlayerItems());
        if (playerState.has("lastItemPickup") && !exemptReset.has("lastItemPickup")) playerState.add("lastItemPickup", null);
        if (playerState.has("lastPickupOwnership") && !exemptReset.has("lastPickupOwnership")) playerState.add("lastPickupOwnership", null);
        if (playerState.has("lastScriptPostFired") && !exemptReset.has("lastScriptPostFired")) playerState.add("lastScriptPostFired", null);
        if (playerState.has("lastChatMessage") && !exemptReset.has("lastChatMessage")) playerState.add("lastChatMessage", null);
        if (playerState.has("lastRegionTransition") && !exemptReset.has("lastRegionTransition")) playerState.add("lastRegionTransition", null);
        if (playerState.has("teleportQueued") && !exemptReset.has("teleportQueued")) playerState.add("teleportQueued", null);
    }

    private void resetCheckpoints(JsonObject goal, JsonObject conditionParams) {
        // Reset all checkpoint references back to their default values
        if (conditionParams.has("cpResetRefTarget") && conditionParams.has("cpResetRefValue")) {
            JsonArray checkpointRefs = (conditionParams.has("cpResetRefTarget") && conditionParams.get("cpResetRefTarget").isJsonArray()) ? conditionParams.get("cpResetRefTarget").getAsJsonArray() : new JsonArray();
            JsonArray resetRefs = (conditionParams.has("cpResetRefValue") && conditionParams.get("cpResetRefValue").isJsonArray()) ? conditionParams.get("cpResetRefValue").getAsJsonArray() : new JsonArray();
            if (checkpointRefs.size() == resetRefs.size()) {
                for (int i = 0; i < resetRefs.size(); i++) {
                    String checkpointRef = checkpointRefs.get(i).getAsString();
                    String resetRef = resetRefs.get(i).getAsString();
                    JsonArray resetArray = (goal.has(resetRef) && goal.get(resetRef).isJsonArray()) ? copyJsonArray(goal.get(resetRef).getAsJsonArray()) : null;
                    if (checkpointRef != null && resetRef != null) {
                        if (resetArray != null) goal.add(checkpointRef, resetArray);
                        else goal.add(checkpointRef, goal.get(resetRef));
                    }
                }
            }
        }
        // Reset all "Update once" checkpoints
        JsonObject goalCheckpoint = goal.getAsJsonObject("goalCheckpoint");
        if (goalCheckpoint != null) {
            for (int i = 0; i < evaluateConditions.size(); i++) {
                String conditionType = evaluateConditions.get(i).getAsString();
                if (goalCheckpoint.has(conditionType) && !goalCheckpoint.get(conditionType).isJsonNull()) {
                    JsonArray cpConditions = goalCheckpoint.getAsJsonArray(conditionType);
                    for (JsonElement cpCondition : cpConditions) {
                        JsonObject checkpoint = cpCondition.getAsJsonObject();
                        if (checkpoint.has("updateOnce")) checkpoint.add("updateOnce", null);
                        if (checkpoint.has("updateOnceFF")) checkpoint.add("updateOnceFF", null);
                    }
                }
            }
        }
    }

    private static JsonArray copyJsonArray(JsonArray originalArray) {
        JsonArray newArray = new JsonArray();
        originalArray.forEach(newArray::add);
        return newArray;
    }

    // Prevents NPCs being reevaluated if they were invalidated
    private boolean npcRequiredAndValid(JsonObject goal) {
        boolean validTarget = true;
        String npcInst = (playerState.has("lastTargetInstance") && !playerState.get("lastTargetInstance").isJsonNull()) ? playerState.get("lastTargetInstance").getAsString() : "";
        if (goal.has("validateNPC") && goal.has("invalidTargets") && goal.get("invalidTargets").isJsonArray()) {
            JsonArray invalidTargets = goal.get("invalidTargets").getAsJsonArray();
            for (JsonElement targetElem : invalidTargets) {
                String target = targetElem.getAsString();
                if (npcInst.equals(target)) validTarget = false; break;
            }
        }
        return validTarget;
    }

    private static boolean isParsableAsInt(String str) {
        try { Integer.parseInt(str); return true; }
        catch (NumberFormatException e) { return false; }
    }

    private boolean playerInBounds(JsonObject goal, JsonObject conditionParams) {
        // Get the last location saved in the playerState
        JsonObject lastLocation;
        if (playerState.has("lastLocation") && playerState.get("lastLocation").isJsonObject()) lastLocation = playerState.get("lastLocation").getAsJsonObject();
        else return false;

        // Determine if the player is in a target map region
        boolean playerInRegion = false;
        boolean regionBounds = conditionParams.has("regionBounds") && conditionParams.get("regionBounds").isJsonArray() && conditionParams.get("regionBounds").isJsonArray();
        if (regionBounds && lastLocation.has("regions") && lastLocation.get("regions").isJsonArray()) {
            JsonArray validRegions = conditionParams.get("regionBounds").getAsJsonArray();
            JsonArray playerRegions = lastLocation.get("regions").getAsJsonArray();
            for (JsonElement vRegion : validRegions) {
                int validRegion = vRegion.getAsInt();
                for (JsonElement pRegion : playerRegions) {
                    int playerRegion = pRegion.getAsInt();
                    if (playerRegion == validRegion) {
                        playerInRegion = true;
                        break;
                    }
                }
                if (playerInRegion) break;
            }
        }

        // Determine if the player is in a target coordinate range and plane
        Integer playerWorldX = (lastLocation.has("worldX") && !lastLocation.get("worldX").isJsonNull()) ? lastLocation.get("worldX").getAsInt() : null;
        Integer playerWorldY = (lastLocation.has("worldY") && !lastLocation.get("worldY").isJsonNull()) ? lastLocation.get("worldY").getAsInt() : null;
        Integer playerRegionX = (lastLocation.has("regionX") && !lastLocation.get("regionX").isJsonNull()) ? lastLocation.get("regionX").getAsInt() : null;
        Integer playerRegionY = (lastLocation.has("regionY") && !lastLocation.get("regionY").isJsonNull()) ? lastLocation.get("regionY").getAsInt() : null;
        boolean playerInCoords = false;
        boolean coordBounds = conditionParams.has("coordBounds") && conditionParams.get("coordBounds").isJsonArray() && conditionParams.get("coordBounds").isJsonArray();
        if (coordBounds && ((playerWorldX != null && playerWorldY !=null) || (playerRegionX != null && playerRegionY !=null))) {
            JsonArray validCoords = conditionParams.get("coordBounds").getAsJsonArray();
            for (JsonElement coordArea : validCoords) {
                if (coordArea.isJsonArray()) {
                    JsonArray coordGroup = coordArea.getAsJsonArray();
                    if (coordGroup.size() == 6) {
                        Integer playerX = null; Integer playerY = null;
                        int playerPlane = (lastLocation.has("plane") && !lastLocation.get("plane").isJsonNull()) ? lastLocation.get("plane").getAsInt() : 0;
                        int x1 = coordGroup.get(0).getAsInt(); int y1 = coordGroup.get(1).getAsInt();
                        int x2 = coordGroup.get(2).getAsInt(); int y2 = coordGroup.get(3).getAsInt();
                        int plane = coordGroup.get(4).getAsInt();
                        if (coordGroup.get(5).getAsString().equals("world")) {
                            playerX = playerWorldX;
                            playerY = playerWorldY;
                        }
                        if (coordGroup.get(5).getAsString().equals("region")) {
                            playerX = playerRegionX;
                            playerY = playerRegionY;
                        }
                        // Set the location hint
                        if (conditionParams.has("locationHint") && !conditionParams.get("locationHint").isJsonNull() &&
                            goal.has("baseCoordHint") && !goal.get("baseCoordHint").isJsonNull() &&
                            goal.has("baseCoordFound") && !goal.get("baseCoordFound").isJsonNull()) {
                            String baseCoordHint = goal.get("baseCoordHint").getAsString();
                            String baseCoordFound = goal.get("baseCoordFound").getAsString();
                            String locationHint = goalUtils.distanceFromLocation(baseCoordHint, baseCoordFound, playerX, playerY, x1, y1, x2, y2);
                            if (goal.has("cpDistHint")) goal.addProperty("cpDistHint", locationHint);
                        }
                        // Return the location status
                        if (playerX != null && playerX >= x1 && playerX <= x2 && playerY != null && playerY <= y1 && playerY >= y2 && playerPlane == plane) {
                            playerInCoords = true;
                            break;
                        }
                    }
                }
            }
        }
        return playerInRegion || playerInCoords;
    }
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.util;
import com.google.gson.JsonArray;
import lombok.Value;

@Value
public class eventObject {
    String eventName;
    String eventType;
    JsonArray eventParameters;
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("pokescape")
public interface PokescapeConfig extends Config {
	String PLUGIN_VERSION = "0.6.0";

	enum SnapMode {
		INV("Top of Inventory"), CHATBOX("Top of Chatbox"), OFF("Off (Alt-Drag)");
		private final String stringValue;
		SnapMode(final String s) { stringValue = s; }
		public String toString() { return stringValue; }
	}

	@ConfigItem(
			position = 1,
			keyName = "panel_visibility",
			name = "Show Side Panel",
			description = "Displays PokeScape PvM in the side panel."
	)
	default boolean showPokescapeSidePanel() {
		return true;
	}

	@ConfigSection(
			name = "Overlay",
			description = "Overlay configuration.",
			position = 2
	)
	String overlaySection = "Overlay section";

	@ConfigItem(
			position = 3,
			keyName = "overlay_visibility",
			name = "Display Overlay",
			description = "Displays the overlay on your game screen.",
			section = overlaySection
	)
	default boolean overlayVisibility() { return true; }

	@ConfigItem(
			position = 4,
			keyName = "overlay_timestamp",
			name = "Timestamp",
			description = "Adds a timestamp to the overlay.",
			section = overlaySection
	)
	default boolean timeStampVisibility() { return true; }

	@ConfigItem(
			position = 5,
			keyName = "overlay_password",
			name = "Event Password:",
			description = "Adds the event password to the overlay.",
			section = overlaySection
	)
	default String eventPassword() { return ""; }

	@ConfigItem(
			position = 5,
			keyName = "overlay_password",
			name = "Event Password:",
			description = "Adds the event password to the overlay.",
			section = overlaySection,
			hidden = true
	)
	void setEventPassword(String password);

	@ConfigItem(
			position = 6,
			keyName = "overlay_snapmode",
			name = "Snap Position",
			description = "Controls the snap position of the overlay.",
			section = overlaySection
	)
	default SnapMode overlaySnapping() { return SnapMode.INV; }

	@ConfigItem(
			position = 7,
			keyName = "overlay_passcolor",
			name = "Password Color",
			description = "Sets the color of the event password.",
			section = overlaySection
	)
	default Color passwordColor() { return Color.GREEN; }

	@ConfigItem(
			position = 8,
			keyName = "overlay_passtime",
			name = "Timestamp Color",
			description = "Sets the color of the timestamp.",
			section = overlaySection
	)
	default Color timestampColor() { return Color.WHITE; }

}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape;

import com.google.gson.JsonElement;
import com.pokescape.ui.PokescapeOverlay;
import com.pokescape.ui.PokescapePanel;
import com.pokescape.web.PokescapeClient;
import com.pokescape.util.Utils;
import com.pokescape.util.eventObject;
import com.pokescape.util.PokeScapeGoals;
import com.pokescape.ui.Icon;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.ResizeableChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.Varbits;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.VarClientInt;
import net.runelite.api.NPC;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.http.api.loottracker.LootRecordType;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;
import net.runelite.client.chat.ChatMessageManager;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@PluginDescriptor(
		name = "PokeScape PvM",
		tags = {"pokescape", "pvm", "competition", "pokemon", "pokeball", "runemon", "gym", "battle", "adventure"},
		description = "The companion plugin for PokeScape PvM! Catch 'em all and make your way to the top to defeat the Runemon League!"
)

public class PokescapePlugin extends Plugin {
	private @Inject Client client;
	private @Inject ClientToolbar clientToolbar;
	private @Inject PokescapeConfig config;
	private @Inject PokescapeClient sendRequest;
	private @Inject Utils utils;
	private @Inject OverlayManager overlayManager;
	private @Inject ChatMessageManager chatMessageManager;

	private PokescapePanel panel;
	private PokescapeOverlay overlay;
	private PokeScapeGoals goals;
	private NavigationButton navButton;
	private static GameState currentGameState;

	private static final String POKESCAPE_TITLE = "PokeScape PvM";

	private JsonObject gameEvents;
	private JsonObject gameActivities;
	private JsonObject allowBlockList;
	private String eventName;
	private String eventType;
	private JsonArray eventParameters;
	private int eventWidget;
	private final JsonObject containerEvents = new JsonObject();
	private JsonObject recentActivities = new JsonObject();
	private final List<String> messageCollector = new ArrayList<>();
	private boolean fetchProfile;
	private boolean fetchGameEvent;
	private int delayedGameEventTick;
	private int delayedMsgCleanupTick;
	private int delayedSubmitTick;
	private int delayDupeWidget;
	private final ArrayList<Object> lootObject = new ArrayList <>();

	@Override
	protected void startUp() {
		goals = injector.getInstance(PokeScapeGoals.class);
		goals.startUp();
		initPanel();
		overlayManager.add(overlay);
		if (config.showPokescapeSidePanel()) clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() {
		sendRequest.shutdownSSE();
		goals.shutDown();
		overlayManager.remove(overlay);
		clientToolbar.removeNavigation(navButton);
		goals = null;
		panel = null;
		overlay = null;
	}

	public void setGameEvents(JsonObject events) { gameEvents = events; setContainerEvents(events); }
	public void setAllowBlockList(JsonObject allowblock) {
		allowBlockList = allowblock;
	}
	public void setGameActivities(JsonObject activities) { gameActivities = activities; goals.setPlayerState(); }
	public JsonObject getGameActivities() {
		return gameActivities;
	}
	public JsonObject getPlayerState() {
		return recentActivities;
	}
	public void setPlayerState(JsonObject playerState) { recentActivities = playerState; }
	public List<String> getMessageCollector() {
		return messageCollector;
	}
	public void setDelayDupeWidget(int value) { delayDupeWidget = value; }

	public JsonObject getContainerEvents() {
		return containerEvents;
	}
	public void setContainerEvents(JsonObject events) {
		events.keySet().forEach(keyName -> {
			JsonObject keyObj = events.get(keyName).getAsJsonObject();
			String filterKeyValue = keyObj.get("type").getAsString();
			if (filterKeyValue.equals("containerUpdate")) {
				JsonArray itemIDs = (keyObj.has("items") && !keyObj.get("items").isJsonNull()) ? keyObj.get("items").getAsJsonArray() : new JsonArray();
				JsonArray eventParameters = (keyObj.has("param") && !keyObj.get("param").isJsonNull()) ? keyObj.get("param").getAsJsonArray() : new JsonArray();
				JsonObject eventObject = new JsonObject();
				eventObject.add("items", itemIDs);
				eventObject.add("param", eventParameters);
				containerEvents.add(keyName, eventObject);
			}
		});
	}

	private void initPanel() {
		panel = injector.getInstance(PokescapePanel.class);
		overlay = injector.getInstance(PokescapeOverlay.class);
		final BufferedImage icon = Icon.PANEL_ICON.getImage();
		navButton = NavigationButton.builder()
				.tooltip(POKESCAPE_TITLE)
				.icon(icon)
				.panel(panel)
				.priority(8)
				.build();

		// Ping the server to return and display its status.
		sendRequest.status(panel);
		fetchProfile = true;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		GameState gameState = gameStateChanged.getGameState();
		if (gameState != GameState.LOGGED_IN && gameState != GameState.LOGIN_SCREEN && gameState != GameState.HOPPING && gameState != GameState.LOGGING_IN) return;

		// Return if the game state updates between loading areas (LOGGED_IN -> LOADING -> LOGGED_IN...etc)
		boolean isNewGameState = gameState != currentGameState;
		if (gameState == GameState.HOPPING) isNewGameState = true;
		if (!isNewGameState) return;

		// Connect to SSE if logging in from the title screen
		if (currentGameState == GameState.LOGGING_IN && gameState == GameState.LOGGED_IN) sendRequest.initSSE();

		// Set the current gameState
		currentGameState = gameState;

		// Disconnect from SSE on logout to title screen
		if (gameState == GameState.LOGIN_SCREEN) sendRequest.shutdownSSE();

		// Set a flag to send a profile request after player login/hop
		if (gameState == GameState.LOGGED_IN) fetchProfile = true;
	}

	@Subscribe
	public void onGameTick(GameTick tick) {
		// Send a profile request on login/hop
		if (fetchProfile) {
			sendRequest.profile(panel, goals);
			fetchProfile = !fetchProfile;
		}
		// Process events when a matching event is found
		if (fetchGameEvent && --delayedGameEventTick < 0) {
			int spriteID = fetchWidgetSprite();
			utils.processEvent(eventName, eventType, eventParameters, eventWidget, messageCollector, recentActivities, spriteID);
			fetchGameEvent = !fetchGameEvent;
		}

		if (client.getVarcIntValue(VarClientInt.INVENTORY_TAB) != overlay.getCollapsedTabsState()) {
			overlay.recalcOverlay(false);
			overlay.setCollapsedTabsState(client.getVarcIntValue(VarClientInt.INVENTORY_TAB));
		}

		// Handles submitting loot set with a delayed submission
		if (!lootObject.isEmpty() && --delayedSubmitTick < 0) {
			sendRequest.loot((String) lootObject.get(0), (String) lootObject.get(1), (Integer) lootObject.get(2), (Collection<ItemStack>) lootObject.get(3), messageCollector, recentActivities);
			lootObject.clear();
		}

		// Clears the message collector at the end of every tick
		// delayedLootTick can be set to a postive value to log messages for a longer period
		if (--delayedMsgCleanupTick < 0) {
			messageCollector.clear();
		}

		// Filters out duplicate widget events when positive
		--delayDupeWidget;
	}

	private int fetchWidgetSprite() {
		Widget sprite = client.getWidget(ComponentID.DIALOG_SPRITE_SPRITE);
		if (sprite != null) return sprite.getItemId();
		return -1;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged) {
		// Toggle the visibility of the plugin in the side panel
		if (configChanged.getKey().equals("panel_visibility")) {
			clientToolbar.removeNavigation(navButton);
			if (config.showPokescapeSidePanel()) clientToolbar.addNavigation(navButton);
		}
		if (configChanged.getKey().startsWith("overlay")) {
			overlay.recalcOverlay(false);
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event) {
		if (event.getVarbitId() == Varbits.SIDE_PANELS) overlay.recalcOverlay(false);
	}

	@Subscribe
	public void onResizeableChanged(ResizeableChanged event) {
		overlay.recalcOverlay(true);
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		// Matches menu actions to a key-value list to determine the player's most recently performed activities
		String lastMenuOption = Text.removeTags(event.getMenuOption());
		String lastMenuTarget = Text.removeTags(event.getMenuTarget());
		if (gameActivities != null) recentActivities = utils.matchActivity(recentActivities, gameActivities, lastMenuOption, lastMenuTarget, -1);
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		if (
			event.getType() != ChatMessageType.GAMEMESSAGE
			&& event.getType() != ChatMessageType.SPAM
			&& event.getType() != ChatMessageType.FRIENDSCHATNOTIFICATION
			&& event.getType() != ChatMessageType.MESBOX
			&& event.getType() != ChatMessageType.DIALOG
		) return;

		// Log game messages to the message collector
		final String chatMessage = Text.removeTags(event.getMessage());
		messageCollector.add(chatMessage);

		// Find game event messages
		if (gameEvents != null && !fetchGameEvent) {
			List<eventObject> eventMatch = utils.matchEvent(gameEvents, chatMessage, "gameEvent", "type", "gameMessage");
			if (!eventMatch.isEmpty()) {
				for (eventObject item : eventMatch) {
					eventName = item.getEventName();
					eventType = item.getEventType();
					eventParameters = item.getEventParameters();
				}
				fetchGameEvent = true;

				// Events with parameters that manipulate timing need to be processed immediately
				for (JsonElement param : eventParameters) {
					String eventParam = param.getAsString();
					// delaySubmission parameter temporarily prevents loot from being submitted
					// Some bosses (Nex) may take multiple ticks to completely log all their game messages
					if (eventParam.startsWith("delaySubmission")) {
						try { delayedSubmitTick = Integer.parseInt(eventParam.split("delaySubmission=")[1]); }
						catch (Exception e) { delayedSubmitTick = 2; }
					}
					// delayMsgCleanup parameter temporarily prevents the message collector from being cleared
					// Some bosses (Nightmare, Duke) fire onLootReceived on a future game tick
					if (eventParam.startsWith("delayMsgCleanup")) {
						try { delayedMsgCleanupTick = Integer.parseInt(eventParam.split("delayMsgCleanup=")[1]); }
						catch (Exception e) { delayedMsgCleanupTick = 2; }
					}
					// delayFetch parameter temporarily prevents an event from being processed
					// This is useful if waiting for other events unrelated to this event
					if (eventParam.startsWith("delayFetch")) {
						try { delayedGameEventTick = Integer.parseInt(eventParam.split("delayFetch=")[1]); }
						catch (Exception e) { delayedGameEventTick = 2; }
					}
					// suppressFetch parameters blocks an event from being sent back to the server
					if (eventParam.startsWith("suppressFetch")) fetchGameEvent = false;
				}
			}
		}

		// Find validation messages
		utils.matchValidation(panel, event, chatMessage);
	}

	@Subscribe
	public void onOverheadTextChanged(OverheadTextChanged event) {
		// Find overhead event messages
		if (gameEvents != null && !fetchGameEvent) {
			List<eventObject> eventMatch = utils.matchEvent(gameEvents, event.getOverheadText(), "gameEvent", "type", "overHeadText");
			if (!eventMatch.isEmpty()) {
				for (eventObject item : eventMatch) {
					eventName = item.getEventName();
					eventType = item.getEventType();
					eventParameters = item.getEventParameters();
				}
				utils.matchOverhead(event, eventName, eventType, eventParameters, recentActivities);
			}
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event) {
		// Find widget events
		if (gameEvents != null && !fetchGameEvent && delayDupeWidget <= 0) {
			List<eventObject> eventMatch = utils.matchEvent(gameEvents, Integer.toString(event.getGroupId()), "gameEvent", "type", "loadedWidget");
			if (!eventMatch.isEmpty()) {
				for (eventObject item : eventMatch) {
					eventName = item.getEventName();
					eventType = item.getEventType();
					eventParameters = item.getEventParameters();
					eventWidget = event.getGroupId();
				}
				fetchGameEvent = true;
				// Events with parameters that manipulate timing need to be processed immediately
				for (JsonElement param : eventParameters) {
					String eventParam = param.getAsString();
					// Used if the widget will be overwritten/unavailable the next tick
					if (eventParam.startsWith("processSameTick")) {
						utils.processEvent(eventName, eventType, eventParameters, eventWidget, messageCollector, recentActivities, -1);
					}
					// suppressFetch parameters blocks events from being sent back to the server
					if (eventParam.startsWith("suppressFetch")) fetchGameEvent = false;
				}
			}
		}
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived npcLootReceived) {
		NPC npc = npcLootReceived.getNpc();

		// Allow or block loot requests if the event is configured in the allowblock list
		Boolean allowBlock = utils.processAllowBlock(allowBlockList, npc.getName(), "NPC");
		if (Boolean.FALSE.equals(allowBlock)) return;

		// If the submission needs to be delayed, hold a reference that can be submitted later
		Collection<ItemStack> items = npcLootReceived.getItems();
		if (delayedSubmitTick > 0) {
			lootObject.add("npcLoot");
			lootObject.add(npc.getName());
			lootObject.add(npc.getId());
			lootObject.add(items);
		} else {
			sendRequest.loot("npcLoot", npc.getName(), npc.getId(), items, messageCollector, recentActivities);
		}
	}

	@Subscribe
	public void onLootReceived(LootReceived lootReceived) {
		// Allow or block loot requests if the event is configured in the allowblock list
		// Default behavior: Loot of type "EVENT" is allowed, all other types are blocked (upstream handles NPCs)
		// No action is taken if the event is unspecified (allowBlock returns null)
		Boolean allowBlock = utils.processAllowBlock(allowBlockList, lootReceived.getName(), lootReceived.getType().toString());
		if (lootReceived.getType() != LootRecordType.EVENT && !Boolean.TRUE.equals(allowBlock)) return;
		if (Boolean.FALSE.equals(allowBlock)) return;

		// If the submission needs to be delayed, hold a reference that can be submitted later
		Collection<ItemStack> items = lootReceived.getItems();
		if (delayedSubmitTick > 0) {
			lootObject.add("otherLoot");
			lootObject.add(lootReceived.getName());
			lootObject.add(0);
			lootObject.add(items);
		} else {
			sendRequest.loot("otherLoot", lootReceived.getName(), 0, items, messageCollector, recentActivities);
		}
	}

	@Provides
	PokescapeConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(PokescapeConfig.class);
	}
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.ui;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class collapseModal extends JPanel {
	private final JPanel titleModal;
	private final JLabel titleText;
	private final JComponent modalContent;
	private boolean isExpanded;

	public collapseModal(String modalTitle, JComponent modalContent, boolean modalExpanded) {
		this.isExpanded = modalExpanded;
		this.modalContent = modalContent;

		setLayout(new BorderLayout(0, 1));
		setBorder(new EmptyBorder(10, 0, 0, 0));

		titleModal = new JPanel();
		titleModal.setBorder(new EmptyBorder(3, 3, 3, 3));
		titleModal.setBackground(modalExpanded ? ColorScheme.BRAND_ORANGE : ColorScheme.DARKER_GRAY_COLOR);
		titleModal.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		titleModal.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e)
			{
				onMouseClick();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				onMouseHover(true);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				onMouseHover(false);
			}
		});

		titleText = new JLabel(modalTitle);
		titleText.setFont(FontManager.getRunescapeBoldFont());
		titleText.setForeground(modalExpanded ? Color.BLACK : Color.WHITE);
		titleModal.add(titleText);

		modalContent.setVisible(modalExpanded);

		add(titleModal, BorderLayout.NORTH);
		add(modalContent, BorderLayout.CENTER);
	}

	public collapseModal(String modalTitle, JComponent modalContent)
	{
		this(modalTitle, modalContent, false);
	}

	private void onMouseHover(boolean isHovering) {
		Color color = ColorScheme.DARKER_GRAY_COLOR;

		if (isHovering) {
			color = ColorScheme.DARKER_GRAY_HOVER_COLOR;
			if (isExpanded) color = ColorScheme.BRAND_ORANGE.darker();
		} else if (isExpanded) color = ColorScheme.BRAND_ORANGE;
		titleModal.setBackground(color);
	}

	private void onMouseClick() {
		isExpanded = !isExpanded;
		Color color = isExpanded ? ColorScheme.BRAND_ORANGE : ColorScheme.DARKER_GRAY_COLOR;
		Color textColor = isExpanded ? Color.BLACK : Color.WHITE;

		titleModal.setBackground(color);
		titleText.setForeground(textColor);
		modalContent.setVisible(isExpanded);
	}
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.ui;

import com.pokescape.PokescapeConfig;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.Cursor;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.Desktop;
import java.awt.FontMetrics;
import javax.inject.Inject;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class PokescapePanel extends PluginPanel {
    private static final ImageIcon INFO_ICON;
    private static final ImageIcon SITE_ICON;
    private static final ImageIcon DISCORD_ICON;
    private static final EmptyBorder DEFAULT_BORDER = new EmptyBorder(10, 10, 10, 10);

    private static final String WEBSITE_URL = "https://pokescape.com/";
    private static final String DISCORD_URL = "https://discord.com/invite/dmfF6yMV9m";

    static {
        INFO_ICON = com.pokescape.ui.Icon.INFO.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
        SITE_ICON = com.pokescape.ui.Icon.SITE.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
        DISCORD_ICON = com.pokescape.ui.Icon.DISCORD.getIcon(img -> ImageUtil.resizeImage(img, 16, 16));
    }

    private JPanel serverInfoPanel;
    private JLabel versionLabel;
    private JLabel serverStatusLabel;
    private JTextArea serverMessage;
    private JLabel pokescapeTeamLabel;
    private JLabel totalLevelLabel;
    private JLabel dexCountLabel;
    private JLabel tempoVerificationLabel;
    private JLabel gotrVerificationLabel;
    public boolean tempoVerified;
    public boolean gotrVerified;

    @Inject
    public PokescapePanel() {
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());
        setBorder(DEFAULT_BORDER);

        JPanel layoutPanel = new JPanel();
        layoutPanel.setLayout(new BoxLayout(layoutPanel, BoxLayout.Y_AXIS));

        JPanel tabPanel = createTabPanel();
        layoutPanel.add(tabPanel);

        add(layoutPanel, BorderLayout.NORTH);
    }

    private JPanel createTabPanel() {
        JPanel tabPanel = new JPanel();
        tabPanel.setLayout(new BoxLayout(tabPanel, BoxLayout.Y_AXIS));

        JPanel activeTabPanel = new JPanel();
        activeTabPanel.setLayout(new BoxLayout(activeTabPanel, BoxLayout.Y_AXIS));
        MaterialTabGroup tabGroup = new MaterialTabGroup(activeTabPanel);
        tabGroup.setLayout(new GridLayout(1, 4, 10, 10));
        tabGroup.setBorder(new EmptyBorder(0, 0, 10, 0));
        tabPanel.add(tabGroup);
        tabPanel.add(activeTabPanel);

        JPanel masterPanel = createMasterPanel();
        activeTabPanel.add(masterPanel);
        createTab(INFO_ICON, "Info", tabGroup, masterPanel, "tab", null).select();

        JPanel dexPanel = createDexBtnPanel();
        createTab(SITE_ICON, "RuneDex", tabGroup, dexPanel, "button", WEBSITE_URL);

        JPanel discordPanel = createDiscordBtnPanel();
        createTab(DISCORD_ICON, "Discord", tabGroup, discordPanel, "button", DISCORD_URL);

        return tabPanel;
    }

    private JPanel createMasterPanel() {
        JPanel infoPanel = new JPanel();
        infoPanel.setLayout(new BoxLayout(infoPanel, BoxLayout.Y_AXIS));

        serverInfoPanel = new JPanel(new GridBagLayout());
        serverInfoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        serverInfoPanel.setBorder(DEFAULT_BORDER);

        // Set the server annoucement
        setServerAnnoucement(0, "");
        infoPanel.add(serverInfoPanel);

        // Create the team panel
        JPanel teamPanelContent = createTabModal();
        pokescapeTeamLabel = new JLabel();
        setPokescapeTeam("","");
        teamPanelContent.add(pokescapeTeamLabel, createGbc(0, 0, 50, 0));
        totalLevelLabel = new JLabel();
        setTotalLevel("-");
        teamPanelContent.add(totalLevelLabel, createGbc(3, 0, 0, 0));
        dexCountLabel = new JLabel();
        setDexCount("-/-");
        teamPanelContent.add(dexCountLabel, createGbc(48, 0, 0, 0));
        collapseModal teamPanel = new collapseModal("PokeScape Team", teamPanelContent);
        infoPanel.add(teamPanel);

        // Create the verification info text
        JPanel verificationContent = createTabModal();
        String verificationText = "Some activities require additional verification checks after the start of the competition. Drops from the activities below are invalid until you validate the activity:";
        JTextArea verificationTextArea = createTextArea(verificationText);
        verificationContent.add(verificationTextArea, createGbc(0, -6, 105, -6));

        // Verification indicators: Tempoross
        JLabel tempoLabel = new JLabel("Tempoross");
        tempoLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        tempoLabel.setFont(FontManager.getRunescapeBoldFont());
        verificationContent.add(tempoLabel, createGbc(18, 0, 0, 0));
        tempoVerificationLabel = new JLabel();
        setTemporossVerification(false);
        if (!getTemporossVerification()) tempoVerificationLabel.setToolTipText("Use the \"Net\" option on the Reward Pool to verify your reward permits. \r\nYou must have 0 reward permits to pass verification.");
        verificationContent.add(tempoVerificationLabel, createGbc(60, 0, 0, 0));
        // Verification indicators: GoTR
        JLabel gotrLabel = new JLabel("Guardians of the Rift");
        gotrLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
        gotrLabel.setFont(FontManager.getRunescapeBoldFont());
        verificationContent.add(gotrLabel, createGbc(113, 0, 0, 0));
        gotrVerificationLabel = new JLabel();
        setGotrVerification(false);
        if (!getGotrVerification()) gotrVerificationLabel.setToolTipText("Use the \"Check\" option on the Rewards Guardian to verify your energy. \r\nYou must have 0-1 catalytic and 0-1 elemental energy to pass verification.");
        verificationContent.add(gotrVerificationLabel, createGbc(155, 0, 0, 0));
        collapseModal verificationPanel = new collapseModal("Minigame Verification", verificationContent);
        infoPanel.add(verificationPanel);

        return infoPanel;
    }

    private MaterialTab createTab(ImageIcon icon, String toolTipText, MaterialTabGroup tabGroup, JComponent content, String modal, String url) {
        MaterialTab tab = new MaterialTab(icon, tabGroup, content);
        switch (modal) {
            // Add a tab
            case "tab":
                tab.setToolTipText(toolTipText);
                tabGroup.addTab(tab);
                break;
            // Add a button
            case "button":
                JButton button = new JButton();
                button.setToolTipText(toolTipText);
                button.setIcon(icon);
                button.setBorderPainted(false);
                button.setFocusPainted(false);
                button.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                button.addMouseListener(new MouseAdapter() {
                    public void mouseEntered(MouseEvent e) {
                        button.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
                    }
                    public void mouseExited(MouseEvent e) {
                        button.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    }
                });
                button.addActionListener(e -> {
                    try { Desktop.getDesktop().browse(java.net.URI.create(url)); }
                    catch (java.io.IOException i) { log.debug(i.getMessage()); }
                });
                tabGroup.add(button);
                break;
            default:
        }
        return tab;
    }

    public void setServerAnnoucement(int status, String message) {
        if (serverMessage != null) serverInfoPanel.remove(serverMessage);
        if (versionLabel != null) serverInfoPanel.remove(versionLabel);
        if (serverStatusLabel != null) serverInfoPanel.remove(serverStatusLabel);

        int lineOffset = 16;
        serverMessage = createTextArea(message);
        serverMessage.setSize(200,200);
        lineOffset = lineOffset*countLines(serverMessage);
        if (!message.isEmpty()) serverInfoPanel.add(serverMessage, createGbc(35, -6, -5, -6));
        else { serverInfoPanel.add(serverMessage, createGbc(0, 0, 0, 0)); lineOffset = -3; }

        versionLabel = new JLabel("Version: "+ PokescapeConfig.PLUGIN_VERSION);
        serverInfoPanel.add(versionLabel, createGbc(-20-lineOffset, 0, 0, 0));

        serverStatusLabel = new JLabel();
        setServerStatusText(status);
        serverInfoPanel.add(serverStatusLabel, createGbc(12-lineOffset, 0, 0, 0));
    }

    private int countLines(JTextArea textArea) {
        int width = (int)textArea.getSize().getWidth();
        FontMetrics fontMetrics = textArea.getFontMetrics(textArea.getFont());
        String text = textArea.getText();
        String currentLine = "";
        int numOfLines = 1;
        int lastWhiteSpaceIndex = 0;

        for (int i = 0; i < text.length(); i++) {
            currentLine = currentLine + text.charAt(i);
            if (text.charAt(i) == ' ') lastWhiteSpaceIndex = i;
            if (fontMetrics.stringWidth(currentLine) > width) {
                i = lastWhiteSpaceIndex;
                currentLine = "";
                numOfLines++;
            }
        }
        return numOfLines;
    }

    private JPanel createDexBtnPanel() {
        JPanel dexBtnPanel = new JPanel();
        dexBtnPanel.setLayout(new BoxLayout(dexBtnPanel, BoxLayout.Y_AXIS));
        return dexBtnPanel;
    }

    private JPanel createDiscordBtnPanel() {
        JPanel discordBtnPanel = new JPanel();
        discordBtnPanel.setLayout(new BoxLayout(discordBtnPanel, BoxLayout.Y_AXIS));
        return discordBtnPanel;
    }

    private GridBagConstraints createGbc(int top, int left, int bottom, int right) {
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.gridwidth = 1;
        gbc.gridheight = 1;

        gbc.anchor = GridBagConstraints.WEST;
        gbc.fill = GridBagConstraints.HORIZONTAL;

        gbc.insets = new Insets(top, left, bottom, right);
        gbc.weightx = 1.0;
        gbc.weighty = 1.0;
        return gbc;
    }

    private JPanel createTabModal() {
        JPanel tabContentPanel = new JPanel(new GridBagLayout());
        tabContentPanel.setBorder(DEFAULT_BORDER);
        tabContentPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        return tabContentPanel;
    }

    private JTextArea createTextArea(String text) {
        JTextArea textArea = new JTextArea(0, 0);
        textArea.setText(text);
        textArea.setWrapStyleWord(true);
        textArea.setLineWrap(true);
        textArea.setEditable(false);
        textArea.setFocusable(false);
        textArea.setOpaque(false);
        return textArea;
    }

    public void setServerStatusText(int status) {
        String statusColor = "#FF0000";
        String statusText = "Unreachable";
        switch (status) {
            // Unreachable
            case 0:
                statusColor = "#FF0000";
                statusText = "Unreachable";
                break;
            // Online
            case 1:
                statusColor = "#00FF00";
                statusText = "Online";
                break;
            // Offline
            case 2:
                statusColor = "#FF0000";
                statusText = "Offline";
                break;
            // Closed
            case 3:
                statusColor = "#FFAA00";
                statusText = "Closed";
                break;
        }
        serverStatusLabel.setText("<html><nobr>Server Status: <font color='"+statusColor+"'>"+statusText+"</font></nobr></html>");
    }

    public void setPokescapeTeam(String team, String color) {
        String teamName = team.isEmpty() ? "" : team;
        String hyphen = team.isEmpty() ? " -" : " ";
        String teamColor = color.isEmpty() ? "#1E1E1E" : color;
        pokescapeTeamLabel.setText("<html><nobr><font style='font-weight: bold;'>Team:</font>"+hyphen+"<font style='font-size: 1.3em;' color='"+teamColor+"'></font> <font>"+teamName+"</font></nobr></html>");
    }

    public void setTotalLevel(String totalLevel) {
        totalLevelLabel.setText("<html><nobr><font style='font-weight: bold;'>Total Level:</font> <font>"+totalLevel+"</font></nobr></html>");
    }

    public void setDexCount(String dexCount) {
        dexCountLabel.setText("<html><nobr><font style='font-weight: bold;'>Dex Count:</font> <font>"+dexCount+"</font></nobr></html>");
    }

    public void setTemporossVerification(boolean verified) {
        tempoVerified = verified;
        String statusColor = verified ? "#00FF00" : "#FF0000";
        String isVerified = verified ? "Verified" : "Unverified";
        tempoVerificationLabel.setText("<html><nobr> <font style='font-size: 1.3em;' color='"+statusColor+"'></font> <font>"+isVerified+"</font></nobr></html>");
    }
    public boolean getTemporossVerification() { return tempoVerified; }

    public void setGotrVerification(boolean verified) {
        gotrVerified = verified;
        String statusColor = verified ? "#00FF00" : "#FF0000";
        String isVerified = verified ? "Verified" : "Unverified";
        gotrVerificationLabel.setText("<html><nobr> <font style='font-size: 1.3em;' color='"+statusColor+"'></font> <font>"+isVerified+"</font></nobr></html>");
    }
    public boolean getGotrVerification() { return gotrVerified; }
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * Copyright (c) 2022, cmsu224 <https://github.com/cmsu224>
 * Copyright (c) 2022, Brianmm94 <https://github.com/Brianmm94>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.ui;

import com.pokescape.PokescapeConfig;
import net.runelite.api.VarClientInt;
import net.runelite.api.Varbits;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.LayoutableRenderableEntity;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Color;
import java.awt.Point;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Objects;
import java.util.TimeZone;
import java.util.List;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import javax.inject.Inject;

public class PokescapeOverlay extends OverlayPanel {
    private @Inject Client client;
    private @Inject PokescapeConfig config;
    private int redrawDelay;
    private int collapsedTabsState;
    private boolean overlaySnapped;

    private static final int CHATBOX = ComponentID.CHATBOX_PARENT;
    private static final int INV_CLASSIC = ComponentID.RESIZABLE_VIEWPORT_INVENTORY_PARENT;
    private static final int INV_MODERN = ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_INVENTORY_PARENT;
    private static final int MODERN_TABS1 = ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_TABS1;
    private static final int MODERN_TABS2 = ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_TABS2;

    private @Inject PokescapeOverlay() {
        setPosition(OverlayPosition.CANVAS_TOP_RIGHT);
        getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "PokeScape Overlay"));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        String password = config.eventPassword();
        Color passColor = config.passwordColor();
        Color timeColor = config.timestampColor();

        if (passColor.toString().equals(timeColor.toString())) {
            passColor = Color.GREEN;
            timeColor = Color.WHITE;
        }

        if (password.matches(".*\\w.*") && config.overlayVisibility()) {
            password = password.trim();
            panelComponent.getChildren().add(LineComponent.builder().left(password).leftColor(passColor).build());

            if (config.timeStampVisibility()) {
                password = password + " " + timeUTC();
                List<LayoutableRenderableEntity> elem = panelComponent.getChildren();
                ((LineComponent) elem.get(0)).setRight(timeUTC());
                ((LineComponent) elem.get(0)).setRightColor(timeColor);
            }

            panelComponent.setPreferredSize(new Dimension(graphics.getFontMetrics().stringWidth(password)+10, 0));
            if (!overlaySnapped) overlaySnapped = snapToWidget();
        }
        return super.render(graphics);
    }

    private static String timeUTC() {
        Date date = new Date();
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yy HH:mm");
        dateFormat.setTimeZone(TimeZone.getTimeZone("UTC"));
        return dateFormat.format(date) + " UTC";
    }

    public void recalcOverlay(boolean resized) {
        if (resized) redrawDelay = (!client.isResized()) ? -20 : -80;
        overlaySnapped = false;
    }
    public void setCollapsedTabsState(int state) { collapsedTabsState = state; }
    public int getCollapsedTabsState() { return collapsedTabsState; }

    private boolean snapToWidget() {
        // Return if snapping is turned off
        if (config.overlaySnapping() == PokescapeConfig.SnapMode.OFF) return true;

        int widgetID = calcSnapWidget();
        Widget snapParent = client.getWidget(widgetID);
        redrawDelay++;
        if (snapParent == null || redrawDelay < 10) return false;

        int invX = snapParent.getCanvasLocation().getX() + snapParent.getWidth();
        int invY = snapParent.getCanvasLocation().getY();
        int xOffset = (int)panelComponent.getBounds().getWidth()+2;
        int yOffset = (int)panelComponent.getBounds().getHeight()+2;
        if (invX <= 0 || invY <= 0 || xOffset <= 12 || yOffset <= 12) return false;

        int finalX = (config.overlaySnapping() == PokescapeConfig.SnapMode.CHATBOX || !client.isResized())
                ? snapParent.getCanvasLocation().getX()+2 : invX-xOffset;

        Point snapLocation = new Point(finalX, invY-yOffset);
        setPreferredLocation(snapLocation);
        redrawDelay = 0;
        return true;
    }

    private int calcSnapWidget() {
        // If chatbox is selected, return the chatbox
        if (config.overlaySnapping() == PokescapeConfig.SnapMode.CHATBOX) return CHATBOX;

        // If inventory is selected calculate where the overlay needs to be depending on the client layout
        String clientLayout = (client.getVarbitValue(Varbits.SIDE_PANELS) == 0) ? "res_classic" : "res_modern";
        if (!client.isResized()) clientLayout = "fixed";

        int widgetID;
        switch(clientLayout) {
            case "fixed": widgetID = CHATBOX; break;
            case "res_classic": widgetID = INV_CLASSIC; break;
            case "res_modern": widgetID = INV_MODERN; break;
            default: widgetID = CHATBOX;
        }

        // Calculates where the overlay will be if all tabs are closed on modern layout
        if (clientLayout.equals("res_modern") && client.getVarcIntValue(VarClientInt.INVENTORY_TAB) == -1) {
            int tabs1Y = Objects.requireNonNull(client.getWidget(MODERN_TABS1)).getCanvasLocation().getY();
            int tabs2Y = Objects.requireNonNull(client.getWidget(MODERN_TABS2)).getCanvasLocation().getY();
            widgetID = (tabs1Y > tabs2Y) ? MODERN_TABS2 : MODERN_TABS1;
        }
        return widgetID;
    }
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.ui;

import java.awt.image.BufferedImage;
import java.util.function.UnaryOperator;
import javax.annotation.Nonnull;
import javax.swing.ImageIcon;

import com.pokescape.PokescapePlugin;
import net.runelite.client.util.ImageUtil;

public enum Icon {
    PANEL_ICON("/panel.png"),
    INFO("/info.png"),
    SITE("/site.png"),
    DISCORD("/discord.png"),
    ;

    private final String file;
    Icon(String file)
    {
        this.file = file;
    }

    public BufferedImage getImage()
    {
        return ImageUtil.loadImageResource(PokescapePlugin.class, file);
    }

    public ImageIcon getIcon(@Nonnull UnaryOperator<BufferedImage> func) {
        BufferedImage img = func.apply(getImage());
        return new ImageIcon(img);
    }
}
/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.web;

import com.google.gson.JsonElement;
import com.pokescape.PokescapeConfig;
import com.pokescape.PokescapePlugin;
import com.pokescape.ui.PokescapePanel;
import com.pokescape.util.Utils;
import com.pokescape.util.PokeScapeGoals;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.common.base.Strings;
import net.runelite.api.Client;
import net.runelite.client.game.ItemStack;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.ImageUtil;
import static net.runelite.http.api.RuneLiteAPI.GSON;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.HttpUrl;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import okio.Buffer;
import okio.BufferedSource;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import okhttp3.Response;
import okhttp3.MultipartBody;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.net.ConnectException;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.util.Collection;
import java.util.List;
import javax.imageio.ImageIO;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class PokescapeClient {
    private @Inject Client client;
    private @Inject OkHttpClient okHttpClient;
    private @Inject OkHttpClient sseClient;
    private @Inject DrawManager drawManager;
    private @Inject PokescapePlugin plugin;
    private @Inject PokescapeConfig config;
    private @Inject formatBody format;
    private @Inject Utils utils;
    private @Inject PokeScapeGoals goals;
    private @Inject PokescapePanel panel;

    private static final String API_ENDPOINT = "https://api.pokescape.com";
    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private int reconnectTimeout = 0;
    private static Call sseHandler;
    private JsonObject cacheManifest;

    public void status(PokescapePanel pokescapePanel) {
        panel = pokescapePanel;
        getRequest("/status");
    }

    public void profile(PokescapePanel pokescapePanel, PokeScapeGoals pokescapeGoals) {
        panel = pokescapePanel;
        goals = pokescapeGoals;
        postBody postBody = new postBody();
        String rsn = client.getLocalPlayer().getName();
        String clientHash = Long.toString(client.getAccountHash());
        postBody.setRsn(rsn);
        postBody.setClientHash(clientHash);
        postBody.setPluginVersion(PokescapeConfig.PLUGIN_VERSION);
        postRequest(postBody, "/profile");
    }

    // Initialize a call instance that doesn't timeout for SSE
    public void initSSE() {
        shutdownSSE();
        sseClient = sseClient.newBuilder().connectTimeout(0, TimeUnit.MINUTES).readTimeout(0, TimeUnit.MINUTES).writeTimeout(0, TimeUnit.MINUTES).build();
        connectToSSE(API_ENDPOINT+"/sse", sseClient);
    }

    // Null out the sseHandler so scheduleReconnect doesn't reopen the connection
    public void shutdownSSE() {
        if (sseHandler != null) { sseHandler.cancel(); sseHandler = null; }
    }

    // If the SSE connection is interuppted: First attempt to reconnect instantly, then every 5 seconds
    private void scheduleReconnect(String url, OkHttpClient sseClient) {
        if (sseHandler != null) scheduler.schedule(() -> connectToSSE(url, sseClient), reconnectTimeout, TimeUnit.SECONDS);
        reconnectTimeout = 5;
    }

    private void connectToSSE(String url, OkHttpClient sseClient) {
        // Build the SSE connection request
        Request request = new Request.Builder().url(url)
                .addHeader("Accept", "text/event-stream")
                .addHeader("Client-Hash", Long.toString(client.getAccountHash()))
                .build();

        // Create a new call with an event listener and start the connection
        sseHandler = sseClient.newCall(request);
        sseHandler.enqueue(new Callback() {
            @Override
            public void onResponse(Call call, Response response) {
                if (!response.isSuccessful()) {
                    log.debug("Failed to connect to SSE endpoint. HTTP status code: " + response.code());
                    scheduleReconnect(url, sseClient);
                    return;
                }
                // Read SSE events
                try (ResponseBody body = response.body()) {
                    if (body != null) readSSEEvents(body);
                } catch (Exception e) {
                    try { if (!e.getMessage().equals("Socket closed")) { scheduleReconnect(url, sseClient); }
                    } catch (Exception f) { scheduleReconnect(url, sseClient); }
                }
            }
            @Override
            public void onFailure(Call call, IOException e) {
                scheduleReconnect(url, sseClient);
            }
        });
    }

    private void readSSEEvents(ResponseBody body) throws IOException {
        // Read SSE events in chunks
        reconnectTimeout = 0;
        BufferedSource source = body.source();
        Buffer buffer = new Buffer();
        while (!source.exhausted()) {
            source.read(buffer, 2048);
            String event = buffer.readUtf8();
            JsonObject eventBody;
            try { eventBody = GSON.fromJson(event, JsonObject.class); }
            catch (Exception e) { eventBody = new JsonObject(); }

            // Validate the message and respond to events
            if (validMessage(eventBody)) {
                if (eventBody.has("fetchProfile") && !eventBody.get("fetchProfile").isJsonNull()) {
                    boolean fetchProfile = eventBody.has("fetchProfile") && !eventBody.get("fetchProfile").isJsonNull() && eventBody.get("fetchProfile").getAsBoolean();
                    if (fetchProfile) profile(panel, goals);
                }
                if (eventBody.has("sync") && !eventBody.get("sync").isJsonNull()) {
                    boolean syncProfile = eventBody.has("sync") && !eventBody.get("sync").isJsonNull() && eventBody.get("sync").getAsBoolean();
                    if (syncProfile) sync();
                }
            }
        }
    }

    private boolean validMessage(JsonObject eventBody) {
        boolean messageValid = false;
        if (eventBody.has("id") && eventBody.get("id").isJsonArray()) {
            JsonArray messageIDs = eventBody.get("id").getAsJsonArray();
            for (JsonElement id : messageIDs) {
                if (id.getAsString().equals(Long.toString(client.getAccountHash()))) messageValid = true;
                if (id.getAsString().equals("all")) messageValid = true;
            }
        }
        return messageValid;
    }

    public void sync() {
        postBody postBody = new postBody();
        String rsn = client.getLocalPlayer().getName();
        String clientHash = Long.toString(client.getAccountHash());
        postBody.setRsn(rsn);
        postBody.setClientHash(clientHash);
        postBody.setPluginVersion(PokescapeConfig.PLUGIN_VERSION);
        postRequest(postBody, "/sync");
    }

    public void validateMinigame(PokescapePanel pokescapePanel, String validationData) {
        panel = pokescapePanel;
        postBody postBody = format.minigame(validationData);
        postRequest(postBody, "/validation");
    }

    public void gameEvent(String eventName, String eventType, List<String> messageCollector, JsonObject eventInfo, JsonObject recentActivities, Integer spriteID) {
        postBody postBody = format.event(eventName, eventType, messageCollector, eventInfo, recentActivities, spriteID);
        postRequest(postBody, "/event");
    }

    public void loot(String activity, String name, Integer id, Collection<ItemStack> items, List<String> messageCollector, JsonObject recentActivities) {
        postBody postBody = format.loot(activity, name, id, items, messageCollector, recentActivities);
        postRequest(postBody, "/loot");
    }

    private void getRequest(String route) {
        // Validate the webhook path and url
        String url = API_ENDPOINT;
        if (Strings.isNullOrEmpty(url) || route == null) return;
        else url = API_ENDPOINT + route;
        HttpUrl u = HttpUrl.parse(url);
        if (u == null) { log.info("Malformed webhook url {}", url); return; }

        // Build the request
        Request request = new Request.Builder().url(url).build();

        // Send the request
        okHttpClient.newCall(request).enqueue(new Callback() {
            // If the request doesn't hit the server, update the server status to "Unreachable" in the side panel
            @Override
            public void onFailure(Call call, IOException e) {
                try { throw new ConnectException("Unreachable"); }
                catch (ConnectException c) {
                    panel.setServerStatusText(0);
                    panel.setServerAnnoucement(0, "");
                    panel.setPokescapeTeam("", "");
                    panel.setTotalLevel("");
                    panel.setDexCount("");
                }
            }
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    JsonObject responseBody;
                    try { responseBody = GSON.fromJson(response.body() != null ? response.body().string() : null, JsonObject.class); }
                    catch (Exception e) { responseBody = new JsonObject(); }

                    // Update the panel to reflect the server status
                    if (response.code() / 100 != 2) panel.setServerStatusText(2);
                    else panel.setServerStatusText(1);

                    // Update the panel with any annoucements and/or special status from the server
                    if (responseBody.has("serverMessage") && !responseBody.get("serverMessage").isJsonNull()) {
                        String serverMessage = responseBody.get("serverMessage").getAsString();
                        int serverStatus = (responseBody.has("serverStatus") && !responseBody.get("serverStatus").isJsonNull()) ? responseBody.get("serverStatus").getAsInt() : 1;
                        if (serverMessage != null) panel.setServerAnnoucement(serverStatus, serverMessage);
                    }
                } catch (Exception e) {
                    log.debug("Error processing response");
                } finally {
                    response.close();
                }
            }
        });
    }

    private void postRequest(postBody postBody, String route) {
        postRequest(postBody, null, route);
    }

    private void postRequest(postBody postBody, byte[] screenshot, String route) {
        // Validate the webhook path and url
        String url = API_ENDPOINT;
        if (Strings.isNullOrEmpty(url) || route == null) return;
        else url = API_ENDPOINT + route;
        HttpUrl u = HttpUrl.parse(url);
        if (u == null) { log.info("Malformed webhook url {}", url); return; }

        // Build the payload body
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(postBody));

        // Add formdata to the payload if a screenshot was taken
        if (screenshot != null) {
            requestBodyBuilder.addFormDataPart("file", "image.png",
                    RequestBody.create(MediaType.parse("image/png"), screenshot));
        }

        // Build the request
        MultipartBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder().url(url).post(requestBody).build();

        // Send the request
        okHttpClient.newCall(request).enqueue(new Callback() {
            // If the request doesn't hit the server, clear the server+team info in the panel
            @Override
            public void onFailure(Call call, IOException e) {
                try { throw new ConnectException("Unreachable"); }
                catch (ConnectException c) {
                    panel.setServerStatusText(0);
                    panel.setServerAnnoucement(0, "");
                    panel.setPokescapeTeam("", "");
                    panel.setTotalLevel("");
                    panel.setDexCount("");
                }
            }
            // If the request is successful, parse the response
            @Override
            public void onResponse(Call call, Response response) {
                try {
                    JsonObject responseBody;
                    try { responseBody = GSON.fromJson(response.body() != null ? response.body().string() : null, JsonObject.class);}
                    catch (Exception e) { responseBody = new JsonObject(); }

                    // Update the server status in the panel to reflect the success/failure of the request
                    if (response.code() / 100 != 2) {
                        panel.setServerStatusText(2);
                        panel.setPokescapeTeam("", "");
                        panel.setTotalLevel("");
                        panel.setDexCount("");
                    } else panel.setServerStatusText(1);

                    // Update the server annoucement in the side panel
                    if (responseBody.has("serverMessage") && !responseBody.get("serverMessage").isJsonNull()) {
                        String serverMessage = responseBody.get("serverMessage").getAsString();
                        int serverStatus = (responseBody.has("serverStatus") && !responseBody.get("serverStatus").isJsonNull()) ? responseBody.get("serverStatus").getAsInt() : 1;
                        if (serverMessage != null) panel.setServerAnnoucement(serverStatus, serverMessage);
                    }

                    // If there's a help message for the player, print it to their chatbox
                    if (responseBody.has("localChatMsg") && !responseBody.get("localChatMsg").isJsonNull()) {
                        JsonArray messageStructure = responseBody.get("localChatMsg").getAsJsonArray();
                        if (messageStructure.isJsonArray()) utils.sendLocalChatMsg(messageStructure);
                    }

                    // Reinitialize SSE
                    if (responseBody.has("initSSE") && !responseBody.get("initSSE").isJsonNull()) {
                        if (sseHandler != null) sseHandler.cancel();
                        sseHandler = null;
                        initSSE();
                    }

                    // Update the side panel with the player's team info and verification status
                    if (route.equals("/profile") && responseBody.has("teamName") && responseBody.has("teamColor")) {
                        if (!responseBody.get("teamName").isJsonNull() && !responseBody.get("teamColor").isJsonNull()) {
                            String teamName = responseBody.get("teamName").getAsString();
                            String teamColor = responseBody.get("teamColor").getAsString();
                            panel.setPokescapeTeam(teamName, teamColor);
                        }
                        if (responseBody.has("verification") && !responseBody.get("verification").isJsonNull()) {
                            JsonObject verification = responseBody.get("verification").getAsJsonObject();
                            boolean tempoVerification = verification.get("tempoross").getAsBoolean();
                            boolean gotrVerification = verification.get("gotr").getAsBoolean();
                            panel.setTemporossVerification(tempoVerification);
                            panel.setGotrVerification(gotrVerification);
                        }
                        if (responseBody.has("goals") && !responseBody.get("goals").isJsonNull()) {
                            // TODO: Set the research description in the panel
                            goals.setGoals(responseBody.get("goals").getAsJsonArray());
                        }
                        if (responseBody.has("totalLevel") && !responseBody.get("totalLevel").isJsonNull()) {
                            String totalLevel = responseBody.get("totalLevel").getAsString();
                            panel.setTotalLevel(totalLevel);
                        }
                        if (responseBody.has("dexCount") && !responseBody.get("dexCount").isJsonNull()) {
                            String dexCount = responseBody.get("dexCount").getAsString();
                            panel.setDexCount(dexCount);
                        }
                        if (responseBody.has("eventPassword") && !responseBody.get("eventPassword").isJsonNull())
                            config.setEventPassword(responseBody.get("eventPassword").getAsString());
                        // Request a sync if the manifest is missing or old
                        if (responseBody.has("manifest") && !responseBody.get("manifest").isJsonNull()) {
                            if (cacheManifest == null || !cacheManifest.toString().equals(responseBody.get("manifest").getAsJsonObject().toString())) {
                                cacheManifest = responseBody.get("manifest").getAsJsonObject();
                                sync();
                            }
                        }
                        // Initialize the SSE connection if it hasn't yet been created
                        if (sseHandler == null) initSSE();
                    }

                    // Update pet and events after a sync
                    if (route.equals("/sync")) {
                        if (responseBody.has("pets") && !responseBody.get("pets").isJsonNull())
                            format.setPets(responseBody.get("pets").getAsJsonObject());
                        if (responseBody.has("events") && !responseBody.get("events").isJsonNull())
                            plugin.setGameEvents(responseBody.get("events").getAsJsonObject());
                        if (responseBody.has("activities") && !responseBody.get("activities").isJsonNull())
                            plugin.setGameActivities(responseBody.get("activities").getAsJsonObject());
                        if (responseBody.has("allowblock") && !responseBody.get("allowblock").isJsonNull())
                            plugin.setAllowBlockList(responseBody.get("allowblock").getAsJsonObject());
                    }

                    // Update the side panel with minigame verification status
                    if (route.equals("/validation") && responseBody.has("activity") && responseBody.has("valid")) {
                        if (!responseBody.get("activity").isJsonNull() && !responseBody.get("valid").isJsonNull()) {
                            String activity = responseBody.get("activity").getAsString();
                            boolean validity = responseBody.get("valid").getAsBoolean();
                            if (activity.equals("tempoross")) panel.setTemporossVerification(validity);
                            if (activity.equals("gotr")) panel.setGotrVerification(validity);
                        }
                    }

                    // When the server successfully validates loot it may send back a 210. This means take a screenshot!
                    if (response.code() == 210) {
                        // Add validation from this response into the body of the screenshot request
                        if (responseBody.has("validEvents") && !responseBody.get("validEvents").isJsonNull()) {
                            postBody.setValidEvents(responseBody.get("validEvents").getAsJsonArray());
                        }
                        // If a delay is specified, wait the delay amount before taking a screenshot. Otherwise, take the screenshot
                        if (responseBody.has("delayScreenshot") && !responseBody.get("delayScreenshot").isJsonNull()) {
                            int delay = responseBody.get("delayScreenshot").getAsInt();
                            scheduler.schedule(() -> requestScreenshot(postBody, route), delay, TimeUnit.MILLISECONDS);
                        } else {
                            requestScreenshot(postBody, route);
                        }
                    }
                } catch (Exception e) {
                    log.debug("Error processing response", e);
                } finally {
                    response.close();
                }
            }
        });
    }

    private void requestScreenshot(postBody postBody, String route) {
        drawManager.requestNextFrameListener(image -> {
            BufferedImage bufferedImage = (BufferedImage) image;
            // Resize the dimensions of the screenshot to 800px before sending it off
            bufferedImage = resizeScreenshot(bufferedImage, 800);
            byte[] imageBytes = null;
            try {
                imageBytes = convertImageToByteArray(bufferedImage);
            } catch (IOException e) {
                log.error("Error converting image to byte array", e);
            }
            if (imageBytes != null) postRequest(postBody, imageBytes, route);
        });
    }

    // Takes the widest dimension of the screenshot and scales it down proportionally
    public static BufferedImage resizeScreenshot(final BufferedImage screenshot, final int maxSize) {
        final Image resizedImg;
        if (screenshot.getWidth() > screenshot.getHeight()) resizedImg = screenshot.getScaledInstance(maxSize, -1, Image.SCALE_SMOOTH);
        else resizedImg = screenshot.getScaledInstance(-1, maxSize, Image.SCALE_SMOOTH);
        return ImageUtil.bufferedImageFromImage(resizedImg);
    }

    private static byte[] convertImageToByteArray(BufferedImage bufferedImage) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "png", byteArrayOutputStream);
        return byteArrayOutputStream.toByteArray();
    }
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.web;

import java.util.EnumSet;
import java.util.List;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import lombok.Data;
import net.runelite.api.WorldType;

@Data
class postBody {
    private String rsn;
    private String clientHash;
    private String pluginVersion;
    private Integer currentWorld;
    private EnumSet<WorldType> worldTypes;
    private JsonObject recentActivities;
    private boolean eventPasswordVisible;
    private boolean chatboxVisible;
    private Integer widgetSprite;
    private String triggerActivity;
    private String channels;
    private String validationData;
    private String npcName;
    private Integer npcID;
    private List<String> lootName;
    private List<Integer> lootID;
    private List<Integer> lootQuantity;
    private String gameEvent;
    private List<String> gameMsg;
    private JsonObject eventInfo;
    private JsonArray validEvents;
}

/*
 * Copyright (c) 2024, Quo <https://github.com/Quoded>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.pokescape.web;

import com.pokescape.PokescapeConfig;
import com.pokescape.util.Utils;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.common.collect.ImmutableSet;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.WorldType;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.List;

@Slf4j
public class formatBody {
    private @Inject Client client;
    private @Inject ItemManager itemManager;
    private @Inject PokescapeConfig config;
    private @Inject Utils utils;

    private JsonObject allPets;
    private static final ImmutableSet<String> PET_MESSAGES = ImmutableSet.of(
            "You have a funny feeling like you're being followed.",
            "You feel something weird sneaking into your backpack.",
            "You have a funny feeling like you would have been followed..."
    );

    private static final int ALL_FILTER = 10616837;
    private static final int GAME_FILTER = 10616840;

    public void setPets(JsonObject pets) {
        allPets = pets;
    }

    public postBody minigame(String validationData) {
        postBody postBody = new postBody();
        String rsn = client.getLocalPlayer().getName();
        String clientHash = Long.toString(client.getAccountHash());
        int world = client.getWorld();
        EnumSet<WorldType> worldType = client.getWorldType();

        postBody.setRsn(rsn);
        postBody.setClientHash(clientHash);
        postBody.setPluginVersion(PokescapeConfig.PLUGIN_VERSION);
        postBody.setEventPasswordVisible(eventPasswordVisible());
        postBody.setChatboxVisible(chatboxVisible());
        postBody.setCurrentWorld(world);
        postBody.setWorldTypes(worldType);
        postBody.setTriggerActivity("validation");
        postBody.setValidationData(validationData);
        return postBody;
    }

    public postBody event(String eventName, String eventType, List<String> messageCollector, JsonObject eventInfo, JsonObject recentActivities, Integer spriteID) {
        postBody postBody = new postBody();
        String rsn = client.getLocalPlayer().getName();
        String clientHash = Long.toString(client.getAccountHash());
        int world = client.getWorld();
        EnumSet<WorldType> worldType = client.getWorldType();

        // Populate body with game messages
        List<String> gameMessages = new ArrayList<>(messageCollector);

        // If other information is present, send it in the request
        if (eventInfo != null && !eventInfo.entrySet().isEmpty()) postBody.setEventInfo(eventInfo);

        postBody.setRsn(rsn);
        postBody.setClientHash(clientHash);
        postBody.setPluginVersion(PokescapeConfig.PLUGIN_VERSION);
        postBody.setEventPasswordVisible(eventPasswordVisible());
        postBody.setChatboxVisible(chatboxVisible());
        postBody.setWidgetSprite(spriteID);
        postBody.setCurrentWorld(world);
        postBody.setWorldTypes(worldType);
        postBody.setRecentActivities(filteredActivities(recentActivities));
        postBody.setTriggerActivity(eventType);
        postBody.setGameEvent(eventName);
        postBody.setGameMsg(gameMessages);
        return postBody;
    }

    public postBody loot(String activity, String npcName, Integer npcID, Collection<ItemStack> items, List<String> messageCollector, JsonObject recentActivities) {
        postBody postBody = new postBody();
        String rsn = client.getLocalPlayer().getName();
        String clientHash = Long.toString(client.getAccountHash());
        int world = client.getWorld();
        EnumSet<WorldType> worldType = client.getWorldType();

        // Populate body with loot info
        List<String> lootName = new ArrayList<>();
        List<Integer> lootID = new ArrayList<>();
        List<Integer> lootQuantity = new ArrayList<>();
        for (ItemStack item : stack(items)) {
            int itemId = item.getId();
            ItemComposition itemComposition = itemManager.getItemComposition(itemId);
            lootName.add(itemComposition.getName());
            lootID.add(itemId);
            lootQuantity.add(item.getQuantity());
        }
        utils.updateLootInfo(recentActivities, npcName, lootName, lootID, lootQuantity);

        // Populate body with game messages
        List<String> gameMessages = new ArrayList<>(messageCollector);

        // If a pet message is found add the pet item associated with the npc to the loot received
        for (String message : gameMessages) {
            if (PET_MESSAGES.contains(message)) {
                if (allPets != null && allPets.has(npcName)) {
                    JsonObject petInfo = allPets.get(npcName).getAsJsonObject();
                    String petName = petInfo.get("petName").getAsString();
                    Integer petID = petInfo.get("petID").getAsInt();
                    lootName.add(petName);
                    lootID.add(petID);
                    lootQuantity.add(1);
                    break;
                }
            }
        }

        // Clears activity to prevent false-positives on other loot (pets)
        if (recentActivities.has("nullOnLoot") && !recentActivities.get("nullOnLoot").isJsonNull()) {
            JsonArray activities = recentActivities.get("nullOnLoot").getAsJsonArray();
            for (JsonElement activityElem : activities) {
                String activityName = activityElem.getAsString();
                recentActivities.add(activityName, null);
            }
        }

        postBody.setRsn(rsn);
        postBody.setClientHash(clientHash);
        postBody.setPluginVersion(PokescapeConfig.PLUGIN_VERSION);
        postBody.setEventPasswordVisible(eventPasswordVisible());
        postBody.setChatboxVisible(chatboxVisible());
        postBody.setCurrentWorld(world);
        postBody.setWorldTypes(worldType);
        postBody.setRecentActivities(filteredActivities(recentActivities));
        postBody.setTriggerActivity(activity);
        postBody.setNpcName(npcName);
        postBody.setNpcID(npcID);
        postBody.setLootName(lootName);
        postBody.setLootID(lootID);
        postBody.setLootQuantity(lootQuantity);
        postBody.setGameMsg(gameMessages);
        return postBody;
    }

    private JsonObject filteredActivities(JsonObject recentActivities) {
        JsonObject filteredActivities = new JsonObject();
        if (recentActivities.has("filterActivities") && recentActivities.get("filterActivities").isJsonArray()) {
            JsonArray activities = recentActivities.get("filterActivities").getAsJsonArray();
            for (JsonElement activity : activities) {
                String activityName = activity.getAsString();
                if (recentActivities.has(activityName) && !recentActivities.get(activityName).isJsonNull()) {
                    filteredActivities.add(activityName, recentActivities.get(activityName));
                }
            }
        }
        return filteredActivities;
    }

    private boolean eventPasswordVisible() {
        String boolA = (config.overlayVisibility()) ? "1" : "0";
        String boolB = (!config.eventPassword().isEmpty()) ? "1" : "0";
        int binaryOut = Integer.parseInt(boolA+boolB,2);
        return binaryOut == 3;
    }

    private boolean chatboxVisible() {
        Widget allFilter = client.getWidget(ALL_FILTER);
        Widget gameFilter = client.getWidget(GAME_FILTER);
        int toggledState = 3053;
        boolean allVisibility = (allFilter != null ? allFilter.getSpriteId() : 0) == toggledState;
        boolean gameVisibility = (gameFilter != null ? gameFilter.getSpriteId() : 0) == toggledState;
        return allVisibility || gameVisibility;
    }

    private static Collection<ItemStack> stack(Collection<ItemStack> items) {
        final List<ItemStack> list = new ArrayList<>();
        for (final ItemStack item : items) {
            int quantity = 0;
            for (final ItemStack i : list) {
                if (i.getId() == item.getId()) {
                    quantity = i.getQuantity();
                    list.remove(i);
                    break;
                }
            }
            if (quantity > 0) list.add(new ItemStack(item.getId(), item.getQuantity() + quantity, item.getLocation()));
            else list.add(item);
        }
        return list;
    }
}

