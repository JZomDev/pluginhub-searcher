package com.barracudatrial;

import lombok.Getter;

import java.awt.Color;

/**
 * Caches config values for performance
 * Config method calls are slow, so we cache values and update on config changes
 */
public class CachedConfig
{
	private final BarracudaTrialConfig config;

	// Path settings
	@Getter private boolean showOptimalPath;
	@Getter private RouteOptimization routeOptimization;
	@Getter private Color pathColor;
	@Getter private int pathWidth;
	@Getter private int pathLookahead;
	@Getter private boolean showPathTiles;

	// Objective settings
	@Getter private boolean highlightObjectives;
	@Getter private Color objectivesColorCurrentWaypoint;
	@Getter private Color objectivesColorCurrentLap;
	@Getter private Color objectivesColorLaterLaps;
	@Getter private Color windCatcherColor;

	// Object highlighting settings
	@Getter private boolean highlightSpeedBoosts;
	@Getter private Color speedBoostColor;
	@Getter private boolean highlightClouds;
	@Getter private Color cloudColor;
	@Getter private int cloudDangerRadius;

	public CachedConfig(BarracudaTrialConfig config)
	{
		this.config = config;
		updateCache();
	}

	/**
	 * Updates all cached values from the config
	 * Should be called on plugin startup and when config changes
	 */
	public void updateCache()
	{
		showOptimalPath = config.showOptimalPath();
		routeOptimization = config.routeOptimization();
		pathColor = config.pathColor();
		pathWidth = config.pathWidth();
		pathLookahead = config.pathLookahead();
		showPathTiles = config.showPathTiles();

		highlightObjectives = config.highlightObjectives();
		objectivesColorCurrentWaypoint = config.objectivesColorCurrentWaypoint();
		objectivesColorCurrentLap = config.objectivesColorCurrentLap();
		objectivesColorLaterLaps = config.objectivesColorLaterLaps();
		windCatcherColor = config.windCatcherColor();

		highlightSpeedBoosts = config.highlightSpeedBoosts();
		speedBoostColor = config.speedBoostColor();
		highlightClouds = config.highlightClouds();
		cloudColor = config.cloudColor();
		cloudDangerRadius = config.cloudDangerRadius();
	}
}

package com.barracudatrial.game;

import com.barracudatrial.game.route.Difficulty;
import com.barracudatrial.game.route.RouteWaypoint;
import com.barracudatrial.game.route.TrialConfig;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.InterfaceID;

import java.util.*;

/**
 * Holds all game state for Barracuda Trial
 */
@Getter
public class State
{
	@Setter
	private TrialConfig currentTrial = null;

	public static final int CLOUD_ANIM_HARMLESS = -1;
	public static final int CLOUD_ANIM_HARMLESS_ALT = 8879;

	@Setter
	private boolean inTrial = false;

	private final Set<NPC> lightningClouds = new HashSet<>();

	private final Set<NPC> dangerousClouds = new HashSet<>();

	private final Set<GameObject> speedBoosts = new HashSet<>();

	@Setter
	private WorldPoint rumPickupLocation = null;

	@Setter
	private WorldPoint rumReturnLocation = null;

	@Setter
	private int rumsCollected = 0;

	@Setter
	private int lostSuppliesCollected = 0;

	@Setter
	private int lostSuppliesTotal = 0;

	@Setter
	private boolean hasThrowableObjective = false;

	@Setter
	private int lastKnownDifficulty = 0;

	@Setter
	private WorldPoint boatLocation = null;

	@Setter
	private WorldPoint frontBoatTileEstimatedActual = null;

	@Setter
	private LocalPoint frontBoatTileLocal = null;

	@Setter
	private int currentLap = 1;

	@Setter
	private List<WorldPoint> path = new ArrayList<>();

	@Setter
	private String lastPathRecalcCaller = "none";

	private final Set<WorldPoint> knownRockLocations = new HashSet<>();

	private final Map<WorldPoint, List<WorldPoint>> knownSpeedBoostLocations = new HashMap<>();

	private final Set<WorldPoint> knownFetidPoolLocations = new HashSet<>();

	private final Set<WorldPoint> knownToadPillarLocations = new HashSet<>();

	// True if interacted with
	private final Map<WorldPoint, Boolean> knownToadPillars = new HashMap<>();

	@Setter
	private int ticksSinceLastPathRecalc = 0;

	@Setter
	private int exclusionZoneMinX = 0;

	@Setter
	private int exclusionZoneMaxX = 0;

	@Setter
	private int exclusionZoneMinY = 0;

	@Setter
	private int exclusionZoneMaxY = 0;

	@Setter
	private List<RouteWaypoint> currentStaticRoute = null;

	private final Set<Integer> completedWaypointIndices = new HashSet<>();

	/**
	 * Clears all temporary state (called when leaving trial area)
	 */
	public void resetAllTemporaryState()
	{
		currentTrial = null;
		inTrial = false;
		lightningClouds.clear();
		dangerousClouds.clear();
		knownToadPillars.clear();
		rumPickupLocation = null;
		rumReturnLocation = null;
		rumsCollected = 0;
		lostSuppliesCollected = 0;
		lostSuppliesTotal = 0;
		hasThrowableObjective = false;
		boatLocation = null;
		currentLap = 1;
		path = new ArrayList<>();
		ticksSinceLastPathRecalc = 0;
		exclusionZoneMinX = 0;
		exclusionZoneMaxX = 0;
		exclusionZoneMinY = 0;
		exclusionZoneMaxY = 0;
		currentStaticRoute = null;
		completedWaypointIndices.clear();
	}

	public void clearLightningClouds()
	{
		lightningClouds.clear();
	}

	public void addLightningCloud(NPC npc)
	{
		lightningClouds.add(npc);
	}

	public Set<NPC> getLightningClouds()
	{
		return Collections.unmodifiableSet(lightningClouds);
	}

	public void clearDangerousClouds()
	{
		dangerousClouds.clear();
	}

	public void addDangerousCloud(NPC npc)
	{
		dangerousClouds.add(npc);
	}

	public Set<NPC> getDangerousClouds()
	{
		return Collections.unmodifiableSet(dangerousClouds);
	}

	public Set<GameObject> getSpeedBoosts()
	{
		return Collections.unmodifiableSet(speedBoosts);
	}

	public Set<WorldPoint> getKnownRockLocations()
	{
		return Collections.unmodifiableSet(knownRockLocations);
	}

	public Map<WorldPoint, List<WorldPoint>> getKnownSpeedBoostLocations()
	{
		return Collections.unmodifiableMap(knownSpeedBoostLocations);
	}

	public Set<WorldPoint> getKnownFetidPoolLocations()
	{
		return Collections.unmodifiableSet(knownFetidPoolLocations);
	}

	public Set<WorldPoint> getKnownToadPillarLocations()
	{
		return Collections.unmodifiableSet(knownToadPillarLocations);
	}

	public Map<WorldPoint, Boolean> getKnownToadPillars()
	{
		return Collections.unmodifiableMap(knownToadPillars);
	}

	public Boolean updateKnownToadPillar(WorldPoint location, boolean isInteractedWith)
	{
		return knownToadPillars.put(location, isInteractedWith);
	}

	public void updateKnownRockLocations(Set<WorldPoint> locations)
	{
		knownRockLocations.clear();
		knownRockLocations.addAll(locations);
	}

	public void updateSpeedBoosts(Set<GameObject> boosts)
	{
		speedBoosts.clear();
		speedBoosts.addAll(boosts);
	}

	public void updateKnownSpeedBoostLocations(Map<WorldPoint, List<WorldPoint>> locations)
	{
		knownSpeedBoostLocations.clear();
		knownSpeedBoostLocations.putAll(locations);
	}

	public void updateKnownFetidPoolLocations(Set<WorldPoint> locations)
	{
		knownFetidPoolLocations.clear();
		knownFetidPoolLocations.addAll(locations);
	}

	public void updateKnownToadPillarLocations(Set<WorldPoint> locations)
	{
		knownToadPillarLocations.clear();
		knownToadPillarLocations.addAll(locations);
	}

	public Set<Integer> getCompletedWaypointIndices()
	{
		return Collections.unmodifiableSet(completedWaypointIndices);
	}

	public void markWaypointCompleted(int waypointIndex)
	{
		completedWaypointIndices.add(waypointIndex);
		
		var route = getCurrentStaticRoute();
		if (route == null || waypointIndex <= 0)
		{
			return;
		}

		for (int i = waypointIndex - 1; i >= 0; i--)
		{
			RouteWaypoint waypoint = route.get(i);
			if (waypoint.getType().isNonNavigableHelper())
			{
				completedWaypointIndices.add(i);
			}
			else
			{
				break;
			}
		}
	}

	public boolean isWaypointCompleted(int waypointIndex)
	{
		return completedWaypointIndices.contains(waypointIndex);
	}

	/**
	 * Calculates the next uncompleted navigable waypoint index by scanning the route.
	 * @return Index of next navigable waypoint, or 0 if route is empty/null
	 */
	public int getNextNavigableWaypointIndex()
	{
		if (currentStaticRoute == null || currentStaticRoute.isEmpty())
		{
			return 0;
		}

		int routeSize = currentStaticRoute.size();
		for (int i = 0; i < routeSize; i++)
		{
			if (!completedWaypointIndices.contains(i))
			{
				RouteWaypoint waypoint = currentStaticRoute.get(i);
				if (!waypoint.getType().isNonNavigableHelper())
				{
					return i;
				}
			}
		}

		return 0;
	}

	public static Difficulty getCurrentDifficulty(Client client)
	{
		var widget = client.getWidget(InterfaceID.SailingBtHud.BT_RANK_GFX);
		if (widget == null || widget.isHidden())
		{
			return Difficulty.SWORDFISH;
		}

		var spriteId = widget.getSpriteId();
		
		switch (spriteId)
		{
			case 7027:
				return Difficulty.SWORDFISH;
			case 7028:
				return Difficulty.SHARK;
			case 7029:
				return Difficulty.MARLIN;
			default:
				return Difficulty.SWORDFISH; // Default to easiest difficulty
		}
	}
}

package com.barracudatrial.game.route;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TrialType
{
	TEMPOR_TANTRUM("Tempor Tantrum"),
	JUBBLY_JIVE("Jubbly Jive"),
	GWENITH_GLIDE("Gwenith Glide");

	private final String displayName;
}

package com.barracudatrial.game.route;

import lombok.Getter;

/**
 * Represents the difficulty levels for Barracuda Trial.
 * Each difficulty determines the number of laps and rum shipments required.
 */
@Getter
public enum Difficulty
{
	SWORDFISH,
	SHARK,
	MARLIN
}

package com.barracudatrial.game.route;

import net.runelite.api.gameval.ObjectID;

import java.util.List;
import java.util.Set;

public class GwenithGlideConfig implements TrialConfig
{
	// Crystal motes - wind motes that provide speed boosts and crystal immunity
	// Not currently implemented - up to the user to swerve to grab when needed
	// public static final int CRYSTAL_MOTE_ID = ObjectID.SAILING_BT_GWENITH_GLIDE_MOTE; // 58980

	// Resonance crystals - the crystals that spawn white spikes
	// Not currently implemented - you can sail through these and sustain minimal drawback
	// public static final Set<Integer> RESONANCE_CRYSTAL_IDS = Set.of(
	// 	ObjectID.SAILING_BT_GWENITH_GLIDE_CRYSTAL, // 58978
	// 	ObjectID.SAILING_BT_GWENITH_GLIDE_CRYSTAL_2 // 58979
	// );

	private static final Set<Integer> SHIPMENT_IDS = Set.of(
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_1, // 58982
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_2,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_3,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_4,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_5,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_6,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_7,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_8,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_9,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_10,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_11,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_12,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_13,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_14,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_15,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_16,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_17,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_18,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_19,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_20,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_21,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_22,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_23,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_24,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_25,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_26,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_27,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_28,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_29,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_30,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_31,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_32,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_33,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_34,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_35,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_36,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_37,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_38,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_39,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_40,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_41,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_42,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_43,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_44,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_45,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_46,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_47,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_48,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_49,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_50,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_51,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_52,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_53,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_54,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_55,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_56,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_57,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_58,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_59,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_60,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_61,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_62,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_63,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_64,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_65,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_66,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_67,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_68,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_69,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_70,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_71,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_72,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_73,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_74,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_75,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_76,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_77,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_78,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_79,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_80,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_81,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_82,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_83,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_84,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_85,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_86,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_87,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_88,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_89,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_90,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_91,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_92,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_93,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_94,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_95,
			ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_96 // 59077
	);

	private static final int SHIPMENT_IMPOSTOR_ID = ObjectID.SAILING_BT_GWENITH_GLIDE_COLLECTABLE_SUPPLIES; // 58981

	@Override
	public TrialType getTrialType()
	{
		return TrialType.GWENITH_GLIDE;
	}

	@Override
	public Set<Integer> getShipmentBaseIds()
	{
		return SHIPMENT_IDS;
	}

	@Override
	public int getShipmentImpostorId()
	{
		return SHIPMENT_IMPOSTOR_ID;
	}

	@Override
	public List<RouteWaypoint> getRoute(Difficulty difficulty)
	{
		return GwenithGlideRoutes.getRoute(difficulty);
	}
}

package com.barracudatrial.game.route;

import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

/**
 * Utility for common route waypoint filtering and searching operations
 * Eliminates repeated patterns across rendering and path planning code
 */
public class RouteWaypointFilter
{
	/**
	 * Finds the next N navigable waypoints starting from a given index (wrapping around)
	 * Returns a list of waypoint locations
	 */
	public static List<WorldPoint> findNextNavigableWaypoints(
			List<RouteWaypoint> route,
			int startIndex,
			Set<Integer> completedIndices,
			int count)
	{
		List<WorldPoint> locations = new ArrayList<>(count);

		if (route == null || route.isEmpty() || startIndex < 0)
		{
			return locations;
		}

		int foundCount = 0;
		for (int offset = 0; offset < route.size() && foundCount < count; offset++)
		{
			int checkIndex = (startIndex + offset) % route.size();
			RouteWaypoint waypoint = route.get(checkIndex);

			if (!completedIndices.contains(checkIndex) && !waypoint.getType().isNonNavigableHelper())
			{
				locations.add(waypoint.getLocation());
				foundCount++;
			}
		}

		return locations;
	}

	/**
	 * Extracts all waypoint locations of a specific type and lap
	 */
	public static Set<WorldPoint> getLocationsByTypeAndLap(
			List<RouteWaypoint> route,
			RouteWaypoint.WaypointType type,
			int lap,
			Set<Integer> completedIndices)
	{
		Set<WorldPoint> locations = new java.util.HashSet<>();

		for (int i = 0; i < route.size(); i++)
		{
			if (completedIndices.contains(i))
			{
				continue;
			}

			RouteWaypoint waypoint = route.get(i);
			if (waypoint.getType() == type && waypoint.getLap() == lap)
			{
				locations.add(waypoint.getLocation());
			}
		}

		return locations;
	}
}

package com.barracudatrial.game.route;

import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.barracudatrial.game.route.JubblyJiveConfig.TOAD_PICKUP_LOCATION;
import static com.barracudatrial.game.route.JubblyJiveConfig.TOAD_PILLARS;
import static com.barracudatrial.game.route.RouteWaypoint.WaypointType;

// S 931.10 SailingBtHud.BT_PARTIAL_TEXT text = holding toad count
public class JubblyJiveRoutes
{
	private static final Map<Difficulty, List<RouteWaypoint>> ROUTES = new HashMap<>();

	static
	{
		// SWORDFISH difficulty - 1 lap, 20 shipments + 4 toads
		// Captured 2025-11-23
		ROUTES.put(Difficulty.SWORDFISH, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2413, 3016, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2396, 3010, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2378, 3008, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2362, 2998, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2353, 2977, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2345, 2974, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2320, 2976, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2285, 2978, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2280, 2978, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2278, 2979, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2276, 2981, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2273, 2984, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2269, 2987, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2265, 2990, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2260, 2992, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2255, 2992, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2250, 2992, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2246, 2994, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2243, 2997, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2241, 3000, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2239, 3004, 0)),
			new RouteWaypoint(WaypointType.TOAD_PICKUP, TOAD_PICKUP_LOCATION), //baseid 59169 impostor 59170
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2248, 3023, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2311, 3021, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2330, 3016, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2353, 3005, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2358, 2964, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[4]), // ID : 59148 impostor: 59150. with toad impostor = 59149
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2367, 2948, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2386, 2940, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2421, 2938, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[5]), // ID : 59154 impostor: 59156. with toad impostor = 59155
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2434, 2949, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2432, 2977, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2979, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2983, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2987, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2433, 2982, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2991, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2992, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2439, 2990, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2435, 2985, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2988, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[6]), // ID : 59160 impostor: 59162. with toad impostor = 59161
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[7]) // ID : 59166 impostor: 59168. with toad impostor = 59167
		));

		
		// SHARK difficulty - 2 lap, 38 shipments + 12 toads
		// Captured 2025-11-23
		ROUTES.put(Difficulty.SHARK, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2413, 3016, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2396, 3010, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2378, 3008, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2362, 2998, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2353, 2977, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2345, 2974, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2332, 2972, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2320, 2976, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2297, 2978, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2285, 2978, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2280, 2978, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2278, 2979, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2276, 2981, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2273, 2984, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2269, 2987, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2265, 2990, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2260, 2992, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2255, 2992, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2250, 2992, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2243, 2997, 0)),
			new RouteWaypoint(WaypointType.TOAD_PICKUP, TOAD_PICKUP_LOCATION), //baseid 59169 impostor 59170
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2239, 3004, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2238, 3012, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2239, 3008, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2248, 3023, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2273, 3006, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[0]), // ID : 59124
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2290, 2998, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[1]), // ID : 59130
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2301, 3018, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[2]), // ID : 59136
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2311, 3021, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2330, 3016, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2345, 2991, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2358, 2964, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[4]), // ID : 59148 impostor: 59150. with toad impostor = 59149
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2367, 2948, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2386, 2940, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2421, 2938, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[5]), // ID : 59154 impostor: 59156. with toad impostor = 59155
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2434, 2949, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2432, 2977, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2979, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2983, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2987, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2433, 2982, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2991, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2992, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2439, 2990, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2435, 2985, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2988, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[6]), // ID : 59160 impostor: 59162. with toad impostor = 59161

			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[7]), // 59166 impostor: 59168. with toad impostor = 59167
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2431, 3014, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2428, 3019, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2425, 3022, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2420, 3026, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2417, 3026, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2412, 3026, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2407, 3024, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2393, 3020, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2371, 3022, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2341, 3031, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2338, 3029, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2335, 3026, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2333, 3022, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2332, 3017, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2333, 3011, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2353, 3005, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[3]), // ID : 59142
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2379, 2993, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2382, 2970, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[4]), // ID : 59148 impostor: 59150. with toad impostor = 59149
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2390, 2956, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2420, 2959, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[5]), // ID : 59154 impostor: 59156. with toad impostor = 59155
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2422, 2975, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2414, 2992, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[6]), // ID : 59160 impostor: 59162. with toad impostor = 59161
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2416, 3001, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[7]) // ID : 59166 impostor: 59168. with toad impostor = 59167
		));

		// MARLIN difficulty - 3 laps, 56 shipments + 12 toads
		ROUTES.put(Difficulty.MARLIN, 
			List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2412, 3026, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2396, 3010, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2378, 3008, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2362, 2998, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2345, 2974, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2320, 2976, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2297, 2978, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2280, 2978, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2278, 2979, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2276, 2981, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2273, 2984, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2269, 2987, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2265, 2990, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2260, 2992, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2255, 2992, 0)),
			new RouteWaypoint(1, WaypointType.TOAD_PICKUP, TOAD_PICKUP_LOCATION,
				List.of(
					new WorldPoint(2270, 2987, 0),
					new WorldPoint(2290, 2980, 0)
				)
			), //baseid 59169 impostor 59170
			new RouteWaypoint(WaypointType.USE_WIND_CATCHER, new WorldPoint(2250, 3005, 0)),
			new RouteWaypoint(WaypointType.USE_WIND_CATCHER, new WorldPoint(2253, 3008, 0)),
			new RouteWaypoint(WaypointType.USE_WIND_CATCHER, new WorldPoint(2259, 3011, 0)),
			new RouteWaypoint(WaypointType.USE_WIND_CATCHER, new WorldPoint(2265, 3010, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2273, 3006, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2290, 2998, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[1]), // ID : 59130
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2301, 3018, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[2]), // ID : 59136,
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2311, 3021, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2330, 3016, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2345, 2991, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2353, 2977, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2358, 2964, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[4]), // ID : 59148 impostor: 59150. with toad impostor = 59149
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2367, 2948, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2386, 2940, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2421, 2938, 0)),
			new JubblyJiveToadPillarWaypoint(TOAD_PILLARS[5]), // ID : 59154 impostor: 59156. with toad impostor = 59155
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2434, 2949, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2979, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2983, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2987, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2433, 2982, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2991, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2992, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2439, 2990, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2435, 2985, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2988, 0)),
			
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[7]), // ID : 59160 impostor: 59162. with toad impostor = 59161
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2433, 3016, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2429, 3015, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2426, 3012, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2423, 3009, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2420, 3006, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2416, 3001, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[6]), // ID : 59160 impostor: 59162. with toad impostor = 59161
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2414, 2992, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2422, 2975, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2420, 2959, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[5]), // ID : 59154 impostor: 59156. with toad impostor = 59155
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2409, 2948, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2390, 2956, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[4]), // ID : 59148 impostor: 59150. with toad impostor = 59149
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2382, 2970, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2376, 2976, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2373, 2979, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2369, 2982, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2365, 2985, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[3]), // ID : 59142
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2332, 2972, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2352, 2985, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2353, 2994, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2351, 2994, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2349, 2994, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2347, 2994, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2344, 2993, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2344, 2990, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2346, 2987, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2348, 2985, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2350, 2983, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2349, 2979, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2347, 2978, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2345, 2976, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2339, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2335, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2331, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2327, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2323, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2318, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2315, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2313, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2310, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2308, 2974, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2303, 2978, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2289, 2980, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2286, 2981, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2282, 2982, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2278, 2984, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2273, 2987, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2267, 2989, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2260, 2992, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2256, 2994, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2250, 2992, 0),
				List.of(
					new WorldPoint(2266, 2990, 0),
					new WorldPoint(2279, 2984, 0),
					new WorldPoint(2298, 2978, 0),
					new WorldPoint(2316, 2974, 0),
					new WorldPoint(2330, 2974, 0),
					new WorldPoint(2351, 2983, 0)
				)
			),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2243, 2997, 0)),
			new RouteWaypoint(2, WaypointType.TOAD_PICKUP, TOAD_PICKUP_LOCATION), //baseid 59169 impostor 59170
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2239, 3004, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2239, 3008, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[1]), // ID : 59130
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2248, 3023, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2297, 2997, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2298, 2996, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2299, 2995, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2300, 2993, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2301, 2992, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2326, 2982, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2333, 2956, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2335, 2946, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2341, 2937, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2355, 2930, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2370, 2929, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2366, 2933, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2367, 2936, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2368, 2940, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2370, 2945, 0)),
			new JubblyJiveToadPillarWaypoint(2, TOAD_PILLARS[4]), // ID : 59148 impostor: 59150. with toad impostor = 59149
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2379, 2941, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2383, 2941, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2389, 2940, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2394, 2938, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2396, 2932, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2400, 2925, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2416, 2923, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2423, 2923, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2439, 2926, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2463, 2944, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2464, 2961, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2449, 2971, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2447, 2989, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2447, 2992, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2447, 2995, 0)),
			new RouteWaypoint(2, WaypointType.USE_WIND_CATCHER, new WorldPoint(2447, 2998, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2447, 3004, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2446, 3008, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2446, 3013, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2447, 3001, 0)),

			new JubblyJiveToadPillarWaypoint(3, TOAD_PILLARS[7]), // ID : 59166 impostor: 59168. with toad impostor = 59167
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2438, 3011, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 3011, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2428, 3011, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2419, 3014, 0)),
			new JubblyJiveToadPillarWaypoint(3, TOAD_PILLARS[6]), // ID : 59160 impostor: 59162. with toad impostor = 59161
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2413, 3016, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2393, 3020, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2371, 3022, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2353, 3028, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2351, 3029, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2348, 3029, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2345, 3030, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2341, 3031, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2323, 3037, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2321, 3038, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2319, 3040, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2317, 3042, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2314, 3042, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2309, 3041, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2307, 3039, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2307, 3036, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2307, 3033, 0)),
			new JubblyJiveToadPillarWaypoint(3, TOAD_PILLARS[2]), // ID : 59136
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2353, 3005, 0)),
			new JubblyJiveToadPillarWaypoint(3, TOAD_PILLARS[3]), // ID : 59142
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2379, 2993, 0)),
			new RouteWaypoint(3, WaypointType.USE_WIND_CATCHER, new WorldPoint(2389, 2986, 0)),
			new RouteWaypoint(3, WaypointType.USE_WIND_CATCHER, new WorldPoint(2392, 2984, 0)),
			new RouteWaypoint(3, WaypointType.USE_WIND_CATCHER, new WorldPoint(2394, 2982, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2396, 2980, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2402, 2973, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2403, 2972, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2406, 2970, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2408, 2967, 0)),
			new RouteWaypoint(3, WaypointType.USE_WIND_CATCHER, new WorldPoint(2412, 2968, 0)),
			new RouteWaypoint(3, WaypointType.USE_WIND_CATCHER, new WorldPoint(2415, 2965, 0)),
			new RouteWaypoint(3, WaypointType.USE_WIND_CATCHER, new WorldPoint(2419, 2961, 0)),
			new JubblyJiveToadPillarWaypoint(3, TOAD_PILLARS[5]), // ID : 59154 impostor: 59156. with toad impostor = 59155
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2432, 2977, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2979, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2983, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2987, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2433, 2982, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2991, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2434, 2992, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2435, 2985, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2436, 2988, 0)),
			new JubblyJiveToadPillarWaypoint(3, TOAD_PILLARS[6]), // ID : 59160 impostor: 59162. with toad impostor = 59161
			new JubblyJiveToadPillarWaypoint(3, TOAD_PILLARS[7]) // ID : 59166 impostor: 59168. with toad impostor = 59167
		)
	);
	}

	/**
	 * Get the static route for a given difficulty.
	 * @param difficulty The difficulty level
	 * @return List of RouteWaypoints representing the optimal waypoint sequence,
	 *         or empty list if no route is defined for this difficulty
	 */
	public static List<RouteWaypoint> getRoute(Difficulty difficulty)
	{
		return ROUTES.getOrDefault(difficulty, new ArrayList<>());
	}
}

package com.barracudatrial.game.route;

import java.util.List;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class RouteWaypoint
{
	protected final WaypointType type;
	private final int lap;
	private final WorldPoint location;

	// If the location is not visible, we fall back to these locations (in order of preference)
	private final List<WorldPoint> fallbackLocations;

	public RouteWaypoint(WaypointType type, WorldPoint location)
	{
		this.lap = 1;
		this.type = type;
		this.location = location;
		this.fallbackLocations = List.of();
	}

	public RouteWaypoint(int lap, WaypointType type, WorldPoint location)
	{
		this.lap = lap;
		this.type = type;
		this.location = location;
		this.fallbackLocations = List.of();
	}

	public RouteWaypoint(int lap, WaypointType type, WorldPoint location, List<WorldPoint> fallbackLocations)
	{
		this.lap = lap;
		this.type = type;
		this.location = location;
		this.fallbackLocations = fallbackLocations;
	}

	@Getter
	public enum WaypointType
	{
		SHIPMENT(2),
		RUM_PICKUP(9),
		RUM_DROPOFF(9),
		TOAD_PICKUP(9),
		TOAD_PILLAR(10),
		PORTAL_ENTER(1),
		PORTAL_EXIT(0),
		PATHFINDING_HINT(0),
		USE_WIND_CATCHER(0);

		private final int toleranceTiles;

		WaypointType(int toleranceTiles)
		{
			this.toleranceTiles = toleranceTiles;
		}

		public boolean isNonNavigableHelper()
		{
			return this == PATHFINDING_HINT || this == USE_WIND_CATCHER || this == PORTAL_EXIT;
		}
	}

	@Override
	public String toString()
	{
		WorldPoint loc = getLocation();
		return String.format("%s at %s", type, loc != null ? loc : "unknown");
	}
}

package com.barracudatrial.game.route;

import lombok.Getter;

import static com.barracudatrial.game.route.RouteWaypoint.WaypointType.TOAD_PILLAR;

@Getter
public class JubblyJiveToadPillarWaypoint extends RouteWaypoint
{
	JubblyJiveToadPillar pillar;

	public JubblyJiveToadPillarWaypoint(JubblyJiveToadPillar pillar)
	{
        super(TOAD_PILLAR, pillar.getLocation());
		this.pillar = pillar;
	}

	public JubblyJiveToadPillarWaypoint(int lap, JubblyJiveToadPillar pillar)
	{
		super(lap, TOAD_PILLAR, pillar.getLocation());
		this.pillar = pillar;
	}
}

package com.barracudatrial.game.route;

import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.ObjectID;

import java.util.List;
import java.util.Set;

public class JubblyJiveConfig implements TrialConfig
{
	public static final WorldPoint TOAD_PICKUP_LOCATION = new WorldPoint(2245, 3009, 0); // ID: BALLOON_TOAD_PILE

	public static final int BOAT_EXCLUSION_WIDTH = 4;
	public static final int BOAT_EXCLUSION_HEIGHT = 8;

	public static final JubblyJiveToadPillar[] TOAD_PILLARS =
	{
		new JubblyJiveToadPillar(
				new WorldPoint(2264, 3003, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_0_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK0_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK0_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_0_PARENT, // 59124
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_0_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_0
		),
		new JubblyJiveToadPillar(
				new WorldPoint(2294, 2989, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_1_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK1_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK1_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_1_PARENT, // 59130
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_1_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_1
		),
		new JubblyJiveToadPillar(
				new WorldPoint(2309, 3011, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_2_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK2_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK2_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_2_PARENT, // 59136
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_2_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_2
		),
		new JubblyJiveToadPillar(
				new WorldPoint(2349, 3000, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_3_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK3_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK3_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_3_PARENT, // 59142
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_3_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_3
		),
		new JubblyJiveToadPillar(
				new WorldPoint(2375, 2955, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_4_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK4_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK4_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_4_PARENT, // 59148
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_4_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_4
		),
		new JubblyJiveToadPillar(
				new WorldPoint(2422, 2950, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_5_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK5_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK5_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_5_PARENT, // 59154
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_5_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_5
		),
		new JubblyJiveToadPillar(
				new WorldPoint(2422, 2998, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_6_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK6_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK6_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_6_PARENT, // 59160
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_6_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_6
		),
		new JubblyJiveToadPillar(
				new WorldPoint(2442, 3018, 0),
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_7_PARENT,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK7_NO_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_ROCK7_TOAD,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_7_PARENT, // 59166
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_7_NOOP,
				ObjectID.SAILING_BT_JUBBLY_JIVE_PILLAR_CLICKBOX_7
		)
	};

	private static final Set<Integer> SHIPMENT_IDS = Set.of(
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_1,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_2,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_3,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_4,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_5,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_6,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_7,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_8,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_9,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_10,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_11,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_12,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_13,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_14,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_15,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_16,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_17,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_18,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_19,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_20,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_21,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_22,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_23,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_24,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_25,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_26,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_27,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_28,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_29,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_30,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_31,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_32,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_33,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_34,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_35,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_36,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_37,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_38,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_39,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_40,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_41,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_42,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_43,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_44,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_45,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_46,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_47,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_48,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_49,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_50,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_51,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_52,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_53,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_54,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_55,
			ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_56
	);
	
	private static final int SHIPMENT_IMPOSTOR_ID = ObjectID.SAILING_BT_JUBBLY_JIVE_COLLECTABLE_SUPPLIES;

	public static final Set<Integer> FETID_POOL_IDS = Set.of(
		ObjectID.SAILING_FETID_POOL,
		ObjectID.SAILING_FETID_POOL_2X2,
		ObjectID.SAILING_FETID_POOL_3X3A,
		ObjectID.SAILING_FETID_POOL_3X3B,
		ObjectID.SAILING_FETID_POOL_3X3C
	);

	@Override
	public TrialType getTrialType()
	{
		return TrialType.JUBBLY_JIVE;
	}

	@Override
	public Set<Integer> getShipmentBaseIds()
	{
		return SHIPMENT_IDS;
	}

	@Override
	public int getShipmentImpostorId()
	{
		return SHIPMENT_IMPOSTOR_ID;
	}

	@Override
	public List<RouteWaypoint> getRoute(Difficulty difficulty)
	{
		return JubblyJiveRoutes.getRoute(difficulty);
	}
}

package com.barracudatrial.game.route;

import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.barracudatrial.game.route.RouteWaypoint.WaypointType;

// Gwenith Glide - Crystal waters navigation with portals and motes
public class GwenithGlideRoutes
{
	private static final Map<Difficulty, List<RouteWaypoint>> ROUTES = new HashMap<>();

	static
	{ROUTES.put(Difficulty.SWORDFISH, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2254, 3469, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2272, 3475, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2273, 3487, 0)),
			new RouteWaypoint(WaypointType.PORTAL_ENTER, new WorldPoint(2260, 3497, 0)), // ithell
			new RouteWaypoint(WaypointType.PORTAL_EXIT, new WorldPoint(2088, 3232, 0)), // ithell
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2104, 3229, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2118, 3230, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2128, 3254, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2134, 3263, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2128, 3277, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2121, 3289, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2129, 3297, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2147, 3295, 0)),
			new RouteWaypoint(WaypointType.PORTAL_ENTER, new WorldPoint(2158, 3293, 0)), // ithell
			new RouteWaypoint(2, WaypointType.PORTAL_EXIT, new WorldPoint(2260, 3504, 0)), // ithell
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2264, 3516, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2265, 3532, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2248, 3541, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2253, 3559, 0)),
			new RouteWaypoint(2, WaypointType.PORTAL_ENTER, new WorldPoint(2241, 3574, 0)), // amlodd
			new RouteWaypoint(2, WaypointType.PORTAL_EXIT, new WorldPoint(2080, 3215, 0)), // amlodd
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2110, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2119, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2122, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2125, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2128, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2132, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2134, 3214, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2141, 3216, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2140, 3230, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2132, 3233, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2150, 3243, 0)),
			new RouteWaypoint(2, WaypointType.PORTAL_ENTER, new WorldPoint(2154, 3247, 0)), // amlodd
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2208, 3574, 0)), // amlodd
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2190, 3569, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2195, 3544, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2201, 3521, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2197, 3512, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2107, 3140, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2092, 3144, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2069, 3160, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2057, 3186, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2074, 3208, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2100, 3205, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2117, 3189, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2133, 3192, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2128, 3171, 0)) // cadarn
		));

		ROUTES.put(Difficulty.SHARK, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2254, 3469, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2272, 3475, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2273, 3487, 0)),
			new RouteWaypoint(WaypointType.PORTAL_ENTER, new WorldPoint(2260, 3497, 0)), // ithell
			new RouteWaypoint(WaypointType.PORTAL_EXIT, new WorldPoint(2088, 3232, 0)), // ithell
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2104, 3229, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2118, 3230, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2132, 3233, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2128, 3254, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2134, 3263, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2128, 3277, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2121, 3289, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2129, 3297, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2147, 3295, 0)),
			new RouteWaypoint(WaypointType.PORTAL_ENTER, new WorldPoint(2158, 3293, 0)), // ithell
			new RouteWaypoint(2, WaypointType.PORTAL_EXIT, new WorldPoint(2260, 3504, 0)), // ithell
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2264, 3516, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2265, 3532, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2248, 3541, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2253, 3559, 0)),
			new RouteWaypoint(2, WaypointType.PORTAL_ENTER, new WorldPoint(2241, 3574, 0)), // amlodd
			new RouteWaypoint(2, WaypointType.PORTAL_EXIT, new WorldPoint(2080, 3215, 0)), // amlodd
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2110, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2119, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2122, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2125, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2128, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2132, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2134, 3214, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2141, 3216, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2140, 3230, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2150, 3243, 0)),
			new RouteWaypoint(2, WaypointType.PORTAL_ENTER, new WorldPoint(2154, 3247, 0)), // amlodd
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2208, 3574, 0)), // amlodd
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2190, 3569, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2195, 3544, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2201, 3521, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2197, 3512, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2107, 3140, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2092, 3144, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2069, 3160, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2057, 3186, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2074, 3208, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2100, 3205, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2117, 3189, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2133, 3192, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2128, 3171, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2197, 3502, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2197, 3492, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2185, 3478, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2175, 3476, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2173, 3469, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2157, 3464, 0)), // cryws
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2120, 3373, 0)), // cryws
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2086, 3376, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2079, 3389, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2094, 3396, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2105, 3406, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2085, 3413, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2081, 3426, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2093, 3436, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2110, 3439, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2118, 3439, 0)), //cryws
			new RouteWaypoint(4, WaypointType.PORTAL_EXIT, new WorldPoint(2148, 3464, 0)), // cryws
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2132, 3461, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2108, 3468, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2103, 3483, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2105, 3495, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2125, 3496, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2152, 3492, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2148, 3504, 0)),
			new RouteWaypoint(4, WaypointType.PORTAL_ENTER, new WorldPoint(2162, 3508, 0)), // hefin
			new RouteWaypoint(5, WaypointType.PORTAL_EXIT, new WorldPoint(2253, 3634, 0)), // hefin
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2240, 3629, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2231, 3618, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2228, 3609, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2224, 3596, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2220, 3592, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2190, 3598, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2186, 3596, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2183, 3594, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2180, 3592, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2176, 3591, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2173, 3590, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2169, 3589, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2165, 3588, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2166, 3589, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2161, 3591, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2162, 3590, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2163, 3589, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2164, 3588, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2165, 3589, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2166, 3588, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2160, 3592, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2155, 3594, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2152, 3595, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2148, 3596, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2144, 3596, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2140, 3597, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2135, 3597, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2131, 3598, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2123, 3599, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2112, 3591, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2098, 3583, 0)),
			new RouteWaypoint(5, WaypointType.PORTAL_ENTER, new WorldPoint(2105, 3574, 0)) // hefin
		));

		ROUTES.put(Difficulty.MARLIN, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2254, 3469, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2272, 3475, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2273, 3487, 0)),
			new RouteWaypoint(WaypointType.PORTAL_ENTER, new WorldPoint(2260, 3497, 0)), // ithell
			new RouteWaypoint(WaypointType.PORTAL_EXIT, new WorldPoint(2088, 3232, 0)), // ithell
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2104, 3229, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2118, 3230, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2132, 3233, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2128, 3254, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2134, 3263, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2147, 3295, 0)),
			new RouteWaypoint(WaypointType.PORTAL_ENTER, new WorldPoint(2158, 3293, 0)), // ithell
			new RouteWaypoint(2, WaypointType.PORTAL_EXIT, new WorldPoint(2260, 3504, 0)), // ithell
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2264, 3516, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2265, 3532, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2248, 3541, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2253, 3559, 0)),
			new RouteWaypoint(2, WaypointType.PORTAL_ENTER, new WorldPoint(2241, 3574, 0)), // amlodd
			new RouteWaypoint(2, WaypointType.PORTAL_EXIT, new WorldPoint(2080, 3215, 0)), // amlodd
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2110, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2119, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2122, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2125, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2128, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2132, 3214, 0)),
			new RouteWaypoint(2, WaypointType.PATHFINDING_HINT, new WorldPoint(2134, 3214, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2141, 3216, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2140, 3230, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2150, 3243, 0)),
			new RouteWaypoint(2, WaypointType.PORTAL_ENTER, new WorldPoint(2154, 3247, 0)), // amlodd
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2208, 3574, 0)), // amlodd
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2190, 3569, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2195, 3544, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2201, 3521, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2197, 3512, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2107, 3140, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2092, 3144, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2069, 3160, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2057, 3186, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2074, 3208, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2100, 3205, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2117, 3189, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2133, 3192, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2128, 3171, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2197, 3502, 0)), // cadarn
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2197, 3492, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2185, 3478, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2175, 3476, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2173, 3469, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2157, 3464, 0)), // cryws
			new RouteWaypoint(3, WaypointType.PORTAL_EXIT, new WorldPoint(2120, 3373, 0)), // cryws
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2086, 3376, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2079, 3389, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2094, 3396, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2105, 3406, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2108, 3409, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2111, 3413, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2113, 3416, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2116, 3419, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2116, 3426, 0)),
			new RouteWaypoint(3, WaypointType.PATHFINDING_HINT, new WorldPoint(2112, 3432, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2110, 3439, 0)),
			new RouteWaypoint(3, WaypointType.PORTAL_ENTER, new WorldPoint(2118, 3439, 0)), //cryws
			new RouteWaypoint(4, WaypointType.PORTAL_EXIT, new WorldPoint(2148, 3464, 0)), // cryws
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2132, 3461, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2108, 3468, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2103, 3483, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2105, 3495, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2125, 3496, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2152, 3492, 0)),
			new RouteWaypoint(4, WaypointType.SHIPMENT, new WorldPoint(2148, 3504, 0)),
			new RouteWaypoint(4, WaypointType.PORTAL_ENTER, new WorldPoint(2162, 3508, 0)), // hefin
			new RouteWaypoint(5, WaypointType.PORTAL_EXIT, new WorldPoint(2253, 3634, 0)), // hefin
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2240, 3629, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2231, 3618, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2228, 3609, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2224, 3596, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2220, 3592, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2190, 3598, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2186, 3596, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2183, 3594, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2180, 3592, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2176, 3591, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2173, 3590, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2169, 3589, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2165, 3588, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2166, 3589, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2161, 3591, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2162, 3590, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2163, 3589, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2164, 3588, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2165, 3589, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2166, 3588, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2160, 3592, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2155, 3594, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2152, 3595, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2148, 3596, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2144, 3596, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2140, 3597, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2135, 3597, 0)),
			new RouteWaypoint(5, WaypointType.PATHFINDING_HINT, new WorldPoint(2131, 3598, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2123, 3599, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2112, 3591, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2098, 3583, 0)),
			new RouteWaypoint(5, WaypointType.PORTAL_ENTER, new WorldPoint(2105, 3574, 0)), // hefin
			new RouteWaypoint(5, WaypointType.PORTAL_EXIT, new WorldPoint(2171, 3508, 0)), // hefin
			new RouteWaypoint(5, WaypointType.PORTAL_ENTER, new WorldPoint(2190, 3508, 0)), // cadarn
			new RouteWaypoint(5, WaypointType.PORTAL_EXIT, new WorldPoint(2205, 3508, 0)), // cadarn
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2222, 3515, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2214, 3538, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2224, 3546, 0)),
			new RouteWaypoint(5, WaypointType.SHIPMENT, new WorldPoint(2222, 3570, 0)),
			new RouteWaypoint(5, WaypointType.PORTAL_ENTER, new WorldPoint(2207, 3584, 0)),
			new RouteWaypoint(6, WaypointType.PORTAL_EXIT, new WorldPoint(2107, 3560, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2096, 3559, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2078, 3553, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2070, 3538, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2084, 3527, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2081, 3504, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2084, 3487, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2089, 3464, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2097, 3444, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2093, 3436, 0)),
			new RouteWaypoint(6, WaypointType.SHIPMENT, new WorldPoint(2104, 3431, 0)),
			new RouteWaypoint(6, WaypointType.PORTAL_ENTER, new WorldPoint(2105, 3424, 0)),
			new RouteWaypoint(7, WaypointType.PORTAL_EXIT, new WorldPoint(2198, 3584, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2176, 3580, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2174, 3562, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2181, 3543, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2163, 3543, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2155, 3568, 0)),
			new RouteWaypoint(7, WaypointType.PORTAL_ENTER, new WorldPoint(2142, 3582, 0)),
			new RouteWaypoint(7, WaypointType.PORTAL_EXIT, new WorldPoint(2137, 3253, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2132, 3269, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2128, 3277, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2132, 3284, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2121, 3289, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2129, 3297, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2131, 3318, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2142, 3336, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2154, 3346, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2147, 3368, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2128, 3381, 0)),
			new RouteWaypoint(7, WaypointType.SHIPMENT, new WorldPoint(2120, 3368, 0)),
			new RouteWaypoint(7, WaypointType.PORTAL_ENTER, new WorldPoint(2126, 3357, 0)),
			new RouteWaypoint(8, WaypointType.PORTAL_EXIT, new WorldPoint(2133, 3582, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2118, 3568, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2126, 3539, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2123, 3538, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2121, 3534, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2119, 3530, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2119, 3526, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2119, 3522, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2121, 3517, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2124, 3514, 0)),
			new RouteWaypoint(8, WaypointType.PATHFINDING_HINT, new WorldPoint(2128, 3513, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2131, 3512, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2140, 3518, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2162, 3520, 0)),
			new RouteWaypoint(8, WaypointType.PORTAL_ENTER, new WorldPoint(2172, 3523, 0)),
			new RouteWaypoint(8, WaypointType.PORTAL_EXIT, new WorldPoint(2107, 3413, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2094, 3419, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2085, 3413, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2081, 3426, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2080, 3439, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2080, 3454, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2096, 3504, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2107, 3520, 0)),
			new RouteWaypoint(8, WaypointType.SHIPMENT, new WorldPoint(2091, 3541, 0)),
			new RouteWaypoint(8, WaypointType.PORTAL_ENTER, new WorldPoint(2106, 3543, 0))
		));
	}

	/**
	 * Get the static route for a given difficulty.
	 * @param difficulty The difficulty level
	 * @return List of RouteWaypoints representing the optimal waypoint sequence,
	 *         or empty list if no route is defined for this difficulty
	 */
	public static List<RouteWaypoint> getRoute(Difficulty difficulty)
	{
		return ROUTES.getOrDefault(difficulty, new ArrayList<>());
	}
}

package com.barracudatrial.game.route;

import java.util.List;
import java.util.Set;

public interface TrialConfig
{
	TrialType getTrialType();

	// Shipment/lost supplies (universal across all trials, but different object IDs)
	Set<Integer> getShipmentBaseIds();
	int getShipmentImpostorId();

	// Routes
	List<RouteWaypoint> getRoute(Difficulty difficulty);
}

package com.barracudatrial.game.route;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class JubblyJiveToadPillar
{
    private final WorldPoint location;
    private final int parentObjectId;
    private final int noToadObjectId;
    private final int toadObjectId;
    private final int clickboxParentObjectId;
    private final int clickboxNoopObjectId;
    private final int clickboxObjectId;

    public JubblyJiveToadPillar(
        WorldPoint location,
        int parentObjectId,
        int noToadObjectId,
        int toadObjectId,
        int clickboxParentObjectId,
        int clickboxNoopObjectId,
        int clickboxObjectId
    ) {
        this.location = location;
        this.parentObjectId = parentObjectId;
        this.noToadObjectId = noToadObjectId;
        this.toadObjectId = toadObjectId;
        this.clickboxParentObjectId = clickboxParentObjectId;
        this.clickboxNoopObjectId = clickboxNoopObjectId;
        this.clickboxObjectId = clickboxObjectId;
    }

    public boolean matchesAnyObjectId(int id)
    {
        return id == parentObjectId
                || id == noToadObjectId
                || id == toadObjectId
                || id == clickboxParentObjectId
                || id == clickboxNoopObjectId
                || id == clickboxObjectId;
    }
}

package com.barracudatrial.game.route;
import com.barracudatrial.game.route.RouteWaypoint.WaypointType;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Static route data for Tempor Tantrum trial.
 *
 * Routes are hardcoded sequences of RouteWaypoints representing the optimal order
 * to complete objectives for each difficulty level. These routes were captured
 * during actual trial runs using the route capture system in debug mode.
 *
 * Each route contains:
 * - Lost Shipment locations in optimal collection order
 * - Rum pickup and dropoff waypoints at the correct points in sequence
 * - Coordinates are specific to the Tempor Tantrum trial layout
 * - Difficulty determines the number of laps (1, 2, or 3)
 *
 * The PathPlanner uses these routes to direct the player to the next uncompleted
 * waypoint in the sequence, with A* pathfinding handling tactical navigation
 * around clouds and rocks.
 */
public class TemporTantrumRoutes
{
	private static final WorldPoint RUM_PICKUP_LOCATION = new WorldPoint(3037, 2767, 0);
	private static final WorldPoint RUM_DROPOFF_LOCATION = new WorldPoint(3035, 2926, 0);

	private static final Map<Difficulty, List<RouteWaypoint>> ROUTES = new HashMap<>();

	static
	{
		// SWORDFISH difficulty - 1 lap, 14 shipments + rum pickup/dropoff
		// Captured 2025-11-21
		ROUTES.put(Difficulty.SWORDFISH, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2994, 2891, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2978, 2866, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2981, 2848, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2978, 2828, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2990, 2808, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3001, 2788, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3012, 2768, 0)),
			new RouteWaypoint(WaypointType.RUM_PICKUP, RUM_PICKUP_LOCATION),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3057, 2792, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3065, 2811, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3077, 2825, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3078, 2863, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3082, 2875, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3084, 2896, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3053, 2920, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3050, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3048, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3046, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3044, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3042, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3040, 2922, 0)),
			new RouteWaypoint(WaypointType.RUM_DROPOFF, RUM_DROPOFF_LOCATION)
		));

		// SHARK difficulty - 2 laps
		// Captured 2025-11-22
		ROUTES.put(Difficulty.SHARK, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2994, 2891, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2978, 2866, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2981, 2848, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2978, 2828, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(2990, 2808, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3001, 2788, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3012, 2768, 0)),
			new RouteWaypoint(WaypointType.RUM_PICKUP, RUM_PICKUP_LOCATION),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3057, 2792, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3065, 2811, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3077, 2825, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3078, 2863, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3082, 2875, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3080, 2883, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3078, 2885, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3078, 2878, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3077, 2881, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3076, 2887, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3073, 2892, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3074, 2889, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3069, 2894, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3059, 2904, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3053, 2920, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3050, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3048, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3046, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3044, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3042, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3040, 2922, 0)),
			new RouteWaypoint(WaypointType.RUM_DROPOFF, RUM_DROPOFF_LOCATION),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3018, 2889, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3001, 2866, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3004, 2834, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3006, 2819, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3028, 2789, 0)),
			new RouteWaypoint(2, WaypointType.RUM_PICKUP, RUM_PICKUP_LOCATION),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3077, 2776, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3082, 2801, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3093, 2835, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3093, 2882, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3084, 2896, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3079, 2906, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3050, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3048, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3046, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3044, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3042, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3040, 2922, 0)),
			new RouteWaypoint(2, WaypointType.RUM_DROPOFF, RUM_DROPOFF_LOCATION)
		));

		// MARLIN difficulty - 3 laps
		// Captured 2025-11-22
		ROUTES.put(Difficulty.MARLIN, List.of(
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3018, 2889, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3001, 2866, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3004, 2834, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3006, 2819, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3030, 2815, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3028, 2789, 0)),
			new RouteWaypoint(WaypointType.RUM_PICKUP, RUM_PICKUP_LOCATION),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3077, 2776, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3082, 2801, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3093, 2835, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3078, 2863, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3082, 2875, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3080, 2883, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3078, 2885, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3078, 2878, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3077, 2881, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3076, 2887, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3073, 2892, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3074, 2889, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3069, 2894, 0)),
			new RouteWaypoint(WaypointType.SHIPMENT, new WorldPoint(3059, 2904, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3050, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3048, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3046, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3044, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3042, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3040, 2922, 0)),
			new RouteWaypoint(WaypointType.RUM_DROPOFF, RUM_DROPOFF_LOCATION),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2994, 2891, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2978, 2866, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2981, 2848, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2978, 2828, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(2990, 2808, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3001, 2788, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3012, 2768, 0)),
			new RouteWaypoint(2, WaypointType.RUM_PICKUP, RUM_PICKUP_LOCATION),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3037, 2762, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3057, 2792, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3065, 2811, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3077, 2825, 0)),
			new RouteWaypoint(2, WaypointType.SHIPMENT, new WorldPoint(3060, 2883, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3050, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3048, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3046, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3044, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3042, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3040, 2922, 0)),
			new RouteWaypoint(2, WaypointType.RUM_DROPOFF, RUM_DROPOFF_LOCATION),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2963, 2882, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2965, 2865, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2957, 2829, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2953, 2809, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2966, 2795, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(2987, 2777, 0)),
			new RouteWaypoint(3, WaypointType.RUM_PICKUP, RUM_PICKUP_LOCATION),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(3095, 2775, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(3119, 2855, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(3093, 2882, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(3084, 2896, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(3079, 2906, 0)),
			new RouteWaypoint(3, WaypointType.SHIPMENT, new WorldPoint(3053, 2920, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3050, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3048, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3046, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3044, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3042, 2922, 0)),
			new RouteWaypoint(WaypointType.PATHFINDING_HINT, new WorldPoint(3040, 2922, 0)),
			new RouteWaypoint(3, WaypointType.RUM_DROPOFF, RUM_DROPOFF_LOCATION)
		));
	}

	/**
	 * Get the static route for a given difficulty.
	 * @param difficulty The difficulty level
	 * @return List of RouteWaypoints representing the optimal waypoint sequence,
	 *         or empty list if no route is defined for this difficulty
	 */
	public static List<RouteWaypoint> getRoute(Difficulty difficulty)
	{
		return ROUTES.getOrDefault(difficulty, new ArrayList<>());
	}
}

package com.barracudatrial.game.route;

import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.ObjectID;

import java.util.List;
import java.util.Set;

public class TemporTantrumConfig implements TrialConfig
{
	public static final int BOAT_EXCLUSION_WIDTH = 8;
	public static final int BOAT_EXCLUSION_HEIGHT = 3;

	public static final int RUM_PICKUP_BASE_ID = ObjectID.SAILING_BT_TEMPOR_TANTRUM_SOUTH_LOC_PARENT;
	public static final int RUM_PICKUP_IMPOSTOR_ID = ObjectID.SAILING_BT_TEMPOR_TANTRUM_SOUTH_LOC_CHILD;
	public static final int RUM_DROPOFF_BASE_ID = ObjectID.SAILING_BT_TEMPOR_TANTRUM_NORTH_LOC_PARENT;
	public static final int RUM_DROPOFF_IMPOSTOR_ID = ObjectID.SAILING_BT_TEMPOR_TANTRUM_NORTH_LOC_CHILD;

	private static final Set<Integer> SHIPMENT_IDS = Set.of(
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_1,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_2,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_3,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_4,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_5,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_6,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_7,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_8,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_9,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_10,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_11,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_12,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_13,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_14,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_15,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_16,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_17,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_18,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_19,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_20,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_21,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_22,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_23,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_24,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_25,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_26,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_27,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_28,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_29,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_30,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_31,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_32,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_33,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_34,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_35,
		ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_36
	);
	
	private static final int SHIPMENT_IMPOSTOR_ID = ObjectID.SAILING_BT_TEMPOR_TANTRUM_COLLECTABLE_SUPPLIES;

	public static final Set<Integer> LIGHTNING_CLOUD_NPC_IDS = Set.of(
		NpcID.SAILING_SEA_STORMY_CLOUD,
		NpcID.SAILING_SEA_STORMY_LIGHTNING_STRIKE
	);

	// Exclusion zone offsets relative to rum dropoff location
	public static final int EXCLUSION_MIN_X_OFFSET = -26;
	public static final int EXCLUSION_MAX_X_OFFSET = 22;
	public static final int EXCLUSION_MIN_Y_OFFSET = -106;
	public static final int EXCLUSION_MAX_Y_OFFSET = -53;

	@Override
	public TrialType getTrialType()
	{
		return TrialType.TEMPOR_TANTRUM;
	}

	@Override
	public Set<Integer> getShipmentBaseIds()
	{
		return SHIPMENT_IDS;
	}

	@Override
	public int getShipmentImpostorId()
	{
		return SHIPMENT_IMPOSTOR_ID;
	}

	@Override
	public List<RouteWaypoint> getRoute(Difficulty difficulty)
	{
		return TemporTantrumRoutes.getRoute(difficulty);
	}
}

package com.barracudatrial.game;

import com.barracudatrial.game.route.TemporTantrumConfig;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;

/**
 * Manages objective locations (rum for Tempor, etc.) and exclusion zone calculations
 */
@Slf4j
public class LocationManager
{
	private final Client client;
	private final State state;

	public LocationManager(Client client, State state)
	{
		this.client = client;
		this.state = state;
	}

	/**
	 * Updates rum locations by searching WorldEntity scenes
	 * Should be called every game tick while in trial area
	 */
	public void updateTemporRumLocations()
	{
		if (!state.isInTrial())
		{
			return;
		}

		searchForTemporRumLocationsInWorldEntities();
	}

	private void searchForTemporRumLocationsInWorldEntities()
	{
		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return;
		}

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null || localPlayer.getWorldView() == null)
		{
			return;
		}

		// Scan all WorldEntities to find rum boats (they're on separate boats from player)
		for (WorldEntity worldEntity : topLevelWorldView.worldEntities())
		{
			if (worldEntity == null)
			{
				continue;
			}

			WorldView entityWorldView = worldEntity.getWorldView();
			if (entityWorldView == null)
			{
				continue;
			}

			Scene entityScene = entityWorldView.getScene();
			if (entityScene == null)
			{
				continue;
			}

			// Pass the WorldEntity so we can get its real world location
			scanSceneForTemporRumReturnAndPickupLocations(entityScene, worldEntity);
		}
	}

	private void scanSceneForTemporRumReturnAndPickupLocations(Scene scene, WorldEntity worldEntity)
	{
		var trial = state.getCurrentTrial();
		if (!(trial instanceof TemporTantrumConfig)) {
			return;
		}

		Tile[][][] tileArray = scene.getTiles();
		if (tileArray == null)
		{
			return;
		}

		// Get the boat's real world location once (it's the same for all objects on this boat)
		WorldPoint boatWorldLocation = null;
		try
		{
			var boatLocalLocation = worldEntity.getLocalLocation();
			if (boatLocalLocation != null)
			{
				boatWorldLocation = WorldPoint.fromLocalInstance(client, boatLocalLocation);
			}
		}
		catch (Exception e)
		{
			log.debug("Error getting boat world location: {}", e.getMessage());
		}

		if (boatWorldLocation == null)
		{
			return; // Can't determine boat location, skip this entity
		}

		// Scan all planes in this scene (WorldEntity scenes need all planes scanned)
		for (int planeIndex = 0; planeIndex < tileArray.length; planeIndex++)
		{
			if (tileArray[planeIndex] == null)
			{
				continue;
			}

			for (int xIndex = 0; xIndex < tileArray[planeIndex].length; xIndex++)
			{
				if (tileArray[planeIndex][xIndex] == null)
				{
					continue;
				}

				for (int yIndex = 0; yIndex < tileArray[planeIndex][xIndex].length; yIndex++)
				{
					Tile tile = tileArray[planeIndex][xIndex][yIndex];
					if (tile == null)
					{
						continue;
					}

					for (GameObject gameObject : tile.getGameObjects())
					{
						if (gameObject == null)
						{
							continue;
						}

						int objectId = gameObject.getId();
						boolean isRumReturnObject = false;
						boolean isRumPickupObject = false;

						if (objectId == TemporTantrumConfig.RUM_DROPOFF_BASE_ID)
						{
							isRumReturnObject = true;
						}
						else if (objectId == TemporTantrumConfig.RUM_PICKUP_BASE_ID)
						{
							isRumPickupObject = true;
						}

						// Check impostor IDs if not found in base IDs
						if (!isRumReturnObject && !isRumPickupObject)
						{
							try
							{
								ObjectComposition objectComposition = client.getObjectDefinition(objectId);
								if (objectComposition != null)
								{
									ObjectComposition activeImpostor = objectComposition.getImpostor();
									if (activeImpostor != null)
									{
										int impostorId = activeImpostor.getId();
										if (impostorId == TemporTantrumConfig.RUM_DROPOFF_IMPOSTOR_ID)
										{
											isRumReturnObject = true;
										}
										else if (impostorId == TemporTantrumConfig.RUM_PICKUP_IMPOSTOR_ID)
										{
											isRumPickupObject = true;
										}
									}
								}
							}
							catch (Exception e)
							{
							}
						}

						if (isRumReturnObject)
						{
							// Secondary objective (rum dropoff for Tempor, etc.)
							// Use the boat's real world location, not the gameObject's location
							if (state.getRumReturnLocation() == null || !state.getRumReturnLocation().equals(boatWorldLocation))
							{
								state.setRumReturnLocation(boatWorldLocation);
								log.info("Found secondary objective location: {} (ObjectID: {}, Plane: {}, SceneTile: [{},{}])",
									boatWorldLocation, objectId, planeIndex, xIndex, yIndex);
								calculateTemporExclusionZoneBounds(boatWorldLocation);
							}
						}
						else if (isRumPickupObject)
						{
							// Primary objective (rum pickup for Tempor, etc.)
							// Use the boat's real world location, not the gameObject's location
							if (state.getRumPickupLocation() == null || !state.getRumPickupLocation().equals(boatWorldLocation))
							{
								state.setRumPickupLocation(boatWorldLocation);
								log.info("Found primary objective location: {} (ObjectID: {}, Plane: {}, SceneTile: [{},{}])",
									boatWorldLocation, objectId, planeIndex, xIndex, yIndex);
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Calculates exclusion zone boundaries from secondary objective location
	 * The exclusion zone is the center island area we circle around
	 */
	private void calculateTemporExclusionZoneBounds(WorldPoint secondaryObjectiveLocation)
	{
		var trial = state.getCurrentTrial();
		if (!(trial instanceof TemporTantrumConfig)) {
			return;
		}

		int exclusionZoneMinX = secondaryObjectiveLocation.getX() + TemporTantrumConfig.EXCLUSION_MIN_X_OFFSET;
		int exclusionZoneMaxX = secondaryObjectiveLocation.getX() + TemporTantrumConfig.EXCLUSION_MAX_X_OFFSET;
		int exclusionZoneMinY = secondaryObjectiveLocation.getY() + TemporTantrumConfig.EXCLUSION_MIN_Y_OFFSET;
		int exclusionZoneMaxY = secondaryObjectiveLocation.getY() + TemporTantrumConfig.EXCLUSION_MAX_Y_OFFSET;

		state.setExclusionZoneMinX(exclusionZoneMinX);
		state.setExclusionZoneMaxX(exclusionZoneMaxX);
		state.setExclusionZoneMinY(exclusionZoneMinY);
		state.setExclusionZoneMaxY(exclusionZoneMaxY);

		log.debug("Exclusion zone: ({}, {}) to ({}, {})",
			exclusionZoneMinX, exclusionZoneMinY, exclusionZoneMaxX, exclusionZoneMaxY);
	}
}

package com.barracudatrial.game;

import com.barracudatrial.game.route.GwenithGlideConfig;
import com.barracudatrial.game.route.JubblyJiveConfig;
import com.barracudatrial.game.route.TemporTantrumConfig;
import com.barracudatrial.game.route.TrialConfig;
import com.barracudatrial.game.route.TrialType;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarbitID;

/**
 * Handles progress tracking for Barracuda Trial using varbits
 * Detects trial entry/exit and initializes trial-specific configurations
 */
@Slf4j
public class ProgressTracker
{
	private final Client client;
	private final State state;

	public ProgressTracker(Client client, State state)
	{
		this.client = client;
		this.state = state;
	}

	/**
	 * Gets the currently active trial type based on varbits
	 * @return The active trial type, or null if not in a trial
	 */
	public TrialType getCurrentActiveTrialType()
	{
		if (client.getVarbitValue(VarbitID.SAILING_BT_TEMPOR_TANTRUM_MASTER_STATE) == 2)
		{
			return TrialType.TEMPOR_TANTRUM;
		}
		else if (client.getVarbitValue(VarbitID.SAILING_BT_JUBBLY_JIVE_MASTER_STATE) == 2)
		{
			return TrialType.JUBBLY_JIVE;
		}
		else if (client.getVarbitValue(VarbitID.SAILING_BT_GWENITH_GLIDE_MASTER_STATE) == 2)
		{
			return TrialType.GWENITH_GLIDE;
		}
		return null;
	}

	/**
	 * @return true if trial area state changed
	 */
	public boolean checkIfPlayerIsInTrial()
	{
		boolean wasinTrialBefore = state.isInTrial();

		TrialType activeTrialType = getCurrentActiveTrialType();
		boolean isInTrialNow = activeTrialType != null;

		state.setInTrial(isInTrialNow);

		if (!wasinTrialBefore && isInTrialNow)
		{
			log.info("Entered Barracuda Trial: {}", activeTrialType);
			TrialConfig trialConfig = createTrialConfig(activeTrialType);
			state.setCurrentTrial(trialConfig);
			return true;
		}
		else if (wasinTrialBefore && !isInTrialNow)
		{
			log.debug("Left Barracuda Trial");
			state.resetAllTemporaryState();
			return true;
		}

		return false;
	}

	private TrialConfig createTrialConfig(TrialType trialType)
	{
		switch (trialType)
		{
			case TEMPOR_TANTRUM:
				return new TemporTantrumConfig();
			case JUBBLY_JIVE:
				return new JubblyJiveConfig();
			case GWENITH_GLIDE:
				return new GwenithGlideConfig();
			default:
				log.warn("Unknown trial type: {}, using Tempor Tantrum as fallback", trialType);
				return new TemporTantrumConfig();
		}
	}
}

package com.barracudatrial.game;

import com.barracudatrial.CachedConfig;
import com.barracudatrial.game.route.*;
import com.barracudatrial.pathfinding.AStarPathfinder;
import com.barracudatrial.pathfinding.BarracudaTileCostCalculator;
import com.barracudatrial.pathfinding.PathNode;
import com.barracudatrial.pathfinding.PathResult;
import com.barracudatrial.pathfinding.PathStabilizer;
import com.barracudatrial.rendering.RenderingUtils;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;

import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;

@Slf4j
public class PathPlanner
{
	private final State state;
	private final CachedConfig cachedConfig;
	private final Client client;
	private final ClientThread clientThread;
	private final PathStabilizer pathStabilizer;
	private final ExecutorService pathfindingExecutor;
	private final AtomicBoolean pathfindingInProgress = new AtomicBoolean(false);
	private final AtomicBoolean pendingRecalculation = new AtomicBoolean(false);
	private volatile PathfindingRequest pendingRequest;

	public PathPlanner(Client client, State state, CachedConfig cachedConfig, ClientThread clientThread)
	{
		this.client = client;
		this.state = state;
		this.cachedConfig = cachedConfig;
		this.clientThread = clientThread;

		AStarPathfinder aStarPathfinder = new AStarPathfinder();
		this.pathStabilizer = new PathStabilizer(aStarPathfinder);
		this.pathfindingExecutor = Executors.newSingleThreadExecutor(r -> {
			Thread thread = new Thread(r, "BarracudaTrial-Pathfinding");
			thread.setDaemon(true);
			return thread;
		});
	}

	private static class PathfindingRequest
	{
		final WorldPoint startLocation;
		final List<RouteWaypoint> waypoints;
		final int waypointCount;
		final int startIndex;
		final String reason;

		PathfindingRequest(WorldPoint startLocation, List<RouteWaypoint> waypoints, int waypointCount, int startIndex, String reason)
		{
			this.startLocation = startLocation;
			this.waypoints = waypoints;
			this.waypointCount = waypointCount;
			this.startIndex = startIndex;
			this.reason = reason;
		}
	}

	/**
	 * Recalculates the optimal path based on current game state
	 * Runs pathfinding asynchronously to avoid blocking the game tick
	 * Only one pathfinding task runs at a time, with at most one queued request
	 * @param recalculationTriggerReason Description of what triggered this recalculation (for debugging)
	 */
	public void recalculateOptimalPathFromCurrentState(String recalculationTriggerReason)
	{
		state.setLastPathRecalcCaller(recalculationTriggerReason);
		log.debug("Path recalculation triggered by: {}", recalculationTriggerReason);

		if (!state.isInTrial())
		{
			state.getPath().clear();
			return;
		}

		state.setTicksSinceLastPathRecalc(0);

		WorldPoint playerBoatLocation = state.getFrontBoatTileEstimatedActual();
		if (playerBoatLocation == null)
		{
			playerBoatLocation = state.getBoatLocation();
		}
		if (playerBoatLocation == null)
		{
			return;
		}

		if (state.getCurrentStaticRoute() == null)
		{
			loadStaticRouteForCurrentDifficulty();
		}

		List<RouteWaypoint> nextWaypoints = findNextUncompletedWaypoints(cachedConfig.getPathLookahead());

		if (nextWaypoints.isEmpty())
		{
			state.setPath(new ArrayList<>());
			log.debug("No uncompleted waypoints found in static route");
			return;
		}

		PathfindingRequest request = new PathfindingRequest(
			playerBoatLocation,
			nextWaypoints,
			nextWaypoints.size(),
			state.getNextNavigableWaypointIndex(),
			recalculationTriggerReason
		);

		if (pathfindingInProgress.get())
		{
			pendingRequest = request;
			pendingRecalculation.set(true);
			log.debug("Pathfinding already running, queued latest request: {}", recalculationTriggerReason);
			return;
		}

		executePathfinding(request);
	}

	private void executePathfinding(PathfindingRequest request)
	{
		pathfindingInProgress.set(true);

		pathfindingExecutor.submit(() -> {
			try
			{
				List<WorldPoint> fullPath = pathThroughMultipleWaypoints(request.startLocation, request.waypoints);

				clientThread.invoke(() -> {
					state.setPath(fullPath);
					log.debug("Async path complete: {} waypoints starting at index {} ({})",
						request.waypointCount, request.startIndex, request.reason);
				});
			}
			catch (Exception e)
			{
				log.error("Pathfinding error", e);
			}
			finally
			{
				pathfindingInProgress.set(false);

				if (pendingRecalculation.getAndSet(false))
				{
					PathfindingRequest nextRequest = pendingRequest;
					if (nextRequest != null)
					{
						log.debug("Running queued pathfinding request: {}", nextRequest.reason);
						executePathfinding(nextRequest);
					}
				}
			}
		});
	}

	private void loadStaticRouteForCurrentDifficulty()
	{
		var trial = state.getCurrentTrial();
		if (trial == null)
		{
			log.warn("Trial config not initialized, cannot load route");
			state.setCurrentStaticRoute(new ArrayList<>());
			return;
		}

		Difficulty difficulty = State.getCurrentDifficulty(client);
		List<RouteWaypoint> staticRoute = trial.getRoute(difficulty);

		if (staticRoute == null || staticRoute.isEmpty())
		{
			log.warn("No static route found for trial {} difficulty: {}", trial.getTrialType(), difficulty);
			state.setCurrentStaticRoute(new ArrayList<>());
			return;
		}

		state.setCurrentStaticRoute(staticRoute);
		log.info("Loaded static route for {} difficulty {} with {} waypoints",
			trial.getTrialType(), difficulty, staticRoute.size());
	}

	/**
	 * Finds the next N uncompleted waypoints in the static route sequence.
	 * Routes to waypoints even if not yet visible (game only reveals nearby shipments).
	 * Supports backtracking if a waypoint was missed.
	 *
	 * @param count Maximum number of uncompleted navigable waypoints
	 * @return List of uncompleted waypoints in route order (includes all helper waypoints between real waypoints)
	 */
	private List<RouteWaypoint> findNextUncompletedWaypoints(int count)
	{
		List<RouteWaypoint> uncompletedWaypoints = new ArrayList<>();

		var route = state.getCurrentStaticRoute();
		if (route == null || route.isEmpty())
		{
			return uncompletedWaypoints;
		}

		int routeSize = route.size();
		int nextNavIndex = state.getNextNavigableWaypointIndex();

		// Scan backwards from nextNavigableWaypointIndex to find uncompleted helpers that precede it
		List<RouteWaypoint> precedingHelpers = new ArrayList<>();
		for (int i = 1; i < routeSize; i++)
		{
			int checkIndex = (nextNavIndex - i + routeSize) % routeSize;
			RouteWaypoint waypoint = route.get(checkIndex);

			if (state.isWaypointCompleted(checkIndex))
			{
				break;
			}

			if (waypoint.getType().isNonNavigableHelper())
			{
				precedingHelpers.add(0, waypoint);
			}
			else
			{
				break;
			}
		}

		uncompletedWaypoints.addAll(precedingHelpers);

		int navigableWaypointCount = 0;

		// Scan forward from nextNavigableWaypointIndex
		for (int offset = 0; offset < routeSize && navigableWaypointCount < count; offset++)
		{
			int checkIndex = (nextNavIndex + offset) % routeSize;
			RouteWaypoint waypoint = route.get(checkIndex);

			if (!state.isWaypointCompleted(checkIndex))
			{
				uncompletedWaypoints.add(waypoint);

				if (!waypoint.getType().isNonNavigableHelper())
				{
					navigableWaypointCount++;
				}
			}
		}

		return uncompletedWaypoints;
	}

	private static class BoatHeading
	{
		private final int dx;
		private final int dy;

		BoatHeading(int dx, int dy)
		{
			this.dx = dx;
			this.dy = dy;
		}

		int dx()
		{
			return dx;
		}

		int dy()
		{
			return dy;
		}
	}

	private List<WorldPoint> extendPath(List<WorldPoint> fullPath, List<WorldPoint> segment)
	{
		List<WorldPoint> result = new ArrayList<>(fullPath);

		if (result.isEmpty())
		{
			result.addAll(segment);
		}
		else if (!segment.isEmpty())
		{
			result.addAll(segment.subList(1, segment.size()));
		}

		return result;
	}

	private BoatHeading calculateBoatHeading(List<WorldPoint> fullPath)
	{
		if (fullPath.isEmpty())
		{
			WorldPoint frontBoatTile = state.getFrontBoatTileEstimatedActual();
			WorldPoint backBoatTile = state.getBoatLocation();

			if (frontBoatTile != null && backBoatTile != null)
			{
				return new BoatHeading(
					frontBoatTile.getX() - backBoatTile.getX(),
					frontBoatTile.getY() - backBoatTile.getY()
				);
			}

			return new BoatHeading(0, 0);
		}

		if (fullPath.size() >= 2)
		{
			WorldPoint prev = fullPath.get(fullPath.size() - 2);
			WorldPoint last = fullPath.get(fullPath.size() - 1);
			return new BoatHeading(
				last.getX() - prev.getX(),
				last.getY() - prev.getY()
			);
		}

		return new BoatHeading(0, 0);
	}

	private WorldPoint handlePortalExitTeleport(WorldPoint currentPosition, WorldPoint portalExitLocation)
	{
		int distance = currentPosition.distanceTo(portalExitLocation);

		if (distance > 10)
		{
			return portalExitLocation;
		}

		return currentPosition;
	}

	private static class WaypointHandlingResult
	{
		final List<WorldPoint> pathSegment;
		final WorldPoint newPosition;
		final boolean shouldStopPathing;
		final int skipToIndex;

		WaypointHandlingResult(List<WorldPoint> pathSegment, WorldPoint newPosition, boolean shouldStopPathing, int skipToIndex)
		{
			this.pathSegment = pathSegment;
			this.newPosition = newPosition;
			this.shouldStopPathing = shouldStopPathing;
			this.skipToIndex = skipToIndex;
		}
	}

	private WaypointHandlingResult handleSingleWaypoint(
		WorldPoint currentPosition,
		RouteWaypoint waypoint,
		boolean isPlayerCurrentlyOnPath,
		int initialBoatDx,
		int initialBoatDy,
		Set<WorldPoint> pathfindingHints,
		boolean stopAfterPathing)
	{
		WorldPoint pathfindingTarget = getInSceneTarget(currentPosition, waypoint);
		PathResult segmentResult = pathToSingleTarget(
			currentPosition,
			pathfindingTarget,
			waypoint.getType().getToleranceTiles(),
			isPlayerCurrentlyOnPath,
			initialBoatDx,
			initialBoatDy,
			pathfindingHints
		);

		List<WorldPoint> segmentPath = segmentResult.getPath();
		WorldPoint newPosition = segmentPath.isEmpty() ? currentPosition : segmentPath.get(segmentPath.size() - 1);
		boolean shouldStop = stopAfterPathing || !segmentResult.isReachedGoal();

		return new WaypointHandlingResult(segmentPath, newPosition, shouldStop, -1);
	}

	/**
	 * Wind catchers provide speed boosts but force specific routes. Sometimes going direct is faster/safer.
	 * This method tries BOTH options and picks the winner based on: goal reached > path cost.
	 */
	private WaypointHandlingResult handleWindCatcherSequence(
		WorldPoint currentPosition,
		List<RouteWaypoint> waypoints,
		int currentIndex,
		boolean isPlayerCurrentlyOnPath,
		int initialBoatDx,
		int initialBoatDy,
		Set<WorldPoint> pathfindingHints)
	{
		List<RouteWaypoint> windCatcherSequence = collectConsecutiveWindCatchers(waypoints, currentIndex);

		int indexAfterWindCatchers = currentIndex + windCatcherSequence.size();
		RouteWaypoint destinationAfterWindCatchers = findDestinationAfterWindCatchers(waypoints, indexAfterWindCatchers);
		Set<WorldPoint> hintsAfterWindCatchers = collectPathfindingHints(waypoints, indexAfterWindCatchers);

		int nextWaypointIndex = indexAfterWindCatchers + hintsAfterWindCatchers.size();
		if (destinationAfterWindCatchers != null)
		{
			nextWaypointIndex++;
		}

		WindCatcherPathResult pathUsingWindCatchers = pathThroughWindCatcherSequence(
			currentPosition,
			windCatcherSequence,
			destinationAfterWindCatchers,
			isPlayerCurrentlyOnPath,
			initialBoatDx,
			initialBoatDy,
			pathfindingHints,
			hintsAfterWindCatchers
		);

		PathResult pathSkippingWindCatchers = null;
		if (destinationAfterWindCatchers != null)
		{
			WorldPoint directTarget = getInSceneTarget(currentPosition, destinationAfterWindCatchers);
			pathSkippingWindCatchers = pathToSingleTarget(
				currentPosition,
				directTarget,
				destinationAfterWindCatchers.getType().getToleranceTiles(),
				isPlayerCurrentlyOnPath,
				initialBoatDx,
				initialBoatDy,
				hintsAfterWindCatchers
			);
		}

		List<WorldPoint> winningPath = chooseBetterPath(pathUsingWindCatchers, pathSkippingWindCatchers);
		WorldPoint finalPosition = winningPath.isEmpty() ? currentPosition : winningPath.get(winningPath.size() - 1);

		return new WaypointHandlingResult(winningPath, finalPosition, false, nextWaypointIndex);
	}

	private List<RouteWaypoint> collectConsecutiveWindCatchers(List<RouteWaypoint> waypoints, int startIndex)
	{
		List<RouteWaypoint> windCatchers = new ArrayList<>();
		windCatchers.add(waypoints.get(startIndex));

		for (int i = startIndex + 1; i < waypoints.size(); i++)
		{
			if (waypoints.get(i).getType() == RouteWaypoint.WaypointType.USE_WIND_CATCHER)
			{
				windCatchers.add(waypoints.get(i));
			}
			else
			{
				break;
			}
		}

		return windCatchers;
	}

	private RouteWaypoint findDestinationAfterWindCatchers(List<RouteWaypoint> waypoints, int startIndex)
	{
		for (int i = startIndex; i < waypoints.size(); i++)
		{
			var type = waypoints.get(i).getType();
			if (type != RouteWaypoint.WaypointType.PATHFINDING_HINT)
			{
				return waypoints.get(i);
			}
		}
		return null;
	}

	private Set<WorldPoint> collectPathfindingHints(List<RouteWaypoint> waypoints, int startIndex)
	{
		Set<WorldPoint> hints = new HashSet<>();

		for (int i = startIndex; i < waypoints.size(); i++)
		{
			if (waypoints.get(i).getType() == RouteWaypoint.WaypointType.PATHFINDING_HINT)
			{
				hints.add(waypoints.get(i).getLocation());
			}
			else
			{
				break;
			}
		}

		return hints;
	}

	private List<WorldPoint> chooseBetterPath(WindCatcherPathResult windCatcherPath, PathResult directPath)
	{
		boolean windCatcherReachedGoal = windCatcherPath.reachedGoal;
		boolean directReachedGoal = directPath != null && directPath.isReachedGoal();

		if (windCatcherReachedGoal && !directReachedGoal)
		{
			return windCatcherPath.path;
		}

		if (directReachedGoal && !windCatcherReachedGoal)
		{
			return directPath.getPath();
		}

		if (windCatcherReachedGoal && directReachedGoal)
		{
			return windCatcherPath.cost <= directPath.getCost() ? windCatcherPath.path : directPath.getPath();
		}

		return (directPath != null && directPath.getCost() < windCatcherPath.cost)
			? directPath.getPath()
			: windCatcherPath.path;
	}

	/**
	 * Paths through multiple waypoints in sequence using A*
	 * @param start Starting position
	 * @param waypoints List of waypoints to path through in order
	 * @return Complete path through all waypoints
	 */
	private List<WorldPoint> pathThroughMultipleWaypoints(WorldPoint start, List<RouteWaypoint> waypoints)
	{
		if (waypoints.isEmpty())
		{
			return new ArrayList<>();
		}

		List<WorldPoint> fullPath = new ArrayList<>();
		WorldPoint currentPosition = start;
		boolean isPlayerCurrentlyOnPath = true;
		Set<WorldPoint> pathfindingHints = new HashSet<>();

		for (int i = 0; i < waypoints.size(); i++)
		{
			RouteWaypoint waypoint = waypoints.get(i);
			var waypointType = waypoint.getType();

			if (waypointType == RouteWaypoint.WaypointType.PATHFINDING_HINT)
			{
				pathfindingHints.add(waypoint.getLocation());
				continue;
			}

			if (waypointType == RouteWaypoint.WaypointType.PORTAL_EXIT)
			{
				currentPosition = handlePortalExitTeleport(currentPosition, waypoint.getLocation());
				continue;
			}

			BoatHeading heading = calculateBoatHeading(fullPath);
			int initialBoatDx = heading.dx();
			int initialBoatDy = heading.dy();

			if (waypointType == RouteWaypoint.WaypointType.PORTAL_ENTER)
			{
				WaypointHandlingResult result = handleSingleWaypoint(
					currentPosition,
					waypoint,
					isPlayerCurrentlyOnPath,
					initialBoatDx,
					initialBoatDy,
					pathfindingHints,
					true
				);

				pathfindingHints.clear();
				fullPath = extendPath(fullPath, result.pathSegment);
				break;
			}

			if (waypointType == RouteWaypoint.WaypointType.USE_WIND_CATCHER)
			{
				WaypointHandlingResult result = handleWindCatcherSequence(
					currentPosition,
					waypoints,
					i,
					isPlayerCurrentlyOnPath,
					initialBoatDx,
					initialBoatDy,
					pathfindingHints
				);

				pathfindingHints.clear();

				fullPath = extendPath(fullPath, result.pathSegment);
				currentPosition = result.newPosition;
				isPlayerCurrentlyOnPath = false;

				i = result.skipToIndex;
				continue;
			}

			WaypointHandlingResult result = handleSingleWaypoint(
				currentPosition,
				waypoint,
				isPlayerCurrentlyOnPath,
				initialBoatDx,
				initialBoatDy,
				pathfindingHints,
				false
			);

			pathfindingHints.clear();
			fullPath = extendPath(fullPath, result.pathSegment);

			if (result.shouldStopPathing)
			{
				break;
			}

			currentPosition = result.newPosition;
			isPlayerCurrentlyOnPath = false;
		}

		return fullPath;
	}

	private static class WindCatcherPathResult
	{
		final List<WorldPoint> path;
		final double cost;
		final boolean reachedGoal;

		WindCatcherPathResult(List<WorldPoint> path, double cost, boolean reachedGoal)
		{
			this.path = path;
			this.cost = cost;
			this.reachedGoal = reachedGoal;
		}
	}

	/**
	 * Handles pathing through a sequence of wind catcher waypoints as one segment:
	 * 1. Pathfind TO the first wind catcher
	 * 2. Add straight lines between all consecutive wind catchers
	 * 3. Pathfind FROM the last wind catcher TO the next normal waypoint (if any)
	 */
	private WindCatcherPathResult pathThroughWindCatcherSequence(
		WorldPoint start,
		List<RouteWaypoint> windCatcherSequence,
		RouteWaypoint nextNormalWaypoint,
		boolean isPlayerCurrentlyOnPath,
		int initialBoatDx,
		int initialBoatDy,
		Set<WorldPoint> pathfindingHints,
		Set<WorldPoint> postWindCatcherHints)
	{
		List<WorldPoint> segmentPath = new ArrayList<>();
		double totalCost = 0;
		boolean reachedGoal = false;

		if (windCatcherSequence.isEmpty())
		{
			return new WindCatcherPathResult(segmentPath, Double.POSITIVE_INFINITY, false);
		}

		// Step 1: Pathfind TO the first wind catcher
		RouteWaypoint firstWindCatcher = windCatcherSequence.get(0);
		WorldPoint firstWindCatcherTarget = getInSceneTarget(start, firstWindCatcher);

		PathResult pathToFirst = pathToSingleTarget(
			start,
			firstWindCatcherTarget,
			1,
			isPlayerCurrentlyOnPath,
			initialBoatDx,
			initialBoatDy,
			pathfindingHints
		);

		segmentPath.addAll(pathToFirst.getPath());
		totalCost += pathToFirst.getCost();

		if (!pathToFirst.isReachedGoal())
		{
			return new WindCatcherPathResult(segmentPath, totalCost, false);
		}

		// Ensure we end exactly at the first wind catcher location
		WorldPoint firstWindCatcherLocation = firstWindCatcher.getLocation();
		WorldPoint lastPoint = segmentPath.isEmpty() ? null : segmentPath.get(segmentPath.size() - 1);
		if (!firstWindCatcherLocation.equals(lastPoint))
		{
			segmentPath.add(firstWindCatcherLocation);
		}

		// Step 2: Add straight lines between all wind catchers
		for (int i = 1; i < windCatcherSequence.size(); i++)
		{
			segmentPath.add(windCatcherSequence.get(i).getLocation());
		}

		// Step 3: Pathfind FROM last wind catcher TO next normal waypoint (if exists)
		if (nextNormalWaypoint != null)
		{
			WorldPoint lastWindCatcherLocation = windCatcherSequence.get(windCatcherSequence.size() - 1).getLocation();
			WorldPoint nextTarget = getInSceneTarget(lastWindCatcherLocation, nextNormalWaypoint);

			// Derive heading from the last wind catcher transition
			int nextBoatDx = 0;
			int nextBoatDy = 0;
			if (segmentPath.size() >= 2)
			{
				WorldPoint prev = segmentPath.get(segmentPath.size() - 2);
				WorldPoint last = segmentPath.get(segmentPath.size() - 1);
				nextBoatDx = last.getX() - prev.getX();
				nextBoatDy = last.getY() - prev.getY();
			}

			PathResult pathFromLast = pathToSingleTarget(
				lastWindCatcherLocation,
				nextTarget,
				nextNormalWaypoint.getType().getToleranceTiles(),
				false,
				nextBoatDx,
				nextBoatDy,
				postWindCatcherHints
			);

			totalCost += pathFromLast.getCost();
			reachedGoal = pathFromLast.isReachedGoal();

			if (!pathFromLast.getPath().isEmpty())
			{
				segmentPath.addAll(pathFromLast.getPath().subList(1, pathFromLast.getPath().size()));
			}
		}
		else
		{
			// No next waypoint, we've reached the end of the wind catcher sequence
			reachedGoal = true;
		}

		return new WindCatcherPathResult(segmentPath, totalCost, reachedGoal);
	}

	/**
	 * Paths from current position to a single target using A*
	 * @param start Starting position
	 * @param target Target position
	 * @param goalTolerance Number of tiles away from target that counts as reaching it (0 = exact)
	 * @param isPlayerCurrentlyOnPath Whether this is the path that the player is currently navigating
	 * @param pathfindingHints Set of tiles that should have reduced cost during pathfinding
	 * @return PathResult containing path from start to target and whether goal was reached
	 */
	private PathResult pathToSingleTarget(WorldPoint start, WorldPoint target, int goalTolerance, boolean isPlayerCurrentlyOnPath, int initialBoatDx, int initialBoatDy, Set<WorldPoint> pathfindingHints)
	{
		var tileCostCalculator = getBarracudaTileCostCalculator(pathfindingHints);

        int tileDistance = start.distanceTo(target); // Chebyshev distance in tiles

		// Never too high, but allow seeking longer on long paths
		int maximumAStarSearchDistance = Math.max(35, Math.min(80, tileDistance * 8));

		PathResult pathResult = pathStabilizer.findPath(tileCostCalculator, cachedConfig.getRouteOptimization(), start, target, maximumAStarSearchDistance, initialBoatDx, initialBoatDy, goalTolerance, isPlayerCurrentlyOnPath);

		if (pathResult.getPath().isEmpty())
		{
			List<PathNode> fallbackPath = new ArrayList<>();
			fallbackPath.add(new PathNode(start, 0));
			fallbackPath.add(new PathNode(target, Double.POSITIVE_INFINITY));
			return new PathResult(fallbackPath, Double.POSITIVE_INFINITY, false);
		}

		return pathResult;
	}

	private BarracudaTileCostCalculator getBarracudaTileCostCalculator(Set<WorldPoint> pathfindingHints)
	{
		Set<NPC> currentlyDangerousClouds = state.getDangerousClouds();

		var trial = state.getCurrentTrial();
		var boatExclusionWidth = trial != null && trial.getTrialType() == TrialType.TEMPOR_TANTRUM
			? TemporTantrumConfig.BOAT_EXCLUSION_WIDTH
			: JubblyJiveConfig.BOAT_EXCLUSION_WIDTH;
		var boatExclusionHeight = trial != null && trial.getTrialType() == TrialType.TEMPOR_TANTRUM
			? TemporTantrumConfig.BOAT_EXCLUSION_HEIGHT
			: JubblyJiveConfig.BOAT_EXCLUSION_HEIGHT;

		WorldPoint secondaryObjectiveLocation = null;

		if (trial != null)
		{
			var trialType = trial.getTrialType();

			if (trialType == TrialType.TEMPOR_TANTRUM)
			{
				secondaryObjectiveLocation = state.getRumReturnLocation();
			}
			else if (trialType == TrialType.JUBBLY_JIVE)
			{
				var route = state.getCurrentStaticRoute();
				if (route != null && !route.isEmpty())
				{
					var completed = state.getCompletedWaypointIndices();
					for (int i = 0; i < route.size(); i++)
					{
						if (completed.contains(i))
							continue;

						var waypoint = route.get(i);
						if (waypoint.getType() == RouteWaypoint.WaypointType.TOAD_PILLAR)
						{
							secondaryObjectiveLocation = waypoint.getLocation();
							break;
						}
					}
				}
			}
		}

		return new BarracudaTileCostCalculator(
			state.getKnownSpeedBoostLocations(),
			state.getKnownRockLocations(),
			state.getKnownFetidPoolLocations(),
			state.getKnownToadPillarLocations(),
			currentlyDangerousClouds,
			state.getExclusionZoneMinX(),
			state.getExclusionZoneMaxX(),
			state.getExclusionZoneMinY(),
			state.getExclusionZoneMaxY(),
			state.getRumPickupLocation(),
			secondaryObjectiveLocation,
			cachedConfig.getRouteOptimization(),
			boatExclusionWidth,
			boatExclusionHeight,
			pathfindingHints
		);
	}

	private WorldPoint getInSceneTarget(WorldPoint start, RouteWaypoint target)
	{
		WorldView worldView = client.getTopLevelWorldView();
		if (worldView == null)
		{
			return target.getLocation();
		}

		int worldPlane = worldView.getPlane();
		WorldPoint targetLocation = target.getLocation();

		List<WorldPoint> candidates = new ArrayList<>();
		candidates.add(targetLocation);

		var fallbackLocations = target.getFallbackLocations();
		if (fallbackLocations != null)
		{
			for (WorldPoint fallback : fallbackLocations)
			{
				if (!fallback.equals(targetLocation))
				{
					candidates.add(fallback);
				}
			}
		}

		// 1. Prefer same-plane tiles in the normal scene
		for (WorldPoint p : candidates)
		{
			if (p.getPlane() != worldPlane)
			{
				continue;
			}

			if (LocalPoint.fromWorld(worldView, p) != null)
			{
				return p;
			}
		}

		// 2. Any tile that exists in the extended scene
		for (WorldPoint p : candidates)
		{
			if (RenderingUtils.localPointFromWorldIncludingExtended(worldView, p) != null)
			{
				return p;
			}
		}

		// 3. Fall back to nearest valid along the line toward the target
		return findNearestValidPoint(
			start,
			targetLocation,
			p -> RenderingUtils.localPointFromWorldIncludingExtended(worldView, p) != null
		);
	}

	/**
	 * Finds the furthest point from start toward target that satisfies the given validation function.
	 * Uses binary search for O(log n) efficiency.
	 * @param start Starting position
	 * @param target Desired target position
	 * @param isValid Function that returns true if a candidate point is valid
	 * @return The furthest valid point toward target, or start if none found
	 */
	private static WorldPoint findNearestValidPoint(WorldPoint start, WorldPoint target, Predicate<WorldPoint> isValid)
	{
		int dx = target.getX() - start.getX();
		int dy = target.getY() - start.getY();
		int maxDistance = Math.max(Math.abs(dx), Math.abs(dy));

		if (maxDistance < 1)
		{
			return start;
		}

		int plane = start.getPlane();
		int low = 0;
		int high = maxDistance;
		WorldPoint bestCandidate = start;

		while (low <= high)
		{
			int mid = (low + high) / 2;
			int x = start.getX() + (dx * mid / maxDistance);
			int y = start.getY() + (dy * mid / maxDistance);
			WorldPoint candidate = new WorldPoint(x, y, plane);

			if (isValid.test(candidate))
			{
				bestCandidate = candidate;
				low = mid + 1;
			}
			else
			{
				high = mid - 1;
			}
		}

		return bestCandidate;
	}

	public void reset()
	{
		pathStabilizer.clearActivePath();
		pendingRecalculation.set(false);
		pendingRequest = null;
	}

	public void shutdown()
	{
		pendingRecalculation.set(false);
		pendingRequest = null;
		pathfindingExecutor.shutdownNow();
	}
}

package com.barracudatrial.game;

import com.barracudatrial.game.route.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.gameval.NpcID;
import net.runelite.api.gameval.ObjectID;

import java.util.*;

/**
 * Handles tracking of game objects in the Barracuda Trial minigame
 * Tracks clouds, rocks, speed boosts, lost supplies, boat location, toad pillars, etc
 */
@Slf4j
@RequiredArgsConstructor
public class ObjectTracker
{
	private final Client client;
	private final State state;

	private static final Set<Integer> ROCK_IDS = Set.of(
		ObjectID.SAILING_CHARTING_GENERIC_DESERT_TROUT,
		ObjectID.SAILING_CHARTING_GENERIC_LIGHTNING_ROD,
		ObjectID.SAILING_BARRACUDA_SHIPWRECK,
		ObjectID.OCEAN_OUTCROP_ROCK02,
		ObjectID.OCEAN_OUTCROP_ROCK03,
		ObjectID.OCEAN_OUTCROP_ROCK05,
		ObjectID.OCEAN_OUTCROP_ROCK06,
		ObjectID.OCEAN_OUTCROP_ROCK07,
		ObjectID.OCEAN_OUTCROP_ROCK08,
		ObjectID.OCEAN_OUTCROP_ROCK09,
		ObjectID.BOATS_CRYSTAL01_HULL01,
		ObjectID.BOATS_CRYSTAL01_HULL01_BROKEN01,
		ObjectID.BOATS_CRYSTAL01_HULL01_BROKEN01_M,
		ObjectID.BOATS_CRYSTAL01_HULL01_BROKEN02,
		ObjectID.BOATS_CRYSTAL01_HULL01_BROKEN02_M,
		ObjectID.BOATS_CRYSTAL01_HULL02,
		ObjectID.BOATS_CRYSTAL01_HULL02_MIRROR,
		ObjectID.BOATS_CRYSTAL01_SUPPORT01,
		ObjectID.BOATS_CRYSTAL01_SUPPORT01_M,
		ObjectID.BOATS_CRYSTAL01_SUPPORT02,
		ObjectID.BOATS_CRYSTAL01_SUPPORT02_M,
		ObjectID.BOATS_CRYSTAL01_MAST01_BROKEN01,
		ObjectID.BOATS_CRYSTAL01_MAST01_BROKEN02,
		ObjectID.BOATS_CRYSTAL01_MAST01_BROKEN03,
		ObjectID.BOATS_CRYSTAL01_WRECK01,
		ObjectID.BOATS_CRYSTAL01_WRECK02,
		ObjectID.BOATS_CRYSTAL01_WRECK03,
		ObjectID.BOATS_CRYSTAL01_WRECK04,
		ObjectID.BOATS_CRYSTAL01_WRECK05,
		ObjectID.BOATS_CRYSTAL01_BARREL01,
		ObjectID.BOATS_CRYSTAL01_CRATE01,
		ObjectID.BOATS_CRYSTAL01_LARGE01,
		ObjectID.BOATS_CRYSTAL01_OUTCROP01,
		ObjectID.BOATS_CRYSTAL01_OUTCROP02,
		ObjectID.BOATS_CRYSTAL01_OUTCROP03,
		ObjectID.BOATS_CRYSTAL01_OUTCROP04,
		ObjectID.BOATS_CRYSTAL01_OUTCROP05,
		ObjectID.ROCK_CRYSTAL02_FLECKED01,
		ObjectID.ROCK_CRYSTAL01_FLECKED01,
		ObjectID.ROCK_CRYSTAL01_FLECKED02,
		ObjectID.ROCK_CRYSTAL01_FLECKED03,
		ObjectID.ROCK_CRYSTAL01_FLECKED04,
		ObjectID.ROCK_CRYSTAL01_FLECKED05
	);

	private static final Set<Integer> SPEED_BOOST_IDS = Set.of(
		ObjectID.SAILING_RAPIDS, ObjectID.SAILING_RAPIDS_STRONG,
		ObjectID.SAILING_RAPIDS_POWERFUL, ObjectID.SAILING_RAPIDS_DEADLY
	);

	private static final Set<Integer> BOAT_NPC_IDS = Set.of(
			NpcID.BOAT_HP_NPC_TINY,
			NpcID.BOAT_HP_NPC_SMALL,
			NpcID.BOAT_HP_NPC_MEDIUM,
			NpcID.BOAT_HP_NPC_LARGE,
			NpcID.BOAT_HP_NPC_COLOSSAL
	);

	/**
	 * Updates hazard NPC tracking (e.g., lightning clouds for Tempor Tantrum)
	 */
	public void updateLightningCloudTracking()
	{
		if (!state.isInTrial())
		{
			state.clearLightningClouds();
			state.clearDangerousClouds();
			return;
		}

		state.clearLightningClouds();
		state.clearDangerousClouds();

		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return;
		}

		for (NPC npc : topLevelWorldView.npcs())
		{
			if (npc == null)
			{
				continue;
			}

			int npcId = npc.getId();
			if (TemporTantrumConfig.LIGHTNING_CLOUD_NPC_IDS.contains(npcId))
			{
				state.addLightningCloud(npc);

				if (!isCloudSafe(npc.getAnimation()))
				{
					state.addDangerousCloud(npc);
				}
			}
		}
	}

	public static boolean isCloudSafe(int animationId)
	{
		return animationId == State.CLOUD_ANIM_HARMLESS || animationId == State.CLOUD_ANIM_HARMLESS_ALT;
	}

	public void updateHazardsSpeedBoostsAndToadPillars()
	{
		if (!state.isInTrial())
		{
			return;
		}

		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return;
		}

		Scene scene = topLevelWorldView.getScene();
		if (scene == null)
		{
			return;
		}

		Tile[][][] regularTiles = scene.getTiles();
		if (regularTiles != null)
		{
			scanTileArrayForHazardsSpeedBoostsAndToadPillars(regularTiles);
		}

		// Skipping for performance - probably don't need to read extended for this
		// Tile[][][] extendedTiles = scene.getExtendedTiles();
		// if (extendedTiles != null)
		// {
		// 	scanTileArrayForHazardsSpeedBoostsAndToadPillars(extendedTiles);
		// }
	}

	private void scanTileArrayForHazardsSpeedBoostsAndToadPillars(Tile[][][] tileArray)
	{
		var trial = state.getCurrentTrial();
		if (trial == null)
		{
			return;
		}
		var fetidPoolIds = JubblyJiveConfig.FETID_POOL_IDS;

		var knownRockTiles = new HashSet<>(state.getKnownRockLocations());

		var knownBoosts = new HashSet<>(state.getSpeedBoosts());
		var knownBoostTiles = new HashMap<>(state.getKnownSpeedBoostLocations());

		var knownFetidPoolTiles = new HashSet<>(state.getKnownFetidPoolLocations());

		var knownToadPillarTiles = new HashSet<>(state.getKnownToadPillarLocations());

		for (var plane : tileArray)
		{
			if (plane == null) continue;

			for (var column : plane)
			{
				if (column == null) continue;

				for (var tile : column)
				{
					if (tile == null) continue;

					WorldPoint tileWp = tile.getWorldLocation();
					for (var obj : tile.getGameObjects())
					{
						if (obj == null) continue;

						int id = obj.getId();
						var objTile = obj.getWorldLocation();
						if (!objTile.equals(tileWp))
						{
							// Don't want to re-process multi-tile objects
							continue;
						}

						if (!knownRockTiles.contains(tileWp) && ROCK_IDS.contains(id))
						{
							knownRockTiles.addAll(ObjectTracker.getObjectTiles(client, obj));

							continue;
						}

						if (!knownBoostTiles.containsKey(tileWp) && SPEED_BOOST_IDS.contains(id))
						{
							knownBoosts.add(obj);

							// getObjectTiles is 5x5, but we want 3x3 to encourage getting closer
							var speedTilesWithOneTolerance = ObjectTracker.getTilesWithTolerance(objTile, 1);
							knownBoostTiles.put(objTile, speedTilesWithOneTolerance);
							continue;
						}

						if (!knownFetidPoolTiles.contains(tileWp) && fetidPoolIds.contains(id))
						{
							knownFetidPoolTiles.addAll(ObjectTracker.getObjectTiles(client, obj));

							continue;
						}

						var matchingToadPillarByParentId =
								Arrays.stream(JubblyJiveConfig.TOAD_PILLARS)
										.filter(v -> v.getClickboxParentObjectId() == id)
										.findFirst()
										.orElse(null);

						if (matchingToadPillarByParentId != null)
						{
							if (!knownToadPillarTiles.contains(tileWp))
							{
								knownToadPillarTiles.addAll(ObjectTracker.getObjectTiles(client, obj));
							}

							onToadPillarTick(obj, matchingToadPillarByParentId);
							continue;
						}
					}
				}
			}
		}

		state.updateKnownRockLocations(knownRockTiles);
		state.updateSpeedBoosts(knownBoosts);
		state.updateKnownSpeedBoostLocations(knownBoostTiles);
		state.updateKnownFetidPoolLocations(knownFetidPoolTiles);
		state.updateKnownToadPillarLocations(knownToadPillarTiles);
	}

	public void onToadPillarTick(GameObject newToadPillarObj, JubblyJiveToadPillar toadPillar)
	{
		var objectComposition = client.getObjectDefinition(newToadPillarObj.getId());
		if (objectComposition == null)
			return;

		var isInteractedWith = false;

		var impostorIds = objectComposition.getImpostorIds();
		if (impostorIds != null)
		{
			var impostor = objectComposition.getImpostor();
			isInteractedWith = impostor.getId() == toadPillar.getClickboxNoopObjectId();
		}

		var previousIsInteractedWith = state.updateKnownToadPillar(newToadPillarObj.getWorldLocation(), isInteractedWith);

		if (previousIsInteractedWith == null) return; // first time
		if (previousIsInteractedWith == isInteractedWith) return; // no change
		if (previousIsInteractedWith && !isInteractedWith) return; // true -> false (reset)

		var route = state.getCurrentStaticRoute();
		if (route == null || route.isEmpty())
		{
			return;
		}

		var objectId = newToadPillarObj.getId();
		log.info("Detected change in pillar. Trying to find id {} in list of waypoints", objectId);

		for (int index = 0; index < route.size(); index++)
		{
			var waypoint = route.get(index);

			if (!(waypoint instanceof JubblyJiveToadPillarWaypoint))
			{
				continue;
			}

			var pillarWaypoint = (JubblyJiveToadPillarWaypoint) waypoint;

			if (!pillarWaypoint.getPillar().matchesAnyObjectId(objectId))
			{
				continue;
			}

			if (state.isWaypointCompleted(index))
			{
				log.info("Found match but it was already completed, seeing if there's more...");
				continue;
			}

			log.info("Found match! Completing it in our waypoint list.");
			state.markWaypointCompleted(index);

			var waypointLap = waypoint.getLap();
			if (state.getCurrentLap() < waypointLap)
			{
				log.info("Advanced to lap {}", waypointLap);
				state.setCurrentLap(waypointLap);
			}

			return;
		}

		log.warn("Couldn't find a match to update! That seems wrong - how did we update the impostor without it being in the list?");
	}

	/**
	 * Checks shipment waypoints for collection and marks them completed.
	 * Detection: base shipment object exists but impostor ID is missing = collected.
	 * Only checks waypoints within 7 tiles (impostor ID visible range).
	 *
	 * @return true if any shipments were collected this tick
	 */
	public boolean updateRouteWaypointShipmentTracking()
	{
		var route = state.getCurrentStaticRoute();
		if (!state.isInTrial() || route == null)
		{
			return false;
		}

		WorldView worldView = client.getTopLevelWorldView();
		if (worldView == null)
		{
			return false;
		}

		Scene scene = worldView.getScene();
		WorldPoint boatLocation = state.getBoatLocation();
		if (scene == null || boatLocation == null)
		{
			return false;
		}

		boolean anyCollected = false;

		for (int i = 0; i < route.size(); i++)
		{
			RouteWaypoint waypoint = route.get(i);

			if (waypoint.getType() != RouteWaypoint.WaypointType.SHIPMENT)
			{
				continue;
			}

			if (state.isWaypointCompleted(i))
			{
				continue;
			}

			WorldPoint location = waypoint.getLocation();

			// Only check if within range (impostor ID only visible within 7 tiles)
			int dx = Math.abs(location.getX() - boatLocation.getX());
			int dy = Math.abs(location.getY() - boatLocation.getY());
			if (Math.max(dx, dy) > 7)
			{
				continue;
			}

			if (hasBaseShipmentButNoImpostor(scene, location))
			{
				state.markWaypointCompleted(i);
				anyCollected = true;
				log.debug("Shipment collected at route waypoint index {}: {}", i, location);
			}
		}

		return anyCollected;
	}

	/**
	 * Checks if a base shipment object exists at a location BUT the impostor ID does not.
	 * This indicates the shipment has been collected (base remains, impostor disappears).
	 */
	private boolean hasBaseShipmentButNoImpostor(Scene scene, WorldPoint worldLocation)
	{
		var trial = state.getCurrentTrial();
		if (trial == null)
		{
			return false;
		}

		var shipmentIds = trial.getShipmentBaseIds();
		int shipmentImpostorId = trial.getShipmentImpostorId();

		int plane = worldLocation.getPlane();
		int sceneX = worldLocation.getX() - scene.getBaseX();
		int sceneY = worldLocation.getY() - scene.getBaseY();

		if (sceneX < 0 || sceneX >= 104 || sceneY < 0 || sceneY >= 104)
		{
			return false;
		}

		Tile[][][] tiles = scene.getTiles();
		if (tiles == null || tiles[plane] == null)
		{
			return false;
		}

		Tile tile = tiles[plane][sceneX][sceneY];
		if (tile == null)
		{
			return false;
		}

		boolean hasBaseShipment = false;
		boolean hasImpostor = false;

		for (GameObject gameObject : tile.getGameObjects())
		{
			if (gameObject == null)
			{
				continue;
			}

			int objectId = gameObject.getId();

			if (!shipmentIds.contains(objectId))
			{
				continue;
			}

			hasBaseShipment = true;

			var objectComposition = client.getObjectDefinition(objectId);
			if (objectComposition == null)
			{
				continue;
			}

			var impostorIds = objectComposition.getImpostorIds();
			if (impostorIds == null)
			{
				continue;
			}

			var impostor = objectComposition.getImpostor();
			if (impostor == null)
			{
				continue;
			}

			var impostorId = impostor.getId();
			if (impostorId == shipmentImpostorId)
			{
				hasImpostor = true;
			}
		}

		return hasBaseShipment && !hasImpostor;
	}

	/**
	 * Updates the boat location (player's boat WorldEntity)
	 * Falls back to player location if boat cannot be found
	 */
	public void updatePlayerBoatLocation()
	{
		if (!state.isInTrial())
		{
			state.setBoatLocation(null);
			return;
		}

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			state.setBoatLocation(null);
			return;
		}

		try
		{
			WorldView playerWorldView = localPlayer.getWorldView();
			if (playerWorldView == null)
			{
				state.setBoatLocation(localPlayer.getWorldLocation());
				return;
			}

			int playerWorldViewId = playerWorldView.getId();

			WorldView topLevelWorldView = client.getTopLevelWorldView();
			if (topLevelWorldView == null)
			{
				state.setBoatLocation(localPlayer.getWorldLocation());
				return;
			}

			WorldEntity boatWorldEntity = topLevelWorldView.worldEntities().byIndex(playerWorldViewId);
			if (boatWorldEntity == null)
			{
				state.setBoatLocation(localPlayer.getWorldLocation());
				return;
			}

			var boatLocalLocation = boatWorldEntity.getLocalLocation();
			if (boatLocalLocation != null)
			{
				state.setBoatLocation(WorldPoint.fromLocalInstance(client, boatLocalLocation));
			}
			else
			{
				state.setBoatLocation(localPlayer.getWorldLocation());
			}
		}
		catch (Exception e)
		{
			state.setBoatLocation(localPlayer.getWorldLocation());
			log.debug("Error getting boat location: {}", e.getMessage());
		}
	}

	/**
	 * Updates the front boat tile position for pathfinding
	 * The front is calculated as 3 tiles ahead of the boat center in the direction of travel
	 */
	public void updateFrontBoatTile()
	{
		if (!state.isInTrial())
		{
			state.setFrontBoatTileEstimatedActual(null);
			state.setFrontBoatTileLocal(null);
			return;
		}

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			log.warn("Local player is null when updating front boat tile");
			state.setFrontBoatTileEstimatedActual(null);
			state.setFrontBoatTileLocal(null);
			return;
		}

		try
		{
			WorldView playerWorldView = localPlayer.getWorldView();
			if (playerWorldView == null)
			{
				log.warn("Player WorldView is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			WorldView topLevelWorldView = client.getTopLevelWorldView();
			if (topLevelWorldView == null)
			{
				log.warn("Top-level WorldView is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			int playerWorldViewId = playerWorldView.getId();
			WorldEntity boatWorldEntity = topLevelWorldView.worldEntities().byIndex(playerWorldViewId);
			if (boatWorldEntity == null)
			{
				log.warn("Boat WorldEntity is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			WorldView boatWorldView = boatWorldEntity.getWorldView();
			if (boatWorldView == null)
			{
				log.warn("Boat WorldView is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			Scene boatScene = boatWorldView.getScene();
			if (boatScene == null)
			{
				log.warn("Boat Scene is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			Player boatPlayer = null;
			for (Player p : boatWorldView.players())
			{
				if (p != null && p.equals(localPlayer))
				{
					boatPlayer = p;
					break;
				}
			}

			if (boatPlayer == null)
			{
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			NPC boatNpc = null;
			for (NPC npc : boatWorldView.npcs())
			{
				if (npc == null || !BOAT_NPC_IDS.contains(npc.getId()))
					continue;
				boatNpc = npc;
				break;
			}

			if (boatNpc == null)
			{
				log.warn("Boat NPC is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			LocalPoint npcLocalPoint = boatNpc.getLocalLocation();
			LocalPoint boatPlayerLocalPoint = boatPlayer.getLocalLocation();

			if (npcLocalPoint == null || boatPlayerLocalPoint == null)
			{
				log.warn("NPC or Boat Player local point is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				state.setFrontBoatTileLocal(null);
				return;
			}

			// Calculate direction from player (back) to NPC (middle) in scene tiles
			int npcSceneX = npcLocalPoint.getSceneX();
			int npcSceneY = npcLocalPoint.getSceneY();
			int playerSceneX = boatPlayerLocalPoint.getSceneX();
			int playerSceneY = boatPlayerLocalPoint.getSceneY();

			int deltaX = npcSceneX - playerSceneX;
			int deltaY = npcSceneY - playerSceneY;

			// Front of boat: extend 3 tiles from NPC
			int frontSceneX = npcSceneX + (deltaX * 3);
			int frontSceneY = npcSceneY + (deltaY * 3);

			// Convert to LocalPoint in boat's coordinate system (for rendering)
			int baseX = boatScene.getBaseX();
			int baseY = boatScene.getBaseY();
			LocalPoint frontLocalPoint = LocalPoint.fromScene(baseX + frontSceneX, baseY + frontSceneY, boatScene);

			// Store the boat-relative LocalPoint (smooth sub-tile positioning, for visual rendering)
			state.setFrontBoatTileLocal(frontLocalPoint);

			// Transform from boat's coordinate system to main world (for tile-based pathfinding)
			LocalPoint frontMainWorldLocal = boatWorldEntity.transformToMainWorld(frontLocalPoint);
			if (frontMainWorldLocal == null)
			{
				log.warn("Front main world LocalPoint is null when updating front boat tile");
				state.setFrontBoatTileEstimatedActual(null);
				return;
			}

			// Convert to WorldPoint (for pathfinding A* algorithm)
			WorldPoint frontWorldPoint = WorldPoint.fromLocalInstance(client, frontMainWorldLocal);
			state.setFrontBoatTileEstimatedActual(frontWorldPoint);
		}
		catch (Exception e)
		{
			log.error("Error calculating front boat tile: {}", e.getMessage());
			state.setFrontBoatTileEstimatedActual(null);
			state.setFrontBoatTileLocal(null);
		}
	}

	public static List<WorldPoint> getObjectTiles(Client client, GameObject obj)
	{
		Point min = obj.getSceneMinLocation();
		Point max = obj.getSceneMaxLocation();

		if (min == null || max == null)
		{
			// Fallback: treat as 1x1 anchored on world location
			return Collections.singletonList(obj.getWorldLocation());
		}

		WorldView worldView = client.getTopLevelWorldView();
		if (worldView == null)
		{
			return Collections.singletonList(obj.getWorldLocation());
		}

		Scene scene = worldView.getScene();
		if (scene == null)
		{
			return Collections.singletonList(obj.getWorldLocation());
		}

		int baseX = scene.getBaseX();
		int baseY = scene.getBaseY();
		int plane = obj.getPlane();

		int width = max.getX() - min.getX() + 1;
		int height = max.getY() - min.getY() + 1;

		List<WorldPoint> result = new ArrayList<>(width * height);
		for (int sx = min.getX(); sx <= max.getX(); sx++)
		{
			for (int sy = min.getY(); sy <= max.getY(); sy++)
			{
				int worldX = baseX + sx;
				int worldY = baseY + sy;
				result.add(new WorldPoint(worldX, worldY, plane));
			}
		}

		return result;
	}

	/**
	 * Computes all tiles within a given tolerance distance from target locations.
	 * Uses Chebyshev distance (max of dx, dy) for square areas.
	 *
	 * @param tolerance Distance in tiles (1 = 3x3 area, 2 = 5x5 area, etc.)
	 * @return Map from grabbable tile to its center point
	 */
	public static List<WorldPoint> getTilesWithTolerance(WorldPoint center, int tolerance)
	{
		List<WorldPoint> tiles = new ArrayList<>();
		int plane = center.getPlane();

		for (int dx = -tolerance; dx <= tolerance; dx++)
		{
			for (int dy = -tolerance; dy <= tolerance; dy++)
			{
				tiles.add(new WorldPoint(center.getX() + dx, center.getY() + dy, plane));
			}
		}

		return tiles;
	}

}

package com.barracudatrial;

import com.barracudatrial.game.route.TrialType;
import com.barracudatrial.rendering.BoatZoneRenderer;
import com.barracudatrial.rendering.ObjectHighlightRenderer;
import com.barracudatrial.rendering.PathRenderer;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.*;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import javax.inject.Inject;
import java.awt.Dimension;
import java.awt.Graphics2D;

public class BarracudaTrialOverlay extends Overlay
{
	private final BarracudaTrialPlugin plugin;
	private final PathRenderer pathRenderer;
	private final ObjectHighlightRenderer highlightRenderer;

	@Inject
	public BarracudaTrialOverlay(Client client, BarracudaTrialPlugin plugin, ModelOutlineRenderer modelOutlineRenderer)
	{
		this.plugin = plugin;
		var boatZoneRenderer = new BoatZoneRenderer(client, plugin);
		this.highlightRenderer = new ObjectHighlightRenderer(client, plugin, modelOutlineRenderer, boatZoneRenderer);
		this.pathRenderer = new PathRenderer(client, plugin);

		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(PRIORITY_MED);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!plugin.getGameState().isInTrial())
		{
			return null;
		}

		CachedConfig cachedConfig = plugin.getCachedConfig();

		if (cachedConfig.isShowOptimalPath())
		{
			pathRenderer.renderOptimalPath(graphics);
		}

		if (cachedConfig.isHighlightObjectives())
		{
			highlightRenderer.renderLostSupplies(graphics);
		}

		var trial = plugin.getGameState().getCurrentTrial();
		if (cachedConfig.isHighlightClouds() && trial != null && trial.getTrialType() == TrialType.TEMPOR_TANTRUM)
		{
			highlightRenderer.renderLightningClouds(graphics);
		}

		if (cachedConfig.isHighlightObjectives() && trial != null && trial.getTrialType() == TrialType.JUBBLY_JIVE)
		{
			highlightRenderer.renderToadPillars(graphics);
			highlightRenderer.renderToadPickup(graphics);
		}

		if (cachedConfig.isHighlightObjectives() && trial != null && trial.getTrialType() == TrialType.GWENITH_GLIDE)
		{
			highlightRenderer.renderPortals(graphics);
		}

		if (cachedConfig.isHighlightSpeedBoosts())
		{
			highlightRenderer.renderSpeedBoosts(graphics);
		}

		if (cachedConfig.isHighlightObjectives() && trial != null && trial.getTrialType() == TrialType.TEMPOR_TANTRUM)
		{
			highlightRenderer.renderRumLocations(graphics);
		}

		return null;
	}
}

package com.barracudatrial;

import lombok.Getter;

/**
 * Route optimization strategies for pathfinding.
 * Determines how aggressively the pathfinder penalizes turns and encourages picking up speed boosts.
 */
@Getter
public enum RouteOptimization
{
	RELAXED(
		4,      // pathRecalcIntervalTicks - recalculate less often for smoother paths
		0.70,   // switchCostRatio - harder to switch paths (30% better required)
		2.0,    // turnPenaltyBase - higher penalty for turns (smoother routes)
		-4.0    // speedBoostCost - less incentive to grab boosts (fewer detours)
	),
	EFFICIENT(
		2,      // pathRecalcIntervalTicks - recalculate more often for dynamic routing
		0.85,   // switchCostRatio - easier to switch paths (15% better required)
		1.0,    // turnPenaltyBase - lower penalty for turns (more dynamic routes)
		-6.0    // speedBoostCost - more incentive to grab boosts (more detours)
	);

	private final int pathRecalcIntervalTicks;
	private final double switchCostRatio;
	private final double turnPenaltyBase;
	private final double speedBoostCost;

	RouteOptimization(int pathRecalcIntervalTicks, double switchCostRatio, double turnPenaltyBase, double speedBoostCost)
	{
		this.pathRecalcIntervalTicks = pathRecalcIntervalTicks;
		this.switchCostRatio = switchCostRatio;
		this.turnPenaltyBase = turnPenaltyBase;
		this.speedBoostCost = speedBoostCost;
	}
}

package com.barracudatrial;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

import java.awt.Color;

@ConfigGroup("barracudatrial")
public interface BarracudaTrialConfig extends Config
{
	@ConfigSection(
		name = "Path Display",
		description = "Settings for the optimal path overlay",
		position = 0
	)
	String pathSection = "pathSection";

	@ConfigSection(
		name = "Objectives",
		description = "Settings for objective highlighting",
		position = 1
	)
	String objectivesSection = "objectivesSection";

	@ConfigSection(
		name = "Object Highlighting",
		description = "Settings for object highlighting",
		position = 2
	)
	String objectHighlightingSection = "objectHighlightingSection";

	@ConfigItem(
		keyName = "showOptimalPath",
		name = "Show Optimal Path",
		description = "Display the optimal path to collect all lost supplies",
		section = pathSection,
		position = 0
	)
	default boolean showOptimalPath()
	{
		return true;
	}

	@ConfigItem(
		keyName = "routeOptimization",
		name = "Route Optimization",
		description = "Relaxed: fewer turns overall (smoother). Efficient: grab nearby boosts (more dynamic).",
		section = pathSection,
		position = 1
	)
	default RouteOptimization routeOptimization()
	{
		return RouteOptimization.RELAXED;
	}

	@ConfigItem(
		keyName = "pathLookahead",
		name = "Path Lookahead",
		description = "Number of waypoints to calculate ahead. Lower values improve performance and reduce visual clutter.",
		section = pathSection,
		position = 2
	)
	@Range(min = 1, max = 10)
	default int pathLookahead()
	{
		return 3;
	}

	@ConfigItem(
		keyName = "pathColor",
		name = "Path Color",
		description = "Color of the optimal path line",
		section = pathSection,
		position = 4
	)
	@Alpha
	default Color pathColor()
	{
		return new Color(0, 255, 0, 180);
	}

	@ConfigItem(
		keyName = "pathWidth",
		name = "Path Width",
		description = "Width of the path line",
		section = pathSection,
		position = 5
	)
	@Range(min = 1, max = 10)
	default int pathWidth()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "showPathTiles",
		name = "Show Path Tiles",
		description = "Display detailed information for each waypoint and path tile (type, completion status, coordinates)",
		section = pathSection,
		position = 6
	)
	default boolean showPathTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlightObjectives",
		name = "Highlight Objectives",
		description = "Highlight objectives in the trial area",
		section = objectivesSection,
		position = 0
	)
	default boolean highlightObjectives()
	{
		return true;
	}

	@ConfigItem(
		keyName = "objectivesColorCurrentWaypoint",
		name = "Current Waypoint",
		description = "Color for current waypoint",
		section = objectivesSection,
		position = 1
	)
	@Alpha
	default Color objectivesColorCurrentWaypoint()
	{
		return new Color(0, 255, 0, 180);
	}

	@ConfigItem(
		keyName = "objectivesColorCurrentLap",
		name = "Current Lap",
		description = "Color for objective highlights on current lap",
		section = objectivesSection,
		position = 2
	)
	@Alpha
	default Color objectivesColorCurrentLap()
	{
		return new Color(255, 215, 0, 180);
	}

	@ConfigItem(
		keyName = "objectivesColorLaterLaps",
		name = "Later Lap",
		description = "Color for objective highlights on later laps",
		section = objectivesSection,
		position = 3
	)
	@Alpha
	default Color objectivesColorLaterLaps()
	{
		return new Color(255, 40, 0, 120);
	}

	@ConfigItem(
		keyName = "windCatcherColor",
		name = "Wind Catcher Color",
		description = "Color for wind catcher path segments and tile highlights",
		section = objectivesSection,
		position = 4
	)
	@Alpha
	default Color windCatcherColor()
	{
		return new Color(173, 216, 230, 180); // Light blue
	}

	@ConfigItem(
		keyName = "highlightSpeedBoosts",
		name = "Highlight Speed Boosts",
		description = "Highlight speed boost areas",
		section = objectHighlightingSection,
		position = 0
	)
	default boolean highlightSpeedBoosts()
	{
		return false;
	}

	@ConfigItem(
		keyName = "speedBoostColor",
		name = "Speed Boost Color",
		description = "Color for speed boost highlights",
		section = objectHighlightingSection,
		position = 1
	)
	@Alpha
	default Color speedBoostColor()
	{
		return new Color(0, 255, 0, 150); // Bright green for speed!
	}

	@ConfigItem(
		keyName = "highlightClouds",
		name = "Highlight Lightning Clouds",
		description = "Highlight dangerous lightning clouds",
		section = objectHighlightingSection,
		position = 2
	)
	default boolean highlightClouds()
	{
		return false;
	}

	@ConfigItem(
		keyName = "cloudColor",
		name = "Cloud Color",
		description = "Color for lightning cloud highlights",
		section = objectHighlightingSection,
		position = 3
	)
	@Alpha
	default Color cloudColor()
	{
		return new Color(255, 0, 0, 120);
	}

	@ConfigItem(
		keyName = "cloudDangerRadius",
		name = "Cloud Danger Radius",
		description = "Radius in tiles for the cloud danger area",
		section = objectHighlightingSection,
		position = 4
	)
	@Range(max = 5)
	default int cloudDangerRadius()
	{
		return 2;
	}
}

package com.barracudatrial.rendering;

import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;

/**
 * Static utility methods for rendering and world/scene coordinate conversion
 */
public class RenderingUtils
{
	public static GameObject findGameObjectAtWorldPoint(Client client, WorldPoint worldPoint)
	{
		return findGameObjectAtWorldPoint(client, worldPoint, null);
	}

	public static GameObject findGameObjectAtWorldPoint(Client client, WorldPoint worldPoint, Integer objectId)
	{
		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return null;
		}

		Scene scene = topLevelWorldView.getScene();
		if (scene == null)
		{
			return null;
		}

		LocalPoint localPoint = localPointFromWorldIncludingExtended(topLevelWorldView, worldPoint);
		if (localPoint == null)
		{
			return null;
		}

		Tile tile = getTileFromSceneOrExtended(worldPoint, localPoint, scene);

		if (tile == null)
		{
			return null;
		}

		for (GameObject gameObject : tile.getGameObjects())
		{
			if (gameObject != null)
			{
				if (objectId != null && gameObject.getId() != objectId)
				{
					continue;
				}
				return gameObject;
			}
		}

		return null;
	}

	public static Tile getTileFromSceneOrExtended(WorldPoint worldPoint, LocalPoint localPoint, Scene scene)
	{
		int sceneX = localPoint.getSceneX();
		int sceneY = localPoint.getSceneY();
		var plane = worldPoint.getPlane();
		var tiles = scene.getTiles();

		if (tiles != null &&
				plane >= 0 && plane < tiles.length &&
				sceneX >= 0 && sceneX < tiles[plane].length &&
				sceneY >= 0 && sceneY < tiles[plane][sceneX].length)
		{
			return tiles[plane][sceneX][sceneY];
		}
		else
		{
			var ext = scene.getExtendedTiles();
			if (ext != null &&
					plane >= 0 && plane < ext.length &&
					sceneX >= 0 && sceneX < ext[plane].length &&
					sceneY >= 0 && sceneY < ext[plane][sceneX].length)
			{
				return ext[plane][sceneX][sceneY];
			}
		}

		return null;
	}

	/**
	 * Creates a LocalPoint from a WorldPoint, including support for extended tiles.
	 * LocalPoint.fromWorld() only works for the normal scene, not extended tiles.
	 * This manually creates LocalPoints for extended tiles by calculating scene coordinates.
	 */
	public static LocalPoint localPointFromWorldIncludingExtended(WorldView view, WorldPoint point)
	{
		if (view == null || point == null)
		{
			return null;
		}

		if (view.getPlane() != point.getPlane())
		{
			return null;
		}

		// Try normal method first (works for regular scene)
		LocalPoint normalPoint = LocalPoint.fromWorld(view, point);
		if (normalPoint != null)
		{
			return normalPoint;
		}

		// For extended tiles, manually create LocalPoint from scene coordinates
		int baseX = view.getBaseX();
		int baseY = view.getBaseY();
		int sceneX = point.getX() - baseX;
		int sceneY = point.getY() - baseY;

		// Extended tiles go up to around 192x192, check if within reasonable bounds
		if (sceneX >= -50 && sceneX < 200 && sceneY >= -50 && sceneY < 200)
		{
			return LocalPoint.fromScene(sceneX, sceneY, view);
		}

		return null;
	}

	/**
	 * Renders a tile highlight at a world point with optional label
	 */
	public static void renderTileHighlightAtWorldPoint(Client client, Graphics2D graphics, WorldPoint worldPoint, Color highlightColor, String label)
	{
		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return;
		}

		LocalPoint tileLocalPoint = localPointFromWorldIncludingExtended(topLevelWorldView, worldPoint);
		if (tileLocalPoint == null)
		{
			return;
		}

		Polygon tilePolygon = Perspective.getCanvasTilePoly(client, tileLocalPoint);
		if (tilePolygon != null)
		{
			OverlayUtil.renderPolygon(graphics, tilePolygon, highlightColor);
		}

		if (label != null)
		{
			Point labelPoint = Perspective.getCanvasTextLocation(client, graphics, tileLocalPoint, "", 30);
			if (labelPoint != null)
			{
				graphics.setColor(highlightColor);
				graphics.drawString(label, labelPoint.getX(), labelPoint.getY());
			}
		}
	}
}

package com.barracudatrial.rendering;

import com.barracudatrial.BarracudaTrialPlugin;
import com.barracudatrial.game.route.JubblyJiveConfig;
import com.barracudatrial.game.route.TemporTantrumConfig;
import com.barracudatrial.game.route.TrialType;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;

/**
 * Handles rendering of boat exclusion zones (rectangles around objectives)
 */
@RequiredArgsConstructor
public class BoatZoneRenderer
{
	private final Client client;
	private final BarracudaTrialPlugin plugin;

	public void renderBoatZoneRectangle(Graphics2D graphics, WorldPoint center, Color baseColor)
	{
		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return;
		}

		var trial = plugin.getGameState().getCurrentTrial();
		if (trial == null)
		{
			return;
		}

		int width;
		int height;
		if (trial.getTrialType() == TrialType.TEMPOR_TANTRUM)
		{
			width = TemporTantrumConfig.BOAT_EXCLUSION_WIDTH;
			height = TemporTantrumConfig.BOAT_EXCLUSION_HEIGHT;
		}
		else if (trial.getTrialType() == TrialType.JUBBLY_JIVE)
		{
			width = JubblyJiveConfig.BOAT_EXCLUSION_WIDTH;
			height = JubblyJiveConfig.BOAT_EXCLUSION_HEIGHT;
		}
		else
		{
			return;
		}

		int halfWidth = width / 2;
		int halfHeight = height / 2;

		int minX = center.getX() - halfWidth;
		int maxX = center.getX() + halfWidth;
		int minY = center.getY() - halfHeight;
		int maxY = center.getY() + halfHeight;

		Color fillColor = new Color(baseColor.getRed(), baseColor.getGreen(), baseColor.getBlue(), 150);

		Polygon rectangleBoundary = buildPerimeterPolygon(topLevelWorldView, minX, maxX, minY, maxY);

		if (rectangleBoundary.npoints > 0)
		{
			OverlayUtil.renderPolygon(graphics, rectangleBoundary, fillColor);
		}
	}

	private Polygon buildPerimeterPolygon(WorldView worldView, int minX, int maxX, int minY, int maxY)
	{
		Polygon boundary = new Polygon();

		// Bottom edge (south)
		for (int x = minX; x <= maxX; x++)
		{
			WorldPoint tile = new WorldPoint(x, minY, 0);
			LocalPoint local = RenderingUtils.localPointFromWorldIncludingExtended(worldView, tile);
			if (local != null)
			{
				Polygon tilePoly = Perspective.getCanvasTilePoly(client, local);
				if (tilePoly != null && tilePoly.npoints >= 4)
				{
					if (x == minX)
					{
						boundary.addPoint(tilePoly.xpoints[0], tilePoly.ypoints[0]); // SW corner
					}
					if (x == maxX)
					{
						boundary.addPoint(tilePoly.xpoints[1], tilePoly.ypoints[1]); // SE corner
					}
				}
			}
		}

		// Right edge (east)
		for (int y = minY; y <= maxY; y++)
		{
			WorldPoint tile = new WorldPoint(maxX, y, 0);
			LocalPoint local = RenderingUtils.localPointFromWorldIncludingExtended(worldView, tile);
			if (local != null)
			{
				Polygon tilePoly = Perspective.getCanvasTilePoly(client, local);
				if (tilePoly != null && tilePoly.npoints >= 4)
				{
					if (y == maxY)
					{
						boundary.addPoint(tilePoly.xpoints[2], tilePoly.ypoints[2]); // NE corner
					}
				}
			}
		}

		// Top edge (north)
		for (int x = maxX; x >= minX; x--)
		{
			WorldPoint tile = new WorldPoint(x, maxY, 0);
			LocalPoint local = RenderingUtils.localPointFromWorldIncludingExtended(worldView, tile);
			if (local != null)
			{
				Polygon tilePoly = Perspective.getCanvasTilePoly(client, local);
				if (tilePoly != null && tilePoly.npoints >= 4)
				{
					if (x == minX)
					{
						boundary.addPoint(tilePoly.xpoints[3], tilePoly.ypoints[3]); // NW corner
					}
				}
			}
		}

		return boundary;
	}
}

package com.barracudatrial.rendering;

import com.barracudatrial.CachedConfig;
import com.barracudatrial.BarracudaTrialPlugin;
import com.barracudatrial.game.route.RouteWaypoint;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.WorldEntity;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Path2D;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

@RequiredArgsConstructor
public class PathRenderer
{
	private final Client client;
	private final BarracudaTrialPlugin plugin;

	public void renderOptimalPath(Graphics2D graphics)
	{
		CachedConfig cachedConfig = plugin.getCachedConfig();
		List<WorldPoint> path = plugin.getGameState().getPath();
		if (path.isEmpty())
		{
			return;
		}

		// Get the visual front position transformed to main world coordinates
		// This preserves sub-tile accuracy while being in the correct coordinate system for interpolation
		LocalPoint visualFrontPositionTransformed = getTransformedFrontPosition();
		if (visualFrontPositionTransformed == null)
		{
			return;
		}

		// Trim the path to start from the closest point to our visual position
		// This prevents visual lag when the pathfinding position is behind the rendering position
		List<WorldPoint> trimmedPath = getTrimmedPathForRendering(visualFrontPositionTransformed, path);

		drawSmoothPathWithBezier(graphics, trimmedPath, visualFrontPositionTransformed);
		renderWindCatcherHighlights(graphics);

		if (cachedConfig.isShowPathTiles())
		{
			renderPathTiles(graphics);
		}
	}

	private LocalPoint getTransformedFrontPosition()
	{
		LocalPoint frontBoatTileLocal = plugin.getGameState().getFrontBoatTileLocal();
		if (frontBoatTileLocal == null)
		{
			return null;
		}

		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return null;
		}

		WorldView playerWorldView = localPlayer.getWorldView();
		if (playerWorldView == null)
		{
			return null;
		}

		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return null;
		}

		int playerWorldViewId = playerWorldView.getId();
		WorldEntity boatWorldEntity = topLevelWorldView.worldEntities().byIndex(playerWorldViewId);
		if (boatWorldEntity == null)
		{
			return null;
		}

		return boatWorldEntity.transformToMainWorld(frontBoatTileLocal);
	}

	private List<WorldPoint> getTrimmedPathForRendering(LocalPoint visualPosition, List<WorldPoint> path)
	{
		if (path.isEmpty() || visualPosition == null)
		{
			return path;
		}

		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return path;
		}

		int closestIndex = findClosestPointOnPath(visualPosition, path, topLevelWorldView);

		// Step forward along the path to bias toward showing "forward progress"
		int forwardBiasOffset = 2;
		int startIndex = Math.min(path.size() - 1, closestIndex + forwardBiasOffset);

		if (startIndex >= path.size())
		{
			return new ArrayList<>();
		}

		return new ArrayList<>(path.subList(startIndex, path.size()));
	}

	private int findClosestPointOnPath(LocalPoint visualPosition, List<WorldPoint> path, WorldView worldView)
	{
		int closestIndex = 0;
		double minDistance = Double.POSITIVE_INFINITY;

		for (int i = 0; i < path.size(); i++)
		{
			LocalPoint pathPointLocal = RenderingUtils.localPointFromWorldIncludingExtended(worldView, path.get(i));
			if (pathPointLocal == null)
			{
				continue;
			}

			int dx = visualPosition.getX() - pathPointLocal.getX();
			int dy = visualPosition.getY() - pathPointLocal.getY();
			double distance = Math.sqrt(dx * dx + dy * dy);

			if (distance < minDistance)
			{
				minDistance = distance;
				closestIndex = i;
			}
		}

		return closestIndex;
	}

	private void drawSmoothPathWithBezier(Graphics2D graphics, List<WorldPoint> waypoints, LocalPoint visualStartPosition)
	{
		if (waypoints.isEmpty() || visualStartPosition == null)
		{
			return;
		}

		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return;
		}

		CachedConfig cachedConfig = plugin.getCachedConfig();

		// Convert visual start position to canvas coordinates
		Point startCanvas = Perspective.localToCanvas(client, visualStartPosition, topLevelWorldView.getPlane(), 0);
		if (startCanvas == null)
		{
			return;
		}

		List<WindCatcherGroup> windCatcherGroups = getWindCatcherGroups();

		List<Point> canvasPoints = new ArrayList<>();
		List<Boolean> isWindCatcherSegment = new ArrayList<>();

		for (int wpIdx = 0; wpIdx < waypoints.size(); wpIdx++)
		{
			WorldPoint wp = waypoints.get(wpIdx);
			LocalPoint lp = RenderingUtils.localPointFromWorldIncludingExtended(topLevelWorldView, wp);
			if (lp != null)
			{
				Point cp = Perspective.localToCanvas(client, lp, wp.getPlane(), 0);
				if (cp != null)
				{
					canvasPoints.add(cp);

					boolean isWindCatcher = false;
					for (WindCatcherGroup group : windCatcherGroups)
					{
						int firstIdx = waypoints.indexOf(group.firstLocation);
						int lastIdx = waypoints.lastIndexOf(group.lastLocation);

						if (firstIdx != -1 && lastIdx != -1 && wpIdx >= firstIdx && wpIdx <= lastIdx)
						{
							isWindCatcher = true;
							break;
						}
					}

					isWindCatcherSegment.add(isWindCatcher);
				}
			}
		}

		if (canvasPoints.isEmpty())
		{
			return;
		}

		graphics.setStroke(new BasicStroke(cachedConfig.getPathWidth(), BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));

		drawPathSegments(graphics, canvasPoints, isWindCatcherSegment, startCanvas, cachedConfig);
	}

	private void drawPathSegments(Graphics2D graphics, List<Point> canvasPoints, List<Boolean> isWindCatcherSegment, Point startCanvas, CachedConfig cachedConfig)
	{
		Color normalColor = cachedConfig.getPathColor();
		Color windCatcherColor = cachedConfig.getWindCatcherColor();

		int segmentStart = -1;
		Color currentColor = isWindCatcherSegment.get(0) ? windCatcherColor : normalColor;

		for (int i = 0; i <= canvasPoints.size(); i++)
		{
			boolean isLastPoint = (i == canvasPoints.size());
			boolean colorChanged = !isLastPoint && i > 0 &&
				(!isWindCatcherSegment.get(i).equals(isWindCatcherSegment.get(i - 1)));

			if (colorChanged || isLastPoint)
			{
				int segmentEnd = i - 1;
				drawSinglePathSegment(graphics, canvasPoints, segmentStart, segmentEnd, startCanvas, currentColor);

				if (!isLastPoint)
				{
					segmentStart = i - 1;
					currentColor = isWindCatcherSegment.get(i) ? windCatcherColor : normalColor;
				}
			}
		}
	}

	private void drawSinglePathSegment(Graphics2D graphics, List<Point> canvasPoints, int startIdx, int endIdx,
	                                    Point startCanvas, Color color)
	{
		if (startIdx > endIdx)
		{
			return;
		}

		Path2D.Double path = new Path2D.Double();

		if (startIdx == -1)
		{
			path.moveTo(startCanvas.getX(), startCanvas.getY());
			if (!canvasPoints.isEmpty())
			{
				path.lineTo(canvasPoints.get(0).getX(), canvasPoints.get(0).getY());
			}
			startIdx = 0;
		}
		else
		{
			path.moveTo(canvasPoints.get(startIdx).getX(), canvasPoints.get(startIdx).getY());
		}

		if (endIdx - startIdx == 1)
		{
			path.lineTo(canvasPoints.get(endIdx).getX(), canvasPoints.get(endIdx).getY());
		}
		else
		{
			for (int i = startIdx; i < endIdx; i++)
			{
				Point p0 = i > 0 ? canvasPoints.get(i - 1) : canvasPoints.get(i);
				Point p1 = canvasPoints.get(i);
				Point p2 = canvasPoints.get(i + 1);
				Point p3 = (i + 2 < canvasPoints.size()) ? canvasPoints.get(i + 2) : p2;

				double tension = 0.1;

				double cp1x = p1.getX() + (p2.getX() - p0.getX()) * tension;
				double cp1y = p1.getY() + (p2.getY() - p0.getY()) * tension;

				double cp2x = p2.getX() - (p3.getX() - p1.getX()) * tension;
				double cp2y = p2.getY() - (p3.getY() - p1.getY()) * tension;

				path.curveTo(cp1x, cp1y, cp2x, cp2y, p2.getX(), p2.getY());
			}
		}

		graphics.setColor(color);
		graphics.draw(path);
	}

	private static class WindCatcherGroup
	{
		final WorldPoint firstLocation;
		final WorldPoint lastLocation;

		WindCatcherGroup(WorldPoint firstLocation, WorldPoint lastLocation)
		{
			this.firstLocation = firstLocation;
			this.lastLocation = lastLocation;
		}
	}

	private List<WindCatcherGroup> getWindCatcherGroups()
	{
		List<WindCatcherGroup> groups = new ArrayList<>();
		List<RouteWaypoint> staticRoute = plugin.getGameState().getCurrentStaticRoute();

		if (staticRoute == null || staticRoute.isEmpty())
		{
			return groups;
		}

		var completedIndices = plugin.getGameState().getCompletedWaypointIndices();
		int currentLap = plugin.getGameState().getCurrentLap();

		WorldPoint groupStart = null;
		WorldPoint groupEnd = null;

		for (int i = 0; i < staticRoute.size(); i++)
		{
			if (completedIndices.contains(i))
			{
				continue;
			}

			RouteWaypoint waypoint = staticRoute.get(i);

			if (waypoint.getType() == RouteWaypoint.WaypointType.USE_WIND_CATCHER)
			{
				if (waypoint.getLap() != currentLap)
				{
					continue;
				}

				if (groupStart == null)
				{
					groupStart = waypoint.getLocation();
				}
				groupEnd = waypoint.getLocation();
			}
			else if (!waypoint.getType().isNonNavigableHelper())
			{
				if (groupStart != null && groupEnd != null)
				{
					groups.add(new WindCatcherGroup(groupStart, groupEnd));
				}
				groupStart = null;
				groupEnd = null;
			}
		}

		if (groupStart != null && groupEnd != null)
		{
			groups.add(new WindCatcherGroup(groupStart, groupEnd));
		}

		return groups;
	}

	private void renderWindCatcherHighlights(Graphics2D graphics)
	{
		List<RouteWaypoint> staticRoute = plugin.getGameState().getCurrentStaticRoute();
		if (staticRoute == null || staticRoute.isEmpty())
		{
			return;
		}

		CachedConfig cachedConfig = plugin.getCachedConfig();
		Color windCatcherColor = cachedConfig.getWindCatcherColor();
		int currentLap = plugin.getGameState().getCurrentLap();

		WorldPoint lastWindCatcherTile = null;
		for (RouteWaypoint waypoint : staticRoute)
		{
			if (waypoint.getType() == RouteWaypoint.WaypointType.USE_WIND_CATCHER)
			{
				if (waypoint.getLap() != currentLap)
				{
					continue;
				}

				WorldPoint loc = waypoint.getLocation();
				if (loc != null)
				{
					// Only highlight the first wind catcher in a sequence
					if (lastWindCatcherTile == null)
					{
						RenderingUtils.renderTileHighlightAtWorldPoint(client, graphics, loc, windCatcherColor, "USE WIND CATCHER");
					}
					lastWindCatcherTile = loc;
				}
			}
			else
			{
				lastWindCatcherTile = null;
			}
		}
	}

	private void renderPathTiles(Graphics2D graphics)
	{
		List<RouteWaypoint> staticRoute = plugin.getGameState().getCurrentStaticRoute();
		if (staticRoute == null || staticRoute.isEmpty())
		{
			return;
		}

		Set<Integer> completedIndices = plugin.getGameState().getCompletedWaypointIndices();
		List<WorldPoint> currentPath = plugin.getGameState().getPath();

		for (int i = 0; i < staticRoute.size(); i++)
		{
			RouteWaypoint waypoint = staticRoute.get(i);
			WorldPoint location = waypoint.getLocation();
			boolean completed = completedIndices.contains(i);

			String label = String.format("%s\n\n%s\n\n(%d, %d)",
				waypoint.getType(),
				completed ? "" : "",
				location.getX(),
				location.getY()
			);

			Color color = completed
				? new Color(144, 238, 144, 150)  // light green
				: new Color(255, 255, 153, 150); // light yellow

			RenderingUtils.renderTileHighlightAtWorldPoint(client, graphics, location, color, label);
		}

		WorldView worldView = client.getTopLevelWorldView();
		Scene scene = worldView != null ? worldView.getScene() : null;

		for (WorldPoint pathTile : currentPath)
		{
			Color pathTileColor = new Color(0, 255, 255, 100); // light cyan

			String objectIdsLabel = null;
			if (scene != null)
			{
				LocalPoint localPoint = LocalPoint.fromWorld(worldView, pathTile);
				if (localPoint != null)
				{
					Tile tile = scene.getTiles()[pathTile.getPlane()][localPoint.getSceneX()][localPoint.getSceneY()];
					if (tile != null)
					{
						GameObject[] gameObjects = tile.getGameObjects();
						if (gameObjects != null && gameObjects.length > 0)
						{
							StringBuilder objectIds = new StringBuilder();
							for (GameObject obj : gameObjects)
							{
								if (obj != null)
								{
									if (objectIds.length() > 0)
									{
										objectIds.append("\n");
									}
									objectIds.append(obj.getId());
								}
							}
							if (objectIds.length() > 0)
							{
								objectIdsLabel = objectIds.toString();
							}
						}
					}
				}
			}

			RenderingUtils.renderTileHighlightAtWorldPoint(client, graphics, pathTile, pathTileColor, objectIdsLabel);
		}
	}
}

package com.barracudatrial.rendering;

import com.barracudatrial.BarracudaTrialPlugin;
import com.barracudatrial.CachedConfig;
import com.barracudatrial.game.ObjectTracker;
import com.barracudatrial.game.route.RouteWaypoint;
import com.barracudatrial.game.route.RouteWaypointFilter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

import java.awt.*;
import java.util.*;
import java.util.List;

/**
 * Handles rendering of objective highlights (shipments, toads, portals, rum)
 */
@RequiredArgsConstructor
public class ObjectHighlightRenderer
{
	private final Client client;
	private final BarracudaTrialPlugin plugin;
	private final ModelOutlineRenderer modelOutlineRenderer;
	private final BoatZoneRenderer boatZoneRenderer;

	public void renderLostSupplies(Graphics2D graphics)
	{
		var cachedConfig = plugin.getCachedConfig();
		var gameState = plugin.getGameState();
		var route = gameState.getCurrentStaticRoute();
		var currentLap = gameState.getCurrentLap();
		var completedWaypointIndices = gameState.getCompletedWaypointIndices();

		if (route == null || route.isEmpty())
		{
			return;
		}

		WorldView worldView = client.getTopLevelWorldView();
		if (worldView == null)
		{
			return;
		}

		Scene scene = worldView.getScene();
		if (scene == null)
		{
			return;
		}

		var trial = gameState.getCurrentTrial();
		if (trial == null)
		{
			return;
		}

		var shipmentIds = trial.getShipmentBaseIds();

		int nextWaypointIndex = gameState.getNextNavigableWaypointIndex();
		WorldPoint currentWaypointLocation = null;

		if (nextWaypointIndex < route.size())
		{
			RouteWaypoint nextWaypoint = route.get(nextWaypointIndex);
			if (nextWaypoint.getType() == RouteWaypoint.WaypointType.SHIPMENT)
			{
				currentWaypointLocation = nextWaypoint.getLocation();
			}
		}

		for (int i = 0; i < route.size(); i++)
		{
			var waypoint = route.get(i);

			if (waypoint.getType() != RouteWaypoint.WaypointType.SHIPMENT)
			{
				continue;
			}

			if (completedWaypointIndices.contains(i))
			{
				continue;
			}

			WorldPoint location = waypoint.getLocation();
			GameObject shipmentObject = findShipmentAtLocation(scene, location, shipmentIds);
			if (shipmentObject == null)
			{
				continue;
			}

			Color renderColor;
			if (currentWaypointLocation != null && currentWaypointLocation.equals(location))
			{
				renderColor = cachedConfig.getObjectivesColorCurrentWaypoint();
			}
			else if (waypoint.getLap() != currentLap)
			{
				renderColor = cachedConfig.getObjectivesColorLaterLaps();
			}
			else
			{
				renderColor = cachedConfig.getObjectivesColorCurrentLap();
			}

			renderGameObjectWithHighlight(graphics, shipmentObject, renderColor, false);
		}
	}

	private GameObject findShipmentAtLocation(Scene scene, WorldPoint worldLocation, Set<Integer> shipmentIds)
	{
		int plane = worldLocation.getPlane();
		int sceneX = worldLocation.getX() - scene.getBaseX();
		int sceneY = worldLocation.getY() - scene.getBaseY();

		if (sceneX < 0 || sceneX >= 104 || sceneY < 0 || sceneY >= 104)
		{
			return null;
		}

		Tile[][][] tiles = scene.getTiles();
		if (tiles == null || tiles[plane] == null)
		{
			return null;
		}

		Tile tile = tiles[plane][sceneX][sceneY];
		if (tile == null)
		{
			return null;
		}

		for (GameObject gameObject : tile.getGameObjects())
		{
			if (gameObject != null && shipmentIds.contains(gameObject.getId()))
			{
				return gameObject;
			}
		}

		return null;
	}

	public void renderSpeedBoosts(Graphics2D graphics)
	{
		CachedConfig cachedConfig = plugin.getCachedConfig();
		var color = cachedConfig.getSpeedBoostColor();

		for (GameObject speedBoostObject : plugin.getGameState().getSpeedBoosts())
		{
			renderGameObjectWithHighlight(graphics, speedBoostObject, color, true);
		}
	}

	public void renderLightningClouds(Graphics2D graphics)
	{
		CachedConfig cachedConfig = plugin.getCachedConfig();
		Color color = cachedConfig.getCloudColor();
		for (NPC cloudNpc : plugin.getGameState().getLightningClouds())
		{
			int currentAnimation = cloudNpc.getAnimation();

			boolean isCloudSafe = ObjectTracker.isCloudSafe(currentAnimation);
			if (isCloudSafe)
			{
				continue;
			}

			renderCloudDangerAreaOnGround(graphics, cloudNpc, color);

			renderNpcWithHighlight(graphics, cloudNpc, color);
		}
	}

	public void renderToadPickup(Graphics2D graphics)
	{
		var cached = plugin.getCachedConfig();
		var state = plugin.getGameState();
		var route = state.getCurrentStaticRoute();
		if (route == null || route.isEmpty())
			return;

		int currentLap = state.getCurrentLap();
		var completed = state.getCompletedWaypointIndices();
		int nextWaypointIndex = state.getNextNavigableWaypointIndex();

		for (int i = 0; i < route.size(); i++)
		{
			var waypoint = route.get(i);
			if (waypoint.getType() != RouteWaypoint.WaypointType.TOAD_PICKUP)
				continue;

			if (completed.contains(i))
				continue;

			if (waypoint.getLap() != currentLap)
				continue;

			var loc = waypoint.getLocation();

			Color color;
			if (i == nextWaypointIndex)
			{
				color = cached.getObjectivesColorCurrentWaypoint();
			}
			else
			{
				color = cached.getObjectivesColorCurrentLap();
			}

			var toadObject = RenderingUtils.findGameObjectAtWorldPoint(client, loc);
			if (toadObject == null)
				continue;

			boatZoneRenderer.renderBoatZoneRectangle(graphics, loc, color);
			renderGameObjectWithHighlight(graphics, toadObject, color, true);
		}
	}

	public void renderToadPillars(Graphics2D graphics)
	{
		var cached = plugin.getCachedConfig();
		var state = plugin.getGameState();
		var route = state.getCurrentStaticRoute();
		if (route == null)
			return;

		if (!state.isHasThrowableObjective())
			return;

		int currentLap = state.getCurrentLap();
		var completed = state.getCompletedWaypointIndices();
		int currentWaypointIndex = state.getNextNavigableWaypointIndex();

		var currentLapLocations = RouteWaypointFilter.getLocationsByTypeAndLap(
				route, RouteWaypoint.WaypointType.TOAD_PILLAR, currentLap, completed);

		var laterLapLocations = new HashSet<WorldPoint>();
		for (int i = 0; i < route.size(); i++)
		{
			if (completed.contains(i))
				continue;

			var wp = route.get(i);
			if (wp.getType() == RouteWaypoint.WaypointType.TOAD_PILLAR && wp.getLap() != currentLap)
			{
				laterLapLocations.add(wp.getLocation());
			}
		}

		List<WorldPoint> currentWaypointLocations = RouteWaypointFilter.findNextNavigableWaypoints(
				route, currentWaypointIndex, completed, 2);

		state.getKnownToadPillars().entrySet().stream()
				.filter(e -> !e.getValue())
				.map(Map.Entry::getKey)
				.map(p -> RenderingUtils.findGameObjectAtWorldPoint(client, p))
				.filter(Objects::nonNull)
				.forEach(pillar -> {
					var loc = pillar.getWorldLocation();

					Color color;
					if (currentWaypointLocations.contains(loc))
					{
						color = cached.getObjectivesColorCurrentWaypoint();
					}
					else if (currentLapLocations.contains(loc))
					{
						color = cached.getObjectivesColorCurrentLap();
					}
					else if (laterLapLocations.contains(loc))
					{
						return;
					}
					else
					{
						return;
					}

					renderGameObjectWithHighlight(graphics, pillar, color, false);
				});
	}

	public void renderPortals(Graphics2D graphics)
	{
		var cached = plugin.getCachedConfig();
		var state = plugin.getGameState();
		var route = state.getCurrentStaticRoute();
		if (route == null)
			return;

		int currentLap = state.getCurrentLap();
		var completed = state.getCompletedWaypointIndices();
		int currentWaypointIndex = state.getNextNavigableWaypointIndex();

		var currentLapPortalLocations = RouteWaypointFilter.getLocationsByTypeAndLap(
				route, RouteWaypoint.WaypointType.PORTAL_ENTER, currentLap, completed);

		List<WorldPoint> next2WaypointLocations = RouteWaypointFilter.findNextNavigableWaypoints(
				route, currentWaypointIndex, completed, 2);

		for (WorldPoint portalLocation : currentLapPortalLocations)
		{
			var portalObject = RenderingUtils.findGameObjectAtWorldPoint(client, portalLocation);
			if (portalObject == null)
				continue;

			Color color;
			if (next2WaypointLocations.contains(portalLocation))
			{
				color = cached.getObjectivesColorCurrentWaypoint();
			}
			else
			{
				color = cached.getObjectivesColorCurrentLap();
			}

			renderGameObjectWithHighlight(graphics, portalObject, color, true);
		}
	}

	public void renderRumLocations(Graphics2D graphics)
	{
		var cached = plugin.getCachedConfig();
		var state = plugin.getGameState();
		var route = state.getCurrentStaticRoute();
		if (route == null || route.isEmpty())
			return;

		int currentLap = state.getCurrentLap();
		var completed = state.getCompletedWaypointIndices();
		int nextWaypointIndex = state.getNextNavigableWaypointIndex();

		for (int i = 0; i < route.size(); i++)
		{
			var waypoint = route.get(i);
			var waypointType = waypoint.getType();

			if (waypointType != RouteWaypoint.WaypointType.RUM_PICKUP &&
			    waypointType != RouteWaypoint.WaypointType.RUM_DROPOFF)
				continue;

			if (completed.contains(i))
				continue;

			if (waypoint.getLap() != currentLap)
				continue;

			var loc = waypoint.getLocation();

			Color color;
			if (i == nextWaypointIndex || i == nextWaypointIndex + 1)
			{
				color = cached.getObjectivesColorCurrentWaypoint();
			}
			else
			{
				color = cached.getObjectivesColorCurrentLap();
			}

			boatZoneRenderer.renderBoatZoneRectangle(graphics, loc, color);
			renderRumLocationHighlight(graphics, loc, color);
		}
	}

	private void renderRumLocationHighlight(Graphics2D graphics, WorldPoint rumLocationPoint, Color highlightColor)
	{
		GameObject rumObjectAtLocation = RenderingUtils.findGameObjectAtWorldPoint(client, rumLocationPoint);
		if (rumObjectAtLocation != null)
		{
			renderGameObjectWithHighlight(graphics, rumObjectAtLocation, highlightColor, true);
		}
		else
		{
			renderTileHighlightAtWorldPoint(graphics, rumLocationPoint, highlightColor);
		}
	}

	private void renderGameObjectWithHighlight(Graphics2D graphics, TileObject tileObject, Color highlightColor, boolean shouldHighlightTile)
	{
		LocalPoint objectLocalPoint = tileObject.getLocalLocation();

		if (shouldHighlightTile)
		{
			Polygon tilePolygon = Perspective.getCanvasTilePoly(client, objectLocalPoint);
			if (tilePolygon != null)
			{
				OverlayUtil.renderPolygon(graphics, tilePolygon, highlightColor);
			}
		}

		try
		{
			drawTileObjectHull(graphics, tileObject, highlightColor);
		}
		catch (Exception e)
		{
			renderTileHighlightAtWorldPoint(graphics, tileObject.getWorldLocation(), highlightColor);
		}
	}

	private void renderNpcWithHighlight(Graphics2D graphics, NPC npc, Color highlightColor)
	{
		LocalPoint npcLocalPoint = npc.getLocalLocation();
		if (npcLocalPoint == null)
		{
			return;
		}

		Polygon tilePolygon = Perspective.getCanvasTilePoly(client, npcLocalPoint);
		if (tilePolygon != null)
		{
			OverlayUtil.renderPolygon(graphics, tilePolygon, highlightColor);
		}

		modelOutlineRenderer.drawOutline(npc, 2, highlightColor, 4);
	}

	private void drawTileObjectHull(Graphics2D g, TileObject object, Color borderColor)
	{
		Stroke stroke = new BasicStroke(2f);
		Shape poly = null;
		Shape poly2 = null;

		if (object instanceof GameObject)
		{
			poly = ((GameObject) object).getConvexHull();
		}
		else if (object instanceof WallObject)
		{
			poly = ((WallObject) object).getConvexHull();
			poly2 = ((WallObject) object).getConvexHull2();
		}
		else if (object instanceof DecorativeObject)
		{
			poly = ((DecorativeObject) object).getConvexHull();
			poly2 = ((DecorativeObject) object).getConvexHull2();
		}
		else if (object instanceof GroundObject)
		{
			poly = ((GroundObject) object).getConvexHull();
		}

		if (poly == null)
		{
			poly = object.getCanvasTilePoly();
		}

		Color fillColor = new Color(borderColor.getRed(), borderColor.getGreen(), borderColor.getBlue(), 50);

		if (poly != null)
		{
			OverlayUtil.renderPolygon(g, poly, borderColor, fillColor, stroke);
		}
		if (poly2 != null)
		{
			OverlayUtil.renderPolygon(g, poly2, borderColor, fillColor, stroke);
		}
	}

	private void renderCloudDangerAreaOnGround(Graphics2D graphics, NPC cloudNpc, Color dangerAreaColor)
	{
		CachedConfig cachedConfig = plugin.getCachedConfig();
		LocalPoint cloudCenterPoint = cloudNpc.getLocalLocation();
		if (cloudCenterPoint == null)
		{
			return;
		}

		WorldView worldView = client.getTopLevelWorldView();
		if (worldView == null)
		{
			return;
		}

		int dangerRadiusInTiles = cachedConfig.getCloudDangerRadius();

		for (int dx = -dangerRadiusInTiles; dx <= dangerRadiusInTiles; dx++)
		{
			for (int dy = -dangerRadiusInTiles; dy <= dangerRadiusInTiles; dy++)
			{
				boolean isTileWithinCircle = (dx * dx + dy * dy <= dangerRadiusInTiles * dangerRadiusInTiles);
				if (isTileWithinCircle)
				{
					LocalPoint tilePoint = new LocalPoint(
							cloudCenterPoint.getX() + dx * Perspective.LOCAL_TILE_SIZE,
							cloudCenterPoint.getY() + dy * Perspective.LOCAL_TILE_SIZE,
							worldView
					);

					Polygon tilePolygon = Perspective.getCanvasTilePoly(client, tilePoint);
					if (tilePolygon != null)
					{
						Color transparentFillColor = new Color(dangerAreaColor.getRed(), dangerAreaColor.getGreen(), dangerAreaColor.getBlue(), 30);
						graphics.setColor(transparentFillColor);
						graphics.fill(tilePolygon);
						graphics.setColor(dangerAreaColor);
						graphics.draw(tilePolygon);
					}
				}
			}
		}
	}

	private void renderTileHighlightAtWorldPoint(Graphics2D graphics, WorldPoint worldPoint, Color highlightColor)
	{
		renderTileHighlightAtWorldPoint(graphics, worldPoint, highlightColor, null);
	}

	private void renderTileHighlightAtWorldPoint(Graphics2D graphics, WorldPoint worldPoint, Color highlightColor, String label)
	{
		WorldView topLevelWorldView = client.getTopLevelWorldView();
		if (topLevelWorldView == null)
		{
			return;
		}

		LocalPoint tileLocalPoint = RenderingUtils.localPointFromWorldIncludingExtended(topLevelWorldView, worldPoint);
		if (tileLocalPoint == null)
		{
			return;
		}

		Polygon tilePolygon = Perspective.getCanvasTilePoly(client, tileLocalPoint);
		if (tilePolygon != null)
		{
			OverlayUtil.renderPolygon(graphics, tilePolygon, highlightColor);
		}

		if (label != null)
		{
			var labelPoint = Perspective.getCanvasTextLocation(client, graphics, tileLocalPoint, "", 30);
			if (labelPoint != null)
			{
				graphics.setColor(highlightColor);
				graphics.drawString(label, labelPoint.getX(), labelPoint.getY());
			}
		}
	}

	private boolean isRumLocationNextWaypoint(WorldPoint rumLocation)
	{
		List<RouteWaypoint> staticRoute = plugin.getGameState().getCurrentStaticRoute();
		if (staticRoute == null || staticRoute.isEmpty())
		{
			return false;
		}

		int nextWaypointIndex = plugin.getGameState().getNextNavigableWaypointIndex();
		if (nextWaypointIndex >= staticRoute.size())
		{
			return false;
		}

		RouteWaypoint nextWaypoint = staticRoute.get(nextWaypointIndex);
		WorldPoint nextWaypointLocation = nextWaypoint.getLocation();

		return nextWaypointLocation != null && nextWaypointLocation.equals(rumLocation);
	}
}

package com.barracudatrial.pathfinding;

import com.barracudatrial.RouteOptimization;
import net.runelite.api.coords.WorldPoint;

import java.util.*;

/**
 * A* pathfinding algorithm for finding optimal routes between points
 * considering variable tile costs (speed boosts, clouds, rocks, etc.)
 */
public class AStarPathfinder
{
	public PathResult findPath(BarracudaTileCostCalculator costCalculator, RouteOptimization routeOptimization, WorldPoint start, WorldPoint goal, int maxSearchDistance, int boatDirectionDx, int boatDirectionDy, int goalTolerance)
	{
		PriorityQueue<Node> openSet = new PriorityQueue<>(
			Comparator.comparingDouble((Node n) -> n.fScore)
		);
		Map<StateKey, Node> allNodes = new HashMap<>();

		Node startNode = new Node(start);
		startNode.gScore = 0;
		startNode.hScore = heuristic(start, goal);
		startNode.fScore = startNode.hScore;
		// Start heading: map provided 8-way boat direction into a 24-heading index (15 steps)
		startNode.headingIdx = -1;
		if (boatDirectionDx != 0 || boatDirectionDy != 0)
		{
			int snappedDx = Integer.signum(boatDirectionDx);
			int snappedDy = Integer.signum(boatDirectionDy);
			int baseDir8 = dirIndex(snappedDx, snappedDy);
			if (baseDir8 != -1)
			{
				startNode.headingIdx = DIR8_TO_HEADING24[baseDir8];
			}
		}

		openSet.add(startNode);
		allNodes.put(new StateKey(start, startNode.headingIdx), startNode);

		Set<StateKey> closedSet = new HashSet<>();
		int nodesExplored = 0;
		Node bestNodeSoFar = startNode; // Track best node in case we don't reach goal
		int bestDistanceToGoal = Integer.MAX_VALUE;

		while (!openSet.isEmpty())
		{
			Node current = openSet.poll();

			StateKey currentKey = new StateKey(current.position, current.headingIdx);
			if (closedSet.contains(currentKey))
			{
				continue;
			}

			// Goal check uses Chebyshev distance (max of dx, dy) so a tile radius counts as reached
			int dx = Math.abs(current.position.getX() - goal.getX());
			int dy = Math.abs(current.position.getY() - goal.getY());
			int distanceToGoal = Math.max(dx, dy);

			if (distanceToGoal <= goalTolerance)
			{
				return new PathResult(reconstructPath(current), current.gScore, true);
			}

			if (distanceToGoal < bestDistanceToGoal)
			{
				bestDistanceToGoal = distanceToGoal;
				bestNodeSoFar = current;
			}

			closedSet.add(currentKey);
			nodesExplored++;

			// Prevent runaway search
			if (nodesExplored > maxSearchDistance * maxSearchDistance)
			{
				break;
			}

			// Steering neighbors: delta heading -1,0,+1 (15) and move one tile in the heading's dominant 8-way direction
			for (int deltaH : new int[] { -1, 0, 1 })
			{
				int currentHeading = current.headingIdx;

				// If unknown heading, treat each 8-way direction as a possible base heading
				if (currentHeading == -1)
				{
					for (int baseDir8 = 0; baseDir8 < 8; baseDir8++)
					{
						int nextHeading = DIR8_TO_HEADING24[baseDir8];
						int moveDir = headingToDir8(nextHeading);
						int nx = current.position.getX() + DIRS[moveDir][0];
						int ny = current.position.getY() + DIRS[moveDir][1];
						WorldPoint neighbor = new WorldPoint(nx, ny, current.position.getPlane());

						StateKey neighborKey = new StateKey(neighbor, nextHeading);
						if (closedSet.contains(neighborKey))
						{
							continue;
						}

						double tileCost = costCalculator.getTileCost(current.position, neighbor);
						if (tileCost > 50000)
						{
							continue;
						}

						boolean isDiagonal = Math.abs(nx - current.position.getX()) == 1 && Math.abs(ny - current.position.getY()) == 1;
						double geometricDistance = isDiagonal ? Math.sqrt(2) : 1.0;

						int absDelta = 0; // starting from unknown, count as no extra turning penalty for first move
						double turningCost = calculateTurningCost(routeOptimization, absDelta);

						double tentativeGScore = current.gScore + (tileCost * geometricDistance) + turningCost;

						Node neighborNode = allNodes.get(neighborKey);
						if (neighborNode == null)
						{
							neighborNode = new Node(neighbor);
							neighborNode.headingIdx = nextHeading;
							allNodes.put(neighborKey, neighborNode);
						}

						if (tentativeGScore < neighborNode.gScore)
						{
							neighborNode.parent = current;
							neighborNode.gScore = tentativeGScore;
							neighborNode.hScore = heuristic(neighbor, goal);
							neighborNode.fScore = neighborNode.gScore + neighborNode.hScore;

							openSet.add(neighborNode);
						}
					}

					continue; // processed all initial headings
				}

				int nextHeading = (currentHeading + deltaH + 24) % 24;
				int moveDir = headingToDir8(nextHeading);
				int nx = current.position.getX() + DIRS[moveDir][0];
				int ny = current.position.getY() + DIRS[moveDir][1];
				WorldPoint neighbor = new WorldPoint(nx, ny, current.position.getPlane());

				StateKey neighborKey = new StateKey(neighbor, nextHeading);
				if (closedSet.contains(neighborKey))
				{
					continue;
				}

				double tileCost = costCalculator.getTileCost(current.position, neighbor);
				if (tileCost > 50000)
				{
					continue;
				}

				boolean isDiagonal = Math.abs(nx - current.position.getX()) == 1 && Math.abs(ny - current.position.getY()) == 1;
				double geometricDistance = isDiagonal ? Math.sqrt(2) : 1.0;

				int absDelta = Math.abs(deltaH);
				double turningCost = calculateTurningCost(routeOptimization, absDelta);

				double tentativeGScore = current.gScore + (tileCost * geometricDistance) + turningCost;

				Node neighborNode = allNodes.get(neighborKey);
				if (neighborNode == null)
				{
					neighborNode = new Node(neighbor);
					neighborNode.headingIdx = nextHeading;
					allNodes.put(neighborKey, neighborNode);
				}

				if (tentativeGScore < neighborNode.gScore)
				{
					neighborNode.parent = current;
					neighborNode.gScore = tentativeGScore;
					neighborNode.hScore = heuristic(neighbor, goal);
					neighborNode.fScore = neighborNode.gScore + neighborNode.hScore;

					openSet.add(neighborNode);
				}
			}
		}

		// If we failed to reach the goal, return the closest path we found
		if (bestNodeSoFar != startNode)
		{
			return new PathResult(reconstructPath(bestNodeSoFar), bestNodeSoFar.gScore, false);
		}

		return new PathResult(new ArrayList<>(), Double.POSITIVE_INFINITY, false);
	}

	private double calculateTurningCost(RouteOptimization routeOptimization, int absDelta)
	{
		// absDelta is the absolute heading step change (in 24-heading units: 0 or 1 here)
		if (absDelta == 0)
		{
			return 0.0;
		}

		var angle = absDelta * 15;
		var baseCost = routeOptimization.getTurnPenaltyBase();

		return angle > 105 ? baseCost * 4 : baseCost;
	}

	/**
	 * Heuristic: returns 0 (Dijkstra mode).
	 * Rationale: tile costs may be negative (speed boosts), so admissible heuristics like
	 * Manhattan/Chebyshev are not safe; Dijkstra guarantees optimality.
	 */
	private double heuristic(WorldPoint from, WorldPoint to)
	{
		return 0;
	}

	private int dirIndex(int dx, int dy)
	{
		for (int i = 0; i < DIRS.length; i++)
		{
			if (DIRS[i][0] == dx && DIRS[i][1] == dy)
			{
				return i;
			}
		}
		return -1;
	}

	// Map 24 headings (15 each) to the dominant 8-way movement direction
	private static final int[] HEADING_TO_DIR8 = {
		0, 0,    // 0, 15 -> E
		1, 1, 1, // 30,45,60 -> NE
		2, 2, 2, // 75,90,105 -> N
		3, 3, 3, // 120,135,150 -> NW
		4, 4, 4, // 165,180,195 -> W
		5, 5, 5, // 210,225,240 -> SW
		6, 6, 6, // 255,270,285 -> S
		7, 7, 7, // 300,315,330 -> SE
		0        // 345 -> E
	};

	private static final int[] DIR8_TO_HEADING24 = {0, 2, 5, 8, 12, 15, 18, 21};

	private int headingToDir8(int headingIdx)
	{
		int idx = (headingIdx % 24 + 24) % 24;
		return HEADING_TO_DIR8[idx];
	}

	private List<PathNode> reconstructPath(Node goalNode)
	{
		List<PathNode> pathNodes = new ArrayList<>();
		Node current = goalNode;

		while (current != null)
		{
			pathNodes.add(new PathNode(current.position, current.gScore));
			current = current.parent;
		}

		// Reverse to get path from start to goal
		Collections.reverse(pathNodes);
		return pathNodes;
	}

	private static final int[][] DIRS = {
		{1, 0},   // 0: E
		{1, 1},   // 1: NE
		{0, 1},   // 2: N
		{-1, 1},  // 3: NW
		{-1, 0},  // 4: W
		{-1, -1}, // 5: SW
		{0, -1},  // 6: S
		{1, -1}   // 7: SE
	};

	private static final class StateKey
	{
		private final WorldPoint pos;
		private final int headingIdx;

		StateKey(WorldPoint pos, int headingIdx)
		{
			this.pos = pos;
			this.headingIdx = headingIdx;
		}

		@Override
		public boolean equals(Object o)
		{
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			StateKey stateKey = (StateKey) o;
			return headingIdx == stateKey.headingIdx && pos.equals(stateKey.pos);
		}

		@Override
		public int hashCode()
		{
			return Objects.hash(pos, headingIdx);
		}
	}
	
	private static class Node
	{
		WorldPoint position;
		Node parent;
		int headingIdx = -1; // 0..23 or -1 for unknown
		double gScore = Double.POSITIVE_INFINITY; // Cost from start to this node
		double hScore = 0; // Heuristic cost from this node to goal
		double fScore = Double.POSITIVE_INFINITY; // Total cost (g + h)

		Node(WorldPoint position)
		{
			this.position = position;
		}
	}
}

package com.barracudatrial.pathfinding;

import com.barracudatrial.game.route.RouteWaypoint;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public class PathNode
{
	private final WorldPoint position;
	private final double cumulativeCost;
	private final RouteWaypoint.WaypointType waypointType;

	public PathNode(WorldPoint position, double cumulativeCost)
	{
		this.position = position;
		this.cumulativeCost = cumulativeCost;
		this.waypointType = null;
	}
}

package com.barracudatrial.pathfinding;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.List;

public class PathResult
{
	@Getter
	private final List<PathNode> pathNodes;
	private final double totalCost;
	@Getter
	private final boolean reachedGoal;

	public PathResult(List<PathNode> pathNodes, double totalCost, boolean reachedGoal)
	{
		this.pathNodes = pathNodes;
		this.totalCost = totalCost;
		this.reachedGoal = reachedGoal;
	}

	public List<WorldPoint> getPath()
	{
		List<WorldPoint> path = new ArrayList<>();
		for (PathNode node : pathNodes)
		{
			path.add(node.getPosition());
		}
		return path;
	}

	public double getCost()
	{
		return totalCost;
	}

	public double getCostFromIndex(int index)
	{
		if (index < 0 || index >= pathNodes.size())
		{
			return totalCost;
		}
		return totalCost - pathNodes.get(index).getCumulativeCost();
	}
}
package com.barracudatrial.pathfinding;

import com.barracudatrial.RouteOptimization;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldPoint;

import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class BarracudaTileCostCalculator
{
	private final int exclusionZoneMinX;
	private final int exclusionZoneMaxX;
	private final int exclusionZoneMinY;
	private final int exclusionZoneMaxY;
	private final RouteOptimization routeOptimization;
	private final WorldPoint primaryObjectiveLocation;
	private final WorldPoint secondaryObjectiveLocation;
	private final int boatExclusionWidth;
	private final int boatExclusionHeight;
	private final Set<WorldPoint> pathfindingHintTiles;

	private int speedBoostTilesRemaining = 0;
	private WorldPoint lastTile = null;
	private final Set<WorldPoint> consumedBoosts = new HashSet<>();

	// Precomputed spatial lookups for O(1) cost checks
	private final Set<WorldPoint> rockLocations;
	private final Set<WorldPoint> closeToRocks;
	private final Set<WorldPoint> cloudDangerZones;
	private final Map<WorldPoint, List<WorldPoint>> boostGrabbableTiles;
	private final Set<WorldPoint> fetidPoolLocations;
	private final Set<WorldPoint> toadPillarLocations;
	private Set<WorldPoint> closeToFetidPoolsAndToadPillars = new HashSet<>();

	public BarracudaTileCostCalculator(
		Map<WorldPoint, List<WorldPoint>> knownSpeedBoostLocations,
		Set<WorldPoint> knownRockLocations,
		Set<WorldPoint> knownFetidPoolLocations,
		Set<WorldPoint> knownToadPillarLocations,
		Set<NPC> lightningClouds,
		int exclusionZoneMinX,
		int exclusionZoneMaxX,
		int exclusionZoneMinY,
		int exclusionZoneMaxY,
		WorldPoint primaryObjectiveLocation,
		WorldPoint secondaryObjectiveLocation,
		RouteOptimization routeOptimization,
		int boatExclusionWidth,
		int boatExclusionHeight,
		Set<WorldPoint> pathfindingHintTiles)
	{
		this.exclusionZoneMinX = exclusionZoneMinX;
		this.exclusionZoneMaxX = exclusionZoneMaxX;
		this.exclusionZoneMinY = exclusionZoneMinY;
		this.exclusionZoneMaxY = exclusionZoneMaxY;
		this.primaryObjectiveLocation = primaryObjectiveLocation;
		this.secondaryObjectiveLocation = secondaryObjectiveLocation;
		this.routeOptimization = routeOptimization;
		this.boatExclusionWidth = boatExclusionWidth;
		this.boatExclusionHeight = boatExclusionHeight;
		this.pathfindingHintTiles = pathfindingHintTiles != null ? pathfindingHintTiles : new HashSet<>();

		this.rockLocations = knownRockLocations;
		this.closeToRocks = precomputeTileProximity(rockLocations, 1);
		this.cloudDangerZones = precomputeCloudDangerZones(lightningClouds);
		this.boostGrabbableTiles = knownSpeedBoostLocations;
		this.fetidPoolLocations = knownFetidPoolLocations;
		this.toadPillarLocations = knownToadPillarLocations;
		this.closeToFetidPoolsAndToadPillars = precomputeTileProximity(fetidPoolLocations, 1);
		this.closeToFetidPoolsAndToadPillars.addAll(precomputeTileProximity(toadPillarLocations, 1));
	}

	public double getTileCost(WorldPoint from, WorldPoint to)
	{
		if (pathfindingHintTiles.contains(to))
		{
			return -1.5;
		}

		int maxTileCost = 100000;

		if (lastTile == null || !lastTile.equals(from))
		{
			speedBoostTilesRemaining = 0;
		}
		lastTile = to;

		double cost = 1.0;

		WorldPoint unconsumedBoost = getUnconsumedBoost(to);
		if (unconsumedBoost != null)
		{
			cost = routeOptimization.getSpeedBoostCost();
			speedBoostTilesRemaining = 15;
			consumedBoosts.add(unconsumedBoost);
		}
		else if (speedBoostTilesRemaining > 0)
		{
			cost /= 2.0; // Double speed
			speedBoostTilesRemaining--;
		}

		if (isInBoatExclusionZone(to))
		{
			cost += 100; // Discouraged but allowed for pathmaking
		}
		else if (rockLocations.contains(to))
		{
			cost = maxTileCost;
		}
		else if (closeToRocks.contains(to))
		{
			cost += 3;
		}
		else if (isInExclusionZone(to))
		{
			cost = maxTileCost;
		}
		else if (cloudDangerZones.contains(to))
		{
			cost += 200;
			speedBoostTilesRemaining = 0;
		}
		else if (fetidPoolLocations.contains(to))
		{
			cost += 100;
		}
		else if (toadPillarLocations.contains(to))
		{
			cost = maxTileCost;
		}
		else if (closeToFetidPoolsAndToadPillars.contains(to))
		{
			cost += 3;
		}
		else
		{
			double distToZone = distanceToExclusionZone(to);
			if (distToZone <= 1)
			{
				cost += 100;
			}
			else if (distToZone <= 2)
			{
				cost += 50;
			}
			else if (distToZone <= 3)
			{
				cost += 25;
			}
		}

		return cost;
	}

	private WorldPoint getUnconsumedBoost(WorldPoint tile)
	{
		List<WorldPoint> boosts = boostGrabbableTiles.get(tile);
		if (boosts != null && boosts.contains(tile) && !consumedBoosts.contains(tile))
		{
			return tile;
		}
		return null;
	}

	/**
	 * Get a snapshot of all current danger zones for path stability tracking
	 */
	public Set<WorldPoint> getDangerZoneSnapshot()
	{
		Set<WorldPoint> snapshot = new HashSet<>();
		snapshot.addAll(cloudDangerZones);
		snapshot.addAll(rockLocations);
		snapshot.addAll(fetidPoolLocations);
		return snapshot;
	}

	private boolean isInExclusionZone(WorldPoint point)
	{
		return point.getX() >= exclusionZoneMinX
			&& point.getX() <= exclusionZoneMaxX
			&& point.getY() >= exclusionZoneMinY
			&& point.getY() <= exclusionZoneMaxY;
	}

	private boolean isInBoatExclusionZone(WorldPoint point)
	{
		if (primaryObjectiveLocation == null && secondaryObjectiveLocation == null)
		{
			return false;
		}

		boolean inPrimaryZone = primaryObjectiveLocation != null
			&& isInRectangularZone(point, primaryObjectiveLocation, boatExclusionWidth, boatExclusionHeight);

		boolean inSecondaryZone = secondaryObjectiveLocation != null
			&& isInRectangularZone(point, secondaryObjectiveLocation, boatExclusionWidth, boatExclusionHeight);

		return inPrimaryZone || inSecondaryZone;
	}

	private static boolean isInRectangularZone(WorldPoint point, WorldPoint center, int width, int height)
	{
		int halfWidth = width / 2;
		int halfHeight = height / 2;

		int minX = center.getX() - halfWidth;
		int maxX = center.getX() + halfWidth;
		int minY = center.getY() - halfHeight;
		int maxY = center.getY() + halfHeight;

		return point.getX() >= minX && point.getX() <= maxX
			&& point.getY() >= minY && point.getY() <= maxY;
	}

	private double distanceToExclusionZone(WorldPoint point)
	{
		if (isInExclusionZone(point))
		{
			return 0;
		}

		int x = point.getX();
		int y = point.getY();

		int dx = Math.max(0, Math.max(exclusionZoneMinX - x, x - exclusionZoneMaxX));
		int dy = Math.max(0, Math.max(exclusionZoneMinY - y, y - exclusionZoneMaxY));

		return Math.sqrt(dx * dx + dy * dy);
	}

	private Set<WorldPoint> precomputeTileProximity(Set<WorldPoint> locations, int maxDistance)
	{
		Set<WorldPoint> proximityTiles = new HashSet<>();
		int maxDistSq = maxDistance * maxDistance;

		for (WorldPoint location : locations)
		{
			int baseX = location.getX();
			int baseY = location.getY();
			int plane = location.getPlane();

			for (int dx = -maxDistance; dx <= maxDistance; dx++)
			{
				int dxSq = dx * dx;

				for (int dy = -maxDistance; dy <= maxDistance; dy++)
				{
					if (dx == 0 && dy == 0)
					{
						continue; // skip the location tile itself
					}

					int distSq = dxSq + dy * dy;
					if (distSq > maxDistSq)
					{
						continue;
					}

					WorldPoint tile = new WorldPoint(baseX + dx, baseY + dy, plane);

					// Don't consider tiles that are themselves location tiles
					if (!locations.contains(tile))
					{
						proximityTiles.add(tile);
					}
				}
			}
		}

		return proximityTiles;
	}

	/**
	 * Precomputes all tiles within cloud danger zones for O(1) lookup
	 */
	private Set<WorldPoint> precomputeCloudDangerZones(Set<NPC> lightningClouds)
	{
		Set<WorldPoint> dangerZones = new HashSet<>();

		for (NPC cloud : lightningClouds)
		{
			WorldPoint cloudLoc = cloud.getWorldLocation();
			int plane = cloudLoc.getPlane();

			// Add all tiles within distance 3 of cloud
			for (int dx = -3; dx <= 3; dx++)
			{
				for (int dy = -3; dy <= 3; dy++)
				{
					WorldPoint tile = new WorldPoint(cloudLoc.getX() + dx, cloudLoc.getY() + dy, plane);
					double dist = Math.sqrt(dx * dx + dy * dy);
					if (dist <= 3)
					{
						dangerZones.add(tile);
					}
				}
			}
		}

		return dangerZones;
	}
}

package com.barracudatrial.pathfinding;

import com.barracudatrial.RouteOptimization;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Wraps a path with the danger zones that existed when it was created.
 * We need this to detect NEWLY appearing dangers - if the path already went through
 * danger zones because there was no alternative, we shouldn't rebuild it unless
 * the situation changes (new lightning clouds, new rocks, etc.)
 */
@Getter
class StabilizedPath
{
	private final PathResult pathResult;
	private final Set<WorldPoint> dangerZonesAtCreation;

	public StabilizedPath(PathResult pathResult, Set<WorldPoint> dangerZonesAtCreation)
	{
		this.pathResult = pathResult;
		this.dangerZonesAtCreation = dangerZonesAtCreation;
	}

}

/**
 * Prevents path thrashing by keeping cached paths stable when the player is following them.
 * Goals:
 * - Don't switch paths just because we moved forward (natural cost reduction)
 * - Don't switch for tiny improvements (1 tile difference)
 * - DO switch when world state changes make the old path dangerous (new lightning clouds)
 * - Treat each waypoint segment independently (don't rebuild segment 1->2 because 2->3 improved)
 */
public class PathStabilizer
{
	private final AStarPathfinder pathfinder;
	private final Map<WorldPoint, StabilizedPath> activePathsByGoal;

    public PathStabilizer(AStarPathfinder pathfinder)
	{
		this.pathfinder = pathfinder;
		this.activePathsByGoal = new HashMap<>();
	}

	public PathResult findPath(BarracudaTileCostCalculator costCalculator, RouteOptimization routeOptimization, WorldPoint start, WorldPoint goal, int maxSearchDistance,
	                                  int boatDirectionDx, int boatDirectionDy, int goalTolerance, boolean isPlayerCurrentlyOnPath)
	{
		PathResult newPathResult = pathfinder.findPath(costCalculator, routeOptimization, start, goal, maxSearchDistance, boatDirectionDx, boatDirectionDy, goalTolerance);
		Set<WorldPoint> currentDangerZones = costCalculator.getDangerZoneSnapshot();

		StabilizedPath activeStabilizedPath = activePathsByGoal.get(goal);
		PathResult activePathResult = activeStabilizedPath != null ? activeStabilizedPath.getPathResult() : null;

		if (shouldForceNewPath(activePathResult, newPathResult))
		{
			activePathsByGoal.put(goal, new StabilizedPath(newPathResult, currentDangerZones));
			return newPathResult;
		}

		if (shouldKeepActivePath(routeOptimization, start, activeStabilizedPath, newPathResult, currentDangerZones, isPlayerCurrentlyOnPath))
		{
			return getTrimmedPathResult(start, activePathResult);
		}

		activePathsByGoal.put(goal, new StabilizedPath(newPathResult, currentDangerZones));
		return newPathResult;
	}

	private boolean shouldForceNewPath(PathResult activePathResult, PathResult newPathResult)
	{
		if (activePathResult == null || activePathResult.getPath().isEmpty())
		{
			return true;
		}

		if (newPathResult.getPath().isEmpty())
		{
			return true;
		}

		if (!activePathResult.isReachedGoal() && newPathResult.isReachedGoal())
		{
			return true;
		}

		var activePathEnd = activePathResult.getPath().get(activePathResult.getPath().size() - 1);
		var newPathEnd = newPathResult.getPath().get(newPathResult.getPath().size() - 1);
        return !activePathEnd.equals(newPathEnd);
    }

	private boolean shouldKeepActivePath(RouteOptimization routeOptimization, WorldPoint start, StabilizedPath activeStabilizedPath, PathResult newPathResult, Set<WorldPoint> currentDangerZones, boolean isPlayerCurrentlyOnPath)
	{
		PathResult activePathResult = activeStabilizedPath.getPathResult();

		// If old path goes through NEW danger zones, force new path
		int closestIndex = findClosestPointOnPath(start, activePathResult.getPath());
		Set<WorldPoint> oldDangerZones = activeStabilizedPath.getDangerZonesAtCreation();
		if (doesPathIntersectNewDangerZones(activePathResult, closestIndex, oldDangerZones, currentDangerZones))
		{
			return false;
		}

		if (isPlayerCurrentlyOnPath && !isWithinProximityOfPath(start, activePathResult))
		{
			return false;
		}

        return !isNewPathSignificantlyBetter(routeOptimization, start, activePathResult, newPathResult);
    }

	private boolean isWithinProximityOfPath(WorldPoint start, PathResult pathResult)
	{
		var pathNodes = pathResult.getPathNodes();
		if (pathNodes.isEmpty())
		{
			return false;
		}

		int closestIndex = -1;
		int minDistance = Integer.MAX_VALUE;

		for (int i = 0; i < pathNodes.size(); i++)
		{
			var nodePosition = pathNodes.get(i).getPosition();
			int dx = Math.abs(start.getX() - nodePosition.getX());
			int dy = Math.abs(start.getY() - nodePosition.getY());
			int chebyshevDistance = Math.max(dx, dy);

			if (chebyshevDistance < minDistance)
			{
				minDistance = chebyshevDistance;
				closestIndex = i;
			}
		}

		// When you're at the start of a new segment (closestIndex=0), give extra leeway (5 tiles) for merging
		// onto the path. This handles waypoint pickups from a distance (~4 tiles). Once you're traveling along
		// the path (closestIndex>0), enforce stricter tolerance (3 tiles) - if you stray, recalculate.
		int tolerance = (closestIndex == 0) ? 5 : 3;

		return minDistance <= tolerance;
	}

	private boolean isNewPathSignificantlyBetter(RouteOptimization routeOptimization, WorldPoint start, PathResult activePathResult, PathResult newPathResult)
	{
		double newCost = newPathResult.getCost();

		int closestIndex = findClosestPointOnPath(start, activePathResult.getPath());
		double oldRemainingCost = activePathResult.getCostFromIndex(closestIndex);

		return newCost <= routeOptimization.getSwitchCostRatio() * oldRemainingCost;
	}

	private boolean doesPathIntersectNewDangerZones(PathResult pathResult, int fromIndex, Set<WorldPoint> oldDangerZones, Set<WorldPoint> currentDangerZones)
	{
		// Find danger zones that exist now but didn't exist when the path was created
		Set<WorldPoint> newDangerZones = new HashSet<>(currentDangerZones);
		newDangerZones.removeAll(oldDangerZones);

		// Check if path intersects any of these NEW danger zones
		List<PathNode> pathNodes = pathResult.getPathNodes();
		for (int i = fromIndex; i < pathNodes.size(); i++)
		{
			if (newDangerZones.contains(pathNodes.get(i).getPosition()))
			{
				return true;
			}
		}
		return false;
	}

	private PathResult getTrimmedPathResult(WorldPoint start, PathResult pathResult)
	{
		List<PathNode> fullPathNodes = pathResult.getPathNodes();
		List<WorldPoint> fullPath = pathResult.getPath();
		int closestIndex = findClosestPointOnPath(start, fullPath);

		// If player is exactly on the closest path tile, start from next tile
		if (closestIndex < fullPath.size() && fullPath.get(closestIndex).equals(start))
		{
			closestIndex++;
		}

		// Return remaining path from that point forward
		if (closestIndex >= fullPathNodes.size())
		{
			return new PathResult(new ArrayList<>(), Double.POSITIVE_INFINITY, pathResult.isReachedGoal());
		}

		List<PathNode> trimmedNodes = new ArrayList<>(fullPathNodes.subList(closestIndex, fullPathNodes.size()));
		double trimmedCost = pathResult.getCostFromIndex(closestIndex);
		return new PathResult(trimmedNodes, trimmedCost, pathResult.isReachedGoal());
	}

	private int findClosestPointOnPath(WorldPoint position, List<WorldPoint> path)
	{
		int closestIndex = 0;
		double minDistance = Double.POSITIVE_INFINITY;

		for (int i = 0; i < path.size(); i++)
		{
			int dx = position.getX() - path.get(i).getX();
			int dy = position.getY() - path.get(i).getY();
			double distance = Math.sqrt(dx * dx + dy * dy);

			if (distance < minDistance)
			{
				minDistance = distance;
				closestIndex = i;
			}
		}

		return closestIndex;
	}

	public void clearActivePath()
	{
		this.activePathsByGoal.clear();
	}
}

package com.barracudatrial;

import com.barracudatrial.game.*;
import com.barracudatrial.game.route.Difficulty;
import com.barracudatrial.game.route.RouteWaypoint;
import com.barracudatrial.game.route.RouteWaypoint.WaypointType;
import com.barracudatrial.game.route.TrialType;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;

@SuppressWarnings("unused")
@Slf4j
@PluginDescriptor(
	name = "Barracuda Trials Pathfinder",
	description = "Displays optimal paths and highlights for Sailing Barracuda Trials training",
	tags = {"sailing", "tempor", "tantrum", "jubbly", "jive", "gwenith", "glide", "rum", "toads", "supply"}
)
public class BarracudaTrialPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private BarracudaTrialConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BarracudaTrialOverlay overlay;

	@Inject
	private ClientThread clientThread;

	@Getter
	private final State gameState = new State();

	@Getter
	private CachedConfig cachedConfig;

	private ObjectTracker objectTracker;
	private LocationManager locationManager;
	private ProgressTracker progressTracker;
	private PathPlanner pathPlanner;

	@Override
	@SuppressWarnings("RedundantThrows")
	protected void startUp() throws Exception
	{
		log.info("Barracuda Trial plugin started!");
		overlayManager.add(overlay);

		cachedConfig = new CachedConfig(config);

		objectTracker = new ObjectTracker(client, gameState);
		locationManager = new LocationManager(client, gameState);
		progressTracker = new ProgressTracker(client, gameState);
		pathPlanner = new PathPlanner(client, gameState, cachedConfig, clientThread);
	}

	@Override
	@SuppressWarnings("RedundantThrows")
	protected void shutDown() throws Exception
	{
		log.info("Barracuda Trial plugin stopped!");
		overlayManager.remove(overlay);
		gameState.resetAllTemporaryState();
		pathPlanner.shutdown();
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		boolean trialAreaStateChanged = progressTracker.checkIfPlayerIsInTrial();
		if (trialAreaStateChanged && !gameState.isInTrial())
		{
			pathPlanner.reset();
		}
		if (!gameState.isInTrial())
		{
			return;
		}

		var trial = gameState.getCurrentTrial();
		if (trial != null && trial.getTrialType() == TrialType.TEMPOR_TANTRUM
			&& (cachedConfig.isShowOptimalPath() || cachedConfig.isHighlightClouds()))
		{
			objectTracker.updateLightningCloudTracking();
		}

		if (trial != null && trial.getTrialType() == TrialType.TEMPOR_TANTRUM
			&& (cachedConfig.isShowOptimalPath() || cachedConfig.isHighlightObjectives()))
		{
			locationManager.updateTemporRumLocations();
		}

		if (cachedConfig.isShowOptimalPath()
			|| cachedConfig.isHighlightSpeedBoosts()
			|| cachedConfig.isHighlightObjectives())
		{
			objectTracker.updateHazardsSpeedBoostsAndToadPillars();
		}

		if (cachedConfig.isShowOptimalPath())
		{
			objectTracker.updatePlayerBoatLocation();

			objectTracker.updateFrontBoatTile();

			boolean shipmentsCollected = objectTracker.updateRouteWaypointShipmentTracking();
			if (shipmentsCollected)
			{
				pathPlanner.recalculateOptimalPathFromCurrentState("shipment collected");
			}

			checkPortalExitProximity();
		}

		if (cachedConfig.isShowOptimalPath())
		{
			int ticksSinceLastPathRecalculation = gameState.getTicksSinceLastPathRecalc() + 1;
			gameState.setTicksSinceLastPathRecalc(ticksSinceLastPathRecalculation);

			int recalcInterval = cachedConfig.getRouteOptimization().getPathRecalcIntervalTicks();
			if (ticksSinceLastPathRecalculation >= recalcInterval)
			{
				gameState.setTicksSinceLastPathRecalc(0);
				pathPlanner.recalculateOptimalPathFromCurrentState("periodic (game tick)");
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (!gameState.isInTrial())
		{
			return;
		}

		if (event.getType() != ChatMessageType.GAMEMESSAGE && event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		String chatMessage = event.getMessage();

		if (chatMessage.contains("You collect the rum"))
		{
			log.debug("Rum collected! Message: {}", chatMessage);
			gameState.setHasThrowableObjective(true);

			var route = gameState.getCurrentStaticRoute();

			if (route != null)
			{
				for (int i = 0, n = route.size(); i < n; i++)
				{
					var waypoint = route.get(i);

					if (waypoint.getType() == RouteWaypoint.WaypointType.RUM_PICKUP
						&& !gameState.isWaypointCompleted(i))
					{
						gameState.markWaypointCompleted(i);
						log.info("Marked RUM_PICKUP waypoint as completed at index {}: {}", i, waypoint.getLocation());
						break;
					}
				}
			}

			pathPlanner.recalculateOptimalPathFromCurrentState("chat: rum collected");
		}
		else if (chatMessage.contains("You deliver the rum"))
		{
			log.debug("Rum delivered! Message: {}", chatMessage);
			gameState.setHasThrowableObjective(false);

			var route = gameState.getCurrentStaticRoute();

			if (route != null)
			{
				for (int i = 0; i < route.size(); i++)
				{
					RouteWaypoint waypoint = route.get(i);
					if (waypoint.getType() == RouteWaypoint.WaypointType.RUM_DROPOFF
						&& !gameState.isWaypointCompleted(i))
					{
						gameState.markWaypointCompleted(i);
						var lap = waypoint.getLap();
						gameState.setCurrentLap(lap + 1);
						log.info("Marked RUM_DROPOFF waypoint as completed at index {}: {}", i, waypoint.getLocation());
						pathPlanner.recalculateOptimalPathFromCurrentState("chat: rum delivered");
						break;
					}
				}
			}
		}
		else if (chatMessage.contains("balloon toads. Time to lure"))
		{
			log.debug("Toads collected! Message: {}", chatMessage);

			gameState.setHasThrowableObjective(true);

			var route = gameState.getCurrentStaticRoute();

			if (route != null)
			{
				for (int i = 0, n = route.size(); i < n; i++)
				{
					var waypoint = route.get(i);

					if (waypoint.getType() == RouteWaypoint.WaypointType.TOAD_PICKUP
						&& !gameState.isWaypointCompleted(i))
					{
						gameState.markWaypointCompleted(i);
						log.info("Marked TOAD_PICKUP waypoint as completed at index {}: {}", i, waypoint.getLocation());
						break;
					}
				}
			}

			pathPlanner.recalculateOptimalPathFromCurrentState("chat: toads collected");
		}
		else if (chatMessage.contains("through the portal"))
		{
			log.debug("Portal traversed! Message: {}", chatMessage);

			var route = gameState.getCurrentStaticRoute();

			if (route != null)
			{
				for (int i = 0, n = route.size(); i < n; i++)
				{
					var waypoint = route.get(i);

					if (waypoint.getType() == RouteWaypoint.WaypointType.PORTAL_ENTER
						&& !gameState.isWaypointCompleted(i))
					{
						gameState.markWaypointCompleted(i);
						log.info("Marked PORTAL_ENTER waypoint as completed at index {}: {}", i, waypoint.getLocation());

						if (waypoint.getLap() > gameState.getCurrentLap())
						{
							gameState.setCurrentLap(waypoint.getLap());
							log.info("Advanced to lap {} (portal enter)", waypoint.getLap());
						}

						pathPlanner.recalculateOptimalPathFromCurrentState("chat: portal entered");

						break;
					}
				}
			}
		}
	}
	
	@Subscribe
	public void onScriptPreFired(ScriptPreFired event)
	{
		// TODO: remove once fade out is fixed in Sailing helper
		var FADE_OUT_TRANSITION_SCRIPT_ID = 948;

        if (event.getScriptId() == FADE_OUT_TRANSITION_SCRIPT_ID)
        {
            event.getScriptEvent().getArguments()[4] = 255;
            event.getScriptEvent().getArguments()[5] = 0;
        }
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("barracudatrial"))
		{
			return;
		}

		cachedConfig.updateCache();

		if (event.getKey().equals("routeOptimization") && gameState.isInTrial())
		{
			pathPlanner.recalculateOptimalPathFromCurrentState("config: route optimization changed");
		}
	}

	private void checkPortalExitProximity()
	{
		var route = gameState.getCurrentStaticRoute();
		if (route == null || route.isEmpty())
		{
			return;
		}

		var boatLocation = gameState.getBoatLocation();
		if (boatLocation == null)
		{
			return;
		}

		for (int i = 0; i < route.size() - 1; i++)
		{
			var waypoint = route.get(i);
			var nextWaypoint = route.get(i + 1);

			if (waypoint.getType() == WaypointType.PORTAL_ENTER
				&& gameState.isWaypointCompleted(i)
				&& nextWaypoint.getType() == WaypointType.PORTAL_EXIT
				&& !gameState.isWaypointCompleted(i + 1))
			{
				int distance = boatLocation.distanceTo(nextWaypoint.getLocation());
				if (distance <= 10)
				{
					gameState.markWaypointCompleted(i + 1);
					log.info("Marked PORTAL_EXIT waypoint as completed at index {} (distance: {}): {}", i + 1, distance, nextWaypoint.getLocation());

					if (nextWaypoint.getLap() > gameState.getCurrentLap())
					{
						gameState.setCurrentLap(nextWaypoint.getLap());
						log.info("Advanced to lap {} (portal exit)", nextWaypoint.getLap());
					}

					pathPlanner.recalculateOptimalPathFromCurrentState("portal exit proximity");
					return;
				}
			}
		}
	}

	@Provides
	BarracudaTrialConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BarracudaTrialConfig.class);
	}
}

package com.barracudatrial;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BarracudaTrialPluginTest
{
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BarracudaTrialPlugin.class);
		RuneLite.main(args);
	}
}

