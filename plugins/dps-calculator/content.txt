package com.duckblade.osrs.dpscalc.devbindings;

import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProviderThreadProxy;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import net.runelite.api.NpcID;
import net.runelite.api.Skill;

@Singleton
public class MockClientDataProvider implements ClientDataProvider
{

	public static class MockClientDataProviderThreadProxy extends ClientDataProviderThreadProxy
	{

		private final ClientDataProvider clientDataProvider;

		@Inject
		public MockClientDataProviderThreadProxy(ClientDataProvider clientDataProvider)
		{
			super(null, null, clientDataProvider);
			this.clientDataProvider = clientDataProvider;
		}

		@Override
		public void tryAcquire(Consumer<ClientDataProvider> runnable)
		{
			runnable.accept(clientDataProvider);
		}
	}

	private final ItemStatsProvider itemStatsProvider;
	private final NpcDataProvider npcDataProvider;

	@Inject
	MockClientDataProvider(ItemStatsProvider itemStatsProvider, NpcDataProvider npcDataProvider)
	{
		this.itemStatsProvider = itemStatsProvider;
		this.npcDataProvider = npcDataProvider;
	}

	@Override
	public Skills getPlayerSkills()
	{
		return Skills.builder()
			.level(Skill.ATTACK, 99)
			.level(Skill.STRENGTH, 99)
			.level(Skill.MAGIC, 99)
			.level(Skill.RANGED, 99)
			.level(Skill.PRAYER, 99)
			.boost(Skill.ATTACK, 19)
			.boost(Skill.STRENGTH, 19)
			.boost(Skill.RANGED, 13)
			.build();
	}

	@Override
	public Map<EquipmentInventorySlot, ItemStats> getPlayerEquipment()
	{
		return ImmutableMap.<EquipmentInventorySlot, ItemStats>builder()
			.put(EquipmentInventorySlot.WEAPON, itemStatsProvider.getById(ItemID.TWISTED_BOW))
			.put(EquipmentInventorySlot.AMMO, itemStatsProvider.getById(ItemID.DRAGON_ARROW))
			.build();
	}

	@Override
	public Set<Prayer> getPlayerActivePrayers()
	{
		return Collections.singleton(Prayer.RIGOUR);
	}

	@Override
	public AttackStyle getAttackStyle()
	{
		return WeaponCategory.BOW.getAttackStyles()
			.stream()
			.filter(as -> as.getCombatStyle() == CombatStyle.RAPID)
			.findFirst()
			.get();
	}

	@Override
	public Spell getSpell()
	{
		return null;
	}

	@Override
	public ItemStats getBlowpipeDarts()
	{
		return null;
	}

	@Override
	public Skills getNpcTargetSkills()
	{
		return npcDataProvider.getById(NpcID.ZULRAH).getSkills();
	}

	@Override
	public DefensiveBonuses getNpcTargetBonuses()
	{
		return npcDataProvider.getById(NpcID.ZULRAH).getDefensiveBonuses();
	}

	@Override
	public DefenderAttributes getNpcTargetAttributes()
	{
		return npcDataProvider.getById(NpcID.ZULRAH).getAttributes();
	}

	@Override
	public boolean playerIsOnSlayerTask()
	{
		return false;
	}

	@Override
	public boolean playerIsUsingChargeSpell()
	{
		return false;
	}

	@Override
	public boolean playerIsUsingMarkOfDarkness()
	{
		return false;
	}

	@Override
	public boolean playerIsInWilderness()
	{
		return false;
	}
}

package com.duckblade.osrs.dpscalc.devbindings;

import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcData;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.duckblade.osrs.dpscalc.plugin.util.FutureUtil;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import javax.inject.Singleton;

@Singleton
public class LocalNpcDataProvider implements NpcDataProvider
{

	private static final Gson GSON = new Gson();
	private static final String NPC_STATS_FILE = "/osdata/npcs.min.json";
	private static final String NPC_BASE_IDS_FILE = "/osdata/npc-base-ids.min.json";

	private Map<Integer, NpcData> npcStatsMap;
	private Map<Integer, Integer> npcBaseIdsMap;

	@Override
	public CompletableFuture<?> load(ExecutorService es)
	{
		return FutureUtil.simpleCompletableFuture(es, () ->
		{
			Reader baseIdsReader = new InputStreamReader(getClass().getResourceAsStream(NPC_BASE_IDS_FILE));
			npcBaseIdsMap = GSON.fromJson(baseIdsReader, new TypeToken<HashMap<Integer, Integer>>()
			{
			}.getType());

			Reader npcDataReader = new InputStreamReader(getClass().getResourceAsStream(NPC_STATS_FILE));
			npcStatsMap = GSON.fromJson(npcDataReader, new TypeToken<HashMap<Integer, NpcData>>()
			{
			}.getType());
		});
	}

	public Set<NpcData> getAll()
	{
		return new HashSet<>(npcStatsMap.values());
	}

	public NpcData getById(int npcId)
	{
		return npcStatsMap.get(canonicalize(npcId));
	}

	public int canonicalize(int npcId)
	{
		return npcBaseIdsMap.getOrDefault(npcId, npcId);
	}

}
package com.duckblade.osrs.dpscalc.devbindings;

import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.util.FutureUtil;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import javax.inject.Singleton;

@Singleton
public class LocalItemStatsProvider implements ItemStatsProvider
{

	private static final Gson GSON = new Gson();
	private static final String ITEM_STATS_FILE = "/osdata/items.min.json";

	private Map<Integer, ItemStats> itemStatsMap;

	@Override
	public CompletableFuture<?> load(ExecutorService es)
	{
		return FutureUtil.simpleCompletableFuture(es, () ->
		{
			Reader reader = new InputStreamReader(getClass().getResourceAsStream(ITEM_STATS_FILE));
			itemStatsMap = GSON.fromJson(reader, new TypeToken<HashMap<Integer, ItemStats>>()
			{
			}.getType());
		});
	}

	@Override
	public Set<ItemStats> getAll()
	{
		return new HashSet<>(itemStatsMap.values());
	}

	@Override
	public ItemStats getById(int npcId)
	{
		return itemStatsMap.get(npcId);
	}

}
package com.duckblade.osrs.dpscalc.graphing;

import com.google.inject.grapher.ShortNameFactory;
import java.lang.reflect.Member;

final class GraphingComputeContextNameFactory extends ShortNameFactory
{

	private final GraphingComputeContext context;

	GraphingComputeContextNameFactory(GraphingComputeContext context)
	{
		this.context = context;
	}

	@Override
	public String getMemberName(Member member)
	{
		String key = member.getDeclaringClass().getSimpleName();
		if (key.endsWith("Computable"))
		{
			key = key.substring(0, key.length() - 10);
		}

		Object raw = context.getRaw(key);
		if (raw == null)
		{
			return "null";
		}
		return raw.toString();
	}
}

package com.duckblade.osrs.dpscalc.graphing;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import java.util.HashMap;
import java.util.Map;

public class GraphingComputeContext extends ComputeContext
{

	private final Map<String, Computable<?>> instances = new HashMap<>();

	@Override
	public <T> T get(Computable<T> computable)
	{
		instances.put(computable.key(), computable);
		return super.get(computable);
	}

	Object getRaw(String key)
	{
		if (instances.containsKey(key))
		{
			return get(instances.get(key));
		}
		else
		{
			return null;
		}
	}

}

package com.duckblade.osrs.dpscalc.graphing;

import com.duckblade.osrs.dpscalc.calc.DpsComputeModule;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.google.inject.grapher.NameFactory;
import com.google.inject.grapher.graphviz.PortIdFactory;
import com.google.inject.grapher.graphviz.PortIdFactoryImpl;
import java.lang.annotation.Annotation;

public class GraphingDpsComputeModule extends DpsComputeModule
{

	@Override
	protected void configure()
	{
		super.configure();
		GraphingComputeContext context = new GraphingComputeContext();
		bind(ComputeContext.class).toInstance(context);

		try
		{
			// this is a pretty janky hack but the class isn't public so whatever
			//noinspection unchecked
			Class<? extends Annotation> graphviz = (Class<? extends Annotation>) Class.forName("com.google.inject.grapher.graphviz.Graphviz");
			bind(NameFactory.class)
				.annotatedWith(graphviz)
				.toInstance(new GraphingComputeContextNameFactory(context));

			bind(PortIdFactory.class)
				.annotatedWith(graphviz)
				.to(PortIdFactoryImpl.class);
		}
		catch (ClassNotFoundException e)
		{
			throw new RuntimeException(e);
		}
	}

}

package com.duckblade.osrs.dpscalc.graphing;

import com.duckblade.osrs.dpscalc.ItemStatsConstants;
import com.duckblade.osrs.dpscalc.TestNpcStats;
import com.duckblade.osrs.dpscalc.TestSkills;
import com.duckblade.osrs.dpscalc.calc.DptComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.google.common.collect.Sets;
import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.Key;
import com.google.inject.grapher.graphviz.GraphvizGrapher;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Optional;
import java.util.Scanner;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import org.apache.commons.lang3.tuple.Pair;

// customize inputs in configureInputs, then run main
// output file is graphviz format in file dps.dot
public class V2Grapher
{

	public static void configureInputs(ComputeContext context)
	{
		ItemStats weapon = ItemStatsConstants.SCYTHE;
		context.put(ComputeInputs.ATTACKER_ITEMS, ItemStatsConstants.maxMelee(weapon));
		context.put(ComputeInputs.ATTACK_STYLE, weapon.getWeaponCategory().getAttackStyles().get(1));
		context.put(ComputeInputs.ATTACKER_SKILLS, TestSkills.MAXED_WITH_BOOSTS);
		context.put(ComputeInputs.ATTACKER_PRAYERS, Collections.singleton(Prayer.PIETY));

		TestNpcStats.verzikP2(context);
	}

	public static void main(String[] args) throws Exception
	{
		Injector injector = Guice.createInjector(new GraphingDpsComputeModule());
		Class<DptComputable> root = DptComputable.class;

		ComputeContext context = injector.getInstance(ComputeContext.class);
		configureInputs(context);
		context.get(injector.getInstance(root));

		StringWriter sw = new StringWriter();
		try (PrintWriter out = new PrintWriter(sw))
		{
			GraphvizGrapher grapher = injector.getInstance(GraphvizGrapher.class);
			grapher.setOut(out);
			grapher.setRankdir("TB");
			grapher.graph(injector, Collections.singleton(Key.get(root)));
		}

		String dotFile = sw.toString();
		String processedDotFile = postProcess(dotFile);
		try (FileWriter fw = new FileWriter("dps.dot"))
		{
			fw.write(processedDotFile);
		}

		Runtime.getRuntime().exec("dot -Tpng dps.dot -o dps.png").waitFor();
	}

	private static String postProcess(String dotFile)
	{
		StringWriter outSw = new StringWriter();
		PrintWriter output = new PrintWriter(outSw);

		Scanner s = new Scanner(dotFile);
		output.println(s.nextLine()); // first two lines are always meta
		output.println(s.nextLine());

		HashMap<String, String> originalNodeLine = new HashMap<>();
		Set<String> nodes = new HashSet<>();
		Set<String> dropNodes = new HashSet<>();
		Set<Pair<String, String>> edges = new HashSet<>();

		// pull existing nodes and edges
		while (s.hasNext())
		{
			String line = s.nextLine();
			String[] parts = line.split(" ");

			boolean isNode = !(parts.length > 2 && parts[1].equals("->"));
			if (isNode)
			{
				String nodeId = parts[0];
				originalNodeLine.put(nodeId, line);
				nodes.add(nodeId);
				if (line.contains("null") || line.toLowerCase().contains("multibinder") || line.contains("Set&lt;"))
				{
					dropNodes.add(nodeId);
				}
			}
			else
			{
				String start = parts[0].split(":")[0];
				String end = parts[2].split(":")[0];
				edges.add(Pair.of(start, end));
			}
		}

		// drop edges and nodes with null values
		Optional<String> toDropOpt;
		Function<String, Predicate<Pair<String, String>>> edgeContainsNode = node -> edge -> edge.getRight().equals(node) || edge.getLeft()
			.equals(node);
		while ((toDropOpt = dropNodes.stream().filter(nodes::contains).findFirst()).isPresent())
		{
			String toDrop = toDropOpt.get();

			Set<String> parents = edges.stream()
				.filter(edge -> edge.getRight().equals(toDrop))
				.map(Pair::getLeft)
				.collect(Collectors.toSet());

			Set<String> children = edges.stream()
				.filter(edge -> edge.getLeft().equals(toDrop))
				.map(Pair::getRight)
				.collect(Collectors.toSet());

			Sets.cartesianProduct(parents, children)
				.forEach(list ->
				{
					String left = list.get(0);
					String right = list.get(1);
					nodes.add(left);
					nodes.add(right);
					edges.add(Pair.of(left, right));
				});

			edges.removeIf(edgeContainsNode.apply(toDrop));
			nodes.remove(toDrop);
		}

		nodes.removeIf(node -> edges.stream().noneMatch(edgeContainsNode.apply(node)));

		nodes.forEach(node ->
			output.println(originalNodeLine.get(node)));
		edges.forEach(edge ->
			output.println(edge.getLeft() + " -> " + edge.getRight()));

		output.println("}");
		output.close();

		return outSw.toString();
	}

}

package com.duckblade.osrs.dpscalc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import net.runelite.api.Skill;

public class TestNpcStats
{

	public static void verzikP2(ComputeContext context)
	{
		context.put(ComputeInputs.DEFENDER_SKILLS, Skills.builder()
			.level(Skill.HITPOINTS, 3250)
			.level(Skill.DEFENCE, 200)
			.level(Skill.MAGIC, 400)
			.build()
		);
		context.put(ComputeInputs.DEFENDER_BONUSES, DefensiveBonuses.builder()
			.defenseStab(100)
			.defenseSlash(60)
			.defenseCrush(100)
			.defenseMagic(70)
			.defenseRanged(250)
			.build());
		context.put(ComputeInputs.DEFENDER_ATTRIBUTES, DefenderAttributes.builder()
			.size(3)
			.accuracyMagic(80)
			.build());
	}

	public static void kurask(ComputeContext context)
	{
		context.put(ComputeInputs.DEFENDER_SKILLS, Skills.builder()
			.level(Skill.HITPOINTS, 97)
			.level(Skill.DEFENCE, 105)
			.level(Skill.MAGIC, 1)
			.build()
		);
		context.put(ComputeInputs.DEFENDER_BONUSES, DefensiveBonuses.builder()
			.defenseSlash(20)
			.defenseCrush(20)
			.build());
		context.put(ComputeInputs.DEFENDER_ATTRIBUTES, DefenderAttributes.builder()
			.size(3)
			.isLeafy(true)
			.build());
	}

}

package com.duckblade.osrs.dpscalc;

import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import org.junit.jupiter.api.Test;

public class TestPanelStateDuplicate
{
	private static void statePresetA(PanelState state)
	{
		state.getAttackerBoosts().put(Skill.ATTACK, 10);
		state.setAttackerDistance(11);
		state.getAttackerItems().put(EquipmentInventorySlot.BODY, ItemStatsConstants.TORVA_BODY);
		state.getAttackerPrayers().add(Prayer.CHIVALRY);
		state.getAttackerSkills().put(Skill.STRENGTH, 50);
		state.setAttackStyle(WeaponCategory.UNARMED.getAttackStyles().get(0));
		state.getDefenderAttributes().setName("fake defender");
		state.getDefenderBonuses().setDefenseRanged(55);
		state.getDefenderSkills().put(Skill.COOKING, 20);
	}

	private static void statePresetB(PanelState state)
	{
		state.getAttackerBoosts().put(Skill.ATTACK, 99);
		state.setAttackerDistance(4);
		state.getAttackerItems().put(EquipmentInventorySlot.WEAPON, ItemStatsConstants.SCYTHE);
		state.getAttackerPrayers().remove(Prayer.CHIVALRY);
		state.getAttackerPrayers().add(Prayer.PIETY);
		state.getAttackerSkills().put(Skill.STRENGTH, 20);
		state.getAttackerSkills().put(Skill.MAGIC, 85);
		state.setAttackStyle(WeaponCategory.SCYTHE.getAttackStyles().get(1));
		state.getDefenderAttributes().setName("Ket-Zek");
		state.getDefenderBonuses().setDefenseRanged(20);
		state.getDefenderSkills().put(Skill.COOKING, 1);
		state.getDefenderSkills().put(Skill.RANGED, 47);
	}

	@Test
	void validatePanelStateEquals()
	{
		PanelState baseline = new PanelState();
		statePresetA(baseline);

		PanelState independent = new PanelState();
		statePresetA(independent);
		assertEquals(baseline, independent);

		statePresetB(baseline);
		assertNotEquals(baseline, independent);

		statePresetB(independent);
		assertEquals(baseline, independent);
	}

	@Test
	void validatePanelStateCopyConstructorIsDeep()
	{
		PanelState baseline = new PanelState();
		statePresetA(baseline);

		PanelState copied = new PanelState(baseline);
		assertEquals(baseline, copied);

		statePresetB(baseline);
		assertNotEquals(baseline, copied);

		statePresetB(copied);
		assertEquals(baseline, copied);
	}
}

package com.duckblade.osrs.dpscalc.calc.util;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class EffectiveLevelComputableTest
{

	@Mock
	private EffectiveLevelComputable effectiveLevelComputable;

	@Mock
	private ComputeContext context;

	@BeforeEach
	void setUp()
	{
		// this is the method we actually test, others can be mocked per-test
		when(effectiveLevelComputable.compute(context)).thenCallRealMethod();
	}

	@Test
	void computeReturnsCorrectAttackValues()
	{
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			Skills.builder()
				.level(Skill.ATTACK, 99)
				.level(Skill.STRENGTH, 12)
				.level(Skill.RANGED, 34)
				.level(Skill.MAGIC, 56)
				.boost(Skill.ATTACK, 12)
				.boost(Skill.RANGED, 16)
				.build()
		);
		when(effectiveLevelComputable.getBaseSkill()).thenReturn(Skill.ATTACK);

		when(context.get(ComputeInputs.ATTACKER_PRAYERS)).thenReturn(ImmutableSet.of(
			Prayer.PIETY,
			Prayer.CHIVALRY,
			Prayer.EAGLE_EYE,
			Prayer.MYSTIC_MIGHT
		));
		when(effectiveLevelComputable.getPrayerGroup()).thenReturn(Prayer.PrayerGroup.MELEE);
		when(effectiveLevelComputable.getPrayerMultiplier()).thenReturn(Prayer::getAttackMod);

		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.builder()
			.attackType(AttackType.RANGED)
			.combatStyle(CombatStyle.ACCURATE)
			.build());
		when(effectiveLevelComputable.getBaseBonus()).thenReturn(16);
		when(effectiveLevelComputable.getCombatFocusBonuses()).thenReturn(ImmutableMap.of(
			CombatStyle.ACCURATE, 11,
			CombatStyle.RAPID, 13
		));

		int expected = (int) ((99 + 12) * Prayer.PIETY.getAttackMod() + (16 + 11));
		assertEquals(expected, effectiveLevelComputable.compute(context));
	}

	@Test
	void computeReturnsCorrectStrengthValues()
	{
		// second test ensures that the class respects the provided values and is not defaulting to anything
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			Skills.builder()
				.level(Skill.ATTACK, 99)
				.level(Skill.STRENGTH, 12)
				.level(Skill.RANGED, 34)
				.level(Skill.MAGIC, 56)
				.boost(Skill.ATTACK, 12)
				.boost(Skill.RANGED, 16)
				.build()
		);
		when(effectiveLevelComputable.getBaseSkill()).thenReturn(Skill.RANGED);

		when(context.get(ComputeInputs.ATTACKER_PRAYERS)).thenReturn(ImmutableSet.of(
			Prayer.PIETY,
			Prayer.CHIVALRY,
			Prayer.EAGLE_EYE,
			Prayer.MYSTIC_MIGHT
		));
		when(effectiveLevelComputable.getPrayerGroup()).thenReturn(Prayer.PrayerGroup.RANGED);
		when(effectiveLevelComputable.getPrayerMultiplier()).thenReturn(Prayer::getStrengthMod);

		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.builder()
			.attackType(AttackType.RANGED)
			.combatStyle(CombatStyle.RAPID)
			.build());
		when(effectiveLevelComputable.getBaseBonus()).thenReturn(22);
		when(effectiveLevelComputable.getCombatFocusBonuses()).thenReturn(ImmutableMap.of(
			CombatStyle.ACCURATE, 11,
			CombatStyle.RAPID, 13
		));

		int expected = (int) ((34 + 16) * Prayer.EAGLE_EYE.getStrengthMod() + (22 + 13));
		assertEquals(expected, effectiveLevelComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.util;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import java.time.Duration;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TicksToDurationComputableTest
{

	@Mock
	private ComputeContext context;

	@Mock
	private TicksToDurationComputable ticksToDurationComputable;

	@BeforeEach
	void setUp()
	{
		when(ticksToDurationComputable.compute(context)).thenCallRealMethod();
	}

	@Test
	void convertsNegativeTicksToNull()
	{
		when(ticksToDurationComputable.getTicks(context)).thenReturn(
			-1,
			-100
		);

		assertNull(ticksToDurationComputable.compute(context));
		assertNull(ticksToDurationComputable.compute(context));
	}

	@Test
	void convertsTicksToSeconds()
	{
		when(ticksToDurationComputable.getTicks(context)).thenReturn(
			5,
			10,
			15
		);

		assertEquals(Duration.ofSeconds(3), ticksToDurationComputable.compute(context));
		assertEquals(Duration.ofSeconds(6), ticksToDurationComputable.compute(context));
		assertEquals(Duration.ofSeconds(9), ticksToDurationComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.attack.AttackRollComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.defender.DefenseRollComputable;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class HitChanceComputableTest
{

	@Mock
	private AttackRollComputable attackRollComputable;

	@Mock
	private DefenseRollComputable defenseRollComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private HitChanceComputable hitChanceComputable;

	@Test
	void isCorrectWhenAttackHigherThanDefense()
	{
		when(context.get(attackRollComputable)).thenReturn(456);
		when(context.get(defenseRollComputable)).thenReturn(123);

		double expected = 1.0 - ((123.0 + 2.0) / (2.0 * (456.0 + 1.0)));
		assertEquals(expected, hitChanceComputable.compute(context));
	}

	@Test
	void isCorrectWhenDefenseHigherThanAttack()
	{
		when(context.get(attackRollComputable)).thenReturn(123);
		when(context.get(defenseRollComputable)).thenReturn(456);

		double expected = 123.0 / (2.0 * (456.0 + 1));
		assertEquals(expected, hitChanceComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.ammo.AmmoSlotItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AttackerItemStatsComputableTest
{

	private static final ItemStats WEAPON = ItemStats.builder()
		.itemId(123)
		.name("MockWeapon")
		.accuracyStab(1)
		.accuracySlash(2)
		.accuracyCrush(3)
		.accuracyRanged(4)
		.accuracyMagic(5)
		.strengthMelee(6)
		.strengthRanged(7)
		.strengthMagic(8)
		.prayer(9)
		.speed(10)
		.slot(EquipmentInventorySlot.WEAPON.getSlotIdx())
		.is2h(true)
		.weaponCategory(WeaponCategory.BLUDGEON)
		.build();

	private static final ItemStats NON_WEAPON_1 = ItemStats.builder()
		.itemId(321)
		.name("MockHelmet")
		.accuracyStab(11)
		.accuracySlash(12)
		.accuracyCrush(13)
		.accuracyRanged(14)
		.accuracyMagic(15)
		.strengthMelee(16)
		.strengthRanged(17)
		.strengthMagic(18)
		.prayer(19)
		.slot(EquipmentInventorySlot.HEAD.getSlotIdx())
		.build();

	private static final ItemStats NON_WEAPON_2 = ItemStats.builder()
		.itemId(213)
		.name("MockTorso")
		.accuracyStab(21)
		.accuracySlash(22)
		.accuracyCrush(23)
		.accuracyRanged(24)
		.accuracyMagic(25)
		.strengthMelee(26)
		.strengthRanged(27)
		.strengthMagic(28)
		.prayer(29)
		.slot(EquipmentInventorySlot.BODY.getSlotIdx())
		.build();

	private static final ItemStats AMMO_SLOT = ItemStats.builder()
		.itemId(987)
		.name("MockAmmo")
		.accuracyStab(51)
		.accuracySlash(52)
		.accuracyCrush(53)
		.accuracyRanged(54)
		.accuracyMagic(55)
		.strengthMelee(56)
		.strengthRanged(57)
		.strengthMagic(58)
		.prayer(59)
		.slot(EquipmentInventorySlot.AMMO.getSlotIdx())
		.build();

	private static final ItemStats SHADOW = ItemStats.builder()
		.itemId(ItemID.TUMEKENS_SHADOW)
		.name("MockShadow")
		.accuracyStab(61)
		.accuracySlash(62)
		.accuracyCrush(63)
		.accuracyRanged(64)
		.accuracyMagic(65)
		.strengthMelee(66)
		.strengthRanged(67)
		.strengthMagic(68)
		.prayer(69)
		.slot(EquipmentInventorySlot.WEAPON.getSlotIdx())
		.build();

	@Mock
	private ComputeContext context;

	@Mock
	private AmmoSlotItemStatsComputable ammoSlotItemStatsComputable;

	@InjectMocks
	private AttackerItemStatsComputable attackerItemStatsComputable;

	@Test
	void mergesStatsKeepingWeaponStatsFromWeaponSlotIfFirst()
	{
		ItemStats expected = ItemStats.builder()
			.accuracyStab(12)
			.accuracySlash(14)
			.accuracyCrush(16)
			.accuracyRanged(18)
			.accuracyMagic(20)
			.strengthMelee(22)
			.strengthRanged(24)
			.strengthMagic(26)
			.prayer(28)
			.speed(10)
			.slot(EquipmentInventorySlot.WEAPON.getSlotIdx())
			.is2h(true)
			.weaponCategory(WeaponCategory.BLUDGEON)
			.build();

		assertEquals(expected, AttackerItemStatsComputable.reduce(WEAPON, NON_WEAPON_1));
	}

	@Test
	void mergesStatsKeepingWeaponStatsFromWeaponSlotIfSecond()
	{
		ItemStats expected = ItemStats.builder()
			.accuracyStab(12)
			.accuracySlash(14)
			.accuracyCrush(16)
			.accuracyRanged(18)
			.accuracyMagic(20)
			.strengthMelee(22)
			.strengthRanged(24)
			.strengthMagic(26)
			.prayer(28)
			.speed(10)
			.slot(EquipmentInventorySlot.WEAPON.getSlotIdx())
			.is2h(true)
			.weaponCategory(WeaponCategory.BLUDGEON)
			.build();

		assertEquals(expected, AttackerItemStatsComputable.reduce(NON_WEAPON_1, WEAPON));
	}

	@Test
	void mergesStatsUsingUnarmedWeaponStatsWithoutWeaponSlot()
	{
		ItemStats expected = ItemStats.builder()
			.accuracyStab(32)
			.accuracySlash(34)
			.accuracyCrush(36)
			.accuracyRanged(38)
			.accuracyMagic(40)
			.strengthMelee(42)
			.strengthRanged(44)
			.strengthMagic(46)
			.prayer(48)
			.slot(-1)
			.build();

		assertEquals(expected, AttackerItemStatsComputable.reduce(NON_WEAPON_1, NON_WEAPON_2));
	}

	@Test
	void combinesStatsOfMultipleItems()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.HEAD, NON_WEAPON_1,
			EquipmentInventorySlot.GLOVES, NON_WEAPON_2
		));
		when(context.get(ammoSlotItemStatsComputable)).thenReturn(ItemStats.EMPTY);

		assertEquals(
			AttackerItemStatsComputable.reduce(NON_WEAPON_1, NON_WEAPON_2),
			attackerItemStatsComputable.compute(context)
		);
	}

	@Test
	void defersAmmoSlotItemToAmmoSlotItemStatsComputable()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.HEAD, NON_WEAPON_1,
			EquipmentInventorySlot.AMMO, WEAPON
		));
		when(context.get(ammoSlotItemStatsComputable)).thenReturn(AMMO_SLOT);

		assertEquals(
			AttackerItemStatsComputable.reduce(NON_WEAPON_1, AMMO_SLOT),
			attackerItemStatsComputable.compute(context)
		);
	}

	@Test
	void returnsEmptyStatsForEmptyInput()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenAnswer(ignored -> Collections.emptyMap());
		when(context.get(ammoSlotItemStatsComputable)).thenReturn(ItemStats.EMPTY);

		assertEquals(ItemStats.EMPTY, attackerItemStatsComputable.compute(context));
	}

	@Test
	void appliesTumekensShadowBonusWhenApplicable()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(Collections.singletonMap(EquipmentInventorySlot.WEAPON, SHADOW));
		when(context.get(ammoSlotItemStatsComputable)).thenReturn(ItemStats.EMPTY);

		ItemStats expected = SHADOW.toBuilder()
			.itemId(-1)
			.name(null)
			.accuracyMagic(3 * SHADOW.getAccuracyMagic())
			.strengthMagic(3 * SHADOW.getStrengthMagic())
			.build();

		assertEquals(expected, attackerItemStatsComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.prayer;

import com.duckblade.osrs.dpscalc.calc.AttackerItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class PrayerDurationRemainingComputableTest
{

	@Mock
	private AttackerItemStatsComputable attackerItemStatsComputable;

	@Mock
	private PrayerDrainComputable prayerDrainComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private PrayerDurationRemainingComputable prayerDurationRemainingComputable;

	@Test
	void givesInfinitePrayerOnZeroDrain()
	{
		when(context.get(prayerDrainComputable)).thenReturn(0);

		assertEquals(-1, prayerDurationRemainingComputable.getTicks(context));
	}

	@Test
	void computesPrayerTicksRemaining()
	{
		when(context.get(prayerDrainComputable)).thenReturn(12);
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(ofSkill(Skill.PRAYER, 12));
		when(context.get(attackerItemStatsComputable)).thenReturn(ItemStats.builder().prayer(30).build());

		assertEquals(120, prayerDurationRemainingComputable.getTicks(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.prayer;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.google.common.collect.ImmutableSet;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class PrayerDrainComputableTest
{

	@Mock
	private ComputeContext context;

	@InjectMocks
	private PrayerDrainComputable prayerDrainComputable;

	@Test
	void sumsPrayerDrains()
	{
		when(context.get(ComputeInputs.ATTACKER_PRAYERS)).thenReturn(ImmutableSet.of(
			Prayer.AUGURY,
			Prayer.PROTECT_ITEM,
			Prayer.PROTECT_FROM_MELEE
		));

		int expected = Prayer.AUGURY.getDrainRate() + Prayer.PROTECT_ITEM.getDrainRate() + Prayer.PROTECT_FROM_MELEE.getDrainRate();
		assertEquals(expected, prayerDrainComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.testutil;

import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;

public class ItemStatsUtil
{

	public static ItemStats ofItemId(int itemId)
	{
		return ItemStats.builder()
			.itemId(itemId)
			.build();
	}

	public static ItemStats ofWeaponCategory(WeaponCategory category)
	{
		return ItemStats.builder()
			.weaponCategory(category)
			.build();
	}

}

package com.duckblade.osrs.dpscalc.calc.testutil;

import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;

public class AttackStyleUtil
{

	public static AttackStyle ofAttackType(AttackType attackType)
	{
		return AttackStyle.builder()
			.attackType(attackType)
			.isManualCast(false)
			.build();
	}

	public static AttackStyle ofCombatStyle(CombatStyle combatStyle)
	{
		return AttackStyle.builder()
			.combatStyle(combatStyle)
			.build();
	}

}

package com.duckblade.osrs.dpscalc.calc.testutil;

import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import net.runelite.api.NpcID;

public class DefenderAttributesUtil
{

	public static DefenderAttributes DEMON = DefenderAttributes.builder().isDemon(true).build();
	public static DefenderAttributes DRAGON = DefenderAttributes.builder().isDragon(true).build();
	public static DefenderAttributes KALPHITE = DefenderAttributes.builder().isKalphite(true).build();
	public static DefenderAttributes LEAFY = DefenderAttributes.builder().isLeafy(true).build();
	public static DefenderAttributes UNDEAD = DefenderAttributes.builder().isUndead(true).build();
	public static DefenderAttributes VAMPYRE1 = DefenderAttributes.builder().isVampyre1(true).build();
	public static DefenderAttributes VAMPYRE2 = DefenderAttributes.builder().isVampyre2(true).build();
	public static DefenderAttributes VAMPYRE3 = DefenderAttributes.builder().isVampyre3(true).build();

	public static DefenderAttributes MAX_MAGIC = DefenderAttributes.builder().accuracyMagic(350).build();
	public static DefenderAttributes MIN_MAGIC = DefenderAttributes.builder().accuracyMagic(0).build();

	public static DefenderAttributes ZULRAH = DefenderAttributes.builder().name("Zulrah").npcId(NpcID.ZULRAH).build();
	public static DefenderAttributes CALLISTO = DefenderAttributes.builder().name("Callisto").npcId(NpcID.CALLISTO).build();

	public static DefenderAttributes SIZE_1 = DefenderAttributes.builder().size(1).build();
	public static DefenderAttributes SIZE_2 = DefenderAttributes.builder().size(2).build();
	public static DefenderAttributes SIZE_3 = DefenderAttributes.builder().size(3).build();
	public static DefenderAttributes SIZE_4 = DefenderAttributes.builder().size(3).build();

}

package com.duckblade.osrs.dpscalc.calc.testutil;

import com.duckblade.osrs.dpscalc.calc.model.Skills;
import net.runelite.api.Skill;

public class SkillsUtil
{

	public static Skills ofSkill(Skill skill, int level)
	{
		return Skills.builder()
			.level(skill, level)
			.build();
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DpsComputableTest
{

	@Mock
	private DptComputable dptComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private DpsComputable dpsComputable;

	@Test
	void convertsDptToDps()
	{
		when(context.get(dptComputable)).thenReturn(
			3.0,
			5.4,
			10.8
		);

		assertEquals(3.0 / 0.6, dpsComputable.compute(context));
		assertEquals(5.4 / 0.6, dpsComputable.compute(context));
		assertEquals(10.8 / 0.6, dpsComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.KALPHITE;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class KerisGearBonusTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private KerisGearBonus kerisGearBonus;

	@Test
	void isApplicableWhenUsingKeris()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.KERIS),
			ofItemId(ItemID.KERISP),
			ofItemId(ItemID.KERIS_PARTISAN)
		);

		assertTrue(kerisGearBonus.isApplicable(context));
		assertTrue(kerisGearBonus.isApplicable(context));
		assertTrue(kerisGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingKeris()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(ItemStats.EMPTY);

		assertFalse(kerisGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableForMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.KERIS_PARTISAN));

		assertFalse(kerisGearBonus.isApplicable(context));
	}

	@Test
	void givesNoBonusForNonKalphite()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributes.EMPTY);

		assertEquals(GearBonuses.EMPTY, kerisGearBonus.compute(context));
	}

	@Test
	void givesBonusForKalphite()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(KALPHITE);

		assertEquals(GearBonuses.of(1, 1.33), kerisGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.Mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AggregateGearBonusesComputableTest
{

	@Mock
	private GearBonusComputable gearBonus1, gearBonus2;

	@Mock
	private ComputeContext context;

	private AggregateGearBonusesComputable aggregateGearBonusesComputable;

	@BeforeEach
	void setUp()
	{
		aggregateGearBonusesComputable = new AggregateGearBonusesComputable(
			ImmutableSet.of(
				gearBonus1,
				gearBonus2
			)
		);
	}

	@Test
	void defaultsToEmptyWhenNonApplicable()
	{
		when(gearBonus1.isApplicable(context)).thenReturn(false);
		when(gearBonus2.isApplicable(context)).thenReturn(false);

		assertEquals(GearBonuses.EMPTY, aggregateGearBonusesComputable.compute(context));
		verify(gearBonus1, never()).compute(any());
		verify(gearBonus2, never()).compute(any());
	}

	@Test
	void returnsSingleResultWhenOneApplicable()
	{
		when(gearBonus1.isApplicable(context)).thenReturn(false);
		when(gearBonus2.isApplicable(context)).thenReturn(true);
		when(context.get(gearBonus2)).thenReturn(GearBonuses.symmetric(2));

		assertEquals(GearBonuses.symmetric(2), aggregateGearBonusesComputable.compute(context));
		verify(gearBonus1, never()).compute(any());
	}

	@Test
	void combinesResultsWhenMultipleApplicable()
	{
		when(gearBonus1.isApplicable(context)).thenReturn(true);
		when(context.get(gearBonus1)).thenReturn(GearBonuses.symmetric(1.5));

		when(gearBonus2.isApplicable(context)).thenReturn(true);
		when(context.get(gearBonus2)).thenReturn(GearBonuses.of(1.25, 3));

		assertEquals(GearBonuses.of(1.875, 4.5), aggregateGearBonusesComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TomesGearBonusTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private TomesGearBonus tomesGearBonus;

	@Test
	void isApplicableWhenUsingMagicWithATome()
	{
		AttackStyle.AttackStyleBuilder attackStyle = AttackStyle.builder().attackType(AttackType.MAGIC);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			attackStyle.isManualCast(true).build(),
			attackStyle.combatStyle(CombatStyle.AUTOCAST).build()
		);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_FIRE),
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_WATER)
		);

		assertTrue(tomesGearBonus.isApplicable(context));
		assertTrue(tomesGearBonus.isApplicable(context));
		assertTrue(tomesGearBonus.isApplicable(context));
		assertTrue(tomesGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenUsingPoweredStaves()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_FIRE),
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_WATER)
		);

		assertFalse(tomesGearBonus.isApplicable(context));
		assertFalse(tomesGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenUsingMagicWithoutATome()
	{
		AttackStyle.AttackStyleBuilder attackStyle = AttackStyle.builder().attackType(AttackType.MAGIC);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
				attackStyle.isManualCast(true).build(),
				attackStyle.combatStyle(CombatStyle.AUTOCAST).build()
		);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_FIRE_EMPTY),
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_WATER_EMPTY),
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.DRAGON_DEFENDER)
		);

		assertFalse(tomesGearBonus.isApplicable(context));
		assertFalse(tomesGearBonus.isApplicable(context));
		assertFalse(tomesGearBonus.isApplicable(context));
		assertFalse(tomesGearBonus.isApplicable(context));
		assertFalse(tomesGearBonus.isApplicable(context));
		assertFalse(tomesGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.RANGED)
		);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_FIRE),
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_WATER)
		);

		assertFalse(tomesGearBonus.isApplicable(context));
		assertFalse(tomesGearBonus.isApplicable(context));
	}

	@Test
	void grantsBonusWhenUsingFireSpellsWithTomeOfFire()
	{
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.FIRE_STRIKE,
			Spell.FIRE_BOLT,
			Spell.FIRE_BLAST,
			Spell.FIRE_WAVE,
			Spell.FIRE_SURGE
		);
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_FIRE)
		);

		assertEquals(GearBonuses.of(1, 1.5), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.of(1, 1.5), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.of(1, 1.5), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.of(1, 1.5), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.of(1, 1.5), tomesGearBonus.compute(context));
	}

	@Test
	void grantsBonusWhenUsingWaterSpellsWithTomeOfWater()
	{
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.WATER_STRIKE,
			Spell.WATER_BOLT,
			Spell.WATER_BLAST,
			Spell.WATER_WAVE,
			Spell.WATER_SURGE
		);
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_WATER)
		);

		assertEquals(GearBonuses.symmetric(1.2), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(1.2), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(1.2), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(1.2), tomesGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(1.2), tomesGearBonus.compute(context));
	}

	@Test
	void grantsNoBonusWhenUsingSpellsThatDontMatchTome()
	{
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.WATER_STRIKE,
			Spell.FIRE_SURGE,
			Spell.ICE_BARRAGE
		);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_FIRE),
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_WATER),
			Collections.singletonMap(EquipmentInventorySlot.SHIELD, ItemID.TOME_OF_WATER)
		);

		assertEquals(GearBonuses.EMPTY, tomesGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, tomesGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, tomesGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonMap;
import java.util.Map;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class BlackMaskGearBonusTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private SalveAmuletGearBonus salveAmuletGearBonus;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private BlackMaskGearBonus blackMaskGearBonus;

	private Map<EquipmentInventorySlot, Integer> helmetMap(int helmet)
	{
		return singletonMap(EquipmentInventorySlot.HEAD, helmet);
	}

	@Test
	void isNotApplicableWithoutBlackMask()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(emptyMap());
		assertFalse(blackMaskGearBonus.isApplicable(context));
	}

	@Test
	void isApplicableWithBlackMask()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(helmetMap(ItemID.BLACK_MASK));
		assertTrue(blackMaskGearBonus.isApplicable(context));
	}

	@Test
	void isApplicableWithBlackMaskImbued()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(helmetMap(ItemID.BLACK_MASK_I));
		assertTrue(blackMaskGearBonus.isApplicable(context));
	}

	@Test
	void warnsOffTask()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(false);

		assertEquals(GearBonuses.EMPTY, blackMaskGearBonus.compute(context));
		verify(context).warn("Black mask/Slayer helmet off-task provides minimal or negative accuracy bonuses.");
	}

	@Test
	void warnsWhenSalveAlreadyInEffect()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true);
		when(salveAmuletGearBonus.isApplicable(context)).thenReturn(true);

		assertEquals(GearBonuses.EMPTY, blackMaskGearBonus.compute(context));
		verify(context).warn("Black mask/Slayer helmet does not stack with salve amulet.");
	}

	@Test
	void warnsForRangedWithUnimbuedMask()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true);
		when(salveAmuletGearBonus.isApplicable(context)).thenReturn(false);
		when(context.get(equipmentItemIdsComputable)).thenReturn(helmetMap(ItemID.SLAYER_HELMET));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals(GearBonuses.EMPTY, blackMaskGearBonus.compute(context));
		verify(context).warn("Unimbued Black mask/Slayer helmet provides negative bonuses for ranged/magic.");
	}

	@Test
	void warnsForMagicWithUnimbuedMask()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true);
		when(salveAmuletGearBonus.isApplicable(context)).thenReturn(false);
		when(context.get(equipmentItemIdsComputable)).thenReturn(helmetMap(ItemID.SLAYER_HELMET));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertEquals(GearBonuses.EMPTY, blackMaskGearBonus.compute(context));
		verify(context).warn("Unimbued Black mask/Slayer helmet provides negative bonuses for ranged/magic.");
	}

	@Test
	void givesBonusForMeleeWithoutImbue()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true);
		when(salveAmuletGearBonus.isApplicable(context)).thenReturn(false);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));

		assertEquals(GearBonuses.symmetric(7.0 / 6.0), blackMaskGearBonus.compute(context));
	}

	@Test
	void givesBonusForMeleeWithImbue()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true);
		when(salveAmuletGearBonus.isApplicable(context)).thenReturn(false);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));

		assertEquals(GearBonuses.symmetric(7.0 / 6.0), blackMaskGearBonus.compute(context));
	}

	@Test
	void givesBonusForRangedWithImbue()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true);
		when(salveAmuletGearBonus.isApplicable(context)).thenReturn(false);
		when(context.get(equipmentItemIdsComputable)).thenReturn(helmetMap(ItemID.SLAYER_HELMET_I));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals(GearBonuses.symmetric(1.15), blackMaskGearBonus.compute(context));
	}

	@Test
	void givesBonusForMagicWithImbue()
	{
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true);
		when(salveAmuletGearBonus.isApplicable(context)).thenReturn(false);
		when(context.get(equipmentItemIdsComputable)).thenReturn(helmetMap(ItemID.SLAYER_HELMET_I));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertEquals(GearBonuses.symmetric(1.15), blackMaskGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class RevenantWeaponGearBonusTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private RevenantWeaponGearBonus revenantWeaponGearBonus;

	@Test
	void isApplicableWhenUsingChainmace()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.VIGGORAS_CHAINMACE));

		assertTrue(revenantWeaponGearBonus.isApplicable(context));
	}

	@Test
	void isApplicableWhenUsingCrawsBow()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.CRAWS_BOW));

		assertTrue(revenantWeaponGearBonus.isApplicable(context));
	}

	@Test
	void isApplicableWhenUsingSceptre()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.THAMMARONS_SCEPTRE));

		assertTrue(revenantWeaponGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenMisusingWeapons()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.MAGIC),
			ofAttackType(AttackType.MAGIC),
			ofAttackType(AttackType.STAB)
		);
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.VIGGORAS_CHAINMACE),
			ofItemId(ItemID.CRAWS_BOW),
			ofItemId(ItemID.THAMMARONS_SCEPTRE)
		);

		assertFalse(revenantWeaponGearBonus.isApplicable(context));
		assertFalse(revenantWeaponGearBonus.isApplicable(context));
		assertFalse(revenantWeaponGearBonus.isApplicable(context));
	}

	@Test
	void warnsWhenOutOfWilderness()
	{
		when(context.get(ComputeInputs.IN_WILDERNESS)).thenReturn(false);

		assertEquals(GearBonuses.EMPTY, revenantWeaponGearBonus.compute(context));
		verify(context, times(1)).warn("Using revenant weapons outside the wilderness provides no bonuses.");
	}

	@Test
	void givesCorrectBonusesForChainmace()
	{
		when(context.get(ComputeInputs.IN_WILDERNESS)).thenReturn(true);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));

		assertEquals(GearBonuses.symmetric(1.5), revenantWeaponGearBonus.compute(context));
	}

	@Test
	void givesCorrectBonusesForCrawsBow()
	{
		when(context.get(ComputeInputs.IN_WILDERNESS)).thenReturn(true);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals(GearBonuses.symmetric(1.5), revenantWeaponGearBonus.compute(context));
	}

	@Test
	void givesCorrectBonusesForSceptre()
	{
		when(context.get(ComputeInputs.IN_WILDERNESS)).thenReturn(true);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertEquals(GearBonuses.of(2, 1.25), revenantWeaponGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AhrimsAutocastGearBonusTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private AhrimsAutocastGearBonus ahrimsAutocastGearBonus;

	@Test
	void isNotApplicableWhenNotUsingMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertFalse(ahrimsAutocastGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWithoutAhrimsAndDamned()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.AHRIMS_STAFF,
				EquipmentInventorySlot.HEAD, ItemID.AHRIMS_HOOD,
				EquipmentInventorySlot.BODY, ItemID.AHRIMS_ROBETOP,
				EquipmentInventorySlot.LEGS, ItemID.AHRIMS_ROBESKIRT
			),
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.AHRIMS_STAFF,
				EquipmentInventorySlot.HEAD, ItemID.AHRIMS_HOOD_0,
				EquipmentInventorySlot.BODY, ItemID.AHRIMS_ROBETOP,
				EquipmentInventorySlot.LEGS, ItemID.AHRIMS_ROBESKIRT,
				EquipmentInventorySlot.AMULET, ItemID.AMULET_OF_THE_DAMNED_FULL
			),
			Collections.emptyMap()
		);

		assertFalse(ahrimsAutocastGearBonus.isApplicable(context));
		assertFalse(ahrimsAutocastGearBonus.isApplicable(context));
		assertFalse(ahrimsAutocastGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenManualCasting()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.builder()
			.attackType(AttackType.MAGIC)
			.isManualCast(true)
			.build());
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.WEAPON, ItemID.AHRIMS_STAFF,
			EquipmentInventorySlot.HEAD, ItemID.AHRIMS_HOOD,
			EquipmentInventorySlot.BODY, ItemID.AHRIMS_ROBETOP,
			EquipmentInventorySlot.LEGS, ItemID.AHRIMS_ROBESKIRT,
			EquipmentInventorySlot.AMULET, ItemID.AMULET_OF_THE_DAMNED_FULL
		));

		assertFalse(ahrimsAutocastGearBonus.isApplicable(context));
		verify(context, times(1)).warn("Ahrim's with amulet of the damned only provides 30% damage bonus when autocasting.");
	}

	@Test
	void isApplicableWithAhrimsAndDamned()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.builder()
			.attackType(AttackType.MAGIC)
			.isManualCast(false)
			.build());
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.AHRIMS_STAFF_75,
				EquipmentInventorySlot.HEAD, ItemID.AHRIMS_HOOD_50,
				EquipmentInventorySlot.BODY, ItemID.AHRIMS_ROBETOP_25,
				EquipmentInventorySlot.LEGS, ItemID.AHRIMS_ROBESKIRT,
				EquipmentInventorySlot.AMULET, ItemID.AMULET_OF_THE_DAMNED_FULL
			)
		);

		assertTrue(ahrimsAutocastGearBonus.isApplicable(context));
	}

	@Test
	void providesCorrectBonus()
	{
		assertEquals(GearBonuses.of(1.0, 1.3), ahrimsAutocastGearBonus.compute(context));
	}
}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.LEAFY;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class LeafyGearBonusTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private LeafyGearBonus leafyGearBonus;

	@Test
	void isApplicableWhenFightingLeafyEnemies()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(LEAFY);

		assertTrue(leafyGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotFightingLeafyEnemies()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributes.EMPTY);

		assertFalse(leafyGearBonus.isApplicable(context));
	}

	@Test
	void providesAppropriateBonusWhenUsingMeleeWithoutBattleaxe()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, ItemID.LEAFBLADED_SWORD),
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, ItemID.LEAFBLADED_SPEAR)
		);

		assertEquals(GearBonuses.EMPTY, leafyGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, leafyGearBonus.compute(context));
	}

	@Test
	void providesAppropriateBonusWhenUsingMeleeWithBattleaxe()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, ItemID.LEAFBLADED_BATTLEAXE)
		);

		assertEquals(GearBonuses.symmetric(1.175), leafyGearBonus.compute(context));
	}

	@Test
	void zerosCalculationWhenUsingMeleeWithoutLeafBladedWeapon()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, ItemID.SCYTHE_OF_VITUR)
		);

		assertEquals(GearBonuses.symmetric(0), leafyGearBonus.compute(context));
		verify(context, times(1)).warn("Leafy creatures are immune to melee unless using a leaf-bladed weapon.");
	}

	@Test
	void providesFlatBonusWhenUsingRangedWithBroadAmmo()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMMO, ItemID.BROAD_ARROWS),
			Collections.singletonMap(EquipmentInventorySlot.AMMO, ItemID.BROAD_BOLTS)
		);

		assertEquals(GearBonuses.EMPTY, leafyGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, leafyGearBonus.compute(context));
	}

	@Test
	void zerosCalculationWhenUsingRangedWithoutBroadAmmo()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMMO, ItemID.DRAGON_ARROW)
		);

		assertEquals(GearBonuses.symmetric(0), leafyGearBonus.compute(context));
		verify(context, times(1)).warn("Leafy creatures are immune to ranged unless using broad bolts/arrows.");
	}

	@Test
	void providesFlatBonusWhenUsingMagicWithMagicDart()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(ComputeInputs.SPELL)).thenReturn(Spell.MAGIC_DART);

		assertEquals(GearBonuses.EMPTY, leafyGearBonus.compute(context));
	}

	@Test
	void zerosCalculationWhenUsingMagicWithoutMagicDart()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(ComputeInputs.SPELL)).thenReturn(Spell.FIRE_SURGE);

		assertEquals(GearBonuses.symmetric(0), leafyGearBonus.compute(context));
		verify(context, times(1)).warn("Leafy creatures are immune to magic spells other than Magic Dart.");
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableMap;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonMap;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class CrystalGearBonusTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private CrystalGearBonus crystalGearBonus;

	@Test
	void isApplicableWhenUsingCrystalBows()
	{
		//noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.WEAPON, ItemID.CRYSTAL_BOW),
			singletonMap(EquipmentInventorySlot.WEAPON, ItemID.BOW_OF_FAERDHINEN),
			singletonMap(EquipmentInventorySlot.WEAPON, ItemID.BOW_OF_FAERDHINEN_C)
		);
		assertTrue(crystalGearBonus.isApplicable(context));
		assertTrue(crystalGearBonus.isApplicable(context));
		assertTrue(crystalGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWithoutCrystalBow()
	{
		//noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			emptyMap(),
			singletonMap(EquipmentInventorySlot.WEAPON, ItemID.MAGIC_SHORTBOW)
		);
		assertFalse(crystalGearBonus.isApplicable(context));
		assertFalse(crystalGearBonus.isApplicable(context));
	}

	@Test
	void grantsBonusForHelm()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.HEAD, ItemID.CRYSTAL_HELM)
		);
		assertEquals(GearBonuses.of(1.05, 1.025), crystalGearBonus.compute(context));
	}

	@Test
	void grantsBonusForBody()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.BODY, ItemID.CRYSTAL_BODY)
		);
		assertEquals(GearBonuses.of(1.15, 1.075), crystalGearBonus.compute(context));
	}

	@Test
	void grantsBonusForLegs()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.LEGS, ItemID.CRYSTAL_LEGS)
		);
		assertEquals(GearBonuses.of(1.10, 1.05), crystalGearBonus.compute(context));
	}

	@Test
	void grantsBonusForFullSet()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.<EquipmentInventorySlot, Integer>builder()
			.put(EquipmentInventorySlot.HEAD, ItemID.CRYSTAL_HELM)
			.put(EquipmentInventorySlot.BODY, ItemID.CRYSTAL_BODY)
			.put(EquipmentInventorySlot.LEGS, ItemID.CRYSTAL_LEGS)
			.build()
		);
		assertEquals(GearBonuses.of(1.3, 1.15), crystalGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SmokeBattlestaffGearBonusTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private SmokeBattlestaffGearBonus smokeBattlestaffGearBonus;

	@Test
	void isApplicableWhenUsingSmokeStaffForStandardSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SMOKE_BATTLESTAFF));
		when(context.get(ComputeInputs.SPELL)).thenReturn(Spell.WATER_STRIKE);

		assertTrue(smokeBattlestaffGearBonus.isApplicable(context));
	}

	@Test
	void isApplicableWhenNotUsingMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));

		assertFalse(smokeBattlestaffGearBonus.isApplicable(context));
	}

	@Test
	void isApplicableWhenNotUsingSmokeStaff()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.MIST_BATTLESTAFF));

		assertFalse(smokeBattlestaffGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingStandardSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SMOKE_BATTLESTAFF));
		when(context.get(ComputeInputs.SPELL)).thenReturn(Spell.ICE_BARRAGE);

		assertFalse(smokeBattlestaffGearBonus.isApplicable(context));
	}

	@Test
	void grantsApplicableBonus()
	{
		assertEquals(GearBonuses.symmetric(1.1), smokeBattlestaffGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.DEMON;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MeleeDemonbaneGearBonusTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private MeleeDemonbaneGearBonus meleeDemonbaneGearBonus;

	@Test
	void isApplicableWhenUsingDemonbaneWeapons()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.SILVERLIGHT),
			ofItemId(ItemID.SILVERLIGHT_6745),
			ofItemId(ItemID.DARKLIGHT),
			ofItemId(ItemID.ARCLIGHT)
		);

		assertTrue(meleeDemonbaneGearBonus.isApplicable(context));
		assertTrue(meleeDemonbaneGearBonus.isApplicable(context));
		assertTrue(meleeDemonbaneGearBonus.isApplicable(context));
		assertTrue(meleeDemonbaneGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWithoutDemonbaneWeapons()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SCYTHE_OF_VITUR));

		assertFalse(meleeDemonbaneGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableForMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SILVERLIGHT));

		assertFalse(meleeDemonbaneGearBonus.isApplicable(context));
	}

	@Test
	void warnsAgainstNonDemons()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributes.EMPTY);

		assertEquals(GearBonuses.EMPTY, meleeDemonbaneGearBonus.compute(context));
		verify(context, times(1)).warn("Using demonbane weaponry against non-demons provides no bonuses.");
	}

	@Test
	void providesCorrectBonusForLevel1Demonbane()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DEMON);
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.SILVERLIGHT),
			ofItemId(ItemID.SILVERLIGHT_6745),
			ofItemId(ItemID.DARKLIGHT)
		);

		assertEquals(GearBonuses.of(1, 1.6), meleeDemonbaneGearBonus.compute(context));
		assertEquals(GearBonuses.of(1, 1.6), meleeDemonbaneGearBonus.compute(context));
		assertEquals(GearBonuses.of(1, 1.6), meleeDemonbaneGearBonus.compute(context));
	}

	@Test
	void providesCorrectBonusForLevel2Demonbane()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DEMON);
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.ARCLIGHT));

		assertEquals(GearBonuses.symmetric(1.7), meleeDemonbaneGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.DRAGON;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DragonHunterGearBonusTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private DragonHunterGearBonus dragonHunterGearBonus;

	@Test
	void isApplicableWhenUsingDragonHunterLance()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.DRAGON_HUNTER_LANCE));

		assertTrue(dragonHunterGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableForMeleeWithoutLance()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SCYTHE_OF_VITUR));

		assertFalse(dragonHunterGearBonus.isApplicable(context));
	}

	@Test
	void isApplicableWhenUsingDragonHunterCrossbow()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.DRAGON_HUNTER_CROSSBOW),
			ofItemId(ItemID.DRAGON_HUNTER_CROSSBOW_B),
			ofItemId(ItemID.DRAGON_HUNTER_CROSSBOW_T)
		);

		assertTrue(dragonHunterGearBonus.isApplicable(context));
		assertTrue(dragonHunterGearBonus.isApplicable(context));
		assertTrue(dragonHunterGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenUsingRangedWithoutCrossbow()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.MAGIC_SHORTBOW)
		);

		assertFalse(dragonHunterGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableForMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.DRAGON_HUNTER_LANCE));

		assertFalse(dragonHunterGearBonus.isApplicable(context));
	}

	@Test
	void warnsForNonDragons()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributes.EMPTY);

		assertEquals(GearBonuses.EMPTY, dragonHunterGearBonus.compute(context));
		verify(context, times(1)).warn("Using dragon hunter weaponry against non-dragons provides no bonuses.");
	}

	@Test
	void providesCorrectBonusForLance()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DRAGON);
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.DRAGON_HUNTER_LANCE));

		assertEquals(GearBonuses.symmetric(1.2), dragonHunterGearBonus.compute(context));
	}

	@Test
	void providesCorrectBonusForCrossbow()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DRAGON);
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.DRAGON_HUNTER_CROSSBOW));

		assertEquals(GearBonuses.of(1.3, 1.25), dragonHunterGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.defender.DefenderSkillsComputable;
import static com.duckblade.osrs.dpscalc.calc.gearbonus.TbowGearBonus.tbowFormula;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.MAX_MAGIC;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.MIN_MAGIC;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TbowGearBonusTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private DefenderSkillsComputable defenderSkillsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private TbowGearBonus tbowGearBonus;

	@Test
	void isApplicableWhenUsingTbow()
	{
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.TWISTED_BOW));

		assertTrue(tbowGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingTbow()
	{
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.MAGIC_SHORTBOW));

		assertFalse(tbowGearBonus.isApplicable(context));
	}

	@Test
	void warnsWhenTargetMagicIsLow()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(MIN_MAGIC);
		when(context.get(defenderSkillsComputable)).thenReturn(ofSkill(Skill.MAGIC, 50));

		assertEquals(GearBonuses.of(tbowFormula(50, true), tbowFormula(50, false)), tbowGearBonus.compute(context));
		verify(context, times(1)).warn("Using the twisted bow against low-magic targets incurs negative bonuses.");
	}

	@Test
	void maxesScalingAt250()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(MAX_MAGIC);
		when(context.get(defenderSkillsComputable)).thenReturn(ofSkill(Skill.MAGIC, 350));

		assertEquals(
			GearBonuses.of(tbowFormula(250, true), tbowFormula(250, false)),
			tbowGearBonus.compute(context)
		);
	}

	@Test
	void usesMagicLevelIfLargerThanMagicAccuracy()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(MAX_MAGIC);
		when(context.get(defenderSkillsComputable)).thenReturn(ofSkill(Skill.MAGIC, 100));

		assertEquals(
			GearBonuses.of(tbowFormula(250, true), tbowFormula(250, false)),
			tbowGearBonus.compute(context)
		);
	}

	@Test
	void usesMagicAccuracyIfLargerThanMagicLevel()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(MIN_MAGIC);
		when(context.get(defenderSkillsComputable)).thenReturn(ofSkill(Skill.MAGIC, 250));

		assertEquals(
			GearBonuses.of(tbowFormula(250, true), tbowFormula(250, false)),
			tbowGearBonus.compute(context)
		);
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.VoidLevelComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.VoidLevel;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class VoidGearBonusTest
{

	@Mock
	private VoidLevelComputable voidLevelComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private VoidGearBonus voidGearBonus;

	@Test
	void isApplicableWhenWearingVoid()
	{
		when(context.get(voidLevelComputable)).thenReturn(VoidLevel.REGULAR, VoidLevel.ELITE);

		assertTrue(voidGearBonus.isApplicable(context));
		assertTrue(voidGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotWearingVoid()
	{
		when(context.get(voidLevelComputable)).thenReturn(VoidLevel.NONE);

		assertFalse(voidGearBonus.isApplicable(context));
	}

	@Test
	void providesCorrectBonusesForMelee()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(voidLevelComputable)).thenReturn(VoidLevel.REGULAR, VoidLevel.ELITE);

		assertEquals(GearBonuses.symmetric(1.1), voidGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(1.1), voidGearBonus.compute(context));
	}

	@Test
	void providesCorrectBonusesForRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(voidLevelComputable)).thenReturn(VoidLevel.REGULAR, VoidLevel.ELITE);

		assertEquals(GearBonuses.symmetric(1.1), voidGearBonus.compute(context));
		assertEquals(GearBonuses.of(1.1, 1.125), voidGearBonus.compute(context));
	}

	@Test
	void providesCorrectBonusesForMage()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(voidLevelComputable)).thenReturn(VoidLevel.REGULAR, VoidLevel.ELITE);

		assertEquals(GearBonuses.of(1.45, 1), voidGearBonus.compute(context));
		assertEquals(GearBonuses.of(1.45, 1.025), voidGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableMap;
import static java.util.Collections.emptyMap;
import static java.util.Collections.singletonMap;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class InquisitorsGearBonusTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private InquisitorsGearBonus inquisitorsGearBonus;

	@Test
	void isApplicableWhenWearingAnyInquisitors()
	{
		//noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.HEAD, ItemID.INQUISITORS_GREAT_HELM),
			singletonMap(EquipmentInventorySlot.BODY, ItemID.INQUISITORS_HAUBERK),
			singletonMap(EquipmentInventorySlot.LEGS, ItemID.INQUISITORS_PLATESKIRT),
			ImmutableMap.<EquipmentInventorySlot, Integer>builder()
				.put(EquipmentInventorySlot.HEAD, ItemID.INQUISITORS_GREAT_HELM)
				.put(EquipmentInventorySlot.BODY, ItemID.INQUISITORS_HAUBERK)
				.put(EquipmentInventorySlot.LEGS, ItemID.INQUISITORS_PLATESKIRT)
				.build()
		);
		assertTrue(inquisitorsGearBonus.isApplicable(context));
		assertTrue(inquisitorsGearBonus.isApplicable(context));
		assertTrue(inquisitorsGearBonus.isApplicable(context));
		assertTrue(inquisitorsGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWithoutInquisitors()
	{
		//noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			emptyMap(),
			singletonMap(EquipmentInventorySlot.BODY, ItemID.RUNE_PLATEBODY)
		);
		assertFalse(inquisitorsGearBonus.isApplicable(context));
		assertFalse(inquisitorsGearBonus.isApplicable(context));
	}

	@Test
	void warnsForNonCrush()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.SLASH),
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.RANGED),
			ofAttackType(AttackType.MAGIC)
		);

		assertEquals(GearBonuses.EMPTY, inquisitorsGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, inquisitorsGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, inquisitorsGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, inquisitorsGearBonus.compute(context));
		verify(context, times(4)).warn("Wearing inquisitor's armour without attacking on crush provides no bonuses.");
	}

	@Test
	void grantsBonusForHelm()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.HEAD, ItemID.INQUISITORS_GREAT_HELM)
		);

		assertEquals(GearBonuses.symmetric(1.005), inquisitorsGearBonus.compute(context));
	}

	@Test
	void grantsBonusForBody()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.BODY, ItemID.INQUISITORS_HAUBERK)
		);

		assertEquals(GearBonuses.symmetric(1.005), inquisitorsGearBonus.compute(context));
	}

	@Test
	void grantsBonusForLegs()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			singletonMap(EquipmentInventorySlot.LEGS, ItemID.INQUISITORS_PLATESKIRT)
		);

		assertEquals(GearBonuses.symmetric(1.005), inquisitorsGearBonus.compute(context));
	}

	@Test
	void grantsBonusForFullSet()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.<EquipmentInventorySlot, Integer>builder()
			.put(EquipmentInventorySlot.HEAD, ItemID.INQUISITORS_GREAT_HELM)
			.put(EquipmentInventorySlot.BODY, ItemID.INQUISITORS_HAUBERK)
			.put(EquipmentInventorySlot.LEGS, ItemID.INQUISITORS_PLATESKIRT)
			.build()
		);

		assertEquals(GearBonuses.symmetric(1.025), inquisitorsGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.UNDEAD;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SalveAmuletGearBonusTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private SalveAmuletGearBonus salveAmuletGearBonus;

	@Test
	void isApplicableWhenWearingSalveAmulet()
	{
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET_E),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETI),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETEI)
		);

		assertTrue(salveAmuletGearBonus.isApplicable(context));
		assertTrue(salveAmuletGearBonus.isApplicable(context));
		assertTrue(salveAmuletGearBonus.isApplicable(context));
		assertTrue(salveAmuletGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWithoutSalveAmulet()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(Collections.emptyMap());

		assertFalse(salveAmuletGearBonus.isApplicable(context));
	}

	@Test
	void warnsWhenFightingNonUndeadTarget()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributes.EMPTY);

		assertEquals(GearBonuses.EMPTY, salveAmuletGearBonus.compute(context));
		verify(context, times(1)).warn("Salve amulet against a non-undead target provides no bonuses.");
	}

	@Test
	void warnsWhenUsingUnimbuedSalveForRanged()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(UNDEAD);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET_E)
		);

		assertEquals(GearBonuses.EMPTY, salveAmuletGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, salveAmuletGearBonus.compute(context));
		verify(context, times(2)).warn("Unimbued salve amulets provide no bonuses for mage/ranged.");
	}

	@Test
	void warnsWhenUsingUnimbuedSalveForMagic()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(UNDEAD);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET_E)
		);

		assertEquals(GearBonuses.EMPTY, salveAmuletGearBonus.compute(context));
		assertEquals(GearBonuses.EMPTY, salveAmuletGearBonus.compute(context));
		verify(context, times(2)).warn("Unimbued salve amulets provide no bonuses for mage/ranged.");
	}

	@Test
	void providesCorrectBonusesForMelee()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(UNDEAD);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETI),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULET_E),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETEI)
		);

		assertEquals(GearBonuses.symmetric(7.0 / 6.0), salveAmuletGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(7.0 / 6.0), salveAmuletGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(6.0 / 5.0), salveAmuletGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(6.0 / 5.0), salveAmuletGearBonus.compute(context));
	}

	@Test
	void providesCorrectBonusesForRanged()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(UNDEAD);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETI),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETEI)
		);

		assertEquals(GearBonuses.symmetric(7.0 / 6.0), salveAmuletGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(6.0 / 5.0), salveAmuletGearBonus.compute(context));
	}

	@Test
	void providesCorrectBonusesForMage()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(UNDEAD);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETI),
			Collections.singletonMap(EquipmentInventorySlot.AMULET, ItemID.SALVE_AMULETEI)
		);

		assertEquals(GearBonuses.symmetric(1.15), salveAmuletGearBonus.compute(context));
		assertEquals(GearBonuses.symmetric(6.0 / 5.0), salveAmuletGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE1;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE2;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE3;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class VampyreBaneGearBonusTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private VampyreBaneGearBonus vampyreBaneGearBonus;

	@Test
	void isApplicableWhenUsingVampyrebaneAgainstVampyres()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.IVANDIS_FLAIL),
			ofItemId(ItemID.BLISTERWOOD_SICKLE),
			ofItemId(ItemID.BLISTERWOOD_FLAIL)
		);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			VAMPYRE1,
			VAMPYRE2,
			VAMPYRE3
		);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));

		assertTrue(vampyreBaneGearBonus.isApplicable(context));
		assertTrue(vampyreBaneGearBonus.isApplicable(context));
		assertTrue(vampyreBaneGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingVampyrebane()
	{
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SCYTHE_OF_VITUR));

		assertFalse(vampyreBaneGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableAgainstNonVampyres()
	{
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.BLISTERWOOD_FLAIL));
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributes.EMPTY);

		assertFalse(vampyreBaneGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingMelee()
	{
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.BLISTERWOOD_FLAIL));
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(VAMPYRE1);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(vampyreBaneGearBonus.isApplicable(context));
	}

	@Test
	void providesAppropriateBonuses()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.IVANDIS_FLAIL),
			ofItemId(ItemID.BLISTERWOOD_SICKLE),
			ofItemId(ItemID.BLISTERWOOD_FLAIL)
		);

		assertEquals(GearBonuses.of(1, 1.20), vampyreBaneGearBonus.compute(context));
		assertEquals(GearBonuses.of(1.05, 1.15), vampyreBaneGearBonus.compute(context));
		assertEquals(GearBonuses.of(1.05, 1.25), vampyreBaneGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofCombatStyle;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ChinchompaDistanceGearBonusTest
{

	private static final ItemStats CHINCHOMPA = ItemStats.builder()
		.itemId(ItemID.BLACK_CHINCHOMPA)
		.weaponCategory(WeaponCategory.CHINCHOMPAS)
		.build();

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private ChinchompaDistanceGearBonus chinchompaDistanceGearBonus;

	@Test
	void isApplicableWhenUsingChinchompas()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(CHINCHOMPA);

		assertTrue(chinchompaDistanceGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(chinchompaDistanceGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingChinchompas()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.TWISTED_BOW));

		assertFalse(chinchompaDistanceGearBonus.isApplicable(context));
	}

	@Test
	void givesCorrectBonusesForShortFuse()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofCombatStyle(CombatStyle.ACCURATE));
		when(context.get(ComputeInputs.ATTACK_DISTANCE)).thenReturn(1, 5, 9);

		assertEquals(GearBonuses.of(1.0, 1.0), chinchompaDistanceGearBonus.compute(context));
		assertEquals(GearBonuses.of(0.75, 1.0), chinchompaDistanceGearBonus.compute(context));
		assertEquals(GearBonuses.of(0.5, 1.0), chinchompaDistanceGearBonus.compute(context));
		verify(context, times(3)).warn("Chinchompa calculation does not support splash damage. Results listed are for a single target.");
	}

	@Test
	void givesCorrectBonusesForMediumFuse()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofCombatStyle(CombatStyle.RAPID));
		when(context.get(ComputeInputs.ATTACK_DISTANCE)).thenReturn(3, 4, 7);

		assertEquals(GearBonuses.of(0.75, 1.0), chinchompaDistanceGearBonus.compute(context));
		assertEquals(GearBonuses.of(1.0, 1.0), chinchompaDistanceGearBonus.compute(context));
		assertEquals(GearBonuses.of(0.75, 1.0), chinchompaDistanceGearBonus.compute(context));
		verify(context, times(3)).warn("Chinchompa calculation does not support splash damage. Results listed are for a single target.");
	}

	@Test
	void givesCorrectBonusesForLongFuse()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofCombatStyle(CombatStyle.LONGRANGE));
		when(context.get(ComputeInputs.ATTACK_DISTANCE)).thenReturn(-1, 6, 100);

		assertEquals(GearBonuses.of(0.5, 1.0), chinchompaDistanceGearBonus.compute(context));
		assertEquals(GearBonuses.of(0.75, 1.0), chinchompaDistanceGearBonus.compute(context));
		assertEquals(GearBonuses.of(1.0, 1.0), chinchompaDistanceGearBonus.compute(context));
		verify(context, times(3)).warn("Chinchompa calculation does not support splash damage. Results listed are for a single target.");
	}

}
package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.SpellMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.DEMON;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MageDemonbaneGearBonusTest
{

	@Mock
	private SpellMaxHitComputable spellMaxHitComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private MageDemonbaneGearBonus mageDemonbaneGearBonus;

	@Test
	void isApplicableWhenUsingDemonbaneSpells()
	{
		when(spellMaxHitComputable.isApplicable(context)).thenReturn(true);
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.INFERIOR_DEMONBANE,
			Spell.SUPERIOR_DEMONBANE,
			Spell.DARK_DEMONBANE
		);

		assertTrue(mageDemonbaneGearBonus.isApplicable(context));
		assertTrue(mageDemonbaneGearBonus.isApplicable(context));
		assertTrue(mageDemonbaneGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingMagic()
	{
		when(spellMaxHitComputable.isApplicable(context)).thenReturn(false);

		assertFalse(mageDemonbaneGearBonus.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingDemonbaneSpells()
	{
		when(spellMaxHitComputable.isApplicable(context)).thenReturn(true);
		when(context.get(ComputeInputs.SPELL)).thenReturn(Spell.FIRE_SURGE);

		assertFalse(mageDemonbaneGearBonus.isApplicable(context));
	}

	@Test
	void warnsWhenNotFightingDemons()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributes.EMPTY);

		assertEquals(GearBonuses.symmetric(0), mageDemonbaneGearBonus.compute(context));
		verify(context, times(1)).warn("Demonbane spells cannot be used against non-demons.");
	}

	@Test
	void providesCorrectBonusWithoutMarkOfDarkness()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DEMON);
		when(context.get(ComputeInputs.USING_MARK_OF_DARKNESS)).thenReturn(false);

		assertEquals(GearBonuses.of(1.2, 1.25), mageDemonbaneGearBonus.compute(context));
	}

	@Test
	void providesCorrectBonusWithMarkOfDarkness()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DEMON);
		when(context.get(ComputeInputs.USING_MARK_OF_DARKNESS)).thenReturn(true);

		assertEquals(GearBonuses.of(1.4, 1.25), mageDemonbaneGearBonus.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class WeaponComputableTest
{

	@Mock
	private ComputeContext context;

	@InjectMocks
	private WeaponComputable weaponComputable;

	@Test
	void returnsWeaponSlotItemStats()
	{
		ItemStats expected = ofItemId(ItemID.SCYTHE_OF_VITUR);
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.HEAD, ofItemId(ItemID.HELM_OF_NEITIZNOT),
			EquipmentInventorySlot.WEAPON, expected
		));

		assertEquals(expected, weaponComputable.compute(context));
	}

	@Test
	void returnsEmptyIfNoWeapon()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(Collections.emptyMap());

		assertEquals(ItemStats.EMPTY, weaponComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.defender.DefenderSkillsComputable;
import com.duckblade.osrs.dpscalc.calc.defender.DefenseRollComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DefenseRollComputableTest
{

	private static final Skills SKILLS = Skills.builder()
		.level(Skill.DEFENCE, 12)
		.level(Skill.MAGIC, 34)
		.build();

	private static final DefensiveBonuses BONUSES = DefensiveBonuses.builder()
		.defenseStab(12)
		.defenseSlash(34)
		.defenseCrush(56)
		.defenseRanged(78)
		.defenseMagic(90)
		.build();

	@Mock
	private DefenderSkillsComputable defenderSkillsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private DefenseRollComputable defenseRollComputable;

	@BeforeEach
	void setUp()
	{
		when(context.get(defenderSkillsComputable)).thenReturn(SKILLS);
		when(context.get(ComputeInputs.DEFENDER_BONUSES)).thenReturn(BONUSES);
	}

	@Test
	void isCorrectForMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertEquals((34 + 9) * (90 + 64), defenseRollComputable.compute(context));
	}

	@Test
	void isCorrectForRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals((12 + 9) * (78 + 64), defenseRollComputable.compute(context));
	}

	@Test
	void isCorrectForStab()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));

		assertEquals((12 + 9) * (12 + 64), defenseRollComputable.compute(context));
	}

	@Test
	void isCorrectForSlash()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertEquals((12 + 9) * (34 + 64), defenseRollComputable.compute(context));
	}

	@Test
	void isCorrectForCrush()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));

		assertEquals((12 + 9) * (56 + 64), defenseRollComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.defender.DefenderSkillsComputable;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TimeToKillComputableTest
{

	@Mock
	private DptComputable dptComputable;

	@Mock
	private DefenderSkillsComputable defenderSkillsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private TimeToKillComputable timeToKillComputable;

	@Test
	void givesInfinityOnZeroDps()
	{
		when(context.get(dptComputable)).thenReturn(0.0);

		assertEquals(-1, timeToKillComputable.getTicks(context));
	}

	@Test
	void givesTicksOnValidDps()
	{
		when(context.get(dptComputable)).thenReturn(1.0);
		when(context.get(defenderSkillsComputable)).thenReturn(ofSkill(Skill.HITPOINTS, 50));

		assertEquals(50, timeToKillComputable.getTicks(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.VoidLevel;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import net.runelite.api.EquipmentInventorySlot;
import static net.runelite.api.ItemID.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class VoidLevelComputableTest
{

	private static Map<EquipmentInventorySlot, Integer> equipmentMap(int helm, int body, int legs, int gloves)
	{
		return ImmutableMap.of(
			EquipmentInventorySlot.HEAD, helm,
			EquipmentInventorySlot.BODY, body,
			EquipmentInventorySlot.LEGS, legs,
			EquipmentInventorySlot.GLOVES, gloves
		);
	}

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private VoidLevelComputable voidLevelComputable;

	@Test
	void recognizesFullVoid()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.RANGED),
			ofAttackType(AttackType.MAGIC)
		);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			equipmentMap(VOID_MELEE_HELM, VOID_KNIGHT_TOP, VOID_KNIGHT_ROBE, VOID_KNIGHT_GLOVES),
			equipmentMap(VOID_RANGER_HELM_OR, VOID_KNIGHT_TOP, ELITE_VOID_ROBE, VOID_KNIGHT_GLOVES_L),
			equipmentMap(VOID_MAGE_HELM_L, ELITE_VOID_TOP, VOID_KNIGHT_ROBE_OR, VOID_KNIGHT_GLOVES)
		);

		assertEquals(VoidLevel.REGULAR, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.REGULAR, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.REGULAR, voidLevelComputable.compute(context));
	}

	@Test
	void recognizesEliteVoid()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.RANGED),
			ofAttackType(AttackType.MAGIC)
		);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			equipmentMap(VOID_MELEE_HELM_OR, ELITE_VOID_TOP, ELITE_VOID_ROBE_L, VOID_KNIGHT_GLOVES),
			equipmentMap(VOID_RANGER_HELM_L, ELITE_VOID_TOP_L, ELITE_VOID_ROBE_OR, VOID_KNIGHT_GLOVES_L),
			equipmentMap(VOID_MAGE_HELM, ELITE_VOID_TOP_OR, ELITE_VOID_ROBE, VOID_KNIGHT_GLOVES)
		);

		assertEquals(VoidLevel.ELITE, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.ELITE, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.ELITE, voidLevelComputable.compute(context));
	}

	@Test
	void returnsNoneWithNoVoid()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			equipmentMap(TORVA_FULL_HELM, TORVA_PLATEBODY, TORVA_PLATELEGS, FEROCIOUS_GLOVES)
		);

		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
	}

	@Test
	void warnsWhenMissingPartsOfVoid()
	{
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			equipmentMap(ARCHER_HELM, VOID_KNIGHT_TOP, VOID_KNIGHT_ROBE, VOID_KNIGHT_GLOVES),
			equipmentMap(VOID_MELEE_HELM, TORVA_PLATEBODY, TORVA_PLATELEGS, FEROCIOUS_GLOVES),
			equipmentMap(VOID_RANGER_HELM, ARMADYL_PLATEBODY, ARMADYL_PLATELEGS, VOID_KNIGHT_GLOVES),
			equipmentMap(VOID_MAGE_HELM, VOID_KNIGHT_TOP, VOID_KNIGHT_ROBE, TORMENTED_BRACELET)
		);

		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
		verify(context, times(4)).warn("Wearing incomplete void equipment provides no offensive bonuses.");
	}

	@Test
	void warnsWhenUsingWrongAttackStyle()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.RANGED),
			ofAttackType(AttackType.MAGIC),
			ofAttackType(AttackType.STAB)
			);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			equipmentMap(VOID_MELEE_HELM, VOID_KNIGHT_TOP, VOID_KNIGHT_ROBE, VOID_KNIGHT_GLOVES),
			equipmentMap(VOID_RANGER_HELM, VOID_KNIGHT_TOP, VOID_KNIGHT_ROBE, VOID_KNIGHT_GLOVES),
			equipmentMap(VOID_MAGE_HELM, VOID_KNIGHT_TOP, VOID_KNIGHT_ROBE, VOID_KNIGHT_GLOVES)
		);

		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
		assertEquals(VoidLevel.NONE, voidLevelComputable.compute(context));
		verify(context, times(3)).warn("Void helm does not matach attack style.");
	}

}
package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class EffectiveAttackLevelComputableTest
{

	@Mock
	private MeleeEffectiveAttackLevelComputable meleeComputable;

	@Mock
	private RangedEffectiveAttackLevelComputable rangedComputable;

	@Mock
	private MageEffectiveAttackLevelComputable mageComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private EffectiveAttackLevelComputable effectiveAttackLevelComputable;

	@Test
	void defersToMelee()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(meleeComputable)).thenReturn(45);

		assertEquals(45, effectiveAttackLevelComputable.compute(context));
	}

	@Test
	void defersToRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(rangedComputable)).thenReturn(23);

		assertEquals(23, effectiveAttackLevelComputable.compute(context));
	}

	@Test
	void defersToMage()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(mageComputable)).thenReturn(67);

		assertEquals(67, effectiveAttackLevelComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import java.util.Collections;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

class MageEffectiveAttackLevelComputableTest
{

	private final MageEffectiveAttackLevelComputable mageEffectiveAttackLevelComputable = new MageEffectiveAttackLevelComputable();

	@Test
	void providesCorrectParametersToBaseClass()
	{
		assertEquals(Skill.MAGIC, mageEffectiveAttackLevelComputable.getBaseSkill());
		assertEquals(Prayer.PrayerGroup.MAGE, mageEffectiveAttackLevelComputable.getPrayerGroup());
		assertEquals(Prayer.AUGURY.getAttackMod(), mageEffectiveAttackLevelComputable.getPrayerMultiplier().applyAsDouble(Prayer.AUGURY));
		assertEquals(9, mageEffectiveAttackLevelComputable.getBaseBonus());
		assertEquals(Collections.singletonMap(CombatStyle.ACCURATE, 2), mageEffectiveAttackLevelComputable.getCombatFocusBonuses());
	}

}
package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.gearbonus.AggregateGearBonusesComputable;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AttackRollComputableTest
{

	@Mock
	private EffectiveAttackLevelComputable effectiveAttackLevelComputable;

	@Mock
	private AttackBonusComputable attackBonusComputable;

	@Mock
	private AggregateGearBonusesComputable aggregateGearBonusesComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private AttackRollComputable attackRollComputable;

	@Test
	void computesAttackRollCorrectly()
	{
		when(context.get(effectiveAttackLevelComputable)).thenReturn(12);
		when(context.get(attackBonusComputable)).thenReturn(34);
		when(context.get(aggregateGearBonusesComputable)).thenReturn(GearBonuses.of(1.2, 1.4));

		assertEquals((int) (12 * (34 + 64) * 1.2), attackRollComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.google.common.collect.ImmutableMap;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

class MeleeEffectiveAttackLevelComputableTest
{

	private final MeleeEffectiveAttackLevelComputable meleeEffectiveAttackLevelComputable = new MeleeEffectiveAttackLevelComputable();

	@Test
	void providesCorrectParametersToBaseClass()
	{
		assertEquals(Skill.ATTACK, meleeEffectiveAttackLevelComputable.getBaseSkill());
		assertEquals(Prayer.PrayerGroup.MELEE, meleeEffectiveAttackLevelComputable.getPrayerGroup());
		assertEquals(Prayer.PIETY.getAttackMod(), meleeEffectiveAttackLevelComputable.getPrayerMultiplier().applyAsDouble(Prayer.PIETY));
		assertEquals(8, meleeEffectiveAttackLevelComputable.getBaseBonus());
		assertEquals(
			ImmutableMap.of(CombatStyle.ACCURATE, 3, CombatStyle.CONTROLLED, 1),
			meleeEffectiveAttackLevelComputable.getCombatFocusBonuses()
		);
	}

}
package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.AttackerItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AttackBonusComputableTest
{

	private static final ItemStats ITEM_STATS = ItemStats.builder()
		.accuracyStab(12)
		.accuracySlash(23)
		.accuracyCrush(34)
		.accuracyRanged(45)
		.accuracyMagic(56)
		.build();

	@Mock
	private AttackerItemStatsComputable attackerItemStatsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private AttackBonusComputable attackBonusComputable;

	@BeforeEach
	void setUp()
	{
		when(context.get(attackerItemStatsComputable)).thenReturn(ITEM_STATS);
	}

	@Test
	void handlesStabAttacks()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));

		assertEquals(ITEM_STATS.getAccuracyStab(), attackBonusComputable.compute(context));
	}

	@Test
	void handlesSlashAttacks()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertEquals(ITEM_STATS.getAccuracySlash(), attackBonusComputable.compute(context));
	}

	@Test
	void handlesCrushAttacks()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));

		assertEquals(ITEM_STATS.getAccuracyCrush(), attackBonusComputable.compute(context));
	}

	@Test
	void handlesRangedAttacks()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals(ITEM_STATS.getAccuracyRanged(), attackBonusComputable.compute(context));
	}

	@Test
	void handlesMagicAttacks()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertEquals(ITEM_STATS.getAccuracyMagic(), attackBonusComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import java.util.Collections;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

class RangedEffectiveAttackLevelComputableTest
{

	private final RangedEffectiveAttackLevelComputable rangedEffectiveAttackLevelComputable = new RangedEffectiveAttackLevelComputable();

	@Test
	void providesCorrectParametersToBaseClass()
	{
		assertEquals(Skill.RANGED, rangedEffectiveAttackLevelComputable.getBaseSkill());
		assertEquals(Prayer.PrayerGroup.RANGED, rangedEffectiveAttackLevelComputable.getPrayerGroup());
		assertEquals(Prayer.RIGOUR.getAttackMod(), rangedEffectiveAttackLevelComputable.getPrayerMultiplier().applyAsDouble(Prayer.RIGOUR));
		assertEquals(8, rangedEffectiveAttackLevelComputable.getBaseBonus());
		assertEquals(Collections.singletonMap(CombatStyle.ACCURATE, 3), rangedEffectiveAttackLevelComputable.getCombatFocusBonuses());
	}

}
package com.duckblade.osrs.dpscalc.calc.ammo;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AmmoSlotItemStatsComputableTest
{

	@Mock
	private AmmoItemStatsComputable ammoItemStatsComputable1, ammoItemStatsComputable2;

	@Mock
	private ComputeContext context;

	private AmmoSlotItemStatsComputable ammoSlotItemStatsComputable;

	@BeforeEach
	void setUp()
	{
		ammoSlotItemStatsComputable = new AmmoSlotItemStatsComputable(ImmutableSet.of(
			ammoItemStatsComputable1,
			ammoItemStatsComputable2
		));
	}

	@Test
	void defaultsToEmptyStatsIfNoneProvided()
	{
		when(ammoItemStatsComputable1.isApplicable(context)).thenReturn(false);
		when(ammoItemStatsComputable2.isApplicable(context)).thenReturn(false);
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.WEAPON, ofItemId(ItemID.SCYTHE_OF_VITUR)
		));

		assertEquals(ItemStats.EMPTY, ammoSlotItemStatsComputable.compute(context));
	}

	@Test
	void defaultsToAmmoSlotStatsIfNoSubcomponentsAreApplicable()
	{
		ItemStats ammo = ofItemId(ItemID.SCYTHE_OF_VITUR);
		when(ammoItemStatsComputable1.isApplicable(context)).thenReturn(false);
		when(ammoItemStatsComputable2.isApplicable(context)).thenReturn(false);
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.AMMO, ammo
		));

		assertEquals(ammo, ammoSlotItemStatsComputable.compute(context));
	}

	@Test
	void usesApplicableSubcomponent()
	{
		ItemStats ammo = ofItemId(ItemID.SCYTHE_OF_VITUR);
		when(ammoItemStatsComputable1.isApplicable(context)).thenReturn(false);
		when(ammoItemStatsComputable2.isApplicable(context)).thenReturn(true);
		when(context.get(ammoItemStatsComputable2)).thenReturn(ammo);

		assertEquals(ammo, ammoSlotItemStatsComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.ammo;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.google.common.collect.ImmutableMap;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class BlowpipeDartsItemStatsComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private BlowpipeDartsItemStatsComputable blowpipeDartsItemStatsComputable;

	@Test
	void isApplicableWhenUsingBlowpipe()
	{
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.TOXIC_BLOWPIPE));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertTrue(blowpipeDartsItemStatsComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(blowpipeDartsItemStatsComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingBlowpipe()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SCYTHE_OF_VITUR));

		assertFalse(blowpipeDartsItemStatsComputable.isApplicable(context));
	}

	@Test
	void mergesAmmoSlotAndBlowpipeDartsAppropriately()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.AMMO, ItemStats.builder()
				.prayer(3)
				.build()
		));
		when(context.get(ComputeInputs.BLOWPIPE_DARTS)).thenReturn(
			ItemStats.builder()
				.strengthRanged(1)
				.accuracyRanged(2)
				.build()
		);

		ItemStats expected = ItemStats.builder()
			.strengthRanged(1)
			.accuracyRanged(2)
			.prayer(3)
			.build();
		assertEquals(expected, blowpipeDartsItemStatsComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.ammo;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.google.common.collect.ImmutableMap;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AmmolessRangedAmmoItemStatsComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private AmmolessRangedAmmoItemStatsComputable ammolessRangedAmmoItemStatsComputable;

	@Test
	void isApplicableWhenUsingCrystalBows()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.CRYSTAL_BOW),
			ofItemId(ItemID.BOW_OF_FAERDHINEN),
			ofItemId(ItemID.BOW_OF_FAERDHINEN_C_25869)
		);

		assertTrue(ammolessRangedAmmoItemStatsComputable.isApplicable(context));
		assertTrue(ammolessRangedAmmoItemStatsComputable.isApplicable(context));
		assertTrue(ammolessRangedAmmoItemStatsComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(ammolessRangedAmmoItemStatsComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenUsingRegularBow()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.MAGIC_SHORTBOW));

		assertFalse(ammolessRangedAmmoItemStatsComputable.isApplicable(context));
	}

	@Test
	void zerosRangedStatsFromAmmoSlot()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.AMMO, ItemStats.builder()
				.strengthRanged(15)
				.accuracyRanged(10)
				.prayer(5)
				.build()
		));

		ItemStats expected = ItemStats.builder()
			.prayer(5)
			.build();
		assertEquals(expected, ammolessRangedAmmoItemStatsComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.compute;

import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

class ComputableTest
{

	private static class TestClass1 implements Computable<String>
	{
		@Override
		public String compute(ComputeContext context)
		{
			throw new IllegalStateException();
		}
	}

	private static class TestClass2Computable implements Computable<String>
	{
		@Override
		public String compute(ComputeContext context)
		{
			throw new IllegalStateException();
		}
	}

	@Test
	void defaultKeyIsClassName()
	{
		assertEquals("TestClass1", new TestClass1().key());
	}

	@Test
	void defaultKeyRemovesComputableSuffix()
	{
		assertEquals("TestClass2", new TestClass2Computable().key());
	}

}
package com.duckblade.osrs.dpscalc.calc.compute;

import com.duckblade.osrs.dpscalc.calc.exceptions.DpsComputeException;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.ComputeInput;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.fail;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.atMostOnce;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ComputeContextTest
{

	@Mock
	private Computable<String> computable;

	private ComputeContext context;

	@BeforeEach
	void setUp()
	{
		context = new ComputeContext();
	}

	@Test
	void usesComputableComputeForUnknownValues()
	{
		when(computable.key()).thenReturn("MOCK_KEY");
		when(computable.compute(context)).thenReturn("MOCK_VALUE");

		assertEquals("MOCK_VALUE", context.get(computable));
	}

	@Test
	void usesCacheForKnownValues()
	{
		when(computable.key()).thenReturn("MOCK_KEY");
		when(computable.compute(context)).thenReturn("MOCK_VALUE");

		assertEquals("MOCK_VALUE", context.get(computable));
		assertEquals("MOCK_VALUE", context.get(computable));

		verify(computable, atMostOnce()).compute(context);
	}

	@Test
	void wrapsExceptionsInDpsComputeException()
	{
		when(computable.compute(context)).thenThrow(RuntimeException.class);
		assertThrows(DpsComputeException.class, () -> context.get(computable));
	}

	@Test
	void doesNotWrapNestedDpsComputeExceptions()
	{
		when(computable.compute(context)).thenThrow(DpsComputeException.class);

		try
		{
			context.get(computable);
			fail();
		}
		catch (DpsComputeException e)
		{
			if (e.getCause() instanceof DpsComputeException)
			{
				fail();
			}
		}
	}

	@Test
	void doesNotRecomputeManualEntries()
	{
		when(computable.key()).thenReturn("MOCK_KEY");
		context.put(computable, "MOCK_VALUE");

		assertEquals("MOCK_VALUE", context.get(computable));
		verify(computable, never()).compute(context);
	}

	@Test
	void combinesAllWarnings()
	{
		context.warn("WARN1");
		context.warn("WARN2");

		assertEquals(Arrays.asList("WARN1", "WARN2"), context.getWarnings());
	}

	@Test
	void initializesWithAllValuesFromInput()
	{
		Skills attackerSkills = ofSkill(Skill.HITPOINTS, 100);
		Map<EquipmentInventorySlot, ItemStats> attackerEquipment = Collections.singletonMap(EquipmentInventorySlot.WEAPON, ofItemId(100));
		Set<Prayer> attackerPrayers = Collections.singleton(Prayer.PIETY);
		AttackStyle attackStyle = ofAttackType(AttackType.RANGED);
		Spell spell = Spell.FIRE_SURGE;
		ItemStats blowpipeDarts = ofItemId(ItemID.DRAGON_DART);
		Skills defenderSkills = ofSkill(Skill.DEFENCE, 100);
		DefensiveBonuses defensiveBonuses = DefensiveBonuses.builder().defenseRanged(100).build();
		DefenderAttributes defenderAttributes = DefenderAttributes.builder().size(100).build();
		boolean onSlayerTask = true;
		boolean usingChargeSpell = true;
		boolean usingMarkOfDarkness = true;
		boolean inWilderness = true;

		ComputeInput input = ComputeInput.builder()
			.attackerSkills(attackerSkills)
			.attackerItems(attackerEquipment)
			.attackerPrayers(attackerPrayers)
			.attackStyle(attackStyle)
			.spell(spell)
			.blowpipeDarts(blowpipeDarts)
			.defenderSkills(defenderSkills)
			.defenderBonuses(defensiveBonuses)
			.defenderAttributes(defenderAttributes)
			.onSlayerTask(onSlayerTask)
			.usingChargeSpell(usingChargeSpell)
			.usingMarkOfDarkness(usingMarkOfDarkness)
			.inWilderness(inWilderness)
			.build();
		context = new ComputeContext(input);

		assertEquals(attackerSkills, context.get(ComputeInputs.ATTACKER_SKILLS));
		assertEquals(attackerEquipment, context.get(ComputeInputs.ATTACKER_ITEMS));
		assertEquals(attackerPrayers, context.get(ComputeInputs.ATTACKER_PRAYERS));
		assertEquals(attackStyle, context.get(ComputeInputs.ATTACK_STYLE));
		assertEquals(spell, context.get(ComputeInputs.SPELL));
		assertEquals(blowpipeDarts, context.get(ComputeInputs.BLOWPIPE_DARTS));
		assertEquals(defenderSkills, context.get(ComputeInputs.DEFENDER_SKILLS));
		assertEquals(defensiveBonuses, context.get(ComputeInputs.DEFENDER_BONUSES));
		assertEquals(defenderAttributes, context.get(ComputeInputs.DEFENDER_ATTRIBUTES));
		assertEquals(onSlayerTask, context.get(ComputeInputs.ON_SLAYER_TASK));
		assertEquals(usingChargeSpell, context.get(ComputeInputs.USING_CHARGE_SPELL));
		assertEquals(usingMarkOfDarkness, context.get(ComputeInputs.USING_MARK_OF_DARKNESS));
		assertEquals(inWilderness, context.get(ComputeInputs.IN_WILDERNESS));
	}

}
package com.duckblade.osrs.dpscalc.calc.compute;

import com.duckblade.osrs.dpscalc.calc.exceptions.MissingInputException;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ComputeInputsTest
{

	@Mock
	private ComputeContext context;

	@Test
	void usesProvidedKeyAsComputeKey()
	{
		ComputeInputs<String> input = ComputeInputs.of("MOCK_Key");
		assertEquals("MOCK_Key", input.key());
	}

	@Test
	void throwsExceptionWhenNoDefault()
	{
		ComputeInputs<String> noDefaultInput = ComputeInputs.of("MOCK_NoDefault");
		assertThrows(MissingInputException.class, () -> noDefaultInput.compute(context));
	}

	@Test
	void returnsDefaultWhenSupplied()
	{
		ComputeInputs<String> defaultInput = ComputeInputs.of("MOCK_Default", "DefaultValue");
		assertEquals("DefaultValue", defaultInput.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.compute;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ComputeOutputTest
{

	@Mock
	private ComputeContext context;

	@Test
	void usesProvidedKeyAsComputeKey()
	{
		ComputeOutput<String> output = ComputeOutput.of("MOCK_Key");
		assertEquals("MOCK_Key", output.key());
	}

	@Test
	void returnsNullWhenComputed()
	{
		ComputeOutput<String> missingOutput = ComputeOutput.of("MOCK_Missing");
		assertNull(missingOutput.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ColossalBladeDptComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private HitChanceComputable hitChanceComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;

	@Mock
	private MaxHitLimitComputable maxHitLimitComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private ColossalBladeDptComputable colossalBladeDptComputable;

	@Test
	void isApplicableWhenUsingColossalBlade()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.COLOSSAL_BLADE));

		assertTrue(colossalBladeDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenUsingMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(colossalBladeDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingColossalBlade()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SCYTHE_OF_VITUR));

		assertFalse(colossalBladeDptComputable.isApplicable(context));
	}

	@Test
	void increasesMaxHitByDoubleSize()
	{
		when(context.get(hitChanceComputable)).thenReturn(0.75);
		when(context.get(attackSpeedComputable)).thenReturn(2);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(15);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.builder().size(1).build(),
			DefenderAttributes.builder().size(3).build(),
			DefenderAttributes.builder().size(5).build()
		);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));

		assertEquals(BaseHitDptComputable.byComponents(0.75, 15 + 2, 2), colossalBladeDptComputable.compute(context));
		assertEquals(BaseHitDptComputable.byComponents(0.75, 15 + 6, 2), colossalBladeDptComputable.compute(context));
		assertEquals(BaseHitDptComputable.byComponents(0.75, 15 + 10, 2), colossalBladeDptComputable.compute(context));
	}

	@Test
	void boundsSizeBetween1And5()
	{
		when(context.get(hitChanceComputable)).thenReturn(0.75);
		when(context.get(attackSpeedComputable)).thenReturn(2);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(15);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.builder().size(0).build(),
			DefenderAttributes.builder().size(6).build()
		);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));

		assertEquals(BaseHitDptComputable.byComponents(0.75, 15 + 2, 2), colossalBladeDptComputable.compute(context));
		assertEquals(BaseHitDptComputable.byComponents(0.75, 15 + 10, 2), colossalBladeDptComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class VeracsDptComputableTest
{

	@Mock
	private BaseHitDptComputable baseHitDptComputable;

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private BaseMaxHitComputable baseMaxHitComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private VeracsDptComputable veracsDptComputable;

	@Test
	void isNotApplicableWhenCastingSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(veracsDptComputable.isApplicable(context));
	}

	@Test
	void isApplicableWhenUsingVeracs()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.WEAPON, ItemID.VERACS_FLAIL,
			EquipmentInventorySlot.HEAD, ItemID.VERACS_HELM_50,
			EquipmentInventorySlot.BODY, ItemID.VERACS_BRASSARD_100,
			EquipmentInventorySlot.LEGS, ItemID.VERACS_PLATESKIRT_25
		));

		assertTrue(veracsDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingVeracs()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.CRUSH));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.VERACS_FLAIL_0,
				EquipmentInventorySlot.HEAD, ItemID.VERACS_HELM_50,
				EquipmentInventorySlot.BODY, ItemID.VERACS_BRASSARD_100,
				EquipmentInventorySlot.LEGS, ItemID.VERACS_PLATESKIRT_25
			),
			Collections.emptyMap()
		);

		assertFalse(veracsDptComputable.isApplicable(context));
		assertFalse(veracsDptComputable.isApplicable(context));
	}

	@Test
	void appliesSpecialEffectAppropriately()
	{
		when(context.get(baseHitDptComputable)).thenReturn(4.0);
		when(context.get(baseMaxHitComputable)).thenReturn(16);
		when(context.get(attackSpeedComputable)).thenReturn(5);

		// byComponents takes avg hit by max / 2, and veracs gives +1 to hit = calc with +2 to max
		double expectedEffectDps = BaseHitDptComputable.byComponents(1.0, 18, 5);
		assertEquals(0.75 * 4.0 + 0.25 * expectedEffectDps, veracsDptComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ScytheDptComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private BaseHitDptComputable baseHitDptComputable;

	@Mock
	private HitChanceComputable hitChanceComputable;

	@Mock
	private PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;

	@Mock
	private BaseMaxHitComputable baseMaxHitComputable;

	@Mock
	private MaxHitLimitComputable maxHitLimitComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private ScytheDptComputable scytheDptComputable;

	@Test
	void isNotApplicableWhenCastingSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(scytheDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingScythe()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.SCYTHE),
			ofItemId(-1)
		);

		assertFalse(scytheDptComputable.isApplicable(context));
		assertFalse(scytheDptComputable.isApplicable(context));
		assertFalse(scytheDptComputable.isApplicable(context));
	}

	@Test
	void isApplicableWhenUsingScythe()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.SCYTHE_OF_VITUR),
			ofItemId(ItemID.HOLY_SCYTHE_OF_VITUR),
			ofItemId(ItemID.SANGUINE_SCYTHE_OF_VITUR),
			ofItemId(ItemID.SCYTHE_OF_VITUR_UNCHARGED)
		);

		assertTrue(scytheDptComputable.isApplicable(context));
		assertTrue(scytheDptComputable.isApplicable(context));
		assertTrue(scytheDptComputable.isApplicable(context));
		assertTrue(scytheDptComputable.isApplicable(context));
	}

	@Test
	void warnsAgainstSize1Targets()
	{
		when(context.get(baseHitDptComputable)).thenReturn(1.5);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributesUtil.SIZE_1);

		assertEquals(1.5, scytheDptComputable.compute(context));
		verify(context).warn("Using the Scythe of vitur against size 1 targets is inefficient unless hitting multiple enemies.");
	}

	@Test
	void appliesSecondHitAgainstSize2Targets()
	{
		when(context.get(baseHitDptComputable)).thenReturn(1.5);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributesUtil.SIZE_2);
		when(context.get(hitChanceComputable)).thenReturn(0.5);
		when(context.get(baseMaxHitComputable)).thenReturn(4);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(4);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));
		when(context.get(attackSpeedComputable)).thenReturn(5);

		double expectedSecondHitDps = BaseHitDptComputable.byComponents(0.5, 2, 5);
		assertEquals(1.5 + expectedSecondHitDps, scytheDptComputable.compute(context));
		verify(context).put(ScytheDptComputable.SCY_MAX_HIT_2, 2);
		verify(context).put(ScytheDptComputable.SCY_MAX_HIT_SUM, 6);
	}

	@Test
	void appliesSecondAndThirdHitAgainstSize3PlusTargets()
	{
		when(context.get(baseHitDptComputable)).thenReturn(1.5);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributesUtil.SIZE_3, DefenderAttributesUtil.SIZE_4);
		when(context.get(hitChanceComputable)).thenReturn(0.5);
		when(context.get(baseMaxHitComputable)).thenReturn(4);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(4);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));
		when(context.get(attackSpeedComputable)).thenReturn(5);

		double expectedSecondHitDps = BaseHitDptComputable.byComponents(0.5, 2, 5);
		double expectedThirdHitDps = BaseHitDptComputable.byComponents(0.5, 1, 5);
		assertEquals(1.5 + expectedSecondHitDps + expectedThirdHitDps, scytheDptComputable.compute(context));
		assertEquals(1.5 + expectedSecondHitDps + expectedThirdHitDps, scytheDptComputable.compute(context));
		verify(context, times(2)).put(ScytheDptComputable.SCY_MAX_HIT_2, 2);
		verify(context, times(2)).put(ScytheDptComputable.SCY_MAX_HIT_3, 1);
		verify(context, times(2)).put(ScytheDptComputable.SCY_MAX_HIT_SUM, 7);
	}

	@Test
	void respectsMaxHitLimiters()
	{
		when(context.get(baseHitDptComputable)).thenReturn(1.5);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributesUtil.SIZE_3, DefenderAttributesUtil.SIZE_4);
		when(context.get(hitChanceComputable)).thenReturn(0.5);
		when(context.get(baseMaxHitComputable)).thenReturn(1);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(4);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenReturn(1);
		when(context.get(attackSpeedComputable)).thenReturn(5);

		double expectedSecondHitDps = BaseHitDptComputable.byComponents(0.5, 1, 5);
		double expectedThirdHitDps = BaseHitDptComputable.byComponents(0.5, 1, 5);
		assertEquals(1.5 + expectedSecondHitDps + expectedThirdHitDps, scytheDptComputable.compute(context));
		assertEquals(1.5 + expectedSecondHitDps + expectedThirdHitDps, scytheDptComputable.compute(context));
		verify(context, times(2)).put(ScytheDptComputable.SCY_MAX_HIT_2, 1);
		verify(context, times(2)).put(ScytheDptComputable.SCY_MAX_HIT_3, 1);
		verify(context, times(2)).put(ScytheDptComputable.SCY_MAX_HIT_SUM, 3);
	}
}
package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DharoksDptComputableTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private HitChanceComputable hitChanceComputable;

	@Mock
	private MaxHitLimitComputable maxHitLimitComputable;

	@Mock
	private PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private DharoksDptComputable dharoksDptComputable;

	@Test
	void isNotApplicableWhenCastingSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(dharoksDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWithoutDharoks()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.DHAROKS_GREATAXE,
				EquipmentInventorySlot.HEAD, ItemID.DHAROKS_HELM,
				EquipmentInventorySlot.BODY, ItemID.DHAROKS_PLATEBODY_0,
				EquipmentInventorySlot.LEGS, ItemID.DHAROKS_PLATELEGS
			),
			Collections.emptyMap()
		);

		assertFalse(dharoksDptComputable.isApplicable(context));
		assertFalse(dharoksDptComputable.isApplicable(context));
	}

	@Test
	void isApplicableWithDharoks()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.DHAROKS_GREATAXE_75,
				EquipmentInventorySlot.HEAD, ItemID.DHAROKS_HELM_25,
				EquipmentInventorySlot.BODY, ItemID.DHAROKS_PLATEBODY_100,
				EquipmentInventorySlot.LEGS, ItemID.DHAROKS_PLATELEGS
			)
		);

		assertTrue(dharoksDptComputable.isApplicable(context));
	}

	@Test
	void increasesMaxHitByAppropriateAmountAt1HpWith99Max()
	{
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(100);
		when(context.get(hitChanceComputable)).thenReturn(1.0);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));

		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			Skills.builder()
				.level(Skill.HITPOINTS, 99)
				.boost(Skill.HITPOINTS, -98)
				.build()
		);
		double dharokMod = 1.9702;

		assertEquals(BaseHitDptComputable.byComponents(1.0, (int) (100 * dharokMod), 5), dharoksDptComputable.compute(context));
		verify(context).put(DharoksDptComputable.DHAROKS_MAX_HIT, (int) (100 * dharokMod));
	}

	@Test
	void increasesMaxHitByAppropriateAmountAt99HpWith99Max()
	{
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(100);
		when(context.get(hitChanceComputable)).thenReturn(1.0);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));

		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(ofSkill(Skill.HITPOINTS, 99));
		double dharokMod = 1.0;

		assertEquals(BaseHitDptComputable.byComponents(1.0, (int) (100 * dharokMod), 5), dharoksDptComputable.compute(context));
		verify(context).put(DharoksDptComputable.DHAROKS_MAX_HIT, (int) (100 * dharokMod));
	}

	@Test
	void increasesMaxHitByAppropriateAmountAt25HpWith50Max()
	{
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(100);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));
		when(context.get(hitChanceComputable)).thenReturn(1.0);
		when(context.get(attackSpeedComputable)).thenReturn(5);

		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			Skills.builder()
				.level(Skill.HITPOINTS, 50)
				.boost(Skill.HITPOINTS, -25)
				.build()
		);
		double dharokMod = 1.125;

		assertEquals(BaseHitDptComputable.byComponents(1.0, (int) (100 * dharokMod), 5), dharoksDptComputable.compute(context));
		verify(context).put(DharoksDptComputable.DHAROKS_MAX_HIT, (int) (100 * dharokMod));
	}

	@Test
	void respectsMaxHitLimiters()
	{
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(100);
		when(context.get(hitChanceComputable)).thenReturn(1.0);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenReturn(5);

		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			Skills.builder()
				.level(Skill.HITPOINTS, 99)
				.boost(Skill.HITPOINTS, -98)
				.build()
		);

		assertEquals(BaseHitDptComputable.byComponents(1.0, 5, 5), dharoksDptComputable.compute(context));
		verify(context).put(DharoksDptComputable.DHAROKS_MAX_HIT, 5);
	}

}
package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.anyString;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class OsmumtensFangDptComputableTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private BaseMaxHitComputable baseMaxHitComputable;

	@Mock
	private HitChanceComputable hitChanceComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private OsmumtensFangDptComputable osmumtensFangDptComputable;

	@Test
	void isApplicableWhenUsingFang()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, ItemID.OSMUMTENS_FANG),
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, ItemID.OSMUMTENS_FANG_OR)
		);

		assertTrue(osmumtensFangDptComputable.isApplicable(context));
		assertTrue(osmumtensFangDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingFang()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.MAGIC),
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.CRUSH)
		);
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, ItemID.SCYTHE_OF_VITUR),
			Collections.singletonMap(EquipmentInventorySlot.WEAPON, -1)
		);

		assertFalse(osmumtensFangDptComputable.isApplicable(context));
		assertFalse(osmumtensFangDptComputable.isApplicable(context));
		assertFalse(osmumtensFangDptComputable.isApplicable(context));
	}

	@Test
	void appliesAccuracyDoubleRollEffect()
	{
		when(context.get(baseMaxHitComputable)).thenReturn(15);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(context.get(MaxHitLimitComputable.LIMIT_APPLIED)).thenReturn(false);
		when(context.get(hitChanceComputable)).thenReturn(
			1.0,
			0.5,
			0.25
		);

		assertEquals(BaseHitDptComputable.byComponents(1.0, 15, 5), osmumtensFangDptComputable.compute(context));
		assertEquals(BaseHitDptComputable.byComponents(0.75, 15, 5), osmumtensFangDptComputable.compute(context));
		assertEquals(BaseHitDptComputable.byComponents(0.4375, 15, 5), osmumtensFangDptComputable.compute(context));
		verify(context, never()).warn(anyString());
	}

	@Test
	void warnsWhenMaxHitLimitInEffect()
	{
		when(context.get(baseMaxHitComputable)).thenReturn(15);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(context.get(hitChanceComputable)).thenReturn(1.0);
		when(context.get(MaxHitLimitComputable.LIMIT_APPLIED)).thenReturn(true);

		assertEquals(BaseHitDptComputable.byComponents(1.0, 15, 5), osmumtensFangDptComputable.compute(context));
		verify(context, times(1)).warn("Max hit may be inaccurate due to conflicting effects of a max hit limiter and fang max hit clamping.");
	}

}
package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class KarilsDptComputableTest
{

	@Mock
	private BaseHitDptComputable baseHitDptComputable;

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private HitChanceComputable hitChanceComputable;

	@Mock
	private PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;

	@Mock
	private MaxHitLimitComputable maxHitLimitComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private KarilsDptComputable karilsDptComputable;

	@Test
	void isNotApplicableWhenCastingSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(karilsDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWithoutKarilsAndDamned()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.KARILS_CROSSBOW,
				EquipmentInventorySlot.HEAD, ItemID.KARILS_COIF,
				EquipmentInventorySlot.BODY, ItemID.KARILS_LEATHERTOP,
				EquipmentInventorySlot.LEGS, ItemID.KARILS_LEATHERSKIRT
			),
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.KARILS_CROSSBOW,
				EquipmentInventorySlot.HEAD, ItemID.KARILS_COIF_0,
				EquipmentInventorySlot.BODY, ItemID.KARILS_LEATHERTOP,
				EquipmentInventorySlot.LEGS, ItemID.KARILS_LEATHERSKIRT,
				EquipmentInventorySlot.AMULET, ItemID.AMULET_OF_THE_DAMNED_FULL
			),
			Collections.emptyMap()
		);

		assertFalse(karilsDptComputable.isApplicable(context));
		verify(context, times(1)).warn("Karil's equipment only provides a beneficial set effect with the Amulet of the damned.");
		assertFalse(karilsDptComputable.isApplicable(context));
		assertFalse(karilsDptComputable.isApplicable(context));
	}

	@Test
	void isApplicableWithKarilsAndDamned()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.KARILS_CROSSBOW_75,
				EquipmentInventorySlot.HEAD, ItemID.KARILS_COIF_50,
				EquipmentInventorySlot.BODY, ItemID.KARILS_LEATHERTOP_25,
				EquipmentInventorySlot.LEGS, ItemID.KARILS_LEATHERSKIRT,
				EquipmentInventorySlot.AMULET, ItemID.AMULET_OF_THE_DAMNED_FULL
			)
		);

		assertTrue(karilsDptComputable.isApplicable(context));
	}

	@Test
	void addsSecondHitToDps()
	{
		when(context.get(baseHitDptComputable)).thenReturn(4.0);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(50);
		when(context.get(hitChanceComputable)).thenReturn(0.5);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));

		double karilsEffectDps = BaseHitDptComputable.byComponents(0.5, 75, 5);
		assertEquals(0.75 * 4.0 + 0.25 * karilsEffectDps, karilsDptComputable.compute(context));
		verify(context).put(KarilsDptComputable.KARILS_MAX_HIT, 75);
	}

	@Test
	void respectsMaxHitLimiters()
	{
		when(context.get(baseHitDptComputable)).thenReturn(4.0);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(50);
		when(context.get(hitChanceComputable)).thenReturn(0.5);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenReturn(5);

		double karilsEffectDps = BaseHitDptComputable.byComponents(0.5, 5, 5);
		assertEquals(0.75 * 4.0 + 0.25 * karilsEffectDps, karilsDptComputable.compute(context));
		verify(context).put(KarilsDptComputable.KARILS_MAX_HIT, 5);
	}

}
package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class KerisDptComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private BaseHitDptComputable baseHitDptComputable;

	@Mock
	private HitChanceComputable hitChanceComputable;

	@Mock
	private PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;

	@Mock
	private MaxHitLimitComputable maxHitLimitComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private KerisDptComputable kerisDptComputable;

	@Test
	void isNotApplicableWhenCastingSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertFalse(kerisDptComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingKerisAgainstKalphite()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.KERIS),
			ofItemId(ItemID.SCYTHE_OF_VITUR)
		);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributesUtil.DRAGON,
			DefenderAttributesUtil.KALPHITE
		);

		assertFalse(kerisDptComputable.isApplicable(context));
		assertFalse(kerisDptComputable.isApplicable(context));
	}

	@Test
	void isApplicableWhenUsingKerisAgainstKalphite()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.KERIS),
			ofItemId(ItemID.KERIS_PARTISAN),
			ofItemId(ItemID.KERISP)
		);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(DefenderAttributesUtil.KALPHITE);

		assertTrue(kerisDptComputable.isApplicable(context));
		assertTrue(kerisDptComputable.isApplicable(context));
		assertTrue(kerisDptComputable.isApplicable(context));
	}

	@Test
	void appliesTripleHitAppropriately()
	{
		when(context.get(baseHitDptComputable)).thenReturn(4.0);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(50);
		when(context.get(hitChanceComputable)).thenReturn(0.5);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenAnswer(i -> i.getArgument(0));

		double kerisEffectDps = BaseHitDptComputable.byComponents(0.5, 150, 5);
		assertEquals((50.0 / 51.0) * 4.0 + (1.0 / 51.0) * kerisEffectDps, kerisDptComputable.compute(context));
		verify(context).put(KerisDptComputable.KERIS_MAX_HIT, 150);
	}

	@Test
	void respectsMaxHitLimiters()
	{
		when(context.get(baseHitDptComputable)).thenReturn(4.0);
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(50);
		when(context.get(hitChanceComputable)).thenReturn(0.5);
		when(context.get(attackSpeedComputable)).thenReturn(5);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenReturn(5);

		double kerisEffectDps = BaseHitDptComputable.byComponents(0.5, 5, 5);
		assertEquals((50.0 / 51.0) * 4.0 + (1.0 / 51.0) * kerisEffectDps, kerisDptComputable.compute(context));
		verify(context).put(KerisDptComputable.KERIS_MAX_HIT, 5);
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class EquipmentItemIdsComputableTest
{

	@Mock
	private ComputeContext context;

	@InjectMocks
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Test
	void mapsItemStatsToItemIDs()
	{
		when(context.get(ComputeInputs.ATTACKER_ITEMS)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.HEAD, ofItemId(ItemID.TORVA_FULL_HELM),
			EquipmentInventorySlot.BODY, ofItemId(ItemID.TORVA_PLATEBODY),
			EquipmentInventorySlot.LEGS, ofItemId(ItemID.TORVA_PLATELEGS),
			EquipmentInventorySlot.WEAPON, ofItemId(ItemID.SCYTHE_OF_VITUR),
			EquipmentInventorySlot.RING, ofItemId(ItemID.BERSERKER_RING)
		));

		// also should fill unspecified slots with default value
		int defaultId = ItemStats.EMPTY.getItemId();
		Map<EquipmentInventorySlot, Integer> expected = ImmutableMap.<EquipmentInventorySlot, Integer>builder()
			.put(EquipmentInventorySlot.HEAD, ItemID.TORVA_FULL_HELM)
			.put(EquipmentInventorySlot.BODY, ItemID.TORVA_PLATEBODY)
			.put(EquipmentInventorySlot.LEGS, ItemID.TORVA_PLATELEGS)
			.put(EquipmentInventorySlot.WEAPON, ItemID.SCYTHE_OF_VITUR)
			.put(EquipmentInventorySlot.RING, ItemID.BERSERKER_RING)
			.put(EquipmentInventorySlot.CAPE, defaultId)
			.put(EquipmentInventorySlot.AMMO, defaultId)
			.put(EquipmentInventorySlot.BOOTS, defaultId)
			.put(EquipmentInventorySlot.AMULET, defaultId)
			.put(EquipmentInventorySlot.GLOVES, defaultId)
			.put(EquipmentInventorySlot.SHIELD, defaultId)
			.build();
		assertEquals(expected, equipmentItemIdsComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class BaseHitDptComputableTest
{

	@Mock
	private HitChanceComputable hitChanceComputable;

	@Mock
	private BaseMaxHitComputable baseMaxHitComputable;

	@Mock
	private AttackSpeedComputable attackSpeedComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private BaseHitDptComputable baseHitDptComputable;

	@Test
	void computePassesChildrenToByComponents()
	{
		when(context.get(hitChanceComputable)).thenReturn(3.0);
		when(context.get(baseMaxHitComputable)).thenReturn(12);
		when(context.get(attackSpeedComputable)).thenReturn(4);

		assertEquals(BaseHitDptComputable.byComponents(3, 12, 4), baseHitDptComputable.compute(context));
	}

	@Test
	void byComponentsReturnsCorrectResults()
	{
		double hitChance = 0.5;
		int maxHit = 50;
		int attackSpeed = 5;

		assertEquals((hitChance * maxHit) / (2.0 * attackSpeed), BaseHitDptComputable.byComponents(hitChance, maxHit, attackSpeed));
	}

}
package com.duckblade.osrs.dpscalc.calc.defender;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.defender.skills.SkillScaling;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import com.google.common.collect.ImmutableSet;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.any;
import org.mockito.Mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DefenderSkillsComputableTest
{

	@Mock
	private SkillScaling skillScaling1, skillScaling2;

	@Mock
	private ComputeContext context;

	private DefenderSkillsComputable defenderSkillsComputable;

	@BeforeEach
	void setUp()
	{
		defenderSkillsComputable = new DefenderSkillsComputable(
			ImmutableSet.of(
				skillScaling1,
				skillScaling2
			)
		);
	}

	@Test
	void defaultsToInputWhenNonApplicable()
	{
		when(skillScaling1.isApplicable(context)).thenReturn(false);
		when(skillScaling2.isApplicable(context)).thenReturn(false);
		when(context.get(ComputeInputs.DEFENDER_SKILLS)).thenReturn(ofSkill(Skill.HITPOINTS, 50));

		assertEquals(ofSkill(Skill.HITPOINTS, 50), defenderSkillsComputable.compute(context));
		verify(skillScaling1, never()).compute(any());
		verify(skillScaling2, never()).compute(any());
	}

	@Test
	void returnsFirstResultWhenApplicable()
	{
		when(skillScaling1.isApplicable(context)).thenReturn(false);
		when(skillScaling2.isApplicable(context)).thenReturn(true);
		when(context.get(skillScaling2)).thenReturn(ofSkill(Skill.ATTACK, 100));

		assertEquals(ofSkill(Skill.ATTACK, 100), defenderSkillsComputable.compute(context));
		verify(skillScaling1, never()).compute(any());
	}

}
package com.duckblade.osrs.dpscalc.calc.defender.skills;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SkillScalingTest
{

	@Mock
	private ComputeContext context;

	@Mock
	private SkillScaling skillScaling;

	@BeforeEach
	void setUp()
	{
		when(skillScaling.compute(context)).thenCallRealMethod();
		when(skillScaling.scale(eq(context), any(), anyInt())).thenAnswer(i -> ((Integer) i.getArguments()[2]) * 2);
	}

	@Test
	void scalesEachSkillByImplementorScale()
	{
		when(context.get(ComputeInputs.DEFENDER_SKILLS)).thenReturn(
			Skills.builder()
				.level(Skill.HITPOINTS, 100)
				.level(Skill.ATTACK, 50)
				.boost(Skill.ATTACK, 25)
				.build()
		);

		Skills result = skillScaling.compute(context);
		assertEquals(200, result.getTotals().get(Skill.HITPOINTS));
		assertEquals(150, result.getTotals().get(Skill.ATTACK));
		assertEquals(0, result.getTotals().get(Skill.DEFENCE));
		verify(skillScaling, times(1)).scale(context, Skill.DEFENCE, 0);
	}
}
package com.duckblade.osrs.dpscalc.calc.defender.skills;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import net.runelite.api.NpcID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TheatreSkillScalingTest
{

	@Mock
	private ComputeContext context;

	@InjectMocks
	private TheatreSkillScaling theatreSkillScaling;

	@Test
	void isApplicableForTobNpcs()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.builder()
				.npcId(NpcID.THE_MAIDEN_OF_SUGADINTI)
				.build(),
			DefenderAttributes.builder()
				.npcId(NpcID.VERZIK_VITUR_10847)
				.build()
		);

		assertTrue(theatreSkillScaling.isApplicable(context));
		assertTrue(theatreSkillScaling.isApplicable(context));
	}

	@Test
	void isApplicableForTobHmNpcs()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.builder()
				.npcId(NpcID.THE_MAIDEN_OF_SUGADINTI_10822)
				.build(),
			DefenderAttributes.builder()
				.npcId(NpcID.VERZIK_VITUR_10847)
				.build()
		);

		assertTrue(theatreSkillScaling.isApplicable(context));
		assertTrue(theatreSkillScaling.isApplicable(context));
	}

	@Test
	void isNotApplicableForOtherNpcs()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.builder()
				.npcId(NpcID.GUARD)
				.build()
		);

		assertFalse(theatreSkillScaling.isApplicable(context));
	}

	@Test
	void scalesHealthByPartySize()
	{
		when(context.get(ComputeInputs.RAID_PARTY_SIZE)).thenReturn(2, 3, 4, 5, 6);

		assertEquals(750, theatreSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(750, theatreSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(875, theatreSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(1000, theatreSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(1000, theatreSkillScaling.scale(context, Skill.HITPOINTS, 1000));
	}

	@Test
	void doesNotScaleOtherSkills()
	{
		assertEquals(100, theatreSkillScaling.scale(context, Skill.ATTACK, 100));
		assertEquals(100, theatreSkillScaling.scale(context, Skill.DEFENCE, 100));
		assertEquals(100, theatreSkillScaling.scale(context, Skill.RANGED, 100));
	}

}
package com.duckblade.osrs.dpscalc.calc.defender.skills;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import net.runelite.api.NpcID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TheatreEntryModeSkillScalingTest
{

	@Mock
	private ComputeContext context;

	@InjectMocks
	private TheatreEntryModeSkillScaling theatreEntryModeSkillScaling;

	@Test
	void isApplicableForTobEmNpcs()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.builder()
				.npcId(NpcID.THE_MAIDEN_OF_SUGADINTI_10814)
				.build(),
			DefenderAttributes.builder()
				.npcId(NpcID.VERZIK_VITUR_10830)
				.build()
		);

		assertTrue(theatreEntryModeSkillScaling.isApplicable(context));
		assertTrue(theatreEntryModeSkillScaling.isApplicable(context));
	}

	@Test
	void isNotApplicableForOtherNpcs()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.builder()
				.npcId(NpcID.GUARD)
				.build()
		);

		assertFalse(theatreEntryModeSkillScaling.isApplicable(context));
	}

	@Test
	void scalesHealthByPartySize()
	{
		when(context.get(ComputeInputs.RAID_PARTY_SIZE)).thenReturn(1, 2, 3, 4, 5);

		assertEquals(200, theatreEntryModeSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(400, theatreEntryModeSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(600, theatreEntryModeSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(800, theatreEntryModeSkillScaling.scale(context, Skill.HITPOINTS, 1000));
		assertEquals(1000, theatreEntryModeSkillScaling.scale(context, Skill.HITPOINTS, 1000));
	}

	@Test
	void doesNotScaleOtherSkills()
	{
		assertEquals(100, theatreEntryModeSkillScaling.scale(context, Skill.ATTACK, 100));
		assertEquals(100, theatreEntryModeSkillScaling.scale(context, Skill.DEFENCE, 100));
		assertEquals(100, theatreEntryModeSkillScaling.scale(context, Skill.RANGED, 100));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofWeaponCategory;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class PoweredStaffMaxHitComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private PoweredStaffMaxHitComputable poweredStaffMaxHitComputable;

	@Test
	void isApplicableWhenUsingPoweredStavesForMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofWeaponCategory(WeaponCategory.POWERED_STAFF));

		assertTrue(poweredStaffMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertFalse(poweredStaffMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenManualCasting()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.MANUAL_CAST);

		assertFalse(poweredStaffMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingPoweredStaves()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofWeaponCategory(WeaponCategory.STAFF));

		assertFalse(poweredStaffMaxHitComputable.isApplicable(context));
	}

	@Test
	void givesMaxHitForTridentOfTheSeas()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.TRIDENT_OF_THE_SEAS),
			ofItemId(ItemID.TRIDENT_OF_THE_SEAS_E),
			ofItemId(ItemID.TRIDENT_OF_THE_SEAS_FULL)
		);
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			ofSkill(Skill.MAGIC, 0),
			ofSkill(Skill.MAGIC, 99),
			ofSkill(Skill.MAGIC, 120)
		);

		assertEquals(1, poweredStaffMaxHitComputable.compute(context));
		assertEquals(28, poweredStaffMaxHitComputable.compute(context));
		assertEquals(35, poweredStaffMaxHitComputable.compute(context));
	}

	@Test
	void givesMaxHitForTridentOfTheSwamp()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.TRIDENT_OF_THE_SWAMP),
			ofItemId(ItemID.TRIDENT_OF_THE_SWAMP_E)
		);
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			ofSkill(Skill.MAGIC, 0),
			ofSkill(Skill.MAGIC, 99)
		);

		assertEquals(4, poweredStaffMaxHitComputable.compute(context));
		assertEquals(31, poweredStaffMaxHitComputable.compute(context));
	}

	@Test
	void givesMaxHitForWarpedSceptre()
	{
		when(context.get(weaponComputable)).thenReturn(
				ofItemId(ItemID.WARPED_SCEPTRE)
		);
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
				ofSkill(Skill.MAGIC, 0),
				ofSkill(Skill.MAGIC, 99)
		);

		assertEquals(2, poweredStaffMaxHitComputable.compute(context));
		assertEquals(24, poweredStaffMaxHitComputable.compute(context));
	}

	@Test
	void givesMaxHitForSangStaff()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.SANGUINESTI_STAFF),
			ofItemId(ItemID.HOLY_SANGUINESTI_STAFF)
		);
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			ofSkill(Skill.MAGIC, 0),
			ofSkill(Skill.MAGIC, 99)
		);

		assertEquals(5, poweredStaffMaxHitComputable.compute(context));
		assertEquals(32, poweredStaffMaxHitComputable.compute(context));
	}

	@Test
	void givesMaxHitForTumekensShadow()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.TUMEKENS_SHADOW)
		);
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			ofSkill(Skill.MAGIC, 0),
			ofSkill(Skill.MAGIC, 99)
		);

		assertEquals(7, poweredStaffMaxHitComputable.compute(context));
		assertEquals(34, poweredStaffMaxHitComputable.compute(context));
	}

	@Test
	void givesMaxHitForGauntletStaves()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.CRYSTAL_STAFF_BASIC),
			ofItemId(ItemID.CORRUPTED_STAFF_ATTUNED),
			ofItemId(ItemID.CRYSTAL_STAFF_PERFECTED)
		);

		assertEquals(23, poweredStaffMaxHitComputable.compute(context));
		assertEquals(31, poweredStaffMaxHitComputable.compute(context));
		assertEquals(39, poweredStaffMaxHitComputable.compute(context));
	}

	@Test
	void throwsForUnknownWeapons()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.SMOKE_BATTLESTAFF),
			ofItemId(ItemID.SCYTHE_OF_VITUR)
		);

		assertThrows(IllegalArgumentException.class, () -> poweredStaffMaxHitComputable.compute(context));
	}

}

package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofWeaponCategory;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MagicSalamanderMaxHitComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private MagicSalamanderMaxHitComputable magicSalamanderMaxHitComputable;

	@Test
	void isApplicableWhenUsingSalamandersForMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofWeaponCategory(WeaponCategory.SALAMANDER));

		assertTrue(magicSalamanderMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertFalse(magicSalamanderMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenManualCasting()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.MANUAL_CAST);

		assertFalse(magicSalamanderMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingSalamanders()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofWeaponCategory(WeaponCategory.STAFF));

		assertFalse(magicSalamanderMaxHitComputable.isApplicable(context));
	}

	@Test
	void computesMaxHitForSalamanders()
	{
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.SWAMP_LIZARD),
			ofItemId(ItemID.ORANGE_SALAMANDER),
			ofItemId(ItemID.RED_SALAMANDER),
			ofItemId(ItemID.BLACK_SALAMANDER)
		);
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(ofSkill(Skill.MAGIC, 99));

		assertEquals(99 * (56 + 64) / 640, magicSalamanderMaxHitComputable.compute(context));
		assertEquals(99 * (59 + 64) / 640, magicSalamanderMaxHitComputable.compute(context));
		assertEquals(99 * (77 + 64) / 640, magicSalamanderMaxHitComputable.compute(context));
		assertEquals(99 * (92 + 64) / 640, magicSalamanderMaxHitComputable.compute(context));
	}

	@Test
	void throwsIllegalArgumentForNonSalamanders()
	{
		when(context.get(weaponComputable)).thenReturn(ofItemId(ItemID.SCYTHE_OF_VITUR));

		assertThrows(IllegalArgumentException.class, () -> magicSalamanderMaxHitComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofWeaponCategory;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SpellMaxHitComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private SpellcastingMaxHitBonusComputable spellcastingMaxHitBonusComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private SpellMaxHitComputable spellMaxHitComputable;

	@Test
	void isApplicableWhenUsingSpellbookSpells()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(ofWeaponCategory(WeaponCategory.STAFF));

		assertTrue(spellMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotUsingMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertFalse(spellMaxHitComputable.isApplicable(context));
	}

	@Test
	void isAlwaysApplicableWhenManualCasting()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.MANUAL_CAST);

		assertTrue(spellMaxHitComputable.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenUsingStavesOrSalamanders()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(
			ofWeaponCategory(WeaponCategory.POWERED_STAFF),
			ofWeaponCategory(WeaponCategory.SALAMANDER)
		);

		assertFalse(spellMaxHitComputable.isApplicable(context));
		assertFalse(spellMaxHitComputable.isApplicable(context));
	}

	@Test
	void returnsMaxHitWithBonus()
	{
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.BLOOD_BARRAGE,
			Spell.FIRE_SURGE,
			Spell.DARK_DEMONBANE
		);
		when(context.get(spellcastingMaxHitBonusComputable)).thenReturn(
			1,
			2,
			3
		);

		assertEquals(Spell.BLOOD_BARRAGE.getBaseMaxHit() + 1, spellMaxHitComputable.compute(context));
		assertEquals(Spell.FIRE_SURGE.getBaseMaxHit() + 2, spellMaxHitComputable.compute(context));
		assertEquals(Spell.DARK_DEMONBANE.getBaseMaxHit() + 3, spellMaxHitComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.gearbonus.AggregateGearBonusesComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.StrengthBonusComputable;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MageMaxHitComputableTest
{

	@Mock
	private MagicMaxHitComputable magicMaxHitComputable1, magicMaxHitComputable2;

	@Mock
	private StrengthBonusComputable strengthBonusComputable;

	@Mock
	private AggregateGearBonusesComputable aggregateGearBonusesComputable;

	@Mock
	private ComputeContext context;

	private MageMaxHitComputable mageMaxHitComputable;

	@BeforeEach
	void setUp()
	{
		mageMaxHitComputable = new MageMaxHitComputable(
			ImmutableSet.of(magicMaxHitComputable1, magicMaxHitComputable2),
			strengthBonusComputable,
			aggregateGearBonusesComputable
		);
	}

	@Test
	void throwsWhenNoProvidersApplicable()
	{
		when(magicMaxHitComputable1.isApplicable(context)).thenReturn(false);
		when(magicMaxHitComputable2.isApplicable(context)).thenReturn(false);

		assertThrows(IllegalArgumentException.class, () -> mageMaxHitComputable.compute(context));
	}

	@Test
	void selectsApplicableMaxHit()
	{
		when(magicMaxHitComputable1.isApplicable(context)).thenReturn(true, false);
		when(magicMaxHitComputable2.isApplicable(context)).thenReturn(true);
		when(context.get(magicMaxHitComputable1)).thenReturn(5);
		when(context.get(magicMaxHitComputable2)).thenReturn(10);
		when(context.get(strengthBonusComputable)).thenReturn(0);
		when(context.get(aggregateGearBonusesComputable)).thenReturn(GearBonuses.EMPTY);

		assertEquals(5, mageMaxHitComputable.compute(context));
		assertEquals(10, mageMaxHitComputable.compute(context));
	}

	@Test
	void correctlyAppliesBonuses()
	{
		when(magicMaxHitComputable1.isApplicable(context)).thenReturn(true);
		when(context.get(magicMaxHitComputable1)).thenReturn(5);
		when(context.get(strengthBonusComputable)).thenReturn(10);
		when(context.get(aggregateGearBonusesComputable)).thenReturn(GearBonuses.of(1.2, 1.5));

		assertEquals((int) (5 * (1.10 * 1.5)), mageMaxHitComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import static com.duckblade.osrs.dpscalc.calc.testutil.SkillsUtil.ofSkill;
import com.google.common.collect.ImmutableMap;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class SpellcastingMaxHitBonusComputableTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private SpellcastingMaxHitBonusComputable spellcastingMaxHitBonusComputable;

	@Test
	void givesBonusForChaosGauntletsWithBoltSpells()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(EquipmentInventorySlot.GLOVES, ItemID.CHAOS_GAUNTLETS));
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.WIND_BOLT,
			Spell.WATER_BOLT,
			Spell.EARTH_BOLT,
			Spell.FIRE_BOLT
		);

		assertEquals(3, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(3, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(3, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(3, spellcastingMaxHitBonusComputable.compute(context));
	}

	@Test
	void givesBonusForChargeWithGodSpells()
	{
		when(context.get(ComputeInputs.USING_CHARGE_SPELL)).thenReturn(true);
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.SARADOMIN_STRIKE,
			Spell.CLAWS_OF_GUTHIX,
			Spell.FLAMES_OF_ZAMORAK
		);

		assertEquals(10, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(10, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(10, spellcastingMaxHitBonusComputable.compute(context));
	}

	@Test
	void givesBonusForMagicDart()
	{
		when(context.get(ComputeInputs.SPELL)).thenReturn(Spell.MAGIC_DART);
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.WEAPON, ItemID.SLAYERS_STAFF
		));
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(
			ofSkill(Skill.MAGIC, 0),
			ofSkill(Skill.MAGIC, 50),
			ofSkill(Skill.MAGIC, 99)
		);

		assertEquals(0, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(5, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(9, spellcastingMaxHitBonusComputable.compute(context));
	}

	@Test
	void givesBonusForMagicDartE()
	{
		when(context.get(ComputeInputs.SPELL)).thenReturn(Spell.MAGIC_DART);
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.WEAPON, ItemID.SLAYERS_STAFF_E
		));
		when(context.get(ComputeInputs.ATTACKER_SKILLS)).thenReturn(ofSkill(Skill.MAGIC, 99));
		when(context.get(ComputeInputs.ON_SLAYER_TASK)).thenReturn(true, false);

		assertEquals(19, spellcastingMaxHitBonusComputable.compute(context)); // on task
		assertEquals(9, spellcastingMaxHitBonusComputable.compute(context)); // off task
	}

	@Test
	void givesNoBonusForOtherInputs()
	{
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.WIND_BOLT,
			Spell.FLAMES_OF_ZAMORAK,
			Spell.FIRE_SURGE
		);
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(
			EquipmentInventorySlot.GLOVES, ItemID.LEATHER_GLOVES
		));
		when(context.get(ComputeInputs.USING_CHARGE_SPELL)).thenReturn(false);

		assertEquals(0, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(0, spellcastingMaxHitBonusComputable.compute(context));
		assertEquals(0, spellcastingMaxHitBonusComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.eq;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class BaseMaxHitComputableTest
{

	@Mock
	private PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;

	@Mock
	private MaxHitLimitComputable maxHitLimitComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private BaseMaxHitComputable baseMaxHitComputable;

	@Test
	void appliesMaxHitLimiter()
	{
		when(context.get(preLimitBaseMaxHitComputable)).thenReturn(12);
		when(maxHitLimitComputable.coerce(anyInt(), eq(context))).thenReturn(5);

		assertEquals(5, baseMaxHitComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.google.common.collect.ImmutableMap;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

class MeleeEffectiveStrengthLevelComputableTest
{

	private final MeleeEffectiveStrengthLevelComputable meleeEffectiveStrengthLevelComputable = new MeleeEffectiveStrengthLevelComputable();

	@Test
	void providesCorrectParametersToBaseClass()
	{
		assertEquals(Skill.STRENGTH, meleeEffectiveStrengthLevelComputable.getBaseSkill());
		assertEquals(Prayer.PrayerGroup.MELEE, meleeEffectiveStrengthLevelComputable.getPrayerGroup());
		assertEquals(Prayer.PIETY.getStrengthMod(), meleeEffectiveStrengthLevelComputable.getPrayerMultiplier().applyAsDouble(Prayer.RIGOUR));
		assertEquals(8, meleeEffectiveStrengthLevelComputable.getBaseBonus());
		assertEquals(
			ImmutableMap.<CombatStyle, Integer>builder()
				.put(CombatStyle.AGGRESSIVE, 3)
				.put(CombatStyle.CONTROLLED, 1)
				.build(),
			meleeEffectiveStrengthLevelComputable.getCombatFocusBonuses()
		);
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.MageMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class PreLimitBaseMaxHitComputableTest
{

	@Mock
	private MageMaxHitComputable mageMaxHitComputable;

	@Mock
	private MeleeRangedMaxHitComputable meleeRangedMaxHitComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;

	@Test
	void defersToCorrectCombatStyle()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.RANGED),
			ofAttackType(AttackType.MAGIC)
		);
		when(context.get(meleeRangedMaxHitComputable)).thenReturn(12);
		when(context.get(mageMaxHitComputable)).thenReturn(34);

		assertEquals(12, preLimitBaseMaxHitComputable.compute(context));
		assertEquals(12, preLimitBaseMaxHitComputable.compute(context));
		assertEquals(34, preLimitBaseMaxHitComputable.compute(context));
	}

}

package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.CALLISTO;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.ZULRAH;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class CombatStyleImmunityMaxHitLimiterTest
{

	@Mock
	private ComputeContext context;

	@InjectMocks
	private CombatStyleImmunityMaxHitLimiter combatStyleImmunityMaxHitLimiter;

	@Test
	void isApplicableWhenImmune()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.STAB),
//			ofAttackType(AttackType.RANGED), no ranged immunities
			ofAttackType(AttackType.MAGIC)
		);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			ZULRAH,
//			DefenderAttributes.builder().npcId().build(), no ranged immunities
			CALLISTO
		);

		assertTrue(combatStyleImmunityMaxHitLimiter.isApplicable(context));
//		assertTrue(combatStyleImmunityMaxHitLimiter.isApplicable(context)); no ranged immunities
		assertTrue(combatStyleImmunityMaxHitLimiter.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotImmune()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.RANGED),
			ofAttackType(AttackType.MAGIC)
		);
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			DefenderAttributes.EMPTY,
			CALLISTO,
			ZULRAH
		);

		assertFalse(combatStyleImmunityMaxHitLimiter.isApplicable(context));
		assertFalse(combatStyleImmunityMaxHitLimiter.isApplicable(context));
		assertFalse(combatStyleImmunityMaxHitLimiter.isApplicable(context));
	}

	@Test
	void returnsAppropriateLimit()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(ZULRAH);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		MaxHitLimit limit = MaxHitLimit.builder()
			.limit(0)
			.warning("Zulrah cannot be hit by slash attacks.")
			.build();
		assertEquals(limit, combatStyleImmunityMaxHitLimiter.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import com.google.common.collect.ImmutableSet;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoMoreInteractions;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MaxHitLimitComputableTest
{

	@Mock
	private MaxHitLimiter limiter1, limiter2;

	@Mock
	private ComputeContext context;

	private MaxHitLimitComputable maxHitLimitComputable;

	@BeforeEach
	void setUp()
	{
		maxHitLimitComputable = new MaxHitLimitComputable(
			ImmutableSet.of(limiter1, limiter2)
		);
	}

	@Test
	void computeReturnsLowestApplicableLimiter()
	{
		when(limiter1.isApplicable(context)).thenReturn(true, false, true);
		when(limiter2.isApplicable(context)).thenReturn(false, true, true);
		when(context.get(limiter1)).thenReturn(MaxHitLimit.of(5, "A"));
		when(context.get(limiter2)).thenReturn(MaxHitLimit.of(3, "B"));

		assertEquals(MaxHitLimit.of(5, "A"), maxHitLimitComputable.compute(context));
		assertEquals(MaxHitLimit.of(3, "B"), maxHitLimitComputable.compute(context));
		assertEquals(MaxHitLimit.of(3, "B"), maxHitLimitComputable.compute(context));
		verify(context, times(3)).put(MaxHitLimitComputable.LIMIT_APPLIED, false);
	}

	@Test
	void computeDefaultsToUnlimited()
	{
		when(limiter1.isApplicable(context)).thenReturn(false);
		when(limiter2.isApplicable(context)).thenReturn(false);

		assertEquals(MaxHitLimit.UNLIMITED, maxHitLimitComputable.compute(context));
		verify(context, times(1)).put(MaxHitLimitComputable.LIMIT_APPLIED, false);
	}

	@Test
	void coerceDoesNothingWhenLimitIsGreaterThanMaxHit()
	{
		when(context.get(maxHitLimitComputable)).thenReturn(MaxHitLimit.of(10, "A"));

		assertEquals(5, maxHitLimitComputable.coerce(5, context));
		assertEquals(10, maxHitLimitComputable.coerce(10, context));
		verifyNoMoreInteractions(context);
	}

	@Test
	void coerceLimitsMaxHitAndWarnsIfNotYetWarned()
	{
		when(context.get(maxHitLimitComputable)).thenReturn(MaxHitLimit.of(10, "A"));
		when(context.get(MaxHitLimitComputable.LIMIT_APPLIED)).thenReturn(false);

		assertEquals(10, maxHitLimitComputable.coerce(15, context));
		verify(context, times(1)).warn("A");
		verify(context, times(1)).put(MaxHitLimitComputable.LIMIT_APPLIED, true);
	}

	@Test
	void coerceLimitsMaxHitAndDoesNotWarnIfAlreadyWarned()
	{
		when(context.get(maxHitLimitComputable)).thenReturn(MaxHitLimit.of(10, "A"));
		when(context.get(MaxHitLimitComputable.LIMIT_APPLIED)).thenReturn(true);

		assertEquals(10, maxHitLimitComputable.coerce(15, context));
		verifyNoMoreInteractions(context);
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE1;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE2;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE3;
import com.google.common.collect.ImmutableMap;
import java.util.Collections;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class Tier2VampyreImmunitiesTest
{

	@Mock
	private EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private Tier2VampyreImmunities tier2VampyreImmunities;

	@Test
	void isApplicableForTier2Vampyres()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(VAMPYRE2);

		assertTrue(tier2VampyreImmunities.isApplicable(context));
	}

	@Test
	void isNotApplicableForNonTier2Vampyres()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			VAMPYRE1,
			VAMPYRE3,
			DefenderAttributes.EMPTY
		);

		assertFalse(tier2VampyreImmunities.isApplicable(context));
		assertFalse(tier2VampyreImmunities.isApplicable(context));
		assertFalse(tier2VampyreImmunities.isApplicable(context));
	}

	@Test
	void limitsMaxHitForMagicWithoutEfaritay()
	{
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(EquipmentInventorySlot.WEAPON, ItemID.BLISTERWOOD_FLAIL),
			Collections.emptyMap()
		);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertEquals(
			MaxHitLimit.of(0, "Tier 2 vampyres can only be damaged by silver weaponry or with Efaritay's aid."),
			tier2VampyreImmunities.compute(context)
		);
	}

	@Test
	void limitsMaxHitForMagicWithEfaritay()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(EquipmentInventorySlot.RING, ItemID.EFARITAYS_AID));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));

		assertEquals(
			MaxHitLimit.of(10, "Efaritay's aid limits max hit to 10."),
			tier2VampyreImmunities.compute(context)
		);
	}

	@Test
	void limitsMaxHitForRangedWithoutEfaritayAndSilverBolts()
	{
		when(context.get(equipmentItemIdsComputable)).thenAnswer(i -> Collections.emptyMap());
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals(
			MaxHitLimit.of(0, "Tier 2 vampyres can only be damaged by silver weaponry or with Efaritay's aid."),
			tier2VampyreImmunities.compute(context)
		);
	}

	@Test
	void limitsMaxHitForRangedWithEfaritay()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(EquipmentInventorySlot.RING, ItemID.EFARITAYS_AID));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals(
			MaxHitLimit.of(10, "Efaritay's aid limits max hit to 10."),
			tier2VampyreImmunities.compute(context)
		);
	}

	@Test
	void doesNotlimitMaxHitForRangedWithSilverBolts()
	{
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(EquipmentInventorySlot.AMMO, ItemID.SILVER_BOLTS),
			ImmutableMap.of(
				EquipmentInventorySlot.AMMO, ItemID.SILVER_BOLTS,
				EquipmentInventorySlot.RING, ItemID.EFARITAYS_AID
			)
		);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));

		assertEquals(MaxHitLimit.UNLIMITED, tier2VampyreImmunities.compute(context));
		assertEquals(MaxHitLimit.UNLIMITED, tier2VampyreImmunities.compute(context));
	}

	@Test
	void limitsMaxHitForMeleeWithoutEfarityAndSilverWeapons()
	{
		when(context.get(equipmentItemIdsComputable)).thenAnswer(i -> Collections.emptyMap());
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertEquals(
			MaxHitLimit.of(0, "Tier 2 vampyres can only be damaged by silver weaponry or with Efaritay's aid."),
			tier2VampyreImmunities.compute(context)
		);
	}

	@Test
	void limitsMaxHitForMeleeWithEfarity()
	{
		when(context.get(equipmentItemIdsComputable)).thenReturn(ImmutableMap.of(EquipmentInventorySlot.RING, ItemID.EFARITAYS_AID));
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertEquals(
			MaxHitLimit.of(10, "Efaritay's aid limits max hit to 10."),
			tier2VampyreImmunities.compute(context)
		);
	}

	@Test
	void doesNotlimitMaxHitForMeleeWithSilverWeapons()
	{
		// noinspection unchecked
		when(context.get(equipmentItemIdsComputable)).thenReturn(
			ImmutableMap.of(EquipmentInventorySlot.WEAPON, ItemID.BLESSED_AXE),
			ImmutableMap.of(
				EquipmentInventorySlot.WEAPON, ItemID.BLISTERWOOD_FLAIL,
				EquipmentInventorySlot.RING, ItemID.EFARITAYS_AID
			)
		);
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));

		assertEquals(MaxHitLimit.UNLIMITED, tier2VampyreImmunities.compute(context));
		assertEquals(MaxHitLimit.UNLIMITED, tier2VampyreImmunities.compute(context));
	}
}
package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE1;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE2;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.VAMPYRE3;
import static com.duckblade.osrs.dpscalc.calc.testutil.ItemStatsUtil.ofItemId;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class Tier3VampyreImmunitiesTest
{

	private static final MaxHitLimit EXPECTED = MaxHitLimit.of(0, "Tier 3 vampyres can only be damaged by Blisterwood weapons.");

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private Tier3VampyreImmunities tier3VampyreImmunities;

	@Test
	void isApplicableAgainstT3Vampyres()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(VAMPYRE3);

		assertTrue(tier3VampyreImmunities.isApplicable(context));
	}

	@Test
	void isNotApplicableAgainstNonT3Vampyres()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			VAMPYRE1,
			VAMPYRE2,
			DefenderAttributes.EMPTY
		);

		assertFalse(tier3VampyreImmunities.isApplicable(context));
		assertFalse(tier3VampyreImmunities.isApplicable(context));
		assertFalse(tier3VampyreImmunities.isApplicable(context));
	}

	@Test
	void limitsMaxHitForNonMelee()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.MAGIC),
			ofAttackType(AttackType.RANGED)
		);

		assertEquals(EXPECTED, tier3VampyreImmunities.compute(context));
	}

	@Test
	void limitsMaxHitForMeleeWithoutVampyrebane()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.STAB),
			ofAttackType(AttackType.SLASH),
			ofAttackType(AttackType.CRUSH)
		);
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.GHRAZI_RAPIER),
			ofItemId(ItemID.SCYTHE_OF_VITUR),
			ofItemId(ItemID.ABYSSAL_BLUDGEON)
		);

		assertEquals(EXPECTED, tier3VampyreImmunities.compute(context));
		assertEquals(EXPECTED, tier3VampyreImmunities.compute(context));
		assertEquals(EXPECTED, tier3VampyreImmunities.compute(context));
	}

	@Test
	void doesNotLimitMaxHitForVampyrebane()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.SLASH));
		when(context.get(weaponComputable)).thenReturn(
			ofItemId(ItemID.BLISTERWOOD_FLAIL),
			ofItemId(ItemID.BLISTERWOOD_SICKLE),
			ofItemId(ItemID.IVANDIS_FLAIL)
		);

		assertEquals(MaxHitLimit.UNLIMITED, tier3VampyreImmunities.compute(context));
		assertEquals(MaxHitLimit.UNLIMITED, tier3VampyreImmunities.compute(context));
		assertEquals(MaxHitLimit.UNLIMITED, tier3VampyreImmunities.compute(context));
	}
}
package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.CALLISTO;
import static com.duckblade.osrs.dpscalc.calc.testutil.DefenderAttributesUtil.ZULRAH;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class ZulrahMaxHitLimiterTest
{

	@Mock
	private ComputeContext context;

	@InjectMocks
	private ZulrahMaxHitLimiter zulrahMaxHitLimiter;

	@Test
	void isApplicableWhenFightingZulrah()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(ZULRAH);

		assertTrue(zulrahMaxHitLimiter.isApplicable(context));
	}

	@Test
	void isNotApplicableWhenNotFightingZulrah()
	{
		when(context.get(ComputeInputs.DEFENDER_ATTRIBUTES)).thenReturn(
			CALLISTO,
			DefenderAttributes.EMPTY
		);

		assertFalse(zulrahMaxHitLimiter.isApplicable(context));
		assertFalse(zulrahMaxHitLimiter.isApplicable(context));
	}

	@Test
	void limitsMaxHitTo50()
	{
		assertEquals(
			MaxHitLimit.of(50, "Zulrah has a max hit limiter of 50."),
			zulrahMaxHitLimiter.compute(context)
		);
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.google.common.collect.ImmutableList;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class TrueMaxHitComputableTest
{

	@Mock
	private BaseMaxHitComputable baseMaxHitComputable;

	@Mock
	private ComputeContext context;

	@Mock
	private ComputeOutput<Integer> effectMaxHit1, effectMaxHit2;

	private TrueMaxHitComputable trueMaxHitComputable;

	@BeforeEach
	private void setUp()
	{
		trueMaxHitComputable = new TrueMaxHitComputable(
			baseMaxHitComputable,
			ImmutableList.of(effectMaxHit1, effectMaxHit2)
		);
	}

	@Test
	void selectsFirstNonNullOutput()
	{
		when(context.get(effectMaxHit1)).thenReturn(null, 3);
		when(context.get(effectMaxHit2)).thenReturn(5, (Integer) null);

		assertEquals(trueMaxHitComputable.compute(context), 5);
		assertEquals(trueMaxHitComputable.compute(context), 3);
	}

	@Test
	void defaultsToBaseMaxHit()
	{
		when(context.get(effectMaxHit1)).thenReturn(null);
		when(context.get(effectMaxHit2)).thenReturn(null);
		when(context.get(baseMaxHitComputable)).thenReturn(12);

		assertEquals(12, trueMaxHitComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.gearbonus.AggregateGearBonusesComputable;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MeleeRangedMaxHitComputableTest
{

	@Mock
	private MeleeEffectiveStrengthLevelComputable meleeEffectiveStrengthLevelComputable;

	@Mock
	private RangedEffectiveStrengthLevelComputable rangedEffectiveStrengthLevelComputable;

	@Mock
	private StrengthBonusComputable strengthBonusComputable;

	@Mock
	private AggregateGearBonusesComputable aggregateGearBonusesComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private MeleeRangedMaxHitComputable meleeRangedMaxHitComputable;

	@Test
	void combinesValuesCorrectlyForMelee()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(meleeEffectiveStrengthLevelComputable)).thenReturn(512);
		when(context.get(strengthBonusComputable)).thenReturn(123);
		when(context.get(aggregateGearBonusesComputable)).thenReturn(GearBonuses.of(1.1, 1.5));

		int expected = (int) ((512 * (123 + 64) + 320) / 640 * 1.5);
		assertEquals(expected, meleeRangedMaxHitComputable.compute(context));
	}

	@Test
	void combinesValuesCorrectlyForRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(rangedEffectiveStrengthLevelComputable)).thenReturn(256);
		when(context.get(strengthBonusComputable)).thenReturn(321);
		when(context.get(aggregateGearBonusesComputable)).thenReturn(GearBonuses.of(1.2, 1.4));

		int expected = (int) ((256 * (321 + 64) + 320) / 640 * 1.4);
		assertEquals(expected, meleeRangedMaxHitComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import java.util.Collections;
import net.runelite.api.Skill;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

class RangedEffectiveStrengthLevelComputableTest
{

	private final RangedEffectiveStrengthLevelComputable rangedEffectiveStrengthLevelComputable = new RangedEffectiveStrengthLevelComputable();

	@Test
	void providesCorrectParametersToBaseClass()
	{
		assertEquals(Skill.RANGED, rangedEffectiveStrengthLevelComputable.getBaseSkill());
		assertEquals(Prayer.PrayerGroup.RANGED, rangedEffectiveStrengthLevelComputable.getPrayerGroup());
		assertEquals(Prayer.RIGOUR.getStrengthMod(), rangedEffectiveStrengthLevelComputable.getPrayerMultiplier().applyAsDouble(Prayer.RIGOUR));
		assertEquals(8, rangedEffectiveStrengthLevelComputable.getBaseBonus());
		assertEquals(Collections.singletonMap(CombatStyle.ACCURATE, 3), rangedEffectiveStrengthLevelComputable.getCombatFocusBonuses());
	}

}
package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.AttackerItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class StrengthBonusComputableTest
{

	private static final ItemStats ITEM_STATS = ItemStats.builder()
		.strengthMelee(12)
		.strengthRanged(34)
		.strengthMagic(56)
		.build();

	@Mock
	private AttackerItemStatsComputable attackerItemStatsComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private StrengthBonusComputable strengthBonusComputable;

	@Test
	void selectsMeleeStrengthForMelee()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(attackerItemStatsComputable)).thenReturn(ITEM_STATS);

		assertEquals(12, strengthBonusComputable.compute(context));
	}

	@Test
	void selectsRangedStrengthForRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.RANGED));
		when(context.get(attackerItemStatsComputable)).thenReturn(ITEM_STATS);

		assertEquals(34, strengthBonusComputable.compute(context));
	}

	@Test
	void selectsMagicDamageBonusForMage()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(attackerItemStatsComputable)).thenReturn(ITEM_STATS);

		assertEquals(56, strengthBonusComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.multihit.MultiHitDptComputable;
import com.google.common.collect.ImmutableSet;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DptComputableTest
{

	@Mock
	private BaseHitDptComputable baseHitDptComputable;

	@Mock
	private MultiHitDptComputable multiHitDptComputable1, multiHitDptComputable2;

	@Mock
	private ComputeContext context;

	private DptComputable dptComputable;

	@BeforeEach
	void setUp()
	{
		dptComputable = new DptComputable(
			baseHitDptComputable,
			ImmutableSet.of(multiHitDptComputable1, multiHitDptComputable2)
		);
	}

	@Test
	void usesApplicableMultiHitResult()
	{
		when(multiHitDptComputable1.isApplicable(context)).thenReturn(false);
		when(multiHitDptComputable2.isApplicable(context)).thenReturn(true);
		when(context.get(multiHitDptComputable2)).thenReturn(3.0);

		assertEquals(3.0, dptComputable.compute(context));
	}

	@Test
	void usesBaseResultWhenNonApplicable()
	{
		when(context.get(baseHitDptComputable)).thenReturn(5.0);
		when(multiHitDptComputable1.isApplicable(context)).thenReturn(false);
		when(multiHitDptComputable2.isApplicable(context)).thenReturn(false);

		assertEquals(5.0, dptComputable.compute(context));
	}

	@Test
	void passesExceptionsUpward()
	{
		when(context.get(baseHitDptComputable)).thenThrow(new RuntimeException());
		assertThrows(RuntimeException.class, () -> dptComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.testutil.AttackStyleUtil.ofAttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import net.runelite.api.ItemID;
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import static org.mockito.Mockito.when;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class AttackSpeedComputableTest
{

	@Mock
	private WeaponComputable weaponComputable;

	@Mock
	private ComputeContext context;

	@InjectMocks
	private AttackSpeedComputable attackSpeedComputable;

	@Test
	void isCorrectForHarmStaff()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(
			ItemStats.builder()
				.itemId(ItemID.HARMONISED_NIGHTMARE_STAFF)
				.weaponCategory(WeaponCategory.STAFF)
				.build()
		);
		when(context.get(ComputeInputs.SPELL)).thenReturn(
			Spell.FIRE_SURGE,
			Spell.ICE_BARRAGE
		);

		assertEquals(4, attackSpeedComputable.compute(context));
		assertEquals(5, attackSpeedComputable.compute(context));
	}

	@Test
	void isCorrectForPoweredStaves()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.MAGIC),
			ofAttackType(AttackType.MAGIC),
			AttackStyle.MANUAL_CAST
		);
		when(context.get(weaponComputable)).thenReturn(
			ItemStats.builder()
				.weaponCategory(WeaponCategory.POWERED_STAFF)
				.speed(5)
				.build(),
			ItemStats.builder()
				.weaponCategory(WeaponCategory.POWERED_STAFF)
				.speed(3)
				.build(),
			ItemStats.builder()
				.weaponCategory(WeaponCategory.POWERED_STAFF)
				.speed(3)
				.build()
		);

		assertEquals(5, attackSpeedComputable.compute(context));
		assertEquals(3, attackSpeedComputable.compute(context));
		assertEquals(5, attackSpeedComputable.compute(context));
	}

	@Test
	void isCorrectForSalamanders()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(
			ofAttackType(AttackType.MAGIC),
			ofAttackType(AttackType.MAGIC),
			AttackStyle.MANUAL_CAST
		);
		when(context.get(weaponComputable)).thenReturn(
			ItemStats.builder()
				.weaponCategory(WeaponCategory.SALAMANDER)
				.speed(5)
				.build(),
			ItemStats.builder()
				.weaponCategory(WeaponCategory.SALAMANDER)
				.speed(3)
				.build(),
			ItemStats.builder()
				.weaponCategory(WeaponCategory.SALAMANDER)
				.speed(3)
				.build()
		);

		assertEquals(5, attackSpeedComputable.compute(context));
		assertEquals(3, attackSpeedComputable.compute(context));
		assertEquals(5, attackSpeedComputable.compute(context));
	}

	@Test
	void isCorrectForOtherMagic()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.MAGIC));
		when(context.get(weaponComputable)).thenReturn(
			ItemStats.builder()
				.weaponCategory(WeaponCategory.STAFF)
				.build(),
			ItemStats.builder()
				.weaponCategory(WeaponCategory.SCYTHE)
				.build()
		);

		assertEquals(5, attackSpeedComputable.compute(context));
		assertEquals(5, attackSpeedComputable.compute(context));
	}

	@Test
	void isCorrectForRapidRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.builder()
			.attackType(AttackType.RANGED)
			.combatStyle(CombatStyle.RAPID)
			.build());
		when(context.get(weaponComputable)).thenReturn(
			ItemStats.builder()
				.weaponCategory(WeaponCategory.BOW)
				.speed(5)
				.build(),
			ItemStats.builder()
				.weaponCategory(WeaponCategory.THROWN)
				.speed(3)
				.build()
		);

		assertEquals(4, attackSpeedComputable.compute(context));
		assertEquals(2, attackSpeedComputable.compute(context));
	}

	@Test
	void isCorrectForOtherRanged()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(AttackStyle.builder()
			.attackType(AttackType.RANGED)
			.combatStyle(CombatStyle.ACCURATE)
			.build());
		when(context.get(weaponComputable)).thenReturn(
			ItemStats.builder()
				.weaponCategory(WeaponCategory.BOW)
				.speed(5)
				.build()
		);

		assertEquals(5, attackSpeedComputable.compute(context));
	}

	@Test
	void isCorrectForMelee()
	{
		when(context.get(ComputeInputs.ATTACK_STYLE)).thenReturn(ofAttackType(AttackType.STAB));
		when(context.get(weaponComputable)).thenReturn(
			ItemStats.builder()
				.weaponCategory(WeaponCategory.STAFF)
				.speed(4)
				.build()
		);

		assertEquals(4, attackSpeedComputable.compute(context));
	}

}
package com.duckblade.osrs.dpscalc;

import com.duckblade.osrs.dpscalc.plugin.DpsCalcPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DPSCalculatorPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DpsCalcPlugin.class);
		RuneLite.main(args);
	}
}

package com.duckblade.osrs.dpscalc;

import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

// ignoring defensive stats for simplicity
public class ItemStatsConstants
{

	public static final ItemStats SCYTHE = ItemStats.builder()
		.accuracyStab(70)
		.accuracySlash(110)
		.accuracyCrush(30)
		.accuracyMagic(-6)
		.strengthMelee(75)
		.speed(5)
		.itemId(ItemID.SCYTHE_OF_VITUR)
		.weaponCategory(WeaponCategory.SCYTHE)
		.is2h(true)
		.slot(EquipmentInventorySlot.WEAPON.getSlotIdx())
		.build();

	public static final ItemStats BERSERKER_RING = ItemStats.builder()
		.strengthMelee(8)
		.slot(EquipmentInventorySlot.RING.getSlotIdx())
		.itemId(ItemID.BERSERKER_RING)
		.build();

	public static final ItemStats TORVA_FULL_HELM = ItemStats.builder()
		.accuracyMagic(-5)
		.accuracyRanged(-5)
		.prayer(1)
		.strengthMelee(8)
		.slot(EquipmentInventorySlot.HEAD.getSlotIdx())
		.itemId(ItemID.TORVA_FULL_HELM)
		.build();

	public static final ItemStats TORVA_BODY = ItemStats.builder()
		.accuracyMagic(-18)
		.accuracyRanged(-14)
		.prayer(1)
		.strengthMelee(6)
		.slot(EquipmentInventorySlot.BODY.getSlotIdx())
		.itemId(ItemID.TORVA_PLATEBODY)
		.build();

	public static final ItemStats TORVA_LEGS = ItemStats.builder()
		.accuracyMagic(-24)
		.accuracyRanged(-11)
		.prayer(1)
		.strengthMelee(4)
		.slot(EquipmentInventorySlot.LEGS.getSlotIdx())
		.itemId(ItemID.TORVA_PLATELEGS)
		.build();

	public static final ItemStats FEROCIOUS_GLOVES = ItemStats.builder()
		.accuracyStab(16)
		.accuracySlash(16)
		.accuracyCrush(16)
		.accuracyMagic(-16)
		.accuracyRanged(-16)
		.strengthMelee(14)
		.slot(EquipmentInventorySlot.GLOVES.getSlotIdx())
		.itemId(ItemID.FEROCIOUS_GLOVES)
		.build();

	public static final ItemStats PRIMS = ItemStats.builder()
		.accuracyStab(2)
		.accuracySlash(2)
		.accuracyCrush(2)
		.accuracyMagic(-4)
		.accuracyRanged(-1)
		.strengthMelee(5)
		.slot(EquipmentInventorySlot.BOOTS.getSlotIdx())
		.itemId(ItemID.PRIMORDIAL_BOOTS)
		.build();

	public static final ItemStats TORTURE = ItemStats.builder()
		.accuracyStab(15)
		.accuracySlash(15)
		.accuracyCrush(15)
		.strengthMelee(10)
		.prayer(2)
		.slot(EquipmentInventorySlot.AMULET.getSlotIdx())
		.itemId(ItemID.AMULET_OF_TORTURE)
		.build();

	public static final ItemStats INFERNAL_CAPE = ItemStats.builder()
		.accuracyStab(4)
		.accuracySlash(4)
		.accuracyCrush(4)
		.accuracyMagic(1)
		.accuracyRanged(1)
		.strengthMelee(8)
		.prayer(2)
		.slot(EquipmentInventorySlot.CAPE.getSlotIdx())
		.itemId(ItemID.INFERNAL_CAPE)
		.build();

	public static final ItemStats RADAS_BLESSING = ItemStats.builder()
		.prayer(2)
		.slot(EquipmentInventorySlot.AMMO.getSlotIdx())
		.itemId(ItemID.RADAS_BLESSING_4)
		.build();

	public static final ItemStats AVERNIC_DEFENDER = ItemStats.builder()
		.accuracyStab(30)
		.accuracySlash(29)
		.accuracyCrush(28)
		.accuracyMagic(-5)
		.accuracyRanged(-4)
		.strengthMelee(8)
		.slot(EquipmentInventorySlot.AMMO.getSlotIdx())
		.itemId(ItemID.DRAGON_DEFENDER)
		.build();

	public static Map<EquipmentInventorySlot, ItemStats> maxMelee(ItemStats weapon)
	{
		ImmutableMap.Builder<EquipmentInventorySlot, ItemStats> builder = ImmutableMap.<EquipmentInventorySlot, ItemStats>builder()
			.put(EquipmentInventorySlot.HEAD, TORVA_FULL_HELM)
			.put(EquipmentInventorySlot.CAPE, INFERNAL_CAPE)
			.put(EquipmentInventorySlot.AMULET, TORTURE)
			.put(EquipmentInventorySlot.AMMO, RADAS_BLESSING)
			.put(EquipmentInventorySlot.BODY, TORVA_BODY)
			.put(EquipmentInventorySlot.LEGS, TORVA_LEGS)
			.put(EquipmentInventorySlot.GLOVES, FEROCIOUS_GLOVES)
			.put(EquipmentInventorySlot.BOOTS, PRIMS)
			.put(EquipmentInventorySlot.RING, BERSERKER_RING);

		if (weapon != null)
		{
			builder.put(EquipmentInventorySlot.WEAPON, weapon);
		}

		if (weapon == null || !weapon.is2h())
		{
			builder.put(EquipmentInventorySlot.SHIELD, AVERNIC_DEFENDER);
		}
		return builder.build();
	}

}

package com.duckblade.osrs.dpscalc;

import com.duckblade.osrs.dpscalc.calc.DpsComputeModule;
import com.duckblade.osrs.dpscalc.devbindings.LocalItemStatsProvider;
import com.duckblade.osrs.dpscalc.devbindings.LocalNpcDataProvider;
import com.duckblade.osrs.dpscalc.devbindings.MockClientDataProvider;
import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import com.duckblade.osrs.dpscalc.plugin.live.party.PartyDpsService;
import com.duckblade.osrs.dpscalc.plugin.module.DpsPluginModule;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProviderThreadProxy;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.duckblade.osrs.dpscalc.plugin.live.overlay.LiveDpsOverlay;
import com.duckblade.osrs.dpscalc.plugin.ui.DpsPluginPanel;
import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.util.Modules;
import com.google.inject.util.Providers;
import java.awt.Cursor;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import javax.swing.JFrame;
import javax.swing.SwingUtilities;
import javax.swing.WindowConstants;
import net.runelite.api.Client;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import okhttp3.Cache;
import okhttp3.OkHttpClient;

public class DPSCalcUITest
{

	public static void main(String[] args) throws InterruptedException, InvocationTargetException
	{
		Injector testInjector = Guice.createInjector(
			Modules.override(new DpsComputeModule(), new DpsPluginModule())
				.with(i ->
				{
					i.bind(Client.class).toProvider(Providers.of(null));
					i.bind(ItemManager.class).toProvider(Providers.of(null));
					i.bind(ClientThread.class).toProvider(Providers.of(null));
					i.bind(OkHttpClient.class).toInstance(new OkHttpClient.Builder()
						.cache(new Cache(new File(RuneLite.CACHE_DIR, "okhttp"), 20 * 1024 * 1024))
						.build());
					i.bind(DpsCalcConfig.class).toInstance(new DpsCalcConfig()
					{
					});

					i.bind(ItemStatsProvider.class).to(LocalItemStatsProvider.class).asEagerSingleton();
					i.bind(NpcDataProvider.class).to(LocalNpcDataProvider.class).asEagerSingleton();
					i.bind(ClientDataProvider.class).to(MockClientDataProvider.class).asEagerSingleton();
					i.bind(ClientDataProviderThreadProxy.class).to(MockClientDataProvider.MockClientDataProviderThreadProxy.class);
					i.bind(LiveDpsOverlay.class).toProvider(Providers.of(null));
					i.bind(PartyDpsService.class).toProvider(Providers.of(null));
				})
		);

		SwingUtilities.invokeAndWait(() ->
		{
			// roughly copied from RuneLite's ClientUI.java init()
			// todo?
//			SwingUtil.setupDefaults();
//			SwingUtil.setTheme(new SubstanceRuneLiteLookAndFeel());
//			SwingUtil.setFont(FontManager.getRunescapeFont());

			JFrame frame = new JFrame();
			frame.getLayeredPane().setCursor(Cursor.getDefaultCursor());
			frame.add(testInjector.getInstance(DpsPluginPanel.class));

			frame.setSize(242, 800);
			frame.setResizable(false);
			frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
			frame.setVisible(true);
		});
	}

}

package com.duckblade.osrs.dpscalc;

import com.duckblade.osrs.dpscalc.calc.model.Skills;
import java.util.Arrays;
import java.util.stream.Collectors;
import net.runelite.api.Skill;

public class TestSkills
{

	public static final Skills MAXED = Skills.builder()
		.boosts(Arrays.stream(Skill.values()).collect(Collectors.toMap(skill -> skill, skill -> 99)))
		.build();

	public static final Skills MAXED_WITH_BOOSTS = MAXED.toBuilderDeep()
		.boost(Skill.ATTACK, 19) // super combat
		.boost(Skill.STRENGTH, 19) // super combat
		.boost(Skill.DEFENCE, 21) // sara brew
		.boost(Skill.RANGED, 13) // ranging potion
		.boost(Skill.MAGIC, 10) // imbued heart
		.build();

}

package com.duckblade.osrs.dpscalc.calc.util;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import java.time.Duration;

public abstract class TicksToDurationComputable implements Computable<Duration>
{

	public static final long MILLIS_PER_TICK = 600;

	protected abstract int getTicks(ComputeContext context);

	@Override
	public Duration compute(ComputeContext context)
	{
		int ticks = getTicks(context);
		if (ticks < 0)
		{
			return null;
		}

		return Duration.ofMillis(ticks * MILLIS_PER_TICK);
	}
}

package com.duckblade.osrs.dpscalc.calc.util;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import java.util.Map;
import java.util.Set;
import java.util.function.ToDoubleFunction;
import net.runelite.api.Skill;

// "Effective levels" come up a lot across both attack and strength rolls
public abstract class EffectiveLevelComputable implements Computable<Integer>
{

	protected abstract Skill getBaseSkill();

	protected abstract Prayer.PrayerGroup getPrayerGroup();

	protected abstract ToDoubleFunction<Prayer> getPrayerMultiplier();

	protected abstract int getBaseBonus();

	protected abstract Map<CombatStyle, Integer> getCombatFocusBonuses();

	@Override
	public Integer compute(ComputeContext context)
	{
		Skills skills = context.get(ComputeInputs.ATTACKER_SKILLS);
		int strLevel = skills.getTotals().get(getBaseSkill());

		Set<Prayer> prayers = context.get(ComputeInputs.ATTACKER_PRAYERS);
		double prayerBonus = prayers.stream()
			.filter(p -> p.getPrayerGroup() == this.getPrayerGroup())
			.mapToDouble(getPrayerMultiplier())
			.max()
			.orElse(1.0);

		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		int weaponModeBonus = getBaseBonus() + getCombatFocusBonuses().getOrDefault(attackStyle.getCombatStyle(), 0);

		return (int) (strLevel * prayerBonus + weaponModeBonus);
	}
}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.util.TicksToDurationComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DpsComputable implements Computable<Double>
{

	private static final double SECONDS_PER_TICK = (TicksToDurationComputable.MILLIS_PER_TICK / 1000.0);

	private final DptComputable dptComputable;

	@Override
	public Double compute(ComputeContext context)
	{
		return context.get(dptComputable) / SECONDS_PER_TICK;
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.ammo.AmmoSlotItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import java.util.Map;
import java.util.Objects;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AttackerItemStatsComputable implements Computable<ItemStats>
{

	// this one is a bit more complicated since it depends whether you're using an ammo-based weapon
	private final AmmoSlotItemStatsComputable ammoSlotItemStatsComputable;

	@Override
	public ItemStats compute(ComputeContext context)
	{
		Map<EquipmentInventorySlot, ItemStats> itemStats = context.get(ComputeInputs.ATTACKER_ITEMS);
		ItemStats ammoless = itemStats.entrySet()
			.stream()
			.filter(is -> is.getKey() != EquipmentInventorySlot.AMMO)
			.map(Map.Entry::getValue)
			.filter(Objects::nonNull)
			.reduce(AttackerItemStatsComputable::reduce)
			.orElse(ItemStats.EMPTY);

		ItemStats ammoSlot = context.get(ammoSlotItemStatsComputable);
		ItemStats preShadow = reduce(ammoless, ammoSlot);

		// todo if anything else ever gets functionality similar, move this out to a better structure
		ItemStats weapon = itemStats.get(EquipmentInventorySlot.WEAPON);
		if (weapon != null && weapon.getItemId() == ItemID.TUMEKENS_SHADOW)
		{
			return preShadow.toBuilder()
				.accuracyMagic(3 * preShadow.getAccuracyMagic())
				.strengthMagic(3 * preShadow.getStrengthMagic())
				.build();
		}

		return preShadow;
	}

	public static ItemStats reduce(ItemStats a, ItemStats b)
	{
		ItemStats.ItemStatsBuilder builder = ItemStats.builder()
			.accuracyStab(a.getAccuracyStab() + b.getAccuracyStab())
			.accuracySlash(a.getAccuracySlash() + b.getAccuracySlash())
			.accuracyCrush(a.getAccuracyCrush() + b.getAccuracyCrush())
			.accuracyRanged(a.getAccuracyRanged() + b.getAccuracyRanged())
			.accuracyMagic(a.getAccuracyMagic() + b.getAccuracyMagic())
			.strengthMelee(a.getStrengthMelee() + b.getStrengthMelee())
			.strengthRanged(a.getStrengthRanged() + b.getStrengthRanged())
			.strengthMagic(a.getStrengthMagic() + b.getStrengthMagic())
			.prayer(a.getPrayer() + b.getPrayer());

		ItemStats weapon = getWeapon(a, b);
		if (weapon != null)
		{
			builder = builder.speed(weapon.getSpeed())
				.slot(EquipmentInventorySlot.WEAPON.getSlotIdx())
				.is2h(weapon.is2h())
				.weaponCategory(weapon.getWeaponCategory());
		}

		return builder.build();
	}

	private static ItemStats getWeapon(ItemStats a, ItemStats b)
	{
		int weaponSlot = EquipmentInventorySlot.WEAPON.getSlotIdx();
		if (a.getSlot() == weaponSlot)
		{
			return a;
		}
		else if (b.getSlot() == weaponSlot)
		{
			return b;
		}

		return null;
	}

}

package com.duckblade.osrs.dpscalc.calc.prayer;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class PrayerDrainComputable implements Computable<Integer>
{

	@Override
	public Integer compute(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACKER_PRAYERS).stream()
			.mapToInt(Prayer::getDrainRate)
			.sum();
	}

}

package com.duckblade.osrs.dpscalc.calc.prayer;

import com.duckblade.osrs.dpscalc.calc.AttackerItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.util.TicksToDurationComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class PrayerDurationRemainingComputable extends TicksToDurationComputable
{

	private final AttackerItemStatsComputable attackerItemStatsComputable;
	private final PrayerDrainComputable prayerDrainComputable;

	@Override
	public int getTicks(ComputeContext context)
	{
		int drain = context.get(prayerDrainComputable);
		if (drain == 0)
		{
			return -1;
		}

		int points = context.get(ComputeInputs.ATTACKER_SKILLS).getTotals().get(Skill.PRAYER);
		int resistance = 2 * context.get(attackerItemStatsComputable).getPrayer() + 60;
		int buffer = points * resistance;

		// always round up, so we cast to double to force decimal precision
		return (int) Math.ceil((double) buffer / drain);
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class TomesGearBonus implements GearBonusComputable
{

	private static final Set<Integer> TOME_OF_FIRE = ImmutableSet.of(
		ItemID.TOME_OF_FIRE
	);

	private static final Set<Spell> FIRE_SPELLS = ImmutableSet.of(
		Spell.FIRE_STRIKE,
		Spell.FIRE_BOLT,
		Spell.FIRE_BLAST,
		Spell.FIRE_WAVE,
		Spell.FIRE_SURGE
	);

	private static final Set<Integer> TOME_OF_WATER = ImmutableSet.of(
		ItemID.TOME_OF_WATER
	);

	private static final Set<Spell> WATER_SPELLS = ImmutableSet.of(
		Spell.WATER_STRIKE,
		Spell.WATER_BOLT,
		Spell.WATER_BLAST,
		Spell.WATER_WAVE,
		Spell.WATER_SURGE
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		int offHand = context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.SHIELD);
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		boolean usingMagic = attackStyle.getAttackType() == AttackType.MAGIC;
		boolean castingSpell = attackStyle.getCombatStyle() == CombatStyle.AUTOCAST || attackStyle.isManualCast();
		return usingMagic && castingSpell && (TOME_OF_FIRE.contains(offHand) || TOME_OF_WATER.contains(offHand));
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		int offHand = context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.SHIELD);
		Spell spell = context.get(ComputeInputs.SPELL);
		if (TOME_OF_FIRE.contains(offHand) && FIRE_SPELLS.contains(spell))
		{
			return GearBonuses.of(1.0, 1.5);
		}
		else if (TOME_OF_WATER.contains(offHand) && WATER_SPELLS.contains(spell))
		{
			return GearBonuses.symmetric(1.2);
		}

		return GearBonuses.EMPTY;
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class LeafyGearBonus implements GearBonusComputable
{

	private static final Set<Integer> LEAF_BLADED_WEAPONS = ImmutableSet.of(
		ItemID.LEAFBLADED_BATTLEAXE,
		ItemID.LEAFBLADED_SPEAR,
		ItemID.LEAFBLADED_SPEAR_4159, // unused id
		ItemID.LEAFBLADED_SWORD
	);

	// gets bonus
	private static final Set<Integer> LEAF_BLADED_ENHANCED = ImmutableSet.of(
		ItemID.LEAFBLADED_BATTLEAXE
	);

	private static final Set<Integer> LEAF_BLADED_AMMO = ImmutableSet.of(
		ItemID.BROAD_ARROWS, // also unused, i think
		ItemID.BROAD_ARROWS_4160,
		ItemID.BROAD_BOLTS,
		ItemID.AMETHYST_BROAD_BOLTS
	);

	private static final Set<Spell> LEAF_BLADED_SPELLS = ImmutableSet.of(
		Spell.MAGIC_DART
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.DEFENDER_ATTRIBUTES).isLeafy();
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		// we have to ensure to 0 out damage here on failure paths
		// since leafy monsters are immune to non-leafy attacks
		switch (context.get(ComputeInputs.ATTACK_STYLE).getAttackType())
		{
			case MAGIC:
				Spell spell = context.get(ComputeInputs.SPELL);
				if (LEAF_BLADED_SPELLS.contains(spell))
				{
					return GearBonuses.EMPTY;
				}

				context.warn("Leafy creatures are immune to magic spells other than Magic Dart.");
				return GearBonuses.symmetric(0);

			case RANGED:
				int ammo = context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.AMMO);
				if (LEAF_BLADED_AMMO.contains(ammo))
				{
					return GearBonuses.EMPTY;
				}

				context.warn("Leafy creatures are immune to ranged unless using broad bolts/arrows.");
				return GearBonuses.symmetric(0);

			default:
				int weapon = context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.WEAPON);
				if (LEAF_BLADED_WEAPONS.contains(weapon))
				{
					return LEAF_BLADED_ENHANCED.contains(weapon) ? GearBonuses.symmetric(1.175) : GearBonuses.EMPTY;
				}

				context.warn("Leafy creatures are immune to melee unless using a leaf-bladed weapon.");
				return GearBonuses.symmetric(0);
		}
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.defender.DefenderSkillsComputable;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class TbowGearBonus implements GearBonusComputable
{

	private static final Set<Integer> TBOW_IDS = ImmutableSet.of(
		ItemID.TWISTED_BOW
	);

	private static final int LOW_MAGIC_WARN_THRESHOLD = 100;

	private final WeaponComputable weaponComputable;
	private final DefenderSkillsComputable defenderSkillsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return TBOW_IDS.contains(context.get(weaponComputable).getItemId());
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		int defenderMagicLevel = context.get(defenderSkillsComputable).getTotals().getOrDefault(Skill.MAGIC, 0);
		int defenderMagicAccuracy = context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getAccuracyMagic();

		int magic = Math.min(250, Math.max(defenderMagicLevel, defenderMagicAccuracy));
		if (magic < LOW_MAGIC_WARN_THRESHOLD)
		{
			context.warn("Using the twisted bow against low-magic targets incurs negative bonuses.");
		}

		return GearBonuses.of(tbowFormula(magic, true), tbowFormula(magic, false));
	}

	// formulas are the same shape with different static values
	@VisibleForTesting
	static double tbowFormula(int magic, boolean accuracy)
	{
		double base = accuracy ? 140.0 : 250.0;
		double sub = accuracy ? 10.0 : 14.0;

		double t2 = (3.0 * magic - sub) / 100.0;
		double t3 = Math.pow((3.0 * magic) / 10.0 - (10.0 * sub), 2.0) / 100.0;
		return (base + t2 - t3) / 100.0;
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class InquisitorsGearBonus implements GearBonusComputable
{

	private static final Set<Integer> INQ_HELM_IDS = ImmutableSet.of(
		ItemID.INQUISITORS_GREAT_HELM
	);

	private static final Set<Integer> INQ_BODY_IDS = ImmutableSet.of(
		ItemID.INQUISITORS_HAUBERK
	);

	private static final Set<Integer> INQ_LEGS_IDS = ImmutableSet.of(
		ItemID.INQUISITORS_PLATESKIRT
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		return INQ_HELM_IDS.contains(equipment.get(EquipmentInventorySlot.HEAD)) ||
			INQ_BODY_IDS.contains(equipment.get(EquipmentInventorySlot.BODY)) ||
			INQ_LEGS_IDS.contains(equipment.get(EquipmentInventorySlot.LEGS));
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		if (context.get(ComputeInputs.ATTACK_STYLE).getAttackType() != AttackType.CRUSH)
		{
			context.warn("Wearing inquisitor's armour without attacking on crush provides no bonuses.");
			return GearBonuses.EMPTY;
		}

		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		boolean helm = INQ_HELM_IDS.contains(equipment.get(EquipmentInventorySlot.HEAD));
		boolean body = INQ_BODY_IDS.contains(equipment.get(EquipmentInventorySlot.BODY));
		boolean legs = INQ_LEGS_IDS.contains(equipment.get(EquipmentInventorySlot.LEGS));

		double inqMod = 1.0;
		if (helm && body && legs)
		{
			// full set gives extra bonus
			inqMod += 0.025;
		}
		else
		{
			inqMod += (helm ? 0.005 : 0.0) +
				(body ? 0.005 : 0.0) +
				(legs ? 0.005 : 0.0);
		}

		return GearBonuses.symmetric(inqMod);
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AggregateGearBonusesComputable implements Computable<GearBonuses>
{

	private final Set<GearBonusComputable> gearBonusComputables;

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		return gearBonusComputables.stream()
			.filter(gbc -> gbc.isApplicable(context))
			.map(context::get)
			.reduce(GearBonuses::combine)
			.orElse(GearBonuses.EMPTY);
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs.DEFENDER_ATTRIBUTES;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class KerisGearBonus implements GearBonusComputable
{

	public static final Set<Integer> KERIS_IDS = ImmutableSet.of(
		ItemID.KERIS,
		ItemID.KERISP,
		ItemID.KERISP_10583,
		ItemID.KERISP_10584,
		ItemID.KERIS_PARTISAN,
		ItemID.KERIS_PARTISAN_OF_BREACHING
	);

	private static final GearBonuses KERIS_STRENGTH_BONUS = GearBonuses.of(1.0, 1.33);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		boolean wieldingKeris = KERIS_IDS.contains(context.get(weaponComputable).getItemId());
		boolean usingMelee = context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee();
		return wieldingKeris && usingMelee;
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		if (!context.get(DEFENDER_ATTRIBUTES).isKalphite())
		{
			return GearBonuses.EMPTY;
		}

		return KERIS_STRENGTH_BONUS;
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class VampyreBaneGearBonus implements GearBonusComputable
{

	private static final Map<Integer, GearBonuses> weaponToBonus = ImmutableMap.of(
		ItemID.IVANDIS_FLAIL, GearBonuses.of(1, 1.20),
		ItemID.BLISTERWOOD_SICKLE, GearBonuses.of(1.05, 1.15),
		ItemID.BLISTERWOOD_FLAIL, GearBonuses.of(1.05, 1.25)
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		int weapon = context.get(weaponComputable).getItemId();
		if (!weaponToBonus.containsKey(weapon))
		{
			return false;
		}

		if (!context.get(ComputeInputs.DEFENDER_ATTRIBUTES).isVampyre())
		{
			context.warn("Vampyrebane weapons against a non-vampyre target provide no bonuses.");
			return false;
		}

		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee();
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		int weapon = context.get(weaponComputable).getItemId();
		return weaponToBonus.getOrDefault(weapon, GearBonuses.EMPTY);
	}
}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs.DEFENDER_ATTRIBUTES;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.SpellMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class MageDemonbaneGearBonus implements GearBonusComputable
{

	private static final Set<Spell> DEMONBANE_SPELLS = ImmutableSet.of(
		Spell.INFERIOR_DEMONBANE,
		Spell.SUPERIOR_DEMONBANE,
		Spell.DARK_DEMONBANE
	);

	private final SpellMaxHitComputable spellMaxHitComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return spellMaxHitComputable.isApplicable(context) &&
			DEMONBANE_SPELLS.contains(context.get(ComputeInputs.SPELL));
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		if (!context.get(DEFENDER_ATTRIBUTES).isDemon())
		{
			context.warn("Demonbane spells cannot be used against non-demons.");
			return GearBonuses.symmetric(0.0);
		}

		boolean mark = context.get(ComputeInputs.USING_MARK_OF_DARKNESS);
		return GearBonuses.of(mark ? 1.4 : 1.2, 1.25);
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class SalveAmuletGearBonus implements GearBonusComputable
{

	private static final Set<Integer> SALVE_BASE = ImmutableSet.of(
		ItemID.SALVE_AMULET
	);

	private static final Set<Integer> SALVE_IMBUED = ImmutableSet.of(
		ItemID.SALVE_AMULETI,
		ItemID.SALVE_AMULETI_25250,
		ItemID.SALVE_AMULETI_26763,
		ItemID.SALVE_AMULETEI,
		ItemID.SALVE_AMULETEI_25278,
		ItemID.SALVE_AMULETEI_26782
	);

	private static final Set<Integer> SALVE_ENHANCED = ImmutableSet.of(
		ItemID.SALVE_AMULET_E,
		ItemID.SALVE_AMULETEI,
		ItemID.SALVE_AMULETEI_25278,
		ItemID.SALVE_AMULETEI_26782
	);

	private static final Set<Integer> SALVE_ALL = Sets.union(SALVE_IMBUED, Sets.union(SALVE_ENHANCED, SALVE_BASE));

	private static final GearBonuses UNENHANCED_MELEE_RANGED = GearBonuses.symmetric(7.0 / 6.0);
	private static final GearBonuses UNENHANCED_MAGE = GearBonuses.symmetric(1.15);
	private static final GearBonuses ENHANCED = GearBonuses.symmetric(6.0 / 5.0);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return SALVE_ALL.contains(context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.AMULET));
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		DefenderAttributes attributes = context.get(ComputeInputs.DEFENDER_ATTRIBUTES);
		if (!attributes.isUndead())
		{
			context.warn("Salve amulet against a non-undead target provides no bonuses.");
			return GearBonuses.EMPTY;
		}

		int amulet = context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.AMULET);
		AttackType attackType = context.get(ComputeInputs.ATTACK_STYLE).getAttackType();
		GearBonuses bonus = salveBonus(attackType, amulet);
		if (bonus == GearBonuses.EMPTY)
		{
			context.warn("Unimbued salve amulets provide no bonuses for mage/ranged.");
		}

		return bonus;
	}

	private GearBonuses salveBonus(AttackType attackType, int amulet)
	{
		boolean imbued = SALVE_IMBUED.contains(amulet);
		boolean enhanced = SALVE_ENHANCED.contains(amulet);
		switch (attackType)
		{
			case MAGIC:
				if (imbued)
				{
					if (enhanced)
					{
						return ENHANCED;
					}
					return UNENHANCED_MAGE;
				}
				return GearBonuses.EMPTY;

			case RANGED:
				if (imbued)
				{
					if (enhanced)
					{
						return ENHANCED;
					}
					return UNENHANCED_MELEE_RANGED;
				}
				return GearBonuses.EMPTY;

			default:
				if (enhanced)
				{
					return ENHANCED;
				}
				return UNENHANCED_MELEE_RANGED;
		}
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.VoidLevelComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.VoidLevel;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class VoidGearBonus implements GearBonusComputable
{

	private final VoidLevelComputable voidLevelComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		switch (context.get(voidLevelComputable))
		{
			case ELITE:
			case REGULAR:
				return true;

			default:
				return false;
		}
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		boolean eliteVoid = context.get(voidLevelComputable) == VoidLevel.ELITE;
		switch (context.get(ComputeInputs.ATTACK_STYLE).getAttackType())
		{
			case MAGIC:
				return GearBonuses.of(1.45, eliteVoid ? 1.025 : 1.0);

			case RANGED:
				return GearBonuses.of(1.1, eliteVoid ? 1.125 : 1.1);

			default:
				return GearBonuses.symmetric(1.1);
		}
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.google.common.collect.ImmutableMap;
import java.util.Arrays;
import java.util.Map;
import java.util.function.ToDoubleFunction;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ChinchompaDistanceGearBonus implements GearBonusComputable
{

	@RequiredArgsConstructor
	@Getter
	private enum ChinchompaRange
	{
		SHORT(3, 1.0, 0.75, 0.5),
		MEDIUM(6, 0.75, 1.0, 0.75),
		LONG(Integer.MAX_VALUE, 0.5, 0.75, 1.0),
		;

		private final int maxDistance;
		private final double shortFuseAccuracy;
		private final double mediumFuseAccuracy;
		private final double longFuseAccuracy;

		public static ChinchompaRange forRange(int range)
		{
			// noinspection OptionalGetWithoutIsPresent
			return Arrays.stream(values())
				.filter(r -> range <= r.getMaxDistance())
				.findFirst()
				.get();
		}
	}

	private static final Map<CombatStyle, ToDoubleFunction<ChinchompaRange>> ACCURACY_BONUS_MAP = ImmutableMap.of(
		CombatStyle.ACCURATE, ChinchompaRange::getShortFuseAccuracy,
		CombatStyle.RAPID, ChinchompaRange::getMediumFuseAccuracy,
		CombatStyle.LONGRANGE, ChinchompaRange::getLongFuseAccuracy
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType() == AttackType.RANGED &&
			context.get(weaponComputable).getWeaponCategory() == WeaponCategory.CHINCHOMPAS;
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		context.warn("Chinchompa calculation does not support splash damage. Results listed are for a single target.");

		double accuracy = ACCURACY_BONUS_MAP.get(context.get(ComputeInputs.ATTACK_STYLE).getCombatStyle())
			.applyAsDouble(ChinchompaRange.forRange(context.get(ComputeInputs.ATTACK_DISTANCE)));
		return GearBonuses.of(accuracy, 1.0);
	}
}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import static com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs.ATTACK_STYLE;
import static com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs.DEFENDER_ATTRIBUTES;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DragonHunterGearBonus implements GearBonusComputable
{

	private static final Set<Integer> DRAGON_HUNTER_MELEE = ImmutableSet.of(
		ItemID.DRAGON_HUNTER_LANCE
	);

	private static final Set<Integer> DRAGON_HUNTER_RANGED = ImmutableSet.of(
		ItemID.DRAGON_HUNTER_CROSSBOW,
		ItemID.DRAGON_HUNTER_CROSSBOW_B,
		ItemID.DRAGON_HUNTER_CROSSBOW_T
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		int weapon = context.get(weaponComputable).getItemId();
		switch (context.get(ATTACK_STYLE).getAttackType())
		{
			case MAGIC:
				return false;

			case RANGED:
				return DRAGON_HUNTER_RANGED.contains(weapon);

			default:
				return DRAGON_HUNTER_MELEE.contains(weapon);
		}
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		if (!context.get(DEFENDER_ATTRIBUTES).isDragon())
		{
			context.warn("Using dragon hunter weaponry against non-dragons provides no bonuses.");
			return GearBonuses.EMPTY;
		}

		ItemStats weapon = context.get(weaponComputable);
		if (DRAGON_HUNTER_MELEE.contains(weapon.getItemId()))
		{
			return GearBonuses.symmetric(1.2);
		}
		return GearBonuses.of(1.30, 1.25);
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Spellbook;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class SmokeBattlestaffGearBonus implements GearBonusComputable
{

	private static final Set<Integer> SMOKE_BATTLESTAVES = ImmutableSet.of(
		ItemID.SMOKE_BATTLESTAFF,
		ItemID.MYSTIC_SMOKE_STAFF
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType() == AttackType.MAGIC &&
			SMOKE_BATTLESTAVES.contains(context.get(weaponComputable).getItemId()) &&
			context.get(ComputeInputs.SPELL).getSpellbook() == Spellbook.STANDARD;
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		return GearBonuses.symmetric(1.1);
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class BlackMaskGearBonus implements GearBonusComputable
{

	private static final Set<Integer> BLACK_MASKS_MAGE_RANGED = ImmutableSet.of(
		ItemID.BLACK_MASK_I,
		ItemID.BLACK_MASK_I_25276,
		ItemID.BLACK_MASK_I_26781,
		ItemID.BLACK_MASK_1_I,
		ItemID.BLACK_MASK_1_I_25275,
		ItemID.BLACK_MASK_1_I_26780,
		ItemID.BLACK_MASK_2_I,
		ItemID.BLACK_MASK_2_I_25274,
		ItemID.BLACK_MASK_2_I_26779,
		ItemID.BLACK_MASK_3_I,
		ItemID.BLACK_MASK_3_I_25273,
		ItemID.BLACK_MASK_3_I_26778,
		ItemID.BLACK_MASK_4_I,
		ItemID.BLACK_MASK_4_I_25272,
		ItemID.BLACK_MASK_4_I_26777,
		ItemID.BLACK_MASK_5_I,
		ItemID.BLACK_MASK_5_I_25271,
		ItemID.BLACK_MASK_5_I_26776,
		ItemID.BLACK_MASK_6_I,
		ItemID.BLACK_MASK_6_I_25270,
		ItemID.BLACK_MASK_6_I_26775,
		ItemID.BLACK_MASK_7_I,
		ItemID.BLACK_MASK_7_I_25269,
		ItemID.BLACK_MASK_7_I_26774,
		ItemID.BLACK_MASK_8_I,
		ItemID.BLACK_MASK_8_I_25268,
		ItemID.BLACK_MASK_8_I_26773,
		ItemID.BLACK_MASK_9_I,
		ItemID.BLACK_MASK_9_I_25267,
		ItemID.BLACK_MASK_9_I_26772,
		ItemID.BLACK_MASK_10_I,
		ItemID.BLACK_MASK_10_I_25266,
		ItemID.BLACK_MASK_10_I_26771,
		ItemID.SLAYER_HELMET_I,
		ItemID.SLAYER_HELMET_I_25177,
		ItemID.SLAYER_HELMET_I_26674,
		ItemID.BLACK_SLAYER_HELMET_I,
		ItemID.BLACK_SLAYER_HELMET_I_25179,
		ItemID.BLACK_SLAYER_HELMET_I_26675,
		ItemID.GREEN_SLAYER_HELMET_I,
		ItemID.GREEN_SLAYER_HELMET_I_25181,
		ItemID.GREEN_SLAYER_HELMET_I_26676,
		ItemID.HYDRA_SLAYER_HELMET_I,
		ItemID.HYDRA_SLAYER_HELMET_I_25189,
		ItemID.HYDRA_SLAYER_HELMET_I_26680,
		ItemID.PURPLE_SLAYER_HELMET_I,
		ItemID.PURPLE_SLAYER_HELMET_I_25185,
		ItemID.PURPLE_SLAYER_HELMET_I_26678,
		ItemID.RED_SLAYER_HELMET_I,
		ItemID.RED_SLAYER_HELMET_I_25183,
		ItemID.RED_SLAYER_HELMET_I_26677,
		ItemID.TURQUOISE_SLAYER_HELMET_I,
		ItemID.TURQUOISE_SLAYER_HELMET_I_25187,
		ItemID.TURQUOISE_SLAYER_HELMET_I_26679,
		ItemID.TWISTED_SLAYER_HELMET_I,
		ItemID.TWISTED_SLAYER_HELMET_I_25191,
		ItemID.TWISTED_SLAYER_HELMET_I_26681,
		ItemID.TZKAL_SLAYER_HELMET_I,
		ItemID.TZKAL_SLAYER_HELMET_I_25914,
		ItemID.TZKAL_SLAYER_HELMET_I_26684,
		ItemID.TZTOK_SLAYER_HELMET_I,
		ItemID.TZTOK_SLAYER_HELMET_I_25902,
		ItemID.TZTOK_SLAYER_HELMET_I_26682,
		ItemID.VAMPYRIC_SLAYER_HELMET_I,
		ItemID.VAMPYRIC_SLAYER_HELMET_I_25908,
		ItemID.VAMPYRIC_SLAYER_HELMET_I_26683
	);

	private static final Set<Integer> BLACK_MASKS_MELEE = Sets.union(ImmutableSet.of(
		ItemID.BLACK_MASK,
		ItemID.BLACK_MASK_1,
		ItemID.BLACK_MASK_2,
		ItemID.BLACK_MASK_3,
		ItemID.BLACK_MASK_4,
		ItemID.BLACK_MASK_5,
		ItemID.BLACK_MASK_6,
		ItemID.BLACK_MASK_7,
		ItemID.BLACK_MASK_8,
		ItemID.BLACK_MASK_9,
		ItemID.BLACK_MASK_10,
		ItemID.SLAYER_HELMET,
		ItemID.BLACK_SLAYER_HELMET,
		ItemID.GREEN_SLAYER_HELMET,
		ItemID.HYDRA_SLAYER_HELMET,
		ItemID.PURPLE_SLAYER_HELMET,
		ItemID.RED_SLAYER_HELMET,
		ItemID.TURQUOISE_SLAYER_HELMET,
		ItemID.TWISTED_SLAYER_HELMET,
		ItemID.TZKAL_SLAYER_HELMET,
		ItemID.TZTOK_SLAYER_HELMET,
		ItemID.VAMPYRIC_SLAYER_HELMET
	), BLACK_MASKS_MAGE_RANGED);

	private static final GearBonuses BLACK_MASK_MELEE = GearBonuses.symmetric(7.0 / 6.0);
	private static final GearBonuses BLACK_MASK_RANGED_MAGE = GearBonuses.symmetric(1.15);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;
	private final SalveAmuletGearBonus salveAmuletGearBonus;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return BLACK_MASKS_MELEE.contains(context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.HEAD));
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		if (!context.get(ComputeInputs.ON_SLAYER_TASK))
		{
			context.warn("Black mask/Slayer helmet off-task provides minimal or negative accuracy bonuses.");
			return GearBonuses.EMPTY;
		}

		if (salveAmuletGearBonus.isApplicable(context))
		{
			context.warn("Black mask/Slayer helmet does not stack with salve amulet.");
			return GearBonuses.EMPTY;
		}

		AttackType attackType = context.get(ComputeInputs.ATTACK_STYLE).getAttackType();
		switch (attackType)
		{
			case MAGIC:
			case RANGED:
				int helmet = context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.HEAD);
				if (!BLACK_MASKS_MAGE_RANGED.contains(helmet))
				{
					context.warn("Unimbued Black mask/Slayer helmet provides negative bonuses for ranged/magic.");
					return GearBonuses.EMPTY;
				}
				return BLACK_MASK_RANGED_MAGE;

			default:
				return BLACK_MASK_MELEE;
		}
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AhrimsAutocastGearBonus implements GearBonusComputable
{

	private static final Set<Integer> AHRIMS_STAFF_IDS = ImmutableSet.of(
		ItemID.AHRIMS_STAFF,
		ItemID.AHRIMS_STAFF_100,
		ItemID.AHRIMS_STAFF_75,
		ItemID.AHRIMS_STAFF_50,
		ItemID.AHRIMS_STAFF_25
	);

	private static final Set<Integer> AHRIMS_HOOD_IDS = ImmutableSet.of(
		ItemID.AHRIMS_HOOD,
		ItemID.AHRIMS_HOOD_100,
		ItemID.AHRIMS_HOOD_75,
		ItemID.AHRIMS_HOOD_50,
		ItemID.AHRIMS_HOOD_25
	);

	private static final Set<Integer> AHRIMS_ROBETOP_IDS = ImmutableSet.of(
		ItemID.AHRIMS_ROBETOP,
		ItemID.AHRIMS_ROBETOP_100,
		ItemID.AHRIMS_ROBETOP_75,
		ItemID.AHRIMS_ROBETOP_50,
		ItemID.AHRIMS_ROBETOP_25
	);

	private static final Set<Integer> AHRIMS_ROBESKIRT_IDS = ImmutableSet.of(
		ItemID.AHRIMS_ROBESKIRT,
		ItemID.AHRIMS_ROBESKIRT_100,
		ItemID.AHRIMS_ROBESKIRT_75,
		ItemID.AHRIMS_ROBESKIRT_50,
		ItemID.AHRIMS_ROBESKIRT_25
	);

	private static final Set<Integer> AMULET_OF_THE_DAMNED = ImmutableSet.of(
		ItemID.AMULET_OF_THE_DAMNED,
		ItemID.AMULET_OF_THE_DAMNED_FULL
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		if (attackStyle.getAttackType() != AttackType.MAGIC)
		{
			return false;
		}

		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		boolean ahrimsWithAmulet = AHRIMS_STAFF_IDS.contains(equipment.get(EquipmentInventorySlot.WEAPON)) &&
			AHRIMS_HOOD_IDS.contains(equipment.get(EquipmentInventorySlot.HEAD)) &&
			AHRIMS_ROBETOP_IDS.contains(equipment.get(EquipmentInventorySlot.BODY)) &&
			AHRIMS_ROBESKIRT_IDS.contains(equipment.get(EquipmentInventorySlot.LEGS)) &&
			AMULET_OF_THE_DAMNED.contains(equipment.get(EquipmentInventorySlot.AMULET));
		if (!ahrimsWithAmulet)
		{
			return false;
		}

		if (attackStyle.isManualCast())
		{
			context.warn("Ahrim's with amulet of the damned only provides 30% damage bonus when autocasting.");
			return false;
		}

		return true;
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		return GearBonuses.of(1.0, 1.3);
	}
}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import static com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs.DEFENDER_ATTRIBUTES;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class MeleeDemonbaneGearBonus implements GearBonusComputable
{

	private static final Set<Integer> DEMONBANE_L2 = ImmutableSet.of(
		ItemID.ARCLIGHT
	);

	private static final Set<Integer> DEMONBANE_L1 = ImmutableSet.of(
		ItemID.DARKLIGHT,
		ItemID.SILVERLIGHT,
		ItemID.SILVERLIGHT_6745 // stained black, mid-shadow of the storm
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		boolean melee = context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee();
		int weapon = context.get(weaponComputable).getItemId();
		return melee && (DEMONBANE_L1.contains(weapon) || DEMONBANE_L2.contains(weapon));
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		if (!context.get(DEFENDER_ATTRIBUTES).isDemon())
		{
			context.warn("Using demonbane weaponry against non-demons provides no bonuses.");
			return GearBonuses.EMPTY;
		}

		int weapon = context.get(weaponComputable).getItemId();
		if (DEMONBANE_L2.contains(weapon))
		{
			return GearBonuses.symmetric(1.7);
		}
		return GearBonuses.of(1.0, 1.6);
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class CrystalGearBonus implements GearBonusComputable
{

	private static final Set<Integer> CRYSTAL_BOWS = ImmutableSet.of(
		// there are a few dozen cbow ids from pre-rework but i think these are the only two in use now
		ItemID.CRYSTAL_BOW,
		ItemID.CRYSTAL_BOW_24123,
		ItemID.BOW_OF_FAERDHINEN,
		ItemID.BOW_OF_FAERDHINEN_C,
		ItemID.BOW_OF_FAERDHINEN_C_25869,
		ItemID.BOW_OF_FAERDHINEN_C_25884,
		ItemID.BOW_OF_FAERDHINEN_C_25886,
		ItemID.BOW_OF_FAERDHINEN_C_25888,
		ItemID.BOW_OF_FAERDHINEN_C_25890,
		ItemID.BOW_OF_FAERDHINEN_C_25892,
		ItemID.BOW_OF_FAERDHINEN_C_25896
	);

	private static final Set<Integer> CRYSTAL_HELM_IDS = ImmutableSet.of(
		ItemID.CRYSTAL_HELM,
		ItemID.CRYSTAL_HELM_27705,
		ItemID.CRYSTAL_HELM_27717,
		ItemID.CRYSTAL_HELM_27729,
		ItemID.CRYSTAL_HELM_27741,
		ItemID.CRYSTAL_HELM_27753,
		ItemID.CRYSTAL_HELM_27765,
		ItemID.CRYSTAL_HELM_27777
	);

	private static final Set<Integer> CRYSTAL_BODY_IDS = ImmutableSet.of(
		ItemID.CRYSTAL_BODY,
		ItemID.CRYSTAL_BODY_27697,
		ItemID.CRYSTAL_BODY_27709,
		ItemID.CRYSTAL_BODY_27721,
		ItemID.CRYSTAL_BODY_27733,
		ItemID.CRYSTAL_BODY_27745,
		ItemID.CRYSTAL_BODY_27757,
		ItemID.CRYSTAL_BODY_27769
	);

	private static final Set<Integer> CRYSTAL_LEGS_IDS = ImmutableSet.of(
		ItemID.CRYSTAL_LEGS,
		ItemID.CRYSTAL_LEGS_27701,
		ItemID.CRYSTAL_LEGS_27713,
		ItemID.CRYSTAL_LEGS_27725,
		ItemID.CRYSTAL_LEGS_27737,
		ItemID.CRYSTAL_LEGS_27749,
		ItemID.CRYSTAL_LEGS_27761,
		ItemID.CRYSTAL_LEGS_27773
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return CRYSTAL_BOWS.contains(context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.WEAPON));
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		// no set bonus so we can treat each piece individually
		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		double bonus = 0.0;

		if (CRYSTAL_HELM_IDS.contains(equipment.get(EquipmentInventorySlot.HEAD)))
		{
			bonus += 0.05;
		}

		if (CRYSTAL_BODY_IDS.contains(equipment.get(EquipmentInventorySlot.BODY)))
		{
			bonus += 0.15;
		}

		if (CRYSTAL_LEGS_IDS.contains(equipment.get(EquipmentInventorySlot.LEGS)))
		{
			bonus += 0.10;
		}

		return GearBonuses.of(1.0 + bonus, 1.0 + (bonus / 2.0));
	}

}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.compute.OptionalComputable;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;

public interface GearBonusComputable extends OptionalComputable<GearBonuses>
{
}

package com.duckblade.osrs.dpscalc.calc.gearbonus;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.GearBonuses;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class RevenantWeaponGearBonus implements GearBonusComputable
{

	private static final Set<Integer> REVENANT_MELEE = ImmutableSet.of(
		ItemID.VIGGORAS_CHAINMACE
	);

	private static final Set<Integer> REVENANT_RANGED = ImmutableSet.of(
		ItemID.CRAWS_BOW
	);

	private static final Set<Integer> REVENANT_MAGE = ImmutableSet.of(
		ItemID.THAMMARONS_SCEPTRE
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		int weapon = context.get(weaponComputable).getItemId();

		// can't check only for weapon, since staff can bash and mace/bow can manual cast
		switch (context.get(ComputeInputs.ATTACK_STYLE).getAttackType())
		{
			case MAGIC:
				return REVENANT_MAGE.contains(weapon);

			case RANGED:
				return REVENANT_RANGED.contains(weapon);

			default:
				return REVENANT_MELEE.contains(weapon);
		}
	}

	@Override
	public GearBonuses compute(ComputeContext context)
	{
		if (!context.get(ComputeInputs.IN_WILDERNESS))
		{
			context.warn("Using revenant weapons outside the wilderness provides no bonuses.");
			return GearBonuses.EMPTY;
		}

		if (context.get(ComputeInputs.ATTACK_STYLE).getAttackType() == AttackType.MAGIC)
		{
			return GearBonuses.of(2.0, 1.25);
		}
		return GearBonuses.symmetric(1.5);
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.ammo.AmmoItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.ammo.AmmolessRangedAmmoItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.ammo.BlowpipeDartsItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.defender.skills.SkillScaling;
import com.duckblade.osrs.dpscalc.calc.defender.skills.TheatreSkillScaling;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.duckblade.osrs.dpscalc.calc.gearbonus.AhrimsAutocastGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.BlackMaskGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.ChinchompaDistanceGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.CrystalGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.DragonHunterGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.GearBonusComputable;
import com.duckblade.osrs.dpscalc.calc.gearbonus.InquisitorsGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.KerisGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.LeafyGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.MageDemonbaneGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.MeleeDemonbaneGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.RevenantWeaponGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.SalveAmuletGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.SmokeBattlestaffGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.TbowGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.TomesGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.VampyreBaneGearBonus;
import com.duckblade.osrs.dpscalc.calc.gearbonus.VoidGearBonus;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.CombatStyleImmunityMaxHitLimiter;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimiter;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.Tier2VampyreImmunities;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.Tier3VampyreImmunities;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.ZulrahMaxHitLimiter;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.MagicMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.MagicSalamanderMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.PoweredStaffMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.SpellMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.multihit.ColossalBladeDptComputable;
import com.duckblade.osrs.dpscalc.calc.multihit.DharoksDptComputable;
import com.duckblade.osrs.dpscalc.calc.multihit.KarilsDptComputable;
import com.duckblade.osrs.dpscalc.calc.multihit.KerisDptComputable;
import com.duckblade.osrs.dpscalc.calc.multihit.MultiHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.multihit.ScytheDptComputable;
import com.duckblade.osrs.dpscalc.calc.multihit.VeracsDptComputable;
import com.google.common.collect.ImmutableList;
import com.google.inject.AbstractModule;
import com.google.inject.TypeLiteral;
import com.google.inject.multibindings.Multibinder;
import com.google.inject.name.Names;
import java.util.List;

public class DpsComputeModule extends AbstractModule
{

	@Override
	protected void configure()
	{
		Multibinder<AmmoItemStatsComputable> ammoItemStatsComputables = Multibinder.newSetBinder(binder(), AmmoItemStatsComputable.class);
		ammoItemStatsComputables.addBinding().to(AmmolessRangedAmmoItemStatsComputable.class);
		ammoItemStatsComputables.addBinding().to(BlowpipeDartsItemStatsComputable.class);

		Multibinder<SkillScaling> defenderSkillsTransformers = Multibinder.newSetBinder(binder(), SkillScaling.class);
		defenderSkillsTransformers.addBinding().to(TheatreSkillScaling.class);

		Multibinder<GearBonusComputable> gearBonusComputables = Multibinder.newSetBinder(binder(), GearBonusComputable.class);
		gearBonusComputables.addBinding().to(AhrimsAutocastGearBonus.class);
		gearBonusComputables.addBinding().to(BlackMaskGearBonus.class);
		gearBonusComputables.addBinding().to(ChinchompaDistanceGearBonus.class);
		gearBonusComputables.addBinding().to(CrystalGearBonus.class);
		gearBonusComputables.addBinding().to(MageDemonbaneGearBonus.class);
		gearBonusComputables.addBinding().to(DragonHunterGearBonus.class);
		gearBonusComputables.addBinding().to(InquisitorsGearBonus.class);
		gearBonusComputables.addBinding().to(KerisGearBonus.class);
		gearBonusComputables.addBinding().to(LeafyGearBonus.class);
		gearBonusComputables.addBinding().to(MeleeDemonbaneGearBonus.class);
		gearBonusComputables.addBinding().to(RevenantWeaponGearBonus.class);
		gearBonusComputables.addBinding().to(SalveAmuletGearBonus.class);
		gearBonusComputables.addBinding().to(SmokeBattlestaffGearBonus.class);
		gearBonusComputables.addBinding().to(TbowGearBonus.class);
		gearBonusComputables.addBinding().to(TomesGearBonus.class);
		gearBonusComputables.addBinding().to(VampyreBaneGearBonus.class);
		gearBonusComputables.addBinding().to(VoidGearBonus.class);

		Multibinder<MagicMaxHitComputable> magicMaxHitComputables = Multibinder.newSetBinder(binder(), MagicMaxHitComputable.class);
		magicMaxHitComputables.addBinding().to(MagicSalamanderMaxHitComputable.class);
		magicMaxHitComputables.addBinding().to(PoweredStaffMaxHitComputable.class);
		magicMaxHitComputables.addBinding().to(SpellMaxHitComputable.class);

		Multibinder<MaxHitLimiter> maxHitLimiters = Multibinder.newSetBinder(binder(), MaxHitLimiter.class);
		maxHitLimiters.addBinding().to(CombatStyleImmunityMaxHitLimiter.class);
		maxHitLimiters.addBinding().to(Tier2VampyreImmunities.class);
		maxHitLimiters.addBinding().to(Tier3VampyreImmunities.class);
		maxHitLimiters.addBinding().to(ZulrahMaxHitLimiter.class);

		Multibinder<MultiHitDptComputable> multiHitDptComputables = Multibinder.newSetBinder(binder(), MultiHitDptComputable.class);
		multiHitDptComputables.addBinding().to(ColossalBladeDptComputable.class);
		multiHitDptComputables.addBinding().to(DharoksDptComputable.class);
		multiHitDptComputables.addBinding().to(KarilsDptComputable.class);
		multiHitDptComputables.addBinding().to(KerisDptComputable.class);
		multiHitDptComputables.addBinding().to(ScytheDptComputable.class);
		multiHitDptComputables.addBinding().to(VeracsDptComputable.class);

		// CHECKSTYLE:OFF
		bind(new TypeLiteral<List<ComputeOutput<Integer>>>() {})
			.annotatedWith(Names.named("EffectMaxHitOutputs"))
			.toInstance(ImmutableList.of(
				ColossalBladeDptComputable.COLOSSAL_BLADE_MAX_HIT,
				DharoksDptComputable.DHAROKS_MAX_HIT,
				KarilsDptComputable.KARILS_MAX_HIT,
				KerisDptComputable.KERIS_MAX_HIT,
				ScytheDptComputable.SCY_MAX_HIT_SUM
			));
		// CHECKSTYLE:ON

		bind(DptComputable.class).asEagerSingleton();
	}

}

package com.duckblade.osrs.dpscalc.calc.exceptions;

public class DpsComputeException extends RuntimeException
{

	public DpsComputeException(Exception inner)
	{
		super(inner);
	}

}

package com.duckblade.osrs.dpscalc.calc.exceptions;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;

public class MissingInputException extends RuntimeException
{

	public MissingInputException(ComputeInputs<?> missingInput)
	{
		super(String.format("ComputeInput [%s] was not supplied and has no default value.", missingInput.key()));
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
// utility class helps with checking for item requirements
// without having to null-check
public class EquipmentItemIdsComputable implements Computable<Map<EquipmentInventorySlot, Integer>>
{

	@Override
	public Map<EquipmentInventorySlot, Integer> compute(ComputeContext context)
	{
		Map<EquipmentInventorySlot, ItemStats> equipment = context.get(ComputeInputs.ATTACKER_ITEMS);
		return Arrays.stream(EquipmentInventorySlot.values())
			.collect(Collectors.toMap(
				k -> k,
				k -> equipment.getOrDefault(k, ItemStats.EMPTY).getItemId()
			));
	}

}

package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class EffectiveAttackLevelComputable implements Computable<Integer>
{

	private final MeleeEffectiveAttackLevelComputable meleeComputable;
	private final RangedEffectiveAttackLevelComputable rangedComputable;
	private final MageEffectiveAttackLevelComputable mageComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		switch (attackStyle.getAttackType())
		{
			case MAGIC:
				return context.get(mageComputable);

			case RANGED:
				return context.get(rangedComputable);

			default:
				return context.get(meleeComputable);
		}
	}
}

package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.gearbonus.AggregateGearBonusesComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AttackRollComputable implements Computable<Integer>
{

	private final EffectiveAttackLevelComputable effectiveAttackLevelComputable;
	private final AttackBonusComputable attackBonusComputable;
	private final AggregateGearBonusesComputable aggregateGearBonusesComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		int effectiveAttack = context.get(effectiveAttackLevelComputable);
		int attackBonus = context.get(attackBonusComputable);
		double accuracyGearBonus = context.get(aggregateGearBonusesComputable).getAccuracyBonus();

		return (int) (effectiveAttack * (attackBonus + 64) * accuracyGearBonus);
	}
}

package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.util.EffectiveLevelComputable;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import java.util.Collections;
import java.util.Map;
import java.util.function.ToDoubleFunction;
import javax.inject.Singleton;
import net.runelite.api.Skill;

@Singleton
public class RangedEffectiveAttackLevelComputable extends EffectiveLevelComputable
{

	@Override
	protected Skill getBaseSkill()
	{
		return Skill.RANGED;
	}

	@Override
	protected Prayer.PrayerGroup getPrayerGroup()
	{
		return Prayer.PrayerGroup.RANGED;
	}

	@Override
	protected ToDoubleFunction<Prayer> getPrayerMultiplier()
	{
		return Prayer::getAttackMod;
	}

	@Override
	protected int getBaseBonus()
	{
		return 8;
	}

	@Override
	protected Map<CombatStyle, Integer> getCombatFocusBonuses()
	{
		return Collections.singletonMap(CombatStyle.ACCURATE, 3);
	}
}

package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.AttackerItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AttackBonusComputable implements Computable<Integer>
{

	private final AttackerItemStatsComputable attackerItemStatsComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		ItemStats attackerItemStats = context.get(attackerItemStatsComputable);
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		switch (attackStyle.getAttackType())
		{
			case STAB:
				return attackerItemStats.getAccuracyStab();
			case SLASH:
				return attackerItemStats.getAccuracySlash();
			case CRUSH:
				return attackerItemStats.getAccuracyCrush();
			case RANGED:
				return attackerItemStats.getAccuracyRanged();
			default:
				return attackerItemStats.getAccuracyMagic();
		}
	}
}

package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.util.EffectiveLevelComputable;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import java.util.function.ToDoubleFunction;
import javax.inject.Singleton;
import net.runelite.api.Skill;

@Singleton
public class MageEffectiveAttackLevelComputable extends EffectiveLevelComputable
{

	@Override
	protected Skill getBaseSkill()
	{
		return Skill.MAGIC;
	}

	@Override
	protected Prayer.PrayerGroup getPrayerGroup()
	{
		return Prayer.PrayerGroup.MAGE;
	}

	@Override
	protected ToDoubleFunction<Prayer> getPrayerMultiplier()
	{
		return Prayer::getAttackMod;
	}

	@Override
	protected int getBaseBonus()
	{
		return 9;
	}

	@Override
	protected Map<CombatStyle, Integer> getCombatFocusBonuses()
	{
		return ImmutableMap.of(
			CombatStyle.ACCURATE, 2
		);
	}
}

package com.duckblade.osrs.dpscalc.calc.attack;

import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.util.EffectiveLevelComputable;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import java.util.function.ToDoubleFunction;
import javax.inject.Singleton;
import net.runelite.api.Skill;

@Singleton
public class MeleeEffectiveAttackLevelComputable extends EffectiveLevelComputable
{

	@Override
	protected Skill getBaseSkill()
	{
		return Skill.ATTACK;
	}

	@Override
	protected Prayer.PrayerGroup getPrayerGroup()
	{
		return Prayer.PrayerGroup.MELEE;
	}

	@Override
	protected ToDoubleFunction<Prayer> getPrayerMultiplier()
	{
		return Prayer::getAttackMod;
	}

	@Override
	protected int getBaseBonus()
	{
		return 8;
	}

	@Override
	protected Map<CombatStyle, Integer> getCombatFocusBonuses()
	{
		return ImmutableMap.of(
			CombatStyle.ACCURATE, 3,
			CombatStyle.CONTROLLED, 1
		);
	}
}

package com.duckblade.osrs.dpscalc.calc.ammo;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class BlowpipeDartsItemStatsComputable implements AmmoItemStatsComputable
{

	private static final Set<Integer> BLOWPIPE_IDS = ImmutableSet.of(
		ItemID.TOXIC_BLOWPIPE
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType() == AttackType.RANGED &&
			BLOWPIPE_IDS.contains(context.get(weaponComputable).getItemId());
	}

	@Override
	public ItemStats compute(ComputeContext context)
	{
		ItemStats darts = context.get(ComputeInputs.BLOWPIPE_DARTS);
		return context.get(ComputeInputs.ATTACKER_ITEMS)
			.getOrDefault(EquipmentInventorySlot.AMMO, ItemStats.EMPTY)
			.toBuilder()
			.accuracyRanged(darts.getAccuracyRanged())
			.strengthRanged(darts.getStrengthRanged())
			.build();
	}

}

package com.duckblade.osrs.dpscalc.calc.ammo;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AmmoSlotItemStatsComputable implements Computable<ItemStats>
{

	private final Set<AmmoItemStatsComputable> ammoItemStatsComputables;

	@Override
	public ItemStats compute(ComputeContext context)
	{
		return ammoItemStatsComputables.stream()
			.filter(c -> c.isApplicable(context))
			.findAny()
			.map(context::get)
			.orElseGet(() -> getDefault(context));
	}

	private ItemStats getDefault(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACKER_ITEMS)
			.getOrDefault(EquipmentInventorySlot.AMMO, ItemStats.EMPTY);
	}
}

package com.duckblade.osrs.dpscalc.calc.ammo;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AmmolessRangedAmmoItemStatsComputable implements AmmoItemStatsComputable
{

	private final static Set<Integer> AMMOLESS_RANGED_WEAPONS = ImmutableSet.of(
		ItemID.CRYSTAL_BOW,
		ItemID.CRYSTAL_BOW_24123,
		ItemID.BOW_OF_FAERDHINEN,
		ItemID.BOW_OF_FAERDHINEN_C,
		ItemID.BOW_OF_FAERDHINEN_C_25869,
		ItemID.BOW_OF_FAERDHINEN_C_25884,
		ItemID.BOW_OF_FAERDHINEN_C_25886,
		ItemID.BOW_OF_FAERDHINEN_C_25888,
		ItemID.BOW_OF_FAERDHINEN_C_25890,
		ItemID.BOW_OF_FAERDHINEN_C_25892,
		ItemID.BOW_OF_FAERDHINEN_C_25896
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType() == AttackType.RANGED &&
			AMMOLESS_RANGED_WEAPONS.contains(context.get(weaponComputable).getItemId());
	}

	@Override
	public ItemStats compute(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACKER_ITEMS)
			.getOrDefault(EquipmentInventorySlot.AMMO, ItemStats.EMPTY)
			.toBuilder()
			.strengthRanged(0)
			.accuracyRanged(0)
			.build();
	}

}

package com.duckblade.osrs.dpscalc.calc.ammo;

import com.duckblade.osrs.dpscalc.calc.compute.OptionalComputable;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;

public interface AmmoItemStatsComputable extends OptionalComputable<ItemStats>
{
}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class BaseHitDptComputable implements Computable<Double>
{

	private final HitChanceComputable hitChanceComputable;
	private final BaseMaxHitComputable baseMaxHitComputable;
	private final AttackSpeedComputable attackSpeedComputable;

	@Override
	public Double compute(ComputeContext context)
	{
		double hitChance = context.get(hitChanceComputable);
		int maxHit = context.get(baseMaxHitComputable);
		int attackSpeed = context.get(attackSpeedComputable);

		return byComponents(hitChance, maxHit, attackSpeed);
	}

	public static double byComponents(double hitChance, int maxHit, int attackSpeed)
	{
		return (hitChance * maxHit) / (2.0 * attackSpeed);
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.multihit.MultiHitDptComputable;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DptComputable implements Computable<Double>
{

	private final BaseHitDptComputable baseHitDptComputable;
	private final Set<MultiHitDptComputable> multiHitDptComputables;

	@Override
	public Double compute(ComputeContext context)
	{
		return multiHitDptComputables.stream()
			.filter(mhdc -> mhdc.isApplicable(context))
			.findFirst()
			.map(context::get)
			.orElseGet(() -> context.get(baseHitDptComputable));
	}

}

package com.duckblade.osrs.dpscalc.calc.compute;

import com.duckblade.osrs.dpscalc.calc.exceptions.MissingInputException;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import static java.util.Collections.emptyMap;
import static java.util.Collections.emptySet;
import java.util.Map;
import java.util.Set;
import lombok.AccessLevel;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;

@RequiredArgsConstructor(staticName = "of", access = AccessLevel.PACKAGE)
public class ComputeInputs<T> implements Computable<T>
{

	// attacker
	public static ComputeInputs<Skills> ATTACKER_SKILLS = ComputeInputs.of("AttackerSkills");
	public static ComputeInputs<Map<EquipmentInventorySlot, ItemStats>> ATTACKER_ITEMS = ComputeInputs.of("AttackerEquipment", emptyMap());
	public static ComputeInputs<Set<Prayer>> ATTACKER_PRAYERS = ComputeInputs.of("AttackerPrayers", emptySet());
	public static ComputeInputs<AttackStyle> ATTACK_STYLE = ComputeInputs.of("AttackStyle");
	public static ComputeInputs<Spell> SPELL = ComputeInputs.of("InputSpell");
	public static ComputeInputs<ItemStats> BLOWPIPE_DARTS = ComputeInputs.of("TbpDarts");
	public static ComputeInputs<Integer> ATTACK_DISTANCE = ComputeInputs.of("AttackDistance");

	// defender
	public static ComputeInputs<Skills> DEFENDER_SKILLS = ComputeInputs.of("DefenderSkillsInput");
	public static ComputeInputs<DefensiveBonuses> DEFENDER_BONUSES = ComputeInputs.of("DefenderBonuses");
	public static ComputeInputs<DefenderAttributes> DEFENDER_ATTRIBUTES = ComputeInputs.of("DefenderAttributes", DefenderAttributes.EMPTY);

	// extras
	public static ComputeInputs<Boolean> ON_SLAYER_TASK = ComputeInputs.of("OnSlayerTask", false);
	public static ComputeInputs<Boolean> USING_CHARGE_SPELL = ComputeInputs.of("UsingChargeSpell", false);
	public static ComputeInputs<Boolean> USING_MARK_OF_DARKNESS = ComputeInputs.of("UsingMarkOfDarkness", false);
	public static ComputeInputs<Boolean> IN_WILDERNESS = ComputeInputs.of("InWilderness", false);
	public static ComputeInputs<Integer> RAID_PARTY_SIZE = ComputeInputs.of("RaidPartySize");

	private final String key;

	private final T defaultValue;

	@Override
	public String key()
	{
		return this.key;
	}

	@Override
	public T compute(ComputeContext context)
	{
		if (defaultValue != null)
		{
			return defaultValue;
		}

		throw new MissingInputException(this);
	}

	public static <T> ComputeInputs<T> of(String key)
	{
		return new ComputeInputs<>(key, null);
	}

}

package com.duckblade.osrs.dpscalc.calc.compute;

/**
 * Allows for a pre-computation check on whether the node should be computed by its parent,
 * without fully computing the value and storing the result in the context.
 * Useful to prune single-parent nodes from the result set, slimming down unnecessary final values.
 */
public interface OptionalComputable<T> extends Computable<T>
{

	boolean isApplicable(ComputeContext context);

}

package com.duckblade.osrs.dpscalc.calc.compute;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor(staticName = "of")
public class ComputeOutput<T> implements Computable<T>
{

	private final String key;

	@Override
	public String key()
	{
		return this.key;
	}

	@Override
	public T compute(ComputeContext context)
	{
		// outputs are placed manually into the context by other computations
		// missing outputs may be requested, we just always return a non-result
		return null;
	}

}

package com.duckblade.osrs.dpscalc.calc.compute;

public interface Computable<T>
{

	default String key()
	{
		String key = getClass().getSimpleName();
		if (key.endsWith("Computable"))
		{
			key = key.substring(0, key.length() - 10);
		}

		return key;
	}

	T compute(ComputeContext context);

}

package com.duckblade.osrs.dpscalc.calc.compute;

import com.duckblade.osrs.dpscalc.calc.exceptions.DpsComputeException;
import com.duckblade.osrs.dpscalc.calc.model.ComputeInput;
import com.google.common.collect.ImmutableList;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@SuppressWarnings("unchecked")
public class ComputeContext
{

	private final Map<String, Object> computedValueCache;
	private final List<String> warnings;

	public ComputeContext()
	{
		computedValueCache = new HashMap<>();
		warnings = new ArrayList<>();
	}

	public ComputeContext(ComputeInput input)
	{
		this();
		this.put(ComputeInputs.ATTACKER_SKILLS, input.getAttackerSkills());
		this.put(ComputeInputs.ATTACKER_ITEMS, input.getAttackerItems());
		this.put(ComputeInputs.ATTACKER_PRAYERS, input.getAttackerPrayers());
		this.put(ComputeInputs.ATTACK_STYLE, input.getAttackStyle());
		this.put(ComputeInputs.SPELL, input.getSpell());
		this.put(ComputeInputs.BLOWPIPE_DARTS, input.getBlowpipeDarts());
		this.put(ComputeInputs.ATTACK_DISTANCE, input.getAttackerDistance());
		this.put(ComputeInputs.DEFENDER_SKILLS, input.getDefenderSkills());
		this.put(ComputeInputs.DEFENDER_BONUSES, input.getDefenderBonuses());
		this.put(ComputeInputs.DEFENDER_ATTRIBUTES, input.getDefenderAttributes());
		this.put(ComputeInputs.ON_SLAYER_TASK, input.isOnSlayerTask());
		this.put(ComputeInputs.USING_CHARGE_SPELL, input.isUsingChargeSpell());
		this.put(ComputeInputs.USING_MARK_OF_DARKNESS, input.isUsingMarkOfDarkness());
		this.put(ComputeInputs.IN_WILDERNESS, input.isInWilderness());
		this.put(ComputeInputs.RAID_PARTY_SIZE, input.getRaidPartySize());
	}

	public <T> T get(Computable<T> computable)
	{
		// hit cache first
		String key = computable.key();
		T value = (T) computedValueCache.get(key);
		if (value != null)
		{
			return value;
		}

		// compute only if new
		try
		{
			value = computable.compute(this);
		}
		catch (DpsComputeException e)
		{
			// don't re-wrap DpsComputeExceptions
			throw e;
		}
		catch (Exception inner)
		{
			throw new DpsComputeException(inner);
		}

		// store and return
		computedValueCache.put(key, value);
		return value;
	}

	public <T> void put(Computable<T> computable, T override)
	{
		computedValueCache.put(computable.key(), override);
	}

	public void warn(String warning)
	{
		warnings.add(warning);
	}

	public List<String> getWarnings()
	{
		return ImmutableList.copyOf(warnings);
	}

}
package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.defender.DefenderSkillsComputable;
import com.duckblade.osrs.dpscalc.calc.util.TicksToDurationComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class TimeToKillComputable extends TicksToDurationComputable
{

	private final DptComputable dptComputable;
	private final DefenderSkillsComputable defenderSkillsComputable;

	@Override
	protected int getTicks(ComputeContext context)
	{
		double dpt = context.get(dptComputable);
		if (dpt <= 0)
		{
			return -1;
		}

		int targetHp = context.get(defenderSkillsComputable).getTotals().get(Skill.HITPOINTS);
		return (int) (Math.ceil((double) targetHp / dpt));
	}

}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ScytheDptComputable implements MultiHitDptComputable
{

	public static final ComputeOutput<Integer> SCY_MAX_HIT_2 = ComputeOutput.of("MaxHit-Scy2");
	public static final ComputeOutput<Integer> SCY_MAX_HIT_3 = ComputeOutput.of("MaxHit-Scy3");
	public static final ComputeOutput<Integer> SCY_MAX_HIT_SUM = ComputeOutput.of("MaxHit-ScySum");

	private static final Set<Integer> SCYTHE_IDS = ImmutableSet.of(
		ItemID.SCYTHE_OF_VITUR,
		ItemID.SCYTHE_OF_VITUR_UNCHARGED, // still works, but has reduced stats which is baked into the item stats
		ItemID.SCYTHE_OF_VITUR_22664, // no clue what this is tbh https://chisel.weirdgloop.org/moid/item_id.html#22664
		ItemID.HOLY_SCYTHE_OF_VITUR,
		ItemID.HOLY_SCYTHE_OF_VITUR_UNCHARGED,
		ItemID.SANGUINE_SCYTHE_OF_VITUR,
		ItemID.SANGUINE_SCYTHE_OF_VITUR_UNCHARGED
	);

	private final WeaponComputable weaponComputable;
	private final BaseHitDptComputable baseHitDptComputable;
	private final HitChanceComputable hitChanceComputable;
	private final PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;
	private final BaseMaxHitComputable baseMaxHitComputable;
	private final MaxHitLimitComputable maxHitLimitComputable;
	private final AttackSpeedComputable attackSpeedComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee() &&
			SCYTHE_IDS.contains(context.get(weaponComputable).getItemId());
	}

	@Override
	public Double compute(ComputeContext context)
	{
		double baseDps = context.get(baseHitDptComputable);
		int npcSize = context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getSize();
		if (npcSize < 2)
		{
			context.warn("Using the Scythe of vitur against size 1 targets is inefficient unless hitting multiple enemies.");
			return baseDps;
		}

		double hitChance = context.get(hitChanceComputable);
		int attackSpeed = context.get(attackSpeedComputable);

		int maxHitUnlimited = context.get(preLimitBaseMaxHitComputable);
		int maxHit1 = context.get(baseMaxHitComputable);

		int maxHit2 = maxHitLimitComputable.coerce(maxHitUnlimited / 2, context);
		context.put(SCY_MAX_HIT_2, maxHit2);
		double secondHitDps = BaseHitDptComputable.byComponents(hitChance, maxHit2, attackSpeed);

		double thirdHitDps = 0;
		int maxHit3 = 0;
		if (npcSize > 2)
		{
			maxHit3 = maxHitLimitComputable.coerce(maxHitUnlimited / 4, context);
			context.put(SCY_MAX_HIT_3, maxHit3);
			thirdHitDps = BaseHitDptComputable.byComponents(hitChance, maxHit3, attackSpeed);
		}

		context.put(SCY_MAX_HIT_SUM, maxHit1 + maxHit2 + maxHit3);
		return baseDps + secondHitDps + thirdHitDps;
	}

}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ColossalBladeDptComputable implements MultiHitDptComputable
{

	public static final ComputeOutput<Integer> COLOSSAL_BLADE_MAX_HIT = ComputeOutput.of("MaxHit-ColossalBlade");

	private static final Set<Integer> COLOSSAL_BLADE_IDS = ImmutableSet.of(
		ItemID.COLOSSAL_BLADE
	);

	private final WeaponComputable weaponComputable;
	private final HitChanceComputable hitChanceComputable;
	private final AttackSpeedComputable attackSpeedComputable;
	private final PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;
	private final MaxHitLimitComputable maxHitLimitComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee() &&
			COLOSSAL_BLADE_IDS.contains(context.get(weaponComputable).getItemId());
	}

	@Override
	public Double compute(ComputeContext context)
	{
		double hitChance = context.get(hitChanceComputable);
		int attackSpeed = context.get(attackSpeedComputable);

		int size = Math.max(1, Math.min(5, context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getSize()));
		int effectMaxHit = maxHitLimitComputable.coerce(2 * size + context.get(preLimitBaseMaxHitComputable), context);
		context.put(COLOSSAL_BLADE_MAX_HIT, effectMaxHit);

		return BaseHitDptComputable.byComponents(hitChance, effectMaxHit, attackSpeed);
	}

}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class KarilsDptComputable implements MultiHitDptComputable
{

	public static final ComputeOutput<Integer> KARILS_MAX_HIT = ComputeOutput.of("MaxHit-Karils");

	private static final Set<Integer> KARILS_CROSSBOW_IDS = ImmutableSet.of(
		ItemID.KARILS_CROSSBOW,
		ItemID.KARILS_CROSSBOW_100,
		ItemID.KARILS_CROSSBOW_75,
		ItemID.KARILS_CROSSBOW_50,
		ItemID.KARILS_CROSSBOW_25
	);

	private static final Set<Integer> KARILS_COIF_IDS = ImmutableSet.of(
		ItemID.KARILS_COIF,
		ItemID.KARILS_COIF_100,
		ItemID.KARILS_COIF_75,
		ItemID.KARILS_COIF_50,
		ItemID.KARILS_COIF_25
	);

	private static final Set<Integer> KARILS_LEATHERTOP_IDS = ImmutableSet.of(
		ItemID.KARILS_LEATHERTOP,
		ItemID.KARILS_LEATHERTOP_100,
		ItemID.KARILS_LEATHERTOP_75,
		ItemID.KARILS_LEATHERTOP_50,
		ItemID.KARILS_LEATHERTOP_25
	);

	private static final Set<Integer> KARILS_LEATHERSKIRT_IDS = ImmutableSet.of(
		ItemID.KARILS_LEATHERSKIRT,
		ItemID.KARILS_LEATHERSKIRT_100,
		ItemID.KARILS_LEATHERSKIRT_75,
		ItemID.KARILS_LEATHERSKIRT_50,
		ItemID.KARILS_LEATHERSKIRT_25
	);

	private static final Set<Integer> AMULET_OF_THE_DAMNED = ImmutableSet.of(
		ItemID.AMULET_OF_THE_DAMNED,
		ItemID.AMULET_OF_THE_DAMNED_FULL
	);

	private final BaseHitDptComputable baseHitDptComputable;
	private final EquipmentItemIdsComputable equipmentItemIdsComputable;
	private final HitChanceComputable hitChanceComputable;
	private final PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;
	private final MaxHitLimitComputable maxHitLimitComputable;
	private final AttackSpeedComputable attackSpeedComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		if (context.get(ComputeInputs.ATTACK_STYLE).getAttackType() != AttackType.RANGED)
		{
			return false;
		}

		// karils effect also requires amulet of the damned
		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		boolean amulet = AMULET_OF_THE_DAMNED.contains(equipment.get(EquipmentInventorySlot.AMULET));
		boolean fullKarils = KARILS_CROSSBOW_IDS.contains(equipment.get(EquipmentInventorySlot.WEAPON)) &&
			KARILS_COIF_IDS.contains(equipment.get(EquipmentInventorySlot.HEAD)) &&
			KARILS_LEATHERTOP_IDS.contains(equipment.get(EquipmentInventorySlot.BODY)) &&
			KARILS_LEATHERSKIRT_IDS.contains(equipment.get(EquipmentInventorySlot.LEGS));

		if (!amulet && fullKarils)
		{
			context.warn("Karil's equipment only provides a beneficial set effect with the Amulet of the damned.");
		}
		return amulet && fullKarils;
	}

	@Override
	public Double compute(ComputeContext context)
	{
		double baseDps = context.get(baseHitDptComputable);

		int effectMaxHit = maxHitLimitComputable.coerce((int) (1.5 * context.get(preLimitBaseMaxHitComputable)), context);
		context.put(KARILS_MAX_HIT, effectMaxHit);

		double hitChance = context.get(hitChanceComputable);
		int attackSpeed = context.get(attackSpeedComputable);

		// 25% chance to deal 1.5x damage
		double specialDps = BaseHitDptComputable.byComponents(hitChance, effectMaxHit, attackSpeed);
		return 0.75 * baseDps + 0.25 * specialDps;
	}

}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class OsmumtensFangDptComputable implements MultiHitDptComputable
{

	private static final Set<Integer> FANG_IDS = ImmutableSet.of(
		ItemID.OSMUMTENS_FANG,
		ItemID.OSMUMTENS_FANG_OR
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;
	private final BaseMaxHitComputable baseMaxHitComputable;
	private final HitChanceComputable hitChanceComputable;
	private final AttackSpeedComputable attackSpeedComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee() &&
			FANG_IDS.contains(context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.WEAPON));
	}

	@Override
	public Double compute(ComputeContext context)
	{

		double baseHitChance = context.get(hitChanceComputable);
		double effectHitChance = 1 - Math.pow(1 - baseHitChance, 2);

		// fang clamps damage per hit between 10% and 90% of max
		// which keeps avg hit the same so no work needed to handle that
		// unless there is a max hit limiter in play
		int maxHit = context.get(baseMaxHitComputable);
		if (context.get(MaxHitLimitComputable.LIMIT_APPLIED))
		{
			context.warn("Max hit may be inaccurate due to conflicting effects of a max hit limiter and fang max hit clamping.");
		}

		int attackSpeed = context.get(attackSpeedComputable);
		return BaseHitDptComputable.byComponents(effectHitChance, maxHit, attackSpeed);
	}
}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DharoksDptComputable implements MultiHitDptComputable
{

	public static final ComputeOutput<Integer> DHAROKS_MAX_HIT = ComputeOutput.of("MaxHit-Dharoks");

	private static final Set<Integer> DHAROKS_GREATAXE_IDS = ImmutableSet.of(
		ItemID.DHAROKS_GREATAXE,
		ItemID.DHAROKS_GREATAXE_100,
		ItemID.DHAROKS_GREATAXE_75,
		ItemID.DHAROKS_GREATAXE_50,
		ItemID.DHAROKS_GREATAXE_25
	);

	private static final Set<Integer> DHAROKS_HELM_IDS = ImmutableSet.of(
		ItemID.DHAROKS_HELM,
		ItemID.DHAROKS_HELM_100,
		ItemID.DHAROKS_HELM_75,
		ItemID.DHAROKS_HELM_50,
		ItemID.DHAROKS_HELM_25
	);

	private static final Set<Integer> DHAROKS_PLATEBODY_IDS = ImmutableSet.of(
		ItemID.DHAROKS_PLATEBODY,
		ItemID.DHAROKS_PLATEBODY_100,
		ItemID.DHAROKS_PLATEBODY_75,
		ItemID.DHAROKS_PLATEBODY_50,
		ItemID.DHAROKS_PLATEBODY_25
	);

	private static final Set<Integer> DHAROKS_PLATELEGS_IDS = ImmutableSet.of(
		ItemID.DHAROKS_PLATELEGS,
		ItemID.DHAROKS_PLATELEGS_100,
		ItemID.DHAROKS_PLATELEGS_75,
		ItemID.DHAROKS_PLATELEGS_50,
		ItemID.DHAROKS_PLATELEGS_25
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;
	private final HitChanceComputable hitChanceComputable;
	private final PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;
	private final MaxHitLimitComputable maxHitLimitComputable;
	private final AttackSpeedComputable attackSpeedComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		if (!context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee())
		{
			return false;
		}

		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		return DHAROKS_GREATAXE_IDS.contains(equipment.get(EquipmentInventorySlot.WEAPON)) &&
			DHAROKS_HELM_IDS.contains(equipment.get(EquipmentInventorySlot.HEAD)) &&
			DHAROKS_PLATEBODY_IDS.contains(equipment.get(EquipmentInventorySlot.BODY)) &&
			DHAROKS_PLATELEGS_IDS.contains(equipment.get(EquipmentInventorySlot.LEGS));
	}

	@Override
	public Double compute(ComputeContext context)
	{
		Skills attackerSkills = context.get(ComputeInputs.ATTACKER_SKILLS);
		int maxHp = attackerSkills.getLevels().getOrDefault(Skill.HITPOINTS, 99);
		int currentHp = attackerSkills.getTotals().getOrDefault(Skill.HITPOINTS, maxHp);
		double dharokMod = 1 + ((maxHp - currentHp) / 100.0) * (maxHp / 100.0);

		int effectMaxHit = maxHitLimitComputable.coerce((int) (context.get(preLimitBaseMaxHitComputable) * dharokMod), context);
		context.put(DHAROKS_MAX_HIT, effectMaxHit);

		double hitChance = context.get(hitChanceComputable);
		int attackSpeed = context.get(attackSpeedComputable);
		return BaseHitDptComputable.byComponents(hitChance, effectMaxHit, attackSpeed);
	}

}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class VeracsDptComputable implements MultiHitDptComputable
{

	private static final Set<Integer> VERACS_FLAIL_IDS = ImmutableSet.of(
		ItemID.VERACS_FLAIL,
		ItemID.VERACS_FLAIL_100,
		ItemID.VERACS_FLAIL_75,
		ItemID.VERACS_FLAIL_50,
		ItemID.VERACS_FLAIL_25
	);

	private static final Set<Integer> VERACS_HELM_IDS = ImmutableSet.of(
		ItemID.VERACS_HELM,
		ItemID.VERACS_HELM_100,
		ItemID.VERACS_HELM_75,
		ItemID.VERACS_HELM_50,
		ItemID.VERACS_HELM_25
	);

	private static final Set<Integer> VERACS_BRASSARD_IDS = ImmutableSet.of(
		ItemID.VERACS_BRASSARD,
		ItemID.VERACS_BRASSARD_100,
		ItemID.VERACS_BRASSARD_75,
		ItemID.VERACS_BRASSARD_50,
		ItemID.VERACS_BRASSARD_25
	);

	private static final Set<Integer> VERACS_PLATESKIRT_IDS = ImmutableSet.of(
		ItemID.VERACS_PLATESKIRT,
		ItemID.VERACS_PLATESKIRT_100,
		ItemID.VERACS_PLATESKIRT_75,
		ItemID.VERACS_PLATESKIRT_50,
		ItemID.VERACS_PLATESKIRT_25
	);

	private final BaseHitDptComputable baseHitDptComputable;
	private final EquipmentItemIdsComputable equipmentItemIdsComputable;
	private final BaseMaxHitComputable baseMaxHitComputable;
	private final AttackSpeedComputable attackSpeedComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		if (!context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee())
		{
			return false;
		}

		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		return VERACS_FLAIL_IDS.contains(equipment.get(EquipmentInventorySlot.WEAPON)) &&
			VERACS_HELM_IDS.contains(equipment.get(EquipmentInventorySlot.HEAD)) &&
			VERACS_BRASSARD_IDS.contains(equipment.get(EquipmentInventorySlot.BODY)) &&
			VERACS_PLATESKIRT_IDS.contains(equipment.get(EquipmentInventorySlot.LEGS));
	}

	@Override
	public Double compute(ComputeContext context)
	{
		double baseDps = context.get(baseHitDptComputable);

		int maxHit = context.get(baseMaxHitComputable);
		int attackSpeed = context.get(attackSpeedComputable);

		// special effect is 25% chance to ignore defence and +1 damage to hit (we add 2 to overcome the mean division)
		double specialDps = BaseHitDptComputable.byComponents(1.0, maxHit + 2, attackSpeed);
		return 0.75 * baseDps + 0.25 * specialDps;
	}

}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.compute.OptionalComputable;

/**
 * Models a DPS calculation that is computed by multiple distinct hit types,
 * not necessarily multiple hits per swing
 * (e.g. Keris applies a regular hit 50/51 hits, and triple damage 1/51 hits).
 * Only one MultiHitDptComputable should be applicable at a time,
 * and if it is applicable, it will replace the resultant DPS calculation.
 */
public interface MultiHitDptComputable extends OptionalComputable<Double>
{
}

package com.duckblade.osrs.dpscalc.calc.multihit;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.BaseHitDptComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.duckblade.osrs.dpscalc.calc.gearbonus.KerisGearBonus;
import com.duckblade.osrs.dpscalc.calc.maxhit.PreLimitBaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class KerisDptComputable implements MultiHitDptComputable
{

	public static final ComputeOutput<Integer> KERIS_MAX_HIT = ComputeOutput.of("MaxHit-Keris");

	private final WeaponComputable weaponComputable;
	private final BaseHitDptComputable baseHitDptComputable;
	private final HitChanceComputable hitChanceComputable;
	private final PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;
	private final MaxHitLimitComputable maxHitLimitComputable;
	private final AttackSpeedComputable attackSpeedComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		if (!context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee())
		{
			return false;
		}

		return KerisGearBonus.KERIS_IDS.contains(context.get(weaponComputable).getItemId()) &&
			context.get(ComputeInputs.DEFENDER_ATTRIBUTES).isKalphite();
	}

	@Override
	public Double compute(ComputeContext context)
	{
		double baseDps = context.get(baseHitDptComputable);

		// 1/51 chance to deal triple damage
		double hitChance = context.get(hitChanceComputable);
		int effectMaxHit = maxHitLimitComputable.coerce(3 * context.get(preLimitBaseMaxHitComputable), context);
		int attackSpeed = context.get(attackSpeedComputable);

		double tripleHitDps = BaseHitDptComputable.byComponents(hitChance, effectMaxHit, attackSpeed);
		context.put(KERIS_MAX_HIT, effectMaxHit);

		return (50.0 / 51.0) * baseDps + (1.0 / 51.0) * tripleHitDps;
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.duckblade.osrs.dpscalc.calc.model.Spellbook;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class AttackSpeedComputable implements Computable<Integer>
{

	private static final Set<Integer> FOUR_TICK_MAGIC_WEAPONS = ImmutableSet.of(ItemID.HARMONISED_NIGHTMARE_STAFF);

	private final WeaponComputable weaponComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		ItemStats weapon = context.get(weaponComputable);
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		switch (attackStyle.getAttackType())
		{
			// mage weapons' "speed" value is their melee speed, and spellbook spells are always 4 tick, except harm effect
			case MAGIC:
				if ((weapon.getWeaponCategory() == WeaponCategory.POWERED_STAFF || weapon.getWeaponCategory() == WeaponCategory.SALAMANDER) && !attackStyle.isManualCast())
				{
					return weapon.getSpeed();
				}

				// harm effect only works on standard spellbook
				if (FOUR_TICK_MAGIC_WEAPONS.contains(weapon.getItemId()) &&
					context.get(ComputeInputs.SPELL).getSpellbook() == Spellbook.STANDARD)
				{
					return 4;
				}

				return 5;

			case RANGED:
				if (attackStyle.getCombatStyle() == CombatStyle.RAPID)
				{
					return weapon.getSpeed() - 1;
				}

			default:
				return weapon.getSpeed();
		}
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.VoidLevel;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class VoidLevelComputable implements Computable<VoidLevel>
{

	private static final Set<Integer> VOID_MELEE_HELMS = ImmutableSet.of(
		ItemID.VOID_MELEE_HELM,
		ItemID.VOID_MELEE_HELM_L,
		ItemID.VOID_MELEE_HELM_OR
	);

	private static final Set<Integer> VOID_RANGER_HELMS = ImmutableSet.of(
		ItemID.VOID_RANGER_HELM,
		ItemID.VOID_RANGER_HELM_L,
		ItemID.VOID_RANGER_HELM_OR
	);

	private static final Set<Integer> VOID_MAGE_HELMS = ImmutableSet.of(
		ItemID.VOID_MAGE_HELM,
		ItemID.VOID_MAGE_HELM_L,
		ItemID.VOID_MAGE_HELM_OR
	);

	private static final Set<Integer> VOID_KNIGHT_TOPS = ImmutableSet.of(
		ItemID.VOID_KNIGHT_TOP,
		ItemID.VOID_KNIGHT_TOP_L,
		ItemID.VOID_KNIGHT_TOP_OR
	);

	private static final Set<Integer> ELITE_VOID_TOPS = ImmutableSet.of(
		ItemID.ELITE_VOID_TOP,
		ItemID.ELITE_VOID_TOP_L,
		ItemID.ELITE_VOID_TOP_OR
	);

	private static final Set<Integer> VOID_KNIGHT_ROBES = ImmutableSet.of(
		ItemID.VOID_KNIGHT_ROBE,
		ItemID.VOID_KNIGHT_ROBE_L,
		ItemID.VOID_KNIGHT_ROBE_OR
	);

	private static final Set<Integer> ELITE_VOID_ROBES = ImmutableSet.of(
		ItemID.ELITE_VOID_ROBE,
		ItemID.ELITE_VOID_ROBE_L,
		ItemID.ELITE_VOID_ROBE_OR
	);

	private static final Set<Integer> VOID_KNIGHT_GLOVES = ImmutableSet.of(
		ItemID.VOID_KNIGHT_GLOVES,
		ItemID.VOID_KNIGHT_GLOVES_L,
		ItemID.VOID_KNIGHT_GLOVES_OR
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public VoidLevel compute(ComputeContext context)
	{
		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		int helm = equipment.get(EquipmentInventorySlot.HEAD);
		int body = equipment.get(EquipmentInventorySlot.BODY);
		int legs = equipment.get(EquipmentInventorySlot.LEGS);
		int gloves = equipment.get(EquipmentInventorySlot.GLOVES);

		boolean wearingHelm = VOID_MELEE_HELMS.contains(helm) || VOID_RANGER_HELMS.contains(helm) || VOID_MAGE_HELMS.contains(helm);
		int topVoidLevel = ELITE_VOID_TOPS.contains(body) ? 2 : VOID_KNIGHT_TOPS.contains(body) ? 1 : 0;
		int bottomVoidLevel = ELITE_VOID_ROBES.contains(legs) ? 2 : VOID_KNIGHT_ROBES.contains(legs) ? 1 : 0;
		boolean wearingGloves = VOID_KNIGHT_GLOVES.contains(gloves);

		boolean anyVoid = wearingHelm || topVoidLevel > 0 || bottomVoidLevel > 0 || wearingGloves;
		if (!anyVoid)
		{
			return VoidLevel.NONE;
		}

		boolean fullVoid = wearingHelm && topVoidLevel > 0 && bottomVoidLevel > 0 && wearingGloves;
		if (!fullVoid)
		{
			context.warn("Wearing incomplete void equipment provides no offensive bonuses.");
			return VoidLevel.NONE;
		}

		AttackType attackMode = context.get(ComputeInputs.ATTACK_STYLE).getAttackType();
		if (!combatModeMatch(attackMode, helm))
		{
			context.warn("Void helm does not matach attack style.");
			return VoidLevel.NONE;
		}

		boolean elite = topVoidLevel == 2 && bottomVoidLevel == 2;
		if (elite)
		{
			return VoidLevel.ELITE;
		}
		return VoidLevel.REGULAR;
	}

	private static boolean combatModeMatch(AttackType attackMode, int helm)
	{
		switch (attackMode)
		{
			case MAGIC:
				return VOID_MAGE_HELMS.contains(helm);

			case RANGED:
				return VOID_RANGER_HELMS.contains(helm);

			default:
				return VOID_MELEE_HELMS.contains(helm);
		}
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.attack.AttackRollComputable;
import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.defender.DefenseRollComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class HitChanceComputable implements Computable<Double>
{

	private final AttackRollComputable attackRollComputable;
	private final DefenseRollComputable defenseRollComputable;

	@Override
	public Double compute(ComputeContext context)
	{
		int attRoll = context.get(attackRollComputable);
		int defRoll = context.get(defenseRollComputable);

		if (attRoll > defRoll)
		{
			return 1.0 - ((defRoll + 2.0) / (2.0 * (attRoll + 1.0)));
		}
		else
		{
			return attRoll / (2.0 * (defRoll + 1.0));
		}
	}
}

package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Builder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Value;

@Value
@Builder
@RequiredArgsConstructor(staticName = "of")
public class MaxHitLimit
{
	public static final MaxHitLimit UNLIMITED = new MaxHitLimit(Integer.MAX_VALUE, null);

	@Getter
	private final int limit;

	@Getter
	private final String warning;
}

package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Builder;
import lombok.Value;
import lombok.extern.jackson.Jacksonized;

@Value
@Builder(toBuilder = true)
@Jacksonized
public class DefensiveBonuses
{

	public static final DefensiveBonuses EMPTY = DefensiveBonuses.builder().build();

	private final int defenseStab;
	private final int defenseSlash;
	private final int defenseCrush;
	private final int defenseRanged;
	private final int defenseMagic;

}

package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Builder;
import lombok.Value;
import lombok.extern.jackson.Jacksonized;

@Value
@Builder(toBuilder = true)
@Jacksonized
public class DefenderAttributes
{

	public static final DefenderAttributes EMPTY = DefenderAttributes.builder().build();

	@Builder.Default
	private final int npcId = -1;

	@Builder.Default
	private final String name = null;

	@Builder.Default
	private final boolean isDemon = false; // demonbane

	@Builder.Default
	private final boolean isDragon = false; // dhl/dhcb

	@Builder.Default
	private final boolean isKalphite = false; // keris

	@Builder.Default
	private final boolean isLeafy = false; // leaf-bladed

	@Builder.Default
	private final boolean isUndead = false; // salve

	@Builder.Default
	private final boolean isVampyre1 = false;

	@Builder.Default
	private final boolean isVampyre2 = false;

	@Builder.Default
	private final boolean isVampyre3 = false;

	@Builder.Default
	private final int size = 1; // scythe

	@Builder.Default
	private final int accuracyMagic = 0; // tbow

	public boolean isVampyre()
	{
		return isVampyre1 ||
			isVampyre2 ||
			isVampyre3;
	}

}

package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Spell
{

	// ancient spells
	ICE_BARRAGE(46, "Ice Barrage", 30, Spellbook.ANCIENT),
	BLOOD_BARRAGE(45, "Blood Barrage", 29, Spellbook.ANCIENT),
	SHADOW_BARRAGE(44, "Shadow Barrage", 28, Spellbook.ANCIENT),
	SMOKE_BARRAGE(43, "Smoke Barrage", 27, Spellbook.ANCIENT),
	ICE_BLITZ(42, "Ice Blitz", 26, Spellbook.ANCIENT),
	BLOOD_BLITZ(41, "Blood Blitz", 25, Spellbook.ANCIENT),
	SHADOW_BLITZ(40, "Shadow Blitz", 24, Spellbook.ANCIENT),
	SMOKE_BLITZ(39, "Smoke Blitz", 23, Spellbook.ANCIENT),
	ICE_BURST(38, "Ice Burst", 22, Spellbook.ANCIENT),
	BLOOD_BURST(37, "Blood Burst", 21, Spellbook.ANCIENT),
	SHADOW_BURST(36, "Shadow Burst", 18, Spellbook.ANCIENT),
	SMOKE_BURST(35, "Smoke Burst", 17, Spellbook.ANCIENT),
	ICE_RUSH(34, "Ice Rush", 16, Spellbook.ANCIENT),
	BLOOD_RUSH(33, "Blood Rush", 15, Spellbook.ANCIENT),
	SHADOW_RUSH(32, "Shadow Rush", 14, Spellbook.ANCIENT),
	SMOKE_RUSH(31, "Smoke Rush", 13, Spellbook.ANCIENT),

	// standard spells
	FIRE_SURGE(51, "Fire Surge", 24, Spellbook.STANDARD),
	EARTH_SURGE(50, "Earth Surge", 23, Spellbook.STANDARD),
	WATER_SURGE(49, "Water Surge", 22, Spellbook.STANDARD),
	WIND_SURGE(48, "Wind Surge", 21, Spellbook.STANDARD),
	FIRE_WAVE(16, "Fire Wave", 20, Spellbook.STANDARD),
	EARTH_WAVE(15, "Earth Wave", 19, Spellbook.STANDARD),
	WATER_WAVE(14, "Water Wave", 18, Spellbook.STANDARD),
	WIND_WAVE(13, "Wind Wave", 17, Spellbook.STANDARD),
	FIRE_BLAST(12, "Fire Blast", 16, Spellbook.STANDARD),
	EARTH_BLAST(11, "Earth Blast", 15, Spellbook.STANDARD),
	WATER_BLAST(10, "Water Blast", 14, Spellbook.STANDARD),
	WIND_BLAST(9, "Wind Blast", 13, Spellbook.STANDARD),
	FIRE_BOLT(8, "Fire Bolt", 12, Spellbook.STANDARD),
	EARTH_BOLT(7, "Earth Bolt", 11, Spellbook.STANDARD),
	WATER_BOLT(6, "Water Bolt", 10, Spellbook.STANDARD),
	WIND_BOLT(5, "Wind Bolt", 9, Spellbook.STANDARD),
	FIRE_STRIKE(4, "Fire Strike", 8, Spellbook.STANDARD),
	EARTH_STRIKE(3, "Earth Strike", 6, Spellbook.STANDARD),
	WATER_STRIKE(2, "Water Strike", 4, Spellbook.STANDARD),
	WIND_STRIKE(1, "Wind Strike", 2, Spellbook.STANDARD),

	// standard but not autocast without special staff
	FLAMES_OF_ZAMORAK(20, "Flames of Zamorak", 20, Spellbook.STANDARD),
	CLAWS_OF_GUTHIX(-1, "Claws of Guthix", 20, Spellbook.STANDARD),
	SARADOMIN_STRIKE(-1, "Saradomin Strike", 20, Spellbook.STANDARD),
	CRUMBLE_UNDEAD(17, "Crumble Undead", 15, Spellbook.STANDARD),
	IBAN_BLAST(47, "Iban Blast", 25, Spellbook.STANDARD),
	MAGIC_DART(18, "Magic Dart", 10, Spellbook.STANDARD),

	// arceuus
	INFERIOR_DEMONBANE(53, "Inferior Demonbane", 16, Spellbook.ARCEUUS),
	SUPERIOR_DEMONBANE(54, "Superior Demonbane", 23, Spellbook.ARCEUUS),
	DARK_DEMONBANE(55, "Dark Demonbane", 30, Spellbook.ARCEUUS),
	GHOSTLY_GRASP(56, "Ghostly Grasp", 12, Spellbook.ARCEUUS),
	SKELETAL_GRASP(57, "Skeletal Grasp", 17, Spellbook.ARCEUUS),
	UNDEAD_GRASP(58, "Undead Grasp", 24, Spellbook.ARCEUUS),
	;

	private final int varbValue;

	private final String displayName;

	private final int baseMaxHit;

	private final Spellbook spellbook;

}
package com.duckblade.osrs.dpscalc.calc.model;

public enum Spellbook
{
	STANDARD,
	ANCIENT,
	ARCEUUS,
	;
}

package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Builder;
import lombok.Value;

@Value
@Builder(toBuilder = true)
public class AttackStyle
{

	public static AttackStyle MANUAL_CAST = AttackStyle.builder()
		.varpValue(-1)
		.displayName("Manual Cast")
		.attackType(AttackType.MAGIC)
		.combatStyle(CombatStyle.AUTOCAST)
		.isManualCast(true)
		.build();

	@Builder.Default
	private final int varpValue = -1;

	@Builder.Default
	private final String displayName = null;

	private final AttackType attackType;

	@Builder.Default
	private final CombatStyle combatStyle = null;

	@Builder.Default
	private final boolean isManualCast = false;

}
package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum Prayer
{

	THICK_SKIN("Thick Skin", PrayerGroup.UTILITY, 1f, 1f, 3, net.runelite.api.Prayer.THICK_SKIN),
	BURST_OF_STRENGTH("Burst of Strength", PrayerGroup.MELEE, 1f, 1.05f, 3, net.runelite.api.Prayer.BURST_OF_STRENGTH),
	CLARITY_OF_THOUGHT("Clarity of Thought", PrayerGroup.MELEE, 1.05f, 1f, 3, net.runelite.api.Prayer.CLARITY_OF_THOUGHT),
	SHARP_EYE("Sharp Eye", PrayerGroup.RANGED, 1.05f, 1.05f, 3, net.runelite.api.Prayer.SHARP_EYE),
	MYSTIC_WILL("Mystic Will", PrayerGroup.MAGE, 1.05f, 1f, 3, net.runelite.api.Prayer.MYSTIC_WILL),
	ROCK_SKIN("Rock Skin", PrayerGroup.UTILITY, 1f, 1f, 6, net.runelite.api.Prayer.ROCK_SKIN),
	SUPERHUMAN_STRENGTH("Superhuman Strength", PrayerGroup.MELEE, 1f, 1.1f, 6, net.runelite.api.Prayer.SUPERHUMAN_STRENGTH),
	IMPROVED_REFLEXES("Improved Reflexes", PrayerGroup.MELEE, 1.1f, 1f, 6, net.runelite.api.Prayer.IMPROVED_REFLEXES),
	RAPID_RESTORE("Rapid Restore", PrayerGroup.UTILITY, 1f, 1f, 1, net.runelite.api.Prayer.RAPID_RESTORE),
	RAPID_HEAL("Rapid Heal", PrayerGroup.UTILITY, 1f, 1f, 2, net.runelite.api.Prayer.RAPID_HEAL),
	PROTECT_ITEM("Protect Item", PrayerGroup.UTILITY, 1f, 1f, 2, net.runelite.api.Prayer.PROTECT_ITEM),
	HAWK_EYE("Hawk Eye", PrayerGroup.RANGED, 1.1f, 1.1f, 6, net.runelite.api.Prayer.HAWK_EYE),
	MYSTIC_LORE("Mystic Lore", PrayerGroup.MAGE, 1.1f, 1f, 6, net.runelite.api.Prayer.MYSTIC_LORE),
	STEEL_SKIN("Steel Skin", PrayerGroup.UTILITY, 1f, 1f, 12, net.runelite.api.Prayer.STEEL_SKIN),
	ULTIMATE_STRENGTH("Ultimate Strength", PrayerGroup.MELEE, 1f, 1.15f, 12, net.runelite.api.Prayer.ULTIMATE_STRENGTH),
	INCREDIBLE_REFLEXES("Incredible Reflexes", PrayerGroup.MELEE, 1.15f, 1f, 12, net.runelite.api.Prayer.INCREDIBLE_REFLEXES),
	PROTECT_FROM_MAGIC("Protect from Magic", PrayerGroup.UTILITY, 1f, 1.05f, 12, net.runelite.api.Prayer.PROTECT_FROM_MAGIC),
	PROTECT_FROM_MISSILES("Protect from Missiles", PrayerGroup.UTILITY, 1f, 1.05f, 12, net.runelite.api.Prayer.PROTECT_FROM_MISSILES),
	PROTECT_FROM_MELEE("Protect from Melee", PrayerGroup.UTILITY, 1f, 1.05f, 12, net.runelite.api.Prayer.PROTECT_FROM_MELEE),
	EAGLE_EYE("Eagle Eye", PrayerGroup.RANGED, 1.15f, 1.15f, 12, net.runelite.api.Prayer.EAGLE_EYE),
	MYSTIC_MIGHT("Mystic Might", PrayerGroup.MAGE, 1.15f, 1f, 12, net.runelite.api.Prayer.MYSTIC_MIGHT),
	RETRIBUTION("Retribution", PrayerGroup.UTILITY, 1f, 1f, 3, net.runelite.api.Prayer.RETRIBUTION),
	REDEMPTION("Redemption", PrayerGroup.UTILITY, 1f, 1f, 6, net.runelite.api.Prayer.REDEMPTION),
	SMITE("Smite", PrayerGroup.UTILITY, 1f, 1f, 18, net.runelite.api.Prayer.SMITE),
	PRESERVE("Preserve", PrayerGroup.UTILITY, 1f, 1f, 2, net.runelite.api.Prayer.PRESERVE),
	CHIVALRY("Chivalry", PrayerGroup.MELEE, 1.15f, 1.18f, 24, net.runelite.api.Prayer.CHIVALRY),
	PIETY("Piety", PrayerGroup.MELEE, 1.2f, 1.23f, 24, net.runelite.api.Prayer.PIETY),
	RIGOUR("Rigour", PrayerGroup.RANGED, 1.2f, 1.23f, 24, net.runelite.api.Prayer.RIGOUR),
	AUGURY("Augury", PrayerGroup.MAGE, 1.25f, 1f, 24, net.runelite.api.Prayer.AUGURY),
	;

	public enum PrayerGroup
	{
		MAGE,
		MELEE,
		RANGED,
		UTILITY,
		;
	}

	private final String displayName;
	private final PrayerGroup prayerGroup;
	private final float attackMod;
	private final float strengthMod;
	private final int drainRate;
	private final net.runelite.api.Prayer rlPrayer;

}

package com.duckblade.osrs.dpscalc.calc.model;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

// https://oldschool.runescape.wiki/w/Module:CombatStyles
@RequiredArgsConstructor
public enum WeaponCategory
{

	TWO_HANDED_SWORD(10, Arrays.asList(
		new AttackStyle(0, "Chop (Slash/Accurate)", AttackType.SLASH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Slash (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Smash (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Slash/Defensive)", AttackType.SLASH, CombatStyle.DEFENSIVE, false)
	)),
	AXE(1, Arrays.asList(
		new AttackStyle(0, "Chop (Slash/Accurate)", AttackType.SLASH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Hack (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Smash (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Slash/Defensive)", AttackType.SLASH, CombatStyle.DEFENSIVE, false)
	)),
	BANNER(24, Arrays.asList(
		new AttackStyle(0, "Lunge (Stab/Accurate)", AttackType.STAB, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Swipe (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Pound (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Stab/Defensive)", AttackType.STAB, CombatStyle.DEFENSIVE, false)
	)),
	BLADED_STAFF(21, Arrays.asList(
		new AttackStyle(0, "Jab (Stab/Accurate)", AttackType.STAB, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Swipe (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Fend (Crush/Defensive)", AttackType.CRUSH, CombatStyle.DEFENSIVE, false),
		new AttackStyle(4, "Spell (Magic/Autocast)", AttackType.MAGIC, CombatStyle.AUTOCAST, false)
	)),
	BLUDGEON(26, Arrays.asList(
		new AttackStyle(0, "Pound (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(1, "Pummel (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Smash (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false)
	)),
	BLUNT(2, Arrays.asList(
		new AttackStyle(0, "Pound (Crush/Accurate)", AttackType.CRUSH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Pummel (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Crush/Defensive)", AttackType.CRUSH, CombatStyle.DEFENSIVE, false)
	)),
	BOW(3, Arrays.asList(
		new AttackStyle(0, "Accurate (Ranged/Accurate)", AttackType.RANGED, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Rapid (Ranged/Rapid)", AttackType.RANGED, CombatStyle.RAPID, false),
		new AttackStyle(3, "Longrange (Ranged/Longrange)", AttackType.RANGED, CombatStyle.LONGRANGE, false)
	)),
	BULWARK(27, Collections.singletonList(
		new AttackStyle(0, "Pummel (Crush/Accurate)", AttackType.CRUSH, CombatStyle.ACCURATE, false)
	)),
	CHINCHOMPAS(7, Arrays.asList(
		new AttackStyle(0, "Short fuse (Ranged/Accurate)", AttackType.RANGED, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Medium fuse (Ranged/Rapid)", AttackType.RANGED, CombatStyle.RAPID, false),
		new AttackStyle(3, "Long fuse (Ranged/Longrange)", AttackType.RANGED, CombatStyle.LONGRANGE, false)
	)),
	CLAW(4, Arrays.asList(
		new AttackStyle(0, "Chop (Slash/Accurate)", AttackType.SLASH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Slash (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Lunge (Stab/Controlled)", AttackType.STAB, CombatStyle.CONTROLLED, false),
		new AttackStyle(3, "Block (Slash/Defensive)", AttackType.SLASH, CombatStyle.DEFENSIVE, false)
	)),
	CROSSBOW(5, Arrays.asList(
		new AttackStyle(0, "Accurate (Ranged/Accurate)", AttackType.RANGED, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Rapid (Ranged/Rapid)", AttackType.RANGED, CombatStyle.RAPID, false),
		new AttackStyle(3, "Longrange (Ranged/Longrange)", AttackType.RANGED, CombatStyle.LONGRANGE, false)
	)),
	PARTISAN(29, Arrays.asList(
		new AttackStyle(0, "Stab (Stab/Accurate)", AttackType.STAB, CombatStyle.ACCURATE, false),
		new AttackStyle(0, "Lunge (Stab/Aggressive)", AttackType.STAB, CombatStyle.ACCURATE, false),
		new AttackStyle(0, "Pound (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.ACCURATE, false),
		new AttackStyle(0, "Block (Stab/Defensive)", AttackType.STAB, CombatStyle.ACCURATE, false)
	)),
	PICKAXE(11, Arrays.asList(
		new AttackStyle(0, "Spike (Stab/Accurate)", AttackType.STAB, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Impale (Stab/Aggressive)", AttackType.STAB, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Smash (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Stab/Defensive)", AttackType.STAB, CombatStyle.DEFENSIVE, false)
	)),
	POLEARM(12, Arrays.asList(
		new AttackStyle(0, "Jab (Stab/Controlled)", AttackType.STAB, CombatStyle.CONTROLLED, false),
		new AttackStyle(1, "Swipe (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Fend (Stab/Defensive)", AttackType.STAB, CombatStyle.DEFENSIVE, false)
	)),
	POLESTAFF(18, Arrays.asList(
		new AttackStyle(0, "Bash (Crush/Accurate)", AttackType.CRUSH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Pound (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Crush/Defensive)", AttackType.CRUSH, CombatStyle.DEFENSIVE, false)
	)),
	POWERED_STAFF(23, Arrays.asList(
		new AttackStyle(0, "Accurate (Magic/Accurate)", AttackType.MAGIC, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Accurate (Magic/Accurate)", AttackType.MAGIC, CombatStyle.ACCURATE, false),
		new AttackStyle(3, "Longrange (Magic/Longrange)", AttackType.MAGIC, CombatStyle.LONGRANGE, false)
	)),
	SALAMANDER(6, Arrays.asList(
		new AttackStyle(0, "Scorch (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(1, "Flare (Ranged/Accurate)", AttackType.RANGED, CombatStyle.ACCURATE, false),
		new AttackStyle(2, "Blaze (Magic/Defensive)", AttackType.MAGIC, CombatStyle.DEFENSIVE, false)
	)),
	SCYTHE(14, Arrays.asList(
		new AttackStyle(0, "Reap (Slash/Accurate)", AttackType.SLASH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Chop (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Jab (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Slash/Defensive)", AttackType.SLASH, CombatStyle.DEFENSIVE, false)
	)),
	SLASH_SWORD(9, Arrays.asList(
		new AttackStyle(0, "Chop (Slash/Accurate)", AttackType.SLASH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Slash (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Lunge (Stab/Controlled)", AttackType.STAB, CombatStyle.CONTROLLED, false),
		new AttackStyle(3, "Block (Slash/Defensive)", AttackType.SLASH, CombatStyle.DEFENSIVE, false)
	)),
	SPEAR(15, Arrays.asList(
		new AttackStyle(0, "Lunge (Stab/Controlled)", AttackType.STAB, CombatStyle.CONTROLLED, false),
		new AttackStyle(1, "Swipe (Slash/Controlled)", AttackType.SLASH, CombatStyle.CONTROLLED, false),
		new AttackStyle(2, "Pound (Crush/Controlled)", AttackType.CRUSH, CombatStyle.CONTROLLED, false),
		new AttackStyle(3, "Block (Stab/Defensive)", AttackType.STAB, CombatStyle.DEFENSIVE, false)
	)),
	SPIKED(16, Arrays.asList(
		new AttackStyle(0, "Pound (Crush/Accurate)", AttackType.CRUSH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Pummel (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Spike (Stab/Controlled)", AttackType.STAB, CombatStyle.CONTROLLED, false),
		new AttackStyle(3, "Block (Crush/Defensive)", AttackType.CRUSH, CombatStyle.DEFENSIVE, false)
	)),
	STAB_SWORD(17, Arrays.asList(
		new AttackStyle(0, "Stab (Stab/Accurate)", AttackType.STAB, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Lunge (Stab/Aggressive)", AttackType.STAB, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(2, "Slash (Slash/Aggressive)", AttackType.SLASH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Stab/Defensive)", AttackType.STAB, CombatStyle.DEFENSIVE, false)
	)),
	STAFF(18, Arrays.asList(
		new AttackStyle(0, "Bash (Crush/Accurate)", AttackType.CRUSH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Pound (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Focus (Crush/Defensive)", AttackType.CRUSH, CombatStyle.DEFENSIVE, false),
		new AttackStyle(4, "Spell (Magic/Autocast)", AttackType.MAGIC, CombatStyle.AUTOCAST, false)
	)),
	THROWN(19, Arrays.asList(
		new AttackStyle(0, "Accurate (Ranged/Accurate)", AttackType.RANGED, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Rapid (Ranged/Rapid)", AttackType.RANGED, CombatStyle.RAPID, false),
		new AttackStyle(3, "Longrange (Ranged/Longrange)", AttackType.RANGED, CombatStyle.LONGRANGE, false)
	)),
	UNARMED(0, Arrays.asList(
		new AttackStyle(0, "Punch (Crush/Accurate)", AttackType.CRUSH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Kick (Crush/Aggressive)", AttackType.CRUSH, CombatStyle.AGGRESSIVE, false),
		new AttackStyle(3, "Block (Crush/Defensive)", AttackType.CRUSH, CombatStyle.DEFENSIVE, false)
	)),
	WHIP(20, Arrays.asList(
		new AttackStyle(0, "Flick (Slash/Accurate)", AttackType.SLASH, CombatStyle.ACCURATE, false),
		new AttackStyle(1, "Lash (Slash/Controlled)", AttackType.SLASH, CombatStyle.CONTROLLED, false),
		new AttackStyle(3, "Deflect (Slash/Defensive)", AttackType.SLASH, CombatStyle.DEFENSIVE, false)
	)),
	;

	@Getter
	private final int varbValue;

	@Getter
	private final List<AttackStyle> attackStyles;

}
package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Builder;
import lombok.Value;
import lombok.extern.jackson.Jacksonized;

@Value
@Builder(toBuilder = true)
@Jacksonized
public class ItemStats
{

	public static final ItemStats EMPTY = ItemStats.builder().build();

	@Builder.Default
	private final int itemId = -1;

	@Builder.Default
	private final String name = null;

	@Builder.Default
	private final int accuracyStab = 0;

	@Builder.Default
	private final int accuracySlash = 0;

	@Builder.Default
	private final int accuracyCrush = 0;

	@Builder.Default
	private final int accuracyMagic = 0;

	@Builder.Default
	private final int accuracyRanged = 0;

	@Builder.Default
	private final int strengthMelee = 0;

	@Builder.Default
	private final int strengthRanged = 0;

	@Builder.Default
	private final int strengthMagic = 0;

	@Builder.Default
	private final int prayer = 0;

	// start weapon stats
	@Builder.Default
	private final int speed = 4;

	@Builder.Default
	private final int slot = -1;

	@Builder.Default
	private final boolean is2h = false;

	@Builder.Default
	private final WeaponCategory weaponCategory = WeaponCategory.UNARMED;

}

package com.duckblade.osrs.dpscalc.calc.model;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import lombok.extern.jackson.Jacksonized;
import net.runelite.api.Skill;

@Value
@Jacksonized
@Builder(toBuilder = true)
public class Skills
{

	public static final Skills EMPTY = Skills.builder().build();

	@Singular
	private final Map<Skill, Integer> levels;

	@Singular
	private final Map<Skill, Integer> boosts;

	public SkillsBuilder toBuilderDeep()
	{
		return toBuilder()
			.boosts(new HashMap<>(boosts))
			.levels(new HashMap<>(levels));
	}

	public Map<Skill, Integer> getTotals()
	{
		// when using jacksonized data, these can be null
		Map<Skill, Integer> levels = this.levels != null ? this.levels : Collections.emptyMap();
		Map<Skill, Integer> boosts = this.boosts != null ? this.boosts : Collections.emptyMap();
		return Arrays.stream(Skill.values())
			.collect(Collectors.toMap(
				skill -> skill,
				skill -> levels.getOrDefault(skill, 0) + boosts.getOrDefault(skill, 0)
			));
	}

}

package com.duckblade.osrs.dpscalc.calc.model;

public enum VoidLevel
{
	NONE,
	REGULAR,
	ELITE,
	;
}

package com.duckblade.osrs.dpscalc.calc.model;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum CombatStyle
{

	ACCURATE("Accurate"),
	AGGRESSIVE("Aggressive"),
	AUTOCAST("Autocast"),
	CONTROLLED("Controlled"),
	DEFENSIVE("Defensive"),
	LONGRANGE("Longrange"),
	RAPID("Rapid"),
	;

	private final String displayName;

}

package com.duckblade.osrs.dpscalc.calc.model;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import lombok.extern.jackson.Jacksonized;
import net.runelite.api.EquipmentInventorySlot;

// utility class for populating ComputeContext without #put
// unlike ComputeInputs, this class provides defaults for ALL values
@Value
@Jacksonized
@Builder(toBuilder = true)
public class ComputeInput
{

	// attacker
	@Builder.Default
	private final Skills attackerSkills = Skills.EMPTY;

	@Singular
	private final Map<EquipmentInventorySlot, ItemStats> attackerItems;

	@Singular
	private final Set<Prayer> attackerPrayers;

	@Builder.Default
	private final AttackStyle attackStyle = WeaponCategory.UNARMED.getAttackStyles().get(0);

	@Builder.Default
	private final Spell spell = null;

	@Builder.Default
	private final ItemStats blowpipeDarts = ItemStats.EMPTY;

	@Builder.Default
	private final int attackerDistance = 1;

	// defender
	@Builder.Default
	private final Skills defenderSkills = Skills.EMPTY;

	@Builder.Default
	private final DefensiveBonuses defenderBonuses = DefensiveBonuses.EMPTY;

	@Builder.Default
	private final DefenderAttributes defenderAttributes = DefenderAttributes.EMPTY;

	// extras
	@Builder.Default
	private final boolean onSlayerTask = false;

	@Builder.Default
	private final boolean usingChargeSpell = false;

	@Builder.Default
	private final boolean usingMarkOfDarkness = false;

	@Builder.Default
	private final boolean inWilderness = false;

	@Builder.Default
	private final int raidPartySize = 1;

	public ComputeInputBuilder toBuilderDeep()
	{
		return toBuilder()
			.attackerSkills(attackerSkills.toBuilderDeep().build())
			.attackerItems(new HashMap<>(attackerItems))
			.attackerPrayers(new HashSet<>(attackerPrayers))
			.attackStyle(attackStyle.toBuilder().build())
			.defenderSkills(defenderSkills.toBuilderDeep().build())
			.defenderBonuses(defenderBonuses.toBuilder().build())
			.defenderAttributes(defenderAttributes.toBuilder().build());
	}
}

package com.duckblade.osrs.dpscalc.calc.model;

public enum AttackType
{

	STAB,
	SLASH,
	CRUSH,
	MAGIC,
	RANGED,
	;

	public boolean isMelee()
	{
		switch (this)
		{
			case STAB:
			case SLASH:
			case CRUSH:
				return true;

			default:
				return false;
		}
	}

}

package com.duckblade.osrs.dpscalc.calc.model;

import lombok.RequiredArgsConstructor;
import lombok.Value;

@Value
@RequiredArgsConstructor(staticName = "of")
public class GearBonuses
{

	public static final GearBonuses EMPTY = new GearBonuses(1.0, 1.0);

	private final double accuracyBonus;
	private final double strengthBonus;

	public static GearBonuses combine(GearBonuses a, GearBonuses b)
	{
		return new GearBonuses(a.accuracyBonus * b.accuracyBonus, a.strengthBonus * b.strengthBonus);
	}

	public static GearBonuses symmetric(double bonus)
	{
		return GearBonuses.of(bonus, bonus);
	}

}

package com.duckblade.osrs.dpscalc.calc;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class WeaponComputable implements Computable<ItemStats>
{

	@Override
	public ItemStats compute(ComputeContext context)
	{
		Map<EquipmentInventorySlot, ItemStats> items = context.get(ComputeInputs.ATTACKER_ITEMS);
		return items.getOrDefault(EquipmentInventorySlot.WEAPON, ItemStats.EMPTY);
	}

}

package com.duckblade.osrs.dpscalc.calc.defender;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.defender.skills.SkillScaling;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DefenderSkillsComputable implements Computable<Skills>
{

	private final Set<SkillScaling> skillScalings;

	@Override
	public Skills compute(ComputeContext context)
	{
		return skillScalings.stream()
			.filter(dst -> dst.isApplicable(context))
			.findFirst()
			.map(context::get)
			.orElseGet(() -> context.get(ComputeInputs.DEFENDER_SKILLS));
	}

}

package com.duckblade.osrs.dpscalc.calc.defender.skills;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.NpcID;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class TheatreEntryModeSkillScaling implements SkillScaling
{

	private static final Set<Integer> TOB_EM_NPCS = ImmutableSet.of(
		NpcID.THE_MAIDEN_OF_SUGADINTI_10814, // 100%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10815, // 70%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10816, // 50%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10817, // 30%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10818, // death 1
		NpcID.THE_MAIDEN_OF_SUGADINTI_10819, // death 2
		NpcID.NYLOCAS_MATOMENOS_10820, // death 2
		NpcID.BLOOD_SPAWN_10821, // death 2

		NpcID.PESTILENT_BLOAT_10812,

		NpcID.NYLOCAS_ISCHYROS_10774, // small melee
		NpcID.NYLOCAS_TOXOBOLOS_10775, // small range
		NpcID.NYLOCAS_HAGIOS_10776, // small mage
		NpcID.NYLOCAS_ISCHYROS_10777, // big melee
		NpcID.NYLOCAS_TOXOBOLOS_10778, // big range
		NpcID.NYLOCAS_HAGIOS_10779, // big mage
		NpcID.NYLOCAS_ISCHYROS_10780, // aggro melee
		NpcID.NYLOCAS_TOXOBOLOS_10781, // aggro range
		NpcID.NYLOCAS_HAGIOS_10782, // aggro mage
		NpcID.NYLOCAS_ISCHYROS_10783, // big aggro melee
		NpcID.NYLOCAS_TOXOBOLOS_10784, // big aggro range
		NpcID.NYLOCAS_HAGIOS_10785, // big aggro mage
		NpcID.NYLOCAS_VASILIAS_10787, // melee boss
		NpcID.NYLOCAS_VASILIAS_10788, // mage boss (yes, really, this isn't swapped with 10789)
		NpcID.NYLOCAS_VASILIAS_10789, // range boss

		NpcID.SOTETSEG_10864, // immune (maze) 
		NpcID.SOTETSEG_10865, // attackable

		NpcID.XARPUS_10767, // p1
		NpcID.XARPUS_10768, // p2

		NpcID.VERZIK_VITUR_10830, // pre-fight
		NpcID.VERZIK_VITUR_10831, // p1
		NpcID.VERZIK_VITUR_10832, // p1 -> p2
		NpcID.VERZIK_VITUR_10833, // p2
		NpcID.VERZIK_VITUR_10834, // p2 -> p3
		NpcID.VERZIK_VITUR_10835, // p3
		NpcID.WEB_10837, // p3 web
		NpcID.NYLOCAS_ISCHYROS_10841, // melee nylo
		NpcID.NYLOCAS_TOXOBOLOS_10842, // range nylo
		NpcID.NYLOCAS_HAGIOS_10843, // mage nylo
		NpcID.NYLOCAS_ATHANATOS_10844, // purple healer
		NpcID.NYLOCAS_MATOMENOS_10845 // red healer
	);

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return TOB_EM_NPCS.contains(context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getNpcId());
	}

	@Override
	public int scale(ComputeContext context, Skill skill, int base)
	{
		if (skill != Skill.HITPOINTS)
		{
			return base;
		}

		double scale = Math.min(5, Math.max(1, context.get(ComputeInputs.RAID_PARTY_SIZE))) / 5.0;
		return (int) (scale * base);
	}

}

package com.duckblade.osrs.dpscalc.calc.defender.skills;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.compute.OptionalComputable;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;
import net.runelite.api.Skill;

public interface SkillScaling extends OptionalComputable<Skills>
{

	int scale(ComputeContext context, Skill skill, int base);

	@Override
	default Skills compute(ComputeContext context)
	{
		Map<Skill, Integer> base = context.get(ComputeInputs.DEFENDER_SKILLS).getTotals();
		return Skills.builder()
			.levels(Arrays.stream(Skill.values())
				.collect(Collectors.toMap(
					s -> s,
					s -> scale(context, s, base.getOrDefault(s, 0))
				)))
			.build();
	}


}

package com.duckblade.osrs.dpscalc.calc.defender.skills;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.NpcID;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class TheatreSkillScaling implements SkillScaling
{

	private static final Set<Integer> TOB_NPCS = ImmutableSet.of(
		NpcID.THE_MAIDEN_OF_SUGADINTI, // 100%
		NpcID.THE_MAIDEN_OF_SUGADINTI_8361, // 70%
		NpcID.THE_MAIDEN_OF_SUGADINTI_8362, // 50%
		NpcID.THE_MAIDEN_OF_SUGADINTI_8363, // 30%
		NpcID.THE_MAIDEN_OF_SUGADINTI_8364, // death 1
		NpcID.THE_MAIDEN_OF_SUGADINTI_8365, // death 2
		NpcID.NYLOCAS_MATOMENOS, // maiden red nylo
		NpcID.BLOOD_SPAWN, // maiden spawn

		NpcID.PESTILENT_BLOAT,

		NpcID.NYLOCAS_ISCHYROS_8342, // small melee
		NpcID.NYLOCAS_TOXOBOLOS_8343, // small range
		NpcID.NYLOCAS_HAGIOS, // small mage
		NpcID.NYLOCAS_ISCHYROS_8345, // big melee
		NpcID.NYLOCAS_TOXOBOLOS_8346, // big range
		NpcID.NYLOCAS_HAGIOS_8347, // big mage
		NpcID.NYLOCAS_ISCHYROS_8348, // aggro melee
		NpcID.NYLOCAS_TOXOBOLOS_8349, // aggro range
		NpcID.NYLOCAS_HAGIOS_8350, // aggro mage
		NpcID.NYLOCAS_ISCHYROS_8351, // big aggro melee
		NpcID.NYLOCAS_TOXOBOLOS_8352, // big aggro range
		NpcID.NYLOCAS_HAGIOS_8353, // big aggro mage
		NpcID.NYLOCAS_VASILIAS_8355, // melee boss
		NpcID.NYLOCAS_VASILIAS_8356, // mage boss (yes, really, this isn't swapped with 8357)
		NpcID.NYLOCAS_VASILIAS_8357, // range boss

		NpcID.SOTETSEG_10864, // immune (maze) 
		NpcID.SOTETSEG_10865, // attackable

		NpcID.XARPUS_8339, // healing
		NpcID.XARPUS_8340, // p2+screech

		NpcID.VERZIK_VITUR_8369, // pre-fight
		NpcID.VERZIK_VITUR_8370, // p1
		NpcID.VERZIK_VITUR_8371, // p1 -> p2
		NpcID.VERZIK_VITUR_8372, // p2
		NpcID.VERZIK_VITUR_8373, // p2 -> p3
		NpcID.VERZIK_VITUR_8374, // p3
		NpcID.WEB, // p3 web
		NpcID.NYLOCAS_ISCHYROS_8381, // verz melee nylo
		NpcID.NYLOCAS_TOXOBOLOS_8382, // verz range nylo
		NpcID.NYLOCAS_HAGIOS_8383, // verz mage nylo
		NpcID.NYLOCAS_ATHANATOS, // verz purple nylo
		NpcID.NYLOCAS_MATOMENOS_8385 // verz red nylo
	);

	private static final Set<Integer> TOB_HM_NPCS = ImmutableSet.of(
		NpcID.THE_MAIDEN_OF_SUGADINTI_10822, // 100%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10823, // 70%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10824, // 50%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10825, // 30%
		NpcID.THE_MAIDEN_OF_SUGADINTI_10826, // death
		NpcID.THE_MAIDEN_OF_SUGADINTI_10827, // death
		NpcID.NYLOCAS_MATOMENOS_10828, // maiden red nylo
		NpcID.BLOOD_SPAWN_10829, // maiden spawn

		NpcID.PESTILENT_BLOAT_10813,

		NpcID.NYLOCAS_ISCHYROS_10791, // small melee
		NpcID.NYLOCAS_TOXOBOLOS_10792, // small range
		NpcID.NYLOCAS_HAGIOS_10793, // small mage
		NpcID.NYLOCAS_ISCHYROS_10794, // big melee
		NpcID.NYLOCAS_TOXOBOLOS_10795, // big range
		NpcID.NYLOCAS_HAGIOS_10796, // big mage
		NpcID.NYLOCAS_ISCHYROS_10797, // aggro melee
		NpcID.NYLOCAS_TOXOBOLOS_10798, // aggro range
		NpcID.NYLOCAS_HAGIOS_10799, // aggro mage
		NpcID.NYLOCAS_ISCHYROS_10800, // big aggro melee
		NpcID.NYLOCAS_TOXOBOLOS_10801, // big aggro range
		NpcID.NYLOCAS_HAGIOS_10802, // big aggro mage
		NpcID.NYLOCAS_PRINKIPAS_10804, // demiboss melee
		NpcID.NYLOCAS_PRINKIPAS_10805, // demiboss mage
		NpcID.NYLOCAS_PRINKIPAS_10806, // demiboss range
		NpcID.NYLOCAS_VASILIAS_10808, // melee boss
		NpcID.NYLOCAS_VASILIAS_10809, // mage boss (yes, really, this isn't swapped with 10810)
		NpcID.NYLOCAS_VASILIAS_10810, // range boss

		NpcID.SOTETSEG_10867, // maze
		NpcID.SOTETSEG_10868, // fight

		NpcID.XARPUS_10770, // pre
		NpcID.XARPUS_10771, // p1
		NpcID.XARPUS_10772, // p2

		NpcID.VERZIK_VITUR_10847, // pre
		NpcID.VERZIK_VITUR_10848, // throne
		NpcID.VERZIK_VITUR_10849, // p1->p2
		NpcID.VERZIK_VITUR_10850, // p2
		NpcID.VERZIK_VITUR_10851, // p2->p3
		NpcID.VERZIK_VITUR_10852, // p3
		NpcID.WEB_10854, // p3 web
		NpcID.NYLOCAS_ISCHYROS_10858, // melee nylo
		NpcID.NYLOCAS_TOXOBOLOS_10859, // range nylo
		NpcID.NYLOCAS_HAGIOS_10860, // mage nylo
		NpcID.NYLOCAS_ATHANATOS_10861, // purple healer
		NpcID.NYLOCAS_MATOMENOS_10862 // red healer
	);

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		int npcId = context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getNpcId();
		return TOB_NPCS.contains(npcId) || TOB_HM_NPCS.contains(npcId);
	}

	@Override
	public int scale(ComputeContext context, Skill skill, int base)
	{
		if (skill != Skill.HITPOINTS)
		{
			return base;
		}

		int partySize = Math.min(5, Math.max(3, context.get(ComputeInputs.RAID_PARTY_SIZE)));
		switch (partySize)
		{
			case 3:
				return (int) (0.75 * base);

			case 4:
				return (int) (0.875 * base);

			default:
				return base;
		}
	}

}

package com.duckblade.osrs.dpscalc.calc.defender;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DefenseRollComputable implements Computable<Integer>
{

	private final DefenderSkillsComputable defenderSkillsComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		Skills skills = context.get(defenderSkillsComputable);
		DefensiveBonuses defensiveBonuses = context.get(ComputeInputs.DEFENDER_BONUSES); // todo scaling bonuses

		int defenseLevel;
		int defenseBonus;

		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		switch (attackStyle.getAttackType())
		{
			case MAGIC:
				defenseLevel = skills.getTotals().get(Skill.MAGIC);
				defenseBonus = defensiveBonuses.getDefenseMagic();
				break;

			case RANGED:
				defenseLevel = skills.getTotals().get(Skill.DEFENCE);
				defenseBonus = defensiveBonuses.getDefenseRanged();
				break;

			case STAB:
				defenseLevel = skills.getTotals().get(Skill.DEFENCE);
				defenseBonus = defensiveBonuses.getDefenseStab();
				break;

			case SLASH:
				defenseLevel = skills.getTotals().get(Skill.DEFENCE);
				defenseBonus = defensiveBonuses.getDefenseSlash();
				break;

			default:
				defenseLevel = skills.getTotals().get(Skill.DEFENCE);
				defenseBonus = defensiveBonuses.getDefenseCrush();
				break;
		}

		return (defenseLevel + 9) * (defenseBonus + 64);
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.util.EffectiveLevelComputable;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import java.util.function.ToDoubleFunction;
import javax.inject.Singleton;
import net.runelite.api.Skill;

@Singleton
public class MeleeEffectiveStrengthLevelComputable extends EffectiveLevelComputable
{

	@Override
	protected Skill getBaseSkill()
	{
		return Skill.STRENGTH;
	}

	@Override
	protected Prayer.PrayerGroup getPrayerGroup()
	{
		return Prayer.PrayerGroup.MELEE;
	}

	@Override
	protected ToDoubleFunction<Prayer> getPrayerMultiplier()
	{
		return Prayer::getStrengthMod;
	}

	@Override
	protected int getBaseBonus()
	{
		return 8;
	}

	@Override
	protected Map<CombatStyle, Integer> getCombatFocusBonuses()
	{
		return ImmutableMap.of(
			CombatStyle.AGGRESSIVE, 3,
			CombatStyle.CONTROLLED, 1
		);
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.util.EffectiveLevelComputable;
import com.duckblade.osrs.dpscalc.calc.model.CombatStyle;
import java.util.Collections;
import java.util.Map;
import java.util.function.ToDoubleFunction;
import javax.inject.Singleton;
import net.runelite.api.Skill;

@Singleton
public class RangedEffectiveStrengthLevelComputable extends EffectiveLevelComputable
{

	@Override
	protected Skill getBaseSkill()
	{
		return Skill.RANGED;
	}

	@Override
	protected Prayer.PrayerGroup getPrayerGroup()
	{
		return Prayer.PrayerGroup.RANGED;
	}

	@Override
	protected ToDoubleFunction<Prayer> getPrayerMultiplier()
	{
		return Prayer::getStrengthMod;
	}

	@Override
	protected int getBaseBonus()
	{
		return 8;
	}

	@Override
	protected Map<CombatStyle, Integer> getCombatFocusBonuses()
	{
		return Collections.singletonMap(CombatStyle.ACCURATE, 3);
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class PoweredStaffMaxHitComputable implements MagicMaxHitComputable
{

	private interface StaffMaxHitProvider extends Computable<Integer>
	{
	}

	private static final StaffMaxHitProvider SEAS = ctx ->
	{
		int magicLevel = ctx.get(ComputeInputs.ATTACKER_SKILLS).getTotals().get(Skill.MAGIC);
		return Math.max(1, (magicLevel - 75) / 3 + 20);
	};
	private static final StaffMaxHitProvider WARPED = ctx ->
	{
		int magicLevel = ctx.get(ComputeInputs.ATTACKER_SKILLS).getTotals().get(Skill.MAGIC);
		return Math.max(1, ((8 * magicLevel) + 96) / 37);
	};

	private static final StaffMaxHitProvider SWAMP = ctx -> SEAS.compute(ctx) + 3;
	private static final StaffMaxHitProvider SANGUINESTI = ctx -> SEAS.compute(ctx) + 4;
	private static final StaffMaxHitProvider SHADOW = ctx -> SEAS.compute(ctx) + 6;

	private static final Map<Integer, StaffMaxHitProvider> SPELL_MAP = ImmutableMap.<Integer, StaffMaxHitProvider>builder()
		.put(ItemID.TRIDENT_OF_THE_SEAS, SEAS)
		.put(ItemID.TRIDENT_OF_THE_SEAS_E, SEAS)
		.put(ItemID.TRIDENT_OF_THE_SEAS_FULL, SEAS)
		.put(ItemID.TRIDENT_OF_THE_SWAMP, SWAMP)
		.put(ItemID.TRIDENT_OF_THE_SWAMP_E, SWAMP)
		.put(ItemID.SANGUINESTI_STAFF, SANGUINESTI)
		.put(ItemID.HOLY_SANGUINESTI_STAFF, SANGUINESTI)
		.put(ItemID.TUMEKENS_SHADOW, SHADOW)
		.put(ItemID.CRYSTAL_STAFF_BASIC, ignored -> 23)
		.put(ItemID.CORRUPTED_STAFF_BASIC, ignored -> 23)
		.put(ItemID.CRYSTAL_STAFF_ATTUNED, ignored -> 31)
		.put(ItemID.CORRUPTED_STAFF_ATTUNED, ignored -> 31)
		.put(ItemID.CRYSTAL_STAFF_PERFECTED, ignored -> 39)
		.put(ItemID.CORRUPTED_STAFF_PERFECTED, ignored -> 39)
		.put(ItemID.WARPED_SCEPTRE, WARPED)
		.build();

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		return attackStyle.getAttackType() == AttackType.MAGIC && !attackStyle.isManualCast() &&
			context.get(weaponComputable).getWeaponCategory() == WeaponCategory.POWERED_STAFF;
	}

	@Override
	public Integer compute(ComputeContext context)
	{
		int weaponId = context.get(weaponComputable).getItemId();
		StaffMaxHitProvider staffMaxHitProvider = SPELL_MAP.get(weaponId);

		if (staffMaxHitProvider == null)
		{
			throw new IllegalArgumentException("Missing powered staff max hit provider for weapon id " + weaponId);
		}

		return staffMaxHitProvider.compute(context);
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class MagicSalamanderMaxHitComputable implements MagicMaxHitComputable
{

	private static final Map<Integer, Integer> SALAMANDER_BASES = ImmutableMap.of(
		ItemID.SWAMP_LIZARD, 56,
		ItemID.ORANGE_SALAMANDER, 59,
		ItemID.RED_SALAMANDER, 77,
		ItemID.BLACK_SALAMANDER, 92
	);

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		return attackStyle.getAttackType() == AttackType.MAGIC && !attackStyle.isManualCast() &&
			context.get(weaponComputable).getWeaponCategory() == WeaponCategory.SALAMANDER;
	}

	@Override
	public Integer compute(ComputeContext context)
	{
		int weaponId = context.get(weaponComputable).getItemId();
		Integer salamanderBase = SALAMANDER_BASES.get(weaponId);
		if (salamanderBase == null)
		{
			throw new IllegalArgumentException("Missing salamander base for weapon id " + weaponId);
		}

		Skills skills = context.get(ComputeInputs.ATTACKER_SKILLS);
		int magicLevel = skills.getTotals().get(Skill.MAGIC);

		return magicLevel * (salamanderBase + 64) / 640;
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class SpellMaxHitComputable implements MagicMaxHitComputable
{

	private final WeaponComputable weaponComputable;
	private final SpellcastingMaxHitBonusComputable spellcastingMaxHitBonusComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		if (attackStyle.getAttackType() != AttackType.MAGIC)
		{
			return false;
		}

		if (attackStyle.isManualCast())
		{
			return true;
		}

		WeaponCategory category = context.get(weaponComputable).getWeaponCategory();
		return category != WeaponCategory.SALAMANDER && category != WeaponCategory.POWERED_STAFF;
	}

	@Override
	public Integer compute(ComputeContext context)
	{
		int baseMaxHit = context.get(ComputeInputs.SPELL).getBaseMaxHit();
		int spellBonus = context.get(spellcastingMaxHitBonusComputable);
		return baseMaxHit + spellBonus;
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.gearbonus.AggregateGearBonusesComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.StrengthBonusComputable;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class MageMaxHitComputable implements Computable<Integer>
{

	private final Set<MagicMaxHitComputable> maxHitComputables;
	private final StrengthBonusComputable strengthBonusComputable;
	private final AggregateGearBonusesComputable aggregateGearBonusesComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		int weaponMaxHit = maxHitComputables.stream()
			.filter(mmhc -> mmhc.isApplicable(context))
			.mapToInt(context::get)
			.findFirst()
			.orElseThrow(() -> new IllegalArgumentException("No magic max hit provider for inputs"));

		double magDmgBonus = 1 + context.get(strengthBonusComputable) / 100.0;
		double gearBonus = context.get(aggregateGearBonusesComputable).getStrengthBonus();
		double bonus = magDmgBonus * gearBonus;
		return (int) (weaponMaxHit * bonus);
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class SpellcastingMaxHitBonusComputable implements Computable<Integer>
{

	private static final int CHAOS_GAUNTLETS = ItemID.CHAOS_GAUNTLETS;
	private static final Set<Spell> BOLT_SPELLS = ImmutableSet.of(
		Spell.WIND_BOLT,
		Spell.WATER_BOLT,
		Spell.EARTH_BOLT,
		Spell.FIRE_BOLT
	);

	public static final Set<Spell> GOD_SPELLS = ImmutableSet.of(
		Spell.CLAWS_OF_GUTHIX,
		Spell.SARADOMIN_STRIKE,
		Spell.FLAMES_OF_ZAMORAK
	);

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		Spell spell = context.get(ComputeInputs.SPELL);
		if (BOLT_SPELLS.contains(spell))
		{
			if (CHAOS_GAUNTLETS == context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.GLOVES))
			{
				return 3;
			}
		}
		else if (GOD_SPELLS.contains(spell))
		{
			if (context.get(ComputeInputs.USING_CHARGE_SPELL))
			{
				return 10;
			}
		}
		else if (spell == Spell.MAGIC_DART)
		{
			int magicLvl = context.get(ComputeInputs.ATTACKER_SKILLS).getTotals().get(Skill.MAGIC);
			int weaponId = context.get(equipmentItemIdsComputable).get(EquipmentInventorySlot.WEAPON);
			if (weaponId == ItemID.SLAYERS_STAFF_E && context.get(ComputeInputs.ON_SLAYER_TASK))
			{
				return magicLvl / 6 + 3;
			}
			return magicLvl / 10;
		}

		return 0;
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.magic;

import com.duckblade.osrs.dpscalc.calc.compute.OptionalComputable;

public interface MagicMaxHitComputable extends OptionalComputable<Integer>
{
}

package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.maxhit.limiters.MaxHitLimitComputable;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class BaseMaxHitComputable implements Computable<Integer>
{

	private final PreLimitBaseMaxHitComputable preLimitBaseMaxHitComputable;
	private final MaxHitLimitComputable maxHitLimitComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		return maxHitLimitComputable.coerce(context.get(preLimitBaseMaxHitComputable), context);
	}

}

package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.gearbonus.AggregateGearBonusesComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class MeleeRangedMaxHitComputable implements Computable<Integer>
{

	private final MeleeEffectiveStrengthLevelComputable meleeStrengthComputable;
	private final RangedEffectiveStrengthLevelComputable rangedStrengthComputable;
	private final StrengthBonusComputable strengthBonusComputable;
	private final AggregateGearBonusesComputable aggregateGearBonusesComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		int effectiveStrength = attackStyle.getAttackType() == AttackType.RANGED
			? context.get(rangedStrengthComputable)
			: context.get(meleeStrengthComputable);

		int strengthBonus = context.get(strengthBonusComputable).intValue();
		int baseMaxHit = (effectiveStrength * (strengthBonus + 64) + 320) / 640;

		double strengthGearBonus = context.get(aggregateGearBonusesComputable).getStrengthBonus();
		return (int) (baseMaxHit * strengthGearBonus);
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Singleton;
import net.runelite.api.NpcID;

@Singleton
public class CombatStyleImmunityMaxHitLimiter implements MaxHitLimiter
{

	private static final Set<Integer> MELEE_IMMUNE = ImmutableSet.of(
		NpcID.AVIANSIE,
		NpcID.AVIANSIE_3170,
		NpcID.AVIANSIE_3171,
		NpcID.AVIANSIE_3172,
		NpcID.AVIANSIE_3173,
		NpcID.AVIANSIE_3174,
		NpcID.AVIANSIE_3175,
		NpcID.AVIANSIE_3176,
		NpcID.AVIANSIE_3177,
		NpcID.AVIANSIE_3178,
		NpcID.AVIANSIE_3179,
		NpcID.AVIANSIE_3180,
		NpcID.AVIANSIE_3181,
		NpcID.AVIANSIE_3182,
		NpcID.AVIANSIE_3183,

		NpcID.KREEARRA,
		NpcID.FLIGHT_KILISA,
		NpcID.WINGMAN_SKREE,
		NpcID.FLOCKLEADER_GEERIN,

		NpcID.ZULRAH,
		NpcID.ZULRAH_2043,
		NpcID.ZULRAH_2044
	);

	private static final Set<Integer> RANGED_IMMUNE = ImmutableSet.of();

	private static final Set<Integer> MAGE_IMMUNE = ImmutableSet.of(
		NpcID.CALLISTO
	);

	private static final Map<AttackType, Set<Integer>> IMMUNITY_MAP = ImmutableMap.of(
		AttackType.STAB, MELEE_IMMUNE,
		AttackType.SLASH, MELEE_IMMUNE,
		AttackType.CRUSH, MELEE_IMMUNE,
		AttackType.RANGED, RANGED_IMMUNE,
		AttackType.MAGIC, MAGE_IMMUNE
	);

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return IMMUNITY_MAP.get(context.get(ComputeInputs.ATTACK_STYLE).getAttackType())
			.contains(context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getNpcId());
	}

	@Override
	public MaxHitLimit compute(ComputeContext context)
	{
		String npcName = context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getName();
		AttackType attackType = context.get(ComputeInputs.ATTACK_STYLE).getAttackType();
		return MaxHitLimit.builder()
			.limit(0)
			.warning(npcName + " cannot be hit by " + attackType.name().toLowerCase() + " attacks.")
			.build();
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Singleton;
import net.runelite.api.NpcID;

@Singleton
public class ZulrahMaxHitLimiter implements MaxHitLimiter
{

	private static final Set<Integer> ZULRAH_IDS = ImmutableSet.of(
		NpcID.ZULRAH,
		NpcID.ZULRAH_2043,
		NpcID.ZULRAH_2044
	);

	private static final MaxHitLimit ZULRAH_MAX_HIT = MaxHitLimit.builder()
		.limit(50)
		.warning("Zulrah has a max hit limiter of 50.")
		.build();

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return ZULRAH_IDS.contains(context.get(ComputeInputs.DEFENDER_ATTRIBUTES).getNpcId());
	}

	@Override
	public MaxHitLimit compute(ComputeContext context)
	{
		return ZULRAH_MAX_HIT;
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import java.util.Comparator;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class MaxHitLimitComputable implements Computable<MaxHitLimit>
{

	public static final ComputeOutput<Boolean> LIMIT_APPLIED = ComputeOutput.of("MaxHitLimitApplied");

	private final Set<MaxHitLimiter> maxHitLimiters;

	@Override
	public MaxHitLimit compute(ComputeContext context)
	{
		context.put(LIMIT_APPLIED, false);
		return maxHitLimiters.stream()
			.filter(mhl -> mhl.isApplicable(context))
			.map(context::get)
			.min(Comparator.comparing(MaxHitLimit::getLimit))
			.orElse(MaxHitLimit.UNLIMITED);
	}

	public int coerce(int maxHit, ComputeContext context)
	{
		MaxHitLimit limit = context.get(this);
		if (limit.getLimit() < maxHit)
		{
			if (!context.get(LIMIT_APPLIED))
			{
				context.put(LIMIT_APPLIED, true);
				context.warn(limit.getWarning());
			}
			return limit.getLimit();
		}

		return maxHit;
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.WeaponComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class Tier3VampyreImmunities implements MaxHitLimiter
{

	private static final Set<Integer> T3_VAMPYREBANE_WEAPONS = ImmutableSet.of(
		// t3
		ItemID.IVANDIS_FLAIL,
		ItemID.BLISTERWOOD_SICKLE,
		ItemID.BLISTERWOOD_FLAIL
	);

	private static final MaxHitLimit TIER_3_IMMUNITY = MaxHitLimit.builder()
		.limit(0)
		.warning("Tier 3 vampyres can only be damaged by Blisterwood weapons.")
		.build();

	private final WeaponComputable weaponComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.DEFENDER_ATTRIBUTES).isVampyre3();
	}

	@Override
	public MaxHitLimit compute(ComputeContext context)
	{
		if (context.get(ComputeInputs.ATTACK_STYLE).getAttackType().isMelee() &&
			T3_VAMPYREBANE_WEAPONS.contains(context.get(weaponComputable).getItemId()))
		{
			return MaxHitLimit.UNLIMITED;
		}

		return TIER_3_IMMUNITY;
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.compute.OptionalComputable;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;

public interface MaxHitLimiter extends OptionalComputable<MaxHitLimit>
{

}

package com.duckblade.osrs.dpscalc.calc.maxhit.limiters;

import com.duckblade.osrs.dpscalc.calc.EquipmentItemIdsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.MaxHitLimit;
import com.google.common.collect.ImmutableSet;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.ItemID;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class Tier2VampyreImmunities implements MaxHitLimiter
{

	private static final Set<Integer> SILVER_MELEE = ImmutableSet.of(
		// t3
		ItemID.IVANDIS_FLAIL,
		ItemID.BLISTERWOOD_SICKLE,
		ItemID.BLISTERWOOD_FLAIL,

		// t2
		ItemID.BLESSED_AXE,
		ItemID.SILVER_SICKLE,
		ItemID.SILVER_SICKLE_B,
		ItemID.EMERALD_SICKLE_B,
		ItemID.ENCHANTED_EMERALD_SICKLE_B,
		ItemID.RUBY_SICKLE_B,
		ItemID.ENCHANTED_RUBY_SICKLE_B,
		ItemID.SILVERLIGHT,
		ItemID.SILVERLIGHT_6745,
		ItemID.DARKLIGHT,
		ItemID.ARCLIGHT,
		ItemID.WOLFBANE,
		ItemID.ROD_OF_IVANDIS_1,
		ItemID.ROD_OF_IVANDIS_2,
		ItemID.ROD_OF_IVANDIS_3,
		ItemID.ROD_OF_IVANDIS_4,
		ItemID.ROD_OF_IVANDIS_5,
		ItemID.ROD_OF_IVANDIS_6,
		ItemID.ROD_OF_IVANDIS_7,
		ItemID.ROD_OF_IVANDIS_8,
		ItemID.ROD_OF_IVANDIS_9,
		ItemID.ROD_OF_IVANDIS_10
	);

	private static final Set<Integer> SILVER_AMMO = ImmutableSet.of(
		ItemID.SILVER_BOLTS,
		ItemID.SILVER_BOLTS_P,
		ItemID.SILVER_BOLTS_P_9299,
		ItemID.SILVER_BOLTS_P_9306
	);

	private static final Set<Integer> EFARITAYS_AID = ImmutableSet.of(
		ItemID.EFARITAYS_AID
	);

	private static final MaxHitLimit EFARITAY_LIMIT = MaxHitLimit.builder()
		.limit(10)
		.warning("Efaritay's aid limits max hit to 10.")
		.build();

	private static final MaxHitLimit TIER_2_IMMUNITY = MaxHitLimit.builder()
		.limit(0)
		.warning("Tier 2 vampyres can only be damaged by silver weaponry or with Efaritay's aid.")
		.build();

	private final EquipmentItemIdsComputable equipmentItemIdsComputable;

	@Override
	public boolean isApplicable(ComputeContext context)
	{
		return context.get(ComputeInputs.DEFENDER_ATTRIBUTES).isVampyre2();
	}

	@Override
	public MaxHitLimit compute(ComputeContext context)
	{
		Map<EquipmentInventorySlot, Integer> equipment = context.get(equipmentItemIdsComputable);
		boolean efaritay = EFARITAYS_AID.contains(equipment.get(EquipmentInventorySlot.RING));

		switch (context.get(ComputeInputs.ATTACK_STYLE).getAttackType())
		{
			case MAGIC:
				return efaritay ? EFARITAY_LIMIT : TIER_2_IMMUNITY;

			case RANGED:
				if (SILVER_AMMO.contains(equipment.get(EquipmentInventorySlot.AMMO)))
				{
					return MaxHitLimit.UNLIMITED;
				}

				return efaritay ? EFARITAY_LIMIT : TIER_2_IMMUNITY;

			default:
				if (SILVER_MELEE.contains(equipment.get(EquipmentInventorySlot.WEAPON)))
				{
					return MaxHitLimit.UNLIMITED;
				}

				return efaritay ? EFARITAY_LIMIT : TIER_2_IMMUNITY;
		}
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.AttackerItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class StrengthBonusComputable implements Computable<Integer>
{

	private final AttackerItemStatsComputable attackerItemStatsComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		AttackStyle attackStyle = context.get(ComputeInputs.ATTACK_STYLE);
		ItemStats itemStats = context.get(attackerItemStatsComputable);
		switch (attackStyle.getAttackType())
		{
			case MAGIC:
				return itemStats.getStrengthMagic();

			case RANGED:
				return itemStats.getStrengthRanged();

			default:
				return itemStats.getStrengthMelee();
		}
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.MageMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.model.AttackType;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;

// this needs to be split out from BaseMaxHitComputable 
// so that future multihit computables can source their max hit accurately
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class PreLimitBaseMaxHitComputable implements Computable<Integer>
{

	private final MeleeRangedMaxHitComputable meleeRangedMaxHitComputable;
	private final MageMaxHitComputable mageMaxHitComputable;

	@Override
	public Integer compute(ComputeContext context)
	{
		if (context.get(ComputeInputs.ATTACK_STYLE).getAttackType() == AttackType.MAGIC)
		{
			return context.get(mageMaxHitComputable);
		}
		return context.get(meleeRangedMaxHitComputable);
	}
}

package com.duckblade.osrs.dpscalc.calc.maxhit;

import com.duckblade.osrs.dpscalc.calc.compute.Computable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeOutput;
import java.util.List;
import java.util.Objects;
import javax.inject.Inject;
import javax.inject.Named;
import javax.inject.Singleton;

/**
 * Computes the combined max hit, 
 * accounting for special effects like multi-hits,
 * or special effects like the Keris.
 * 
 * This class is not called anywhere naturally within the calc module,
 * and will not be accurate unless run after the effect calculations,
 * which are only sourced during DptComputable.
 * It exists to be called after dps calculations, 
 * to simplify grabbing the true max hit that would otherwise be 
 * distributed across multiple possible output sources.
 */
@Singleton
public class TrueMaxHitComputable implements Computable<Integer>
{

	private final BaseMaxHitComputable baseMaxHitComputable;

	private final List<ComputeOutput<Integer>> effectMaxHitOutputs;

	@Inject
	public TrueMaxHitComputable(BaseMaxHitComputable baseMaxHitComputable, @Named("EffectMaxHitOutputs") List<ComputeOutput<Integer>> effectMaxHitOutputs)
	{
		this.baseMaxHitComputable = baseMaxHitComputable;
		this.effectMaxHitOutputs = effectMaxHitOutputs;
	}

	@Override
	public Integer compute(ComputeContext context)
	{
		return effectMaxHitOutputs.stream()
			.map(context::get)
			.filter(Objects::nonNull)
			.findFirst()
			.orElseGet(() -> context.get(baseMaxHitComputable));
	}
}

package com.duckblade.osrs.dpscalc.plugin.live;

import lombok.Value;

@Value
public class TargetedDps
{

	private final int npcIndex;
	private final double dps;

}

package com.duckblade.osrs.dpscalc.plugin.live;

import com.duckblade.osrs.dpscalc.calc.DpsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.exceptions.MissingInputException;
import com.duckblade.osrs.dpscalc.calc.model.ComputeInput;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.plugin.module.PluginLifecycleComponent;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.InteractingNpcTracker;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class LiveDpsService implements PluginLifecycleComponent
{

	private final EventBus eventBus;

	private final ClientDataProvider clientDataProvider;
	private final DpsComputable dpsComputable;
	private final InteractingNpcTracker interactingNpcTracker;

	private ComputeInput lastInput;
	private int lastNpcIndex;

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		ComputeInput input = clientDataProvider.toComputeInput();
		int npcIndex = interactingNpcTracker.getLastInteractedIndex();
		if (!input.equals(lastInput) || lastNpcIndex != npcIndex)
		{
			lastNpcIndex = npcIndex;
			lastInput = input;
			ComputeContext context = new ComputeContext(input);
			try
			{
				DefenderAttributes defenderAttributes = input.getDefenderAttributes();
				if (defenderAttributes == null || defenderAttributes.getNpcId() == -1)
				{
					setDps(null, input, context);
				}
				else
				{
					TargetedDps newDps = new TargetedDps(npcIndex, context.get(dpsComputable));
					setDps(newDps, input, context);
				}
			}
			catch (Exception e)
			{
				setDps(null, input, context);
				if (!(e.getCause() instanceof MissingInputException))
				{
					throw e;
				}
			}
		}
	}

	public void setDps(TargetedDps newValue, ComputeInput input, ComputeContext context)
	{
		eventBus.post(new TargetedDpsChanged(newValue, input, context));
	}
}

package com.duckblade.osrs.dpscalc.plugin.live.party;

import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import com.duckblade.osrs.dpscalc.plugin.live.TargetedDps;
import com.duckblade.osrs.dpscalc.plugin.live.TargetedDpsChanged;
import com.duckblade.osrs.dpscalc.plugin.live.party.messages.UpdateLiveDps;
import com.duckblade.osrs.dpscalc.plugin.module.PluginLifecycleComponent;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.PartyChanged;
import net.runelite.client.party.PartyMember;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.party.events.UserPart;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class PartyDpsService implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final PartyService partyService;
	private final WSClient wsClient;

	private final Map<Long, TargetedDps> partyMemberDps = new HashMap<>();

	@Override
	public Predicate<DpsCalcConfig> isConfigEnabled()
	{
		return DpsCalcConfig::enablePartyService;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		wsClient.registerMessage(UpdateLiveDps.class);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		wsClient.unregisterMessage(UpdateLiveDps.class);
	}

	@Subscribe
	public void onPartyChanged(PartyChanged e)
	{
		partyMemberDps.clear();
	}

	@Subscribe
	public void onUserPart(UserPart e)
	{
		partyMemberDps.remove(e.getMemberId());
	}

	@Subscribe
	public void onUpdateLiveDps(UpdateLiveDps e)
	{
		setMemberDps(e.getMemberId(), e.getTargetedDps());
	}

	@Subscribe
	public void onTargetedDpsChanged(TargetedDpsChanged e)
	{
		PartyMember localMember;
		if (partyService.isInParty() && (localMember = partyService.getLocalMember()) != null)
		{
			long localId = localMember.getMemberId();
			setMemberDps(localId, e.getTargetedDps());
			partyService.send(new UpdateLiveDps(localId, e.getTargetedDps()));
		}
	}

	private void setMemberDps(long memberId, TargetedDps dps)
	{
		if (dps == null)
		{
			partyMemberDps.remove(memberId);
		}
		else
		{
			partyMemberDps.put(memberId, dps);
		}
	}

	public double getPartyDps(int npcIndex)
	{
		return partyMemberDps.values()
			.stream()
			.filter(td -> td.getNpcIndex() == npcIndex)
			.mapToDouble(TargetedDps::getDps)
			.sum();
	}

	public boolean hasDps()
	{
		return partyService.isInParty() &&
			!partyMemberDps.isEmpty();
	}
}

package com.duckblade.osrs.dpscalc.plugin.live.party.messages;

import com.duckblade.osrs.dpscalc.plugin.live.TargetedDps;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@EqualsAndHashCode(callSuper = true)
public class UpdateLiveDps extends PartyMemberMessage
{

	private final TargetedDps targetedDps;

	public UpdateLiveDps(long memberId, TargetedDps targetedDps)
	{
		setMemberId(memberId);
		this.targetedDps = targetedDps;
	}
}

package com.duckblade.osrs.dpscalc.plugin.live.overlay;

import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import com.duckblade.osrs.dpscalc.plugin.module.PluginLifecycleComponent;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.input.KeyManager;
import net.runelite.client.util.HotkeyListener;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class OverlayMinimizerService implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final KeyManager keyManager;

	private final DpsCalcConfig config;

	private HotkeyListener toggleListener;
	private boolean forceMinimized = false;

	private Instant minimizeTimeout = Instant.now();
	private boolean timeoutMinimized = false;

	@Override
	public void startUp()
	{
		eventBus.register(this);
		keyManager.registerKeyListener(toggleListener = new HotkeyListener(config::liveOverlayMinimizeHotkey)
		{
			@Override
			public void hotkeyPressed()
			{
				forceMinimized = !forceMinimized;
			}
		});
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		keyManager.unregisterKeyListener(toggleListener);
	}

	public boolean isMinimized()
	{
		if (!timeoutMinimized)
		{
			timeoutMinimized = minimizeTimeout.isBefore(Instant.now());
		}

		return forceMinimized || timeoutMinimized;
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied e)
	{
		if (e.getHitsplat().isMine())
		{
			timeoutMinimized = false;
			minimizeTimeout = Instant.now()
				.plus(config.liveOverlayMinimizeDelay(), ChronoUnit.SECONDS);
		}
	}
}

package com.duckblade.osrs.dpscalc.plugin.live.overlay;

import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.maxhit.TrueMaxHitComputable;
import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import com.duckblade.osrs.dpscalc.plugin.live.TargetedDps;
import com.duckblade.osrs.dpscalc.plugin.live.TargetedDpsChanged;
import com.duckblade.osrs.dpscalc.plugin.live.party.PartyDpsService;
import com.duckblade.osrs.dpscalc.plugin.module.PluginLifecycleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.text.DecimalFormat;
import java.util.function.Predicate;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Singleton
@Slf4j
public class LiveDpsOverlay extends OverlayPanel implements PluginLifecycleComponent
{

	private static final DecimalFormat DPS_FORMAT = new DecimalFormat("#.##");
	private static final DecimalFormat MAX_HIT_FORMAT = new DecimalFormat("#.##");
	private static final DecimalFormat HIT_CHANCE_FORMAT = new DecimalFormat("#.##%");

	private final EventBus eventBus;
	private final OverlayManager overlayManager;
	private final DpsCalcConfig config;

	private final OverlayMinimizerService overlayMinimizerService;
	private final PartyDpsService partyDpsService;

	private final TrueMaxHitComputable trueMaxHitComputable;
	private final HitChanceComputable hitChanceComputable;

	// boxed types so we can store null
	private TargetedDps targetedDps;
	private Integer maxHit;
	private Double hitChance;

	@Inject
	public LiveDpsOverlay(
		OverlayManager overlayManager, EventBus eventBus, DpsCalcConfig config,
		OverlayMinimizerService overlayMinimizerService, PartyDpsService partyDpsService,
		TrueMaxHitComputable trueMaxHitComputable, HitChanceComputable hitChanceComputable
	)
	{
		this.eventBus = eventBus;
		this.overlayManager = overlayManager;
		this.config = config;

		this.overlayMinimizerService = overlayMinimizerService;
		this.partyDpsService = partyDpsService;

		this.trueMaxHitComputable = trueMaxHitComputable;
		this.hitChanceComputable = hitChanceComputable;

		setPosition(OverlayPosition.BOTTOM_LEFT);
	}

	@Override
	public Predicate<DpsCalcConfig> isConfigEnabled()
	{
		return DpsCalcConfig::showLiveOverlay;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
		overlayManager.add(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
		overlayManager.remove(this);
	}

	@Subscribe
	public void onTargetedDpsChanged(TargetedDpsChanged e)
	{
		targetedDps = e.getTargetedDps();

		ComputeContext context = e.getContext();
		maxHit = ComputeUtil.tryCompute(() -> context.get(trueMaxHitComputable));
		hitChance = ComputeUtil.tryCompute(() -> context.get(hitChanceComputable));
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (overlayMinimizerService.isMinimized())
		{
			return null;
		}

		if (targetedDps == null && config.liveOverlayMinimizeIncomplete())
		{
			return null;
		}

		if (config.liveOverlayShowTitle())
		{
			getPanelComponent().getChildren().add(
				TitleComponent.builder()
					.text("DPS Calc")
					.build()
			);
		}

		if (config.liveOverlayShowDps())
		{
			addLineComponent("DPS", targetedDps == null ? "???" : DPS_FORMAT.format(targetedDps.getDps()));
		}

		if (config.liveOverlayShowPartyDps() && partyDpsService.hasDps())
		{
			double partyDps = partyDpsService.getPartyDps(targetedDps.getNpcIndex());
			addLineComponent("Party DPS", targetedDps == null ? "???" : DPS_FORMAT.format(partyDps));
		}

		if (config.liveOverlayShowMaxHit())
		{
			addLineComponent("Max Hit", maxHit == null ? "???" : MAX_HIT_FORMAT.format(maxHit));
		}

		if (config.liveOverlayShowHitChance())
		{
			addLineComponent("Hit Chance", hitChance == null ? "???" : HIT_CHANCE_FORMAT.format(hitChance));
		}

		return super.render(graphics);
	}

	private void addLineComponent(String left, String right)
	{
		getPanelComponent().getChildren().add(
			LineComponent.builder()
				.left(left)
				.right(right)
				.build()
		);
	}

}

package com.duckblade.osrs.dpscalc.plugin.live;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.model.ComputeInput;
import lombok.Value;

@Value
public class TargetedDpsChanged
{

	private final TargetedDps targetedDps;
	private final ComputeInput input;
	private final ComputeContext context;

}

package com.duckblade.osrs.dpscalc.plugin.util;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

public class FutureUtil
{

	public static CompletableFuture<?> simpleCompletableFuture(ExecutorService es, ThrowableRunnable r)
	{
		CompletableFuture<?> f = new CompletableFuture<>();

		es.submit(() ->
		{
			try
			{
				r.run();
				f.complete(null);
			}
			catch (Throwable ex)
			{
				f.completeExceptionally(ex);
			}
		});

		return f;
	}

}

package com.duckblade.osrs.dpscalc.plugin.util;

@FunctionalInterface
public interface ThrowableRunnable
{

	void run() throws Throwable;

}

package com.duckblade.osrs.dpscalc.plugin;

import com.duckblade.osrs.dpscalc.calc.DpsComputeModule;
import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import com.duckblade.osrs.dpscalc.plugin.module.ComponentManager;
import com.duckblade.osrs.dpscalc.plugin.module.DpsPluginModule;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.inject.Binder;
import com.google.inject.Provides;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.slayer.SlayerPlugin;

@Slf4j
@Singleton
@PluginDependency(SlayerPlugin.class)
@PluginDescriptor(
	name = "DPS Calculator"
)
public class DpsCalcPlugin extends Plugin
{

	private static final ListeningExecutorService dataLoadEs =
		MoreExecutors.listeningDecorator(Executors.newSingleThreadExecutor());

	private ComponentManager componentManager;

	@Override
	public void configure(Binder binder)
	{
		binder.install(new DpsComputeModule());
		binder.install(new DpsPluginModule());
	}

	@Override
	protected void startUp()
	{
		CompletableFuture.allOf(
			injector.getInstance(NpcDataProvider.class).load(dataLoadEs),
			injector.getInstance(ItemStatsProvider.class).load(dataLoadEs)
		).thenRunAsync(() ->
			SwingUtilities.invokeLater(() ->
			{
				componentManager = injector.getInstance(ComponentManager.class);
				componentManager.onPluginStart();
			}), dataLoadEs);
	}

	@Override
	protected void shutDown()
	{
		componentManager.onPluginStop();
	}

	@Provides
	DpsCalcConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DpsCalcConfig.class);
	}
}
package com.duckblade.osrs.dpscalc.plugin.osdata.wiki;

import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

public interface ItemStatsProvider
{

	CompletableFuture<?> load(ExecutorService es);

	Set<ItemStats> getAll();

	ItemStats getById(int itemId);

}

package com.duckblade.osrs.dpscalc.plugin.osdata.wiki;

import com.duckblade.osrs.dpscalc.plugin.util.FutureUtil;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class WikiNpcDataProvider implements NpcDataProvider
{

	private static final String NPC_STATS_URL = "npcs.min.json";
	private static final String NPC_BASE_IDS_URL = "npc-base-ids.min.json";

	private final Gson gson;
	private final WikiDataLoader wikiDataLoader;

	private Map<Integer, NpcData> npcStatsMap;
	private Map<Integer, Integer> npcBaseIdsMap;

	@Override
	public CompletableFuture<?> load(ExecutorService es)
	{
		return FutureUtil.simpleCompletableFuture(es, () ->
		{
			wikiDataLoader.getReader(NPC_BASE_IDS_URL, reader ->
				npcBaseIdsMap = gson.fromJson(reader, new TypeToken<HashMap<Integer, Integer>>()
				{
				}.getType())
			);
			wikiDataLoader.getReader(NPC_STATS_URL, reader ->
				npcStatsMap = gson.fromJson(reader, new TypeToken<HashMap<Integer, NpcData>>()
				{
				}.getType())
			);
		});
	}

	public Set<NpcData> getAll()
	{
		return new HashSet<>(npcStatsMap.values());
	}

	public NpcData getById(int npcId)
	{
		return npcStatsMap.get(canonicalize(npcId));
	}

	public int canonicalize(int npcId)
	{
		return npcBaseIdsMap.getOrDefault(npcId, npcId);
	}

}
package com.duckblade.osrs.dpscalc.plugin.osdata.wiki;

import java.io.IOException;
import java.io.Reader;
import java.util.function.Consumer;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

@Slf4j
@Singleton
public class WikiDataLoader
{

	private static final String BASE_URL = "https://raw.githubusercontent.com/LlemonDuck/runelite-wiki-scraper/wiki-data-v2/";

	private final OkHttpClient okHttpClient;

	@Inject
	public WikiDataLoader(OkHttpClient okHttpClient)
	{
		this.okHttpClient = okHttpClient.newBuilder()
			.addInterceptor(chain ->
				chain.proceed(
					chain.request()
						.newBuilder()
						.header("User-Agent", "RuneLite plugin dps-calculator (GitHub/LlemonDuck)")
						.build()
				))
			.build();
	}

	void getReader(String part, Consumer<Reader> callback) throws IOException
	{
		String url = BASE_URL + part;
		try (Response response = okHttpClient.newCall(new Request.Builder().url(url).build()).execute())
		{
			log.debug(response.toString());

			if (!response.isSuccessful() && response.code() != 304)
			{
				throw new IOException(String.format("Request to [%s] failed: %s", url, response));
			}

			ResponseBody body = response.body();
			if (body == null)
			{
				throw new IOException(String.format("Received null body from request to [%s]", url));
			}

			callback.accept(body.charStream());
		}
	}

}
package com.duckblade.osrs.dpscalc.plugin.osdata.wiki;

import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

public interface NpcDataProvider
{

	CompletableFuture<?> load(ExecutorService es);

	Set<NpcData> getAll();

	NpcData getById(int npcId);

	int canonicalize(int npcId);

}

package com.duckblade.osrs.dpscalc.plugin.osdata.wiki;

import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import lombok.Builder;
import lombok.Value;
import lombok.extern.jackson.Jacksonized;

/**
 * Aggregate data type for a single NPC's multiple calc properties.
 */
@Value
@Jacksonized
@Builder
public class NpcData
{
	private final Skills skills;
	private final DefensiveBonuses defensiveBonuses;
	private final DefenderAttributes attributes;
}

package com.duckblade.osrs.dpscalc.plugin.osdata.wiki;

import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.plugin.util.FutureUtil;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class WikiItemStatsProvider implements ItemStatsProvider
{

	private static final String ITEM_STATS_URL = "items.min.json";

	private Map<Integer, ItemStats> itemStatsMap;

	private final Gson gson;
	private final WikiDataLoader wikiDataLoader;

	public CompletableFuture<?> load(ExecutorService es)
	{
		return FutureUtil.simpleCompletableFuture(es, () ->
		{
			wikiDataLoader.getReader(ITEM_STATS_URL, reader ->
				itemStatsMap = gson.fromJson(reader, new TypeToken<HashMap<Integer, ItemStats>>()
				{
				}.getType())
			);
		});
	}

	@Override
	public Set<ItemStats> getAll()
	{
		return new HashSet<>(itemStatsMap.values());
	}

	@Override
	public ItemStats getById(int npcId)
	{
		return itemStatsMap.get(npcId);
	}

}
package com.duckblade.osrs.dpscalc.plugin.osdata.clientdata;

import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcData;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.client.plugins.slayer.SlayerPluginService;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class RuneLiteClientDataProvider implements ClientDataProvider
{

	private static final int AUTOCAST_SPELL_VARBIT = 276;

	private final Client client;
	private final SlayerPluginService slayerPluginService;

	private final DpsCalcConfig config;
	private final ItemStatsProvider itemStatsProvider;
	private final NpcDataProvider npcDataProvider;
	private final InteractingNpcTracker interactingNpcTracker;

	@Override
	public Skills getPlayerSkills()
	{
		Map<Skill, Integer> levels = new EnumMap<>(Skill.class);
		Map<Skill, Integer> boosts = new EnumMap<>(Skill.class);
		for (Skill s : Skill.values())
		{
			if (s != Skill.OVERALL)
			{
				int level = client.getRealSkillLevel(s);
				levels.put(s, level);
				boosts.put(s, client.getBoostedSkillLevel(s) - level);
			}
		}

		return Skills.builder()
			.levels(ImmutableMap.copyOf(levels))
			.boosts(ImmutableMap.copyOf(boosts))
			.build();
	}

	@Override
	public Map<EquipmentInventorySlot, ItemStats> getPlayerEquipment()
	{
		ItemContainer inv = client.getItemContainer(InventoryID.EQUIPMENT);
		if (inv == null)
		{
			return Collections.emptyMap();
		}

		Map<EquipmentInventorySlot, ItemStats> equipment = new EnumMap<>(EquipmentInventorySlot.class);
		for (EquipmentInventorySlot slot : EquipmentInventorySlot.values())
		{
			Item i = inv.getItem(slot.getSlotIdx());
			ItemStats is = i == null ? null : itemStatsProvider.getById(i.getId());
			if (is != null)
			{
				equipment.put(slot, is);
			}
		}
		return ImmutableMap.copyOf(equipment);
	}

	@Override
	public Set<Prayer> getPlayerActivePrayers()
	{
		Set<Prayer> prayers = EnumSet.noneOf(Prayer.class);
		for (Prayer p : Prayer.values())
		{
			if (client.isPrayerActive(p.getRlPrayer()))
			{
				prayers.add(p);
			}
		}

		return ImmutableSet.copyOf(prayers);
	}

	@Override
	public AttackStyle getAttackStyle()
	{
		ItemStats weapon = getPlayerEquipment().getOrDefault(EquipmentInventorySlot.WEAPON, ItemStats.EMPTY);
		int asVarp = client.getVarpValue(VarPlayer.ATTACK_STYLE);

		for (AttackStyle as : weapon.getWeaponCategory().getAttackStyles())
		{
			if (as.getVarpValue() == asVarp)
			{
				return as;
			}
		}

		return null;
	}

	@Override
	public Spell getSpell()
	{
		int spellVarb = client.getVarbitValue(AUTOCAST_SPELL_VARBIT);
		for (Spell s : Spell.values())
		{
			if (s.getVarbValue() == spellVarb)
			{
				return s;
			}
		}

		return null;
	}

	@Override
	public ItemStats getBlowpipeDarts()
	{
		return itemStatsProvider.getById(config.defaultBlowpipeDarts().getItemId());
	}

	@Override
	public Skills getNpcTargetSkills()
	{
		NpcData lastInteracted = interactingNpcTracker.getLastInteracted();
		return lastInteracted == null ? null : lastInteracted.getSkills();
	}

	@Override
	public DefensiveBonuses getNpcTargetBonuses()
	{
		NpcData lastInteracted = interactingNpcTracker.getLastInteracted();
		return lastInteracted == null ? null : lastInteracted.getDefensiveBonuses();
	}

	@Override
	public DefenderAttributes getNpcTargetAttributes()
	{
		NpcData lastInteracted = interactingNpcTracker.getLastInteracted();
		return lastInteracted == null ? null : lastInteracted.getAttributes();
	}

	@Override
	public boolean playerIsOnSlayerTask()
	{
		DefenderAttributes attr = getNpcTargetAttributes();
		if (attr == null)
		{
			return false;
		}

		List<NPC> targets = slayerPluginService.getTargets();
		if (targets == null)
		{
			return false;
		}

		// this will only work if the task npc is on-screen which should always be true for the overlay
		// but could be inaccurate if loading the data into side panel after a delay
		return targets.stream()
			.anyMatch(npc -> npcDataProvider.canonicalize(npc.getId()) == attr.getNpcId());
	}

	@Override
	public boolean playerIsUsingChargeSpell()
	{
		return false;
	}

	@Override
	public boolean playerIsUsingMarkOfDarkness()
	{
		return false;
	}

	@Override
	public boolean playerIsInWilderness()
	{
		return client.getVarbitValue(Varbits.PVP_SPEC_ORB) == 1;
	}
}

package com.duckblade.osrs.dpscalc.plugin.osdata.clientdata;

import com.duckblade.osrs.dpscalc.plugin.module.PluginLifecycleComponent;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcData;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.events.InteractingChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
@Slf4j
public class InteractingNpcTracker implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final Client client;

	private final NpcDataProvider npcDataProvider;

	@Getter
	private NpcData lastInteracted = null;

	@Getter
	private int lastInteractedIndex = -1;

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged e)
	{
		if (e.getSource() != client.getLocalPlayer())
		{
			return;
		}

		if (!(e.getTarget() instanceof NPC))
		{
			return;
		}

		NPC npc = (NPC) e.getTarget();
		lastInteractedIndex = npc.getIndex();
		lastInteracted = npcDataProvider.getById(npc.getId());

		log.debug("Setting last interacted to {}", lastInteracted == null ? "null" : lastInteracted.getAttributes().getName());
	}
}

package com.duckblade.osrs.dpscalc.plugin.osdata.clientdata;

import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProvider;
import java.util.function.Consumer;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.callback.ClientThread;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ClientDataProviderThreadProxy
{

	private final Client client;
	private final ClientThread clientThread;
	private final ClientDataProvider clientDataProvider;

	/**
	 * Silently swallows the runnable if client data is not available.
	 */
	public void tryAcquire(Consumer<ClientDataProvider> runnable)
	{
		clientThread.invokeLater(() ->
		{
			if (client.getGameState() == GameState.LOGGED_IN && client.getLocalPlayer() != null)
			{
				runnable.accept(clientDataProvider);
			}
		});
	}

}

package com.duckblade.osrs.dpscalc.plugin.osdata.clientdata;

import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.ComputeInput;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import java.util.Map;
import java.util.Set;
import net.runelite.api.EquipmentInventorySlot;

public interface ClientDataProvider
{

	Skills getPlayerSkills();

	Map<EquipmentInventorySlot, ItemStats> getPlayerEquipment();

	Set<Prayer> getPlayerActivePrayers();

	AttackStyle getAttackStyle();

	Spell getSpell();

	ItemStats getBlowpipeDarts();

	Skills getNpcTargetSkills();

	DefensiveBonuses getNpcTargetBonuses();

	DefenderAttributes getNpcTargetAttributes();

	boolean playerIsOnSlayerTask();

	boolean playerIsUsingChargeSpell();

	boolean playerIsUsingMarkOfDarkness();

	boolean playerIsInWilderness();

	default ComputeInput toComputeInput()
	{
		return ComputeInput.builder()
			.attackerSkills(getPlayerSkills())
			.attackerItems(getPlayerEquipment())
			.attackerPrayers(getPlayerActivePrayers())
			.attackStyle(getAttackStyle())
			.spell(getSpell())
			.blowpipeDarts(getBlowpipeDarts())
			.defenderSkills(getNpcTargetSkills())
			.defenderBonuses(getNpcTargetBonuses())
			.defenderAttributes(getNpcTargetAttributes())
			.onSlayerTask(playerIsOnSlayerTask())
			.usingChargeSpell(playerIsUsingChargeSpell())
			.usingMarkOfDarkness(playerIsUsingMarkOfDarkness())
			.inWilderness(playerIsInWilderness())
			.build();
	}

}

package com.duckblade.osrs.dpscalc.plugin.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.ItemID;

@Getter
@RequiredArgsConstructor
public enum BlowpipeDarts
{

	DRAGON("Dragon", ItemID.DRAGON_DART),
	RUNE("Rune", ItemID.RUNE_DART),
	AMETHYST("Amethyst", ItemID.AMETHYST_DART),
	ADAMANT("Adamant", ItemID.ADAMANT_DART),
	MITHRIL("Mithril", ItemID.MITHRIL_DART),
	BLACK("Black", ItemID.BLACK_DART),
	STEEL("Steel", ItemID.STEEL_DART),
	IRON("Iron", ItemID.IRON_DART),
	BRONZE("Bronze", ItemID.BRONZE_DART),
	;

	private final String displayName;
	private final int itemId;

	public static BlowpipeDarts fromId(int id)
	{
		for (BlowpipeDarts dartType : values())
		{
			if (id == dartType.itemId)
			{
				return dartType;
			}
		}

		return null;
	}

}

package com.duckblade.osrs.dpscalc.plugin.config;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup(DpsCalcConfig.CONFIG_GROUP)
public interface DpsCalcConfig extends Config
{
	String CONFIG_GROUP = "dpscalculator";

	@ConfigItem(
		keyName = "showMinimenuEntry",
		name = "Right-Click Entry",
		description = "Whether to add a right-click entry to NPCs to quickly load them into the side panel.",
		position = 1
	)
	default boolean showMinimenuEntry()
	{
		return true;
	}

	@ConfigItem(
		keyName = "defaultBlowpipeDarts",
		name = "Blowpipe Darts",
		description = "Default darts to use in calculations for the Toxic Blowpipe.",
		position = 2,
		hidden = true
	)
	default BlowpipeDarts defaultBlowpipeDarts()
	{
		return BlowpipeDarts.DRAGON;
	}

	@ConfigItem(
		keyName = "enablePartyService",
		name = "Enable Party DPS",
		description = "Shares your DPS results with your party members who also have DPS Calculator installed.",
		position = 3
	)
	default boolean enablePartyService()
	{
		return true;
	}

	@ConfigSection(
		name = "Live Overlay",
		description = "",
		position = 100
	)
	String SECTION_LIVE_OVERLAY_FEATURES = "liveOverlayFeatures";

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "showLiveOverlay",
		name = "Live Overlay Panel",
		description = "Show live overlay panel with DPS results against your current target.",
		position = 101
	)
	default boolean showLiveOverlay()
	{
		return true;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "showTitle",
		name = "Show Title",
		description = "Show 'DPS Calc' title bar in live overlay panel.",
		position = 102
	)
	default boolean liveOverlayShowTitle()
	{
		return true;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "showDps",
		name = "Show DPS",
		description = "Show DPS in live overlay panel.",
		position = 103
	)
	default boolean liveOverlayShowDps()
	{
		return true;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "showPartyDps",
		name = "Show Party DPS",
		description = "Show cumulative party DPS in live overlay panel (requires party members to also have DPS Calculator installed).",
		position = 104
	)
	default boolean liveOverlayShowPartyDps()
	{
		return true;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "showMaxHit",
		name = "Show Max Hit",
		description = "Show max hit in live overlay panel.",
		position = 105
	)
	default boolean liveOverlayShowMaxHit()
	{
		return true;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "showHitChance",
		name = "Show Hit %",
		description = "Show hit chance in live overlay panel.",
		position = 106
	)
	default boolean liveOverlayShowHitChance()
	{
		return true;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "minimizeDelay",
		name = "Minimize Delay",
		description = "Hide the live overlay after this long out without dealing damage.",
		position = 107
	)
	@Units(Units.SECONDS)
	@Range()
	default int liveOverlayMinimizeDelay()
	{
		return 60;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "minimizeIncomplete",
		name = "Minimize Incomplete",
		description = "Minimize the overlay when the DPS cannot be calculated.",
		position = 108
	)
	default boolean liveOverlayMinimizeIncomplete()
	{
		return true;
	}

	@ConfigItem(
		section = SECTION_LIVE_OVERLAY_FEATURES,
		keyName = "minimizeHotkey",
		name = "Toggle Hotkey",
		description = "Toggle the live dps overlay with this hotkey",
		position = 109
	)
	default Keybind liveOverlayMinimizeHotkey()
	{
		return Keybind.NOT_SET;
	}
}

package com.duckblade.osrs.dpscalc.plugin.module;

import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;

/**
 * Manages all the subcomponents of the plugin
 * so they can register themselves to RuneLite resources
 * e.g. EventBus/OverlayManager/init on startup/etc
 * instead of the DpsCalcPlugin class handling everything.
 */
@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
@Slf4j
public class ComponentManager
{

	private final EventBus eventBus;
	private final DpsCalcConfig config;
	private final Set<PluginLifecycleComponent> components;

	private final Map<PluginLifecycleComponent, Boolean> states = new HashMap<>();

	public void onPluginStart()
	{
		eventBus.register(this);
		components.forEach(c -> states.put(c, false));
		components.stream()
			.filter(c -> c.isConfigEnabled().test(config))
			.forEach(this::tryStartUp);
	}

	public void onPluginStop()
	{
		eventBus.unregister(this);
		components.stream()
			.filter(states::get)
			.forEach(this::tryShutDown);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (!DpsCalcConfig.CONFIG_GROUP.equals(e.getGroup()))
		{
			return;
		}

		components.forEach(c ->
		{
			boolean shouldBeEnabled = c.isConfigEnabled().test(config);
			boolean isEnabled = states.get(c);
			if (shouldBeEnabled == isEnabled)
			{
				return;
			}

			if (shouldBeEnabled)
			{
				tryStartUp(c);
			}
			else
			{
				tryShutDown(c);
			}
		});
	}

	private void tryStartUp(PluginLifecycleComponent component)
	{
		if (states.get(component))
		{
			return;
		}

		try
		{
			component.startUp();
			states.put(component, true);
		}
		catch (Exception e)
		{
			log.error("Failed to start DPS Calc component [{}]", component.getClass().getName(), e);
		}
	}

	private void tryShutDown(PluginLifecycleComponent component)
	{
		if (!states.get(component))
		{
			return;
		}

		try
		{
			component.shutDown();
		}
		catch (Exception e)
		{
			log.error("Failed to cleanly shut down DPS Calc component [{}]", component.getClass().getName());
		}
		finally
		{
			states.put(component, false);
		}
	}

}

package com.duckblade.osrs.dpscalc.plugin.module;

import com.duckblade.osrs.dpscalc.plugin.DpsMenuActionListener;
import com.duckblade.osrs.dpscalc.plugin.live.LiveDpsService;
import com.duckblade.osrs.dpscalc.plugin.live.overlay.LiveDpsOverlay;
import com.duckblade.osrs.dpscalc.plugin.live.overlay.OverlayMinimizerService;
import com.duckblade.osrs.dpscalc.plugin.live.party.PartyDpsService;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.InteractingNpcTracker;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.RuneLiteClientDataProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.WikiItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.WikiNpcDataProvider;
import com.duckblade.osrs.dpscalc.plugin.ui.NavButtonManager;
import com.google.inject.AbstractModule;
import com.google.inject.multibindings.Multibinder;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class DpsPluginModule extends AbstractModule
{

	@Override
	protected void configure()
	{
		Multibinder<PluginLifecycleComponent> lifecycleComponents = Multibinder.newSetBinder(binder(), PluginLifecycleComponent.class);
		lifecycleComponents.addBinding().to(DpsMenuActionListener.class);
		lifecycleComponents.addBinding().to(InteractingNpcTracker.class);
		lifecycleComponents.addBinding().to(LiveDpsService.class);
		lifecycleComponents.addBinding().to(LiveDpsOverlay.class);
		lifecycleComponents.addBinding().to(PartyDpsService.class);
		lifecycleComponents.addBinding().to(NavButtonManager.class);
		lifecycleComponents.addBinding().to(OverlayMinimizerService.class);

		bind(ItemStatsProvider.class).to(WikiItemStatsProvider.class);
		bind(NpcDataProvider.class).to(WikiNpcDataProvider.class);
		bind(ClientDataProvider.class).to(RuneLiteClientDataProvider.class);
	}

}

package com.duckblade.osrs.dpscalc.plugin.module;

import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import java.util.function.Predicate;

public interface PluginLifecycleComponent
{

	default Predicate<DpsCalcConfig> isConfigEnabled()
	{
		return ignored -> true;
	}

	void startUp();

	void shutDown();

}

package com.duckblade.osrs.dpscalc.plugin;

import com.duckblade.osrs.dpscalc.plugin.config.DpsCalcConfig;
import com.duckblade.osrs.dpscalc.plugin.module.PluginLifecycleComponent;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcData;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.duckblade.osrs.dpscalc.plugin.ui.DpsCalcPanel;
import com.duckblade.osrs.dpscalc.plugin.ui.NavButtonManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import java.util.function.Predicate;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class DpsMenuActionListener implements PluginLifecycleComponent
{

	private final EventBus eventBus;
	private final Client client;

	private final NpcDataProvider npcDataProvider;
	private final NavButtonManager navButtonManager;

	private final PanelStateManager panelStateManager;
	private final DpsCalcPanel dpsCalcPanel;

	@Override
	public Predicate<DpsCalcConfig> isConfigEnabled()
	{
		return DpsCalcConfig::showMinimenuEntry;
	}

	@Override
	public void startUp()
	{
		eventBus.register(this);
	}

	@Override
	public void shutDown()
	{
		eventBus.unregister(this);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded e)
	{
		if (MenuAction.of(e.getType()) == MenuAction.EXAMINE_NPC)
		{
			NPC npc = client.getCachedNPCs()[e.getIdentifier()];
			int npcId = npc.getId();

			NpcData npcData = npcDataProvider.getById(npcId);
			if (npcData != null)
			{
				client.createMenuEntry(-1)
					.setOption("Dps")
					.setTarget(e.getTarget())
					.setType(MenuAction.RUNELITE)
					.setParam0(e.getActionParam0())
					.setParam1(e.getActionParam1())
					.setIdentifier(e.getIdentifier())
					.onClick(me -> onMenuOptionClicked(npcData));
			}
		}
	}

	public void onMenuOptionClicked(NpcData npcData)
	{
		SwingUtilities.invokeLater(() ->
		{
			PanelState panelState = panelStateManager.currentState();
			panelState.loadNpcData(npcData);

			dpsCalcPanel.openNpcPanel();
			navButtonManager.openPanel();
		});
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui;

import com.duckblade.osrs.dpscalc.plugin.module.PluginLifecycleComponent;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class NavButtonManager implements PluginLifecycleComponent
{

	private final ClientToolbar clientToolbar;
	private final DpsPluginPanel pluginPanel;

	private NavigationButton navButton;

	@Override
	public void startUp()
	{
		navButton = NavigationButton.builder()
			.priority(5)
			.icon(ImageUtil.loadImageResource(getClass(), "equip/slot_0.png"))
			.tooltip("DPS Calculator")
			.panel(pluginPanel)
			.build();
		clientToolbar.addNavigation(navButton);
	}

	@Override
	public void shutDown()
	{
		clientToolbar.removeNavigation(navButton);
		navButton = null;
	}

	public void openPanel()
	{
		SwingUtilities.invokeLater(() -> clientToolbar.openPanel(navButton));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.npc;

import com.duckblade.osrs.dpscalc.plugin.ui.skills.StatCategory;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState.MutableDefenderAttributes;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJCheckBox;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundStatBox;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.ObjIntConsumer;
import java.util.function.Predicate;
import java.util.function.ToIntFunction;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import lombok.Getter;

@Singleton
public class NpcAttributesPanel extends JPanel implements StateBoundComponent
{

	private static ObjIntConsumer<PanelState> writer(ObjIntConsumer<MutableDefenderAttributes> inner)
	{
		return (state, value) -> inner.accept(state.getDefenderAttributes(), value);
	}

	private static ToIntFunction<PanelState> reader(ToIntFunction<MutableDefenderAttributes> inner)
	{
		return state -> inner.applyAsInt(state.getDefenderAttributes());
	}

	private static BiConsumer<PanelState, Boolean> writer(BiConsumer<MutableDefenderAttributes, Boolean> inner)
	{
		return (state, value) -> inner.accept(state.getDefenderAttributes(), value);
	}

	private static Predicate<PanelState> reader(Predicate<MutableDefenderAttributes> inner)
	{
		return state -> inner.test(state.getDefenderAttributes());
	}

	@Getter
	private final PanelStateManager manager;
	private final List<StateBoundStatBox> numericalAttrBoxes = new ArrayList<>(5);
	private final List<StateBoundJCheckBox> booleanAttrBoxes = new ArrayList<>(6);

	@Inject
	public NpcAttributesPanel(PanelStateManager manager)
	{
		this.manager = manager;
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setPreferredSize(new Dimension(200, 300));
		setMaximumSize(new Dimension(200, 300));

		numericalAttrBoxes.add(new StateBoundStatBox(manager, "id", "NPC ID", false, writer(MutableDefenderAttributes::setNpcId), reader(MutableDefenderAttributes::getNpcId)));
		numericalAttrBoxes.add(new StateBoundStatBox(manager, "amagic", "Magic Acc.", false, writer(MutableDefenderAttributes::setAccuracyMagic), reader(MutableDefenderAttributes::getAccuracyMagic)));
		numericalAttrBoxes.add(new StateBoundStatBox(manager, "size", "Size", false, writer(MutableDefenderAttributes::setSize), reader(MutableDefenderAttributes::getSize)));
		add(new StatCategory("Defensive Bonuses", numericalAttrBoxes));
		add(Box.createVerticalStrut(5));

		JPanel booleanAttrPanel = new JPanel();
		booleanAttrPanel.setLayout(new GridLayout(4, 2));
		add(booleanAttrPanel);

		booleanAttrBoxes.add(new StateBoundJCheckBox("Demon", manager, writer(MutableDefenderAttributes::setDemon), reader(MutableDefenderAttributes::isDemon)));
		booleanAttrBoxes.add(new StateBoundJCheckBox("Dragon", manager, writer(MutableDefenderAttributes::setDragon), reader(MutableDefenderAttributes::isDragon)));
		booleanAttrBoxes.add(new StateBoundJCheckBox("Kalphite", manager, writer(MutableDefenderAttributes::setKalphite), reader(MutableDefenderAttributes::isKalphite)));
		booleanAttrBoxes.add(new StateBoundJCheckBox("Leafy", manager, writer(MutableDefenderAttributes::setLeafy), reader(MutableDefenderAttributes::isLeafy)));
		booleanAttrBoxes.add(new StateBoundJCheckBox("Undead", manager, writer(MutableDefenderAttributes::setUndead), reader(MutableDefenderAttributes::isUndead)));
		booleanAttrBoxes.add(new StateBoundJCheckBox("T1 Vampyre", manager, writer(MutableDefenderAttributes::setVampyre1), reader(MutableDefenderAttributes::isVampyre1)));
		booleanAttrBoxes.add(new StateBoundJCheckBox("T2 Vampyre", manager, writer(MutableDefenderAttributes::setVampyre2), reader(MutableDefenderAttributes::isVampyre2)));
		booleanAttrBoxes.add(new StateBoundJCheckBox("T3 Vampyre", manager, writer(MutableDefenderAttributes::setVampyre3), reader(MutableDefenderAttributes::isVampyre3)));
		booleanAttrBoxes.forEach(sbsb -> sbsb.setEditable(false));
		booleanAttrBoxes.forEach(booleanAttrPanel::add);
	}

	@Override
	public void toState()
	{
		numericalAttrBoxes.forEach(StateBoundStatBox::toState);
	}

	@Override
	public void fromState()
	{
		setPreferredSize(new Dimension(200, 300));
		setMaximumSize(new Dimension(200, 300));
		numericalAttrBoxes.forEach(StateBoundStatBox::fromState);
	}

	public void setEditable(boolean editable)
	{
		numericalAttrBoxes.forEach(sbsb -> sbsb.setEditable(editable));
		booleanAttrBoxes.forEach(sbsb -> sbsb.setEditable(editable));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.npc;

import com.duckblade.osrs.dpscalc.plugin.ui.skills.StatCategory;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState.MutableDefensiveBonuses;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundStatBox;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import java.util.function.ObjIntConsumer;
import java.util.function.ToIntFunction;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.JPanel;
import lombok.Getter;

@Singleton
public class NpcBonusesPanel extends JPanel implements StateBoundComponent
{

	private static ObjIntConsumer<PanelState> writer(ObjIntConsumer<MutableDefensiveBonuses> inner)
	{
		return (state, value) -> inner.accept(state.getDefenderBonuses(), value);
	}

	private static ToIntFunction<PanelState> reader(ToIntFunction<MutableDefensiveBonuses> inner)
	{
		return state -> inner.applyAsInt(state.getDefenderBonuses());
	}

	@Getter
	private final PanelStateManager manager;
	private final List<StateBoundStatBox> statBoxes = new ArrayList<>(5);

	@Inject
	public NpcBonusesPanel(PanelStateManager manager)
	{
		this.manager = manager;

		statBoxes.add(new StateBoundStatBox(manager, "dstab", "Stab", false, writer(MutableDefensiveBonuses::setDefenseStab), reader(MutableDefensiveBonuses::getDefenseStab)));
		statBoxes.add(new StateBoundStatBox(manager, "dslash", "Slash", false, writer(MutableDefensiveBonuses::setDefenseSlash), reader(MutableDefensiveBonuses::getDefenseSlash)));
		statBoxes.add(new StateBoundStatBox(manager, "dcrush", "Crush", false, writer(MutableDefensiveBonuses::setDefenseCrush), reader(MutableDefensiveBonuses::getDefenseCrush)));
		statBoxes.add(new StateBoundStatBox(manager, "dmagic", "Magic", false, writer(MutableDefensiveBonuses::setDefenseMagic), reader(MutableDefensiveBonuses::getDefenseMagic)));
		statBoxes.add(new StateBoundStatBox(manager, "drange", "Ranged", false, writer(MutableDefensiveBonuses::setDefenseRanged), reader(MutableDefensiveBonuses::getDefenseRanged)));
		add(new StatCategory("Defensive Bonuses", statBoxes));

		add(Box.createVerticalStrut(5));
		setMaximumSize(new Dimension(200, 134));
	}

	@Override
	public void toState()
	{
		statBoxes.forEach(StateBoundStatBox::toState);
	}

	@Override
	public void fromState()
	{
		statBoxes.forEach(StateBoundStatBox::fromState);
	}

	public void setEditable(boolean editable)
	{
		statBoxes.forEach(sbsb -> sbsb.setEditable(editable));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.npc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.defender.DefenderSkillsComputable;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.plugin.ui.skills.StatCategory;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundStatBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.function.ObjIntConsumer;
import java.util.function.ToIntFunction;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.JPanel;
import lombok.Getter;
import net.runelite.api.Skill;

@Singleton
public class NpcSkillsPanel extends JPanel implements StateBoundComponent
{

	private static ObjIntConsumer<PanelState> writer(Skill skill)
	{
		return (state, lvl) -> state.getDefenderSkills().put(skill, lvl);
	}

	private static ToIntFunction<PanelState> reader(Skill skill)
	{
		return state -> state.getDefenderSkills().getOrDefault(skill, 0);
	}

	@Getter
	private final PanelStateManager manager;
	private final Map<Skill, StateBoundStatBox> skillBoxes = new HashMap<>(6);
	private final DefenderSkillsComputable defenderSkillsComputable;

	@Inject
	public NpcSkillsPanel(PanelStateManager manager, DefenderSkillsComputable defenderSkillsComputable)
	{
		this.manager = manager;
		this.defenderSkillsComputable = defenderSkillsComputable;

		skillBoxes.put(Skill.HITPOINTS, new StateBoundStatBox(manager, "hitpoints", "Hitpoints", false, writer(Skill.HITPOINTS), reader(Skill.HITPOINTS)));
		skillBoxes.put(Skill.ATTACK, new StateBoundStatBox(manager, "att", "Attack", false, writer(Skill.ATTACK), reader(Skill.ATTACK)));
		skillBoxes.put(Skill.STRENGTH, new StateBoundStatBox(manager, "str", "Strength", false, writer(Skill.STRENGTH), reader(Skill.STRENGTH)));
		skillBoxes.put(Skill.DEFENCE, new StateBoundStatBox(manager, "def", "Defence", false, writer(Skill.DEFENCE), reader(Skill.DEFENCE)));
		skillBoxes.put(Skill.MAGIC, new StateBoundStatBox(manager, "mage", "Magic", false, writer(Skill.MAGIC), reader(Skill.MAGIC)));
		skillBoxes.put(Skill.RANGED, new StateBoundStatBox(manager, "range", "Ranged", false, writer(Skill.RANGED), reader(Skill.RANGED)));
		add(new StatCategory("Combat Stats", new ArrayList<>(skillBoxes.values())));
		add(Box.createVerticalStrut(5));
		setMaximumSize(new Dimension(200, 134));
	}

	@Override
	public void toState()
	{
		skillBoxes.values().forEach(StateBoundStatBox::toState);
	}

	@Override
	public void fromState()
	{
		skillBoxes.values().forEach(StateBoundStatBox::fromState);
	}

	public void fromScaled()
	{
		Skills scaled = ComputeUtil.tryCompute(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.DEFENDER_ATTRIBUTES, getState().getDefenderAttributes().toImmutable());
			ctx.put(ComputeInputs.DEFENDER_SKILLS, Skills.builder().levels(getState().getDefenderSkills()).build());
			ctx.put(ComputeInputs.RAID_PARTY_SIZE, getState().getRaidPartySize());

			return ctx.get(defenderSkillsComputable);
		});

		if (scaled != null)
		{
			skillBoxes.forEach((s, sbsb) -> sbsb.setValue(scaled.getTotals().getOrDefault(s, 0)));
		}
		else
		{
			fromState();
		}
	}

	public void setEditable(boolean editable)
	{
		skillBoxes.values().forEach(sbsb -> sbsb.setEditable(editable));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.npc;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.defender.skills.TheatreEntryModeSkillScaling;
import com.duckblade.osrs.dpscalc.calc.defender.skills.TheatreSkillScaling;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import com.duckblade.osrs.dpscalc.plugin.ui.util.FocusLostAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.JTextFieldIntOnlyKeyAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.SelectAllFocusListener;
import com.google.common.base.Strings;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import lombok.Getter;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class RaidPartySizePanel extends JPanel implements StateBoundComponent, StateVisibleComponent
{

	@Getter
	private final PanelStateManager manager;
	private final TheatreSkillScaling theatreSkillScaling;
	private final TheatreEntryModeSkillScaling theatreEntryModeSkillScaling;

	private final JTextField partySizeField;

	private final List<Runnable> callbacks = new ArrayList<>();

	@Inject
	public RaidPartySizePanel(PanelStateManager manager, TheatreSkillScaling theatreSkillScaling, TheatreEntryModeSkillScaling theatreEntryModeSkillScaling)
	{
		this.manager = manager;
		this.theatreSkillScaling = theatreSkillScaling;
		this.theatreEntryModeSkillScaling = theatreEntryModeSkillScaling;

		setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH - 25, 40));
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 25, 40));
		setLayout(new GridLayout(2, 2));
		setVisible(false);

		partySizeField = new JTextField("1", 2);
		partySizeField.setAlignmentX(Component.CENTER_ALIGNMENT); // of component
		partySizeField.setHorizontalAlignment(JTextField.CENTER); // of inner text
		partySizeField.addFocusListener(new SelectAllFocusListener(partySizeField));
		partySizeField.addKeyListener(new JTextFieldIntOnlyKeyAdapter());
		partySizeField.addFocusListener(new FocusLostAdapter(e -> onChange()));
		partySizeField.addActionListener(e -> onChange());

		add(new JLabel("Party Size"));
		add(partySizeField);
		add(Box.createVerticalStrut(10));
	}

	private void onChange()
	{
		toState();
		callbacks.forEach(Runnable::run);
	}

	@Override
	public void toState()
	{
		coerce();
		getState().setRaidPartySize(Integer.parseInt(partySizeField.getText()));
	}

	@Override
	public void fromState()
	{
		partySizeField.setText(String.valueOf(getState().getRaidPartySize()));
	}

	@Override
	public void updateVisibility()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.DEFENDER_ATTRIBUTES, getState().getDefenderAttributes().toImmutable());

			setVisible(theatreSkillScaling.isApplicable(ctx) || theatreEntryModeSkillScaling.isApplicable(ctx));
		});
	}

	private void coerce()
	{
		if (Strings.isNullOrEmpty(partySizeField.getText()))
		{
			partySizeField.setText("1");
		}
	}

	public void addCallback(Runnable r)
	{
		callbacks.add(r);
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.npc;

import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProviderThreadProxy;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState.MutableDefenderAttributes;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState.MutableDefensiveBonuses;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.CustomJCheckBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.LoadFromClientButton;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import lombok.Getter;

@Singleton
public class NpcStatsPanel extends JPanel implements StateBoundComponent
{

	@Getter
	private final PanelStateManager manager;
	private final ClientDataProviderThreadProxy clientDataProviderThreadProxy;

	private final CustomJCheckBox manualEntry;
	private final NpcSelectPanel npcSelectPanel;
	private final RaidPartySizePanel raidPartySizePanel;
	private final NpcSkillsPanel npcSkillsPanel;
	private final NpcBonusesPanel npcBonusesPanel;
	private final NpcAttributesPanel npcAttributesPanel;

	@Inject
	public NpcStatsPanel(
		PanelStateManager manager, ClientDataProviderThreadProxy clientDataProviderThreadProxy,
		NpcSelectPanel npcSelectPanel, RaidPartySizePanel raidPartySizePanel, NpcSkillsPanel npcSkillsPanel,
		NpcBonusesPanel npcBonusesPanel, NpcAttributesPanel npcAttributesPanel
	)
	{
		this.manager = manager;
		this.raidPartySizePanel = raidPartySizePanel;
		this.clientDataProviderThreadProxy = clientDataProviderThreadProxy;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		add(new LoadFromClientButton(this::loadFromClient));

		manualEntry = new CustomJCheckBox("Manual Entry Mode");
		manualEntry.setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 8));
		manualEntry.addCallback(() -> setManualMode(manualEntry.getValue()));
		add(manualEntry);
		add(Box.createVerticalStrut(5));

		this.npcSelectPanel = npcSelectPanel;
		npcSelectPanel.addCallback(this::fromState);
		add(npcSelectPanel);

		raidPartySizePanel.addCallback(this::fromState);
		add(raidPartySizePanel);

		this.npcSkillsPanel = npcSkillsPanel;
		add(npcSkillsPanel);

		this.npcBonusesPanel = npcBonusesPanel;
		add(npcBonusesPanel);

		this.npcAttributesPanel = npcAttributesPanel;
		add(npcAttributesPanel);
	}

	public void setManualMode(boolean manualMode)
	{
		if (!manualMode)
		{
			npcSelectPanel.setValue(null);
		}
		npcSelectPanel.setVisible(!manualMode);

		npcSkillsPanel.setEditable(manualMode);
		npcBonusesPanel.setEditable(manualMode);
		npcAttributesPanel.setEditable(manualMode);
	}

	public void loadFromClient()
	{
		clientDataProviderThreadProxy.tryAcquire(clientDataProvider ->
		{
			Skills s = clientDataProvider.getNpcTargetSkills();
			getState().setDefenderSkills(s != null ? s.getTotals() : Skills.EMPTY.getTotals());
			getState().setDefenderBonuses(MutableDefensiveBonuses.fromImmutable(clientDataProvider.getNpcTargetBonuses()));
			getState().setDefenderAttributes(MutableDefenderAttributes.fromImmutable(clientDataProvider.getNpcTargetAttributes()));
			SwingUtilities.invokeLater(this::fromState);
		});
	}

	@Override
	public void toState()
	{
		raidPartySizePanel.toState();
		if (!manualEntry.getValue())
		{
			npcSelectPanel.toState();

			npcSkillsPanel.fromScaled();
			return;
		}
		npcSkillsPanel.toState();
		npcBonusesPanel.toState();
		npcAttributesPanel.toState();
	}

	@Override
	public void fromState()
	{
		raidPartySizePanel.fromState();
		raidPartySizePanel.updateVisibility();
		if (!manualEntry.getValue())
		{
			npcSelectPanel.fromState();

			npcSkillsPanel.fromScaled();
			npcBonusesPanel.fromState();
			npcAttributesPanel.fromState();
			return;
		}
		npcSkillsPanel.fromState();
		npcBonusesPanel.fromState();
		npcAttributesPanel.fromState();
	}

	public boolean isReady()
	{
		return manualEntry.getValue() || npcSelectPanel.getValue() != null;
	}

	public String getSummary()
	{
		if (!isReady())
		{
			return "Not Set";
		}

		if (manualEntry.getValue())
		{
			return "Entered Manually";
		}

		return getState().getDefenderAttributes().getName();
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.npc;

import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcData;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcDataProvider;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJComboBox;
import java.awt.Dimension;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import lombok.Getter;

@Singleton
public class NpcSelectPanel extends StateBoundJComboBox<NpcData>
{

	private static List<NpcData> getNpcs(NpcDataProvider npcDataProvider)
	{
		return npcDataProvider.getAll()
			.stream()
			.sorted(Comparator.comparing(npc -> npc.getAttributes().getName()))
			.collect(Collectors.toList());
	}

	private static NpcData readNpcFromState(PanelState state, NpcDataProvider npcDataProvider)
	{
		return npcDataProvider.getById(state.getDefenderAttributes().getNpcId());
	}

	@Getter
	private final PanelStateManager manager;

	@Inject
	public NpcSelectPanel(NpcDataProvider npcDataProvider, PanelStateManager manager)
	{
		super(
			getNpcs(npcDataProvider),
			npc -> npc.getAttributes().getName(),
			null,
			manager,
			PanelState::loadNpcData,
			ps -> readNpcFromState(ps, npcDataProvider)
		);
		this.manager = manager;

		setBorder(BorderFactory.createEmptyBorder(0, 8, 0, 8));
		setPreferredSize(new Dimension(200, 25));
		enableAutocomplete();
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BorderFactory;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

public class CustomJCheckBox extends JPanel
{

	JCheckBox checkBox;
	JLabel label;

	private final List<Runnable> callbacks = new ArrayList<>();

	public CustomJCheckBox(String text)
	{
		setLayout(new BorderLayout());
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 25));

		checkBox = new JCheckBox();
		checkBox.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 3));
		checkBox.addActionListener(e -> invokeCallback());
		add(checkBox, BorderLayout.WEST);

		label = new JLabel(text);
		label.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		add(label, BorderLayout.CENTER);

		final MouseAdapter clickListener = new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (checkBox.isEnabled())
				{
					setValue(!getValue());
					invokeCallback();
				}
			}
		};
		label.addMouseListener(clickListener);
		addMouseListener(clickListener);
	}

	private void invokeCallback()
	{
		callbacks.forEach(Runnable::run);
	}

	public boolean getValue()
	{
		return isVisible() && checkBox.isSelected();
	}

	public void setValue(boolean newValue)
	{
		checkBox.setSelected(newValue);
		invokeCallback();
	}

	public void setEditable(boolean editable)
	{
		this.checkBox.setEnabled(editable);
	}

	public void addCallback(Runnable r)
	{
		callbacks.add(r);
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import com.duckblade.osrs.dpscalc.calc.exceptions.DpsComputeException;
import com.duckblade.osrs.dpscalc.calc.exceptions.MissingInputException;
import java.util.function.Supplier;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;

@UtilityClass
@Slf4j
public class ComputeUtil
{

	public void computeSilent(Runnable compute)
	{
		try
		{
			compute.run();
		}
		catch (DpsComputeException e)
		{
			if (!(e.getCause() instanceof MissingInputException))
			{
				throw e;
			}
		}
	}

	public <T> T tryCompute(Supplier<T> compute)
	{
		try
		{
			return compute.get();
		}
		catch (DpsComputeException e)
		{
			if (!(e.getCause() instanceof MissingInputException))
			{
				throw e;
			}
			return null;
		}
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import java.awt.event.*;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import javax.swing.*;
import javax.swing.text.*;

/* Public domain class from http://www.orbital-computer.de/JComboBox/
 * TODO Refactor before release
 */
public class AutoCompletion extends PlainDocument
{
	JComboBox comboBox;
	ComboBoxModel model;
	JTextComponent editor;
	// flag to indicate if setSelectedItem has been called
	// subsequent calls to remove/insertString should be ignored
	boolean selecting = false;
	boolean hidePopupOnFocusLoss;
	boolean hitBackspace = false;
	boolean hitBackspaceOnSelection;

	KeyListener editorKeyListener;
	FocusListener editorFocusListener;

	public AutoCompletion(final JComboBox comboBox)
	{
		this.comboBox = comboBox;
		model = comboBox.getModel();
		comboBox.addActionListener(e ->
		{
			if (!selecting) highlightCompletedText(0);
		});
		comboBox.addPropertyChangeListener(new PropertyChangeListener()
		{
			public void propertyChange(PropertyChangeEvent e)
			{
				if (e.getPropertyName().equals("editor")) configureEditor((ComboBoxEditor) e.getNewValue());
				if (e.getPropertyName().equals("model")) model = (ComboBoxModel) e.getNewValue();
			}
		});
		editorKeyListener = new KeyAdapter()
		{
			public void keyPressed(KeyEvent e)
			{
				if (comboBox.isDisplayable()) comboBox.setPopupVisible(true);
				hitBackspace = false;
				switch (e.getKeyCode())
				{
					// determine if the pressed key is backspace (needed by the remove method)
					case KeyEvent.VK_BACK_SPACE:
						hitBackspace = true;
						hitBackspaceOnSelection = editor.getSelectionStart() != editor.getSelectionEnd();
						break;
					// ignore delete key
					case KeyEvent.VK_DELETE:
						e.consume();
						comboBox.getToolkit().beep();
						break;
				}
			}
		};
		// Bug 5100422 on Java 1.5: Editable JComboBox won't hide popup when tabbing out
		hidePopupOnFocusLoss = System.getProperty("java.version").startsWith("1.5");
		// Highlight whole text when gaining focus
		editorFocusListener = new FocusAdapter()
		{
			public void focusGained(FocusEvent e)
			{
				highlightCompletedText(0);
			}

			public void focusLost(FocusEvent e)
			{
				// Workaround for Bug 5100422 - Hide Popup on focus loss
				if (hidePopupOnFocusLoss) comboBox.setPopupVisible(false);
			}
		};
		configureEditor(comboBox.getEditor());
		// Handle initially selected object
		Object selected = comboBox.getSelectedItem();
		if (selected != null) setText(selected.toString());
		highlightCompletedText(0);
	}

	public static void enable(JComboBox comboBox)
	{
		// has to be editable
		comboBox.setEditable(true);
		// change the editor's document
		new AutoCompletion(comboBox);
	}

	void configureEditor(ComboBoxEditor newEditor)
	{
		if (editor != null)
		{
			editor.removeKeyListener(editorKeyListener);
			editor.removeFocusListener(editorFocusListener);
		}

		if (newEditor != null)
		{
			editor = (JTextComponent) newEditor.getEditorComponent();
			editor.addKeyListener(editorKeyListener);
			editor.addFocusListener(editorFocusListener);
			editor.setDocument(this);
		}
	}

	public void remove(int offs, int len) throws BadLocationException
	{
		// return immediately when selecting an item
		if (selecting) return;
		if (hitBackspace)
		{
			// user hit backspace => move the selection backwards
			// old item keeps being selected
			if (offs > 0)
			{
				if (hitBackspaceOnSelection) offs--;
			}
			else
			{
				// User hit backspace with the cursor positioned on the start => beep
				comboBox.getToolkit().beep(); // when available use: UIManager.getLookAndFeel().provideErrorFeedback(comboBox);
			}
			highlightCompletedText(offs);
		}
		else
		{
			super.remove(offs, len);
		}
	}

	public void insertString(int offs, String str, AttributeSet a) throws BadLocationException
	{
		// return immediately when selecting an item
		if (selecting) return;
		// insert the string into the document
		super.insertString(offs, str, a);
		// lookup and select a matching item
		Object item = lookupItem(getText(0, getLength()));
		if (item != null)
		{
			setSelectedItem(item);
		}
		else
		{
			// keep old item selected if there is no match
			item = comboBox.getSelectedItem();
			// imitate no insert (later on offs will be incremented by str.length(): selection won't move forward)
			offs = offs - str.length();
			// provide feedback to the user that his input has been received but can not be accepted
			comboBox.getToolkit().beep(); // when available use: UIManager.getLookAndFeel().provideErrorFeedback(comboBox);
		}
		setText(item.toString());
		// select the completed part
		highlightCompletedText(offs + str.length());
	}

	private void setText(String text)
	{
		try
		{
			// remove all text and insert the completed string
			super.remove(0, getLength());
			super.insertString(0, text, null);
		}
		catch (BadLocationException e)
		{
			throw new RuntimeException(e.toString());
		}
	}

	private void highlightCompletedText(int start)
	{
		editor.setCaretPosition(getLength());
		editor.moveCaretPosition(start);
	}

	private void setSelectedItem(Object item)
	{
		selecting = true;
		model.setSelectedItem(item);
		selecting = false;
	}

	private Object lookupItem(String pattern)
	{
		Object selectedItem = model.getSelectedItem();
		// only search for a different item if the currently selected does not match
		if (selectedItem != null && startsWithIgnoreCase(selectedItem.toString(), pattern))
		{
			return selectedItem;
		}
		else
		{
			// iterate over all items
			for (int i = 0, n = model.getSize(); i < n; i++)
			{
				Object currentItem = model.getElementAt(i);
				// current item starts with the pattern?
				if (currentItem != null && startsWithIgnoreCase(currentItem.toString(), pattern))
				{
					return currentItem;
				}
			}
		}
		// no item starts with the pattern => return null
		return null;
	}

	// checks if str1 starts with str2 - ignores case
	private boolean startsWithIgnoreCase(String str1, String str2)
	{
		return str1.toUpperCase().startsWith(str2.toUpperCase());
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;

// only allows ascii digits and minus sign
public class JTextFieldIntOnlyKeyAdapter extends KeyAdapter
{

	private static boolean isDigit(char c)
	{
		// java.lang.Character.isDigit includes non-ascii codes
		return c >= '0' && c <= '9';
	}

	@Override
	public void keyTyped(KeyEvent e)
	{
		char targetKey = e.getKeyChar();
		if (!isDigit(targetKey) && targetKey != '-')
			e.consume();
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import javax.swing.Box;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.PluginPanel;

public class CustomJComboBox<T> extends JPanel
{

	private static final int HEIGHT_WITH_TITLE = 40;
	private static final int HEIGHT_WITHOUT_TITLE = 25;

	private final JLabel titleLabel;
	private final JComboBox<String> comboBox;

	private List<T> items;
	private final Function<T, String> displayMapper;
	private boolean allowNull = true;
	private boolean nullLast = false;
	private String nullText = "";
	private int bottomPadding;

	private boolean callbackEnabled = true; // disables callback when programmatically setting combobox value

	private final List<Runnable> callbacks = new ArrayList<>();

	public CustomJComboBox(List<T> items, Function<T, String> displayMapper, String title)
	{
		this.displayMapper = displayMapper;
		setLayout(new BorderLayout());

		titleLabel = new JLabel();
		titleLabel.setVisible(false);
		add(titleLabel, BorderLayout.NORTH);
		setTitle(title);

		comboBox = new JComboBox<>();
		comboBox.setPrototypeDisplayValue("");
		comboBox.addActionListener(e ->
		{
			if (callbackEnabled)
			{
				invokeCallbacks();
			}
		});
		this.items = items;
		updateInternalComboBox();
		add(comboBox, BorderLayout.CENTER);

		updateSizes();
	}

	public void setTitle(String title)
	{
		if (title != null)
		{
			titleLabel.setText(title);
			titleLabel.setVisible(true);
		}
		else
		{
			titleLabel.setVisible(false);
		}
		updateSizes();
	}

	public void setItems(List<T> newItems)
	{
		if (newItems != items)
		{
			items = newItems;
			updateInternalComboBox();
		}
	}

	public void setAllowNull(boolean newValue)
	{
		if (allowNull != newValue)
		{
			allowNull = newValue;
			if (items.isEmpty())
			{
				throw new IllegalStateException("Must provide non-empty items before disabling null");
			}
			updateInternalComboBox();
		}
	}

	public void setNullLast(boolean newValue)
	{
		if (nullLast != newValue)
		{
			nullLast = newValue;
			updateInternalComboBox();
		}
	}

	public void setNullText(String newValue)
	{
		newValue = newValue == null ? "" : newValue;
		if (!newValue.equals(nullText))
		{
			nullText = newValue;
			updateInternalComboBox();
		}
	}

	private void updateInternalComboBox()
	{
		callbackEnabled = false;
		comboBox.removeAllItems();
		if (allowNull && !nullLast)
		{
			comboBox.addItem(nullText);
		}

		items.stream()
			.map(displayMapper)
			.forEach(comboBox::addItem);

		if (allowNull && nullLast)
		{
			comboBox.addItem(nullText);
		}
		callbackEnabled = true;
	}

	public T getValue()
	{
		if (!allowNull)
		{
			return items.get(comboBox.getSelectedIndex());
		}

		int nullIx = nullLast ? items.size() : 0;
		if (comboBox.getSelectedIndex() == nullIx)
		{
			return null;
		}

		int nullOffset = nullLast ? 0 : 1;
		return items.get(comboBox.getSelectedIndex() - nullOffset);
	}

	public void setValue(T newValue)
	{
		callbackEnabled = false;
		if (!isValidValue(newValue))
		{
			callbackEnabled = true;
			throw new IllegalArgumentException(newValue + " does not exist in items");
		}

		if (newValue == null)
		{
			int nullIx = nullLast ? items.size() : 0;
			comboBox.setSelectedIndex(nullIx);
		}
		else
		{
			int nullOffset = (allowNull && !nullLast) ? 1 : 0;
			comboBox.setSelectedIndex(items.indexOf(newValue) + nullOffset);
		}
		callbackEnabled = true;
	}

	public boolean isValidValue(T newValue)
	{
		if (newValue == null)
		{
			return allowNull;
		}

		return items.contains(newValue);
	}

	public void addBottomPadding(int height)
	{
		bottomPadding = height;
		add(Box.createVerticalStrut(height), BorderLayout.SOUTH);
		updateSizes();
	}

	private void updateSizes()
	{
		int height = bottomPadding + (titleLabel.isVisible() ? HEIGHT_WITH_TITLE : HEIGHT_WITHOUT_TITLE);
		setMinimumSize(new Dimension(0, height));
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, height));
	}

	public void addCallback(Runnable r)
	{
		callbacks.add(r);
	}

	protected void invokeCallbacks()
	{
		callbacks.forEach(Runnable::run);
	}

	public void enableAutocomplete()
	{
		AutoCompletion.enable(comboBox);
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.util.function.Consumer;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class FocusLostAdapter extends FocusAdapter
{

	private final Consumer<FocusEvent> handler;

	@Override
	public final void focusLost(FocusEvent e)
	{
		handler.accept(e);
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import java.awt.CardLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;

public class ResizingCardLayout extends CardLayout
{

	@Override
	public Dimension preferredLayoutSize(Container parent)
	{
		Component current = getCurrentComponent(parent);
		if (current == null)
		{
			return super.preferredLayoutSize(parent);
		}

		Insets insets = parent.getInsets();
		Dimension size = new Dimension(current.getPreferredSize());
		size.width += insets.left + insets.right;
		size.height += insets.top + insets.bottom;
		return size;
	}

	private Component getCurrentComponent(Container parent)
	{
		for (Component child : parent.getComponents())
		{
			if (child.isVisible())
			{
				return child;
			}
		}
		return null;
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import javax.swing.JTextField;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class SelectAllFocusListener implements FocusListener
{

	private final JTextField parentTextField;

	@Override
	public void focusGained(FocusEvent e)
	{
		parentTextField.select(0, parentTextField.getText().length());
	}

	@Override
	public void focusLost(FocusEvent e)
	{
		parentTextField.select(0, 0);
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.util;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JPanel;

public class LoadFromClientButton extends JPanel
{

	public LoadFromClientButton(Runnable callback)
	{
		this("Load From Client", callback);
	}

	public LoadFromClientButton(String text, Runnable callback)
	{
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		JButton loadFromClientButton = new JButton(text);
		loadFromClientButton.addActionListener(e -> callback.run());
		loadFromClientButton.setAlignmentX(CENTER_ALIGNMENT);
		add(loadFromClientButton);

		add(Box.createVerticalStrut(10));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui;

import com.duckblade.osrs.dpscalc.plugin.ui.equip.EquipmentPanel;
import com.duckblade.osrs.dpscalc.plugin.ui.npc.NpcStatsPanel;
import com.duckblade.osrs.dpscalc.plugin.ui.prayer.PrayerPanel;
import com.duckblade.osrs.dpscalc.plugin.ui.result.CalcResultPanel;
import com.duckblade.osrs.dpscalc.plugin.ui.skills.SkillsPanel;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.LoadFromClientButton;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class DpsCalcPanel extends JPanel
{

	private final JPanel menuPanel;

	private final MenuPanelNavEntry npcStatsNav;
	private final NpcStatsPanel npcStatsPanel;

	private final MenuPanelNavEntry equipmentNav;
	private final EquipmentPanel equipmentPanel;

	private final MenuPanelNavEntry skillsNav;
	private final SkillsPanel skillsPanel;

	private final MenuPanelNavEntry prayerNav;
	private final PrayerPanel prayerPanel;

	private final CalcResultPanel resultPanel;

	@Inject
	public DpsCalcPanel(NpcStatsPanel npcStatsPanel, EquipmentPanel equipmentPanel, SkillsPanel skillsPanel, PrayerPanel prayerPanel, CalcResultPanel resultPanel)
	{
		this.npcStatsPanel = npcStatsPanel;
		this.equipmentPanel = equipmentPanel;
		this.skillsPanel = skillsPanel;
		this.prayerPanel = prayerPanel;
		this.resultPanel = resultPanel;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));
		setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

		menuPanel = new JPanel();
		menuPanel.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));
		menuPanel.setLayout(new BoxLayout(menuPanel, BoxLayout.Y_AXIS));
		add(menuPanel);

		menuPanel.add(new LoadFromClientButton("Load All From Client", this::loadAllFromClient));

		npcStatsNav = new MenuPanelNavEntry("NPC Stats", "Not Set", () -> openPanel(npcStatsPanel));
		menuPanel.add(npcStatsNav);
		menuPanel.add(Box.createVerticalStrut(5));

		equipmentNav = new MenuPanelNavEntry("Equipment", "Not Set", () -> openPanel(equipmentPanel));
		menuPanel.add(equipmentNav);
		menuPanel.add(Box.createVerticalStrut(5));

		skillsNav = new MenuPanelNavEntry("Skills", "Not Set", () -> openPanel(skillsPanel));
		menuPanel.add(skillsNav);
		menuPanel.add(Box.createVerticalStrut(5));

		prayerNav = new MenuPanelNavEntry("Prayer", "None", () -> openPanel(prayerPanel));
		menuPanel.add(prayerNav);
		menuPanel.add(Box.createVerticalStrut(20));

		menuPanel.add(resultPanel);
	}

	private void updateResultPanel()
	{
		SwingUtilities.invokeLater(() ->
		{
			resultPanel.clear();
			if (npcStatsPanel.isReady() && equipmentPanel.isReady() && skillsPanel.isReady())
			{
				resultPanel.fromState();
			}
		});
	}

	public void openMenu()
	{
		SwingUtilities.invokeLater(() ->
		{
			removeAll();
			add(menuPanel, BorderLayout.CENTER);

			npcStatsPanel.fromState();
			npcStatsNav.setDescription(npcStatsPanel.getSummary());

			equipmentPanel.fromState();
			equipmentNav.setDescription(equipmentPanel.getSummary());

			skillsPanel.fromState();
			skillsNav.setDescription(skillsPanel.getSummary());

			prayerPanel.fromState();
			prayerNav.setDescription(prayerPanel.getSummary());

			updateResultPanel();
			revalidate();
			repaint();
		});
	}

	public void openPanel(Component c)
	{
		SwingUtilities.invokeLater(() ->
		{
			if (c instanceof StateBoundComponent)
			{
				((StateBoundComponent) c).fromState();
			}

			removeAll();
			add(c, BorderLayout.CENTER);
			revalidate();
			repaint();
		});
	}

	public void openNpcPanel()
	{
		openPanel(npcStatsPanel);
	}

	public void loadAllFromClient()
	{
		npcStatsPanel.loadFromClient();
		equipmentPanel.loadFromClient();
		skillsPanel.loadFromClient();
		prayerPanel.loadFromClient();
		openMenu();
	}

}
package com.duckblade.osrs.dpscalc.plugin.ui.prayer;

import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JPanel;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

public class PrayerButton extends JPanel implements StateBoundComponent
{

	private static final Image SELECTED_BACKGROUND = ImageUtil.loadImageResource(PrayerButton.class, "activated_background.png");
	private static final int WIDTH = 34;
	private static final int HEIGHT = 34;

	private static BufferedImage createSelectedGraphic(Image prayerIcon)
	{
		// create selectedIcon from SELECTED_BACKGROUND + deselectedIcon
		BufferedImage selectedIcon = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_4BYTE_ABGR);
		Graphics g = selectedIcon.getGraphics();
		g.drawImage(SELECTED_BACKGROUND, 0, 0, null);
		g.drawImage(prayerIcon, 0, 0, null);
		g.dispose();

		return selectedIcon;
	}

	@Getter
	private final Prayer prayer;

	@Getter
	private final PanelStateManager manager;

	private final ImageIcon selectedIcon;
	private final ImageIcon deselectedIcon;

	private final JButton button;
	private boolean selected;

	private final List<Runnable> callbacks = new ArrayList<>();

	public PrayerButton(PanelStateManager manager, Prayer prayer)
	{
		this.manager = manager;
		this.prayer = prayer;
		callbacks.add(this::toState);

		String iconFileName = prayer.name().toLowerCase() + ".png";
		BufferedImage deselected = ImageUtil.loadImageResource(getClass(), iconFileName);
		this.deselectedIcon = new ImageIcon(deselected);
		this.selectedIcon = new ImageIcon(createSelectedGraphic(deselected));

		button = new JButton(deselectedIcon);
		SwingUtil.removeButtonDecorations(button);
		button.setMinimumSize(new Dimension(WIDTH, HEIGHT));
		button.setPreferredSize(new Dimension(WIDTH, HEIGHT));
		button.setMaximumSize(new Dimension(WIDTH, HEIGHT));
		button.addActionListener(e ->
		{
			setSelected(!selected);
			callbacks.forEach(Runnable::run);
		});
		add(button);
	}

	private void setSelected(boolean newValue)
	{
		selected = newValue;
		button.setIcon(selected ? selectedIcon : deselectedIcon);
	}

	@Override
	public void toState()
	{
		if (selected)
		{
			getState().getAttackerPrayers().add(prayer);
		}
		else
		{
			getState().getAttackerPrayers().remove(prayer);
		}
	}

	@Override
	public void fromState()
	{
		setSelected(getState().getAttackerPrayers().contains(prayer));
	}

	public void addCallback(Runnable r)
	{
		callbacks.add(r);
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.prayer;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.prayer.PrayerDrainComputable;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProviderThreadProxy;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import com.duckblade.osrs.dpscalc.plugin.ui.util.LoadFromClientButton;
import com.google.common.collect.ImmutableList;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import lombok.Getter;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class PrayerPanel extends JPanel implements StateBoundComponent
{

	@Getter
	private final PanelStateManager manager;
	private final ClientDataProviderThreadProxy clientDataProviderThreadProxy;
	private final PrayerDrainComputable prayerDrainComputable;

	private final JLabel drainLabel;
	private final List<PrayerButton> prayerButtons;

	@Inject
	public PrayerPanel(PanelStateManager manager, ClientDataProviderThreadProxy clientDataProviderThreadProxy, PrayerDrainComputable prayerDrainComputable)
	{
		this.manager = manager;
		this.clientDataProviderThreadProxy = clientDataProviderThreadProxy;
		this.prayerDrainComputable = prayerDrainComputable;

		add(new LoadFromClientButton(this::loadFromClient));

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));

		drainLabel = new JLabel("Total Drain: 0");
		drainLabel.setAlignmentX(CENTER_ALIGNMENT);
		add(drainLabel);

		JPanel prayerGrid = new JPanel(new GridLayout(6, 5, 1, 1));
		prayerGrid.setMinimumSize(new Dimension(182, 219));
		prayerGrid.setPreferredSize(new Dimension(182, 219));
		prayerGrid.setMaximumSize(new Dimension(182, 219));
		add(prayerGrid);

		ImmutableList.Builder<PrayerButton> builder = ImmutableList.builder();
		for (Prayer prayer : Prayer.values())
		{
			PrayerButton panel = new PrayerButton(manager, prayer);
			panel.addCallback(this::calculateDrain);
			prayerGrid.add(panel);
			builder.add(panel);
		}
		prayerButtons = builder.build();
	}

	public void loadFromClient()
	{
		clientDataProviderThreadProxy.tryAcquire(clientDataProvider ->
		{
			getState().setAttackerPrayers(new HashSet<>(clientDataProvider.getPlayerActivePrayers()));
			SwingUtilities.invokeLater(this::fromState);
		});
	}

	@Override
	public void fromState()
	{
		prayerButtons.forEach(PrayerButton::fromState);
		calculateDrain();
	}

	private void calculateDrain()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.ATTACKER_PRAYERS, getState().getAttackerPrayers());

			int drain = ctx.get(prayerDrainComputable);
			drainLabel.setText("Total Drain: " + drain);
		});
	}

	public String getSummary()
	{
		Set<Prayer> enabled = getState().getAttackerPrayers();
		if (enabled.isEmpty())
		{
			return "None";
		}

		if (enabled.size() == 1)
		{
			return enabled.stream()
				.max(Comparator.comparing(Prayer::getDrainRate))
				.get()
				.getDisplayName();
		}
		else
		{
			return enabled.size() + " Selected";
		}
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.skills;

import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProviderThreadProxy;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundStatBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.CustomJComboBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.LoadFromClientButton;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.function.ObjIntConsumer;
import java.util.function.ToIntFunction;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import lombok.Getter;
import net.runelite.api.Skill;
import static net.runelite.api.Skill.ATTACK;
import static net.runelite.api.Skill.DEFENCE;
import static net.runelite.api.Skill.MAGIC;
import static net.runelite.api.Skill.PRAYER;
import static net.runelite.api.Skill.RANGED;
import static net.runelite.api.Skill.STRENGTH;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class SkillsPanel extends JPanel implements StateBoundComponent
{

	private static ObjIntConsumer<PanelState> writer(Function<PanelState, Map<Skill, Integer>> mapSelector, Skill skill)
	{
		return (state, lvl) -> mapSelector.apply(state).put(skill, lvl);
	}

	private static ToIntFunction<PanelState> reader(Function<PanelState, Map<Skill, Integer>> mapSelector, Skill skill)
	{
		return state -> mapSelector.apply(state).getOrDefault(skill, 0);
	}

	@Getter
	private final PanelStateManager manager;
	private final ClientDataProviderThreadProxy clientDataProviderThreadProxy;
	private final List<StateBoundStatBox> statBoxes;
	private final List<StateBoundStatBox> boostBoxes;

	@Inject
	public SkillsPanel(PanelStateManager manager, ClientDataProviderThreadProxy clientDataProviderThreadProxy)
	{
		this.manager = manager;
		this.clientDataProviderThreadProxy = clientDataProviderThreadProxy;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		add(new LoadFromClientButton(this::loadFromClient));

		statBoxes = Arrays.asList(
			new StateBoundStatBox(manager, "att", "Attack", true, writer(PanelState::getAttackerSkills, ATTACK), reader(PanelState::getAttackerSkills, ATTACK)),
			new StateBoundStatBox(manager, "str", "Strength", true, writer(PanelState::getAttackerSkills, STRENGTH), reader(PanelState::getAttackerSkills, STRENGTH)),
			new StateBoundStatBox(manager, "def", "Defence", true, writer(PanelState::getAttackerSkills, DEFENCE), reader(PanelState::getAttackerSkills, DEFENCE)),
			new StateBoundStatBox(manager, "mage", "Magic", true, writer(PanelState::getAttackerSkills, MAGIC), reader(PanelState::getAttackerSkills, MAGIC)),
			new StateBoundStatBox(manager, "range", "Ranged", true, writer(PanelState::getAttackerSkills, RANGED), reader(PanelState::getAttackerSkills, RANGED)),
			new StateBoundStatBox(manager, "prayer", "Prayer", true, writer(PanelState::getAttackerSkills, PRAYER), reader(PanelState::getAttackerSkills, PRAYER))
		);
		add(new StatCategory("Player Stats", statBoxes));

		add(Box.createVerticalStrut(10));

		boostBoxes = Arrays.asList(
			new StateBoundStatBox(manager, "att", "Attack", true, writer(PanelState::getAttackerBoosts, ATTACK), reader(PanelState::getAttackerBoosts, ATTACK)),
			new StateBoundStatBox(manager, "str", "Strength", true, writer(PanelState::getAttackerBoosts, STRENGTH), reader(PanelState::getAttackerBoosts, STRENGTH)),
			new StateBoundStatBox(manager, "def", "Defence", true, writer(PanelState::getAttackerBoosts, DEFENCE), reader(PanelState::getAttackerBoosts, DEFENCE)),
			new StateBoundStatBox(manager, "mage", "Magic", true, writer(PanelState::getAttackerBoosts, MAGIC), reader(PanelState::getAttackerBoosts, MAGIC)),
			new StateBoundStatBox(manager, "range", "Ranged", true, writer(PanelState::getAttackerBoosts, RANGED), reader(PanelState::getAttackerBoosts, RANGED)),
			new StateBoundStatBox(manager, "prayer", "Prayer", true, writer(PanelState::getAttackerBoosts, PRAYER), reader(PanelState::getAttackerBoosts, PRAYER))
		);
		add(new StatCategory("Boosts", boostBoxes));

		add(Box.createVerticalStrut(10));

		JPanel commonBoostsPanel = new JPanel();
		commonBoostsPanel.setMaximumSize(new Dimension(200, 40));
		commonBoostsPanel.setLayout(new GridLayout(1, 3));
		commonBoostsPanel.add(new SkillBoostPresetButton(this, SkillBoostPreset.SUPER_COMBAT_POTION, "boost_super_combat_potion.png"));
		commonBoostsPanel.add(new SkillBoostPresetButton(this, SkillBoostPreset.RANGING_POTION, "boost_ranging_potion.png"));
		commonBoostsPanel.add(new SkillBoostPresetButton(this, SkillBoostPreset.IMBUED_HEART, "boost_imbued_heart.png"));
		add(commonBoostsPanel);

		add(Box.createVerticalStrut(10));

		List<SkillBoostPreset> presets = Arrays.asList(SkillBoostPreset.values());
		presets.sort(Comparator.comparing(SkillBoostPreset::getDisplayName));
		CustomJComboBox<SkillBoostPreset> presetSelect = new CustomJComboBox<>(presets, SkillBoostPreset::getDisplayName, null);
		add(presetSelect);

		JButton applyPresetButton = new JButton("Apply");
		applyPresetButton.setAlignmentX(Component.CENTER_ALIGNMENT);
		applyPresetButton.setMinimumSize(new Dimension(0, 35));
		applyPresetButton.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 30));
		applyPresetButton.addActionListener(e ->
		{
			SkillBoostPreset preset = presetSelect.getValue();
			applyBoostPreset(preset);
		});
		add(applyPresetButton);
	}

	public void loadFromClient()
	{
		clientDataProviderThreadProxy.tryAcquire(clientDataProvider ->
		{
			Skills playerSkills = clientDataProvider.getPlayerSkills();
			for (Skill s : new Skill[]{ATTACK, STRENGTH, DEFENCE, MAGIC, RANGED, PRAYER})
			{
				getState().getAttackerSkills().put(s, playerSkills.getLevels().getOrDefault(s, 0));
				getState().getAttackerBoosts().put(s, playerSkills.getBoosts().getOrDefault(s, 0));
			}
			SwingUtilities.invokeLater(this::fromState);
		});
	}

	@Override
	public void toState()
	{
		statBoxes.forEach(StateBoundStatBox::toState);
		boostBoxes.forEach(StateBoundStatBox::toState);
	}

	@Override
	public void fromState()
	{
		statBoxes.forEach(StateBoundStatBox::fromState);
		boostBoxes.forEach(StateBoundStatBox::fromState);
	}

	public boolean isReady()
	{
		return getState().getAttackerSkills()
			.values()
			.stream()
			.anyMatch(i -> i != 0);
	}

	public String getSummary()
	{
		if (isReady())
		{
			return "Set";
		}

		return "Not Set";
	}

	public void applyBoostPreset(SkillBoostPreset boostPreset)
	{
		if (boostPreset != null)
		{
			boostPreset.apply(getState());
			boostBoxes.forEach(StateBoundStatBox::fromState);
		}
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.skills;

import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import java.util.Map;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Skill;

@RequiredArgsConstructor
public enum SkillBoostPreset
{
	ATTACK_POTION("Attack potion", Skill.ATTACK, 0.10f, 3),
	STRENGTH_POTION("Strength potion", Skill.STRENGTH, 0.10f, 3),
	DEFENSE_POTION("Defence potion", Skill.DEFENCE, 0.10f, 3),
	COMBAT_POTION("Combat potion", ATTACK_POTION, STRENGTH_POTION, DEFENSE_POTION),

	SUPER_ATTACK_POTION("Super attack potion", Skill.ATTACK, 0.15f, 5),
	SUPER_STRENGTH_POTION("Super strength potion", Skill.STRENGTH, 0.15f, 5),
	SUPER_DEFENSE_POTION("Super defence potion", Skill.DEFENCE, 0.15f, 5),
	SUPER_COMBAT_POTION("Super combat potion", SUPER_ATTACK_POTION, SUPER_STRENGTH_POTION, SUPER_DEFENSE_POTION),

	RANGING_POTION("Ranging potion", Skill.RANGED, 0.10f, 4),
	SUPER_RANGING_POTION("Super ranging potion (NMZ)", Skill.RANGED, 0.15f, 5),
	BASTION_POTION("Bastion potion", SUPER_DEFENSE_POTION, RANGING_POTION),

	ANCIENT_BREW("Ancient brew", Skill.MAGIC, 0.05f, 2),
	MAGIC_POTION("Magic potion", Skill.MAGIC, 0f, 4),
	SUPER_MAGIC_POTION("Super magic potion (NMZ)", Skill.MAGIC, 0.15f, 5),
	BATTLEMAGE_POTION("Battlemage potion", MAGIC_POTION, SUPER_DEFENSE_POTION),

	IMBUED_HEART("Imbued Heart", Skill.MAGIC, 0.10f, 1),

	COX_OVERLOAD_MINUS("Overload (-)",
		new Skill[]{Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE, Skill.RANGED, Skill.MAGIC},
		new float[]{0.10f, 0.10f, 0.10f, 0.10f, 0.10f},
		new int[]{4, 4, 4, 4, 4}
	),
	COX_OVERLOAD("Overload",
		new Skill[]{Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE, Skill.RANGED, Skill.MAGIC},
		new float[]{0.13f, 0.13f, 0.13f, 0.13f, 0.13f},
		new int[]{5, 5, 5, 5, 5}
	),
	COX_OVERLOAD_PLUS("Overload (+)",
		new Skill[]{Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE, Skill.RANGED, Skill.MAGIC},
		new float[]{0.16f, 0.16f, 0.16f, 0.16f, 0.16f},
		new int[]{6, 6, 6, 6, 6}
	),
	NMZ_OVERLOAD("Overload (NMZ)",
		new Skill[]{Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE, Skill.RANGED, Skill.MAGIC},
		new float[]{0.15f, 0.15f, 0.15f, 0.15f, 0.15f},
		new int[]{5, 5, 5, 5, 5}
	),

	SARADOMIN_BREW("Saradomin brew",
		new Skill[]{Skill.DEFENCE, Skill.ATTACK, Skill.STRENGTH, Skill.RANGED, Skill.MAGIC},
		new float[]{0.20f, -0.10f, -0.10f, -0.10f, -0.10f},
		new int[]{2, -2, -2, -2, -2}
	),
	ZAMORAK_BREW("Zamorak brew",
		new Skill[]{Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE},
		new float[]{0.20f, 0.12f, -0.10f},
		new int[]{2, 2, -2}
	),

	D_BAXE_SPEC("Dragon battleaxe spec", state ->
	{
		Map<Skill, Integer> totals = Skills.builder()
			.levels(state.getAttackerSkills())
			.boosts(state.getAttackerBoosts())
			.build()
			.getTotals();

		int attDrain = (int) (totals.get(Skill.ATTACK) * 0.10f);
		state.getAttackerBoosts().put(Skill.ATTACK, -attDrain);

		int defDrain = (int) (totals.get(Skill.DEFENCE) * 0.10f);
		state.getAttackerBoosts().put(Skill.DEFENCE, -defDrain);

		int rngDrain = (int) (totals.get(Skill.RANGED) * 0.10f);
		state.getAttackerBoosts().put(Skill.RANGED, -rngDrain);

		int magDrain = (int) (totals.get(Skill.MAGIC) * 0.10f);
		state.getAttackerBoosts().put(Skill.MAGIC, -magDrain);

		int strBoost = 10 + (attDrain + defDrain + rngDrain + magDrain) / 4;
		state.getAttackerBoosts().put(Skill.STRENGTH, strBoost);
	}),
	;

	@Getter
	private final String displayName;
	private final Consumer<PanelState> mapFunction;

	// lvl * factor + base
	SkillBoostPreset(String displayName, Skill skill, float percent, int base)
	{
		this(displayName, new Skill[] {skill}, new float[] {percent}, new int[] {base});
	}

	// lvl * factor + base for multiple skills
	SkillBoostPreset(String displayName, Skill[] skills, float[] percents, int[] bases)
	{
		this(displayName, state ->
		{
			for (int i = 0; i < skills.length; i++)
			{
				int lvl = state.getAttackerSkills().getOrDefault(skills[i], 0);
				int targetBoost = (int) (lvl * percents[i]) + bases[i];
				state.getAttackerBoosts().put(skills[i], targetBoost);
			}
		});
	}

	// compositional
	SkillBoostPreset(String displayName, SkillBoostPreset... compositions)
	{
		this(displayName, state ->
		{
			for (SkillBoostPreset p : compositions)
			{
				p.apply(state);
			}
		});
	}

	public void apply(PanelState state)
	{
		mapFunction.accept(state);
	}

}
package com.duckblade.osrs.dpscalc.plugin.ui.skills;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;
import java.util.List;

public class StatCategory extends JPanel
{

	private static JPanel buildSubPanel(List<? extends StatBox> elements)
	{
		JPanel subPanel = new JPanel();
		subPanel.setLayout(new BoxLayout(subPanel, BoxLayout.X_AXIS));
		elements.forEach(subPanel::add);
		return subPanel;
	}

	public StatCategory(String title, List<? extends StatBox> innerStats)
	{
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBorder(BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR, 5));

		int rows = (int) Math.ceil(innerStats.size() / 3.0);
		setPreferredSize(new Dimension(200, 24 + 70 * rows));
		setMaximumSize(new Dimension(200, 24 + 70 * rows));

		JLabel titleLabel = new JLabel(title);
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		add(titleLabel);

		for (int i = 0; i < innerStats.size(); i += 3)
		{
			List<? extends StatBox> rowStats = innerStats.subList(i, Math.min(i + 3, innerStats.size()));
			JPanel rowPanel = buildSubPanel(rowStats);
			if (i + 3 < innerStats.size())
			{
				rowPanel.setBorder(BorderFactory.createEmptyBorder(3, 0, 3, 0));
			}
			add(rowPanel);
		}
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.skills;

import com.duckblade.osrs.dpscalc.plugin.ui.util.FocusLostAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.JTextFieldIntOnlyKeyAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.SelectAllFocusListener;
import java.awt.Component;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import net.runelite.client.util.ImageUtil;

public class StatBox extends JPanel
{

	private final JTextField valueField;
	private final List<Runnable> callbacks = new ArrayList<>();

	public StatBox(String iconName, String title, boolean editable)
	{

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		BufferedImage icon;
		try
		{
			icon = ImageUtil.loadImageResource(StatBox.class, "icon_" + iconName + ".png");
			icon = ImageUtil.resizeCanvas(icon, 25, 25);
		}
		catch (IllegalArgumentException e)
		{
			icon = new BufferedImage(25, 25, BufferedImage.TYPE_INT_ARGB);
		}
		JLabel iconLabel = new JLabel(new ImageIcon(icon));
		iconLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		add(iconLabel);

		JLabel titleLabel = new JLabel(title);
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		add(titleLabel);

		valueField = new JTextField("0", 3);
		valueField.setAlignmentX(Component.CENTER_ALIGNMENT); // of component
		valueField.setHorizontalAlignment(JTextField.CENTER); // of inner text
		valueField.addFocusListener(new SelectAllFocusListener(valueField));
		valueField.addKeyListener(new JTextFieldIntOnlyKeyAdapter());
		valueField.setEditable(editable);
		valueField.addFocusListener(new FocusLostAdapter(e -> callbacks.forEach(Runnable::run)));

		add(valueField);
	}

	public void setValue(int value)
	{
		SwingUtilities.invokeLater(() -> valueField.setText(Integer.toString(value)));
	}

	public int getValue()
	{
		if (valueField.getText().isEmpty())
		{
			return 0;
		}
		return Integer.parseInt(valueField.getText());
	}

	public void setEditable(boolean editable)
	{
		valueField.setEditable(editable);
	}

	public void addCallback(Runnable r)
	{
		callbacks.add(r);
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.skills;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import net.runelite.client.util.ImageUtil;

public class SkillBoostPresetButton extends JButton
{

	public SkillBoostPresetButton(SkillsPanel skillsPanel, SkillBoostPreset boostPreset, String iconPath)
	{
		super(new ImageIcon(ImageUtil.loadImageResource(SkillBoostPresetButton.class, iconPath)));
		setToolTipText(boostPreset.getDisplayName());
		addActionListener(ignored -> skillsPanel.applyBoostPreset(boostPreset));
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.result;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.exceptions.DpsComputeException;
import com.duckblade.osrs.dpscalc.calc.exceptions.MissingInputException;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.util.function.Function;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

public class CalcResultLabel extends JPanel
{

	private final Function<ComputeContext, String> getter;
	private final JLabel valueLabel;

	public CalcResultLabel(String title, Function<ComputeContext, String> getter)
	{
		this.getter = getter;

		setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 12, 20));
		setVisible(false);

		JLabel titleLabel = new JLabel(title);
		titleLabel.setFont(FontManager.getRunescapeBoldFont());
		titleLabel.setForeground(Color.white);
		add(titleLabel);

		Component glue = Box.createHorizontalGlue();
		glue.setBackground(Color.pink);
		add(glue);

		valueLabel = new JLabel(title);
		valueLabel.setFont(FontManager.getRunescapeBoldFont());
		valueLabel.setForeground(Color.white);
		add(valueLabel);
	}

	public void setValue(ComputeContext context)
	{
		if (context == null)
		{
			setDisplay(null);
			return;
		}

		try
		{
			setDisplay(getter.apply(context));
		}
		catch (DpsComputeException e)
		{
			setDisplay(null);

			if (!(e.getCause() instanceof MissingInputException))
			{
				throw e;
			}
		}
	}

	private void setDisplay(String newValue)
	{
		valueLabel.setText(newValue);
		setVisible(newValue != null);
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.result;

import com.duckblade.osrs.dpscalc.calc.AttackSpeedComputable;
import com.duckblade.osrs.dpscalc.calc.defender.DefenseRollComputable;
import com.duckblade.osrs.dpscalc.calc.DpsComputable;
import com.duckblade.osrs.dpscalc.calc.HitChanceComputable;
import com.duckblade.osrs.dpscalc.calc.TimeToKillComputable;
import com.duckblade.osrs.dpscalc.calc.attack.AttackRollComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.exceptions.DpsComputeException;
import com.duckblade.osrs.dpscalc.calc.exceptions.MissingInputException;
import com.duckblade.osrs.dpscalc.calc.maxhit.BaseMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.maxhit.TrueMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.prayer.PrayerDurationRemainingComputable;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.text.DecimalFormat;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import org.apache.commons.lang3.time.DurationFormatUtils;

@Singleton
@Slf4j
public class CalcResultPanel extends JPanel implements StateBoundComponent
{

	private static final DecimalFormat DPS_FORMAT = new DecimalFormat("'DPS:' #.###");
	private static final DecimalFormat ROLL_FORMAT = new DecimalFormat("#,###");
	private static final DecimalFormat HIT_CHANCE_FORMAT = new DecimalFormat("#.#%");
	private static final DecimalFormat HIT_RATE_FORMAT = new DecimalFormat("#.# 'secs'");

	private static String timeFormat(Duration duration)
	{
		if (duration == null)
		{
			return "Infinity";
		}
		return DurationFormatUtils.formatDuration(duration.toMillis(), "mm:ss", true);
	}

	@Getter
	private final PanelStateManager manager;
	private final DpsComputable dpsComputable;

	private final JLabel dpsValue;
	private static final String DPS_CALC_FAIL = "DPS: ???";

	private final List<CalcResultLabel> resultLabels;
	private final JTextArea warningsLabel;

	@Inject
	public CalcResultPanel(
		PanelStateManager manager,
		DpsComputable dpsComputable,
		AttackRollComputable attackRollComputable,
		DefenseRollComputable defenseRollComputable,
		BaseMaxHitComputable baseMaxHitComputable,
		TrueMaxHitComputable trueMaxHitComputable,
		HitChanceComputable hitChanceComputable,
		AttackSpeedComputable attackSpeedComputable,
		TimeToKillComputable timeToKillComputable,
		PrayerDurationRemainingComputable prayerDurationRemainingComputable
	)
	{
		this.manager = manager;
		this.dpsComputable = dpsComputable;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

		Font originalBold = FontManager.getRunescapeBoldFont();
		Font dpsFont = originalBold.deriveFont(originalBold.getSize() * 2f);

		dpsValue = new JLabel(DPS_CALC_FAIL, JLabel.CENTER);
		dpsValue.setAlignmentX(CENTER_ALIGNMENT);
		dpsValue.setForeground(Color.white);
		dpsValue.setFont(dpsFont);
		add(dpsValue);

		add(Box.createVerticalStrut(5));

		resultLabels = Arrays.asList(
			new CalcResultLabel("Max Attack Roll:", ctx -> ROLL_FORMAT.format(ctx.get(attackRollComputable))),
			new CalcResultLabel("NPC Defense Roll:", ctx -> ROLL_FORMAT.format(ctx.get(defenseRollComputable))),
			new CalcResultLabel("Hit Chance:", ctx -> HIT_CHANCE_FORMAT.format(ctx.get(hitChanceComputable))),

			new CalcResultLabel("Max Hit:", ctx -> String.valueOf(ctx.get(trueMaxHitComputable))),
			new CalcResultLabel("Base Max Hit:", ctx ->
			{
				int baseMaxHit = ctx.get(baseMaxHitComputable);
				if (baseMaxHit < ctx.get(trueMaxHitComputable))
				{
					return String.valueOf(baseMaxHit);
				}
				return null;
			}),

			new CalcResultLabel("Attack Every:", ctx -> HIT_RATE_FORMAT.format(ctx.get(attackSpeedComputable) / 0.6)),
			new CalcResultLabel("Avg TTK:", ctx -> timeFormat(ctx.get(timeToKillComputable))),
			new CalcResultLabel("Prayer Lasts:", ctx -> timeFormat(ctx.get(prayerDurationRemainingComputable)))
		);

		resultLabels.subList(0, 3).forEach(this::add);
		add(Box.createVerticalStrut(10));

		resultLabels.subList(3, 5).forEach(this::add);
		add(Box.createVerticalStrut(10));

		resultLabels.subList(6, 8).forEach(this::add);
		add(Box.createVerticalStrut(20));

		warningsLabel = new JTextArea();
		warningsLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(Font.ITALIC));
		warningsLabel.setLineWrap(true);
		warningsLabel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 2000));
		warningsLabel.setVisible(false);
		warningsLabel.setFocusable(false);
		warningsLabel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		add(warningsLabel);
	}

	@Override
	public void fromState()
	{
		try
		{
			ComputeContext ctx = new ComputeContext(getState().toComputeInput());
			double dps = ctx.get(dpsComputable);
			dpsValue.setText(DPS_FORMAT.format(dps));
			resultLabels.forEach(l -> l.setValue(ctx));

			List<String> warnings = ctx.getWarnings();
			warningsLabel.setText(String.join("\n\n", warnings));
			warningsLabel.setVisible(!warnings.isEmpty());
		}
		catch (DpsComputeException e)
		{
			log.debug("Failed compute: ", e);
			clear();

			if (!(e.getCause() instanceof MissingInputException))
			{
				throw e;
			}
		}
	}

	public void clear()
	{
		dpsValue.setText(DPS_CALC_FAIL);
		resultLabels.forEach(l -> l.setValue(null));
		warningsLabel.setVisible(false);
	}
}
package com.duckblade.osrs.dpscalc.plugin.ui;

import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.panel.DuplicateSetButton;
import com.duckblade.osrs.dpscalc.plugin.ui.state.panel.DeleteSetButton;
import com.duckblade.osrs.dpscalc.plugin.ui.state.panel.PanelInputSetSelect;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import static java.awt.GridBagConstraints.BOTH;
import static java.awt.GridBagConstraints.CENTER;
import java.awt.GridBagLayout;
import java.awt.Insets;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

@Singleton
public class DpsPluginPanel extends PluginPanel
{

	private final DpsCalcPanel calcPanel;

	private static final String GITHUB_LINK = "https://github.com/LlemonDuck/dps-calculator";

	@Inject
	public DpsPluginPanel(
		DpsCalcPanel calcPanel, PanelInputSetSelect panelInputSetSelect, DuplicateSetButton duplicateSetButton, DeleteSetButton deleteSetButton,
		PanelStateManager manager
	)
	{
		super(false);
		this.calcPanel = calcPanel;
		manager.addOnSetChangedListener(this::showHome);

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));

		JPanel headerPanel = new JPanel();
		headerPanel.setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 40));
		headerPanel.setLayout(new GridBagLayout());
		add(headerPanel);

		ImageIcon homeIcon = new ImageIcon(ImageUtil.resizeImage(ImageUtil.loadImageResource(getClass(), "icon_home.png"), 25, 25));
		JButton homeButton = new JButton(homeIcon);
		homeButton.setFocusPainted(false);
		homeButton.setPreferredSize(new Dimension(35, 35));
		homeButton.addActionListener(e -> showHome());
		headerPanel.add(homeButton, new GridBagConstraints(0, 0, 1, 1, 0, 0, CENTER, BOTH, new Insets(0, 0, 0, 0), 0, 0));

		headerPanel.add(panelInputSetSelect, new GridBagConstraints(1, 0, 1, 1, 1, 1, CENTER, BOTH, new Insets(0, 0, 0, 0), 0, 0));

		duplicateSetButton.setPreferredSize(new Dimension(25, 25));
		headerPanel.add(duplicateSetButton, new GridBagConstraints(2, 0, 1, 1, 0, 0, CENTER, BOTH, new Insets(0, 0, 0, 0), 0, 0));

		deleteSetButton.setPreferredSize(new Dimension(25, 25));
		headerPanel.add(deleteSetButton, new GridBagConstraints(3, 0, 1, 1, 0, 0, CENTER, BOTH, new Insets(0, 0, 0, 0), 0, 0));

		ImageIcon ghIcon = new ImageIcon(ImageUtil.resizeImage(ImageUtil.loadImageResource(getClass(), "gh_logo.png"), 25, 25));
		JButton linkToGh = new JButton(ghIcon);
		linkToGh.setFocusPainted(false);
		linkToGh.setPreferredSize(new Dimension(35, 35));
		linkToGh.addActionListener(e -> openGhLink());
		headerPanel.add(linkToGh, new GridBagConstraints(4, 0, 1, 1, 0, 0, CENTER, BOTH, new Insets(0, 0, 0, 0), 0, 0));

		JScrollPane contentScrollPane = new JScrollPane(calcPanel);
		contentScrollPane.setBorder(BorderFactory.createEmptyBorder());
		contentScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		contentScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);
		contentScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(0, 0));
		add(contentScrollPane);
	}

	private void openGhLink()
	{
		LinkBrowser.browse(GITHUB_LINK);
	}

	private void showHome()
	{
		SwingUtilities.invokeLater(calcPanel::openMenu);
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.state;

public interface StateBoundComponent extends HasState
{

	default void toState()
	{
	}

	void fromState();

}

package com.duckblade.osrs.dpscalc.plugin.ui.state;

import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProvider;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.RequiredArgsConstructor;
import net.runelite.client.callback.ClientThread;

@Singleton
@RequiredArgsConstructor(onConstructor = @__(@Inject))
public class ClientDataPanelSetLoader
{

	private final ClientDataProvider clientDataProvider;
	private final ClientThread clientThread;

}

package com.duckblade.osrs.dpscalc.plugin.ui.state;

import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.ComputeInput;
import com.duckblade.osrs.dpscalc.calc.model.DefenderAttributes;
import com.duckblade.osrs.dpscalc.calc.model.DefensiveBonuses;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.Prayer;
import com.duckblade.osrs.dpscalc.calc.model.Skills;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.NpcData;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Skill;

// contains all the information for one tab of the ui panel
@Data
public class PanelState
{

	@Data
	public static class MutableDefensiveBonuses
	{
		private int defenseStab = 0;
		private int defenseSlash = 0;
		private int defenseCrush = 0;
		private int defenseRanged = 0;
		private int defenseMagic = 0;

		public DefensiveBonuses toImmutable()
		{
			return DefensiveBonuses.builder()
				.defenseStab(defenseStab)
				.defenseSlash(defenseSlash)
				.defenseCrush(defenseCrush)
				.defenseRanged(defenseRanged)
				.defenseMagic(defenseMagic)
				.build();
		}

		public static MutableDefensiveBonuses fromImmutable(DefensiveBonuses immutable)
		{
			MutableDefensiveBonuses mbd = new MutableDefensiveBonuses();
			if (immutable != null)
			{
				mbd.defenseStab = immutable.getDefenseStab();
				mbd.defenseSlash = immutable.getDefenseSlash();
				mbd.defenseCrush = immutable.getDefenseCrush();
				mbd.defenseRanged = immutable.getDefenseRanged();
				mbd.defenseMagic = immutable.getDefenseMagic();
			}
			return mbd;
		}
	}

	@Data
	@NoArgsConstructor
	@AllArgsConstructor
	public static class MutableDefenderAttributes
	{
		private int npcId = -1;
		private String name = null;
		private boolean isDemon = false; // demonbane
		private boolean isDragon = false; // dhl/dhcb
		private boolean isKalphite = false; // keris
		private boolean isLeafy = false; // leaf-bladed
		private boolean isUndead = false; // salve
		private boolean isVampyre1 = false; // no immunities
		private boolean isVampyre2 = false; // requires silver weapon
		private boolean isVampyre3 = false; // requires blisterwood
		private int size = 1; // scythe
		private int accuracyMagic = 0; // tbow
		private int raidPartySize = 0;

		public DefenderAttributes toImmutable()
		{
			return DefenderAttributes.builder()
				.npcId(npcId)
				.name(name)
				.isDemon(isDemon)
				.isDragon(isDragon)
				.isKalphite(isKalphite)
				.isLeafy(isLeafy)
				.isUndead(isUndead)
				.isVampyre1(isVampyre1)
				.isVampyre2(isVampyre2)
				.isVampyre3(isVampyre3)
				.size(size)
				.accuracyMagic(accuracyMagic)
				.build();
		}

		public static MutableDefenderAttributes fromImmutable(DefenderAttributes immutable)
		{
			MutableDefenderAttributes mda = new MutableDefenderAttributes();
			if (immutable != null)
			{
				mda.npcId = immutable.getNpcId();
				mda.name = immutable.getName();
				mda.isDemon = immutable.isDemon();
				mda.isDragon = immutable.isDragon();
				mda.isKalphite = immutable.isKalphite();
				mda.isLeafy = immutable.isLeafy();
				mda.isUndead = immutable.isUndead();
				mda.isVampyre1 = immutable.isVampyre1();
				mda.isVampyre2 = immutable.isVampyre2();
				mda.isVampyre3 = immutable.isVampyre3();
				mda.size = immutable.getSize();
				mda.accuracyMagic = immutable.getAccuracyMagic();
			}
			return mda;
		}
	}

	// attacker
	private Map<Skill, Integer> attackerSkills = new HashMap<>();

	private Map<Skill, Integer> attackerBoosts = new HashMap<>();

	private Map<EquipmentInventorySlot, ItemStats> attackerItems = new HashMap<>();

	private Set<Prayer> attackerPrayers = new HashSet<>();

	private AttackStyle attackStyle = null;

	private Spell spell = null;

	private ItemStats blowpipeDarts = null;

	private int attackerDistance = 1;

	// defender
	private Map<Skill, Integer> defenderSkills = new HashMap<>();

	private MutableDefensiveBonuses defenderBonuses = new MutableDefensiveBonuses();

	private MutableDefenderAttributes defenderAttributes = new MutableDefenderAttributes();

	// extras
	private boolean onSlayerTask = false;

	private boolean usingChargeSpell = false;

	private boolean usingMarkOfDarkness = false;

	private boolean inWilderness = false;

	private int raidPartySize = 1;

	public void loadNpcData(NpcData npc)
	{
		if (npc == null)
		{
			defenderSkills = new HashMap<>();
			defenderBonuses = new MutableDefensiveBonuses();
			defenderAttributes = new MutableDefenderAttributes();
		}
		else
		{
			defenderSkills = npc.getSkills() == null ? new HashMap<>() : new HashMap<>(npc.getSkills().getTotals());
			defenderBonuses = MutableDefensiveBonuses.fromImmutable(npc.getDefensiveBonuses());
			defenderAttributes = MutableDefenderAttributes.fromImmutable(npc.getAttributes());
		}
	}

	public ComputeInput toComputeInput()
	{
		return ComputeInput.builder()
			.attackerSkills(Skills.builder()
				.levels(new HashMap<>(attackerSkills))
				.boosts(new HashMap<>(attackerBoosts))
				.build())
			.attackerItems(new HashMap<>(attackerItems))
			.attackerPrayers(new HashSet<>(attackerPrayers))
			.attackStyle(attackStyle.toBuilder().build())
			.spell(spell)
			.blowpipeDarts(blowpipeDarts)
			.attackerDistance(attackerDistance)
			.defenderSkills(Skills.builder()
				.levels(new HashMap<>(defenderSkills))
				.build())
			.defenderBonuses(defenderBonuses.toImmutable())
			.defenderAttributes(defenderAttributes.toImmutable())
			.onSlayerTask(onSlayerTask)
			.usingChargeSpell(usingChargeSpell)
			.usingMarkOfDarkness(usingMarkOfDarkness)
			.inWilderness(inWilderness)
			.raidPartySize(raidPartySize)
			.build();
	}

	public PanelState()
	{
	}

	public PanelState(PanelState original)
	{
		this.attackerBoosts.putAll(original.attackerBoosts);
		this.attackerDistance = original.attackerDistance;
		this.attackerItems.putAll(original.attackerItems);
		this.attackerPrayers.addAll(original.attackerPrayers);
		this.attackerSkills.putAll(original.attackerSkills);
		this.attackStyle = original.attackStyle;
		this.blowpipeDarts = original.blowpipeDarts;
		this.defenderAttributes = MutableDefenderAttributes.fromImmutable(original.defenderAttributes.toImmutable());
		this.defenderBonuses = MutableDefensiveBonuses.fromImmutable(original.defenderBonuses.toImmutable());
		this.defenderSkills.putAll(original.defenderSkills);
		this.inWilderness = original.inWilderness;
		this.onSlayerTask = original.onSlayerTask;
		this.raidPartySize = original.raidPartySize;
		this.spell = original.spell;
		this.usingChargeSpell = original.usingChargeSpell;
		this.usingMarkOfDarkness = original.usingMarkOfDarkness;
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.state;

public interface StateVisibleComponent extends HasState
{

	void updateVisibility();

}

package com.duckblade.osrs.dpscalc.plugin.ui.state;

import java.util.UUID;
import lombok.Builder;
import lombok.Data;
import lombok.extern.jackson.Jacksonized;

@Data
@Jacksonized
@Builder(toBuilder = true)
public class PanelInputSet
{

	@Builder.Default
	private final String uuid = UUID.randomUUID().toString();

	@Builder.Default
	private String name = "Default Set";

	@Builder.Default
	private final PanelState state = new PanelState();

}

package com.duckblade.osrs.dpscalc.plugin.ui.state.panel;

import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelInputSet;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.util.CustomJComboBox;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.JOptionPane;

@Singleton
public class PanelInputSetSelect extends CustomJComboBox<PanelInputSet>
{

	private final PanelStateManager manager;

	@Inject
	public PanelInputSetSelect(PanelStateManager manager)
	{
		super(manager.getInputSets(), PanelInputSet::getName, null);
		this.manager = manager;
		manager.addOnSetChangedListener(() ->
		{
			setItems(manager.getInputSets());
			setValue(manager.getCurrentSet());
		});

		setValue(manager.currentSet());
		setNullLast(true);
		setNullText("New...");

		addCallback(() ->
		{
			if (getValue() == null)
			{
				createNewSet();
			}
			else
			{
				manager.selectSet(getValue());
			}
		});
	}

	public void createNewSet()
	{
		String name = JOptionPane.showInputDialog(this, "New set name:", "Create Set", JOptionPane.QUESTION_MESSAGE);
		if (name != null)
		{
			manager.createNewSet(name);
		}
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.state.panel;

import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import net.runelite.client.util.ImageUtil;

@Singleton
public class DuplicateSetButton extends JButton
{

	private static final ImageIcon DELETE_ICON =
		new ImageIcon(ImageUtil.resizeImage(ImageUtil.loadImageResource(DeleteSetButton.class, "icon_copy.png"), 20, 20));

	@Inject
	public DuplicateSetButton(PanelStateManager manager)
	{
		super(DELETE_ICON);
		setFocusPainted(false);
		addActionListener(e ->
		{
			String name = JOptionPane.showInputDialog(
				this,
				"New set name:",
				"Duplicate \"" + manager.currentSet().getName() + "\"",
				JOptionPane.QUESTION_MESSAGE
			);
			if (name != null)
			{
				manager.duplicateSet(manager.currentSet(), name);
			}
		});
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.state.panel;

import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import net.runelite.client.util.ImageUtil;

@Singleton
public class DeleteSetButton extends JButton
{

	private static final ImageIcon DELETE_ICON =
		new ImageIcon(ImageUtil.resizeImage(ImageUtil.loadImageResource(DeleteSetButton.class, "icon_delete.png"), 20, 20));

	@Inject
	public DeleteSetButton(PanelStateManager manager)
	{
		super(DELETE_ICON);
		setFocusPainted(false);
		addActionListener(e ->
		{
			int confirmResult = JOptionPane.showConfirmDialog(this, "Delete the current set?", "Delete Set", JOptionPane.YES_NO_OPTION);
			if (confirmResult == JOptionPane.YES_OPTION)
			{
				manager.deleteSet(manager.currentSet());
			}
		});
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.state;

import com.google.common.collect.ImmutableList;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;

@Singleton
public class PanelStateManager
{

	private final List<PanelInputSet> sets;

	@Getter
	private PanelInputSet currentSet;

	private final List<Runnable> onSetChangedCallbacks = new ArrayList<>();

	@Inject
	public PanelStateManager()
	{
		sets = new ArrayList<>();
		createNewSet("Set 1");
	}

	public void createNewSet(String name)
	{
		PanelInputSet newSet = PanelInputSet.builder()
			.name(name)
			.build();

		sets.add(newSet);
		selectSet(newSet);
	}

	public PanelInputSet currentSet()
	{
		return currentSet;
	}

	public PanelState currentState()
	{
		return currentSet.getState();
	}

	public List<PanelInputSet> getInputSets()
	{
		return ImmutableList.copyOf(sets);
	}

	public void selectSet(PanelInputSet set)
	{
		currentSet = sets.contains(set) ? set : null;
		invokeCallbacks();
	}

	public void deleteSet(PanelInputSet set)
	{
		sets.remove(set);
		if (sets.isEmpty())
		{
			createNewSet("Set 1");
		}
		else
		{
			selectSet(sets.get(0));
		}
	}

	public void duplicateSet(PanelInputSet set, String name)
	{
		PanelInputSet newSet = PanelInputSet.builder()
				.name(name)
				.state(new PanelState(set.getState()))
				.build();

		sets.add(newSet);
		selectSet(newSet);
	}

	private void invokeCallbacks()
	{
		onSetChangedCallbacks.forEach(Runnable::run);
	}

	public void addOnSetChangedListener(Runnable r)
	{
		onSetChangedCallbacks.add(r);
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.state.component;

import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.CustomJCheckBox;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import lombok.Getter;

public class StateBoundJCheckBox extends CustomJCheckBox implements StateBoundComponent
{

	@Getter
	private final PanelStateManager manager;

	private final BiConsumer<PanelState, Boolean> stateWriter;
	private final Predicate<PanelState> stateReader;

	public StateBoundJCheckBox(String text, PanelStateManager manager, BiConsumer<PanelState, Boolean> stateWriter, Predicate<PanelState> stateReader)
	{
		super(text);
		this.manager = manager;
		this.stateWriter = stateWriter;
		this.stateReader = stateReader;
		addCallback(this::toState);
	}

	@Override
	public void toState()
	{
		stateWriter.accept(getState(), getValue());
	}

	@Override
	public void fromState()
	{
		setValue(stateReader.test(getState()));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.state.component;

import com.duckblade.osrs.dpscalc.plugin.ui.skills.StatBox;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import java.util.function.ObjIntConsumer;
import java.util.function.ToIntFunction;
import lombok.Getter;

public class StateBoundStatBox extends StatBox implements StateBoundComponent
{

	@Getter
	private final PanelStateManager manager;

	private final ObjIntConsumer<PanelState> stateWriter;
	private final ToIntFunction<PanelState> stateReader;

	public StateBoundStatBox(PanelStateManager manager, String iconName, String title, boolean editable, ObjIntConsumer<PanelState> stateWriter, ToIntFunction<PanelState> stateReader)
	{
		super(iconName, title, editable);
		this.manager = manager;
		this.stateWriter = stateWriter;
		this.stateReader = stateReader;
		addCallback(this::toState);
	}

	@Override
	public void toState()
	{
		stateWriter.accept(getState(), getValue());
	}

	@Override
	public void fromState()
	{
		setValue(stateReader.applyAsInt(getState()));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.state.component;

import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.CustomJComboBox;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Function;
import lombok.Getter;

public class StateBoundJComboBox<T> extends CustomJComboBox<T> implements StateBoundComponent
{

	@Getter
	private final PanelStateManager manager;

	private final BiConsumer<PanelState, T> stateWriter;
	private final Function<PanelState, T> stateReader;

	public StateBoundJComboBox(List<T> items, Function<T, String> displayMapper, String title, PanelStateManager manager, BiConsumer<PanelState, T> stateWriter, Function<PanelState, T> stateReader)
	{
		super(items, displayMapper, title);
		this.manager = manager;
		this.stateWriter = stateWriter;
		this.stateReader = stateReader;
		addCallback(this::toState);
	}

	@Override
	public void toState()
	{
		if (stateWriter != null)
		{
			stateWriter.accept(getState(), getValue());
		}
	}

	@Override
	public void fromState()
	{
		setValue(stateReader.apply(getState()));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.state;

interface HasState
{

	PanelStateManager getManager();

	default PanelState getState()
	{
		return getManager().currentState();
	}

}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.calc.model.WeaponCategory;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJComboBox;
import java.util.ArrayList;
import java.util.List;
import javax.inject.Inject;
import javax.inject.Singleton;
import net.runelite.api.EquipmentInventorySlot;

@Singleton
public class AttackStyleSelectPanel extends StateBoundJComboBox<AttackStyle>
{
	private WeaponCategory previousWeaponCategory = null;

	@Inject
	public AttackStyleSelectPanel(PanelStateManager manager)
	{
		super(
			WeaponCategory.UNARMED.getAttackStyles(),
			AttackStyle::getDisplayName,
			"Attack Style",
			manager,
			PanelState::setAttackStyle,
			PanelState::getAttackStyle
		);

		setAlignmentX(CENTER_ALIGNMENT);
		addBottomPadding(10);
	}

	@Override
	public void fromState()
	{
		WeaponCategory currentWeaponCategory = getState().getAttackerItems()
				.getOrDefault(EquipmentInventorySlot.WEAPON, ItemStats.EMPTY)
				.getWeaponCategory();

		if (previousWeaponCategory != (previousWeaponCategory = currentWeaponCategory))
		{
			List<AttackStyle> selectableStyles = new ArrayList<>(currentWeaponCategory.getAttackStyles().size() + 1);
			selectableStyles.addAll(currentWeaponCategory.getAttackStyles());
			// No matter the weapon, you can always manually cast spells
			selectableStyles.add(AttackStyle.MANUAL_CAST);
			setItems(selectableStyles);

			// reset attack style if it is no longer valid
			if (!selectableStyles.contains(getState().getAttackStyle()))
			{
				getState().setAttackStyle(null);
			}
		}

		super.fromState();
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.gearbonus.MageDemonbaneGearBonus;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJCheckBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;

@Singleton
public class UsingMarkOfDarknessCheckBox extends StateBoundJCheckBox implements StateVisibleComponent
{

	private final MageDemonbaneGearBonus mageDemonbaneGearBonus;

	@Inject
	public UsingMarkOfDarknessCheckBox(PanelStateManager manager, MageDemonbaneGearBonus mageDemonbaneGearBonus)
	{
		super(
			"Using Mark of Darkness",
			manager,
			PanelState::setUsingMarkOfDarkness,
			PanelState::isUsingMarkOfDarkness
		);
		this.mageDemonbaneGearBonus = mageDemonbaneGearBonus;

		setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		setValue(false);
		setEditable(true);
		setVisible(false);
	}

	@Override
	public void updateVisibility()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());
			ctx.put(ComputeInputs.ATTACK_STYLE, getState().getAttackStyle());
			ctx.put(ComputeInputs.SPELL, getState().getSpell());

			setVisible(mageDemonbaneGearBonus.isApplicable(ctx));
		});
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.maxhit.magic.SpellMaxHitComputable;
import com.duckblade.osrs.dpscalc.calc.model.Spell;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJComboBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import java.util.Arrays;
import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class SpellSelectPanel extends StateBoundJComboBox<Spell> implements StateVisibleComponent
{

	private final SpellMaxHitComputable spellMaxHitComputable;

	@Inject
	public SpellSelectPanel(PanelStateManager manager, SpellMaxHitComputable spellMaxHitComputable)
	{
		super(
			Arrays.asList(Spell.values()),
			Spell::getDisplayName,
			"Spell",
			manager,
			PanelState::setSpell,
			PanelState::getSpell
		);
		this.spellMaxHitComputable = spellMaxHitComputable;

		setAlignmentX(CENTER_ALIGNMENT);
		setVisible(false);
		addBottomPadding(10);
	}

	@Override
	public void updateVisibility()
	{
		Boolean visibleOpt = ComputeUtil.tryCompute(() ->
		{
			ComputeContext context = new ComputeContext();
			context.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());
			context.put(ComputeInputs.ATTACK_STYLE, getState().getAttackStyle());

			return spellMaxHitComputable.isApplicable(context);
		});

		boolean visible = visibleOpt != null && visibleOpt;
		setVisible(visible);
		if (!visible)
		{
			setValue(null);
		}
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.gearbonus.BlackMaskGearBonus;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJCheckBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;

@Singleton
public class OnSlayerTaskCheckBox extends StateBoundJCheckBox implements StateVisibleComponent
{

	private final BlackMaskGearBonus blackMaskGearBonus;

	@Inject
	public OnSlayerTaskCheckBox(PanelStateManager manager, BlackMaskGearBonus blackMaskGearBonus)
	{
		super(
			"On Slayer Task",
			manager,
			PanelState::setOnSlayerTask,
			PanelState::isOnSlayerTask
		);
		this.blackMaskGearBonus = blackMaskGearBonus;

		setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		setValue(false);
		setEditable(true);
		setVisible(false);
	}

	@Override
	public void updateVisibility()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());

			setVisible(blackMaskGearBonus.isApplicable(ctx));
		});
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.gearbonus.RevenantWeaponGearBonus;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJCheckBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;

@Singleton
public class InWildernessCheckBox extends StateBoundJCheckBox implements StateVisibleComponent
{

	private final RevenantWeaponGearBonus revenantWeaponGearBonus;

	@Inject
	public InWildernessCheckBox(PanelStateManager manager, RevenantWeaponGearBonus revenantWeaponGearBonus)
	{
		super(
			"In Wilderness",
			manager,
			PanelState::setInWilderness,
			PanelState::isInWilderness
		);
		this.revenantWeaponGearBonus = revenantWeaponGearBonus;

		setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		setValue(false);
		setEditable(true);
		setVisible(false);
	}

	@Override
	public void updateVisibility()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());
			ctx.put(ComputeInputs.ATTACK_STYLE, getState().getAttackStyle());

			setVisible(revenantWeaponGearBonus.isApplicable(ctx));
		});
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.plugin.osdata.clientdata.ClientDataProviderThreadProxy;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.LoadFromClientButton;
import java.awt.Component;
import java.awt.Dimension;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Skill;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class EquipmentPanel extends JPanel implements StateBoundComponent
{

	private static final List<EquipmentInventorySlot> RELEVANT_EQUIP_SLOTS = List.of(
		EquipmentInventorySlot.HEAD,
		EquipmentInventorySlot.CAPE,
		EquipmentInventorySlot.AMULET,
		EquipmentInventorySlot.WEAPON,
		EquipmentInventorySlot.BODY,
		EquipmentInventorySlot.SHIELD,
		EquipmentInventorySlot.LEGS,
		EquipmentInventorySlot.GLOVES,
		EquipmentInventorySlot.BOOTS,
		EquipmentInventorySlot.RING,
		EquipmentInventorySlot.AMMO
	);

	@Getter
	private final PanelStateManager manager;
	private final ClientDataProviderThreadProxy clientDataProviderThreadProxy;
	private final BlowpipeDartsSelectPanel blowpipeDartsSelectPanel;
	private final SpellSelectPanel spellSelectPanel;

	private final Set<StateBoundComponent> stateBoundComponents = new HashSet<>();
	private final Set<StateVisibleComponent> stateVisibleComponents = new HashSet<>();

	@Inject
	public EquipmentPanel(
		@Nullable ItemManager rlItemManager, ItemStatsProvider itemStatsProvider,
		PanelStateManager manager, ClientDataProviderThreadProxy clientDataProviderThreadProxy,
		EquipmentTotalsPanel equipmentTotalsPanel, AttackStyleSelectPanel attackStyleSelectPanel,
		InWildernessCheckBox inWildernessCheckBox, OnSlayerTaskCheckBox onSlayerTaskCheckBox,
		UsingChargeCheckBox usingChargeCheckBox, UsingMarkOfDarknessCheckBox usingMarkOfDarknessCheckBox,
		BlowpipeDartsSelectPanel blowpipeDartsSelectPanel, DharokHpPanel dharokHpPanel,
		ChinchompaDistancePanel chinchompaDistancePanel, SpellSelectPanel spellSelectPanel
	)
	{
		this.manager = manager;
		this.clientDataProviderThreadProxy = clientDataProviderThreadProxy;
		this.blowpipeDartsSelectPanel = blowpipeDartsSelectPanel;
		this.spellSelectPanel = spellSelectPanel;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 1000));

		add(new LoadFromClientButton(this::loadFromClient));

		add(Box.createVerticalStrut(10));

		JPanel slotPanel = new JPanel();
		slotPanel.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));
		slotPanel.setLayout(new BoxLayout(slotPanel, BoxLayout.Y_AXIS));
		slotPanel.setAlignmentX(CENTER_ALIGNMENT);
		add(slotPanel);

		for (EquipmentInventorySlot slot : RELEVANT_EQUIP_SLOTS)
		{
			EquipmentSlotPanel innerPanel = new EquipmentSlotPanel(manager, rlItemManager, slot, itemStatsProvider);
			innerPanel.addCallback(this::fromState);
			addPanel(innerPanel, slotPanel);

			slotPanel.add(Box.createVerticalStrut(5));

			if (slot == EquipmentInventorySlot.HEAD)
			{
				addPanel(onSlayerTaskCheckBox, slotPanel);
			}

			if (slot == EquipmentInventorySlot.WEAPON)
			{
				addPanel(inWildernessCheckBox, slotPanel);
			}
		}
		add(Box.createVerticalStrut(5));

		addPanel(dharokHpPanel);
		dharokHpPanel.add(Box.createVerticalStrut(10));

		addPanel(chinchompaDistancePanel);
		chinchompaDistancePanel.add(Box.createVerticalStrut(10));

		addPanel(blowpipeDartsSelectPanel);
		blowpipeDartsSelectPanel.addCallback(this::fromState);

		addPanel(attackStyleSelectPanel);
		attackStyleSelectPanel.addCallback(this::fromState);

		addPanel(spellSelectPanel);
		spellSelectPanel.addCallback(this::fromState);

		addPanel(usingMarkOfDarknessCheckBox);
		usingMarkOfDarknessCheckBox.add(Box.createVerticalStrut(10));

		addPanel(usingChargeCheckBox);
		usingChargeCheckBox.add(Box.createVerticalStrut(10));

		addPanel(equipmentTotalsPanel);
	}

	public void loadFromClient()
	{
		clientDataProviderThreadProxy.tryAcquire(clientDataProvider ->
		{
			getState().setAttackerItems(new HashMap<>(clientDataProvider.getPlayerEquipment()));
			getState().setAttackStyle(clientDataProvider.getAttackStyle().toBuilder().build());
			getState().setBlowpipeDarts(clientDataProvider.getBlowpipeDarts());
			getState().setOnSlayerTask(clientDataProvider.playerIsOnSlayerTask());
			getState().setUsingChargeSpell(clientDataProvider.playerIsUsingChargeSpell());
			getState().setUsingMarkOfDarkness(clientDataProvider.playerIsUsingMarkOfDarkness());
			getState().setInWilderness(clientDataProvider.playerIsInWilderness());
			getState().getAttackerSkills().put(Skill.HITPOINTS, clientDataProvider.getPlayerSkills().getLevels().getOrDefault(Skill.HITPOINTS, 99));
			getState().getAttackerBoosts().put(Skill.HITPOINTS, clientDataProvider.getPlayerSkills().getBoosts().getOrDefault(Skill.HITPOINTS, 0));
			SwingUtilities.invokeLater(this::fromState);
		});
	}

	private void addPanel(Component child)
	{
		addPanel(child, this);
	}

	private void addPanel(Component child, JPanel parent)
	{
		parent.add(child);
		if (child instanceof StateBoundComponent)
		{
			stateBoundComponents.add((StateBoundComponent) child);
		}
		if (child instanceof StateVisibleComponent)
		{
			stateVisibleComponents.add((StateVisibleComponent) child);
		}
	}

	@Override
	public void toState()
	{
		stateBoundComponents.forEach(StateBoundComponent::toState);
	}

	@Override
	public void fromState()
	{
		stateBoundComponents.forEach(StateBoundComponent::fromState);
		stateVisibleComponents.forEach(StateVisibleComponent::updateVisibility);
	}

	public boolean isReady()
	{
		// ensure selected dart if using tbp
		if (blowpipeDartsSelectPanel.isVisible() && getState().getBlowpipeDarts() == null)
		{
			return false;
		}

		// ensure spell is selected if needed
		if (spellSelectPanel.isVisible() && getState().getSpell() == null)
		{
			return false;
		}

		// ensure selected attack style (wearing nothing is fine)
		return getState().getAttackStyle() != null;
	}

	public String getSummary()
	{
		if (!isReady())
		{
			return "Not Set";
		}

		ItemStats weapon = getState().getAttackerItems().get(EquipmentInventorySlot.WEAPON);
		String weaponName = weapon == null ? "Unarmed" : weapon.getName();
		return getState().getAttackStyle().getAttackType() + " - " + weaponName;
	}
}
package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJComboBox;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingUtilities;
import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

public class EquipmentSlotPanel extends JPanel implements StateBoundComponent
{

	private static final ImageIcon CLEAR_ICON = new ImageIcon(ImageUtil.loadImageResource(EquipmentSlotPanel.class, "icon_clear.png"));

	private static List<ItemStats> getItemsForSlot(ItemStatsProvider itemStatsProvider, int slotIx)
	{
		return itemStatsProvider.getAll()
			.stream()
			.filter(is -> is.getSlot() == slotIx)
			.sorted(Comparator.comparing(ItemStats::getName))
			.collect(Collectors.toList());
	}

	@Getter
	private final PanelStateManager manager;
	private final ItemManager rlItemManager;

	private final ImageIcon defaultIcon;
	private final JLabel imageLabel;
	private final StateBoundJComboBox<ItemStats> comboBox;

	public EquipmentSlotPanel(PanelStateManager manager, ItemManager rlItemManager, EquipmentInventorySlot slot, ItemStatsProvider itemStatsProvider)
	{
		this.manager = manager;
		this.rlItemManager = rlItemManager;

		setLayout(new BorderLayout());
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 25));

		defaultIcon = new ImageIcon(ImageUtil.resizeImage(ImageUtil.loadImageResource(getClass(), "slot_" + slot.getSlotIdx() + ".png"), 25, 25));
		imageLabel = new JLabel(defaultIcon);
		imageLabel.setMaximumSize(new Dimension(25, 25));
		imageLabel.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 3));
		add(imageLabel, BorderLayout.WEST);

		comboBox = new StateBoundJComboBox<>(
			getItemsForSlot(itemStatsProvider, slot.getSlotIdx()),
			ItemStats::getName,
			null,
			manager,
			(ps, v) ->
			{
				if (v == null)
				{
					ps.getAttackerItems().remove(slot);
				}
				else
				{
					ps.getAttackerItems().put(slot, v);
				}
			},
			ps -> ps.getAttackerItems().get(slot)
		);
		comboBox.enableAutocomplete();
		comboBox.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 75, 25));
		comboBox.addCallback(this::updateImage);
		add(comboBox, BorderLayout.CENTER);

		JButton clearButton = new JButton(CLEAR_ICON);
		clearButton.setPreferredSize(new Dimension(25, 25));
		SwingUtil.removeButtonDecorations(clearButton);
		clearButton.addActionListener(e ->
		{
			getState().getAttackerItems().remove(slot);
			fromState();
		});
		add(clearButton, BorderLayout.EAST);
	}

	private void updateImage()
	{
		SwingUtilities.invokeLater(() ->
		{
			ItemStats newValue = comboBox.getValue();
			if (newValue == null)
			{
				imageLabel.setIcon(defaultIcon);
			}
			else if (rlItemManager != null)
			{
				AsyncBufferedImage newIcon = rlItemManager.getImage(newValue.getItemId());
				BufferedImage resized = ImageUtil.resizeImage(newIcon, 25, 25); // if async, this does nothing
				newIcon.onLoaded(() ->
				{
					// only fires on async
					BufferedImage resizedDelayed = ImageUtil.resizeImage(newIcon, 25, 25);
					imageLabel.setIcon(new ImageIcon(resizedDelayed));
				});
				imageLabel.setIcon(new ImageIcon(resized));
			}
		});
	}

	@Override
	public void toState()
	{
		comboBox.toState();
	}

	@Override
	public void fromState()
	{
		comboBox.fromState();
		updateImage();
	}

	public void addCallback(Runnable r)
	{
		comboBox.addCallback(r);
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.maxhit.magic.SpellcastingMaxHitBonusComputable;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJCheckBox;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.BorderFactory;

@Singleton
public class UsingChargeCheckBox extends StateBoundJCheckBox implements StateVisibleComponent
{

	@Inject
	public UsingChargeCheckBox(PanelStateManager manager)
	{
		super(
			"Using Mark of Darkness",
			manager,
			PanelState::setUsingMarkOfDarkness,
			PanelState::isUsingMarkOfDarkness
		);

		setBorder(BorderFactory.createEmptyBorder(0, 0, 5, 0));
		setValue(false);
		setEditable(true);
		setVisible(false);
	}

	@Override
	public void updateVisibility()
	{
		setVisible(SpellcastingMaxHitBonusComputable.GOD_SPELLS.contains(getState().getSpell()));
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.gearbonus.ChinchompaDistanceGearBonus;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import com.duckblade.osrs.dpscalc.plugin.ui.util.FocusLostAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.JTextFieldIntOnlyKeyAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.SelectAllFocusListener;
import com.google.common.base.Strings;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import lombok.Getter;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class ChinchompaDistancePanel extends JPanel implements StateBoundComponent, StateVisibleComponent
{

	@Getter
	private final PanelStateManager manager;
	private final ChinchompaDistanceGearBonus chinchompaDistanceGearBonus;

	private final JTextField distanceField;

	@Inject
	public ChinchompaDistancePanel(PanelStateManager manager, ChinchompaDistanceGearBonus chinchompaDistanceGearBonus)
	{
		this.manager = manager;
		this.chinchompaDistanceGearBonus = chinchompaDistanceGearBonus;

		setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 40));
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 40));
		setLayout(new GridLayout(2, 2));
		setVisible(false);

		distanceField = new JTextField("1", 2);
		distanceField.setAlignmentX(Component.CENTER_ALIGNMENT); // of component
		distanceField.setHorizontalAlignment(JTextField.CENTER); // of inner text
		distanceField.addFocusListener(new SelectAllFocusListener(distanceField));
		distanceField.addKeyListener(new JTextFieldIntOnlyKeyAdapter());
		distanceField.addFocusListener(new FocusLostAdapter(e -> toState()));
		distanceField.addActionListener(e -> toState());

		add(new JLabel("Distance"));
		add(distanceField);
		add(Box.createVerticalStrut(10));
	}

	@Override
	public void toState()
	{
		coerce();
		getState().setAttackerDistance(Integer.parseInt(distanceField.getText()));
	}

	@Override
	public void fromState()
	{
		distanceField.setText(String.valueOf(getState().getAttackerDistance()));
	}

	@Override
	public void updateVisibility()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());
			ctx.put(ComputeInputs.ATTACK_STYLE, getState().getAttackStyle());

			setVisible(chinchompaDistanceGearBonus.isApplicable(ctx));
		});
	}

	private void coerce()
	{
		if (Strings.isNullOrEmpty(distanceField.getText()))
		{
			distanceField.setText("1");
		}
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.AttackerItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.AttackStyle;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import java.awt.Dimension;
import java.text.DecimalFormat;
import java.util.HashSet;
import java.util.Set;
import java.util.function.ToDoubleFunction;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JPanel;
import lombok.Getter;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class EquipmentTotalsPanel extends JPanel implements StateBoundComponent
{

	private static class StatLine extends JLabel
	{
		private static final DecimalFormat STAT_LABEL_FORMAT = new DecimalFormat(": #.#");

		private final String title;
		private final ToDoubleFunction<ItemStats> getter;

		public StatLine(String title, ToDoubleFunction<ItemStats> getter)
		{
			super(title + ": 0");
			this.title = title;
			this.getter = getter;
		}

		public void update(ItemStats itemStats)
		{
			setText(title + STAT_LABEL_FORMAT.format(getter.applyAsDouble(itemStats)));
		}
	}

	@Getter
	private final PanelStateManager manager;
	private final AttackerItemStatsComputable attackerItemStatsComputable;

	private final Set<StatLine> statLines = new HashSet<>();

	@Inject
	public EquipmentTotalsPanel(PanelStateManager manager, AttackerItemStatsComputable attackerItemStatsComputable)
	{
		this.manager = manager;
		this.attackerItemStatsComputable = attackerItemStatsComputable;

		setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH, 0));
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setAlignmentX(CENTER_ALIGNMENT);
		add(Box.createHorizontalGlue());

		addLine("Stab Accuracy", ItemStats::getAccuracyStab);
		addLine("Slash Accuracy", ItemStats::getAccuracySlash);
		addLine("Crush Accuracy", ItemStats::getAccuracyCrush);
		addLine("Magic Accuracy", ItemStats::getAccuracyMagic);
		addLine("Ranged Accuracy", ItemStats::getAccuracyRanged);
		add(Box.createVerticalStrut(10));

		addLine("Melee Strength", ItemStats::getStrengthMelee);
		addLine("Ranged Strength", ItemStats::getStrengthRanged);
		addLine("Magic Damage Bonus", ItemStats::getStrengthMagic);
		add(Box.createVerticalStrut(10));

		addLine("Weapon Speed", ItemStats::getSpeed);
		addLine("Prayer", ItemStats::getPrayer);
	}

	private void addLine(String title, ToDoubleFunction<ItemStats> getter)
	{
		StatLine line = new StatLine(title, getter);
		statLines.add(line);
		add(line);
	}

	@Override
	public void fromState()
	{
		ComputeUtil.computeSilent(() ->
		{
			// force an attack style so that the stats panel updates whether the user has selected one or not
			AttackStyle attackStyle = getState().getAttackStyle();
			if (attackStyle == null)
			{
				attackStyle = getState().getAttackerItems()
					.getOrDefault(EquipmentInventorySlot.WEAPON, ItemStats.EMPTY)
					.getWeaponCategory()
					.getAttackStyles()
					.get(0);
			}

			ComputeContext ctx = new ComputeContext();

			ctx.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());
			ctx.put(ComputeInputs.ATTACK_STYLE, attackStyle);
			ctx.put(ComputeInputs.BLOWPIPE_DARTS, getState().getBlowpipeDarts());

			ItemStats aggregate = ctx.get(attackerItemStatsComputable);
			statLines.forEach(sl -> sl.update(aggregate));
		});
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.multihit.DharoksDptComputable;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateBoundComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import com.duckblade.osrs.dpscalc.plugin.ui.util.FocusLostAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.JTextFieldIntOnlyKeyAdapter;
import com.duckblade.osrs.dpscalc.plugin.ui.util.SelectAllFocusListener;
import com.google.common.base.Strings;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.Box;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import lombok.Getter;
import net.runelite.api.Skill;
import net.runelite.client.ui.PluginPanel;

@Singleton
public class DharokHpPanel extends JPanel implements StateBoundComponent, StateVisibleComponent
{

	@Getter
	private final PanelStateManager manager;
	private final DharoksDptComputable dharoksDptComputable;

	private final JTextField currentHpField, maxHpField;

	@Inject
	public DharokHpPanel(PanelStateManager manager, DharoksDptComputable dharoksDptComputable)
	{
		this.manager = manager;
		this.dharoksDptComputable = dharoksDptComputable;

		setMinimumSize(new Dimension(0, 70));
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH, 70));
		setLayout(new GridLayout(3, 2));
		setVisible(false);

		currentHpField = new JTextField("1", 3);
		currentHpField.setAlignmentX(Component.CENTER_ALIGNMENT); // of component
		currentHpField.setHorizontalAlignment(JTextField.CENTER); // of inner text
		currentHpField.addFocusListener(new SelectAllFocusListener(currentHpField));
		currentHpField.addKeyListener(new JTextFieldIntOnlyKeyAdapter());
		currentHpField.addFocusListener(new FocusLostAdapter(e -> toState()));
		currentHpField.addActionListener(e -> toState());

		maxHpField = new JTextField("99", 3);
		maxHpField.setAlignmentX(Component.CENTER_ALIGNMENT); // of component
		maxHpField.setHorizontalAlignment(JTextField.CENTER); // of inner text
		maxHpField.addFocusListener(new SelectAllFocusListener(maxHpField));
		maxHpField.addKeyListener(new JTextFieldIntOnlyKeyAdapter());
		maxHpField.addFocusListener(new FocusLostAdapter(e -> toState()));
		maxHpField.addActionListener(e -> toState());

		add(new JLabel("Curr. HP"));
		add(new JLabel("Max HP"));
		add(currentHpField);
		add(maxHpField);
		add(Box.createVerticalStrut(10));
	}

	@Override
	public void toState()
	{
		coerce();
		int currentHp = Integer.parseInt(currentHpField.getText());
		int maxHp = Integer.parseInt(maxHpField.getText());

		getState().getAttackerSkills().put(Skill.HITPOINTS, maxHp);
		getState().getAttackerBoosts().put(Skill.HITPOINTS, currentHp - maxHp);
	}

	@Override
	public void fromState()
	{
		int maxHp = getState().getAttackerSkills().getOrDefault(Skill.HITPOINTS, 99);
		int currentHp = maxHp + getState().getAttackerBoosts().getOrDefault(Skill.HITPOINTS, 0);

		currentHpField.setText(String.valueOf(currentHp));
		maxHpField.setText(String.valueOf(maxHp));
	}

	@Override
	public void updateVisibility()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());
			ctx.put(ComputeInputs.ATTACK_STYLE, getState().getAttackStyle());

			setVisible(dharoksDptComputable.isApplicable(ctx));
		});
	}

	private void coerce()
	{
		if (Strings.isNullOrEmpty(currentHpField.getText()))
		{
			currentHpField.setText("1");
		}
		if (Strings.isNullOrEmpty(maxHpField.getText()))
		{
			currentHpField.setText("99");
		}
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui.equip;

import com.duckblade.osrs.dpscalc.calc.ammo.BlowpipeDartsItemStatsComputable;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeContext;
import com.duckblade.osrs.dpscalc.calc.compute.ComputeInputs;
import com.duckblade.osrs.dpscalc.calc.model.ItemStats;
import com.duckblade.osrs.dpscalc.plugin.config.BlowpipeDarts;
import com.duckblade.osrs.dpscalc.plugin.osdata.wiki.ItemStatsProvider;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelState;
import com.duckblade.osrs.dpscalc.plugin.ui.state.PanelStateManager;
import com.duckblade.osrs.dpscalc.plugin.ui.state.StateVisibleComponent;
import com.duckblade.osrs.dpscalc.plugin.ui.state.component.StateBoundJComboBox;
import com.duckblade.osrs.dpscalc.plugin.ui.util.ComputeUtil;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class BlowpipeDartsSelectPanel extends StateBoundJComboBox<ItemStats> implements StateVisibleComponent
{

	private final BlowpipeDartsItemStatsComputable blowpipeDartsItemStatsComputable;

	private static List<ItemStats> getDarts(ItemStatsProvider itemStatsProvider)
	{
		return Arrays.stream(BlowpipeDarts.values())
			.map(BlowpipeDarts::getItemId)
			.map(itemStatsProvider::getById)
			.collect(Collectors.toList());
	}

	@Inject
	public BlowpipeDartsSelectPanel(PanelStateManager manager, ItemStatsProvider itemStatsProvider, BlowpipeDartsItemStatsComputable blowpipeDartsItemStatsComputable)
	{
		super(
			getDarts(itemStatsProvider),
			ItemStats::getName,
			"Blowpipe Darts",
			manager,
			PanelState::setBlowpipeDarts,
			PanelState::getBlowpipeDarts
		);
		this.blowpipeDartsItemStatsComputable = blowpipeDartsItemStatsComputable;

		setAlignmentX(CENTER_ALIGNMENT);
		setVisible(false);
		addBottomPadding(10);
	}

	public void updateVisibility()
	{
		ComputeUtil.computeSilent(() ->
		{
			ComputeContext ctx = new ComputeContext();
			ctx.put(ComputeInputs.ATTACKER_ITEMS, getState().getAttackerItems());
			ctx.put(ComputeInputs.ATTACK_STYLE, getState().getAttackStyle());

			setVisible(blowpipeDartsItemStatsComputable.isApplicable(ctx));
		});
	}
}

package com.duckblade.osrs.dpscalc.plugin.ui;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JSeparator;
import javax.swing.SwingConstants;
import net.runelite.client.plugins.config.ConfigPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

public class MenuPanelNavEntry extends JPanel
{

	private static final ImageIcon NAVIGATION_ICON;

	static
	{
		BufferedImage image = ImageUtil.loadImageResource(ConfigPlugin.class, "/util/arrow_right.png");
		image = ImageUtil.resizeImage(image, 25, 25);
		NAVIGATION_ICON = new ImageIcon(image);
	}

	private final JLabel descriptionLabel;

	public MenuPanelNavEntry(String title, String description, Runnable onClick)
	{
		setLayout(new BorderLayout());
		setOpaque(true);
		setBackground(ColorScheme.DARKER_GRAY_COLOR.darker());
		setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 40));
		setMaximumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 40));
		setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));

		JButton navButton = new JButton(NAVIGATION_ICON);
		SwingUtil.removeButtonDecorations(navButton);
		add(navButton, BorderLayout.EAST);

		JPanel splitPanel = new JPanel();
		splitPanel.setLayout(new BoxLayout(splitPanel, BoxLayout.Y_AXIS));
		splitPanel.setOpaque(false);
		add(splitPanel, BorderLayout.CENTER);

		JLabel titleLabel = new JLabel(title);
		titleLabel.setForeground(Color.white);
		titleLabel.setFont(FontManager.getRunescapeBoldFont());
		splitPanel.add(titleLabel);

		JSeparator separator = new JSeparator(SwingConstants.HORIZONTAL);
		separator.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
		splitPanel.add(separator);

		descriptionLabel = new JLabel(description);
		descriptionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		descriptionLabel.setFont(FontManager.getRunescapeSmallFont());
		splitPanel.add(descriptionLabel);

		final MouseAdapter m = new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				onClick.run();
			}
		};
		titleLabel.addMouseListener(m);
		descriptionLabel.addMouseListener(m);
		splitPanel.addMouseListener(m);
		this.addMouseListener(m);
		navButton.addActionListener(e -> onClick.run());
	}

	public void setDescription(String text)
	{
		this.descriptionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
		this.descriptionLabel.setText(text);
	}

}

