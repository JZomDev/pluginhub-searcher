/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// From AttackStyles RuneLite plugin
// Located at: https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/attackstyles/AttackStyle.java
// or net.runelite.client.plugins.attackstyles.AttackStyle

package com.maxhitcalc;

import lombok.Getter;
import net.runelite.api.Skill;

enum AttackStyle
{
    ACCURATE("Accurate", Skill.ATTACK),
    AGGRESSIVE("Aggressive", Skill.STRENGTH),
    DEFENSIVE("Defensive", Skill.DEFENCE),
    CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
    RANGING("Ranging", Skill.RANGED),
    LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
    CASTING("Casting", Skill.MAGIC),
    DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
    OTHER("Other");

    @Getter
    private final String name;
    @Getter
    private final Skill[] skills;

    AttackStyle(String name, Skill... skills)
    {
        this.name = name;
        this.skills = skills;
    }
}
/* EquipmentItems.java
 * Contains Functions for retrieving information about currently equipped items.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.gameval.InventoryID;

public class EquipmentItems
{
    /**
     * Gets Currently Equipped Items
     *
     * @param client
     *
     * @return Item[] of all Equipped Items
     */
    public static Item[] getCurrentlyEquipped(Client client)
    {
        Item[] playerEquipment;
        if (client.getItemContainer(InventoryID.WORN) != null )
        {
            playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
        }
        else
        {
            playerEquipment = null;
        }

        return playerEquipment;
    }

    /**
     * Get Item Name in Specific Slot of Specified Equipment Set <br>
     *
     * @param client
     * @param ITEMSLOT the item slot id that will be checked
     * @param playerEquipment specified Item list
     * @return string of item name, returns empty string if ITEMSLOT is empty
     */
    public static String getItemNameInGivenSetSlot(Client client, Item[] playerEquipment, EquipmentInventorySlot ITEMSLOT)
    {
        String itemName = "";

        if(playerEquipment != null){
            if(playerEquipment.length > ITEMSLOT.getSlotIdx()
                    && playerEquipment[ITEMSLOT.getSlotIdx()] != null)
            {
                itemName = client.getItemDefinition(playerEquipment[ITEMSLOT.getSlotIdx()].getId()).getName();
            }
        }

        return itemName;
    }

    /**
     * Get Item ID in Specific Slot with a specified equipment list <br>
     *
     * @param playerEquipment specified Item list
     * @param ITEMSLOT the item slot id that will be checked
     *
     * @return int of item id, returns -1 if empty
     */
    public static int getItemIdInGivenSetSlot(Item[] playerEquipment, EquipmentInventorySlot ITEMSLOT)
    {
        int itemID = -1;

        if(playerEquipment != null) {
            if(playerEquipment.length > ITEMSLOT.getSlotIdx()
                    && playerEquipment[ITEMSLOT.getSlotIdx()] != null)
            {
                itemID = playerEquipment[ITEMSLOT.getSlotIdx()].getId();
            }
        }

        return itemID;
    }

    public static Item[] getQuiverItem(Client client)
    {
        Item[] quiverItem;

        if (client.getItemContainer(InventoryID.DIZANAS_QUIVER_AMMO) != null )
        {
            quiverItem = client.getItemContainer(InventoryID.DIZANAS_QUIVER_AMMO).getItems(); // returns as an array, but should only have 1 item or none
        }
        else
        {
            quiverItem = null;
        }

        return quiverItem;
    }

    public static String getQuiverItemName(Client client)
    {
        String itemName = "";

        Item[] quiverItems = getQuiverItem(client);

        if (quiverItems != null)
        {
            if(quiverItems.length > 0)
            {
                itemName = client.getItemDefinition(quiverItems[0].getId()).getName();
            }
        }

        return itemName;
    }

    public static int getQuiverItemID(Client client)
    {
        int itemID = -1;

        Item[] quiverItems = getQuiverItem(client);

        if (quiverItems != null)
        {
            if(quiverItems.length > 0)
            {
                itemID = quiverItems[0].getId();
            }
        }

        return itemID;
    }

    /**
     * Returns if a given ammo could be fired from a weapon,
     * does not take into account the tier of ammo or tier of weapon
     *
     * @param ammoTypeName name of ammo item
     * @param weaponName name of weapon
     *
     * @return boolean, true or false
     */
    public static boolean doesAmmoMatchWeapon(String ammoTypeName, String weaponName)
    {
        // Arrows -> bows
        if (ammoTypeName.toLowerCase().contains("arrow")) {
            // Ogre arrow -> ogre bow
            if (ammoTypeName.toLowerCase().contains("ogre")) {
                if(weaponName.toLowerCase().contains("ogre")) return true;
            }
            // all other arrows -> any bow
            else {
                if(weaponName.toLowerCase().contains("bow") && !weaponName.toLowerCase().contains("crossbow")) return true;
            }
        }
        // Brutal Arrows
        else if(ammoTypeName.toLowerCase().contains("brutal")) {
            if(weaponName.toLowerCase().contains("ogre")) return true;
        }
        // Bolts -> crossbows
        else if(ammoTypeName.toLowerCase().contains("bolts")) {
            // Kebbit bolts -> hunters' crossbow
            if(ammoTypeName.toLowerCase().contains("kebbit")) {
                if(weaponName.toLowerCase().contains("hunters' crossbow")) return true;
            }
            // Antler bolts -> hunter's sunlight crossbow
            else if(ammoTypeName.toLowerCase().contains("antler")){
                if(weaponName.toLowerCase().contains("hunters' sunlight crossbow")) return true;
            }
            // Bone bolts -> Dorgeshuun crossbow
            else if (ammoTypeName.toLowerCase().contains("bone")) {
                if(weaponName.toLowerCase().contains("dorgeshuun")) return true;
            }
            // All other types of bolts -> normal crossbows
            else {
                if(weaponName.toLowerCase().contains("crossbow")) return true;
            }
        }
        // Bolt rack -> Karil's
        else if(ammoTypeName.toLowerCase().contains("rack")) {
            if(weaponName.toLowerCase().contains("karil's")) return true;
        }
        // Javelin -> Ballistae
        else if(ammoTypeName.toLowerCase().contains("javelin")) {
            if(weaponName.toLowerCase().contains("ballistae")) return true;
        }
        // Tar -> Salamander
        else if(ammoTypeName.toLowerCase().contains("tar")) {
            if(weaponName.toLowerCase().contains("salamader")) return true;
        }

        // otherwise, ammo does match!
        return false;
    }
}

/* MaxHitCalcConfig.java
 * Contains all config items for the plugin.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("MaxHitCalc")
public interface MaxHitCalcConfig extends Config
{
	@ConfigSection(
			name = "Main Panel",
			description = "Settings relating to the Main Panel",
			position =  2,
			closedByDefault = false
	)
	String mainPanelSettings = "Main Panel";

	@ConfigSection(
			name = "Special Attack Settings",
			description = "Settings for Special Attacks and Weapons",
			position =  3,
			closedByDefault = false
	)
	String specSettings = "Special Attack Settings";

	@ConfigSection(
			name = "Inventory Settings",
			description = "Settings relating to tooltips on Inventory Items",
			position =  4,
			closedByDefault = false
	)
	String inventorySettings = "Inventory Settings";

	@ConfigSection(
			name = "Spell Settings",
			description = "Settings relating to tooltips on Spells",
			position =  5,
			closedByDefault = false
	)
	String spellSettings = "Spell Settings";

	// Persistent Blowdart Setting
	@ConfigItem(
			keyName = "blowpipeDartType",
			name = "Blowpipe Dart Type",
			description = "Sets the Dart type for calculation",
			position = 0,
			hidden = true
	)
	default BlowpipeDartType blowpipeDartType()
	{
		return BlowpipeDartType.MITHRIL;
	}

	// Show Max Hit
	@ConfigItem(
			keyName = "showMaxHit",
			name = "Display Max Hit",
			description = "Shows your Max Hit with equipped item.",
			position = 0,
			section = mainPanelSettings
	)
	default boolean showMaxHit()
	{
		return true;
	}

	// Show Max Spec
	@ConfigItem(
		keyName = "showSpec",
		name = "Display Max Spec",
		description = "Shows your Max Spec with equipped items.",
		position = 1,
		section = mainPanelSettings
	)
	default boolean showSpec()
	{
		return true;
	}

	// Show Max Hit vs Type
	@ConfigItem(
			keyName = "showType",
			name = "Display Max Hit vs Type",
			description = "Shows your Max Hit vs current Type bonus.",
			position = 2,
			section = mainPanelSettings
	)
	default boolean showType()
	{
		return true;
	}

	// Show Max Spec vs Type
	@ConfigItem(
			keyName = "showSpecVsType",
			name = "Display Max Spec vs Type",
			description = "Shows your Max Spec vs current Type bonus.",
			position = 3,
			section = mainPanelSettings
	)
	default boolean showSpecVsType()
	{
		return true;
	}

	// Show Predicted Requirements for next Max Hit
	@ConfigItem(
			keyName = "showPredictionTooltip",
			name = "Tooltip for Predicted Next Max Hit",
			description = "Hover over the panel for a prediction of requirements for next max hit.",
			position = 4,
			section = mainPanelSettings
	)
	default boolean showPredictionTooltip()
	{
		return true;
	}

	// Show Predicted Requirements for next Max Hit
	@ConfigItem(
			keyName = "displayDoubleHitWeaponsAsOneHit",
			name = "Combine Multi Hit Specs as One Hit",
			description = "Weapons like the DDS will display as one hit calculation.",
			position = 0,
			section = specSettings
	)
	default boolean displayMultiHitWeaponsAsOneHit()
	{
		return true;
	}

	// Show Predicted Max Hit when hovering over item in inventory
	@ConfigItem(
			keyName = "showInventoryTooltip",
			name = "Tooltip on Inventory Items",
			description = "Hover over an item in your inventory to see it's max hit impact when equipped.",
			position = 0,
			section = inventorySettings
	)
	default boolean showInventoryTooltip() { return true; }

	// Show Predicted Max Hit when hovering over item in bank or bank inventory
	@ConfigItem(
			keyName = "showBankTooltip",
			name = "Tooltip on Bank Items",
			description = "Hover over an item in your bank to see it's max hit impact when equipped.",
			position = 1,
			section = inventorySettings
	)
	default boolean showBankTooltip()
	{
		return true;
	}

	// Show Predicted Max Hit when hovering over spell in Spellbook
	@ConfigItem(
			keyName = "showSpellbookTooltip",
			name = "Tooltip on Spells in Spellbook",
			description = "Hover over a spell in the spellbook to see its current max hit.",
			position = 0,
			section = spellSettings
	)
	default boolean showSpellbookTooltip()
	{
		return true;
	}

	// Show Predicted Max Hit when hovering over spell in Autocast Seleciton
	@ConfigItem(
			keyName = "showAutocastSelectionTooltip",
			name = "Tooltip on Spells in Autocast Selection",
			description = "Hover over a spell in the autocast selection to see its current max hit.",
			position = 1,
			section = spellSettings
	)
	default boolean showAutocastSelectionTooltip()
	{
		return true;
	}

	// Show Predicted Max Hit for spells that are currently disabled (not enough runes)
	@ConfigItem(
			keyName = "showTooltipOnDisabledSpells",
			name = "Tooltip on Disabled Spells",
			description = "Show max hit on spells you don't have the runes to use.",
			position = 2,
			section = spellSettings
	)
	default boolean showTooltipOnDisabledSpells()
	{
		return true;
	}

	@ConfigItem(
			keyName = "timeToWaitBeforeResettingSelectedNPC",
			name = "Time To Wait Before Resetting Selected NPC",
			description = "NPC is selected when attacking, calculating any magic weaknesses and will be removed after a certain amount of time. (in minutes) 0 = No Resetting",
			position = 3,
			section = spellSettings
	)
	default int timeToWaitBeforeResettingSelectedNPC() { return 2; }
}

/* MaxAgainstType.java
 * Contains the function for calculating the max hit against specific type.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Skill;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;
import java.util.ArrayList;
import java.util.List;

/**
 * Contains functions for calculating max hit vs specific types of npc.
 */
public class MaxAgainstType extends MaxHit {
    MaxAgainstType(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);
    }

    protected List<Double> getTypeBonus(AttackStyle attackStyle, Item[] playerEquipment)
    {
        List<Double> typeBonusToApply = new ArrayList<>();

        // Get Required Items
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String amuletItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMULET);
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);

        /*
         Order bonuses by when the bonus was added to the game, not when the item was added
        */

        // Melee Checks
        if(attackStyle == AttackStyle.AGGRESSIVE || attackStyle == AttackStyle.CONTROLLED || attackStyle == AttackStyle.ACCURATE || attackStyle == AttackStyle.DEFENSIVE)
        {
            // Undead and Slayer checks, they are mutually exclusive
            // Salve Amulet (e), Added 22 January 2007
            if (amuletItemName.contains("Salve amulet (e)"))
            {
                typeBonusToApply.add(1.2);
            }
            else if (amuletItemName.contains("Salve amulet(ei)"))
            {
                typeBonusToApply.add(1.2);
            }
            // Black Mask, Added 4 July 2006
            else if (headItemName.contains("Black mask"))
            {
                typeBonusToApply.add(1.1667);
            }
            // Slayer Helm, same as black mask, Attribute Added 4 July 2006
            else if (headItemName.contains("Slayer helmet"))
            {
                typeBonusToApply.add(1.1667);
            }
            else if (headItemName.contains("slayer helmet"))
            {
                typeBonusToApply.add(1.1667);
            }
            // Salve Amulet, Added 21 December 2004
            else if (amuletItemName.contains("Salve amulet"))
            {
                typeBonusToApply.add(1.15);
            }

            // Demonbane, added 4 January 2001
            if(weaponItemName.contains("Silverlight"))
            {
                typeBonusToApply.add(1.6) ;
            }
            else if(weaponItemName.contains("Darklight"))
            {
                typeBonusToApply.add(1.6); // same bonus as silverlight
            }

            // Shades, added 22 March 2006
            if(weaponItemName.contains("Gadderhammer"))
            {
                typeBonusToApply.add(1.25);
            }

            // Demonbane, added 9 June 2016
            if(weaponItemName.contains("Arclight"))
            {
                typeBonusToApply.add(1.7); // different from silverlight and darklight
            }
            else if(weaponItemName.contains("Emberlight"))
            {
                typeBonusToApply.add(1.7); //same as Arclight, but does not degrade
            }

            // Leaf-bladed Battleaxe vs Turoths and Kurasks, 15 September 2016
            if(weaponItemName.contains("Leaf-bladed battleaxe"))
            {
                typeBonusToApply.add(1.175);
            }

            // Dragonbane, added 5 January 2017
            if(weaponItemName.contains("Dragon hunter"))
            {
                typeBonusToApply.add(1.2); // same as dragon hunter crossbow boost which was added first
            }

            // Vampyre, added 24 May 2018
            if(weaponItemName.contains("Ivandis flail"))
            {
                typeBonusToApply.add(1.2);
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Viggora's"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Ursine chainmace"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Inquisitor's Crush Bonus, added 6 February 2020, set effect removed 25 September 2024
            // Now, wearing the Mace is the only requirement for the inquisitor's crush bonus
            if (weaponItemName.contains("Inquisitor"))
            {
                // If on crush style, which for the mace is all styles except controlled
                if (attackStyle != AttackStyle.CONTROLLED)
                {
                    typeBonusToApply.add(1.025); // +2.5% for the mace

                    // +2.5% crush dmg bonus for each armor piece if wearing the mace
                    if (headItemName.contains("Inquisitor's"))
                    {
                        typeBonusToApply.add(1.025);
                    }

                    if (bodyItemName.contains("Inquisitor's"))
                    {
                        typeBonusToApply.add(1.025);
                    }

                    if (legsItemName.contains("Inquisitor's"))
                    {
                        typeBonusToApply.add(1.025);
                    }
                }
            }

            // Vampyre, added 4 June 2020
            if(weaponItemName.contains("Blisterwood flail"))
            {
                typeBonusToApply.add(1.25);
            }

            // Golem bonus, added 14 April 2021, updated on 28 April 2021
            if(weaponItemName.contains("Barronite mace"))
            {
                typeBonusToApply.add(1.15);
            }

            // Kalphite, acording to Mod Ash, added with Partisan, 27 April 2022
            if(weaponItemName.contains("Keris"))
            {
                typeBonusToApply.add(1.33);
            }

            // Demonbane, added 10 July 2024
            if(weaponItemName.contains("Burning claws"))
            {
                typeBonusToApply.add(1.05) ;
            }

        }
        // Ranged Checks
        else if (attackStyle == AttackStyle.RANGING || attackStyle == AttackStyle.LONGRANGE)
        {
            // Salve Amulet (ei), added 1 May 2014
            if (amuletItemName.contains("Salve amulet(ei)"))
            {
                typeBonusToApply.add(1.2);
            }
            // Salve Amulet (i), added 1 May 2014
            else if (amuletItemName.contains("Salve amulet(i)"))
            {
                typeBonusToApply.add(1.1667) ;
            }
            // Black Mask (i), added 26 September 2013
            else if (headItemName.contains("Black mask"))
            {
                if (headItemName.contains("(i)"))
                {
                    typeBonusToApply.add(1.15);
                }
            }
            // Slayer helm (i)
            else if (headItemName.contains("Slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }
            else if (headItemName.contains("slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }

            // Dragonbane, added 5 January 2017
            if(weaponItemName.contains("Dragon hunter"))
            {
                typeBonusToApply.add(1.25);
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Craw's bow"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Webweaver bow"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Demonbane, added 10 July 2024
            if(weaponItemName.contains("Scorching bow"))
            {
                typeBonusToApply.add(1.3);
            }

        }
        // Magic Checks
        else if (attackStyle == AttackStyle.CASTING || attackStyle == AttackStyle.DEFENSIVE_CASTING)
        {
            // Salve Amulet (ei), added 1 May 2014
            if (amuletItemName.contains("Salve amulet(ei)"))
            {
                typeBonusToApply.add(1.2);
            }
            // Salve Amulet (i), added 1 May 2014
            else if (amuletItemName.contains("Salve amulet(i)"))
            {
                typeBonusToApply.add(1.15) ;
            }
            // Black Mask (i), added 26 September 2013
            else if (headItemName.contains("Black mask"))
            {
                if (headItemName.contains("(i)"))
                {
                    typeBonusToApply.add(1.15);
                }
            }
            // Slayer helm (i)
            else if (headItemName.contains("Slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }
            else if (headItemName.contains("slayer helmet (i)"))
            {
                typeBonusToApply.add(1.15); // same as black mask (i) boost which was added first
            }

            // Dragonbane, added 5 January 2017 ; OR potentially "new" type since value is different from original, added 25 September 2024
            if(weaponItemName.contains("Dragon hunter"))
            {
                typeBonusToApply.add(1.2);
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Thammaron's sceptre"))
            {
                if(!weaponItemName.contains("(u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }

            // Wilderness, added 26 July 2018
            if(weaponItemName.contains("Accursed sceptre"))
            {
                if(!weaponItemName.contains("u)"))
                {
                    typeBonusToApply.add(1.5);
                }
            }
        }

        return typeBonusToApply; // List of Modifiers
    }

    // Needed in Magic for Slayer Staff (e)
    protected double getSpellBaseHit(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        double basehit = 0;
        double magicLevel = client.getBoostedSkillLevel(Skill.MAGIC);

        String weaponItemName = "";
        if(playerEquipment.length > EquipmentInventorySlot.WEAPON.getSlotIdx()
                && playerEquipment[EquipmentInventorySlot.WEAPON.getSlotIdx()] != null)
        {
            weaponItemName = client.getItemDefinition(playerEquipment[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName();
        }

        String capeItemName = "";
        if(playerEquipment.length > EquipmentInventorySlot.CAPE.getSlotIdx()
                && playerEquipment[EquipmentInventorySlot.CAPE.getSlotIdx()] != null)
        {
            capeItemName = client.getItemDefinition(playerEquipment[EquipmentInventorySlot.CAPE.getSlotIdx()].getId()).getName();
        }

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Magic Weapon: " + client.getItemDefinition(playerItems[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName(), null);

        // Powered Staff Check
        // Trident of the Seas
        if(weaponItemName.contains("of the seas"))
        {
            basehit = Math.max((Math.floor((Math.min(magicLevel, 125) - 15) / 3)), 1); // Corrected, thanks to Mod Ash
        }
        // Trident of the Swamp
        else if(weaponItemName.contains("of the swamp"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 6) / 3))), 3); // Corrected, thanks to Mod Ash
        }
        // Sanquinesti Staff
        else if(weaponItemName.contains("Sanguinesti"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 3) / 3))), 4); // Corrected, thanks to Mod Ash
        }
        // Thammaron's Sceptre
        else if(weaponItemName.contains("Thammaron's"))
        {
            basehit = (Math.floor(magicLevel/3) - 8);
        }
        // Accursed Sceptre
        else if(weaponItemName.contains("Accursed"))
        {
            basehit = (Math.floor(magicLevel/3) - 6);
        }
        // Tumeken's Shadow
        else if(weaponItemName.contains("Tumeken"))
        {
            basehit = (Math.floor(magicLevel/3) + 1);
        }
        // Warped sceptre
        else if(weaponItemName.contains("Warped sceptre"))
        {
            // Current Wiki Value
            basehit = Math.floor(((8*magicLevel)+96)/37);
        }
        // Crystal staff (basic)
        else if(weaponItemName.contains("Crystal staff (basic)"))
        {
            basehit = 23;
        }
        // Crystal staff (attuned)
        else if(weaponItemName.contains("Crystal staff (attuned)"))
        {
            basehit = 31;
        }
        // Crystal staff (perfected)
        else if(weaponItemName.contains("Crystal staff (perfected)"))
        {
            basehit = 39;
        }
        else if(weaponItemName.contains("Bone staff"))
        {
            basehit = Math.floor(magicLevel/3) + 5;
        }
        // Autocasted Spell
        else
        {
            // Check if casting without spell selected
            int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
            if (selectedSpellId == 0)
            {
                // no spell selected
                return -1; // error
            }

            CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId);

            // Debug
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "VsType: Selected Spell ID: " + selectedSpellId, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "VsType: Selected Spell: " + selectedSpell, null);

            // Specific Selected Spell Cases
            if (selectedSpell != null)
            {
                // Magic Dart Case
                if(selectedSpell == CombatSpell.MAGIC_DART)
                {
                    double magicDartDamage = Math.floor(magicLevel * ((double)1/10)) + 10;

                    if(weaponItemName.contains("Slayer's staff (e)"))
                    {
                        magicDartDamage = Math.floor(magicLevel * ((double)1/6)) + 13;
                    }

                    basehit = magicDartDamage;
                }
                else
                {
                    basehit = selectedSpell.getBaseDamage();
                }

                // Purging Staff Boost to Demonbane spells
                if(weaponItemName.contains("Purging staff"))
                {
                    if((selectedSpell == CombatSpell.INFERIOR_DEMONBANE) || (selectedSpell == CombatSpell.SUPERIOR_DEMONBANE) || (selectedSpell == CombatSpell.DARK_DEMONBANE))
                    {
                        basehit = (selectedSpell.getBaseDamage() * 2); // Demonbane spells are doubled
                    }
                }

                // God Spell Cases with Charge
                if((selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK) || (selectedSpell == CombatSpell.CLAWS_OF_GUTHIX) || (selectedSpell == CombatSpell.SARADOMIN_STRIKE))
                {
                    if (client.getVarpValue(VarPlayerID.MAGEARENA_CHARGE) > 0) // Varplayer: Charge God Spell
                    {
                        if(selectedSpell == CombatSpell.CLAWS_OF_GUTHIX &&
                                (capeItemName.toLowerCase().contains("guthix cape") ||  capeItemName.toLowerCase().contains("guthix max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK &&
                                (capeItemName.toLowerCase().contains("zamorak cape") || capeItemName.toLowerCase().contains("zamorak max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.SARADOMIN_STRIKE &&
                                (capeItemName.toLowerCase().contains("saradomin cape") || capeItemName.toLowerCase().contains("saradomin max cape")))
                        {
                            basehit = 30;
                        }
                        else
                        {
                            basehit = 20;
                        }
                    }
                    else
                    {
                        basehit = 20;
                    }
                }
            }
        }

        return basehit;
    }

    protected double calculateMagicMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        // Calculate Magic Max Hit
        // Step 1: Find the base hit of the spell
        double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle);

        // Step 2: Calculate the Magic Damage Bonus
        double magicDmgBonus = getMagicEquipmentBoost(playerEquipment);

        double maxDamage = (spellBaseMaxHit * magicDmgBonus);

        // Step 3: Calculate Bonuses
        // Tome Bonuses
        double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
        maxDamage = maxDamage * correctTomeSpellBonus;

        CombatSpell spell = getSpell();

        // Final step: Calculate and add spell type weakness Bonus
        if (spell != null && spell.hasType())
        {
            if (plugin.selectedNPCName != null)
            {
                NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                if (weaknessBonus != null)
                {
                    if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                    {
                        int bonusPercent = weaknessBonus.getWeaknessPercent();

                        double typeBonusDamage = maxDamage * ((double) bonusPercent / (double)100);
                        maxDamage = maxDamage + typeBonusDamage;
                    }
                }
            }
        }

        // Twinflame Staff Double Hit bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {

                if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                {
                    double bonusHit = Math.floor(maxDamage) * 0.4;
                    maxDamage = Math.floor(maxDamage) + Math.floor(bonusHit);
                }
            }
        }

        return maxDamage;
    }

    private double calculateTypeMaxHit()
    {
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];

        // Get Current Equipment
        Item[] playerEquipment;
        if (client.getItemContainer(InventoryID.WORN) != null ) // Equipment container ID = 94
        {
            playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
        }
        else
        {
            playerEquipment = null;
        }

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            return calculateMeleeMaxHit(playerEquipment, attackStyle, attackStyleID, false);
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            return calculateRangedMaxHit(playerEquipment, attackStyle, attackStyleID);
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            return calculateMagicMaxHit(playerEquipment, attackStyle);
        }
        else
        {
            return -1;
        }
    }

    /**
     * Calculates Max Hit Vs Types
     *
     * @return Max Hit vs Types as Double
     */
    public double calculate()
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return 0;

        // Get Type modifier
        List<Double> typeModifiersList = this.getTypeBonus(attackStyle, playerEquipment);

        // Debug Modifiers
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Type Modifiers: " + typeModifiersList.toString(), null);

        // Get Max hit
        MaxHit normalMaxCalc = new MaxHit(plugin, config, itemManager, client);
        double maxHit = normalMaxCalc.calculate(false); // Normal Max
        double maxHitVsType = Math.floor(this.calculateTypeMaxHit()); // Vs Type Max

        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);

        // Remove bonuses that are constant from normal max hit in order to calculate max vs type.
        // Remove default + 2 colossal blade bonus
        if(weaponName.contains("Colossal blade"))
        {
            maxHitVsType = maxHitVsType - 2; // remove default bonus
        }

        // remove default +10 rat bonus
        if(weaponName.contains("Bone mace") || weaponName.contains("Bone shortbow"))
        {
            maxHitVsType = maxHitVsType - 10;
        }

        // Iterate through modifiers, flooring after multiplying
        if(!typeModifiersList.isEmpty())
        {
            for (double modifier: typeModifiersList)
            {
                maxHitVsType = Math.floor(maxHitVsType * modifier);
            }
        }

        // Re Add Bonuses that do not scale
        // Re-add Colossal Blade Increase, factoring in other modifiers.
        if(weaponName.contains("Colossal blade"))
        {
            int sizeBonus = (2 * Math.min(plugin.NPCSize, 5));

            maxHitVsType = maxHitVsType + sizeBonus;
        }

        // Re-add Rat +10 Damage Bonus
        if(weaponName.contains("Bone mace") || weaponName.contains("Bone shortbow"))
        {
            maxHitVsType = maxHitVsType + 10;
        }

        if(maxHit >= maxHitVsType)
        {
            return 0; // No Type Bonus
        }
        else
        {
            return maxHitVsType;
        }

    }
}

/* SpellbookSpellMaxHit.java
 * Calculates Max Hit for magic when given a specific spell.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.game.ItemManager;

public class SpellbookSpellMaxHit extends MaxHit
{
    SpellbookSpellMaxHit(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);
    }

    protected double getSpellBaseHit(Item[] playerEquipment, int magicLevel, CombatSpell spell)
    {
        double basehit = 0;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String capeItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.CAPE);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // God Spells Cases
        if((spell == CombatSpell.FLAMES_OF_ZAMORAK) || (spell == CombatSpell.CLAWS_OF_GUTHIX) || (spell == CombatSpell.SARADOMIN_STRIKE))
        {
            if (client.getVarpValue(VarPlayerID.MAGEARENA_CHARGE) > 0) // Varplayer: Charge God Spell
            {
                if(spell == CombatSpell.CLAWS_OF_GUTHIX &&
                        (capeItemName.toLowerCase().contains("guthix cape") ||  capeItemName.toLowerCase().contains("guthix max cape")))
                {
                    return 30;
                }
                else if(spell == CombatSpell.FLAMES_OF_ZAMORAK &&
                        (capeItemName.toLowerCase().contains("zamorak cape") || capeItemName.toLowerCase().contains("zamorak max cape")))
                {
                    return 30;
                }
                else if(spell == CombatSpell.SARADOMIN_STRIKE &&
                        (capeItemName.toLowerCase().contains("saradomin cape") || capeItemName.toLowerCase().contains("saradomin max cape")))
                {
                    return 30;
                }
                else
                {
                    return 20;
                }
            }
            else
            {
                return 20;
            }
        }
        // Magic Dart Case
        else if(spell == CombatSpell.MAGIC_DART)
        {
            double magicDartDamage = Math.floor(magicLevel * ((double)1/10)) + 10;

            return magicDartDamage;
        }
        else
        {
            // FIND TIER, FIND HIGHEST IN TIER
            if (spell.getTier() == 0)
            {
                // NO TIER,
                basehit = spell.getBaseDamage();
            }
            else if(magicLevel < spell.getReqLevel())
            {
                // Cant use spell
                basehit = -1;
            }
            else
            {
                // GET TIER, Get highest tier in level
                int spellTier = spell.getTier();
                String spellbook = spell.getSpellbook();

                CombatSpell[] spellsInTier = CombatSpell.getSpellsOfTier(spellTier, spellbook);

                for(CombatSpell cSpell : spellsInTier)
                {
                    if(magicLevel >= cSpell.getReqLevel())
                    {
                        if (basehit <= cSpell.getBaseDamage())
                        {
                            // new highest found
                            basehit = cSpell.getBaseDamage();
                        }
                    }
                }

                // Error, didn't find usable spell
                if (basehit == 0)
                    return -1; // error
            }
        }

        // Chaos Gauntlet Bonus Check
        if(spell.getName().toLowerCase().contains("bolt"))
        {
            if (glovesItemName.toLowerCase().contains("chaos gauntlets"))
            {
                basehit += 3;
            }
        }

        return basehit;
    }

    protected double getTomeSpellBonus(Item[] playerEquipment, CombatSpell spell)
    {
        String shieldItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.SHIELD);

        if (spell.getName().toLowerCase().contains("fire"))
        {
            // Check for tome of fire
            if (shieldItemName.contains("Tome of fire"))
            {
                if (!shieldItemName.contains("(empty)"))
                {
                    return 1.1;
                }
            }
        }

        if (spell.getName().toLowerCase().contains("water"))
        {
            // Check for tome of water
            if (shieldItemName.contains("Tome of water"))
            {
                if (!shieldItemName.contains("(empty)"))
                {
                    return 1.1;
                }
            }
        }

        if (spell.getName().toLowerCase().contains("earth"))
        {
            // Check for tome of water
            if (shieldItemName.contains("Tome of earth"))
            {
                if (!shieldItemName.contains("(empty)"))
                {
                    return 1.1;
                }
            }
        }

        return 1;
    }

    /**
     * Calculates Max hit of a specific spell with given equipment.
     *
     * @param playerEquipment current player equipment
     * @param spell selected spell to calculate max hit with
     * @return double, max hit value
     */
    public double calculateMagicMaxHit(Item[] playerEquipment, CombatSpell spell)
    {
        // Calculate Magic Max Hit
        // Step 1: Find the base hit of the spell
        double spellBaseMaxHit = getSpellBaseHit(playerEquipment, client.getBoostedSkillLevel(Skill.MAGIC), spell);

        // Step 2: Calculate the Magic Damage Bonus
        double magicDmgBonus = getMagicEquipmentBoost( playerEquipment);

        double maxDamage = (spellBaseMaxHit * magicDmgBonus);

        // Step 3: Calculate Bonuses
        // Tome Bonuses
        double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, spell); // default 1
        maxDamage = maxDamage * correctTomeSpellBonus;

        // Final step: Calculate and add spell type weakness Bonus
        if(spell.hasType())
        {
            if(plugin.selectedNPCName != null)
            {
                NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                if(weaknessBonus != null)
                {
                    if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                    {
                        int bonusPercent = weaknessBonus.getWeaknessPercent();

                        double typeBonusDamage = maxDamage * ((double) bonusPercent / (double)100);
                        maxDamage = maxDamage + typeBonusDamage;
                    }
                }
            }
        }

        // Twinflame Staff Double Hit bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {

                if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                {
                    double bonusHit = Math.floor(maxDamage) * 0.4;
                    maxDamage = Math.floor(maxDamage) + Math.floor(bonusHit);
                }
            }
        }

        return maxDamage;
    }
}

/* MaxHitCalcPlugin.java
 * Main program code for Max Hit Calc RuneLite plugin.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ClientToolbar;

import java.awt.image.BufferedImage;

@Slf4j
@PluginDescriptor(
	name = "Max Hit Calculator",
	description = "Calculates Max Hit stats for the current equipment setup.",
	tags = "max hit, combat, stats, helpful, melee, ranged, magic"
)
public class MaxHitCalcPlugin extends Plugin
{
	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MaxHitCalcOverlay pluginOverlay;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private MaxHitCalcConfig config;

	@Inject
	private ItemManager itemManager;

	@Inject
	private ConfigManager configManager;

	// UI Panels
	@Inject
	private ClientToolbar clientToolbar;
	private MaxHitCalcPanel panel;
	private NavigationButton navButton;

	//
	private MaxHit maxHits;
	private MaxSpec maxSpecs;
	private MaxAgainstType maxAgainstTypes;
	private MaxSpecAgainstType maxSpecsAgainstTypes;

	// Public Max Hit variables, calculated when Equipment changes
	public int maxHit = 0;
	public int maxSpec = 0;
	public int maxVsType = 0;
	public int maxSpecVsType = 0;

	// Variable to check custom "gamestate"
	private boolean gameReady; // false before logged-in screen, true once logged-in screen closes, reset on logout

	// Variables for Currently interacting NPC
	public String selectedNPCName;
	public int selectedNPCExpiryTime = Integer.MAX_VALUE;
	boolean npcSelectedByPanel = false;
	boolean npcResetByPanel = false;

	// Vars for Calculations
	public int NPCSize = 1;
	boolean npcSizeSettingChanged = false;

	public BlowpipeDartType selectedDartType = BlowpipeDartType.MITHRIL;
	boolean dartSettingChanged = false;




//	DEBUG
//	@Subscribe
//	public void onChatMessage(ChatMessage chatMessageReceived)
//	{
//		if(chatMessageReceived.getMessage().equals("!Allstyles"))
//		{
//			System.out.println("================S===============");
//			int[] weaponStyles = client.getEnum(EnumID.WEAPON_STYLES).getIntVals();
//
//			for(int i = 0; i < weaponStyles.length; i++)
//			{
//				System.out.println("i: " + i + "; WS: " + weaponStyles[i]);
//			}
//			System.out.println("================E===============");
//		}
//
//		if(chatMessageReceived.getMessage().equals("!Getstyle"))
//		{
//			int attackStyleID = client.getVarpValue(VarPlayer.ATTACK_STYLE);
//			int weaponTypeID = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
//
//			System.out.println("=================S==================");
//			System.out.println("WTID: " + weaponTypeID);
//			System.out.println("ASID: " + attackStyleID);
//			System.out.println("=================E==================");
//		}
//	}

	@Provides
	MaxHitCalcConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(MaxHitCalcConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(pluginOverlay);

		// Check if plugin started while game is running
		if (client.getGameState().equals(GameState.LOGGED_IN))
		{
			gameReady = true; // Set true if game is logged in and ready
		}
		else
		{
			gameReady = false; // Set false on normal runelite boot
		}

		maxHits = new MaxHit(this, config, itemManager, client);
		maxSpecs = new MaxSpec(this, config, itemManager, client);
		maxAgainstTypes = new MaxAgainstType(this, config, itemManager, client);
		maxSpecsAgainstTypes = new MaxSpecAgainstType(this, config, itemManager, client);


		// UI Startup
		panel = injector.getInstance(MaxHitCalcPanel.class);
		panel.init(this, config);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

		navButton = NavigationButton.builder()
				.tooltip("Max Hit Calc")
				.icon(icon)
				.priority(7)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(pluginOverlay);

		panel.deinit();
		clientToolbar.removeNavigation(navButton);
		panel = null;
		navButton = null;
	}

	// On Widget Closed, check for when login screen is closed
	@Subscribe
	public void onWidgetClosed(WidgetClosed widget)
	{
		if (widget.getGroupId() == InterfaceID.WELCOME_SCREEN) // "Click to play" screen interface id = 378
		{
			gameReady = true; // Set as soon as user closes welcome screen
			calculateMaxes();
		}
	}

	// Un-ready when logged out.
	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		// On return to login screen, gameReady = false
		if (event.getGameState().equals(GameState.LOGIN_SCREEN))
		{
			gameReady = false;
		}
	}

	// OnItemContainerChanged, waiting for equipment container
	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		// On Item Equip/de-equip
		if(event.getContainerId() == InventoryID.WORN) // Equipment Container ID
		{
			calculateMaxes();
		}
	}

	// OnVarbitChanged, waiting for change in prayer, attack style, or selected spell
	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if(!gameReady)
		{
			// Fix for potential out-of-order startup problems (logging in without welcome screen)
			if (client.getGameState() == GameState.LOGGED_IN)
			{
				gameReady = true;
			}
			else
			{
				return; // do nothing, before you can see the game
			}
		}

//		System.out.println("Varplayer: " + event.getVarpId());
//		System.out.println("Varbit: " + event.getVarbitId());
//		System.out.println("Varbit value: " + event.getValue());

		// On prayer changed: 83 = normal prayerbook
		if (event.getVarpId() == VarPlayerID.PRAYER0)
		{
			calculateMaxes();
		}

		// On attack style changed
		if (event.getVarpId() == VarPlayerID.COM_MODE) // Varplayer: Attack Style
		{
			calculateMaxes();
		}

		// On selected Spell changed
		if (event.getVarbitId() == VarbitID.AUTOCAST_SPELL)
		{
			calculateMaxes();
		}

		// On soul stack changed
		if (event.getVarpId() == VarPlayerID.SOULREAPER_STACKS) // Varplayer: Soul Stack
		{
			calculateMaxes();
		}

		// On Charge Spell Buff Start/End
		if(event.getVarpId() == VarPlayerID.MAGEARENA_CHARGE) // Varplayer: Charge God Spell
		{
			calculateMaxes();
		}
	}

	// OnStatChanged, waiting for skill changes, boosted or levelled
	@Subscribe
	public void onStatChanged(StatChanged event)
	{
		// On Strength Changed
		if(event.getSkill() == Skill.STRENGTH)
		{
			calculateMaxes();
		}
		// On Ranged Changed
		if(event.getSkill() == Skill.RANGED)
		{
			calculateMaxes();
		}
		// On Magic Changed
		if(event.getSkill() == Skill.MAGIC)
		{
			calculateMaxes();
		}
		// On HP Changed
		if(event.getSkill() == Skill.HITPOINTS)
		{
			calculateMaxes();
		}
	}

	// On config Changed, run calculations
	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		// Only update for this plugin!
		if(event.getGroup().contains("MaxHitCalc"))
		{
			if(gameReady)
			{
				clientThread.invoke(this::calculateMaxes);
			}
		}
	}

	// Get Selected NPC from interaction
	@Subscribe
	public void onInteractingChanged(InteractingChanged interaction)
	{
		// Verify interaction is between user and npc
		if(interaction.getSource() != null)
		{
			// Verify source == local player
			String localPlayerName = client.getLocalPlayer().getName();
			String sourceName = interaction.getSource().getName();

			if(localPlayerName.equals(sourceName))
			{
				if(interaction.getTarget() != null)
				{
					NPC rawNPC = (NPC)interaction.getTarget();

					if(rawNPC != null)
					{
						// Do nothing for combat dummy or bankers
						if(!rawNPC.getName().toLowerCase().contains("combat dummy") && !rawNPC.getName().toLowerCase().contains("banker"))
						{
							if(config.timeToWaitBeforeResettingSelectedNPC() > 0)
							{
								selectedNPCExpiryTime = client.getTickCount() + (int)((config.timeToWaitBeforeResettingSelectedNPC() * 60)/0.6);
							}

							// Get necessary vars: name and size
							selectedNPCName = rawNPC.getComposition().getName();
							NPCSize = Math.max(1, rawNPC.getComposition().getSize()); // enforce to 1, incase of error

							panel.setNPCviaPlugin();

							calculateMaxes();
						}
					}
				}
			}
		}
	}

	// After certain amount of ticks, clear clickedNPC
	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		// If NPC is selected, wait for time to expire to deselect it
		if(selectedNPCName != null)
		{
			if (selectedNPCExpiryTime < client.getTickCount() && config.timeToWaitBeforeResettingSelectedNPC() != 0)
			{
				selectedNPCName = null;
				NPCSize = 1;
				selectedNPCExpiryTime = Integer.MAX_VALUE; // Set higher than tick count
				panel.resetNPCviaPanel();
				calculateMaxes();
			}
		}

		// Check flags set by panel
		// Update tick after panel settings are changed
		if(npcSizeSettingChanged)
		{
			calculateMaxes();
			npcSizeSettingChanged = false;
		}

		if(dartSettingChanged)
		{
			calculateMaxes();
			configManager.setConfiguration("MaxHitCalc", "blowpipeDartType", selectedDartType);
			dartSettingChanged = false;
		}

		if(npcSelectedByPanel)
		{
			calculateMaxes();
			npcSelectedByPanel = false;
		}

		if (npcResetByPanel)
		{
			calculateMaxes();
			npcResetByPanel = false;
		}
	}

	// Calculates all panel max hits.
	public void calculateMaxes()
	{
		// Calculate Normal Max Hits
		maxHit = (int)Math.floor(maxHits.calculate(false));

		// Calculate Special Attack Max Hit
		maxSpec = (int)Math.floor(maxSpecs.calculate());
		if(config.displayMultiHitWeaponsAsOneHit())
		{
			int multiHitSpec = maxSpecs.getSpecMultiHit(maxSpec);
			if(multiHitSpec != 0)
			{
				maxSpec = multiHitSpec;
			}
		}

		// Calculate Max Hit vs Types of NPCs
		maxVsType = (int)Math.floor(maxAgainstTypes.calculate());


		// Calculate Special Attack Max Hit vs Types of NPCs
		maxSpecVsType = (int)Math.floor(maxSpecsAgainstTypes.calculate());
		if(config.displayMultiHitWeaponsAsOneHit())
		{
			int multiHitSpec = maxSpecs.getSpecMultiHit(maxSpecVsType);
			if(multiHitSpec != 0)
			{
				maxSpecVsType = multiHitSpec;
			}
		}
	}
}

/* MaxHitCalcOverlay.java
 * Code for plugin main display panel and tooltip.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Menu;
import net.runelite.api.MenuEntry;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.widgets.*;
import net.runelite.api.Item;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.game.ItemStats;
import net.runelite.client.game.ItemManager;
import javax.inject.Inject;
import java.awt.*;
import java.util.List;

public class MaxHitCalcOverlay extends OverlayPanel
{
    private final MaxHitCalcPlugin plugin;
    private final MaxHitCalcConfig config;
    @Inject
    private TooltipManager tooltipManager;
    @Inject
    private ItemManager itemManager;
    @Inject
    private Client client;

    @Inject
    MaxHitCalcOverlay(MaxHitCalcPlugin plugin, MaxHitCalcConfig config)
    {
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_SCENE);

        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        panelComponent.getChildren().clear();

        // Don't Display if 0, or -1 (error)
        if(plugin.maxHit > 0 && config.showMaxHit())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Hit:")
                    .right(Integer.toString(plugin.maxHit))
                    .build());
        }

        // Don't Display if 0 (not useful) or turned off
        if(plugin.maxSpec > 0 && config.showSpec())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Spec Hit:")
                    .right(Integer.toString(plugin.maxSpec))
                    .build());
        }

        // Don't Display if 0 (not useful) or turned off
        if(plugin.maxVsType > 0 && config.showType())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Hit vs Type:")
                    .right(Integer.toString(plugin.maxVsType))
                    .build());
        }

        // Don't Display if 0 (not useful) or turned off
        if(plugin.maxSpecVsType > 0 && config.showSpecVsType())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Max Spec vs Type:")
                    .right(Integer.toString(plugin.maxSpecVsType))
                    .build());
        }

        // Tooltip for Prediction
        if (config.showPredictionTooltip())
        {
            // Check for mouse
            if(this.getBounds().contains(
                client.getMouseCanvasPosition().getX(),
                client.getMouseCanvasPosition().getY()))
            {
                String tooltipString = predictedMaxHitTooltip();

                // Check if useful
                if(tooltipString != null)
                {
                    // Display tooltip
                    tooltipManager.add(new Tooltip(tooltipString));
                }
            }
        }

        // Bank & Inventory Item Tooltip
        if (config.showInventoryTooltip() || config.showBankTooltip())
        {
            getInventoryMaxHitTooltip(plugin.maxHit);
        }

        // Spellbook Spell Tooltip
        if (config.showSpellbookTooltip())
        {
            getSpellbookMaxHitTooltip();
        }

        // Autocast Selection Tooltip
        if(config.showAutocastSelectionTooltip())
        {
            getAutocastSelectionMaxHitTooltip();
        }

        return super.render(graphics);
    }

    private String predictedMaxHitTooltip()
    {
        PredictNextMax predictNextMaxes = new PredictNextMax(plugin, config, itemManager, client);
        List<Object> prediction = predictNextMaxes.predict();

        String result = "Next Max Hit at: </br>";

        if (prediction.get(0).equals("melee"))
        {
            result += prediction.get(1) + " Strength Levels </br>" + prediction.get(2) + " Strength Bonus </br>" + (int)((double)prediction.get(3) * 100) + "% Prayer Bonus";
            return result;
        }
        else if (prediction.get(0).equals("ranged"))
        {
            result += prediction.get(1) + " Ranged Levels </br>" + prediction.get(2) + " Ranged Strength Bonus </br>" + (int)((double)prediction.get(3) * 100) + "% Prayer Bonus";
            return result;
        }
        else if (prediction.get(0).equals("magic"))
        {
            // Magic Level not always used for max hit
            if (!prediction.get(1).equals(0))
            {
                result += prediction.get(1) + " Magic Levels </br>";
            }

            // Magic Damage Bonus always used for max hit
            result += (int)((double)prediction.get(2) * 100) + "% Magic Damage Bonus";

            return result;
        }
        else
        {
            return null;
        }
    }

    private void getInventoryMaxHitTooltip(int maxHit)
    {
        // Tooltip on item in inventory
        Menu clientMenu = client.getMenu();
        MenuEntry[] menu = clientMenu.getMenuEntries();
        int menuSize = menu.length;
        if (menuSize == 0)
        {
            return;
        }

        // Get Inventory
        MenuEntry entry = menu[menuSize - 1];
        Widget widget = entry.getWidget();
        if (widget == null)
        {
            return;
        }

        // Get Hovered Item
        int itemID = -1;
        // Check if inventory item
        if(config.showInventoryTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.INVENTORY) // Inventory Interface ID
            {
                itemID = widget.getItemId();
            }
        }
        // Check if Bank item
        if (config.showBankTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.BANKMAIN) // Bank Interface ID
            {
                itemID = widget.getItemId();
            }
        }
        // Check if "Bank Invetory" Item, shows with either option true
        if (config.showInventoryTooltip() || config.showBankTooltip())
        {
            if (WidgetUtil.componentToInterface(widget.getId()) == InterfaceID.BANKSIDE) // Bank Inventory Interface ID
            {
                itemID = widget.getItemId();
            }
        }


        // Prepare Tooltip
        if (itemID != -1)
        {
            ItemStats stats = itemManager.getItemStats(itemID);
            if(stats != null)
            {
                if(stats.getEquipment() != null)
                {
                    int slotID = stats.getEquipment().getSlot();

                    InventoryItemMaxHit inventoryMaxHits = new InventoryItemMaxHit(plugin, config, itemManager, client);
                    int maxWithItem = (int) inventoryMaxHits.predict(itemID, slotID);

                    // If no error
                    if (maxWithItem != -1){
                        int deltaMax = maxWithItem - maxHit;

                        // Display depending on Negative or Positive Increase
                        String tooltip = "";
                        if(deltaMax < 0)
                        {
                            // Negative
                            tooltip = "Max hit: " + ColorUtil.wrapWithColorTag("-" + Math.abs(deltaMax), Color.RED);
                        }
                        else if (deltaMax > 0)
                        {
                            tooltip = "Max hit: " + ColorUtil.wrapWithColorTag("+" + deltaMax, Color.GREEN);
                        }
                        else
                        {
                            return;
                        }

                        tooltipManager.add(new Tooltip(tooltip));
                    }

                }

            }

        }
    }

    private void getSpellbookMaxHitTooltip()
    {
        // Tooltip on item in inventory
        Menu clientMenu = client.getMenu();
        MenuEntry[] menu = clientMenu.getMenuEntries();
        int menuSize = menu.length;
        if (menuSize == 0)
        {
            return;
        }

        // Get Spellbook
        MenuEntry entry = menu[menuSize - 1];
        Widget widget = entry.getWidget();
        if (widget == null)
        {
            return;
        }

        final int group = WidgetUtil.componentToInterface(widget.getId());
        int spellSpriteID = -1;

        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Group ID: " + group, ""); // DEBUG
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Spell Sprite ID: " + widget.getSpriteId(), ""); // DEBUG

        // Get Spell Sprite ID if actually in Spellbook
        if(group == InterfaceID.MAGIC_SPELLBOOK) // Spellbook Interface ID = 218
        {
            spellSpriteID = widget.getSpriteId();
        }

        // Prepare Tooltip
        if (spellSpriteID != -1)
        {
            // Get Combat Spell Info
            CombatSpell spell = CombatSpell.getSpellBySpriteID(spellSpriteID);

            // Check if spell is disabled
            if (spell == null && config.showTooltipOnDisabledSpells()){
                spell = CombatSpell.getSpellByDisabledSpriteID(spellSpriteID);
            }

            if(spell != null)
            {
                // Spell is a combat spell, continue with calc

                // Get Current Equipment
                Item[] playerEquipment;
                if (client.getItemContainer(InventoryID.WORN) != null ) // Equipment Inventory ID
                {
                    playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
                }
                else {
                    playerEquipment = null;
                }

                // Calculate Max Hit
                SpellbookSpellMaxHit spellbookMaxHits = new SpellbookSpellMaxHit(plugin, config, itemManager, client);
                int spellbookMaxHit = (int)spellbookMaxHits.calculateMagicMaxHit(playerEquipment, spell);

                // Error Check
                if (spellbookMaxHit > 0)
                {
                    String tooltip = "Max hit: " + spellbookMaxHit;
                    tooltipManager.add(new Tooltip(tooltip));
                }
            }
        }
    }

    private void getAutocastSelectionMaxHitTooltip()
    {
        // Tooltip on item in inventory
        Menu clientMenu = client.getMenu();
        MenuEntry[] menu = clientMenu.getMenuEntries();
        int menuSize = menu.length;
        if (menuSize == 0)
        {
            return;
        }

        // Get Autocast Selection Screen
        MenuEntry entry = menu[menuSize - 1];
        Widget widget = entry.getWidget();
        if (widget == null)
        {
            return;
        }

        final int group = WidgetUtil.componentToInterface(widget.getId());
        int spellSpriteID = -1;

        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Group ID: " + group, ""); // DEBUG
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Spell Sprite ID: " + widget.getSpriteId(), ""); // DEBUG

        // Get Spell Sprite ID if actually in Autocast Selection
        if(group == InterfaceID.AUTOCAST) // Autocast Interface = 201
        {
            spellSpriteID = widget.getSpriteId();
        }

        // Prepare Tooltip
        if (spellSpriteID != -1)
        {
            // Get Combat Spell Info
            CombatSpell spell = CombatSpell.getSpellBySpriteID(spellSpriteID);

            // Check if spell is disabled
            if (spell == null && config.showTooltipOnDisabledSpells()){
                spell = CombatSpell.getSpellByDisabledSpriteID(spellSpriteID);
            }

            if(spell != null)
            {
                // Spell is a combat spell, continue with calc

                // Get Current Equipment
                Item[] playerEquipment;
                if (client.getItemContainer(InventoryID.WORN) != null ) // Equipment Inventory ID
                {
                    playerEquipment = client.getItemContainer(InventoryID.WORN).getItems();
                }
                else
                {
                    playerEquipment = null;
                }

                // Calculate Max Hit
                SpellbookSpellMaxHit spellbookMaxHits = new SpellbookSpellMaxHit(plugin, config, itemManager, client);
                int spellbookMaxHit = (int)spellbookMaxHits.calculateMagicMaxHit(playerEquipment, spell);

                // Error Check
                if (spellbookMaxHit > 0)
                {
                    String tooltip = "Max hit: " + spellbookMaxHit;
                    tooltipManager.add(new Tooltip(tooltip));
                }
            }
        }
    }
}

/* InventoryItemMaxHit.java
 * Contains functions required for calculating max hit based on hovered equipment in inventory.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;

public class InventoryItemMaxHit
{
    protected MaxHitCalcConfig config;
    private MaxHit maxHits;
    protected ItemManager itemManager;
    protected Client client;

    InventoryItemMaxHit(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        this.config = config;
        this.maxHits = new MaxHit(plugin, config, itemManager, client);
        this.itemManager = itemManager;
        this.client = client;
    }

    // Crudely determines attack style based on an item's name
    private AttackStyle determineAttackStyle(int weaponID)
    {
        AttackStyle attackStyle;

        // Ranged
        if (client.getItemDefinition(weaponID).getName().contains("bow")
                || client.getItemDefinition(weaponID).getName().contains("Bow")
                || client.getItemDefinition(weaponID).getName().contains("chinchompa")
                || client.getItemDefinition(weaponID).getName().contains("Chinchompa")
                || client.getItemDefinition(weaponID).getName().contains("ballista")
                || client.getItemDefinition(weaponID).getName().contains("dart")
                || client.getItemDefinition(weaponID).getName().contains("knife")
                || client.getItemDefinition(weaponID).getName().contains("thrownaxe")
                || client.getItemDefinition(weaponID).getName().contains("Toktz-xil-ul")
                || client.getItemDefinition(weaponID).getName().contains("blowpipe")
                || client.getItemDefinition(weaponID).getName().contains("Tonalztics of ralos")
                || client.getItemDefinition(weaponID).getName().contains("Eclipse atlatl")
                || client.getItemDefinition(weaponID).getName().contains("Hunter's spear"))
        {
            attackStyle = AttackStyle.RANGING;
        }
        // Magic
        else if (client.getItemDefinition(weaponID).getName().contains("sceptre")
                || client.getItemDefinition(weaponID).getName().contains("staff")
                || client.getItemDefinition(weaponID).getName().contains("Trident")
                || client.getItemDefinition(weaponID).getName().contains("Tumeken's shadow")
                || client.getItemDefinition(weaponID).getName().contains("Staff")
                || client.getItemDefinition(weaponID).getName().contains("wand")
                || client.getItemDefinition(weaponID).getName().contains("crozier")
                || client.getItemDefinition(weaponID).getName().contains("Void knight mace")
                || client.getItemDefinition(weaponID).getName().contains("Blue moon spear"))
        {

            attackStyle = AttackStyle.CASTING;
        }
        else {
            // Assume Melee
            attackStyle = AttackStyle.AGGRESSIVE;
        }

        return attackStyle;
    }

    private Item[] changeEquipment(Item[] currentEquipment, int itemID, int slotID)
    {
        Item[] newEquipment = new Item[14];

        for(int i = 0; i < newEquipment.length; i++)
        {
            if(currentEquipment != null)
            {
                if(i < currentEquipment.length)
                {
                    if (currentEquipment[i] != null)
                    {
                        newEquipment[i] = currentEquipment[i]; // Set new slot item to old slot item
                    }
                }
            }

            if (newEquipment[i] == null)
            {
                newEquipment[i] = new Item(-1, 1);
            }
        }

        newEquipment[slotID] = new Item(itemID, 1);

        return newEquipment;
    }


    /**
     * Predicts max hit of a given item if it is equipped.
     *
     * @param itemID int of Item ID to do prediction on
     * @param slotID int of slot the item will replace
     * @return Max Hit Prediction as Double
     */
    public double predict(int itemID, int slotID)
    {
        // Initialize Variables
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type
        AttackStyle attackStyle = null;

        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Determine if Attack Style is correct
        if(slotID == 3)
        {
            // IS A WEAPON
            attackStyle = determineAttackStyle(itemID);
        }
        else
        {
            // Get Current Attack Style
            AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
            attackStyle = weaponAttackStyles[attackStyleID];
        }

        // Get corrected slot ID if player is not fully equipped
        //slotID = InventoryItemMaxHit.getCorrectedSlotID(client, slotID);

        // Change equipment slot to new item
        playerEquipment = changeEquipment(playerEquipment, itemID, slotID);

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            return maxHits.calculateMeleeMaxHit(playerEquipment, attackStyle, attackStyleID, false);
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            return maxHits.calculateRangedMaxHit(playerEquipment, attackStyle, attackStyleID);
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            double magicMaxHit = maxHits.calculateMagicMaxHit(playerEquipment, attackStyle);

            // If -1, error, skip
            if (magicMaxHit > -1){
                return magicMaxHit;
            }
        }

        return -1;

    }
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// From AttackStyles RuneLite plugin
// Located at: https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/attackstyles/WeaponType.java
// or net.runelite.client.plugins.attackstyles.AttackStyle

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EnumID;
import net.runelite.api.ParamID;
import net.runelite.api.StructComposition;

import static com.maxhitcalc.AttackStyle.*;

public class WeaponType
{
    // Modified From runelite.client.plugins.attackstyles.AttackStyle
    protected static AttackStyle[] getWeaponTypeStyles(Client client, int weaponType)
    {
        // Keris partisan returns 30; values can only be from 0-28 ?
        if (weaponType == 30)
            weaponType = 17; // set to equivalent weapon type; accurate, aggr, aggr, defensive

        // Blue moon spear returns 22; enum undefined at 22, change to regular bladed spear: 21
        if (weaponType == 22)
            weaponType = 21;

        int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);
        int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

        AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
        int i = 0;
        for (int style : weaponStyleStructs)
        {
            StructComposition attackStyleStruct = client.getStructComposition(style);
            String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);

            AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
            if (attackStyle == OTHER)
            {
                // "Other" is used for no style
                ++i;
                continue;
            }

            // "Defensive" is used for Defensive and also Defensive casting
            if (attackStyle == DEFENSIVE)
            {
                // Powered Staves Check, has "defensive" but should be "defensive casting"
                if (weaponType == 24)
                    attackStyle = DEFENSIVE_CASTING;
            }

            styles[i++] = attackStyle;
        }
        return styles;
    }

}
/* MaxSpec.java
 * Contains the function for getting the damage bonus from special weapons.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.game.ItemManager;

/**
 * Contains functions for calculating max hit from a special attack weapon.
 */
public class MaxSpec
{
    private MaxHitCalcConfig config;
    private MaxHit maxHits;
    private ItemManager itemManager;
    private Client client;

    MaxSpec(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        this.config = config;
        this.maxHits = new MaxHit(plugin, config, itemManager, client);
        this.itemManager = itemManager;
        this.client = client;
    }

    double getSpecWeaponStat(Item[] playerEquipment)
    {
        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String ammoItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMMO);

        // Check if we even have a spec weapon
        // Melee Checks
        if(weaponName.contains("Armadyl godsword"))
        {
            return 1.375;
        }

        if(weaponName.contains("Ancient godsword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Bandos godsword"))
        {
            return 1.21;
        }

        if(weaponName.contains("Saradomin godsword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Zamorak godsword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Saradomin sword"))
        {
            return 1.1;
        }

        if(weaponName.contains("Dragon dagger"))
        {
            return 1.15;
        }

        if(weaponName.contains("Dragon sword"))
        {
            return 1.25;
        }

        if(weaponName.contains("Dragon halberd"))
        {
            return 1.1;
        }

        if(weaponName.contains("Crystal halberd"))
        {
            if(!weaponName.contains("(basic)") && !weaponName.contains("(attuned)") && !weaponName.contains("(perfected)"))
            {
                return 1.1;
            }
        }

        if(weaponName.contains("Barrelchest"))
        {
            return 1.1;
        }

        if(weaponName.contains("Dragon hasta"))
        {
            return 1.0 + (0.5 * ((double)client.getVarpValue(VarPlayerID.SA_ENERGY) /1000)); // Varplayer: Special Attack Percent
        }

        if(weaponName.contains("Dragon longsword"))
        {
            return 1.25;
        }

        if(weaponName.contains("Dragon mace"))
        {
            return 1.5;
        }

        if(weaponName.contains("Dragon warhammer"))
        {
            return 1.5;
        }

        if(weaponName.contains("Rune claws"))
        {
            return 1.1;
        }

        if(weaponName.contains("Abyssal dagger"))
        {
            return 0.85;
        }

        if(weaponName.contains("Abyssal bludgeon"))
        {
            double currentPrayer = client.getBoostedSkillLevel(Skill.PRAYER);
            double totalPrayer = client.getRealSkillLevel(Skill.PRAYER);
            return (1 +(0.005 * (totalPrayer - currentPrayer)));
        }

        if(weaponName.contains("Saradomin's blessed sword"))
        {
            return 1.25;
        }

        if (weaponName.contains("Osmumten's fang"))
        {
            return 1.16666667;
        }

        if(weaponName.contains("Voidwaker"))
        {
            return 1.5;
        }

        if(weaponName.contains("Vesta's longsword"))
        {
            return 1.20;
        }

        if(weaponName.contains("Statius's warhammer"))
        {
            return 1.25;
        }

        if(weaponName.contains("Soulreaper axe"))
        {
            return 1 + maxHits.getSoulStackBonus();
        }

        if(weaponName.contains("Dual macuahuitl"))
        {
            return 1.25;
        }

        // Ranged Checks
        if(weaponName.contains("Dark bow"))
        {
            if(ammoItemName.contains("Dragon arrow"))
            {
                return 1.5;
            }
            else if (ammoItemName.contains("arrow"))
            {
                return 1.3;
            }
        }
        if(weaponName.contains("Zaryte crossbow"))
        {
            if(ammoItemName.contains("bolts (e)"))
            {
                return 1.1;
            }
        }
        if(weaponName.contains("crossbow"))
        {
            if(ammoItemName.contains("Diamond bolts (e)"))
            {
                return 1.15;
            }

            if(ammoItemName.contains("Dragonstone bolts (e)"))
            {
                return 1.45;
            }

            if(ammoItemName.contains("Onyx bolts (e)"))
            {
                return 1.15;
            }

            if(ammoItemName.contains("Opal bolts (e)"))
            {
                return 1.25;
            }
        }

        if(weaponName.contains("Morrigan's throwing axe"))
        {
            return 1.25;
        }

        if(weaponName.contains("Webweaver bow"))
        {
            return 0.4;
        }

        if(weaponName.contains("Toxic blowpipe"))
        {
            return 1.5;
        }

        return 0; // Not a spec weapon with a damage boost
    }

    // Returns the maximum hit of a spec weapon that hits multiple times in one move.
    // Returns 0 if not a multi hit spec weapon.
    public int getSpecMultiHit(int hit)
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);

        // Melee Double Hit Spec Weapons
        if(weaponName.contains("Dragon dagger"))
        {
            return hit * 2;
        }

        if(weaponName.contains("Dragon claws"))
        {
            int first = hit - 1;
            int second = (hit - (hit/2)) - 1;
            int third = (hit - ((hit*3/4))) - 1;
            int fourth = third + 1;

            // Debug
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "First: " + first, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Second: " + second, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Third: " + third, null);
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Fourth: " + fourth, null);

            return first + second + third + fourth;
        }

        if(weaponName.contains("Abyssal dagger"))
        {
            return hit * 2;
        }

        if(weaponName.contains("Saradomin sword"))
        {
            return hit + 16;
        }

        // Range Double Hit Spec Weapons
        if(weaponName.contains("Magic shortbow"))
        {
            return hit * 2;
        }

        if (weaponName.contains("Dragon knife"))
        {
            return hit * 2;
        }

        if(weaponName.contains("Webweaver bow"))
        {
            return hit * 4;
        }

        if(weaponName.contains("Burning claws"))
        {
            return hit * 3;
        }

        // else
        return 0;
    }

    /**
     * Calculates Max Hit of a Special Attack.
     *
     * @return Max Hit of Special Attack as Double
     */
    public double calculate()
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Get Config Settings
        boolean doubleHitSetting = config.displayMultiHitWeaponsAsOneHit();

        // Get Spec modifier
        double specialAttackWeapon = this.getSpecWeaponStat(playerEquipment);

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Spec Modifier: " + specialAttackWeapon, null);

        double maxHit = maxHits.calculate(true);
        if(specialAttackWeapon != 0)
        {
            // Get Max hit then calculate Spec
            double maxSpecHit = Math.floor(maxHit) * specialAttackWeapon;

            return maxSpecHit;
        }
        else if (doubleHitSetting && (this.getSpecMultiHit((int)Math.floor(maxHit)) != 0))
        {
            // Niche cases where Special Attack does not increase Damage, but does hit twice. E.g: Dragon Knives, Magic Shortbow
            return maxHit;
        }

        return 0; // No spec attack on weapon
    }
}

/* CombatSpell.java
 * Separates spells by SpriteID. Useful for getting the selected auto-cast spell.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import lombok.Getter;

import java.util.ArrayList;

/**
 * Contains definitions of combat spells and functions for retrieving them.
 * Selected Autocast Varbit is Varbit 276
 *
 *
 */
public enum CombatSpell
{
    // In order of autocast varbit
    WIND_STRIKE(1, 15, 65, "WIND STRIKE", 1,2, "standard", SpellType.Air, 1),
    WATER_STRIKE(2, 17, 67, "WATER STRIKE", 5,4, "standard", SpellType.Water, 1),
    EARTH_STRIKE(3, 19, 69, "EARTH STRIKE", 9,6, "standard", SpellType.Earth, 1),
    FIRE_STRIKE(4, 21, 71, "FIRE STRIKE", 13,8, "standard", SpellType.Fire, 1),
    WIND_BOLT(5,23, 73, "WIND BOLT", 17,9, "standard", SpellType.Air,2),
    WATER_BOLT(6,26, 76, "WATER BOLT", 23,10, "standard", SpellType.Water, 2),
    EARTH_BOLT(7,29, 79, "EARTH BOLT", 29,11, "standard", SpellType.Earth, 2),
    FIRE_BOLT(8,32, 82, "FIRE BOLT", 35,12, "standard", SpellType.Fire, 2),
    WIND_BLAST(9,35, 85, "WIND BLAST", 41,13, "standard", SpellType.Air,3),
    WATER_BLAST(10,38, 88, "WATER BLAST",47,14, "standard", SpellType.Water, 3),
    EARTH_BLAST(11,40, 90, "EARTH BLAST", 53,15, "standard", SpellType.Earth, 3),
    FIRE_BLAST(12,44, 94, "FIRE BLAST", 59,16, "standard", SpellType.Fire, 3),
    WIND_WAVE(13,46, 96, "WIND WAVE", 62,17, "standard", SpellType.Air,4),
    WATER_WAVE(14,48, 98, "WATER WAVE", 65,18, "standard", SpellType.Water, 4),
    EARTH_WAVE(15,51, 101, "EARTH WAVE", 70,19, "standard", SpellType.Earth, 4),
    FIRE_WAVE(16,52, 102, "FIRE WAVE", 75,20, "standard", SpellType.Fire, 4),

    CRUMBLE_UNDEAD(17,34, 84, "CRUMBLE UNDEAD", 39,15, "standard",0),
    MAGIC_DART(18, 324, 374, "MAGIC DART", 50,10, "standard",0),
    CLAWS_OF_GUTHIX(19, 60, 110, "CLAWS OF GUTHIX", 60,20, "standard",0),
    FLAMES_OF_ZAMORAK(20, 59, 109, "FLAMES OF ZAMORAK", 60,20, "standard",0),

    SMOKE_RUSH(31, 329, 379, "SMOKE RUSH", 50,13, "ancients",0),
    SHADOW_RUSH(32, 337, 387, "SHADOW RUSH", 52,14, "ancients",0),
    BLOOD_RUSH(33,333, 383, "BLOOD RUSH", 56,15, "ancients",0),
    ICE_RUSH(34,325, 375, "ICE RUSH", 58,16, "ancients",0),
    SMOKE_BURST(35, 330, 380, "SMOKE BURST", 62,17, "ancients",0),
    SHADOW_BURST(36, 338, 388, "SHADOW BURST", 64,18, "ancients",0),
    BLOOD_BURST(37, 334, 384, "BLOOD BURST", 68,21, "ancients",0),
    ICE_BURST(38, 326, 381, "ICE BURST", 70,22, "ancients",0),
    SMOKE_BLITZ(39, 331, 389, "SMOKE BLITZ", 74,23, "ancients",0),
    SHADOW_BLITZ(40, 339, 389, "SHADOW BLITZ", 76,24, "ancients",0),
    BLOOD_BLITZ(41, 335, 385, "BLOOD BLITZ", 80,25, "ancients",0),
    ICE_BLITZ(42, 327, 377, "ICE BLITZ", 82,26, "ancients",0),
    SMOKE_BARRAGE(43, 332, 382, "SMOKE BARRAGE", 86,27, "ancients",0),
    SHADOW_BARRAGE(44, 340, 390, "SHADOW BARRAGE", 88,28, "ancients",0),
    BLOOD_BARRAGE(45, 336, 386, "BLOOD BARRAGE", 92,29, "ancients",0),
    ICE_BARRAGE(46, 328, 378, "ICE BARRAGE", 94,30, "ancients",0),
    IBAN_BLAST(47, 53, 103, "IBAN BLAST", 50,25, "standard",0),
    WIND_SURGE(48, 362, 412, "WIND SURGE", 81,21, "standard",SpellType.Air,5),
    WATER_SURGE(49, 363, 413, "WATER SURGE", 85,22, "standard",SpellType.Water,5),
    EARTH_SURGE(50,364, 414, "EARTH SURGE", 90,23, "standard",SpellType.Earth,5),
    FIRE_SURGE(51, 365, 415, "FIRE SURGE", 95,24, "standard",SpellType.Fire,5),
    SARADOMIN_STRIKE(52, 61, 111, "SARADOMIN STRIKE", 60, 20, "standard",0),
    INFERIOR_DEMONBANE(53,1302, 1321, "INFERIOR DEMONBANE", 44,16, "arceuss",0),
    SUPERIOR_DEMONBANE(54, 1303, 1322, "SUPERIOR DEMONBANE", 62,23, "arceuss",0),
    DARK_DEMONBANE(55, 1304, 1323, "DARK DEMONBANE", 82,30, "arceuss",0),
    GHOSTLY_GRASP(56,1267, 1292, "GHOSTLY GRASP", 35,12, "arceuss",0),
    SKELETAL_GRASP(57,1268, 1293, "SKELETAL GRASP", 56,17, "arceuss",0),
    UNDEAD_GRASP(58, 1269, 1294, "UNDEAD GRASP", 79,24, "arceuss",0);


    @Getter
    private final int autocastVarbitValue;
    @Getter
    private final int spriteID;
    @Getter
    private final int disabledSpriteID;
    @Getter
    private final String name;
    @Getter
    private final int reqLevel;
    @Getter
    private final int baseDamage;
    @Getter
    private final String spellbook;
    @Getter
    private final SpellType spellType;
    @Getter
    private final int tier;

    /**
     * Gets a CombatSpell from a Varbit ID
     * @param value int, varbit value of spell
     * @return Spell, or null for failure
     */
    public static CombatSpell getSpellbyVarbitValue(int value)
    {
        for (CombatSpell spell : CombatSpell.values())
        {
            if(spell.autocastVarbitValue == value){
                return spell;
            }
        }

        // error, failure
        return null;
    }

    /**
     * Finds a CombatSpell based on sprite ID
     * @param spriteID int
     * @return Spell, or null for failure
     */
    public static CombatSpell getSpellBySpriteID(int spriteID)
    {
        for (CombatSpell spell : CombatSpell.values())
        {
            if(spell.spriteID == spriteID){
                return spell;
            }
        }

        // error, failure
        return null;
    }

    /**
     * Finds a CombatSpell based on its disabled sprite ID
     * @param spriteID int
     * @return Spell, or null for failure
     */
    public static CombatSpell getSpellByDisabledSpriteID(int spriteID)
    {
        // Spells that
        for (CombatSpell spell : CombatSpell.values())
        {
            if(spell.disabledSpriteID == spriteID){
                return spell;
            }
        }

        // error, failure
        return null;
    }

    /**
     * Returns if a CombatSpell has a Type
     */
    public boolean hasType(){
        if(this.spellType != SpellType.NoType)
            return true;

        return false;
    }

    public static CombatSpell[] getSpellsOfTier(int tier, String spellbook){
        ArrayList<CombatSpell> results = new ArrayList<>();

        for (CombatSpell spell : CombatSpell.values())
        {
            if (spell.getSpellbook().equals(spellbook))
            {
                if (spell.getTier() == tier)
                {
                    // found spell of correct tier and spellbook
                    results.add(spell);
                }
            }
        }

        return results.toArray(new CombatSpell[results.size()]);
    }

    CombatSpell(int autocastVarbitValue, int spriteID, int disabledSpriteID, String name, int reqLevel, int baseDamage, String spellbook, SpellType spellType, int tier)
    {
        this.autocastVarbitValue = autocastVarbitValue;
        this.spriteID = spriteID;
        this.disabledSpriteID = disabledSpriteID;
        this.name = name;
        this.reqLevel = reqLevel;
        this.baseDamage = baseDamage;
        this.spellbook = spellbook;
        this.spellType = spellType;
        this.tier = tier;
    }

    /**
     * Constructor: No type given
     */
    CombatSpell(int autocastVarbitValue, int spriteID, int disabledSpriteID, String name, int reqLevel, int baseDamage, String spellbook, int tier)
    {
        this.autocastVarbitValue = autocastVarbitValue;
        this.spriteID = spriteID;
        this.disabledSpriteID = disabledSpriteID;
        this.name = name;
        this.reqLevel = reqLevel;
        this.baseDamage = baseDamage;
        this.spellbook = spellbook;
        this.spellType = SpellType.NoType;
        this.tier = tier;
    }
}

/* MaxHit.java
 * Contains all functions necessary for calculating the normal max hit per attack type.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;

import java.util.ArrayList;
import java.util.List;

/**
 * Contains functions for calculating standard max hit.
 */
public class MaxHit {

    protected MaxHitCalcPlugin plugin;
    protected MaxHitCalcConfig config;
    protected ItemManager itemManager;
    protected Client client;

    MaxHit(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        this.plugin = plugin;
        this.config = config;
        this.itemManager = itemManager;
        this.client = client;
    }

    // Get Prayer Bonus for Max Hit Calculation
    protected double getPrayerBonus(AttackStyle weaponAttackStyle)
    {
        // Melee Prayers
        if(weaponAttackStyle == AttackStyle.ACCURATE || weaponAttackStyle == AttackStyle.AGGRESSIVE || weaponAttackStyle == AttackStyle.CONTROLLED || weaponAttackStyle == AttackStyle.DEFENSIVE)
        {
            // Burst of Strength
            if(client.getVarbitValue(VarbitID.PRAYER_BURSTOFSTRENGTH) == 1) return 1.05;

            // Superhuman Strength
            if(client.getVarbitValue(VarbitID.PRAYER_SUPERHUMANSTRENGTH) == 1) return 1.1;

            // Ultimate Strength
            if(client.getVarbitValue(VarbitID.PRAYER_ULTIMATESTRENGTH) == 1) return 1.15;

            // Chivalry
            if(client.getVarbitValue(VarbitID.PRAYER_CHIVALRY) == 1) return 1.18;

            // Piety
            if(client.getVarbitValue(VarbitID.PRAYER_PIETY) == 1) return 1.23;
        }

        // Ranged Prayers
        if(weaponAttackStyle == AttackStyle.RANGING || weaponAttackStyle == AttackStyle.LONGRANGE)
        {
            // Sharp Eye
            if(client.getVarbitValue(VarbitID.PRAYER_SHARPEYE) == 1) return 1.05;

            // Hawk Eye
            if(client.getVarbitValue(VarbitID.PRAYER_HAWKEYE) == 1) return 1.1;

            // Eagle Eye / Deadeye
            if(client.getVarbitValue(VarbitID.PRAYER_DEADEYE) == 1 || client.getVarbitValue(VarbitID.PRAYER_EAGLEEYE) == 1)
            {
                int deadeyeUnlocked = client.getVarbitValue(VarbitID.PRAYER_DEADEYE_UNLOCKED);

                //System.out.println("deadEyeUnlocked = " + deadeyeUnlocked);

                if (deadeyeUnlocked == 0)
                {
                    //System.out.println("Eagle Eye Active");
                    return 1.15;
                }
                else if (deadeyeUnlocked == 1)
                {
                    //System.out.println("Dead eye Active");
                    return 1.18;
                }
            }

            // Rigour
            if(client.getVarbitValue(VarbitID.PRAYER_RIGOUR) == 1) return 1.23;
        }

        return 1; // default
    }

    protected double getSoulStackBonus()
    {
        int soulStack = client.getVarpValue(VarPlayerID.SOULREAPER_STACKS);

        return 0.06 * soulStack;
    }

    // Get Attack Style Bonus for Melee or Ranged
    protected int getAttackStyleBonus(AttackStyle weaponAttackStyle, int attackStyleID)
    {
        // Return attack style bonus
        // Melee bonuses
        if (weaponAttackStyle.getName().equalsIgnoreCase("Aggressive")) return 3;

        if (weaponAttackStyle.getName().equalsIgnoreCase("Controlled")) return 1;

        // Ranged bonus
        if (weaponAttackStyle.getName().equalsIgnoreCase("RANGING"))
        {
            if(attackStyleID == 0) return 3;
        }

        return 0; // default
    }

    // Get Melee Strength Bonus from Weapon and armor
    protected double getMeleeStrengthBonus(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 0;

        double strengthBonus = 0;

        // Get Melee Strength Bonus of each equipped Item
        for (Item equipmentItem: playerEquipment)
        {
            if (equipmentItem != null)
            {
                if(equipmentItem.getId() != -1)
                {
                    int equipmentID = equipmentItem.getId();

                    // Ensure not null
                    if(itemManager.getItemStats(equipmentID) != null)
                    {
                        int equipmentStrengthStat = itemManager.getItemStats(equipmentID).getEquipment().getStr();

                        strengthBonus += equipmentStrengthStat;
                    }
                }
            }
        }

        return strengthBonus;
    }

    protected double getVoidMeleeBonus(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 1;

        // Get required items for void check
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Check for set bonus
        if (headItemName.contains("Void melee"))
        {
            if (glovesItemName.contains("Void"))
            {
                // Melee helm and gloves, check for elite or not
                if (bodyItemName.contains("Void"))
                {
                    if (legsItemName.contains("Void"))
                    {
                        // Normal void set
                        return 1.1;
                    }
                }
                else if (bodyItemName.contains("Elite void"))
                {
                    if(legsItemName.contains("Elite void"))
                    {
                        // Elite void set
                        return 1.1; // same for melee
                    }
                }
            }
        }

        // Void Set incomplete, no bonus
        return 1;
    }

    // Passive Melee Set effects
    protected List<Double> getMeleeSpecialBonusMultiplier(Item[] playerEquipment)
    {
        List<Double> specialBonusesToApply = new ArrayList<>();

        if (playerEquipment == null) return specialBonusesToApply;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String ammuletItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMULET);

        // SPECIAL BONUSES MUST BE ORDERED CORRECTLY.
        // Dharok's Set Check
        if (headItemName.contains("Dharok's"))
        {
            if(bodyItemName.contains("Dharok's"))
            {
                if(legsItemName.contains("Dharok's"))
                {
                    if(weaponItemName.contains("Dharok's"))
                    {
                        // Passed Check, Dharok's Set Equipped, Apply Effect
                        double baseHP = client.getRealSkillLevel(Skill.HITPOINTS);
                        double currentHP = client.getBoostedSkillLevel(Skill.HITPOINTS);
                        double dharokBonus = ((((baseHP - currentHP) / 100) * (baseHP / 100)));

                        specialBonusesToApply.add(dharokBonus);
                    }
                }
            }
        }

        // Obsidian Set Check
        if (headItemName.contains("Obsidian"))
        {
            if(bodyItemName.contains("Obsidian"))
            {
                if(legsItemName.contains("Obsidian"))
                {
                    if(weaponItemName.contains("ket") || weaponItemName.contains("xil"))
                    {
                        specialBonusesToApply.add(0.1);
                    }
                }
            }
        }

        // Berserker Necklace and Obisidian Melee Check
        if(weaponItemName.contains("ket") || weaponItemName.contains("xil"))
        {
            if(ammuletItemName.contains("Berserker"))
            {
                specialBonusesToApply.add(0.2);
            }
        }

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Special Bonus: " + specialBonus, null);

        return specialBonusesToApply;
    }

    // Calculate Melee Max Hit
    protected double calculateMeleeMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID, boolean isSpecialAttack)
    {
        // Calculate Melee Max Hit
        // Step 1: Calculate effective Strength
        int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
        double prayerBonus = getPrayerBonus(weaponAttackStyle);
        int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
        double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
        double soulStackBonus = getSoulStackBonus();
        double effectiveSoulStackLevel = 0;

        if (!isSpecialAttack)
        {
            effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);
        }

        double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

        // Step 2: Calculate the base damage
        double strengthBonus = getMeleeStrengthBonus(playerEquipment); // default 0

        double baseDamage = (0.5 + (effectiveStrength * ((strengthBonus + 64)/640)));
        double flooredBaseDamage = Math.floor(baseDamage);

        // Step 3: Calculate the bonus damage
        List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

        double maxHit = flooredBaseDamage;

        if(!specialBonusMultipliers.isEmpty())
        {
            for (double bonus: specialBonusMultipliers)
            {
                maxHit += Math.floor(maxHit * bonus);
            }
        }

        // Osmumten's Fang Decrease
        String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponName.contains("Osmumten's fang"))
        {
            maxHit = maxHit * 0.85 + 1;
        }

        // Colossal Blade Base Increase
        if(weaponName.contains("Colossal blade")){
            maxHit = maxHit + 2;
        }

        // Rat Default +10 damage Bonus
        if(weaponName.contains("Bone mace"))
        {
            maxHit = maxHit + 10;
        }

        // Complete
        return maxHit;
    }

    // Get Ranged Void Bonus for Elite and Normal Sets
    protected double getVoidRangedBonus(Item[] playerEquipment)
    {
        // Get required items for void check
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Check for set bonus
        if (headItemName.contains("Void ranger"))
        {
            if (glovesItemName.contains("Void"))
            {
                // Ranged helm and gloves, check for elite or not
                if (bodyItemName.contains("Void"))
                {
                    if (legsItemName.contains("Void"))
                    {
                        // Normal void set
                        return 1.1;
                    }
                }
                else if (bodyItemName.contains("Elite void"))
                {
                    if(legsItemName.contains("Elite void"))
                    {
                        // Elite void set
                        return 1.125;
                    }
                }
            }
        }

        // Void Set incomplete, no bonus
        return 1;
    }

    // Get Ranged Strength Bonus from Equipment
    protected double getRangedStrengthBonus(Item[] playerEquipment)
    {
        double rangedStrengthBonus = 0;

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Weapon Name: " + client.getItemDefinition(playerEquipment[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName(), null);

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        int weaponID = EquipmentItems.getItemIdInGivenSetSlot(playerEquipment, EquipmentInventorySlot.WEAPON);

        String ammoItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.AMMO);
        int ammoID = EquipmentItems.getItemIdInGivenSetSlot(playerEquipment, EquipmentInventorySlot.AMMO);

        String capeItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.CAPE);
        int capeID = EquipmentItems.getItemIdInGivenSetSlot(playerEquipment, EquipmentInventorySlot.CAPE);

        String quiverItemName;
        int quiverItemID;

        boolean skipAmmo = false;
        boolean calcWithMelee = false;

        // Cases to skip ammo: throwing weapons, crystal bow, blowpipe
        if (weaponItemName.contains("dart") || weaponItemName.contains("knife") || weaponItemName.contains("thrownaxe") || weaponItemName.contains("Toktz-xil-ul"))
        {
            // "Stackable" Throwing weapons
            skipAmmo = true;
        }
        else if(weaponItemName.contains("Morrigan's javelin") || weaponItemName.contains("Morrigan's throwing axe") || weaponItemName.contains("Mud pie"))
        {
            // Not Stackable Throwing Weapons
            skipAmmo = true;
        }
        else if (weaponItemName.contains("Crystal bow")
                || weaponItemName.contains("faerdhinen")
                || weaponItemName.contains("Webweaver")
                || weaponItemName.contains("Craw's"))
        {
            skipAmmo = true;
        }
        else if(weaponItemName.contains("blowpipe"))
        {
            skipAmmo = true;

            if(plugin.selectedDartType == BlowpipeDartType.ADAMANT)
            {
                rangedStrengthBonus += 17;
            }
            else if(plugin.selectedDartType == BlowpipeDartType.RUNE)
            {
                rangedStrengthBonus += 26;
            }
            else if(plugin.selectedDartType == BlowpipeDartType.AMETHYST)
            {
                rangedStrengthBonus += 28;
            }
            else if(plugin.selectedDartType == BlowpipeDartType.DRAGON)
            {
                rangedStrengthBonus += 35;
            }
            else
            {
                rangedStrengthBonus += 9; // default and lowest (mithril)
            }
        }
        else if(weaponItemName.contains("Tonalztics"))
        {
            skipAmmo = true;
        }
        else if(weaponItemName.contains("atlatl"))
        {
            skipAmmo = true;
            calcWithMelee = true;
        }
        else if(weaponItemName.contains("Hunter's spear"))
        {
            skipAmmo = true;
            calcWithMelee = true;
        }

        // Check Ammo type matches up with weapon
        if(!skipAmmo)
        {
            // Check if ammo type matches with weapon, otherwise skip ammo slot in calc
            if(ammoID != -1)
            {
                if(!EquipmentItems.doesAmmoMatchWeapon(ammoItemName, weaponItemName))
                {
                    // Ammo did not match weapon, skip ammo for calc
                    skipAmmo = true;
                }
            }


            // Quiver Check
//            if(capeItemName.toLowerCase().contains("quiver"))
//            {
//                quiverItemName = EquipmentItems.getQuiverItemName(client);
//                quiverItemID = EquipmentItems.getQuiverItemID(client);
//
//
////                if(!capeItemName.toLowerCase().contains("uncharged"))
////                {
////                    rangedStrengthBonus += 1; // Bonus range strength to ammo when Quiver is charged
////                }
//
//                if (ammoID != -1 && quiverItemID != -1)
//                {
//                    // determine if we use quiver's ammo, or default slot ammo, or Neither!
//
//                    if(weaponItemName.toLowerCase().contains("bow"))
//                    {
//                        if(ammoItemName.toLowerCase().contains())
//                    }
//                }
//                else if (ammoID == -1 && quiverItemID >= 0) {
//
//                }
//                else if(ammoID )
//            }
        }



        // Get Ranged Strength Bonus of each equipped Item
        for (Item equipmentItem: playerEquipment)
        {
            if (equipmentItem != null)
            {
                if(equipmentItem.getId() != -1)
                {
                    int equipmentID = equipmentItem.getId();

                    // Ensure not null
                    if(itemManager.getItemStats(equipmentID) != null)
                    {
                        if(!calcWithMelee)
                        {
                            int equipmentStrengthStat = itemManager.getItemStats(equipmentID).getEquipment().getRstr();

                            if (equipmentID != ammoID || !skipAmmo)
                            {
                                // If equipment ID == Ammo, skip if skipAmmo is true
                                rangedStrengthBonus += equipmentStrengthStat;
                            }
                        }
                        else
                        {
                            int equipmentStrengthStat = itemManager.getItemStats(equipmentID).getEquipment().getStr();

                            if (equipmentID != ammoID || !skipAmmo)
                            {
                                // If equipment ID == Ammo, skip if skipAmmo is true
                                rangedStrengthBonus += equipmentStrengthStat;
                            }
                        }

                    }
                }
            }
        }

        return rangedStrengthBonus;
    }

    // Get Gear Boost, for instance Crystal Armor set bonus
    protected double getRangeGearBoost(Item[] playerEquipment)
    {
        double damagePercentBonus = 1;

        // Get Required Item Names for checks
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);


        if (weaponItemName.contains("Crystal bow") || weaponItemName.contains("faerdhinen"))
        {
            // Crystal Armor Damage bonus
            if (headItemName.contains("Crystal helm"))
            {
                if(!headItemName.contains("(basic)")
                        || !headItemName.contains("(attuned)")
                        || !headItemName.contains("(perfected)"))
                {
                    damagePercentBonus += 0.025;
                }
            }

            if (bodyItemName.contains("Crystal body"))
            {
                if(!bodyItemName.contains("(basic)")
                        || !bodyItemName.contains("(attuned)")
                        || !bodyItemName.contains("(perfected)"))
                {
                    damagePercentBonus += 0.075;
                }
            }

            if (legsItemName.contains("Crystal legs"))
            {
                if(!legsItemName.contains("(basic)")
                        || !legsItemName.contains("(attuned)")
                        || !legsItemName.contains("(perfected)"))
                {
                    damagePercentBonus += 0.05;
                }
            }
        }

        return damagePercentBonus;
    }

    // Calculate Ranged Max Hit
    protected double calculateRangedMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        // Calculate Ranged Max Hit
        // Step 1: Calculate effective ranged Strength
        int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
        double prayerBonus = getPrayerBonus(weaponAttackStyle);
        int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
        double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

        double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

        // Step 2: Calculate the max hit
        double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment);
        double gearBonus = getRangeGearBoost(playerEquipment);

        double maxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

        // Step 3: Bonus damage from special attack and effects
        // Rat Default +10 damage Bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if(weaponItemName.contains("Bone shortbow"))
        {
            maxHit = maxHit + 10;
        }

        // Tonalztics of Ralos (uncharged) max hit is 75% of normal
        if(weaponItemName.contains("Tonalztics of ralos"))
        {
            maxHit = Math.floor(maxHit * 0.75); // unknown if flooring here causes miscalcs
            if(!weaponItemName.contains("(uncharged)"))
            {
                maxHit = maxHit * 2;
            }
        }

        return maxHit;
    }

    protected double getSpellBaseHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, double magicLevel)
    {
        double basehit = 0;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        String capeItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.CAPE);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Magic Weapon: " + client.getItemDefinition(playerItems[EquipmentInventorySlot.WEAPON.getSlotIdx()].getId()).getName(), null);

        // Powered Staff Check
        // Trident of the Seas
        if(weaponItemName.contains("of the seas"))
        {
            basehit = Math.max((Math.floor((Math.min(magicLevel, 125) - 15) / 3)), 1); // Corrected, thanks to Mod Ash
        }
        // Trident of the Swamp
        else if(weaponItemName.contains("of the swamp"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 6) / 3))), 3); // Corrected, thanks to Mod Ash
        }
        // Sanquinesti Staff
        else if(weaponItemName.contains("Sanguinesti"))
        {
            basehit = Math.max((Math.floor(((Math.min(magicLevel, 125) - 3) / 3))), 4); // Corrected, thanks to Mod Ash
        }
        // Thammaron's Sceptre
        else if(weaponItemName.contains("Thammaron's"))
        {
            basehit = (Math.floor(magicLevel/3) - 8);
        }
        // Accursed Sceptre
        else if(weaponItemName.contains("Accursed"))
        {
            basehit = (Math.floor(magicLevel/3) - 6);
        }
        // Tumeken's Shadow
        else if(weaponItemName.contains("Tumeken"))
        {
            basehit = (Math.floor(magicLevel/3) + 1);
        }
        // Warped sceptre
        else if(weaponItemName.contains("Warped sceptre"))
        {
            // Current Wiki Value
            basehit = Math.floor(((8*magicLevel)+96)/37);

            /* My math estimate
            if(magicLevel >= 99)
            {
                basehit = Math.floor((magicLevel/5) + 4.2);
            }
            else
            {
                basehit = Math.floor((magicLevel/5) + 3.6);
            }
            */
        }
        // Crystal staff (basic)
        else if(weaponItemName.contains("Crystal staff (basic)"))
        {
            basehit = 23;
        }
        // Crystal staff (attuned)
        else if(weaponItemName.contains("Crystal staff (attuned)"))
        {
            basehit = 31;
        }
        // Crystal staff (perfected)
        else if(weaponItemName.contains("Crystal staff (perfected)"))
        {
            basehit = 39;
        }
        // Corrupted staff (basic)
        else if(weaponItemName.contains("Corrupted staff (basic)"))
        {
            basehit = 23;
        }
        // Corrupted staff (attuned)
        else if(weaponItemName.contains("Corrupted staff (attuned)"))
        {
            basehit = 31;
        }
        // Corrupted staff (perfected)
        else if(weaponItemName.contains("Corrupted staff (perfected)"))
        {
            basehit = 39;
        }
        // Bone Staff
        else if(weaponItemName.contains("Bone staff"))
        {
            basehit = Math.floor(magicLevel/3) + 5;
        }
        // Autocasted Spell
        else
        {
            int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
            if (selectedSpellId == 0)
            {
                // no spell selected
                return -1; // error
            }

            CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId); // returns null as default

            // Debug
            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "MH: Selected Spell: " + selectedSpell, null);

            // Specific Selected Spell Cases
            if (selectedSpell == null)
            {
                //System.out.println("Error");
                return -1; // error
            }
            else
            {
                // Magic Dart Case
                if(selectedSpell == CombatSpell.MAGIC_DART)
                {
                    double magicDartDamage = Math.floor(magicLevel * ((double)1/10)) + 10;

                    basehit = magicDartDamage;
                }
                else
                {
                    // FIND TIER, FIND HIGHEST IN TIER
                    if (selectedSpell.getTier() == 0)
                    {
                        // NO TIER,
                        basehit = selectedSpell.getBaseDamage();
                    }
                    else
                    {
                        // GET TIER, Get highest tier in level
                        int spellTier = selectedSpell.getTier();
                        String spellbook = selectedSpell.getSpellbook();

                        CombatSpell[] spellsInTier = CombatSpell.getSpellsOfTier(spellTier, spellbook);

                        for(CombatSpell spell : spellsInTier)
                        {
                            if(magicLevel >= spell.getReqLevel())
                            {
                                if (basehit <= spell.getBaseDamage())
                                {
                                    // new highest found
                                    basehit = spell.getBaseDamage();
                                }
                            }
                        }

                        // Error, didn't find usable spell
                        if (basehit == 0)
                            return -1; // error
                    }


                }

                // God Spell Cases with Charge
                if((selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK) || (selectedSpell == CombatSpell.CLAWS_OF_GUTHIX) || (selectedSpell == CombatSpell.SARADOMIN_STRIKE))
                {
                    if (client.getVarpValue(VarPlayerID.MAGEARENA_CHARGE) > 0) // Varplayer: Charge God Spell
                    {
                        if(selectedSpell == CombatSpell.CLAWS_OF_GUTHIX &&
                                (capeItemName.toLowerCase().contains("guthix cape") ||  capeItemName.toLowerCase().contains("guthix max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.FLAMES_OF_ZAMORAK &&
                                (capeItemName.toLowerCase().contains("zamorak cape") || capeItemName.toLowerCase().contains("zamorak max cape")))
                        {
                            basehit = 30;
                        }
                        else if(selectedSpell == CombatSpell.SARADOMIN_STRIKE &&
                                (capeItemName.toLowerCase().contains("saradomin cape") || capeItemName.toLowerCase().contains("saradomin max cape")))
                        {
                            basehit = 30;
                        }
                        else
                        {
                            basehit = 20;
                        }
                    }
                    else
                    {
                        basehit = 20;
                    }
                }

                // Chaos Gauntlet Bonus Check
                if(selectedSpell.getName().toLowerCase().contains("bolt"))
                {
                    if (glovesItemName.toLowerCase().contains("chaos gauntlets"))
                    {
                        basehit += 3;
                    }
                }
            }
        }

        return basehit;
    }

    // Get Spell Info
    protected CombatSpell getSpell(){
        int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
        if (selectedSpellId == 0)
        {
            // no spell selected
            return null; // error
        }

        CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId); // returns null as default

        return selectedSpell;
    }

    protected double getMagicEquipmentBoost(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 1;

        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        double magicdamagebonus = 0;

        // Get Magic Strength Bonus of each equipped Item
        for (Item equipmentItem: playerEquipment)
        {
            if (equipmentItem != null)
            {
                if (equipmentItem.getId() != -1)
                {
                    int equipmentID = equipmentItem.getId();

                    double equipmentMagicBonusStat = 0;

                    // Ensure not null
                    if(itemManager.getItemStats(equipmentID) != null)
                    {
                        equipmentMagicBonusStat = itemManager.getItemStats(equipmentID).getEquipment().getMdmg();

                        magicdamagebonus += (equipmentMagicBonusStat/100);
                    }

                }
            }
        }

        // Get Void 2.5% bonus if necessary, otherwise +0
        magicdamagebonus += getVoidMagicBonus(playerEquipment);

        // Get Tumeken's Shadow Bonus
        if(weaponItemName.contains("Tumeken"))
        {
            magicdamagebonus *= 3;

            magicdamagebonus = Math.min(magicdamagebonus, 1);
        }

        // Get Virtus Robe's Damage Bonus for Ancient Magicks
        CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(client.getVarbitValue(VarbitID.AUTOCAST_SPELL));
        if(selectedSpell != null){
            if (selectedSpell.getName().toLowerCase().contains("smoke")
                    || selectedSpell.getName().toLowerCase().contains("shadow")
                    || selectedSpell.getName().toLowerCase().contains("blood")
                    || selectedSpell.getName().toLowerCase().contains("ice"))
            {
                // Get Item names
                String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
                String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
                String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);

                // Add bonus per robe
                if(headItemName.toLowerCase().contains("virtus"))
                {
                    magicdamagebonus += 0.03; // 1% added normally, add 3% to make total 4% bonus
                }

                if(bodyItemName.toLowerCase().contains("virtus"))
                {
                    magicdamagebonus += 0.03;
                }

                if(legsItemName.toLowerCase().contains("virtus"))
                {
                    magicdamagebonus += 0.03;
                }
            }
        }

        // Prayer Bonuses
        // Mystic Lore
        if(client.getVarbitValue(VarbitID.PRAYER_MYSTICLORE) == 1) magicdamagebonus += 0.01;

        // Mystic Might / Mystic Vigour
        if(client.getVarbitValue(VarbitID.PRAYER_MYSTICMIGHT) == 1 || client.getVarbitValue(VarbitID.PRAYER_MYSTICVIGOUR) == 1)
        {
            int vigourUnlocked = client.getVarbitValue(VarbitID.PRAYER_MYSTIC_VIGOUR_UNLOCKED);

            //System.out.println("MysticVigour = " + vigourUnlocked);

            if (vigourUnlocked == 0)
            {
                //System.out.println("Mystic Might Active");
                magicdamagebonus += 0.02;
            }
            else if (vigourUnlocked == 1)
            {
                //System.out.println("Mystic Vigour Active");
                magicdamagebonus += 0.03;
            }
        }

        // Augury
        if(client.getVarbitValue(VarbitID.PRAYER_AUGURY) == 1) magicdamagebonus += 0.04;


        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Bonus Magic Damage: " + magicdamagebonus*100 + "%", null);

        // Smoke Battlestaff Dmg Bonus
        CombatSpell spell = getSpell();
        if (weaponItemName.toLowerCase().contains("smoke battlestaff") || weaponItemName.toLowerCase().contains("smoke staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {
                magicdamagebonus += 0.1;
            }
        }

        // Twinflame Staff Magic Dmg Bonus
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard")) {
                magicdamagebonus += 0.1;
            }
        }

        return 1 + magicdamagebonus; // Default is 1.
    }

    protected double getVoidMagicBonus(Item[] playerEquipment)
    {
        if (playerEquipment == null) return 0;

        // Get required items for void check
        String headItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.HEAD);
        String bodyItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.BODY);
        String legsItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.LEGS);
        String glovesItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.GLOVES);

        // Check for set bonus
        if (headItemName.contains("Void mage"))
        {
            if (glovesItemName.contains("Void"))
            {
                if (bodyItemName.contains("Elite void"))
                {
                    if(legsItemName.contains("Elite void"))
                    {
                        // Elite void set
                        return 0.05; // 5% magic dmg bonus
                    }
                }
            }
        }

        // Elite Void Set incomplete, no bonus
        return 0;
    }

    protected double getTomeSpellBonus(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        String shieldItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.SHIELD);

        // Check if casting without spell selected
        int selectedSpellId = client.getVarbitValue(VarbitID.AUTOCAST_SPELL); // Varbit 276 is Selected Autocasted Spell
        if (selectedSpellId == 0)
        {
            // no spell selected
            return 1; // no bonus, default
        }

        CombatSpell selectedSpell = CombatSpell.getSpellbyVarbitValue(selectedSpellId); // returns null as default

        // Debug
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Selected Spell Sprite ID: " + spellSpriteID, null);
        //client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Selected Spell: " + selectedSpell, null);

        // Spell is selected, not casting from weapon
        if (selectedSpell == null)
        {
            return 1; // no bonus, default
        }
        else
        {
            if (selectedSpell.getName().toLowerCase().contains("fire"))
            {
                // Check for tome of fire
                if (shieldItemName.contains("Tome of fire"))
                {
                    if (!shieldItemName.contains("(empty)"))
                    {
                        return 1.1;
                    }
                }
            }

            if (selectedSpell.getName().toLowerCase().contains("water"))
            {
                // Check for tome of water
                if (shieldItemName.contains("Tome of water"))
                {
                    if (!shieldItemName.contains("(empty)"))
                    {
                        return 1.1;
                    }
                }
            }

            if (selectedSpell.getName().toLowerCase().contains("earth"))
            {
                // Check for tome of water
                if (shieldItemName.contains("Tome of earth"))
                {
                    if (!shieldItemName.contains("(empty)"))
                    {
                        return 1.1;
                    }
                }
            }
        }

        return 1;
    }

    // Calculate Standard Magic Max Hit
    protected double calculateMagicMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle)
    {
        // Calculate Magic Max Hit
        // Step 1: Find the base hit of the spell
        double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle, client.getBoostedSkillLevel(Skill.MAGIC));

        if (spellBaseMaxHit == 0)
        {
            return -1;
        }

        // Step 2: Calculate the Magic Damage Bonus
        double magicDmgBonus = getMagicEquipmentBoost(playerEquipment);

        double maxDamage = (spellBaseMaxHit * magicDmgBonus);

        // Step 3: Calculate Bonuses
        // Tome Bonuses
        double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
        maxDamage = maxDamage * correctTomeSpellBonus;

        // Final step: Calculate and add spell type weakness Bonus
        CombatSpell spell = getSpell();
        if (spell != null && spell.hasType())
        {
            if (plugin.selectedNPCName != null)
            {
                NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                if (weaknessBonus != null)
                {
                    if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                    {
                        int bonusPercent = weaknessBonus.getWeaknessPercent();

                        double typeBonusDamage = maxDamage * ((double) bonusPercent / (double)100);
                        maxDamage = maxDamage + typeBonusDamage;
                    }
                }
            }
        }

        // Twinflame Staff Double Hit bonus
        String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
        if (weaponItemName.toLowerCase().contains("twinflame staff"))
        {
            if (spell != null && spell.getSpellbook().contains("standard"))
            {
                if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                {
                    double bonusHit = Math.floor(maxDamage) * 0.4;
                    maxDamage = Math.floor(maxDamage) + Math.floor(bonusHit);
                }
            }
        }

        return maxDamage;
    }

    /**
     * Calculates the standard max hit based on current equipment and player status.
     *
     * @param isSpecialAttack boolean
     * @return Max Hit as Double
     */
    public double calculate(boolean isSpecialAttack)
    {
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return -1;

        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            return this.calculateMeleeMaxHit(playerEquipment, attackStyle, attackStyleID, isSpecialAttack);
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            return this.calculateRangedMaxHit(playerEquipment, attackStyle, attackStyleID);
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            return this.calculateMagicMaxHit(playerEquipment, attackStyle);
        }
        else
        {
            return -1;
        }
    }
}

/* PredictNextMax.java
 * Predicts the required stats to have a new max hit.
 *
 *
 * Copyright (c) 2023, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.Item;
import net.runelite.api.Skill;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.game.ItemManager;
import java.util.Arrays;
import java.util.List;

public class PredictNextMax extends MaxHit
{
    PredictNextMax(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);
    }

    private List<Object> predictNextMeleeMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        int nextStrengthLevel = 0;
        int nextStrengthBonus = 0;
        double nextPrayerBonus = 0;

        double currentMaxHit = Math.floor(calculateMeleeMaxHit(playerEquipment, weaponAttackStyle, attackStyleID, false));

        // Predict Next Prayer Bonus for Next Max Hit
        for(int i = 1; i <= 23; i++)
        {
            // Calculate Melee Max Hit
            // Step 1: Calculate effective Strength
            int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
            double prayerBonus = getPrayerBonus(weaponAttackStyle) + (i * 0.01);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
            double soulStackBonus = getSoulStackBonus();
            double effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);

            double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the base damage
            double strengthBonus = getMeleeStrengthBonus(playerEquipment); // default 0

            double baseDamage = (0.5 + effectiveStrength * ((strengthBonus + 64)/640));
            double flooredBaseDamage = Math.floor(baseDamage);

            // Step 3: Calculate the bonus damage
            List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

            double predictedMaxHit = flooredBaseDamage;

            if(!specialBonusMultipliers.isEmpty())
            {
                for (double bonus: specialBonusMultipliers)
                {
                    predictedMaxHit += Math.floor(predictedMaxHit * bonus);
                }
            }

            // Osmumten's Fang Decrease
            String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponName.contains("Osmumten's fang"))
            {
                predictedMaxHit = predictedMaxHit * 0.85 + 1;
            }

            // Colossal Blade Base Increase
            if(weaponName.contains("Colossal blade")){
                predictedMaxHit = predictedMaxHit + 2;
            }

            // Rat Default +10 damage Bonus
            if(weaponName.contains("Bone mace"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextPrayerBonus = (i * 0.01);
                break;
            }
        }

        // Predict Next Strength Bonus for Next Max Hit
        for(int i = 1; i <= 25; i++)
        {
            // Calculate Melee Max Hit
            // Step 1: Calculate effective Strength
            int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH);
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
            double soulStackBonus = getSoulStackBonus();
            double effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);

            double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the base damage
            double strengthBonus = getMeleeStrengthBonus(playerEquipment) + i; // default 0

            double baseDamage = (0.5 + effectiveStrength * ((strengthBonus + 64)/640));
            double flooredBaseDamage = Math.floor(baseDamage);

            // Step 3: Calculate the bonus damage
            List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

            double predictedMaxHit = flooredBaseDamage;

            if(!specialBonusMultipliers.isEmpty())
            {
                for (double bonus: specialBonusMultipliers)
                {
                    predictedMaxHit += Math.floor(predictedMaxHit * bonus);
                }
            }

            // Osmumten's Fang Decrease
            String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponName.contains("Osmumten's fang"))
            {
                predictedMaxHit = predictedMaxHit * 0.85 + 1;
            }

            // Colossal Blade Base Increase
            if(weaponName.contains("Colossal blade")){
                predictedMaxHit = predictedMaxHit + 2;
            }

            // Rat Default +10 damage Bonus
            if(weaponName.contains("Bone mace"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextStrengthBonus = i;
                break;
            }
        }

        // Predict Next Strength Level for Next Max Hit
        for(int i = 1; i <= 20; i++)
        {
            // Calculate Melee Max Hit
            // Step 1: Calculate effective Strength
            int strengthLevel = client.getBoostedSkillLevel(Skill.STRENGTH) + i;
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidMeleeBonus(playerEquipment); // default 1;
            double soulStackBonus = getSoulStackBonus();
            double effectiveSoulStackLevel = Math.floor(strengthLevel * soulStackBonus);

            double effectiveStrength = Math.floor((Math.floor(strengthLevel * prayerBonus) + effectiveSoulStackLevel + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the base damage
            double strengthBonus = getMeleeStrengthBonus(playerEquipment); // default 0

            double baseDamage = (0.5 + effectiveStrength * ((strengthBonus + 64)/640));
            double flooredBaseDamage = Math.floor(baseDamage);

            // Step 3: Calculate the bonus damage
            List<Double> specialBonusMultipliers = getMeleeSpecialBonusMultiplier(playerEquipment); // default empty

            double predictedMaxHit = flooredBaseDamage;

            if(!specialBonusMultipliers.isEmpty())
            {
                for (double bonus: specialBonusMultipliers)
                {
                    predictedMaxHit += Math.floor(predictedMaxHit * bonus);
                }
            }

            // Osmumten's Fang Decrease
            String weaponName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponName.contains("Osmumten's fang"))
            {
                predictedMaxHit = predictedMaxHit * 0.85 + 1;
            }

            // Colossal Blade Base Increase
            if(weaponName.contains("Colossal blade")){
                predictedMaxHit = predictedMaxHit + 2;
            }

            // Rat Default +10 damage Bonus
            if(weaponName.contains("Bone mace"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextStrengthLevel = i;
                break;
            }
        }

        List<Object> results = Arrays.asList("melee", nextStrengthLevel, nextStrengthBonus, nextPrayerBonus);

        // Complete
        return results;
    }

    private List<Object> predictNextRangeMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        int nextRangedLevel = 0;
        int nextRangeEquipmentBonus = 0;
        double nextPrayerBonus = 0;

        double currentMaxHit = Math.floor(calculateRangedMaxHit(playerEquipment, weaponAttackStyle, attackStyleID));

        // Predict Next Ranged Level for Next Max Hit
        for(int i = 1; i <= 20; i++)
        {
            // Calculate Ranged Max Hit
            // Step 1: Calculate effective ranged Strength
            int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED) + i;
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

            double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the max hit
            double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment);
            double gearBonus = getRangeGearBoost(playerEquipment);

            double predictedMaxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

            // Step 3: Bonus damage from special attack and effects
            // Rat Default +10 damage Bonus
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if(weaponItemName.contains("Bone shortbow"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Tonalztics of Ralos (uncharged) max hit is 75% of normal
            if(weaponItemName.contains("Tonalztics of ralos"))
            {
                predictedMaxHit = Math.floor(predictedMaxHit * 0.75); // unknown if flooring here causes miscalcs
                if(!weaponItemName.contains("(uncharged)"))
                {
                    predictedMaxHit = predictedMaxHit*2;
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextRangedLevel = i;
                break;
            }
        }

        // Predict Next Prayer Bonus for Next Max Hit
        for(int i = 1; i <= 23; i++)
        {
            // Calculate Ranged Max Hit
            // Step 1: Calculate effective ranged Strength
            int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
            double prayerBonus = getPrayerBonus(weaponAttackStyle) + (i * 0.01);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

            double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the max hit
            double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment);
            double gearBonus = getRangeGearBoost(playerEquipment);

            double predictedMaxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

            // Step 3: Bonus damage from special attack and effects
            // Rat Default +10 damage Bonus
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if(weaponItemName.contains("Bone shortbow"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Tonalztics of Ralos (uncharged) max hit is 75% of normal
            if(weaponItemName.contains("Tonalztics of ralos"))
            {
                predictedMaxHit = Math.floor(predictedMaxHit * 0.75); // unknown if flooring here causes miscalcs
                if(!weaponItemName.contains("(uncharged)"))
                {
                    predictedMaxHit = predictedMaxHit*2;
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextPrayerBonus = (i * 0.01);
                break;
            }
        }

        // Predict Next Ranged Equipment Strength Bonus for Next Max Hit
        for(int i = 1; i <= 20; i++)
        {
            // Calculate Ranged Max Hit
            // Step 1: Calculate effective ranged Strength
            int rangedLevel = client.getBoostedSkillLevel(Skill.RANGED);
            double prayerBonus = getPrayerBonus(weaponAttackStyle);
            int styleBonus = getAttackStyleBonus(weaponAttackStyle, attackStyleID);
            double voidBonus = getVoidRangedBonus(playerEquipment); // default 1;

            double effectiveRangedStrength = Math.floor((Math.floor(rangedLevel * prayerBonus) + styleBonus + 8) * voidBonus);

            // Step 2: Calculate the max hit
            double equipmentRangedStrength = getRangedStrengthBonus(playerEquipment) + i;
            double gearBonus = getRangeGearBoost(playerEquipment);

            double predictedMaxHit = (0.5 + (((effectiveRangedStrength * (equipmentRangedStrength + 64))/640) * gearBonus) );

            // Step 3: Bonus damage from special attack and effects
            // Rat Default +10 damage Bonus
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if(weaponItemName.contains("Bone shortbow"))
            {
                predictedMaxHit = predictedMaxHit + 10;
            }

            // Tonalztics of Ralos (uncharged) max hit is 75% of normal
            if(weaponItemName.contains("Tonalztics of ralos"))
            {
                predictedMaxHit = Math.floor(predictedMaxHit * 0.75); // unknown if flooring here causes miscalcs
                if(!weaponItemName.contains("(uncharged)"))
                {
                    predictedMaxHit = predictedMaxHit*2;
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextRangeEquipmentBonus = i;
                break;
            }
        }

        List<Object> results = Arrays.asList("ranged", nextRangedLevel, nextRangeEquipmentBonus, nextPrayerBonus);

        // Complete
        return results;
    }

    private List<Object> predictNextMageMaxHit(Item[] playerEquipment, AttackStyle weaponAttackStyle, int attackStyleID)
    {
        int nextMagicLevel = 0;
        double nextMagicDamageBonus = 0;

        double currentMaxHit = Math.floor(calculateMagicMaxHit(playerEquipment, weaponAttackStyle));
        CombatSpell spell = getSpell();

        // Predict Next Magic Level for Next Max Hit - Only used for Charged Weapons and Magic Dart
        if(spell == null || (spell.getName().toLowerCase().contains("magic dart")))
        {
            for(int i = 1; i <= 20; i++)
            {
                // Calculate Magic Max Hit
                // Step 1: Find the base hit of the spell
                double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle, (client.getBoostedSkillLevel(Skill.MAGIC) + i));

                // Step 2: Calculate the Magic Damage Bonus
                double magicDmgBonus = getMagicEquipmentBoost(playerEquipment) + (i * 0.01);

                double predictedMaxHit = (spellBaseMaxHit * magicDmgBonus);

                // Step 3: Calculate Type Bonuses
                // Tome Bonuses
                double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
                predictedMaxHit = predictedMaxHit * correctTomeSpellBonus;

                // Check if predicted is better than current
                if (Math.floor(predictedMaxHit) > currentMaxHit)
                {
                    nextMagicLevel = i;
                    break;
                }
            }
        }

        // Predict Next Magic Damage Bonus needed for next Max Hit
        for(int i = 1; i <= 50; i++)
        {
            // Calculate Magic Max Hit
            // Step 1: Find the base hit of the spell
            double spellBaseMaxHit = getSpellBaseHit(playerEquipment, weaponAttackStyle, client.getBoostedSkillLevel(Skill.MAGIC));

            // Step 2: Calculate the Magic Damage Bonus
            double magicDmgBonus = getMagicEquipmentBoost(playerEquipment) + (i * 0.01);

            double predictedMaxHit = (spellBaseMaxHit * magicDmgBonus);

            // Step 3: Calculate Type Bonuses
            // Tome Bonuses
            double correctTomeSpellBonus = getTomeSpellBonus(playerEquipment, weaponAttackStyle); // default 1
            predictedMaxHit = predictedMaxHit * correctTomeSpellBonus;

            // Final step: Calculate and add spell type weakness Bonus
            if (spell != null && spell.hasType())
            {
                if (plugin.selectedNPCName != null)
                {
                    NPCTypeWeakness weaknessBonus = NPCTypeWeakness.findWeaknessByName(plugin.selectedNPCName);
                    if (weaknessBonus != null)
                    {
                        if(spell.getSpellType() == weaknessBonus.getElementalWeakness())
                        {
                            int bonusPercent = weaknessBonus.getWeaknessPercent();

                            double typeBonusDamage = predictedMaxHit * ((double) bonusPercent / (double)100);
                            predictedMaxHit = predictedMaxHit + typeBonusDamage;
                        }
                    }
                }
            }

            // Twinflame Staff Double Hit bonus
            String weaponItemName = EquipmentItems.getItemNameInGivenSetSlot(client, playerEquipment, EquipmentInventorySlot.WEAPON);
            if (weaponItemName.toLowerCase().contains("twinflame staff"))
            {
                if (spell != null && spell.getSpellbook().contains("standard")) {

                    if(!spell.getName().toLowerCase().contains("strike") && !spell.getName().toLowerCase().contains("surge"))
                    {
                        double bonusHit = Math.floor(predictedMaxHit) * 0.4;
                        predictedMaxHit = Math.floor(predictedMaxHit) + Math.floor(bonusHit);
                    }
                }
            }

            // Check if predicted is better than current
            if (Math.floor(predictedMaxHit) > currentMaxHit)
            {
                nextMagicDamageBonus = (i * 0.01);
                break;
            }
        }

        List<Object> results = Arrays.asList("magic", nextMagicLevel, nextMagicDamageBonus);

        // Complete
        return results;
    }

    /**
     * Calculates a prediction of stat increases required for a new max hit.<br><br>
     * Predictions for Melee: Strength Level, Equipment Strength Bonus, and Prayer Bonus <br>
     * Predictions for Ranged: Ranged Level, Ranged Equipment Strength Bonus, and Prayer Bonus <br>
     * Predictions for Magic: Magic Level, and Magic Equipment Damage Bonus <br><br>
     *
     * @return List of predictions
     */
    public List<Object> predict()
    {
        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return null;

        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        // Find what type to calculate
        if(attackStyle.equals(AttackStyle.ACCURATE) || attackStyle.equals(AttackStyle.AGGRESSIVE) || attackStyle.equals(AttackStyle.CONTROLLED) || attackStyle.equals(AttackStyle.DEFENSIVE))
        {
            List<Object> meleeResults = this.predictNextMeleeMaxHit(playerEquipment, attackStyle, attackStyleID);

            // index: 0 = "melee", 1 = strength level, 2 = equipment strength bonus, 3 = prayer percent bonus
            return meleeResults;
        }
        else if (attackStyle.equals(AttackStyle.RANGING) || attackStyle.equals(AttackStyle.LONGRANGE))
        {
            List<Object> rangedResults = this.predictNextRangeMaxHit(playerEquipment, attackStyle, attackStyleID);

            // index: 0 = "ranged", 1 = range level, 2 = range equipment strength bonus, 3 = prayer percent bonus
            return rangedResults;
        }
        else if ((attackStyle.equals(AttackStyle.CASTING)  || attackStyle.equals(AttackStyle.DEFENSIVE_CASTING)))
        {
            List<Object> mageResults = this.predictNextMageMaxHit(playerEquipment, attackStyle, attackStyleID);

            // index: 0 = "magic", 1 = magic level, 2 = mage equipment damage bonus
            return mageResults;
        }
        else
        {
            return null;
        }
    }
}

/* MaxSpecAgainstType.java
 * Calculates Max hit for special attacks vs enemy types.
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.api.Client;
import net.runelite.api.Item;
import net.runelite.api.gameval.*;
import net.runelite.client.game.ItemManager;
import java.util.List;

/**
 * Contains functions for calculating max hit of a special attack weapon vs specific types of npc.
 */
public class MaxSpecAgainstType extends MaxAgainstType
{
    private MaxSpec maxSpecs;

    MaxSpecAgainstType(MaxHitCalcPlugin plugin, MaxHitCalcConfig config, ItemManager itemManager, Client client)
    {
        super(plugin, config, itemManager, client);

        maxSpecs = new MaxSpec(plugin, config, itemManager, client);
    }

    /**
     * Calculates Max hit of a special attack against specific type bonuses
     *
     * @return Max hit as Double
     */
    public double calculate()
    {
        // Get Current Equipment
        Item[] playerEquipment = EquipmentItems.getCurrentlyEquipped(client);

        if (playerEquipment == null) return 0;

        int attackStyleID = client.getVarpValue(VarPlayerID.COM_MODE); // Varplayer: Attack Style
        int weaponTypeID = client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);  // Varbit: Equipped Weapon Type

        // Get Current Attack Style
        AttackStyle[] weaponAttackStyles = WeaponType.getWeaponTypeStyles(client, weaponTypeID);
        AttackStyle attackStyle = weaponAttackStyles[attackStyleID];
        if (attackStyle == null)
            return 0;

        // Get Type modifier
        List<Double> typeModifiersList = getTypeBonus(attackStyle, playerEquipment);

        if(!typeModifiersList.isEmpty())
        {
            // Get Max hit then calculate Spec
            double maxSpec = maxSpecs.calculate();

            if(maxSpec != 0)
            {
                double maxSpecVsTypeHit = Math.floor(maxSpec);
                // Iterate through modifiers, flooring after multiplying
                for (double modifier: typeModifiersList)
                {
                    maxSpecVsTypeHit = Math.floor(maxSpecVsTypeHit * modifier);
                }

                return maxSpecVsTypeHit;
            }
        }

        return 0; // No Type Bonus
    }
}

/* SpellType.java
 * Separates spells by SpriteID. Useful for getting the selected auto-cast spell.
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

public enum SpellType {
    Air,
    Water,
    Earth,
    Fire,
    NoType
}

/* NPCIcons.java
 * Static references to all icon resources.
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import java.awt.image.BufferedImage;

public class NPCIcons
{
    public static final ImageIcon ABYSSAL_PORTAL_ICON;
    public static final ImageIcon ADAMANT_DRAGON_ICON;
    public static final ImageIcon AHRIM_ICON;
    public static final ImageIcon AMOXLIATL;
    public static final ImageIcon ARAXXOR_ICON;
    public static final ImageIcon ARCANE_SCARAB_ICON;
    public static final ImageIcon AVIANSIE_ICON;
    public static final ImageIcon BLACK_DEMON_ICON;
    public static final ImageIcon BLACK_DRAGON_ICON;
    public static final ImageIcon BLUE_DRAGON_ICON;
    public static final ImageIcon BRONZE_DRAGON_ICON;
    public static final ImageIcon CERBERUS_ICON;
    public static final ImageIcon CHILLED_JELLY_ICON;
    public static final ImageIcon DEMONIC_GORILLA_ICON;
    public static final ImageIcon DHAROK_ICON;
    public static final ImageIcon DRAKE_ICON;
    public static final ImageIcon FIRE_GIANT_ICON;
    public static final ImageIcon FROST_CRAB;
    public static final ImageIcon FROST_NAGUA;
    public static final ImageIcon GHOST_ICON;
    public static final ImageIcon GIANT_MOLE_ICON;
    public static final ImageIcon GIANT_SPIDER_ICON;
    public static final ImageIcon GREATER_DEMON_ICON;
    public static final ImageIcon GREEN_DRAGON_ICON;
    public static final ImageIcon GUTHAN_ICON;
    public static final ImageIcon HELLHOUND_ICON;
    public static final ImageIcon HESPORI_ICON;
    public static final ImageIcon HUEYCOATL_ICON;
    public static final ImageIcon ICE_DEMON_ICON;
    public static final ImageIcon ICE_GIANT_ICON;
    public static final ImageIcon ICE_SPIDER_ICON;
    public static final ImageIcon ICE_TROLL_ICON;
    public static final ImageIcon ICE_TROLL_RUNT_ICON;
    public static final ImageIcon ICE_WARRIOR_ICON;
    public static final ImageIcon ICEFIEND_ICON;
    public static final ImageIcon IRON_DRAGON_ICON;
    public static final ImageIcon KARIL_ICON;
    public static final ImageIcon KEPHRI_ICON;
    public static final ImageIcon KBD_ICON;
    public static final ImageIcon KREE_ICON;
    public static final ImageIcon KRIL_ICON;
    public static final ImageIcon LAVA_DRAGON_ICON;
    public static final ImageIcon LESSER_DEMON_ICON;
    public static final ImageIcon MITHRIL_DRAGON_ICON;
    public static final ImageIcon MOSS_GIANT_ICON;
    public static final ImageIcon MOUNTAIN_TROLL_ICON;
    public static final ImageIcon PYREFIEND_ICON;
    public static final ImageIcon RED_DRAGON_ICON;
    public static final ImageIcon RUNE_DRAGON_ICON;
    public static final ImageIcon SCARAB_MAGE_ICON;
    public static final ImageIcon SCARAB_SWARM_ICON;
    public static final ImageIcon SKELETON_ICON;
    public static final ImageIcon SOLDIER_SCARAB_ICON;
    public static final ImageIcon SPITTING_SCARAB_ICON;
    public static final ImageIcon STEEL_DRAGON_ICON;
    public static final ImageIcon TORAG_ICON;
    public static final ImageIcon VERAC_ICON;
    public static final ImageIcon VESPULA_ICON;
    public static final ImageIcon WATERFIEND_ICON;
    public static final ImageIcon WYRM_ICON;
    public static final ImageIcon WYRMLING_ICON;
    public static final ImageIcon ZULRAH_ICON;

    static {
        final BufferedImage ABYSSAL_PORTAL_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/abyssal_portal.png");
        final BufferedImage ADAMANT_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/adamant_dragon.png");
        final BufferedImage AHRIM_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ahrim.png");
        final BufferedImage AMOXLIATL_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/amoxliatl.png");
        final BufferedImage ARAXXOR_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/araxxor.png");
        final BufferedImage ARCANE_SCARAB_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/arcane_scarab.png");
        final BufferedImage AVIANSIE_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/aviansie.png");
        final BufferedImage BLACK_DEMON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/black_demon.png");
        final BufferedImage BLACK_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/black_dragon.png");
        final BufferedImage BLUE_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/blue_dragon.png");
        final BufferedImage BRONZE_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/bronze_dragon.png");
        final BufferedImage CERBERUS_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/cerberus.png");
        final BufferedImage CHILLED_JELLY_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/chilled_jelly.png");
        final BufferedImage DEMONIC_GORILLA_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/demonic_gorilla.png");
        final BufferedImage DHAROK_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/dharok.png");
        final BufferedImage DRAKE_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/drake.png");
        final BufferedImage FIRE_GIANT_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/fire_giant.png");
        final BufferedImage FROST_CRAB_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/frost_crab.png");
        final BufferedImage FROST_NAGUA_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/frost_nagua.png");
        final BufferedImage GHOST_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ghost.png");
        final BufferedImage GIANT_MOLE_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/giant_mole.png");
        final BufferedImage GIANT_SPIDER_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/giant_spider.png");
        final BufferedImage GREATER_DEMON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/greater_demon.png");
        final BufferedImage GREEN_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/green_dragon.png");
        final BufferedImage GUTHAN_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/guthan.png");
        final BufferedImage HELLHOUND_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/hellhound.png");
        final BufferedImage HESPORI_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/hespori.png");
        final BufferedImage HUEYCOATL_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/hueycoatl.png");
        final BufferedImage ICE_DEMON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ice_demon.png");
        final BufferedImage ICE_GIANT_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ice_giant.png");
        final BufferedImage ICE_SPIDER_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ice_spider.png");
        final BufferedImage ICE_TROLL_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ice_troll.png");
        final BufferedImage ICE_TROLL_RUNT_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ice_troll_runt.png");
        final BufferedImage ICE_WARRIOR_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/ice_warrior.png");
        final BufferedImage ICEFIEND_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/icefiend.png");
        final BufferedImage IRON_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/iron_dragon.png");
        final BufferedImage KARIL_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/karil.png");
        final BufferedImage KEPHRI_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/kephri.png");
        final BufferedImage KBD_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/kbd.png");
        final BufferedImage KREE_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/kree.png");
        final BufferedImage KRIL_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/kril.png");
        final BufferedImage LAVA_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/lava_dragon.png");
        final BufferedImage LESSER_DEMON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/lesser_demon.png");
        final BufferedImage MITHRIL_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/mithril_dragon.png");
        final BufferedImage MOSS_GIANT_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/moss_giant.png");
        final BufferedImage MOUNTAIN_TROLL_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/mountain_troll.png");
        final BufferedImage PYREFIEND_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/pyrefiend.png");
        final BufferedImage RED_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/red_dragon.png");
        final BufferedImage RUNE_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/rune_dragon.png");
        final BufferedImage SCARAB_MAGE_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/scarab_mage.png");
        final BufferedImage SCARAB_SWARM_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/scarab_swarm.png");
        final BufferedImage SKELETON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/skeleton.png");
        final BufferedImage SOLDIER_SCARAB_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/soldier_scarab.png");
        final BufferedImage SPITTING_SCARAB_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/spitting_scarab.png");
        final BufferedImage STEEL_DRAGON_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/steel_dragon.png");
        final BufferedImage TORAG_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/torag.png");
        final BufferedImage VERAC_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/verac.png");
        final BufferedImage VESPULA_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/vespula.png");
        final BufferedImage WATERFIEND_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/waterfiend.png");
        final BufferedImage WYRM_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/wyrm.png");
        final BufferedImage WYRMLING_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/wyrmling.png");
        final BufferedImage ZULRAH_IMG = ImageUtil.loadImageResource(MaxHitCalcPlugin.class, "/npc_icons/zulrah.png");

        ABYSSAL_PORTAL_ICON = new ImageIcon(ABYSSAL_PORTAL_IMG);
        ADAMANT_DRAGON_ICON = new ImageIcon(ADAMANT_DRAGON_IMG);
        AHRIM_ICON = new ImageIcon(AHRIM_IMG);
        AMOXLIATL = new ImageIcon(AMOXLIATL_IMG);
        ARAXXOR_ICON = new ImageIcon(ARAXXOR_IMG);
        ARCANE_SCARAB_ICON = new ImageIcon(ARCANE_SCARAB_IMG);
        AVIANSIE_ICON = new ImageIcon(AVIANSIE_IMG);
        BLACK_DEMON_ICON = new ImageIcon(BLACK_DEMON_IMG);
        BLACK_DRAGON_ICON = new ImageIcon(BLACK_DRAGON_IMG);
        BLUE_DRAGON_ICON = new ImageIcon(BLUE_DRAGON_IMG);
        BRONZE_DRAGON_ICON = new ImageIcon(BRONZE_DRAGON_IMG);
        CERBERUS_ICON = new ImageIcon(CERBERUS_IMG);
        CHILLED_JELLY_ICON = new ImageIcon(CHILLED_JELLY_IMG);
        DEMONIC_GORILLA_ICON = new ImageIcon(DEMONIC_GORILLA_IMG);
        DHAROK_ICON = new ImageIcon(DHAROK_IMG);
        DRAKE_ICON = new ImageIcon(DRAKE_IMG);
        FIRE_GIANT_ICON = new ImageIcon(FIRE_GIANT_IMG);
        FROST_CRAB = new ImageIcon(FROST_CRAB_IMG);
        FROST_NAGUA = new ImageIcon(FROST_NAGUA_IMG);
        GHOST_ICON = new ImageIcon(GHOST_IMG);
        GIANT_MOLE_ICON = new ImageIcon(GIANT_MOLE_IMG);
        GIANT_SPIDER_ICON = new ImageIcon(GIANT_SPIDER_IMG);
        GREATER_DEMON_ICON = new ImageIcon(GREATER_DEMON_IMG);
        GREEN_DRAGON_ICON = new ImageIcon(GREEN_DRAGON_IMG);
        GUTHAN_ICON = new ImageIcon(GUTHAN_IMG);
        HELLHOUND_ICON = new ImageIcon(HELLHOUND_IMG);
        HESPORI_ICON = new ImageIcon(HESPORI_IMG);
        HUEYCOATL_ICON = new ImageIcon(HUEYCOATL_IMG);
        ICE_DEMON_ICON = new ImageIcon(ICE_DEMON_IMG);
        ICE_GIANT_ICON = new ImageIcon(ICE_GIANT_IMG);
        ICE_SPIDER_ICON = new ImageIcon(ICE_SPIDER_IMG);
        ICE_TROLL_ICON = new ImageIcon(ICE_TROLL_IMG);
        ICE_TROLL_RUNT_ICON = new ImageIcon(ICE_TROLL_RUNT_IMG);
        ICE_WARRIOR_ICON = new ImageIcon(ICE_WARRIOR_IMG);
        ICEFIEND_ICON = new ImageIcon(ICEFIEND_IMG);
        IRON_DRAGON_ICON = new ImageIcon(IRON_DRAGON_IMG);
        KARIL_ICON = new ImageIcon(KARIL_IMG);
        KEPHRI_ICON = new ImageIcon(KEPHRI_IMG);
        KBD_ICON = new ImageIcon(KBD_IMG);
        KREE_ICON = new ImageIcon(KREE_IMG);
        KRIL_ICON = new ImageIcon(KRIL_IMG);
        LAVA_DRAGON_ICON = new ImageIcon(LAVA_DRAGON_IMG);
        LESSER_DEMON_ICON = new ImageIcon(LESSER_DEMON_IMG);
        MITHRIL_DRAGON_ICON = new ImageIcon(MITHRIL_DRAGON_IMG);
        MOSS_GIANT_ICON = new ImageIcon(MOSS_GIANT_IMG);
        MOUNTAIN_TROLL_ICON = new ImageIcon(MOUNTAIN_TROLL_IMG);
        PYREFIEND_ICON = new ImageIcon(PYREFIEND_IMG);
        RED_DRAGON_ICON = new ImageIcon(RED_DRAGON_IMG);
        RUNE_DRAGON_ICON = new ImageIcon(RUNE_DRAGON_IMG);
        SCARAB_MAGE_ICON = new ImageIcon(SCARAB_MAGE_IMG);
        SCARAB_SWARM_ICON = new ImageIcon(SCARAB_SWARM_IMG);
        SKELETON_ICON = new ImageIcon(SKELETON_IMG);
        SOLDIER_SCARAB_ICON = new ImageIcon(SOLDIER_SCARAB_IMG);
        SPITTING_SCARAB_ICON = new ImageIcon(SPITTING_SCARAB_IMG);
        STEEL_DRAGON_ICON = new ImageIcon(STEEL_DRAGON_IMG);
        TORAG_ICON = new ImageIcon(TORAG_IMG);
        VERAC_ICON = new ImageIcon(VERAC_IMG);
        VESPULA_ICON = new ImageIcon(VESPULA_IMG);
        WATERFIEND_ICON = new ImageIcon(WATERFIEND_IMG);
        WYRM_ICON = new ImageIcon(WYRM_IMG);
        WYRMLING_ICON = new ImageIcon(WYRMLING_IMG);
        ZULRAH_ICON = new ImageIcon(ZULRAH_IMG);
    }
}

/* BlowpipeDartType.java
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

public enum BlowpipeDartType
{
    MITHRIL,
    ADAMANT,
    RUNE,
    AMETHYST,
    DRAGON
}

/* MaxHitCalcPanel.java
 * Code for plugin panel which changes calculation settings
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import com.google.inject.Inject;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;


public class MaxHitCalcPanel extends PluginPanel
{
    @Inject
    @Nullable
    private Client client;

    @Inject
    private EventBus eventBus;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ConfigManager configManager;

    private MaxHitCalcPlugin plugin;
    private MaxHitCalcConfig config;

    // UI Settings
    private JComboBox dartList = new JComboBox();
    private JComboBox colossalBladeList = new JComboBox();

    private JLabel selectionNotice;
    private JLabel[] allNPCLabels;
    private Map<JLabel, String> npcLabels = new HashMap<>();

    private String panelSelectedNPCName = "";


    enum ColossalBladeSizeBonus
    {
        ONE(1) {

            @Override
            public String toString() {
                return "1x1";
            }
        },
        TWO(2) {
            @Override
            public String toString() {
                return "2x2";
            }
        },
        THREE(3) {
            @Override
            public String toString() {
                return "3x3";
            }
        },
        FOUR(4) {
            @Override
            public String toString() {
                return "4x4";
            }
        },
        FIVE(5) {
            @Override
            public String toString() {
                return "5x5 +";
            }
        };

        public final int monsterSize;

        ColossalBladeSizeBonus(int monsterSize) {
            this.monsterSize = monsterSize;
        }
    }

    void init(MaxHitCalcPlugin plugin, MaxHitCalcConfig config)
    {
        this.plugin = plugin;
        this.config = config;

        // Initial Settings
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Title Panel
        JPanel titlePanel = new JPanel();
        titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        titlePanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        titlePanel.setLayout(new GridLayout(0, 1));

        JLabel titleLabel = new JLabel();
        titleLabel.setText("Calculation Settings");

        titlePanel.add(titleLabel);
        //titlePanel.add(Box.createGlue()); // Adds a break


        // Content section
        JPanel contentPanel = new JPanel();
        contentPanel.setBorder(new EmptyBorder(10, 0, 0, 0));
        contentPanel.setLayout(new GridLayout(0, 1));

        // Blowpipe Dart Setting
        JPanel panel = new JPanel();
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new EmptyBorder(10, 10, 10, 10));
        panel.setLayout(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.ipadx = 0;

        JLabel dartSettingLabel = new JLabel("Blowpipe Dart:");
        dartSettingLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        //dartSettingLabel.setLayout(new GridLayout(2, 1));

        c.gridx = 0;
        c.gridy = 0;
        c.ipady = 0;
        c.weightx = 0.5;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_START;
        c.gridwidth = 2;

        panel.add(dartSettingLabel, c);


        // Create Dropdown menu for selecting Dart type
        dartList = new JComboBox(BlowpipeDartType.values());
        BlowpipeDartType selectedDart = (BlowpipeDartType)configManager.getConfiguration("MaxHitCalc", "blowpipeDartType", BlowpipeDartType.class);
        dartList.setSelectedIndex(selectedDart.ordinal()); // 0 = Mithril
        dartList.addActionListener(e -> onDartSwitched());

        c.gridx = 2;
        c.gridy = 0;
        c.ipady = 0;
        c.weightx = 0.5;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_END;
        c.gridwidth = 2;

        panel.add(dartList, c);


        c.gridx = 0;
        c.gridy = 1;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(10,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 2;

        panel.add(Box.createGlue(), c);

        // Colossal Blade NPC Size Setting
        JLabel cbladeSettingLabel = new JLabel("NPC Size:");
        cbladeSettingLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cbladeSettingLabel.setLayout(new GridLayout(2, 1));

        c.gridx = 0;
        c.gridy = 2;
        c.ipady = 0;
        c.weightx = 0.5;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_START;
        c.gridwidth = 2;

        panel.add(cbladeSettingLabel, c);

        // Dropdown for NPC Size
        colossalBladeList = new JComboBox(ColossalBladeSizeBonus.values());
        colossalBladeList.setSelectedIndex(0);
        colossalBladeList.addActionListener(e -> onCBladeSettingSwitched());

        c.gridx = 2;
        c.gridy = 2;
        c.ipady = 0;
        c.weightx = 0.5;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_END;
        c.gridwidth = 2;

        panel.add(colossalBladeList, c);

        c.gridx = 0;
        c.gridy = 3;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(10,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 2;

        panel.add(Box.createGlue(), c);

        // NPC Selection Title
        JLabel npcSelectionTitleLabel = new JLabel("Selected NPC:");
        npcSelectionTitleLabel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        c.gridx = 0;
        c.gridy = 4;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_START;
        c.gridwidth = 2;

        panel.add(npcSelectionTitleLabel, c);

        // NPC Selection
        selectionNotice = new JLabel("");
        selectionNotice.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        c.gridx = 2;
        c.gridy = 4;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.LINE_END;
        c.gridwidth = 2;

        panel.add(selectionNotice, c);

        int totalCells = NPCTypeWeakness.values().length;
        allNPCLabels = new JLabel[totalCells];

        int columns = 4;
        int rows = (int) Math.ceil(((double) totalCells/(double)columns));
        int index = 0;

        int finalRow = 6;

        for(int i = 0; i < rows; i++)
        {
            for(int j = 0; j < columns; j++)
            {
                if(index >= totalCells)
                {


                    //panel.add(new JLabel(""), c);
                }
                else
                {
                    NPCTypeWeakness currentNPC = NPCTypeWeakness.values()[index];
                    JLabel createLabel = createIcon(currentNPC.getIcon(), currentNPC.getNPCName());

                    allNPCLabels[index] = createLabel;
                    npcLabels.put(createLabel, currentNPC.getNPCName());

                    c.gridx = 0+j;
                    c.gridy = 5+i;
                    c.ipady = 0;
                    c.weightx = 0.5;
                    c.weighty = 0;
                    c.insets = new Insets(0,0,0,0);  //top padding
                    c.anchor = GridBagConstraints.CENTER;
                    c.gridwidth = 1;
                    c.gridheight = 1;

                    panel.add(createLabel, c);
                    index++;
                }
            }
            finalRow = 6+i; // needed for last button
        }

        JButton resetButton = new JButton("Reset");
        resetButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                resetNPCviaPanel();
            }
        });

        c.gridx = 0;
        c.gridy = finalRow;
        c.ipady = 0;
        c.weightx = 0;
        c.weighty = 0;
        c.insets = new Insets(0,0,0,0);  //top padding
        c.anchor = GridBagConstraints.CENTER;
        c.gridwidth = 2;
        c.gridheight = 0;

        panel.add(resetButton, c);

        contentPanel.add(panel);

        // Final,
        add(titlePanel, BorderLayout.NORTH);
        add(contentPanel, BorderLayout.CENTER);

        eventBus.register(this);
    }

    void deinit()
    {
        eventBus.unregister(this);
    }

    private JLabel createIcon(ImageIcon icon, String npcName)
    {
        ImageIcon resizedImage = new ImageIcon(icon.getImage().getScaledInstance(-1, 39, Image.SCALE_DEFAULT));

        JLabel iconLabel = new JLabel(resizedImage);
        iconLabel.setLayout(new BorderLayout());
        iconLabel.setBorder(new EmptyBorder(1,1,1,1));
        iconLabel.setToolTipText(npcName);
        iconLabel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                JLabel currentLabel = (JLabel) e.getSource();

                clearCurrentPanelNPC(); // remove border from previous npc

                currentLabel.setBorder(new LineBorder(Color.ORANGE, 1));

                panelSelectedNPCName = npcLabels.get(currentLabel);

                selectionNotice.setText(panelSelectedNPCName);

                // Recalculate plugin
                plugin.selectedNPCName = panelSelectedNPCName;
                plugin.npcSelectedByPanel = true;
            }
        });

        return iconLabel;
    }

    void onDartSwitched()
    {
        BlowpipeDartType selectedDart = BlowpipeDartType.values()[dartList.getSelectedIndex()];
        configManager.setConfiguration("MaxHitCalc", "blowpipeDartType", selectedDart);
        plugin.selectedDartType = selectedDart;
        plugin.dartSettingChanged = true;
    }

    void onCBladeSettingSwitched()
    {
        plugin.NPCSize = Math.max(1, colossalBladeList.getSelectedIndex()+1); // index 0 == 1, index 1 == 2, etc...
        plugin.npcSizeSettingChanged = true;
    }

    void resetNPCviaPanel(){
        // Reset size
        colossalBladeList.setSelectedIndex(0);

        // Reset border around npc
        clearCurrentPanelNPC();

        // Clear Texts
        panelSelectedNPCName = "";
        selectionNotice.setText(panelSelectedNPCName);
    }

    // Set panel info automatically from plugin
    void setNPCviaPlugin()
    {
        // Set Size
        int size = Math.min(plugin.NPCSize, 5);
        colossalBladeList.setSelectedIndex(size-1);

        // Clear currently bordered npc on panel
        clearCurrentPanelNPC();

        // Set NPC
        selectionNotice.setText(plugin.selectedNPCName);
        if(plugin.selectedNPCName != null)
        {
            for(JLabel label : allNPCLabels)
            {
                String searchedNPC = npcLabels.get(label);

                // Full and Correct name found
                if(searchedNPC.equals(plugin.selectedNPCName))
                {
                    label.setBorder(new LineBorder(Color.ORANGE, 1));
                    panelSelectedNPCName = plugin.selectedNPCName; // Full name
                    break;
                }

                // Partial name found, e.g. baby (black dragon)
                if(plugin.selectedNPCName.toLowerCase().contains(searchedNPC.toLowerCase()))
                {
                    label.setBorder(new LineBorder(Color.ORANGE, 1));
                    panelSelectedNPCName = searchedNPC.toLowerCase(); // Partial name
                    break;
                }
            }
        }
    }

    // Clears currently Selected in the panel
    void clearCurrentPanelNPC()
    {
        for(JLabel label : allNPCLabels)
        {
            String searchedNPC = npcLabels.get(label);

            if (!panelSelectedNPCName.isEmpty())
            {
                // Find Full correct name
                if (searchedNPC.equals(panelSelectedNPCName))
                {
                    label.setBorder(new EmptyBorder(0, 0, 0, 0));
                    break;
                }

                // Find Partial name , e.g. baby (black dragon)
                if (panelSelectedNPCName.toLowerCase().contains(searchedNPC.toLowerCase()))
                {
                    label.setBorder(new EmptyBorder(0, 0, 0, 0));
                    break;
                }
            }
            else
            {
                break; // no npc currently selected in panel
            }
        }
    }
}

/* NPCTypeWeakness.java
 * Enum for all NPC's with a type weakness.
 *
 *
 * Copyright (c) 2024, Jacob Burton <https://github.com/j-cob44>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package com.maxhitcalc;

import lombok.Getter;

import javax.swing.*;


/**
 *
 * Contains all known type bonuses against different NPC's.
 * Updated based on https://oldschool.runescape.wiki/w/Elemental_weakness
 * Last updated on 9/21/24
 *
 */

public enum NPCTypeWeakness
{
    // In Alphabetical Order
    AbyssalPortal("Abyssal portal", SpellType.Fire, 50, NPCIcons.ABYSSAL_PORTAL_ICON),
    AdamantDragon("Adamant dragon", SpellType.Earth, 50, NPCIcons.ADAMANT_DRAGON_ICON),
    Ahrim("Ahrim", SpellType.Air, 50, NPCIcons.AHRIM_ICON),
    Amoxliatl("Amoxliatl", SpellType.Fire, 30, NPCIcons.AMOXLIATL),
    Araxxor("Araxxor", SpellType.Fire, 50, NPCIcons.ARAXXOR_ICON),
    Araxyte("Araxyte", SpellType.Fire, 50, NPCIcons.ARAXXOR_ICON), // Needs Icon
    ArcaneScarab("Arcane scarab", SpellType.Fire, 50, NPCIcons.ARCANE_SCARAB_ICON),
    ArmadyleanGuard("Armadylean guard", SpellType.Air, 30, NPCIcons.AVIANSIE_ICON), // Needs Icon
    Aviansie("Aviansie", SpellType.Air, 45, NPCIcons.AVIANSIE_ICON),
    BlackDemon("Black demon", SpellType.Water, 40, NPCIcons.BLACK_DEMON_ICON),
    BlackDragon("Black dragon", SpellType.Water, 50, NPCIcons.BLACK_DRAGON_ICON), // Brutal, Baby, and normal black dragons all have the same %
    BlueDragon("Blue dragon", SpellType.Water, 50, NPCIcons.BLUE_DRAGON_ICON), // Brutal, Baby, and normal blue dragons all have the same %
    BronzeDragon("Bronze dragon", SpellType.Earth, 50, NPCIcons.BRONZE_DRAGON_ICON),
    Cerberus("Cerberus", SpellType.Water, 40, NPCIcons.CERBERUS_ICON),
    ChilledJelly("Chilled jelly", SpellType.Fire, 50, NPCIcons.CHILLED_JELLY_ICON),
    DemonicGorilla("Demonic gorilla", SpellType.Water, 35, NPCIcons.DEMONIC_GORILLA_ICON),
    Dharok("Dharok", SpellType.Air, 50, NPCIcons.DHAROK_ICON),
    Drake("Drake", SpellType.Water, 50, NPCIcons.DRAKE_ICON),
    FireGiant("Fire giant", SpellType.Water, 100, NPCIcons.FIRE_GIANT_ICON),
    FlightKilisa("Flight kilisa", SpellType.Air, 30, NPCIcons.AVIANSIE_ICON), // Needs icon
    FlockleaderGeerin("Flockleader geerin", SpellType.Air, 30, NPCIcons.AVIANSIE_ICON), // Needs icon
    FrostCrab("Frost Crab", SpellType.Fire, 100, NPCIcons.FROST_CRAB),
    FrostNagua("Frost Nagua",SpellType.Fire, 50, NPCIcons.FROST_NAGUA),
    Ghost("Ghost", SpellType.Air, 50, NPCIcons.GHOST_ICON),
    GiantMole("Giant mole", SpellType.Water, 50, NPCIcons.GIANT_MOLE_ICON),
    GiantSpider("Giant spider", SpellType.Fire, 50, NPCIcons.GIANT_SPIDER_ICON),
    GreaterDemon("Greater demon", SpellType.Water, 40, NPCIcons.GREATER_DEMON_ICON),
    GreenDragon("Green dragon", SpellType.Water, 50, NPCIcons.GREEN_DRAGON_ICON), // Brutal, Baby, and normal blue dragons all have the same %
    Guthan("Guthan", SpellType.Air, 50, NPCIcons.GUTHAN_ICON),
    Hellhound("Hellhound", SpellType.Water, 50, NPCIcons.HELLHOUND_ICON),
    Hespori("Hespori", SpellType.Fire, 100, NPCIcons.HESPORI_ICON),
    Hueycoatl("hueycoatl", SpellType.Earth, 60, NPCIcons.HUEYCOATL_ICON),
    IceDemon("Ice demon", SpellType.Fire, 150, NPCIcons.ICE_DEMON_ICON),
    IceGiant("Ice giant", SpellType.Fire, 100, NPCIcons.ICE_GIANT_ICON),
    IceSpider("Ice spider", SpellType.Fire, 100, NPCIcons.ICE_SPIDER_ICON),
    IceTroll("Ice troll", SpellType.Fire, 100, NPCIcons.ICE_TROLL_ICON), // Ordinary, Male, Female, and Grunt all have the same %
    IceTrollRunt("Ice troll runt", SpellType.Fire, 50, NPCIcons.ICE_TROLL_RUNT_ICON),
    IceWarrior("Ice warrior", SpellType.Fire, 100, NPCIcons.ICE_WARRIOR_ICON),
    Icefiend("Icefiend", SpellType.Fire, 100, NPCIcons.ICEFIEND_ICON),
    IronDragon("Iron dragon", SpellType.Earth, 50, NPCIcons.IRON_DRAGON_ICON),
    Karil("Karil", SpellType.Air, 50, NPCIcons.KARIL_ICON),
    Kephri("Kephri", SpellType.Fire, 35, NPCIcons.KEPHRI_ICON), // 40% with shield, not possible to calculate
    KingBlackDragon("King black dragon", SpellType.Water, 50, NPCIcons.KBD_ICON),
    Kreearra("Kree'arra", SpellType.Air, 30, NPCIcons.KREE_ICON),
    KrilTsutsaroth("K'ril Tsutsaroth", SpellType.Water, 30, NPCIcons.KRIL_ICON),
    LavaDragon("Lava dragon", SpellType.Water, 50, NPCIcons.LAVA_DRAGON_ICON),
    LesserDemon("Lava dragon", SpellType.Water, 40, NPCIcons.LESSER_DEMON_ICON),
    MithrilDragon("Mithril dragon", SpellType.Earth, 50, NPCIcons.MITHRIL_DRAGON_ICON),
    MossGiant("Moss gian", SpellType.Fire, 50, NPCIcons.MOSS_GIANT_ICON),
    MountainTroll("Mountain troll", SpellType.Fire, 50, NPCIcons.MOUNTAIN_TROLL_ICON),
    Pyrefiend("Pyrefiend", SpellType.Water, 100, NPCIcons.PYREFIEND_ICON),
    RedDragon("Red dragon", SpellType.Water, 50, NPCIcons.RED_DRAGON_ICON), // Brutal, Baby, and normal black dragons all have the same %
    RuneDragon("Rune dragon", SpellType.Earth, 50, NPCIcons.RUNE_DRAGON_ICON),
    ScarabMage("Scarab mage", SpellType.Fire, 50, NPCIcons.SCARAB_MAGE_ICON),
    ScarabSwarm("Scarab swarm", SpellType.Fire, 50, NPCIcons.SCARAB_SWARM_ICON),
    Skeleton("Skeleton", SpellType.Air, 35, NPCIcons.SKELETON_ICON),
    SoldierScarab("Soldier scarab", SpellType.Fire, 50, NPCIcons.SOLDIER_SCARAB_ICON),
    SpittingScarab("Spitting scarab", SpellType.Fire, 50, NPCIcons.SPITTING_SCARAB_ICON),
    // Spiritual Warrior (Zaros), find how to differentiate between all different spiritual warriors
    SteelDragon("Steel dragon", SpellType.Earth, 50, NPCIcons.STEEL_DRAGON_ICON),
    Torag("Torag", SpellType.Air, 50, NPCIcons.TORAG_ICON),
    Verac("Verac", SpellType.Air, 50, NPCIcons.VERAC_ICON),
    Vespula("Vespula", SpellType.Fire, 50, NPCIcons.VESPULA_ICON),
    Waterfiend("Waterfiend", SpellType.Earth, 50, NPCIcons.WATERFIEND_ICON),
    Wyrm("Wyrm", SpellType.Earth, 50, NPCIcons.WYRM_ICON),
    Wyrmling("Wyrmling", SpellType.Earth, 50, NPCIcons.WYRMLING_ICON),
    Zulrah("Zulrah", SpellType.Fire, 50, NPCIcons.ZULRAH_ICON);

    @Getter
    private final String NPCName;
    @Getter
    private final SpellType elementalWeakness;
    @Getter
    private final int weaknessPercent;
    @Getter
    private final ImageIcon icon;

    /**
     * Gets an NPC's Weakness by searching their name
     * @param name string
     * @return NPCTypeWeakness, or null for failure
     */
    public static NPCTypeWeakness findWeaknessByName(String name)
    {
        if(name == null)
            return null;

        // Search exact name first
        for (NPCTypeWeakness npc : NPCTypeWeakness.values())
        {
            if(npc.NPCName.equalsIgnoreCase(name)){
                return npc;
            }
        }

        // Search names that aren't complete, e.g: baby (black dragon)
        for (NPCTypeWeakness npc : NPCTypeWeakness.values())
        {
            if(name.toLowerCase().contains(npc.NPCName.toLowerCase())){
                return npc;
            }
        }

        // error, failure
        return null;
    }

    NPCTypeWeakness(String NPCName, SpellType elementalWeakness, int weaknessPercent, ImageIcon icon)
    {
        this.NPCName = NPCName;
        this.elementalWeakness = elementalWeakness;
        this.weaknessPercent = weaknessPercent;
        this.icon = icon;
    }
}

package com.maxhitcalc;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MaxHitCalcPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MaxHitCalcPlugin.class);
		RuneLite.main(args);
	}
}
